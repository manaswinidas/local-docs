<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>元编程</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>元编程</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_runtime_metaprogramming">1。运行时元编程</a>
<ul class="sectlevel2">
<li><a href="#_groovyobject_interface">1.1。GroovyObject接口</a>
<ul class="sectlevel3">
<li><a href="#_invokemethod">1.1.1。 invokeMethod</a></li>
<li><a href="#_get_setproperty">1.1.2。 get / setProperty</a></li>
<li><a href="#_get_setmetaclass">1.1.3。 get / setMetaClass</a></li>
</ul>
</li>
<li><a href="#_get_setattribute">1.2。 get / setAttribute</a></li>
<li><a href="#_methodmissing">1.3。方法缺失</a></li>
<li><a href="#_propertymissing">1.4。属性缺失</a></li>
<li><a href="#_static_methodmissing">1.5。静态方法</a></li>
<li><a href="#_static_propertymissing">1.6。静态属性缺失</a></li>
<li><a href="#_groovyinterceptable">1.7。GroovyInterceptable</a></li>
<li><a href="#categories">1.8。分类目录</a></li>
<li><a href="#_metaclasses">1.9。元类</a>
<ul class="sectlevel3">
<li><a href="#_the_default_metaclass_code_metaclassimpl_code">1.9.1。默认元类<code>MetaClassImpl</code></a></li>
<li><a href="#_custom_metaclasses">1.9.2。自定义元类</a>
<ul class="sectlevel4">
<li><a href="#_delegating_metaclass">委托元类</a></li>
<li><a href="#_magic_package">魔术包</a></li>
</ul>
</li>
<li><a href="#_per_instance_metaclass">1.9.3。每个实例元类</a></li>
<li><a href="#metaprogramming_emc">1.9.4。ExpandoMetaClass</a>
<ul class="sectlevel4">
<li><a href="#_methods">方法</a></li>
<li><a href="#_properties">性质</a></li>
<li><a href="#_constructors">建设者</a></li>
<li><a href="#_static_methods">静态方法</a></li>
<li><a href="#_borrowing_methods">借用方法</a></li>
<li><a href="#_dynamic_method_names">动态方法名称</a></li>
<li><a href="#_runtime_discovery">运行时发现</a></li>
<li><a href="#_groovyobject_methods">GroovyObject方法</a></li>
<li><a href="#_overriding_static_invokemethod">重写静态invokeMethod</a></li>
<li><a href="#_extending_interfaces">扩展接口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_extension_modules">1.10。扩展模块</a>
<ul class="sectlevel3">
<li><a href="#_extending_existing_classes">1.10.1。扩展现有课程</a></li>
<li><a href="#_instance_methods">1.10.2。实例方法</a></li>
<li><a href="#_static_methods_2">1.10.3。静态方法</a></li>
<li><a href="#module-descriptor">1.10.4。模块描述符</a></li>
<li><a href="#_extension_modules_and_classpath">1.10.5。扩展模块和类路径</a></li>
<li><a href="#_compatibility_with_type_checking">1.10.6。与类型检查的兼容性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_compile_time_metaprogramming">2。编译时元编程</a>
<ul class="sectlevel2">
<li><a href="#_available_ast_transformations">2.1。可用的AST转换</a>
<ul class="sectlevel3">
<li><a href="#_code_generation_transformations">2.1.1。代码生成转换</a>
<ul class="sectlevel4">
<li><a href="#xform-ToString"><code>@groovy.transform.ToString</code></a></li>
<li><a href="#xform-EqualsAndHashCode"><code>@groovy.transform.EqualsAndHashCode</code></a></li>
<li><a href="#xform-TupleConstructor"><code>@groovy.transform.TupleConstructor</code></a></li>
<li><a href="#_implementation_details">实施细节</a></li>
<li><a href="#_immutability_support">不变性支持</a></li>
<li><a href="#_customization_options">定制选项</a></li>
<li><a href="#xform-MapConstructor"><code>@groovy.transform.MapConstructor</code></a></li>
<li><a href="#xform-Canonical"><code>@groovy.transform.Canonical</code></a></li>
<li><a href="#xform-InheritConstructors"><code>@groovy.transform.InheritConstructors</code></a></li>
<li><a href="#xform-Category"><code>@groovy.lang.Category</code></a></li>
<li><a href="#xform-IndexedProperty"><code>@groovy.transform.IndexedProperty</code></a></li>
<li><a href="#xform-Lazy"><code>@groovy.lang.Lazy</code></a></li>
<li><a href="#xform-Newify"><code>@groovy.lang.Newify</code></a></li>
<li><a href="#xform-Sortable"><code>@groovy.transform.Sortable</code></a></li>
<li><a href="#xform-Builder"><code>@groovy.transform.builder.Builder</code></a></li>
<li><a href="#xform-AutoImplement"><code>@groovy.transform.AutoImplement</code></a></li>
</ul>
</li>
<li><a href="#_class_design_annotations">2.1.2。类设计注释</a>
<ul class="sectlevel4">
<li><a href="#xform-BaseScript"><code>@groovy.transform.BaseScript</code></a></li>
<li><a href="#xform-Delegate"><code>@groovy.lang.Delegate</code></a></li>
<li><a href="#xform-Immutable"><code>@groovy.transform.Immutable</code></a></li>
<li><a href="#xform-ImmutableBase"><code>@groovy.transform.ImmutableBase</code></a></li>
<li><a href="#xform-PropertyOptions"><code>@groovy.transform.PropertyOptions</code></a></li>
<li><a href="#xform-VisibilityOptions"><code>@groovy.transform.VisibilityOptions</code></a></li>
<li><a href="#xform-ImumtableOptions"><code>@groovy.transform.ImmutableOptions</code></a></li>
<li><a href="#xform-KnownImmutable"><code>@groovy.transform.KnownImmutable</code></a></li>
<li><a href="#xform-Memoized"><code>@groovy.transform.Memoized</code></a></li>
<li><a href="#xform-TailRecursive"><code>@groovy.transform.TailRecursive</code></a></li>
<li><a href="#xform-Singleton"><code>@groovy.lang.Singleton</code></a></li>
<li><a href="#xform-Mixin"><code>@groovy.lang.Mixin</code></a></li>
</ul>
</li>
<li><a href="#_logging_improvements">2.1.3。记录改进</a>
<ul class="sectlevel4">
<li><a href="#xform-Log"><code>@groovy.util.logging.Log</code></a></li>
<li><a href="#xform-Commons"><code>@groovy.util.logging.Commons</code></a></li>
<li><a href="#xform-Log4j"><code>@groovy.util.logging.Log4j</code></a></li>
<li><a href="#xform-Log4j2"><code>@groovy.util.logging.Log4j2</code></a></li>
<li><a href="#xform-Slf4j"><code>@groovy.util.logging.Slf4j</code></a></li>
</ul>
</li>
<li><a href="#_declarative_concurrency">2.1.4。声明式并发</a>
<ul class="sectlevel4">
<li><a href="#xform-Synchronized"><code>@groovy.transform.Synchronized</code></a></li>
<li><a href="#xform-WithReadLock"><code>@groovy.transform.WithReadLock</code>和<code>@groovy.transform.WithWriteLock</code></a></li>
</ul>
</li>
<li><a href="#_easier_cloning_and_externalizing">2.1.5。轻松克隆和外化</a>
<ul class="sectlevel4">
<li><a href="#xform-AutoClone"><code>@groovy.transform.AutoClone</code></a></li>
<li><a href="#xform-AutoExternalize"><code>@groovy.transform.AutoExternalize</code></a></li>
</ul>
</li>
<li><a href="#_safer_scripting">2.1.6。更安全的脚本</a>
<ul class="sectlevel4">
<li><a href="#xform-ThreadInterrupt"><code>@groovy.transform.ThreadInterrupt</code></a></li>
<li><a href="#xform-TimedInterrupt"><code>@groovy.transform.TimedInterrupt</code></a></li>
<li><a href="#xform-ConditionalInterrupt"><code>@groovy.transform.ConditionalInterrupt</code></a></li>
</ul>
</li>
<li><a href="#_compiler_directives">2.1.7。编译器指令</a>
<ul class="sectlevel4">
<li><a href="#xform-Field"><code>@groovy.transform.Field</code></a></li>
<li><a href="#xform-PackageScope"><code>@groovy.transform.PackageScope</code></a></li>
<li><a href="#xform-AutoFinal"><code>@groovy.transform.AutoFinal</code></a></li>
<li><a href="#xform-AnnotationCollector"><code>@groovy.transform.AnnotationCollector</code></a></li>
<li><a href="#xform-TypeChecked"><code>@groovy.transform.TypeChecked</code></a></li>
<li><a href="#xform-CompileStatic"><code>@groovy.transform.CompileStatic</code></a></li>
<li><a href="#xform-CompileDynamic"><code>@groovy.transform.CompileDynamic</code></a></li>
<li><a href="#xform-DelegatesTo"><code>@groovy.lang.DelegatesTo</code></a></li>
<li><a href="#xform-SelfType"><code>@groovy.transform.SelfType</code></a></li>
</ul>
</li>
<li><a href="#_swing_patterns">2.1.8。摇摆模式</a>
<ul class="sectlevel4">
<li><a href="#xform-Bindable"><code>@groovy.beans.Bindable</code></a></li>
<li><a href="#xform-ListenerList"><code>@groovy.beans.ListenerList</code></a></li>
<li><a href="#xform-Vetoable"><code>@groovy.beans.Vetoable</code></a></li>
</ul>
</li>
<li><a href="#_test_assistance">2.1.9。测试协助</a>
<ul class="sectlevel4">
<li><a href="#xform-NotYetImplemented"><code>@groovy.test.NotYetImplemented</code></a></li>
<li><a href="#xform-ASTTest"><code>@groovy.transform.ASTTest</code></a></li>
</ul>
</li>
<li><a href="#_grape_handling">2.1.10。葡萄处理</a>
<ul class="sectlevel4">
<li><a href="#xform-Grab"><code>@groovy.lang.Grab</code></a></li>
<li><a href="#xform-GrabConfig"><code>@groovy.lang.GrabConfig</code></a></li>
<li><a href="#xform-GrabExclude"><code>@groovy.lang.GrabExclude</code></a></li>
<li><a href="#xform-GrabResolver"><code>@groovy.lang.GrabResolver</code></a></li>
<li><a href="#xform-Grapes"><code>@groovy.lang.Grapes</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#developing-ast-xforms">2.2。开发AST转换</a>
<ul class="sectlevel3">
<li><a href="#_compilation_phases_guide">2.2.1。编译阶段指南</a></li>
<li><a href="#transforms-local">2.2.2。本地转型</a></li>
<li><a href="#transforms-global">2.2.3。全球转型</a></li>
<li><a href="#_ast_api_guide">2.2.4。AST API指南</a>
<ul class="sectlevel4">
<li><a href="#_abstractasttransformation">抽象AST转换</a></li>
<li><a href="#_classcodeexpressiontransformer">ClassCodeExpressionTransformer</a></li>
<li><a href="#_ast_nodes">AST节点</a></li>
</ul>
</li>
<li><a href="#_macros">2.2.5。巨集</a>
<ul class="sectlevel4">
<li><a href="#_introduction">介绍</a></li>
<li><a href="#_statements_and_expressions">陈述和表达</a></li>
<li><a href="#_variable_substitution">变量替代</a></li>
<li><a href="#_macroclass">宏类</a></li>
<li><a href="#_macro_methods">@宏方法</a></li>
</ul>
</li>
<li><a href="#_testing_ast_transformations">2.2.6。测试AST转换</a>
<ul class="sectlevel4">
<li><a href="#_separating_source_trees">分离源树</a></li>
<li><a href="#_debugging_ast_transformations">调试AST转换</a></li>
<li><a href="#_astmatcher">ASTMatcher</a></li>
<li><a href="#_asttest">ASTTest</a></li>
</ul>
</li>
<li><a href="#_external_references">2.2.7。外部参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Groovy语言支持两种元编程风格：运行时和编译时。第一个允许在运行时更改类模型和程序的行为，而第二个仅在编译时发生。两者都有优点和缺点，我们将在本节中详细介绍。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_runtime_metaprogramming"><a class="anchor" href="#_runtime_metaprogramming"></a> 1。运行时元编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过运行时元编程，我们可以将拦截，注入甚至综合类和接口方法的决策推迟到运行时。为了深入了解Groovy的元对象协议（MOP），我们需要了解Groovy对象和Groovy的方法处理。在Groovy中，我们处理三种对象：POJO，POGO和Groovy拦截器。Groovy允许以各种方式对所有类型的对象进行元编程。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POJO-常规Java对象，其类可以用Java或JVM的任何其他语言编写。</p>
</li>
<li>
<p>POGO-一个Groovy对象，其类用Groovy编写。它延伸<code>java.lang.Object</code>并实现<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyObject.html">groovy.lang。默认情况下， GroovyObject</a>接口。</p>
</li>
<li>
<p>Groovy拦截器-一个实现<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyInterceptable.html">groovy.lang的 Groovy对象</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyInterceptable.html">。GroovyInterceptable</a>接口，并具有方法拦截功能，这在<a href="#_groovyinterceptable">GroovyInterceptable</a>部分中进行了讨论。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于每个方法调用，Groovy都会检查对象是POJO还是POGO。对于POJO，Groovy获取其<code>MetaClass</code>来自<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/MetaClassRegistry.html">groovy.lang。MetaClassRegistry</a>并对其进行委托方法调用。对于POGO，Groovy采取了更多步骤，如下图所示：</p>
</div>
<div class="imageblock" style="text-align:center">
<div class="content">
<img src="assets/img/GroovyInterceptions.png" alt="Groovy拦截">
</div>
<div class="title">图1。Groovy拦截机制</div>
</div>
<div class="sect2">
<h3 id="_groovyobject_interface"><a class="anchor" href="#_groovyobject_interface"></a> 1.1。GroovyObject接口</h3>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyObject.html">groovy.lang。GroovyObject</a>是Groovy中的主要界面， <code>Object</code>类使用Java。 <code>GroovyObject</code> <a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyObjectSupport.html">groovy.lang中有一个默认实现</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyObjectSupport.html">。GroovyObjectSupport</a>类，它负责将调用转移到<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/MetaClass.html">groovy.lang。MetaClass</a>对象。的<code>GroovyObject</code>源看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package groovy.lang;

public interface GroovyObject {

    Object invokeMethod(String name, Object args);

    Object getProperty(String propertyName);

    void setProperty(String propertyName, Object newValue);

    MetaClass getMetaClass();

    void setMetaClass(MetaClass metaClass);
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_invokemethod"><a class="anchor" href="#_invokemethod"></a> 1.1.1。 invokeMethod</h4>
<div class="paragraph">
<p>此方法主要旨在与<a href="#_groovyinterceptable">GroovyInterceptable</a>接口或对象的<code>MetaClass</code>它将拦截所有方法调用。</p>
</div>
<div class="paragraph">
<p>当Groovy对象上不存在所调用的方法时，也会调用它。这是一个使用覆盖的简单示例<code>invokeMethod()</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeGroovyClass {

    def invokeMethod(String name, Object args) {
        return "called invokeMethod $name $args"
    }

    def test() {
        return 'method exists'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.test() == 'method exists'
assert someGroovyClass.someMethod() == 'called invokeMethod someMethod []'</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，使用<code>invokeMethod</code>不鼓励拦截丢失的方法。如果目的是仅在方法分派失败的情况下拦截方法调用，请改用<a href="#_methodmissing">methodMissing</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_get_setproperty"><a class="anchor" href="#_get_setproperty"></a> 1.1.2。 get / setProperty</h4>
<div class="paragraph">
<p>可以通过覆盖属性来拦截对属性的每次读取访问<code>getProperty()</code>当前对象的方法。这是一个简单的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeGroovyClass {

    def property1 = 'ha'
    def field2 = 'ho'
    def field4 = 'hu'

    def getField1() {
        return 'getHa'
    }

    def getProperty(String name) {
        if (name != 'field3')
            return metaClass.getProperty(this, name) <i class="conum" data-value="1"></i><b>(1)</b>
        else
            return 'field3'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.field1 == 'getHa'
assert someGroovyClass.field2 == 'ho'
assert someGroovyClass.field3 == 'field3'
assert someGroovyClass.field4 == 'hu'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将所有属性的请求转发给getter <code>field3</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以通过覆盖属性来拦截对属性的写访问<code>setProperty()</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class POGO {

    String property

    void setProperty(String name, Object value) {
        this.@"$name" = 'overridden'
    }
}

def pogo = new POGO()
pogo.property = 'a'

assert pogo.property == 'overridden'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_get_setmetaclass"><a class="anchor" href="#_get_setmetaclass"></a> 1.1.3。 get / setMetaClass</h4>
<div class="paragraph">
<p>您可以访问对象的<code>metaClass</code>或自行设定<code>MetaClass</code>用于更改默认拦截机制的实现。例如，您可以编写自己的<code>MetaClass</code>接口并将其分配给对象，以更改拦截机制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// getMetaclass
someObject.metaClass

// setMetaClass
someObject.metaClass = new OwnMetaClassImplementation()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以在<a href="#_groovyinterceptable">GroovyInterceptable</a>主题中找到其他示例。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_get_setattribute"><a class="anchor" href="#_get_setattribute"></a> 1.2。 get / setAttribute</h3>
<div class="paragraph">
<p>此功能与<code>MetaClass</code>实施。在默认实现中，您可以访问字段而无需调用其getter和setter。下面的示例演示了这种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeGroovyClass {

    def field1 = 'ha'
    def field2 = 'ho'

    def getField1() {
        return 'getHa'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.metaClass.getAttribute(someGroovyClass, 'field1') == 'ha'
assert someGroovyClass.metaClass.getAttribute(someGroovyClass, 'field2') == 'ho'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class POGO {

    private String field
    String property1

    void setProperty1(String property1) {
        this.property1 = "setProperty1"
    }
}

def pogo = new POGO()
pogo.metaClass.setAttribute(pogo, 'field', 'ha')
pogo.metaClass.setAttribute(pogo, 'property1', 'ho')

assert pogo.field == 'ha'
assert pogo.property1 == 'ho'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_methodmissing"><a class="anchor" href="#_methodmissing"></a> 1.3。方法缺失</h3>
<div class="paragraph">
<p>Groovy支持以下概念<code>methodMissing</code> 。此方法不同于<code>invokeMethod</code>因为仅当找不到给定名称和/或给定参数的方法时，才在方法分派失败的情况下调用该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {

   def methodMissing(String name, def args) {
        return "this is me"
   }
}

assert new Foo().someUnknownMethod(42l) == 'this is me'</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常在使用时<code>methodMissing</code>可以在下次调用相同方法时缓存结果。</p>
</div>
<div class="paragraph">
<p>例如，考虑GORM中的动态查找器。这些是根据<code>methodMissing</code> 。该代码类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GORM {

   def dynamicMethods = [...] // an array of dynamic methods that use regex

   def methodMissing(String name, args) {
       def method = dynamicMethods.find { it.match(name) }
       if(method) {
          GORM.metaClass."$name" = { Object[] varArgs -&gt;
             method.invoke(delegate, name, varArgs)
          }
          return method.invoke(delegate,name, args)
       }
       else throw new MissingMethodException(name, delegate, args)
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果找到要调用的方法，那么我们如何使用<a href="#metaprogramming_emc">ExpandoMetaClass</a>动态注册新方法。这样一来，下次调用相同的方法时，效率更高。这种使用方式<code>methodMissing</code>没有...的开销<code>invokeMethod</code> <em>而且</em>从第二次通话开始并不昂贵。</p>
</div>
</div>
<div class="sect2">
<h3 id="_propertymissing"><a class="anchor" href="#_propertymissing"></a> 1.4。属性缺失</h3>
<div class="paragraph">
<p>Groovy支持以下概念<code>propertyMissing</code>用于拦截否则失败的属性解析尝试。如果是吸气方法， <code>propertyMissing</code>需要一个<code>String</code>包含属性名称的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
   def propertyMissing(String name) { name }
}

assert new Foo().boo == 'boo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>propertyMissing(String)</code>仅当Groovy运行时找不到给定属性的getter方法时，才调用method。</p>
</div>
<div class="paragraph">
<p>对于二传手方法<code>propertyMissing</code>可以添加带有附加值参数的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
   def storage = [:]
   def propertyMissing(String name, value) { storage[name] = value }
   def propertyMissing(String name) { storage[name] }
}

def f = new Foo()
f.foo = "bar"

assert f.foo == "bar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>与<code>methodMissing</code>最佳实践是在运行时动态注册新属性，以提高整体查找性能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_methodmissing"><a class="anchor" href="#_static_methodmissing"></a> 1.5。静态方法</h3>
<div class="paragraph">
<p>的静态变体<code>methodMissing</code>方法可以通过<a href="#metaprogramming_emc">ExpandoMetaClass</a>添加，也可以在类级别使用<code>$static_methodMissing</code>方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
    static def $static_methodMissing(String name, Object args) {
        return "Missing static method name is $name"
    }
}

assert Foo.bar() == 'Missing static method name is bar'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_static_propertymissing"><a class="anchor" href="#_static_propertymissing"></a> 1.6。静态属性缺失</h3>
<div class="paragraph">
<p>的静态变体<code>propertyMissing</code>方法可以通过<a href="#metaprogramming_emc">ExpandoMetaClass</a>添加，也可以在类级别使用<code>$static_propertyMissing</code>方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
    static def $static_propertyMissing(String name) {
        return "Missing static property name is $name"
    }
}

assert Foo.foobar == 'Missing static property name is foobar'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_groovyinterceptable"><a class="anchor" href="#_groovyinterceptable"></a> 1.7。GroovyInterceptable</h3>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyInterceptable.html">groovy.lang。GroovyInterceptable</a>接口是扩展的标记接口<code>GroovyObject</code>并用于通知Groovy运行时所有方法应通过Groovy运行时的方法分派器机制进行拦截。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package groovy.lang;

public interface GroovyInterceptable extends GroovyObject {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当Groovy对象实现<code>GroovyInterceptable</code>接口，其<code>invokeMethod()</code>任何方法调用都会被调用。在下面，您可以看到此对象的简单示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Interception implements GroovyInterceptable {

    def definedMethod() { }

    def invokeMethod(String name, Object args) {
        'invokedMethod'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一段代码是一个测试，该测试表明对现有方法和不存在方法的调用都将返回相同的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class InterceptableTest extends GroovyTestCase {

    void testCheckInterception() {
        def interception = new Interception()

        assert interception.definedMethod() == 'invokedMethod'
        assert interception.someMethod() == 'invokedMethod'
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们不能使用默认的常规方法<code>println</code>因为这些方法被注入到所有Groovy对象中，所以它们也将被拦截。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们要拦截所有方法调用，但又不想实现<code>GroovyInterceptable</code>我们可以实现的接口<code>invokeMethod()</code>在物体的<code>MetaClass</code> 。此方法适用于POGO和POJO，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class InterceptionThroughMetaClassTest extends GroovyTestCase {

    void testPOJOMetaClassInterception() {
        String invoking = 'ha'
        invoking.metaClass.invokeMethod = { String name, Object args -&gt;
            'invoked'
        }

        assert invoking.length() == 'invoked'
        assert invoking.someMethod() == 'invoked'
    }

    void testPOGOMetaClassInterception() {
        Entity entity = new Entity('Hello')
        entity.metaClass.invokeMethod = { String name, Object args -&gt;
            'invoked'
        }

        assert entity.build(new Object()) == 'invoked'
        assert entity.someMethod() == 'invoked'
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关的其他信息<code>MetaClass</code>可以在<a href="#_metaclasses">MetaClasses</a>部分中找到。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="categories"><a class="anchor" href="#categories"></a> 1.8。分类目录</h3>
<div class="paragraph">
<p>在有些情况下，如果<em>没有</em>得到控制的一类具有额外的方法是有用的情况。为了启用此功能，Groovy实现了从Objective-C借来的一项功能，即<em>Categories</em> 。</p>
</div>
<div class="paragraph">
<p>类别通过所谓的<em>类别类实现</em> 。类别类的特殊之处在于它需要满足某些用于定义扩展方法的预定义规则。</p>
</div>
<div class="paragraph">
<p>系统中包含一些类别，用于为类添加功能，以使它们在Groovy环境中更加可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/time/TimeCategory.html">groovy.time。时间类别</a></p>
</li>
<li>
<p><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/servlet/ServletCategory.html">groovy.servlet。Servlet类别</a></p>
</li>
<li>
<p><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/xml/dom/DOMCategory.html">groovy.xml.dom。DOMC类别</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，类别类未启用。要使用类别类中定义的方法，必须应用范围<code>use</code> GDK提供的方法，可从每个Groovy对象实例内部使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">use(TimeCategory)  {
    println 1.minute.from.now       <i class="conum" data-value="1"></i><b>(1)</b>
    println 10.hours.ago

    def someDate = new Date()       <i class="conum" data-value="2"></i><b>(2)</b>
    println someDate - 3.months
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>TimeCategory</code>将方法添加到<code>Integer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>TimeCategory</code>将方法添加到<code>Date</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>use</code>方法将类别类作为其第一参数，并将闭合代码块作为第二参数。在 - 的里面<code>Closure</code>可以访问类别方法。如上例所示，甚至JDK类<code>java.lang.Integer</code>要么<code>java.util.Date</code>可以使用用户定义的方法来丰富。</p>
</div>
<div class="paragraph">
<p>类别不必直接暴露给用户代码，以下操作也可以做到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class JPACategory{
  // Let's enhance JPA EntityManager without getting into the JSR committee
  static void persistAll(EntityManager em , Object[] entities) { //add an interface to save all
    entities?.each { em.persist(it) }
  }
}

def transactionContext = {
  EntityManager em, Closure c -&gt;
  def tx = em.transaction
  try {
    tx.begin()
    use(JPACategory) {
      c()
    }
    tx.commit()
  } catch (e) {
    tx.rollback()
  } finally {
    //cleanup your resource here
  }
}

// user code, they always forget to close resource in exception, some even forget to commit, let's not rely on them.
EntityManager em; //probably injected
transactionContext (em) {
 em.persistAll(obj1, obj2, obj3)
 // let's do some logics here to make the example sensible
 em.persistAll(obj2, obj4, obj6)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们看一下<code>groovy.time.TimeCategory</code>类，我们看到扩展方法都声明为<code>static</code>方法。实际上，这是类别类必须满足的要求之一，才能将其方法成功添加到内部的类中。 <code>use</code>代码块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class TimeCategory {

    public static Date plus(final Date date, final BaseDuration duration) {
        return duration.plus(date);
    }

    public static Date minus(final Date date, final BaseDuration duration) {
        final Calendar cal = Calendar.getInstance();

        cal.setTime(date);
        cal.add(Calendar.YEAR, -duration.getYears());
        cal.add(Calendar.MONTH, -duration.getMonths());
        cal.add(Calendar.DAY_OF_YEAR, -duration.getDays());
        cal.add(Calendar.HOUR_OF_DAY, -duration.getHours());
        cal.add(Calendar.MINUTE, -duration.getMinutes());
        cal.add(Calendar.SECOND, -duration.getSeconds());
        cal.add(Calendar.MILLISECOND, -duration.getMillis());

        return cal.getTime();
    }

    // ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个要求是，静态方法的第一个参数必须定义该方法在被激活后所附加的类型。其他参数是该方法将作为参数的普通参数。</p>
</div>
<div class="paragraph">
<p>由于参数和静态方法的约定，类别方法的定义可能不如普通方法的定义直观。作为替代，Groovy附带了<code>@Category</code>在编译时将带注释的类转换为类别类的注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Distance {
    def number
    String toString() { "${number}m" }
}

@Category(Number)
class NumberCategory {
    Distance getMeters() {
        new Distance(number: this)
    }
}

use (NumberCategory)  {
    assert 42.meters.toString() == '42m'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>应用<code>@Category</code>注释的优点是能够在不将目标类型作为第一个参数的情况下使用实例方法。目标类型类将作为注释的参数提供。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有一个不同的部分<code>@Category</code>在<a href="#xform-Category">编译时元编程部分</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_metaclasses"><a class="anchor" href="#_metaclasses"></a> 1.9。元类</h3>
<div class="paragraph">
<p>如前所述，元类在方法解析中起着核心作用。对于从groovy代码进行的每个方法调用，Groovy都会找到<code>MetaClass</code>对于给定的对象，并通过<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/groovy/lang/MetaClass.html#invokeMethod(java.lang.Class, java.lang.Object, java.lang.String, java.lang.Object, boolean, boolean)">MetaClass＃invokeMethod</a>将方法解析委托给元类，不应将其与<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/groovy/lang/GroovyObject.html#invokeMethod(java.lang.String, java.lang.Object)">GroovyObject＃invokeMethod</a>混淆，后者恰好是元类最终可以调用的方法。</p>
</div>
<div class="sect3">
<h4 id="_the_default_metaclass_code_metaclassimpl_code"><a class="anchor" href="#_the_default_metaclass_code_metaclassimpl_code"></a> 1.9.1。默认元类<code>MetaClassImpl</code></h4>
<div class="paragraph">
<p>默认情况下，对象获取的实例<code>MetaClassImpl</code>实现默认的方法查找。此方法查找包括在对象类中查找该方法（“常规”方法），但是如果未找到这种方法，则将诉诸于调用<code>methodMissing</code>最终是<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/groovy/lang/GroovyObject.html#invokeMethod(java.lang.String, java.lang.Object)">GroovyObject＃invokeMethod</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {}

def f = new Foo()

assert f.metaClass =~ /MetaClassImpl/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_metaclasses"><a class="anchor" href="#_custom_metaclasses"></a> 1.9.2。自定义元类</h4>
<div class="paragraph">
<p>您可以更改任何对象或类的元类，并替换为<code>MetaClass</code> <a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/MetaClass.html">接口</a> 。通常，您将希望对现有元类之一进行子类化<code>MetaClassImpl</code> ， <code>DelegatingMetaClass</code> ， <code>ExpandoMetaClass</code> ， <code>ProxyMetaClass</code>等等，否则您将需要实现完整的方法查找逻辑。在使用新的元类实例之前，应调用<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/groovy/lang/MetaClass.html#initialize()">groovy.lang。MetaClass＃initialize（）</a>否则，元类可能会或可能不会按预期运行。</p>
</div>
<div class="sect4">
<h5 id="_delegating_metaclass"><a class="anchor" href="#_delegating_metaclass"></a>委托元类</h5>
<div class="paragraph">
<p>如果只需要装饰现有的元类，则<code>DelegatingMetaClass</code>简化了用例。仍然可以通过以下方式访问旧的元类实现<code>super</code>易于将预转换应用于输入，路由至其他方法并对输出进行后处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo { def bar() { "bar" } }

class MyFooMetaClass extends DelegatingMetaClass {
  MyFooMetaClass(MetaClass metaClass) { super(metaClass) }
  MyFooMetaClass(Class theClass) { super(theClass) }

  Object invokeMethod(Object object, String methodName, Object[] args) {
     def result = super.invokeMethod(object,methodName.toLowerCase(), args)
     result.toUpperCase();
  }
}


def mc =  new MyFooMetaClass(Foo.metaClass)
mc.initialize()

Foo.metaClass = mc
def f = new Foo()

assert f.BAR() == "BAR" // the new metaclass routes .BAR() to .bar() and uppercases the result</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_magic_package"><a class="anchor" href="#_magic_package"></a>魔术包</h5>
<div class="paragraph">
<p>通过为元类赋予特制的（魔术）类名和包名，可以在启动时更改元类。为了更改元类<code>java.lang.Integer</code>上一堂课就足够了<code>groovy.runtime.metaclass.java.lang.IntegerMetaClass</code>在类路径中。例如，这在使用框架时非常有用，如果您想在框架执行代码之前对更改进行元类化。魔术包的一般形式是<code>groovy.runtime.metaclass.[package].[class]MetaClass</code> 。在下面的示例中<code>[package]</code>是<code>java.lang</code>和<code>[class]</code>是<code>Integer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// file: IntegerMetaClass.groovy
package groovy.runtime.metaclass.java.lang;

class IntegerMetaClass extends DelegatingMetaClass {
  IntegerMetaClass(MetaClass metaClass) { super(metaClass) }
  IntegerMetaClass(Class theClass) { super(theClass) }
  Object invokeMethod(Object object, String name, Object[] args) {
    if (name =~ /isBiggerThan/) {
      def other = name.split(/isBiggerThan/)[1].toInteger()
      object &gt; other
    } else {
      return super.invokeMethod(object,name, args);
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过编译上面的文件<code>groovyc IntegerMetaClass.groovy</code>一种<code>./groovy/runtime/metaclass/java/lang/IntegerMetaClass.class</code>将生成。下面的示例将使用此新的元类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// File testInteger.groovy
def i = 10

assert i.isBiggerThan5()
assert !i.isBiggerThan15()

println i.isBiggerThan5()</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过运行该文件<code>groovy -cp . testInteger.groovy</code>的<code>IntegerMetaClass</code>将在类路径中，因此它将成为<code>java.lang.Integer</code>拦截对<code>isBiggerThan*()</code>方法。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_per_instance_metaclass"><a class="anchor" href="#_per_instance_metaclass"></a> 1.9.3。每个实例元类</h4>
<div class="paragraph">
<p>您可以分别更改单个对象的元类，因此可以使具有相同元类的多个对象具有不同的元类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo { def bar() { "bar" }}

class FooMetaClass extends DelegatingMetaClass {
  FooMetaClass(MetaClass metaClass) { super(metaClass) }
  Object invokeMethod(Object object, String name, Object[] args) {
      super.invokeMethod(object,name,args).toUpperCase()
  }
}

def f1 = new Foo()
def f2 = new Foo()
f2.metaClass = new FooMetaClass(f2.metaClass)

assert f1.bar() == "bar"
assert f2.bar() == "BAR"
assert f1.metaClass =~ /MetaClassImpl/
assert f2.metaClass =~ /FooMetaClass/
assert f1.class.toString() == "class Foo"
assert f2.class.toString() == "class Foo"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="metaprogramming_emc"><a class="anchor" href="#metaprogramming_emc"></a> 1.9.4。ExpandoMetaClass</h4>
<div class="paragraph">
<p>Groovy带有特殊功能<code>MetaClass</code>所谓的<code>ExpandoMetaClass</code> 。它的特殊之处在于，它允许使用简洁的闭包语法动态添加或更改方法，构造函数，属性，甚至静态方法。</p>
</div>
<div class="paragraph">
<p>如《 <a href="core-testing-guide.html#testing_guide_emc">测试指南》</a>所示，在模拟或存根方案中应用这些修改可能特别有用。</p>
</div>
<div class="paragraph">
<p>每一个<code>java.lang.Class</code>由Groovy提供，带有特殊的<code>metaClass</code>属性，可为您提供参考<code>ExpandoMetaClass</code>实例。然后，可以使用该实例添加方法或更改现有方法的行为。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认<code>ExpandoMetaClass</code>不做继承。要启用此功能，您必须致电<code>ExpandoMetaClass#enableGlobally()</code>在您的应用启动之前（例如在main方法或servlet引导中）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下各节详细介绍了如何<code>ExpandoMetaClass</code>可以在各种情况下使用。</p>
</div>
<div class="sect4">
<h5 id="_methods"><a class="anchor" href="#_methods"></a>方法</h5>
<div class="paragraph">
<p>一旦<code>ExpandoMetaClass</code>通过调用<code>metaClass</code>属性，可以使用左移添加方法<code><<</code>或者<code>=</code>操作员。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，左移运算符用于<em>附加</em>新方法。如果类或接口声明了具有相同名称和参数类型的公共方法，包括从超类和超接口继承的方法，但不包括添加到<code>metaClass</code>在运行时，将引发异常。如果要<em>替换</em>由类或接口声明的方法，则可以使用<code>=</code>操作员。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>运算符应用于不存在的属性<code>metaClass</code>传递一个实例<code>Closure</code>代码块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
   String title
}

Book.metaClass.titleInUpperCase &lt;&lt; {-&gt; title.toUpperCase() }

def b = new Book(title:"The Stand")

assert "THE STAND" == b.titleInUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例展示了如何通过访问<code>metaClass</code>属性并使用<code><<</code>要么<code>=</code>操作员分配一个<code>Closure</code>代码块。的<code>Closure</code>参数被解释为方法参数。可以使用以下方法添加无参数方法<code>{→ …​}</code>句法。</p>
</div>
</div>
<div class="sect4">
<h5 id="_properties"><a class="anchor" href="#_properties"></a>性质</h5>
<div class="paragraph">
<p><code>ExpandoMetaClass</code>支持两种用于添加或覆盖属性的机制。</p>
</div>
<div class="paragraph">
<p>首先，它支持通过简单地将值<em>赋给以下属性</em>来声明<em>可变</em>属性： <code>metaClass</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
   String title
}

Book.metaClass.author = "Stephen King"
def b = new Book()

assert "Stephen King" == b.author</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是通过使用用于添加实例方法的标准机制来添加getter和/或setter方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
  String title
}
Book.metaClass.getAuthor &lt;&lt; {-&gt; "Stephen King" }

def b = new Book()

assert "Stephen King" == b.author</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的源代码示例中，该属性由闭包指示，并且是只读属性。添加等效的setter方法是可行的，但随后需要存储属性值以备后用。如以下示例所示，可以完成此操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
  String title
}

def properties = Collections.synchronizedMap([:])

Book.metaClass.setAuthor = { String value -&gt;
   properties[System.identityHashCode(delegate) + "author"] = value
}
Book.metaClass.getAuthor = {-&gt;
   properties[System.identityHashCode(delegate) + "author"]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这不是唯一的技术。例如，在Servlet容器中，一种方法可能是将当前正在执行的请求中的值存储为请求属性（在某些情况下，在Grails中是这样做的）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_constructors"><a class="anchor" href="#_constructors"></a>建设者</h5>
<div class="paragraph">
<p>可以通过使用特殊的构造函数来添加构造函数<code>constructor</code>属性。要么<code><<</code>要么<code>=</code>运算符可用于分配<code>Closure</code>代码块。的<code>Closure</code>在运行时执行代码时，自变量将成为构造函数自变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
    String title
}
Book.metaClass.constructor &lt;&lt; { String title -&gt; new Book(title:title) }

def book = new Book('Groovy in Action - 2nd Edition')
assert book.title == 'Groovy in Action - 2nd Edition'</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">但是，在添加构造函数时要小心，因为很容易陷入堆栈溢出的麻烦。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_static_methods"><a class="anchor" href="#_static_methods"></a>静态方法</h5>
<div class="paragraph">
<p>可以使用与实例方法相同的技术来添加静态方法，并添加<code>static</code>方法名称前的限定符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
   String title
}

Book.metaClass.static.create &lt;&lt; { String title -&gt; new Book(title:title) }

def b = Book.create("The Stand")</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_borrowing_methods"><a class="anchor" href="#_borrowing_methods"></a>借用方法</h5>
<div class="paragraph">
<p>用<code>ExpandoMetaClass</code>可以使用Groovy的方法指针语法从其他类中借用方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}
class MortgageLender {
   def borrowMoney() {
      "buy house"
   }
}

def lender = new MortgageLender()

Person.metaClass.buyHouse = lender.&amp;borrowMoney

def p = new Person()

assert "buy house" == p.buyHouse()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_method_names"><a class="anchor" href="#_dynamic_method_names"></a>动态方法名称</h5>
<div class="paragraph">
<p>由于Groovy允许您将字符串用作属性名称，因此这又使您可以在运行时动态创建方法和属性名称。要使用动态名称创建方法，只需使用引用属性名称的语言功能作为字符串即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
   String name = "Fred"
}

def methodName = "Bob"

Person.metaClass."changeNameTo${methodName}" = {-&gt; delegate.name = "Bob" }

def p = new Person()

assert "Fred" == p.name

p.changeNameToBob()

assert "Bob" == p.name</code></pre>
</div>
</div>
<div class="paragraph">
<p>相同的概念可以应用于静态方法和属性。</p>
</div>
<div class="paragraph">
<p>动态方法名称的一种应用程序可以在Grails Web应用程序框架中找到。通过使用动态方法名称来实现“动态编解码器”的概念。</p>
</div>
<div class="listingblock">
<div class="title"><code>HTMLCodec</code>类</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class HTMLCodec {
    static encode = { theTarget -&gt;
        HtmlUtils.htmlEscape(theTarget.toString())
    }

    static decode = { theTarget -&gt;
    	HtmlUtils.htmlUnescape(theTarget.toString())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例显示了编解码器实现。Grails带有各种编解码器实现，每个实现都在单个类中定义。在运行时，应用程序类路径中将有多个编解码器类。在应用程序启动时，框架会添加一个<code>encodeXXX</code>和一个<code>decodeXXX</code>某些元类的方法<code>XXX</code>是编解码器类名称的第一部分（例如<code>encodeHTML</code> ）。下面以一些Groovy伪代码显示此机制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def codecs = classes.findAll { it.name.endsWith('Codec') }

codecs.each { codec -&gt;
    Object.metaClass."encodeAs${codec.name-'Codec'}" = { codec.newInstance().encode(delegate) }
    Object.metaClass."decodeFrom${codec.name-'Codec'}" = { codec.newInstance().decode(delegate) }
}


def html = '&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;'

assert '&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;' == html.encodeAsHTML()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_discovery"><a class="anchor" href="#_runtime_discovery"></a>运行时发现</h5>
<div class="paragraph">
<p>在运行时，了解执行该方法时还存在哪些其他方法或属性通常很有用。<code>ExpandoMetaClass</code>在撰写本文时，提供了以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getMetaMethod</code></p>
</li>
<li>
<p><code>hasMetaMethod</code></p>
</li>
<li>
<p><code>getMetaProperty</code></p>
</li>
<li>
<p><code>hasMetaProperty</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为什么不能只使用反射？好吧，因为Groovy有所不同，它具有的方法是“真实的”方法，而这些方法仅在运行时可用。这些有时（但不总是）表示为MetaMethods。MetaMethods告诉您在运行时可以使用哪些方法，因此您的代码可以适应。</p>
</div>
<div class="paragraph">
<p>覆盖时特别有用<code>invokeMethod</code> ， <code>getProperty</code>和/或<code>setProperty</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_groovyobject_methods"><a class="anchor" href="#_groovyobject_methods"></a> GroovyObject方法</h5>
<div class="paragraph">
<p>的另一个特点<code>ExpandoMetaClass</code>是它允许覆盖方法<code>invokeMethod</code> ， <code>getProperty</code>和<code>setProperty</code> ，所有这些都可以在<code>groovy.lang.GroovyObject</code>类。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何覆盖<code>invokeMethod</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Stuff {
   def invokeMe() { "foo" }
}

Stuff.metaClass.invokeMethod = { String name, args -&gt;
   def metaMethod = Stuff.metaClass.getMetaMethod(name, args)
   def result
   if(metaMethod) result = metaMethod.invoke(delegate,args)
   else {
      result = "bar"
   }
   result
}

def stf = new Stuff()

assert "foo" == stf.invokeMe()
assert "bar" == stf.doStuff()</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一步<code>Closure</code>代码是查找<code>MetaMethod</code>给定的名称和参数。如果可以找到该方法，则一切都很好，并将其委派给该方法。如果不是，则返回一个伪值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">一种<code>MetaMethod</code>是一种已知存在于<code>MetaClass</code>无论是在运行时还是在编译时添加。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用相同的逻辑覆盖<code>setProperty</code>要么<code>getProperty</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
   String name = "Fred"
}

Person.metaClass.getProperty = { String name -&gt;
   def metaProperty = Person.metaClass.getMetaProperty(name)
   def result
   if(metaProperty) result = metaProperty.getProperty(delegate)
   else {
      result = "Flintstone"
   }
   result
}

def p = new Person()

assert "Fred" == p.name
assert "Flintstone" == p.other</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里要注意的重要一点是， <code>MetaMethod</code>一种<code>MetaProperty</code>实例被查找。如果存在<code>getProperty</code>的方法<code>MetaProperty</code>被调用，传递了委托。</p>
</div>
</div>
<div class="sect4">
<h5 id="_overriding_static_invokemethod"><a class="anchor" href="#_overriding_static_invokemethod"></a>重写静态invokeMethod</h5>
<div class="paragraph">
<p><code>ExpandoMetaClass</code>甚至允许使用特殊的方法覆盖静态方法<code>invokeMethod</code>句法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Stuff {
   static invokeMe() { "foo" }
}

Stuff.metaClass.'static'.invokeMethod = { String name, args -&gt;
   def metaMethod = Stuff.metaClass.getStaticMetaMethod(name, args)
   def result
   if(metaMethod) result = metaMethod.invoke(delegate,args)
   else {
      result = "bar"
   }
   result
}

assert "foo" == Stuff.invokeMe()
assert "bar" == Stuff.doStuff()</code></pre>
</div>
</div>
<div class="paragraph">
<p>用于覆盖静态方法的逻辑与我们之前用于覆盖实例方法的逻辑相同。唯一的区别是访问<code>metaClass.static</code>财产和对<code>getStaticMethodName</code>用于检索静态<code>MetaMethod</code>实例。</p>
</div>
</div>
<div class="sect4">
<h5 id="_extending_interfaces"><a class="anchor" href="#_extending_interfaces"></a>扩展接口</h5>
<div class="paragraph">
<p>可以使用以下方法将方法添加到接口上<code>ExpandoMetaClass</code> 。为此， <strong>必须</strong>使用<code>ExpandoMetaClass.enableGlobally()</code>应用程序启动之前的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">List.metaClass.sizeDoubled = {-&gt; delegate.size() * 2 }

def list = []

list &lt;&lt; 1
list &lt;&lt; 2

assert 4 == list.sizeDoubled()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_extension_modules"><a class="anchor" href="#_extension_modules"></a> 1.10。扩展模块</h3>
<div class="sect3">
<h4 id="_extending_existing_classes"><a class="anchor" href="#_extending_existing_classes"></a> 1.10.1。扩展现有课程</h4>
<div class="paragraph">
<p>扩展模块允许您将新方法添加到现有类中，包括预编译的类，例如JDK中的类。与通过元类或使用类别定义的那些新方法不同，这些新方法在全球范围内可用。例如，当您编写时：</p>
</div>
<div class="listingblock">
<div class="title">标准扩展方法</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def file = new File(...)
def contents = file.getText('utf-8')</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>getText</code>方法不存在<code>File</code>类。但是，Groovy知道它是因为它是在特殊类中定义的， <code>ResourceGroovyMethods</code> ：</p>
</div>
<div class="listingblock">
<div class="title">ResourceGroovyMethods.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public static String getText(File file, String charset) throws IOException {
 return IOGroovyMethods.getText(newReader(file, charset));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会注意到，扩展方法是在帮助程序类（其中定义了各种扩展方法）中使用静态方法定义的。第一个论点<code>getText</code>该方法对应于接收方，而其他参数则对应于扩展方法的参数。所以在这里，我们定义了一个名为<em>getText</em>的方法<code>File</code>类（因为第一个参数是类型<code>File</code> ），它以单个参数作为参数（编码<code>String</code> ）。</p>
</div>
<div class="paragraph">
<p>创建扩展模块的过程很简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>像上面写一个扩展类</p>
</li>
<li>
<p>编写模块描述符文件</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，您必须使扩展模块对Groovy可见，就像在classpath上具有扩展模块的类和描述符一样简单。这意味着您可以选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要么直接在类路径上提供类和模块描述符</p>
</li>
<li>
<p>或将扩展模块捆绑到jar中以实现可重用性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>扩展模块可以向类添加两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实例方法（在类的实例上调用）</p>
</li>
<li>
<p>静态方法（在类本身上调用）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_instance_methods"><a class="anchor" href="#_instance_methods"></a> 1.10.2。实例方法</h4>
<div class="paragraph">
<p>要将实例方法添加到现有类，您需要创建一个扩展类。例如，假设您要添加一个<code>maxRetries</code>方法开启<code>Integer</code>它接受一个关闭并最多执行<em>n</em>次，直到没有引发异常为止。为此，您只需要编写以下内容：</p>
</div>
<div class="listingblock">
<div class="title">MaxRetriesExtension.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MaxRetriesExtension {                                     <i class="conum" data-value="1"></i><b>(1)</b>
    static void maxRetries(Integer self, Closure code) {        <i class="conum" data-value="2"></i><b>(2)</b>
        assert self &gt;= 0
        int retries = self
        Throwable e = null
        while (retries &gt; 0) {
            try {
                code.call()
                break
            } catch (Throwable err) {
                e = err
                retries--
            }
        }
        if (retries == 0 &amp;&amp; e) {
            throw e
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扩展类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>静态方法的第一个参数对应于消息的接收者，即扩展实例</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，在<a href="#module-descriptor">声明了扩展类之后</a> ，您可以通过以下方式调用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int i=0
5.maxRetries {
    i++
}
assert i == 1
i=0
try {
    5.maxRetries {
        i++
        throw new RuntimeException("oops")
    }
} catch (RuntimeException e) {
    assert i == 5
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_static_methods_2"><a class="anchor" href="#_static_methods_2"></a> 1.10.3。静态方法</h4>
<div class="paragraph">
<p>也可以将静态方法添加到类中。在这种情况下，静态方法需要在其<strong>自己的</strong>文件中定义。静态和实例扩展方法<strong>不能</strong>存在于同一类中。</p>
</div>
<div class="listingblock">
<div class="title">StaticStringExtension.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class StaticStringExtension {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    static String greeting(String self) {                           <i class="conum" data-value="2"></i><b>(2)</b>
        'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>静态扩展类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>静态方法的第一个参数对应于正在扩展的类，并且<strong>未使用</strong></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下，您可以直接在<code>String</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert String.greeting() == 'Hello, world!'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="module-descriptor"><a class="anchor" href="#module-descriptor"></a> 1.10.4。模块描述符</h4>
<div class="paragraph">
<p>为了使Groovy能够加载扩展方法，必须声明扩展帮助程序类。您必须创建一个名为<code>org.codehaus.groovy.runtime.ExtensionModule</code>进入<code>META-INF/groovy</code>目录：</p>
</div>
<div class="listingblock">
<div class="title">org.codehaus.groovy.runtime。扩展模块</div>
<div class="content">
<pre>moduleName=Test module for specifications
moduleVersion=1.0-test
extensionClasses=support.MaxRetriesExtension
staticExtensionClasses=support.StaticStringExtension</pre>
</div>
</div>
<div class="paragraph">
<p>模块描述符需要4个键：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>moduleName</em> ：模块的名称</p>
</li>
<li>
<p><em>moduleVersion</em> ：模块的版本。请注意，版本号仅用于检查您是否在两个不同版本中未加载同一模块。</p>
</li>
<li>
<p><em>extensionClasses</em> ：实例方法的扩展帮助程序类的列表。您可以提供几个类，因为它们是逗号分隔的。</p>
</li>
<li>
<p><em>staticExtensionClasses</em> ：静态方法的扩展帮助程序类的列表。您可以提供几个类，因为它们是逗号分隔的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，模块不需要同时定义静态助手和实例助手，并且可以将多个类添加到单个模块中。您还可以毫无问题地在单个模块中扩展不同的类。甚至可以在单个扩展类中使用不同的类，但是建议按功能集将扩展方法分组为类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_extension_modules_and_classpath"><a class="anchor" href="#_extension_modules_and_classpath"></a> 1.10.5。扩展模块和类路径</h4>
<div class="paragraph">
<p>值得注意的是，您不能使用与使用它的代码同时编译的扩展。这意味着要使用扩展名， <strong>必须</strong>先在类路径中将其作为已编译的类使用，然后才能编译使用它的代码。通常，这意味着您不能将<em>测试</em>类与扩展类本身放在同一源单元中。由于通常将测试源与正常源分开，并在构建的另一步骤中执行，所以这不是问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_compatibility_with_type_checking"><a class="anchor" href="#_compatibility_with_type_checking"></a> 1.10.6。与类型检查的兼容性</h4>
<div class="paragraph">
<p>与类别不同，扩展模块与类型检查兼容：如果在类路径中找到扩展模块，则类型检查器会知道扩展方法，并且在调用它们时不会抱怨。它也与静态编译兼容。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compile_time_metaprogramming"><a class="anchor" href="#_compile_time_metaprogramming"></a> 2。编译时元编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy中的编译时元编程允许在编译时生成代码。这些转换正在改变程序的抽象语法树（AST），这就是为什么在Groovy中我们将其称为AST转换。AST转换使您可以进入编译过程，修改AST并继续编译过程以生成常规字节码。与运行时元编程相比，这具有使更改在类文件本身（即在字节码中）可见的优点。例如，如果您希望将转换作为类协定的一部分（实现接口，扩展抽象类等），或者甚至需要从Java（或其他JVM语言）调用该类，则使其在字节码中可见非常重要。 ）。例如，AST转换可以将方法添加到类中。如果使用运行时元编程来执行此操作，则新方法仅在Groovy中可见。如果使用编译时元编程进行相同的操作，则该方法也将在Java中可见。最后但并非最不重要的一点是，编译时元编程的性能可能会更好（因为不需要初始化阶段）。</p>
</div>
<div class="paragraph">
<p>在本节中，我们将从解释与Groovy发行版捆绑在一起的各种编译时转换开始。在接下来的部分中，我们将描述如何<a href="#developing-ast-xforms">实现自己的AST转换</a>以及该技术的缺点。</p>
</div>
<div class="sect2">
<h3 id="_available_ast_transformations"><a class="anchor" href="#_available_ast_transformations"></a> 2.1。可用的AST转换</h3>
<div class="paragraph">
<p>Groovy带有各种AST转换，可满足不同需求：减少样板（代码生成），实现设计模式（委托，...），日志记录，声明性并发，克隆，更安全的脚本，调整编译，实现Swing模式，测试并最终管理依赖项。如果这些AST转换都不能满足您的需求，那么您仍然可以实现<a href="#developing-ast-xforms">自己的AST</a> ，如<a href="#developing-ast-xforms">开发自己的AST转换一节中所示</a> 。</p>
</div>
<div class="paragraph">
<p>AST转换可以分为两类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一旦在编译类路径上找到全局AST转换，便会在全球范围内透明地对其进行应用</p>
</li>
<li>
<p>通过用标记注释源代码来应用本地AST转换。与全局AST转换不同，本地AST转换可以支持参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy没有提供任何全局AST转换，但是您可以在此处找到可在代码中使用的本地AST转换列表：</p>
</div>
<div class="sect3">
<h4 id="_code_generation_transformations"><a class="anchor" href="#_code_generation_transformations"></a> 2.1.1。代码生成转换</h4>
<div class="paragraph">
<p>此类转换包括帮助删除样板代码的AST转换。通常，这是您必须编写的代码，但是没有任何有用的信息。通过自动生成该样板代码，您必须编写的代码将变得简洁明了，并减少了通过使样板代码不正确而引入错误的机会。</p>
</div>
<div class="sect4">
<h5 id="xform-ToString"><a class="anchor" href="#xform-ToString"></a><code>@groovy.transform.ToString</code></h5>
<div class="paragraph">
<p>的<code>@ToString</code> AST转换产生易于阅读的内容<code>toString</code>类的表示形式。例如，注释<code>Person</code>如下所示的类将自动生成<code>toString</code>为您提供的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ToString

@ToString
class Person {
    String firstName
    String lastName
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个定义，下面的断言就会通过，这意味着<code>toString</code>生成了从类中获取字段值并将其打印出来的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Jack, Nicholson)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@ToString</code>批注接受几个参数，下表中总结了这些参数：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">排除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空清单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要从toString中排除的属性列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(excludes=['firstName'])
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包括</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未定义的标记列表（指示所有字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要包含在toString中的字段列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includes=['lastName'])
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">超类是否应包含在toString中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString
class Id { long id }

@ToString(includeSuper=true)
class Person extends Id {
    String firstName
    String lastName
}

def p = new Person(id:1, firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Jack, Nicholson, Id(1))'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在生成的toString中包括属性名称。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeNames=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(firstName:Jack, lastName:Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除属性外，字段还应包含在toString中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeFields=true)
class Person {
    String firstName
    String lastName
    private int age
    void test() {
       age = 42
    }
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
p.test()
assert p.toString() == 'Person(Jack, Nicholson, 42)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">超级属性是否应包含在toString中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}

@ToString(includeSuperProperties = true, includeNames = true)
class BandMember extends Person {
    String bandName
}

def bono = new BandMember(name:'Bono', bandName: 'U2').toString()

assert bono.toString() == 'BandMember(bandName:U2, name:Bono)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应该在toString中包含可见的超级字段</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    protected String name
}

@ToString(includeSuperFields = true, includeNames = true)
@MapConstructor(includeSuperFields = true)
class BandMember extends Person {
    String bandName
}

def bono = new BandMember(name:'Bono', bandName: 'U2').toString()

assert bono.toString() == 'BandMember(bandName:U2, name:Bono)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ignoreNulls</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该显示具有空值的属性/字段</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(ignoreNulls=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack')
assert p.toString() == 'Person(Jack)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includePackage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在toString中使用完全限定的类名称而不是简单名称</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includePackage=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName:'Nicholson')
assert p.toString() == 'acme.Person(Jack, Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在toString中包含所有JavaBean属性</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeNames=true)
class Person {
    String firstName
    String getLastName() { 'Nicholson' }
}

def p = new Person(firstName: 'Jack')
assert p.toString() == 'acme.Person(firstName:Jack, lastName:Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">快取</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缓存toString字符串。如果类是不可变的，则应仅将其设置为true。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(cache=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName:'Nicholson')
def s1 = p.toString()
def s2 = p.toString()
assert s1 == s2
assert s1 == 'Person(Jack, Nicholson)'
assert s1.is(s2) // same instance</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有内部名称的字段和/或属性应包含在生成的toString中吗</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(allNames=true)
class Person {
    String $firstName
}

def p = new Person($firstName: "Jack")
assert p.toString() == 'acme.Person(Jack)'</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-EqualsAndHashCode"><a class="anchor" href="#xform-EqualsAndHashCode"></a><code>@groovy.transform.EqualsAndHashCode</code></h5>
<div class="paragraph">
<p>的<code>@EqualsAndHashCode</code> AST转型旨在产生<code>equals</code>和<code>hashCode</code>给你的方法。生成的哈希码遵循<em>Josh Bloch</em>在<em>Effective Java中</em>描述的最佳实践：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(firstName: 'Jack', lastName: 'Nicholson')

assert p1==p2
assert p1.hashCode() == p2.hashCode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>有几个选项可以调整行为<code>@EqualsAndHashCode</code> ：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">排除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空清单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从equals / hashCode中排除的属性列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(excludes=['firstName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(firstName: 'Bob', lastName: 'Nicholson')

assert p1==p2
assert p1.hashCode() == p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包括</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未定义的标记列表（指示所有字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含在equals / hashCode中的字段列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(includes=['lastName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(firstName: 'Bob', lastName: 'Nicholson')

assert p1==p2
assert p1.hashCode() == p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">快取</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缓存hashCode计算。如果类是不可变的，则应仅将其设置为true。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode
import groovy.transform.Immutable

@Immutable
class SlowHashCode {
    static final SLEEP_PERIOD = 500

    int hashCode() {
        sleep SLEEP_PERIOD
        127
    }
}

@EqualsAndHashCode(cache=true)
@Immutable
class Person {
    SlowHashCode slowHashCode = new SlowHashCode()
}

def p = new Person()
p.hashCode()

def start = System.currentTimeMillis()
p.hashCode()
assert System.currentTimeMillis() - start &lt; SlowHashCode.SLEEP_PERIOD</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">callSuper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在等于和hashCode计算中包括super</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
class Living {
    String race
}

@EqualsAndHashCode(callSuper=true)
class Person extends Living {
    String firstName
    String lastName
}

def p1 = new Person(race:'Human', firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(race: 'Human being', firstName: 'Jack', lastName: 'Nicholson')

assert p1!=p2
assert p1.hashCode() != p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除属性外，字段是否应包含在equals / hashCode中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(includeFields=true)
class Person {
    private String firstName

    Person(String firstName) {
        this.firstName = firstName
    }
}

def p1 = new Person('Jack')
def p2 = new Person('Jack')
def p3 = new Person('Bob')

assert p1 == p2
assert p1 != p3</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useCanEqual</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该等于调用canEqual辅助方法。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>参见<a href="http://www.artima.com/lejava/articles/equality.html" class="bare">http://www.artima.com/lejava/articles/equality.html</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JavaBean属性是否应包含在equals和hashCode计算中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@EqualsAndHashCode(allProperties=true, excludes='first, last')
class Person {
    String first, last
    String getInitials() { first[0] + last[0] }
}

def p1 = new Person(first: 'Jack', last: 'Smith')
def p2 = new Person(first: 'Jack', last: 'Spratt')
def p3 = new Person(first: 'Bob', last: 'Smith')

assert p1 == p2
assert p1.hashCode() == p2.hashCode()
assert p1 != p3
assert p1.hashCode() != p3.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有内部名称的字段和/或属性应包含在equals和hashCode计算中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(allNames=true)
class Person {
    String $firstName
}

def p1 = new Person($firstName: 'Jack')
def p2 = new Person($firstName: 'Bob')

assert p1 != p2
assert p1.hashCode() != p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-TupleConstructor"><a class="anchor" href="#xform-TupleConstructor"></a><code>@groovy.transform.TupleConstructor</code></h5>
<div class="paragraph">
<p>的<code>@TupleConstructor</code>注解旨在通过为您生成构造函数来消除样板代码。创建一个元组构造函数，为每个属性（可能还有每个字段）具有一个参数。每个参数都有一个默认值（使用属性的初始值（如果存在）或Java的默认值（根据属性类型）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_implementation_details"><a class="anchor" href="#_implementation_details"></a>实施细节</h5>
<div class="paragraph">
<p>通常，您不需要了解所生成的构造函数的实现细节；您只是以常规方式使用它们。但是，如果要添加多个构造函数，了解Java集成选项或满足某些依赖项注入框架的要求，则一些详细信息很有用。</p>
</div>
<div class="paragraph">
<p>如前所述，生成的构造函数将应用默认值。在以后的编译阶段，将应用Groovy编译器的标准默认值处理行为。最终结果是在类的字节码内放置了多个构造函数。这提供了很好理解的语义，对于Java集成目的也很有用。例如，以下代码将生成3个构造函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor
class Person {
    String firstName
    String lastName
}

// traditional map-style constructor
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
// generated tuple constructor
def p2 = new Person('Jack', 'Nicholson')
// generated tuple constructor with default value for second property
def p3 = new Person('Jack')</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个构造函数是无参数构造函数，只要您没有最终属性，就可以使用传统的地图样式构造。Groovy先调用no-arg构造函数，然后再调用相关的setter。值得注意的是，如果第一个属性（或字段）的类型为LinkedHashMap，或者只有一个Map，AbstractMap或HashMap属性（或字段），则地图样式的命名参数将不可用。</p>
</div>
<div class="paragraph">
<p>其他构造函数是通过按定义顺序获取属性而生成的。Groovy将生成与属性（或字段，取决于选项）一样多的构造函数。</p>
</div>
<div class="paragraph">
<p>设置<code>defaults</code>属性（请参阅可用的配置选项表） <code>false</code> ，禁用正常的默认值行为，这意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>只会产生一个构造函数</p>
</li>
<li>
<p>尝试使用初始值会产生错误</p>
</li>
<li>
<p>地图样式的命名参数将不可用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常仅在另一个Java框架期望一个构造函数（例如注入框架或JUnit参数化运行器）的情况下使用此属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="_immutability_support"><a class="anchor" href="#_immutability_support"></a>不变性支持</h5>
<div class="paragraph">
<p>如果<code>@PropertyOptions</code>注释也可以在类上找到<code>@TupleConstructor</code>注释，则生成的构造函数可能包含自定义属性处理逻辑。的<code>propertyHandler</code>的属性<code>@PropertyOptions</code>例如，注释可以设置为<code>ImmutablePropertyHandler</code>这将导致为不变的类添加必要的逻辑（防御性复制，克隆等）。通常，当您使用<code>@Immutable</code>元注释。并非所有的属性处理程序都支持某些注释属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="_customization_options"><a class="anchor" href="#_customization_options"></a>定制选项</h5>
<div class="paragraph">
<p>的<code>@TupleConstructor</code> AST转换接受几个注释属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">排除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空清单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从元组构造函数生成中排除的属性列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person('Jack')
try {
    // will fail because the second property is excluded
    def p3 = new Person('Jack', 'Nicholson')
} catch (e) {
    assert e.message.contains ('Could not find matching constructor')
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包括</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未定义列表（指示所有字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元组构造函数生成中包含的字段列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(includes=['firstName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person('Jack')
try {
    // will fail because the second property is not included
    def p3 = new Person('Jack', 'Nicholson')
} catch (e) {
    assert e.message.contains ('Could not find matching constructor')
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性应包含在元组构造函数生成中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(includeProperties=false)
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')

try {
    def p2 = new Person('Jack', 'Nicholson')
} catch(e) {
    // will fail because properties are not included
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除属性外，还应将字段包括在元组构造函数生成中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(includeFields=true)
class Person {
    String firstName
    String lastName
    private String occupation
    public String toString() {
        "$firstName $lastName: $occupation"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson', occupation: 'Actor')
def p2 = new Person('Jack', 'Nicholson', 'Actor')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: Actor'
assert p1.toString() == p2.toString()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元组构造函数生成中是否应包含超类的属性</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

class Base {
    String occupation
}

@TupleConstructor(includeSuperProperties=true)
class Person extends Base {
    String firstName
    String lastName
    public String toString() {
        "$firstName $lastName: $occupation"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')

def p2 = new Person('Actor', 'Jack', 'Nicholson')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: null'
assert p2.toString() == 'Jack Nicholson: Actor'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元组构造函数生成中是否应包含超级类的字段</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

class Base {
    protected String occupation
    public String occupation() { this.occupation }
}

@TupleConstructor(includeSuperFields=true)
class Person extends Base {
    String firstName
    String lastName
    public String toString() {
        "$firstName $lastName: ${occupation()}"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson', occupation: 'Actor')

def p2 = new Person('Actor', 'Jack', 'Nicholson')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: Actor'
assert p2.toString() == p1.toString()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">callSuper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该在对父构造函数的调用中调用超级属性，而不是将其设置为属性</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

class Base {
    String occupation
    Base() {}
    Base(String job) { occupation = job?.toLowerCase() }
}

@TupleConstructor(includeSuperProperties = true, callSuper=true)
class Person extends Base {
    String firstName
    String lastName
    public String toString() {
        "$firstName $lastName: $occupation"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')

def p2 = new Person('ACTOR', 'Jack', 'Nicholson')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: null'
assert p2.toString() == 'Jack Nicholson: actor'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">力</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下，如果已经定义了构造函数，则转换将不执行任何操作。将此属性设置为true，将生成构造函数，您有责任确保未定义重复的构造函数。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@ToString @TupleConstructor(force=true)
final class Person {
    String name
    // explicit constructor would normally disable tuple constructor
    Person(String first, String last) { this("$first $last") }
}

assert new Person('john smith').toString() == 'Person(john smith)'
assert new Person('john', 'smith').toString() == 'Person(john smith)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示为构造函数参数启用默认值处理。设置为false以获得恰好一个构造函数，但是具有初始值支持和命名参数。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString
@TupleConstructor(defaults=false)
class Musician {
  String name
  String instrument
  int born
}

assert new Musician('Jimi', 'Guitar', 1942).toString() == 'Musician(Jimi, Guitar, 1942)'
assert Musician.constructors.size() == 1</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useSetters</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下，转换将从其相应的构造函数参数直接设置每个属性的后备字段。将此属性设置为true，构造方法将调用setter（如果存在）。从构造函数内部到调用setter都可以将其覆盖，这通常被认为是不良样式。避免出现这种不良风格是您的责任。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@ToString @TupleConstructor(useSetters=true)
final class Foo {
    String bar
    void setBar(String bar) {
        this.bar = bar?.toUpperCase() // null-safe
    }
}

assert new Foo('cat').toString() == 'Foo(CAT)'
assert new Foo(bar: 'cat').toString() == 'Foo(CAT)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有内部名称的字段和/或属性应包含在构造函数中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(allNames=true)
class Person {
    String $firstName
}

def p = new Person('Jack')

assert p.$firstName == 'Jack'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JavaBean属性是否应包含在构造函数中</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TupleConstructor(allProperties=true)
class Person {
    String first
    private String last
    void setLast(String last) {
        this.last = last
    }
    String getName() { "$first $last" }
}

assert new Person('john', 'smith').name == 'john smith'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">预先</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个包含要在生成的构造函数的开头插入的语句的闭包</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(pre={ first = first?.toLowerCase() })
class Person {
    String first
}

def p = new Person('Jack')

assert p.first == 'jack'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个闭包，其中包含要在生成的构造函数的末尾插入的语句</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor
import static groovy.test.GroovyAssert.shouldFail

@TupleConstructor(post={ assert first })
class Person {
    String first
}

def jack = new Person('Jack')
shouldFail {
  def unknown = new Person()
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>设置<code>defaults</code>注释属性<code>false</code>和<code>force</code>注释属性<code>true</code>允许通过针对不同案例使用不同的自定义选项来创建多个元组构造函数（假设每个案例具有不同的类型签名），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Named {
  String name
}

@ToString(includeSuperProperties=true, ignoreNulls=true, includeNames=true, includeFields=true)
@TupleConstructor(force=true, defaults=false)
@TupleConstructor(force=true, defaults=false, includeFields=true)
@TupleConstructor(force=true, defaults=false, includeSuperProperties=true)
class Book extends Named {
  Integer published
  private Boolean fiction
  Book() {}
}

assert new Book("Regina", 2015).toString() == 'Book(published:2015, name:Regina)'
assert new Book(2015, false).toString() == 'Book(published:2015, fiction:false)'
assert new Book(2015).toString() == 'Book(published:2015)'
assert new Book().toString() == 'Book()'
assert Book.constructors.size() == 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，这是另一个示例，使用不同的选项<code>includes</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeSuperProperties=true, ignoreNulls=true, includeNames=true, includeFields=true)
@TupleConstructor(force=true, defaults=false, includes='name,year')
@TupleConstructor(force=true, defaults=false, includes='year,fiction')
@TupleConstructor(force=true, defaults=false, includes='name,fiction')
class Book {
    String name
    Integer year
    Boolean fiction
}

assert new Book("Regina", 2015).toString() == 'Book(name:Regina, year:2015)'
assert new Book(2015, false).toString() == 'Book(year:2015, fiction:false)'
assert new Book("Regina", false).toString() == 'Book(name:Regina, fiction:false)'
assert Book.constructors.size() == 3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-MapConstructor"><a class="anchor" href="#xform-MapConstructor"></a><code>@groovy.transform.MapConstructor</code></h5>
<div class="paragraph">
<p>的<code>@MapConstructor</code>注解旨在通过为您生成地图构造函数来消除样板代码。创建一个地图构造函数，以便基于提供的地图中具有键和属性名称的值来设置类中的每个属性。用法如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@ToString
@MapConstructor
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack, Nicholson)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成的构造函数将大致如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public Person(Map args) {
    if (args.containsKey('firstName')) {
        this.firstName = args.get('firstName')
    }
    if (args.containsKey('lastName')) {
        this.lastName = args.get('lastName')
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Canonical"><a class="anchor" href="#xform-Canonical"></a><code>@groovy.transform.Canonical</code></h5>
<div class="paragraph">
<p>的<code>@Canonical</code>元注释结合了<a href="#xform-ToString">@ToString</a> ， <a href="#xform-EqualsAndHashCode">@EqualsAndHashCode</a>和<a href="#xform-TupleConstructor">@TupleConstructor</a>注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Canonical

@Canonical
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack, Nicholson)' // Effect of @ToString

def p2 = new Person('Jack','Nicholson') // Effect of @TupleConstructor
assert p2.toString() == 'Person(Jack, Nicholson)'

assert p1==p2 // Effect of @EqualsAndHashCode
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用<a href="#xform-Immutable">@Immutable</a>元注释生成类似的不可变类。的<code>@Canonical</code>元注释支持在聚合注释中找到的配置选项。有关更多详细信息，请参见那些注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Canonical

@Canonical(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack)' // Effect of @ToString(excludes=['lastName'])

def p2 = new Person('Jack') // Effect of @TupleConstructor(excludes=['lastName'])
assert p2.toString() == 'Person(Jack)'

assert p1==p2 // Effect of @EqualsAndHashCode(excludes=['lastName'])
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode(excludes=['lastName'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@Canonical</code>元注释可以与显式使用其一个或多个组件注释结合使用，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Canonical

@Canonical(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack)' // Effect of @ToString(excludes=['lastName'])

def p2 = new Person('Jack') // Effect of @TupleConstructor(excludes=['lastName'])
assert p2.toString() == 'Person(Jack)'

assert p1==p2 // Effect of @EqualsAndHashCode(excludes=['lastName'])
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode(excludes=['lastName'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>来自的任何适用注释属性<code>@Canonical</code>传递给显式批注，但是显式批注中已经存在的属性优先。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-InheritConstructors"><a class="anchor" href="#xform-InheritConstructors"></a><code>@groovy.transform.InheritConstructors</code></h5>
<div class="paragraph">
<p>的<code>@InheritConstructor</code> AST转换旨在为您生成与超级构造函数匹配的构造函数。当覆盖异常类时，这特别有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.InheritConstructors

@InheritConstructors
class CustomException extends Exception {}

// all those are generated constructors
new CustomException()
new CustomException("A custom message")
new CustomException("A custom message", new RuntimeException())
new CustomException(new RuntimeException())

// Java 7 only
// new CustomException("A custom message", new RuntimeException(), false, true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@InheritConstructor</code> AST转换支持以下配置选项：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">构造函数注释</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">复制期间是否继承构造函数的注释</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.CONSTRUCTOR])
public @interface ConsAnno {}

class Base {
  @ConsAnno Base() {}
}

@InheritConstructors(constructorAnnotations=true)
class Child extends Base {}

assert Child.constructors[0].annotations[0].annotationType().name == 'groovy.transform.Generated'
assert Child.constructors[0].annotations[1].annotationType().name == 'ConsAnno'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">parameterAnnotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">复制构造函数时是否继承构造函数参数的批注</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.PARAMETER])
public @interface ParamAnno {}

class Base {
  Base(@ParamAnno String name) {}
}

@InheritConstructors(parameterAnnotations=true)
class Child extends Base {}

assert Child.constructors[0].parameterAnnotations[0][0].annotationType().name == 'ParamAnno'</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Category"><a class="anchor" href="#xform-Category"></a><code>@groovy.lang.Category</code></h5>
<div class="paragraph">
<p>的<code>@Category</code> AST转换简化了Groovy类别的创建。从历史上看，Groovy类别是这样写的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TripleCategory {
    public static Integer triple(Integer self) {
        3*self
    }
}
use (TripleCategory) {
    assert 9 == 3.triple()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@Category</code>转换使您可以使用实例样式类而不是静态类样式编写相同的内容。这消除了将每个方法的第一个参数作为接收者的需要。类别可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Category(Integer)
class TripleCategory {
    public Integer triple() { 3*this }
}
use (TripleCategory) {
    assert 9 == 3.triple()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，混合类可以使用<code>this</code>代替。还值得注意的是，在类别类中使用实例字段本质上是不安全的：类别不是有状态的（例如特征）。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-IndexedProperty"><a class="anchor" href="#xform-IndexedProperty"></a><code>@groovy.transform.IndexedProperty</code></h5>
<div class="paragraph">
<p>的<code>@IndexedProperty</code>注解旨在为列表/数组类型的属性生成索引的获取器/设置器。如果您想使用Java的Groovy类，这特别有用。尽管Groovy支持GPath来访问属性，但是Java不提供此功能。的<code>@IndexedProperty</code>注释将生成以下形式的索引属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeBean {
    @IndexedProperty String[] someArray = new String[2]
    @IndexedProperty List someList = []
}

def bean = new SomeBean()
bean.setSomeArray(0, 'value')
bean.setSomeList(0, 123)

assert bean.someArray[0] == 'value'
assert bean.someList == [123]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Lazy"><a class="anchor" href="#xform-Lazy"></a><code>@groovy.lang.Lazy</code></h5>
<div class="paragraph">
<p>的<code>@Lazy</code> AST转换实现字段的延迟初始化。例如，以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeBean {
    @Lazy LinkedList myField
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将产生以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">List $myField
List getMyField() {
    if ($myField!=null) { return $myField }
    else {
        $myField = new LinkedList()
        return $myField
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用于初始化字段的默认值是声明类型的默认构造函数。可以通过使用属性分配右侧的闭包来定义默认值，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class SomeBean {
    @Lazy LinkedList myField = { ['a','b','c']}()
}</pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，生成的代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>List $myField
List getMyField() {
    if ($myField!=null) { return $myField }
    else {
        $myField = { ['a','b','c']}()
        return $myField
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>如果该字段声明为volatile，则将使用<a href="http://en.wikipedia.org/wiki/Double-checked_locking">双重检查的锁定</a>模式来同步初始化。</p>
</div>
<div class="paragraph">
<p>使用<code>soft=true</code>参数，helper字段将使用<code>SoftReference</code>而是提供一种实现缓存的简单方法。在这种情况下，如果垃圾收集器决定收集引用，则下次访问该字段时将进行初始化。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Newify"><a class="anchor" href="#xform-Newify"></a><code>@groovy.lang.Newify</code></h5>
<div class="paragraph">
<p>的<code>@Newify</code> AST转换用于带来替代语法来构造对象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<code>Python</code>样式：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@Newify([Tree,Leaf])
class TreeBuilder {
    Tree tree = Tree(Leaf('A'),Leaf('B'),Tree(Leaf('C')))
}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>或使用<code>Ruby</code>样式：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@Newify([Tree,Leaf])
class TreeBuilder {
    Tree tree = Tree.new(Leaf.new('A'),Leaf.new('B'),Tree.new(Leaf.new('C')))
}</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Ruby</code>可以通过设置<code>auto</code>标记为<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Sortable"><a class="anchor" href="#xform-Sortable"></a><code>@groovy.transform.Sortable</code></h5>
<div class="paragraph">
<p>的<code>@Sortable</code> AST转换用于帮助编写以下类<code>Comparable</code>并且通常可以通过众多属性轻松进行排序。易于使用，如以下示例所示，其中我们注释了<code>Person</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Sortable

@Sortable class Person {
    String first
    String last
    Integer born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成的类具有以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它实现了<code>Comparable</code>接口</p>
</li>
<li>
<p>它包含一个<code>compareTo</code>方法的实现方式基于<code>first</code> ， <code>last</code>和<code>born</code>属性</p>
</li>
<li>
<p>它有三种返回比较器的方法： <code>comparatorByFirst</code> ， <code>comparatorByLast</code>和<code>comparatorByBorn</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>产生的<code>compareTo</code>方法将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public int compareTo(java.lang.Object obj) {
    if (this.is(obj)) {
        return 0
    }
    if (!(obj instanceof Person)) {
        return -1
    }
    java.lang.Integer value = this.first &lt;=&gt; obj.first
    if (value != 0) {
        return value
    }
    value = this.last &lt;=&gt; obj.last
    if (value != 0) {
        return value
    }
    value = this.born &lt;=&gt; obj.born
    if (value != 0) {
        return value
    }
    return 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为生成的比较器的示例， <code>comparatorByFirst</code>比较器将有一个<code>compare</code>如下所示的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public int compare(java.lang.Object arg0, java.lang.Object arg1) {
    if (arg0 == arg1) {
        return 0
    }
    if (arg0 != null &amp;&amp; arg1 == null) {
        return -1
    }
    if (arg0 == null &amp;&amp; arg1 != null) {
        return 1
    }
    return arg0.first &lt;=&gt; arg1.first
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Person</code>该类可以在任何地方使用<code>Comparable</code>是预期的，并且在任何情况下都会生成比较器<code>Comparator</code>如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def people = [
    new Person(first: 'Johnny', last: 'Depp', born: 1963),
    new Person(first: 'Keira', last: 'Knightley', born: 1985),
    new Person(first: 'Geoffrey', last: 'Rush', born: 1951),
    new Person(first: 'Orlando', last: 'Bloom', born: 1977)
]

assert people[0] &gt; people[2]
assert people.sort()*.last == ['Rush', 'Depp', 'Knightley', 'Bloom']
assert people.sort(false, Person.comparatorByFirst())*.first == ['Geoffrey', 'Johnny', 'Keira', 'Orlando']
assert people.sort(false, Person.comparatorByLast())*.last == ['Bloom', 'Depp', 'Knightley', 'Rush']
assert people.sort(false, Person.comparatorByBorn())*.last == ['Rush', 'Depp', 'Bloom', 'Knightley']</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，所有属性都在生成的<code>compareTo</code>定义它们的优先级顺序的方法。您可以在生成的文件中包含或排除某些属性<code>compareTo</code>方法，方法是在<code>includes</code>要么<code>excludes</code>注释属性。如果使用<code>includes</code> ，属性名称的顺序将决定比较时属性的优先级。为了说明，请考虑以下内容<code>Person</code>类定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Sortable(includes='first,born') class Person {
    String last
    int born
    String first
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将有两种比较器方法<code>comparatorByFirst</code>和<code>comparatorByBorn</code>和生成的<code>compareTo</code>方法将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public int compareTo(java.lang.Object obj) {
    if (this.is(obj)) {
        return 0
    }
    if (!(obj instanceof Person)) {
        return -1
    }
    java.lang.Integer value = this.first &lt;=&gt; obj.first
    if (value != 0) {
        return value
    }
    value = this.born &lt;=&gt; obj.born
    if (value != 0) {
        return value
    }
    return 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个<code>Person</code>该类可以如下使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def people = [
    new Person(first: 'Ben', last: 'Affleck', born: 1972),
    new Person(first: 'Ben', last: 'Stiller', born: 1965)
]

assert people.sort()*.last == ['Stiller', 'Affleck']</code></pre>
</div>
</div>
<div class="paragraph">
<p>的行为<code>@Sortable</code>可以使用以下附加参数进一步更改AST转换：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该使用JavaBean属性（在本机属性之后排序）</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@Canonical(includeFields = true)
@Sortable(allProperties = true, includes = 'nameSize')
class Player {
  String name
  int getNameSize() { name.size() }
}

def finalists = [
  new Player('Serena'),
  new Player('Venus'),
  new Player('CoCo'),
  new Player('Mirjana')
]

assert finalists.sort()*.name == ['CoCo', 'Venus', 'Serena', 'Mirjana']</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该使用带有“内部”名称的属性</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@Canonical(allNames = true)
@Sortable(allNames = false)
class Player {
  String $country
  String name
}

def finalists = [
  new Player('USA', 'Serena'),
  new Player('USA', 'Venus'),
  new Player('USA', 'CoCo'),
  new Player('Croatian', 'Mirjana')
]

assert finalists.sort()*.name == ['Mirjana', 'CoCo', 'Serena', 'Venus']</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应该使用超级属性（先订购）</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
  String name
}

@Canonical(includeSuperProperties = true)
@Sortable(includeSuperProperties = true)
class Citizen extends Person {
  String country
}

def people = [
  new Citizen('Bob', 'Italy'),
  new Citizen('Cathy', 'Hungary'),
  new Citizen('Cathy', 'Egypt'),
  new Citizen('Bob', 'Germany'),
  new Citizen('Alan', 'France')
]

assert people.sort()*.name == ['Alan', 'Bob', 'Bob', 'Cathy', 'Cathy']
assert people.sort()*.country == ['France', 'Germany', 'Italy', 'Egypt', 'Hungary']</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Builder"><a class="anchor" href="#xform-Builder"></a><code>@groovy.transform.builder.Builder</code></h5>
<div class="paragraph">
<p>的<code>@Builder</code> AST转换用于帮助编写可使用<em>流利的</em> api调用创建的类。转换支持多种构建策略以涵盖各种情况，并且有许多配置选项可自定义构建过程。如果您是AST黑客，则还可以定义自己的策略类。下表列出了Groovy捆绑提供的可用策略以及每种策略支持的配置选项。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:11.1111%">
<col style="width:11.1111%">
<col style="width:11.1111%">
<col style="width:11.1111%">
<col style="width:11.1111%">
<col style="width:11.1111%">
<col style="width:11.1111%">
<col style="width:11.1111%">
<col style="width:11.1112%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">战略</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">builderClassName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">builderMethodName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">buildMethodName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字首</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含/排除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链式二传手</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“设置”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExternalStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显式生成器类，未构建的类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“ build”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建一个嵌套的帮助器类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<em><typename></typename></em>建造者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“构建器”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“ build”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InitializerStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建一个嵌套的帮助程序类，以提供类型安全的流利的创建</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<em><typename></typename></em>初始化器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“ createInitializer”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“创建”，但通常仅在内部使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认为“”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是的，默认<code>false</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">简单策略</div>
<p>要使用<code>SimpleStrategy</code> ，使用注释您的Groovy类<code>@Builder</code>注释，并指定策略，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=SimpleStrategy)
class Person {
    String first
    String last
    Integer born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，只需按如下所示的链式调用设置器即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p1 = new Person().setFirst('Johnny').setLast('Depp').setBorn(1963)
assert "$p1.first $p1.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每个属性，将创建一个生成的setter，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public Person setFirst(java.lang.String first) {
    this.first = first
    return this
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以指定一个前缀，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=SimpleStrategy, prefix="")
class Person {
    String first
    String last
    Integer born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并调用链式设置器将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = new Person().first('Johnny').last('Depp').born(1963)
assert "$p.first $p.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>SimpleStrategy</code>和这个结合<code>@TupleConstructor</code> 。如果你的<code>@Builder</code>注释没有明确的<code>includes</code>要么<code>excludes</code>注释属性，但您的<code>@TupleConstructor</code>批注确实来自<code>@TupleConstructor</code>将被重新用于<code>@Builder</code> 。结合使用任何注释别名的情况相同<code>@TupleConstructor</code>如<code>@Canonical</code> 。</p>
</div>
<div class="paragraph">
<p>注释属性<code>useSetters</code>如果您有在施工过程中要调用的二传手，则可以使用。有关详细信息，请参见JavaDoc。</p>
</div>
<div class="paragraph">
<p>注释属性<code>builderClassName</code> ， <code>buildMethodName</code> ， <code>builderMethodName</code> ， <code>forClass</code>和<code>includeSuperProperties</code>不支持此策略。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy已经具有内置的构建机制。不要急于使用<code>@Builder</code>如果内置机制满足您的需求。一些例子：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p2 = new Person(first: 'Keira', last: 'Knightley', born: 1985)
def p3 = new Person().with {
    first = 'Geoffrey'
    last = 'Rush'
    born = 1951
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">外部策略</div>
<p>要使用<code>ExternalStrategy</code> ，使用创建和注释Groovy构建器类<code>@Builder</code>注释，指定构建器要使用的类<code>forClass</code>并指出使用<code>ExternalStrategy</code> 。假设您要使用以下类作为构建器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String first
    String last
    int born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您显式创建并使用构建器类，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=ExternalStrategy, forClass=Person)
class PersonBuilder { }

def p = new PersonBuilder().first('Johnny').last('Depp').born(1963).build()
assert "$p.first $p.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您提供的（通常为空）构建器类将使用适当的设置器和构建方法填充。生成的生成方法将类似于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public Person build() {
    Person _thePerson = new Person()
    _thePerson.first = first
    _thePerson.last = last
    _thePerson.born = born
    return _thePerson
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您要为其创建构建器的类可以是遵循常规JavaBean约定的任何Java或Groovy类，例如，无参数构造器和属性的设置器。这是一个使用Java类的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=ExternalStrategy, forClass=javax.swing.DefaultButtonModel)
class ButtonModelBuilder {}

def model = new ButtonModelBuilder().enabled(true).pressed(true).armed(true).rollover(true).selected(true).build()
assert model.isArmed()
assert model.isPressed()
assert model.isEnabled()
assert model.isSelected()
assert model.isRollover()</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用<code>prefix</code> ， <code>includes</code> ， <code>excludes</code>和<code>buildMethodName</code>注释属性。这是说明各种自定义的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.Canonical

@Canonical
class Person {
    String first
    String last
    int born
}

@Builder(builderStrategy=ExternalStrategy, forClass=Person, includes=['first', 'last'], buildMethodName='create', prefix='with')
class PersonBuilder { }

def p = new PersonBuilder().withFirst('Johnny').withLast('Depp').create()
assert "$p.first $p.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>builderMethodName</code>和<code>builderClassName</code>的注释属性<code>@Builder</code>不适用于此策略。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>ExternalStrategy</code>和这个结合<code>@TupleConstructor</code> 。如果你的<code>@Builder</code>注释没有明确的<code>includes</code>要么<code>excludes</code>注释属性，但<code>@TupleConstructor</code>您正在为其创建构建器的类的注释，来自<code>@TupleConstructor</code>将被重新用于<code>@Builder</code> 。结合使用任何注释别名的情况相同<code>@TupleConstructor</code>如<code>@Canonical</code> 。</p>
</div>
<div class="paragraph">
<div class="title">默认策略</div>
<p>要使用<code>DefaultStrategy</code> ，使用注释您的Groovy类<code>@Builder</code>注释如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.Builder

@Builder
class Person {
    String firstName
    String lastName
    int age
}

def person = Person.builder().firstName("Robert").lastName("Lewandowski").age(21).build()
assert person.firstName == "Robert"
assert person.lastName == "Lewandowski"
assert person.age == 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要，您可以使用以下方法自定义构建过程的各个方面<code>builderClassName</code> ， <code>buildMethodName</code> ， <code>builderMethodName</code> ， <code>prefix</code> ， <code>includes</code>和<code>excludes</code>批注属性，此处的示例中使用了其中的一些：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.Builder

@Builder(buildMethodName='make', builderMethodName='maker', prefix='with', excludes='age')
class Person {
    String firstName
    String lastName
    int age
}

def p = Person.maker().withFirstName("Robert").withLastName("Lewandowski").make()
assert "$p.firstName $p.lastName" == "Robert Lewandowski"</code></pre>
</div>
</div>
<div class="paragraph">
<p>该策略还支持注释静态方法和构造函数。在这种情况下，静态方法或构造函数参数将成为用于构建目的的属性，在静态方法的情况下，方法的返回类型将成为正在构建的目标类。如果您有多个<code>@Builder</code>在类中使用注释（在类，方法或构造函数位置），然后由您确保所生成的帮助器类和工厂方法具有唯一的名称（即，最多可以使用默认名称值）。这是一个突出显示方法和构造函数用法的示例（并说明了唯一名称的重命名）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.*

@ToString
@Builder
class Person {
  String first, last
  int born

  Person(){}

  @Builder(builderClassName='MovieBuilder', builderMethodName='byRoleBuilder')
  Person(String roleName) {
     if (roleName == 'Jack Sparrow') {
         this.first = 'Johnny'; this.last = 'Depp'; this.born = 1963
     }
  }

  @Builder(builderClassName='NameBuilder', builderMethodName='nameBuilder', prefix='having', buildMethodName='fullName')
  static String join(String first, String last) {
      first + ' ' + last
  }

  @Builder(builderClassName='SplitBuilder', builderMethodName='splitBuilder')
  static Person split(String name, int year) {
      def parts = name.split(' ')
      new Person(first: parts[0], last: parts[1], born: year)
  }
}

assert Person.splitBuilder().name("Johnny Depp").year(1963).build().toString() == 'Person(Johnny, Depp, 1963)'
assert Person.byRoleBuilder().roleName("Jack Sparrow").build().toString() == 'Person(Johnny, Depp, 1963)'
assert Person.nameBuilder().havingFirst('Johnny').havingLast('Depp').fullName() == 'Johnny Depp'
assert Person.builder().first("Johnny").last('Depp').born(1963).build().toString() == 'Person(Johnny, Depp, 1963)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>forClass</code>此策略不支持注释属性。</p>
</div>
<div class="paragraph">
<div class="title">初始化策略</div>
<p>要使用<code>InitializerStrategy</code> ，使用注释您的Groovy类<code>@Builder</code>注释，并指定策略，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.*

@ToString
@Builder(builderStrategy=InitializerStrategy)
class Person {
    String firstName
    String lastName
    int age
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的类将被锁定为只有一个公共构造函数采用“完全设置”的初始化程序。它还将具有工厂方法来创建初始化程序。它们的用法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
def firstLastAge() {
    assert new Person(Person.createInitializer().firstName("John").lastName("Smith").age(21)).toString() == 'Person(John, Smith, 21)'
}
firstLastAge()</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试使用不涉及设置所有属性（尽管顺序并不重要）的初始化程序将导致编译错误。如果您不需要这种严格级别，则无需使用<code>@CompileStatic</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>InitializerStrategy</code>和这个结合<code>@Canonical</code>和<code>@Immutable</code> 。如果你的<code>@Builder</code>注释没有明确的<code>includes</code>要么<code>excludes</code>注释属性，但您的<code>@Canonical</code>批注确实来自<code>@Canonical</code>将被重新用于<code>@Builder</code> 。这是一个使用示例<code>@Builder</code>与<code>@Immutable</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.*
import static groovy.transform.options.Visibility.PRIVATE

@Builder(builderStrategy=InitializerStrategy)
@Immutable
@VisibilityOptions(PRIVATE)
class Person {
    String first
    String last
    int born
}

def publicCons = Person.constructors
assert publicCons.size() == 1

@CompileStatic
def createFirstLastBorn() {
  def p = new Person(Person.createInitializer().first('Johnny').last('Depp').born(1963))
  assert "$p.first $p.last $p.born" == 'Johnny Depp 1963'
}

createFirstLastBorn()</code></pre>
</div>
</div>
<div class="paragraph">
<p>注释属性<code>useSetters</code>如果您有在施工过程中要调用的二传手，则可以使用。有关详细信息，请参见JavaDoc。</p>
</div>
<div class="paragraph">
<p>该策略还支持注释静态方法和构造函数。在这种情况下，静态方法或构造函数参数将成为用于构建目的的属性，在静态方法的情况下，方法的返回类型将成为正在构建的目标类。如果您有多个<code>@Builder</code>在类中使用注释（在类，方法或构造函数位置），然后由您确保所生成的帮助器类和工厂方法具有唯一的名称（即，最多可以使用默认名称值）。有关方法和构造函数用法的示例，但使用<code>DefaultStrategy</code>策略，请参阅该策略的文档。</p>
</div>
<div class="paragraph">
<p>注释属性<code>forClass</code>不支持此策略。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-AutoImplement"><a class="anchor" href="#xform-AutoImplement"></a><code>@groovy.transform.AutoImplement</code></h5>
<div class="paragraph">
<p>的<code>@AutoImplement</code> AST转换为从超类或接口中找到的任何抽象方法提供虚拟实现。对于所有找到的抽象方法，虚拟实现都是相同的，可以是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>本质上为空（对于void方法和具有返回类型的方法完全正确，返回该类型的默认值）</p>
</li>
<li>
<p>引发指定异常的语句（带有可选消息）</p>
</li>
<li>
<p>一些用户提供的代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一个示例说明了默认情况。我们的课用<code>@AutoImplement</code> ，具有一个超类和一个接口，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoImplement

@AutoImplement
class MyNames extends AbstractList&lt;String&gt; implements Closeable { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>一种<code>void close()</code>的方法<code>Closeable</code>提供了接口，并保留为空。还为超类的三种抽象方法提供了实现。的<code>get</code> ， <code>addAll</code>和<code>size</code>方法的返回类型为<code>String</code> ， <code>boolean</code>和<code>int</code>分别具有默认值<code>null</code> ， <code>false</code>和<code>0</code> 。我们可以使用以下代码使用我们的类（并检查其中一种方法的预期返回类型）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new MyNames().size() == 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查等效的生成代码也是值得的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyNames implements Closeable extends AbstractList&lt;String&gt; {

    String get(int param0) {
        return null
    }

    boolean addAll(Collection&lt;? extends String&gt; param0) {
        return false
    }

    void close() throws Exception {
    }

    int size() {
        return 0
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个示例说明了最简单的异常情况。我们的课用<code>@AutoImplement</code> ，具有超类，并且注释属性指示<code>IOException</code>如果调用了我们的任何“虚拟”方法，则应抛出该异常。这是类的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AutoImplement(exception=IOException)
class MyWriter extends Writer { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用以下代码使用该类（并检查其中一种方法是否抛出了预期的异常）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static groovy.test.GroovyAssert.shouldFail

shouldFail(IOException) {
  new MyWriter().flush()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还值得研究生成了三个void方法的等效生成代码，所有这些方法都会抛出所提供的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyWriter extends Writer {

    void flush() throws IOException {
        throw new IOException()
    }

    void write(char[] param0, int param1, int param2) throws IOException {
        throw new IOException()
    }

    void close() throws Exception {
        throw new IOException()
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第三个示例说明了带有提供的消息的异常情况。我们的课用<code>@AutoImplement</code> ，实现一个接口并具有注释属性，以指示<code>UnsupportedOperationException</code>与<code>Not supported by MyIterator</code>因为应该为任何提供的方法抛出该消息。这是类的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AutoImplement(exception=UnsupportedOperationException, message='Not supported by MyIterator')
class MyIterator implements Iterator&lt;String&gt; { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用以下代码来使用该类（并检查是否抛出了预期的异常，并且对于其中一种方法具有正确的消息）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ex = shouldFail(UnsupportedOperationException) {
     new MyIterator().hasNext()
}
assert ex.message == 'Not supported by MyIterator'</code></pre>
</div>
</div>
<div class="paragraph">
<p>还值得研究生成了三个void方法的等效生成代码，所有这些方法都会抛出所提供的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyIterator implements Iterator&lt;String&gt; {

    boolean hasNext() {
        throw new UnsupportedOperationException('Not supported by MyIterator')
    }

    String next() {
        throw new UnsupportedOperationException('Not supported by MyIterator')
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第四个示例说明了用户提供的代码的情况。我们的课用<code>@AutoImplement</code> ，实现一个接口，并有一个明显的覆盖<code>hasNext</code>方法，并具有一个注释属性，其中包含任何提供的方法的提供的代码。这是类的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AutoImplement(code = { throw new UnsupportedOperationException('Should never be called but was called on ' + new Date()) })
class EmptyIterator implements Iterator&lt;String&gt; {
    boolean hasNext() { false }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用以下代码使用该类（并检查是否抛出了预期的异常并具有预期形式的消息）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ex = shouldFail(UnsupportedOperationException) {
     new EmptyIterator().next()
}
assert ex.message.startsWith('Should never be called but was called on ')</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样值得研究的是等效生成的代码，其中<code>next</code>提供了方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class EmptyIterator implements java.util.Iterator&lt;String&gt; {

    boolean hasNext() {
        false
    }

    String next() {
        throw new UnsupportedOperationException('Should never be called but was called on ' + new Date())
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_class_design_annotations"><a class="anchor" href="#_class_design_annotations"></a> 2.1.2。类设计注释</h4>
<div class="paragraph">
<p>此类注释旨在通过使用声明式样式来简化众所周知的设计模式（委托，单例，…）的实现。</p>
</div>
<div class="sect4">
<h5 id="xform-BaseScript"><a class="anchor" href="#xform-BaseScript"></a><code>@groovy.transform.BaseScript</code></h5>
<div class="paragraph">
<p><code>@BaseScript</code>在脚本内用于表示脚本应从自定义脚本基类扩展，而不是扩展自定义脚本基类<code>groovy.lang.Script</code> 。有关更多详细信息，请参阅<a href="#dsl-basescript">域特定语言</a>的文档。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Delegate"><a class="anchor" href="#xform-Delegate"></a><code>@groovy.lang.Delegate</code></h5>
<div class="paragraph">
<p>的<code>@Delegate</code> AST转换旨在实现委托设计模式。在以下课程中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Event {
    @Delegate Date when
    String title
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>when</code>属性带有注释<code>@Delegate</code> ，表示<code>Event</code>班级将呼叫委托给<code>Date</code>方法<code>when</code>属性。在这种情况下，生成的代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Event {
    Date when
    String title
    boolean before(Date other) {
        when.before(other)
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以致电<code>before</code>方法，例如，直接在<code>Event</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ev = new Event(title:'Groovy keynote', when: Date.parse('yyyy/MM/dd', '2013/09/10'))
def now = new Date()
assert ev.before(now)</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了注释属性（或字段），您还可以注释方法。在这种情况下，该方法可以视为委托的getter或factory方法。例如，下面是一个类（非常不寻常），该类具有以循环方式访问的委托池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Test {
    private int robinCount = 0
    private List&lt;List&gt; items = [[0], [1], [2]]

    @Delegate
    List getRoundRobinList() {
        items[robinCount++ % items.size()]
    }

    void checkItems(List&lt;List&gt; testValue) {
        assert items == testValue
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是该类的示例用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def t = new Test()
t &lt;&lt; 'fee'
t &lt;&lt; 'fi'
t &lt;&lt; 'fo'
t &lt;&lt; 'fum'
t.checkItems([[0, 'fee', 'fum'], [1, 'fi'], [2, 'fo']])</code></pre>
</div>
</div>
<div class="paragraph">
<p>以这种循环方式使用标准列表会违反列表的许多预期属性，因此，不要期望上述类会在此琐碎的示例之外做任何有用的事情。</p>
</div>
<div class="paragraph">
<p>的行为<code>@Delegate</code>可以使用以下参数更改AST转换：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">介面</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段实现的接口是否也应由类实现</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter { void sayHello() }
class MyGreeter implements Greeter { void sayHello() { println 'Hello!'} }

class DelegatingGreeter { // no explicit interface
    @Delegate MyGreeter greeter = new MyGreeter()
}
def greeter = new DelegatingGreeter()
assert greeter instanceof Greeter // interface was added transparently</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">不推荐使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则还委托使用@Deprecated注释的方法</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class WithDeprecation {
    @Deprecated
    void foo() {}
}
class WithoutDeprecation {
    @Deprecated
    void bar() {}
}
class Delegating {
    @Delegate(deprecated=true) WithDeprecation with = new WithDeprecation()
    @Delegate WithoutDeprecation without = new WithoutDeprecation()
}
def d = new Delegating()
d.foo() // passes thanks to deprecated=true
d.bar() // fails because of @Deprecated</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">methodAnnotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否将注释从委托的方法转移到委托的方法。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class WithAnnotations {
    @Transactional
    void method() {
    }
}
class DelegatingWithoutAnnotations {
    @Delegate WithAnnotations delegate
}
class DelegatingWithAnnotations {
    @Delegate(methodAnnotations = true) WithAnnotations delegate
}
def d1 = new DelegatingWithoutAnnotations()
def d2 = new DelegatingWithAnnotations()
assert d1.class.getDeclaredMethod('method').annotations.length==1
assert d2.class.getDeclaredMethod('method').annotations.length==2</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">parameterAnnotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否将注释从委托的方法参数转移到委托的方法。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class WithAnnotations {
    void method(@NotNull String str) {
    }
}
class DelegatingWithoutAnnotations {
    @Delegate WithAnnotations delegate
}
class DelegatingWithAnnotations {
    @Delegate(parameterAnnotations = true) WithAnnotations delegate
}
def d1 = new DelegatingWithoutAnnotations()
def d2 = new DelegatingWithAnnotations()
assert d1.class.getDeclaredMethod('method',String).parameterAnnotations[0].length==0
assert d2.class.getDeclaredMethod('method',String).parameterAnnotations[0].length==1</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">排除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">排除在委托之外的方法列表。有关更细粒度的控制，另请参见<code>excludeTypes</code> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Worker {
    void task1() {}
    void task2() {}
}
class Delegating {
    @Delegate(excludes=['task2']) Worker worker = new Worker()
}
def d = new Delegating()
d.task1() // passes
d.task2() // fails because method is excluded</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包括</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未定义的标记数组（指示所有方法）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">委派要包括的方法列表。有关更细粒度的控制，另请参见<code>includeTypes</code> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Worker {
    void task1() {}
    void task2() {}
}
class Delegating {
    @Delegate(includes=['task1']) Worker worker = new Worker()
}
def d = new Delegating()
d.task1() // passes
d.task2() // fails because method is not included</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludeTypes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含要从委托中排除的方法签名的接口列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface AppendStringSelector {
    StringBuilder append(String str)
}
class UpperStringBuilder {
    @Delegate(excludeTypes=AppendStringSelector)
    StringBuilder sb1 = new StringBuilder()

    @Delegate(includeTypes=AppendStringSelector)
    StringBuilder sb2 = new StringBuilder()

    String toString() { sb1.toString() + sb2.toString().toUpperCase() }
}
def usb = new UpperStringBuilder()
usb.append(3.5d)
usb.append('hello')
usb.append(true)
assert usb.toString() == '3.5trueHELLO'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeTypes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未定义的标记数组（表示默认没有列表）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含要包含在委托中的方法签名的接口列表</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface AppendBooleanSelector {
    StringBuilder append(boolean b)
}
interface AppendFloatSelector {
    StringBuilder append(float b)
}
class NumberBooleanBuilder {
    @Delegate(includeTypes=AppendBooleanSelector, interfaces=false)
    StringBuilder nums = new StringBuilder()
    @Delegate(includeTypes=[AppendFloatSelector], interfaces=false)
    StringBuilder bools = new StringBuilder()
    String result() { "${nums.toString()} ~ ${bools.toString()}" }
}
def b = new NumberBooleanBuilder()
b.append(true)
b.append(3.14f)
b.append(false)
b.append(0.0f)
assert b.result() == "truefalse ~ 3.140.0"
b.append(3.5d) // would fail because we didn't include append(double)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">委托模式是否也应应用于内部名称的方法</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Worker {
    void task$() {}
}
class Delegating {
    @Delegate(allNames=true) Worker worker = new Worker()
}
def d = new Delegating()
d.task$() //passes</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Immutable"><a class="anchor" href="#xform-Immutable"></a><code>@groovy.transform.Immutable</code></h5>
<div class="paragraph">
<p>的<code>@Immutable</code>元注释结合了以下注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xform-ToString">@ToString</a></p>
</li>
<li>
<p><a href="#xform-EqualsAndHashCode">@EqualsAndHashCode</a></p>
</li>
<li>
<p><a href="#xform-TupleConstructor">@TupleConstructor</a></p>
</li>
<li>
<p><a href="#xform-MapConstructor">@MapConstructor</a></p>
</li>
<li>
<p><a href="#xform-ImmutableBase">@ImmutableBase</a></p>
</li>
<li>
<p><a href="#xform-ImmutableOptions">@ImmutableOptions</a></p>
</li>
<li>
<p><a href="#xform-PropertyOptions">@PropertyOptions</a></p>
</li>
<li>
<p><a href="#xform-KnownImmutable">@KnownImmutable</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>@Immutable</code>元注释简化了不可变类的创建。不可变的类很有用，因为它们通常更易于推理，并且本质上是线程安全的。有关如何在Java中实现不可变类的所有详细信息<a href="http://www.informit.com/store/effective-java-9780134685991">，</a>请参见<a href="http://www.informit.com/store/effective-java-9780134685991">有效的Java，最小化可变性</a> 。的<code>@Immutable</code>元注释自动为您完成了<em>有效Java中</em>描述的大多数事情。要使用元注释，您要做的就是对类进行注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable

@Immutable
class Point {
    int x
    int y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对不可变类的要求之一是无法修改该类内的任何状态信息。实现此目的的一个要求是对每个属性使用不可变的类，或者对构造函数和属性获取器中的任何可变属性执行特殊编码，例如防御性复制和防御性复制。之间<code>@ImmutableBase</code> ， <code>@MapConstructor</code>和<code>@TupleConstructor</code>属性被标识为不可变的，或者自动处理许多已知情况的特殊编码。提供了各种机制来扩展允许的已处理属性类型。看到<code>@ImmutableOptions</code>和<code>@KnownImmutable</code>有关详细信息。</p>
</div>
<div class="paragraph">
<p>申请结果<code>@Immutable</code>类的应用与<a href="#xform-Canonical">@Canonical</a>元注释的应用非常相似，但是生成的类将具有额外的逻辑来处理不变性。例如，您将尝试修改属性，从而导致<code>ReadOnlyPropertyException</code>因为该属性的后备字段将被自动设置为final。</p>
</div>
<div class="paragraph">
<p>的<code>@Immutable</code>元注释支持在聚合注释中找到的配置选项。有关更多详细信息，请参见那些注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-ImmutableBase"><a class="anchor" href="#xform-ImmutableBase"></a><code>@groovy.transform.ImmutableBase</code></h5>
<div class="paragraph">
<p>用生成的不可变类<code>@ImmutableBase</code>会自动定型。另外，将检查每个属性的类型，并对类进行各种检查，例如，当前不允许使用公共实例字段。它还会生成一个<code>copyWith</code>构造函数（如果需要）。</p>
</div>
<div class="paragraph">
<p>支持以下注释属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">copyWith</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值是否生成一个<code>copyWith( Map )</code>方法。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable

@Immutable( copyWith=true )
class User {
    String  name
    Integer age
}

def bob   = new User( 'bob', 43 )
def alice = bob.copyWith( name:'alice' )
assert alice.name == 'alice'
assert alice.age  == 43</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-PropertyOptions"><a class="anchor" href="#xform-PropertyOptions"></a><code>@groovy.transform.PropertyOptions</code></h5>
<div class="paragraph">
<p>此批注允许您指定在类构造期间要由转换使用的自定义属性处理程序。Groovy主编译器将忽略它，但其他转换（例如<code>@TupleConstructor</code> ， <code>@MapConstructor</code>和<code>@ImmutableBase</code> 。它经常被后台使用<code>@Immutable</code>元注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-VisibilityOptions"><a class="anchor" href="#xform-VisibilityOptions"></a><code>@groovy.transform.VisibilityOptions</code></h5>
<div class="paragraph">
<p>此批注允许您为另一个转换生成的结构指定自定义可见性。Groovy主编译器将忽略它，但其他转换（例如<code>@TupleConstructor</code> ， <code>@MapConstructor</code>和<code>@NamedVariant</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-ImumtableOptions"><a class="anchor" href="#xform-ImumtableOptions"></a><code>@groovy.transform.ImmutableOptions</code></h5>
<div class="paragraph">
<p>Groovy的不可变性支持依赖于已知不可变类的预定义列表（例如<code>java.net.URI</code>要么<code>java.lang.String</code>如果使用的类型不在该列表中，则会失败，由于以下注释属性的允许，您可以将其添加到已知的不可变类型的列表中<code>@ImmutableOptions</code>注解：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">已知不可变类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空清单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被视为不可变的类的列表。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable
import groovy.transform.TupleConstructor

@TupleConstructor
final class Point {
    final int x
    final int y
    public String toString() { "($x,$y)" }
}

@Immutable(knownImmutableClasses=[Point])
class Triangle {
    Point a,b,c
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">已知不可变项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空清单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">视为不可变的属性名称的列表。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable
import groovy.transform.TupleConstructor

@TupleConstructor
final class Point {
    final int x
    final int y
    public String toString() { "($x,$y)" }
}

@Immutable(knownImmutables=['a','b','c'])
class Triangle {
    Point a,b,c
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果您认为一个类型是不可变的，并且不是自动处理的类型之一，则取决于您是否正确编码该类以确保不可变。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-KnownImmutable"><a class="anchor" href="#xform-KnownImmutable"></a><code>@groovy.transform.KnownImmutable</code></h5>
<div class="paragraph">
<p>的<code>@KnownImmutable</code>注释实际上并不是触发任何AST转换的注释。它只是一个标记注释。您可以使用注释对类进行注释（包括Java类），并且它们将被视为不可变类中的成员可接受的类型。这样可以省去您显式使用<code>knownImmutables</code>要么<code>knownImmutableClasses</code>来自的注释属性<code>@ImmutableOptions</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Memoized"><a class="anchor" href="#xform-Memoized"></a><code>@groovy.transform.Memoized</code></h5>
<div class="paragraph">
<p>的<code>@Memoized</code> AST转换通过仅使用注释方法就可以缓存方法调用的结果，从而简化了缓存的实现。 <code>@Memoized</code> 。让我们想象一下以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">long longComputation(int seed) {
    // slow computation
    Thread.sleep(100*seed)
    System.nanoTime()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>基于该方法的实际参数，这将模拟长时间的计算。不带<code>@Memoized</code> ，每个方法调用将花费几秒钟，而且还会返回一个随机结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = longComputation(1)
def y = longComputation(1)
assert x!=y</code></pre>
</div>
</div>
<div class="paragraph">
<p>新增中<code>@Memoized</code>根据参数，通过添加缓存来更改方法的语义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Memoized
long longComputation(int seed) {
    // slow computation
    Thread.sleep(100*seed)
    System.nanoTime()
}

def x = longComputation(1) // returns after 100 milliseconds
def y = longComputation(1) // returns immediatly
def z = longComputation(2) // returns after 200 milliseconds
assert x==y
assert x!=z</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用两个可选参数配置缓存的大小：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>protectedCacheSize</em> ：保证垃圾收集后不会清除的结果数</p>
</li>
<li>
<p><em>maxCacheSize</em> ：可以保存在内存中的最大结果数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，缓存的大小是无限的，并且不会保护任何缓存结果免受垃圾回收。设置<em>protectedCacheSize> 0</em>将创建无限缓存，并保护某些结果。将<em>maxCacheSize> 0</em>设置将创建有限的缓存，但没有任何垃圾保护措施。同时设置两者将创建受限制的受保护缓存。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-TailRecursive"><a class="anchor" href="#xform-TailRecursive"></a><code>@groovy.transform.TailRecursive</code></h5>
<div class="paragraph">
<p>的<code>@TailRecursive</code>批注可用于将方法末尾的递归调用自动转换为同一代码的等效迭代版本。这避免了由于过多的递归调用而导致的堆栈溢出。以下是计算阶乘时的使用示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.CompileStatic
import groovy.transform.TailRecursive

@CompileStatic
class Factorial {

    @TailRecursive
    static BigInteger factorial( BigInteger i, BigInteger product = 1) {
        if( i == 1) {
            return product
        }
        return factorial(i-1, product*i)
    }
}

assert Factorial.factorial(1) == 1
assert Factorial.factorial(3) == 6
assert Factorial.factorial(5) == 120
assert Factorial.factorial(50000).toString().size() == 213237 // Big number and no Stack Overflow</code></pre>
</div>
</div>
<div class="paragraph">
<p>当前，注释仅适用于自递归方法调用，即再次对完全相同的方法进行单个递归调用。考虑使用闭包和<code>trampoline()</code>如果您有涉及简单相互递归的方案。还要注意，当前仅处理非void方法（void调用将导致编译错误）。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">当前，某些形式的方法重载可以欺骗编译器，并且某些非尾递归调用被错误地视为尾递归。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="xform-Singleton"><a class="anchor" href="#xform-Singleton"></a><code>@groovy.lang.Singleton</code></h5>
<div class="paragraph">
<p>的<code>@Singleton</code>批注可用于在类上实现单例设计模式。默认情况下，使用类初始化来预先定义单例实例，或者使用惰性检查来定义单例实例，在这种情况下，使用双重检查锁定来初始化字段。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Singleton
class GreetingService {
    String greeting(String name) { "Hello, $name!" }
}
assert GreetingService.instance.greeting('Bob') == 'Hello, Bob!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，当初始化类并通过<code>instance</code>属性。可以使用来更改单例的名称<code>property</code>参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Singleton(property='theOne')
class GreetingService {
    String greeting(String name) { "Hello, $name!" }
}

assert GreetingService.theOne.greeting('Bob') == 'Hello, Bob!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用<code>lazy</code>参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Collaborator {
    public static boolean init = false
}
@Singleton(lazy=true,strict=false)
class GreetingService {
    static void init() {}
    GreetingService() {
        Collaborator.init = true
    }
    String greeting(String name) { "Hello, $name!" }
}
GreetingService.init() // make sure class is initialized
assert Collaborator.init == false
GreetingService.instance
assert Collaborator.init == true
assert GreetingService.instance.greeting('Bob') == 'Hello, Bob!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们还设置了<code>strict</code>参数为false，这使我们可以定义自己的构造函数。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Mixin"><a class="anchor" href="#xform-Mixin"></a><code>@groovy.lang.Mixin</code></h5>
<div class="paragraph">
<p>不推荐使用。考虑改用特征。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_logging_improvements"><a class="anchor" href="#_logging_improvements"></a> 2.1.3。记录改进</h4>
<div class="paragraph">
<p>Groovy提供AST转换，可帮助与最广泛使用的日志记录框架集成。值得注意的是，使用这些注释之一对类进行注释并不会阻止您在类路径上添加适当的日志记录框架。</p>
</div>
<div class="paragraph">
<p>所有转换都以类似的方式工作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加静态最终<code>log</code>记录器对应的字段</p>
</li>
<li>
<p>将所有呼叫包装到<code>log.level()</code>放入适当的<code>log.isLevelEnabled</code>保护，取决于基础框架</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些转换支持两个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value</code> （默认<code>log</code> ）对应于记录器字段的名称</p>
</li>
<li>
<p><code>category</code> （默认为类名称）是记录器类别的名称</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="xform-Log"><a class="anchor" href="#xform-Log"></a><code>@groovy.util.logging.Log</code></h5>
<div class="paragraph">
<p>可用的第一个日志AST转换是<code>@Log</code>注释依赖于JDK日志记录框架。写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Log
class Greeter {
    void greet() {
        log.info 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等同于写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.util.logging.Level
import java.util.logging.Logger

class Greeter {
    private static final Logger log = Logger.getLogger(Greeter.name)
    void greet() {
        if (log.isLoggable(Level.INFO)) {
            log.info 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Commons"><a class="anchor" href="#xform-Commons"></a><code>@groovy.util.logging.Commons</code></h5>
<div class="paragraph">
<p>Groovy支持将<a href="http://commons.apache.org/proper/commons-logging/">Apache Commons Logging</a>框架用于<code>@Commons</code>注解。写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Commons
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等同于写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.apache.commons.logging.LogFactory
import org.apache.commons.logging.Log

class Greeter {
    private static final Log log = LogFactory.getLog(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Log4j"><a class="anchor" href="#xform-Log4j"></a><code>@groovy.util.logging.Log4j</code></h5>
<div class="paragraph">
<p>Groovy支持将<a href="http://logging.apache.org/log4j/1.2/">Apache Log4j 1.x</a>框架用于<code>@Log4j</code>注解。写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Log4j
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等同于写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.apache.log4j.Logger

class Greeter {
    private static final Logger log = Logger.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Log4j2"><a class="anchor" href="#xform-Log4j2"></a><code>@groovy.util.logging.Log4j2</code></h5>
<div class="paragraph">
<p>Groovy支持将<a href="http://logging.apache.org/log4j/2.x/">Apache Log4j 2.x</a>框架用于<code>@Log4j2</code>注解。写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Log4j2
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等同于写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.apache.logging.log4j.LogManager
import org.apache.logging.log4j.Logger

class Greeter {
    private static final Logger log = LogManager.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Slf4j"><a class="anchor" href="#xform-Slf4j"></a><code>@groovy.util.logging.Slf4j</code></h5>
<div class="paragraph">
<p>Groovy支持<a href="http://www.slf4j.org/">用于Java</a>的<a href="http://www.slf4j.org/">简单日志记录（SLF4J）</a>框架，该框架用于<code>@Slf4j</code>注解。写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Slf4j
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等同于写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.slf4j.LoggerFactory
import org.slf4j.Logger

class Greeter {
    private static final Logger log = LoggerFactory.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_declarative_concurrency"><a class="anchor" href="#_declarative_concurrency"></a> 2.1.4。声明式并发</h4>
<div class="paragraph">
<p>Groovy语言提供了一组注释，旨在以声明的方式简化常见的并发模式。</p>
</div>
<div class="sect4">
<h5 id="xform-Synchronized"><a class="anchor" href="#xform-Synchronized"></a><code>@groovy.transform.Synchronized</code></h5>
<div class="paragraph">
<p>的<code>@Synchronized</code> AST转换的工作方式与<code>synchronized</code>关键字，但锁定不同的对象以获得更安全的并发性。它可以应用于任何方法或静态方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Synchronized

import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class Counter {
    int cpt
    @Synchronized
    int incrementAndGet() {
        cpt++
    }
    int get() {
        cpt
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>编写此代码等效于创建一个锁对象并将整个方法包装到一个同步块中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Counter {
    int cpt
    private final Object $lock = new Object()

    int incrementAndGet() {
        synchronized($lock) {
            cpt++
        }
    }
    int get() {
        cpt
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>@Synchronized</code>创建一个名为<code>$lock</code> （要么<code>$LOCK</code> （适用于静态方法），但可以通过指定value属性使其使用所需的任何字段，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Synchronized

import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class Counter {
    int cpt
    private final Object myLock = new Object()

    @Synchronized('myLock')
    int incrementAndGet() {
        cpt++
    }
    int get() {
        cpt
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-WithReadLock"><a class="anchor" href="#xform-WithReadLock"></a><code>@groovy.transform.WithReadLock</code>和<code>@groovy.transform.WithWriteLock</code></h5>
<div class="paragraph">
<p>的<code>@WithReadLock</code> AST转换与<code>@WithWriteLock</code>转换以使用以下命令提供读/写同步<code>ReentrantReadWriteLock</code> JDK提供的功能。注释可以添加到方法或静态方法中。它将透明地创建一个<code>$reentrantLock</code>最终字段（或<code>$REENTRANTLOCK</code> （对于静态方法），并将添加适当的同步代码。例如，以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.WithReadLock
import groovy.transform.WithWriteLock

class Counters {
    public final Map&lt;String,Integer&gt; map = [:].withDefault { 0 }

    @WithReadLock
    int get(String id) {
        map.get(id)
    }

    @WithWriteLock
    void add(String id, int num) {
        Thread.sleep(200) // emulate long computation
        map.put(id, map.get(id)+num)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等效于此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.WithReadLock as WithReadLock
import groovy.transform.WithWriteLock as WithWriteLock

public class Counters {

    private final Map&lt;String, Integer&gt; map
    private final java.util.concurrent.locks.ReentrantReadWriteLock $reentrantlock

    public int get(java.lang.String id) {
        $reentrantlock.readLock().lock()
        try {
            map.get(id)
        }
        finally {
            $reentrantlock.readLock().unlock()
        }
    }

    public void add(java.lang.String id, int num) {
        $reentrantlock.writeLock().lock()
        try {
            java.lang.Thread.sleep(200)
            map.put(id, map.get(id) + num )
        }
        finally {
            $reentrantlock.writeLock().unlock()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>都<code>@WithReadLock</code>和<code>@WithWriteLock</code>支持指定备用锁定对象。在这种情况下，引用字段必须由用户声明，如以下替代方法所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.WithReadLock
import groovy.transform.WithWriteLock

import java.util.concurrent.locks.ReentrantReadWriteLock

class Counters {
    public final Map&lt;String,Integer&gt; map = [:].withDefault { 0 }
    private final ReentrantReadWriteLock customLock = new ReentrantReadWriteLock()

    @WithReadLock('customLock')
    int get(String id) {
        map.get(id)
    }

    @WithWriteLock('customLock')
    void add(String id, int num) {
        Thread.sleep(200) // emulate long computation
        map.put(id, map.get(id)+num)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>详情</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有关<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/WithReadLock.html">groovy.transform的信息，请参见Javadoc </a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/WithReadLock.html">。WithReadLock</a></p>
</li>
<li>
<p>有关<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/WithWriteLock.html">groovy.transform的信息，请参见Javadoc </a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/WithWriteLock.html">。WithWriteLock</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_easier_cloning_and_externalizing"><a class="anchor" href="#_easier_cloning_and_externalizing"></a> 2.1.5。轻松克隆和外化</h4>
<div class="paragraph">
<p>Groovy提供了两个注释，目的是促进实施<code>Cloneable</code>和<code>Externalizable</code>接口，分别命名<code>@AutoClone</code>和<code>@AutoExternalize</code> 。</p>
</div>
<div class="sect4">
<h5 id="xform-AutoClone"><a class="anchor" href="#xform-AutoClone"></a><code>@groovy.transform.AutoClone</code></h5>
<div class="paragraph">
<p>的<code>@AutoClone</code>注释旨在实现<code>@java.lang.Cloneable</code>界面使用各种策略，这要归功于<code>style</code>参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>默认值<code>AutoCloneStyle.CLONE</code>战略召唤<code>super.clone()</code>首先<code>clone()</code>在每个可克隆属性上</p>
</li>
<li>
<p>的<code>AutoCloneStyle.SIMPLE</code>策略使用常规的构造函数调用并将属性从源复制到克隆</p>
</li>
<li>
<p>的<code>AutoCloneStyle.COPY_CONSTRUCTOR</code>策略创建并使用副本构造函数</p>
</li>
<li>
<p>的<code>AutoCloneStyle.SERIALIZATION</code>策略使用序列化（或外部化）来克隆对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每种策略都有其优缺点，在Javadoc中针对<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/AutoClone.html">groovy.transform进行了讨论</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/AutoClone.html">。AutoClone</a>和<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/AutoCloneStyle.html">groovy.transform。AutoCloneStyle</a> 。</p>
</div>
<div class="paragraph">
<p>例如，以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoClone

@AutoClone
class Book {
    String isbn
    String title
    List&lt;String&gt; authors
    Date publicationDate
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等效于此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book implements Cloneable {
    String isbn
    String title
    List&lt;String&gt; authors
    Date publicationDate

    public Book clone() throws CloneNotSupportedException {
        Book result = super.clone()
        result.authors = authors instanceof Cloneable ? (List) authors.clone() : authors
        result.publicationDate = publicationDate.clone()
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，未明确处理String属性，因为String是不可变的，并且<code>clone()</code>来自的方法<code>Object</code>将复制字符串引用。这同样适用于原始字段和大多数的具体子类<code>java.lang.Number</code> 。</p>
</div>
<div class="paragraph">
<p>除了克隆样式之外， <code>@AutoClone</code>支持多种选择：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">排除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空清单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">需要从克隆中排除的属性或字段名称的列表。也可以使用由逗号分隔的字段/属性名称组成的字符串。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/AutoClone.html#excludes">groovy.transform。AutoClone＃排除</a>详细信息</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoClone
import groovy.transform.AutoCloneStyle

@AutoClone(style=AutoCloneStyle.SIMPLE,excludes='authors')
class Book {
    String isbn
    String title
    List authors
    Date publicationDate
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下，仅克隆属性。将此标志设置为true还将克隆字段。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoClone
import groovy.transform.AutoCloneStyle

@AutoClone(style=AutoCloneStyle.SIMPLE,includeFields=true)
class Book {
    String isbn
    String title
    List authors
    protected Date publicationDate
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-AutoExternalize"><a class="anchor" href="#xform-AutoExternalize"></a><code>@groovy.transform.AutoExternalize</code></h5>
<div class="paragraph">
<p>的<code>@AutoExternalize</code> AST转型将有助于创建<code>java.io.Externalizable</code>类。它将自动将接口添加到类并生成<code>writeExternal</code>和<code>readExternal</code>方法。例如，此代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoExternalize

@AutoExternalize
class Book {
    String isbn
    String title
    float price
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将转换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book implements java.io.Externalizable {
    String isbn
    String title
    float price

    void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(isbn)
        out.writeObject(title)
        out.writeFloat( price )
    }

    public void readExternal(ObjectInput oin) {
        isbn = (String) oin.readObject()
        title = (String) oin.readObject()
        price = oin.readFloat()
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@AutoExternalize</code>注释支持两个参数，这些参数使您可以稍微自定义其行为：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">排除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空清单</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">需要从外部化中排除的属性或字段名称的列表。也可以使用由逗号分隔的字段/属性名称组成的字符串。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/AutoExternalize.html#excludes">groovy.transform。AutoExternalize＃排除</a>详细信息</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoExternalize

@AutoExternalize(excludes='price')
class Book {
    String isbn
    String title
    float price
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下，仅属性是外部化的。将此标志设置为true还将克隆字段。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoExternalize

@AutoExternalize(includeFields=true)
class Book {
    String isbn
    String title
    protected float price
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_safer_scripting"><a class="anchor" href="#_safer_scripting"></a> 2.1.6。更安全的脚本</h4>
<div class="paragraph">
<p>Groovy语言使运行时易于执行用户脚本（例如，使用<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/lang/GroovyShell.html">groovy.lang。GroovyShell</a> ），但是如何确保脚本不会耗尽所有CPU（无限循环）或并发脚本不会慢慢消耗线程池中的所有可用线程呢？Groovy提供了一些注释，这些注释旨在实现更安全的脚本编制，例如生成代码，这些代码将使您可以自动中断执行。</p>
</div>
<div class="sect4">
<h5 id="xform-ThreadInterrupt"><a class="anchor" href="#xform-ThreadInterrupt"></a><code>@groovy.transform.ThreadInterrupt</code></h5>
<div class="paragraph">
<p>JVM世界中的一种复杂情况是无法停止线程。的<code>Thread#stop</code>方法存在，但已被弃用（并且不可靠），因此您唯一的机会取决于<code>Thread#interrupt</code> 。调用后者将设置<code>interrupt</code>线程上的标志，但<strong>不会</strong>停止线程的执行。这是有问题的，因为在线程中执行的代码有责任检查中断标志并正确退出。当您作为开发人员知道要执行的代码是要在独立线程中运行的，但是总的来说，您却不知道它时，这是有道理的。使用用户脚本甚至更糟，他们甚至可能不知道线程是什么（想想DSL）。</p>
</div>
<div class="paragraph">
<p><code>@ThreadInterrupt</code>通过在代码中的关键位置添加线程中断检查来简化此操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>循环（一段时间）</p>
</li>
<li>
<p>方法的第一条指令</p>
</li>
<li>
<p>封闭体的第一条说明</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们想象以下用户脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">while (true) {
    i++
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个明显的无限循环。如果此代码在其自己的线程中执行，则中断将无济于事： <code>join</code>在线程上，则调用代码将能够继续，但是该线程仍将处于活动状态，并且在后台运行，而您没有任何能力停止它，从而缓慢地导致线程饥饿。</p>
</div>
<div class="paragraph">
<p>解决此问题的一种可能性是通过以下方式设置您的shell：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(ThreadInterrupt)
)
def binding = new Binding(i:0)
def shell = new GroovyShell(binding,config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将外壳配置为自动应用<code>@ThreadInterrupt</code>所有脚本上的AST转换。这使您可以通过以下方式执行用户脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(1000) // give at most 1000ms for the script to complete
if (t.alive) {
    t.interrupt()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>转换会自动修改用户代码，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">while (true) {
    if (Thread.currentThread().interrupted) {
        throw new InterruptedException('The current thread has been interrupted.')
    }
    i++
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环内引入的检查可以确保<code>interrupt</code>如果在当前线程上设置了标志，则会引发异常，从而中断线程的执行。</p>
</div>
<div class="paragraph">
<p><code>@ThreadInterrupt</code>支持多个选项，这些选项使您可以进一步自定义转换的行为：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">抛出</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.InterruptedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定在线程中断时引发的异常类型。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BadException extends Exception {
    BadException(String message) { super(message) }
}

def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(thrown:BadException, ThreadInterrupt)
)
def binding = new Binding(i:0)
def shell = new GroovyShell(this.class.classLoader,binding,config)

def userCode = """
try {
    while (true) {
        i++
    }
} catch (BadException e) {
    i = -1
}
"""

def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(1000) // give at most 1s for the script to complete
assert binding.i &gt; 0
if (t.alive) {
    t.interrupt()
}
Thread.sleep(500)
assert binding.i == -1'''</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkOnMethodStart</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应在每个方法正文的开头插入中断检查。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/ThreadInterrupt.html">groovy.transform。有关详细信息，请参见ThreadInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ThreadInterrupt(checkOnMethodStart=false)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllClasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换应应用于同一源单元的所有类（在同一源文件中）。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/ThreadInterrupt.html">groovy.transform。有关详细信息，请参见ThreadInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ThreadInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllMembers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换是否应该应用于所有班级成员。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/ThreadInterrupt.html">groovy.transform。有关详细信息，请参见ThreadInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A {
    @ThreadInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-TimedInterrupt"><a class="anchor" href="#xform-TimedInterrupt"></a><code>@groovy.transform.TimedInterrupt</code></h5>
<div class="paragraph">
<p>的<code>@TimedInterrupt</code> AST转换试图解决与<a href="#xform-ThreadInterrupt"><code>@groovy.transform.ThreadInterrupt</code></a> ：而不是检查<code>interrupt</code>标记，如果线程运行时间过长，它将自动引发异常。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此批注<strong>没有</strong>产生一个监测线程。相反，它的工作方式与<code>@ThreadInterrupt</code>通过将检查放在代码中的适当位置。这意味着，如果您有一个被I / O阻塞的线程，它将<strong>不会</strong>被中断。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>想象以下用户代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def fib(int n) { n&lt;2?n:fib(n-1)+fib(n-2) }

result = fib(600)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里著名的斐波那契数计算的实现远非最佳。如果叫高<code>n</code>值，可能要花几分钟才能回答。用<code>@TimedInterrupt</code> ，您可以选择允许脚本运行多长时间。以下设置代码将允许用户脚本最多运行1秒钟：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(value:1, TimedInterrupt)
)
def binding = new Binding(result:0)
def shell = new GroovyShell(this.class.classLoader, binding,config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码等效于用<code>@TimedInterrupt</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(value=1, unit=TimeUnit.SECONDS)
class MyClass {
    def fib(int n) {
        n&lt;2?n:fib(n-1)+fib(n-2)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@TimedInterrupt</code>支持多个选项，这些选项使您可以进一步自定义转换的行为：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长。MAX_VALUE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与...结合使用<code>unit</code>指定执行超时后的时间。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(value=500L, unit= TimeUnit.MILLISECONDS, applyToAllClasses = false)
class Slow {
    def fib(n) { n&lt;2?n:fib(n-1)+fib(n-2) }
}
def result
def t = Thread.start {
    result = new Slow().fib(500)
}
t.join(5000)
assert result == null
assert !t.alive</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">单元</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TimeUnit。秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与...结合使用<code>value</code>指定执行超时后的时间。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(value=500L, unit= TimeUnit.MILLISECONDS, applyToAllClasses = false)
class Slow {
    def fib(n) { n&lt;2?n:fib(n-1)+fib(n-2) }
}
def result
def t = Thread.start {
    result = new Slow().fib(500)
}
t.join(5000)
assert result == null
assert !t.alive</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">抛出</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.concurrent.TimeoutException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定在达到超时时引发的异常类型。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(thrown=TooLongException, applyToAllClasses = false, value=1L)
class Slow {
    def fib(n) { Thread.sleep(100); n&lt;2?n:fib(n-1)+fib(n-2) }
}
def result
def t = Thread.start {
    try {
        result = new Slow().fib(50)
    } catch (TooLongException e) {
        result = -1
    }
}
t.join(5000)
assert result == -1</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkOnMethodStart</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应在每个方法正文的开头插入中断检查。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/TimedInterrupt.html">groovy.transform。有关详细信息，请参见TimedInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(checkOnMethodStart=false)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllClasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换应应用于同一源单元的所有类（在同一源文件中）。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/TimedInterrupt.html">groovy.transform。有关详细信息，请参见TimedInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllMembers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换是否应该应用于所有班级成员。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/TimedInterrupt.html">groovy.transform。有关详细信息，请参见TimedInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A {
    @TimedInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<code>@TimedInterrupt</code>当前与静态方法不兼容！
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="xform-ConditionalInterrupt"><a class="anchor" href="#xform-ConditionalInterrupt"></a><code>@groovy.transform.ConditionalInterrupt</code></h5>
<div class="paragraph">
<p>要使用自定义策略中断脚本时，最安全的脚本编写方法的最后一个注释是基本注释。特别是，如果要使用资源管理（限制对API的调用次数，...），这是选择的注释。在下面的示例中，用户代码使用了无限循环，但是<code>@ConditionalInterrupt</code>将允许我们检查配额管理器并自动中断脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt({Quotas.disallow('user')})
class UserCode {
    void doSomething() {
        int i=0
        while (true) {
            println "Consuming resources ${++i}"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>配额检查在这里非常基本，但是可以是任何代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Quotas {
    static def quotas = [:].withDefault { 10 }
    static boolean disallow(String userName) {
        println "Checking quota for $userName"
        (quotas[userName]--)&lt;0
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以确保<code>@ConditionalInterrupt</code>使用以下测试代码即可正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert Quotas.quotas['user'] == 10
def t = Thread.start {
    new UserCode().doSomething()
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] &lt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，实际上，不太可能<code>@ConditionalInterrupt</code>将自己手动添加到用户代码上。可以使用<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/control/customizers/ASTTransformationCustomizer.html">org.codehaus.groovy.control.customizers以类似于</a><a href="#xform-ThreadInterrupt">ThreadInterrupt</a>部分中所示示例的方式注入它<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/control/customizers/ASTTransformationCustomizer.html">。ASTTransformationCustomizer</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
def checkExpression = new ClosureExpression(
        Parameter.EMPTY_ARRAY,
        new ExpressionStatement(
                new MethodCallExpression(new ClassExpression(ClassHelper.make(Quotas)), 'disallow', new ConstantExpression('user'))
        )
)
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(value: checkExpression, ConditionalInterrupt)
)

def shell = new GroovyShell(this.class.classLoader,new Binding(),config)

def userCode = """
        int i=0
        while (true) {
            println "Consuming resources \\${++i}"
        }
"""

assert Quotas.quotas['user'] == 10
def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] &lt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ConditionalInterrupt</code>支持多个选项，这些选项使您可以进一步自定义转换的行为：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">值</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该闭包将被调用以检查是否允许执行。如果闭包返回false，则允许执行。如果返回true，则将引发异常。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt({ ... })</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">抛出</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.InterruptedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定如果中止执行将引发的异常类型。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
        new ASTTransformationCustomizer(thrown: QuotaExceededException,value: checkExpression, ConditionalInterrupt)
)
assert Quotas.quotas['user'] == 10
def t = Thread.start {
    try {
        shell.evaluate(userCode)
    } catch (QuotaExceededException) {
        Quotas.quotas['user'] = 'Quota exceeded'
    }
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] == 'Quota exceeded'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkOnMethodStart</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应在每个方法正文的开头插入中断检查。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html">groovy.transform。有关详细信息，请参阅ConditionalInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt(checkOnMethodStart=false)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllClasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换应应用于同一源单元的所有类（在同一源文件中）。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html">groovy.transform。有关详细信息，请参阅ConditionalInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllMembers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换是否应该应用于所有班级成员。参见<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html">groovy.transform。有关详细信息，请参阅ConditionalInterrupt</a> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A {
    @ConditionalInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_compiler_directives"><a class="anchor" href="#_compiler_directives"></a> 2.1.7。编译器指令</h4>
<div class="paragraph">
<p>这种AST转换类别将对代码的语义有直接影响的注释分组，而不是专注于代码生成。因此，它们可以看作是编译器指令，可以在编译时或运行时更改程序的行为。</p>
</div>
<div class="sect4">
<h5 id="xform-Field"><a class="anchor" href="#xform-Field"></a><code>@groovy.transform.Field</code></h5>
<div class="paragraph">
<p>的<code>@Field</code>注解仅在脚本的上下文中才有意义，并且旨在解决脚本的常见范围错误。例如，以下示例将在运行时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x

String line() {
    "="*x
}

x=3
assert "===" == line()
x=5
assert "=====" == line()</code></pre>
</div>
</div>
<div class="paragraph">
<p>抛出的错误可能很难解释：groovy.lang。MissingPropertyException：没有此类属性：x。原因是脚本被编译为类，脚本主体本身被编译为单个<em>run（）</em>方法。脚本中定义的方法是独立的，因此上面的代码等效于此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyScript extends Script {

    String line() {
        "="*x
    }

    public def run() {
        def x
        x=3
        assert "===" == line()
        x=5
        assert "=====" == line()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以<code>def x</code>有效地解释为局部变量，超出了<code>line</code>方法。的<code>@Field</code> AST转换旨在通过将变量的范围更改为封闭脚本的字段来解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Field def x

String line() {
    "="*x
}

x=3
assert "===" == line()
x=5
assert "=====" == line()</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在产生的等效代码为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyScript extends Script {

    def x

    String line() {
        "="*x
    }

    public def run() {
        x=3
        assert "===" == line()
        x=5
        assert "=====" == line()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-PackageScope"><a class="anchor" href="#xform-PackageScope"></a><code>@groovy.transform.PackageScope</code></h5>
<div class="paragraph">
<p>默认情况下，Groovy可见性规则意味着如果创建一个字段时未指定修饰符，则该字段将被解释为属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name // this is a property
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您要创建一个包私有字段而不是一个属性（私有字段+ getter / setter），请使用以下注释字段<code>@PackageScope</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    @PackageScope String name // not a property anymore
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@PackageScope</code>注解也可以用于类，方法和构造函数。另外，通过指定<code>PackageScopeTarget</code>值作为类级别的注释属性，该类中所有没有显式修饰符且与提供的成员匹配的成员<code>PackageScopeTarget</code>将保持受包装保护。例如，要应用于类中的字段，请使用以下注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static groovy.transform.PackageScopeTarget.FIELDS
@PackageScope(FIELDS)
class Person {
  String name     // not a property, package protected
  Date dob        // not a property, package protected
  private int age // explicit modifier, so won't be touched
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@PackageScope</code>注释很少用作常规Groovy约定的一部分，但有时对于在包内部应可见的工厂方法，为测试目的提供的方法或构造函数或与需要此类可见性约定的第三方库集成时，有时很有用。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-AutoFinal"><a class="anchor" href="#xform-AutoFinal"></a><code>@groovy.transform.AutoFinal</code></h5>
<div class="paragraph">
<p>的<code>@AutoFinal</code>注解指示编译器将最终修饰符自动插入到带注释的节点内的许多位置。如果应用于方法（或构造函数），则该方法（或构造函数）的参数将标记为final。如果应用于类定义，则该类中所有声明的方法和构造函数都将进行相同的处理。</p>
</div>
<div class="paragraph">
<p>将方法或构造函数的参数重新分配给它的主体通常被认为是不好的做法。通过将final修饰符添加到所有参数声明中，您可以完全避免这种做法。一些程序员认为，在所有位置添加final会增加样板代码的数量，并使方法签名有些嘈杂。相反，替代方案可能是使用代码检查过程或应用<a href="http://codenarc.org">Codenarc</a> <a href="http://codenarc.sourceforge.net/codenarc-rules-convention.html#ParameterReassignment">规则</a>来发出警告（如果遵守该惯例），但是这些替代方案可能导致质量检查期间（而不是在IDE中或在编译过程中）延迟反馈。的<code>@AutoFinal</code>注解旨在最大程度地提高编译器/ IDE的反馈，同时保持简洁的代码并减少样板噪声。</p>
</div>
<div class="paragraph">
<p>以下示例说明了在类级别应用注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoFinal

@AutoFinal
class Person {
    private String first, last

    Person(String first, String last) {
        this.first = first
        this.last = last
    }

    String fullName(String separator) {
        "$first$separator$last"
    }

    String greeting(String salutation) {
        "$salutation, $first"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，构造函数的两个参数和构造函数的单个参数<code>fullname</code>和<code>greeting</code>方法将是最终的。尝试在构造函数或方法体内修改这些参数的操作将由编译器标记。</p>
</div>
<div class="paragraph">
<p>以下示例说明了在方法级别应用注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calc {
    @AutoFinal
    int add(int a, int b) { a + b }

    int mult(int a, int b) { a * b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里<code>add</code>方法将具有最终参数，但<code>mult</code>方法将保持不变。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-AnnotationCollector"><a class="anchor" href="#xform-AnnotationCollector"></a><code>@groovy.transform.AnnotationCollector</code></h5>
<div class="paragraph">
<p><code>@AnnotationCollector</code>允许创建元注释，这将在<a href="#meta-annotations">专用部分中介绍</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-TypeChecked"><a class="anchor" href="#xform-TypeChecked"></a><code>@groovy.transform.TypeChecked</code></h5>
<div class="paragraph">
<p><code>@TypeChecked</code>在您的Groovy代码上激活编译时类型检查。有关详细信息，请参见<a href="#section-typechecked">类型检查部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-CompileStatic"><a class="anchor" href="#xform-CompileStatic"></a><code>@groovy.transform.CompileStatic</code></h5>
<div class="paragraph">
<p><code>@CompileStatic</code>在您的Groovy代码上激活静态编译。有关详细信息，请参见<a href="#section-typechecked">类型检查部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-CompileDynamic"><a class="anchor" href="#xform-CompileDynamic"></a><code>@groovy.transform.CompileDynamic</code></h5>
<div class="paragraph">
<p><code>@CompileDynamic</code>在Groovy代码的某些部分上禁用静态编译。有关详细信息，请参见<a href="#section-typechecked">类型检查部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-DelegatesTo"><a class="anchor" href="#xform-DelegatesTo"></a><code>@groovy.lang.DelegatesTo</code></h5>
<div class="paragraph">
<p><code>@DelegatesTo</code>从技术上讲，它不是AST转换。它旨在记录代码并在使用<a href="#xform-TypeChecked">类型检查</a>或<a href="#xform-CompileStatic">静态编译的</a>情况下为编译器提供帮助。该注释在本指南的<a href="#section-delegatesto">DSL部分中</a>进行了详细说明。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-SelfType"><a class="anchor" href="#xform-SelfType"></a><code>@groovy.transform.SelfType</code></h5>
<div class="paragraph">
<p><code>@SelfType</code>不是AST转换，而是与特征一起使用的标记接口。请参阅<a href="#traits-selftype">特征文档</a>以获取更多详细信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_swing_patterns"><a class="anchor" href="#_swing_patterns"></a> 2.1.8。摇摆模式</h4>
<div class="sect4">
<h5 id="xform-Bindable"><a class="anchor" href="#xform-Bindable"></a><code>@groovy.beans.Bindable</code></h5>
<div class="paragraph">
<p><code>@Bindable</code>是AST转换，它将常规属性转换为绑定属性（根据<a href="http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans规范</a> ）。的<code>@Bindable</code>注释可以放在属性或类上。要将类的所有属性转换为绑定属性，可以像下面的示例一样在on上注释类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Bindable

@Bindable
class Person {
    String name
    int age
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这等效于编写此代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.beans.PropertyChangeListener
import java.beans.PropertyChangeSupport

class Person {
    final private PropertyChangeSupport this$propertyChangeSupport

    String name
    int age

    public void addPropertyChangeListener(PropertyChangeListener listener) {
        this$propertyChangeSupport.addPropertyChangeListener(listener)
    }

    public void addPropertyChangeListener(String name, PropertyChangeListener listener) {
        this$propertyChangeSupport.addPropertyChangeListener(name, listener)
    }

    public void removePropertyChangeListener(PropertyChangeListener listener) {
        this$propertyChangeSupport.removePropertyChangeListener(listener)
    }

    public void removePropertyChangeListener(String name, PropertyChangeListener listener) {
        this$propertyChangeSupport.removePropertyChangeListener(name, listener)
    }

    public void firePropertyChange(String name, Object oldValue, Object newValue) {
        this$propertyChangeSupport.firePropertyChange(name, oldValue, newValue)
    }

    public PropertyChangeListener[] getPropertyChangeListeners() {
        return this$propertyChangeSupport.getPropertyChangeListeners()
    }

    public PropertyChangeListener[] getPropertyChangeListeners(String name) {
        return this$propertyChangeSupport.getPropertyChangeListeners(name)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Bindable</code>因此从您的课程中删除了很多样板，大大提高了可读性。如果注释放在单个属性上，则仅绑定该属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Bindable

class Person {
    String name
    @Bindable int age
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-ListenerList"><a class="anchor" href="#xform-ListenerList"></a><code>@groovy.beans.ListenerList</code></h5>
<div class="paragraph">
<p>的<code>@ListenerList</code> AST转换仅通过注释集合属性即可生成用于添加，删除和获取类的侦听器列表的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.awt.event.ActionListener
import groovy.beans.ListenerList

class Component {
    @ListenerList
    List&lt;ActionListener&gt; listeners;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>转换将基于列表的通用类型生成适当的添加/删除方法。此外，它还将创建<code>fireXXX</code>基于在类上声明的公共方法的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.awt.event.ActionEvent
import java.awt.event.ActionListener as ActionListener
import groovy.beans.ListenerList as ListenerList

public class Component {

    @ListenerList
    private List&lt;ActionListener&gt; listeners

    public void addActionListener(ActionListener listener) {
        if ( listener == null) {
            return
        }
        if ( listeners == null) {
            listeners = []
        }
        listeners.add(listener)
    }

    public void removeActionListener(ActionListener listener) {
        if ( listener == null) {
            return
        }
        if ( listeners == null) {
            listeners = []
        }
        listeners.remove(listener)
    }

    public ActionListener[] getActionListeners() {
        Object __result = []
        if ( listeners != null) {
            __result.addAll(listeners)
        }
        return (( __result ) as ActionListener[])
    }

    public void fireActionPerformed(ActionEvent param0) {
        if ( listeners != null) {
            ArrayList&lt;ActionListener&gt; __list = new ArrayList&lt;ActionListener&gt;(listeners)
            for (def listener : __list ) {
                listener.actionPerformed(param0)
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Bindable</code>支持多个选项，这些选项使您可以进一步自定义转换的行为：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通用类型名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下，将添加到add / remove / ...方法的后缀是列表通用类型的简单类名。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Component {
    @ListenerList(name='item')
    List&lt;ActionListener&gt; listeners;
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">同步化</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置为true，则生成的方法将被同步</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Component {
    @ListenerList(synchronize = true)
    List&lt;ActionListener&gt; listeners;
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Vetoable"><a class="anchor" href="#xform-Vetoable"></a><code>@groovy.beans.Vetoable</code></h5>
<div class="paragraph">
<p>的<code>@Vetoable</code>注释的工作方式与<code>@Bindable</code>但会根据JavaBeans规范生成受约束的属性，而不是绑定属性。注释可以放在一个类上，这意味着所有属性都将转换为受约束的属性，也可以放在单个属性上。例如，用<code>@Vetoable</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Vetoable

import java.beans.PropertyVetoException
import java.beans.VetoableChangeListener

@Vetoable
class Person {
    String name
    int age
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等效于编写此代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class Person {

    private String name
    private int age
    final private java.beans.VetoableChangeSupport this$vetoableChangeSupport

    public void addVetoableChangeListener(VetoableChangeListener listener) {
        this$vetoableChangeSupport.addVetoableChangeListener(listener)
    }

    public void addVetoableChangeListener(String name, VetoableChangeListener listener) {
        this$vetoableChangeSupport.addVetoableChangeListener(name, listener)
    }

    public void removeVetoableChangeListener(VetoableChangeListener listener) {
        this$vetoableChangeSupport.removeVetoableChangeListener(listener)
    }

    public void removeVetoableChangeListener(String name, VetoableChangeListener listener) {
        this$vetoableChangeSupport.removeVetoableChangeListener(name, listener)
    }

    public void fireVetoableChange(String name, Object oldValue, Object newValue) throws PropertyVetoException {
        this$vetoableChangeSupport.fireVetoableChange(name, oldValue, newValue)
    }

    public VetoableChangeListener[] getVetoableChangeListeners() {
        return this$vetoableChangeSupport.getVetoableChangeListeners()
    }

    public VetoableChangeListener[] getVetoableChangeListeners(String name) {
        return this$vetoableChangeSupport.getVetoableChangeListeners(name)
    }

    public void setName(String value) throws PropertyVetoException {
        this.fireVetoableChange('name', name, value)
        name = value
    }

    public void setAge(int value) throws PropertyVetoException {
        this.fireVetoableChange('age', age, value)
        age = value
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果注释放在单个属性上，则仅将该属性设置为可否决的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Vetoable

class Person {
    String name
    @Vetoable int age
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_test_assistance"><a class="anchor" href="#_test_assistance"></a> 2.1.9。测试协助</h4>
<div class="sect4">
<h5 id="xform-NotYetImplemented"><a class="anchor" href="#xform-NotYetImplemented"></a><code>@groovy.test.NotYetImplemented</code></h5>
<div class="paragraph">
<p><code>@NotYetImplemented</code>用于反转JUnit 3/4测试用例的结果。如果尚未实现某功能但测试已完成，则特别有用。在这种情况下，预计测试将失败。用标记<code>@NotYetImplemented</code>会颠倒测试结果，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.test.GroovyTestCase
import groovy.test.NotYetImplemented

class Maths {
    static int fib(int n) {
        // todo: implement later
    }
}

class MathsTest extends GroovyTestCase {
    @NotYetImplemented
    void testFib() {
        def dataTable = [
                1:1,
                2:1,
                3:2,
                4:3,
                5:5,
                6:8,
                7:13
        ]
        dataTable.each { i, r -&gt;
            assert Maths.fib(i) == r
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用这种技术的另一个优点是，您可以在知道如何修复错误之前编写测试用例。如果将来有一段时间，代码中的修改可以解决一个副作用，那么您将收到通知，因为通过了预期会失败的测试。</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-ASTTest"><a class="anchor" href="#xform-ASTTest"></a><code>@groovy.transform.ASTTest</code></h5>
<div class="paragraph">
<p><code>@ASTTest</code>是一种特殊的AST转换，旨在帮助调试其他AST转换或Groovy编译器本身。它将使开发人员在编译过程中“探索” AST，并对AST而不是编译结果执行断言。这意味着，此AST转换可在生成字节码之前访问AST。 <code>@ASTTest</code>可以放置在任何可注释的节点上，并且需要两个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>阶段</em> ：设置在哪个阶段<code>@ASTTest</code>将被触发。在此阶段结束时，测试代码将在AST树上工作。</p>
</li>
<li>
<p><em>value</em> ：一旦到达阶段，将在带注释的节点上执行的代码</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">必须从<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/control/CompilePhase.html">org.codehaus.groovy.control中的一个选择编译阶段</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/control/CompilePhase.html">。编译阶段</a> 。但是，由于不可能用相同的注释对节点进行两次注释，因此您将无法使用<code>@ASTTest</code>在两个不同的编译阶段处于同一节点上。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>value</code>是可以访问特殊变量的闭包表达式<code>node</code>对应于带注释的节点，以及一个助手<code>lookup</code>方法将在<a href="#asttest-lookup">这里</a>讨论。例如，您可以这样注释一个类节点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import org.codehaus.groovy.ast.ClassNode
import static org.codehaus.groovy.control.CompilePhase.*

@ASTTest(phase=CONVERSION, value={   <i class="conum" data-value="1"></i><b>(1)</b>
    assert node instanceof ClassNode <i class="conum" data-value="2"></i><b>(2)</b>
    assert node.name == 'Person'     <i class="conum" data-value="3"></i><b>(3)</b>
})
class Person {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在转换阶段之后，我们正在检查抽象语法树的状态</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>节点是指由@ASTTest注释的AST节点</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>它可以用来在编译时执行断言</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的一项有趣功能<code>@ASTTest</code>如果断言失败，则<strong>编译将失败</strong> 。现在假设我们要在编译时检查AST转换的行为。我们将<code>@PackageScope</code>在这里，我们将要验证带有注释的属性<code>@PackageScope</code>成为包私有字段。为此，我们必须知道转换在哪个阶段运行，可以在<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/PackageScopeASTTransformation.html">org.codehaus.groovy.transform中找到</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/PackageScopeASTTransformation.html">。PackageScopeASTTransformation</a> ：语义分析。然后可以这样编写一个测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.PackageScope

import static org.codehaus.groovy.control.CompilePhase.*

@ASTTest(phase=SEMANTIC_ANALYSIS, value= {
    def nameNode = node.properties.find { it.name == 'name' }
    def ageNode = node.properties.find { it.name == 'age' }
    assert nameNode
    assert ageNode == null // shouldn't be a property anymore
    def ageField = node.getDeclaredField 'age'
    assert ageField.modifiers == 0
})
class Person {
    String name
    @PackageScope int age
}</code></pre>
</div>
</div>
<div id="asttest-lookup" class="paragraph">
<p>的<code>@ASTTest</code>注释只能放在语法允许的地方。有时，您想测试一个AST节点的内容，但它并不明显。在这种情况下， <code>@ASTTest</code>提供方便<code>lookup</code>将在AST中搜索带有特殊标记的节点的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = lookup('anchor') <i class="conum" data-value="1"></i><b>(1)</b>
Statement stmt = list[0] <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>返回标签为“ anchor”的AST节点列表</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>由于查找总是返回一个列表，因此始终必须选择要处理的元素</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，假设您要测试for循环变量的声明类型。然后，您可以像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.PackageScope
import org.codehaus.groovy.ast.ClassHelper
import org.codehaus.groovy.ast.expr.DeclarationExpression
import org.codehaus.groovy.ast.stmt.ForStatement

import static org.codehaus.groovy.control.CompilePhase.*

class Something {
    @ASTTest(phase=SEMANTIC_ANALYSIS, value= {
        def forLoop = lookup('anchor')[0]
        assert forLoop instanceof ForStatement
        def decl = forLoop.collectionExpression.expressions[0]
        assert decl instanceof DeclarationExpression
        assert decl.variableExpression.name == 'i'
        assert decl.variableExpression.originType == ClassHelper.int_TYPE
    })
    void someMethod() {
        int x = 1;
        int y = 10;
        anchor: for (int i=0; i&lt;x+y; i++) {
            println "$i"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ASTTest</code>还在测试闭包中公开了这些变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>node</code>照常对应于带注释的节点</p>
</li>
<li>
<p><code>compilationUnit</code>允许访问当前<code>org.codehaus.groovy.control.CompilationUnit</code></p>
</li>
<li>
<p><code>compilePhase</code>返回当前的编译阶段（ <code>org.codehaus.groovy.control.CompilePhase</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您不指定<code>phase</code>属性。在这种情况下，闭包将在（包括）之后的每个编译阶段之后执行<code>SEMANTIC_ANALYSIS</code> 。在每个阶段之后都会保留转换的上下文，这使您有机会检查两个阶段之间的变化。</p>
</div>
<div class="paragraph">
<p>例如，以下是如何转储在类节点上注册的AST转换列表的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.CompileStatic
import groovy.transform.Immutable
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.control.CompilePhase

@ASTTest(value={
    System.err.println "Compile phase: $compilePhase"
    ClassNode cn = node
    System.err.println "Global AST xforms: ${compilationUnit?.ASTTransformationsContext?.globalTransformNames}"
    CompilePhase.values().each {
        def transforms = cn.getTransforms(it)
        if (transforms) {
            System.err.println "Ast xforms for phase $it:"
            transforms.each { map -&gt;
                System.err.println(map)
            }
        }
    }
})
@CompileStatic
@Immutable
class Foo {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里是您可以记住变量以便在两个阶段之间进行测试的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.ToString
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.control.CompilePhase

@ASTTest(value={
    if (compilePhase==CompilePhase.INSTRUCTION_SELECTION) {             <i class="conum" data-value="1"></i><b>(1)</b>
        println "toString() was added at phase: ${added}"
        assert added == CompilePhase.CANONICALIZATION                   <i class="conum" data-value="2"></i><b>(2)</b>
    } else {
        if (node.getDeclaredMethods('toString') &amp;&amp; added==null) {       <i class="conum" data-value="3"></i><b>(3)</b>
            added = compilePhase                                        <i class="conum" data-value="4"></i><b>(4)</b>
        }
    }
})
@ToString
class Foo {
    String name
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果当前的编译阶段是指令选择</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>那么我们要确保<code>toString</code>在添加<code>CANONICALIZATION</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>否则，如果<code>toString</code>存在，并且上下文中的变量<code>added</code>一片空白</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>则表示该编译阶段是<code>toString</code>加入</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_grape_handling"><a class="anchor" href="#_grape_handling"></a> 2.1.10。葡萄处理</h4>
<div class="sect4">
<h5 id="xform-Grab"><a class="anchor" href="#xform-Grab"></a><code>@groovy.lang.Grab</code></h5>

</div>
<div class="sect4">
<h5 id="xform-GrabConfig"><a class="anchor" href="#xform-GrabConfig"></a><code>@groovy.lang.GrabConfig</code></h5>

</div>
<div class="sect4">
<h5 id="xform-GrabExclude"><a class="anchor" href="#xform-GrabExclude"></a><code>@groovy.lang.GrabExclude</code></h5>

</div>
<div class="sect4">
<h5 id="xform-GrabResolver"><a class="anchor" href="#xform-GrabResolver"></a><code>@groovy.lang.GrabResolver</code></h5>

</div>
<div class="sect4">
<h5 id="xform-Grapes"><a class="anchor" href="#xform-Grapes"></a><code>@groovy.lang.Grapes</code></h5>
<div class="paragraph">
<p><code>Grape</code>是嵌入在Groovy中的依赖项管理引擎，它依赖于本<a href="#section-grape">指南</a>本<a href="#section-grape">节</a>中详细描述的几个注释。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="developing-ast-xforms"><a class="anchor" href="#developing-ast-xforms"></a> 2.2。开发AST转换</h3>
<div class="paragraph">
<p>有两种类型的转换：全局和局部转换。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无论转换在何处应用，编译器都会在正在编译的代码上应用<a href="#transforms-global">全局转换</a> 。实现全局转换的已编译类位于添加到编译器的类路径中的JAR中，并且包含服务定位器文件<code>META-INF/services/org.codehaus.groovy.transform.ASTTransformation</code>一行带有转换类名称的行。转换类必须具有no-args构造函数并实现<code>org.codehaus.groovy.transform.ASTTransformation</code>接口。它将针对<strong>编译器</strong>中的<strong>每个源</strong>运行，因此请确保不要创建以广泛且耗时的方式扫描所有AST的转换，以保持编译器的快速运行。</p>
</li>
<li>
<p><a href="#transforms-local">本地转换</a>是通过注释要转换的代码元素在本地应用的转换。为此，我们重用了注释符号，并且这些注释应实现<code>org.codehaus.groovy.transform.ASTTransformation</code> 。编译器将发现它们并将转换应用于这些代码元素。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_compilation_phases_guide"><a class="anchor" href="#_compilation_phases_guide"></a> 2.2.1。编译阶段指南</h4>
<div class="paragraph">
<p>Groovy AST转换必须在定义的九个编译阶段之一中进行（ <a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/control/CompilePhase.html">org.codehaus.groovy.control。CompilePhase</a> ）。</p>
</div>
<div class="paragraph">
<p>全局转换可以应用于任何阶段，但是局部转换只能应用于语义分析阶段或更高版本。简而言之，编译器阶段为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>初始化</em> ：打开源文件并配置环境</p>
</li>
<li>
<p><em>解析</em> ：语法用于产生表示源代码的令牌树</p>
</li>
<li>
<p><em>转换</em> ：从令牌树创建抽象语法树（AST）。</p>
</li>
<li>
<p><em>语义分析</em> ：执行语法无法检查的一致性和有效性检查，并解析类。</p>
</li>
<li>
<p><em>规范化</em> ：完成AST的构建</p>
</li>
<li>
<p><em>指令选择</em> ： <em>选择</em>指令集，例如Java 6或Java 7字节码级别</p>
</li>
<li>
<p><em>类生成</em> ：在内存中创建<em>类</em>的字节码</p>
</li>
<li>
<p><em>输出</em> ：将二进制输出写入文件系统</p>
</li>
<li>
<p><em>完成</em> ：执行最后的清理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一般而言，在后续阶段中会提供更多类型信息。如果您的转换与阅读AST有关，则在以后的阶段获取更多信息可能是一个不错的选择。如果您的转换与编写AST有关，则树更稀疏的早期阶段可能会更方便。</p>
</div>
</div>
<div class="sect3">
<h4 id="transforms-local"><a class="anchor" href="#transforms-local"></a> 2.2.2。本地转型</h4>
<div class="paragraph">
<p>本地AST转换相对于它们所应用的上下文。在大多数情况下，上下文是由注释定义的，该注释将定义转换的范围。例如，对字段进行注释将意味着转换<em>适用于</em>该字段，而对类进行注释将意味着转换<em>适用于</em>整个类。</p>
</div>
<div class="paragraph">
<p>作为一个简单的示例，请考虑编写一个<code>@WithLogging</code>转换，它将在方法调用的开始和结束时添加控制台消息。因此，以下“ Hello World”示例实际上将打印“ Hello World”以及开始和停止消息：</p>
</div>
<div class="listingblock">
<div class="title">穷人面向方面的编程</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@WithLogging
def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>本地AST转换是执行此操作的简便方法。它需要两件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的定义<code>@WithLogging</code>注解</p>
</li>
<li>
<p><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/ASTTransformation.html">org.codehaus.groovy.transform的实现</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/ASTTransformation.html">。ASTTransformation</a>将日志记录表达式添加到方法中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个<code>ASTTransformation</code>是一个回调，使您可以访问<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/control/SourceUnit.html">org.codehaus.groovy.control。SourceUnit</a> ，通过它可以获取对<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/ast/ModuleNode.html">org.codehaus.groovy.ast的引用</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/ast/ModuleNode.html">。ModuleNode</a> （AST）。</p>
</div>
<div class="paragraph">
<p>AST（抽象语法树）是一种树结构，主要由<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/ast/expr/Expression.html">org.codehaus.groovy.ast.expr组成</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/ast/expr/Expression.html">。表达式</a> （expressions）或<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/ast/expr/Statement.html">org.codehaus.groovy.ast.expr。声明</a> （陈述）。了解AST的一种简单方法是在调试器中对其进行探索。拥有AST之后，您可以对其进行分析以查找有关代码的信息，或重写它以添加新功能。</p>
</div>
<div class="paragraph">
<p>局部转换注释是简单的部分。这里是<code>@WithLogging</code>一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.transform.GroovyASTTransformationClass

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.METHOD])
@GroovyASTTransformationClass(["gep.WithLoggingASTTransformation"])
public @interface WithLogging {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注释保留可以是<code>SOURCE</code>因为您以后不需要注解。这里的元素类型是<code>METHOD</code> ， <code>@WithLogging</code>因为注释适用于方法。</p>
</div>
<div class="paragraph">
<p>但最重要的部分是<code>@GroovyASTTransformationClass</code>注解。这链接了<code>@WithLogging</code>的注释<code>ASTTransformation</code>您将要编写的课程。
<code>gep.WithLoggingASTTransformation</code>是的全限定类名称<code>ASTTransformation</code>我们要写。这条线将注释连接到转换。</p>
</div>
<div class="paragraph">
<p>有了这个，Groovy编译器将调用<code>gep.WithLoggingASTTransformation</code>每次<code>@WithLogging</code>在源单位中找到。内设置的任何断点<code>LoggingASTTransformation</code>现在，在运行示例脚本时，将在IDE中将其击中。</p>
</div>
<div class="paragraph">
<p>的<code>ASTTransformation</code>类要复杂一些。这是非常简单且非常幼稚的转换，用于添加方法的开始和停止消息<code>@WithLogging</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)                  <i class="conum" data-value="2"></i><b>(2)</b>
class WithLoggingASTTransformation implements ASTTransformation {               <i class="conum" data-value="3"></i><b>(3)</b>

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {                        <i class="conum" data-value="4"></i><b>(4)</b>
        MethodNode method = (MethodNode) nodes[1]                               <i class="conum" data-value="5"></i><b>(5)</b>

        def startMessage = createPrintlnAst("Starting $method.name")            <i class="conum" data-value="6"></i><b>(6)</b>
        def endMessage = createPrintlnAst("Ending $method.name")                <i class="conum" data-value="7"></i><b>(7)</b>

        def existingStatements = ((BlockStatement)method.code).statements       <i class="conum" data-value="8"></i><b>(8)</b>
        existingStatements.add(0, startMessage)                                 <i class="conum" data-value="9"></i><b>(9)</b>
        existingStatements.add(endMessage)                                      <i class="conum" data-value="10"></i><b>(10)</b>

    }

    private static Statement createPrintlnAst(String message) {                 <i class="conum" data-value="11"></i><b>(11)</b>
        new ExpressionStatement(
            new MethodCallExpression(
                new VariableExpression("this"),
                new ConstantExpression("println"),
                new ArgumentListExpression(
                    new ConstantExpression(message)
                )
            )
        )
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>即使不是强制性的，如果您用Groovy编写AST转换，强烈建议使用<code>CompileStatic</code>因为它将提高编译器的性能。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html">org.codehaus.groovy.transform进行注释</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html">。GroovyASTTransformation</a>指示转换需要在哪个编译阶段运行。在这里，它处于<em>语义分析</em>阶段。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>实施<code>ASTTransformation</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>只有一个<code>visit</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的<code>nodes</code>参数是2个AST节点数组，第一个是注释节点（ <code>@WithLogging</code> ），第二个是带注释的节点（方法节点）</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>创建一个声明，当我们输入方法时将打印一条消息</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>创建一条语句，当我们退出该方法时将打印一条消息</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>获取方法主体，在这种情况下为<code>BlockStatement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>在现有代码的第一条语句之前添加回车方法消息</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>在现有代码的最后一条语句之后附加退出方法消息</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i> <b>11</b></td>
<td>创建一个<code>ExpressionStatement</code>包装一个<code>MethodCallExpression</code>对应于<code>this.println("message")</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>重要的是要注意，为了简化本示例，我们没有进行必要的检查，例如检查带注释的节点是否确实是<code>MethodNode</code> ，或者方法主体是的实例<code>BlockStatement</code> 。本练习留给读者。</p>
</div>
<div class="paragraph">
<p>请注意，在<code>createPrintlnAst(String)</code>方法。为代码创建AST并不总是那么简单。在这种情况下，我们需要构造一个新的方法调用，传入接收器/变量，方法名称和参数列表。创建AST时，将您要尝试创建的代码写入Groovy文件中，然后在调试器中检查该代码的AST以了解创建内容可能会有所帮助。然后写一个像<code>createPrintlnAst</code>使用通过调试器中学到的知识。</p>
</div>
<div class="paragraph">
<p>到底：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@WithLogging
def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Starting greet
Hello World
Ending greet</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">重要的是要注意，AST转换直接参与了编译过程。初学者常见的错误是将AST转换代码与使用该转换的类放在同一源树中。通常，位于同一源代码树中意味着它们是在同一时间编译的。由于转换本身将分阶段进行编译，并且每个编译阶段都将处理同一源单元的所有文件，然后再进行下一个转换，因此有直接的后果：转换将不会在使用它的类之前进行编译！总之，在使用AST转换之前，需要对其进行预编译。通常，就像将它们放在单独的源树中一样容易。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="transforms-global"><a class="anchor" href="#transforms-global"></a> 2.2.3。全球转型</h4>
<div class="paragraph">
<p>全局AST转换与本地AST转换类似，但有一个主要区别：它们不需要注释，这意味着它们是<em>全局</em>应用的，也就是说，在正在编译的每个类上。因此，将它们的使用限制为不得已是非常重要的，因为这可能会对编译器性能产生重大影响。</p>
</div>
<div class="paragraph">
<p>以<a href="#transform-local">本地AST转换</a>的示例为例，假设我们想跟踪所有方法，而不仅限于那些用注释的方法<code>@WithLogging</code> 。基本上，我们需要此代码的行为与带注释的代码相同<code>@WithLogging</code>之前：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>要完成此工作，有两个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建<code>org.codehaus.groovy.transform.ASTTransformation</code>内部的描述符<code>META-INF/services</code>目录</p>
</li>
<li>
<p>创建<code>ASTTransformation</code>实作</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>描述符文件是必需的，必须在类路径中找到。它将包含一行：</p>
</div>
<div class="listingblock">
<div class="title">META-INF / services / org.codehaus.groovy.transform。AST转换</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">gep.WithLoggingASTTransformation</code></pre>
</div>
</div>
<div class="paragraph">
<p>转换代码看起来与本地情况类似，但是没有使用<code>ASTNode[]</code>参数，我们需要使用<code>SourceUnit</code>代替：</p>
</div>
<div class="listingblock">
<div class="title">gep / WithLoggingASTTransformation.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)                  <i class="conum" data-value="2"></i><b>(2)</b>
class WithLoggingASTTransformation implements ASTTransformation {               <i class="conum" data-value="3"></i><b>(3)</b>

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {                        <i class="conum" data-value="4"></i><b>(4)</b>
        def methods = sourceUnit.AST.methods                                    <i class="conum" data-value="5"></i><b>(5)</b>
        methods.each { method -&gt;                                                <i class="conum" data-value="6"></i><b>(6)</b>
            def startMessage = createPrintlnAst("Starting $method.name")        <i class="conum" data-value="7"></i><b>(7)</b>
            def endMessage = createPrintlnAst("Ending $method.name")            <i class="conum" data-value="8"></i><b>(8)</b>

            def existingStatements = ((BlockStatement)method.code).statements   <i class="conum" data-value="9"></i><b>(9)</b>
            existingStatements.add(0, startMessage)                             <i class="conum" data-value="10"></i><b>(10)</b>
            existingStatements.add(endMessage)                                  <i class="conum" data-value="11"></i><b>(11)</b>
        }
    }

    private static Statement createPrintlnAst(String message) {                 <i class="conum" data-value="12"></i><b>(12)</b>
        new ExpressionStatement(
            new MethodCallExpression(
                new VariableExpression("this"),
                new ConstantExpression("println"),
                new ArgumentListExpression(
                    new ConstantExpression(message)
                )
            )
        )
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>即使不是强制性的，如果您用Groovy编写AST转换，强烈建议使用<code>CompileStatic</code>因为它将提高编译器的性能。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html">org.codehaus.groovy.transform进行注释</a><a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html">。GroovyASTTransformation</a>指示转换需要在哪个编译阶段运行。在这里，它处于<em>语义分析</em>阶段。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>实施<code>ASTTransformation</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>只有一个<code>visit</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的<code>sourceUnit</code>参数提供对正在编译的源的访问权限，因此我们获取当前源的AST并从此文件中检索方法列表</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>我们从源文件中迭代每种方法</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>创建一个声明，当我们输入方法时将打印一条消息</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>创建一条语句，当我们退出该方法时将打印一条消息</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>获取方法主体，在这种情况下为<code>BlockStatement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>在现有代码的第一条语句之前添加回车方法消息</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i> <b>11</b></td>
<td>在现有代码的最后一条语句之后附加退出方法消息</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i> <b>12</b></td>
<td>创建一个<code>ExpressionStatement</code>包装一个<code>MethodCallExpression</code>对应于<code>this.println("message")</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_ast_api_guide"><a class="anchor" href="#_ast_api_guide"></a> 2.2.4。AST API指南</h4>
<div class="sect4">
<h5 id="_abstractasttransformation"><a class="anchor" href="#_abstractasttransformation"></a>抽象AST转换</h5>
<div class="paragraph">
<p>虽然您已经看到可以直接实施<code>ASTTransformation</code>接口，在几乎所有情况下，您都不会这样做，而是扩展<a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/transform/AbstractASTTransformation.html">org.codehaus.groovy.transform。AbstractASTTransformation</a>类。此类提供了几种实用的方法，这些方法使AST转换更易于编写。Groovy中包含的几乎所有AST转换都扩展了此类。</p>
</div>
</div>
<div class="sect4">
<h5 id="_classcodeexpressiontransformer"><a class="anchor" href="#_classcodeexpressiontransformer"></a> ClassCodeExpressionTransformer</h5>
<div class="paragraph">
<p>能够将一个表达式转换为另一个表达式是一种常见的用例。Groovy提供了一个使执行此操作非常容易的类： <a href="https://docs.groovy-lang.org/3.0.0-rc-1/html/gapi/index.html?org/codehaus/groovy/ast/ClassCodeExpressionTransformer.html">org.codehaus.groovy.ast。ClassCodeExpressionTransformer</a></p>
</div>
<div class="paragraph">
<p>为了说明这一点，让我们创建一个<code>@Shout</code>变革将改变一切<code>String</code>方法调用参数中的常量变为大写形式。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Shout
def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>应该打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>HELLO WORLD</pre>
</div>
</div>
<div class="paragraph">
<p>然后，转换代码可以使用<code>ClassCodeExpressionTransformer</code>使这更容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)
class ShoutASTTransformation implements ASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {
        ClassCodeExpressionTransformer trn = new ClassCodeExpressionTransformer() {         <i class="conum" data-value="1"></i><b>(1)</b>
            private boolean inArgList = false
            @Override
            protected SourceUnit getSourceUnit() {
                sourceUnit                                                                  <i class="conum" data-value="2"></i><b>(2)</b>
            }

            @Override
            Expression transform(final Expression exp) {
                if (exp instanceof ArgumentListExpression) {
                    inArgList = true
                } else if (inArgList &amp;&amp;
                    exp instanceof ConstantExpression &amp;&amp; exp.value instanceof String) {
                    return new ConstantExpression(exp.value.toUpperCase())                  <i class="conum" data-value="3"></i><b>(3)</b>
                }
                def trn = super.transform(exp)
                inArgList = false
                trn
            }
        }
        trn.visitMethod((MethodNode)nodes[1])                                               <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在内部，转换会创建一个<code>ClassCodeExpressionTransformer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>变压器需要返回源单元</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果在参数列表中检测到字符串类型的常量表达式，请将其转换为大写版本</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>在被注释的方法上调用转换器</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_ast_nodes"><a class="anchor" href="#_ast_nodes"></a> AST节点</h5>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">编写AST转换需要深入了解内部Groovy API。特别是，它需要有关AST类的知识。由于这些类是内部类，因此将来有可能API会更改，这意味着您的转换<em>可能会</em>中断。尽管发出了警告，但AST随时间推移一直非常稳定，很少发生这种情况。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>抽象语法树的类属于<code>org.codehaus.groovy.ast</code>包。建议读者使用Groovy控制台，尤其是AST浏览器工具，以获取有关这些类的知识。但是， <a href="https://github.com/apache/groovy/tree/master/src/test/org/codehaus/groovy/ast/builder">AST Builder</a>测试套件是一个很好的学习资源。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_macros"><a class="anchor" href="#_macros"></a> 2.2.5。巨集</h4>
<div class="sect4">
<h5 id="_introduction"><a class="anchor" href="#_introduction"></a>介绍</h5>
<div class="paragraph">
<p>在版本2.5.0之前，开发AST转换时，开发人员应该对编译器如何构建AST（抽象语法树）有深刻的了解，以便知道如何在编译时添加新的表达式或语句。</p>
</div>
<div class="paragraph">
<p>虽然使用<code>org.codehaus.groovy.ast.tool.GeneralUtils</code>静态方法可以减轻创建表达式和语句的负担，这仍然是直接编写这些AST节点的低级方法。我们需要一些东西来使我们从直接编写AST中抽象出来，而这正是Groovy宏的用途。它们使您可以在编译期间直接添加代码，而不必将您考虑的代码转换为<code>org.codehaus.groovy.ast.*</code>节点相关的类。</p>
</div>
</div>
<div class="sect4">
<h5 id="_statements_and_expressions"><a class="anchor" href="#_statements_and_expressions"></a>陈述和表达</h5>
<div class="paragraph">
<p>让我们看一个例子，让我们创建一个本地AST转换： <code>@AddMessageMethod</code> 。当应用于给定的类时，它将添加一个名为<code>getMessage</code>到那个班级。该方法将返回“ 42”。注释非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.TYPE])
@GroovyASTTransformationClass(["metaprogramming.AddMethodASTTransformation"])
@interface AddMethod { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不使用宏，AST转换将是什么样？像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddMethodASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]

        ReturnStatement code =
                new ReturnStatement(                              <i class="conum" data-value="1"></i><b>(1)</b>
                        new ConstantExpression("42"))             <i class="conum" data-value="2"></i><b>(2)</b>

        MethodNode methodNode =
                new MethodNode(
                        "getMessage",
                        ACC_PUBLIC,
                        ClassHelper.make(String),
                        [] as Parameter[],
                        [] as ClassNode[],
                        code)                                     <i class="conum" data-value="3"></i><b>(3)</b>

        classNode.addMethod(methodNode)                           <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个退货声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个常量表达式“ 42”</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将代码添加到新方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>将新方法添加到带注释的类</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您不习惯AST API，那肯定与您所想到的代码不一样。现在看一下前面的代码如何通过宏的使用来简化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddMethodWithMacrosASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]

        ReturnStatement simplestCode = macro { return "42" }   <i class="conum" data-value="1"></i><b>(1)</b>

        MethodNode methodNode =
                new MethodNode(
                        "getMessage",
                        ACC_PUBLIC,
                        ClassHelper.make(String),
                        [] as Parameter[],
                        [] as ClassNode[],
                        simplestCode)                          <i class="conum" data-value="2"></i><b>(2)</b>

        classNode.addMethod(methodNode)                        <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>简单得多。您想添加一个返回“ 42”的return语句，这正是您可以在其中读取的内容<code>macro</code>实用方法。您的原始代码将被翻译为<code>org.codehaus.groovy.ast.stmt.ReturnStatement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将return语句添加到新方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将新代码添加到带注释的类</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>虽然<code>macro</code>在此示例中使用方法创建一条<strong>语句</strong> <code>macro</code>方法也可以用于创建<strong>表达式</strong> ，具体取决于哪个<code>macro</code>您使用的签名：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>macro(Closure)</code> ：使用闭包内部的代码创建给定的语句。</p>
</li>
<li>
<p><code>macro(Boolean,Closure)</code> ：如果为<strong>true</strong> ，则将表达式包装在语句内的闭包内；如果为<strong>false，</strong>则返回表达式</p>
</li>
<li>
<p><code>macro(CompilePhase, Closure)</code> ：在特定的编译阶段使用闭包中的代码创建给定语句</p>
</li>
<li>
<p><code>macro(CompilePhase, Boolean, Closure)</code> ：在特定的编译阶段创建一个语句或表达式（true ==语句，false ==表达式）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">所有这些签名可以在以下位置找到<code>org.codehaus.groovy.macro.runtime.MacroGroovyMethods</code>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有时我们可能只对创建一个给定的表达式感兴趣，而对整个语句不感兴趣，因此我们应该使用任何<code>macro</code>布尔参数调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddGetTwoASTTransformation extends AbstractASTTransformation {

    BinaryExpression onePlusOne() {
        return macro(false) { 1 + 1 }                                      <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = nodes[1]
        BinaryExpression expression = onePlusOne()                         <i class="conum" data-value="2"></i><b>(2)</b>
        ReturnStatement returnStatement = GeneralUtils.returnS(expression) <i class="conum" data-value="3"></i><b>(3)</b>

        MethodNode methodNode =
                new MethodNode("getTwo",
                        ACC_PUBLIC,
                        ClassHelper.Integer_TYPE,
                        [] as Parameter[],
                        [] as ClassNode[],
                        returnStatement                                    <i class="conum" data-value="4"></i><b>(4)</b>
                )

        classNode.addMethod(methodNode)                                    <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们告诉宏不要将表达式包装在语句中，我们只对表达式感兴趣</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>分配表达式</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个<code>ReturnStatement</code>使用以下方法<code>GeneralUtils</code>然后返回表达式</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>将代码添加到新方法</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>将方法添加到类中</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_variable_substitution"><a class="anchor" href="#_variable_substitution"></a>变量替代</h5>
<div class="paragraph">
<p>宏很棒，但是如果我们的宏无法接收参数或无法解析周围的变量，我们就无法创建任何有用或可重用的宏。</p>
</div>
<div class="paragraph">
<p>在以下示例中，我们将创建AST转换<code>@MD5</code>当应用于给定的String字段时，将添加一个返回该字段的MD5值的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.FIELD])
@GroovyASTTransformationClass(["metaprogramming.MD5ASTTransformation"])
@interface MD5 { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
class MD5ASTTransformation extends AbstractASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        FieldNode fieldNode = nodes[1]
        ClassNode classNode = fieldNode.declaringClass
        String capitalizedName = fieldNode.name.capitalize()
        MethodNode methodNode = new MethodNode(
                "get${capitalizedName}MD5",
                ACC_PUBLIC,
                ClassHelper.STRING_TYPE,
                [] as Parameter[],
                [] as ClassNode[],
                buildMD5MethodCode(fieldNode))

        classNode.addMethod(methodNode)
    }

    BlockStatement buildMD5MethodCode(FieldNode fieldNode) {
        VariableExpression fieldVar = GeneralUtils.varX(fieldNode.name) <i class="conum" data-value="1"></i><b>(1)</b>

        return macro(CompilePhase.SEMANTIC_ANALYSIS, true) {            <i class="conum" data-value="2"></i><b>(2)</b>
            return java.security.MessageDigest
                    .getInstance('MD5')
                    .digest($v { fieldVar }.getBytes())                 <i class="conum" data-value="3"></i><b>(3)</b>
                    .encodeHex()
                    .toString()
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们需要引用一个变量表达式</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果使用标准软件包之外的类，则应添加任何需要的导入或使用限定名称。当使用给定静态方法的合格名称时，您需要确保在正确的编译阶段已解决该问题。在这种特殊情况下，我们指示宏在SEMANTIC_ANALYSIS阶段解析它，这是具有类型信息的第一个编译阶段。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>为了替代任何<code>expression</code>在宏中，我们需要使用<code>$v</code>方法。 <code>$v</code>接收一个闭包作为参数，并且该闭包仅允许替换表达式，这意味着类继承<code>org.codehaus.groovy.ast.expr.Expression</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_macroclass"><a class="anchor" href="#_macroclass"></a>宏类</h5>
<div class="paragraph">
<p>如前所述， <code>macro</code>方法只能产生<code>statements</code>和<code>expressions</code> 。但是，如果我们想产生其他类型的节点，例如方法，字段等，该怎么办？</p>
</div>
<div class="paragraph">
<p><code>org.codehaus.groovy.macro.transform.MacroClass</code>可以用来在我们的转换中创建<strong>类</strong> （ClassNode实例），就像我们使用<code>macro</code>方法之前。</p>
</div>
<div class="paragraph">
<p>下一个示例是局部转换<code>@Statistics</code> 。当应用于给定的类时，它将添加两个方法<strong>getMethodCount（）</strong>和<strong>getFieldCount（）</strong> ，它们分别返回该类中有多少个方法和字段。这是标记注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.TYPE])
@GroovyASTTransformationClass(["metaprogramming.StatisticsASTTransformation"])
@interface Statistics {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和AST转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class StatisticsASTTransformation extends AbstractASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]
        ClassNode templateClass = buildTemplateClass(classNode)  <i class="conum" data-value="1"></i><b>(1)</b>

        templateClass.methods.each { MethodNode node -&gt;          <i class="conum" data-value="2"></i><b>(2)</b>
            classNode.addMethod(node)
        }
    }

    @CompileDynamic
    ClassNode buildTemplateClass(ClassNode reference) {          <i class="conum" data-value="3"></i><b>(3)</b>
        def methodCount = constX(reference.methods.size())       <i class="conum" data-value="4"></i><b>(4)</b>
        def fieldCount = constX(reference.fields.size())         <i class="conum" data-value="5"></i><b>(5)</b>

        return new MacroClass() {
            class Statistics {
                java.lang.Integer getMethodCount() {             <i class="conum" data-value="6"></i><b>(6)</b>
                    return $v { methodCount }
                }

                java.lang.Integer getFieldCount() {              <i class="conum" data-value="7"></i><b>(7)</b>
                    return $v { fieldCount }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建模板类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将模板类方法添加到带注释的类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通过参考班</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>提取参考类方法计数值表达式</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>提取参考类字段计数值表达式</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>使用引用的方法计数值表达式构建<strong>getMethodCount（）</strong>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>使用引用的字段计数值表达式构建<strong>getFieldCount（）</strong>方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>基本上，我们创建了<strong>Statistics</strong>类作为模板，以避免编写底层AST API，然后将在模板类中创建的方法复制到其最终目标。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">里面的类型<code>MacroClass</code>实现应该在内部解决，这就是为什么我们不得不写<code>java.lang.Integer</code>而不是简单地写<code>Integer</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请注意，我们正在使用<code>@CompileDynamic</code> 。那是因为我们使用的方式<code>MacroClass</code>就像我们实际上正在实施它。因此，如果您使用的是<code>@CompileStatic</code>它会抱怨，因为抽象类的实现不能是另一个不同的类。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_macro_methods"><a class="anchor" href="#_macro_methods"></a> @宏方法</h5>
<div class="paragraph">
<p>您已经看到使用<code>macro</code>您可以节省很多工作，但您可能想知道该方法的来源。您没有声明它或静态导入它。您可以将其视为一种特殊的全局方法（或者，如果愿意，可以将<code>Object</code> ）。这很像<code>println</code>扩展方法已定义。但是不像<code>println</code>成为在编译过程中稍后选择执行的方法， <code>macro</code>扩展是在编译过程的早期完成的。的声明<code>macro</code>作为此早期扩展的一种可用方法是通过注释<code>macro</code>方法定义<code>@Macro</code>注释，并使用类似的扩展模块机制使该方法可用。此类方法称为<em>宏</em>方法，可喜的是您可以定义自己的方法。</p>
</div>
<div class="paragraph">
<p>要定义自己的宏方法，请以类似于扩展模块的方式创建一个类，并添加一个方法，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class ExampleMacroMethods {

    @Macro
    public static Expression safe(MacroContext macroContext, MethodCallExpression callExpression) {
        return ternaryX(
                notNullX(callExpression.getObjectExpression()),
                callExpression,
                constX(null)
        );
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您可以使用<code>org.codehaus.groovy.runtime.ExtensionModule</code>内的文件<code>META-INF/groovy</code>目录。</p>
</div>
<div class="paragraph">
<p>现在，假设类和元信息文件位于类路径中，则可以通过以下方式使用宏方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nullObject = null
assert null == safe(safe(nullObject.hashcode()).toString())</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_testing_ast_transformations"><a class="anchor" href="#_testing_ast_transformations"></a> 2.2.6。测试AST转换</h4>
<div class="sect4">
<h5 id="_separating_source_trees"><a class="anchor" href="#_separating_source_trees"></a>分离源树</h5>
<div class="paragraph">
<p>本节介绍有关测试AST转换的良好做法。前几节强调了一个事实，要能够执行AST转换，必须对其进行预编译。听起来似乎很明显，但是很多人都陷入了困境，试图在定义它的源树中使用AST转换。</p>
</div>
<div class="paragraph">
<p>因此，测试AST转换的第一个技巧是将测试源与转换源分开。再说一次，这不过是最佳实践，但是您必须确保您的构建也确实单独编译了它们。默认情况下， <a href="http://maven.apache.org">Apache Maven</a>和<a href="http://gradle.org">Gradle</a>都是这种情况。</p>
</div>
</div>
<div class="sect4">
<h5 id="_debugging_ast_transformations"><a class="anchor" href="#_debugging_ast_transformations"></a>调试AST转换</h5>
<div class="paragraph">
<p>能够在AST转换中放置断点非常方便，因此您可以在IDE中调试代码。但是，您可能会惊讶地发现IDE并没有在断点处停止。原因实际上很简单：如果您的IDE使用Groovy编译器来编译AST转换的单元测试，则编译是从IDE触发的，但是用于编译文件的过程没有调试选项。仅在执行测试用例时，才在虚拟机上设置调试选项。简而言之：为时已晚，该类已被编译，并且您的转换已被应用。</p>
</div>
<div class="paragraph">
<p>一个非常简单的解决方法是使用<code>GroovyTestCase</code>提供一个<code>assertScript</code>方法。这意味着与其在测试用例中编写它，不如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">static class Subject {
    @MyTransformToDebug
    void methodToBeTested() {}
}

void testMyTransform() {
    def c = new Subject()
    c.methodToBeTested()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您应该写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testMyTransformWithBreakpoint() {
    assertScript '''
        import metaprogramming.MyTransformToDebug

        class Subject {
            @MyTransformToDebug
            void methodToBeTested() {}
        }
        def c = new Subject()
        c.methodToBeTested()
    '''
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>区别在于，当您使用<code>assertScript</code> ，中的代码<code>assertScript</code> <strong>执行单元测试时</strong>编译块。也就是说，这次， <code>Subject</code>该类将在调试处于活动状态时进行编译，并且断点将被击中。</p>
</div>
</div>
<div class="sect4">
<h5 id="_astmatcher"><a class="anchor" href="#_astmatcher"></a> ASTMatcher</h5>
<div class="paragraph">
<p>有时您可能想对AST节点进行断言；可能是为了过滤节点，或确保给定的转换已构建了预期的AST节点。</p>
</div>
<div class="paragraph">
<p><strong>过滤节点</strong></p>
</div>
<div class="paragraph">
<p>例如，如果您只想将给定的转换仅应用于一组特定的AST节点，则可以使用<strong>ASTMatcher</strong>来过滤这些节点。下面的示例演示如何将给定表达式转换为另一个表达式。使用<strong>ASTMatcher</strong>查找特定的表达式<code>1 + 1</code>并将其转换为<code>3</code> 。这就是为什么我们称它为<code>@Joking</code>例。</p>
</div>
<div class="paragraph">
<p>首先，我们创建<code>@Joking</code>仅可应用于方法的注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.METHOD])
@GroovyASTTransformationClass(["metaprogramming.JokingASTTransformation"])
@interface Joking { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后是仅应用以下实例的转换<code>org.codehaus.groovy.ast.ClassCodeExpressionTransformer</code>方法代码块中的所有表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class JokingASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        MethodNode methodNode = (MethodNode) nodes[1]

        methodNode
            .getCode()
            .visit(new ConvertOnePlusOneToThree(source))  <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获取方法的代码语句并应用表达式转换器</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是当<strong>ASTMatcher</strong>用于仅将转换应用于与表达式匹配的表达式时<code>1 + 1</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class ConvertOnePlusOneToThree extends ClassCodeExpressionTransformer {
    SourceUnit sourceUnit

    ConvertOnePlusOneToThree(SourceUnit sourceUnit) {
        this.sourceUnit = sourceUnit
    }

    @Override
    Expression transform(Expression exp) {
        Expression ref = macro { 1 + 1 }     <i class="conum" data-value="1"></i><b>(1)</b>

        if (ASTMatcher.matches(ref, exp)) {  <i class="conum" data-value="2"></i><b>(2)</b>
            return macro { 3 }               <i class="conum" data-value="3"></i><b>(3)</b>
        }

        return super.transform(exp)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>构建用作参考模式的表达式</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>检查评估的当前表达式是否与参考表达式匹配</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果匹配，则将当前表达式替换为生成的表达式<code>macro</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，您可以按以下方式测试实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">package metaprogramming

class Something {
    @Joking
    Integer getResult() {
        return 1 + 1
    }
}

assert new Something().result == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>单元测试AST转换</strong></p>
</div>
<div class="paragraph">
<p>通常，我们只检查AST转换的最终用途是否符合我们的预期，就测试AST转换。但是，如果我们能够采用一种简便的方法来检查转换（例如，转换添加的节点）是否是我们从一开始就期望的节点，那就太好了。</p>
</div>
<div class="paragraph">
<p>以下转换添加了新方法<code>giveMeTwo</code>到带注释的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class TwiceASTTransformation extends AbstractASTTransformation {

    static final String VAR_X = 'x'

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]
        MethodNode giveMeTwo = getTemplateClass(sumExpression)
            .getDeclaredMethods('giveMeTwo')
            .first()

        classNode.addMethod(giveMeTwo)                  <i class="conum" data-value="1"></i><b>(1)</b>
    }

    BinaryExpression getSumExpression() {               <i class="conum" data-value="2"></i><b>(2)</b>
        return macro {
            $v{ varX(VAR_X) } +
            $v{ varX(VAR_X) }
        }
    }

    ClassNode getTemplateClass(Expression expression) { <i class="conum" data-value="3"></i><b>(3)</b>
        return new MacroClass() {
            class Template {
                java.lang.Integer giveMeTwo(java.lang.Integer x) {
                    return $v { expression }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将方法添加到带注释的类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>构建一个二进制表达式。二进制表达式在变量的两侧使用相同的变量表达式<code>+</code>令牌（检查<code>varX</code> <strong>org.codehaus.groovy.ast.tool中的方法<strong>。GeneralUtils</strong> ）。</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用称为的方法构建一个新的<strong>ClassNode</strong> <code>giveMeTwo</code>它返回作为参数传递的表达式的结果。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在，而不是创建对给定示例代码执行转换的测试。我想检查二进制表达式的构造是否正确完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testTestingSumExpression() {
    use(ASTMatcher) {                 <i class="conum" data-value="1"></i><b>(1)</b>
        TwiceASTTransformation sample = new TwiceASTTransformation()
        Expression referenceNode = macro {
            a + a                     <i class="conum" data-value="2"></i><b>(2)</b>
        }.withConstraints {           <i class="conum" data-value="3"></i><b>(3)</b>
            placeholder 'a'           <i class="conum" data-value="4"></i><b>(4)</b>
        }

        assert sample
            .sumExpression
            .matches(referenceNode)   <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用ASTMatcher作为类别</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>建立一个模板节点</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将一些约束应用于该模板节点</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>告诉编译器<code>a</code>是一个占位符。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>断言参考节点和当前节点相等</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当然，您可以/应该始终检查实际执行情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testASTBehavior() {
    assertScript '''
    package metaprogramming

    @Twice
    class AAA {

    }

    assert new AAA().giveMeTwo(1) == 2
    '''
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_asttest"><a class="anchor" href="#_asttest"></a> ASTTest</h5>
<div class="paragraph">
<p>最后但并非最不重要的一点是，测试AST转换还与<strong>在编译期间</strong>测试AST的状态有关。Groovy提供了一个名为<code>@ASTTest</code>为此：它是一个注释，可让您在抽象语法树上添加断言。请查看<a href="#xform-ASTTest">ASTTest</a>的<a href="#xform-ASTTest">文档以</a>了解更多详细信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_external_references"><a class="anchor" href="#_external_references"></a> 2.2.7。外部参考</h4>
<div class="paragraph">
<p>如果您对有关编写AST转换的分步教程感兴趣，可以按照<a href="http://melix.github.io/ast-workshop/">此研讨会进行操作</a> 。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:02 AEST</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>