<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>将Groovy集成到Java应用程序中</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=0">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>将Groovy集成到Java应用程序中</h1>
<div class="details">
<span id="revnumber">版本3.0.0-rc-1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_groovy_integration_mechanisms">1。Groovy集成机制</a>
<ul class="sectlevel2">
<li><a href="#integ-eval">1.1。评估</a></li>
<li><a href="#integ-groovyshell">1.2。GroovyShell</a>
<ul class="sectlevel3">
<li><a href="#_multiple_sources">1.2.1。多种来源</a></li>
<li><a href="#_sharing_data_between_a_script_and_the_application">1.2.2。在脚本和应用程序之间共享数据</a></li>
<li><a href="#_custom_script_class">1.2.3。自定义脚本类</a></li>
</ul>
</li>
<li><a href="#groovyclassloader">1.3。GroovyClassLoader</a></li>
<li><a href="#_groovyscriptengine">1.4。GroovyScriptEngine</a></li>
<li><a href="#_compilationunit">1.5。编译单元</a></li>
</ul>
</li>
<li><a href="#_bean_scripting_framework">2。Bean脚本框架</a>
<ul class="sectlevel2">
<li><a href="#_getting_started">2.1。入门</a></li>
<li><a href="#_passing_in_variables">2.2。传递变量</a></li>
<li><a href="#_other_calling_options">2.3。其他通话选项</a></li>
<li><a href="#_access_to_the_scripting_engine">2.4。访问脚本引擎</a></li>
</ul>
</li>
<li><a href="#jsr223">3。JSR 223 javax.script API</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_groovy_integration_mechanisms"><a class="anchor" href="#_groovy_integration_mechanisms"></a> 1。Groovy集成机制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy语言提出了几种在运行时将其自身集成到应用程序（Java甚至Groovy）中的方法，从最基本，最简单的代码执行到最完整的集成缓存和编译器定制。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">本节中编写的所有示例都使用Groovy，但是Java可以使用相同的集成机制。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="integ-eval"><a class="anchor" href="#integ-eval"></a> 1.1。评估</h3>
<div class="paragraph">
<p>的<code>groovy.util.Eval</code>类是在运行时动态执行Groovy的最简单方法。这可以通过调用<code>me</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.util.Eval

assert Eval.me('33*3') == 99
assert Eval.me('"foo".toUpperCase()') == 'FOO'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Eval</code>支持多种接受参数以进行简单评估的变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert Eval.x(4, '2*x') == 8                <i class="conum" data-value="1"></i><b>(1)</b>
assert Eval.me('k', 4, '2*k') == 8          <i class="conum" data-value="2"></i><b>(2)</b>
assert Eval.xy(4, 5, 'x*y') == 20           <i class="conum" data-value="3"></i><b>(3)</b>
assert Eval.xyz(4, 5, 6, 'x*y+z') == 26     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用一个名为的绑定参数进行简单评估<code>x</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>相同的评估，带有名为的自定义绑定参数<code>k</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>具有两个绑定参数的简单评估<code>x</code>和<code>y</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>具有三个绑定参数的简单评估<code>x</code> ， <code>y</code>和<code>z</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>Eval</code>使用class可以很容易地评估简单的脚本，但是却不能扩展：脚本没有缓存，也不能评估多个衬板。</p>
</div>
</div>
<div class="sect2">
<h3 id="integ-groovyshell"><a class="anchor" href="#integ-groovyshell"></a> 1.2。GroovyShell</h3>
<div class="sect3">
<h4 id="_multiple_sources"><a class="anchor" href="#_multiple_sources"></a> 1.2.1。多种来源</h4>
<div class="paragraph">
<p>的<code>groovy.lang.GroovyShell</code> class是评估脚本的首选方法，并且可以缓存生成的脚本实例。虽然<code>Eval</code>类返回已编译脚本的执行结果， <code>GroovyShell</code>类提供更多选择。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def shell = new GroovyShell()                           <i class="conum" data-value="1"></i><b>(1)</b>
def result = shell.evaluate '3*5'                       <i class="conum" data-value="2"></i><b>(2)</b>
def result2 = shell.evaluate(new StringReader('3*5'))   <i class="conum" data-value="3"></i><b>(3)</b>
assert result == result2
def script = shell.parse '3*5'                          <i class="conum" data-value="4"></i><b>(4)</b>
assert script instanceof groovy.lang.Script
assert script.run() == 15                               <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个新的<code>GroovyShell</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以用作<code>Eval</code>直接执行代码</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>可以从多个来源读取（ <code>String</code> ， <code>Reader</code> ， <code>File</code> ， <code>InputStream</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>可以推迟脚本的执行。 <code>parse</code>返回一个<code>Script</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>Script</code>定义一个<code>run</code>方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_sharing_data_between_a_script_and_the_application"><a class="anchor" href="#_sharing_data_between_a_script_and_the_application"></a> 1.2.2。在脚本和应用程序之间共享数据</h4>
<div class="paragraph">
<p>使用以下命令可以在应用程序和脚本之间共享数据： <code>groovy.lang.Binding</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sharedData = new Binding()                          <i class="conum" data-value="1"></i><b>(1)</b>
def shell = new GroovyShell(sharedData)                 <i class="conum" data-value="2"></i><b>(2)</b>
def now = new Date()
sharedData.setProperty('text', 'I am shared data!')     <i class="conum" data-value="3"></i><b>(3)</b>
sharedData.setProperty('date', now)                     <i class="conum" data-value="4"></i><b>(4)</b>

String result = shell.evaluate('"At $date, $text"')     <i class="conum" data-value="5"></i><b>(5)</b>

assert result == "At $now, I am shared data!"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个新的<code>Binding</code>将包含共享数据</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个<code>GroovyShell</code>使用此共享数据</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在绑定中添加一个字符串</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>在绑定中添加日期（您不仅限于简单类型）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>评估脚本</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，也可以从脚本写入绑定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sharedData = new Binding()                          <i class="conum" data-value="1"></i><b>(1)</b>
def shell = new GroovyShell(sharedData)                 <i class="conum" data-value="2"></i><b>(2)</b>

shell.evaluate('foo=123')                               <i class="conum" data-value="3"></i><b>(3)</b>

assert sharedData.getProperty('foo') == 123             <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个新的<code>Binding</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个新的<code>GroovyShell</code>使用共享数据</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用<strong>未声明的</strong>变量将结果存储到绑定中</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>读取呼叫者的结果</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>重要的是要理解，如果要写入绑定，则需要使用未声明的变量。使用<code>def</code>或<code>explicit</code>像下面的示例中那样的类型将失败，因为您随后将创建一个<em>局部变量</em> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sharedData = new Binding()
def shell = new GroovyShell(sharedData)

shell.evaluate('int foo=123')

try {
    assert sharedData.getProperty('foo')
} catch (MissingPropertyException e) {
    println "foo is defined as a local variable"
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">在多线程环境中使用共享数据时，必须非常小心。的<code>Binding</code>您传递给的实例<code>GroovyShell</code> <strong>不是</strong>线程安全的，并且由所有脚本共享。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以解决的共享实例<code>Binding</code>通过利用<code>Script</code>返回的实例<code>parse</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def shell = new GroovyShell()

def b1 = new Binding(x:3)                       <i class="conum" data-value="1"></i><b>(1)</b>
def b2 = new Binding(x:4)                       <i class="conum" data-value="2"></i><b>(2)</b>
def script = shell.parse('x = 2*x')
script.binding = b1
script.run()
script.binding = b2
script.run()
assert b1.getProperty('x') == 6
assert b2.getProperty('x') == 8
assert b1 != b2</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将存储<code>x</code>内部变量<code>b1</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将存储<code>x</code>内部变量<code>b2</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，您必须意识到您仍在共享脚本的<strong>相同实例</strong> 。因此，如果有两个线程在同一个脚本上工作，则无法使用此技术。在这种情况下，必须确保创建两个不同的脚本实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def shell = new GroovyShell()

def b1 = new Binding(x:3)
def b2 = new Binding(x:4)
def script1 = shell.parse('x = 2*x')            <i class="conum" data-value="1"></i><b>(1)</b>
def script2 = shell.parse('x = 2*x')            <i class="conum" data-value="2"></i><b>(2)</b>
assert script1 != script2
script1.binding = b1                            <i class="conum" data-value="3"></i><b>(3)</b>
script2.binding = b2                            <i class="conum" data-value="4"></i><b>(4)</b>
def t1 = Thread.start { script1.run() }         <i class="conum" data-value="5"></i><b>(5)</b>
def t2 = Thread.start { script2.run() }         <i class="conum" data-value="6"></i><b>(6)</b>
[t1,t2]*.join()                                 <i class="conum" data-value="7"></i><b>(7)</b>
assert b1.getProperty('x') == 6
assert b2.getProperty('x') == 8
assert b1 != b2</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>为线程1创建脚本实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>为线程2创建脚本实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将第一个绑定分配给脚本1</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>将第二个绑定分配给脚本2</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>在单独的线程中启动第一个脚本</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>在单独的线程中启动第二个脚本</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>等待完成</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要像这里这样的线程安全，建议直接使用<a href="#groovyclassloader">GroovyClassLoader</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_script_class"><a class="anchor" href="#_custom_script_class"></a> 1.2.3。自定义脚本类</h4>
<div class="paragraph">
<p>我们已经看到<code>parse</code>方法返回一个实例<code>groovy.lang.Script</code> ，但是可以扩展使用自定义类<code>Script</code>本身。它可以用来为脚本提供其他行为，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class MyScript extends Script {
    String name

    String greet() {
        "Hello, $name!"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义类定义了一个名为<code>name</code>还有一个叫做<code>greet</code> 。通过使用自定义配置，可以将该类用作脚本基类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.control.CompilerConfiguration

def config = new CompilerConfiguration()                                    <i class="conum" data-value="1"></i><b>(1)</b>
config.scriptBaseClass = 'MyScript'                                         <i class="conum" data-value="2"></i><b>(2)</b>

def shell = new GroovyShell(this.class.classLoader, new Binding(), config)  <i class="conum" data-value="3"></i><b>(3)</b>
def script = shell.parse('greet()')                                         <i class="conum" data-value="4"></i><b>(4)</b>
assert script instanceof MyScript
script.setName('Michel')
assert script.run() == 'Hello, Michel!'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个<code>CompilerConfiguration</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>指示它使用<code>MyScript</code>作为脚本的基类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后在创建外壳时使用编译器配置</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>脚本现在可以访问新方法<code>greet</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您不仅限于单一的<em>scriptBaseClass</em>配置。您可以使用任何编译器配置调整，包括<a href="#compilation-customizers">编译定制器</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="groovyclassloader"><a class="anchor" href="#groovyclassloader"></a> 1.3。GroovyClassLoader</h3>
<div class="paragraph">
<p>在上<a href="#integ-groovyshell">一节中</a> ，我们显示了<code>GroovyShell</code>虽然是执行脚本的简便工具，但除了脚本之外，其他任何东西的编译都很复杂。在内部，它利用了<code>groovy.lang.GroovyClassLoader</code> ，这是在运行时编译和加载类的核心。</p>
</div>
<div class="paragraph">
<p>通过利用<code>GroovyClassLoader</code>代替<code>GroovyShell</code> ，您将能够加载类，而不是脚本实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.lang.GroovyClassLoader

def gcl = new GroovyClassLoader()                                           <i class="conum" data-value="1"></i><b>(1)</b>
def clazz = gcl.parseClass('class Foo { void doIt() { println "ok" } }')    <i class="conum" data-value="2"></i><b>(2)</b>
assert clazz.name == 'Foo'                                                  <i class="conum" data-value="3"></i><b>(3)</b>
def o = clazz.newInstance()                                                 <i class="conum" data-value="4"></i><b>(4)</b>
o.doIt()                                                                    <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个新的<code>GroovyClassLoader</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>parseClass</code>将返回一个实例<code>Class</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>您可以检查返回的类是否确实是脚本中定义的类</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>您可以创建该类的新实例，而不是脚本</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>然后在上面调用任何方法</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">GroovyClassLoader保留对其创建的所有类的引用，因此很容易造成内存泄漏。特别是，如果您两次执行相同的脚本（如果它是一个字符串），那么您将获得两个不同的类！
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.lang.GroovyClassLoader

def gcl = new GroovyClassLoader()
def clazz1 = gcl.parseClass('class Foo { }')                                <i class="conum" data-value="1"></i><b>(1)</b>
def clazz2 = gcl.parseClass('class Foo { }')                                <i class="conum" data-value="2"></i><b>(2)</b>
assert clazz1.name == 'Foo'                                                 <i class="conum" data-value="3"></i><b>(3)</b>
assert clazz2.name == 'Foo'
assert clazz1 != clazz2                                                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>动态创建一个名为“ Foo”的类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个外观相同的类，使用单独的<code>parseClass</code>呼叫</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>确保两个类具有相同的名称</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>但是它们实际上是不同的！</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>原因是<code>GroovyClassLoader</code>不跟踪源文本。如果要具有相同的实例，则源<strong>必须</strong>是文件，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def gcl = new GroovyClassLoader()
def clazz1 = gcl.parseClass(file)                                           <i class="conum" data-value="1"></i><b>(1)</b>
def clazz2 = gcl.parseClass(new File(file.absolutePath))                    <i class="conum" data-value="2"></i><b>(2)</b>
assert clazz1.name == 'Foo'                                                 <i class="conum" data-value="3"></i><b>(3)</b>
assert clazz2.name == 'Foo'
assert clazz1 == clazz2                                                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>解析一个类<code>File</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>从不同的文件实例解析一个类，但指向同一物理文件</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>确保我们的课程名称相同</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>但是现在，它们是同一个实例</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>用一个<code>File</code>作为输入， <code>GroovyClassLoader</code>能够<strong>缓存</strong>生成的类文件，从而避免在运行时为同一源创建多个类。</p>
</div>
</div>
<div class="sect2">
<h3 id="_groovyscriptengine"><a class="anchor" href="#_groovyscriptengine"></a> 1.4。GroovyScriptEngine</h3>
<div class="paragraph">
<p>的<code>groovy.util.GroovyScriptEngine</code>类为依赖脚本重新加载和脚本依赖项的应用程序提供了灵活的基础。而<code>GroovyShell</code>专注于独立<code>Script`s and `GroovyClassLoader</code>处理任何Groovy类的动态编译和加载， <code>GroovyScriptEngine</code>将在<code>GroovyClassLoader</code>处理脚本依赖性和重新加载。</p>
</div>
<div class="paragraph">
<p>为了说明这一点，我们将创建一个脚本引擎并无限循环地执行代码。首先，您需要创建一个包含以下脚本的目录：</p>
</div>
<div class="listingblock">
<div class="title">ReloadingTest.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Greeter {
    String sayHello() {
        def greet = "Hello, world!"
        greet
    }
}

new Greeter()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以使用<code>GroovyScriptEngine</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def binding = new Binding()
def engine = new GroovyScriptEngine([tmpDir.toURI().toURL()] as URL[])          <i class="conum" data-value="1"></i><b>(1)</b>

while (true) {
    def greeter = engine.run('ReloadingTest.groovy', binding)                   <i class="conum" data-value="2"></i><b>(2)</b>
    println greeter.sayHello()                                                  <i class="conum" data-value="3"></i><b>(3)</b>
    Thread.sleep(1000)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个脚本引擎，它将在我们的源目录中查找源</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>执行脚本，它将返回一个实例<code>Greeter</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>打印问候语</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此时，您应该每秒看到一条消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello, world!
Hello, world!
...</pre>
</div>
</div>
<div class="paragraph">
<p><strong>在不</strong>中断脚本执行的情况下，现在替换<code>ReloadingTest</code>文件包含：</p>
</div>
<div class="listingblock">
<div class="title">ReloadingTest.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Greeter {
    String sayHello() {
        def greet = "Hello, Groovy!"
        greet
    }
}

new Greeter()</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且该消息应更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello, world!
...
Hello, Groovy!
Hello, Groovy!
...</pre>
</div>
</div>
<div class="paragraph">
<p>但是也可能依赖于另一个脚本。为了说明这一点，请在不中断执行脚本的情况下，将以下文件创建到同一目录中：</p>
</div>
<div class="listingblock">
<div class="title">依赖关系</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Dependency {
    String message = 'Hello, dependency 1'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并更新<code>ReloadingTest</code>脚本如下：</p>
</div>
<div class="listingblock">
<div class="title">ReloadingTest.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import Dependency

class Greeter {
    String sayHello() {
        def greet = new Dependency().message
        greet
    }
}

new Greeter()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，消息应更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello, Groovy!
...
Hello, dependency 1!
Hello, dependency 1!
...</pre>
</div>
</div>
<div class="paragraph">
<p>作为最后的测试，您可以更新<code>Dependency.groovy</code>文件而不碰<code>ReloadingTest</code>文件：</p>
</div>
<div class="listingblock">
<div class="title">依赖关系</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Dependency {
    String message = 'Hello, dependency 2'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您应该观察到依赖文件已重新加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello, dependency 1!
...
Hello, dependency 2!
Hello, dependency 2!</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compilationunit"><a class="anchor" href="#_compilationunit"></a> 1.5。编译单元</h3>
<div class="paragraph">
<p>最终，有可能直接依靠编译来执行编译期间的更多操作。 <code>org.codehaus.groovy.control.CompilationUnit</code>类。此类负责确定编译的各个步骤，并让您介绍新的步骤，甚至在各个阶段停止编译。例如，这就是联合编译器如何完成存根生成。</p>
</div>
<div class="paragraph">
<p>但是，覆盖<code>CompilationUnit</code>不建议使用此方法，只有在没有其他标准解决方案的情况下才应这样做。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bean_scripting_framework"><a class="anchor" href="#_bean_scripting_framework"></a> 2。Bean脚本框架</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content"><a href="http://commons.apache.org/proper/commons-bsf/">Bean脚本框架</a>是一种尝试创建API以允许从Java调用脚本语言的尝试。它没有更新很长时间，为了支持标准的<a href="#jsr223">JSR-223</a> API而被放弃了。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Groovy的BSF引擎由<code>org.codehaus.groovy.bsf.GroovyEngine</code>类。但是，BSF API通常掩盖了这一事实。您只需通过BSF API像其他脚本语言一样对待Groovy。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于Groovy拥有与Java集成的本机支持，因此，如果您还希望也能够调用其他语言（例如<a href="https://www.jruby.org/">JRuby），</a>或者希望与脚本语言保持紧密的联系，则只需担心BSF。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="_getting_started"><a class="anchor" href="#_getting_started"></a> 2.1。入门</h3>
<div class="paragraph">
<p>如果您在类路径中有Groovy和BSF jar，则可以使用以下Java代码运行示例Groovy脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">String myScript = "println('Hello World')\n  return [1, 2, 3]";
BSFManager manager = new BSFManager();
List answer = (List) manager.eval("groovy", "myScript.groovy", 0, 0, myScript);
assertEquals(3, answer.size());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_passing_in_variables"><a class="anchor" href="#_passing_in_variables"></a> 2.2。传递变量</h3>
<div class="paragraph">
<p>BSF使您可以在Java和脚本语言之间传递bean。您可以<em>注册</em> / <em>取消注册</em> bean，从而使BSF知道它们。然后，您可以根据需要使用BSF方法来<em>查找</em> bean。另外，您可以<em>声明</em> / <em>取消声明</em> bean。这将注册它们，但也可以直接在您的脚本语言中使用它们。第二种方法是Groovy使用的常规方法。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">BSFManager manager = new BSFManager();
manager.declareBean("xyz", 4, Integer.class);
Object answer = manager.eval("groovy", "test.groovy", 0, 0, "xyz + 1");
assertEquals(5, answer);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_other_calling_options"><a class="anchor" href="#_other_calling_options"></a> 2.3。其他通话选项</h3>
<div class="paragraph">
<p>前面的示例使用了<em>eval</em>方法。BSF提供了多种方法供您使用（有关更多详细信息，请参见<a href="http://commons.apache.org/proper/commons-bsf/manual.html">BSF文档</a> ）。<em>应用</em>其他可用方法之一。它允许您使用脚本语言定义匿名函数，并将该函数应用于参数。Groovy使用闭包支持此功能。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">BSFManager manager = new BSFManager();
Vector&lt;String&gt; ignoreParamNames = null;
Vector&lt;Integer&gt; args = new Vector&lt;Integer&gt;();
args.add(2);
args.add(5);
args.add(1);
Integer actual = (Integer) manager.apply("groovy", "applyTest", 0, 0,
        "def summer = { a, b, c -&gt; a * 100 + b * 10 + c }", ignoreParamNames, args);
assertEquals(251, actual.intValue());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_access_to_the_scripting_engine"><a class="anchor" href="#_access_to_the_scripting_engine"></a> 2.4。访问脚本引擎</h3>
<div class="paragraph">
<p>尽管您通常不需要它，但BSF确实提供了一个钩子，可让您直接使用脚本引擎。引擎可执行的功能之一是在对象上调用单个方法。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">BSFManager manager = new BSFManager();
BSFEngine bsfEngine = manager.loadScriptingEngine("groovy");
manager.declareBean("myvar", "hello", String.class);
Object myvar = manager.lookupBean("myvar");
String result = (String) bsfEngine.call(myvar, "reverse", new Object[0]);
assertEquals("olleh", result);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jsr223"><a class="anchor" href="#jsr223"></a> 3。JSR 223 javax.script API</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">JSR-223是用于用Java调用脚本框架的标准API。它从Java 6开始可用，其目的是提供一个用于从Java调用多种语言的通用框架。Groovy提供了自己更丰富的集成机制，如果您不打算在同一应用程序中使用多种语言，则建议您使用Groovy集成机制，而不是受限的JSR-223 API。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是初始化JSR-223引擎以从Java与Groovy对话的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
...
ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine = factory.getEngineByName("groovy");</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以轻松执行Groovy脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Integer sum = (Integer) engine.eval("(1..10).sum()");
assertEquals(new Integer(55), sum);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以共享变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">engine.put("first", "HELLO");
engine.put("second", "world");
String result = (String) engine.eval("first.toLowerCase() + ' ' + second.toUpperCase()");
assertEquals("hello WORLD", result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例说明了如何调用可调用函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import javax.script.Invocable;
...
ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine = factory.getEngineByName("groovy");
String fact = "def factorial(n) { n == 1 ? 1 : n * factorial(n - 1) }";
engine.eval(fact);
Invocable inv = (Invocable) engine;
Object[] params = {5};
Object result = inv.invokeFunction("factorial", params);
assertEquals(new Integer(120), result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>引擎默认保留对脚本功能的硬引用。要更改此设置，您应该将引擎级别的范围属性设置为名称的脚本上下文<code>#jsr223.groovy.engine.keep.globals</code>有一个字符串<code>phantom</code>使用幻像引用， <code>weak</code>使用弱引用或<code>soft</code>使用软引用-忽略大小写。任何其他字符串都将导致使用硬引用。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本3.0.0-rc-1<br>最近更新时间2019-10-22 17:47:01 AEST</div>
</div>
<link rel="stylesheet" href="asset?aid=1">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>