<html lang="zh-Hans" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="./images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9（9.0.21）-集群/会话复制方法</title><meta name="author" content="Filip Hanik"><meta name="author" content="Peter Rossbach"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/cluster-howto">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script></head><body ><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="./images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="./images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="index.html">文件首页</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>用户指南</h2><ul><li><a href="introduction.html">1）简介</a></li><li><a href="setup.html">2）设定</a></li><li><a href="appdev/index.html">3）第一个webapp</a></li><li><a href="deployer-howto.html">4）部署者</a></li><li><a href="manager-howto.html">5）经理</a></li><li><a href="host-manager-howto.html">6）主机管理员</a></li><li><a href="realm-howto.html">7）领域和AAA</a></li><li><a href="security-manager-howto.html">8）安全经理</a></li><li><a href="jndi-resources-howto.html">9）JNDI资源</a></li><li><a href="jndi-datasource-examples-howto.html">10）JDBC数据源</a></li><li><a href="class-loader-howto.html">11）类加载</a></li><li><a href="jasper-howto.html">12）JSP</a></li><li><a href="ssl-howto.html">13）SSL / TLS</a></li><li><a href="ssi-howto.html">14）SSI</a></li><li><a href="cgi-howto.html">15）CGI</a></li><li><a href="proxy-howto.html">16）代理支持</a></li><li><a href="mbeans-descriptors-howto.html">17）MBean描述符</a></li><li><a href="default-servlet.html">18）默认Servlet</a></li><li><a href="cluster-howto.html">19）聚类</a></li><li><a href="balancer-howto.html">20）负载均衡器</a></li><li><a href="connectors.html">21）连接器</a></li><li><a href="monitoring.html">22）监控与管理</a></li><li><a href="logging.html">23）记录</a></li><li><a href="apr.html">24）APR /本地</a></li><li><a href="virtual-hosting-howto.html">25）虚拟主机</a></li><li><a href="aio.html">26）高级IO</a></li><li><a href="extras.html">27）附加组件</a></li><li><a href="maven-jars.html">28）行刑</a></li><li><a href="security-howto.html">29）安全注意事项</a></li><li><a href="windows-service-howto.html">30）Windows服务</a></li><li><a href="windows-auth-howto.html">31）Windows身份验证</a></li><li><a href="jdbc-pool.html">32）Tomcat的JDBC池</a></li><li><a href="web-socket-howto.html">33）WebSocket</a></li><li><a href="rewrite.html">34）改写</a></li></ul></div><div><h2>参考</h2><ul><li><a href="RELEASE-NOTES.txt">发行说明</a></li><li><a href="config/index.html">组态</a></li><li><a href="api/index.html">Tomcat Java文档</a></li><li><a href="servletapi/index.html">Servlet Java文档</a></li><li><a href="jspapi/index.html">JSP 2.3 Java文档</a></li><li><a href="elapi/index.html">EL 3.0 Java文档</a></li><li><a href="websocketapi/index.html">WebSocket 1.1 Java文档</a></li><li><a href="https://tomcat.apache.org/connectors-doc/">JK 1.2文档</a></li></ul></div><div><h2>Apache Tomcat开发</h2><ul><li><a href="building.html">建造</a></li><li><a href="changelog.html">变更日志</a></li><li><a href="https://wiki.apache.org/tomcat/TomcatVersions">状态</a></li><li><a href="developers.html">开发者</a></li><li><a href="architecture/index.html">建筑</a></li><li><a href="funcspecs/index.html">功能规格。</a></li><li><a href="tribes/introduction.html">部族</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>群集/会话复制方法</h2><h3 id="Important_Note">重要的提示</h3><div class="text">
<p><b>您还可以查看<a href="config/cluster.html">配置参考文档。</a></b>
</p>
</div><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#For_the_impatient">对于急躁的人</a></li><li><a href="#Security">安全</a></li><li><a href="#Cluster_Basics">集群基础</a></li><li><a href="#Overview">总览</a></li><li><a href="#Cluster_Information">集群信息</a></li><li><a href="#Bind_session_after_crash_to_failover_node">崩溃后将会话绑定到故障转移节点</a></li><li><a href="#Configuration_Example">配置实例</a></li><li><a href="#Cluster_Architecture">集群架构</a></li><li><a href="#How_it_Works">怎么运行的</a></li><li><a href="#Monitoring_your_Cluster_with_JMX">使用JMX监视集群</a></li><li><a href="#FAQ">常问问题</a></li></ul>
</div><h3 id="For_the_impatient">对于急躁的人</h3><div class="text">
  <p>只需添加</p>
  <div class="codeBox"><pre><code>&lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;</code></pre></div>
  <p>给你<code><Engine></code>或你的<code><Host></code>启用群集的元素。
  </p>
  <p>使用以上配置，将启用使用<code>DeltaManager</code>复制会话增量。从全部到全部，我们的意思是<i>每个</i>会话都被复制到集群中的<i>所有其他节点</i> 。这对于较小的群集非常有用，但是对于较大的群集（超过4个左右的节点），我们不建议这样做。另外，在使用DeltaManager时，Tomcat会将会话复制到<i>所有</i>节点， <i>甚至没有部署应用程序的节点</i> 。<br>要解决这些问题，您将需要使用<code>BackupManager</code> 。的<code>BackupManager</code>仅将会话数据复制到<i>一个</i>备份节点，并且仅复制到已部署应用程序的节点。在运行了一个简单的集群后， <code>DeltaManager</code> ，您可能要迁移到<code>BackupManager</code>随着您增加群集中节点的数量。
  </p>
  <p>以下是一些重要的默认值：</p>
  <ol>
    <li>组播地址是228.0.0.4</li>
    <li>组播端口为45564（端口和地址共同决定群集成员资格。</li>
    <li>广播的IP是<code>java.net.InetAddress.getLocalHost().getHostAddress()</code> （确保您没有广播127.0.0.1，这是一个常见错误）</li>
    <li>侦听复制消息的TCP端口是范围中的第一个可用服务器套接字<code>4000-4100</code></li>
    <li>侦听器已配置<code>ClusterSessionListener</code></li>
    <li>配置了两个拦截器<code>TcpFailureDetector</code>和<code>MessageDispatchInterceptor</code></li>
  </ol>
  <p>以下是默认的群集配置：</p>
  <div class="codeBox"><pre><code>        &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"
                 channelSendOptions="8"&gt;

          &lt;Manager className="org.apache.catalina.ha.session.DeltaManager"
                   expireSessionsOnShutdown="false"
                   notifyListenersOnReplication="true"/&gt;

          &lt;Channel className="org.apache.catalina.tribes.group.GroupChannel"&gt;
            &lt;Membership className="org.apache.catalina.tribes.membership.McastService"
                        address="228.0.0.4"
                        port="45564"
                        frequency="500"
                        dropTime="3000"/&gt;
            &lt;Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver"
                      address="auto"
                      port="4000"
                      autoBind="100"
                      selectorTimeout="5000"
                      maxThreads="6"/&gt;

            &lt;Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter"&gt;
              &lt;Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/&gt;
            &lt;/Sender&gt;
            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/&gt;
            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor"/&gt;
          &lt;/Channel&gt;

          &lt;Valve className="org.apache.catalina.ha.tcp.ReplicationValve"
                 filter=""/&gt;
          &lt;Valve className="org.apache.catalina.ha.session.JvmRouteBinderValve"/&gt;

          &lt;Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer"
                    tempDir="/tmp/war-temp/"
                    deployDir="/tmp/war-deploy/"
                    watchDir="/tmp/war-listen/"
                    watchEnabled="false"/&gt;

          &lt;ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/&gt;
        &lt;/Cluster&gt;</code></pre></div>
  <p>我们将在本文档的后面部分更详细地介绍这一部分。</p>
</div><h3 id="Security">安全</h3><div class="text">

<p>在将安全，受信任的网络用于所有与群集相关的网络流量的基础上编写群集实现。在不安全，不受信任的网络上运行群集是不安全的。</p>

<p>有许多选项可提供安全，可信任的网络，以供Tomcat群集使用。这些包括：</p>
<ul>
  <li>专用局域网</li>
  <li>虚拟专用网（VPN）</li>
  <li>IPSEC</li>
  <li>使用<a href="config/cluster-interceptor.html#org.apache.catalina.tribes.group.interceptors.EncryptInterceptor_Attributes">EncryptInterceptor</a>加密群集流量</li>
</ul>

</div><h3 id="Cluster_Basics">集群基础</h3><div class="text">

<p>要在Tomcat 9容器中运行会话复制，应完成以下步骤：</p>
<ul>
  <li>您的所有会话属性都必须实现<code>java.io.Serializable</code></li>
  <li>取消注释<code>Cluster</code> server.xml中的元素</li>
  <li>如果已定义自定义群集阀，请确保您拥有<code>ReplicationValve</code>在server.xml的Cluster元素下也定义</li>
  <li>如果您的Tomcat实例在同一台计算机上运行，请确保<code>Receiver.port</code>属性对于每个实例都是唯一的，在大多数情况下，Tomcat足够聪明，可以通过自动检测4000-4100范围内的可用端口自行解决此问题</li>
  <li>确保你的<code>web.xml</code>有<code><distributable/></code>元件</li>
  <li>如果您使用的是mod_jk，请确保在您的引擎上设置了jvmRoute属性<code><Engine name="Catalina" jvmRoute="node01" ></code>并且jvmRoute属性值与worker.properties中的工作人员名称匹配</li>
  <li>确保所有节点都具有相同的时间并与NTP服务同步！</li>
  <li>确保将您的负载均衡器配置为粘性会话模式。</li>
</ul>
<p>负载均衡可以通过许多技术来实现，如“ <a href="balancer-howto.html">负载均衡”</a>一章所示。</p>
<p>注意：请记住，您的会话状态是由Cookie跟踪的，因此您的URL必须从外到外看起来相同，否则，将创建一个新会话。</p>
<p>群集模块使用Tomcat JULI日志记录框架，因此您可以通过常规logging.properties文件配置日志记录。要跟踪消息，可以启用登录密钥：<code>org.apache.catalina.tribes.MESSAGES</code></p>
</div><h3 id="Overview">总览</h3><div class="text">

<p>要在Tomcat中启用会话复制，可以遵循三个不同的路径来实现完全相同的目的：</p>
<ol>
  <li>使用会话持久性，并将会话保存到共享文件系统（PersistenceManager + FileStore）</li>
  <li>使用会话持久性，并将会话保存到共享数据库（PersistenceManager + JDBCStore）</li>
  <li>使用内存中复制，使用Tomcat附带的SimpleTcpCluster（lib / catalina-tribes.jar + lib / catalina-ha.jar）</li>
</ol>

<p>Tomcat可以使用以下命令执行会话状态的全部复制<code>DeltaManager</code>或使用以下命令仅将备份复制到一个节点<code>BackupManager</code> 。全部复制是仅在群集较小时才有效的算法。对于较大的群集，应使用BackupManager来使用主-次会话复制策略，其中会话将仅存储在一个备份节点上。<br>当前，您可以使用域工作程序属性（mod_jk> 1.2.8）来构建群集分区，并可能通过DeltaManager获得更具扩展性的群集解决方案（为此您需要配置域拦截器）。为了在所有环境中降低网络流量，可以将群集分成较小的组。通过为不同的组使用不同的多播地址，可以轻松实现这一点。一个非常简单的设置如下所示：</p>

<div class="codeBox"><pre><code>        DNS Round Robin
               |
         Load Balancer
          /           \
      Cluster1      Cluster2
      /     \        /     \
  Tomcat1 Tomcat2  Tomcat3 Tomcat4</code></pre></div>

<p>这里要提到的重要一点是，会话复制仅仅是集群的开始。用于实现集群的另一个流行概念是耕种，即，您仅将应用程序部署到一台服务器，并且集群将在整个集群中分布部署。这是FarmWarDeployer可以使用的所有功能（位于的群集示例<code>server.xml</code> ）</p>
<p>在下一节中，将更深入地讨论会话复制的工作方式以及如何配置它。</p>

</div><h3 id="Cluster_Information">集群信息</h3><div class="text">
<p>成员资格是使用多播心跳建立的。因此，如果您想细分集群，可以通过更改网络中的多播IP地址或端口来实现。 <code><Membership></code>元件。
</p>
<p>心跳包含Tomcat节点的IP地址和Tomcat侦听复制流量的TCP端口。所有数据通信均通过TCP进行。</p>
<p>的<code>ReplicationValve</code>用于确定请求何时完成并启动复制（如果有）。仅当会话已更改时才复制数据（通过在会话上调用setAttribute或removeAttribute）。
</p>
<p>性能最重要的考虑因素之一是同步复制与异步复制。在同步复制模式下，直到复制的会话通过网络发送并在所有其他群集节点上重新实例化后，请求才返回。使用以下命令配置同步与异步<code>channelSendOptions</code>标志，是一个整数值。的默认值<code>SimpleTcpCluster/DeltaManager</code>组合是8，这是异步的。
</p>
<p>为了方便， <code>channelSendOptions</code>可以通过名称而不是整数进行设置，然后在启动时将其转换为整数值。有效的选项名称是：“异步”（别名“异步”），“字节消息”（别名“字节”），“多播”，“安全”，“ synchronized_ack”（别名“ sync”），“ udp”和“ use_ack” ”。使用逗号分隔多个名称，例如，为选项传递“异步，多播” <code>SEND_OPTIONS_ASYNCHRONOUS | SEND_OPTIONS_MULTICAST</code> 。
</p>
<p>您可以在<a href="tribes/introduction.html">send标志（概述）</a>或<a href="https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/tribes/Channel.html">send标志（javadoc）</a>上阅读更多内容。在异步复制期间，将在复制数据之前返回请求。异步复制可缩短请求时间，同步复制可确保在请求返回之前复制会话。
</p>
</div><h3 id="Bind_session_after_crash_to_failover_node">崩溃后将会话绑定到故障转移节点</h3><div class="text">
<p>如果您使用的是mod_jk而不是使用粘性会话，或者由于某些原因粘性会话无法正常工作，或者您只是在进行故障转移，则需要修改会话ID，因为该会话ID之前包含了先前tomcat的worker ID（已定义）通过引擎元素中的jvmRoute）。为了解决这个问题，我们将使用JvmRouteBinderValve。
</p>
<p>JvmRouteBinderValve重写会话ID，以确保故障转移后下一个请求将保持粘性（并且不会退回到随机节点，因为该工作器不再可用）。阀门用相同的名称重写Cookie中的JSESSIONID值。如果未安装此阀，则在mod_jk模块发生故障的情况下，将很难确保粘性。
</p>
<p>请记住，如果要在server.xml中添加自己的阀门，则默认值不再有效，请确保您添加了默认值定义的所有适当的阀门。
</p>
<p>
    <b>暗示：</b><br>使用属性<i>sessionIdAttribute，</i>您可以更改包括旧会话ID的请求属性名称。默认属性名称是<i>org.apache.catalina.ha.session。JvmRouteOrignalSessionID</i> 。</p>
<p>
    <b>特技：</b><br>在将节点拖放到所有备份节点之前，可以通过JMX启用此mod_jk周转模式！在所有JvmRouteBinderValve备份上将enable设置为true，在mod_jk上禁用worker，然后删除节点并重新启动它！然后启用mod_jk Worker并再次禁用JvmRouteBinderValves。该用例意味着仅迁移请求的会话。
</p>


</div><h3 id="Configuration_Example">配置实例</h3><div class="text">
    <div class="codeBox"><pre><code>        &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"
                 channelSendOptions="6"&gt;

          &lt;Manager className="org.apache.catalina.ha.session.BackupManager"
                   expireSessionsOnShutdown="false"
                   notifyListenersOnReplication="true"
                   mapSendOptions="6"/&gt;
          &lt;!--
          &lt;Manager className="org.apache.catalina.ha.session.DeltaManager"
                   expireSessionsOnShutdown="false"
                   notifyListenersOnReplication="true"/&gt;
          --&gt;
          &lt;Channel className="org.apache.catalina.tribes.group.GroupChannel"&gt;
            &lt;Membership className="org.apache.catalina.tribes.membership.McastService"
                        address="228.0.0.4"
                        port="45564"
                        frequency="500"
                        dropTime="3000"/&gt;
            &lt;Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver"
                      address="auto"
                      port="5000"
                      selectorTimeout="100"
                      maxThreads="6"/&gt;

            &lt;Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter"&gt;
              &lt;Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/&gt;
            &lt;/Sender&gt;
            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/&gt;
            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor"/&gt;
            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor"/&gt;
          &lt;/Channel&gt;

          &lt;Valve className="org.apache.catalina.ha.tcp.ReplicationValve"
                 filter=".*\.gif|.*\.js|.*\.jpeg|.*\.jpg|.*\.png|.*\.htm|.*\.html|.*\.css|.*\.txt"/&gt;

          &lt;Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer"
                    tempDir="/tmp/war-temp/"
                    deployDir="/tmp/war-deploy/"
                    watchDir="/tmp/war-listen/"
                    watchEnabled="false"/&gt;

          &lt;ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/&gt;
        &lt;/Cluster&gt;</code></pre></div>
    <p>分解吧！
    </p>
    <div class="codeBox"><pre><code>        &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"
                 channelSendOptions="6"&gt;</code></pre></div>
    <p>在该元素内部，可以配置所有群集详细信息的主要元素。的<code>channelSendOptions</code>是附加到由SimpleTcpCluster类发送的每条消息或调用SimpleTcpCluster.send方法的任何对象的标志。有关发送标志的说明，请参见<a href="https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/tribes/Channel.html">我们的javadoc网站</a> 。 <code>DeltaManager</code>使用SimpleTcpCluster.send方法发送信息，而备份管理器本身直接通过通道发送信息。
      <br>有关更多信息，请访问<a href="config/cluster.html">参考文档</a>
    </p>
    <div class="codeBox"><pre><code>          &lt;Manager className="org.apache.catalina.ha.session.BackupManager"
                   expireSessionsOnShutdown="false"
                   notifyListenersOnReplication="true"
                   mapSendOptions="6"/&gt;
          &lt;!--
          &lt;Manager className="org.apache.catalina.ha.session.DeltaManager"
                   expireSessionsOnShutdown="false"
                   notifyListenersOnReplication="true"/&gt;
          --&gt;</code></pre></div>
    <p>这是管理器配置的模板，如果在<context>元素中未定义管理器，将使用该模板<context>。在Tomcat 5.x中，每个标记为可分发的Web应用程序都必须使用同一管理器，现在不再是这种情况，因为Tomcat可以为每个Web应用程序定义一个管理器类，以便可以在群集中混合使用管理器。显然，一个节点的应用程序上的管理器必须与另一节点上的同一应用程序上的同一管理器相对应。如果尚未为该Web应用程序指定管理器，并且该Web应用程序被标记为<distributable></distributable> Tomcat将采用此管理器配置，并创建一个克隆该配置的管理器实例。
        <br>有关更多信息，请访问<a href="config/cluster-manager.html">参考文档</a>
    </context></context></p>
    <div class="codeBox"><pre><code>          &lt;Channel className="org.apache.catalina.tribes.group.GroupChannel"&gt;</code></pre></div>
    <p>通道元素是<a href="tribes/introduction.html">Tribes</a> ，这是Tomcat内部使用的组通信框架。该元素封装了与通信和成员资格逻辑有关的所有内容。
        <br>有关更多信息，请访问<a href="config/cluster-channel.html">参考文档</a>
    </p>
    <div class="codeBox"><pre><code>            &lt;Membership className="org.apache.catalina.tribes.membership.McastService"
                        address="228.0.0.4"
                        port="45564"
                        frequency="500"
                        dropTime="3000"/&gt;</code></pre></div>
    <p>成员资格是使用多播完成的。请注意，部落也支持使用<code>StaticMembershipInterceptor</code>如果您想将成员资格扩展到多播以外的点。地址属性是使用的多播地址，端口是多播端口。这两个一起创建了群集分离。如果要QA群集和生产群集，最简单的配置是将QA群集放置在与生产群集不同的多播地址/端口组合上。<br>成员资格组件将自身的TCP地址/端口广播到其他节点，以便可以通过TCP进行节点之间的通信。请注意，正在广播的地址是以下地址之一<code>Receiver.address</code>属性。
        <br>有关更多信息，请访问<a href="config/cluster-membership.html">参考文档</a>
    </p>
    <div class="codeBox"><pre><code>            &lt;Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver"
                      address="auto"
                      port="5000"
                      selectorTimeout="100"
                      maxThreads="6"/&gt;</code></pre></div>
    <p>在部落中，发送和接收数据的逻辑分为两个功能组件。顾名思义，接收方负责接收消息。由于Tribes堆栈的线程较少（其他框架现在也采用了流行的改进），因此该组件中的线程池具有maxThreads和minThreads设置。<br>地址属性是将由成员资格组件广播到其他节点的主机地址。
        <br>有关更多信息，请访问<a href="config/cluster-receiver.html">参考文档</a>
    </p>
    <div class="codeBox"><pre><code>            &lt;Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter"&gt;
              &lt;Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/&gt;
            &lt;/Sender&gt;</code></pre></div>
    <p>顾名思义，发送方组件负责将消息发送到其他节点。发送者有一个外壳组件， <code>ReplicationTransmitter</code>但是真正完成的工作是在子组件中完成的， <code>Transport</code> 。部落支持拥有一个发件人池，以便可以并行发送消息，如果使用NIO发件人，则也可以同时发送消息。<br>同时意味着一条消息同时发送给多个发件人，而并行意味着一条消息同时发送给多个发件人。
        <br>有关更多信息，请访问<a href="config/cluster-sender.html">参考文档</a>
    </p>
    <div class="codeBox"><pre><code>            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/&gt;
            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor"/&gt;
            &lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor"/&gt;
          &lt;/Channel&gt;</code></pre></div>
    <p>部落使用堆栈来发送消息。堆栈中的每个元素都称为拦截器，其工作方式与Tomcat Servlet容器中的阀门非常相似。使用拦截器，可以将逻辑分解为更易于管理的代码段。上面配置的拦截器是：<br>TcpFailureDetector-通过TCP验证崩溃的成员，如果丢弃了多播数据包，则此拦截器可防止误报，即，即使该节点仍处于活动状态并正在运行，它也标记为已崩溃。<br>MessageDispatchInterceptor-将消息调度到线程（线程池）以异步发送消息。<br>ThroughputInterceptor-输出有关邮件流量的简单统计信息。<br>请注意，拦截器的顺序很重要。它们在server.xml中的定义方式就是它们在通道堆栈中的表示方式。可以将其视为一个链表，头是第一个拦截器，尾号是最后一个。
        <br>有关更多信息，请访问<a href="config/cluster-interceptor.html">参考文档</a>
    </p>
    <div class="codeBox"><pre><code>          &lt;Valve className="org.apache.catalina.ha.tcp.ReplicationValve"
                 filter=".*\.gif|.*\.js|.*\.jpeg|.*\.jpg|.*\.png|.*\.htm|.*\.html|.*\.css|.*\.txt"/&gt;</code></pre></div>
    <p>集群使用阀门来跟踪对Web应用程序的请求，我们在上面提到了ReplicationValve和JvmRouteBinderValve。<cluster>元素本身不是Tomcat中管道的一部分，而是集群将阀门添加到其父容器中。如果在<cluster>元素中配置了<engine>元素，则将气门添加到引擎中，依此类推。
        <br>有关更多信息，请访问<a href="config/cluster-valve.html">参考文档</a>
    </engine></cluster></cluster></p>
    <div class="codeBox"><pre><code>          &lt;Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer"
                    tempDir="/tmp/war-temp/"
                    deployDir="/tmp/war-deploy/"
                    watchDir="/tmp/war-listen/"
                    watchEnabled="false"/&gt;</code></pre></div>
    <p>默认的tomcat集群支持场部署，即集群可以在其他节点上部署和取消部署应用程序。该组件的状态目前处于变化之中，但很快就会解决。在Tomcat 5.0和5.5之间，部署算法发生了变化，此时，该组件的逻辑更改为部署目录必须与webapps目录匹配的位置。
        <br>有关更多信息，请访问<a href="config/cluster-deployer.html">参考文档</a>
    </p>
    <div class="codeBox"><pre><code>          &lt;ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/&gt;
        &lt;/Cluster&gt;</code></pre></div>
    <p>由于SimpleTcpCluster本身是Channel对象的发送者和接收者，因此组件可以将自己注册为SimpleTcpCluster的侦听器。上面的听众<code>ClusterSessionListener</code>侦听DeltaManager复制消息，并将增量应用到管理器，然后将其应用到会话。
        <br>有关更多信息，请访问<a href="config/cluster-listener.html">参考文档</a>
    </p>

</div><h3 id="Cluster_Architecture">集群架构</h3><div class="text">

<p><b>组件级别：</b></p>
<div class="codeBox"><pre><code>         Server
           |
         Service
           |
         Engine
           |  \
           |  --- Cluster --*
           |
         Host
           |
         ------
        /      \
     Cluster    Context(1-N)
        |             \
        |             -- Manager
        |                   \
        |                   -- DeltaManager
        |                   -- BackupManager
        |
     ---------------------------
        |                       \
      Channel                    \
    ----------------------------- \
        |                          \
     Interceptor_1 ..               \
        |                            \
     Interceptor_N                    \
    -----------------------------      \
     |          |         |             \
   Receiver    Sender   Membership       \
                                         -- Valve
                                         |      \
                                         |       -- ReplicationValve
                                         |       -- JvmRouteBinderValve
                                         |
                                         -- LifecycleListener
                                         |
                                         -- ClusterListener
                                         |      \
                                         |       -- ClusterSessionListener
                                         |
                                         -- Deployer
                                                \
                                                 -- FarmWarDeployer

</code></pre></div>


</div><h3 id="How_it_Works">怎么运行的</h3><div class="text">
<p>为了便于理解群集的工作原理，我们将带您完成一系列场景。在这种情况下，我们仅计划使用两个tomcat实例<code>TomcatA</code>和<code>TomcatB</code> 。我们将介绍以下事件序列：</p>

<ol>
<li><code>TomcatA</code>启动</li>
<li><code>TomcatB</code>启动（等待TomcatA启动完成）</li>
<li><code>TomcatA</code>收到一个请求，一个会话<code>S1</code>被建造。</li>
<li><code>TomcatA</code>崩溃</li>
<li><code>TomcatB</code>收到会话请求<code>S1</code></li>
<li><code>TomcatA</code>启动</li>
<li><code>TomcatA</code>收到请求，则在会话上调用无效（ <code>S1</code> ）</li>
<li><code>TomcatB</code>收到一个新会话的请求（ <code>S2</code> ）</li>
<li><code>TomcatA</code>会议<code>S2</code>因不活动而过期。</li>
</ol>

<p>好的，既然我们有一个很好的序列，我们将带您准确了解会话复制代码中发生的一切</p>

<ol>
<li><b><code>TomcatA</code>启动</b>
    <p>Tomcat使用标准启动顺序启动。创建主机对象后，将与一个群集对象关联。解析上下文时，如果web.xml中有可分发元素，则Tomcat会询问Cluster类（在这种情况下， <code>SimpleTcpCluster</code> ）为复制的上下文创建管理器。因此，启用集群后，Tomcat在web.xml中设置的可分配性将创建一个<code>DeltaManager</code>在这种情况下，而不是<code>StandardManager</code> 。群集类将启动成员资格服务（多播）和复制服务（tcp单播）。本文档中进一步介绍了体系结构。
    </p>
</li>
<li><b><code>TomcatB</code>启动</b>
    <p>TomcatB启动时，它遵循与TomcatA相同的顺序，但有一个例外。集群启动，并将建立成员资格（TomcatA，TomcatB）。TomcatB现在将从集群中已经存在的服务器（在本例中为TomcatA）请求会话状态。 TomcatA响应该请求，并且在TomcatB开始侦听HTTP请求之前，状态已从TomcatA转移到TomcatB。万一TomcatA不响应，TomcatB将在60秒后超时，并发出日志条目。对于在其web.xml中可分发的每个Web应用程序，将转移会话状态。注意：为了有效地使用会话复制，所有的tomcat实例都应配置为相同。
    </p>
</li>
<li><b><code>TomcatA</code>收到一个请求，一个会话<code>S1</code>被建造。</b>
    <p>进入TomcatA的请求的处理方式与没有会话复制的方式完全相同。该操作在请求完成时发生， <code>ReplicationValve</code>在响应返回给用户之前将拦截请求。此时，它发现该会话已被修改，并且使用TCP将会话复制到TomcatB。将序列化数据移交给操作系统TCP逻辑后，请求将通过阀门管道返回给用户。对于每个请求，整个会话都将被复制，这允许修改会话中属性的代码无需调用setAttribute或removeAttribute被复制。useDirtyFlag配置参数可用于优化会话被复制的次数。
    </p>

</li>
<li><b><code>TomcatA</code>崩溃</b>
    <p>当TomcatA崩溃时，TomcatB会收到有关TomcatA退出集群的通知。TomcatB从其成员资格列表中删除了TomcatA，并且TomcatB中发生的任何更改都不会再通知TomcatA。负载平衡器会将请求从TomcatA重定向到TomcatB，并且所有会话均为当前会话。
    </p>
</li>
<li><b><code>TomcatB</code>收到会话请求<code>S1</code></b>
    <p>没什么令人兴奋的，TomcatB会像处理其他任何请求一样处理该请求。</p>
</li>
<li><b><code>TomcatA</code>启动</b>
    <p>在启动时，在TomcatA开始接受新请求并使其可用之前，将遵循上述1）2）所述的启动顺序。它将加入集群，请与TomcatB联系以获取所有会话的当前状态。并且一旦收到会话状态，它将完成加载并打开其HTTP / mod_jk端口。因此，直到收到来自TomcatB的会话状态，才会向TomcatA发送请求。</p>
</li>
<li><b><code>TomcatA</code>收到请求，则在会话上调用无效（ <code>S1</code> ）</b>
    <p>无效呼叫被截获，并且会话与无效会话排队。请求完成后，它不会发送已更改的会话，而是向TomcatB发送“过期”消息，并且TomcatB也会使该会话无效。
    </p>

</li>
<li><b><code>TomcatB</code>收到一个新会话的请求（ <code>S2</code> ）</b>
    <p>与步骤3中相同的情况）</p>


</li>
<li><code>TomcatA</code>会议<code>S2</code>因不活动而过期。
    <p>截取无效呼叫的过程与用户使会话无效时的拦截过程相同，并且该会话与无效会话一起排队。此时，在另一个请求通过系统并检查无效队列之前，无效会话将不会被复制。
    </p>
</li>
</ol>

<p>hu！ :)</p>

<p><b>成员身份</b>群集成员身份是使用非常简单的多播ping建立的。每个Tomcat实例将定期发送多播ping，在ping消息中，该实例将广泛转换其IP和TCP侦听端口以进行复制。如果实例在给定的时间范围内未收到此类ping，则该成员被视为已死。很简单，很有效！当然，您需要在系统上启用多播。
</p>

<p><b>TCP复制</b>一旦收到多播ping，成员便被添加到群集。在下一个复制请求时，发送实例将使用主机和端口信息并建立一个TCP套接字。使用此套接字，它发送序列化的数据。我选择TCP套接字的原因是因为它具有内置的流控制和保证的交付。所以我知道，当我发送一些数据时，它将到达那里:)</p>

<p><b>分布式锁定和使用框架的页面</b> Tomcat不会使会话实例在集群中保持同步。这样的逻辑的实现将花费大量的开销并且会引起各种问题。如果您的客户端使用多个请求同时访问同一会话，则最后一个请求将覆盖群集中的其他会话。
</p>

</div><h3 id="Monitoring_your_Cluster_with_JMX">使用JMX监视集群</h3><div class="text">
<p>使用群集时，监视是一个非常重要的问题。一些集群对象是JMX MBean</p>
<p>使用Java 5将以下参数添加到启动脚本中：</p>
<div class="codeBox"><pre><code>set CATALINA_OPTS=\
-Dcom.sun.management.jmxremote \
-Dcom.sun.management.jmxremote.port=%my.jmx.port% \
-Dcom.sun.management.jmxremote.ssl=false \
-Dcom.sun.management.jmxremote.authenticate=false</code></pre></div>

<p>群集Mbean列表</p>
<table class="defaultTable">

  <tbody><tr>
    <th>名称</th>
    <th>描述</th>
    <th>MBean ObjectName-引擎</th>
    <th>MBean ObjectName-主机</th>
  </tr>

  <tr>
    <td>簇</td>
    <td>完整的集群元素</td>
    <td><code>type=Cluster</code></td>
    <td><code>type=Cluster,host=${HOST}</code></td>
  </tr>

  <tr>
    <td>三角洲经理</td>
    <td>该管理器控制会话并处理会话复制</td>
    <td><code>type=Manager,context=${APP.CONTEXT.PATH}, host=${HOST}</code></td>
    <td><code>type=Manager,context=${APP.CONTEXT.PATH}, host=${HOST}</code></td>
  </tr>

  <tr>
    <td>FarmWarDeployer</td>
    <td>管理将应用程序部署到集群中所有节点的过程</td>
    <td>不支持</td>
    <td><code>type=Cluster, host=${HOST}, component=deployer</code></td>
  </tr>

  <tr>
    <td>会员</td>
    <td>表示集群中的节点</td>
    <td>类型=集群，组件=成员，名称= $ {NODE_NAME}</td>
    <td><code>type=Cluster, host=${HOST}, component=member, name=${NODE_NAME}</code></td>
  </tr>

  <tr>
    <td>复制阀</td>
    <td>该阀控制到备份节点的复制</td>
    <td><code>type=Valve,name=ReplicationValve</code></td>
    <td><code>type=Valve,name=ReplicationValve,host=${HOST}</code></td>
  </tr>

  <tr>
    <td>JvmRouteBinderValve</td>
    <td>这是一个群集回退阀，用于将会话ID更改为当前的tomcat jvmroute。</td>
    <td><code>type=Valve,name=JvmRouteBinderValve, context=${APP.CONTEXT.PATH}</code></td>
    <td><code>type=Valve,name=JvmRouteBinderValve,host=${HOST}, context=${APP.CONTEXT.PATH}</code></td>
  </tr>

</tbody></table>
</div><h3 id="FAQ">常问问题</h3><div class="text">
<p>请参阅<a href="https://wiki.apache.org/tomcat/FAQ/Clustering">常见问题解答的群集部分</a> 。</p>
</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="./comments.html">这里</a>解释<a href="./comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>