<html lang="zh-Hans" ><head></head><body >﻿<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="./images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9（9.0.21）-Manager App的操作方法</title><meta name="author" content="Craig R. McClanahan"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/manager-howto">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="./images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="./images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="index.html">文件首页</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>用户指南</h2><ul><li><a href="introduction.html">1）简介</a></li><li><a href="setup.html">2）设定</a></li><li><a href="appdev/index.html">3）第一个webapp</a></li><li><a href="deployer-howto.html">4）部署者</a></li><li><a href="manager-howto.html">5）经理</a></li><li><a href="host-manager-howto.html">6）主机管理员</a></li><li><a href="realm-howto.html">7）领域和AAA</a></li><li><a href="security-manager-howto.html">8）安全经理</a></li><li><a href="jndi-resources-howto.html">9）JNDI资源</a></li><li><a href="jndi-datasource-examples-howto.html">10）JDBC数据源</a></li><li><a href="class-loader-howto.html">11）类加载</a></li><li><a href="jasper-howto.html">12）JSP</a></li><li><a href="ssl-howto.html">13）SSL / TLS</a></li><li><a href="ssi-howto.html">14）SSI</a></li><li><a href="cgi-howto.html">15）CGI</a></li><li><a href="proxy-howto.html">16）代理支持</a></li><li><a href="mbeans-descriptors-howto.html">17）MBean描述符</a></li><li><a href="default-servlet.html">18）默认Servlet</a></li><li><a href="cluster-howto.html">19）聚类</a></li><li><a href="balancer-howto.html">20）负载均衡器</a></li><li><a href="connectors.html">21）连接器</a></li><li><a href="monitoring.html">22）监控与管理</a></li><li><a href="logging.html">23）记录</a></li><li><a href="apr.html">24）APR /本地</a></li><li><a href="virtual-hosting-howto.html">25）虚拟主机</a></li><li><a href="aio.html">26）高级IO</a></li><li><a href="extras.html">27）附加组件</a></li><li><a href="maven-jars.html">28）行刑</a></li><li><a href="security-howto.html">29）安全注意事项</a></li><li><a href="windows-service-howto.html">30）Windows服务</a></li><li><a href="windows-auth-howto.html">31）Windows身份验证</a></li><li><a href="jdbc-pool.html">32）Tomcat的JDBC池</a></li><li><a href="web-socket-howto.html">33）WebSocket</a></li><li><a href="rewrite.html">34）改写</a></li></ul></div><div><h2>参考</h2><ul><li><a href="RELEASE-NOTES.txt">发行说明</a></li><li><a href="config/index.html">组态</a></li><li><a href="api/index.html">Tomcat Java文档</a></li><li><a href="servletapi/index.html">Servlet Java文档</a></li><li><a href="jspapi/index.html">JSP 2.3 Java文档</a></li><li><a href="elapi/index.html">EL 3.0 Java文档</a></li><li><a href="websocketapi/index.html">WebSocket 1.1 Java文档</a></li><li><a href="https://tomcat.apache.org/connectors-doc/">JK 1.2文档</a></li></ul></div><div><h2>Apache Tomcat开发</h2><ul><li><a href="building.html">建造</a></li><li><a href="changelog.html">变更日志</a></li><li><a href="https://wiki.apache.org/tomcat/TomcatVersions">状态</a></li><li><a href="developers.html">开发者</a></li><li><a href="architecture/index.html">建筑</a></li><li><a href="funcspecs/index.html">功能规格。</a></li><li><a href="tribes/introduction.html">部族</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>Manager App操作方法</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Introduction">介绍</a></li><li><a href="#Configuring_Manager_Application_Access">配置Manager应用程序访问</a></li><li><a href="#HTML_User-friendly_Interface">HTML用户友好界面</a></li><li><a href="#Supported_Manager_Commands">支持的管理器命令</a><ol><li><a href="#Common_Parameters">常用参数</a></li><li><a href="#Deploy_A_New_Application_Archive_(WAR)_Remotely">远程部署新的应用程序存档（WAR）</a></li><li><a href="#Deploy_A_New_Application_from_a_Local_Path">从本地路径部署新应用程序</a><ol><li><a href="#Deploy_a_previously_deployed_webapp">部署先前部署的Web应用程序</a></li><li><a href="#Deploy_a_Directory_or_WAR_by_URL">通过URL部署目录或WAR</a></li><li><a href="#Deploy_a_Directory_or_War_from_the_Host_appBase">从主机appBase部署目录或War</a></li><li><a href="#Deploy_using_a_Context_configuration_".xml"_file">使用上下文配置“ .xml”文件进行部署</a></li><li><a href="#Deployment_Notes">部署说明</a></li><li><a href="#Deploy_Response">部署响应</a></li></ol></li><li><a href="#List_Currently_Deployed_Applications">列出当前部署的应用程序</a></li><li><a href="#Reload_An_Existing_Application">重新加载现有的应用程序</a></li><li><a href="#List_OS_and_JVM_Properties">列出OS和JVM属性</a></li><li><a href="#List_Available_Global_JNDI_Resources">列出可用的全球JNDI资源</a></li><li><a href="#Session_Statistics">会话统计</a></li><li><a href="#Expire_Sessions">届满时间</a></li><li><a href="#Start_an_Existing_Application">启动现有的应用程序</a></li><li><a href="#Stop_an_Existing_Application">停止现有的应用程序</a></li><li><a href="#Undeploy_an_Existing_Application">取消部署现有应用程序</a></li><li><a href="#Finding_memory_leaks">查找内存泄漏</a></li><li><a href="#Connector_SSL/TLS_cipher_information">连接器SSL / TLS密码信息</a></li><li><a href="#Connector_SSL/TLS_certificate_chain_information">连接器SSL / TLS证书链信息</a></li><li><a href="#Connector_SSL/TLS_trusted_certificate_information">连接器SSL / TLS可信证书信息</a></li><li><a href="#Reload_TLS_configuration">重新加载TLS配置</a></li><li><a href="#Thread_Dump">线程转储</a></li><li><a href="#VM_Info">虚拟机信息</a></li><li><a href="#Save_Configuration">保存配置</a></li></ol></li><li><a href="#Server_Status">服务器状态</a></li><li><a href="#Using_the_JMX_Proxy_Servlet">使用JMX代理Servlet</a><ol><li><a href="#What_is_JMX_Proxy_Servlet">什么是JMX代理Servlet</a></li><li><a href="#JMX_Query_command">JMX查询命令</a></li><li><a href="#JMX_Get_command">JMX获取命令</a></li><li><a href="#JMX_Set_command">JMX Set命令</a></li><li><a href="#JMX_Invoke_command">JMX调用命令</a></li></ol></li><li><a href="#Executing_Manager_Commands_With_Ant">用Ant执行Manager命令</a><ol><li><a href="#Tasks_output_capture">任务输出捕获</a></li></ol></li></ul>
</div><h3 id="Introduction">介绍</h3><div class="text">

<p>在许多生产环境中，具有部署新的Web应用程序或取消部署现有Web应用程序的功能而不必关闭并重新启动整个容器的功能非常有用。此外，您可以请求现有应用程序重新加载自身，即使您尚未声明它是<code>reloadable</code>在Tomcat服务器配置文件中。</p>

<p>为了支持这些功能，Tomcat包括一个Web应用程序（默认安装在上下文路径中） <code>/manager</code> ），它支持以下功能：</p>
<ul>
<li>从WAR文件的上载内容部署新的Web应用程序。</li>
<li>从服务器文件系统在指定的上下文路径上部署新的Web应用程序。</li>
<li>列出当前部署的Web应用程序以及这些Web应用程序当前处于活动状态的会话。</li>
<li>重新加载现有的Web应用程序，以反映内容的变化<code>/WEB-INF/classes</code>要么<code>/WEB-INF/lib</code> 。
    </li>
<li>列出OS和JVM属性值。</li>
<li>列出可用的全局JNDI资源，以供正在准备的部署工具中使用<code><ResourceLink></code>嵌套在一个元素中<code><Context></code>部署说明。</li>
<li>启动已停止的应用程序（从而使其再次可用）。</li>
<li>停止现有应用程序（以使其不可用），但不要取消部署它。</li>
<li>取消部署已部署的Web应用程序并删除其文档基本目录（除非已从文件系统中部署它）。</li>
</ul>

<p>Tomcat的默认安装包括Manager。添加Manager Web应用程序的实例<code>Context</code>到新主机安装<code>manager.xml</code>上下文配置文件<code>$CATALINA_BASE/conf/[enginename]/[hostname]</code>夹。这是一个例子：</p>
<div class="codeBox"><pre><code>&lt;Context privileged="true" antiResourceLocking="false"
         docBase="${catalina.home}/webapps/manager"&gt;
  &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"
         allow="127\.0\.0\.1" /&gt;
&lt;/Context&gt;</code></pre></div>

<p>如果已将Tomcat配置为支持多个虚拟主机（网站），则需要为每个虚拟主机配置一个Manager。</p>

<p>有三种使用<strong>Manager</strong> Web应用程序的方法。</p>
<ul>
<li>作为具有用户界面的应用程序，您可以在浏览器中使用。这是一个示例网址，您可以在其中替换<code>localhost</code>使用您的网站主机名： <code>http://localhost:8080/manager/html</code> 。</li>
<li>仅使用HTTP请求的最低版本，适合系统管理员设置的脚本使用。命令作为请求URI的一部分提供，并且响应采用简单文本的形式，可以轻松地对其进行解析和处理。有关更多信息，请参见<a href="#Supported_Manager_Commands">支持的Manager命令</a> 。</li>
<li><em>Ant</em> （1.4版或更高版本）构建工具的一组方便的任务定义。有关更多信息，请参见<a href="#Executing_Manager_Commands_With_Ant">使用Ant执行Manager命令</a> 。</li>
</ul>

</div><h3 id="Configuring_Manager_Application_Access">配置Manager应用程序访问</h3><div class="text">


    <p><em>下面的描述使用变量名$ CATALINA_BASE来引用可解决大多数相对路径的基本目录。如果尚未通过设置CATALINA_BASE目录为多个实例配置Tomcat，则$ CATALINA_BASE将设置为$ CATALINA_HOME的值，该目录已将Tomcat安装到该目录中。</em></p>


<p>如果使用默认设置允许Internet上的任何人在您的服务器上执行Manager应用程序，则将Tomcat交付是非常不安全的。因此，附带的Manager应用程序要求任何尝试使用该应用程序的用户都必须使用具有与其关联的<strong>manager-xxx</strong>角色之一的用户名和密码进行身份验证（角色名称取决于所需的功能）。此外，默认用户文件中没有用户名（ <code>$CATALINA_BASE/conf/tomcat-users.xml</code> ）分配给这些角色。因此，默认情况下完全禁用对Manager应用程序的访问。</p>

<p>您可以在<code>web.xml</code> Web应用程序的文件。可用角色为：</p>

<ul>
  <li><strong>manager-gui-</strong>访问HTML界面。</li>
  <li><strong>manager-status-仅</strong>访问“服务器状态”页面。</li>
  <li><strong>manager-script</strong> —访问本文档中描述的工具友好的纯文本界面以及“服务器状态”页面。</li>
  <li><strong>manager-jmx-</strong>访问JMX代理界面和“服务器状态”页面。</li>
</ul>

<p>HTML界面受到了CSRF（跨站点请求伪造）攻击的保护，但是文本和JMX界面不能得到保护。这意味着在使用Web浏览器访问Manager应用程序时，被允许访问文本和JMX界面的用户必须谨慎。维护CSRF保护：</p>

<ul>
  <li>如果您使用具有浏览器<strong>脚本</strong>或<strong>管理员-jmx</strong>角色的用户（例如，用于测试纯文本或JMX界面）的用户使用Web浏览器访问Manager应用程序，则必须随后关闭浏览器的所有窗口以终止会话。如果您不关闭浏览器并访问其他站点，则可能成为CSRF攻击的受害者。</li>
  <li>建议不要向具有<strong>manager-gui</strong>角色的用户授予<strong>manager-script</strong>或<strong>manager-jmx</strong>角色。</li>
</ul>

<p><strong>请注意</strong> ，JMX代理接口实际上是Tomcat的低级类似于根的管理接口。如果他知道要调用什么命令，则可以做很多事情。启用<strong>manager-jmx</strong>角色时，请务必谨慎。</p>

<p>要启用对Manager Web应用程序的访问，您必须创建一个新的用户名/密码组合，并将其中的<strong>manager-xxx</strong>角色与之关联，或者将<strong>manager-xxx</strong>角色添加到某些现有的用户名/密码组合中。由于本文的大部分内容描述了文本界面的使用，因此本示例将使用角色名称<strong>manager-script</strong> 。用户名/密码的确切配置方式取决于您所使用的<a href="config/realm.html">Realm实现</a> ：</p>
<ul>
<li><em>UserDatabaseRealm</em>加上<em>MemoryUserDatabase</em>或<em>MemoryRealm</em> —默认情况下配置了<em>UserDatabaseRealm</em>和<em>MemoryUserDatabase</em> <code>$CATALINA_BASE/conf/server.xml</code> 。默认情况下， <em>MemoryUserDatabase</em>和<em>MemoryRealm都</em>读取XML格式的文件，该文件存储在<code>$CATALINA_BASE/conf/tomcat-users.xml</code> ，可以使用任何文本编辑器进行编辑。该文件包含XML <code><user></code>对于每个用户，可能看起来像这样：<div class="codeBox"><pre><code>&lt;user username="craigmcc" password="secret" roles="standard,manager-script" /&gt;</code></pre></div>其中定义了该个人用于登录的用户名和密码，以及他或她与之关联的角色名称。您可以将<strong>经理脚本</strong>角色添加到以逗号分隔的位置<code>roles</code>属性为一个或多个现有用户分配属性，和/或使用分配的角色创建新用户。</li>
<li><em>DataSourceRealm</em>或<em>JDBCRealm</em> —您的用户和角色信息存储在通过JDBC访问的数据库中。按照您环境的标准过程，将<strong>经理脚本</strong>角色添加到一个或多个现有用户，和/或创建一个或多个新用户，并为其分配了该角色。</li>
<li><em>JNDIRealm</em> —您的用户和角色信息存储在通过LDAP访问的目录服务器中。按照您环境的标准过程，将<strong>经理脚本</strong>角色添加到一个或多个现有用户，和/或创建一个或多个新用户，并为其分配了该角色。</li>
</ul>

<p>首次尝试发出下一节中描述的Manager命令之一时，将面临使用BASIC身份验证登录的挑战。输入的用户名和密码无关紧要，只要它们在用户数据库中标识拥有角色<strong>manager-script</strong>的有效用户即可。</p>

<p>除了密码限制之外，通过添加<strong>IP地址</strong>或主机，还可以通过<strong>远程IP地址</strong>或主机来限制对Manager Web应用程序的访问。 <code>RemoteAddrValve</code>要么<code>RemoteHostValve</code> 。有关详细信息，请参见<a href="config/valve.html#Remote_Address_Filter">阀门文档</a> 。这是通过IP地址限制对本地主机的访问的示例：</p>
<div class="codeBox"><pre><code>&lt;Context privileged="true"&gt;
         &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"
                allow="127\.0\.0\.1"/&gt;
&lt;/Context&gt;</code></pre></div>

</div><h3 id="HTML_User-friendly_Interface">HTML用户友好界面</h3><div class="text">

<p>Manager Web应用程序的用户友好HTML界面位于</p>

<div class="codeBox"><pre><code>http://{host}:{port}/manager/html</code></pre></div>

<p>如前所述，您需要具有<strong>manager-gui</strong>角色才能访问它。有一个单独的文档提供了有关此界面的帮助。看到：</p>

<ul>
  <li><a href="html-manager-howto.html">HTML Manager文档</a></li>
</ul>

<p>HTML界面受到了CSRF（跨站点请求伪造）攻击的保护。对HTML页面的每次访问都会生成一个随机令牌，该令牌存储在您的会话中，并包含在页面上的所有链接中。如果您的下一个操作没有正确的令牌值，则该操作将被拒绝。如果令牌已过期，则可以从Manager的主页或“ <em>列出应用程序”</em>页面重新开始。</p>

</div><h3 id="Supported_Manager_Commands">支持的管理器命令</h3><div class="text">

<p>Manager应用程序知道如何处理的所有命令都在单个请求URI中指定，如下所示：</p>
<div class="codeBox"><pre><code>http://{host}:{port}/manager/text/{command}?{parameters}</code></pre></div>
<p>哪里<code>{host}</code>和<code>{port}</code>代表运行Tomcat的主机名和端口号， <code>{command}</code>代表您要执行的Manager命令，并且<code>{parameters}</code>表示特定于该命令的查询参数。在以下插图中，为您的安装自定义主机和端口。</p>

<p>这些命令通常由HTTP GET请求执行。的<code>/deploy</code>命令具有由HTTP PUT请求执行的形式。</p>

<div class="subsection"><h4 id="Common_Parameters">常用参数</h4><div class="text">

<p>大多数命令接受以下一个或多个查询参数：</p>
<ul>
<li><strong>路径</strong> -你正在处理的Web应用程序的上下文路径（包括斜线）。要选择ROOT Web应用程序，请指定“ /”。
    <br>
    <strong>注意</strong> ：无法在Manager应用程序本身上执行管理命令。
    <br>
    <strong>注意</strong> ：如果未明确指定path参数，则将使用标准<a href="config/context.html#Naming">Context命名</a>规则从config参数或（如果不存在config参数的情况下）war参数派生路径和版本。</li>
<li><strong>版本</strong> - <a href="config/context.html">并行部署</a>功能使用的此Web应用程序的版本。如果在需要路径的任何地方使用并行部署，则除了路径之外，还必须指定版本，并且路径和版本的组合必须唯一，而不仅仅是路径。
    <br>
    <strong>注意</strong> ：如果未明确指定路径，则忽略version参数。</li>
<li><strong>war</strong> -Web应用程序存档（WAR）文件的URL，或包含Web应用程序的目录的路径名，或上下文配置“ .xml”文件。您可以使用以下任何格式的URL：<ul>
    <li><strong>文件：/ absolute / path / to / a / directory-</strong>包含Web应用程序解压缩版本的<strong>目录</strong>的绝对路径。该目录将被附加到您指定的上下文路径，而无需进行任何更改。</li>
    <li><strong>文件：/absolute/path/to/a/webapp.war-Web</strong>应用程序存档（WAR）文件的绝对路径。这<strong>仅</strong>适用于有效<code>/deploy</code>命令，并且是该命令唯一可接受的格式。</li>
    <li><strong>文件：/absolute/path/to/a/context.xml-Web</strong>应用程序上下文配置“ .xml”文件的绝对路径，该文件包含上下文配置元素。</li>
    <li><strong>directory-</strong>主机的应用程序基本目录中Web应用程序上下文的目录名称。</li>
    <li><strong>webapp.war-</strong>位于主机的应用程序基本目录中的Web应用程序war文件的名称。</li>
    </ul></li>
</ul>

<p>每个命令都将在<code>text/plain</code>格式（即没有HTML标记的纯ASCII），使人类和程序都易于阅读。响应的第一行将以<code>OK</code>要么<code>FAIL</code> ，指示请求的命令是否成功。如果发生故障，第一行的其余部分将包含所遇到问题的描述。某些命令包括其他信息行，如下所述。</p>

<p><em>国际化说明</em> -Manager应用程序在资源包中查找其消息字符串，因此可能已为您的平台转换了字符串。下面的示例显示消息的英语版本。</p>

</div></div>

<div class="subsection"><h4 id="Deploy_A_New_Application_Archive_(WAR)_Remotely">远程部署新的应用程序存档（WAR）</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy?path=/foo</code></pre></div>

<p>上载在此HTTP PUT请求中指定为请求数据的Web应用程序存档（WAR）文件，然后将其安装到<code>appBase</code>相应虚拟主机的目录，然后开始，获得添加到WAR文件中的WAR文件的名称<code>appBase</code>从指定路径开始。以后可以通过使用以下方式取消部署该应用程序（并删除相应的WAR文件）。 <code>/undeploy</code>命令。</p>

<p>该命令由HTTP PUT请求执行。</p>

<p>的。通过在其中包含上下文配置XML文件，WAR文件可以包括Tomcat特定的部署配置。 <code>/META-INF/context.xml</code> 。</p>

<p>URL参数包括：</p>
<ul>
<li><code>update</code> ：设置为true时，将首先取消部署任何现有更新。默认值设置为false。</li>
<li><code>tag</code> ：指定标签名称，这允许将已部署的Web应用程序与标签或标签相关联。如果取消部署Web应用程序，则以后可以仅在使用标签时重新部署它。</li>
<li><code>config</code> ：上下文配置“ .xml”文件的URL，格式为<strong>文件：/absolute/path/to/a/context.xml</strong> 。这必须是包含上下文配置元素的Web应用程序上下文配置“ .xml”文件的绝对路径。</li>
</ul>

<p><strong>注</strong> –此命令与<code>/undeploy</code>命令。</p>

<p>如果安装和启动成功，您将收到以下响应：</p>
<div class="codeBox"><pre><code>OK - Deployed application at context path /foo</code></pre></div>

<p>否则，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>应用程序已存在于路径/ foo中</em>
    <p>当前所有正在运行的Web应用程序的上下文路径必须唯一。因此，您必须使用此上下文路径取消部署现有的Web应用程序，或者为新的应用程序选择其他上下文路径。的<code>update</code>参数可以指定为URL上的参数，其值为<code>true</code>以避免此错误。在这种情况下，将在执行部署之前对现有应用程序执行取消部署。</p>
    </li>
<li><em>遇到异常</em>
    <p>尝试启动新的Web应用程序时遇到异常。检查Tomcat日志以获取详细信息，但可能的解释包括解析您的Tomcat时出现的问题<code>/WEB-INF/web.xml</code>文件，或初始化应用程序事件侦听器和过滤器时遇到缺少的类。</p>
    </li>
</ul>

</div></div>

<div class="subsection"><h4 id="Deploy_A_New_Application_from_a_Local_Path">从本地路径部署新应用程序</h4><div class="text">

<p>部署并启动附加到指定上下文的新Web应用程序<code>path</code> （不得被任何其他Web应用程序使用）。此命令与<code>/undeploy</code>命令。</p>

<p>该命令由HTTP GET请求执行。有许多不同的方式可以使用deploy命令。</p>

<div class="subsection"><h4 id="Deploy_a_previously_deployed_webapp">部署先前部署的Web应用程序</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy?path=/footoo&amp;tag=footag</code></pre></div>

<p>这可用于部署先前部署的Web应用程序，该应用程序已使用<code>tag</code>属性。请注意，Manager Webapp的工作目录将包含以前部署的WAR；删除它会使部署失败。</p>

</div></div>

<div class="subsection"><h4 id="Deploy_a_Directory_or_WAR_by_URL">通过URL部署目录或WAR</h4><div class="text">

<p>在Tomcat服务器上部署Web应用程序目录或“ .war”文件。如果不<code>path</code>指定后，路径和版本将从目录名或war文件名派生。的<code>war</code>参数指定一个网址（包括<code>file:</code>目录或Web应用程序归档（WAR）文件的方案）。引用WAR文件的URL支持的语法在Javadocs页面上针对<code>java.net.JarURLConnection</code>类。仅使用引用整个WAR文件的URL。</p>

<p>在此示例中，位于目录中的Web应用程序<code>/path/to/foo</code>在Tomcat服务器上部署为名为Web应用程序上下文<code>/footoo</code> 。</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy?path=/footoo&amp;war=file:/path/to/foo</code></pre></div>


<p>在此示例中，“。war”文件<code>/path/to/bar.war</code>在Tomcat服务器上部署为名为Web应用程序上下文<code>/bar</code> 。请注意，没有<code>path</code>参数，因此上下文路径默认为不带“ .war”扩展名的Web应用程序归档文件的名称。</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy?war=file:/path/to/bar.war</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Deploy_a_Directory_or_War_from_the_Host_appBase">从主机appBase部署目录或War</h4><div class="text">

<p>部署位于主机appBase目录中的Web应用程序目录或“ .war”文件。路径和可选版本来自目录或war文件名。</p>

<p>在此示例中，Web应用程序位于名为<code>foo</code> Tomcat服务器的Host appBase目录中的部署为名为的Web应用程序上下文<code>/foo</code> 。请注意，使用的上下文路径是Web应用程序目录的名称。</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy?war=foo</code></pre></div>


<p>在此示例中，“。war”文件<code>bar.war</code>位于Tomcat服务器上Host appBase目录中的服务器作为名为<code>/bar</code> 。</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy?war=bar.war</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Deploy_using_a_Context_configuration_" .xm="_file" ="">使用上下文配置“ .xml”文件进行部署</h4><div class="text">

<p>如果将Host deployXML标志设置为true，则可以使用上下文配置“ .xml”文件和可选的“ .war”文件或Web应用程序目录来部署Web应用程序。上下文<code>path</code>使用上下文“ .xml”配置文件部署Web应用程序时不使用。</p>

<p>上下文配置“ .xml”文件可以包含适用于Web应用程序上下文的有效XML，就像在Tomcat中对其进行配置一样<code>server.xml</code>配置文件。这是一个例子：</p>
<div class="codeBox"><pre><code>&lt;Context path="/foobar" docBase="/path/to/application/foobar"&gt;
&lt;/Context&gt;</code></pre></div>


<p>当可选<code>war</code>参数设置为Web应用程序“ .war”文件或目录的URL，它将覆盖上下文配置“ .xml”文件中配置的任何docBase。</p>

<p>这是一个使用上下文配置“ .xml”文件部署应用程序的示例。</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy?config=file:/path/context.xml</code></pre></div>


<p>这是使用服务器上的上下文配置“ .xml”文件和Web应用程序“ .war”文件部署应用程序的示例。</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/text/deploy
 ?config=file:/path/context.xml&amp;war=file:/path/bar.war</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Deployment_Notes">部署说明</h4><div class="text">

<p>如果为主机配置了unpackWARs = true且您部署了war文件，则战争将被解压缩到Host appBase目录中的目录中。</p>

<p>如果将应用程序war或目录安装在Host appBase目录中，并且Host配置为autoDeploy = true或Context路径必须与目录名称或war文件名匹配，且不带“ .war”扩展名。</p>

<p>为了确保不受信任的用户可以管理Web应用程序时的安全性，可以将Host deployXML标志设置为false。这可以防止不受信任的用户使用配置XML文件来部署Web应用程序，并且还可以防止他们部署位于其主机appBase外部的应用程序目录或“ .war”文件。</p>

</div></div>

<div class="subsection"><h4 id="Deploy_Response">部署响应</h4><div class="text">

<p>如果安装和启动成功，您将收到以下响应：</p>
<div class="codeBox"><pre><code>OK - Deployed application at context path /foo</code></pre></div>

<p>否则，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>应用程序已存在于路径/ foo中</em>
    <p>当前所有正在运行的Web应用程序的上下文路径必须唯一。因此，您必须使用此上下文路径取消部署现有的Web应用程序，或者为新的应用程序选择其他上下文路径。的<code>update</code>参数可以指定为URL上的参数，其值为<code>true</code>以避免此错误。在这种情况下，将在执行部署之前对现有应用程序执行取消部署。</p>
    </li>
<li><em>文档库不存在或目录不可读</em>
    <p>网址指定的网址<code>war</code>参数必须标识此服务器上包含Web应用程序“解压缩”版本的目录，或包含此应用程序的Web应用程序存档（WAR）文件的绝对URL。更正由<code>war</code>参数。</p>
    </li>
<li><em>遇到异常</em>
    <p>尝试启动新的Web应用程序时遇到异常。检查Tomcat日志以获取详细信息，但可能的解释包括解析您的Tomcat时出现的问题<code>/WEB-INF/web.xml</code>文件，或初始化应用程序事件侦听器和过滤器时遇到缺少的类。</p>
    </li>
<li><em>指定了无效的应用程序URL</em>
    <p>您指定的目录或Web应用程序的URL无效。此类网址必须以<code>file:</code> ，并且WAR文件的URL必须以“ .war”结尾。</p>
    </li>
<li><em>指定了无效的上下文路径</em>
    <p>上下文路径必须以斜杠字符开头。要引用ROOT Web应用程序，请使用“ /”。</p>
    </li>
<li><em>上下文路径必须与目录或WAR文件名匹配：</em>
    <p>如果将应用程序war或目录安装在Host appBase目录中，并且Host配置为autoDeploy = true，则Context路径必须与目录名称或war文件名匹配，且不带“ .war”扩展名。</p>
    </li>
<li><em>只能安装主机Web应用程序目录中的Web应用程序</em>
     <p>如果将Host deployXML标志设置为false，并且尝试将Web应用程序目录或“ .war”文件部署到Host appBase目录之外，则会发生此错误。
     </p></li>
</ul>

</div></div>
</div></div>

<div class="subsection"><h4 id="List_Currently_Deployed_Applications">列出当前部署的应用程序</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/list</code></pre></div>

<p>列出上下文路径，当前状态（ <code>running</code>要么<code>stopped</code> ），以及当前所有已部署的Web应用程序的活动会话数。启动Tomcat之后立即出现的典型响应如下所示：</p>
<div class="codeBox"><pre><code>OK - Listed applications for virtual host localhost
/webdav:running:0:webdav
/examples:running:0:examples
/manager:running:0:manager
/:running:0:ROOT
/test:running:0:test##2
/test:running:0:test##1</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Reload_An_Existing_Application">重新加载现有的应用程序</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/reload?path=/examples</code></pre></div>

<p>向现有应用发出信号以自行关闭并重新加载。当无法重新加载Web应用程序上下文并且您在其中更新了类或属性文件时，这很有用。 <code>/WEB-INF/classes</code>目录，或者在目录中添加或更新了jar文件时<code>/WEB-INF/lib</code>目录。
</p>

<p>如果此命令成功，您将看到如下响应：</p>
<div class="codeBox"><pre><code>OK - Reloaded application at context path /examples</code></pre></div>

<p>否则，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>遇到异常</em>
    <p>尝试重新启动Web应用程序时遇到异常。检查Tomcat日志以获取详细信息。</p>
    </li>
<li><em>指定了无效的上下文路径</em>
    <p>上下文路径必须以斜杠字符开头。要引用ROOT Web应用程序，请使用“ /”。</p>
    </li>
<li><em>路径/ foo不存在上下文</em>
    <p>您指定的上下文路径上没有部署的应用程序。</p>
    </li>
<li><em>没有指定上下文路径</em>
    <p>的<code>path</code>参数是必需的。
    </p></li>
<li><em>在路径/ foo上部署的WAR不支持重新加载</em>
    <p>目前，应用程序正在重新加载（以获取对类或<code>web.xml</code>直接从WAR文件部署Web应用程序时，不支持该文件）。仅当从解压目录中部署Web应用程序时，它才起作用。如果您使用的是WAR文件，则应<code>undeploy</code>然后<code>deploy</code>要么<code>deploy</code>与<code>update</code>再次对应用程序进行参数设置以获取更改。
    </p></li>
</ul>

</div></div>

<div class="subsection"><h4 id="List_OS_and_JVM_Properties">列出OS和JVM属性</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/serverinfo</code></pre></div>

<p>列出有关Tomcat版本，操作系统和JVM属性的信息。</p>

<p>如果发生错误，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>遇到异常</em>
    <p>尝试枚举系统属性时遇到异常。检查Tomcat日志以获取详细信息。</p>
    </li>
</ul>

</div></div>

<div class="subsection"><h4 id="List_Available_Global_JNDI_Resources">列出可用的全球JNDI资源</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/resources[?type=xxxxx]</code></pre></div>

<p>列出可在上下文配置文件的资源链接中使用的全局JNDI资源。如果您指定<code>type</code> request参数，该值必须是您感兴趣的资源类型的标准Java类名称（例如，您将指定<code>javax.sql.DataSource</code>获取所有可用JDBC数据源的名称）。如果不指定<code>type</code> request参数，将返回所有类型的资源。</p>

<p>取决于是否<code>type</code>是否指定了request参数，正常响应的第一行将是：</p>
<div class="codeBox"><pre><code>OK - Listed global resources of all types</code></pre></div>
<p>要么</p>
<div class="codeBox"><pre><code>OK - Listed global resources of type xxxxx</code></pre></div>
<p>每个资源后跟一行。每行由用冒号（“：”）定界的字段组成，如下所示：</p>
<ul>
<li><em>全局资源名称</em> -此全局JNDI资源的<em>名称</em> ，该名称将在<code>global</code>一个的属性<code><ResourceLink></code>元件。</li>
<li><em>全局资源类型</em> -此全局JNDI资源的标准Java类名称。</li>
</ul>

<p>如果发生错误，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>遇到异常</em>
    <p>尝试枚举全局JNDI资源时遇到异常。检查Tomcat日志以获取详细信息。</p>
    </li>
<li><em>没有可用的全球JNDI资源</em>
    <p>您正在运行的Tomcat服务器已配置为没有全局JNDI资源。</p>
    </li>
</ul>


</div></div>

<div class="subsection"><h4 id="Session_Statistics">会话统计</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/sessions?path=/examples</code></pre></div>

<p>显示Web应用程序的默认会话超时，以及当前处于活动状态的一分钟范围内的实际会话数。例如，重新启动Tomcat，然后在其中执行JSP示例之一后， <code>/examples</code>网络应用程序，您可能会收到类似以下内容的信息：</p>

<div class="codeBox"><pre><code>OK - Session information for application at context path /examples
Default maximum session inactive interval 30 minutes
&lt;1 minutes: 1 sessions
1 - &lt;2 minutes: 1 sessions</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Expire_Sessions">届满时间</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/expire?path=/examples&amp;idle=num</code></pre></div>

<p>显示会话统计信息（如上<code>/sessions</code>命令），并使闲置时间超过<code>num</code>分钟。要使所有会话到期，请使用<code>&idle=0</code> 。</p>

<div class="codeBox"><pre><code>OK - Session information for application at context path /examples
Default maximum session inactive interval 30 minutes
1 - &lt;2 minutes: 1 sessions
3 - &lt;4 minutes: 1 sessions
&gt;0 minutes: 2 sessions were expired</code></pre></div>

<p>其实<code>/sessions</code>和<code>/expire</code>是同一命令的同义词。不同之处在于存在<code>idle</code>参数。</p>

</div></div>

<div class="subsection"><h4 id="Start_an_Existing_Application">启动现有的应用程序</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/start?path=/examples</code></pre></div>

<p>发出停止的应用程序重新启动的信号，然后使其再次可用。停止和启动很有用，例如，如果应用程序所需的数据库暂时不可用。通常最好停止依赖此数据库的Web应用程序，而不是让用户不断遇到数据库异常。</p>

<p>如果此命令成功，您将看到如下响应：</p>
<div class="codeBox"><pre><code>OK - Started application at context path /examples</code></pre></div>

<p>否则，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>遇到异常</em>
    <p>尝试启动Web应用程序时遇到异常。检查Tomcat日志以获取详细信息。</p>
    </li>
<li><em>指定了无效的上下文路径</em>
    <p>上下文路径必须以斜杠字符开头。要引用ROOT Web应用程序，请使用“ /”。</p>
    </li>
<li><em>路径/ foo不存在上下文</em>
    <p>您指定的上下文路径上没有部署的应用程序。</p>
    </li>
<li><em>没有指定上下文路径</em>
    <p>的<code>path</code>参数是必需的。
    </p></li>
</ul>

</div></div>

<div class="subsection"><h4 id="Stop_an_Existing_Application">停止现有的应用程序</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/stop?path=/examples</code></pre></div>

<p>发信号通知现有应用程序使其不可用，但将其部署。在应用程序停止时出现的任何请求都将看到HTTP错误404，并且该应用程序在列表应用程序命令上将显示为“已停止”。</p>

<p>如果此命令成功，您将看到如下响应：</p>
<div class="codeBox"><pre><code>OK - Stopped application at context path /examples</code></pre></div>

<p>否则，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>遇到异常</em>
    <p>尝试停止Web应用程序时遇到异常。检查Tomcat日志以获取详细信息。</p>
    </li>
<li><em>指定了无效的上下文路径</em>
    <p>上下文路径必须以斜杠字符开头。要引用ROOT Web应用程序，请使用“ /”。</p>
    </li>
<li><em>路径/ foo不存在上下文</em>
    <p>您指定的上下文路径上没有部署的应用程序。</p>
    </li>
<li><em>未指定上下文路径</em> <code>path</code>参数是必需的。
    </li>
</ul>

</div></div>


<div class="subsection"><h4 id="Undeploy_an_Existing_Application">取消部署现有应用程序</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/undeploy?path=/examples</code></pre></div>

<p><strong><span style="color:red">警告</span> -此命令将删除其中存在的任何Web应用程序工件<code>appBase</code>此虚拟主机的目录（通常为“ webapps”）</strong> 。这将删除该应用程序。WAR（如果存在），是应用程序目录，它来自解压缩形式的部署或来自的目录。WAR扩展以及XML上下文定义来自<code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code>目录。如果您只是想使某个应用程序退出服务，则应使用<code>/stop</code>命令代替。</p>

<p>向现有应用程序发出信号，以使其正常关闭，然后将其从Tomcat中删除（这也使该上下文路径可用于以后重用）。此外，如果文档根目录存在于<code>appBase</code>该虚拟主机的目录（通常为“ webapps”）。此命令与<code>/deploy</code>命令。</p>

<p>如果此命令成功，您将看到如下响应：</p>
<div class="codeBox"><pre><code>OK - Undeployed application at context path /examples</code></pre></div>

<p>否则，响应将以<code>FAIL</code>并包含错误消息。问题的可能原因包括：</p>
<ul>
<li><em>遇到异常</em>
    <p>尝试取消部署Web应用程序时遇到异常。检查Tomcat日志以获取详细信息。</p>
    </li>
<li><em>指定了无效的上下文路径</em>
    <p>上下文路径必须以斜杠字符开头。要引用ROOT Web应用程序，请使用“ /”。</p>
    </li>
<li><em>不存在名为/ foo的上下文</em>
    <p>没有使用您指定的名称的已部署应用程序。</p>
    </li>
<li><em>未指定上下文路径</em> <code>path</code>参数是必需的。
    </li>
</ul>

</div></div>

<div class="subsection"><h4 id="Finding_memory_leaks">查找内存泄漏</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/findleaks[?statusLine=[true|false]]</code></pre></div>

<p><strong>查找泄漏诊断将触发完整的垃圾回收。在生产系统上使用时应格外小心。</strong></p>

<p>查找泄漏诊断尝试识别停止，重新加载或取消部署时导致内存泄漏的Web应用程序。应始终使用分析器确认结果。该诊断使用StandardHost实现提供的其他功能。如果使用不扩展StandardHost的自定义主机，它将无法正常工作。</p>

<p>据记录，从Java代码中明确触发完整的垃圾回收是不可靠的。此外，根据所使用的JVM，有一些选项可以禁用显式GC触发，例如<code>-XX:+DisableExplicitGC</code> 。如果要确保诊断程序已成功运行完整的GC，则需要使用GC日志记录，JConsole等工具进行检查。</p>

<p>如果此命令成功，您将看到如下响应：</p>
<div class="codeBox"><pre><code>/leaking-webapp</code></pre></div>

<p>如果您希望看到响应中包含状态行，请添加<code>statusLine</code>请求中的查询参数，其值为<code>true</code> 。</p>

<p>已停止，重新加载或取消部署但以前运行的哪些类仍在内存中加载的Web应用程序的每个上下文路径都将在新行中列出。如果某个应用程序已重新加载几次，则可能会列出几次。</p>

<p>如果命令不成功，响应将以<code>FAIL</code>并包含错误消息。</p>

</div></div>

<div class="subsection"><h4 id="Connector_SSL/TLS_cipher_information">连接器SSL / TLS密码信息</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/sslConnectorCiphers</code></pre></div>

<p>“ SSL连接器/密码”诊断列出了当前为每个连接器配置的SSL / TLS密码。对于NIO和NIO2，列出了各个密码套件的名称。对于APR，将返回SSLCipherSuite的值。</p>

<p>响应如下所示：</p>
<div class="codeBox"><pre><code>OK - Connector / SSL Cipher information
Connector[HTTP/1.1-8080]
  SSL is not enabled for this connector
Connector[HTTP/1.1-8443]
  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
  TLS_DHE_RSA_WITH_AES_128_CBC_SHA
  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
  ...</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Connector_SSL/TLS_certificate_chain_information">连接器SSL / TLS证书链信息</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/sslConnectorCerts</code></pre></div>

<p>“ SSL连接器/证书”诊断列出了当前为每个虚拟主机配置的证书链。</p>

<p>响应如下所示：</p>
<div class="codeBox"><pre><code>OK - Connector / Certificate Chain information
Connector[HTTP/1.1-8080]
SSL is not enabled for this connector
Connector[HTTP/1.1-8443]-_default_-RSA
[
[
  Version: V3
  Subject: CN=localhost, OU=Apache Tomcat PMC, O=The Apache Software Foundation, L=Wakefield, ST=MA, C=US
  Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11
  ...</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Connector_SSL/TLS_trusted_certificate_information">连接器SSL / TLS可信证书信息</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/sslConnectorTrustedCerts</code></pre></div>

<p>SSL连接器/证书诊断列出了当前为每个虚拟主机配置的受信任证书。</p>

<p>响应如下所示：</p>
<div class="codeBox"><pre><code>OK - Connector / Trusted Certificate information
Connector[HTTP/1.1-8080]
SSL is not enabled for this connector
Connector[AJP/1.3-8009]
SSL is not enabled for this connector
Connector[HTTP/1.1-8443]-_default_
[
[
  Version: V3
  Subject: CN=Apache Tomcat Test CA, OU=Apache Tomcat PMC, O=The Apache Software Foundation, L=Wakefield, ST=MA, C=US
  ...</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Reload_TLS_configuration">重新加载TLS配置</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/sslReload?tlsHostName=name</code></pre></div>

<p>重新加载TLS配置文件（证书和密钥文件，这不会触发对server.xml的重新分析）。要为所有主机重新加载文件，请不要指定<code>tlsHostName</code>参数。</p>

<div class="codeBox"><pre><code>OK - Reloaded TLS configuration for [_default_]</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Thread_Dump">线程转储</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/threaddump</code></pre></div>

<p>编写JVM线程转储。</p>

<p>响应如下所示：</p>
<div class="codeBox"><pre><code>OK - JVM thread dump
2014-12-08 07:24:40.080
Full thread dump Java HotSpot(TM) Client VM (25.25-b02 mixed mode):

"http-nio-8080-exec-2" Id=26 cpu=46800300 ns usr=46800300 ns blocked 0 for -1 ms waited 0 for -1 ms
   java.lang.Thread.State: RUNNABLE
        locks java.util.concurrent.ThreadPoolExecutor$Worker@1738ad4
        at sun.management.ThreadImpl.dumpThreads0(Native Method)
        at sun.management.ThreadImpl.dumpAllThreads(ThreadImpl.java:446)
        at org.apache.tomcat.util.Diagnostics.getThreadDump(Diagnostics.java:440)
        at org.apache.tomcat.util.Diagnostics.getThreadDump(Diagnostics.java:409)
        at org.apache.catalina.manager.ManagerServlet.threadDump(ManagerServlet.java:557)
        at org.apache.catalina.manager.ManagerServlet.doGet(ManagerServlet.java:371)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:618)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:725)
...
</code></pre></div>

</div></div>

<div class="subsection"><h4 id="VM_Info">虚拟机信息</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/vminfo</code></pre></div>

<p>编写一些有关Java虚拟机的诊断信息。</p>

<p>响应如下所示：</p>
<div class="codeBox"><pre><code>OK - VM info
2014-12-08 07:27:32.578
Runtime information:
  vmName: Java HotSpot(TM) Client VM
  vmVersion: 25.25-b02
  vmVendor: Oracle Corporation
  specName: Java Virtual Machine Specification
  specVersion: 1.8
  specVendor: Oracle Corporation
  managementSpecVersion: 1.2
  name: ...
  startTime: 1418012458849
  uptime: 393855
  isBootClassPathSupported: true

OS information:
...
</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Save_Configuration">保存配置</h4><div class="text">

<div class="codeBox"><pre><code>http://localhost:8080/manager/text/save</code></pre></div>

<p>如果未指定任何参数，则此命令会将服务器的当前配置保存到server.xml。如果需要，现有文件将重命名为备份。</p>

<p>如果指定了<code>path</code>参数，该参数与已部署的Web应用程序的路径匹配，则该Web应用程序的配置将保存到以下位置中适当命名的context.xml文件中： <code>xmlBase</code>当前主机。</p>

<p>要使用该命令，必须存在StoreConfig MBean。通常，这是使用<a href="config/listeners.html#StoreConfig_Lifecycle_Listener_-_org.apache.catalina.storeconfig.StoreConfigLifecycleListener">StoreConfigLifecycleListener</a>配置的。
</p>

<p>如果命令不成功，响应将以<code>FAIL</code>并包含错误消息。</p>

</div></div>

</div><h3 id="Server_Status">服务器状态</h3><div class="text">

<p>通过以下链接，您可以查看有关服务器的状态信息。<strong>manager-xxx</strong>角色中的任何一个都允许访问此页面。</p>

<div class="codeBox"><pre><code>http://localhost:8080/manager/status
http://localhost:8080/manager/status/all</code></pre></div>

<p>以HTML格式显示服务器状态信息。</p>

<div class="codeBox"><pre><code>http://localhost:8080/manager/status?XML=true
http://localhost:8080/manager/status/all?XML=true</code></pre></div>

<p>以XML格式显示服务器状态信息。</p>

<p>首先，您具有服务器和JVM版本号，JVM提供程序，操作系统名称和编号，然后是体系结构类型。</p>

<p>其次，有关于JVM内存使用情况的信息。</p>

<p>然后，有关于Tomcat AJP和HTTP连接器的信息。两者都可以使用相同的信息：</p>
<ul>
    <li><p>线程信息：最大线程，最小和最大备用线程，当前线程数和当前线程繁忙。</p></li>
    <li><p>请求信息：最大处理时间和处理时间，请求和错误计数，接收和发送的字节数。</p></li>
    <li><p>该表显示阶段，时间，发送的字节数，接收的字节数，客户端，VHost和请求。表中列出了所有现有线程。这是可能的线程阶段的列表：</p>
    <ul>
        <li><p><em>“解析并准备请求”</em> ：正在解析请求标头，或者正在进行必要的准备工作以读取请求正文（如果已指定传输编码）。</p></li>
        <li><p><em>“服务”</em> ：线程正在处理请求并生成响应。此阶段在“解析和准备请求”阶段之后，并且在“完成”阶段之前。在此阶段，始终有至少一个线程（服务器状态页面）。</p></li>
        <li><p><em>“完成”</em> ：请求处理的结束。仍保留在输出缓冲区中的任何其余响应都将发送到客户端。如果适合使连接保持活动状态，则此阶段之后为“保持活动”，如果不适合则保持“就绪”。</p></li>
        <li><p><em>“ Keep-Alive”</em> ：如果客户端发送另一个请求，线程将保持与客户端的连接打开。如果收到另一个请求，则下一阶段将是“解析并准备请求”。如果在保持活动超时之前未收到任何请求，则连接将关闭，下一阶段将为“就绪”。</p></li>
        <li><p><em>“就绪”</em> ：线程处于静止状态并准备使用。</p></li>
    </ul>
    </li>
</ul>

<p>如果您正在使用<code>/status/all</code>命令，有关每个已部署的Web应用程序的附加信息将可用。</p>

</div><h3 id="Using_the_JMX_Proxy_Servlet">使用JMX代理Servlet</h3><div class="text">

  <div class="subsection"><h4 id="What_is_JMX_Proxy_Servlet">什么是JMX代理Servlet</h4><div class="text">JMX代理Servlet是一种轻量级代理，用于获取和设置tomcat内部。（或任何通过MBean公开的类）它的用法不是非常用户友好，但是UI对于集成用于监视和更改tomcat内部的命令行脚本非常有帮助。您可以使用代理执行两件事：获取信息和设置信息。为了真正了解JMX代理Servlet，您应该对JMX有一个一般的了解。如果您不知道JMX是什么，那么请做好准备。
  </div></div>

  <div class="subsection"><h4 id="JMX_Query_command">JMX查询命令</h4><div class="text">
    <p>它采用以下形式：</p>
<div class="codeBox"><pre><code>http://webserver/manager/jmxproxy/?qry=STUFF</code></pre></div>
    <p>哪里<code>STUFF</code>是您希望执行的JMX查询。例如，以下是您可能希望运行的一些查询：</p>
    <ul>
      <li>
        <code>qry=*%3Atype%3DRequestProcessor%2C* --> type=RequestProcessor</code>它将找到所有可以处理请求并报告其状态的工作人员。
      </li>
      <li>
        <code>qry=*%3Aj2eeType=Servlet%2c* --> j2eeType=Servlet</code>返回所有已加载的servlet。
      </li>
      <li>
        <code>qry=Catalina%3Atype%3DEnvironment%2Cresourcetype%3DGlobal%2Cname%3DsimpleValue --> Catalina:type=Environment,resourcetype=Global,name=simpleValue</code>通过给定名称查找特定的MBean。
      </li>
    </ul>
    <p>您需要尝试一下才能真正了解其功能。 <code>qry</code>参数，那么将显示所有MBean。我们确实建议您查看tomcat源代码并了解JMX规范，以更好地了解您可能会运行的所有查询。
    </p>
  </div></div>

  <div class="subsection"><h4 id="JMX_Get_command">JMX获取命令</h4><div class="text">
  <p>JXMProxyServlet还支持“ get”命令，您可以使用该命令来获取特定MBean属性的值。的一般形式<code>get</code>命令是：</p>

<div class="codeBox"><pre><code>http://webserver/manager/jmxproxy/?get=BEANNAME&amp;att=MYATTRIBUTE&amp;key=MYKEY</code></pre></div>

    <p>您必须提供以下参数：</p>
    <ol>
      <li><code>get</code> ：完整的Bean名称</li>
      <li><code>att</code> ：您希望获取的属性</li>
      <li><code>key</code> ：（可选）进入CompositeData MBean属性的键</li>
    </ol>
    <p>如果一切顺利，则提示“ OK”，否则将显示错误消息。例如，假设我们希望获取当前的堆内存数据：</p>

<div class="codeBox"><pre><code>http://webserver/manager/jmxproxy/?get=java.lang:type=Memory&amp;att=HeapMemoryUsage</code></pre></div>

    <p>或者，如果您只想要“ used”键：</p>

<div class="codeBox"><pre><code>http://webserver/manager/jmxproxy/
 ?get=java.lang:type=Memory&amp;att=HeapMemoryUsage&amp;key=used</code></pre></div>
  </div></div>

  <div class="subsection"><h4 id="JMX_Set_command">JMX Set命令</h4><div class="text">
    <p>现在，您可以查询MBean了，现在该浪费Tomcat的内部知识了！set命令的一般形式为：</p>
<div class="codeBox"><pre><code>http://webserver/manager/jmxproxy/?set=BEANNAME&amp;att=MYATTRIBUTE&amp;val=NEWVALUE</code></pre></div>
    <p>因此，您需要提供3个请求参数：</p>
    <ol>
      <li><code>set</code> ：完整的Bean名称</li>
      <li><code>att</code> ：您希望更改的属性</li>
      <li><code>val</code> ：新价值</li>
    </ol>
    <p>如果一切正常，则会显示“ OK”，否则将显示错误消息。例如，假设我们希望为<code>ErrorReportValve</code> 。以下将调试设置为10。
    </p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/jmxproxy/
 ?set=Catalina%3Atype%3DValve%2Cname%3DErrorReportValve%2Chost%3Dlocalhost
 &amp;att=debug&amp;val=10</code></pre></div>
    <p>我的结果是（YMMV）：</p>
<div class="codeBox"><pre><code>Result: ok</code></pre></div>

    <p>如果我传递的值不正确，这就是我看到的。这是我使用的URL，我尝试将调试设置为“ cow”：</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/jmxproxy/
 ?set=Catalina%3Atype%3DValve%2Cname%3DErrorReportValve%2Chost%3Dlocalhost
 &amp;att=debug&amp;val=cow</code></pre></div>
    <p>当我尝试时，我的结果是</p>
<div class="codeBox"><pre><code>Error: java.lang.NumberFormatException: For input string: "cow"</code></pre></div>
  </div></div>

  <div class="subsection"><h4 id="JMX_Invoke_command">JMX调用命令</h4><div class="text">
    <p>的<code>invoke</code>命令使方法可以在MBean上调用。该命令的一般形式为：</p>
<div class="codeBox"><pre><code>http://webserver/manager/jmxproxy/
 ?invoke=BEANNAME&amp;op=METHODNAME&amp;ps=COMMASEPARATEDPARAMETERS</code></pre></div>
    <p>例如，调用<code>findConnectors()</code> <strong>服务</strong>使用方法：</p>
<div class="codeBox"><pre><code>http://localhost:8080/manager/jmxproxy/
 ?invoke=Catalina%3Atype%3DService&amp;op=findConnectors&amp;ps=</code></pre></div>
  </div></div>
</div><h3 id="Executing_Manager_Commands_With_Ant">用Ant执行Manager命令</h3><div class="text">

<p>如上所述，除了可以通过HTTP请求执行Manager命令的功能之外，Tomcat还提供了一组方便的用于<em>Ant</em> （1.4版或更高版本）构建工具的Task定义。为了使用这些命令，您必须执行以下设置操作：</p>
<ul>
<li>从<a href="https://ant.apache.org">https://ant.apache.org</a>下载Ant的二进制发行版。您必须使用<strong>1.4</strong>或更高版本。</li>
<li>将Ant发行版安装在方便的目录中（在本说明的其余部分中称为ANT_HOME）。</li>
<li>添加<code>$ANT_HOME/bin</code>目录到您的<code>PATH</code>环境变量。</li>
<li>在Tomcat用户数据库中至少配置一个用户名/密码组合，其中包括<code>manager-script</code>角色。</li>
</ul>

<p>要在Ant中使用自定义任务，必须先使用<code><import></code>元件。因此，您的<code>build.xml</code>文件可能看起来像这样：</p>

<div class="codeBox"><pre><code>&lt;project name="My Application" default="compile" basedir="."&gt;

  &lt;!-- Configure the directory into which the web application is built --&gt;
  &lt;property name="build"    value="${basedir}/build"/&gt;

  &lt;!-- Configure the context path for this application --&gt;
  &lt;property name="path"     value="/myapp"/&gt;

  &lt;!-- Configure properties to access the Manager application --&gt;
  &lt;property name="url"      value="http://localhost:8080/manager/text"/&gt;
  &lt;property name="username" value="myusername"/&gt;
  &lt;property name="password" value="mypassword"/&gt;

  &lt;!-- Configure the path to the Tomcat installation --&gt;
  &lt;property name="catalina.home" value="/usr/local/apache-tomcat"/&gt;

  &lt;!-- Configure the custom Ant tasks for the Manager application --&gt;
  &lt;import file="${catalina.home}/bin/catalina-tasks.xml"/&gt;

  &lt;!-- Executable Targets --&gt;
  &lt;target name="compile" description="Compile web application"&gt;
    &lt;!-- ... construct web application in ${build} subdirectory, and
            generated a ${path}.war ... --&gt;
  &lt;/target&gt;

  &lt;target name="deploy" description="Install web application"
          depends="compile"&gt;
    &lt;deploy url="${url}" username="${username}" password="${password}"
            path="${path}" war="file:${build}${path}.war"/&gt;
  &lt;/target&gt;

  &lt;target name="reload" description="Reload web application"
          depends="compile"&gt;
    &lt;reload  url="${url}" username="${username}" password="${password}"
            path="${path}"/&gt;
  &lt;/target&gt;

  &lt;target name="undeploy" description="Remove web application"&gt;
    &lt;undeploy url="${url}" username="${username}" password="${password}"
            path="${path}"/&gt;
  &lt;/target&gt;

&lt;/project&gt;</code></pre></div>

<p>注意：通过上面的导入对资源任务的定义将覆盖Ant 1.7中添加的资源数据类型。如果您希望使用资源数据类型，则需要使用Ant的名称空间支持进行修改<code>catalina-tasks.xml</code>将Tomcat任务分配给自己的名称空间。</p>

<p>现在，您可以执行如下命令<code>ant deploy</code>将应用程序部署到正在运行的Tomcat实例，或<code>ant reload</code>告诉Tomcat重新加载它。还要注意，在此最有趣的值<code>build.xml</code>文件被定义为可替换属性，因此您可以从命令行覆盖它们的值。例如，您可能认为将真实的管理员密码包含在自己的帐户中会带来安全风险<code>build.xml</code>文件的源代码。为避免这种情况，请省略password属性，然后在命令行中指定它：</p>
<div class="codeBox"><pre><code>ant -Dpassword=secret deploy</code></pre></div>

<div class="subsection"><h4 id="Tasks_output_capture">任务输出捕获</h4><div class="text">

<p>使用<em>Ant</em>版本<strong>1.6.2</strong>或更高版本，Catalina任务提供了在属性或外部文件中捕获其输出的选项。他们直接支持以下<code><redirector></code>类型属性：</p>

<table class="defaultTable">
<tbody><tr>
<th>属性</th>
<th>描述</th>
<th style="text-align:center">需要</th>
</tr>
<tr>
<td>输出</td>
<td>要向其写入输出的文件的名称。如果错误流也未重定向到文件或属性，它将显示在此输出中。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td>错误</td>
<td>该命令的标准错误应重定向到的文件。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td>logError</td>
<td>当您希望在Ant的日志中看到错误输出并且将输出重定向到文件/属性时，可以使用此属性。错误输出将不包含在输出文件/属性中。如果使用<i>error</i>或<i>errorProperty</i>属性重定向错误，则将无效。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td>附加</td>
<td>输出文件和错误文件应附加还是覆盖。默认为<code>false</code> 。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td>createemptyfiles</td>
<td>即使为空，是否也应创建输出文件和错误文件。默认为<code>true</code> 。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td>输出属性</td>
<td>应在其中存储命令输出的属性的名称。除非错误流被重定向到单独的文件或流，否则此属性将包括错误输出。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td>错误属性</td>
<td>应该在其中存储命令的标准错误的属性的名称。</td>
<td style="text-align:center">没有</td>
</tr>
</tbody></table>

<p>还可以指定几个其他属性：</p>
<table class="defaultTable">
<tbody><tr>
<th>属性</th>
<th>描述</th>
<th style="text-align:center">需要</th>
</tr>
<tr>
<td>alwaysLog</td>
<td>当您希望查看正在捕获的输出时，也可以使用此属性，它也会出现在Ant的日志中。除非要捕获任务输出，否则不得使用它。默认为<code>false</code> 。
<em>此属性将直接受到支持<code><redirector></code>在Ant 1.6.3中</em></td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td>故障错误</td>
<td>当您希望避免任何管理器命令处理错误终止蚂蚁执行时，使用此属性。默认为<code>true</code> 。必须将其设置为<code>false</code> ，如果您想捕获错误输出，否则执行将在捕获任何内容之前终止。
<br>此属性仅对管理器命令执行起作用，任何错误或丢失的命令属性仍将导致Ant执行终止。
</td>
<td style="text-align:center">没有</td>
</tr>
</tbody></table>

<p>它们还支持嵌入式<code><redirector></code>您可以在其中指定其完整属性集的元素，但是<code>input</code> ， <code>inputstring</code>和<code>inputencoding</code>即使被接受，也不会使用，因为它们在此上下文中没有任何意义。有关详细信息，请参阅<a href="https://ant.apache.org">蚂蚁手册</a> 。 <code><redirector></code>元素属性。
</p>

<p>这是一个示例构建文件摘要，显示了如何使用此输出重定向支持：</p>

<div class="codeBox"><pre><code>    &lt;target name="manager.deploy"
        depends="context.status"
        if="context.notInstalled"&gt;
        &lt;deploy url="${mgr.url}"
            username="${mgr.username}"
            password="${mgr.password}"
            path="${mgr.context.path}"
            config="${mgr.context.descriptor}"/&gt;
    &lt;/target&gt;

    &lt;target name="manager.deploy.war"
        depends="context.status"
        if="context.deployable"&gt;
        &lt;deploy url="${mgr.url}"
            username="${mgr.username}"
            password="${mgr.password}"
            update="${mgr.update}"
            path="${mgr.context.path}"
            war="${mgr.war.file}"/&gt;
    &lt;/target&gt;

    &lt;target name="context.status"&gt;
        &lt;property name="running" value="${mgr.context.path}:running"/&gt;
        &lt;property name="stopped" value="${mgr.context.path}:stopped"/&gt;

        &lt;list url="${mgr.url}"
            outputproperty="ctx.status"
            username="${mgr.username}"
            password="${mgr.password}"&gt;
        &lt;/list&gt;

        &lt;condition property="context.running"&gt;
            &lt;contains string="${ctx.status}" substring="${running}"/&gt;
        &lt;/condition&gt;
        &lt;condition property="context.stopped"&gt;
            &lt;contains string="${ctx.status}" substring="${stopped}"/&gt;
        &lt;/condition&gt;
        &lt;condition property="context.notInstalled"&gt;
            &lt;and&gt;
                &lt;isfalse value="${context.running}"/&gt;
                &lt;isfalse value="${context.stopped}"/&gt;
            &lt;/and&gt;
        &lt;/condition&gt;
        &lt;condition property="context.deployable"&gt;
            &lt;or&gt;
                &lt;istrue value="${context.notInstalled}"/&gt;
                &lt;and&gt;
                    &lt;istrue value="${context.running}"/&gt;
                    &lt;istrue value="${mgr.update}"/&gt;
                &lt;/and&gt;
                &lt;and&gt;
                    &lt;istrue value="${context.stopped}"/&gt;
                    &lt;istrue value="${mgr.update}"/&gt;
                &lt;/and&gt;
            &lt;/or&gt;
        &lt;/condition&gt;
        &lt;condition property="context.undeployable"&gt;
            &lt;or&gt;
                &lt;istrue value="${context.running}"/&gt;
                &lt;istrue value="${context.stopped}"/&gt;
            &lt;/or&gt;
        &lt;/condition&gt;
    &lt;/target&gt;</code></pre></div>

<p><strong>警告：</strong>即使多次调用Catalina任务并没有多大意义，并且总是一个坏主意，但错误设置的Ant任务依赖链可能会导致在同一Ant运行中多次调用一个任务，即使如果不是故意的。在捕获该任务的输出时，应格外小心，因为这可能会导致意外情况：</p>
<ul>
<li>在捕获属性时，您只会在<em>第一个</em>调用中找到输出，因为Ant属性是不可变的，一旦设置，就无法更改，</li>
<li>捕获文件时，每次运行都会覆盖它，并且您只会在其中找到<em>最后一个</em>调用输出，除非您正在使用<code>append="true"</code>属性，在这种情况下，您将看到每个任务调用的输出附加到文件中。
</li>
</ul>

</div></div>

</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="./comments.html">这里</a>解释<a href="./comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>