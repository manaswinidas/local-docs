<html lang="zh-Hans" ><head></head><body >﻿<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="../images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9配置参考（9.0.21）-HTTP连接器</title><meta name="author" content="Craig R. McClanahan"><meta name="author" content="Yoav Shapira"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/config/http">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="../images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="../images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9配置参考</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="../index.html">文件首页</a></li><li><a href="index.html">配置参考家</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>顶级元素</h2><ul><li><a href="server.html">服务器</a></li><li><a href="service.html">服务</a></li></ul></div><div><h2>执行者</h2><ul><li><a href="executor.html">执行者</a></li></ul></div><div><h2>连接器</h2><ul><li><a href="http.html">HTTP / 1.1</a></li><li><a href="http2.html">HTTP / 2</a></li><li><a href="ajp.html">AJP</a></li></ul></div><div><h2>货柜</h2><ul><li><a href="context.html">语境</a></li><li><a href="engine.html">发动机</a></li><li><a href="host.html">主办</a></li><li><a href="cluster.html">簇</a></li></ul></div><div><h2>嵌套组件</h2><ul><li><a href="cookie-processor.html">Cookie处理器</a></li><li><a href="credentialhandler.html">凭证处理程序</a></li><li><a href="globalresources.html">全球资源</a></li><li><a href="jar-scanner.html">JarScanner</a></li><li><a href="jar-scan-filter.html">JarScanFilter</a></li><li><a href="listeners.html">听众</a></li><li><a href="loader.html">装载机</a></li><li><a href="manager.html">经理</a></li><li><a href="realm.html">领域</a></li><li><a href="resources.html">资源资源</a></li><li><a href="sessionidgenerator.html">SessionIdGenerator</a></li><li><a href="valve.html">阀</a></li></ul></div><div><h2>集群元素</h2><ul><li><a href="cluster.html">簇</a></li><li><a href="cluster-manager.html">经理</a></li><li><a href="cluster-channel.html">渠道</a></li><li><a href="cluster-membership.html">频道/会员</a></li><li><a href="cluster-sender.html">频道/发件人</a></li><li><a href="cluster-receiver.html">频道/接收器</a></li><li><a href="cluster-interceptor.html">通道/拦截器</a></li><li><a href="cluster-valve.html">阀</a></li><li><a href="cluster-deployer.html">部署者</a></li><li><a href="cluster-listener.html">集群监听器</a></li></ul></div><div><h2>web.xml</h2><ul><li><a href="filter.html">过滤</a></li></ul></div><div><h2>其他</h2><ul><li><a href="systemprops.html">系统属性</a></li><li><a href="jaspic.html">日本宝石</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>HTTP连接器</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Introduction">介绍</a></li><li><a href="#Attributes">属性</a><ol><li><a href="#Common_Attributes">共同属性</a></li><li><a href="#Standard_Implementation">标准实施</a></li><li><a href="#Java_TCP_socket_attributes">Java TCP套接字属性</a></li><li><a href="#NIO_specific_configuration">NIO特定配置</a></li><li><a href="#NIO2_specific_configuration">NIO2特定配置</a></li><li><a href="#APR/native_specific_configuration">APR /本机特定配置</a></li></ol></li><li><a href="#Nested_Components">嵌套组件</a></li><li><a href="#Special_Features">特殊功能</a><ol><li><a href="#HTTP/1.1_and_HTTP/1.0_Support">HTTP / 1.1和HTTP / 1.0支持</a></li><li><a href="#HTTP/2_Support">HTTP / 2支持</a></li><li><a href="#Proxy_Support">代理支持</a></li><li><a href="#SSL_Support">SSL支持</a></li><li><a href="#SSL_Support_-_SSLHostConfig">SSL支持-SSLHostConfig</a></li><li><a href="#SSL_Support_-_Certificate">SSL支持-证书</a></li><li><a href="#SSL_Support_-_Connector_-_NIO_and_NIO2">SSL支持-连接器-NIO和NIO2</a></li><li><a href="#SSL_Support_-_Connector_-_NIO_and_NIO2_(deprecated)">SSL支持-连接器-NIO和NIO2（已弃用）</a></li><li><a href="#SSL_Support_-_Connector_-_APR/Native_(deprecated)">SSL支持-连接器-APR /本机（不建议使用）</a></li><li><a href="#Connector_Comparison">连接器比较</a></li></ol></li></ul>
</div><h3 id="Introduction">介绍</h3><div class="text">

  <p><strong>HTTP Connector</strong>元素代表支持HTTP / 1.1协议的<strong>Connector</strong>组件。除了执行Servlet和JSP页面的功能外，它还使Catalina能够充当独立的Web服务器。该组件的特定实例侦听服务器上特定TCP端口号上的连接。可以将一个或多个此类<strong>连接器</strong>配置为单个<a href="service.html">服务的</a>一部分，每个<strong>连接器</strong>都转发到关联的<a href="engine.html">引擎</a>以执行请求处理并创建响应。</p>

  <p>如果您希望配置用于通过AJP协议连接到Web服务器的<strong>连接器</strong> （例如<code>mod_jk 1.2.x</code> Apache 1.3的连接器），请参阅<a href="ajp.html">AJP连接器</a>文档。</p>

  <p>每个传入请求在该请求期间需要一个线程。如果接收到的并发请求多于当前可用请求处理线程所能处理的数量，则将创建其他线程，直到配置的最大值（ <code>maxThreads</code>属性）。如果收到更多同时请求，则将它们堆积在<strong>连接器</strong>创建的服务器套接字内，直到配置的最大值（ <code>acceptCount</code>属性）。任何进一步的同时请求都将收到“连接被拒绝”错误，直到有足够的资源来处理它们为止。</p>

</div><h3 id="Attributes">属性</h3><div class="text">

  <div class="subsection"><h4 id="Common_Attributes">共同属性</h4><div class="text">

  <p><strong>连接器的</strong>所有实现均支持以下属性：</p>

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">allowTrace</code></td><td>
      <p>一个布尔值，可用于启用或禁用TRACE HTTP方法。如果未指定，则此属性设置为false。</p>
    </td></tr><tr><td><code class="attributeName">asyncTimeout</code></td><td>
      <p>异步请求的默认超时（以毫秒为单位）。如果未指定，则此属性设置为Servlet规范默认值30000（30秒）。</p>
    </td></tr><tr><td><code class="attributeName">defaultSSLHostConfigName</code></td><td>
      <p>如果客户端连接不提供SNI或提供了SNI但与任何已配置的<strong>SSLHostConfig</strong>不匹配，则将用于安全连接（如果此连接器配置为安全连接）的默认<strong>SSLHostConfig</strong>的名称。如果未指定，则默认值为<code>_default_</code>将会被使用。</p>
    </td></tr><tr><td><code class="attributeName">enableLookups</code></td><td>
      <p>调成<code>true</code>如果您想致电<code>request.getRemoteHost()</code>执行DNS查找以返回远程客户端的实际主机名。调成<code>false</code>跳过DNS查找并改为以字符串形式返回IP地址（从而提高性能）。默认情况下，DNS查找被禁用。</p>
    </td></tr><tr><td><code class="attributeName">maxHeaderCount</code></td><td>
      <p>容器允许的请求中的最大标头数。标头超过指定限制的请求将被拒绝。小于0的值表示没有限制。如果未指定，则使用默认值100。</p>
    </td></tr><tr><td><code class="attributeName">maxParameterCount</code></td><td>
      <p>容器将自动解析的参数和值对的最大数量（GET加POST）。超出此限制的参数和值对将被忽略。小于0的值表示没有限制。如果未指定，则使用默认值10000。注意<code>FailedRequestFilter</code> <a href="filter.html">过滤器</a>可用于拒绝达到限制的请求。</p>
    </td></tr><tr><td><code class="attributeName">maxPostSize</code></td><td>
      <p>容器FORM URL参数解析将处理的POST的最大大小（以字节为单位）。可以通过将此属性设置为小于零的值来禁用该限制。如果未指定，则此属性设置为2097152（2兆字节）。请注意<a href="filter.html#Failed_Request_Filter"><code>FailedRequestFilter</code></a>可用于拒绝超出此限制的请求。</p>
    </td></tr><tr><td><code class="attributeName">maxSavePostSize</code></td><td>
      <p>在FORM或CLIENT-CERT身份验证期间，容器将保存/缓冲的POST的最大大小（以字节为单位）。对于这两种类型的身份验证，将在对用户进行身份验证之前保存/缓冲POST。对于CLIENT-CERT身份验证，在SSL握手期间将对POST进行缓冲，并在处理请求时将其清空。对于FORM身份验证，POST被保存，而用户被重定向到登录表单，并一直保留到用户成功进行身份验证或与身份验证请求关联的会话到期为止。可以通过将此属性设置为-1来禁用该限制。将该属性设置为零将禁用身份验证期间的POST数据保存。如果未指定，则此属性设置为4096（4 KB）。</p>
    </td></tr><tr><td><code class="attributeName">parseBodyMethods</code></td><td>
      <p>请求主体使用的HTTP方法的逗号分隔列表<code>application/x-www-form-urlencoded</code>将解析与POST相同的请求参数。这在想要支持PUT请求的POST样式语义的RESTful应用程序中很有用。请注意，除<code>POST</code>导致Tomcat的行为违背Servlet规范的意图。根据HTTP规范，此处特别禁止使用HTTP方法TRACE。默认是<code>POST</code></p>
    </td></tr><tr><td><strong><code class="attributeName">port</code></strong></td><td>
      <p><strong>连接器</strong>将在其上创建服务器套接字并等待传入连接的TCP端口号。您的操作系统将仅允许一个服务器应用程序侦听特定IP地址上的特定端口号。如果使用特殊值0（零），则Tomcat将随机选择一个空闲端口用于此连接器。这通常仅在嵌入式和测试应用程序中有用。</p>
    </td></tr><tr><td><code class="attributeName">protocol</code></td><td>
      <p>设置协议以处理传入流量。默认值为<code>HTTP/1.1</code>它使用自动切换机制来选择基于Java NIO的连接器或基于APR / native的连接器。如果<code>PATH</code> （Windows）或<code>LD_LIBRARY_PATH</code> （在大多数Unix系统上）环境变量包含Tomcat本机库，并且<code>AprLifecycleListener</code>用于初始化APR的<code>useAprConnector</code>属性设置为<code>true</code> ，将使用APR /本机连接器。如果找不到本机库或未配置属性，则将使用基于Java NIO的连接器。请注意，APR /本机连接器的HTTPS设置与Java连接器的设置不同。<br>要使用显式协议而不是依赖于上述自动切换机制，可以使用以下值：<br>
        <code>org.apache.coyote.http11.Http11NioProtocol</code> -非阻塞Java NIO连接器<br>
        <code>org.apache.coyote.http11.Http11Nio2Protocol</code> -非阻塞Java NIO2连接器<br>
        <code>org.apache.coyote.http11.Http11AprProtocol</code> -APR /本机连接器。<br>也可以使用自定义实现。<br>看看我们的<a href="#Connector_Comparison">连接器比较</a>表。对于Java和Java连接器，http和https的配置相同。<br>有关APR连接器和特定于APR的SSL设置的更多信息，请访问<a href="../apr.html">APR文档</a>
      </p>
    </td></tr><tr><td><code class="attributeName">proxyName</code></td><td>
      <p>如果在代理配置中使用了此<strong>连接器</strong> ，请配置此属性以指定要返回的服务器名称以调用<code>request.getServerName()</code> 。有关更多信息，请参见<a href="#Proxy_Support">代理支持</a> 。</p>
    </td></tr><tr><td><code class="attributeName">proxyPort</code></td><td>
      <p>如果在代理配置中使用了此<strong>连接器</strong> ，请配置此属性以指定要返回的服务器端口以调用<code>request.getServerPort()</code> 。有关更多信息，请参见<a href="#Proxy_Support">代理支持</a> 。</p>
    </td></tr><tr><td><code class="attributeName">redirectPort</code></td><td>
      <p>如果此<strong>连接器</strong>支持非SSL请求，并且接收到一个匹配的请求<code><security-constraint></code>需要SSL传输，Catalina将自动将请求重定向到此处指定的端口号。</p>
    </td></tr><tr><td><code class="attributeName">scheme</code></td><td>
      <p>将此属性设置为您希望通过调用返回的协议的名称<code>request.getScheme()</code> 。例如，您可以将此属性设置为“ <code>https</code> “用于SSL连接器。默认值为“ <code>http</code> ”。
      </p>
    </td></tr><tr><td><code class="attributeName">secure</code></td><td>
      <p>将此属性设置为<code>true</code>如果您想致电<code>request.isSecure()</code>返回<code>true</code>该连接器收到的请求。您可能希望在SSL连接器或从SSL加速器（例如加密卡，SSL设备甚至Web服务器）接收数据的非SSL连接器上使用此连接器。默认值为<code>false</code> 。</p>
    </td></tr><tr><td><code class="attributeName">URIEncoding</code></td><td>
      <p>在％xx解码URL之后，这指定用于解码URI字节的字符编码。如果未指定，将使用UTF-8，除非<code>org.apache.catalina.STRICT_SERVLET_COMPLIANCE</code> <a href="systemprops.html">系统属性</a>设置为<code>true</code>在这种情况下，将使用ISO-8859-1。</p>
    </td></tr><tr><td><code class="attributeName">useBodyEncodingForURI</code></td><td>
      <p>这指定是否应将contentType中指定的编码用于URI查询参数，而不是使用URIEncoding。出现此设置是为了与Tomcat 4.1.x兼容，其中在contentType中指定的编码或使用Request.setCharacterEncoding方法显式设置的编码也用于URL中的参数。默认值为<code>false</code> 。
      </p>
      <p><strong>注意：</strong> 1）此设置仅适用于请求的查询字符串。不像<code>URIEncoding</code>它不会影响请求URI的路径部分。 2）如果请求字符编码未知（不是由浏览器提供的，也不是由<code>SetCharacterEncodingFilter</code>或使用Request.setCharacterEncoding方法的类似过滤器），默认编码始终为“ ISO-8859-1”。的<code>URIEncoding</code>设置对此默认值无效。
      </p>
    </td></tr><tr><td><code class="attributeName">useIPVHosts</code></td><td>
      <p>将此属性设置为<code>true</code>使Tomcat使用接收到请求的IP地址来确定将请求发送到的主机。默认值为<code>false</code> 。</p>
    </td></tr><tr><td><code class="attributeName">xpoweredBy</code></td><td>
      <p>将此属性设置为<code>true</code>使Tomcat使用规范中建议的标头宣传对Servlet规范的支持。默认值为<code>false</code> 。</p>
    </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="Standard_Implementation">标准实施</h4><div class="text">

  <p>除了上面列出的通用连接器属性外，标准HTTP连接器（NIO，NIO2和APR / native）均支持以下属性。</p>

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">acceptCount</code></td><td>
      <p>使用所有可能的请求处理线程时，传入连接请求的最大队列长度。队列已满时收到的任何请求都将被拒绝。默认值为100。</p>
    </td></tr><tr><td><code class="attributeName">acceptorThreadPriority</code></td><td>
      <p>受体线程的优先级。用于接受新连接的线程。默认值为<code>5</code> （ <code>java.lang.Thread.NORM_PRIORITY</code>不变）。请参阅JavaDoc <code>java.lang.Thread</code>类，了解有关此优先级含义的更多详细信息。</p>
    </td></tr><tr><td><code class="attributeName">address</code></td><td>
      <p>对于具有多个IP地址的服务器，此属性指定将用于侦听指定端口的地址。默认情况下，连接器将侦听所有本地地址。除非使用系统属性以其他方式配置了JVM，否则在配置了Java和Java的连接器（NIO，NIO2）中的任何一个时，它们将同时侦听IPv4和IPv6地址<code>0.0.0.0</code>要么<code>::</code> 。如果配置了APR / native连接器，则它将仅侦听IPv4地址<code>0.0.0.0</code>如果配置了，则将侦听IPv6地址（以及可选的IPv4地址，具体取决于<strong>ipv6onlyv6</strong>的设置） <code>::</code> 。</p>
    </td></tr><tr><td><code class="attributeName">allowHostHeaderMismatch</code></td><td>
      <p>默认情况下，Tomcat将拒绝在请求行中指定主机但在主机标头中指定其他主机的请求。可以通过将此属性设置为来禁用此检查<code>true</code> 。如果未指定，则默认为<code>false</code> 。</p>
    </td></tr><tr><td><code class="attributeName">allowedTrailerHeaders</code></td><td>
      <p>默认情况下，Tomcat在处理分块输入时将忽略所有尾部标头。对于要处理的标头，必须将其添加到此标头名称的逗号分隔列表中。</p>
    </td></tr><tr><td><code class="attributeName">bindOnInit</code></td><td>
      <p>控制何时绑定连接器使用的套接字。默认情况下，它在启动连接器时绑定，而在销毁连接器时取消绑定。如果设置为<code>false</code> ，套接字将在连接器启动时绑定，而在连接器停止时取消绑定。</p>
    </td></tr><tr><td><code class="attributeName">clientCertProvider</code></td><td>
      <p>当客户端证书信息以除实例以外的形式呈现时<code>java.security.cert.X509Certificate</code>它需要先转换，然后才能使用，并且此属性控制使用哪个JSSE提供程序执行转换。例如，它与<a href="ajp.html">AJP连接器</a> ，HTTP APR连接器以及<a href="valve.html#SSL_Authenticator_Valve">org.apache.catalina.valves一起使用。SSLValve</a> 。如果未指定，将使用默认提供程序。</p>
    </td></tr><tr><td><code class="attributeName">compressibleMimeType</code></td><td>
      <p>该值是逗号分隔的MIME类型列表，可以对其使用HTTP压缩。默认值为<code>text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json,application/xml</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">compression</code></td><td>
      <p><strong>连接器</strong>可能会使用HTTP / 1.1 GZIP压缩，以节省服务器带宽。该参数的可接受值为“ off”（禁用压缩），“ on”（允许压缩，这将导致压缩文本数据），“ force”（在所有情况下均强制压缩）或数字整数值（即等效于“ on”，但指定压缩输出之前的最小数据量。如果内容长度未知，并且压缩设置为“ on”或更具攻击性，则输出也将被压缩。如果未指定，则此属性设置为“ off”。</p>
      <p><em>注意</em> ：在使用压缩（节省带宽）和使用sendfile功能（节省CPU周期）之间需要权衡。如果连接器支持sendfile功能，例如NIO连接器，则使用sendfile将优先于压缩。症状是大于48 Kb的静态文件将以未压缩的形式发送。您可以通过设置关闭sendfile <code>useSendfile</code>连接器的属性，如下所述，或者在默认情况下在<a href="../default-servlet.html">DefaultServlet</a>的配置中更改sendfile使用阈值<code>conf/web.xml</code>或在<code>web.xml</code>您的Web应用程序。
      </p>
    </td></tr><tr><td><code class="attributeName">compressionMinSize</code></td><td>
      <p>如果<strong>压缩</strong>设置为“ on”，则此属性可用于指定压缩输出之前的最小数据量。如果未指定，则此属性默认为“ 2048”。</p>
    </td></tr><tr><td><code class="attributeName">connectionLinger</code></td><td>
      <p>关闭<strong>连接器</strong>时，此<strong>连接器</strong>使用的插座停留的秒数。默认值为<code>-1</code>禁用套接字延迟。</p>
    </td></tr><tr><td><code class="attributeName">connectionTimeout</code></td><td>
      <p>接受连接后，此<strong>连接器</strong>将等待呈现请求URI行的毫秒数。使用值-1表示没有（即无限）超时。默认值为60000（即60秒），但请注意，Tomcat附带的标准server.xml将此值设置为20000（即20秒）。除非将<strong>disableUploadTimeout</strong>设置为<code>false</code> ，则在读取请求正文（如果有）时也会使用此超时。</p>
    </td></tr><tr><td><code class="attributeName">connectionUploadTimeout</code></td><td>
      <p>指定在进行数据上载时要使用的超时（以毫秒为单位）。仅当<strong>disableUploadTimeout</strong>设置<strong>为时，</strong>此选项才生效。 <code>false</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">disableUploadTimeout</code></td><td>
      <p>此标志允许Servlet容器在数据上载期间使用其他通常更长的连接超时。如果未指定，则此属性设置为<code>true</code>禁用此较长的超时。
      </p>
    </td></tr><tr><td><code class="attributeName">executor</code></td><td>
      <p>对<a href="executor.html">Executor</a>元素中名称的引用。如果设置了此属性，并且命名的执行程序存在，则连接器将使用该执行程序，所有其他线程属性将被忽略。请注意，如果未为连接器指定共享执行器，则连接器将使用私有的内部执行器来提供线程池。</p>
    </td></tr><tr><td><code class="attributeName">executorTerminationTimeoutMillis</code></td><td>
      <p>私有内部执行器在继续执行停止连接器过程之前等待请求处理线程终止的时间。如果未设置，则默认为<code>5000</code> （5秒）。</p>
    </td></tr><tr><td><code class="attributeName">keepAliveTimeout</code></td><td>
      <p>该<strong>连接器</strong>在关闭连接之前将等待另一个HTTP请求的毫秒数。默认值是使用为<strong>connectionTimeout</strong>属性设置的值。使用值-1表示没有（即无限）超时。</p>
    </td></tr><tr><td><code class="attributeName">maxConnections</code></td><td>
      <p>服务器在任何给定时间将接受和处理的最大连接数。达到此数目后，服务器将接受但不处理另一个连接。在处理的连接数降至<strong>maxConnections</strong>以下之前，该附加连接将被阻止，此时服务器将再次开始接受和处理新的连接。请注意，一旦达到限制，操作系统仍然可以根据以下情况接受连接： <code>acceptCount</code>设置。默认值因连接器类型而异。对于NIO和NIO2，默认值为<code>10000</code> 。对于APR /本机，默认值为<code>8192</code> 。</p>
      <p>请注意，对于Windows上的APR /本机，配置的值将减小为1024的最大倍，该最大值小于或等于maxConnections。这样做是出于性能原因。<br>如果设置为-1，将禁用maxConnections功能，并且不计算连接数。</p>
    </td></tr><tr><td><code class="attributeName">maxCookieCount</code></td><td>
      <p>请求允许的最大Cookie数。小于零的值表示没有限制。如果未指定，将使用默认值200。</p>
    </td></tr><tr><td><code class="attributeName">maxExtensionSize</code></td><td>
      <p>限制HTTP区块请求中区块扩展的总长度。如果值为<code>-1</code> ，没有限制。如果未指定，则默认值为<code>8192</code>将会被使用。</p>
    </td></tr><tr><td><code class="attributeName">maxHttpHeaderSize</code></td><td>
      <p>请求和响应HTTP标头的最大大小，以字节为单位指定。如果未指定，则此属性设置为8192（8 KB）。</p>
    </td></tr><tr><td><code class="attributeName">maxKeepAliveRequests</code></td><td>
      <p>在服务器关闭连接之前可以管道传输的HTTP请求的最大数量。将此属性设置为1将禁用HTTP / 1.0保持活动以及HTTP / 1.1保持活动和流水线。将此设置为-1将允许无限数量的流水线或保持活动的HTTP请求。如果未指定，则此属性设置为100。</p>
    </td></tr><tr><td><code class="attributeName">maxSwallowSize</code></td><td>
      <p>Tomcat会为中止的上载而吞下的请求正文字节的最大数量（不包括传输编码开销）。上载中止是指Tomcat知道将忽略请求主体，但客户端仍将其发送。如果Tomcat不吞咽该主体，则客户端不太可能看到响应。如果未指定，将使用默认值2097152（2兆字节）。小于零的值表示不应强制执行任何限制。</p>
    </td></tr><tr><td><code class="attributeName">maxThreads</code></td><td>
      <p>此<strong>Connector</strong>将创建的请求处理线程的最大数量，因此确定了可以处理的同时请求的最大数量。如果未指定，则此属性设置为200。如果执行程序与此连接器相关联，则此属性将被忽略，因为连接器将使用执行程序而不是内部线程池执行任务。请注意，如果配置了执行程序，则将正确记录为此属性设置的任何值，但会（例如通过JMX）将其报告为<code>-1</code>明确表示未使用。</p>
    </td></tr><tr><td><code class="attributeName">maxTrailerSize</code></td><td>
      <p>限制在分块的HTTP请求的最后一块中的尾部标头的总长度。如果值为<code>-1</code> ，没有限制。如果未指定，则默认值为<code>8192</code>将会被使用。</p>
    </td></tr><tr><td><code class="attributeName">minSpareThreads</code></td><td>
      <p>始终保持运行状态的最小线程数。这包括活动线程和空闲线程。如果未指定，则默认为<code>10</code>用来。如果执行程序与此连接器相关联，则此属性将被忽略，因为连接器将使用执行程序而不是内部线程池执行任务。请注意，如果配置了执行程序，则将正确记录为此属性设置的任何值，但会（例如通过JMX）将其报告为<code>-1</code>明确表示未使用。</p>
    </td></tr><tr><td><code class="attributeName">noCompressionUserAgents</code></td><td>
      <p>该值是一个正则表达式（使用<code>java.util.regex</code> ）匹配<code>user-agent</code> HTTP客户端的标头，不应该对其进行压缩，因为这些客户端尽管确实宣传了对该功能的支持，但它们的实现方式很糟糕。默认值为空字符串（禁用正则表达式匹配）。</p>
    </td></tr><tr><td><code class="attributeName">processorCache</code></td><td>
      <p>协议处理程序缓存Processor对象以提高性能。此设置指示要缓存多少这些对象。
      <code>-1</code>表示无限，默认为<code>200</code> 。如果未使用Servlet 3.0异步处理，则一个很好的默认设置是使用与maxThreads设置相同的设置。如果使用Servlet 3.0异步处理，一个好的默认设置是使用maxThreads中的较大者和预期的并发请求（同步和异步）的最大数量。</p>
    </td></tr><tr><td><code class="attributeName">rejectIllegalHeaderName</code></td><td>
      <p>如果收到的HTTP请求包含非法的标头名称（即标头名称不是令牌），则此设置确定该请求是否将被400响应拒绝（ <code>true</code> ），或者如果忽略了非法标头（ <code>false</code> ）。默认值为<code>true</code>这将导致请求被拒绝。</p>
    </td></tr><tr><td><code class="attributeName">relaxedPathChars</code></td><td>
      <p><a href="https://tools.ietf.org/rfc/rfc7230.txt">HTTP / 1.1规范</a>要求在URI路径中使用某些字符时必须进行％nn编码。不幸的是，包括所有主要浏览器在内的许多用户代理都不符合该规范，并且以未编码形式使用这些字符。为了防止Tomcat拒绝此类请求，可以使用此属性指定允许的其他字符。如果未指定，则不允许其他字符。该值可以是以下字符的任意组合： <code>" < > [ \ ] ^ ` { | }</code> 。值中存在的任何其他字符将被忽略。</p>
    </td></tr><tr><td><code class="attributeName">relaxedQueryChars</code></td><td>
      <p><a href="https://tools.ietf.org/rfc/rfc7230.txt">HTTP / 1.1规范</a>要求在URI查询字符串中使用某些字符时必须进行％nn编码。不幸的是，包括所有主要浏览器在内的许多用户代理都不符合该规范，并且以未编码形式使用这些字符。为了防止Tomcat拒绝此类请求，可以使用此属性指定允许的其他字符。如果未指定，则不允许其他字符。该值可以是以下字符的任意组合： <code>" < > [ \ ] ^ ` { | }</code> 。值中存在的任何其他字符将被忽略。</p>
    </td></tr><tr><td><code class="attributeName">restrictedUserAgents</code></td><td>
      <p>该值是一个正则表达式（使用<code>java.util.regex</code> ）匹配<code>user-agent</code>即使客户端宣告了对这些功能的支持，也不应使用HTTP / 1.1或HTTP / 1.0保持活动状态的HTTP客户端的标头。默认值为空字符串（禁用正则表达式匹配）。</p>
    </td></tr><tr><td><code class="attributeName">server</code></td><td>
      <p>覆盖http响应的Server标头。如果设置，则此属性的值将覆盖Web应用程序设置的任何服务器标头。如果未设置，则使用应用程序指定的任何值。如果应用程序未指定值，则不会设置服务器头。</p>
    </td></tr><tr><td><code class="attributeName">serverRemoveAppProvidedValues</code></td><td>
      <p>如果<code>true</code> ，由网络应用程序设置的任何服务器标头都将被删除。请注意，如果设置了<strong>服务器</strong> ，则该属性将被有效忽略。如果未设置，则默认值为<code>false</code>将会被使用。</p>
    </td></tr><tr><td><code class="attributeName">SSLEnabled</code></td><td>
      <p>使用此属性可以在连接器上启用SSL通信。要在连接器上打开SSL握手/加密/解密，请将此值设置为<code>true</code> 。默认值为<code>false</code> 。转换此值时<code>true</code>您将要设置<code>scheme</code>和<code>secure</code>属性以及正确的传递<code>request.getScheme()</code>和<code>request.isSecure()</code> servlet的值。有关更多信息，请参见<a href="#SSL_Support">SSL支持</a> 。
      </p>
    </td></tr><tr><td><code class="attributeName">tcpNoDelay</code></td><td>
      <p>如果设置为<code>true</code> ，将在服务器套接字上设置TCP_NO_DELAY选项，从而在大多数情况下提高性能。设置为<code>true</code>默认。</p>
    </td></tr><tr><td><code class="attributeName">threadPriority</code></td><td>
      <p>JVM中请求处理线程的优先级。默认值为<code>5</code> （ <code>java.lang.Thread.NORM_PRIORITY</code>不变）。请参阅JavaDoc <code>java.lang.Thread</code>类，了解有关此优先级含义的更多详细信息。如果执行程序与此连接器相关联，则此属性将被忽略，因为连接器将使用执行程序而不是内部线程池执行任务。请注意，如果配置了执行程序，则将正确记录为此属性设置的任何值，但会（例如通过JMX）将其报告为<code>-1</code>明确表示未使用。</p>
    </td></tr><tr><td><code class="attributeName">throwOnFailure</code></td><td>
      <p>如果连接器在生命周期过渡期间遇到异常，是否应重新抛出或记录该异常？如果未指定，则默认为<code>false</code>将会被使用。请注意，默认设置可以通过<code>org.apache.catalina.startup.EXIT_ON_INIT_FAILURE</code>系统属性。</p>
    </td></tr><tr><td><code class="attributeName">useAsyncIO</code></td><td>
      <p>（布尔）使用此属性可以启用或禁用异步IO API的使用。默认值为<code>true</code>除非由于性能低而使用APR连接器。</p>
    </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="Java_TCP_socket_attributes">Java TCP套接字属性</h4><div class="text">

    <p>NIO和NIO2实现除了上面列出的公共连接器和HTTP属性外，还支持以下Java TCP套接字属性。</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">socket.rxBufSize</code></td><td>
        <p>（int）套接字接收缓冲区（SO_RCVBUF）的大小，以字节为单位。如果未设置，则使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.txBufSize</code></td><td>
        <p>（int）套接字发送缓冲区（SO_SNDBUF）的大小，以字节为单位。如果未设置，则使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.tcpNoDelay</code></td><td>
        <p>（布尔）这等效于标准属性<strong>tcpNoDelay</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">socket.soKeepAlive</code></td><td>
        <p>（布尔）套接字的保持活动设置的布尔值（SO_KEEPALIVE）。如果未设置，则使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.ooBInline</code></td><td>
        <p>（布尔）套接字OOBINLINE设置的布尔值。如果未设置，则使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.soReuseAddress</code></td><td>
        <p>套接字重用地址选项（SO_REUSEADDR）的（布尔）布尔值。如果未设置，则使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.soLingerOn</code></td><td>
        <p>（bool）套接字so linger选项的布尔值（SO_LINGER）。标准属性<strong>connectionLinger的</strong>值> = 0等于将其设置为<code>true</code> 。标准属性<strong>connectionLinger的</strong>值小于0等于将其设置为<code>false</code> 。此属性和<code>soLingerTime</code>必须设置，否则将使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.soLingerTime</code></td><td>
        <p>（int）套接字so linger选项（SO_LINGER）的秒数。这等效于标准属性<strong>connectionLinger</strong> 。此属性和<code>soLingerOn</code>必须设置，否则将使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.soTimeout</code></td><td>
        <p>这等效于标准属性<strong>connectionTimeout</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">socket.performanceConnectionTime</code></td><td>
        <p>（int）性能设置的第一个值。请参阅<a href="http://docs.oracle.com/javase/7/docs/api/java/net/Socket.html#setPerformancePreferences(int, int, int)">套接字性能选项</a> 。必须设置所有三个性能属性，否则所有三个将使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.performanceLatency</code></td><td>
        <p>（int）性能设置的第二个值。请参阅<a href="http://docs.oracle.com/javase/7/docs/api/java/net/Socket.html#setPerformancePreferences(int, int, int)">套接字性能选项</a> 。必须设置所有三个性能属性，否则所有三个将使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.performanceBandwidth</code></td><td>
        <p>（int）性能设置的第三个值。请参阅<a href="http://docs.oracle.com/javase/7/docs/api/java/net/Socket.html#setPerformancePreferences(int, int, int)">套接字性能选项</a> 。必须设置所有三个性能属性，否则所有三个将使用JVM默认值。</p>
      </td></tr><tr><td><code class="attributeName">socket.unlockTimeout</code></td><td>
        <p>（int）套接字解锁的超时。当连接器停止时，它将尝试通过打开自身的连接器来释放接收器线程。默认值为<code>250</code>值以毫秒为单位</p>
      </td></tr></tbody></table>
  </div></div>

  <div class="subsection"><h4 id="NIO_specific_configuration">NIO特定配置</h4><div class="text">

    <p>以下属性特定于NIO连接器。</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">pollerThreadPriority</code></td><td>
        <p>（int）轮询线程的优先级。默认值为<code>5</code> （ <code>java.lang.Thread.NORM_PRIORITY</code>不变）。请参阅JavaDoc <code>java.lang.Thread</code>类，了解有关此优先级含义的更多详细信息。</p>
      </td></tr><tr><td><code class="attributeName">selectorTimeout</code></td><td>
        <p>（int）轮询器的select（）上的超时时间（以毫秒为单位）。此值很重要，因为连接清理是在同一线程上完成的，因此请勿将此值设置为极高的值。默认值为<code>1000</code>毫秒。</p>
      </td></tr><tr><td><code class="attributeName">useSendfile</code></td><td>
        <p>（布尔）使用此属性启用或禁用发送文件功能。默认值为<code>true</code> 。请注意，使用sendfile将禁用Tomcat可能会对响应执行的任何压缩。</p>
      </td></tr><tr><td><code class="attributeName">socket.directBuffer</code></td><td>
        <p>（布尔）布尔值，是使用直接ByteBuffer还是Java映射的ByteBuffer。如果<code>true</code>然后<code>java.nio.ByteBuffer.allocateDirect()</code>用于分配缓冲区，如果<code>false</code>然后<code>java.nio.ByteBuffer.allocate()</code>用来。默认值为<code>false</code> 。<br>使用直接缓冲区时，请确保为直接内存空间分配了适当的内存量。在Sun的JDK上，类似<code>-XX:MaxDirectMemorySize=256m</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">socket.directSslBuffer</code></td><td>
        <p>（布尔）布尔值，是对SSL缓冲区使用直接ByteBuffer还是Java映射的ByteBuffer。如果<code>true</code>然后<code>java.nio.ByteBuffer.allocateDirect()</code>用于分配缓冲区，如果<code>false</code>然后<code>java.nio.ByteBuffer.allocate()</code>用来。默认值为<code>false</code> 。<br>使用直接缓冲区时，请确保为直接内存空间分配了适当的内存量。在Oracle的JDK上，类似<code>-XX:MaxDirectMemorySize=256m</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">socket.appReadBufSize</code></td><td>
        <p>（int）在Tomcat中打开的每个连接都与读取的ByteBuffer关联。此属性控制此缓冲区的大小。默认情况下，此读取缓冲区的大小为<code>8192</code>个字节。对于较低的并发，可以增加此值以缓冲更多数据。对于极大量的保持活动连接，请减少此数目或增加堆大小。</p>
      </td></tr><tr><td><code class="attributeName">socket.appWriteBufSize</code></td><td>
        <p>（int）在Tomcat中打开的每个连接都与一个写ByteBuffer相关联。此属性控制此缓冲区的大小。默认情况下，此写缓冲区的大小为<code>8192</code>个字节。对于低并发性，您可以增加此值以缓冲更多响应数据。对于极大量的保持活动连接，请减少此数目或增加堆大小。<br>这里的默认值非常低，如果不处理成千上万的并发连接，则应将其调高。</p>
      </td></tr><tr><td><code class="attributeName">socket.bufferPool</code></td><td>
        <p>（int）NIO连接器使用称为NioChannel的类，该类保存链接到套接字的元素。为了减少垃圾收集，NIO连接器会缓存这些通道对象。此值指定此缓存的大小。默认值为<code>500</code> ，并表示该缓存将容纳500个NioChannel对象。其他值是<code>-1</code>无限缓存和<code>0</code>没有缓存。</p>
      </td></tr><tr><td><code class="attributeName">socket.bufferPoolSize</code></td><td>
        <p>（int）NioChannel池也可以基于大小，而不是基于对象。大小计算如下：<br>NioChannel<code>buffer size = read buffer size + write buffer size</code><br>SecureNioChannel<code>buffer size = application read buffer size + application write buffer size + network read buffer size + network write buffer size</code><br>该值以字节为单位，默认值为<code>1024*1024*100</code> （100MB）。</p>
      </td></tr><tr><td><code class="attributeName">socket.processorCache</code></td><td>
        <p>（int）Tomcat将缓存SocketProcessor对象以减少垃圾收集。整数值指定最多在缓存中保留多少个对象。默认是<code>500</code> 。其他值是<code>-1</code>无限缓存和<code>0</code>没有缓存。</p>
      </td></tr><tr><td><code class="attributeName">socket.keyCache</code></td><td>
        <p>（int）Tomcat将缓存KeyAttachment对象以减少垃圾收集。整数值指定最多在缓存中保留多少个对象。默认是<code>500</code> 。其他值是<code>-1</code>无限缓存和<code>0</code>没有缓存。</p>
      </td></tr><tr><td><code class="attributeName">socket.eventCache</code></td><td>
        <p>（int）Tomcat将缓存PollerEvent对象以减少垃圾收集。整数值指定最多在缓存中保留多少个对象。默认是<code>500</code> 。其他值是<code>-1</code>无限缓存和<code>0</code>没有缓存。</p>
      </td></tr><tr><td><code class="attributeName">selectorPool.maxSelectors</code></td><td>
        <p>（int）池中使用的最大选择器，以减少选择器争用。命令行时使用此选项<code>org.apache.tomcat.util.net.NioSelectorShared</code>值设置为false。默认值为<code>200</code> 。</p>
      </td></tr><tr><td><code class="attributeName">selectorPool.maxSpareSelectors</code></td><td>
        <p>（int）池中使用的最大备用选择器，以减少选择器争用。当选择器返回到池中时，系统可以决定保留它还是让它成为GC。命令行时使用此选项<code>org.apache.tomcat.util.net.NioSelectorShared</code>值设置为false。默认值为<code>-1</code> （无限）。</p>
      </td></tr><tr><td><code class="attributeName">selectorPool.shared</code></td><td>
        <p>（布尔）将此值设置为<code>false</code>如果您希望为每个线程使用选择器。当您将其设置为<code>false</code> ，您可以使用<strong>selectorPool.maxSelectors</strong>属性控制选择器池的大小。默认为<code>true</code>或<code>org.apache.tomcat.util.net.NioSelectorShared</code>系统属性（如果存在）。</p>
      </td></tr><tr><td><code class="attributeName">useInheritedChannel</code></td><td>
        <p>（布尔）定义此连接器是否应继承inetd / systemd网络套接字。只有一个连接器可以继承网络套接字。一旦对systemd超级守护程序的端口发出连接请求，就可以使用该选项自动启动Tomcat。默认值为<code>false</code> 。请参阅JavaDoc <code>java.nio.channels.spi.SelectorProvider</code>类以获取更多详细信息。</p>
      </td></tr><tr><td><code class="attributeName">command-line-options</code></td><td>
        <p>以下命令行选项可用于NIO连接器：<br>
        <code>-Dorg.apache.tomcat.util.net.NioSelectorShared=true|false</code> -默认为<code>true</code> 。将此值设置为<code>false</code>如果您希望为每个线程使用选择器。当您将其设置为<code>false</code> ，您可以使用<strong>selectorPool.maxSelectors</strong>属性控制选择器池的大小。</p>
      </td></tr></tbody></table>
  </div></div>

  <div class="subsection"><h4 id="NIO2_specific_configuration">NIO2特定配置</h4><div class="text">

    <p>以下属性特定于NIO2连接器。</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">useSendfile</code></td><td>
        <p>（布尔）使用此属性启用或禁用发送文件功能。默认值为<code>true</code> 。请注意，使用sendfile将禁用Tomcat可能会对响应执行的任何压缩。</p>
      </td></tr><tr><td><code class="attributeName">socket.directBuffer</code></td><td>
        <p>（布尔）布尔值，是使用直接ByteBuffer还是Java映射的ByteBuffer。如果<code>true</code>然后<code>java.nio.ByteBuffer.allocateDirect()</code>用于分配缓冲区，如果<code>false</code>然后<code>java.nio.ByteBuffer.allocate()</code>用来。默认值为<code>false</code> 。<br>使用直接缓冲区时，请确保为直接内存空间分配了适当的内存量。在Sun的JDK上，类似<code>-XX:MaxDirectMemorySize=256m</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">socket.directSslBuffer</code></td><td>
        <p>（布尔）布尔值，是对SSL缓冲区使用直接ByteBuffer还是Java映射的ByteBuffer。如果<code>true</code>然后<code>java.nio.ByteBuffer.allocateDirect()</code>用于分配缓冲区，如果<code>false</code>然后<code>java.nio.ByteBuffer.allocate()</code>用来。默认值为<code>false</code> 。<br>使用直接缓冲区时，请确保为直接内存空间分配了适当的内存量。在Oracle的JDK上，类似<code>-XX:MaxDirectMemorySize=256m</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">socket.appReadBufSize</code></td><td>
        <p>（int）在Tomcat中打开的每个连接都与读取的ByteBuffer关联。此属性控制此缓冲区的大小。默认情况下，此读取缓冲区的大小为<code>8192</code>个字节。对于较低的并发，可以增加此值以缓冲更多数据。对于极大量的保持活动连接，请减少此数目或增加堆大小。</p>
      </td></tr><tr><td><code class="attributeName">socket.appWriteBufSize</code></td><td>
        <p>（int）在Tomcat中打开的每个连接都与一个写ByteBuffer相关联。此属性控制此缓冲区的大小。默认情况下，此写缓冲区的大小为<code>8192</code>个字节。对于低并发性，您可以增加此值以缓冲更多响应数据。对于极大量的保持活动连接，请减少此数目或增加堆大小。<br>这里的默认值非常低，如果不处理成千上万的并发连接，则应将其调高。</p>
      </td></tr><tr><td><code class="attributeName">socket.bufferPool</code></td><td>
        <p>（int）NIO2连接器使用称为Nio2Channel的类，该类保存链接到套接字的元素。为了减少垃圾收集，NIO2连接器会缓存这些通道对象。此值指定此缓存的大小。默认值为<code>500</code> ，并表示该缓存将容纳500个Nio2Channel对象。其他值是<code>-1</code>无限缓存和<code>0</code>没有缓存。</p>
      </td></tr><tr><td><code class="attributeName">socket.processorCache</code></td><td>
        <p>（int）Tomcat将缓存SocketProcessor对象以减少垃圾收集。整数值指定最多在缓存中保留多少个对象。默认是<code>500</code> 。其他值是<code>-1</code>无限缓存和<code>0</code>没有缓存。</p>
      </td></tr></tbody></table>
  </div></div>

  <div class="subsection"><h4 id="APR/native_specific_configuration">APR /本机特定配置</h4><div class="text">

    <p>以下属性特定于APR /本机连接器。</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">deferAccept</code></td><td>
        <p>设置<code>TCP_DEFER_ACCEPT</code>该连接器的侦听套接字上的标志。默认值为<code>true</code>哪里<code>TCP_DEFER_ACCEPT</code>由操作系统支持，否则<code>false</code> 。</p>
      </td></tr><tr><td><code class="attributeName">ipv6v6only</code></td><td>
        <p>如果在双堆栈系统上侦听IPv6地址，连接器是否应该仅侦听IPv6地址？如果未指定，则默认为<code>false</code>连接器将侦听IPv6地址和等效的IPv4地址（如果存在）。</p>
      </td></tr><tr><td><code class="attributeName">pollerThreadCount</code></td><td>
        <p>用于轮询保持活动的连接的线程数。在Windows上，选择默认值是使每个线程管理的套接字小于1024。对于Linux，默认值为1。在Windows上更改默认值可能会对性能产生负面影响。</p>
      </td></tr><tr><td><code class="attributeName">pollTime</code></td><td>
        <p>轮询呼叫的持续时间（以微秒为单位）。降低此值将在某些情况下稍微减少保持连接的等待时间，但随着进行更多的轮询调用，将使用更多的CPU。默认值为2000（2毫秒）。</p>
      </td></tr><tr><td><code class="attributeName">sendfileSize</code></td><td>
        <p>轮询程序负责异步发送静态文件的套接字数量可以在给定的时间保持。多余的连接将立即关闭，而不会发送任何数据（导致客户端的文件长度为零）。请注意，在大多数情况下，sendfile是一个立即返回的调用（由内核“同步”处理），并且不会使用sendfile poller，因此可以并行发送的静态文件数量很多大于指定的数量。默认值为1024。</p>
      </td></tr><tr><td><code class="attributeName">threadPriority</code></td><td>
        <p>（int）接受方和轮询方线程的优先级。默认值为<code>5</code> （ <code>java.lang.Thread.NORM_PRIORITY</code>不变）。请参阅JavaDoc <code>java.lang.Thread</code>类，了解有关此优先级含义的更多详细信息。</p>
      </td></tr><tr><td><code class="attributeName">useSendfile</code></td><td>
        <p>（布尔）使用此属性启用或禁用发送文件功能。默认值为<code>true</code> 。请注意，使用sendfile将禁用Tomcat可能会对响应执行的任何压缩。</p>
      </td></tr></tbody></table>

  </div></div>

</div><h3 id="Nested_Components">嵌套组件</h3><div class="text">

  <p>Tomcat首先在Tomcat 9中实现，然后反向移植到8.5，现在支持服务器名称指示（SNI）。这允许将多个SSL配置与单个安全连接器关联，该配置用于由客户端请求的主机名确定的任何给定连接。为方便<strong>起见</strong> ，添加了<strong>SSLHostConfig</strong>元素，该元素可用于定义这些配置之一。<strong>连接器中</strong>可以嵌套任何数量的<strong>SSLHostConfig</strong> 。同时，添加了对将多个证书与单个<strong>SSLHostConfig</strong>关联的<strong>支持</strong> 。因此，每个SSL证书都在<strong>SSLHostConfig</strong>中的<strong>Certificate</strong>元素中进行<strong>配置</strong> 。有关更多信息，请参见下面的SSL支持部分。</p>

</div><h3 id="Special_Features">特殊功能</h3><div class="text">


  <div class="subsection"><h4 id="HTTP/1.1_and_HTTP/1.0_Support">HTTP / 1.1和HTTP / 1.0支持</h4><div class="text">

  <p>此<strong>连接器</strong>支持RFC 7230-7235中所述的HTTP / 1.1协议的所有必需功能，包括持久连接，流水线，期望和分块编码。如果客户端仅支持HTTP / 1.0或HTTP / 0.9，则<strong>连接器</strong>也会正常地回退到支持该协议。启用此支持不需要特殊配置。<strong>连接器</strong>还支持HTTP / 1.0保持活动状态。</p>

  <p>RFC 7230要求HTTP服务器始终以其声称支持的最高HTTP版本开始其响应。因此，此<strong>连接器</strong>将始终返回<code>HTTP/1.1</code>在回应开始时。</p>

  </div></div>

  <div class="subsection"><h4 id="HTTP/2_Support">HTTP / 2支持</h4><div class="text">

  <p>TLS（h2），通过HTTP升级（h2c）的非TLS和直接HTTP / 2（h2c）连接提供了HTTP / 2支持。要为HTTP连接器启用HTTP / 2支持，必须在<strong>连接器中</strong>嵌套以下<strong>UpgradeProtocol</strong>元素，其<strong>className</strong>属性为<code>org.apache.coyote.http2.Http2Protocol</code> 。</p>

<div class="codeBox"><pre><code>&lt;Connector ... &gt;
  &lt;UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" /&gt;
&lt;/Connector&gt;</code></pre></div>

  <p>因为Java 8的TLS实现不支持ALPN（这是基于TLS的HTTP / 2所必需的），所以您必须使用基于OpenSSL的TLS实现来启用HTTP / 2支持。见<code>sslImplementationName</code> <strong>连接器的</strong>属性。</p>

  <p>其他配置属性可用。有关详细信息，请参见<a href="http2.html">HTTP / 2升级协议</a>文档。</p>

  </div></div>

  <div class="subsection"><h4 id="Proxy_Support">代理支持</h4><div class="text">

  <p>的<code>proxyName</code>和<code>proxyPort</code>当Tomcat在代理服务器后面运行时，可以使用属性。这些属性修改返回给调用了<code>request.getServerName()</code>和<code>request.getServerPort()</code>方法，通常用于构造用于重定向的绝对URL。如果不配置这些属性，则返回的值将反映接收到来自代理服务器的连接的服务器名称和端口，而不是客户端将原始请求定向到的服务器名称和端口。</p>

  <p>有关更多信息，请参见<a href="../proxy-howto.html">代理支持方法</a> 。</p>

  </div></div>


  <div class="subsection"><h4 id="SSL_Support">SSL支持</h4><div class="text">

  <p>您可以通过设置此<strong>连接器</strong>的特定实例来启用SSL支持<code>SSLEnabled</code>归因于<code>true</code> 。</p>

  <p>您还需要设置<code>scheme</code>和<code>secure</code>值的属性<code>https</code>和<code>true</code>分别将正确的信息传递给servlet。</p>

  <p>NIO和NIO2连接器使用JSSE Java SSL实现或OpenSSL实现，而APR / native连接器仅使用OpenSSL。在Tomcat 8.5之前，JSSE和OpenSSL使用了不同的配置属性。从Tomcat 8.5开始，并尽可能将JSSE和OpenSSL都使用通用配置属性。同样，如果使用JSSE OpenSSL实现，则可以使用JSSE或APR属性来设置配置（注意：同一配置中不能同时使用两种类型）。这有助于简化SSL连接器的连接器实现之间的切换。</p>

  <p>每个安全连接器必须至少定义一个<strong>SSLHostConfig</strong> 。<strong>SSLHostConfig</strong>元素的名称必须唯一，并且其中之一必须与<code>defaultSSLHostConfigName</code> <strong>连接器的</strong>属性。</p>

  <p>每个<strong>SSLHostConfig</strong>必须依次定义至少一个<strong>证书</strong> 。<strong>证书</strong>的类型必须唯一。</p>

  <p>从Tomcat 8.5开始，不推荐使用<strong>连接器</strong>中的大多数SSL配置属性。如果指定，它们将用于配置<strong>SSLHostConfig</strong>和<strong>证书</strong> 。 <code>defaultSSLHostConfigName</code> 。请注意，如果显式<strong>SSLHostConfig</strong>元素也存在<code>defaultSSLHostConfigName</code>则将其视为配置错误。预计Tomcat 10将在<strong>连接器中</strong>放弃对SSL配置属性的支持。</p>

  <p>有关更多信息，请参见<a href="../ssl-howto.html">SSL配置方法</a> 。</p>

  </div></div>

  <div class="subsection"><h4 id="SSL_Support_-_SSLHostConfig">SSL支持-SSLHostConfig</h4><div class="text">

  <p></p>

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">certificateRevocationListFile</code></td><td>
      <p>包含证书颁发机构的级联证书吊销列表的文件名。格式是PEM编码的。如果未定义，则不会针对证书吊销列表检查客户端证书（除非使用了基于OpenSSL的连接器并且定义了<strong>certificateRevocationListPath</strong> ）。相对路径将针对<code>$CATALINA_BASE</code> 。基于JSSE的连接器也可以为此属性指定一个URL。</p>
    </td></tr><tr><td><code class="attributeName">certificateRevocationListPath</code></td><td>
      <p>仅OpenSSL。</p>
      <p>包含证书颁发机构的证书吊销列表的目录的名称。格式是PEM编码的。相对路径将针对<code>$CATALINA_BASE</code> 。</p>
    </td></tr><tr><td><code class="attributeName">certificateVerification</code></td><td>
      <p>调成<code>required</code>如果您希望SSL堆栈在接受连接之前要求客户端提供有效的证书链。调成<code>optional</code>如果您希望SSL堆栈请求客户端证书，但如果未提供证书则不会失败。调成<code>optionalNoCA</code>如果您希望客户端证书是可选的，并且您不希望Tomcat根据受信任的CA列表对其进行检查。如果TLS提供程序不支持此选项（OpenSSL支持，JSSE不支持），则将其视为<code>optional</code>已指定。一种<code>none</code>值（这是默认值）将不需要证书链，除非客户端请求受使用以下内容的安全约束保护的资源<code>CLIENT-CERT</code>身份验证。</p>
    </td></tr><tr><td><code class="attributeName">certificateVerificationDepth</code></td><td>
      <p>验证客户端证书时允许的中间证书的最大数量。如果未指定，将使用默认值10。</p>
    </td></tr><tr><td><code class="attributeName">caCertificateFile</code></td><td>
      <p>仅OpenSSL。</p>
      <p>包含可信任证书颁发机构的串联证书的文件名。格式是PEM编码的。</p>
    </td></tr><tr><td><code class="attributeName">caCertificatePath</code></td><td>
      <p>仅OpenSSL。</p>
      <p>包含受信任的证书颁发机构的证书的目录的名称。格式是PEM编码的。</p>
    </td></tr><tr><td><code class="attributeName">ciphers</code></td><td>
      <p>使用OpenSSL语法启用的密码。（有关支持的密码列表和语法，请参见OpenSSL文档。）或者，可以使用逗号分隔的使用标准OpenSSL密码名称或标准JSSE密码名称的密码列表。</p>
      <p>对于基于JSSE的连接器，从OpenSSL语法转换为JSSE密码时，OpenSSL语法解析的行为与OpenSSL 1.1.0开发分支的行为保持一致。</p>
      <p>仅使用SSL实施支持的密码。</p>
      <p>如果未指定，则默认（使用OpenSSL表示法）为<code>HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!kRSA</code>将会被使用。</p>
      <p>请注意，默认情况下，定义密码的顺序被视为优先顺序。看到<code>honorCipherOrder</code> 。</p>
    </td></tr><tr><td><code class="attributeName">disableCompression</code></td><td>
      <p>仅OpenSSL。</p>
      <p>配置是否禁用压缩。默认是<code>true</code> 。如果使用的OpenSSL版本不支持禁用压缩，则将使用该OpenSSL版本的默认值。</p>
    </td></tr><tr><td><code class="attributeName">disableSessionTickets</code></td><td>
      <p>仅OpenSSL。</p>
      <p>如果设置为，则禁用TLS会话票证（RFC 5077） <code>true</code> 。默认为<code>false</code> 。请注意，当使用TLS会话票证时，完整的对等证书链仅在第一个连接上可用。后续连接（使用票证建立TLS会话）将仅具有对等证书，而不具有完整链。</p>
    </td></tr><tr><td><code class="attributeName">honorCipherOrder</code></td><td>
      <p>调成<code>true</code>强制执行服务器的密码顺序（从<code>ciphers</code>设置），而不是允许客户选择密码。默认是<code>false</code> 。</p>
    </td></tr><tr><td><code class="attributeName">hostName</code></td><td>
      <p>SSL主机的名称。这应该是完全限定的域名（例如<code>tomcat.apache.org</code> ）或通配符域名（例如<code>*.apache.org</code> ）。如果未指定，则默认值为<code>_default_</code>将会被使用。</p>
    </td></tr><tr><td><code class="attributeName">insecureRenegotiation</code></td><td>
      <p>仅OpenSSL。</p>
      <p>配置是否允许不安全的重新协商。默认是<code>false</code> 。如果使用的OpenSSL版本不支持配置是否允许不安全的重新协商，则将使用该OpenSSL版本的默认值。</p>
    </td></tr><tr><td><code class="attributeName">keyManagerAlgorithm</code></td><td>
      <p>仅限JSSE。</p>
      <p>的<code>KeyManager</code>使用的算法。默认为<code>KeyManagerFactory.getDefaultAlgorithm()</code>哪个返回<code>SunX509</code>用于Sun JVM。 IBM JVM返回<code>IbmX509</code> 。对于其他供应商，请查阅JVM文档以获取缺省值。</p>
    </td></tr><tr><td><code class="attributeName">protocols</code></td><td>
      <p>与客户端通信时要支持的协议的名称。这应该是以下各项组合的列表：</p>
      <ul><li>SSLv2您好</li><li>SSLv3</li><li>TLSv1</li><li>TLSv1.1</li>
      <li>TLSv1.2</li><li>TLSv1.3</li><li>所有</li></ul>
      <p>列表中的每个标记都可以带有加号（“ +”）或减号（“-”）前缀。加号添加协议，减号将其从当前列表中删除。该列表是从一个空列表开始构建的。</p>
      <p>代币<code>all</code>是的别名<code>SSLv2Hello,TLSv1,TLSv1.1,TLSv1.2,TLSv1.3</code> 。</p>
      <p>注意<code>TLSv1.3</code>仅当使用实现了JVM的JSSE时才支持<code>TLSv1.3</code> 。</p>
      <p>注意<code>SSLv2Hello</code>对于基于OpenSSL的安全连接器将被忽略。如果为基于OpenSSL的安全连接器指定了多个协议，它将始终支持<code>SSLv2Hello</code> 。如果指定了单个协议，它将不支持<code>SSLv2Hello</code> 。</p>
      <p>注意<code>SSLv2</code>和<code>SSLv3</code>本质上是不安全的。</p>
      <p>如果未指定，则默认值为<code>all</code>将会被使用。</p>
    </td></tr><tr><td><code class="attributeName">revocationEnabled</code></td><td>
      <p>仅限JSSE。</p>
      <p>JSSE提供程序是否应该启用证书吊销检查？如果设置了<strong>certificateRevocationListFile</strong> ，则将忽略此属性，并且始终启用吊销检查。此属性用于启用通过其他方式为当前JSSE提供程序配置的吊销检查。如果未指定，则默认为<code>false</code>用来。</p>
    </td></tr><tr><td><code class="attributeName">sessionCacheSize</code></td><td>
      <p>要在会话缓存中维护的SSL会话数。使用0指定无限的缓存大小。如果未指定，则使用默认值0。</p>
    </td></tr><tr><td><code class="attributeName">sessionTimeout</code></td><td>
      <p>创建SSL会话后将超时的时间（以秒为单位）。使用0指定无限超时。如果未指定，则使用默认值86400（24小时）。</p>
    </td></tr><tr><td><code class="attributeName">sslProtocol</code></td><td>
      <p>仅限JSSE。</p>
      <p>要使用的SSL协议（一个值可以启用多个协议-有关详细信息，请参阅JVM文档）。如果未指定，则默认为<code>TLS</code> 。可以从JVM文档中获取算法创建时允许值的允许值。 <code>SSLContext</code>实例，例如<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SSLContext">Oracle Java 7</a> 。注意：此属性与<code>protocols</code> 。</p>
    </td></tr><tr><td><code class="attributeName">trustManagerClassName</code></td><td>
      <p>仅限JSSE。</p>
      <p>用于验证客户端证书的自定义信任管理器类的名称。该类必须具有零参数构造函数，并且还必须实现<code>javax.net.ssl.X509TrustManager</code> 。如果设置了此属性，则可以忽略信任库属性。</p>
    </td></tr><tr><td><code class="attributeName">truststoreAlgorithm</code></td><td>
      <p>仅限JSSE。</p>
      <p>用于信任库的算法。如果未指定，则返回默认值<code>javax.net.ssl.TrustManagerFactory.getDefaultAlgorithm()</code>用来。</p>
    </td></tr><tr><td><code class="attributeName">truststoreFile</code></td><td>
      <p>仅限JSSE。</p>
      <p>用于验证客户端证书的信任库文件。默认值为<code>javax.net.ssl.trustStore</code>系统属性。如果未设置此属性或默认系统属性，则不会配置任何信任库。相对路径将针对<code>$CATALINA_BASE</code> 。URL也可以用于此属性。</p>
    </td></tr><tr><td><code class="attributeName">truststorePassword</code></td><td>
      <p>仅限JSSE。</p>
      <p>访问信任库的密码。默认值为<code>javax.net.ssl.trustStorePassword</code>系统属性。如果该属性为null，则不会配置任何信任库密码。如果指定了无效的信任库密码，将记录警告，并尝试在没有密码的情况下访问信任库，这将跳过对信任库内容的验证。</p>
    </td></tr><tr><td><code class="attributeName">truststoreProvider</code></td><td>
      <p>仅限JSSE。</p>
      <p>用于服务器证书的信任库提供程序的名称。默认值为<code>javax.net.ssl.trustStoreProvider</code>系统属性。如果该属性为null，则值<code>keystoreProvider</code>用作默认值。如果没有此属性，则默认系统属性或<code>keystoreProvider</code>设置后，将按优先顺序遍历已注册提供程序的列表，并且第一个支持该提供程序的提供程序<code>truststoreType</code>用来。
      </p>
    </td></tr><tr><td><code class="attributeName">truststoreType</code></td><td>
      <p>仅限JSSE。</p>
      <p>用于信任库的密钥库的类型。默认值为<code>javax.net.ssl.trustStoreType</code>系统属性。如果该属性为null，则已为此TLS虚拟主机配置单个证书，并且该证书具有<code>keystoreType</code>那不是<code>PKCS12</code>那么默认值为<code>keystoreType</code>单个证书。如果这些都不标识默认值，则默认值为<code>JKS</code> 。</p>
     </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="SSL_Support_-_Certificate">SSL支持-证书</h4><div class="text">

  <p></p>

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">certificateFile</code></strong></td><td>
      <p>包含服务器证书的文件的名称。格式是PEM编码的。相对路径将针对<code>$CATALINA_BASE</code> 。</p>
      <p>除了证书之外，该文件还可以包含DH参数和/或临时密钥的EC曲线名称作为可选元素，由<code>openssl dhparam</code>和<code>openssl ecparam</code> ， 分别。各个OpenSSL命令的输出可以简单地连接到证书文件。</p>
    </td></tr><tr><td><code class="attributeName">certificateChainFile</code></td><td>
      <p>包含与所使用的服务器证书关联的证书链的文件的名称。格式是PEM编码的。相对路径将针对<code>$CATALINA_BASE</code> 。</p>
      <p>用于Tomcat的证书链不应将服务器证书作为其第一要素。</p>
      <p>请注意，对于不同类型使用多个证书时，它们都必须使用相同的证书链。</p>
    </td></tr><tr><td><code class="attributeName">certificateKeyAlias</code></td><td>
      <p>仅限JSSE。</p>
      <p>密钥库中用于服务器密钥和证书的别名。如果未指定，将使用从密钥库读取的第一个密钥。从密钥库中读取密钥的顺序取决于实现。可能并非以与添加密钥相同的顺序从密钥库中读取密钥。如果密钥库中存在多个密钥，则强烈建议配置keyAlias以确保使用正确的密钥。</p>
    </td></tr><tr><td><code class="attributeName">certificateKeyFile</code></td><td>
      <p>包含服务器私钥的文件的名称。格式是PEM编码的。默认值为<strong>certificateFile</strong>的值，在这种情况下，证书和私钥都必须在此文件中（不推荐）。相对路径将针对<code>$CATALINA_BASE</code> 。</p>
    </td></tr><tr><td><code class="attributeName">certificateKeyPassword</code></td><td>
      <p>用于从指定文件访问与服务器证书关联的私钥的密码。</p>
      <p>如果未指定，则JSSE的默认行为是使用<strong>certificateKeystorePassword</strong> 。对于OpenSSL，默认行为是不使用密码。</p>
    </td></tr><tr><td><code class="attributeName">certificateKeystoreFile</code></td><td>
      <p>仅限JSSE。</p>
      <p>存储服务器证书和要加载的密钥的密钥库文件的路径名。默认情况下，路径名是文件<code>.keystore</code>在运行Tomcat的用户的操作系统主目录中。如果你的<code>keystoreType</code>不需要使用文件<code>""</code> （空字符串）或<code>NONE</code>对于此参数。相对路径将针对<code>$CATALINA_BASE</code> 。URI也可以用于此属性。使用域密钥库时（ <code>keystoreType</code>的<code>DKS</code> ），则此参数应该是域密钥库的URI。</p>
    </td></tr><tr><td><code class="attributeName">certificateKeystorePassword</code></td><td>
      <p>仅限JSSE。</p>
      <p>用于访问包含服务器的私钥和证书的密钥库的密码。如果未指定，则默认为<code>changeit</code>将会被使用。</p>
    </td></tr><tr><td><code class="attributeName">certificateKeystoreProvider</code></td><td>
      <p>仅限JSSE。</p>
      <p>用于服务器证书的密钥库提供程序的名称。如果未指定，则系统属性的值<code>javax.net.ssl.keyStoreProvider</code>用来。如果未设置此属性或系统属性，则将按优先级顺序遍历已注册提供程序的列表，并且第一个支持该提供程序的提供程序<code>keystoreType</code>用来。
      </p>
    </td></tr><tr><td><code class="attributeName">certificateKeystoreType</code></td><td>
      <p>仅限JSSE。</p>
      <p>服务器证书要使用的密钥库文件的类型。如果未指定，则系统属性的值<code>javax.net.ssl.keyStoreType</code>用来。如果既未设置此属性也未设置系统属性，则默认值为“ <code>JKS</code> “。 用来。</p>
    </td></tr><tr><td><code class="attributeName">type</code></td><td>
      <p>证书的类型。这用于识别与证书兼容的密码。它必须是以下之一<code>UNDEFINED</code> ， <code>RSA</code> ， <code>DSS</code>要么<code>EC</code> 。如果仅一个<strong>证书</strong>嵌套在一个<strong>证书</strong>中<code>SSLHostConfig</code>那么此属性不是必需的，并且默认为<code>UNDEFINED</code> 。如果多个<strong>证书</strong>嵌套在一个<strong>证书</strong>中<code>SSLHostConfig</code>那么此属性是必需的，并且每个<strong>证书</strong>必须具有唯一的类型。</p>
    </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="SSL_Support_-_Connector_-_NIO_and_NIO2">SSL支持-连接器-NIO和NIO2</h4><div class="text">

  <p>启用APR / native时，连接器将默认为通过JSSE使用OpenSSL，根据所使用的处理器，它可能比JSSE Java实现更优化，并且可以与许多商业加速器组件进行补充。</p>

  <p>以下NIO和NIO2 SSL配置属性并非特定于虚拟主机，因此必须在连接器上进行配置。</p>

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">sniParseLimit</code></td><td>
      <p>为了实现SNI支持，Tomcat必须解析在新的TLS连接（客户端问候）上收到的第一条TLS消息，以提取请求的服务器名称。该消息需要进行缓冲，以便随后可以将其传递给JSSE实现以进行常规TLS处理。从理论上讲，该第一条消息可能非常大，尽管实际上通常只有几百个字节。此属性设置Tomcat将缓冲的最大消息大小。如果消息超过此大小，则将配置连接，就像客户端未指示任何服务器名称一样。如果未指定默认值<code>65536</code> （64k）将被使用。</p>
    </td></tr><tr><td><code class="attributeName">sslImplementationName</code></td><td>
      <p>要使用的SSL实现的类名。如果未指定并且未安装tomcat本机库，则默认为<code>org.apache.tomcat.util.net.jsse.JSSEImplementation</code>将用于包装JVM的默认JSSE提供程序。请注意，可以将JVM配置为使用其他JSSE提供程序作为默认设置。Tomcat还捆绑了由OpenSSL支持的JSSE特殊SSL实现。要启用它，应像打算使用APR连接器一样启用本机库，Tomcat将自动启用它，并且该属性的默认值变为<code>org.apache.tomcat.util.net.openssl.OpenSSLImplementation</code> 。在这种情况下，只要不混合使用两种类型的属性，就可以使用JSSE和OpenSSL配置样式中的属性（例如，不允许定义Java密钥库的使用并使用OpenSSL属性）。</p>
    </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="SSL_Support_-_Connector_-_NIO_and_NIO2_(deprecated)">SSL支持-连接器-NIO和NIO2（已弃用）</h4><div class="text">

  <p>以下NIO和NIO2 SSL配置属性已被弃用，而默认<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。
  </p>

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">algorithm</code></td><td>
      <p>这是别名<code>keyManagerAlgorithm</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">ciphers</code></td><td>
      <p>这是别名<code>ciphers</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">clientAuth</code></td><td>
      <p>这是别名<code>certificateVerification</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">crlFile</code></td><td>
      <p>这是别名<code>certificateRevocationListFile</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">keyAlias</code></td><td>
      <p>这是别名<code>certificateKeyAlias</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">keyPass</code></td><td>
      <p>这是别名<code>certificateKeyPassword</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">keystoreFile</code></td><td>
      <p>这是别名<code>certificateKeystoreFile</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">keystorePass</code></td><td>
      <p>这是别名<code>certificateKeystorePassword</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">keystoreProvider</code></td><td>
      <p>这是别名<code>certificateKeystoreProvider</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">keystoreType</code></td><td>
      <p>这是别名<code>certificateKeystoreType</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">sessionCacheSize</code></td><td>
      <p>这是别名<code>sessionCacheSize</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">sessionTimeout</code></td><td>
      <p>这是别名<code>sessionTimeout</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">sslEnabledProtocols</code></td><td>
      <p>这是别名<code>protocols</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">sslProtocol</code></td><td>
      <p>这是别名<code>sslProtocol</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">trustManagerClassName</code></td><td>
      <p>这是别名<code>trustManagerClassName</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">trustMaxCertLength</code></td><td>
      <p>这是别名<code>certificateVerificationDepth</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">truststoreAlgorithm</code></td><td>
      <p>这是别名<code>truststoreAlgorithm</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">truststoreFile</code></td><td>
      <p>这是别名<code>truststoreFile</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">truststorePass</code></td><td>
      <p>这是别名<code>truststorePassword</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">truststoreProvider</code></td><td>
      <p>这是别名<code>truststoreProvider</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">truststoreType</code></td><td>
      <p>这是别名<code>truststoreType</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
     </td></tr><tr><td><code class="attributeName">useServerCipherSuitesOrder</code></td><td>
      <p>这是别名<code>honorCipherOrder</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性具有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="SSL_Support_-_Connector_-_APR/Native_(deprecated)">SSL支持-连接器-APR /本机（不建议使用）</h4><div class="text">

  <p>启用APR /本机后，HTTPS连接器将使用套接字轮询器保持活动状态，从而提高服务器的可伸缩性。它还使用OpenSSL，根据使用的处理器，OpenSSL可能比JSSE更优化，并且可以与许多商业加速器组件进行补充。与HTTP连接器不同，HTTPS连接器不能使用sendfile来优化静态文件处理。</p>

  <p>HTTPS APR /本机连接器具有与HTTP APR /本机连接器相同的属性，但添加了OpenSSL特定的属性。有关使用OpenSSL的完整详细信息，请参考OpenSSL文档以及许多可用的书籍（请参见<a href="http://www.openssl.org">OpenSSL官方网站</a> ）。APR /本机连接器的SSL特定属性是：</p>

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">SSLCACertificateFile</code></td><td>
      <p>这是别名<code>caCertificateFile</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLCACertificatePath</code></td><td>
      <p>这是别名<code>caCertificatePath</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLCARevocationFile</code></td><td>
      <p>这是别名<code>certificateRevocationListFile</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLCARevocationPath</code></td><td>
      <p>这是别名<code>certificateRevocationListPath</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><strong><code class="attributeName">SSLCertificateFile</code></strong></td><td>
      <p>这是别名<code>certificateFile</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">SSLCertificateKeyFile</code></td><td>
      <p>这是别名<code>certificateKeyFile</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">SSLCipherSuite</code></td><td>
      <p>这是别名<code>ciphers</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLDisableCompression</code></td><td>
      <p>这是别名<code>disableCompression</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLHonorCipherOrder</code></td><td>
      <p>这是别名<code>honorCipherOrder</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLPassword</code></td><td>
      <p>这是别名<code>certificateKeyPassword</code>嵌套在<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素中的第一个<a href="#SSL_Support_-_Certificate">Certificate</a>元素的属性， <code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_Certificate">证书</a>和/或<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它们。</p>
    </td></tr><tr><td><code class="attributeName">SSLProtocol</code></td><td>
      <p>这是别名<code>protocols</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLVerifyClient</code></td><td>
      <p>这是别名<code>certificateVerification</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLVerifyDepth</code></td><td>
      <p>这是别名<code>certificateVerificationDepth</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr><tr><td><code class="attributeName">SSLDisableSessionTickets</code></td><td>
      <p>这是别名<code>disableSessionTickets</code> <a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素的属性带有<code>hostName</code>的<code>_default_</code> 。如果未明确定义此<a href="#SSL_Support_-_SSLHostConfig">SSLHostConfig</a>元素，则将创建它。</p>
    </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="Connector_Comparison">连接器比较</h4><div class="text">

    <p>下面的小图显示了连接器的不同之处。</p>

    <table class="defaultTable" style="text-align:center">
      <tbody><tr>
        <th></th>
        <th style="text-align:center">Java Nio连接器<br>蔚来</th>
        <th style="text-align:center">Java Nio2连接器<br>NIO2</th>
        <th style="text-align:center">APR /本地连接器<br>年利率</th>
      </tr>
      <tr>
        <th>班级名称</th>
        <td><code class="noHighlight">Http11NioProtocol</code></td>
        <td><code class="noHighlight">Http11Nio2Protocol</code></td>
        <td><code class="noHighlight">Http11AprProtocol</code></td>
      </tr>
      <tr>
        <th>Tomcat版本</th>
        <td>6.x以上</td>
        <td>从8.x开始</td>
        <td>5.5.x以上</td>
      </tr>
      <tr>
        <th>支持轮询</th>
        <td>是</td>
        <td>是</td>
        <td>是</td>
      </tr>
      <tr>
        <th>轮询大小</th>
        <td><code class="noHighlight">maxConnections</code></td>
        <td><code class="noHighlight">maxConnections</code></td>
        <td><code class="noHighlight">maxConnections</code></td>
      </tr>
      <tr>
        <th>读取请求标题</th>
        <td>非阻塞</td>
        <td>非阻塞</td>
        <td>非阻塞</td>
      </tr>
      <tr>
        <th>读取请求正文</th>
        <td>封锁</td>
        <td>封锁</td>
        <td>封锁</td>
      </tr>
      <tr>
        <th>写响应标题和正文</th>
        <td>封锁</td>
        <td>封锁</td>
        <td>封锁</td>
      </tr>
      <tr>
        <th>等待下一个请求</th>
        <td>非阻塞</td>
        <td>非阻塞</td>
        <td>非阻塞</td>
      </tr>
      <tr>
        <th>SSL支持</th>
        <td>Java SSL或OpenSSL</td>
        <td>Java SSL或OpenSSL</td>
        <td>的OpenSSL</td>
      </tr>
      <tr>
        <th>SSL握手</th>
        <td>不阻塞</td>
        <td>不阻塞</td>
        <td>封锁</td>
      </tr>
      <tr>
        <th>最大连接数</th>
        <td><code class="noHighlight">maxConnections</code></td>
        <td><code class="noHighlight">maxConnections</code></td>
        <td><code class="noHighlight">maxConnections</code></td>
      </tr>
    </tbody></table>

  </div></div>
</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="../comments.html">这里</a>解释<a href="../comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>