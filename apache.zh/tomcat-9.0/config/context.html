<html lang="zh-Hans" ><head></head><body >﻿<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="../images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9配置参考（9.0.21）-上下文容器</title><meta name="author" content="Craig R. McClanahan"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/config/context">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="../images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="../images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9配置参考</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="../index.html">文件首页</a></li><li><a href="index.html">配置参考家</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>顶级元素</h2><ul><li><a href="server.html">服务器</a></li><li><a href="service.html">服务</a></li></ul></div><div><h2>执行者</h2><ul><li><a href="executor.html">执行者</a></li></ul></div><div><h2>连接器</h2><ul><li><a href="http.html">HTTP / 1.1</a></li><li><a href="http2.html">HTTP / 2</a></li><li><a href="ajp.html">AJP</a></li></ul></div><div><h2>货柜</h2><ul><li><a href="context.html">语境</a></li><li><a href="engine.html">发动机</a></li><li><a href="host.html">主办</a></li><li><a href="cluster.html">簇</a></li></ul></div><div><h2>嵌套组件</h2><ul><li><a href="cookie-processor.html">Cookie处理器</a></li><li><a href="credentialhandler.html">凭证处理程序</a></li><li><a href="globalresources.html">全球资源</a></li><li><a href="jar-scanner.html">JarScanner</a></li><li><a href="jar-scan-filter.html">JarScanFilter</a></li><li><a href="listeners.html">听众</a></li><li><a href="loader.html">装载机</a></li><li><a href="manager.html">经理</a></li><li><a href="realm.html">领域</a></li><li><a href="resources.html">资源资源</a></li><li><a href="sessionidgenerator.html">SessionIdGenerator</a></li><li><a href="valve.html">阀</a></li></ul></div><div><h2>集群元素</h2><ul><li><a href="cluster.html">簇</a></li><li><a href="cluster-manager.html">经理</a></li><li><a href="cluster-channel.html">渠道</a></li><li><a href="cluster-membership.html">频道/会员</a></li><li><a href="cluster-sender.html">频道/发件人</a></li><li><a href="cluster-receiver.html">频道/接收器</a></li><li><a href="cluster-interceptor.html">通道/拦截器</a></li><li><a href="cluster-valve.html">阀</a></li><li><a href="cluster-deployer.html">部署者</a></li><li><a href="cluster-listener.html">集群监听器</a></li></ul></div><div><h2>web.xml</h2><ul><li><a href="filter.html">过滤</a></li></ul></div><div><h2>其他</h2><ul><li><a href="systemprops.html">系统属性</a></li><li><a href="jaspic.html">日本宝石</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>上下文容器</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Introduction">介绍</a><ol><li><a href="#Parallel_deployment">并行部署</a></li><li><a href="#Naming">命名</a></li><li><a href="#Defining_a_context">定义上下文</a></li></ol></li><li><a href="#Attributes">属性</a><ol><li><a href="#Common_Attributes">共同属性</a></li><li><a href="#Standard_Implementation">标准实施</a></li></ol></li><li><a href="#Nested_Components">嵌套组件</a></li><li><a href="#Special_Features">特殊功能</a><ol><li><a href="#Logging">记录中</a></li><li><a href="#Access_Logs">访问日志</a></li><li><a href="#Automatic_Context_Configuration">自动上下文配置</a></li><li><a href="#Context_Parameters">上下文参数</a></li><li><a href="#Environment_Entries">环境条目</a></li><li><a href="#Lifecycle_Listeners">生命周期侦听器</a></li><li><a href="#Request_Filters">请求过滤器</a></li><li><a href="#Resource_Definitions">资源定义</a></li><li><a href="#Resource_Links">资源链接</a></li><li><a href="#Transaction">交易</a></li></ol></li></ul>
</div><h3 id="Introduction">介绍</h3><div class="text">

    <p><em>下面的描述使用变量名$ CATALINA_BASE来引用可解决大多数相对路径的基本目录。如果尚未通过设置CATALINA_BASE目录为多个实例配置Tomcat，则$ CATALINA_BASE将设置为$ CATALINA_HOME的值，该目录已将Tomcat安装到该目录中。
    </em></p>

  <p><strong>Context</strong>元素表示一个<em>Web应用程序</em> ，它在特定的虚拟主机中运行。每个Web应用程序都基于<em>Web应用程序存档</em> （WAR）文件或包含相应解压缩内容的相应目录，如Servlet规范（2.2或更高版本）中所述。有关Web应用程序归档文件的更多信息，可以下载<a href="https://wiki.apache.org/tomcat/Specifications">Servlet规范</a> ，并查看《 Tomcat <a href="../appdev/index.html">应用程序开发人员指南》</a> 。</p>

  <p>Catalina通过将Request URI的最长可能前缀与每个定义的Context的<em>上下文路径</em>进行匹配，来选择用于处理每个HTTP请求的Web应用程序。选择之后，该上下文将根据Web应用程序部署定义的servlet映射，选择适当的servlet来处理传入的请求。</p>

  <p>您可以根据需要定义任意多个<strong>Context</strong>元素。每个这样的上下文必须在虚拟主机中具有唯一的上下文名称。上下文路径不必唯一（请参见下面的<em>并行部署</em> ）。另外，必须使用等于零长度字符串的上下文路径来提供上下文。此上下文成为该虚拟主机的<em>默认</em> Web应用程序，并用于处理与任何其他上下文的上下文路径都不匹配的所有请求。</p>

  <div class="subsection"><h4 id="Parallel_deployment">并行部署</h4><div class="text">
  <p><b>您可以同时部署具有相同上下文路径的多个版本的Web应用程序。</b> 用于将请求匹配到上下文版本的规则如下：</p>
  <ul>
  <li>如果请求中没有会话信息，请使用最新版本。</li>
  <li>如果请求中存在会话信息，请检查每个版本的会话管理器以查找匹配的会话，如果找到一个，则使用该版本。</li>
  <li>如果请求中存在会话信息，但找不到匹配的会话，请使用最新版本。</li>
  </ul>
  <p>可以配置<a href="host.html">主机</a> （通过<code>undeployOldVersions</code> ），以便在不再使用以这种方式部署的旧版本时将其删除。</p>
  </div></div>

  <div class="subsection"><h4 id="Naming">命名</h4><div class="text">
  <p>什么时候<code>autoDeploy</code>要么<code>deployOnStartup</code>操作由主机执行，Web应用程序的名称和上下文路径来自定义Web应用程序的文件的名称。因此，上下文路径<strong>可能未</strong>在<code>META-INF/context.xml</code>嵌入在应用程序中， <em>上下文名称</em> ， <em>上下文路径</em> ， <em>上下文版本</em>和<em>基本文件名称</em> （名称减去任何<code>.war</code>要么<code>.xml</code>扩展名）。</p>

  <p>如果未指定版本，则<em>上下文名称</em>始终与<em>上下文路径</em>相同。如果<em>上下文路径</em>为空字符串，则<em>基本名称</em>将为ROOT（始终为大写），否则， <em>基本名称</em>将为<em>上下文路径</em> ，其中前导'/'被删除，所有剩余的'/'字符均被替换为'＃'。</p>

  <p>如果指定了版本，则<em>上下文路径</em>保持不变，并且<em>上下文名称</em>和<em>基本名称</em>都附加了字符串“ ##”，后跟版本标识符。</p>

  <p>这些命名约定的一些示例在下面给出。</p>

  <table class="detail-table">
    <tbody><tr>
      <th>上下文路径</th>
      <th>上下文版本</th>
      <th>上下文名称</th>
      <th>基本文件名</th>
      <th>示例文件名（.xml，.war和目录）</th>
    </tr>
    <tr>
      <td>/ foo</td>
      <td><i>没有</i></td>
      <td>/ foo</td>
      <td>富</td>
      <td>foo.xml，foo.war，foo</td>
    </tr>
    <tr>
      <td>/ foo / bar</td>
      <td><i>没有</i></td>
      <td>/ foo / bar</td>
      <td>foo＃bar</td>
      <td>foo＃bar.xml，foo＃bar.war，foo＃bar</td>
    </tr>
    <tr>
      <td><i>空字符串</i></td>
      <td><i>没有</i></td>
      <td><i>空字符串</i></td>
      <td>根</td>
      <td>ROOT.xml，ROOT.war，ROOT</td>
    </tr>
    <tr>
      <td>/ foo</td>
      <td>42</td>
      <td>/ foo ## 42</td>
      <td>foo ## 42</td>
      <td>foo ## 42.xml，foo ## 42.war，foo ## 42</td>
    </tr>
    <tr>
      <td>/ foo / bar</td>
      <td>42</td>
      <td>/ foo / bar ## 42</td>
      <td>foo＃bar ## 42</td>
      <td>foo＃bar ## 42.xml，foo＃bar ## 42.war，foo＃bar ## 42</td>
    </tr>
    <tr>
      <td><i>空字符串</i></td>
      <td>42</td>
      <td>## 42</td>
      <td>根## 42</td>
      <td>ROOT ## 42.xml，ROOT ## 42.war，ROOT ## 42</td>
    </tr>
  </tbody></table>

  <p>版本组件被视为<code>String</code>出于性能原因，并允许版本控制方案具有灵活性。字符串比较用于确定版本顺序。如果未指定version，则将其视为空字符串。因此， <code>foo.war</code>将被视为早于<code>foo##11.war</code>和<code>foo##11.war</code>将被视为早于<code>foo##2.war</code> 。如果使用纯数字版本控制方案，建议使用零填充，以便<code>foo##002.war</code>被视为早于<code>foo##011.war</code> 。
  </p>

  <p>如果要使用与基本文件名无关的上下文路径来部署WAR文件或目录，则必须使用以下选项之一来防止双重部署：</p>
  <ul>
  <li>禁用autoDeploy和deployOnStartup并在server.xml中定义所有<strong>Context</strong></li>
  <li>在主机的appBase之外找到WAR和/或目录，并使用带有docBase属性的context.xml文件对其进行定义。</li>
  </ul>
  </div></div>

  <div class="subsection"><h4 id="Defining_a_context">定义上下文</h4><div class="text">
  <p><b>不建议将<context>元素直接放置在server.xml文件中。</context></b> 这是因为它使得修改<strong>Context</strong>配置由于主更侵入<code>conf/server.xml</code>如果不重新启动Tomcat，则无法重新加载文件。默认<strong>上下文</strong>元素（请参见下文）还将<strong>覆盖</strong> <context>直接放置在server.xml中的任何<context>元素的配置<context>。为了防止这种情况， <code>override</code> <context>server.xml中定义</context>的<context>元素的</context>属性<context>应设置为<code>true</code> 。</context></context></context></context></p>

  <p>各个<strong>上下文</strong>元素可以明确定义：</p>
  <ul>
  <li>在单个文件中<code>/META-INF/context.xml</code>在应用程序文件中。可以选择（基于主机的copyXML属性）将其复制到<code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code>并重命名为应用程序的基本文件名以及“ .xml”扩展名。</li>
  <li>在单个文件（扩展名为“ .xml”）中， <code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code>目录。上下文路径和版本将从文件的基本名称（文件名减去.xml扩展名）派生。该文件将始终优先于Web应用程序的META-INF目录中打包的任何context.xml文件。</li>
  <li>里面一个<a href="host.html">主机</a>中的主要元素<code>conf/server.xml</code> 。</li>
  </ul>

  <p>可以定义适用于多个Web应用程序的默认<strong>上下文</strong>元素。单个Web应用程序的配置将覆盖这些默认值之一中配置的所有内容。<resource>对于默认<strong>上下文</strong>所应用的每个<strong>上下文</strong> ，将创建一次在默认<strong>上下文</strong>中定义的任何嵌套元素，例如<resource>元素。它们<b>不会</b>在<strong>Context</strong>元素之间共享。
  </resource></resource></p>
  <ul>
  <li>在里面<code>$CATALINA_BASE/conf/context.xml</code>文件：上下文元素信息将由所有Web应用程序加载。</li>
  <li>在里面<code>$CATALINA_BASE/conf/[enginename]/[hostname]/context.xml.default</code>文件：上下文元素信息将由该主机的所有Web应用程序加载。</li>
  </ul>

  <p>除server.xml外，定义<strong>Context</strong>元素的文件只能定义单个<strong>Context</strong>元素。
  </p>

  <p>除了明确指定的Context元素外，还有几种技术可以自动为您创建Context元素。有关更多信息，请参见<a href="host.html#Automatic_Application_Deployment">自动应用程序部署</a>和<a href="host.html#User_Web_Applications">用户Web应用程序</a> 。</p>

  <p>若要定义使用单个WAR文件或目录的多个上下文，请使用上面“ <a href="#Naming">命名”</a>部分中描述的选项之一来创建<strong>上下文</strong>路径与基本文件名无关的<strong>上下文</strong> 。</p>
  </div></div>
</div><h3 id="Attributes">属性</h3><div class="text">

  <div class="subsection"><h4 id="Common_Attributes">共同属性</h4><div class="text">

    <p><strong>Context的</strong>所有实现都支持以下属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">allowCasualMultipartParsing</code></td><td>
        <p>如果Tomcat在调用HttpServletRequest.getPart *或HttpServletRequest.getParameter *时自动解析多部分/表单数据请求主体，则设置为true，即使目标servlet没有标记@MultipartConfig注释（请参阅Servlet Specification 3.0，第3.2节）有关详细信息）。请注意，除<code>false</code>导致Tomcat的行为不符合技术规范。默认是<code>false</code></p>
      </td></tr><tr><td><code class="attributeName">allowMultipleLeadingForwardSlashInPath</code></td><td>
        <p>Tomcat将多个序列归一化<code>/</code> URI中的单个字符<code>/</code> 。这是为了与文件系统的行为保持一致，因为URI通常会转换为文件系统路径。结果，返回值<code>HttpServletRequest#getContextPath()</code>预期以多个开头<code>/</code>一些URI的字符。如果直接将此值与<code>HttpServletResponse#sendRedirect()</code>作为以开头的重定向路径<code>//</code>被视为协议相对重定向。为了避免潜在的问题，Tomcat将折叠多个<code>/</code>返回值开头的字符<code>HttpServletRequest#getContextPath()</code>到一个<code>/</code> 。此属性的默认值为<code>false</code>可以折叠多个<code>/</code>字符。要禁用此行为，请将此属性设置为<code>true</code> 。</p>
      </td></tr><tr><td><code class="attributeName">altDDName</code></td><td>
        <p>此上下文的备用部署描述符的绝对路径。这将覆盖位于以下位置的默认部署描述符<code>/WEB-INF/web.xml</code> 。</p>
      </td></tr><tr><td><code class="attributeName">backgroundProcessorDelay</code></td><td>
        <p>此值表示在此上下文上调用backgroundProcess方法及其子容器（包括所有包装程序）之间的延迟（以秒为单位）。如果子容器的延迟值不为负（则表示它们正在使用自己的处理线程），则不会调用它们。将此值设置为正值将导致产生线程。等待指定的时间后，线程将在此主机及其所有子容器上调用backgroundProcess方法。上下文将使用后台处理来执行会话到期和类监视以进行重新加载。如果未指定，则此属性的默认值为-1，这意味着上下文将依赖于其父主机的后台处理线程。</p>
      </td></tr><tr><td><code class="attributeName">className</code></td><td>
        <p>使用的Java类名称。此类必须实现<code>org.apache.catalina.Context</code>接口。如果未指定，将使用标准值（定义如下）。</p>
      </td></tr><tr><td><code class="attributeName">containerSciFilter</code></td><td>
        <p>指定应过滤掉提供SCI的容器的正则表达式，并且不用于此上下文。配套用途<code>java.util.regex.Matcher.find()</code>因此，正则表达式只需要匹配提供SCI的容器的完全合格类名的子字符串，即可将其过滤掉。如果未指定，则不应用任何过滤。</p>
      </td></tr><tr><td><code class="attributeName">cookies</code></td><td>
        <p>调成<code>true</code>如果要在客户端支持的情况下将cookie用于会话标识符通信（默认设置）。调成<code>false</code>如果要禁用cookie来进行会话标识符通信，而仅依赖于应用程序重写URL。</p>
      </td></tr><tr><td><code class="attributeName">createUploadTargets</code></td><td>
        <p>调成<code>true</code> Tomcat是否应尝试创建在<code>MultipartConfig</code> Servlet，如果该位置尚不存在。如果未指定，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">crossContext</code></td><td>
        <p>调成<code>true</code>如果您想在此应用程序内拨打电话<code>ServletContext.getContext()</code>成功返回该虚拟主机上运行的其他Web应用程序的请求调度程序。调成<code>false</code> （默认）在注重安全的环境中<code>getContext()</code>总是回来<code>null</code> 。</p>
      </td></tr><tr><td><strong><code class="attributeName">docBase</code></strong></td><td>
        <p>此Web应用程序的<em>Document Base</em> （也称为<em>Context Root</em> ）目录，或Web应用程序存档文件的路径名（如果直接从WAR文件执行此Web应用程序）。您可以为此目录或WAR文件指定绝对路径名，也可以指定相对于<code>appBase</code>所属<a href="host.html">主机的</a>目录。</p>
        <p>除非在server.xml中定义了Context元素，否则不得设置此字段的值。 <code>docBase</code>不在<a href="host.html">主持人</a>的<code>appBase</code> 。</p>
        <p>如果将符号链接用于docBase，则仅在Tomcat重新启动或通过取消部署和重新部署上下文后，对符号链接的更改才会生效。上下文重载是不够的。</p>
      </td></tr><tr><td><code class="attributeName">dispatchersUseEncodedPaths</code></td><td>
        <p>控制是否期望对用于获取请求分配器的调用中的路径进行编码。这不仅影响Tomcat处理调用以获取请求分配器的方式，还影响Tomcat内部生成用于获取请求分配器的路径的方式。如果未指定，则默认值为<code>true</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">failCtxIfServletStartFails</code></td><td>
        <p>调成<code>true</code>如果任何具有load-on-startup> = 0的servlet自身无法启动，则使上下文无法启动。</p>
        <p>如果未指定，则使用父主机配置中相同名称的属性（如果指定）。否则，默认值为<code>false</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">fireRequestListenersOnForwards</code></td><td>
        <p>调成<code>true</code>在Tomcat转发请求时触发任何已配置的ServletRequestListeners。这主要适用于使用ServletRequestListeners为请求配置必要环境的CDI框架的用户。如果未指定，则默认值为<code>false</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">logEffectiveWebXml</code></td><td>
        <p>调成<code>true</code>如果要在应用程序启动时记录用于Web应用程序的有效web.xml（在INFO级别）。有效的web.xml是将应用程序的web.xml与Tomcat配置的任何默认值以及发现的任何web-fragment.xml文件和注释结合在一起的结果。如果未指定，则默认值为<code>false</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">mapperContextRootRedirectEnabled</code></td><td>
        <p>如果启用，则如有必要，映射器（而不是默认Servlet）将重定向对Web应用程序上下文根的请求（添加斜杠）。这更有效，但具有确认上下文路径存在的副作用。如果未指定，则默认值为<code>true</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">mapperDirectoryRedirectEnabled</code></td><td>
        <p>如果启用，则对Web应用程序目录的请求将在必要时由Mapper而不是默认Servlet重定向（添加斜杠）。这效率更高，但具有确认目录存在的副作用。如果未指定，则默认值为<code>false</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">override</code></td><td>
        <p>调成<code>true</code>忽略全局或<a href="host.html">主机</a>默认上下文中的任何设置。默认情况下，将使用默认上下文中的设置，但可以通过为上下文显式设置相同的属性来覆盖这些设置。</p>
      </td></tr><tr><td><code class="attributeName">path</code></td><td>
        <p>此Web应用程序的<em>上下文路径</em>与每个请求URI的开头匹配，以选择适当的Web应用程序进行处理。特定<a href="host.html">主机</a>内的所有上下文路径必须唯一。如果指定空字符串（“”）的上下文路径，则将为此主机定义<em>默认的</em> Web应用程序，它将处理所有未分配给其他上下文的请求。</p>
        <p>仅当在server.xml中静态定义上下文时，才必须使用此属性。在所有其他情况下，将从用于.xml上下文文件或docBase的文件名中推断出路径。
        </p>
        <p>即使在server.xml中静态定义Context时，也必须设置此属性，除非docBase不在<a href="host.html">Host</a>的下面。 <code>appBase</code>或两者<code>deployOnStartup</code>和<code>autoDeploy</code>是假的。如果不遵循此规则，则可能导致双重部署。</p>
      </td></tr><tr><td><code class="attributeName">preemptiveAuthentication</code></td><td>
        <p>设置为<code>true</code>并且用户提供不受安全约束保护的资源的凭据，如果身份验证器支持抢占式身份验证（Tomcat随附的标准身份验证器），则将处理用户的凭据。如果未指定，则默认为<code>false</code>用来。
        </p>
      </td></tr><tr><td><code class="attributeName">privileged</code></td><td>
        <p>调成<code>true</code>以允许此上下文使用容器servlet，例如管理器servlet。使用<code>privileged</code>属性会将上下文的父类加载器更改为<em>服务器</em>类加载器，而不是<em>共享</em>类加载器。请注意，在默认安装中，“ <em>公共”</em>类加载器用于“ <em>服务器”</em>和“ <em>共享”</em>类加载器。</p>
      </td></tr><tr><td><code class="attributeName">reloadable</code></td><td>
        <p>调成<code>true</code>如果您想让Catalina监控<code>/WEB-INF/classes/</code>和<code>/WEB-INF/lib</code>进行更改，并在检测到更改时自动重新加载Web应用程序。此功能在应用程序开发期间非常有用，但是它需要大量的运行时开销，因此不建议在已部署的生产应用程序上使用。这就是为什么此属性的默认设置为<i>false的原因</i> 。但是，您可以使用<a href="../manager-howto.html">Manager</a> Web应用程序来触发按需重新加载已部署的应用程序。</p>
      </td></tr><tr><td><code class="attributeName">resourceOnlyServlets</code></td><td>
        <p>逗号分隔的Servlet名称列表（用于<code>/WEB-INF/web.xml</code> ），期望资源存在。确保在不存在资源的情况下，不使用与希望与资源存在的Servlet相关联的欢迎文件（例如JSP Servlet）。这样可以防止由于Servlet 3.0规范的10.10节中对欢迎文件映射的阐明而导致的问题。如果<code>org.apache.catalina.STRICT_SERVLET_COMPLIANCE</code> <a href="systemprops.html">系统属性</a>设置为<code>true</code> ，此属性的默认值为空字符串，否则默认值为<code>jsp</code> 。</p>
      </td></tr><tr><td><code class="attributeName">sendRedirectBody</code></td><td>
        <p>如果<code>true</code> ，重定向响应将包含一个简短的响应主体，其中包含RFC 2616建议的重定向详细信息。默认情况下禁用此选项，因为包括响应主体可能会导致某些应用程序组件（例如压缩过滤器）出现问题。</p>
      </td></tr><tr><td><code class="attributeName">sessionCookieDomain</code></td><td>
        <p>用于为此上下文创建的所有会话cookie的域。如果设置，则它将覆盖Web应用程序设置的任何域。如果未设置，则将使用Web应用程序指定的值（如果有）。</p>
      </td></tr><tr><td><code class="attributeName">sessionCookieName</code></td><td>
        <p>用于为此上下文创建的所有会话cookie的名称。如果设置，它将覆盖Web应用程序设置的任何名称。如果未设置，将使用由Web应用程序指定的值（如果有）或名称<code>JSESSIONID</code>如果Web应用程序未明确设置一个。</p>
      </td></tr><tr><td><code class="attributeName">sessionCookiePath</code></td><td>
        <p>用于为此上下文创建的所有会话cookie的路径。如果设置，它将覆盖Web应用程序设置的任何路径。如果未设置，则将使用Web应用程序指定的值，如果Web应用程序未明确设置一个，则使用上下文路径。要将所有Web应用程序配置为使用空路径（这对于portlet规范实现很有用），请将此属性设置为<code>/</code>在全球范围内<code>CATALINA_BASE/conf/context.xml</code>文件。</p>
        <p>注意：一次使用一个Web应用程序<code>sessionCookiePath="/"</code>获取会话，同一主机中其他任何Web应用程序的所有后续会话也配置为<code>sessionCookiePath="/"</code>将始终使用相同的会话ID。即使会话无效并创建了一个新会话，该设置仍然成立。这使得会话固定保护更加困难，并且需要定制的特定于Tomcat的代码来更改多个应用程序共享的会话ID。</p>
      </td></tr><tr><td><code class="attributeName">sessionCookiePathUsesTrailingSlash</code></td><td>
        <p>某些浏览器（例如Internet Explorer，Safari和Edge）将发送路径为的上下文的会话Cookie <code>/foo</code>要求<code>/foobar</code>违反RFC6265。这可能会暴露来自部署在以下位置的应用程序的会话ID <code>/foo</code>到部署在的应用程序<code>/foobar</code> 。如果应用程序部署在<code>/foobar</code>不信任，可能会造成安全风险。但是，应注意，RFC 6265第8.5节明确指出，仅路径不应被视为足以防止不受信任的应用程序从其他应用程序访问cookie。为了减轻这种风险，可以将此属性设置为<code>true</code>并且Tomcat将在与会话cookie关联的路径后添加斜杠，因此，在上面的示例中，cookie路径变为/ foo /。但是，使用/ foo /的cookie路径，浏览器将不再将带有请求的cookie发送到/ foo。除非有一个servlet映射到/ *，否则这应该不是问题。在这种情况下，需要将该属性设置为<code>false</code>禁用此功能。该属性的默认值为<code>false</code> 。</p>
      </td></tr><tr><td><code class="attributeName">swallowAbortedUploads</code></td><td>
        <p>设置为false如果Tomcat <b>不</b>应该阅读中止上传，而是中止客户端连接任何额外要求的身体数据。在以下情况下使用此设置：</p>
        <ul>
        <li>请求正文的大小大于<code>maxPostSize</code>在连接器中配置</li>
        <li>已达到MultiPart上传的大小限制</li>
        <li>Servlet将响应状态设置为413（请求实体太大）</li>
        </ul>
        <p>不读取其他数据将更快地释放请求处理线程。不幸的是，如果大多数HTTP客户端无法编写完整的请求，它们将不会读取响应。</p>
        <p>默认是<code>true</code> ，因此将读取其他数据。</p>
        <p>请注意，如果在触发5xx响应的请求处理期间发生错误，则一旦写入错误响应，所有未读的请求数据将始终被忽略，并且客户端连接将被关闭。</p>
      </td></tr><tr><td><code class="attributeName">swallowOutput</code></td><td>
        <p>如果此标志的值为<code>true</code> ，Web应用程序输出到System.out和System.err的字节将被重定向到Web应用程序记录器。如果未指定，则标志的默认值为<code>false</code> 。</p>
      </td></tr><tr><td><code class="attributeName">tldValidation</code></td><td>
        <p>如果此标志的值为<code>true</code> ，则TLD文件将在上下文启动时经过XML验证。如果<code>org.apache.catalina.STRICT_SERVLET_COMPLIANCE</code> <a href="systemprops.html">系统属性</a>设置为<code>true</code> ，此属性的默认值为<code>true</code> ，否则默认值为<code>false</code> 。将此属性设置为<code>true</code>将会导致性能下降。</p>
      </td></tr><tr><td><code class="attributeName">useHttpOnly</code></td><td>
       <p>是否应在会话cookie上设置HttpOnly标志，以防止客户端脚本访问会话ID？默认为<code>true</code> 。</p>
      </td></tr><tr><td><code class="attributeName">useRelativeRedirects</code></td><td>
        <p>控制是否通过调用HTTP生成HTTP 1.1和更高版本的位置标头<code>javax.servlet.http.HttpServletResponse#sendRedirect(String)</code>将使用相对或绝对重定向。相对重定向更有效，但可能不适用于更改上下文路径的反向代理。应该注意的是，由于它产生了多个问题，因此不建议使用反向代理来更改上下文路径。绝对重定向应与反向代理一起使用，这些代理可以更改上下文路径，但可能会导致<code>org.apache.catalina.filters.RemoteIpFilter</code>如果过滤器正在更改方案和/或端口。如果<code>org.apache.catalina.STRICT_SERVLET_COMPLIANCE</code> <a href="systemprops.html">系统属性</a>设置为<code>true</code> ，此属性的默认值为<code>false</code> ，否则默认值为<code>true</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">validateClientProvidedNewSessionId</code></td><td>
        <p>当客户端为新会话提供ID时，此属性控制该ID是否经过验证。使用客户端提供的会话ID的唯一用例是在多个Web应用程序之间具有通用的会话ID。因此，任何客户端提供的会话ID应该已经存在于另一个Web应用程序中。如果启用此检查，则仅当会话ID存在于当前主机的至少一个其他Web应用程序中时，才使用客户端提供的会话ID。请注意，无论此设置如何，都将始终执行以下附加测试：</p>
        <ul>
          <li>会话ID由Cookie提供</li>
          <li>会话Cookie的路径为{@code /}</li>
        </ul>
        <p>如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">wrapperClass</code></td><td>
        <p>Java类名<code>org.apache.catalina.Wrapper</code>实现类，将用于此Context管理的servlet。如果未指定，将使用标准默认值。</p>
      </td></tr><tr><td><code class="attributeName">xmlBlockExternal</code></td><td>
        <p>如果此标志的值为<code>true</code> ，解析<code>web.xml</code> ， <code>web-fragment.xml</code> ， <code>tomcat-web.xml</code> ， <code>*.tld</code> ， <code>*.jspx</code> ， <code>*.tagx</code>和<code>tagPlugins.xml</code>此Web应用程序的文件将不允许加载外部实体。如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">xmlNamespaceAware</code></td><td>
        <p>如果此标志的值为<code>true</code> ，解析<code>web.xml</code> ， <code>web-fragment.xml</code>和<code>tomcat-web.xml</code>此Web应用程序的文件将支持名称空间。注意<code>*.tld</code> ， <code>*.jspx</code>和<code>*.tagx</code>始终使用支持名称空间的解析器来解析文件，并且<code>tagPlugins.xml</code>永远不会使用支持名称空间的解析器来解析文件（如果有）。还要注意，如果打开此标志，则可能还应该打开<code>xmlValidation</code>上。如果<code>org.apache.catalina.STRICT_SERVLET_COMPLIANCE</code> <a href="systemprops.html">系统属性</a>设置为<code>true</code> ，此属性的默认值为<code>true</code> ，否则默认值为<code>false</code> 。将此属性设置为<code>true</code>将会导致性能下降。</p>
      </td></tr><tr><td><code class="attributeName">xmlValidation</code></td><td>
        <p>如果此标志的值为<code>true</code> ，解析<code>web.xml</code> ， <code>web-fragment.xml</code>和<code>tomcat-web.xml</code>此Web应用程序的文件将使用验证解析器。如果<code>org.apache.catalina.STRICT_SERVLET_COMPLIANCE</code> <a href="systemprops.html">系统属性</a>设置为<code>true</code> ，此属性的默认值为<code>true</code> ，否则默认值为<code>false</code> 。将此属性设置为<code>true</code>将会导致性能下降。</p>
      </td></tr></tbody></table>

  </div></div>


  <div class="subsection"><h4 id="Standard_Implementation">标准实施</h4><div class="text">

    <p><strong>Context</strong>的标准实现是<strong>org.apache.catalina.core。StandardContext</strong> 。它支持以下其他属性（除了上面列出的常见属性之外）：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">addWebinfClassesResources</code></td><td>
        <p>除了从中提供静态资源之外，此属性还控制是否<code>META-INF/resources</code>在Web应用程序JAR文件中，静态资源也可以从<code>WEB-INF/classes/META-INF/resources</code> 。这仅适用于主版本为3或更高版本的Web应用程序。由于这是Servlet 3规范的专有扩展，因此默认情况下将其禁用。要启用此功能，请将属性设置为<code>true</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">antiResourceLocking</code></td><td>
        <p>如果为true，Tomcat将阻止任何文件锁定。这将显着影响应用程序的启动时间，但允许完整的webapp热部署和在可能发生文件锁定的平台或配置上取消部署。如果未指定，则默认值为<code>false</code> 。</p>

        <p>请注意，将此设置为<code>true</code>有一些副作用，包括在运行中的服务器中禁用JSP重载：请参见<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=37668">Bugzilla 37668</a> 。</p>

        <p>请注意，在主机的appBase之外的应用程序（ <code>webapps</code>目录（默认情况下为目录）将导致在Tomcat关闭时<strong>删除</strong>该应用程序。您可能不想这样做，因此，在主机的appBase之外的Web应用程序上设置antiResourceLocking = true之前，请三思。</p>
      </td></tr><tr><td><code class="attributeName">clearReferencesHttpClientKeepAliveThread</code></td><td>
        <p>如果<code>true</code>和<code>sun.net.www.http.HttpClient</code>该Web应用程序已经启动了keep-alive计时器线程，并且该线程仍在运行，Tomcat会将该线程的上下文类加载器从Web应用程序类加载器更改为Web应用程序类加载器的父级，以防止内存泄漏。请注意，一旦保持活动全部到期，保持活动计时器线程将自行停止，但是在忙碌的系统上可能不会再出现一段时间了。如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">clearReferencesObjectStreamClassCaches</code></td><td>
        <p>如果<code>true</code> ，当Web应用程序停止时，Tomcat查找<code>SoftReference</code>到Web应用程序在<code>ObjectStreamClass</code>用于序列化的类，并清除任何<code>SoftReference</code>它找到了。此功能使用反射来识别<code>SoftReference</code> s，因此需要命令行选项<code>-XaddExports:java.base/java.io=ALL-UNNAMED</code>在Java 9及更高版本上运行时设置。如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">clearReferencesRmiTargets</code></td><td>
        <p>如果<code>true</code> ，Tomcat查找与RMI Targets相关的内存泄漏并清除找到的所有内容。此功能使用反射来识别泄漏，因此需要命令行选项<code>-XaddExports:java.rmi/sun.rmi.transport=ALL-UNNAMED</code>在Java 9及更高版本上运行时设置。将此属性设置为，没有内存泄漏的应用程序应正确运行。 <code>false</code> 。如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">clearReferencesStopThreads</code></td><td>
        <p>如果<code>true</code> ，Tomcat尝试终止Web应用程序已启动的线程。停止线程是通过不推荐使用的（有充分的理由） <code>Thread.stop()</code>方法，可能会导致不稳定。因此，在开发环境中启用此选项应被视为最后选择，在生产环境中不建议启用。如果未指定，则默认值为<code>false</code>将会被使用。如果启用了此功能，则在停止执行之前，Web应用程序最多可能需要两秒钟的时间才能停止，因为执行程序线程最多可以有两秒钟的时间才能正常停止<code>Thread.stop()</code>在任何其余线程上被调用。</p>
      </td></tr><tr><td><code class="attributeName">clearReferencesStopTimerThreads</code></td><td>
        <p>如果<code>true</code> ，Tomcat尝试终止<code>java.util.Timer</code> Web应用程序已启动的线程。与标准线程不同，计时器线程可以安全地停止，尽管对于应用程序可能仍然会有副作用。如果未指定，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">clearReferencesThreadLocals</code></td><td>
        <p>如果<code>true</code> ，Tomcat尝试清除<code>java.lang.ThreadLocal</code>已用Web应用程序加载的类填充的变量。如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">copyXML</code></td><td>
        <p>调成<code>true</code>如果要在应用程序中嵌入上下文XML描述符（位于<code>/META-INF/context.xml</code> ）将被复制到拥有<a href="host.html">主机</a>的<code>xmlBase</code>部署应用程序时。在随后的启动中，将优先使用复制的上下文XML描述符，即使嵌入在应用程序内部的描述符是最新的，也将优先使用嵌入在应用程序内部的任何上下文XML描述符。标志的值默认为<code>false</code> 。请注意，如果拥有<a href="host.html">主机</a>的<strong>deployXML</strong>属性是<code>false</code>或拥有的<a href="host.html">主机</a>的<strong>copyXML</strong>属性是<code>true</code> ，此属性将无效。</p>
      </td></tr><tr><td><code class="attributeName">jndiExceptionOnFailedWrite</code></td><td>
        <p>如果<code>true</code> ，应用程序通过对bind（），unbind（），createSubContext（），destroySubContext（）或close（）的调用来修改提供的JNDI上下文的任何尝试都会触发<code>javax.naming.OperationNotSupportedException</code>按照Java EE规范的EE.5.3.4节的要求。可以通过将此属性设置为false来禁用此异常，在这种情况下，修改JNDI上下文的任何调用都将返回<b>而无需</b>进行任何更改，并且返回值的方法将返回<code>null</code> 。如果未指定，则符合规范的默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">renewThreadsWhenStoppingContext</code></td><td>
        <p>如果<code>true</code> ，当该上下文停止时，Tomcat会从用于该上下文的线程池中更新所有线程。这还要求<code>ThreadLocalLeakPreventionListener</code>被配置在<code>server.xml</code>而且那个<code>threadRenewalDelay</code>的属性<code>Executor</code> >> = 0。如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">skipMemoryLeakChecksOnJvmShutdown</code></td><td>
        <p>如果<code>true</code> ，如果该Web应用程序是作为JVM关闭的一部分而停止的，则该Web应用程序停止时，Tomcat将不会执行通常的内存泄漏检查。如果未指定，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">unloadDelay</code></td><td>
        <p>容器将等待servlet卸载的毫秒数。如果未指定，则默认值为<code>2000</code>女士。</p>
      </td></tr><tr><td><code class="attributeName">unpackWAR</code></td><td>
        <p>如果<code>false</code> ，则拥有<a href="host.html">主机</a>的<strong>unpackWARs</strong>属性将被覆盖，并且不会解压缩WAR文件。如果<code>true</code> ，拥有<a href="host.html">主机</a>的<strong>unpackWARs</strong>属性的值将确定WAR是否已解压缩。如果未指定，则默认值为<code>true</code> 。</p>
      </td></tr><tr><td><code class="attributeName">useNaming</code></td><td>
        <p>调成<code>true</code> （默认设置）让Catalina启用JNDI <code>InitialContext</code>适用于与Java2 Enterprise Edition（J2EE）平台约定兼容的Web应用程序。</p>
      </td></tr><tr><td><code class="attributeName">workDir</code></td><td>
        <p>此Context提供的临时目录的路径名，供关联的Web应用程序中的servlet临时读写使用。Web应用程序中的servlet将通过servlet上下文属性（类型为）使此目录可见<code>java.io.File</code> ）命名<code>javax.servlet.context.tempdir</code>如Servlet规范中所述。如果未指定，则在下面有合适的目录<code>$CATALINA_BASE/work</code>将会给予。</p>
      </td></tr></tbody></table>

  </div></div>


</div><h3 id="Nested_Components">嵌套组件</h3><div class="text">

  <p>您可以通过在<strong>Context</strong>元素内嵌套一个对应的元素来最多嵌套以下实用程序组件的一个实例：</p>
  <ul>
  <li><a href="cookie-processor.html"><strong>Cookie处理器</strong></a> -配置HTTP Cookie标头的解析和生成。</li>
  <li><a href="loader.html"><strong>加载程序</strong></a> -配置Web应用程序类加载程序，该加载程序将用于加载此Web应用程序的Servlet和Bean类。通常，类加载器的默认配置就足够了。</li>
  <li><a href="manager.html"><strong>管理器</strong></a> -配置会话管理器，该会话管理器将用于创建，销毁和持久化此Web应用程序的HTTP会话。通常，会话管理器的默认配置就足够了。</li>
  <li><a href="realm.html"><strong>领域</strong></a> -配置一个领域，以使其用户数据库及其相关角色仅可用于此特定的Web应用程序。如果未指定，则此Web应用程序将利用与拥有的<a href="host.html">Host</a>或<a href="engine.html">Engine</a>关联的领域。</li>
  <li><a href="resources.html"><strong>资源</strong></a> -配置将用于访问与此Web应用程序关联的静态资源的资源管理器。通常，资源管理器的默认配置就足够了。</li>
  <li><strong>WatchedResource-</strong>自动部署程序将监视Web应用程序的指定静态资源以进行更新，并在更新后重新加载Web应用程序。该元素的内容必须是字符串。</li>
  <li><a href="jar-scanner.html"><strong>JarScanner-</strong></a>配置Jar扫描仪，该扫描仪将用于扫描Web应用程序中的JAR文件和类文件目录。通常在Web应用程序启动期间使用它来标识配置文件，例如TLD或web-fragment.xml文件，这些文件必须作为Web应用程序初始化的一部分进行处理。通常，默认的Jar扫描仪配置就足够了。</li>
  </ul>

</div><h3 id="Special_Features">特殊功能</h3><div class="text">


  <div class="subsection"><h4 id="Logging">记录中</h4><div class="text">

    <p>上下文与<code>org.apache.catalina.core.ContainerBase.[enginename].[hostname].[path]</code>日志类别。请注意，方括号实际上是名称的一部分，请不要忽略它们。</p>

  </div></div>


  <div class="subsection"><h4 id="Access_Logs">访问日志</h4><div class="text">

    <p>运行Web服务器时，正常生成的输出文件之一是<em>访问日志</em> ，该<em>访问日志</em>以标准格式为服务器处理的每个请求生成一行信息。Catalina包括一个可选的<a href="valve.html">Valve</a>实现，该实现可以创建与Web服务器创建的标准格式相同的访问日志，也可以创建任意数量的自定义格式。</p>

    <p>您可以通过嵌套如下所示的<a href="valve.html">Valve</a>元素，要求Catalina为<a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a>处理的所有请求创建访问日志：</p>

<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;Valve className="org.apache.catalina.valves.AccessLogValve"
         prefix="localhost_access_log" suffix=".txt"
         pattern="common"/&gt;
  ...
&lt;/Context&gt;</code></pre></div>

    <p>有关支持的配置属性的更多信息，请参见<a href="valve.html#Access_Logging">访问记录阀</a> 。</p>

  </div></div>


  <div class="subsection"><h4 id="Automatic_Context_Configuration">自动上下文配置</h4><div class="text">

    <p>如果使用标准的<strong>Context</strong>实现，则在启动Catalina或重新加载此Web应用程序时，将自动执行以下配置步骤。启用此功能不需要特殊配置。</p>

    <ul>
    <li>如果尚未声明自己的<a href="loader.html">Loader</a>元素，则将配置标准的Web应用程序类加载器。
       </li>
    <li>如果尚未声明自己的<a href="manager.html">Manager</a>元素，则将配置标准会话管理器。</li>
    <li>如果尚未声明自己的<a href="resources.html">Resources</a>元素，则将配置标准资源管理器。</li>
    <li>列出的Web应用程序属性<code>conf/web.xml</code>将作为此Web应用程序的默认处理。这用于建立默认映射（例如<code>*.jsp</code>扩展到相应的JSP servlet），以及适用于所有Web应用程序的其他标准功能。</li>
    <li>列出的Web应用程序属性<code>/WEB-INF/tomcat-web.xml</code>将处理此Web应用程序的资源（如果存在此资源），优先于默认值。</li>
    <li>列出的Web应用程序属性<code>/WEB-INF/web.xml</code>此Web应用程序的资源将被处理（如果存在此资源）。</li>
    <li>如果您的Web应用程序具有指定的安全性约束，可能需要用户身份验证，则将配置实现您选择的登录方法的适当身份验证器。</li>
    </ul>

  </div></div>


  <div class="subsection"><h4 id="Context_Parameters">上下文参数</h4><div class="text">

    <p>您可以通过嵌套配置将使Web应用程序可以看到的命名值作为Servlet上下文初始化参数。 <code><Parameter></code>元素内的元素。例如，您可以创建一个初始化参数，如下所示：</p>
<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;Parameter name="companyName" value="My Company, Incorporated"
         override="false"/&gt;
  ...
&lt;/Context&gt;</code></pre></div>

    <p>这等效于在Web应用程序部署描述符中包含以下元素（ <code>/WEB-INF/web.xml</code> ）：</p>
<div class="codeBox"><pre><code>&lt;context-param&gt;
  &lt;param-name&gt;companyName&lt;/param-name&gt;
  &lt;param-value&gt;My Company, Incorporated&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre></div>
    <p>但<em>不需要</em>修改deployment descriptor来定制这个值。</p>

    <p>的有效属性<code><Parameter></code>元素如下：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">description</code></td><td>
        <p>此上下文初始化参数的人类可读的可选描述。</p>
      </td></tr><tr><td><strong><code class="attributeName">name</code></strong></td><td>
        <p>要创建的上下文初始化参数的名称。</p>
      </td></tr><tr><td><code class="attributeName">override</code></td><td>
        <p>设置为<code>false</code>如果你<strong>不想</strong> <code><context-param></code>对于在Web应用程序部署描述符中找到的相同参数名称，将覆盖此处指定的值。默认情况下，允许覆盖。</p>
      </td></tr><tr><td><strong><code class="attributeName">value</code></strong></td><td>
        <p>通过调用请求时将呈现给应用程序的参数值<code>ServletContext.getInitParameter()</code> 。</p>
      </td></tr></tbody></table>

  </div></div>


  <div class="subsection"><h4 id="Environment_Entries">环境条目</h4><div class="text">

    <p>您可以通过嵌套来配置命名的值，这些值将对Web应用程序作为环境条目资源可见<code><Environment></code>此元素内的条目。例如，您可以创建如下环境条目：</p>
<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;Environment name="maxExemptions" value="10"
         type="java.lang.Integer" override="false"/&gt;
  ...
&lt;/Context&gt;</code></pre></div>

    <p>这等效于在Web应用程序部署描述符中包含以下元素（ <code>/WEB-INF/web.xml</code> ）：</p>
<div class="codeBox"><pre><code>&lt;env-entry&gt;
  &lt;env-entry-name&gt;maxExemptions&lt;/env-entry-name&gt;
  &lt;env-entry-value&gt;10&lt;/env-entry-value&gt;
  &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt;
&lt;/env-entry&gt;</code></pre></div>
    <p>但<em>不需要</em>修改deployment descriptor来定制这个值。</p>

    <p>的有效属性<code><Environment></code>元素如下：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">description</code></td><td>
        <p>此环境条目的可选的，易于阅读的描述。</p>
      </td></tr><tr><td><strong><code class="attributeName">name</code></strong></td><td>
        <p>要创建的环境条目的名称，相对于<code>java:comp/env</code>上下文。</p>
      </td></tr><tr><td><code class="attributeName">override</code></td><td>
        <p>设置为<code>false</code>如果你<strong>不</strong>想要的<code><env-entry></code>在Web应用程序部署描述符中找到的相同环境条目名称，以覆盖此处指定的值。默认情况下，允许覆盖。</p>
      </td></tr><tr><td><strong><code class="attributeName">type</code></strong></td><td>
        <p>Web应用程序为此环境条目期望的标准Java类名称。必须是具有法律价值<code><env-entry-type></code>在Web应用程序部署描述符中。</p>
      </td></tr><tr><td><strong><code class="attributeName">value</code></strong></td><td>
        <p>从JNDI上下文请求时将显示给应用程序的参数值。此值必须可转换为由<code>type</code>属性。</p>
      </td></tr></tbody></table>

  </div></div>


  <div class="subsection"><h4 id="Lifecycle_Listeners">生命周期侦听器</h4><div class="text">

    <p>如果实现了需要知道何时启动或停止此<strong>Context</strong>的Java对象，则可以通过在该元素内嵌套<strong>Listener</strong>元素来声明它。您指定的类名称必须实现<code>org.apache.catalina.LifecycleListener</code>接口，并且该类必须包装在一个jar中并放在<code>$CATALINA_HOME/lib</code>目录。将会通知有关相应生命周期事件的发生。这样的侦听器的配置如下所示：</p>

<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;Listener className="com.mycompany.mypackage.MyListener" ... &gt;
  ...
&lt;/Context&gt;</code></pre></div>

    <p>请注意，侦听器可以具有可以从此元素配置的任意数量的其他属性。使用标准的属性方法命名模式，将属性名称与相应的JavaBean属性名称匹配。</p>

  </div></div>


  <div class="subsection"><h4 id="Request_Filters">请求过滤器</h4><div class="text">

    <p>您可以要求Catalina在针对周围<a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a>元素的每个传入请求中检查IP地址或主机名。将根据配置的“接受”和/或“拒绝”过滤器检查远程地址或名称，这些过滤器使用<code>java.util.regex</code>正则表达式语法。来自不接受位置的请求将被拒绝，并显示HTTP“禁止”错误。过滤器声明示例：</p>

<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;Valve className="org.apache.catalina.valves.RemoteHostValve"
         allow=".*\.mycompany\.com|www\.yourcompany\.com"/&gt;
  &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"
         deny="192\.168\.1\.\d+"/&gt;
  ...
&lt;/Context&gt;</code></pre></div>

    <p>有关支持的配置选项的更多信息，请参见<a href="valve.html#Remote_Address_Filter">远程地址过滤器</a>和<a href="valve.html#Remote_Host_Filter">远程主机过滤器</a> 。</p>

  </div></div>


  <div class="subsection"><h4 id="Resource_Definitions">资源定义</h4><div class="text">

    <p>您可以声明要为JNDI查找返回的资源的特征<code><resource-ref></code>和<code><resource-env-ref></code> Web应用程序部署描述符中的元素。您还<strong>必须</strong>将所需的资源参数定义为<code>Resource</code>元素，以配置要使用的对象工厂（如果Tomcat还不知道），以及用于配置该对象工厂的属性。</p>

    <p>例如，您可以创建如下的资源定义：</p>
<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;Resource name="jdbc/EmployeeDB" auth="Container"
            type="javax.sql.DataSource"
     description="Employees Database for HR Applications"/&gt;
  ...
&lt;/Context&gt;</code></pre></div>

    <p>这等效于在Web应用程序部署描述符中包含以下元素（ <code>/WEB-INF/web.xml</code> ）：</p>
<div class="codeBox"><pre><code>&lt;resource-ref&gt;
  &lt;description&gt;Employees Database for HR Applications&lt;/description&gt;
  &lt;res-ref-name&gt;jdbc/EmployeeDB&lt;/res-ref-name&gt;
  &lt;res-ref-type&gt;javax.sql.DataSource&lt;/res-ref-type&gt;
  &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;</code></pre></div>

    <p>但<em>不需要</em>修改deployment descriptor来定制这个值。</p>

    <p>的有效属性<code><Resource></code>元素如下：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">auth</code></td><td>
        <p>指定Web应用程序代码是通过编程方式登录到相应的资源管理器，还是指定容器是否代表该应用程序登录到资源管理器。此属性的值必须为<code>Application</code>要么<code>Container</code> 。如果Web应用程序将使用该属性是<strong>必需的</strong> <code><resource-ref></code> Web应用程序部署描述符中的元素，但如果应用程序使用<code><resource-env-ref></code>代替。</p>
      </td></tr><tr><td><code class="attributeName">closeMethod</code></td><td>
        <p>当不再需要单例资源时调用零参数方法的名称。这是为了加快清理可能会作为垃圾回收一部分而发生的资源的速度。如果<code>singleton</code>属性为假。</p>
        <p>对于<code>javax.sql.DataSource</code>和<code>javax.sql.XADataSource</code>实现的资源<code>AutoCloseable</code>例如Apache Commons DBCP 2和默认的Apache Tomcat连接池，此属性默认为<code>close</code> 。通过将属性设置为空字符串可以禁用此功能。对于所有其他资源类型，没有定义默认值，并且默认情况下不会调用close方法。</p>
      </td></tr><tr><td><code class="attributeName">description</code></td><td>
        <p>此资源的可选的，易于阅读的描述。</p>
      </td></tr><tr><td><strong><code class="attributeName">name</code></strong></td><td>
        <p>要创建的资源的名称，相对于<code>java:comp/env</code>上下文。</p>
      </td></tr><tr><td><code class="attributeName">scope</code></td><td>
        <p>指定是否可以共享通过此资源管理器获得的连接。此属性的值必须为<code>Shareable</code>要么<code>Unshareable</code> 。默认情况下，假定连接是可共享的。</p>
      </td></tr><tr><td><code class="attributeName">singleton</code></td><td>
        <p>指定此资源定义是否针对单例资源，即仅该资源的单个实例的资源。如果此属性是<code>true</code> ，对此资源的多个JNDI查找将返回相同的对象。如果此属性是<code>false</code> ，对此资源的多个JNDI查找将返回不同的对象。此属性必须是<code>true</code>对于<code>javax.sql.DataSource</code>资源以启用数据源的JMX注册。此属性的值必须为<code>true</code>要么<code>false</code> 。默认情况下，此属性为<code>true</code> 。
        </p>
      </td></tr><tr><td><strong><code class="attributeName">type</code></strong></td><td>
        <p>Web应用程序对此资源执行查找时需要的标准Java类名称。</p>
      </td></tr></tbody></table>


  </div></div>


  <div class="subsection"><h4 id="Resource_Links">资源链接</h4><div class="text">

     <p>该元素用于创建到全局JNDI资源的链接。然后，对链接名称进行JNDI查找将返回链接的全局资源。</p>

    <p>例如，您可以创建如下的资源链接：</p>
<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;ResourceLink name="linkToGlobalResource"
            global="simpleValue"
            type="java.lang.Integer"
  ...
&lt;/Context&gt;</code></pre></div>

    <p>的有效属性<code><ResourceLink></code>元素如下：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">global</code></strong></td><td>
        <p>全局JNDI上下文中链接的全局资源的名称。</p>
      </td></tr><tr><td><strong><code class="attributeName">name</code></strong></td><td>
        <p>要创建的资源链接的名称，相对于<code>java:comp/env</code>上下文。</p>
      </td></tr><tr><td><strong><code class="attributeName">type</code></strong></td><td>
        <p>Web应用程序对此资源链接执行查找时需要的标准Java类名称。</p>
      </td></tr><tr><td><code class="attributeName">factory</code></td><td>
        <p>创建这些对象的类的标准Java类名称。此类应实现<code>javax.naming.spi.ObjectFactory</code>接口。</p>
      </td></tr></tbody></table>

    <p>当属性<code>factory="org.apache.naming.factory.DataSourceLinkFactory"</code>资源链接可以与两个附加属性一起使用，以允许共享数据源与不同的凭据一起使用。当这两个附加属性与<code>javax.sql.DataSource</code>类型，不同的上下文可以使用不同的凭据共享全局数据源。在幕后，发生的是<a href="http://docs.oracle.com/javase/7/docs/api/javax/sql/DataSource.html#getConnection()"><code>getConnection()</code></a>简单地转换为通话<a href="http://docs.oracle.com/javase/7/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String, java.lang.String)"><code>getConnection(username, password)</code></a>在全局数据源上。这是使代码对所使用的架构透明的简单方法，并且能够控制全局配置中的连接（或池）。
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">username</code></td><td>
        <p><code>username</code>的价值<code>getConnection(username, password)</code>调用链接的全局数据源。
        </p>
      </td></tr><tr><td><code class="attributeName">password</code></td><td>
        <p><code>password</code>的价值<code>getConnection(username, password)</code>调用链接的全局数据源。
        </p>
      </td></tr></tbody></table>
    <p>共享数据源示例：</p>
    <p><strong>警告：</strong>仅当全局数据源支持时，此功能才有效<code>getConnection(username, password)</code>方法。
Tomcat默认使用的<a href="https://commons.apache.org/dbcp/">Apache Commons DBCP 2</a>池不支持该池。有关其Javadoc，请参见<code>BasicDataSource</code>类。
<a href="../jdbc-pool.html">Apache Tomcat JDBC池</a>确实支持它，但是默认情况下，此支持处于禁用状态，可以通过以下方式启用<code>alternateUsernameAllowed</code>属性。有关详细信息，请参见其文档。</p>
<div class="codeBox"><pre><code>&lt;GlobalNamingResources&gt;
  ...
  &lt;Resource name="sharedDataSource"
            global="sharedDataSource"
            type="javax.sql.DataSource"
            factory="org.apache.tomcat.jdbc.pool.DataSourceFactory"
            alternateUsernameAllowed="true"
            username="bar"
            password="barpass"
            ...
  ...
&lt;/GlobalNamingResources&gt;

&lt;Context path="/foo"...&gt;
  ...
  &lt;ResourceLink
            name="appDataSource"
            global="sharedDataSource"
            type="javax.sql.DataSource"
            factory="org.apache.naming.factory.DataSourceLinkFactory"
            username="foo"
            password="foopass"
  ...
&lt;/Context&gt;
&lt;Context path="/bar"...&gt;
  ...
  &lt;ResourceLink
            name="appDataSource"
            global="sharedDataSource"
            type="javax.sql.DataSource"
  ...
&lt;/Context&gt;</code></pre></div>
    <p>当要求<code>getConnection()</code>是在<code>/foo</code>上下文中，请求被翻译成<code>getConnection("foo","foopass")</code> ，而<code>/bar</code>直接通过。</p>
  </div></div>

  <div class="subsection"><h4 id="Transaction">交易</h4><div class="text">

    <p>您可以声明要为JNDI查找返回的UserTransaction的特征。 <code>java:comp/UserTransaction</code> 。您<strong>必须</strong>定义一个对象工厂类来实例化该对象以及所需的资源参数作为对象的属性。 <code>Transaction</code>元素，以及用于配置该对象工厂的属性。</p>

    <p>的有效属性<code><Transaction></code>元素如下：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">factory</code></strong></td><td>
        <p>JNDI对象工厂的类名。</p>
      </td></tr></tbody></table>

  </div></div>

</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="../comments.html">这里</a>解释<a href="../comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>