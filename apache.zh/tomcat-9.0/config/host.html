<html lang="zh-Hans" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="../images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9配置参考（9.0.21）-主机容器</title><meta name="author" content="Craig R. McClanahan"><meta name="author" content="Remy Maucherat"><meta name="author" content="Yoav Shapira"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/config/host">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script></head><body ><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="../images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="../images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9配置参考</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="../index.html">文件首页</a></li><li><a href="index.html">配置参考家</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>顶级元素</h2><ul><li><a href="server.html">服务器</a></li><li><a href="service.html">服务</a></li></ul></div><div><h2>执行者</h2><ul><li><a href="executor.html">执行者</a></li></ul></div><div><h2>连接器</h2><ul><li><a href="http.html">HTTP / 1.1</a></li><li><a href="http2.html">HTTP / 2</a></li><li><a href="ajp.html">AJP</a></li></ul></div><div><h2>货柜</h2><ul><li><a href="context.html">语境</a></li><li><a href="engine.html">发动机</a></li><li><a href="host.html">主办</a></li><li><a href="cluster.html">簇</a></li></ul></div><div><h2>嵌套组件</h2><ul><li><a href="cookie-processor.html">Cookie处理器</a></li><li><a href="credentialhandler.html">凭证处理程序</a></li><li><a href="globalresources.html">全球资源</a></li><li><a href="jar-scanner.html">JarScanner</a></li><li><a href="jar-scan-filter.html">JarScanFilter</a></li><li><a href="listeners.html">听众</a></li><li><a href="loader.html">装载机</a></li><li><a href="manager.html">经理</a></li><li><a href="realm.html">领域</a></li><li><a href="resources.html">资源资源</a></li><li><a href="sessionidgenerator.html">SessionIdGenerator</a></li><li><a href="valve.html">阀</a></li></ul></div><div><h2>集群元素</h2><ul><li><a href="cluster.html">簇</a></li><li><a href="cluster-manager.html">经理</a></li><li><a href="cluster-channel.html">渠道</a></li><li><a href="cluster-membership.html">频道/会员</a></li><li><a href="cluster-sender.html">频道/发件人</a></li><li><a href="cluster-receiver.html">频道/接收器</a></li><li><a href="cluster-interceptor.html">通道/拦截器</a></li><li><a href="cluster-valve.html">阀</a></li><li><a href="cluster-deployer.html">部署者</a></li><li><a href="cluster-listener.html">集群监听器</a></li></ul></div><div><h2>web.xml</h2><ul><li><a href="filter.html">过滤</a></li></ul></div><div><h2>其他</h2><ul><li><a href="systemprops.html">系统属性</a></li><li><a href="jaspic.html">日本宝石</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>主机容器</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Introduction">介绍</a></li><li><a href="#Attributes">属性</a><ol><li><a href="#Common_Attributes">共同属性</a></li><li><a href="#Standard_Implementation">标准实施</a></li></ol></li><li><a href="#Nested_Components">嵌套组件</a></li><li><a href="#Special_Features">特殊功能</a><ol><li><a href="#Logging">记录中</a></li><li><a href="#Access_Logs">访问日志</a></li><li><a href="#Automatic_Application_Deployment">自动应用程序部署</a></li><li><a href="#Host_Name_Aliases">主机名别名</a></li><li><a href="#Lifecycle_Listeners">生命周期侦听器</a></li><li><a href="#Request_Filters">请求过滤器</a></li><li><a href="#Single_Sign_On">单点登录</a></li><li><a href="#User_Web_Applications">用户Web应用程序</a></li><li><a href="#Custom_context.xml_and_web.xml">自定义context.xml和web.xml</a></li></ol></li></ul>
</div><h3 id="Introduction">介绍</h3><div class="text">

  <p><strong>Host</strong>元素表示一个<em>虚拟主机</em> ，它是服务器（例如“ www.mycompany.com”）的网络名称与运行Tomcat的特定服务器的关联。为了使客户端能够使用其网络名称连接到Tomcat服务器，必须在管理您所属的Internet域的<em>域名服务</em> （DNS）服务器中注册该<em>名称</em> -请与网络管理员联系以获取更多信息。</p>

  <p>在许多情况下，系统管理员希望关联多个网络名称（例如<code>www.mycompany.com</code>和<code>company.com</code> ）具有相同的虚拟主机和应用程序。这可以使用下面讨论的<a href="#Host_Name_Aliases">主机名别名</a>功能来完成。</p>

  <p>一个或多个<strong>Host</strong>元素嵌套在<a href="engine.html">Engine</a>元素内。在Host元素内，您可以为与此虚拟主机关联的Web应用程序嵌套<a href="context.html">Context</a>元素。与每个引擎关联的主机之一的名称必须与<code>defaultHost</code>该引擎的属性。</p>

  <p>客户端通常使用主机名来标识希望连接的服务器。该主机名也包含在HTTP请求标头中。Tomcat从HTTP标头中提取主机名，并查找具有匹配名称的<strong>主机</strong> 。如果找不到匹配项，则将请求路由到默认主机。默认主机的名称不必与DNS名称匹配（尽管可以），因为DNS名称与<strong>Host</strong>元素的名称不匹配的任何请求都将被路由到默认主机。</p>

    <p><em>下面的描述使用变量名$ CATALINA_BASE来引用可解决大多数相对路径的基本目录。如果尚未通过设置CATALINA_BASE目录为多个实例配置Tomcat，则$ CATALINA_BASE将设置为$ CATALINA_HOME的值，该目录已将Tomcat安装到该目录中。</em></p>

</div><h3 id="Attributes">属性</h3><div class="text">

  <div class="subsection"><h4 id="Common_Attributes">共同属性</h4><div class="text">

    <p><strong>Host的</strong>所有实现均支持以下属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">appBase</code></strong></td><td>
        <p>此虚拟主机的<em>Application Base</em>目录。这是目录的路径名，该目录可能包含要在此虚拟主机上部署的Web应用程序。您可以指定绝对路径名，也可以指定相对于<code>$CATALINA_BASE</code>目录。有关自动识别和部署Web应用程序的更多信息，请参见<a href="#Automatic_Application_Deployment">自动应用程序部署</a> 。如果未指定，则默认为<code>webapps</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">xmlBase</code></td><td>
        <p>此虚拟主机的<em>XML Base</em>目录。这是目录的路径名，其中可能包含要在此虚拟主机上部署的上下文XML描述符。您可以为此目录指定绝对路径名，也可以指定相对于该目录的路径名。 <code>$CATALINA_BASE</code>目录。有关自动识别和部署Web应用程序的更多信息，请参见<a href="#Automatic_Application_Deployment">自动应用程序部署</a> 。如果未指定默认值<code>conf/<engine_name>/<host_name></code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">createDirs</code></td><td>
        <p>如果设置为true，则Tomcat将尝试创建由属性定义的目录<code>appBase</code>和<code>xmlBase</code>在启动阶段。默认值为<code>true</code> 。如果设置为true，并且目录创建失败，将显示一条错误消息，但不会停止启动顺序。</p>
      </td></tr><tr><td><code class="attributeName">autoDeploy</code></td><td>
        <p>该标志值指示在Tomcat运行时，Tomcat是否应定期检查新的或更新的Web应用程序。如果为true，则Tomcat会定期检查<code>appBase</code>和<code>xmlBase</code>目录并部署找到的任何新的Web应用程序或上下文XML描述符。更新的Web应用程序或上下文XML描述符将触发Web应用程序的重新加载。标志的值默认为true。有关更多信息，请参见<a href="#Automatic_Application_Deployment">自动应用程序部署</a> 。</p>
      </td></tr><tr><td><code class="attributeName">backgroundProcessorDelay</code></td><td>
        <p>此值表示在此主机及其子容器（包括所有上下文）上调用backgroundProcess方法之间的延迟（以秒为单位）。如果子容器的延迟值不为负（则表示它们正在使用自己的处理线程），则不会调用它们。将此值设置为正值将导致产生线程。等待指定的时间后，线程将在此主机及其所有子容器上调用backgroundProcess方法。主机将使用后台处理来执行与实时Web应用程序部署相关的任务。如果未指定，则此属性的默认值为-1，这意味着主机将依赖其父引擎的后台处理设置。</p>
      </td></tr><tr><td><code class="attributeName">className</code></td><td>
        <p>使用的Java类名称。此类必须实现<code>org.apache.catalina.Host</code>接口。如果未指定，将使用标准值（定义如下）。</p>
      </td></tr><tr><td><code class="attributeName">deployIgnore</code></td><td>
        <p>定义路径的正则表达式<code>autoDeploy</code>和<code>deployOnStartup</code>被设置。例如，这使您可以将配置保留在版本控制系统中，而不部署恰好位于文件系统中的.svn或CVS文件夹。 <code>appBase</code> 。</p>
        <p>这个正则表达式是相对于<code>appBase</code> 。它还是<em>锚定的</em> ，这意味着将对整个文件/目录名称执行匹配。所以， <code>foo</code>仅匹配名为的文件或目录<code>foo</code>但不是<code>foo.war</code> ， <code>foobar</code> ， 要么<code>myfooapp</code> 。要与“ foo”匹配，您可以使用<code>.*foo.*</code> 。</p>
        <p>有关更多信息，请参见<a href="#Automatic_Application_Deployment">自动应用程序部署</a> 。</p>
      </td></tr><tr><td><code class="attributeName">deployOnStartup</code></td><td>
        <p>此标志值指示在Tomcat启动时是否应自动部署来自该主机的Web应用程序。标志的值默认为true。有关更多信息，请参见<a href="#Automatic_Application_Deployment">自动应用程序部署</a> 。</p>
      </td></tr><tr><td><code class="attributeName">failCtxIfServletStartFails</code></td><td>
        <p>调成<code>true</code>如果每个子上下文的启动> load-on-startup> = 0的servlet自身都失败，则启动失败。</p>
        <p>每个子上下文可以覆盖此属性。</p>
        <p>如果未指定，则默认值为<code>false</code>用来。</p>
      </td></tr><tr><td><strong><code class="attributeName">name</code></strong></td><td>
        <p>通常，此虚拟主机的网络名称（在您的<em>域名服务</em>服务器中注册）。不管用于指定主机名的大小写如何，Tomcat都会在内部将其转换为小写形式。嵌套在<a href="engine.html">引擎</a>中的主机之一的名称必须与<code>defaultHost</code>该引擎的设置。有关如何为同一虚拟主机分配多个网络名称的信息，请参阅<a href="#Host_Name_Aliases">主机名别名</a> 。如果名称采用以下形式<code>*.domainname</code> （例如<code>*.apache.org</code> ），那么它将被视为该域中任何主机的匹配项，除非找到了名称完全匹配的主机。</p>
      </td></tr><tr><td><code class="attributeName">startStopThreads</code></td><td>
        <p>该<strong>主机</strong>将用于并行启动子<a href="context.html">上下文</a>元素的线程数。如果正在使用自动部署，则将使用相同的线程池来部署新的<a href="context.html">Context</a> 。由于线程池是在服务器级别共享的，因此，如果一个以上的主机指定此设置，则仅最大值将适用于所有值，特殊值1除外。如果未指定，将使用默认值1。如果使用1个线程，则不使用<code>ExecutorService</code>当前线程将被使用。</p>
      </td></tr><tr><td><code class="attributeName">undeployOldVersions</code></td><td>
        <p>该标志确定Tomcat作为自动部署过程的一部分，是否将检查使用并行部署部署的Web应用程序的旧的，未使用的版本，如果找到，则将其删除。该标志仅在以下情况下适用<code>autoDeploy</code>是真的。如果未指定，将使用默认值false。</p>
      </td></tr></tbody></table>

  </div></div>


  <div class="subsection"><h4 id="Standard_Implementation">标准实施</h4><div class="text">

    <p><strong>Host</strong>的标准实现是<strong>org.apache.catalina.core。StandardHost</strong> 。它支持以下其他属性（除了上面列出的常见属性之外）：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">copyXML</code></td><td>
        <p>调成<code>true</code>如果要在应用程序中嵌入上下文XML描述符（位于<code>/META-INF/context.xml</code> ）复制到<code>xmlBase</code>部署应用程序时。在随后的启动中，将优先使用复制的上下文XML描述符，即使嵌入在应用程序内部的描述符是最新的，也将优先使用嵌入在应用程序内部的任何上下文XML描述符。标志的值默认为<code>false</code> 。注意<strong>deployXML</strong>是否为<code>false</code> ，此属性将无效。</p>
      </td></tr><tr><td><code class="attributeName">deployXML</code></td><td>
        <p>调成<code>false</code>如果要禁用解析嵌入在应用程序内的上下文XML描述符（位于<code>/META-INF/context.xml</code> ）。具有安全意识的环境应将此设置为<code>false</code>防止应用程序与容器的配置进行交互。然后，管理员将负责提供一个外部上下文配置文件，并将其放在<strong>xmlBase</strong>属性定义的位置。如果这个标志是<code>false</code> ，描述符位于<code>/META-INF/context.xml</code>并且在<strong>xmlBase中</strong>不存在任何描述符，那么如果描述符包含安全部署的必要配置（例如RemoteAddrValve），则该上下文将无法启动，而不应忽略该配置。标志的值默认为<code>true</code>除非默认情况下启用安全管理器<code>false</code> 。在安全管理器下运行时，可以通过授予以下权限以启用每个Web应用程序： <code>org.apache.catalina.security.DeployXmlPermission</code>到Web应用程序。默认情况下，授予Manager和Host Manager应用程序此权限，以便它们在安全管理器下运行时可以继续工作。</p>
      </td></tr><tr><td><code class="attributeName">errorReportValveClass</code></td><td>
        <p>此主机将使用的错误报告阀的Java类名称。该阀的职责是输出错误报告。设置此属性允许自定义将由Tomcat生成的错误页面的外观。此类必须实现<code>org.apache.catalina.Valve</code>接口。如果未指定，则值<code>org.apache.catalina.valves.ErrorReportValve</code>将默认使用。</p>
      </td></tr><tr><td><code class="attributeName">unpackWARs</code></td><td>
        <p>调成<code>true</code>如果您希望将Web应用程序放置在<code>appBase</code>目录作为Web应用程序归档（WAR）文件要解压到相应的磁盘目录结构中， <code>false</code>直接从WAR文件运行此类Web应用程序。有关更多信息，请参见<a href="#Automatic_Application_Deployment">自动应用程序部署</a> 。</p>
        <p>注意：如果Tomcat扩展了WAR文件，则它将添加一个文件（ <code>/META-INF/war-tracking</code> ）到解压缩的目录结构，它用于在Tomcat不运行时检测WAR文件中的更改。任何此类更改都会在Tomcat下一次启动时触发扩展目录的删除和更新WAR文件的部署。</p>
        <p>注意：运行此选项设置为<code>false</code>将会导致性能下降。为了避免显着的性能损失，应该对Web应用程序进行配置，以便不需要对Servlet 3.0+可插拔功能进行类扫描。用户可能还希望考虑<strong>ExtractingRoot</strong> <a href="resources.html">资源</a>实现。</p>
      </td></tr><tr><td><code class="attributeName">workDir</code></td><td>
        <p>应用程序为此主机使用的临时目录的路径名。每个应用程序都有其自己的子目录，这些子目录具有临时读写功能。配置上下文workDir将覆盖对host workDir配置的使用。Web应用程序中的servlet将通过servlet上下文属性（类型为）使此目录可见<code>java.io.File</code> ）命名<code>javax.servlet.context.tempdir</code>如Servlet规范中所述。如果未指定，则在下面有合适的目录<code>$CATALINA_BASE/work</code>将会给予。</p>
      </td></tr></tbody></table>

  </div></div>


</div><h3 id="Nested_Components">嵌套组件</h3><div class="text">

  <p>您可以在此<strong>Host</strong>元素内嵌套一个或多个<a href="context.html">Context</a>元素，每个<a href="context.html">Context</a>元素代表与此虚拟主机关联的不同Web应用程序。</p>

  <p>您可以通过在<strong>Host</strong>元素内嵌套相应的元素，最多嵌套以下实用程序组件的一个实例：</p>
  <ul>
  <li><a href="realm.html"><strong>领域</strong></a> -配置一个领域，该领域将允许其用户数据库及其相关角色在嵌套在此主机内的所有<a href="context.html">上下文</a>之间共享（除非被较低级别的<a href="realm.html">领域</a>配置覆盖）。</li>
  </ul>

</div><h3 id="Special_Features">特殊功能</h3><div class="text">


  <div class="subsection"><h4 id="Logging">记录中</h4><div class="text">

    <p>主机与<code>org.apache.catalina.core.ContainerBase.[engine_name].[host_name]</code>日志类别。请注意，方括号是名称的一部分，请不要忽略它们。</p>

  </div></div>


  <div class="subsection"><h4 id="Access_Logs">访问日志</h4><div class="text">

    <p>运行Web服务器时，正常生成的输出文件之一是<em>访问日志</em> ，该<em>访问日志</em>以标准格式为服务器处理的每个请求生成一行信息。Catalina包括一个可选的<a href="valve.html">Valve</a>实现，该实现可以创建与Web服务器创建的标准格式相同的访问日志，也可以创建任意数量的自定义格式。</p>

    <p>您可以通过嵌套如下所示的<a href="valve.html">Valve</a>元素，要求Catalina为<a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a>处理的所有请求创建访问日志：</p>

<div class="codeBox"><pre><code>&lt;Host name="localhost" ...&gt;
  ...
  &lt;Valve className="org.apache.catalina.valves.AccessLogValve"
         prefix="localhost_access_log" suffix=".txt"
         pattern="common"/&gt;
  ...
&lt;/Host&gt;</code></pre></div>

    <p>有关支持的配置属性的更多信息，请参见<a href="valve.html#Access_Logging">访问记录阀</a> 。</p>

  </div></div>


  <div class="subsection"><h4 id="Automatic_Application_Deployment">自动应用程序部署</h4><div class="text">

    <p>如果您使用默认设置的标准<strong>Host</strong>实现，则在Tomcat启动时会自动部署<em>appBase中的</em>应用程序或<em>configBase</em>中的上下文文件（ <code>deployOnStartup</code>属性默认为<code>true</code> ），并在Tomcat运行时检测到更改时重新加载或重新部署（视情况而定）（ <code>autoDeploy</code>属性也默认为<code>true</code> ）。</p>

    <p><code>deployOnStartup</code>和<code>autoDeploy</code>触发执行完全相同的代码，因此行为非常相似。但是，有一个关键区别。Tomcat启动时，它不知道哪些文件相同，哪些文件已更改以及哪些文件是新文件。因此，它将所有文件视为新文件。Tomcat运行时，可以区分未更改，已修改和新文件。这会导致在运行Tomcat时修改文件和停止Tomcat时修改文件的行为有所不同。</p>

    <p>使用自动部署时， <strong>主机</strong>的<em>appBase</em>和/或<em>configBase</em>中存在的相关文件（Web应用程序可能具有context.xml文件，WAR和目录）必须符合预期的<a href="context.html#Naming">命名约定</a> 。简而言之，这意味着同一Web应用程序的文件必须共享相同的<em>基本名称</em> 。</p>

    <p>自动部署过程使用以下搜索顺序来标识新的和/或修改的Web应用程序：</p>

    <ol>
      <li>在主机的<em>configBase中</em>具有context.xml文件的Web应用程序。</li>
      <li>在扫描context.xml文件期间尚未标识位于主机<em>appBase</em>中的WAR文件的Web应用程序。</li>
      <li>具有在主机<em>appBase</em>中的目录的Web应用程序，在扫描context.xml和/或WAR文件期间尚未标识。</li>
    </ol>

    <p>什么时候<code>autoDeploy</code>是<code>true</code> ，自动部署过程将监视已部署的Web应用程序的更改。根据确切的更改，将重新部署或重新加载Web应用程序。重新部署涉及创建新的Web应用程序，如果使用标准会话管理器，则不会保留用户会话。重新加载使用现有的Web应用程序，但重新解析web.xml并重新加载任何类。如果使用标准会话管理器，则用户会话将保持不变。</p>

    <p>通过将<em>WatchedResources</em>元素添加到context.xml文件中，用户可以将文件添加到自动部署过程监视的文件中以进行重新加载（即，对这些文件之一的任何更改都会触发Web应用程序的重新加载）。有关更多详细信息，请参见<a href="context.html#Nested_Components">上下文</a>文档。</p>

    <p>使用自动部署时， <code>docBase</code> XML <a href="context.html">Context</a>文件定义的内容应位于<code>appBase</code>目录。如果不是这种情况，则部署Web应用程序可能会遇到困难，或者应用程序可能会部署两次。的<code>deployIgnore</code>属性可以用来避免这种情况。</p>

    <p>请注意，如果要在server.xml中显式定义上下文，则可能应关闭自动应用程序部署或指定<code>deployIgnore</code>小心。否则，每个Web应用程序将被部署两次，这可能会导致应用程序出现问题。</p>

    <p>设置，新文件，更改的文件和已删除的文件有许多可能的组合。单独的页面描述了在许多情况下<a href="automatic-deployment.html">自动部署过程</a>的<a href="automatic-deployment.html">预期行为</a> 。</p>

  </div></div>


  <div class="subsection"><h4 id="Host_Name_Aliases">主机名别名</h4><div class="text">

    <p>在许多服务器环境中，网络管理员已经配置了多个网络名称（在<em>域名服务</em> （DNS）服务器中），这些网络名称解析为同一服务器的IP地址。通常情况下，每个这样的网络名称将被配置为在单独的<strong>主机</strong>元件<code>conf/server.xml</code> ，每个都有自己的一套Web应用程序。</p>

    <p>但是，在某些情况下，希望两个或多个网络名称应解析为运行同一组应用程序的<strong>同一</strong>虚拟主机。此方案的常见用例是公司网站，希望用户能够使用其中一个<code>www.mycompany.com</code>要么<code>company.com</code>访问完全相同的内容和应用程序。</p>

    <p>这是通过利用嵌套在<strong>Host</strong>元素内的一个或多个<strong>Alias</strong>元素来完成的。例如：</p>
<div class="codeBox"><pre><code>&lt;Host name="www.mycompany.com" ...&gt;
  ...
  &lt;Alias&gt;mycompany.com&lt;/Alias&gt;
  ...
&lt;/Host&gt;</code></pre></div>

    <p>为了使该策略生效，必须在您的DNS服务器中注册所有涉及的网络名称，以解析为运行此Catalina实例的同一台计算机。</p>

    <p>别名也可以使用通配符形式（ <code>*.domainname</code> ）允许用于<strong>主机</strong>的<strong>名称</strong>属性。</p>

  </div></div>


  <div class="subsection"><h4 id="Lifecycle_Listeners">生命周期侦听器</h4><div class="text">

    <p>如果实现了需要知道何时启动或停止此<strong>Host</strong>的Java对象，则可以通过在该元素内嵌套<strong>Listener</strong>元素来声明它。您指定的类名称必须实现<code>org.apache.catalina.LifecycleListener</code>界面，系统会通知其相应生命周期事件的发生。这样的侦听器的配置如下所示：</p>

<div class="codeBox"><pre><code>&lt;Host name="localhost" ...&gt;
  ...
  &lt;Listener className="com.mycompany.mypackage.MyListener" ... &gt;
  ...
&lt;/Host&gt;</code></pre></div>

    <p>请注意，侦听器可以具有可以从此元素配置的任意数量的其他属性。使用标准的属性方法命名模式，将属性名称与相应的JavaBean属性名称匹配。</p>

  </div></div>


  <div class="subsection"><h4 id="Request_Filters">请求过滤器</h4><div class="text">

    <p>您可以要求Catalina在针对周围<a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a>元素的每个传入请求中检查IP地址或主机名。将根据配置的“接受”和/或“拒绝”过滤器检查远程地址或名称，这些过滤器使用<code>java.util.regex</code>正则表达式语法。来自不接受位置的请求将被拒绝，并显示HTTP“禁止”错误。过滤器声明示例：</p>

<div class="codeBox"><pre><code>&lt;Host name="localhost" ...&gt;
  ...
  &lt;Valve className="org.apache.catalina.valves.RemoteHostValve"
         allow=".*\.mycompany\.com|www\.yourcompany\.com"/&gt;
  &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"
         deny="192\.168\.1\.\d+"/&gt;
  ...
&lt;/Host&gt;</code></pre></div>

  <p>有关支持的配置选项的更多信息，请参见<a href="valve.html#Remote_Address_Filter">远程地址过滤器</a>和<a href="valve.html#Remote_Host_Filter">远程主机过滤器</a> 。</p>

  </div></div>


  <div class="subsection"><h4 id="Single_Sign_On">单点登录</h4><div class="text">

    <p>在许多环境中，特别是在门户网站环境中，希望让用户面临挑战，使其只能通过部署在特定虚拟主机上的一组Web应用程序进行一次身份验证。这可以通过在此虚拟主机的Host元素内嵌套这样的元素来实现：</p>

<div class="codeBox"><pre><code>&lt;Host name="localhost" ...&gt;
  ...
  &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn"/&gt;
  ...
&lt;/Host&gt;</code></pre></div>

    <p>单一登录功能根据以下规则进行操作：</p>
    <ul>
    <li>为此虚拟主机配置的所有Web应用程序必须共享同一<a href="realm.html">Realm</a> 。实际上，这意味着您可以将Realm元素嵌套在此Host元素（或周围的<a href="engine.html">Engine</a>元素）内，但不能嵌套在所涉及的Web应用程序之一的<a href="context.html">Context</a>元素内。</li>
    <li>只要用户仅访问此虚拟主机上任何Web应用程序中不受保护的资源，它们就不会受到身份验证的挑战。</li>
    <li>一旦用户访问与该虚拟主机关联的<strong>任何</strong> Web应用程序中的受保护资源，就将要求用户使用为当前正在访问的Web应用程序定义的登录方法来验证自己的身份。</li>
    <li>一旦通过身份验证，与此用户关联的角色将被用于跨<strong>所有</strong>关联的Web应用程序进行访问控制决策，而不会挑战用户分别对每个应用程序进行身份验证。</li>
    <li>一旦用户注销一个Web应用程序（例如，如果使用基于表单的登录名，则通过使相应会话无效）， <strong>所有</strong> Web应用程序中的用户会话<strong>都</strong>将失效。随后在任何应用程序中访问受保护资源的任何尝试都将要求用户再次进行身份验证。</li>
    <li>单一登录功能利用HTTP cookie传输将每个请求与保存的用户身份相关联的令牌，因此只能在支持cookie的客户端环境中使用。</li>
    </ul>

  </div></div>


  <div class="subsection"><h4 id="User_Web_Applications">用户Web应用程序</h4><div class="text">

    <p>许多Web服务器可以自动将以波浪号（“〜”）和用户名开头的请求URI映射到目录（通常命名为<code>public_html</code> ）放在服务器上该用户的主目录中。您可以在Catalina中使用类似这样的特殊<strong>Listener</strong>元素完成相同的操作（在使用<code>/etc/passwd</code>文件以标识有效用户）：</p>

<div class="codeBox"><pre><code>&lt;Host name="localhost" ...&gt;
  ...
  &lt;Listener className="org.apache.catalina.startup.UserConfig"
            directoryName="public_html"
            userClass="org.apache.catalina.startup.PasswdUserDatabase"/&gt;
  ...
&lt;/Host&gt;</code></pre></div>

    <p>在服务器上<code>/etc/passwd</code>未使用时，您可以请求Catalina考虑在指定基本目录中找到的所有目录（例如<code>c:\Homes</code>在此示例中）就此指令而言被视为“用户主目录”：</p>

<div class="codeBox"><pre><code>&lt;Host name="localhost" ...&gt;
  ...
  &lt;Listener className="org.apache.catalina.startup.UserConfig"
            directoryName="public_html"
            homeBase="c:\Homes"
            userClass="org.apache.catalina.startup.HomesUserDatabase"/&gt;
  ...
&lt;/Host&gt;</code></pre></div>

    <p>如果已为名为的用户设置了用户主目录<code>craigmcc</code> ，则通过向网址发出请求（例如：</p>

<div class="codeBox"><pre><code>http://www.mycompany.com:8080/~craigmcc</code></pre></div>

    <p>成功使用此功能需要认识以下注意事项：</p>
    <ul>
    <li>每个用户Web应用程序都将部署具有由全局和主机级别默认上下文设置建立的特征。</li>
    <li>包含一个以上此Listener元素实例是合法的。但是，这仅在您要配置多个“ homeBase”目录的情况下才有用。</li>
    <li>执行Catalina的操作系统用户名必须对每个用户的Web应用程序目录及其所有内容具有读取权限。</li>
    </ul>

  </div></div>

  <div class="subsection"><h4 id="Custom_context.xml_and_web.xml">自定义context.xml和web.xml</h4><div class="text">
    <p>您可以覆盖在中找到的默认值<code>conf/context.xml</code>和<code>conf/web.xml</code>来自的文件<code>$CATALINA_BASE</code>每个虚拟主机。Tomcat将查找名为<code>context.xml.default</code>和<code>web.xml.default</code>在指定的目录中<code>xmlBase</code>并将文件合并到默认文件中。</p>
  </div></div>

</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="../comments.html">这里</a>解释<a href="../comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>