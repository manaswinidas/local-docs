<html lang="zh-Hans" ><head></head><body >﻿<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="../images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9配置参考（9.0.21）-Valve组件</title><meta name="author" content="Craig R. McClanahan"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/config/valve">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="../images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="../images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9配置参考</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="../index.html">文件首页</a></li><li><a href="index.html">配置参考家</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>顶级元素</h2><ul><li><a href="server.html">服务器</a></li><li><a href="service.html">服务</a></li></ul></div><div><h2>执行者</h2><ul><li><a href="executor.html">执行者</a></li></ul></div><div><h2>连接器</h2><ul><li><a href="http.html">HTTP / 1.1</a></li><li><a href="http2.html">HTTP / 2</a></li><li><a href="ajp.html">AJP</a></li></ul></div><div><h2>货柜</h2><ul><li><a href="context.html">语境</a></li><li><a href="engine.html">发动机</a></li><li><a href="host.html">主办</a></li><li><a href="cluster.html">簇</a></li></ul></div><div><h2>嵌套组件</h2><ul><li><a href="cookie-processor.html">Cookie处理器</a></li><li><a href="credentialhandler.html">凭证处理程序</a></li><li><a href="globalresources.html">全球资源</a></li><li><a href="jar-scanner.html">JarScanner</a></li><li><a href="jar-scan-filter.html">JarScanFilter</a></li><li><a href="listeners.html">听众</a></li><li><a href="loader.html">装载机</a></li><li><a href="manager.html">经理</a></li><li><a href="realm.html">领域</a></li><li><a href="resources.html">资源资源</a></li><li><a href="sessionidgenerator.html">SessionIdGenerator</a></li><li><a href="valve.html">阀</a></li></ul></div><div><h2>集群元素</h2><ul><li><a href="cluster.html">簇</a></li><li><a href="cluster-manager.html">经理</a></li><li><a href="cluster-channel.html">渠道</a></li><li><a href="cluster-membership.html">频道/会员</a></li><li><a href="cluster-sender.html">频道/发件人</a></li><li><a href="cluster-receiver.html">频道/接收器</a></li><li><a href="cluster-interceptor.html">通道/拦截器</a></li><li><a href="cluster-valve.html">阀</a></li><li><a href="cluster-deployer.html">部署者</a></li><li><a href="cluster-listener.html">集群监听器</a></li></ul></div><div><h2>web.xml</h2><ul><li><a href="filter.html">过滤</a></li></ul></div><div><h2>其他</h2><ul><li><a href="systemprops.html">系统属性</a></li><li><a href="jaspic.html">日本宝石</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>阀门组件</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Introduction">介绍</a></li><li><a href="#Access_Logging">访问记录</a><ol><li><a href="#Access_Log_Valve">检修阀</a><ol><li><a href="#Access_Log_Valve/Introduction">介绍</a></li><li><a href="#Access_Log_Valve/Attributes">属性</a></li></ol></li><li><a href="#Extended_Access_Log_Valve">延长检修阀</a><ol><li><a href="#Extended_Access_Log_Valve/Introduction">介绍</a></li><li><a href="#Extended_Access_Log_Valve/Attributes">属性</a></li></ol></li></ol></li><li><a href="#Access_Control">访问控制</a><ol><li><a href="#Remote_Address_Valve">远程地址阀</a><ol><li><a href="#Remote_Address_Valve/Introduction">介绍</a></li><li><a href="#Remote_Address_Valve/Attributes">属性</a></li><li><a href="#Remote_Address_Valve/Example_localhost">例子1</a></li><li><a href="#Remote_Address_Valve/Example_localhost_port">例子2</a></li><li><a href="#Remote_Address_Valve/Example_port_auth">例子3</a></li></ol></li><li><a href="#Remote_Host_Valve">远程主阀</a><ol><li><a href="#Remote_Host_Valve/Introduction">介绍</a></li><li><a href="#Remote_Host_Valve/Attributes">属性</a></li></ol></li><li><a href="#Remote_CIDR_Valve">远程CIDR阀</a><ol><li><a href="#Remote_CIDR_Valve/Introduction">介绍</a></li><li><a href="#Remote_CIDR_Valve/Attributes">属性</a></li><li><a href="#Example">例</a></li></ol></li></ol></li><li><a href="#Proxies_Support">代理支持</a><ol><li><a href="#Load_Balancer_Draining_Valve">负载平衡器排水阀</a><ol><li><a href="#Load_Balancer_Draining_Valve/Introduction">介绍</a></li><li><a href="#Load_Balancer_Draining_Valve/Attributes">属性</a></li></ol></li><li><a href="#Remote_IP_Valve">远程IP阀</a><ol><li><a href="#Remote_IP_Valve/Introduction">介绍</a></li><li><a href="#Remote_IP_Valve/Attributes">属性</a></li></ol></li><li><a href="#SSL_Valve">SSL阀</a><ol><li><a href="#SSL_Valve/Introduction">介绍</a></li><li><a href="#SSL_Valve/Attributes">属性</a></li></ol></li></ol></li><li><a href="#Single_Sign_On_Valve">单点登录阀</a><ol><li><a href="#Single_Sign_On_Valve/Introduction">介绍</a></li><li><a href="#Single_Sign_On_Valve/Attributes">属性</a></li></ol></li><li><a href="#Authentication">认证方式</a><ol><li><a href="#Basic_Authenticator_Valve">基本认证阀</a><ol><li><a href="#Basic_Authenticator_Valve/Introduction">介绍</a></li><li><a href="#Basic_Authenticator_Valve/Attributes">属性</a></li></ol></li><li><a href="#Digest_Authenticator_Valve">消化认证阀</a><ol><li><a href="#Digest_Authenticator_Valve/Introduction">介绍</a></li><li><a href="#Digest_Authenticator_Valve/Attributes">属性</a></li></ol></li><li><a href="#Form_Authenticator_Valve">形状认证阀</a><ol><li><a href="#Form_Authenticator_Valve/Introduction">介绍</a></li><li><a href="#Form_Authenticator_Valve/Attributes">属性</a></li></ol></li><li><a href="#SSL_Authenticator_Valve">SSL认证阀</a><ol><li><a href="#SSL_Authenticator_Valve/Introduction">介绍</a></li><li><a href="#SSL_Authenticator_Valve/Attributes">属性</a></li></ol></li><li><a href="#SPNEGO_Valve">SPNEGO阀门</a><ol><li><a href="#SPNEGO_Valve/Introduction">介绍</a></li><li><a href="#SPNEGO_Valve/Attributes">属性</a></li></ol></li></ol></li><li><a href="#Error_Report_Valve">错误报告阀</a><ol><li><a href="#Error_Report_Valve/Introduction">介绍</a></li><li><a href="#Error_Report_Valve/Attributes">属性</a></li></ol></li><li><a href="#Crawler_Session_Manager_Valve">履带会话管理器阀门</a><ol><li><a href="#Crawler_Session_Manager_Valve/Introduction">介绍</a></li><li><a href="#Crawler_Session_Manager_Valve/Attributes">属性</a></li></ol></li><li><a href="#Stuck_Thread_Detection_Valve">卡线检测阀</a><ol><li><a href="#Stuck_Thread_Detection_Valve/Introduction">介绍</a></li><li><a href="#Stuck_Thread_Detection_Valve/Attributes">属性</a></li></ol></li><li><a href="#Semaphore_Valve">信号灯阀</a><ol><li><a href="#Semaphore_Valve/Introduction">介绍</a></li><li><a href="#Semaphore_Valve/Attributes">属性</a></li></ol></li></ul>
</div><h3 id="Introduction">介绍</h3><div class="text">

  <p><strong>Valve</strong>元素表示将插入到相关Catalina容器（ <a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a> ）的请求处理管道中的组件。各个阀门具有独特的处理能力，下面分别进行介绍。</p>

    <p><em>下面的描述使用变量名$ CATALINA_BASE来引用可解决大多数相对路径的基本目录。如果尚未通过设置CATALINA_BASE目录为多个实例配置Tomcat，则$ CATALINA_BASE将设置为$ CATALINA_HOME的值，该目录已将Tomcat安装到该目录中。</em></p>

</div><h3 id="Access_Logging">访问记录</h3><div class="text">

<p>访问日志记录由实现<strong>org.apache.catalina的阀门执行<strong>。AccessLog</strong>界面。</strong></p><strong>

<div class="subsection"><h4 id="Access_Log_Valve">检修阀</h4><div class="text">

  <div class="subsection"><h4 id="Access_Log_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>访问日志阀</strong>以与标准Web服务器创建的格式相同的格式创建日志文件。以后可以使用标准的日志分析工具来分析这些日志，以跟踪页面命中数，用户会话活动等。这个<code>Valve</code>使用独立的逻辑来写入其日志文件，该日志文件可以在每天午夜自动翻转。（访问日志记录的基本要求是以低开销处理大量连续的数据流。这个<code>Valve</code>不使用Apache Commons Logging，从而避免了额外的开销和潜在的复杂配置。</p>

    <p>这个<code>Valve</code>可能与任何Catalina容器（ <code>Context</code> ， <code>Host</code> ， 要么<code>Engine</code> ），并将记录该容器处理的所有请求。</p>

    <p>某些请求可能在被传递到容器之前由Tomcat处理。这些包括从/ foo到/ foo /的重定向以及无效请求的拒绝。Tomcat可以在其中识别<code>Context</code>将会处理请求的请求/响应将记录在<code>AccessLog</code> （s）个相关<code>Context</code> ， <code>Host</code>和<code>Engine</code> 。Tomcat无法识别的地方<code>Context</code>会处理请求的内容，例如，在URL无效的情况下，Tomcat将在<code>Engine</code> ，然后是默认值<code>Host</code>为了<code>Engine</code>最后是ROOT（或默认值） <code>Context</code>为默认<code>Host</code>为<code>AccessLog</code>实施。Tomcat将使用第一个<code>AccessLog</code>发现实现记录了那些在传递到容器之前被拒绝的请求。</p>

    <p>输出文件将放置在由<code>directory</code>属性。文件名由配置文件的串联组成<code>prefix</code> ，时间戳记和<code>suffix</code> 。可以使用以下命令设置文件名中时间戳的格式<code>fileDateFormat</code>属性。如果通过设置关闭文件旋转，则此时间戳将被省略<code>rotatable</code>至<code>false</code> 。</p>

    <p><strong>警告：</strong>如果使用了多个AccessLogValve实例，则应将它们配置为使用不同的输出文件。</p>

    <p>如果使用sendfile，则将在一个单独的线程中异步写入响应字节，并且访问日志阀将不知道实际写入了多少字节。在这种情况下，传递给sendfile线程进行写入的字节数将记录在访问日志阀中。
    </p>
  </div></div>

  <div class="subsection"><h4 id="Access_Log_Valve/Attributes">属性</h4><div class="text">

    <p><strong>访问日志阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">buffered</code></td><td>
        <p>用于确定是否将缓冲日志记录的标志。如果设置为<code>false</code> ，然后将在每个请求之后写入访问日志。默认值： <code>true</code>
        </p>
      </td></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。AccessLogValve</strong>使用默认的访问日志阀。</p>
      </td></tr><tr><td><code class="attributeName">condition</code></td><td>
        <p>与...相同<code>conditionUnless</code> 。提供此属性是为了向后兼容。
        </p>
      </td></tr><tr><td><code class="attributeName">conditionIf</code></td><td>
        <p>打开条件日志记录。如果设置，则仅在以下情况下记录请求<code>ServletRequest.getAttribute()</code>不为空。例如，如果此值设置为<code>important</code> ，则只有在以下情况下才会记录特定请求<code>ServletRequest.getAttribute("important") != null</code> 。使用过滤器是在许多不同请求上设置/取消ServletRequest中的属性的简便方法。
        </p>
      </td></tr><tr><td><code class="attributeName">conditionUnless</code></td><td>
        <p>打开条件日志记录。如果设置，则仅在以下情况下记录请求<code>ServletRequest.getAttribute()</code>一片空白。例如，如果此值设置为<code>junk</code> ，则只有在以下情况下才会记录特定请求<code>ServletRequest.getAttribute("junk") == null</code> 。使用过滤器是在许多不同请求上设置/取消ServletRequest中的属性的简便方法。
        </p>
      </td></tr><tr><td><code class="attributeName">directory</code></td><td>
        <p>该阀创建的日志文件将放置在目录的绝对或相对路径名。如果指定了相对路径，则将其解释为相对于$ CATALINA_BASE。如果未指定目录属性，则默认值为“ logs”（相对于$ CATALINA_BASE）。</p>
      </td></tr><tr><td><code class="attributeName">encoding</code></td><td>
        <p>用于写入日志文件的字符集。空字符串表示使用系统默认字符集。默认值：使用系统默认字符集。
        </p>
      </td></tr><tr><td><code class="attributeName">fileDateFormat</code></td><td>
        <p>在访问日志文件名中允许自定义时间戳。只要格式化的时间戳更改，文件就会旋转。默认值为<code>.yyyy-MM-dd</code> 。如果您希望每小时旋转一次，则将此值设置为<code>.yyyy-MM-dd.HH</code> 。日期格式将始终使用语言环境进行本地化<code>en_US</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">ipv6Canonical</code></td><td>
        <p>用于确定是否应按照RFC 5952定义的规范表示格式表示IPv6地址的标志。如果设置为<code>true</code> ，则IPv6地址将以规范格式（例如<code>2001:db8::1:0:0:1</code> ， <code>::1</code> ），否则将以完整形式表示（例如<code>2001:db8:0:0:1:0:0:1</code> ， <code>0:0:0:0:0:0:0:1</code> ）。默认值： <code>false</code>
        </p>
      </td></tr><tr><td><code class="attributeName">locale</code></td><td>
        <p>用于格式化访问日志行中时间戳的语言环境。使用显式SimpleDateFormat模式配置的任何时间戳（ <code>%{xxx}t</code> ）的格式设置为该语言环境。默认情况下，使用Java进程的默认语言环境。不支持在AccessLogValve初始化后切换语言环境。使用通用日志格式的任何时间戳记（ <code>CLF</code> ）始终在语言环境中格式化<code>en_US</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">maxDays</code></td><td>
        <p>轮流访问日志的最大保留天数将被保留，然后再删除。如果未指定，则默认值为<code>-1</code>将被使用，这意味着从不删除旧文件。</p>
      </td></tr><tr><td><code class="attributeName">maxLogMessageBufferSize</code></td><td>
        <p>日志消息缓冲区通常被回收并重新使用。为防止过多的内存使用，如果缓冲区增长到超过此大小，它将被丢弃。默认是<code>256</code>字符。应将其设置为大于典型的访问日志消息大小。</p>
      </td></tr><tr><td><code class="attributeName">pattern</code></td><td>
        <p>格式布局，用于标识要记录的请求和响应中的各个信息字段，或单词<code>common</code>要么<code>combined</code>选择标准格式。有关配置此属性的更多信息，请参见下文。</p>
      </td></tr><tr><td><code class="attributeName">prefix</code></td><td>
        <p>在每个日志文件名的开头添加前缀。如果未指定，则默认值为“ access_log”。</p>
      </td></tr><tr><td><code class="attributeName">renameOnRotate</code></td><td>
        <p>默认情况下，对于可旋转日志，活动访问日志文件名将包含当前时间戳<code>fileDateFormat</code> 。在旋转期间，将关闭文件，并创建并使用名称中带有下一个时间戳的新文件。设定时<code>renameOnRotate</code>至<code>true</code> ，时间戳不再是活动日志文件名的一部分。仅在旋转期间，文件才关闭，然后重命名为包括时间戳。这类似于大多数日志框架在进行基于时间的轮换时的行为。默认值： <code>false</code>
        </p>
      </td></tr><tr><td><code class="attributeName">requestAttributesEnabled</code></td><td>
        <p>调成<code>true</code>检查是否存在用于覆盖远程地址，远程主机，服务器端口和协议的请求返回值的请求属性（通常由RemoteIpValve等设置）。如果未设置属性，或者此属性设置为<code>false</code>然后将使用请求中的值。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">resolveHosts</code></td><td>
        <p>不再支持此属性。使用连接器属性<code>enableLookups</code>代替。</p>
        <p>如果你有<code>enableLookups</code>在连接器上设置为<code>true</code>并想忽略它，在值中使用<b>％a</b>而不是<b>％h</b> <code>pattern</code> 。</p>
      </td></tr><tr><td><code class="attributeName">rotatable</code></td><td>
        <p>用于确定是否应该发生日志轮换的标志。如果设置为<code>false</code> ，则此文件永远不会旋转，并且<code>fileDateFormat</code>被忽略。默认值： <code>true</code>
        </p>
      </td></tr><tr><td><code class="attributeName">suffix</code></td><td>
        <p>后缀添加到每个日志文件名称的末尾。如果未指定，则默认值为“”（长度为零的字符串），表示将不添加后缀。</p>
      </td></tr></tbody></table>

    <p>的值<code>pattern</code>属性由文字文本字符串和以“％”字符为前缀的模式标识符组成，以替换为来自当前请求和响应的相应变量值。支持以下模式代码：</p>
    <ul>
    <li><b>％</b> a-远程IP地址</li>
    <li><b>％A-</b>本地IP地址</li>
    <li><b>％b-</b>发送的字节，不包括HTTP标头，如果为零则为'-'</li>
    <li><b>％B-</b>发送的字节，不包括HTTP标头</li>
    <li><b>％h-</b>远程主机名（如果是，则为IP地址<code>enableLookups</code> （连接器为假）</li>
    <li><b>％H-</b>请求协议</li>
    <li><b>％l-</b>来自identd的远程逻辑用户名（总是返回“-”）</li>
    <li><b>％m-</b>请求方法（GET，POST等）</li>
    <li><b>％p-</b>接收此请求的本地端口。也可以看看<code>%{xxx}p</code>下面。</li>
    <li><b>％q-</b>查询字符串（以'？开头'（如果存在）</li>
    <li><b>％r-</b>请求的第一行（方法和请求URI）</li>
    <li><b>％s-</b>响应的HTTP状态代码</li>
    <li><b>％S-</b>用户会话ID</li>
    <li><b>％t-</b>日期和时间，以通用日志格式</li>
    <li><b>％u-</b>已验证（如果有）的远程用户，否则为'-'</li>
    <li><b>％U-</b>请求的URL路径</li>
    <li><b>％v-</b>本地服务器名称</li>
    <li><b>％D-</b>以毫秒为单位处理请求所花费的时间。注意：在httpd中，％D是微秒。从Tomcat 10开始，行为将与httpd对齐。</li>
    <li><b>％T-</b>处理请求所花费的时间，以秒为单位。注意：此值具有毫秒分辨率，而在httpd中具有第二分辨率。行为将与Tomcat 10及更高版本中的httpd保持一致。</li>
    <li><b>％F-</b>提交响应所花费的时间（以毫秒为单位）</li>
    <li><b>％I-</b>当前请求线程名称（以后可以与堆栈跟踪进行比较）</li>
    <li><b>％X-</b>响应完成时的连接状态：<ul>
      <li><code>X</code> =在响应完成之前连接已中止。</li>
      <li><code>+</code> =发送响应后，连接可以保持活动状态。</li>
      <li><code>-</code> =发送响应后，连接将关闭。</li>
      </ul>
    </li>
    </ul>

    <p>还支持写入信息的传入或传出标题，cookie，会话或请求属性以及特殊的时间戳格式。它是根据<a href="https://httpd.apache.org/">Apache HTTP Server</a>日志配置语法建模的。每个都可以多次使用，不同<code>xxx</code>按键：</p>
    <ul>
    <li><b><code>%{xxx}i</code></b>用名称写入传入标头的值<code>xxx</code></li>
    <li><b><code>%{xxx}o</code></b>用名称写输出头的值<code>xxx</code></li>
    <li><b><code>%{xxx}c</code></b>用名称写Cookie的值<code>xxx</code></li>
    <li><b><code>%{xxx}r</code></b>用名称写入ServletRequest属性的值<code>xxx</code></li>
    <li><b><code>%{xxx}s</code></b>用名称写入HttpSession属性的值<code>xxx</code></li>
    <li><b><code>%{xxx}p</code></b>写入本地（服务器）端口（ <code>xxx==local</code> ）或远程（客户端）端口（ <code>xxx=remote</code> ）</li>
    <li><b><code>%{xxx}t</code></b>使用增强的SimpleDateFormat模式格式化的请求末尾写入时间戳<code>xxx</code></li>
    </ul>

    <p>允许使用SimpleDateFormat支持的所有格式<code>%{xxx}t</code> 。另外，添加了以下扩展名：</p>
    <ul>
    <li><b><code>sec</code></b> -自纪元以来的秒数</li>
    <li><b><code>msec</code></b> -自纪元以来的毫秒数</li>
    <li><b><code>msec_frac</code></b> -毫秒分数</li>
    </ul>
    <p>这些格式不能与同一格式标记中的SimpleDateFormat格式混合。</p>

    <p>此外，可以定义是记录请求开始时间还是响应结束时间的时间戳：</p>
    <ul>
    <li><b><code>begin</code></b>或前缀<b><code>begin:</code></b>选择请求开始时间</li>
    <li><b><code>end</code></b>或前缀<b><code>end:</code></b>选择响应完成时间</li>
    </ul>
    <p>通过添加多个<code>%{xxx}t</code>标记，也可以同时记录两个时间戳。</p>

    <p>速记模式<code>pattern="common"</code>对应于<strong>'％h％l％u％t“％r”％s％b'</strong>定义的通用日志格式。</p>

    <p>速记模式<code>pattern="combined"</code>附加的值<code>Referer</code>和<code>User-Agent</code>标头，每个标头都用双引号引起来<code>common</code>图案。</p>

    <p>当Tomcat在反向代理后面运行时，访问日志阀记录的客户端信息可能代表反向代理，浏览器或两者的某种组合，具体取决于Tomcat和反向代理的配置。有关Tomcat的配置选项，请参阅<a href="#Proxies_Support">代理支持</a>和<a href="../proxy-howto.html">代理方法</a> 。有关使用mod_jk的反向代理，请参见<a href="https://tomcat.apache.org/connectors-doc/generic_howto/proxy.html">通用代理</a>文档。对于其他反向代理，请查阅其文档。</p>
  </div></div>

</div></div>


<div class="subsection"><h4 id="Extended_Access_Log_Valve">延长检修阀</h4><div class="text">

  <div class="subsection"><h4 id="Extended_Access_Log_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>扩展访问日志阀</strong>扩展了<a href="#Access_Log_Valve">访问日志阀</a>类，因此使用相同的自包含日志逻辑。这意味着它实现了许多相同的文件处理属性。与标准的主要区别<code>AccessLogValve</code>就是它<code>ExtendedAccessLogValve</code>创建符合W3C定义的<a href="https://www.w3.org/TR/WD-logfile.html">扩展日志文件格式</a>工作草案的<a href="https://www.w3.org/TR/WD-logfile.html">日志文件</a> 。</p>

  </div></div>

  <div class="subsection"><h4 id="Extended_Access_Log_Valve/Attributes">属性</h4><div class="text">

    <p><strong>扩展访问日志阀</strong>支持标准<a href="#Access_Log_Valve">访问日志阀的</a>所有配置属性<a href="#Access_Log_Valve">。</a> 仅用于的值<code>className</code>和<code>pattern</code>不同。</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。ExtendedAccessLogValve</strong>使用扩展访问日志阀。</p>
      </td></tr><tr><td><code class="attributeName">pattern</code></td><td>
        <p>格式化布局，用于标识要记录的请求和响应中的各个信息字段。有关配置此属性的更多信息，请参见下文。</p>
      </td></tr></tbody></table>

    <p>的值<code>pattern</code>属性由格式标记组成。一些令牌需要附加前缀。可能的前缀是<code>c</code>对于“客户”， <code>s</code>对于“服务器”， <code>cs</code>对于“客户端到服务器”， <code>sc</code>用于“服务器到客户端”或<code>x</code>用于“特定于应用程序”。此外，一些令牌由其他选择器完成。有关格式的更多信息，请参见<a href="https://www.w3.org/TR/WD-logfile.html">W3C规范</a> 。</p>

    <p>支持以下格式标记：</p>
    <ul>
    <li><b>字节</b> -发送的字节，不包括HTTP标头；如果为零，则为“-”</li>
    <li><b>c-dns-</b>远程主机名（或IP地址，如果<code>enableLookups</code> （连接器为假）</li>
    <li><b>c-ip-</b>远程IP地址</li>
    <li><b>CS方法</b> -请求方法（GET，POST等）</li>
    <li><b>cs-uri-</b>请求URI</li>
    <li><b>cs-uri-</b> query-查询字符串（以'？开头'（如果存在）</li>
    <li><b>cs-uri-stem-</b>请求的URL路径</li>
    <li><b>date</b> -GMT的yyyy-mm-dd格式的日期</li>
    <li><b>s-dns-</b>本地主机名</li>
    <li><b>s-ip-</b>本地IP地址</li>
    <li><b>sc-status-</b>响应的HTTP状态代码</li>
    <li><b>时间</b> -GMT以HH：mm：ss格式处理请求的时间</li>
    <li><b>花费的时间-</b>服务请求<b>所花费的</b>时间（以秒为单位的浮点数）</li>
    <li><b>x-threadname-</b>当前请求线程名称（以后可以与stacktraces比较）</li>
    </ul>

    <p>对于任何<code>x-H(XXX)</code>从HttpServletRequest对象将调用以下方法：</p>
    <ul>
    <li><b><code>x-H(authType)</code></b> ：getAuthType</li>
    <li><b><code>x-H(characterEncoding)</code></b> ：getCharacterEncoding</li>
    <li><b><code>x-H(contentLength)</code></b> ：getContentLength</li>
    <li><b><code>x-H(locale)</code></b> ：getLocale</li>
    <li><b><code>x-H(protocol)</code></b> ：getProtocol</li>
    <li><b><code>x-H(remoteUser)</code></b> ：getRemoteUser</li>
    <li><b><code>x-H(requestedSessionId)</code></b> ：getRequestedSessionId</li>
    <li><b><code>x-H(requestedSessionIdFromCookie)</code></b> ：isRequestedSessionIdFromCookie</li>
    <li><b><code>x-H(requestedSessionIdValid)</code></b> ：isRequestedSessionIdValid</li>
    <li><b><code>x-H(scheme)</code></b> ：getScheme</li>
    <li><b><code>x-H(secure)</code></b> ：isSecure</li>
    </ul>

    <p>还支持编写有关标题cookie，上下文，请求或会话属性和请求参数的信息。
    </p>
    <ul>
    <li><b><code>cs(XXX)</code></b>用于名称为XXX的传入请求标头</li>
    <li><b><code>sc(XXX)</code></b>用于名称为XXX的传出响应标头</li>
    <li><b><code>x-A(XXX)</code></b>名为XXX的servlet上下文属性</li>
    <li><b><code>x-C(XXX)</code></b>对于第一个名称为XXX的Cookie</li>
    <li><b><code>x-O(XXX)</code></b>用于所有名称为XXX的外发响应标头的串联</li>
    <li><b><code>x-P(XXX)</code></b>用于使用名称XXX编码的URL（使用UTF-8）请求参数</li>
    <li><b><code>x-R(XXX)</code></b>用于名称为XXX的请求属性</li>
    <li><b><code>x-S(XXX)</code></b>用于名称为XXX的会话属性</li>
    </ul>

  </div></div>

</div></div>

</strong></div><h3 id="Access_Control"><strong>访问控制</strong></h3><div class="text"><strong>


<div class="subsection"><h4 id="Remote_Address_Valve">远程地址阀</h4><div class="text">

  <div class="subsection"><h4 id="Remote_Address_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>远程地址阀</strong>允许您将提交此请求的客户端的IP地址与一个或多个<em>正则表达式进行比较</em> ，并允许请求继续或拒绝处理来自此客户端的请求。远程地址阀可以与任何Catalina容器（ <a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a> ）相关联，并且必须接受对该容器提出的任何请求进行处理，然后才能继续传递。</p>

    <p><em>正则表达式</em>的语法与“标准”通配符匹配的语法不同。Tomcat使用<code>java.util.regex</code>包。请查询Java文档以获取所支持表达式的详细信息。</p>

    <p>可以选择在服务器连接器端口后面附加一个分号（“;”），以允许每个连接器使用不同的表达式。</p>

    <p>可以将拒绝请求时的行为更改为不拒绝，而是将其设置为无效<code>authentication</code>标头。与context属性结合使用时很有用<code>preemptiveAuthentication="true"</code> 。</p>

    <p><strong>注意：</strong>将此阀门与IPv6地址一起使用时， <strong>请注意</strong> 。该阀正在处理的IP地址的格式取决于用于获取它的API。如果该地址是使用Inet6Address类从Java套接字获取的，则其格式为<code>x:x:x:x:x:x:x:x</code> 。也就是说，本地主机的IP地址将是<code>0:0:0:0:0:0:0:1</code>而不是更广泛地使用<code>::1</code> 。请查阅您的访问日志以获取实际值。</p>

    <p>另请参阅： <a href="#Remote_Host_Valve">远程主阀</a> ， <a href="#Remote_IP_Valve">远程IP阀</a> 。</p>
  </div></div>

  <div class="subsection"><h4 id="Remote_Address_Valve/Attributes">属性</h4><div class="text">

    <p><strong>远程地址阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。RemoteAddrValve</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">allow</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ）与远程客户端的IP地址进行比较。如果指定了此属性，则远程地址必须与该请求匹配。如果未指定此属性，则所有请求都将被接受，除非远程地址与<code>deny</code>图案。</p>
      </td></tr><tr><td><code class="attributeName">deny</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ）与远程客户端的IP地址进行比较。如果指定了此属性，则远程地址必须不匹配才能接受此请求。如果未指定此属性，则请求接受仅由<code>allow</code>属性。</p>
      </td></tr><tr><td><code class="attributeName">denyStatus</code></td><td>
        <p>拒绝被拒绝的请求时使用的HTTP响应状态代码。默认值为<code>403</code> 。例如，可以将其设置为<code>404</code> 。</p>
      </td></tr><tr><td><code class="attributeName">addConnectorPort</code></td><td>
        <p>将服务器连接器端口附加到用分号（“;”）分隔的客户端IP地址。如果设置为<code>true</code> ，使用<code>allow</code>和<code>deny</code>与比较<code>ADDRESS;PORT</code>哪里<code>ADDRESS</code>是客户端IP地址， <code>PORT</code>是接收请求的Tomcat连接器端口。默认值为<code>false</code> 。</p>
      </td></tr><tr><td><code class="attributeName">invalidAuthenticationWhenDeny</code></td><td>
        <p>当请求应被拒绝时，请勿拒绝，而应将其设置为无效<code>authentication</code>标头。这仅在上下文具有属性时才有效<code>preemptiveAuthentication="true"</code>组。一个已经存在的<code>authentication</code>标头将不会被覆盖。实际上，即使应用程序未配置安全约束，这也将触发身份验证而不是拒绝。</p>
        <p>这可以与<code>addConnectorPort</code>根据客户端和用于访问应用程序的连接器触发身份验证。</p>
      </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="Remote_Address_Valve/Example_localhost">例子1</h4><div class="text">
    <p>要仅允许从本地主机连接的客户端访问，请执行以下操作：</p>
    <div class="codeBox"><pre><code>&lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"
   allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1"/&gt;</code></pre></div>
  </div></div>

  <div class="subsection"><h4 id="Remote_Address_Valve/Example_localhost_port">例子2</h4><div class="text">
    <p>要允许不受限制地访问从本地主机连接的客户端，但仅允许所有其他客户端访问端口8443，请执行以下操作：</p>
    <div class="codeBox"><pre><code>&lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"
   addConnectorPort="true"
   allow="127\.\d+\.\d+\.\d+;\d*|::1;\d*|0:0:0:0:0:0:0:1;\d*|.*;8443"/&gt;</code></pre></div>
  </div></div>

  <div class="subsection"><h4 id="Remote_Address_Valve/Example_port_auth">例子3</h4><div class="text">
    <p>要允许不受限制地访问端口8009，但如果在另一个端口上访问应用程序，则触发基本身份验证：</p>
<div class="codeBox"><pre><code>&lt;Context&gt;
  ...
  &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"
         addConnectorPort="true"
         invalidAuthenticationWhenDeny="true"
         allow=".*;8009"/&gt;
  &lt;Valve className="org.apache.catalina.authenticator.BasicAuthenticator" /&gt;
  ...
&lt;/Context&gt;</code></pre></div>
  </div></div>

</div></div>


<div class="subsection"><h4 id="Remote_Host_Valve">远程主阀</h4><div class="text">

  <div class="subsection"><h4 id="Remote_Host_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>Remote Host Valve</strong>允许您将提交此请求的客户端的主机名与一个或多个<em>正则表达式进行比较</em> ，并允许请求继续或拒绝处理来自此客户端的请求。远程主机Valve可以与任何Catalina容器（ <a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a> ） <a href="context.html">关联</a> ，并且必须接受对此容器进行处理的任何请求，然后才能继续进行传递。</p>

    <p><em>正则表达式</em>的语法与“标准”通配符匹配的语法不同。Tomcat使用<code>java.util.regex</code>包。请查询Java文档以获取所支持表达式的详细信息。</p>

    <p>可以选择在服务器连接器端口后面附加一个分号（“;”），以允许每个连接器使用不同的表达式。</p>

    <p>可以将拒绝请求时的行为更改为不拒绝，而是将其设置为无效<code>authentication</code>标头。与context属性结合使用时很有用<code>preemptiveAuthentication="true"</code> 。</p>

    <p><strong>注意：</strong>此阀处理方法返回的值<code>ServletRequest.getRemoteHost()</code> 。要允许该方法返回正确的主机名，必须在<strong>连接器</strong>上启用“ DNS查找”功能。</p>

    <p>另请参阅： <a href="#Remote_Address_Valve">远程地址阀</a> ， <a href="http.html">HTTP连接器</a>配置。</p>
  </div></div>

  <div class="subsection"><h4 id="Remote_Host_Valve/Attributes">属性</h4><div class="text">

    <p><strong>远程主机阀门</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。RemoteHostValve</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">allow</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ），比较远程客户端的主机名。如果指定了此属性，则远程主机名必须与该请求匹配。如果未指定此属性，则所有请求都将被接受，除非远程主机名与<code>deny</code>图案。</p>
      </td></tr><tr><td><code class="attributeName">deny</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ），比较远程客户端的主机名。如果指定了此属性，则远程主机名必须与要接受的请求不匹配。如果未指定此属性，则请求接受仅由<code>allow</code>属性。</p>
      </td></tr><tr><td><code class="attributeName">denyStatus</code></td><td>
        <p>拒绝被拒绝的请求时使用的HTTP响应状态代码。默认值为<code>403</code> 。例如，可以将其设置为<code>404</code> 。</p>
      </td></tr><tr><td><code class="attributeName">addConnectorPort</code></td><td>
        <p>将服务器连接器端口附加到客户端主机名，并用分号（“;”）分隔。如果设置为<code>true</code> ，使用<code>allow</code>和<code>deny</code>与比较<code>HOSTNAME;PORT</code>哪里<code>HOSTNAME</code>是客户端主机名， <code>PORT</code>是接收请求的Tomcat连接器端口。默认值为<code>false</code> 。</p>
      </td></tr><tr><td><code class="attributeName">invalidAuthenticationWhenDeny</code></td><td>
        <p>当请求应被拒绝时，请勿拒绝，而应将其设置为无效<code>authentication</code>标头。这仅在上下文具有属性时才有效<code>preemptiveAuthentication="true"</code>组。一个已经存在的<code>authentication</code>标头将不会被覆盖。实际上，即使应用程序未配置安全约束，这也将触发身份验证而不是拒绝。</p>
        <p>这可以与<code>addConnectorPort</code>根据客户端和用于访问应用程序的连接器触发身份验证。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>

<div class="subsection"><h4 id="Remote_CIDR_Valve">远程CIDR阀</h4><div class="text">

  <div class="subsection"><h4 id="Remote_CIDR_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>远程CIDR阀</strong>允许您将提交此请求的客户端的IP地址与遵循CIDR表示法的一个或多个网络掩码进行比较，并允许请求继续或拒绝处理来自此客户端的请求。完全支持IPv4和IPv6。远程CIDR阀可以与任何Catalina容器（ <a href="engine.html">Engine</a> ， <a href="host.html">Host</a>或<a href="context.html">Context</a> ） <a href="context.html">关联</a> ，并且必须接受对此容器进行处理的任何请求，然后才能继续进行。
    </p>

    <p>这个阀门模仿阿帕奇的<code>Order</code> ， <code>Allow from</code>和<code>Deny from</code>指令，但有以下限制：</p>

    <ul>
      <li><code>Order</code>一直会<code>allow, deny</code> ;</li>
      <li>不支持网络掩码的点分四元符号（即，您不能编写<code>192.168.1.0/255.255.255.0</code> ，你必须写<code>192.168.1.0/24</code> ;</li>
      <li>捷径，例如<code>10.10.</code> ，相当于<code>10.10.0.0/16</code> ，不受支持；</li>
      <li>就像阀门名称所说的，这是仅CIDR的阀门，因此子域符号如<code>.mydomain.com</code>也不受支持。
      </li>
    </ul>

    <p>该阀的其他一些功能包括：</p>

    <ul>
      <li>如果省略CIDR前缀，则此阀将成为单个IP阀；</li>
      <li>与<a href="#Remote_Host_Valve">远程主机Valve不同</a> ，它可以以压缩形式处理IPv6地址（ <code>::1</code> ， <code>fe80::/71</code>等）。</li>
    </ul>

  </div></div>

  <div class="subsection"><h4 id="Remote_CIDR_Valve/Attributes">属性</h4><div class="text">

    <p><strong>远程CIDR阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。RemoteCIDRValve</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">allow</code></td><td>
        <p>与远程客户端的IP地址匹配的IPv4或IPv6网络掩码或地址的逗号分隔列表。如果指定了此属性，则远程地址必须与该请求匹配。如果未指定此属性，则所有请求都将被接受，除非远程IP与网络中的网络掩码匹配。 <code>deny</code>属性。
        </p>
      </td></tr><tr><td><code class="attributeName">deny</code></td><td>
        <p>与远程客户端的IP地址匹配的IPv4或IPv6网络掩码或地址的逗号分隔列表。如果指定了此属性，则远程地址必须不匹配才能接受此请求。如果未指定此属性，则请求接受仅由<code>accept</code>属性。
        </p>
      </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="Example">例</h4><div class="text">
    <p>要仅允许从本地主机连接的客户端访问，请执行以下操作：</p>
    <pre>
      &lt;Valve className="org.apache.catalina.valves.RemoteCIDRValve"
      allow="127.0.0.1, ::1"/&gt;
    </pre>
  </div></div>

</div></div>


</strong></div><h3 id="Proxies_Support"><strong>代理支持</strong></h3><div class="text"><strong>
  <div class="subsection"><h4 id="Load_Balancer_Draining_Valve">负载平衡器排水阀</h4><div class="text">
    <div class="subsection"><h4 id="Load_Balancer_Draining_Valve/Introduction">介绍</h4><div class="text">
      <p>当使用mod_jk或mod_proxy_ajp时，客户端的会话ID用于确定将使用哪个后端服务器来处理请求。如果目标节点正在“耗尽”（在mod_jk中，这是<i>DISABLED</i>状态；在mod_proxy_ajp中，这是<i>Drain（N）</i>状态），对过期会话的请求实际上可能导致耗尽节点无法耗尽。
      </p>
      <p>不幸的是，基于AJP的负载均衡器无法证明客户端提供的会话ID是否有效，因此会将对目标为该节点的会话的任何请求发送到禁用（或“排水”）节点，从而导致“排干”过程需要的时间比必要的时间长。
      </p>
      <p>该Valve检测到无效会话的请求，从请求中剥离会话信息，然后重定向回相同的URL，负载均衡器应在该URL中选择其他（活动）节点来处理请求。这将加速禁用节点的“排出”过程。
      </p>

      <p>节点的激活状态由请求中的负载平衡器发送，因此不需要在禁用的节点上进行状态更改。只需在您的阀门管道中配置此阀门，当激活状态设置为“禁用”时它将起作用。
      </p>

      <p>您应谨慎在所有认证Valve之前在Valve管道中注册此Valve，因为在任何认证Valve将请求保存到受保护资源之前，此Valve应该能够重定向请求。如果发生这种情况，将创建一个新的会话，并且耗尽过程将停止，因为将建立一个新的有效会话。
      </p>
    </div></div>

    <div class="subsection"><h4 id="Load_Balancer_Draining_Valve/Attributes">属性</h4><div class="text">
      <p><strong>负载平衡器排水阀</strong>支持以下配置属性：</p>

      <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
          <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。LoadBalancerDrainingValve</strong> 。
          </p>
        </td></tr><tr><td><code class="attributeName">redirectStatusCode</code></td><td>
          <p>允许设置自定义重定向代码，以在客户端重定向到负载平衡器重新平衡时使用。默认值为307 TEMPORARY_REDIRECT。</p>
        </td></tr><tr><td><code class="attributeName">ignoreCookieName</code></td><td>
          <p>当与<code>ignoreCookieValue</code> ，客户可以显示此Cookie（及其伴随值），这将导致该Valve不执行任何操作。这将允许您在重新启用节点之前先探查已<i>禁用的</i>节点，以确保其按预期工作。</p>
        </td></tr><tr><td><code class="attributeName">ignoreCookieValue</code></td><td>
          <p>当与<code>ignoreCookieName</code> ，客户可以出示Cookie（及其附带的值），这将导致该Valve不执行任何操作。这将允许您在重新启用节点之前先探查已<i>禁用的</i>节点，以确保其按预期工作。</p>
        </td></tr></tbody></table>
    </div></div>
  </div></div>

<div class="subsection"><h4 id="Remote_IP_Valve">远程IP阀</h4><div class="text">

  <div class="subsection"><h4 id="Remote_IP_Valve/Introduction">介绍</h4><div class="text">

    <p>Tomcat的<a href="https://httpd.apache.org/docs/trunk/mod/mod_remoteip.html">mod_remoteip</a>端口，此阀门用代理或负载均衡器通过请求标头（例如“ X-Forwarded-For”）提供的IP地址列表替换请求的表观客户端远程IP地址和主机名。</p>

    <p>该阀的另一个功能是替换外观方案（http / https），服务器端口和<code>request.secure</code>通过代理或负载平衡器通过请求标头（例如“ X-Forwarded-Proto”）提供的方案。</p>

    <p>该阀可用于<code>Engine</code> ， <code>Host</code>要么<code>Context</code>所需的级别。通常，此阀将用于<code>Engine</code>水平。</p>

    <p>如果与远程地址/主机阀结合使用，则应首先定义此阀，以确保向远程地址/主机阀提供正确的客户端IP地址。</p>

    <p><strong>注意：</strong>默认情况下，此阀不影响写入访问日志的值。当请求处理离开阀门时，将恢复原始值，并且总是在访问日志记录之前发生。要将此阀设置的远程地址，远程主机，服务器端口和协议值传递到访问日志，它们将放入请求属性中。默认情况下，在此处发布这些值是启用的，但是<code>AccessLogValve</code>应该明确配置为使用它们。请参阅说明文件<code>requestAttributesEnabled</code>的属性<code>AccessLogValve</code> 。</p>

    <p>由该阀设置并可由访问日志使用的请求属性的名称如下：</p>

    <ul>
      <li><code>org.apache.catalina.AccessLog.RemoteAddr</code></li>
      <li><code>org.apache.catalina.AccessLog.RemoteHost</code></li>
      <li><code>org.apache.catalina.AccessLog.Protocol</code></li>
      <li><code>org.apache.catalina.AccessLog.ServerPort</code></li>
      <li><code>org.apache.tomcat.remoteAddr</code></li>
    </ul>

  </div></div>

  <div class="subsection"><h4 id="Remote_IP_Valve/Attributes">属性</h4><div class="text">

    <p><strong>远程IP Valve</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。RemoteIpValve</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">remoteIpHeader</code></td><td>
        <p>该阀门读取的HTTP标头的名称，该标头包含从发出请求的客户端开始的遍历IP地址的列表。如果未指定，则默认为<code>x-forwarded-for</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">internalProxies</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ），则代理的IP地址必须匹配才能被视为内部代理。出现在<strong>remoteIpHeader</strong>中的内部代理将受到信任，并且不会出现在<strong>proxiesHeader</strong>值中。如果未指定，则默认值为<code>10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|169\.254\.\d{1,3}\.\d{1,3}|127\.\d{1,3}\.\d{1,3}\.\d{1,3}|172\.1[6-9]{1}\.\d{1,3}\.\d{1,3}|172\.2[0-9]{1}\.\d{1,3}\.\d{1,3}|172\.3[0-1]{1}\.\d{1,3}\.\d{1,3}|0:0:0:0:0:0:0:1</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">proxiesHeader</code></td><td>
        <p>此阀创建的HTTP标头的名称，以保存在传入<strong>remoteIpHeader中</strong>已处理的代理列表。如果未指定，则默认为<code>x-forwarded-by</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">requestAttributesEnabled</code></td><td>
        <p>调成<code>true</code>设置AccessLog实现使用的请求属性，以覆盖请求所返回的远程地址，远程主机，服务器端口和协议的值。请求属性还用于使转发的远程地址显示在Manager Web应用程序的状态页上。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">trustedProxies</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ），则代理的IP地址必须匹配才能被视为受信任的代理。出现在<strong>remoteIpHeader</strong>中的受信任代理将受到信任，并出现在<strong>proxiesHeader</strong>值中。如果未指定，则不会信任任何代理。</p>
      </td></tr><tr><td><code class="attributeName">protocolHeader</code></td><td>
        <p>该阀读取的HTTP标头的名称，该标头保存客户端用于连接到代理的协议。如果未指定，则默认为<code>X-Forwarded-Proto</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">portHeader</code></td><td>
        <p>该阀读取的HTTP标头的名称，该标头保存客户端用于连接到代理的端口。如果未指定，则默认为<code>null</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">protocolHeaderHttpsValue</code></td><td>
        <p><strong>protocolHeader的</strong>值，指示它是HTTPS请求。如果未指定，则默认为<code>https</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">httpServerPort</code></td><td>
         <p>传回的值<code>ServletRequest.getServerPort()</code>当<strong>protocolHeader</strong>指示<code>http</code>协议，并且不存在<strong>portHeader</strong> 。如果未指定，则默认为<code>80</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">httpsServerPort</code></td><td>
         <p>传回的值<code>ServletRequest.getServerPort()</code>当<strong>protocolHeader</strong>指示<code>https</code>协议，并且不存在<strong>portHeader</strong> 。如果未指定，则默认为<code>443</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">changeLocalPort</code></td><td>
        <p>如果<code>true</code> ，由传回的值<code>ServletRequest.getLocalPort()</code>和<code>ServletRequest.getServerPort()</code>由该阀修改。如果未指定，则默认为<code>false</code>用来。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>


<div class="subsection"><h4 id="SSL_Valve">SSL阀</h4><div class="text">

  <div class="subsection"><h4 id="SSL_Valve/Introduction">介绍</h4><div class="text">

    <p>使用mod_proxy_http时，协议中不包含客户端SSL信息（与mod_jk和mod_proxy_ajp不同）。为了使客户端SSL信息对Tomcat可用，需要一些其他配置。在httpd中，mod_headers用于将SSL信息添加为HTTP标头。在Tomcat中，此阀用于从HTTP标头读取信息，并将其插入请求中。</p>

    <p>注意：确保始终由httpd为所有请求设置标头，以防止客户端通过发送假标头来欺骗SSL信息。</p>

    <p>要配置httpd设置必要的标题，请添加以下内容：</p>
<div class="codeBox"><pre><code>&lt;IfModule ssl_module&gt;
  RequestHeader set SSL_CLIENT_CERT "%{SSL_CLIENT_CERT}s"
  RequestHeader set SSL_CIPHER "%{SSL_CIPHER}s"
  RequestHeader set SSL_SESSION_ID "%{SSL_SESSION_ID}s"
  RequestHeader set SSL_CIPHER_USEKEYSIZE "%{SSL_CIPHER_USEKEYSIZE}s"
&lt;/IfModule&gt;</code></pre></div>

  </div></div>

  <div class="subsection"><h4 id="SSL_Valve/Attributes">属性</h4><div class="text">

    <p><strong>SSL Valve</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。SSLValve</strong> 。
        </p>
      </td></tr><tr><td><code class="attributeName">sslClientCertHeader</code></td><td>
        <p>允许为ssl_client_cert标头设置自定义名称。如果未指定，则默认为<code>ssl_client_cert</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">sslCipherHeader</code></td><td>
        <p>允许为ssl_cipher标头设置自定义名称。如果未指定，则默认为<code>ssl_cipher</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">sslSessionIdHeader</code></td><td>
        <p>允许为ssl_session_id标头设置自定义名称。如果未指定，则默认为<code>ssl_session_id</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">sslCipherUserKeySizeHeader</code></td><td>
        <p>允许为ssl_cipher_usekeysize标头设置自定义名称。如果未指定，则默认为<code>ssl_cipher_usekeysize</code>用来。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>


</strong></div><h3 id="Single_Sign_On_Valve"><strong>单点登录阀</strong></h3><div class="text"><strong>

  <div class="subsection"><h4 id="Single_Sign_On_Valve/Introduction">介绍</h4><div class="text">

    <p>当您希望使用户能够登录到与您的虚拟主机关联的任何一个Web应用程序，然后让其在同一虚拟主机上的所有其他Web应用程序识别其身份时，可以使用<em>Single Sign On Valve</em> 。</p>

    <p>有关更多信息，请参见<strong>Host</strong>元素上的<a href="host.html#Single_Sign_On">Single Sign On</a>特殊功能。</p>

  </div></div>


  <div class="subsection"><h4 id="Single_Sign_On_Valve/Attributes">属性</h4><div class="text">

    <p><strong>单一登录</strong>阀支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.authenticator。SingleSignOn</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">requireReauthentication</code></td><td>
        <p>默认为false。用于确定是否需要将每个请求重新认证到安全<strong>领域的</strong>标志。如果为“ true”，则此Valve使用缓存的安全凭证（用户名和密码）将与SSO会话关联的每个请求重新认证到<strong>Realm</strong> 。如果为“ false”，则Valve自身可以基于有效SSO cookie的存在对请求进行身份验证，而无需与<strong>Realm</strong>进行重新检查。</p>
      </td></tr><tr><td><code class="attributeName">cookieDomain</code></td><td>
        <p>设置要用于sso cookie的主机域。</p>
      </td></tr></tbody></table>

  </div></div>


</strong></div><h3 id="Authentication"><strong>认证方式</strong></h3><div class="text"><strong>

<p>本节中的阀实现<strong>org.apache.catalina。身份验证器</strong>接口。</p>

<div class="subsection"><h4 id="Basic_Authenticator_Valve">基本认证阀</h4><div class="text">

  <div class="subsection"><h4 id="Basic_Authenticator_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>基本身份验证器阀</strong>会自动添加到配置为使用BASIC身份验证的任何<a href="context.html">上下文</a>中。</p>

    <p>如果需要任何非默认设置，则可以在<a href="context.html">Context</a>元素内使用所需值配置阀门。</p>

  </div></div>

  <div class="subsection"><h4 id="Basic_Authenticator_Valve/Attributes">属性</h4><div class="text">

    <p><strong>基本身份验证器阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">alwaysUseSession</code></td><td>
        <p>验证用户身份后，是否应始终使用会话？这可能会带来一些性能上的好处，因为该会话随后可以用于缓存已验证的Principal，因此无需在每个请求上都通过Realm对用户进行验证。这对于组合使用（例如与JNDIRealm或DataSourceRealms一起使用的BASIC身份验证）可能会有所帮助。但是，创建和GC会话也将产生性能成本。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">cache</code></td><td>
        <p>如果请求是HTTP会话的一部分，我们是否应该缓存经过身份验证的主体？如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">changeSessionIdOnAuthentication</code></td><td>
        <p>控制如果在认证用户时存在会话，则是否更改会话ID。这是为了防止会话固定攻击。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">charset</code></td><td>
        <p>控制是否<code>WWW-Authenticate</code> HTTP标头包含一个<code>charset</code>根据RFC 7617的身份验证参数。唯一允许的选项是<code>null</code> ，空字符串和<code>UTF-8</code> 。如果<code>UTF-8</code>指定然后<code>charset</code>将使用该值发送身份验证参数，并使用UTF-8将提供的用户名和可选密码从字节转换为字符。否则，不会<code>charset</code>将发送认证参数，并使用ISO-8859-1将提供的用户名和可选密码从字节转换为字符。默认值为<code>null</code></p>
      </td></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.authenticator。BasicAuthenticator</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">disableProxyCaching</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>可能有助于解决某些浏览器中的缓存问题，但也将导致受保护的页面被代理缓存，这几乎肯定是安全问题。
        <code>securePagesWithPragma</code>为浏览器缓存问题提供了另一种安全的解决方法。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">securePagesWithPragma</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>通过使用可能有助于解决某些浏览器中的缓存问题<code>Cache-Control: private</code>而不是默认<code>Pragma: No-cache</code>和<code>Cache-control: No-cache</code> 。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomAlgorithm</code></td><td>
        <p>用于创建算法的算法名称<code>java.security.SecureRandom</code>生成会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用SHA1PRNG的默认算法。如果不支持默认算法，则将使用平台默认值。要指定应使用平台默认值，请不要设置secureRandomProvider属性并将此属性设置为空字符串。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomClass</code></td><td>
        <p>扩展的Java类的名称<code>java.security.SecureRandom</code>用于生成SSO会话ID。如果未指定，则默认值为<code>java.security.SecureRandom</code> 。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomProvider</code></td><td>
        <p>提供者的名称，用于创建<code>java.security.SecureRandom</code>生成SSO会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用平台默认提供程序。</p>
      </td></tr><tr><td><code class="attributeName">trimCredentials</code></td><td>
        <p>控制是否从已解析的凭据中删除前导和/或尾随空格。如果未指定，则默认值为<code>true</code> 。</p>
      </td></tr><tr><td><code class="attributeName">jaspicCallbackHandlerClass</code></td><td>
        <p>Java类的名称<code>javax.security.auth.callback.CallbackHandler</code> JASPIC应该使用的实现。如果未指定，则默认<code>org.apache.catalina.authenticator.jaspic.CallbackHandlerImpl</code>将会被使用。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>


<div class="subsection"><h4 id="Digest_Authenticator_Valve">消化认证阀</h4><div class="text">

  <div class="subsection"><h4 id="Digest_Authenticator_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>摘要身份验证器阀门</strong>会自动添加到配置为使用DIGEST身份验证的任何<a href="context.html">上下文</a>中。</p>

    <p>如果需要任何非默认设置，则可以在<a href="context.html">Context</a>元素内使用所需值配置阀门。</p>

  </div></div>

  <div class="subsection"><h4 id="Digest_Authenticator_Valve/Attributes">属性</h4><div class="text">

    <p><strong>摘要验证器阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">alwaysUseSession</code></td><td>
        <p>验证用户身份后，是否应始终使用会话？这可能会带来一些性能上的好处，因为该会话随后可以用于缓存已验证的Principal，因此无需在每个请求上都通过Realm对用户进行验证。这对于组合使用（例如与JNDIRealm或DataSourceRealms一起使用的BASIC身份验证）可能会有所帮助。但是，创建和GC会话也将产生性能成本。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">cache</code></td><td>
        <p>如果请求是HTTP会话的一部分，我们是否应该缓存经过身份验证的主体？如果未指定，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">changeSessionIdOnAuthentication</code></td><td>
        <p>控制如果在认证用户时存在会话，则是否更改会话ID。这是为了防止会话固定攻击。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.authenticator。DigestAuthenticator</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">disableProxyCaching</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>可能有助于解决某些浏览器中的缓存问题，但也将导致受保护的页面被代理缓存，这几乎肯定是安全问题。
        <code>securePagesWithPragma</code>为浏览器缓存问题提供了另一种安全的解决方法。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">key</code></td><td>
        <p>摘要认证使用的秘密密钥。如果未设置，则生成一个安全的随机值。通常仅在需要在服务器重新启动和/或整个集群中使键值保持恒定的情况下才应设置此选项。</p>
      </td></tr><tr><td><code class="attributeName">nonceCacheSize</code></td><td>
        <p>为了防止重放攻击，DIGEST身份验证器跟踪服务器的随机数和随机数计数值。此属性控制该缓存的大小。如果未指定，则使用默认值1000。</p>
      </td></tr><tr><td><code class="attributeName">nonceCountWindowSize</code></td><td>
        <p>客户请求可能会无序处理，这又意味着随机数计数值可能会无序处理。为了防止在随机数计数出现乱序时验证失败，验证器将跟踪随机数计数值的窗口。此属性控制该窗口的大小。如果未指定，则使用默认值100。</p>
      </td></tr><tr><td><code class="attributeName">nonceValidity</code></td><td>
        <p>服务器生成的随机数被认为有效的时间（以毫秒为单位）可用于身份验证。如果未指定，将使用默认值300000（5分钟）。</p>
      </td></tr><tr><td><code class="attributeName">opaque</code></td><td>
        <p>摘要身份验证使用的不透明服务器字符串。如果未设置，则生成一个随机值。通常仅在需要在服务器重新启动和/或整个集群中使不透明值保持恒定时才应设置此选项。</p>
      </td></tr><tr><td><code class="attributeName">securePagesWithPragma</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>通过使用可能有助于解决某些浏览器中的缓存问题<code>Cache-Control: private</code>而不是默认<code>Pragma: No-cache</code>和<code>Cache-control: No-cache</code> 。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomAlgorithm</code></td><td>
        <p>用于创建算法的算法名称<code>java.security.SecureRandom</code>生成会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用SHA1PRNG的默认算法。如果不支持默认算法，则将使用平台默认值。要指定应使用平台默认值，请不要设置secureRandomProvider属性并将此属性设置为空字符串。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomClass</code></td><td>
        <p>扩展的Java类的名称<code>java.security.SecureRandom</code>用于生成SSO会话ID。如果未指定，则默认值为<code>java.security.SecureRandom</code> 。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomProvider</code></td><td>
        <p>提供者的名称，用于创建<code>java.security.SecureRandom</code>生成SSO会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用平台默认提供程序。</p>
      </td></tr><tr><td><code class="attributeName">validateUri</code></td><td>
        <p>是否应该按照RFC2617的要求验证URI？如果未指定，则默认值为<code>true</code>将会被使用。通常只有在Tomcat位于反向代理后面并且代理正在修改传递给Tomcat的URI时，才应设置该值，以使DIGEST身份验证始终失败。</p>
      </td></tr><tr><td><code class="attributeName">jaspicCallbackHandlerClass</code></td><td>
        <p>Java类的名称<code>javax.security.auth.callback.CallbackHandler</code> JASPIC应该使用的实现。如果未指定，则默认<code>org.apache.catalina.authenticator.jaspic.CallbackHandlerImpl</code>将会被使用。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>


<div class="subsection"><h4 id="Form_Authenticator_Valve">形状认证阀</h4><div class="text">

  <div class="subsection"><h4 id="Form_Authenticator_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>表单身份验证器阀门</strong>会自动添加到配置为使用<strong>表单身份验证的</strong>任何<a href="context.html">上下文</a>中。</p>

    <p>如果需要任何非默认设置，则可以在<a href="context.html">Context</a>元素内使用所需值配置阀门。</p>

  </div></div>

  <div class="subsection"><h4 id="Form_Authenticator_Valve/Attributes">属性</h4><div class="text">

    <p><strong>表单验证器阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">changeSessionIdOnAuthentication</code></td><td>
        <p>控制如果在认证用户时存在会话，则是否更改会话ID。这是为了防止会话固定攻击。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">characterEncoding</code></td><td>
        <p>用于从请求中读取用户名和密码参数的字符编码。如果未设置，则将使用请求正文的编码。</p>
      </td></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.authenticator。FormAuthenticator</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">disableProxyCaching</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>可能有助于解决某些浏览器中的缓存问题，但也将导致受保护的页面被代理缓存，这几乎肯定是安全问题。
        <code>securePagesWithPragma</code>为浏览器缓存问题提供了另一种安全的解决方法。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">landingPage</code></td><td>
        <p>如果滥用了FORM身份验证过程，例如通过直接请求登录页面或将登录延迟很长时间以至会话过期，则控制该过程。如果设置了此属性，则在使用有效凭据提交登录表单的情况下，Tomcat会将用户重定向到指定的登录页面，而不是返回错误响应代码。为了处理登录，登录页面必须是受保护的资源（即需要身份验证的资源）。如果登录页面不需要身份验证，则该用户将无法登录，并且在他们访问受保护页面时将再次被提示输入其凭据。</p>
      </td></tr><tr><td><code class="attributeName">securePagesWithPragma</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>通过使用可能有助于解决某些浏览器中的缓存问题<code>Cache-Control: private</code>而不是默认<code>Pragma: No-cache</code>和<code>Cache-control: No-cache</code> 。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomAlgorithm</code></td><td>
        <p>用于创建算法的算法名称<code>java.security.SecureRandom</code>生成会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用SHA1PRNG的默认算法。如果不支持默认算法，则将使用平台默认值。要指定应使用平台默认值，请不要设置secureRandomProvider属性并将此属性设置为空字符串。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomClass</code></td><td>
        <p>扩展的Java类的名称<code>java.security.SecureRandom</code>用于生成SSO会话ID。如果未指定，则默认值为<code>java.security.SecureRandom</code> 。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomProvider</code></td><td>
        <p>提供者的名称，用于创建<code>java.security.SecureRandom</code>生成SSO会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用平台默认提供程序。</p>
      </td></tr><tr><td><code class="attributeName">jaspicCallbackHandlerClass</code></td><td>
        <p>Java类的名称<code>javax.security.auth.callback.CallbackHandler</code> JASPIC应该使用的实现。如果未指定，则默认<code>org.apache.catalina.authenticator.jaspic.CallbackHandlerImpl</code>将会被使用。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>


<div class="subsection"><h4 id="SSL_Authenticator_Valve">SSL认证阀</h4><div class="text">

  <div class="subsection"><h4 id="SSL_Authenticator_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>SSL Authenticator Valve</strong>自动添加到配置为使用SSL身份验证的任何<a href="context.html">上下文</a>中。</p>

    <p>如果需要任何非默认设置，则可以在<a href="context.html">Context</a>元素内使用所需值配置阀门。</p>

  </div></div>

  <div class="subsection"><h4 id="SSL_Authenticator_Valve/Attributes">属性</h4><div class="text">

    <p><strong>SSL Authenticator Valve</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">cache</code></td><td>
        <p>如果请求是HTTP会话的一部分，我们是否应该缓存经过身份验证的主体？如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.authenticator。SSLAuthenticator</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">changeSessionIdOnAuthentication</code></td><td>
        <p>控制如果在认证用户时存在会话，则是否更改会话ID。这是为了防止会话固定攻击。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">disableProxyCaching</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>可能有助于解决某些浏览器中的缓存问题，但也将导致受保护的页面被代理缓存，这几乎肯定是安全问题。
        <code>securePagesWithPragma</code>为浏览器缓存问题提供了另一种安全的解决方法。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">securePagesWithPragma</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>通过使用可能有助于解决某些浏览器中的缓存问题<code>Cache-Control: private</code>而不是默认<code>Pragma: No-cache</code>和<code>Cache-control: No-cache</code> 。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomAlgorithm</code></td><td>
        <p>用于创建算法的算法名称<code>java.security.SecureRandom</code>生成会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用SHA1PRNG的默认算法。如果不支持默认算法，则将使用平台默认值。要指定应使用平台默认值，请不要设置secureRandomProvider属性并将此属性设置为空字符串。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomClass</code></td><td>
        <p>扩展的Java类的名称<code>java.security.SecureRandom</code>用于生成SSO会话ID。如果未指定，则默认值为<code>java.security.SecureRandom</code> 。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomProvider</code></td><td>
        <p>提供者的名称，用于创建<code>java.security.SecureRandom</code>生成SSO会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用平台默认提供程序。</p>
      </td></tr><tr><td><code class="attributeName">jaspicCallbackHandlerClass</code></td><td>
        <p>Java类的名称<code>javax.security.auth.callback.CallbackHandler</code> JASPIC应该使用的实现。如果未指定，则默认<code>org.apache.catalina.authenticator.jaspic.CallbackHandlerImpl</code>将会被使用。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>


<div class="subsection"><h4 id="SPNEGO_Valve">SPNEGO阀门</h4><div class="text">

  <div class="subsection"><h4 id="SPNEGO_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>SPNEGO Authenticator Valve</strong>会自动添加到配置为使用SPNEGO身份验证的任何<a href="context.html">上下文</a>中。</p>

    <p>如果需要任何非默认设置，则可以在<a href="context.html">Context</a>元素内使用所需值配置阀门。</p>

  </div></div>

  <div class="subsection"><h4 id="SPNEGO_Valve/Attributes">属性</h4><div class="text">

    <p><strong>SPNEGO Authenticator Valve</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">applyJava8u40Fix</code></td><td>
        <p>从Java 8更新40（ <a href="https://bugs.openjdk.java.net/browse/JDK-8048194">JDK-8048194</a> ）开始引入的修复程序破坏了IE的SPNEGO身份验证，并在Windows 2008 R2服务器上运行Tomcat。此选项启用一种变通方法，该方法允许SPNEGO身份验证继续工作。解决方法不应影响其他配置，因此默认情况下已启用它。如有必要，可以通过将此属性设置为来禁用解决方法<code>false</code> 。</p>
      </td></tr><tr><td><code class="attributeName">alwaysUseSession</code></td><td>
        <p>验证用户身份后，是否应始终使用会话？这可能会带来一些性能上的好处，因为该会话随后可以用于缓存已验证的Principal，因此无需在每个请求上都对用户进行验证。这对于假定服务器将缓存经过身份验证的用户的客户端也有帮助。但是，创建和GC会话也将产生性能成本。有关替代解决方案，请参见<code>noKeepAliveUserAgents</code> 。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">cache</code></td><td>
        <p>如果请求是HTTP会话的一部分，我们是否应该缓存经过身份验证的主体？如果未指定，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.authenticator。SpnegoAuthenticator</strong> 。
        </p>
      </td></tr><tr><td><code class="attributeName">changeSessionIdOnAuthentication</code></td><td>
        <p>控制如果在认证用户时存在会话，则是否更改会话ID。这是为了防止会话固定攻击。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">disableProxyCaching</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>可能有助于解决某些浏览器中的缓存问题，但也将导致受保护的页面被代理缓存，这几乎肯定是安全问题。
        <code>securePagesWithPragma</code>为浏览器缓存问题提供了另一种安全的解决方法。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">loginConfigName</code></td><td>
        <p>用于作为服务登录的JAAS登录配置的名称。如果未指定，则默认为<code>com.sun.security.jgss.krb5.accept</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">noKeepAliveUserAgents</code></td><td>
        <p>某些客户端（不是大多数浏览器）希望服务器为连接缓存经过身份验证的用户信息，而不是在每次请求时都重新发送凭据。除非HTTP会话可用，否则Tomcat不会这样做。如果应用程序创建了一个会话，或者如果<code>alwaysUseSession</code>已为此身份验证器启用。</p>
        <p>作为创建会话的替代方法，此属性可用于定义禁用了HTTP保持活动状态的用户代理。这意味着一个连接将仅用于单个请求，因此无法为每个连接缓存经过身份验证的用户信息。禁用HTTP保持活动会降低性能。</p>
        <p>该属性应为匹配整个用户代理字符串的正则表达式，例如<code>.*Chrome.*</code> 。如果未指定，则不会定义任何正则表达式，并且不会禁用任何用户代理。</p>
      </td></tr><tr><td><code class="attributeName">securePagesWithPragma</code></td><td>
        <p>控制受安全性约束保护的页面的缓存。设置为<code>false</code>通过使用可能有助于解决某些浏览器中的缓存问题<code>Cache-Control: private</code>而不是默认<code>Pragma: No-cache</code>和<code>Cache-control: No-cache</code> 。如果未设置，则默认值为<code>false</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomAlgorithm</code></td><td>
        <p>用于创建算法的算法名称<code>java.security.SecureRandom</code>生成会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用SHA1PRNG的默认算法。如果不支持默认算法，则将使用平台默认值。要指定应使用平台默认值，请不要设置secureRandomProvider属性并将此属性设置为空字符串。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomClass</code></td><td>
        <p>扩展的Java类的名称<code>java.security.SecureRandom</code>用于生成SSO会话ID。如果未指定，则默认值为<code>java.security.SecureRandom</code> 。</p>
      </td></tr><tr><td><code class="attributeName">secureRandomProvider</code></td><td>
        <p>提供者的名称，用于创建<code>java.security.SecureRandom</code>生成SSO会话ID的实例。如果指定了无效的算法和/或提供程序，则将使用平台默认提供程序和默认算法。如果未指定，将使用平台默认提供程序。</p>
      </td></tr><tr><td><code class="attributeName">storeDelegatedCredential</code></td><td>
        <p>控制是否将用户委派的凭据存储在用户主体中。如果可用，则委派证书将通过以下方式对应用程序可用（例如，对外部服务的继续身份验证） <code>org.apache.catalina.realm.GSS_CREDENTIAL</code>请求属性。如果未设置，则默认值为<code>true</code>将会被使用。</p>
      </td></tr><tr><td><code class="attributeName">jaspicCallbackHandlerClass</code></td><td>
        <p>Java类的名称<code>javax.security.auth.callback.CallbackHandler</code> JASPIC应该使用的实现。如果未指定，则默认<code>org.apache.catalina.authenticator.jaspic.CallbackHandlerImpl</code>将会被使用。</p>
      </td></tr></tbody></table>

  </div></div>

</div></div>


</strong></div><h3 id="Error_Report_Valve"><strong>错误报告阀</strong></h3><div class="text"><strong>

  <div class="subsection"><h4 id="Error_Report_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>错误报告阀</strong>是HTTP状态代码的简单错误处理程序，它将生成并返回HTML错误页面。还可以将其配置为返回针对特定状态代码和/或异常类型的预定义静态HTML页面。</p>

    <p><strong>注意：同时</strong>禁用showServerInfo和showReport只会返回HTTP状态代码，并从默认响应中删除所有CSS。</p>

  </div></div>

  <div class="subsection"><h4 id="Error_Report_Valve/Attributes">属性</h4><div class="text">

    <p><strong>错误报告阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。ErrorReportValve</strong>使用默认的错误报告阀。</p>
      </td></tr><tr><td><code class="attributeName">errorCode.nnn</code></td><td>
        <p>针对由表示的HTTP错误代码返回的UTF-8编码HTML文件的位置<code>nnn</code> 。例如， <code>errorCode.404</code>指定要返回HTTP 404错误的文件。该位置可以是相对的，也可以是绝对的。如果是相对的，则必须相对于<code>$CATALINA_BASE</code> 。的特殊价值<code>errorCode.0</code>如果未为状态代码定义错误页面，则可用于定义要使用的默认错误页面。如果找不到匹配的错误页面，则将返回默认的<strong>错误报告阀门</strong>响应。</p>
      </td></tr><tr><td><code class="attributeName">exceptionType.fullyQualifiedClassName</code></td><td>
        <p>如果发生错误，则返回UTF-8编码的HTML文件的位置，并且<code>javax.servlet.error.exception</code> request属性已设置为的实例<code>fullyQualifiedClassName</code>或它的一个子类。例如， <code>errorCode.java.io.IOException</code>指定要返回的文件<code>IOException</code> 。该位置可以是相对的，也可以是绝对的。如果是相对的，则必须相对于<code>$CATALINA_BASE</code> 。如果找不到匹配的错误页面，则将返回默认的<strong>错误报告阀门</strong>响应。</p>
      </td></tr><tr><td><code class="attributeName">showReport</code></td><td>
        <p>标记，用于确定发生错误时是否显示错误报告（自定义错误消息和/或堆栈跟踪）。如果设置为<code>false</code> ，则错误报告不会在HTML响应中返回。默认值： <code>true</code>
        </p>
      </td></tr><tr><td><code class="attributeName">showServerInfo</code></td><td>
        <p>用于确定发生错误时是否提供服务器信息的标志。如果设置为<code>false</code> ，则HTML响应中不会返回服务器版本。默认值： <code>true</code>
        </p>
      </td></tr></tbody></table>

  </div></div>

</strong></div><h3 id="Crawler_Session_Manager_Valve"><strong>履带会话管理器阀门</strong></h3><div class="text"><strong>

  <div class="subsection"><h4 id="Crawler_Session_Manager_Valve/Introduction">介绍</h4><div class="text">

    <p>Web搜寻器在搜寻站点时会触发成千上万个会话的创建，这可能会导致大量内存消耗。该Valve可以确保搜寻器与单个会话相关联（就像普通用户一样），无论它们是否随请求提供会话令牌。</p>

    <p>该阀可用于<code>Engine</code> ， <code>Host</code>要么<code>Context</code>所需的级别。通常，此阀将用于<code>Engine</code>水平。</p>

    <p>如果与远程IP阀结合使用，则应在此阀之前定义远程IP阀，以确保向该阀提供正确的客户端IP地址。</p>

  </div></div>

  <div class="subsection"><h4 id="Crawler_Session_Manager_Valve/Attributes">属性</h4><div class="text">

    <p><strong>搜寻器会话管理器Valve</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。CrawlerSessionManagerValve</strong> 。
        </p>
      </td></tr><tr><td><code class="attributeName">contextAware</code></td><td>
        <p>标记以使用上下文名称和客户端IP来标识要重用的会话。可以与<code>hostAware</code> 。默认值： <code>true</code>
        </p>
      </td></tr><tr><td><code class="attributeName">crawlerIps</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ）与该客户端IP相匹配，以确定是否来自Web搜寻器的请求。默认情况下，未设置此类正则表达式。</p>
      </td></tr><tr><td><code class="attributeName">crawlerUserAgents</code></td><td>
        <p>正则表达式（使用<code>java.util.regex</code> ）与用户代理HTTP请求标头进行匹配，以确定请求是否来自网络抓取工具。如果未设置，则默认为<code>.*[bB]ot.*|.*Yahoo! Slurp.*|.*Feedfetcher-Google.*</code>用来。</p>
      </td></tr><tr><td><code class="attributeName">hostAware</code></td><td>
        <p>标记以将配置的主机与客户端IP一起使用以标识要重用的会话。可以与<code>contextAware</code> 。默认值： <code>true</code>
        </p>
      </td></tr><tr><td><code class="attributeName">sessionInactiveInterval</code></td><td>
        <p>Crawler会话管理器Valve在不进行任何客户端活动的情况下，应将客户端IP映射到会话ID的最短时间（以秒为单位）。客户端IP /会话缓存将定期清除不活动时间超过此间隔的映射。如果未指定，则默认值为<code>60</code>将会被使用。</p>
      </td></tr></tbody></table>

  </div></div>

</strong></div><h3 id="Stuck_Thread_Detection_Valve"><strong>卡线检测阀</strong></h3><div class="text"><strong>

  <div class="subsection"><h4 id="Stuck_Thread_Detection_Valve/Introduction">介绍</h4><div class="text">

    <p>该阀允许检测需要很长时间才能处理的请求，这可能表明正在处理它的线程被卡住了。此外，它还可以选择中断此类线程以尝试对其进行解锁。</p>
    <p>当检测到此类请求时，其线程的当前堆栈跟踪将以WARN级别写入Tomcat日志。</p>
    <p>卡住的线程的ID和名称可通过JMX中的<code>stuckThreadIds</code>和<code>stuckThreadNames</code>属性。这些ID可以与标准Threading JVM MBean（ <code>java.lang:type=Threading</code> ）以获取有关每个卡住的线程的其他信息。</p>

  </div></div>

  <div class="subsection"><h4 id="Stuck_Thread_Detection_Valve/Attributes">属性</h4><div class="text">

    <p><strong>粘螺纹检测阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。StuckThreadDetectionValve</strong> 。
        </p>
      </td></tr><tr><td><code class="attributeName">threshold</code></td><td>
        <p>最短持续时间（以秒为单位），之后线程被视为阻塞。默认值为600秒。如果设置为0，则禁用检测。</p>
        <p>注意：由于检测（和可选的中断）是在声明此Valve的容器（引擎，主机或上下文）的后台线程中完成的，因此阈值应高于<code>backgroundProcessorDelay</code>这个容器。</p>
      </td></tr><tr><td><code class="attributeName">interruptThreadThreshold</code></td><td>
        <p>最短持续时间（以秒为单位），之后应中断被卡住的线程以尝试“释放”该线程。</p>
        <p>请注意，不能保证线程将被释放。这通常适用于卡在I / O或锁上的线程，但在无限循环的情况下可能没用。</p>
        <p>默认值为-1，将禁用此功能。要启用它，该值必须大于或等于<code>threshold</code> 。</p>
      </td></tr></tbody></table>

  </div></div>

</strong></div><h3 id="Semaphore_Valve"><strong>信号灯阀</strong></h3><div class="text"><strong>

  <div class="subsection"><h4 id="Semaphore_Valve/Introduction">介绍</h4><div class="text">

    <p><strong>信号阀</strong>可以限制并发请求处理线程的数量。</p>
    <p><strong>org.apache.catalina.valves。SemaphoreValve</strong>提供的方法可以被子类覆盖以自定义行为：</p>
    <ul>
    <li><b><code>controlConcurrency</code></b>可能被覆盖以增加条件；</li>
    <li><b><code>permitDenied</code></b>如果未授予许可，则可能会被覆盖以添加错误处理。</li>
    </ul>

  </div></div>

  <div class="subsection"><h4 id="Semaphore_Valve/Attributes">属性</h4><div class="text">

    <p><strong>信号量阀</strong>支持以下配置属性：</p>

    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">block</code></td><td>
        <p>标记以确定线程是否被阻塞，直到获得许可为止。默认值为<strong>true</strong> 。</p>
      </td></tr><tr><td><strong><code class="attributeName">className</code></strong></td><td>
        <p>使用的Java类名称。必须将此设置为<strong>org.apache.catalina.valves。SemaphoreValve</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">concurrency</code></td><td>
        <p>信号量的并发级别。默认值为<strong>10</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">fairness</code></td><td>
        <p>信号量的公平性。默认值为<strong>false</strong> 。</p>
      </td></tr><tr><td><code class="attributeName">interruptible</code></td><td>
        <p>用于确定线程是否可以在允许之前被中断的标志。默认值为<strong>false</strong> 。</p>
      </td></tr></tbody></table>

  </div></div>

</strong></div><div class="noprint"><h3 id="comments_section"><strong>评论</strong></h3><div class="text"><p class="notice"><strong><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="../comments.html">这里</a>解释<a href="../comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </strong></p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer"><strong>版权所有©1999-2019，Apache软件基金会</strong></div></footer></div></body></html>