<html lang="zh-Hans" ><head></head><body >﻿<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="./images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9（9.0.21）-领域配置方法</title><meta name="author" content="Craig R. McClanahan"><meta name="author" content="Yoav Shapira"><meta name="author" content="Andrew R. Jaquith"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/realm-howto">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="./images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="./images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="index.html">文件首页</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>用户指南</h2><ul><li><a href="introduction.html">1）简介</a></li><li><a href="setup.html">2）设定</a></li><li><a href="appdev/index.html">3）第一个webapp</a></li><li><a href="deployer-howto.html">4）部署者</a></li><li><a href="manager-howto.html">5）经理</a></li><li><a href="host-manager-howto.html">6）主机管理员</a></li><li><a href="realm-howto.html">7）领域和AAA</a></li><li><a href="security-manager-howto.html">8）安全经理</a></li><li><a href="jndi-resources-howto.html">9）JNDI资源</a></li><li><a href="jndi-datasource-examples-howto.html">10）JDBC数据源</a></li><li><a href="class-loader-howto.html">11）类加载</a></li><li><a href="jasper-howto.html">12）JSP</a></li><li><a href="ssl-howto.html">13）SSL / TLS</a></li><li><a href="ssi-howto.html">14）SSI</a></li><li><a href="cgi-howto.html">15）CGI</a></li><li><a href="proxy-howto.html">16）代理支持</a></li><li><a href="mbeans-descriptors-howto.html">17）MBean描述符</a></li><li><a href="default-servlet.html">18）默认Servlet</a></li><li><a href="cluster-howto.html">19）聚类</a></li><li><a href="balancer-howto.html">20）负载均衡器</a></li><li><a href="connectors.html">21）连接器</a></li><li><a href="monitoring.html">22）监控与管理</a></li><li><a href="logging.html">23）记录</a></li><li><a href="apr.html">24）APR /本地</a></li><li><a href="virtual-hosting-howto.html">25）虚拟主机</a></li><li><a href="aio.html">26）高级IO</a></li><li><a href="extras.html">27）附加组件</a></li><li><a href="maven-jars.html">28）行刑</a></li><li><a href="security-howto.html">29）安全注意事项</a></li><li><a href="windows-service-howto.html">30）Windows服务</a></li><li><a href="windows-auth-howto.html">31）Windows身份验证</a></li><li><a href="jdbc-pool.html">32）Tomcat的JDBC池</a></li><li><a href="web-socket-howto.html">33）WebSocket</a></li><li><a href="rewrite.html">34）改写</a></li></ul></div><div><h2>参考</h2><ul><li><a href="RELEASE-NOTES.txt">发行说明</a></li><li><a href="config/index.html">组态</a></li><li><a href="api/index.html">Tomcat Java文档</a></li><li><a href="servletapi/index.html">Servlet Java文档</a></li><li><a href="jspapi/index.html">JSP 2.3 Java文档</a></li><li><a href="elapi/index.html">EL 3.0 Java文档</a></li><li><a href="websocketapi/index.html">WebSocket 1.1 Java文档</a></li><li><a href="https://tomcat.apache.org/connectors-doc/">JK 1.2文档</a></li></ul></div><div><h2>Apache Tomcat开发</h2><ul><li><a href="building.html">建造</a></li><li><a href="changelog.html">变更日志</a></li><li><a href="https://wiki.apache.org/tomcat/TomcatVersions">状态</a></li><li><a href="developers.html">开发者</a></li><li><a href="architecture/index.html">建筑</a></li><li><a href="funcspecs/index.html">功能规格。</a></li><li><a href="tribes/introduction.html">部族</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>领域配置方法</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Quick_Start">快速开始</a></li><li><a href="#Overview">总览</a><ol><li><a href="#What_is_a_Realm?">什么是境界？</a></li><li><a href="#Configuring_a_Realm">配置领域</a></li></ol></li><li><a href="#Common_Features">共同特征</a><ol><li><a href="#Digested_Passwords">摘要密码</a></li><li><a href="#Example_Application">应用范例</a></li><li><a href="#Manager_Application">经理申请</a></li><li><a href="#Realm_Logging">领域记录</a></li></ol></li><li><a href="#Standard_Realm_Implementations">标准领域实现</a><ol><li><a href="#JDBCRealm">JDBC领域</a></li><li><a href="#DataSourceRealm">数据源领域</a></li><li><a href="#JNDIRealm">JNDIRealm</a></li><li><a href="#UserDatabaseRealm">UserDatabaseRealm</a></li><li><a href="#MemoryRealm">内存领域</a></li><li><a href="#JAASRealm">JAASRealm</a></li><li><a href="#CombinedRealm">合并领域</a></li><li><a href="#LockOutRealm">锁定领域</a></li></ol></li></ul>
</div><h3 id="Quick_Start">快速开始</h3><div class="text">

<p>本文档介绍了如何通过连接到用户名，密码和用户角色的现有“数据库”来配置Tomcat以支持<em>容器管理的安全性</em> 。仅当您使用包含一个或多个Web应用程序时，才需要关心这一点。 <code><security-constraint></code>元素和<code><login-config></code>元素，用于定义要求用户进行身份验证的方式。如果您没有使用这些功能，则可以安全地跳过此文档。</p>

<p>有关容器管理的安全性的基本背景信息，请参见<a href="https://wiki.apache.org/tomcat/Specifications">Servlet规范（版本2.4）的</a>第12节。</p>

<p>有关利用Tomcat的<em>单一登录</em>功能（允许用户在与虚拟主机相关联的整个Web应用程序集中进行一次身份验证）的信息，请参见<a href="config/host.html#Single_Sign_On">此处</a> 。</p>

</div><h3 id="Overview">总览</h3><div class="text">


<div class="subsection"><h4 id="What_is_a_Realm?">什么是境界？</h4><div class="text">

<p><strong>领域</strong>是用户名和密码的“数据库”，用于标识Web应用程序（或Web应用程序集）的有效用户，以及与每个有效用户关联的<em>角色</em>列表的枚举。你可以把角色类似于<em>组</em>的类Unix操作系统，因为访问特定的Web应用程序资源被授予具有特定角色（而不是枚举关联的用户名列表）的所有用户。特定用户可以具有与其用户名关联的任意数量的角色。</p>

<p>尽管Servlet规范描述了一种可移植的机制，供应用程序<em>声明</em>其安全要求（在<code>web.xml</code>部署描述符），因此没有可移植的API定义Servlet容器与关联的用户和角色信息之间的接口。但是，在许多情况下，希望将Servlet容器“连接”到生产环境中已经存在的某些现有身份验证数据库或机制。因此，Tomcat定义了一个Java接口（ <code>org.apache.catalina.Realm</code> ），可以通过“插入”组件来建立此连接。提供了六个标准插件，支持与各种身份验证信息源的连接：</p>
<ul>
<li><a href="#JDBCRealm">JDBCRealm-</a>访问存储在关系数据库中的身份验证信息，可通过JDBC驱动程序进行访问。</li>
<li><a href="#DataSourceRealm">DataSourceRealm-</a>访问存储在关系数据库中的身份验证信息，可通过命名的JNDI JDBC DataSource访问。</li>
<li><a href="#JNDIRealm">JNDIRealm-</a>访问通过JNDI提供程序访问的，存储在基于LDAP的目录服务器中的身份验证信息。
    </li>
<li><a href="#UserDatabaseRealm">UserDatabaseRealm-</a>访问存储在UserDatabase JNDI资源中的身份验证信息，该信息通常由XML文档支持（ <code>conf/tomcat-users.xml</code> ）。</li>
<li><a href="#MemoryRealm">MemoryRealm-</a>访问存储在内存中对象集中的身份验证信息，该对象是从XML文档初始化的（ <code>conf/tomcat-users.xml</code> ）。</li>
<li><a href="#JAASRealm">JAASRealm-</a>通过Java认证和授权服务（JAAS）框架访问认证信息。</li>
</ul>

<p>也可以自己写<code>Realm</code>实现，并将其与Tomcat集成。为此，您需要：</p>
<ul>
  <li>实行<code>org.apache.catalina.Realm</code> ，</li>
  <li>将已编译的领域放置在$ CATALINA_HOME / lib中，</li>
  <li>按照下面的“配置领域”部分所述声明您的领域，</li>
  <li>向<a href="mbeans-descriptors-howto.html">MBeans描述符</a>声明您的领域。</li>
</ul>

</div></div>


<div class="subsection"><h4 id="Configuring_a_Realm">配置领域</h4><div class="text">

<p>在深入了解标准Realm实现之前，重要的是要通俗地理解Realm的配置方式。通常，您将向您的服务器添加XML元素<code>conf/server.xml</code>配置文件，如下所示：</p>

<div class="codeBox"><pre><code>&lt;Realm className="... class name for this implementation"
       ... other attributes for this implementation .../&gt;</code></pre></div>

<p>的<code><Realm></code>元素可以嵌套在以下任何一项中<code>Container</code>元素。Realm元素的位置直接影响该Realm的“范围”（即哪些Web应用程序将共享相同的身份验证信息）：</p>
<ul>
<li><em><engine>元素内</engine></em> -此Realm将在所有虚拟主机上的所有Web应用程序之间共享，除非被嵌套在下属中的Realm元素覆盖<code><Host></code>要么<code><Context></code>元件。</li>
<li><em>在<host>元素</host>内部</em> -此Realm将在此虚拟主机的所有Web应用程序之间共享，除非被嵌套在下属中的Realm元素覆盖<code><Context></code>元件。</li>
<li><em>在<context>元素</context>内部</em> -此领域将仅用于此Web应用程序。</li>
</ul>


</div></div>


</div><h3 id="Common_Features">共同特征</h3><div class="text">


<div class="subsection"><h4 id="Digested_Passwords">摘要密码</h4><div class="text">

<p>对于每个标准<code>Realm</code>在实现中，用户密码（默认情况下）以明文形式存储。在许多环境中，这是不希望的，因为身份验证数据的临时观察者可以收集足够的信息以成功登录并模拟其他用户。为了避免这个问题，标准的实现支持<em>消化</em>用户密码的概念。这样可以对存储的密码版本进行编码（格式不易逆转），但是<code>Realm</code>实现仍然可以用于身份验证。</p>

<p>当标准领域通过检索存储的密码并将其与用户提供的值进行身份验证时，可以通过以下方式选择摘要密码： <a href="config/credentialhandler.html"><code>CredentialHandler</code></a>你里面的元素<code><Realm></code>元件。支持SSHA，SHA或MD5算法之一的简单选择是使用<code>MessageDigestCredentialHandler</code> 。必须将此元素配置为支持的摘要算法之一<code>java.security.MessageDigest</code>类（SSHA，SHA或MD5）。当您选择此选项时，密码的内容将存储在<code>Realm</code>必须是密码的明文版本，由指定算法提取。</p>

<p>当。。。的时候<code>authenticate()</code>调用Realm的方法，由用户自己指定的（明文）密码本身将由相同的算法提取，并将结果与密码返回的值进行比较。 <code>Realm</code> 。相等匹配表示原始密码的明文版本与用户提供的密码相同，因此应授权该用户。</p>

<p>要计算明文密码的摘要值，支持两种便捷技术：</p>
<ul>
<li>如果要编写需要动态计算摘要密码的应用程序，请调用静态<code>Digest()</code>的方法<code>org.apache.catalina.realm.RealmBase</code>类，传递明文密码，摘要算法名称和编码作为参数。此方法将返回摘要密码。</li>
<li>如果要执行命令行实用工具来计算摘要密码，只需执行<div class="codeBox"><pre><code>CATALINA_HOME/bin/digest.[bat|sh] -a {algorithm} {cleartext-password}</code></pre></div>并且此明文密码的摘要版本将返回到标准输出。</li>
</ul>

<p>如果将摘要密码与DIGEST身份验证一起使用，则用于生成摘要的明文会有所不同，摘要必须使用MD5算法的一次迭代，且不得加盐。在上面的例子中<code>{cleartext-password}</code>必须替换为<code>{username}:{realm}:{cleartext-password}</code> 。例如，在开发环境中，这可能采用以下形式<code>testUser:Authentication required:testPassword</code> 。的价值<code>{realm}</code>取自<code><realm-name></code> Web应用程序的元素<code><login-config></code> 。如果未在web.xml中指定，则默认值为<code>Authentication required</code>用来。</p>

<p>支持使用非平台默认编码的用户名和/或密码，使用</p>
<div class="codeBox"><pre><code>CATALINA_HOME/bin/digest.[bat|sh] -a {algorithm} -e {encoding} {input}</code></pre></div>
<p>但需要注意确保将输入正确传递到摘要器。消化器返回<code>{input}:{digest}</code> 。如果输入在返回中显示为损坏，则摘要将无效。</p>

<p>摘要的输出格式为<code>{salt}${iterations}${digest}</code> 。如果盐长度为零且迭代计数为1，则输出简化为<code>{digest}</code> 。</p>

<p>的完整语法<code>CATALINA_HOME/bin/digest.[bat|sh]</code>是：</p>
<div class="codeBox"><pre><code>CATALINA_HOME/bin/digest.[bat|sh] [-a &lt;algorithm&gt;] [-e &lt;encoding&gt;]
        [-i &lt;iterations&gt;] [-s &lt;salt-length&gt;] [-k &lt;key-length&gt;]
        [-h &lt;handler-class-name&gt;] &lt;credentials&gt;
</code></pre></div>
<ul>
<li><b>-a-</b>用于生成存储的凭证的算法。如果未指定，将使用处理程序的默认值。如果未指定处理程序或算法，则默认为<code>SHA-512</code>将会被使用</li>
<li><b>-e-</b>可能需要用于任何字节到字符转换或从字符转换的编码。如果未指定，则系统编码（ <code>Charset#defaultCharset()</code> ） 将会被使用。</li>
<li><b>-i-</b>生成存储的凭证时要使用的迭代次数。如果未指定，将使用CredentialHandler的默认值。</li>
<li><b>-s-</b>生成和存储为凭证一部分的盐的长度（以字节为单位）。如果未指定，将使用CredentialHandler的默认值。</li>
<li><b>-k-</b>生成证书时创建的密钥的长度（以位为单位）（如果有）。如果未指定，将使用CredentialHandler的默认值。</li>
<li><b>-h-</b>要使用的CredentialHandler的完全限定的类名。如果未指定，则将依次测试内置处理程序（MessageDigestCredentialHandler然后SecretKeyCredentialHandler），并且将使用第一个接受指定算法的处理程序。</li>
</ul>
</div></div>



<div class="subsection"><h4 id="Example_Application">应用范例</h4><div class="text">

<p>Tomcat附带的示例应用程序包括一个区域，该区域利用基于表单的登录受到安全约束的保护。要访问它，请将浏览器指向<a href="http://localhost:8080/examples/jsp/security/protected/">http：// localhost：8080 / examples / jsp / security / protected /</a>并使用为默认<a href="#UserDatabaseRealm">UserDatabaseRealm</a>描述的用户名和密码之一登录。</p>

</div></div>


<div class="subsection"><h4 id="Manager_Application">经理申请</h4><div class="text">

<p>如果希望使用<a href="manager-howto.html">Manager应用</a>程序在正在运行的Tomcat安装中部署和取消部署应用程序，则必须在所选的Realm实现中，将“ manager-gui”角色至少添加到一个用户名中。这是因为管理器Web应用程序本身使用的安全约束要求角色“ manager-gui”访问该应用程序的HTML界面内的任何请求URI。</p>

<p>出于安全原因，默认领域中没有用户名（即使用<code>conf/tomcat-users.xml</code>被分配了“ manager-gui”角色。因此，在Tomcat管理员专门将此角色分配给一个或多个用户之前，没有人能够使用此应用程序的功能。</p>

</div></div>

<div class="subsection"><h4 id="Realm_Logging">领域记录</h4><div class="text">

<p>由调试器记录的调试和异常消息<code>Realm</code>将通过与领域容器相关联的日志记录配置进行记录：其周围的<a href="config/context.html">Context</a> ， <a href="config/host.html">Host</a>或<a href="config/engine.html">Engine</a> 。</p>

</div></div>

</div><h3 id="Standard_Realm_Implementations">标准领域实现</h3><div class="text">

<div class="subsection"><h4 id="JDBCRealm">JDBC领域</h4><div class="text">

<h5>介绍</h5>

<p><strong>JDBCRealm</strong>是Tomcat的实现<code>Realm</code>接口，用于在通过JDBC驱动程序访问的关系数据库中查找用户。只要您的数据库结构符合以下要求，就有很大的配置灵活性，可让您适应现有的表名和列名：</p>
<ul>
<li>必须有一个表，下面称为“ <em>用户”</em>表，该表针对该表中的每个有效用户都包含一行<code>Realm</code>应该认识。</li>
<li><em>users</em>表必须至少包含两列（如果您现有的应用程序需要，则可以包含更多列）：<ul>
    <li>Tomcat在用户登录时可以识别的用户名。</li>
    <li>用户登录时Tomcat识别的密码。该值可以是明文形式或摘要形式-有关更多信息，请参见下文。</li>
    </ul></li>
<li>必须有一个表，下面称为<em>用户角色</em>表，其中包含分配给特定用户的每个有效角色的一行。用户具有零个，一个或多个有效角色是合法的。</li>
<li><em>用户角色</em>表必须至少包含两列（如果现有应用程序需要，则可以包含更多列）：<ul>
    <li>Tomcat可以识别的用户名（与<em>用户</em>表中指定的值相同）。</li>
    <li>与此用户关联的有效角色的角色名称。</li>
    </ul></li>
</ul>

<h5>快速开始</h5>

<p>要将Tomcat设置为使用JDBCRealm，您将需要执行以下步骤：</p>
<ol>
<li>如果尚未这样做，请在数据库中创建符合上述要求的表和列。</li>
<li>配置供Tomcat使用的数据库用户名和密码，该用户名和密码至少具有对上述表的只读访问权限。（Tomcat绝不会尝试写入这些表。）</li>
<li>将要使用的JDBC驱动程序副本放在<code>$CATALINA_HOME/lib</code>目录。请注意， <strong>只能</strong>识别JAR文件！</li>
<li>设置一个<code><Realm></code>元素，如下所述<code>$CATALINA_BASE/conf/server.xml</code>文件。</li>
<li>如果Tomcat已在运行，请重新启动它。</li>
</ol>

<h5>领域元素属性</h5>

<p>要配置JDBCRealm，您将创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>文件， <a href="#Configuring_a_Realm">如上所述</a> 。JDBCRealm的属性在<a href="config/realm.html">Realm</a>配置文档中定义。</p>

<h5>例</h5>

<p>创建所需表的示例SQL脚本可能类似于以下内容（根据特定数据库的需要调整语法）：</p>
<div class="codeBox"><pre><code>create table users (
  user_name         varchar(15) not null primary key,
  user_pass         varchar(15) not null
);

create table user_roles (
  user_name         varchar(15) not null,
  role_name         varchar(15) not null,
  primary key (user_name, role_name)
);</code></pre></div>

<p>例<code>Realm</code>元素默认包含（注释） <code>$CATALINA_BASE/conf/server.xml</code>文件。这是一个使用名为“ authority”的MySQL数据库的示例，该数据库配置有上述表，并通过用户名“ dbuser”和密码“ dbpass”进行访问：</p>
<div class="codeBox"><pre><code>&lt;Realm className="org.apache.catalina.realm.JDBCRealm"
      driverName="org.gjt.mm.mysql.Driver"
   connectionURL="jdbc:mysql://localhost/authority?user=dbuser&amp;amp;password=dbpass"
       userTable="users" userNameCol="user_name" userCredCol="user_pass"
   userRoleTable="user_roles" roleNameCol="role_name"/&gt;</code></pre></div>

<h5>附加条款</h5>

<p>JDBCRealm根据以下规则进行操作：</p>
<ul>
<li>当用户首次尝试访问受保护的资源时，Tomcat将调用<code>authenticate()</code>此方法<code>Realm</code> 。因此，您直接对数据库所做的任何更改（新用户，更改的密码或角色等）都将立即反映出来。</li>
<li>验证用户身份后，将在用户登录期间将用户（及其关联角色）缓存在Tomcat中。（对于基于FORM的身份验证，这意味着直到会话超时或无效；对于BASIC身份验证，这意味着直到用户关闭其浏览器）。缓存的用户<strong>不会</strong>在会话序列化中保存和还原。对于已经通过身份验证的用户，数据库信息的任何更改将<strong>不会</strong>反映，直到该用户下次再次登录。</li>
<li>管理<em>用户</em>和<em>用户角色</em>表中的信息是您自己的应用程序的责任。Tomcat不提供任何内置功能来维护用户和角色。</li>
</ul>

</div></div>


<div class="subsection"><h4 id="DataSourceRealm">数据源领域</h4><div class="text">

<h5>介绍</h5>

<p><strong>DataSourceRealm</strong>是Tomcat的实现<code>Realm</code>接口，该接口在通过名为JDBC DataSource的JNDI访问的关系数据库中查找用户。只要您的数据库结构符合以下要求，就有很大的配置灵活性，可让您适应现有的表名和列名：</p>
<ul>
<li>必须有一个表，下面称为“ <em>用户”</em>表，该表针对该表中的每个有效用户都包含一行<code>Realm</code>应该认识。</li>
<li><em>users</em>表必须至少包含两列（如果您现有的应用程序需要，则可以包含更多列）：<ul>
    <li>Tomcat在用户登录时可以识别的用户名。</li>
    <li>用户登录时Tomcat识别的密码。该值可以是明文形式或摘要形式-有关更多信息，请参见下文。</li>
    </ul></li>
<li>必须有一个表，下面称为<em>用户角色</em>表，其中包含分配给特定用户的每个有效角色的一行。用户具有零个，一个或多个有效角色是合法的。</li>
<li><em>用户角色</em>表必须至少包含两列（如果现有应用程序需要，则可以包含更多列）：<ul>
    <li>Tomcat可以识别的用户名（与<em>用户</em>表中指定的值相同）。</li>
    <li>与此用户关联的有效角色的角色名称。</li>
    </ul></li>
</ul>

<h5>快速开始</h5>

<p>要将Tomcat设置为使用DataSourceRealm，您将需要执行以下步骤：</p>
<ol>
<li>如果尚未这样做，请在数据库中创建符合上述要求的表和列。</li>
<li>配置供Tomcat使用的数据库用户名和密码，该用户名和密码至少具有对上述表的只读访问权限。（Tomcat绝不会尝试写入这些表。）</li>
<li>为数据库配置一个名为JDBC DataSource的JNDI。有关如何配置名为JDBC DataSource的JNDI的信息，请参考<a href="jndi-datasource-examples-howto.html">JNDI DataSource示例方法</a> 。请务必设置<code>Realm</code>的<code>localDataSource</code>属性，具体取决于JNDI数据源的定义位置。</li>
<li>设置一个<code><Realm></code>元素，如下所述<code>$CATALINA_BASE/conf/server.xml</code>文件。</li>
<li>如果Tomcat已在运行，请重新启动它。</li>
</ol>

<h5>领域元素属性</h5>

<p>要配置DataSourceRealm，您将创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>文件， <a href="#Configuring_a_Realm">如上所述</a> 。DataSourceRealm的属性在<a href="config/realm.html">Realm</a>配置文档中定义。</p>

<h5>例</h5>

<p>创建所需表的示例SQL脚本可能类似于以下内容（根据特定数据库的需要调整语法）：</p>
<div class="codeBox"><pre><code>create table users (
  user_name         varchar(15) not null primary key,
  user_pass         varchar(15) not null
);

create table user_roles (
  user_name         varchar(15) not null,
  role_name         varchar(15) not null,
  primary key (user_name, role_name)
);</code></pre></div>

<p>这是一个使用名为“ authority”的MySQL数据库的示例，该数据库已配置上述表，并通过名称为“ java：/ comp / env / jdbc / authority”的JNDI JDBC数据源进行访问。</p>
<div class="codeBox"><pre><code>&lt;Realm className="org.apache.catalina.realm.DataSourceRealm"
   dataSourceName="jdbc/authority"
   userTable="users" userNameCol="user_name" userCredCol="user_pass"
   userRoleTable="user_roles" roleNameCol="role_name"/&gt;</code></pre></div>

<h5>附加条款</h5>

<p>DataSourceRealm根据以下规则进行操作：</p>
<ul>
<li>当用户首次尝试访问受保护的资源时，Tomcat将调用<code>authenticate()</code>此方法<code>Realm</code> 。因此，您直接对数据库所做的任何更改（新用户，更改的密码或角色等）都将立即反映出来。</li>
<li>验证用户身份后，将在用户登录期间将用户（及其关联角色）缓存在Tomcat中。（对于基于FORM的身份验证，这意味着直到会话超时或无效；对于BASIC身份验证，这意味着直到用户关闭其浏览器）。缓存的用户<strong>不会</strong>在会话序列化中保存和还原。对于已经通过身份验证的用户，数据库信息的任何更改将<strong>不会</strong>反映，直到该用户下次再次登录。</li>
<li>管理<em>用户</em>和<em>用户角色</em>表中的信息是您自己的应用程序的责任。Tomcat不提供任何内置功能来维护用户和角色。</li>
</ul>

</div></div>


<div class="subsection"><h4 id="JNDIRealm">JNDIRealm</h4><div class="text">

<h5>介绍</h5>

<p><strong>JNDIRealm</strong>是Tomcat的实现<code>Realm</code>接口，用于在JNDI提供程序（通常是JNDI API类提供的标准LDAP提供程序）访问的LDAP目录服务器中查找用户。该领域支持使用目录进行身份验证的多种方法。</p>

<h6>连接到目录</h6>

<p>领域与目录的连接由<strong>connectionURL</strong>配置属性定义。这是一个URL，其格式由JNDI提供程序定义。通常，它是一个LDAP URL，它指定要连接到的目录服务器的域名，还可以指定所需的根命名上下文的端口号和专有名称（DN）。</p>

<p>如果您有多个提供程序，则可以配置<strong>AlternativeURL</strong> 。如果一个套接字连接不能对供应商在中的<strong>ConnectionURL</strong>做出了将尝试使用<strong>alternateURL。</strong></p>

<p>进行连接以搜索目录并检索用户和角色信息时，领域将使用由<strong>connectionName</strong>和<strong>connectionPassword</strong>属性指定的用户名和密码对目录进行身份验证。如果未指定这些属性，则连接为匿名。在许多情况下，这就足够了。
</p>


<h6>选择用户的目录条目</h6>

<p>每个可以通过身份验证的用户都必须在目录中用一个对应于初始元素的单独条目来表示<code>DirContext</code>由<strong>connectionURL</strong>属性定义。该用户条目必须具有包含用于身份验证的用户名的属性。</p>

<p>用户条目的可分辨名称通常包含用于身份验证的用户名，但对于所有用户而言都是相同的。在这种情况下，可以使用<strong>userPattern</strong>属性指定DN，并用“ {0}”标记应替换用户名的位置。</p>

<p>否则，领域必须搜索目录以找到包含用户名的唯一条目。以下属性配置此搜索：</p>

     <ul>
     <li><strong>userBase-</strong>作为包含用户的子树的基础的条目。如果未指定，则搜索基础是顶级上下文。</li>

     <li><strong>userSubtree-</strong>搜索范围。调成<code>true</code>如果您希望搜索植根于<strong>userBase</strong>条目的整个子树。的默认值<code>false</code>请求仅包括顶层的单层搜索。</li>

     <li><strong>userSearch-</strong>指定替换用户名后要使用的LDAP搜索过滤器的模式。</li>

    </ul>


<h6>验证用户</h6>

<ul>
<li>
<p><b>绑定模式</b></p>

<p>默认情况下，领域通过使用该用户条目的DN和该用户提供的密码绑定到目录来对用户进行身份验证。如果此简单绑定成功，则认为用户已通过身份验证。</p>

<p>出于安全原因，目录可能存储用户密码的摘要，而不是明文版本（有关更多信息，请参见摘要<a href="#Digested_Passwords">密码</a> ）。在这种情况下，作为简单绑定操作的一部分，目录在根据存储的值对其进行验证之前，会自动计算用户提供的明文密码的正确摘要。因此，在绑定模式下，领域不参与摘要处理。<strong>摘要</strong>属性未使用，如果设置，将被忽略。</p>
</li>

<li>
<p><b>比较模式</b></p>
<p>或者，领域可以从目录中检索存储的密码，并将其与用户提供的值进行显式比较。通过将<strong>userPassword</strong>属性设置为包含密码的用户条目中目录属性的名称来配置此模式。</p>

<p>比较模式有一些缺点。首先，必须配置<strong>connectionName</strong>和<strong>connectionPassword</strong>属性，以允许领域读取目录中用户的密码。出于安全原因，通常不希望这样做；实际上，许多目录实现甚至都不允许目录管理器读取这些密码。此外，领域必须自己处理密码摘要，包括使用的算法的变化形式以及在目录中表示密码哈希的方式。但是，该领域有时可能需要访问存储的密码，例如，以支持HTTP摘要访问身份验证（RFC 2069）。（请注意，如上所述，HTTP摘要认证不同于密码摘要在用户信息存储库中的存储）。
</p>
</li>
</ul>

<h6>为用户分配角色</h6>

<p>目录领域支持两种方法来表示目录中的角色：</p>

<ul>
<li>
<p><b>充当显式目录条目</b></p>

<p>角色可以由显式目录条目表示。角色条目通常是LDAP组条目，其一个属性包含该角色的名称，另一个属性的值是该角色中用户的专有名称或用户名。以下属性配置目录搜索以查找与已认证用户关联的角色的名称：</p>

<ul>
<li><strong>roleBase-</strong>角色搜索的基本条目。如果未指定，则搜索基础是顶级目录上下文。</li>

<li><strong>roleSubtree-</strong>搜索范围。调成<code>true</code>如果您想搜索植根于<code>roleBase</code>条目。的默认值<code>false</code>请求单级搜索，仅包括顶级搜索。</li>

<li><strong>roleSearch-</strong>用于选择角色条目的LDAP搜索过滤器。它可选地包括已认证用户的模式替换“ {0}”（用于专有名称）和/或“ {1}”（用于用户名）和/或“ {2}”（用于来自用户目录条目的属性）。使用<strong>userRoleAttribute</strong>指定提供“ {2}”值的属性的名称。</li>

<li><strong>roleName-</strong>角色条目中的属性，其中包含该角色的名称。</li>

<li><strong>roleNested-</strong>启用嵌套角色。调成<code>true</code>如果要在角色中嵌套角色。如果已配置，则将递归地尝试每个新发现的roleName和专有名称，以进行新的角色搜索。默认值为<code>false</code> 。</li>

</ul>

</li>
</ul>

<ul>
<li>
<p><b>角色作为用户条目的属性</b></p>

<p>角色名称也可以作为属性的值保存在用户的目录条目中。使用<strong>userRoleName</strong>指定此属性的名称。</p>

</li>
</ul>
<p>可以使用两种方法来组合角色表示。</p>

<h5>快速开始</h5>

<p>要将Tomcat设置为使用JNDIRealm，您将需要执行以下步骤：</p>
<ol>
<li>确保您的目录服务器配置了符合上述要求的架构。</li>
<li>如果需要，请配置用户名和密码以供Tomcat使用，该用户名和密码具有对上述信息的只读访问权限。（Tomcat绝不会尝试修改此信息。）</li>
<li>设置一个<code><Realm></code>元素，如下所述<code>$CATALINA_BASE/conf/server.xml</code>文件。</li>
<li>如果Tomcat已在运行，请重新启动它。</li>
</ol>

<h5>领域元素属性</h5>

<p>要配置JNDIRealm，您将创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>文件， <a href="#Configuring_a_Realm">如上所述</a> 。JNDIRealm的属性在<a href="config/realm.html">Realm</a>配置文档中定义。</p>

<h5>例</h5>

<p>在目录服务器中创建适当的模式超出了本文档的范围，因为它对于每个目录服务器实现都是唯一的。在下面的示例中，我们假设您使用的是OpenLDAP目录服务器（版本2.0.11或更高版本），可以从<a href="https://www.openldap.org">https://www.openldap.org</a>下载。假设你的<code>slapd.conf</code>文件包含以下设置（以及其他设置）：</p>
<div class="codeBox"><pre><code>database ldbm
suffix dc="mycompany",dc="com"
rootdn "cn=Manager,dc=mycompany,dc=com"
rootpw secret</code></pre></div>

<p>我们将假设<code>connectionURL</code>目录服务器与Tomcat在同一台计算机上运行。有关配置和使用JNDI LDAP提供程序的更多信息，请参见<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jndi/index.html">http://docs.oracle.com/javase/7/docs/technotes/guides/jndi/index.html</a> 。</p>

<p>接下来，假定此目录服务器已填充如下所示的元素（采用LDIF格式）：</p>

<div class="codeBox"><pre><code># Define top-level entry
dn: dc=mycompany,dc=com
objectClass: dcObject
dc:mycompany

# Define an entry to contain people
# searches for users are based on this entry
dn: ou=people,dc=mycompany,dc=com
objectClass: organizationalUnit
ou: people

# Define a user entry for Janet Jones
dn: uid=jjones,ou=people,dc=mycompany,dc=com
objectClass: inetOrgPerson
uid: jjones
sn: jones
cn: janet jones
mail: j.jones@mycompany.com
userPassword: janet

# Define a user entry for Fred Bloggs
dn: uid=fbloggs,ou=people,dc=mycompany,dc=com
objectClass: inetOrgPerson
uid: fbloggs
sn: bloggs
cn: fred bloggs
mail: f.bloggs@mycompany.com
userPassword: fred

# Define an entry to contain LDAP groups
# searches for roles are based on this entry
dn: ou=groups,dc=mycompany,dc=com
objectClass: organizationalUnit
ou: groups

# Define an entry for the "tomcat" role
dn: cn=tomcat,ou=groups,dc=mycompany,dc=com
objectClass: groupOfUniqueNames
cn: tomcat
uniqueMember: uid=jjones,ou=people,dc=mycompany,dc=com
uniqueMember: uid=fbloggs,ou=people,dc=mycompany,dc=com

# Define an entry for the "role1" role
dn: cn=role1,ou=groups,dc=mycompany,dc=com
objectClass: groupOfUniqueNames
cn: role1
uniqueMember: uid=fbloggs,ou=people,dc=mycompany,dc=com</code></pre></div>

<p>一个例子<code>Realm</code>如上所述配置的OpenLDAP目录服务器的元素可能看起来像这样，假设用户使用其uid（例如jjones）登录应用程序，并且匿名连接足以搜索目录并检索角色信息：</p>

<div class="codeBox"><pre><code>&lt;Realm   className="org.apache.catalina.realm.JNDIRealm"
     connectionURL="ldap://localhost:389"
       userPattern="uid={0},ou=people,dc=mycompany,dc=com"
          roleBase="ou=groups,dc=mycompany,dc=com"
          roleName="cn"
        roleSearch="(uniqueMember={0})"
/&gt;</code></pre></div>

<p>使用此配置，领域将通过将用户名替换为用户名来确定用户的专有名称。 <code>userPattern</code> ，通过使用此DN和从用户收到的密码绑定到目录进行身份验证，然后搜索目录以查找用户的角色。</p>

<p>现在，假设希望用户在登录时输入其电子邮件地址而不是用户ID。在这种情况下，领域必须在目录中搜索用户的条目。（当用户条目保存在可能对应于不同组织单位或公司位置的多个子树中时，搜索也是必要的）。</p>

<p>此外，假设除了组条目外，您还想使用用户条目的属性来担任角色。现在，Janet Jones的条目可能如下所示：</p>

<div class="codeBox"><pre><code>dn: uid=jjones,ou=people,dc=mycompany,dc=com
objectClass: inetOrgPerson
uid: jjones
sn: jones
cn: janet jones
mail: j.jones@mycompany.com
memberOf: role2
memberOf: role3
userPassword: janet</code></pre></div>

<p>此领域配置将满足新的要求：</p>

<div class="codeBox"><pre><code>&lt;Realm   className="org.apache.catalina.realm.JNDIRealm"
     connectionURL="ldap://localhost:389"
          userBase="ou=people,dc=mycompany,dc=com"
        userSearch="(mail={0})"
      userRoleName="memberOf"
          roleBase="ou=groups,dc=mycompany,dc=com"
          roleName="cn"
        roleSearch="(uniqueMember={0})"
/&gt;</code></pre></div>

<p>现在，当珍妮特·琼斯（Janet Jones）以“ j.jones@mycompany.com”登录时，该领域在目录中搜索一个唯一条目，并将该值作为其邮件属性，并尝试将其绑定到该目录。 <code>uid=jjones,ou=people,dc=mycompany,dc=com</code>使用给定的密码。如果身份验证成功，则会为她分配三个角色：“ role2”和“ role3”，这是她的目录条目中“ memberOf”属性的值；以及“ tomcat”，这是该目录唯一组条目中“ cn”属性的值。她是会员。</p>

<p>最后，要通过从目录中检索密码并在领域中进行本地比较来验证用户身份，可以使用如下领域配置：</p>

<div class="codeBox"><pre><code>&lt;Realm   className="org.apache.catalina.realm.JNDIRealm"
    connectionName="cn=Manager,dc=mycompany,dc=com"
connectionPassword="secret"
     connectionURL="ldap://localhost:389"
      userPassword="userPassword"
       userPattern="uid={0},ou=people,dc=mycompany,dc=com"
          roleBase="ou=groups,dc=mycompany,dc=com"
          roleName="cn"
        roleSearch="(uniqueMember={0})"
/&gt;</code></pre></div>

<p>然而，如上所述，通常优选用于认证的默认绑定模式。</p>

<h5>附加条款</h5>

<p>JNDIRealm根据以下规则进行操作：</p>
<ul>
<li>当用户首次尝试访问受保护的资源时，Tomcat将调用<code>authenticate()</code>此方法<code>Realm</code> 。因此，您对目录所做的任何更改（新用户，更改的密码或角色等）都将立即反映出来。</li>
<li>验证用户身份后，将在用户登录期间将用户（及其关联角色）缓存在Tomcat中。（对于基于FORM的身份验证，这意味着直到会话超时或无效；对于BASIC身份验证，这意味着直到用户关闭其浏览器）。缓存的用户<strong>不会</strong>在会话序列化中保存和还原。对于已经过身份验证的用户，目录信息的任何更改将<strong>不会</strong>反映，直到该用户下次再次登录。</li>
<li>在目录服务器中管理信息是您自己的应用程序的责任。Tomcat不提供任何内置功能来维护用户和角色。</li>
</ul>

</div></div>


<div class="subsection"><h4 id="UserDatabaseRealm">UserDatabaseRealm</h4><div class="text">

<h5>介绍</h5>

<p><strong>UserDatabaseRealm</strong>是Tomcat的实现<code>Realm</code>使用JNDI资源存储用户信息的接口。默认情况下，JNDI资源由XML文件支持。它不适用于大规模生产。在启动时，UserDatabaseRealm从XML文档中加载有关所有用户及其相应角色的信息（默认情况下，该文档是从<code>$CATALINA_BASE/conf/tomcat-users.xml</code> ）。用户，他们的密码及其角色都可以动态地进行编辑，通常是通过JMX进行。更改可能会保存并反映在XML文件中。</p>

<h5>领域元素属性</h5>

<p>要配置UserDatabaseRealm，您将创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>文件， <a href="#Configuring_a_Realm">如上所述</a> 。UserDatabaseRealm的属性在<a href="config/realm.html">Realm</a>配置文档中定义。</p>

<h5>用户文件格式</h5>

<p>用户文件使用与<a href="#MemoryRealm">MemoryRealm</a>相同的格式。</p>

<h5>例</h5>

<p>Tomcat的默认安装是通过嵌套在UserDatabaseRealm中的UserDatabaseRealm配置的<code><Engine></code>元素，以便将其应用于所有虚拟主机和Web应用程序。默认内容<code>conf/tomcat-users.xml</code>文件是：</p>
<div class="codeBox"><pre><code>&lt;tomcat-users&gt;
  &lt;user username="tomcat" password="tomcat" roles="tomcat" /&gt;
  &lt;user username="role1"  password="tomcat" roles="role1"  /&gt;
  &lt;user username="both"   password="tomcat" roles="tomcat,role1" /&gt;
&lt;/tomcat-users&gt;</code></pre></div>

<h5>附加条款</h5>

<p>UserDatabaseRealm根据以下规则进行操作：</p>
<ul>
<li>Tomcat首次启动时，它将从用户文件中加载所有定义的用户及其相关信息。在重新启动Tomcat之前， <strong>无法</strong>识别对此文件中的数据所做的更改。可以通过UserDatabase资源进行更改。Tomcat为此提供了可通过JMX访问的MBean。</li>
<li>当用户首次尝试访问受保护的资源时，Tomcat将调用<code>authenticate()</code>此方法<code>Realm</code> 。</li>
<li>验证用户身份后，将在用户登录期间将用户（及其关联角色）缓存在Tomcat中。（对于基于FORM的身份验证，这意味着直到会话超时或无效；对于BASIC身份验证，这意味着直到用户关闭其浏览器）。缓存的用户<strong>不会</strong>在会话序列化中保存和还原。</li>
</ul>


</div></div>


<div class="subsection"><h4 id="MemoryRealm">内存领域</h4><div class="text">

<h5>介绍</h5>

<p><strong>MemoryRealm</strong>是Tomcat的简单演示实现<code>Realm</code>接口。它不是设计用于生产用途。在启动时，MemoryRealm从XML文档中加载有关所有用户及其相应角色的信息（默认情况下，该文档是从<code>$CATALINA_BASE/conf/tomcat-users.xml</code> ）。在重新启动Tomcat之前，无法识别对此文件中数据的更改。</p>

<h5>领域元素属性</h5>

<p>要配置MemoryRealm，您将创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>文件， <a href="#Configuring_a_Realm">如上所述</a> 。MemoryRealm的属性在<a href="config/realm.html">Realm</a>配置文档中定义。</p>

<h5>用户文件格式</h5>

<p>用户文件（默认情况下， <code>conf/tomcat-users.xml</code>必须是带有根元素的XML文档<code><tomcat-users></code> 。嵌套在根元素中的是<code><user></code>每个有效用户的元素，由以下属性组成：</p>
<ul>
<li>name-该用户必须登录的用户<strong>名</strong> 。</li>
<li><strong>密码</strong> -该用户必须使用的登录密码（如果<code>digest</code>未在上设置属性<code><Realm></code>元素，或按照<a href="#Digested_Passwords">此处的</a>说明进行适当消化）。</li>
<li><strong>角色</strong> -与此用户关联的角色名称的逗号分隔列表。</li>
</ul>

<h5>附加条款</h5>

<p>MemoryRealm根据以下规则进行操作：</p>
<ul>
<li>Tomcat首次启动时，它将从用户文件中加载所有定义的用户及其相关信息。在重新启动Tomcat之前，将<strong>无法</strong>识别对此文件中数据的更改。</li>
<li>当用户首次尝试访问受保护的资源时，Tomcat将调用<code>authenticate()</code>此方法<code>Realm</code> 。</li>
<li>验证用户身份后，将在用户登录期间将用户（及其关联角色）缓存在Tomcat中。（对于基于FORM的身份验证，这意味着直到会话超时或无效；对于BASIC身份验证，这意味着直到用户关闭其浏览器）。缓存的用户<strong>不会</strong>在会话序列化中保存和还原。</li>
<li>管理用户文件中的信息是您的应用程序的责任。Tomcat不提供任何内置功能来维护用户和角色。</li>
</ul>


</div></div>


<div class="subsection"><h4 id="JAASRealm">JAASRealm</h4><div class="text">

<h5>介绍</h5>

        <p><strong>JAASRealm</strong>是Tomcat的实现<code>Realm</code>通过Java身份验证和授权服务（JAAS）框架对用户进行身份验证的接口，该框架现在作为标准Java SE API的一部分提供。</p>
        <p>使用JAASRealm，使开发人员能够将几乎所有可能的安全领域与Tomcat的CMA相结合。</p>
        <p>JAASRealm是基于<a href="https://www.jcp.org/en/jsr/detail?id=196">JCP规范请求196</a>的基于JAAS的J2EE v1.4的基于JAAS的J2EE身份验证框架的Tomcat的原型，以增强容器管理的安全性并促进实现与容器无关的“可插拔”身份验证机制。
        </p>
        <p>基于JAAS登录模块和主体（请参阅<code>javax.security.auth.spi.LoginModule</code>和<code>javax.security.Principal</code> ），则可以开发自己的安全性机制或包装另一种第三方机制，以与Tomcat实施的CMA集成。
        </p>

        <h5>快速开始</h5>
        <p>要将Tomcat设置为将JAASRealm与您自己的JAAS登录模块一起使用，您将需要执行以下步骤：</p>
        <ol>
          <li>根据JAAS编写您自己的LoginModule，User和Role类（请参阅<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html">《 JAAS认证教程》</a>和<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/JAASLMDevGuide.html">《 JAAS登录模块开发人员指南》</a> ），以由JAAS登录上下文（ <code>javax.security.auth.login.LoginContext</code> ）在开发LoginModule时，请注意，JAASRealm是内置的<code>CallbackHandler</code>只认出<code>NameCallback</code>和<code>PasswordCallback</code>现在。
          </li>
          <li>尽管在JAAS中未指定，但您应该创建单独的类来区分用户和角色，并扩展<code>javax.security.Principal</code> ，以便Tomcat可以判断从登录模块返回的Principal是用户，哪些是角色（请参阅<code>org.apache.catalina.realm.JAASRealm</code> ）。无论如何，返回的第一个委托人<em>始终</em>被视为用户委托人。
          </li>
          <li>将已编译的类放在Tomcat的类路径上</li>
          <li>为Java设置一个login.config文件（请参阅<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/LoginConfigFile.html">JAAS LoginConfig文件</a> ），并通过指定其在JVM中的位置（例如通过设置环境变量）来告诉Tomcat在哪里找到它：<code>JAVA_OPTS=$JAVA_OPTS -Djava.security.auth.login.config==$CATALINA_BASE/conf/jaas.config</code></li>

          <li>在web.xml中为要保护的资源配置安全约束</li>
          <li>在server.xml中配置JAASRealm模块</li>
          <li>如果Tomcat已在运行，请重新启动它。</li>
        </ol>
        <h5>领域元素属性</h5>
        <p>要按照上述步骤6配置JAASRealm，请创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>在您的文件<code><Engine></code>节点。JAASRealm的属性在<a href="config/realm.html">Realm</a>配置文档中定义。</p>

<h5>例</h5>

<p>这是一个有关server.xml代码片段外观的示例。</p>

<div class="codeBox"><pre><code>&lt;Realm className="org.apache.catalina.realm.JAASRealm"
                appName="MyFooRealm"
    userClassNames="org.foobar.realm.FooUser"
     roleClassNames="org.foobar.realm.FooRole"/&gt;</code></pre></div>

<p>登录模块负责创建和保存代表用户主体的User和Role对象（ <code>javax.security.auth.Subject</code> ）。如果您的登录模块未创建用户对象，但也未引发登录异常，则Tomcat CMA将中断，您将留在http：// localhost：8080 / myapp / j_security_check URI或其他某个位置未指定位置。</p>

        <p>JAAS方法的灵活性有两个方面：</p>
        <ul>
          <li>您可以在自己的登录模块中进行后台所需的任何处理。</li>
          <li>您可以通过更改配置并重新启动服务器来插入完全不同的LoginModule，而无需对应用程序进行任何代码更改。</li>
        </ul>

        <h5>附加条款</h5>
        <ul>
          <li>当用户首次尝试访问受保护的资源时，Tomcat将调用<code>authenticate()</code>此方法<code>Realm</code> 。因此，您在安全性机制中直接进行的任何更改（新用户，更改的密码或角色等）都将立即反映出来。</li>
          <li>验证用户身份后，将在用户登录期间将用户（及其关联角色）缓存在Tomcat中。对于基于FORM的身份验证，这意味着直到会话超时或无效；对于BASIC身份验证，这意味着直到用户关闭其浏览器。对已验证用户的安全性信息所做的任何更改将<strong>不会</strong>反映，直到该用户下次再次登录。</li>
          <li>和其他一样<code>Realm</code>实施中，如果<code><Realm></code>元素在<code>server.xml</code>包含一个<code>digest</code>属性; JAASRealm的<code>CallbackHandler</code>在将密码传回到<code>LoginModule</code></li>
        </ul>

</div></div>


<div class="subsection"><h4 id="CombinedRealm">合并领域</h4><div class="text">

    <h5>介绍</h5>

    <p><strong>CombinedRealm</strong>是Tomcat的实现<code>Realm</code>通过一个或多个子领域对用户进行身份验证的界面。</p>

    <p>使用CombinedRealm使开发人员能够组合相同或不同类型的多个Realm。这可以用于针对不同的来源进行身份验证，以防万一一个Realm失败而退回，或者用于需要多个Realm的任何其他目的。</p>

    <p>子领域是通过嵌套定义的<code>Realm</code>里面的元素<code>Realm</code>定义CombinedRealm的元素。将尝试对每个认证<code>Realm</code>按照它们列出的顺序。针对任何领域的身份验证就足以对用户进行身份验证。</p>

    <h5>领域元素属性</h5>
    <p>要配置CombinedRealm，请创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>在您的文件<code><Engine></code>要么<code><Host></code> 。您也可以嵌套在<code><Context></code>一个节点<code>context.xml</code>文件。</p>

<h5>例</h5>

<p>这是一个有关如何使用UserDatabase领域和DataSource领域的server.xml代码片段的示例。</p>

<div class="codeBox"><pre><code>&lt;Realm className="org.apache.catalina.realm.CombinedRealm" &gt;
   &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
             resourceName="UserDatabase"/&gt;
   &lt;Realm className="org.apache.catalina.realm.DataSourceRealm"
             dataSourceName="jdbc/authority"
             userTable="users" userNameCol="user_name" userCredCol="user_pass"
             userRoleTable="user_roles" roleNameCol="role_name"/&gt;
&lt;/Realm&gt;</code></pre></div>

</div></div>

<div class="subsection"><h4 id="LockOutRealm">锁定领域</h4><div class="text">

    <h5>介绍</h5>

    <p><strong>LockOutRealm</strong>是Tomcat的实现<code>Realm</code>扩展CombinedRealm的接口，以提供锁定功能，以在给定的时间内失败的身份验证尝试过多时提供用户锁定机制。</p>

    <p>为了确保正确操作，此领域中存在合理程度的同步。</p>

    <p>该领域不需要修改基础领域或相关的用户存储机制。它通过记录所有失败的登录（包括那些不存在的用户的登录）来实现此目的。为了防止DOS通过考虑向无效用户发出请求（从而导致此高速缓存增长），限制了身份验证失败的用户列表的大小。</p>

    <p>子领域是通过嵌套定义的<code>Realm</code>里面的元素<code>Realm</code>定义LockOutRealm的元素。将尝试对每个认证<code>Realm</code>按照它们列出的顺序。针对任何领域的身份验证就足以对用户进行身份验证。</p>

    <h5>领域元素属性</h5>
    <p>要配置LockOutRealm，请创建一个<code><Realm></code>元素并将其嵌套在您的<code>$CATALINA_BASE/conf/server.xml</code>在您的文件<code><Engine></code>要么<code><Host></code> 。您也可以嵌套在<code><Context></code>一个节点<code>context.xml</code>文件。LockOutRealm的属性在<a href="config/realm.html">Realm</a>配置文档中定义。</p>

<h5>例</h5>

<p>这是您的server.xml代码片段应如何向UserDatabase领域添加锁定功能的示例。</p>

<div class="codeBox"><pre><code>&lt;Realm className="org.apache.catalina.realm.LockOutRealm" &gt;
   &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"
             resourceName="UserDatabase"/&gt;
&lt;/Realm&gt;</code></pre></div>

</div></div>

</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="./comments.html">这里</a>解释<a href="./comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>