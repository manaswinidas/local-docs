<html lang="zh-Hans" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="./images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9（9.0.21）-JNDI数据源方法</title><meta name="author" content="Les Hughes"><meta name="author" content="David Haraburda"><meta name="author" content="Glenn Nielsen"><meta name="author" content="Yoav Shapira"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/jndi-datasource-examples-howto">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script></head><body ><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="./images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="./images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="index.html">文件首页</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>用户指南</h2><ul><li><a href="introduction.html">1）简介</a></li><li><a href="setup.html">2）设定</a></li><li><a href="appdev/index.html">3）第一个webapp</a></li><li><a href="deployer-howto.html">4）部署者</a></li><li><a href="manager-howto.html">5）经理</a></li><li><a href="host-manager-howto.html">6）主机管理员</a></li><li><a href="realm-howto.html">7）领域和AAA</a></li><li><a href="security-manager-howto.html">8）安全经理</a></li><li><a href="jndi-resources-howto.html">9）JNDI资源</a></li><li><a href="jndi-datasource-examples-howto.html">10）JDBC数据源</a></li><li><a href="class-loader-howto.html">11）类加载</a></li><li><a href="jasper-howto.html">12）JSP</a></li><li><a href="ssl-howto.html">13）SSL / TLS</a></li><li><a href="ssi-howto.html">14）SSI</a></li><li><a href="cgi-howto.html">15）CGI</a></li><li><a href="proxy-howto.html">16）代理支持</a></li><li><a href="mbeans-descriptors-howto.html">17）MBean描述符</a></li><li><a href="default-servlet.html">18）默认Servlet</a></li><li><a href="cluster-howto.html">19）聚类</a></li><li><a href="balancer-howto.html">20）负载均衡器</a></li><li><a href="connectors.html">21）连接器</a></li><li><a href="monitoring.html">22）监控与管理</a></li><li><a href="logging.html">23）记录</a></li><li><a href="apr.html">24）APR /本地</a></li><li><a href="virtual-hosting-howto.html">25）虚拟主机</a></li><li><a href="aio.html">26）高级IO</a></li><li><a href="extras.html">27）附加组件</a></li><li><a href="maven-jars.html">28）行刑</a></li><li><a href="security-howto.html">29）安全注意事项</a></li><li><a href="windows-service-howto.html">30）Windows服务</a></li><li><a href="windows-auth-howto.html">31）Windows身份验证</a></li><li><a href="jdbc-pool.html">32）Tomcat的JDBC池</a></li><li><a href="web-socket-howto.html">33）WebSocket</a></li><li><a href="rewrite.html">34）改写</a></li></ul></div><div><h2>参考</h2><ul><li><a href="RELEASE-NOTES.txt">发行说明</a></li><li><a href="config/index.html">组态</a></li><li><a href="api/index.html">Tomcat Java文档</a></li><li><a href="servletapi/index.html">Servlet Java文档</a></li><li><a href="jspapi/index.html">JSP 2.3 Java文档</a></li><li><a href="elapi/index.html">EL 3.0 Java文档</a></li><li><a href="websocketapi/index.html">WebSocket 1.1 Java文档</a></li><li><a href="https://tomcat.apache.org/connectors-doc/">JK 1.2文档</a></li></ul></div><div><h2>Apache Tomcat开发</h2><ul><li><a href="building.html">建造</a></li><li><a href="changelog.html">变更日志</a></li><li><a href="https://wiki.apache.org/tomcat/TomcatVersions">状态</a></li><li><a href="developers.html">开发者</a></li><li><a href="architecture/index.html">建筑</a></li><li><a href="funcspecs/index.html">功能规格。</a></li><li><a href="tribes/introduction.html">部族</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>JNDI数据源方法</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Introduction">介绍</a></li><li><a href="#DriverManager,_the_service_provider_mechanism_and_memory_leaks">DriverManager，服务提供者机制和内存泄漏</a></li><li><a href="#Database_Connection_Pool_(DBCP_2)_Configurations">数据库连接池（DBCP 2）配置</a><ol><li><a href="#Installation">安装</a></li><li><a href="#Preventing_database_connection_pool_leaks">防止数据库连接池泄漏</a></li><li><a href="#MySQL_DBCP_2_Example">MySQL DBCP 2示例</a></li><li><a href="#Oracle_8i,_9i_&_10g">Oracle 8i，9i和10g</a></li><li><a href="#PostgreSQL">PostgreSQL的</a></li></ol></li><li><a href="#Non-DBCP_Solutions">非DBCP解决方案</a></li><li><a href="#Oracle_8i_with_OCI_client">带有OCI客户端的Oracle 8i</a><ol><li><a href="#Oracle_8i_with_OCI_client/Introduction">介绍</a></li><li><a href="#Putting_it_all_together">放在一起</a></li></ol></li><li><a href="#Common_Problems">常见问题</a><ol><li><a href="#Intermittent_Database_Connection_Failures">间歇性数据库连接失败</a></li><li><a href="#Random_Connection_Closed_Exceptions">随机连接封闭异常</a></li><li><a href="#Context_versus_GlobalNamingResources">上下文与GlobalNamingResources</a></li><li><a href="#JNDI_Resource_Naming_and_Realm_Interaction">JNDI资源命名和领域交互</a></li></ol></li></ul>
</div><h3 id="Introduction">介绍</h3><div class="text">

<p>JNDI-Resources-HOWTO中广泛介绍了JNDI数据源配置。但是，来自<code>tomcat-user</code>已经表明，单个配置的细节可能非常棘手。</p>

<p>然后是一些已发布到tomcat-user的流行数据库的示例配置，以及一些有关db使用的常规提示。</p>

<p>您应该知道，由于这些说明是从配置和/或反馈到<code>tomcat-user</code> YMMV :-)。如果您有其他可能受到广大受众欢迎的经过测试的配置，或者您认为我们仍然可以改进此部分，请告诉我们。</p>

<p>
<b>请注意，由于Tomcat 7.x和Tomcat 8.x使用不同版本的Apache Commons DBCP库，因此JNDI资源配置有所不同。</b>  您很可能需要修改旧的JNDI资源配置以匹配下面示例中的语法，以使其在Tomcat 9中工作。有关详细信息，请参见《 <a href="https://tomcat.apache.org/migration.html">Tomcat迁移指南</a> 》。
</p>

<p>另外，请注意，一般而言，特别是本教程，JNDI DataSource配置都假定您已阅读并理解了<a href="config/context.html">Context</a>和<a href="config/host.html">Host</a>配置参考，包括后一参考中有关自动应用程序部署的部分。
</p>
</div><h3 id="DriverManager,_the_service_provider_mechanism_and_memory_leaks">DriverManager，服务提供者机制和内存泄漏</h3><div class="text">

<p><code>java.sql.DriverManager</code>支持<a href="http://docs.oracle.com/javase/6/docs/api/index.html?java/sql/DriverManager.html">服务提供者</a>机制。此功能是通过提供一个<code>META-INF/services/java.sql.Driver</code>该文件会被自动发现，加载和注册，从而使您无需在创建JDBC连接之前显式加载数据库驱动程序。但是，对于servlet容器环境，该实现在所有Java版本中都基本中断。问题是<code>java.sql.DriverManager</code>只会扫描一次驱动程序。</p>

<p>Apache Tomcat随附的<a href="config/listeners.html">JRE内存泄漏防护侦听器</a>通过在Tomcat启动期间触发驱动程序扫描来解决此问题。默认情况下启用。这意味着将只扫描公共类加载器及其父级可见的库，以查找数据库驱动程序。这包括<code>$CATALINA_HOME/lib</code> ， <code>$CATALINA_BASE/lib</code> ，类路径以及（在JRE支持的地方）认可目录。打包在Web应用程序中的驱动程序（在<code>WEB-INF/lib</code> ）和共享类加载器（已配置的位置）中将不可见，也不会自动加载。如果要考虑禁用此功能，请注意，扫描将由使用JDBC的第一个Web应用程序触发，从而导致在重新加载该Web应用程序以及其他依赖此功能的Web应用程序时失败。
</p>

<p>因此，Web应用程序中具有数据库驱动程序<code>WEB-INF/lib</code>目录不能依赖服务提供者机制，而应显式注册驱动程序。</p>

<p>中的驱动程序列表<code>java.sql.DriverManager</code>也是已知的内存泄漏源。Web应用程序停止时，必须注销该Web应用程序注册的所有驱动程序。当Web应用程序停止时，Tomcat将尝试自动发现并注销由Web应用程序类加载器加载的所有JDBC驱动程序。但是，期望应用程序通过<code>ServletContextListener</code> 。
</p>

</div><h3 id="Database_Connection_Pool_(DBCP_2)_Configurations">数据库连接池（DBCP 2）配置</h3><div class="text">

<p>Apache Tomcat中的默认数据库连接池实现依赖于<a href="https://commons.apache.org/">Apache Commons</a>项目中的库。使用以下库：</p>

<ul>
<li>公用DBCP 2</li>
<li>公共游泳池2</li>
</ul>

<p>这些库位于单个JAR中，网址为<code>$CATALINA_HOME/lib/tomcat-dbcp.jar</code> 。但是，仅包括连接池所需的类，并且已对包进行重命名以避免干扰应用程序。
</p>

<p>DBCP 2提供了对JDBC 4.1的支持。</p>

<div class="subsection"><h4 id="Installation">安装</h4><div class="text">

<p>有关配置参数的完整列表，请参见<a href="https://commons.apache.org/dbcp/configuration.html">DBCP 2文档</a> 。
</p>

</div></div>

<div class="subsection"><h4 id="Preventing_database_connection_pool_leaks">防止数据库连接池泄漏</h4><div class="text">

<p>数据库连接池创建和管理与数据库的连接池。回收和重用数据库的现有连接比打开新连接更有效。
</p>

<p>连接池存在一个问题。Web应用程序必须显式关闭ResultSet的，Statement的和Connection的。Web应用程序无法关闭这些资源可能导致它们再也无法重用，即数据库连接池“泄漏”。如果没有更多可用连接，最终可能会导致Web应用程序数据库连接失败。</p>

<p>有一个解决此问题的方法。可以将Apache Commons DBCP 2配置为跟踪和恢复这些废弃的数据库连接。它不仅可以恢复它们，还可以为打开这些资源而从未关闭它们的代码生成堆栈跟踪。</p>

<p>要配置DBCP 2数据源，以便删除并回收废弃的数据库连接，请将以下一个或两个属性添加到<code>Resource</code> DBCP 2数据源的配置：</p>
<div class="codeBox"><pre><code>removeAbandonedOnBorrow=true</code></pre></div>
<div class="codeBox"><pre><code>removeAbandonedOnMaintenance=true</code></pre></div>
<p>这两个属性的默认值为<code>false</code> 。注意<code>removeAbandonedOnMaintenance</code>除非通过设置启用池维护，否则无效<code>timeBetweenEvictionRunsMillis</code>为正值。有关这些属性的完整文档，请参阅<a href="https://commons.apache.org/dbcp/configuration.html">DBCP 2文档</a> 。
</p>

<p>使用<code>removeAbandonedTimeout</code>该属性设置数据库连接在被视为放弃之前空闲的秒数。
</p>

<div class="codeBox"><pre><code>removeAbandonedTimeout="60"</code></pre></div>

<p>删除废弃连接的默认超时为300秒。
</p>

<p>的<code>logAbandoned</code>可以将属性设置为<code>true</code>如果要DBCP 2记录放弃了数据库连接资源的代码的堆栈跟踪。
</p>
<div class="codeBox"><pre><code>logAbandoned="true"</code></pre></div>
<p>默认是<code>false</code> 。
</p>

</div></div>

<div class="subsection"><h4 id="MySQL_DBCP_2_Example">MySQL DBCP 2示例</h4><div class="text">

<h5>0。介绍</h5>
<p>据报告可以正常工作的<a href="https://www.mysql.com/products/mysql/index.html">MySQL</a>和JDBC驱动程序版本：</p>
<ul>
<li>MySQL 3.23.47，使用InnoDB的MySQL 3.23.47，MySQL 3.23.58，MySQL 4.0.1alpha</li>
<li><a href="https://www.mysql.com/products/connector-j">Connector / J</a> 3.0.11稳定（官方JDBC驱动程序）</li>
<li><a href="http://mmmysql.sourceforge.net">mm.mysql</a> 2.0.14（旧的第三方JDBC驱动程序）</li>
</ul>

<p>在继续之前，请不要忘记将JDBC驱动程序的jar复制到<code>$CATALINA_HOME/lib</code> 。</p>

<h5>1。MySQL配置</h5>
<p>确保您遵循这些说明，否则会引起问题。
</p>

<p>创建一个新的测试用户，一个新的数据库和一个测试表。您的MySQL用户<strong>必须</strong>分配密码。如果尝试使用空密码连接，驱动程序将失败。
</p>
<div class="codeBox"><pre><code>mysql&gt; GRANT ALL PRIVILEGES ON *.* TO javauser@localhost
    -&gt;   IDENTIFIED BY 'javadude' WITH GRANT OPTION;
mysql&gt; create database javatest;
mysql&gt; use javatest;
mysql&gt; create table testdata (
    -&gt;   id int not null auto_increment primary key,
    -&gt;   foo varchar(25),
    -&gt;   bar int);</code></pre></div>
<blockquote>
<strong>注意：</strong>测试完成后，应删除上述用户！
</blockquote>

<p>接下来，将一些测试数据插入到testdata表中。
</p>
<div class="codeBox"><pre><code>mysql&gt; insert into testdata values(null, 'hello', 12345);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from testdata;
+----+-------+-------+
| ID | FOO   | BAR   |
+----+-------+-------+
|  1 | hello | 12345 |
+----+-------+-------+
1 row in set (0.00 sec)

mysql&gt;</code></pre></div>

<h5>2。上下文配置</h5>
<p>通过将资源的声明添加到<a href="config/context.html">Context中，</a>在Tomcat中配置JNDI数据源。</p>
<p>例如：</p>
<div class="codeBox"><pre><code>&lt;Context&gt;

    &lt;!-- maxTotal: Maximum number of database connections in pool. Make sure you
         configure your mysqld max_connections large enough to handle
         all of your db connections. Set to -1 for no limit.
         --&gt;

    &lt;!-- maxIdle: Maximum number of idle database connections to retain in pool.
         Set to -1 for no limit.  See also the DBCP 2 documentation on this
         and the minEvictableIdleTimeMillis configuration parameter.
         --&gt;

    &lt;!-- maxWaitMillis: Maximum time to wait for a database connection to become available
         in ms, in this example 10 seconds. An Exception is thrown if
         this timeout is exceeded.  Set to -1 to wait indefinitely.
         --&gt;

    &lt;!-- username and password: MySQL username and password for database connections  --&gt;

    &lt;!-- driverClassName: Class name for the old mm.mysql JDBC driver is
         org.gjt.mm.mysql.Driver - we recommend using Connector/J though.
         Class name for the official MySQL Connector/J driver is com.mysql.jdbc.Driver.
         --&gt;

    &lt;!-- url: The JDBC connection url for connecting to your MySQL database.
         --&gt;

  &lt;Resource name="jdbc/TestDB" auth="Container" type="javax.sql.DataSource"
               maxTotal="100" maxIdle="30" maxWaitMillis="10000"
               username="javauser" password="javadude" driverClassName="com.mysql.jdbc.Driver"
               url="jdbc:mysql://localhost:3306/javatest"/&gt;

&lt;/Context&gt;</code></pre></div>

<h5>3. web.xml配置</h5>

<p>现在创建一个<code>WEB-INF/web.xml</code>该测试应用程序。</p>
<div class="codeBox"><pre><code>&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4"&gt;
  &lt;description&gt;MySQL Test App&lt;/description&gt;
  &lt;resource-ref&gt;
      &lt;description&gt;DB Connection&lt;/description&gt;
      &lt;res-ref-name&gt;jdbc/TestDB&lt;/res-ref-name&gt;
      &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
      &lt;res-auth&gt;Container&lt;/res-auth&gt;
  &lt;/resource-ref&gt;
&lt;/web-app&gt;</code></pre></div>

<h5>4。测试码</h5>
<p>现在创建一个简单的<code>test.jsp</code>页面供以后使用。</p>
<div class="codeBox"><pre><code>&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/sql" prefix="sql" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;

&lt;sql:query var="rs" dataSource="jdbc/TestDB"&gt;
select id, foo, bar from testdata
&lt;/sql:query&gt;

&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;DB Test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;h2&gt;Results&lt;/h2&gt;

&lt;c:forEach var="row" items="${rs.rows}"&gt;
    Foo ${row.foo}&lt;br/&gt;
    Bar ${row.bar}&lt;br/&gt;
&lt;/c:forEach&gt;

  &lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<p>该JSP页面使用了<a href="http://www.oracle.com/technetwork/java/index-jsp-135995.html">JSTL</a>的SQL和Core标签库。您可以从<a href="https://tomcat.apache.org/taglibs/standard/">Apache Tomcat Taglibs-标准标记库</a>项目中获得它-只需确保获得1.1.x或更高版本即可。拥有JSTL后，复制<code>jstl.jar</code>和<code>standard.jar</code>到您的网络应用的<code>WEB-INF/lib</code>目录。

</p>

<p>最后将您的Web应用程序部署到<code>$CATALINA_BASE/webapps</code>要么作为一个称为<code>DBTest.war</code>或进入子目录<code>DBTest</code></p>
<p>部署后，将浏览器指向<code>http://localhost:8080/DBTest/test.jsp</code>查看您辛勤工作的成果。</p>

</div></div>

<div class="subsection"><h4 id="Oracle_8i,_9i_&_10g">Oracle 8i，9i和10g</h4><div class="text">
<h5>0。介绍</h5>

<p>除了通常的陷阱外，Oracle对MySQL配置的更改要求极低：-)</p>
<p>较早的Oracle版本的驱动程序可能以* .zip文件而不是* .jar文件的形式分发。Tomcat只会使用<code>*.jar</code>文件安装在<code>$CATALINA_HOME/lib</code> 。因此<code>classes111.zip</code>要么<code>classes12.zip</code>将需要重命名为<code>.jar</code>延期。由于jarfile是zipfile，因此无需解压缩和jar这些文件-一个简单的重命名就足够了。</p>

<p>从Oracle 9i开始，您应该使用<code>oracle.jdbc.OracleDriver</code>而不是<code>oracle.jdbc.driver.OracleDriver</code>正如甲骨文所说<code>oracle.jdbc.driver.OracleDriver</code>不推荐使用，并且在下一个主要版本中将不再对此驱动程序类提供支持。
</p>

<h5>1。上下文配置</h5>
<p>与上述mysql配置类似，您将需要在<a href="config/context.html">Context中</a>定义数据源。在这里，我们使用瘦驱动程序定义一个名为myoracle的数据源，以用户scott的身份将密码Tiger连接到名为mysid的sid。（注意：对于瘦驱动程序，此sid与tnsname不同）。使用的模式将是用户scott的默认模式。</p>

<p>使用OCI驱动程序应该只涉及更改URL字符串中的oci到Thin。
</p>
<div class="codeBox"><pre><code>&lt;Resource name="jdbc/myoracle" auth="Container"
              type="javax.sql.DataSource" driverClassName="oracle.jdbc.OracleDriver"
              url="jdbc:oracle:thin:@127.0.0.1:1521:mysid"
              username="scott" password="tiger" maxTotal="20" maxIdle="10"
              maxWaitMillis="-1"/&gt;</code></pre></div>

<h5>2. web.xml配置</h5>
<p>创建应用程序web.xml文件时，应确保遵守DTD定义的元素顺序。</p>
<div class="codeBox"><pre><code>&lt;resource-ref&gt;
 &lt;description&gt;Oracle Datasource example&lt;/description&gt;
 &lt;res-ref-name&gt;jdbc/myoracle&lt;/res-ref-name&gt;
 &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
 &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;</code></pre></div>
<h5>3。代码示例</h5>
<p>您可以使用与上述相同的示例应用程序（假设您创建了所需的数据库实例，表等），将Datasource代码替换为类似的内容</p>
<div class="codeBox"><pre><code>Context initContext = new InitialContext();
Context envContext  = (Context)initContext.lookup("java:/comp/env");
DataSource ds = (DataSource)envContext.lookup("jdbc/myoracle");
Connection conn = ds.getConnection();
//etc.</code></pre></div>
</div></div>


<div class="subsection"><h4 id="PostgreSQL">PostgreSQL的</h4><div class="text">
<h5>0。介绍</h5>
<p>PostgreSQL的配置与Oracle类似。</p>

<h5>1。所需文件</h5>
<p>将Postgres JDBC jar复制到$ CATALINA_HOME / lib。与Oracle一样，jar必须位于此目录中，以便DBCP 2的Classloader找到它们。无论接下来要执行哪个配置步骤，都必须执行此操作。
</p>

<h5>2。资源配置</h5>

<p>您在这里有两个选择：定义一个在所有Tomcat应用程序之间共享的数据源，或者定义一个专门用于一个应用程序的数据源。
</p>

<h6>2a。共享资源配置</h6>
<p>如果您希望定义在多个Tomcat应用程序之间共享的数据源，或者仅希望在此文件中定义数据源，请使用此选项。
</p>
<p><i>尽管没有其他人报道，但该作者在这里没有取得成功。澄清将不胜感激。</i></p>

<div class="codeBox"><pre><code>&lt;Resource name="jdbc/postgres" auth="Container"
          type="javax.sql.DataSource" driverClassName="org.postgresql.Driver"
          url="jdbc:postgresql://127.0.0.1:5432/mydb"
          username="myuser" password="mypasswd" maxTotal="20" maxIdle="10" maxWaitMillis="-1"/&gt;</code></pre></div>
<h6>2b。特定于应用程序的资源配置</h6>

<p>如果您希望定义特定于您的应用程序的数据源，而其他Tomcat应用程序不可见，请使用此选项。此方法对Tomcat安装的侵入性较小。
</p>

<p>为<a href="config/context.html">Context</a>创建资源定义。Context元素应类似于以下内容。
</p>

<div class="codeBox"><pre><code>&lt;Context&gt;

&lt;Resource name="jdbc/postgres" auth="Container"
          type="javax.sql.DataSource" driverClassName="org.postgresql.Driver"
          url="jdbc:postgresql://127.0.0.1:5432/mydb"
          username="myuser" password="mypasswd" maxTotal="20" maxIdle="10"
maxWaitMillis="-1"/&gt;
&lt;/Context&gt;</code></pre></div>

<h5>3. web.xml配置</h5>
<div class="codeBox"><pre><code>&lt;resource-ref&gt;
 &lt;description&gt;postgreSQL Datasource example&lt;/description&gt;
 &lt;res-ref-name&gt;jdbc/postgres&lt;/res-ref-name&gt;
 &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
 &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;</code></pre></div>

<h5>4。访问数据源</h5>
<p>以编程方式访问数据源时，请记住在前面<code>java:/comp/env</code>到您的JNDI查找，如下面的代码片段所示。还请注意，“ jdbc / postgres”可以替换为您喜欢的任何值，前提是您也可以在上述资源定义文件中对其进行更改。
</p>

<div class="codeBox"><pre><code>InitialContext cxt = new InitialContext();
if ( cxt == null ) {
   throw new Exception("Uh oh -- no context!");
}

DataSource ds = (DataSource) cxt.lookup( "java:/comp/env/jdbc/postgres" );

if ( ds == null ) {
   throw new Exception("Data source not found!");
}</code></pre></div>

</div></div>
</div><h3 id="Non-DBCP_Solutions">非DBCP解决方案</h3><div class="text">
<p>这些解决方案都利用与数据库的单一连接（除了测试外，不建议使用其他方法！）或其他一些合并技术。
</p>
</div><h3 id="Oracle_8i_with_OCI_client">带有OCI客户端的Oracle 8i</h3><div class="text">
<div class="subsection"><h4 id="Oracle_8i_with_OCI_client/Introduction">介绍</h4><div class="text">
<p>尽管不严格解决使用OCI客户端创建JNDI数据源的问题，但这些说明可以与上述Oracle和DBCP 2解决方案结合使用。</p>
<p>为了使用OCI驱动程序，您应该安装了Oracle客户端。您应该已经从cd安装了Oracle8i（8.1.7）客户端，并从<a href="http://otn.oracle.com/">otn.oracle.com</a>下载了合适的JDBC / OCI驱动程序（Oracle8i 8.1.7.1 JDBC / OCI驱动程序）。
</p>
<p>重命名后<code>classes12.zip</code>归档到<code>classes12.jar</code>对于Tomcat，将其复制到<code>$CATALINA_HOME/lib</code> 。您可能还必须删除<code>javax.sql.*</code>该文件中的类取决于您使用的Tomcat和JDK的版本。
</p>
</div></div>

<div class="subsection"><h4 id="Putting_it_all_together">放在一起</h4><div class="text">
<p>确保您拥有<code>ocijdbc8.dll</code>要么<code>.so</code>在你的<code>$PATH</code>要么<code>LD_LIBRARY_PATH</code> （可能在<code>$ORAHOME\bin</code> ），并确认可以使用以下简单测试程序加载本机库<code>System.loadLibrary("ocijdbc8");</code>
</p>
<p>接下来，您应该创建一个具有以下<strong>关键行</strong>的简单测试servlet或JSP：</p>
<div class="codeBox"><pre><code>DriverManager.registerDriver(new
oracle.jdbc.driver.OracleDriver());
conn =
DriverManager.getConnection("jdbc:oracle:oci8:@database","username","password");</code></pre></div>
<p>数据库的形式<code>host:port:SID</code>现在，如果您尝试访问测试servlet / JSP的URL，您将获得一个<code>ServletException</code>根本原因<code>java.lang.UnsatisfiedLinkError:get_env_handle</code> 。
</p>
<p>首先， <code>UnsatisfiedLinkError</code>表示你有</p>
<ul>
<li>JDBC类文件和Oracle客户端版本之间不匹配。这里的赠品是消息，指出找不到所需的库文件。例如，您可能将Oracle版本8.1.6中的classes12.zip文件与版本8.1.5 Oracle客户端一起使用。classesXXX.zip文件和Oracle客户端软件版本必须匹配。
</li>
<li>一种<code>$PATH</code> ， <code>LD_LIBRARY_PATH</code>问题。</li>
<li>据报道，忽略从otn下载的驱动程序，并使用目录中的classes12.zip文件<code>$ORAHOME\jdbc\lib</code>也可以。
</li>
</ul>
<p>接下来，您可能会遇到错误<code>ORA-06401 NETCMN: invalid driver designator</code>
</p>
<p>Oracle文档说：“原因：登录（连接）字符串包含无效的驱动程序指示符。操作：更正该字符串，然后重新提交。“更改数据库连接字符串（形式为<code>host:port:SID</code> ）与此： <code>(description=(address=(host=myhost)(protocol=tcp)(port=1521))(connect_data=(sid=orcl)))</code>
</p>
<p>
<i>埃德嗯，如果您整理出TNSName，我认为这不是真的需要-但我不是Oracle DBA ：-)</i>
</p>
</div></div>
</div><h3 id="Common_Problems">常见问题</h3><div class="text">
<p>这是使用数据库的Web应用程序遇到的一些常见问题，以及解决这些问题的技巧。</p>

<div class="subsection"><h4 id="Intermittent_Database_Connection_Failures">间歇性数据库连接失败</h4><div class="text">
<p>Tomcat在JVM中运行。JVM定期执行垃圾回收（GC）来删除不再使用的Java对象。当JVM执行GC时，Tomcat中的代码将冻结。如果配置用于建立数据库连接的最大时间少于垃圾回收所花费的时间，则可能会导致数据库连接失败。
</p>

<p>要收集有关垃圾收集需要多长时间的数据，请添加<code>-verbose:gc</code>对你的论点<code>CATALINA_OPTS</code>启动Tomcat时的环境变量。启用详细gc后，您的<code>$CATALINA_BASE/logs/catalina.out</code>日志文件将包含每个垃圾收集的数据，包括花费了多长时间。</p>

<p>当您的JVM正确地调整了99％的时间时，GC将花费不到一秒钟的时间。其余的只需几秒钟。很少，如果GC需要花费超过10秒的时间。</p>

<p>确保数据库连接超时设置为10-15秒。对于DBCP 2，您可以使用参数进行设置<code>maxWaitMillis</code> 。</p>

</div></div>

<div class="subsection"><h4 id="Random_Connection_Closed_Exceptions">随机连接封闭异常</h4><div class="text">
<p>当一个请求从连接池获取数据库连接并将其关闭两次时，可能会发生这些情况。使用连接池时，关闭连接只是将其返回到池中，以供另一个请求重用，它不会关闭连接。Tomcat使用多个线程来处理并发请求。这是可能在Tomcat中导致此错误的事件序列的示例：</p>
<pre>
  Request 1 running in Thread 1 gets a db connection.

  Request 1 closes the db connection.

  The JVM switches the running thread to Thread 2

  Request 2 running in Thread 2 gets a db connection
  (the same db connection just closed by Request 1).

  The JVM switches the running thread back to Thread 1

  Request 1 closes the db connection a second time in a finally block.

  The JVM switches the running thread back to Thread 2

  Request 2 Thread 2 tries to use the db connection but fails
  because Request 1 closed it.
</pre>
<p>这是使用从连接池获得的数据库连接的正确编写的代码示例：</p>
<div class="codeBox"><pre><code>  Connection conn = null;
  Statement stmt = null;  // Or PreparedStatement if needed
  ResultSet rs = null;
  try {
    conn = ... get connection from connection pool ...
    stmt = conn.createStatement("select ...");
    rs = stmt.executeQuery();
    ... iterate through the result set ...
    rs.close();
    rs = null;
    stmt.close();
    stmt = null;
    conn.close(); // Return to connection pool
    conn = null;  // Make sure we don't close it twice
  } catch (SQLException e) {
    ... deal with errors ...
  } finally {
    // Always make sure result sets and statements are closed,
    // and the connection is returned to the pool
    if (rs != null) {
      try { rs.close(); } catch (SQLException e) { ; }
      rs = null;
    }
    if (stmt != null) {
      try { stmt.close(); } catch (SQLException e) { ; }
      stmt = null;
    }
    if (conn != null) {
      try { conn.close(); } catch (SQLException e) { ; }
      conn = null;
    }
  }</code></pre></div>

</div></div>

<div class="subsection"><h4 id="Context_versus_GlobalNamingResources">上下文与GlobalNamingResources</h4><div class="text">
<p>请注意，尽管以上说明将JNDI声明放置在Context元素中，但有时甚至可能需要将这些声明放置在服务器配置文件的<a href="config/globalresources.html">GlobalNamingResources</a>部分中。放置在GlobalNamingResources部分中的资源将在服务器的上下文之间共享。
</p>
</div></div>

<div class="subsection"><h4 id="JNDI_Resource_Naming_and_Realm_Interaction">JNDI资源命名和领域交互</h4><div class="text">
<p>为了使领域发挥作用，领域必须引用<globalnamingresources>或<context>部分中定义的数据源<globalnamingresources><context>，而不是使用进行重命名的数据源<resourcelink>。
</resourcelink></context></globalnamingresources></context></globalnamingresources></p>
</div></div>

</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="./comments.html">这里</a>解释<a href="./comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>