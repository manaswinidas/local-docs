<html lang="zh-Hans" ><head></head><body >﻿<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="./images/docs-stylesheet.css" rel="stylesheet" type="text/css"><title>Apache Tomcat 9（9.0.21）-Tomcat JDBC连接池</title><meta name="author" content="Filip Hanik"><script type="application/javascript" data-comments-identifier="tomcat-9.0-doc/jdbc-pool">
    "use strict"; // Enable strict mode

    (function() {
      var thisScript = document.currentScript;
      if (!thisScript) { // Workaround for IE <= 11
        var scripts = document.getElementsByTagName("script");
        thisScript = scripts[scripts.length - 1];
      }
      document.addEventListener("DOMContentLoaded", (function() {
        var commentsDiv = document.getElementById("comments_thread");
        var commentsShortname = "tomcat";
        var commentsIdentifier = "https://tomcat.apache.org/" +
          thisScript.getAttribute("data-comments-identifier") + ".html";

        (function(w, d) {
          if (w.location.hostname.toLowerCase() == "tomcat.apache.org") {
            var s = d.createElement("script");
            s.type = "application/javascript";
            s.async = true;
            s.src = "https://comments.apache.org/show_comments.lua?site=" +
              encodeURIComponent(commentsShortname) +
              "&page=" + encodeURIComponent(commentsIdentifier);
            d.head.appendChild(s);
          } else {
            commentsDiv.appendChild(d.createTextNode("Comments are disabled for this page at the moment."));
          }
        })(window, document);
      }), false);
    })();
  </script><div id="wrapper"><header><div id="header"><div><div><div class="logo noPrint"><a href="https://tomcat.apache.org/"><img alt="Tomcat主页" src="./images/tomcat.png"></a></div><div style="height:1px"></div><div class="asfLogo noPrint"><a href="https://www.apache.org/" target="_blank"><img src="./images/asf-logo.svg" alt="Apache软件基金会" style="width:266px;height:83px"></a></div><h1>Apache Tomcat 9</h1><div class="versionInfo">版本9.0.21， <time datetime="2019-06-04"> 2019年6月4日</time></div><div style="height:1px"></div><div style="clear:left"></div></div></div></div></header><div id="middle"><div><div id="mainLeft" class="noprint"><div><nav><div><h2>链接</h2><ul><li><a href="index.html">文件首页</a></li><li><a href="https://wiki.apache.org/tomcat/FAQ">常问问题</a></li><li><a href="#comments_section">用户评论</a></li></ul></div><div><h2>用户指南</h2><ul><li><a href="introduction.html">1）简介</a></li><li><a href="setup.html">2）设定</a></li><li><a href="appdev/index.html">3）第一个webapp</a></li><li><a href="deployer-howto.html">4）部署者</a></li><li><a href="manager-howto.html">5）经理</a></li><li><a href="host-manager-howto.html">6）主机管理员</a></li><li><a href="realm-howto.html">7）领域和AAA</a></li><li><a href="security-manager-howto.html">8）安全经理</a></li><li><a href="jndi-resources-howto.html">9）JNDI资源</a></li><li><a href="jndi-datasource-examples-howto.html">10）JDBC数据源</a></li><li><a href="class-loader-howto.html">11）类加载</a></li><li><a href="jasper-howto.html">12）JSP</a></li><li><a href="ssl-howto.html">13）SSL / TLS</a></li><li><a href="ssi-howto.html">14）SSI</a></li><li><a href="cgi-howto.html">15）CGI</a></li><li><a href="proxy-howto.html">16）代理支持</a></li><li><a href="mbeans-descriptors-howto.html">17）MBean描述符</a></li><li><a href="default-servlet.html">18）默认Servlet</a></li><li><a href="cluster-howto.html">19）聚类</a></li><li><a href="balancer-howto.html">20）负载均衡器</a></li><li><a href="connectors.html">21）连接器</a></li><li><a href="monitoring.html">22）监控与管理</a></li><li><a href="logging.html">23）记录</a></li><li><a href="apr.html">24）APR /本地</a></li><li><a href="virtual-hosting-howto.html">25）虚拟主机</a></li><li><a href="aio.html">26）高级IO</a></li><li><a href="extras.html">27）附加组件</a></li><li><a href="maven-jars.html">28）行刑</a></li><li><a href="security-howto.html">29）安全注意事项</a></li><li><a href="windows-service-howto.html">30）Windows服务</a></li><li><a href="windows-auth-howto.html">31）Windows身份验证</a></li><li><a href="jdbc-pool.html">32）Tomcat的JDBC池</a></li><li><a href="web-socket-howto.html">33）WebSocket</a></li><li><a href="rewrite.html">34）改写</a></li></ul></div><div><h2>参考</h2><ul><li><a href="RELEASE-NOTES.txt">发行说明</a></li><li><a href="config/index.html">组态</a></li><li><a href="api/index.html">Tomcat Java文档</a></li><li><a href="servletapi/index.html">Servlet Java文档</a></li><li><a href="jspapi/index.html">JSP 2.3 Java文档</a></li><li><a href="elapi/index.html">EL 3.0 Java文档</a></li><li><a href="websocketapi/index.html">WebSocket 1.1 Java文档</a></li><li><a href="https://tomcat.apache.org/connectors-doc/">JK 1.2文档</a></li></ul></div><div><h2>Apache Tomcat开发</h2><ul><li><a href="building.html">建造</a></li><li><a href="changelog.html">变更日志</a></li><li><a href="https://wiki.apache.org/tomcat/TomcatVersions">状态</a></li><li><a href="developers.html">开发者</a></li><li><a href="architecture/index.html">建筑</a></li><li><a href="funcspecs/index.html">功能规格。</a></li><li><a href="tribes/introduction.html">部族</a></li></ul></div></nav></div></div><div id="mainRight"><div id="content"><h2>Tomcat JDBC连接池</h2><h3 id="Table_of_Contents">目录</h3><div class="text">
<ul><li><a href="#Introduction">介绍</a></li><li><a href="#How_to_use">如何使用</a><ol><li><a href="#Additional_features">附加的功能</a></li><li><a href="#Inside_the_Apache_Tomcat_Container">在Apache Tomcat容器内部</a></li><li><a href="#Standalone">单机版</a></li><li><a href="#JMX">JMX</a></li></ol></li><li><a href="#Attributes">属性</a><ol><li><a href="#JNDI_Factory_and_Type">JNDI工厂和类型</a></li><li><a href="#System_Properties">系统属性</a></li><li><a href="#Common_Attributes">共同属性</a></li><li><a href="#Tomcat_JDBC_Enhanced_Attributes">Tomcat JDBC增强属性</a></li></ol></li><li><a href="#Advanced_usage">高级用法</a><ol><li><a href="#JDBC_interceptors">JDBC拦截器</a></li><li><a href="#Configuring_JDBC_interceptors">配置JDBC拦截器</a></li><li><a href="#org.apache.tomcat.jdbc.pool.JdbcInterceptor">org.apache.tomcat.jdbc.pool。Jdbc拦截器</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.ConnectionState">org.apache.tomcat.jdbc.pool.interceptor。连接状态</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer">org.apache.tomcat.jdbc.pool.interceptor。声明定稿器</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.StatementCache">org.apache.tomcat.jdbc.pool.interceptor。StatementCache</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor">org.apache.tomcat.jdbc.pool.interceptor。StatementDecoratorInterceptor</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.QueryTimeoutInterceptor">org.apache.tomcat.jdbc.pool.interceptor。QueryTimeoutInterceptor</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport">org.apache.tomcat.jdbc.pool.interceptor。SlowQueryReport</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx">org.apache.tomcat.jdbc.pool.interceptor。SlowQueryReportJmx</a></li><li><a href="#org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer">org.apache.tomcat.jdbc.pool.interceptor。ResetAbandonedTimer</a></li></ol></li><li><a href="#Code_Example">代码示例</a><ol><li><a href="#Plain_Ol'_Java">普通的爪哇</a></li><li><a href="#As_a_Resource">作为资源</a></li><li><a href="#Asynchronous_Connection_Retrieval">异步连接检索</a></li><li><a href="#Interceptors">拦截器</a></li><li><a href="#Getting_the_actual_JDBC_connection">获取实际的JDBC连接</a></li></ol></li><li><a href="#Building">建造</a><ol><li><a href="#Building_from_source">从源头建造</a></li></ol></li></ul>
</div><h3 id="Introduction">介绍</h3><div class="text">

  <p><strong>JDBC连接池<code>org.apache.tomcat.jdbc.pool</code></strong>是<a href="https://commons.apache.org/dbcp/">Apache Commons DBCP</a>连接池的替代品或替代品。</p>

  <p>那么，为什么我们需要一个新的连接池？</p>

  <p>原因如下：</p>
    <ol>
      <li>Commons DBCP 1.x是单线程的。为了线程安全，Commons在对象分配和对象返回期间都将整个池锁定较短的时间。请注意，这不适用于Commons DBCP2.x。</li>
      <li>Commons DBCP 1.x可能很慢。随着逻辑CPU数量的增加以及尝试借用或返回对象的并发线程的数量增加，性能会受到影响。对于高度并发的系统，影响可能很大。请注意，这不适用于Commons DBCP2.x。</li>
      <li>Commons DBCP有60多个类。 tomcat-jdbc-pool核心是8个类，因此为将来的需求进行修改将需要的更改要少得多。这就是运行连接池本身所需的全部，其余的都是肉汁。</li>
      <li>Commons DBCP使用静态接口。这意味着您必须为给定的JRE版本使用正确的版本，否则您可能会看到<code>NoSuchMethodException</code>例外情况。</li>
      <li>当连接池可以用更简单的实现来实现时，不应该重写60个以上的类。</li>
      <li>Tomcat jdbc池实现了异步检索连接的功能，而无需向库本身添加其他线程。</li>
      <li>Tomcat jdbc池是Tomcat模块，它依赖于Tomcat JULI（Tomcat中使用的简化日志记录框架）。</li>
      <li>使用以下命令检索基础连接<code>javax.sql.PooledConnection</code>接口。</li>
      <li>饥饿证明。如果池为空，并且线程正在等待连接，则返回连接时，池将唤醒正确的线程等待。大多数游泳池只会饿死。</li>
    </ol>

  <p>在其他连接池实现上添加的功能</p>
    <ol>
      <li>支持高度并发的环境和多核/ cpu系统。</li>
      <li>动态实现接口，将支持<code>java.sql</code>和<code>javax.sql</code>即使使用较低版本的JDK进行编译，也可以为运行时环境提供接口（只要JDBC驱动程序也可以这样做）。</li>
      <li>验证间隔-我们不必每次使用连接时都进行验证，我们可以在借用或返回连接时进行验证，只是不超过我们可以配置的间隔。</li>
      <li>运行一次查询，这是一种可配置的查询，在建立与数据库的连接时将仅运行一次。这对于设置会话设置非常有用，您希望在整个连接建立期间都存在该会话设置。</li>
      <li>能够配置自定义拦截器。这使您可以编写自定义拦截器以增强功能。您可以使用拦截器来收集查询统计信息，缓存会话状态，在发生故障时重新连接，重试查询，缓存查询结果等等。您的选择无穷无尽，拦截器是动态的，而不是绑定到JDK版本的<code>java.sql</code> / <code>javax.sql</code>接口。</li>
      <li>高性能-稍后我们将展示一些性能差异</li>
      <li>极其简单，由于实现非常简化，因此行数和源文件数都非常低，与具有200多个源文件的c3p0（上次检查）相比，Tomcat jdbc具有8个文件核心，即连接池本身大约一半。由于可能会发生错误，因此可以更快地找到它们，并且更容易修复。从一开始，降低复杂性就成为关注的焦点。</li>
      <li>异步连接检索-您可以将连接请求排队并接收<code>Future<Connection></code>背部。</li>
      <li>更好的空闲连接处理。与其直接关闭连接，它还可以使用更智能的算法来缓冲连接并调整空闲池的大小。</li>
      <li>您可以通过指定池使用量阈值来决定何时将连接视为已放弃，是何时池已满，还是直接在超时时确定。
      </li>
      <li>放弃连接计时器将在语句/查询活动时重置。允许长时间使用的连接不会超时。这是通过使用<code>ResetAbandonedTimer</code>
      </li>
      <li>连接一定时间后，请关闭连接。年龄根据返回游泳池的时间而定。
      </li>
      <li>当怀疑连接被放弃时，获取JMX通知和日志条目。这类似于<code>removeAbandonedTimeout</code>但不采取任何措施，仅报告信息。这是通过使用<code>suspectTimeout</code>属性。</li>
      <li>可以从连接中检索连接<code>java.sql.Driver</code> ， <code>javax.sql.DataSource</code>要么<code>javax.sql.XADataSource</code>这是通过使用<code>dataSource</code>和<code>dataSourceJNDI</code>属性。</li>
      <li>XA连接支持</li>
    </ol>


</div><h3 id="How_to_use">如何使用</h3><div class="text">
  <p>Tomcat连接池的使用已尽可能地简单，对于熟悉commons-dbcp的人来说，过渡将非常简单。从其他连接池迁移也很简单。
  </p>
  <div class="subsection"><h4 id="Additional_features">附加的功能</h4><div class="text">
    <p>Tomcat连接池提供了大多数其他池所不具备的一些其他功能：</p>
    <ul>
      <li><code>initSQL</code> -创建连接后，仅运行一次SQL语句的能力</li>
      <li><code>validationInterval</code> -除了对连接运行验证之外，请避免过于频繁地运行它们。</li>
      <li><code>jdbcInterceptors</code> -灵活且可插入的拦截器，可在池，查询执行和结果集处理周围创建任何自定义项。有关更多信息，请参见高级部分。</li>
      <li><code>fairQueue</code> -将fair标志设置为true以实现线程公平或使用异步连接检索</li>
    </ul>
  </div></div>
  <div class="subsection"><h4 id="Inside_the_Apache_Tomcat_Container">在Apache Tomcat容器内部</h4><div class="text">
    <p>Tomcat连接池配置为<a href="http://tomcat.apache.org/tomcat-9.0-doc/jndi-datasource-examples-howto.html" target="_blank">Tomcat JDBC文档中</a>描述的资源，唯一的区别是您必须指定<code>factory</code>属性并将其值设置为<code>org.apache.tomcat.jdbc.pool.DataSourceFactory</code>
    </p>
  </div></div>
  <div class="subsection"><h4 id="Standalone">单机版</h4><div class="text">
    <p>连接池仅具有另一个依赖项，即tomcat-juli.jar。要使用bean实例化在独立项目中配置池，要实例化的bean是<code>org.apache.tomcat.jdbc.pool.DataSource</code> 。与将连接池配置为JNDI资源时使用的相同属性（下面记录）用于将数据源配置为Bean。
    </p>
  </div></div>
  <div class="subsection"><h4 id="JMX">JMX</h4><div class="text">
    <p>连接池对象公开了可以注册的MBean。为了使连接池对象创建MBean，该标志<code>jmxEnabled</code>必须设置为true。这并不意味着该池将被注册到MBean服务器，而仅仅是创建了MBean。在Tomcat之类的容器中，Tomcat本身向MBean服务器注册了数据源， <code>org.apache.tomcat.jdbc.pool.DataSource</code>然后，对象将注册实际的连接池MBean。如果您在容器外部运行，则可以使用您指定的任何对象名称自行注册DataSource，并将其传播到基础池。为此，您将致电<code>mBeanServer.registerMBean(dataSource.getPool().getJmxPool(),objectname)</code> 。在进行此调用之前，请确保已通过调用创建池<code>dataSource.createPool()</code> 。
    </p>
  </div></div>

</div><h3 id="Attributes">属性</h3><div class="text">
  <p>为了提供与commons-dbcp和tomcat-jdbc-pool之间的非常简单的切换，大多数属性都是相同的，并且具有相同的含义。</p>
  <div class="subsection"><h4 id="JNDI_Factory_and_Type">JNDI工厂和类型</h4><div class="text">
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">factory</code></strong></td><td>
        <p>工厂是必填项，其值应为<code>org.apache.tomcat.jdbc.pool.DataSourceFactory</code></p>
      </td></tr><tr><td><strong><code class="attributeName">type</code></strong></td><td>
        <p>类型应始终为<code>javax.sql.DataSource</code>要么<code>javax.sql.XADataSource</code></p>
        <p>取决于类型<code>org.apache.tomcat.jdbc.pool.DataSource</code>或一个<code>org.apache.tomcat.jdbc.pool.XADataSource</code>将被创建。</p>
      </td></tr></tbody></table>
  </div></div>

  <div class="subsection"><h4 id="System_Properties">系统属性</h4><div class="text">
    <p>系统属性是JVM范围的，影响在JVM中创建的所有池</p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">org.apache.tomcat.jdbc.pool.onlyAttemptCurrentClassLoader</code></td><td>
        <p>（布尔值）控制动态类（例如JDBC驱动程序，拦截器和验证器）的类加载。如果设置为<code>false</code> （默认值），池将首先尝试使用当前的加载器（即，加载池类的类加载器）进行加载，如果类加载失败，则尝试使用线程上下文加载器进行加载。将此值设置为<code>true</code> ，如果您希望与Apache Tomcat 8.0.8及更早版本保持向后兼容，请仅尝试使用当前的加载器。如果未设置，则默认值为<code>false</code> 。
        </p>
      </td></tr></tbody></table>
  </div></div>

  <div class="subsection"><h4 id="Common_Attributes">共同属性</h4><div class="text">
  <p>这些属性在commons-dbcp和tomcat-jdbc-pool之间共享，在某些情况下默认值是不同的。</p>
  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">defaultAutoCommit</code></td><td>
      <p>（布尔值）此池创建的连接的默认自动提交状态。如果未设置，则默认值为JDBC驱动程序默认值（如果未设置，则默认<code>setAutoCommit</code>方法将不会被调用。）</p>
    </td></tr><tr><td><code class="attributeName">defaultReadOnly</code></td><td>
      <p>（布尔值）此池创建的连接的默认只读状态。如果未设置，则<code>setReadOnly</code>方法不会被调用。（某些驱动程序不支持只读模式，例如：Informix）</p>
    </td></tr><tr><td><code class="attributeName">defaultTransactionIsolation</code></td><td>
      <p>（字符串）此池创建的连接的默认TransactionIsolation状态。以下之一：（请参阅javadoc）</p>
         <ul>
           <li><code>NONE</code></li>
           <li><code>READ_COMMITTED</code></li>
           <li><code>READ_UNCOMMITTED</code></li>
           <li><code>REPEATABLE_READ</code></li>
           <li><code>SERIALIZABLE</code></li>
         </ul>
         <p>如果未设置，则不会调用该方法，并且默认为JDBC驱动程序。</p>
    </td></tr><tr><td><code class="attributeName">defaultCatalog</code></td><td>
      <p>（字符串）此池创建的默认连接目录。</p>
    </td></tr><tr><td><strong><code class="attributeName">driverClassName</code></strong></td><td>
      <p>（字符串）要使用的JDBC驱动程序的标准Java类名称。必须从与tomcat-jdbc.jar相同的类加载器中访问驱动程序</p>
    </td></tr><tr><td><strong><code class="attributeName">username</code></strong></td><td>
      <p>（字符串）要传递给我们的JDBC驱动程序以建立连接的连接用户名。注意该方法<code>DataSource.getConnection(username,password)</code>默认情况下，将不使用传递给方法的凭据，而是将使用此处配置的凭据。看到<code>alternateUsernameAllowed</code>属性以获取更多详细信息。
      </p>
    </td></tr><tr><td><strong><code class="attributeName">password</code></strong></td><td>
      <p>（字符串）要传递给我们的JDBC驱动程序以建立连接的连接密码。注意该方法<code>DataSource.getConnection(username,password)</code>默认情况下，将不使用传递给方法的凭据，而是将使用此处配置的凭据。看到<code>alternateUsernameAllowed</code>属性以获取更多详细信息。
      </p>
    </td></tr><tr><td><code class="attributeName">maxActive</code></td><td>
      <p>（int）可以同时从该池分配的最大活动连接数。默认值为<code>100</code></p>
    </td></tr><tr><td><code class="attributeName">maxIdle</code></td><td>
      <p>（int）始终应保留在池中的最大连接数。默认值为<code>maxActive</code> ： <code>100</code>定期检查空闲连接（如果启用），并且空闲时间超过<code>minEvictableIdleTimeMillis</code>将会被释放。 （另请参阅<code>testWhileIdle</code> ）</p>
    </td></tr><tr><td><code class="attributeName">minIdle</code></td><td>
      <p>（int）始终应保留在池中的已建立连接的最小数目。如果验证查询失败，则连接池可以缩小到该数字以下。默认值源自<code>initialSize</code> ： <code>10</code> （另请参阅<code>testWhileIdle</code> ）</p>
    </td></tr><tr><td><code class="attributeName">initialSize</code></td><td>
      <p>（int）启动池时创建的初始连接数。默认值为<code>10</code></p>
    </td></tr><tr><td><code class="attributeName">maxWait</code></td><td>
      <p>（int）在引发异常之前，池将等待（无可用连接时）连接被返回的最大毫秒数。默认值为<code>30000</code> （30秒）</p>
    </td></tr><tr><td><code class="attributeName">testOnBorrow</code></td><td>
      <p>（布尔值）指示从池中借用对象之前是否对其进行验证。如果对象验证失败，它将被从池中删除，我们将尝试借用另一个对象。为了进行更有效的验证，请参见<code>validationInterval</code> 。默认值为<code>false</code>
      </p>
    </td></tr><tr><td><code class="attributeName">testOnConnect</code></td><td>
      <p>（布尔值）指示在首次创建连接时是否将验证对象。如果对象未能通过验证，将被抛出<code>SQLException</code> 。默认值为<code>false</code>
      </p>
    </td></tr><tr><td><code class="attributeName">testOnReturn</code></td><td>
      <p>（布尔值）指示在将对象返回到池之前是否将对其进行验证。默认值为<code>false</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">testWhileIdle</code></td><td>
      <p>（布尔值）指示空闲对象退出者（如果有）是否将验证对象。如果对象验证失败，则会将其从池中删除。默认值为<code>false</code>并且必须设置此属性才能运行池清洁器/测试线程（另请参见<code>timeBetweenEvictionRunsMillis</code> ）</p>
    </td></tr><tr><td><code class="attributeName">validationQuery</code></td><td>
      <p>（字符串）SQL查询，该查询将用于验证来自此池的连接，然后再将其返回给调用方。如果指定，则此查询不必返回任何数据，只是不能抛出<code>SQLException</code> 。默认值为<code>null</code> 。如果未指定，则将通过isValid（）方法验证连接。示例值是<code>SELECT 1</code> （mysql）， <code>select 1 from dual</code> （oracle）， <code>SELECT 1</code> （MS Sql服务器）</p>
    </td></tr><tr><td><code class="attributeName">validationQueryTimeout</code></td><td>
      <p>（int）连接验证查询失败之前的超时（以秒为单位）。这可以通过调用<code>java.sql.Statement.setQueryTimeout(seconds)</code>在执行<code>validationQuery</code> 。池本身不会使查询超时，它仍然由JDBC驱动程序来强制执行查询超时。小于或等于零的值将禁用此功能。默认值为<code>-1</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">validatorClassName</code></td><td>
      <p>（字符串）实现该类的类的名称<code>org.apache.tomcat.jdbc.pool.Validator</code>接口，并提供一个无参数的构造函数（可能是隐式的）。如果指定，则该类将用于创建Validator实例，然后将其用于代替任何验证查询来验证连接。默认值为<code>null</code> 。一个示例值是<code>com.mycompany.project.SimpleValidator</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">timeBetweenEvictionRunsMillis</code></td><td>
      <p>（int）空闲连接验证/清除线程的运行之间要休眠的毫秒数。此值不应在1秒内设置。它决定了我们检查空闲，被放弃的连接的频率以及验证空闲连接的频率。该值将被覆盖<code>maxAge</code>如果后者为非零且较低。默认值为<code>5000</code> （5秒）。<br>
      </p>
    </td></tr><tr><td><code class="attributeName">numTestsPerEvictionRun</code></td><td>
      <p>（int）在tomcat-jdbc-pool中未使用的属性。</p>
    </td></tr><tr><td><code class="attributeName">minEvictableIdleTimeMillis</code></td><td>
      <p>（int）一个对象在有资格被驱逐之前可能在池中空闲的最短时间。默认值为<code>60000</code> （60秒）。</p>
    </td></tr><tr><td><code class="attributeName">accessToUnderlyingConnectionAllowed</code></td><td>
      <p>（布尔值）未使用的属性。可以通过致电来访问<code>unwrap</code>在池连接上。看到<code>javax.sql.DataSource</code>界面或通话<code>getConnection</code>通过反射或将对象投射为<code>javax.sql.PooledConnection</code></p>
    </td></tr><tr><td><code class="attributeName">removeAbandoned</code></td><td>
      <p>（布尔值）标记如果超出的则放弃的连接将被删除<code>removeAbandonedTimeout</code> 。如果设置为true，则连接的使用时间长于<code>removeAbandonedTimeout</code>设置为<code>true</code>可以从无法关闭连接的应用程序中恢复数据库连接。也可以看看<code>logAbandoned</code>默认值为<code>false</code> 。</p>
    </td></tr><tr><td><code class="attributeName">removeAbandonedTimeout</code></td><td>
      <p>（int）超时（以秒为单位），可以删除已废弃（正在使用）的连接。默认值为<code>60</code> （60秒）。该值应设置为您的应用程序可能具有的最长运行查询。</p>
    </td></tr><tr><td><code class="attributeName">logAbandoned</code></td><td>
      <p>（布尔值）标记为放弃连接的应用程序代码记录堆栈跟踪。记录废弃的连接会增加每次连接借用的开销，因为必须生成堆栈跟踪。默认值为<code>false</code> 。</p>
    </td></tr><tr><td><code class="attributeName">connectionProperties</code></td><td>
      <p>（字符串）建立新连接时将发送到我们的JDBC驱动程序的连接属性。字符串的格式必须为[propertyName = property;] *注意-“ user”和“ password”属性将显式传递，因此无需在此处包含它们。默认值为<code>null</code> 。</p>
    </td></tr><tr><td><code class="attributeName">poolPreparedStatements</code></td><td>
      <p>（布尔值）未使用的属性。</p>
    </td></tr><tr><td><code class="attributeName">maxOpenPreparedStatements</code></td><td>
      <p>（int）不使用的属性。</p>
    </td></tr></tbody></table>

  </div></div>

  <div class="subsection"><h4 id="Tomcat_JDBC_Enhanced_Attributes">Tomcat JDBC增强属性</h4><div class="text">

  <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">initSQL</code></td><td>
      <p>（字符串）首次创建连接时要运行的自定义查询。默认值为<code>null</code> 。</p>
    </td></tr><tr><td><code class="attributeName">jdbcInterceptors</code></td><td>
      <p>（字符串）用分号分隔的类名称列表，扩展<code>org.apache.tomcat.jdbc.pool.JdbcInterceptor</code>类。有关语法和示例的详细说明，请参见下面的<a href="#Configuring_JDBC_interceptors">配置JDBC拦截器</a> 。
      </p>
      <p>这些拦截器将作为拦截器插入到<code>java.sql.Connection</code>宾语。默认值为<code>null</code> 。
      </p>
      <p>预定义的拦截器：<br>
         <code>org.apache.tomcat.jdbc.pool.interceptor.<br>ConnectionState</code> -跟踪自动提交，只读，目录和事务隔离级别。<br>
         <code>org.apache.tomcat.jdbc.pool.interceptor.<br>StatementFinalizer</code> -跟踪打开的语句，并在连接返回到池时关闭它们。
      </p>
      <p>更多预定义的拦截器在“ <a href="#JDBC_interceptors">JDBC拦截器”部分</a>中进行了详细描述。
      </p>
    </td></tr><tr><td><code class="attributeName">validationInterval</code></td><td>
      <p>（长）避免过多的验证，最多只能在此频率下运行验证-时间以毫秒为单位。如果连接应进行验证，但之前已在此时间间隔内进行验证，则不会再次对其进行验证。默认值为<code>3000</code> （3秒）。</p>
    </td></tr><tr><td><code class="attributeName">jmxEnabled</code></td><td>
      <p>（布尔值）是否向JMX注册池。默认值为<code>true</code> 。</p>
    </td></tr><tr><td><code class="attributeName">fairQueue</code></td><td>
      <p>（布尔值）如果希望以真正的FIFO方式公平对待对getConnection的调用，则设置为true。这使用<code>org.apache.tomcat.jdbc.pool.FairBlockingQueue</code>空闲连接列表的实现。默认值为<code>true</code> 。当您要使用异步连接检索时，此标志是必需的。<br>设置此标志可确保线程按到达顺序接收连接。<br>在性能测试期间，实现锁和等待锁的方式有很大的不同。什么时候<code>fairQueue=true</code>有一个基于系统运行的操作系统的决策过程。如果系统在Linux上运行（属性<code>os.name=Linux</code> 。要禁用此特定于Linux的行为并仍使用公平队列，只需添加属性<code>org.apache.tomcat.jdbc.pool.FairBlockingQueue.ignoreOS=true</code>连接池类加载之前，将其设置为系统属性。
      </p>
    </td></tr><tr><td><code class="attributeName">abandonWhenPercentageFull</code></td><td>
      <p>（int）除非正在使用的连接数超过以下定义的百分比，否则已被放弃（超时）的连接不会关闭并报告。 <code>abandonWhenPercentageFull</code> 。该值应介于0到100之间。默认值为<code>0</code> ，这意味着连接有资格尽快关闭<code>removeAbandonedTimeout</code>已经达到。</p>
    </td></tr><tr><td><code class="attributeName">maxAge</code></td><td>
      <p>（长）以毫秒为单位的时间，以重新建立连接。从池中借用连接时，池将检查是否<code>now - time-when-connected > maxAge</code>已达到，如果是，则在借用之前重新连接。当连接返回到池中时，池将检查以查看是否<code>now - time-when-connected > maxAge</code>已达到，如果是，它将尝试重新连接。当连接空闲时， <code>timeBetweenEvictionRunsMillis</code>大于零，则池会定期检查是否<code>now - time-when-connected > maxAge</code>已达到，如果是，它将尝试重新连接。设置<code>maxAge</code>小于<code>timeBetweenEvictionRunsMillis</code>将覆盖它（因此空闲连接验证/清除将更频繁地运行）。默认值为<code>0</code> ，这意味着连接将保持打开状态，并且从池中借用，将连接返回到池中或检查空闲连接时都不会进行年龄检查。</p>
    </td></tr><tr><td><code class="attributeName">useEquals</code></td><td>
      <p>（布尔值）如果您希望<code>ProxyConnection</code>使用的课程<code>String.equals</code>并设置为<code>false</code>当你想使用<code>==</code>比较方法名称时。此属性不适用于添加的拦截器，因为它们是单独配置的。默认值为<code>true</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">suspectTimeout</code></td><td>
      <p>（int）超时值，以秒为单位。默认值为<code>0</code> 。<br>类似于<code>removeAbandonedTimeout</code>值，但不是将连接视为已放弃并可能关闭连接，而是在以下情况下仅记录警告<code>logAbandoned</code>设置为true。如果该值等于或小于0，则不会执行任何可疑检查。仅当超时值大于0并且未放弃连接或禁用放弃检查时，才进行可疑检查。如果怀疑连接，则记录WARN消息，并发送一次JMX通知。
      </p>
    </td></tr><tr><td><code class="attributeName">rollbackOnReturn</code></td><td>
      <p>（布尔值）如果<code>autoCommit==false</code>那么池可以通过在连接返回到池时调用连接上的回滚来终止事务，默认值为<code>false</code> 。<br>
      </p>
    </td></tr><tr><td><code class="attributeName">commitOnReturn</code></td><td>
      <p>（布尔值）如果<code>autoCommit==false</code>那么池可以通过在连接返回到池时调用连接上的commit来完成事务。 <code>rollbackOnReturn==true</code>那么该属性将被忽略。默认值为<code>false</code> 。<br>
      </p>
    </td></tr><tr><td><code class="attributeName">alternateUsernameAllowed</code></td><td>
      <p>（布尔值）默认情况下，jdbc-pool将忽略<a href="http://docs.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String, java.lang.String)"><code>DataSource.getConnection(username,password)</code></a>调用，然后简单地在全局配置的属性下返回先前池化的连接<code>username</code>和<code>password</code> ，出于性能原因。
      </p>
      <p>但是，可以将池配置为允许每次请求连接时使用不同的凭据。要启用<a href="http://docs.oracle.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection(java.lang.String, java.lang.String)"><code>DataSource.getConnection(username,password)</code></a>调用，只需设置属性<code>alternateUsernameAllowed</code>至<code>true</code> 。<br>如果您请求使用凭据user1 / password1进行连接，并且以前使用不同的user2 / password2连接了该连接，则该连接将被关闭，并使用所请求的凭据重新打开。这样，池大小仍在全局级别而不是在每个架构级别进行管理。<br>默认值为<code>false</code> 。<br>添加此属性是对<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=50025">Bug 50025</a>的增强。
      </p>
    </td></tr><tr><td><code class="attributeName">dataSource</code></td><td>
      <p>（javax.sql。DataSource）将数据源注入连接池，该池将使用数据源来检索连接，而不是使用<code>java.sql.Driver</code>接口。当您希望合并XA连接或使用数据源而不是连接字符串建立的连接时，此功能很有用。默认值为<code>null</code>
      </p>
    </td></tr><tr><td><code class="attributeName">dataSourceJNDI</code></td><td>
      <p>（字符串）要在JNDI中查找然后用于建立与数据库的连接的数据源的JNDI名称。见<code>dataSource</code>属性。默认值为<code>null</code>
      </p>
    </td></tr><tr><td><code class="attributeName">useDisposableConnectionFacade</code></td><td>
      <p>（布尔值）如果要在连接上放置外观，则将其设置为true，以使其在关闭后无法重复使用。这样可以防止线程保留已调用的已关闭连接的引用，以对其执行查询。默认值为<code>true</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">logValidationErrors</code></td><td>
      <p>（布尔值）将此属性设置为true可以在验证阶段将错误记录到日志文件中。如果设置为true，则错误将记录为SEVERE。默认值为<code>false</code>向后兼容。
      </p>
    </td></tr><tr><td><code class="attributeName">propagateInterruptState</code></td><td>
      <p>（布尔值）将其设置为true可以传播已被中断的线程的中断状态（不清除中断状态）。默认值为<code>false</code>向后兼容。
      </p>
    </td></tr><tr><td><code class="attributeName">ignoreExceptionOnPreLoad</code></td><td>
      <p>（布尔值）标记初始化池时是否忽略连接创建错误。如果要在初始化池时忽略连接创建错误，请设置为true。如果要通过引发异常使池初始化失败，请设置为false。默认值为<code>false</code> 。
      </p>
    </td></tr><tr><td><code class="attributeName">useStatementFacade</code></td><td>
      <p>（布尔值）如果您希望包装语句以启用它，请将其设置为true <code>equals()</code>和<code>hashCode()</code>如果设置了任何语句代理，则在封闭语句上调用的方法。默认值为<code>true</code> 。
      </p>
    </td></tr></tbody></table>
  </div></div>
</div><h3 id="Advanced_usage">高级用法</h3><div class="text">
  <div class="subsection"><h4 id="JDBC_interceptors">JDBC拦截器</h4><div class="text">
    <p>要查看有关如何使用拦截器的示例，请看一下<code>org.apache.tomcat.jdbc.pool.interceptor.ConnectionState</code> 。这个简单的拦截器是对三个属性的缓存，即事务隔离级别，自动提交和只读状态，以便系统避免不必要的数据库往返。
    </p>
    <p>如有需要，其他拦截器将添加到池的核心。永远欢迎捐款！</p>
    <p>当然，拦截器不仅限于<code>java.sql.Connection</code>但也可以用于包装方法调用的任何结果。您可以构建查询性能分析器，以在查询运行时间超过预期时间时提供JMX通知。</p>
  </div></div>
  <div class="subsection"><h4 id="Configuring_JDBC_interceptors">配置JDBC拦截器</h4><div class="text">
    <p>使用<b>jdbcInterceptors</b>属性完成JDBC拦截器的配置。该属性包含用分号分隔的类名称的列表。如果类名不完全限定，则将以<code>org.apache.tomcat.jdbc.pool.interceptor.</code>字首。
    </p>
    <p>例：<br>
      <code>jdbcInterceptors="org.apache.tomcat.jdbc.pool.interceptor.ConnectionState; org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer"</code>
      <br>是相同的<br>
      <code>jdbcInterceptors="ConnectionState;StatementFinalizer"</code>
    </p>
    <p>拦截器也可以具有属性。拦截器的属性在类名后的括号内指定。几个属性用逗号分隔。
    </p>
    <p>例：<br>
    <code>jdbcInterceptors="ConnectionState;StatementFinalizer(useEquals=true)"</code>
    </p>
    <p>类名，属性名和值周围的多余空格字符将被忽略。
    </p>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.JdbcInterceptor">org.apache.tomcat.jdbc.pool。Jdbc拦截器</h4><div class="text">
    <p>所有拦截器的抽象基类都无法实例化。</p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">useEquals</code></td><td>
        <p>（布尔值）如果您希望<code>ProxyConnection</code>使用的课程<code>String.equals</code>并设置为<code>false</code>当你想使用<code>==</code>比较方法名称时。默认值为<code>true</code> 。
        </p>
      </td></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.ConnectionState">org.apache.tomcat.jdbc.pool.interceptor。连接状态</h4><div class="text">
    <p>缓存以下属性的连接<code>autoCommit</code> ， <code>readOnly</code> ， <code>transactionIsolation</code>和<code>catalog</code> 。这是一种性能增强，可以避免在调用getter或使用已设置的值调用setter时往返数据库。
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer">org.apache.tomcat.jdbc.pool.interceptor。声明定稿器</h4><div class="text">
    <p>跟踪使用创建的所有语句<code>createStatement</code> ， <code>prepareStatement</code>要么<code>prepareCall</code>并在连接返回到池时关闭这些语句。
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">trace</code></td><td>
        <p>（布尔值作为字符串）启用对未关闭语句的跟踪。启用并关闭连接且未关闭语句时，拦截器将记录所有堆栈跟踪。默认值为<code>false</code> 。
        </p>
      </td></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.StatementCache">org.apache.tomcat.jdbc.pool.interceptor。StatementCache</h4><div class="text">
    <p>快取<code>PreparedStatement</code>和/或<code>CallableStatement</code>连接上的实例。
    </p>
    <p>语句按连接缓存。对于属于同一池的所有连接，该计数限制是全局计数的。一旦达到计数<code>max</code> ，后续语句不会返回到缓存，而是立即关闭。
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">prepared</code></td><td>
        <p>（布尔值作为字符串）启用缓存<code>PreparedStatement</code>使用创建的实例<code>prepareStatement</code>电话。默认值为<code>true</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">callable</code></td><td>
        <p>（布尔值作为字符串）启用缓存<code>CallableStatement</code>使用创建的实例<code>prepareCall</code>电话。默认值为<code>false</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">max</code></td><td>
        <p>（以String形式表示）（整数）限制整个连接池中缓存的语句的数量。默认值为<code>50</code> 。
        </p>
      </td></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor">org.apache.tomcat.jdbc.pool.interceptor。StatementDecoratorInterceptor</h4><div class="text">
    <p>参见<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=48392">48392</a> 。拦截器包装语句和结果集，以防止使用方法访问实际连接<code>ResultSet.getStatement().getConnection()</code>和<code>Statement.getConnection()</code>
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.QueryTimeoutInterceptor">org.apache.tomcat.jdbc.pool.interceptor。QueryTimeoutInterceptor</h4><div class="text">
    <p>自动通话<code>java.sql.Statement.setQueryTimeout(seconds)</code>创建新语句时。池本身不会使查询超时，它仍然由JDBC驱动程序来强制执行查询超时。
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><strong><code class="attributeName">queryTimeout</code></strong></td><td>
        <p>（以字符串形式int）要为查询超时设置的秒数。小于或等于零的值将禁用此功能。默认值为<code>1</code>秒。
        </p>
      </td></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport">org.apache.tomcat.jdbc.pool.interceptor。SlowQueryReport</h4><div class="text">
    <p>跟踪查询性能并在查询超过失败时间阈值时发出日志条目。使用的日志级别是<code>WARN</code>
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">threshold</code></td><td>
        <p>（以字符串形式int表示）发出日志警报之前查询必须超过的毫秒数。默认值为<code>1000</code>毫秒。
        </p>
      </td></tr><tr><td><code class="attributeName">maxQueries</code></td><td>
        <p>（int作为String）为了保留内存空间而要跟踪的最大查询数。小于或等于0的值将禁用此功能。默认值为<code>1000</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">logSlow</code></td><td>
        <p>（布尔值作为字符串）设置为<code>true</code>如果您希望记录慢查询。默认值为<code>true</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">logFailed</code></td><td>
        <p>（布尔值作为字符串）设置为<code>true</code>如果您希望记录失败的查询。默认值为<code>false</code> 。
        </p>
      </td></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx">org.apache.tomcat.jdbc.pool.interceptor。SlowQueryReportJmx</h4><div class="text">
    <p>扩展<code>SlowQueryReport</code>除了日志条目外，它还发出JMX通知，以使监视工具做出反应。从其父类继承所有属性。此类使用Tomcat的JMX引擎，因此它将无法在Tomcat容器之外工作。默认情况下，如果启用了JMX通知，则会通过ConnectionPool mbean发送该通知。的<code>SlowQueryReportJmx</code>也可以注册一个MBean <code>notifyPool=false</code>
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr><tr><td><code class="attributeName">notifyPool</code></td><td>
        <p>（布尔值作为字符串）如果您希望JMX通知转到<code>SlowQueryReportJmx</code> MBean的默认值为<code>true</code> 。
        </p>
      </td></tr><tr><td><code class="attributeName">objectName</code></td><td>
        <p>（字符串）定义一个有效的<code>javax.management.ObjectName</code>将用于向平台mbean服务器注册此对象的字符串。默认值为<code>null</code>并且将使用tomcat.jdbc：type = org.apache.tomcat.jdbc.pool.interceptor注册该对象。SlowQueryReportJmx，名称=池名称</p>
      </td></tr></tbody></table>
  </div></div>
  <div class="subsection"><h4 id="org.apache.tomcat.jdbc.pool.interceptor.ResetAbandonedTimer">org.apache.tomcat.jdbc.pool.interceptor。ResetAbandonedTimer</h4><div class="text">
    <p>从池中检出连接后，废弃的计时器将启动。这意味着，如果您有30秒的超时时间，并使用该连接运行10x10秒的查询，则将其标记为已废弃，并可能会被回收，具体取决于<code>abandonWhenPercentageFull</code>属性。使用此拦截器，每次您对连接执行操作或成功执行查询时，它将重置结帐计时器。
    </p>
    <table class="defaultTable"><tbody><tr><th style="width:15%">属性</th><th style="width:85%">描述</th></tr></tbody></table>
  </div></div>
</div><h3 id="Code_Example">代码示例</h3><div class="text">
  <p>可以<a href="https://tomcat.apache.org/tomcat-9.0-doc/jndi-datasource-examples-howto.html">在Tomcat文档中</a>找到有关JDBC使用的Tomcat配置的其他示例。</p>
  <div class="subsection"><h4 id="Plain_Ol'_Java">普通的爪哇</h4><div class="text">
    <p>这是有关如何创建和使用数据源的简单示例。</p>
<div class="codeBox"><pre><code>  import java.sql.Connection;
  import java.sql.ResultSet;
  import java.sql.Statement;

  import org.apache.tomcat.jdbc.pool.DataSource;
  import org.apache.tomcat.jdbc.pool.PoolProperties;

  public class SimplePOJOExample {

      public static void main(String[] args) throws Exception {
          PoolProperties p = new PoolProperties();
          p.setUrl("jdbc:mysql://localhost:3306/mysql");
          p.setDriverClassName("com.mysql.jdbc.Driver");
          p.setUsername("root");
          p.setPassword("password");
          p.setJmxEnabled(true);
          p.setTestWhileIdle(false);
          p.setTestOnBorrow(true);
          p.setValidationQuery("SELECT 1");
          p.setTestOnReturn(false);
          p.setValidationInterval(30000);
          p.setTimeBetweenEvictionRunsMillis(30000);
          p.setMaxActive(100);
          p.setInitialSize(10);
          p.setMaxWait(10000);
          p.setRemoveAbandonedTimeout(60);
          p.setMinEvictableIdleTimeMillis(30000);
          p.setMinIdle(10);
          p.setLogAbandoned(true);
          p.setRemoveAbandoned(true);
          p.setJdbcInterceptors(
            "org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;"+
            "org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer");
          DataSource datasource = new DataSource();
          datasource.setPoolProperties(p);

          Connection con = null;
          try {
            con = datasource.getConnection();
            Statement st = con.createStatement();
            ResultSet rs = st.executeQuery("select * from user");
            int cnt = 1;
            while (rs.next()) {
                System.out.println((cnt++)+". Host:" +rs.getString("Host")+
                  " User:"+rs.getString("User")+" Password:"+rs.getString("Password"));
            }
            rs.close();
            st.close();
          } finally {
            if (con!=null) try {con.close();}catch (Exception ignore) {}
          }
      }

  }</code></pre></div>
  </div></div>
  <div class="subsection"><h4 id="As_a_Resource">作为资源</h4><div class="text">
    <p>这是关于如何为JNDI查找配置资源的示例</p>
<div class="codeBox"><pre><code>&lt;Resource name="jdbc/TestDB"
          auth="Container"
          type="javax.sql.DataSource"
          factory="org.apache.tomcat.jdbc.pool.DataSourceFactory"
          testWhileIdle="true"
          testOnBorrow="true"
          testOnReturn="false"
          validationQuery="SELECT 1"
          validationInterval="30000"
          timeBetweenEvictionRunsMillis="30000"
          maxActive="100"
          minIdle="10"
          maxWait="10000"
          initialSize="10"
          removeAbandonedTimeout="60"
          removeAbandoned="true"
          logAbandoned="true"
          minEvictableIdleTimeMillis="30000"
          jmxEnabled="true"
          jdbcInterceptors="org.apache.tomcat.jdbc.pool.interceptor.ConnectionState;
            org.apache.tomcat.jdbc.pool.interceptor.StatementFinalizer"
          username="root"
          password="password"
          driverClassName="com.mysql.jdbc.Driver"
          url="jdbc:mysql://localhost:3306/mysql"/&gt;</code></pre></div>

  </div></div>
  <div class="subsection"><h4 id="Asynchronous_Connection_Retrieval">异步连接检索</h4><div class="text">
    <p>Tomcat JDBC连接池支持异步连接检索，而无需向池库中添加其他线程。它通过向数据源添加一个名为<code>Future<Connection> getConnectionAsync()</code> 。为了使用异步检索，必须满足两个条件：</p>
        <ol>
          <li>您必须配置<code>fairQueue</code>财产<code>true</code> 。</li>
          <li>您将必须将数据源转换为<code>org.apache.tomcat.jdbc.pool.DataSource</code></li>
        </ol>下面显示了使用异步功能的示例。
<div class="codeBox"><pre><code>  Connection con = null;
  try {
    Future&lt;Connection&gt; future = datasource.getConnectionAsync();
    while (!future.isDone()) {
      System.out.println("Connection is not yet available. Do some background work");
      try {
        Thread.sleep(100); //simulate work
      }catch (InterruptedException x) {
        Thread.currentThread().interrupt();
      }
    }
    con = future.get(); //should return instantly
    Statement st = con.createStatement();
    ResultSet rs = st.executeQuery("select * from user");</code></pre></div>

  </div></div>
  <div class="subsection"><h4 id="Interceptors">拦截器</h4><div class="text">
    <p>拦截器是启用，禁用或修改特定连接或其子组件上的功能的强大方法。当拦截器有用时，有许多不同的用例。默认情况下，由于性能原因，连接池是无状态的。池本身插入的唯一状态是<code>defaultAutoCommit</code> ， <code>defaultReadOnly</code> ， <code>defaultTransactionIsolation</code> ， <code>defaultCatalog</code>如果设置了这些。仅在创建连接时设置这4个属性。如果在使用连接期间修改了这些属性，则池本身不会重置它们。</p>
    <p>拦截器必须扩展<code>org.apache.tomcat.jdbc.pool.JdbcInterceptor</code>类。此类非常简单，您将需要一个无参数的构造函数</p>
<div class="codeBox"><pre><code>  public JdbcInterceptor() {
  }</code></pre></div>
    <p>当从池中借用连接时，拦截器可以通过执行以下操作来初始化事件或以其他方式对事件做出反应</p>
<div class="codeBox"><pre><code>  public abstract void reset(ConnectionPool parent, PooledConnection con);</code></pre></div>
    <p>方法。使用两个参数调用此方法，这是对连接池本身的引用<code>ConnectionPool parent</code>以及对基础连接的引用<code>PooledConnection con</code> 。
    </p>
    <p>当一个方法上<code>java.sql.Connection</code>对象被调用，将导致</p>
<div class="codeBox"><pre><code>  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</code></pre></div>
    <p>被调用的方法。的<code>Method method</code>是实际调用的方法，并且<code>Object[] args</code>是论据。让我们来看一个非常简单的示例，在该示例中，我们演示了如何调用<code>java.sql.Connection.close()</code>如果连接已关闭则无提示</p>
<div class="codeBox"><pre><code>  if (CLOSE_VAL==method.getName()) {
      if (isClosed()) return null; //noop for already closed.
  }
  return super.invoke(proxy,method,args);</code></pre></div>
    <p>正在观察。它是方法名称的比较。一种方法是<code>"close".equals(method.getName())</code> 。上面我们看到了方法名称和<code>static final String</code>参考。根据JVM规范，方法名称和静态最终String最终位于共享常量池中，因此引用比较应该起作用。当然也可以这样做：</p>
<div class="codeBox"><pre><code>  if (compare(CLOSE_VAL,method)) {
      if (isClosed()) return null; //noop for already closed.
  }
  return super.invoke(proxy,method,args);</code></pre></div>
    <p>的<code>compare(String,Method)</code>将使用<code>useEquals</code>标志在拦截器上并在引用比较或字符串值比较时<code>useEquals=true</code>标志已设置。
    </p>
    <p>泳池开始/停止<br>当启动或关闭连接池时，可以通知您。即使它是一个实例方法，每个拦截器类也只会通知您一次。并且会使用当前未附加到池中的拦截器来通知您。
    </p>
<div class="codeBox"><pre><code>  public void poolStarted(ConnectionPool pool) {
  }

  public void poolClosed(ConnectionPool pool) {
  }</code></pre></div>
    <p>覆盖这些方法时，如果要扩展除以下类以外的其他类，请不要忘记调用super <code>JdbcInterceptor</code>
    </p>
    <p>配置拦截器<br>拦截器使用<code>jdbcInterceptors</code>财产或<code>setJdbcInterceptors</code>方法。拦截器可以具有属性，并且可以这样配置</p>
<div class="codeBox"><pre><code>  String jdbcInterceptors=
    "org.apache.tomcat.jdbc.pool.interceptor.ConnectionState(useEquals=true,fast=yes)"</code></pre></div>

    <p>拦截器属性<br>由于拦截器可以具有属性，因此您需要能够在拦截器中读取这些属性的值。以上面的示例为例，您可以覆盖<code>setProperties</code>方法。
    </p>
<div class="codeBox"><pre><code>  public void setProperties(Map&lt;String, InterceptorProperty&gt; properties) {
     super.setProperties(properties);
     final String myprop = "myprop";
     InterceptorProperty p1 = properties.get(myprop);
     if (p1!=null) {
         setMyprop(Long.parseLong(p1.getValue()));
     }
  }</code></pre></div>

  </div></div>
  <div class="subsection"><h4 id="Getting_the_actual_JDBC_connection">获取实际的JDBC连接</h4><div class="text">
    <p>连接池在实际连接周围创建包装器，以正确地对其进行缓冲。我们还在这些包装器中创建拦截器，以执行某些功能。如果需要检索实际连接，则可以使用<code>javax.sql.PooledConnection</code>接口。
    </p>
<div class="codeBox"><pre><code>  Connection con = datasource.getConnection();
  Connection actual = ((javax.sql.PooledConnection)con).getConnection();</code></pre></div>

  </div></div>

</div><h3 id="Building">建造</h3><div class="text">
  <p>我们用1.6构建JDBC池代码，但是对于运行时环境，它向下兼容到1.5。对于单元测试，我们使用1.6及更高版本</p>
  <p>可以<a href="https://tomcat.apache.org/tomcat-9.0-doc/jndi-datasource-examples-howto.html">在Tomcat文档中</a>找到有关JDBC使用的Tomcat配置的其他示例。</p>
  <div class="subsection"><h4 id="Building_from_source">从源头建造</h4><div class="text">
    <p>建造非常简单。池依赖于<code>tomcat-juli.jar</code>如果你想要<code>SlowQueryReportJmx</code></p>
<div class="codeBox"><pre><code>  javac -classpath tomcat-juli.jar \
        -d . \
        org/apache/tomcat/jdbc/pool/*.java \
        org/apache/tomcat/jdbc/pool/interceptor/*.java \
        org/apache/tomcat/jdbc/pool/jmx/*.java</code></pre></div>
    <p>可以在Tomcat <a href="https://svn.apache.org/viewvc/tomcat/trunk/modules/jdbc-pool/">源存储库中</a>找到一个构建文件。
    </p>
    <p>为方便起见，还包括一个构建文件，其中一个简单的构建命令将生成所需的所有文件。
    </p>
<div class="codeBox"><pre><code>  ant download  (downloads dependencies)
  ant build     (compiles and generates .jar files)
  ant dist      (creates a release package)
  ant test      (runs tests, expects a test database to be setup)</code></pre></div>

    <p>该系统是为Maven构建构建的，但确实会生成发行工件。只是图书馆本身。
    </p>
  </div></div>
</div><div class="noprint"><h3 id="comments_section">评论</h3><div class="text"><p class="notice"><strong>注意：</strong>此注释部分收集有关改进Apache Tomcat文档的建议。<br><br>如果您遇到问题并需要帮助，请阅读“ <a href="https://tomcat.apache.org/findhelp.html">查找帮助”</a>页面，然后在tomcat-users <a href="https://tomcat.apache.org/lists.html">邮件列表中</a>询问您的问题。不要在这里问这样的问题。这不是“问答”部分。<br><br><a href="./comments.html">这里</a>解释<a href="./comments.html">了</a> Apache Comments System。如果评论已被实施或被认为无效/偏离主题，则我们的主持人可能会将其删除。
                  </p><div id="comments_thread"></div></div></div></div></div></div></div><footer><div id="footer">版权所有©1999-2019，Apache软件基金会</div></footer></div></body></html>