<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>Trident API概述</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=2">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">Trident API概述</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>Trident中的核心数据模型是“流”，按一系列批次进行处理。流在集群中的节点之间分区，并且应用于流的操作跨每个分区并行应用。</p>

<p>Trident中有五种操作：</p>

<ol>
<li>本地适用于每个分区且不会引起网络传输的操作</li>
<li>对流进行重新分区但不更改内容的重新分区操作（涉及网络传输）</li>
<li>作为操作一部分进行网络传输的聚合操作</li>
<li>分组流上的操作</li>
<li>合并并加入</li>
</ol>

<h2 id="partition-local-operations">分区本地操作</h2>

<p>分区本地操作不涉及网络传输，并且独立应用于每个批处理分区。</p>

<h3 id="functions">功能</h3>

<p>一个函数接受一组输入字段，并发出零个或多个元组作为输出。输出元组的字段将附加到流中的原始输入元组。如果函数不发出任何元组，则将原始输入元组过滤掉。否则，将为每个输出元组复制输入元组。假设您具有以下功能：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFunction</span> <span class="kd">extends</span> <span class="n">BaseFunction</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>现在，假设您在变量“ mystream”中具有一个带有以下元组的字段[“ a”，“ b”，“ c”]的流：</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3]
[4, 1, 6]
[3, 0, 8]
</code></pre></div>
<p>如果运行此代码：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">),</span> <span class="k">new</span> <span class="n">MyFunction</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"d"</span><span class="o">)))</span>
</code></pre></div>
<p>结果元组将具有字段[“ a”，“ b”，“ c”，“ d”]，如下所示：</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3, 0]
[1, 2, 3, 1]
[4, 1, 6, 0]
</code></pre></div>
<h3 id="filters">筛选器</h3>

<p>过滤器将元组作为输入，并决定是否保留该元组。假设您有以下过滤器：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFilter</span> <span class="kd">extends</span> <span class="n">BaseFilter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isKeep</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>现在假设您具有带有字段[“ a”，“ b”，“ c”]的这些元组：</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3]
[2, 1, 1]
[2, 3, 4]
</code></pre></div>
<p>如果您运行以下代码：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">MyFilter</span><span class="o">())</span>
</code></pre></div>
<p>结果元组将是：</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3]
</code></pre></div>
<h3 id="map-and-flatmap">地图和flatMap</h3>

<p><code>map</code>返回一个流，该流包括将给定映射函数应用于该流的元组的结果。这可用于对元组进行一对一转换。</p>

<p>例如，如果有单词流，并且想要将其转换为大写单词流，则可以如下定义映射函数，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UpperCase</span> <span class="kd">extends</span> <span class="n">MapFunction</span> <span class="o">{</span>
 <span class="nd">@Override</span>
 <span class="kd">public</span> <span class="n">Values</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">return</span> <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">toUpperCase</span><span class="o">());</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>然后可以将映射函数应用于流，以生成大写单词流。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">UpperCase</span><span class="o">())</span>
</code></pre></div>
<p><code>flatMap</code>类似于<code>map</code>但具有对流的值进行一对多转换，然后将生成的元素展平到新流中的效果。</p>

<p>例如，如果有句子流，而您想将其转换为单词流，则可以按以下方式定义flatMap函数，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Split</span> <span class="kd">extends</span> <span class="n">FlatMapFunction</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Values</span><span class="o">&gt;</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Values</span><span class="o">&gt;</span> <span class="n">valuesList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">input</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">valuesList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">valuesList</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>然后，可以将flatMap函数应用于句子流以生成单词流，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Split</span><span class="o">())</span>
</code></pre></div>
<p>当然，这些操作可以链接在一起，因此可以从句子流中获取大写单词流，如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Split</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">UpperCase</span><span class="o">())</span>
</code></pre></div>
<p>如果不将输出字段作为参数传递，则map和flatMap会将输入字段保留为输出字段。</p>

<p>如果您要应用MapFunction或FlatMapFunction并用新的输出字段替换旧字段，则可以使用以下附加Fields参数调用map / flatMap，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">UpperCase</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"uppercased"</span><span class="o">))</span>
</code></pre></div>
<p>无论先前流具有什么输出字段，输出流都将仅具有一个“大写”输出字段。同样的情况也适用于flatMap，因此跟随也是有效的，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
</code></pre></div>
<h3 id="peek">窥视</h3>

<p><code>peek</code>可以用于在每个三叉戟元组流过流时对其执行附加操作。这对于调试查看元组流过管道中的特定点可能很有用。</p>

<p>例如，下面的代码将打印将单词传递给大写字母的结果，然后再将它们传递给<code>groupBy</code></p>
<div class="highlight"><pre><code class="language-java" data-lang="java"> <span class="n">mystream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Split</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">UpperCase</span><span class="o">())</span>
         <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="k">new</span> <span class="n">Consumer</span><span class="o">()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
                <span class="o">}</span>
         <span class="o">})</span>
         <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
         <span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">MemoryMapState</span><span class="o">.</span><span class="na">Factory</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<h3 id="min-and-minby">min和minBy</h3>

<p><code>min</code>和<code>minBy</code>三叉戟流中的操作会在一批元组的每个分区上返回最小值。</p>

<p>假设三叉戟流包含字段[“ device-id”，“ count”]和以下元组分区</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[123, 2]
[113, 54]
[23,  28]
[237, 37]
[12,  23]
[62,  17]
[98,  42]

Partition 1:
[64,  18]
[72,  54]
[2,   28]
[742, 71]
[98,  45]
[62,  12]
[19,  174]


Partition 2:
[27,  94]
[82,  23]
[9,   86]
[53,  71]
[74,  37]
[51,  49]
[37,  98]
</code></pre></div>
<p><code>minBy</code>可以对上面的元组流进行以下操作，如下所示，这会导致发出的元组的最小值为<code>count</code>每个分区中的字段。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">  <span class="n">mystream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>上面提到的分区上的代码的结果是：</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[123, 2]


Partition 1:
[62,  12]


Partition 2:
[82,  23]
</code></pre></div>
<p>你可以看看其他<code>min</code>和<code>minBy</code>流上的操作<code>java public <T> Stream minBy(String inputFieldName, Comparator<T> comparator) public Stream min(Comparator<TridentTuple> comparator)</code>下面的示例显示如何使用这些API在元组上使用相应的比较器查找最小值。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
        <span class="n">FixedBatchSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FixedBatchSpout</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">Vehicle</span><span class="o">.</span><span class="na">generateVehicles</span><span class="o">(</span><span class="mi">20</span><span class="o">));</span>

        <span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
        <span class="n">Stream</span> <span class="n">vehiclesStream</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">).</span>
                <span class="n">each</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"##### vehicles"</span><span class="o">));</span>

        <span class="n">Stream</span> <span class="n">slowVehiclesStream</span> <span class="o">=</span>
                <span class="n">vehiclesStream</span>
                        <span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="k">new</span> <span class="n">SpeedComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t speed on received tuple.</span>
                        <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### slowest vehicle"</span><span class="o">));</span>

        <span class="n">vehiclesStream</span>
                <span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="n">Vehicle</span><span class="o">.</span><span class="na">FIELD_NAME</span><span class="o">,</span> <span class="k">new</span> <span class="n">EfficiencyComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t efficiency on received tuple.</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### least efficient vehicle"</span><span class="o">));</span>

</code></pre></div>
<p>这些API的示例应用程序可以位于<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfDevicesTopology.java">TridentMinMaxOfDevicesTopology</a>和<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfVehiclesTopology.java">TridentMinMaxOfVehiclesTopology</a> </p>

<h3 id="max-and-maxby">max和maxBy</h3>

<p><code>max</code>和<code>maxBy</code>操作在三叉戟流中返回一批元组的每个分区上的最大值。</p>

<p>假设三叉戟流包含上一节中提到的字段[“ device-id”，“ count”]。</p>

<p><code>max</code>和<code>maxBy</code>可以对上述元组流进行以下操作，如下所示，这会导致发出最大值为的元组<code>count</code>每个分区的字段。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">  <span class="n">mystream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>上面提到的分区上的代码的结果是：</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[113, 54]


Partition 1:
[19,  174]


Partition 2:
[37,  98]

</code></pre></div>
<p>你可以看看其他<code>max</code>和<code>maxBy</code>流上的功能</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
      <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stream</span> <span class="nf">maxBy</span><span class="o">(</span><span class="n">String</span> <span class="n">inputFieldName</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> 
      <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">max</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> 

</code></pre></div>
<p>下例显示了如何使用元组上的各个比较器将这些API用于查找最大值。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
        <span class="n">FixedBatchSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FixedBatchSpout</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">Vehicle</span><span class="o">.</span><span class="na">generateVehicles</span><span class="o">(</span><span class="mi">20</span><span class="o">));</span>

        <span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
        <span class="n">Stream</span> <span class="n">vehiclesStream</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">).</span>
                <span class="n">each</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"##### vehicles"</span><span class="o">));</span>

        <span class="n">vehiclesStream</span>
                <span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="k">new</span> <span class="n">SpeedComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t speed on received tuple.</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### fastest vehicle"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="n">driverField</span><span class="o">)</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">driverField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"##### fastest driver"</span><span class="o">));</span>

        <span class="n">vehiclesStream</span>
                <span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="n">Vehicle</span><span class="o">.</span><span class="na">FIELD_NAME</span><span class="o">,</span> <span class="k">new</span> <span class="n">EfficiencyComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t efficiency on received tuple.</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### most efficient vehicle"</span><span class="o">));</span>

</code></pre></div>
<p>这些API的示例应用程序可以位于<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfDevicesTopology.java">TridentMinMaxOfDevicesTopology</a>和<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfVehiclesTopology.java">TridentMinMaxOfVehiclesTopology</a> </p>

<h3 id="windowing">加窗</h3>

<p>三叉戟流可以批量处理具有相同窗口的元组，并将汇总结果发送到下一个操作。根据处理时间或元组计数支持两种加窗：1。翻滚窗口2。滑动窗口</p>

<h4 id="tumbling-window">翻滚窗口</h4>

<p>元组根据处理时间或计数分组在单个窗口中。任何元组仅属于其中一个窗口。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a tumbling window with every {@code windowCount} of tuples.
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">tumblingWindow</span><span class="o">(</span><span class="kt">int</span> <span class="n">windowCount</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span>
                                      <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>

    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a window that tumbles at duration of {@code windowDuration}
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">tumblingWindow</span><span class="o">(</span><span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Duration</span> <span class="n">windowDuration</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span>
                                     <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>

</code></pre></div>
<h4 id="sliding-window">滑动窗口</h4>

<p>在每个滑动间隔中，元组都在窗口和窗口幻灯片中分组。一个元组可以属于多个窗口。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a sliding window with every {@code windowCount} of tuples
     * and slides the window after {@code slideCount}.
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">slidingWindow</span><span class="o">(</span><span class="kt">int</span> <span class="n">windowCount</span><span class="o">,</span> <span class="kt">int</span> <span class="n">slideCount</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span>
                                      <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>

    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a window which slides at duration of {@code slidingInterval}
     * and completes a window at {@code windowDuration}
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">slidingWindow</span><span class="o">(</span><span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Duration</span> <span class="n">windowDuration</span><span class="o">,</span> <span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Duration</span> <span class="n">slidingInterval</span><span class="o">,</span>
                                    <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>
</code></pre></div>
<p>在<a href="Windowing.html">这里</a>可以找到翻滚和滑动窗口的示例</p>

<h4 id="common-windowing-api">通用窗口API</h4>

<p>以下是常用的窗口API， <code>WindowConfig</code>对于任何受支持的窗口配置。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">window</span><span class="o">(</span><span class="n">WindowConfig</span> <span class="n">windowConfig</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span>
                         <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">)</span>

</code></pre></div>
<p><code>windowConfig</code>可以是以下任何一个。-- <code>SlidingCountWindow.of(int windowCount, int slidingCount)</code> -- <code>SlidingDurationWindow.of(BaseWindowedBolt.Duration windowDuration, BaseWindowedBolt.Duration slidingDuration)</code> -- <code>TumblingCountWindow.of(int windowLength)</code> --<code>TumblingDurationWindow.of(BaseWindowedBolt.Duration windowLength)</code></p>

<p>三叉戟窗口API需要<code>WindowsStoreFactory</code>存储收到的元组和汇总值。目前，HBase的基本实现已通过<code>HBaseWindowsStoreFactory</code> 。可以进一步扩展以解决各个用例。使用范例<code>HBaseWindowStoreFactory</code>可以在下面看到窗口。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="c1">// window-state table should already be created with cf:tuples column</span>
    <span class="n">HBaseWindowsStoreFactory</span> <span class="n">windowStoreFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HBaseWindowsStoreFactory</span><span class="o">(</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;(),</span> <span class="s">"window-state"</span><span class="o">,</span> <span class="s">"cf"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">),</span> <span class="s">"tuples"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">));</span>
    <span class="n">FixedBatchSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FixedBatchSpout</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="mi">3</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="s">"the cow jumped over the moon"</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"the man went to the store and bought some candy"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="s">"four score and seven years ago"</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"how many apples can you eat"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="s">"to be or not to be the person"</span><span class="o">));</span>
    <span class="n">spout</span><span class="o">.</span><span class="na">setCycle</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

    <span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>

    <span class="n">Stream</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">).</span><span class="na">parallelismHint</span><span class="o">(</span><span class="mi">16</span><span class="o">).</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingCountWindow</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1000</span><span class="o">),</span> <span class="n">windowStoreFactory</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">),</span> <span class="k">new</span> <span class="n">CountAsAggregator</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="k">new</span> <span class="n">Consumer</span><span class="o">()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Received tuple: [{}]"</span><span class="o">,</span> <span class="n">input</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>

    <span class="n">StormTopology</span> <span class="n">stormTopology</span> <span class="o">=</span>  <span class="n">topology</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>

</code></pre></div>
<p>您可以在<a href="javadocs/org/apache/storm/trident/Stream.html">此处</a>找到上述所有API的详细说明  </p>

<h4 id="example-applications">应用范例</h4>

<p>这些API的示例应用程序位于<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentHBaseWindowingStoreTopology.java">TridentHBaseWindowingStoreTopology</a>和<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentWindowingInmemoryStoreTopology.java">TridentWindowingInmemoryStoreTopology</a> </p>

<h3 id="partitionaggregate">partitionAggregate</h3>

<p>partitionAggregate在一批元组的每个分区上运行一个函数。与函数不同，partitionAggregate发出的元组将替换为其提供的输入元组。考虑以下示例：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">partitionAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sum"</span><span class="o">))</span>
</code></pre></div>
<p>假设输入流包含字段[“ a”，“ b”]和以下元组分区：</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
["a", 1]
["b", 2]

Partition 1:
["a", 3]
["c", 8]

Partition 2:
["e", 1]
["d", 9]
["d", 10]
</code></pre></div>
<p>然后，该代码的输出流将包含这些元组以及一个称为“ sum”的字段：</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[3]

Partition 1:
[11]

Partition 2:
[20]
</code></pre></div>
<p>定义聚合器有三种不同的接口：CombinerAggregator，ReducerAggregator和Aggregator。</p>

<p>这是CombinerAggregator的接口：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CombinerAggregator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">init</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">);</span>
    <span class="n">T</span> <span class="nf">combine</span><span class="o">(</span><span class="n">T</span> <span class="n">val1</span><span class="o">,</span> <span class="n">T</span> <span class="n">val2</span><span class="o">);</span>
    <span class="n">T</span> <span class="nf">zero</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>CombinerAggregator返回具有单个字段的单个元组作为输出。CombinerAggregator在每个输入元组上运行init函数，并使用Combine函数合并值，直到仅剩一个值为止。如果分区中没有元组，则CombinerAggregator会发出零函数的输出。例如，这是Count的实现：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Count</span> <span class="kd">implements</span> <span class="n">CombinerAggregator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">init</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">combine</span><span class="o">(</span><span class="n">Long</span> <span class="n">val1</span><span class="o">,</span> <span class="n">Long</span> <span class="n">val2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">zero</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>与聚合方法（而不是partitionAggregate）一起使用时，CombinerAggregator提供高效率（ <a href="#aggregation-operations">请参阅下文</a> ）。</p>

<p>ReducerAggregator具有以下接口：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ReducerAggregator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">init</span><span class="o">();</span>
    <span class="n">T</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">T</span> <span class="n">curr</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>ReducerAggregator会使用init生成一个初始值，然后针对每个输入元组对该值进行迭代，以生成具有单个值作为输出的单个元组。例如，以下是将Count定义为ReducerAggregator的方法：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Count</span> <span class="kd">implements</span> <span class="n">ReducerAggregator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Long</span> <span class="n">curr</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">curr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>ReducerAggregator也可以与persistentAggregate一起使用，您将在后面看到。</p>

<p>执行聚合的最通用的接口是Aggregator，如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Aggregator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Operation</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">init</span><span class="o">(</span><span class="n">Object</span> <span class="n">batchId</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">aggregate</span><span class="o">(</span><span class="n">T</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">complete</span><span class="o">(</span><span class="n">T</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>聚合器可以发出具有任意多个字段的任意数量的元组。它们可以在执行期间的任何时候发出元组。聚合器以以下方式执行：</p>

<ol>
<li>在处理批处理之前，将调用init方法。init的返回值是一个Object，它将表示聚合的状态并将传递到聚合和complete方法中。</li>
<li>将为批处理分区中的每个输入元组调用聚合方法。此方法可以更新状态并有选择地发出元组。</li>
<li>当批处理分区的所有元组都已通过聚合处理后，将调用complete方法。</li>
</ol>

<p>这是将Count实现为聚合器的方法：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountAgg</span> <span class="kd">extends</span> <span class="n">BaseAggregator</span><span class="o">&lt;</span><span class="n">CountState</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CountState</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">CountState</span> <span class="nf">init</span><span class="o">(</span><span class="n">Object</span> <span class="n">batchId</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CountState</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">aggregate</span><span class="o">(</span><span class="n">CountState</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">state</span><span class="o">.</span><span class="na">count</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">complete</span><span class="o">(</span><span class="n">CountState</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">count</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>有时您想同时执行多个聚合器。这称为链接，可以这样完成：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">chainedAgg</span><span class="o">()</span>
        <span class="o">.</span><span class="na">partitionAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">partitionAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sum"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">chainEnd</span><span class="o">()</span>
</code></pre></div>
<p>此代码将在每个分区上运行Count和Sum聚合器。输出将包含带有字段[“ count”，“ sum”]的单个元组。</p>

<h3 id="statequery-and-partitionpersist">stateQuery和partitionPersist</h3>

<p>stateQuery和partitionPersist分别查询和更新状态源。您可以在<a href="Trident-state.html">Trident state doc</a>上了解如何使用它们。</p>

<h3 id="projection">投影</h3>

<p>Stream上的投影方法仅保留操作中指定的字段。如果您的流具有字段[“ a”，“ b”，“ c”，“ d”]，并且您运行了以下代码：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">))</span>
</code></pre></div>
<p>输出流将仅包含字段[“ b”，“ d”]。</p>

<h2 id="repartitioning-operations">重新分区操作</h2>

<p>重新分区操作运行一个函数来更改元组在任务之间的分区方式。分区的数量也可以作为重新分区的结果而改变（例如，如果重新分区后并行提示更大）。重新分区需要网络传输。这是重新分区功能：</p>

<ol>
<li>随机播放：使用随机循环算法在所有目标分区上均匀地重新分配元组</li>
<li>广播：每个元组都复制到所有目标分区。这在DRPC期间很有用-例如，如果您需要对每个数据分区执行stateQuery。</li>
<li>partitionBy：partitionBy接受一组字段，并根据该组字段进行语义分区。这些字段将根据目标分区的数量进行散列和修改，以选择目标分区。 partitionBy保证相同的字段集始终进入相同的目标分区。</li>
<li>全局：所有元组都发送到同一分区。为流中的所有批次选择相同的分区。</li>
<li>batchGlobal：批处理中的所有元组都发送到同一分区。流中的不同批次可能会转到不同的分区。</li>
<li>partition：此方法采用实现org.apache.storm.grouping的自定义分区功能。CustomStreamGrouping</li>
</ol>

<h2 id="aggregation-operations">汇总操作</h2>

<p>Trident具有用于在流上进行聚合的aggregation和persistentAggregate方法。聚合是在流的每个批次上单独运行的，而persistentAggregate将在流中所有批次的所有元组上聚合，并将结果存储在状态源中。</p>

<p>在Stream上运行聚合会进行全局聚合。当您使用ReducerAggregator或Aggregator时，首先将流重新划分为单个分区，然后在该分区上运行聚合功能。另一方面，当您使用CombinerAggregator时，首先三叉戟将计算每个分区的部分聚合，然后重新分区为单个分区，然后在网络传输后完成聚合。CombinerAggregator的效率要高得多，应尽可能使用。</p>

<p>这是一个使用聚合获取批次全局计数的示例：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>像partitionAggregate一样，可以将用于聚合的聚合器链接起来。但是，如果将一个CombinerAggregator与一个非CombinerAggregator链接在一起，则Trident无法进行部分聚合优化。</p>

<p>您可以在<a href="Trident-state.html">Trident状态文档中</a>阅读有关如何使用persistentAggregate的更多信息。</p>

<h2 id="operations-on-grouped-streams">分组流上的操作</h2>

<p>groupBy操作通过在指定字段上执行partitionBy对流进行重新分区，然后在每个分区内将组字段相等的组元组组合在一起。例如，下面是groupBy操作的说明：</p>

<p><img src="images/grouping.png" alt="分组"></p>

<p>如果您在分组流上运行聚合器，则聚合将在每个组中而不是针对整个批次运行。 persistentAggregate也可以在GroupedStream上运行，在这种情况下，结果将存储在<a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/trident/state/map/MapState.java">MapState中</a> ，其键为分组字段。您可以在<a href="Trident-state.html">Trident状态doc中</a>阅读有关persistentAggregate的更多信息。</p>

<p>像常规流一样，可以将分组流上的聚合器链接起来。</p>

<h2 id="merges-and-joins">合并并加入</h2>

<p>API的最后一部分是将不同的流组合在一起。合并流的最简单方法是将它们合并为一个流。您可以使用TridentTopology＃merge方法执行此操作，如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">topology</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">stream1</span><span class="o">,</span> <span class="n">stream2</span><span class="o">,</span> <span class="n">stream3</span><span class="o">);</span>
</code></pre></div>
<p>Trident将把新的合并流的输出字段命名为第一个流的输出字段。</p>

<p>组合流的另一种方法是联接。现在，标准联接（如SQL中的那种联接）需要有限的输入。因此，它们对于无限流毫无意义。Trident中的联接仅适用于从喷嘴流出的每个小批量。</p>

<p>这是一个包含字段[“ key”，“ val1”，“ val2”]和另一个包含[“ x”，“ val1”]的流之间的连接示例：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">topology</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">stream1</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"key"</span><span class="o">),</span> <span class="n">stream2</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"x"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"key"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">));</span>
</code></pre></div>
<p>使用“键”和“ x”作为每个相应流的连接字段，将stream1和stream2连接在一起。然后，Trident要求命名新流的所有输出字段，因为输入流的字段名称可能重叠。从联接发出的元组将包含：</p>

<ol>
<li>首先，联接字段列表。在这种情况下，“密钥”对应于流1的“密钥”，而对应于流2的“ x”。</li>
<li>接下来，按流如何传递给join方法的顺序列出所有流的所有非联接字段。在这种情况下，“ a”和“ b”对应于流1的“ val1”和“ val2”，而“ c”对应于流2的“ val1”。</li>
</ol>

<p>当源于不同喷嘴的流之间发生联接时，这些喷嘴将与它们发出批次的方式同步。也就是说，一批处理将包括每个喷嘴的元组。</p>

<p>您可能想知道–您如何做类似“窗口式联接”的操作，其中联接的一侧的元组与联接另一侧的最后一小时的元组联接在一起。</p>

<p>为此，您将使用partitionPersist和stateQuery。来自联接一侧的元组的最后一小时将被存储并在状态源中旋转，并以联接字段为键。然后stateQuery将通过join字段进行查找以执行“ join”。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>