<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>三叉戟州</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=2">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">三叉戟州</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>Trident具有一流的抽象，可以读取和写入有状态源。状态可以是拓扑内部的（例如，保留在内存中并由HDFS支持），也可以外部存储在诸如Memcached或Cassandra之类的数据库中。在这两种情况下，Trident API都没有区别。</p>

<p>Trident以容错的方式管理状态，因此在重试和失败的情况下状态更新是幂等的。这使您可以对Trident拓扑进行推理，就好像每个消息都被处理一次一样。</p>

<p>执行状态更新时，可能会有各种级别的容错。在介绍这些内容之前，让我们看一个示例，该示例说明实现精确一次语义所必需的技巧。假设您正在对流进行计数汇总，并且想要将运行中的计数存储在数据库中。现在，假设您在数据库中存储了一个代表计数的单个值，并且每次处理一个新的元组时，都会增加计数。</p>

<p>发生故障时，将重播元组。这在进行状态更新（或任何有副作用的东西）时会带来一个问题-您不知道您是否曾经成功基于该元组成功更新状态。也许您以前从未处理过元组，在这种情况下，应增加计数。也许您已经处理了元组并成功增加了计数，但是元组在另一步骤中失败了。在这种情况下，您不应增加计数。或者，也许您之前看过元组，但是在更新数据库时出错。在这种情况下，您<em>应该</em>更新数据库。</p>

<p>通过仅将计数存储在数据库中，您不知道此元组是否已被处理过。因此，您需要更多信息才能做出正确的决定。Trident提供了以下语义，足以实现一次精确的处理语义：</p>

<ol>
<li>元组被小批量处理（请参阅<a href="Trident-tutorial.html">教程</a> ）</li>
<li>每批元组都有一个唯一的ID，称为“交易ID”（txid）。如果重播该批处理，则会给出完全相同的txid。</li>
<li>状态更新是按批次排序的。也就是说，直到成功完成批次2的状态更新后，才会应用批次3的状态更新。</li>
</ol>

<p>使用这些原语，您的State实现可以检测之前是否已处理该批元组，并采取适当的操作以一致的方式更新该状态。您要采取的行动取决于您的输入喷口提供的确切语义，包括每批中的内容。关于容错，可能有三种喷口：“非事务性”，“事务性”和“不透明事务性”。同样，就容错而言，存在三种状态：“非事务性”，“事务性”和“不透明事务性”。让我们看一下每种喷口类型，看看每种喷口可以实现什么样的容错能力。</p>

<h2 id="transactional-spouts">交易喷口</h2>

<p>请记住，Trident将元组作为小批处理，每个批处理都被赋予唯一的交易ID。壶嘴的属性根据它们可以提供的关于每批物品的保证而变化。事务性喷口具有以下属性：</p>

<ol>
<li>给定txid的批次始终相同。一个txid的批次重播将与第一次为该txid发出该批次的元组完全相同。</li>
<li>批处理元组之间没有重叠（元组在一批或另一批中，从不多个）。</li>
<li>每个元组都是一个批处理（不跳过任何元组）</li>
</ol>

<p>这是一种非常容易理解的喷口类型，流分为固定的批次，不会改变。Storm为Kafka <a href="http://github.com/apache/storm/tree/v2.1.0/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/trident/KafkaTridentSpoutTransactional">实现了事务处理喷口</a> 。</p>

<p>您可能想知道–为什么您不总是使用事务性喷口？它们简单易懂。您可能不使用其中一种的原因是，它们不一定具有很高的容错能力。例如，TransactionalTridentKafkaSpout的工作方式是txid的批处理，它将包含一个主题的所有Kafka分区中的元组。发出批次后，将来任何时候重新发出该批次时，都必须发出完全相同的元组集，以满足事务喷口的语义。现在，假设从TransactionalTridentKafkaSpout发出了一个批次，该批次无法处理，并且同时一个Kafka节点发生故障。现在，您无法像以前一样重播相同的批处理（因为节点关闭并且该主题的某些分区不可用），处理将停止。</p>

<p>这就是为什么存在“不透明的事务处理”喷口的原因-它们可以容错丢失源节点，同时仍然允许您实现一次精确的处理语义。我们将在下一部分中介绍这些喷口。</p>

<p>（一个旁注–一旦Kafka支持复制，将有可能具有容错能力来防止节点故障，但是该功能尚不存在。）</p>

<p>在介绍“不透明的事务处理”喷口之前，让我们看一下如何设计一种状态实现，该实现对事务处理喷口具有完全一次的语义。此状态类型称为“事务状态”，并利用以下事实：任何给定的txid始终与完全相同的元组集相关联。</p>

<p>假设您的拓扑计算字数，并且您要将字数存储在键/值数据库中。键将是单词，并且值将包含计数。您已经看到仅将计数存储为值不足以知道您之前是否处理过一批元组。相反，您可以做的是将事务ID和计数作为原子值存储在数据库中。然后，在更新计数时，您只需将数据库中的交易ID与当前批次的交易ID进行比较即可。如果它们相同，则跳过更新-由于顺序强大，因此您可以肯定地知道数据库中的值包含当前批次。如果它们不同，则增加计数。该逻辑之所以有效，是因为txid的批次永不更改，并且Trident确保状态更新在批次之间进行排序。</p>

<p>考虑这个为什么起作用的例子。假设您正在处理txid 3，它由以下一批元组组成：</p>
<div class="highlight"><pre><code class="language-" data-lang="">["man"]
["man"]
["dog"]
</code></pre></div>
<p>假设数据库当前包含以下键/值对：</p>
<div class="highlight"><pre><code class="language-" data-lang="">man =&gt; [count=3, txid=1]
dog =&gt; [count=4, txid=3]
apple =&gt; [count=10, txid=2]
</code></pre></div>
<p>与“ man”相关联的txid是txid 1。由于当前的txid为3，因此您可以肯定地知道在该计数中未表示这批元组。因此，您可以继续将计数加2并更新txid。另一方面，“ dog”的txid与当前txid相同。因此，您可以确定数据库中已经为“ dog”键表示了当前批次的增量。因此，您可以跳过更新。完成更新后，数据库如下所示：</p>
<div class="highlight"><pre><code class="language-" data-lang="">man =&gt; [count=5, txid=3]
dog =&gt; [count=4, txid=3]
apple =&gt; [count=10, txid=2]
</code></pre></div>
<p>现在，让我们看一下不透明的事务处理喷嘴，以及如何为该类型的喷嘴设计状态。</p>

<h2 id="opaque-transactional-spouts">不透明的交易喷口</h2>

<p>如前所述，不透明的事务处理喷嘴无法保证txid的元组批次保持恒定。不透明的事务处理喷口具有以下属性：</p>

<ol>
<li>每个元组仅在一批中被<em>成功</em>处理。但是，元组有可能无法在一批中处理，然后在以后的一批中成功处理。</li>
</ol>

<p><a href="http://github.com/apache/storm/tree/v2.1.0/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/trident/KafkaTridentSpoutOpaque.java">KafkaTridentSpoutOpaque</a>是具有此属性的喷口，可以容忍丢失Kafka节点。每当KafkaTridentSpoutOpaque发出一次批处理时，它就会从最后一个批处理结束的地方开始发出元组。这样可以确保多个批处理都不会跳过或成功处理任何元组。</p>

<p>使用不透明的事务处理喷口，如果数据库中的事务处理ID与当前批次的事务处理ID相同，则不再可以使用跳过状态更新的技巧。这是因为批次可能在状态更新之间已更改。</p>

<p>您可以做的是在数据库中存储更多状态。与其在数据库中存储值和交易ID，不如在数据库中存储值，交易ID和先前的值。让我们再次使用将计数存储在数据库中的示例。假设您的批次的部分计数为“ 2”，是时候应用状态更新了。假设数据库中的值如下所示：</p>
<div class="highlight"><pre><code class="language-" data-lang="">{ value = 4,
  prevValue = 1,
  txid = 2
}
</code></pre></div>
<p>假设您当前的txid为3，与数据库中的不同。在这种情况下，将“ prevValue”设置为等于“ value”，将“ value”增加部分计数，然后更新txid。新的数据库值将如下所示：</p>
<div class="highlight"><pre><code class="language-" data-lang="">{ value = 6,
  prevValue = 4,
  txid = 3
}
</code></pre></div>
<p>现在假设您当前的txid为2，等于数据库中的值。现在，您知道数据库中的“值”包含当前txid的先前批次的更新，但是该批次可能有所不同，因此您必须忽略它。在这种情况下，您要做的是将“ prevValue”增加部分计数，以计算新的“值”。然后，您将数据库中的值设置为此：</p>
<div class="highlight"><pre><code class="language-" data-lang="">{ value = 3,
  prevValue = 1,
  txid = 2
}
</code></pre></div>
<p>之所以能够成功，是因为Trident提供了强大的批处理顺序。一旦Trident移至新批次以进行状态更新，它将永远不会返回到先前的批次。而且，由于不透明的事务处理喷口保证了批次之间没有重叠-每个元组都可以被一个批次成功处理-您可以根据先前的值安全地进行更新。</p>

<h2 id="non-transactional-spouts">非交易喷嘴</h2>

<p>非事务性喷口不保证每批次中的含量。因此，它最多只能进行一次处理，在这种情况下，批处理失败后将不会重试元组。或者它可能至少要进行一次处理，其中元组可以被多个批次成功处理。对于这种喷口，无法实现一次精确的语义。</p>

<h2 id="summary-of-spout-and-state-types">喷口和状态类型摘要</h2>

<p>下图显示了喷口/状态的哪些组合启用了一次精确的消息传递语义：</p>

<p><img src="images/spout-vs-state.png" alt="壶嘴vs州"></p>

<p>不透明的事务状态具有最强的容错能力，但这是以需要在数据库中存储txid和两个值为代价的。事务状态需要较少的数据库状态，但仅适用于事务喷口。最后，非事务状态需要数据库中最少的状态，但不能实现一次精确的语义。</p>

<p>您选择的状态和喷口类型是容错和存储成本之间的权衡，最终您的应用程序需求将确定哪种组合最适合您。</p>

<h2 id="state-apis">状态API</h2>

<p>您已经了解了实现精确一次语义所需要的复杂性。关于Trident的好处是，它将内部的所有容错逻辑内在化了–作为用户，您不必处理比较txid，在数据库中存储多个值或类似的事情。您可以编写如下代码：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>        
<span class="n">TridentState</span> <span class="n">wordCounts</span> <span class="o">=</span>
      <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="n">MemcachedState</span><span class="o">.</span><span class="na">opaque</span><span class="o">(</span><span class="n">serverLocations</span><span class="o">),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>                
        <span class="o">.</span><span class="na">parallelismHint</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
</code></pre></div>
<p>MemcachedState.opaque调用内部化了管理不透明事务状态逻辑所需的所有逻辑。此外，更新将自动进行批处理，以最大程度地减少数据库往返次数。</p>

<p>基本State接口只有两种方法：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">beginCommit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">);</span> <span class="c1">// can be null for things like partitionPersist occurring off a DRPC stream</span>
    <span class="kt">void</span> <span class="nf">commit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>系统会通知您状态更新开始的时间，状态更新结束的时间以及每种情况下的txid。Trident不假设您的状态如何工作，有什么方法可以更新状态以及可以从状态中读取什么方法。</p>

<p>假设您有一个包含用户位置信息的本地数据库，并且希望能够从Trident访问它。您的州实施将具有获取和设置用户信息的方法：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationDB</span> <span class="kd">implements</span> <span class="n">State</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beginCommit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">commit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLocation</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="n">String</span> <span class="n">location</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// code to access database and set location</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getLocation</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// code to get location from database</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>然后，您为Trident提供一个StateFactory，该工厂可以在Trident任务中创建State对象的实例。LocationDB的StateFactory可能看起来像这样：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationDBFactory</span> <span class="kd">implements</span> <span class="n">StateFactory</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="n">State</span> <span class="nf">makeState</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="kt">int</span> <span class="n">partitionIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numPartitions</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">LocationDB</span><span class="o">();</span>
   <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div>
<p>Trident提供了用于编写查询状态源的Trident操作的QueryFunction接口，以及用于编写更新状态源的Trident操作的StateUpdater接口。例如，让我们编写一个操作“ QueryLocation”，该查询在LocationDB中查询用户的位置。让我们从如何在拓扑中使用它开始。假设此拓扑消耗了用户ID的输入流：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
<span class="n">TridentState</span> <span class="n">locations</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStaticState</span><span class="o">(</span><span class="k">new</span> <span class="n">LocationDBFactory</span><span class="o">());</span>
<span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"myspout"</span><span class="o">,</span> <span class="n">spout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">stateQuery</span><span class="o">(</span><span class="n">locations</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"userid"</span><span class="o">),</span> <span class="k">new</span> <span class="n">QueryLocation</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"location"</span><span class="o">))</span>
</code></pre></div>
<p>现在让我们看一下QueryLocation的实现是什么样的：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QueryLocation</span> <span class="kd">extends</span> <span class="n">BaseQueryFunction</span><span class="o">&lt;</span><span class="n">LocationDB</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">batchRetrieve</span><span class="o">(</span><span class="n">LocationDB</span> <span class="n">state</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="nl">input:</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">getLocation</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">String</span> <span class="n">location</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">location</span><span class="o">));</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div>
<p>QueryFunction的执行分为两个步骤。首先，Trident收集一批读取，并将它们传递给batchRetrieve。在这种情况下，batchRetrieve将收到多个用户ID。 batchRetrieve预期将返回与输入元组列表大小相同的结果列表。结果列表的第一个元素对应于第一个输入元组的结果，第二个元素对应于第二个输入元组的结果，依此类推。</p>

<p>您可以看到此代码没有利用Trident的批处理功能，因为它一次只查询LocationDB。因此，编写LocationDB的更好方法是这样的：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationDB</span> <span class="kd">implements</span> <span class="n">State</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beginCommit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">commit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLocationsBulk</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">userIds</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">locations</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// set locations in bulk</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">bulkGetLocations</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">userIds</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// get locations in bulk</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>然后，您可以编写QueryLocation函数，如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QueryLocation</span> <span class="kd">extends</span> <span class="n">BaseQueryFunction</span><span class="o">&lt;</span><span class="n">LocationDB</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">batchRetrieve</span><span class="o">(</span><span class="n">LocationDB</span> <span class="n">state</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">userIds</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="nl">input:</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">userIds</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">bulkGetLocations</span><span class="o">(</span><span class="n">userIds</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">String</span> <span class="n">location</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">location</span><span class="o">));</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div>
<p>通过减少到数据库的往返次数，此代码将更加高效。</p>

<p>要更新状态，请使用StateUpdater接口。这是一个StateUpdater，它使用新的位置信息更新LocationDB：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationUpdater</span> <span class="kd">extends</span> <span class="n">BaseStateUpdater</span><span class="o">&lt;</span><span class="n">LocationDB</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateState</span><span class="o">(</span><span class="n">LocationDB</span> <span class="n">state</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">tuples</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">ids</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">locations</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="nl">t:</span> <span class="n">tuples</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ids</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">locations</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">state</span><span class="o">.</span><span class="na">setLocationsBulk</span><span class="o">(</span><span class="n">ids</span><span class="o">,</span> <span class="n">locations</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>这是在Trident拓扑中使用此操作的方式：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
<span class="n">TridentState</span> <span class="n">locations</span> <span class="o">=</span> 
    <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"locations"</span><span class="o">,</span> <span class="n">locationsSpout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">partitionPersist</span><span class="o">(</span><span class="k">new</span> <span class="n">LocationDBFactory</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"userid"</span><span class="o">,</span> <span class="s">"location"</span><span class="o">),</span> <span class="k">new</span> <span class="n">LocationUpdater</span><span class="o">())</span>
</code></pre></div>
<p>partitionPersist操作将更新状态源。StateUpdater接收状态和一批具有该状态更新的元组。这段代码只是从输入元组中获取用户ID和位置，并在State中进行批量设置。</p>

<p>partitionPersist返回一个TridentState对象，该对象表示由Trident拓扑更新的位置db。然后，您可以在拓扑中其他位置的stateQuery操作中使用此状态。</p>

<p>您还可以看到为StateUpdaters提供了TridentCollector。发射到此收集器的元组进入“新值流”。在这种情况下，没有什么有趣的事情可以发送到该流，但是如果您正在执行诸如更新数据库中计数的操作，则可以将更新后的计数发送到该流。然后，您可以通过TridentState＃newValuesStream方法访问新值流，以进行进一步处理。</p>

<h2 id="persistentaggregate">持久聚合</h2>

<p>三叉戟有另一种更新状态的方法，称为persistentAggregate。您已经在流式字数示例中看到了此用法，如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>        
<span class="n">TridentState</span> <span class="n">wordCounts</span> <span class="o">=</span>
      <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">MemoryMapState</span><span class="o">.</span><span class="na">Factory</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>persistentAggregate是在partitionPersist之上构建的附加抽象，它知道如何获取Trident聚合器并将其用于将更新应用于状态源。在这种情况下，由于这是一个分组的流，因此Trident希望您提供的状态能够实现“ MapState”接口。分组字段将是状态中的键，聚合结果将是状态中的值。“ MapState”界面如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MapState</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">State</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">multiGet</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">multiUpdate</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ValueUpdater</span><span class="o">&gt;</span> <span class="n">updaters</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">multiPut</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vals</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>当您在非分组流上进行聚合（全局聚合）时，Trident希望您的State对象实现“ Snapshottable”接口：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Snapshottable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">State</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">get</span><span class="o">();</span>
    <span class="n">T</span> <span class="nf">update</span><span class="o">(</span><span class="n">ValueUpdater</span> <span class="n">updater</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/trident/testing/MemoryMapState.java">MemoryMapState</a>和<a href="https://github.com/nathanmarz/trident-memcached/blob/2.1.0/src/jvm/trident/memcached/MemcachedState.java">MemcachedState</a>均实现这两个接口。</p>

<h2 id="implementing-map-states">实施地图状态</h2>

<p>Trident使实现MapState变得容易，几乎为您完成了所有工作。OpaqueMap，TransactionalMap和NonTransactionalMap类实现了用于执行各自的容错逻辑的所有逻辑。您只需为这些类提供IBackingMap实现即可，该实现知道如何对各个键/值进行multiGets和multiPuts。IBackingMap看起来像这样：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IBackingMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">multiGet</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">);</span> 
    <span class="kt">void</span> <span class="nf">multiPut</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vals</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div>
<p>OpaqueMap将为val调用multiPut，而<a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/trident/state/OpaqueValue.java">OpaqueValue则为</a>调用，TransactionalMap将为vals提供<a href="http://github.com/apache/storm/blob/v2.1.0/storm-core/src/jvm/org/apache/storm/trident/state/TransactionalValue.java">TransactionalValue</a> ，并且NonTransactionalMaps将从拓扑中传递对象。</p>

<p>Trident还提供了<a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/trident/state/map/CachedMap.java">CachedMap</a>类来对映射键/值进行自动LRU缓存。</p>

<p>最后，Trident通过将全局聚合存储到固定键中，提供了<a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/trident/state/map/SnapshottableMap.java">SnapshottableMap</a>类，该类将MapState转换为Snapshottable对象。</p>

<p>查看<a href="https://github.com/nathanmarz/trident-memcached/blob/master/src/jvm/trident/memcached/MemcachedState.java">MemcachedState</a>的实现，以了解如何将所有这些实用程序组合在一起以实现高性能的MapState实现。MemcachedState允许您在不透明的事务，事务和非事务语义之间进行选择。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>