<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>资源感知调度程序</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=0">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">资源感知调度程序</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><h1 id="introduction">介绍</h1>

<p>本文档的目的是提供对Storm分布式实时计算系统的Resource Aware Scheduler的描述。本文档将为您提供有关Storm中资源感知调度程序的高级描述。在Hadoop Summit 2016的以下演示中概述了在Storm之上使用资源感知调度程序的一些好处：</p>

<p><a href="http://www.slideshare.net/HadoopSummit/resource-aware-scheduling-in-apache-storm">http://www.slideshare.net/HadoopSummit/resource-aware-scheduling-in-apache-storm</a></p>

<h1 id="table-of-contents">目录</h1>

<ol>
<li><a href="#Using-Resource-Aware-Scheduler">使用资源感知计划程序</a></li>
<li><a href="#API-Overview">API概述</a>

<ol>
<li><a href="#Setting-Memory-Requirement">设置内存需求</a></li>
<li><a href="#Setting-Shared-Memory">共享内存需求</a></li>
<li><a href="#Setting-CPU-Requirement">设置CPU要求</a></li>
<li><a href="#Limiting-the-Heap-Size-per-Worker-(JVM)Process">限制每个工作者（JVM）进程的堆大小</a></li>
<li><a href="#Setting-Available-Resources-on-Node">在节点上设置可用资源</a></li>
<li><a href="#Other-Configurations">其他配置</a></li>
</ol></li>
<li><a href="#Topology-Priorities-and-Per-User-Resource">拓扑优先级和每个用户资源</a>

<ol>
<li><a href="#Setup">设定</a></li>
<li><a href="#Specifying-Topology-Priority">指定拓扑优先级</a></li>
<li><a href="#Specifying-Scheduling-Strategy">指定调度策略</a></li>
<li><a href="#Specifying-Topology-Prioritization-Strategy">指定拓扑优先级策略</a></li>
</ol></li>
<li><a href="#Profiling-Resource-Usage">分析资源使用情况</a></li>
<li><a href="#Enhancements-on-original-DefaultResourceAwareStrategy">原始DefaultResourceAwareStrategy的增强功能</a></li>
</ol>

<p></p><div id="Using-Resource-Aware-Scheduler"></div><p></p>

<h2 id="using-resource-aware-scheduler">使用资源感知计划程序</h2>

<p>用户可以通过在<em>conf / storm.yaml中</em>设置以下内容来切换到使用资源感知计划程序
<code>storm.scheduler: “org.apache.storm.scheduler.resource.ResourceAwareScheduler”</code><br>
</p><div id="API-Overview"></div><p></p>

<h2 id="api-overview">API概述</h2>

<p>要与Trident一起使用，请参阅<a href="Trident-RAS-API.html">Trident RAS API</a></p>

<p>对于Storm拓扑，用户现在可以指定拓扑组件（例如Spout或Bolt）运行单个组件实例所需的资源量。用户可以使用以下API调用来指定拓扑组件的资源要求。</p>

<p></p><div id="Setting-Memory-Requirement"></div><p></p>

<h3 id="setting-memory-requirement">设置内存需求</h3>

<p>用于设置组件内存要求的API： <code>public T setMemoryLoad(Number onHeap, Number offHeap)</code>参数：* Number onHeap –该组件实例将消耗的堆内存量（以兆字节为单位）* Number offHeap –该组件实例将消耗的堆内存量（以兆字节为单位）</p>

<p>如果组件没有堆外内存需求，则用户还必须选择仅指定堆上内存需求。
<code>public T setMemoryLoad(Number onHeap)</code>参数：* Number onHeap –该组件实例将消耗的堆内存量</p>

<p>如果没有为offHeap提供任何值，则将使用0.0。如果没有为onHeap提供任何值，或者从不为组件调用API，则将使用默认值。</p>

<p>使用示例： <code>SpoutDeclarer s1 = builder.setSpout("word", new TestWordSpout(), 10); s1.setMemoryLoad(1024.0, 512.0); builder.setBolt("exclaim1", new ExclamationBolt(), 3) .shuffleGrouping("word").setMemoryLoad(512.0);</code>该拓扑请求的整个内存为16.5 GB。那是从10个喷口中获得的，堆内存为1GB，每个堆内存为0.5 GB，三个螺栓分别为0.5 GB。</p>

<p></p><div id="Setting-Shared-Memory"></div><p></p>

<h3 id="shared-memory">共享内存</h3>

<p>在某些情况下，您可能拥有组件之间共享的内存。它可能与大型静态数据结构一样简单，也可能与内存映射到螺栓并在工作进程之间共享的静态数据一样复杂。在任何情况下，您都可以通过创建以下选项之一来指定共享内存请求<code>SharedOffHeapWithinNode</code> ， <code>SharedOffHeapWithinWorker</code> ， 要么<code>SharedOnHeap</code>并将其添加到使用该共享内存的螺栓和喷嘴中。</p>

<p>使用示例：</p>
<div class="highlight"><pre><code class="language-" data-lang=""> builder.setBolt("exclaim1", new ExclamationBolt(), 3).shuffleGrouping("word")
          .addSharedMemory(new SharedOnHeap(100, "exclaim-cache"));
</code></pre></div>
<p>在上面的示例中，工作程序中的所有“ exclaim1”螺栓将共享100MB的内存。</p>
<div class="highlight"><pre><code class="language-" data-lang=""> builder.setBolt("lookup", new LookupBolt(), 3).shuffleGrouping("spout")
          .addSharedMemory(new SharedOffHeapWithinNode(500, "static-lookup"));
</code></pre></div>
<p>在此示例中，给定节点上的所有“查找”螺栓将共享500 MB内存或堆外内存。</p>

<p></p><div id="Setting-CPU-Requirement"></div><p></p>

<h3 id="setting-cpu-requirement">设置CPU要求</h3>

<p>用于设置组件CPU要求的API： <code>public T setCPULoad(Double amount)</code>参数：*数字数量–该组件实例将消耗的CPU数量。</p>

<p>当前，组件需要或在节点上可用的CPU资源量由点系统表示。CPU使用率是很难定义的概念。不同的CPU架构会根据手头的任务执行不同的操作。它们是如此复杂，以至于不可能用一个精确的便携式数字来表达所有这些。取而代之的是，我们在配置方法上采用惯例，主要关注粗略的CPU使用率，同时仍然提供了指定更细粒度的数量的可能性。</p>

<p>按照惯例，CPU内核通常将获得100分。如果您觉得处理器的功能或多或少都可以相应调整。受CPU约束的繁重任务将获得100分，因为它们会消耗整个内核。中型任务应有50个，轻型任务应有25个，小型任务应有10个。在某些情况下，您有一个任务会产生其他线程来帮助进行处理。这些任务可能需要超过100分才能表示它们正在使用的CPU数量。如果遵循这些约定，则单线程任务的常见情况是报告的Capacity * 100应该是任务所需的CPU点数。</p>

<p>使用示例：<code>SpoutDeclarer s1 = builder.setSpout("word", new TestWordSpout(), 10); s1.setCPULoad(15.0); builder.setBolt("exclaim1", new ExclamationBolt(), 3) .shuffleGrouping("word").setCPULoad(10.0); builder.setBolt("exclaim2", new HeavyBolt(), 1) .shuffleGrouping("exclaim1").setCPULoad(450.0);</code></p>

<p></p><div id="Limiting-the-Heap-Size-per-Worker-(JVM)Process"></div><p></p>

<h3 id="limiting-the-heap-size-per-worker-jvm-process">限制每个工作者（JVM）进程的堆大小</h3>
<div class="highlight"><pre><code class="language-" data-lang="">    public void setTopologyWorkerMaxHeapSize(Number size)
</code></pre></div>
<p>参数：*数字大小–将为工作进程分配的内存限制（以兆字节为单位）</p>

<p>用户可以使用上述API来限制资源感知调度程序在每个拓扑基础上分配给单个工作程序的内存资源量。该API到位，以便用户可以将执行程序传播给多个工作人员。但是，将执行程序传播给多个工作人员可能会增加通信延迟，因为执行程序将无法使用Disruptor Queue进行进程内通信。</p>

<p>使用示例：<code>Config conf = new Config(); conf.setTopologyWorkerMaxHeapSize(512.0);</code></p>

<p></p><div id="Setting-Available-Resources-on-Node"></div><p></p>

<h3 id="setting-available-resources-on-node">在节点上设置可用资源</h3>

<p>风暴管理员可以通过修改该节点的风暴主目录中的<em>conf / storm.yaml</em>文件来指定节点资源的可用性。</p>

<p>风暴管理员可以指定节点有多少可用内存（以兆字节为单位），将以下内容添加到<em>storm.yaml中</em> <code>supervisor.memory.capacity.mb: [amount<Double>]</code>风暴管理员还可以指定节点可用的可用CPU资源量，将以下内容添加到<em>storm.yaml中</em>
<code>supervisor.cpu.capacity: [amount<Double>]</code></p>

<p>注意：用户可以为可用的CPU指定的数量是使用如前所述的积分系统表示的。</p>

<p>使用示例：<code>supervisor.memory.capacity.mb: 20480.0 supervisor.cpu.capacity: 100.0</code></p>

<p></p><div id="Other-Configurations"></div><p></p>

<h3 id="other-configurations">其他配置</h3>

<p>用户可以在<em>conf / storm.yaml中</em>为Resource Aware Scheduler设置一些默认配置：</p>
<div class="highlight"><pre><code class="language-" data-lang="">    //default value if on heap memory requirement is not specified for a component 
    topology.component.resources.onheap.memory.mb: 128.0

    //default value if off heap memory requirement is not specified for a component 
    topology.component.resources.offheap.memory.mb: 0.0

    //default value if CPU requirement is not specified for a component 
    topology.component.cpu.pcore.percent: 10.0

    //default value for the max heap size for a worker  
    topology.worker.max.heap.size.mb: 768.0
</code></pre></div>
<h3 id="warning">警告</h3>

<p>如果启用了“资源感知计划”，它将动态计算工作程序的数量和<code>topology.workers</code>设置被忽略。</p>

<p></p><div id="Topology-Priorities-and-Per-User-Resource"></div><p></p>

<h2 id="topology-priorities-and-per-user-resource">拓扑优先级和每个用户资源</h2>

<p>资源意识调度程序或RAS还具有多租户功能，因为许多Storm用户通常共享一个Storm集群。Resource Aware Scheduler可以基于每个用户分配资源。可以确保每个用户一定数量的资源来运行其拓扑，并且资源感知调度程序将在可能的情况下满足这些保证。当Storm群集具有额外的可用资源时，资源感知调度程序将能够以公平的方式向用户分配其他资源。拓扑的重要性也可能有所不同。拓扑可用于实际生产或仅用于实验，因此，资源感知调度程序将在确定调度拓扑的顺序或何时撤出拓扑的顺序时考虑拓扑的重要性</p>

<p></p><div id="Setup"></div><p></p>

<h3 id="setup">设定</h3>

<p>可以将用户的资源保证指定为<em>conf / user-resource-pools.yaml</em> 。以以下格式指定用户的资源保证： <code>resource.aware.scheduler.user.pools: [UserId] cpu: [Amount of Guarantee CPU Resources] memory: [Amount of Guarantee Memory Resources]</code> <em>user-resource-pools.yaml的示例</em>如下所示： <code>resource.aware.scheduler.user.pools: jerry: cpu: 1000 memory: 8192.0 derek: cpu: 10000.0 memory: 32768 bobby: cpu: 5000.0 memory: 16384.0</code>请注意，指定的“保证的CPU和内存”量可以是整数或两倍</p>

<p></p><div id="Specifying-Topology-Priority"></div><p></p>

<h3 id="specifying-topology-priority">指定拓扑优先级</h3>

<p>拓扑优先级的范围可以是0-29。拓扑优先级将分为几个优先级，其中可能包含一系列优先级。例如，我们可以创建一个优先级映射：</p>
<div class="highlight"><pre><code class="language-" data-lang="">PRODUCTION =&gt; 0 – 9
STAGING =&gt; 10 – 19
DEV =&gt; 20 – 29
</code></pre></div>
<p>因此，每个优先级级别包含10个子优先级。用户可以使用以下API设置拓扑的优先级<code>conf.setTopologyPriority(int priority)</code>参数：* priority –表示拓扑优先级的整数</p>

<p>请注意，0-29的范围不是硬性限制。因此，用户可以设置一个高于29的优先级数字。但是，优先级数越高，重要性越低</p>

<p></p><div id="Specifying-Scheduling-Strategy"></div><p></p>

<h3 id="specifying-scheduling-strategy">指定调度策略</h3>

<p>用户可以基于每个拓扑指定要使用的调度策略。用户可以实施IStrategy界面并定义新策略来安排特定的拓扑。之所以创建此可插入接口，是因为我们意识到不同的拓扑可能具有不同的调度需求。用户可以使用API在拓扑定义中设置拓扑策略： <code>public void setTopologyStrategy(Class<? extends IStrategy> clazz)</code>参数：* clazz –实现IStrategy接口的策略类</p>

<p>用法示例： <code>conf.setTopologyStrategy(org.apache.storm.scheduler.resource.strategies.scheduling.DefaultResourceAwareStrategy.class);</code>提供了默认计划。DefaultResourceAwareStrategy是基于描述Storm中的资源感知调度的原始论文中的调度算法实现的：</p>

<p>Peng，Boyang，Mohammad Hosseini，Hong Zhihao Hong，Reza Farivar和Roy Campbell。 “ R-storm：风暴中的资源感知调度。”在第16届年度中间件会议记录中，第149-161页。ACM，2015年。</p>

<p><a href="http://dl.acm.org/citation.cfm?id=2814808">http://dl.acm.org/citation.cfm?id=2814808</a></p>

<p><strong>请注意：如本文所述，必须在原始调度策略的基础上进行增强。请参阅“原始DefaultResourceAwareStrategy的增强功能”部分</strong></p>

<p></p><div id="Specifying-Topology-Prioritization-Strategy"></div><p></p>

<h3 id="specifying-topology-prioritization-strategy">指定拓扑优先级策略</h3>

<p>调度和逐出的顺序由可插拔接口确定，群集所有者可以在该接口中定义应如何调度拓扑。为了让所有者定义自己的优先级策略，她或她需要实现ISchedulingPriorityStrategy接口。用户可以通过设置<code>DaemonConfig.RESOURCE_AWARE_SCHEDULER_PRIORITY_STRATEGY</code>指向实现该策略的类。例如：<code>resource.aware.scheduler.priority.strategy: "org.apache.storm.scheduler.resource.strategies.priority.DefaultSchedulingPriorityStrategy"</code></p>

<p>拓扑计划从此插件返回的列表的开头开始。如果没有足够的资源来安排拓扑，则从列表末尾开始驱逐其他资源。当没有更低优先级的拓扑需要驱逐时，驱逐停止。</p>

<p><strong>DefaultSchedulingPriorityStrategy</strong></p>

<p>过去，调度的顺序是基于用户当前资源分配与其保证分配之间的距离。</p>

<p>我们目前使用的方法略有不同。我们模拟为每个用户安排最高优先级的拓扑，并使用以下公式对每种资源的拓扑进行评分</p>
<div class="highlight"><pre><code class="language-" data-lang="">(Requested + Assigned - Guaranteed)/Available
</code></pre></div>
<p>哪里</p>

<ul>
<li><code>Requested</code>是此拓扑请求的资源（或它对于诸如共享内存之类的复杂请求的近似值）</li>
<li><code>Assigned</code>是模拟已经分配的资源。</li>
<li><code>Guaranteed</code>是该用户的资源保证</li>
<li><code>Available</code>是集群中当前可用的资源量。</li>
</ul>

<p>对于保证的请求，这给出的分数为负；对于不在保证范围之内的请求，给出的分数为正。</p>

<p>为了组合不同的资源，使用所有单个资源得分中的最大值。这保证了，如果用户要对单个资源进行担保，则不会因对任何其他资源受到担保而被抵消。</p>

<p>例如：</p>

<p>假设我们必须安排以下拓扑。</p>

<table><thead>
<tr>
<th>ID</th>
<th>用户</th>
<th>中央处理器</th>
<th>记忆</th>
<th>优先</th>
</tr>
</thead><tbody>
<tr>
<td>A-1</td>
<td>一种</td>
<td>100</td>
<td>1,000</td>
<td>1个</td>
</tr>
<tr>
<td>A2</td>
<td>一种</td>
<td>100</td>
<td>1,000</td>
<td>10</td>
</tr>
<tr>
<td>B-1</td>
<td>乙</td>
<td>100</td>
<td>1,000</td>
<td>1个</td>
</tr>
<tr>
<td>B-2</td>
<td>乙</td>
<td>100</td>
<td>1,000</td>
<td>10</td>
</tr>
</tbody></table>

<p>整个群集具有300个CPU和4,000个内存。</p>

<p>保证用户A 100个CPU和1,000个内存。保证用户B有200个CPU和1,500个内存。每个用户最重要，优先级最低的拓扑的分数将是。</p>
<div class="highlight"><pre><code class="language-" data-lang="">A-1 Score = max(CPU: (100 + 0 - 100)/300, MEM: (1,000 + 0 - 1,000)/4,000) = 0
B-1 Score = max(CPU: (100 + 0 - 200)/300, MEM: (1,000 + 0 - 1,500)/4,000) = -0.125
</code></pre></div>
<p><code>B-1</code>具有最低的分数，因此它是要安排的最高优先级拓扑。在下一轮中得分将是。</p>
<div class="highlight"><pre><code class="language-" data-lang="">A-1 Score = max(CPU: (100 + 0 - 100)/200, MEM: (1,000 + 0 - 1,000)/3,000) = 0
B-2 Score = max(CPU: (100 + 100 - 200)/200, MEM: (1,000 + 1,000 - 1,500)/3,000) = 0.167
</code></pre></div>
<p><code>A-1</code>现在具有最低的分数，因此它将成为排定的下一个优先级最高的拓扑。</p>

<p>即使没有足够的资源来安排拓扑，该过程也将重复进行直到所有拓扑都被排序为止。</p>

<p><strong>FIFO调度优先级策略</strong></p>

<p>FIFO策略更多地用于用户正在运行集成测试或进行开发工作的测试或暂存群集。在这些情况下，拓扑往往寿命很短，有时用户可能会忘记它们完全在运行拓扑。</p>

<p>为了对运行短期拓扑的用户尽可能公平地对待， <code>FIFOSchedulingPriorityStrategy</code>扩展<code>DefaultSchedulingPriorityStrategy</code>因此，任何负分数（也就是适合用户保证的拓扑）都将保持不变，但将正分数替换为拓扑的正常运行时间。</p>

<p>这尊重用户的保证，但是同时，它会将其余资源的优先级分配给最近启动的拓扑。那么，可能已被遗忘的旧拓扑最不可能获得资源。</p>

<p></p><div id="Profiling-Resource-Usage"></div><p></p>

<h2 id="profiling-resource-usage">分析资源使用情况</h2>

<p>找出拓扑的资源使用情况：</p>

<p>要了解拓扑实际使用了多少内存/ CPU，可以将以下内容添加到拓扑启动代码中。</p>
<div class="highlight"><pre><code class="language-" data-lang="">    //Log all storm metrics
    conf.registerMetricsConsumer(backtype.storm.metric.LoggingMetricsConsumer.class);

    //Add in per worker CPU measurement
    Map&lt;String, String&gt; workerMetrics = new HashMap&lt;String, String&gt;();
    workerMetrics.put("CPU", "org.apache.storm.metrics.sigar.CPUMetric");
    conf.put(Config.TOPOLOGY_WORKER_METRICS, workerMetrics);
</code></pre></div>
<p>CPU指标将要求您添加</p>
<div class="highlight"><pre><code class="language-" data-lang="">    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.storm&lt;/groupId&gt;
        &lt;artifactId&gt;storm-metrics&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre></div>
<p>作为拓扑依赖项（1.0.0或更高）。</p>

<p>然后，您可以转到UI上的拓扑，打开系统指标，并找到LoggingMetricsConsumer写入的日志。它将在类似日志中输出结果。</p>
<div class="highlight"><pre><code class="language-" data-lang="">    1454526100 node1.nodes.com:6707 -1:__system CPU {user-ms=74480, sys-ms=10780}
    1454526100 node1.nodes.com:6707 -1:__system memory/nonHeap     {unusedBytes=2077536, virtualFreeBytes=-64621729, initBytes=2555904, committedBytes=66699264, maxBytes=-1, usedBytes=64621728}
    1454526100 node1.nodes.com:6707 -1:__system memory/heap  {unusedBytes=573861408, virtualFreeBytes=694644256, initBytes=805306368, committedBytes=657719296, maxBytes=778502144, usedBytes=83857888}
</code></pre></div>
<p>-1：__ system的指标通常是整个工作人员的指标。在上面的示例中，该工作程序在node1.nodes.com:6707上运行。这些指标每60秒收集一次。对于CPU，您可以看到在60秒钟内，该工作人员使用了74480 + 10780 = 85260 ms的CPU时间。这相当于85260/60000或大约1.5个内核。</p>

<p>内存使用情况类似，但请查看usedBytes。 offHeap是64621728或大约62MB，onHeap是83857888或大约80MB，但是您应该已经知道在每个工作线程中设置的堆大小。您如何将每个螺栓/喷嘴分开？这会有点困难，并且可能需要您反复尝试并尝试一些错误。</p>

<p></p><div id="Enhancements-on-original-DefaultResourceAwareStrategy"></div><p></p>

<h2 id="enhancements-on-original-defaultresourceawarestrategy">原始DefaultResourceAwareStrategy的增强功能</h2>

<p>如上文所述，默认的资源感知调度策略有两个主要的调度阶段：</p>

<ol>
<li>任务选择-计算应安排拓扑中任务/执行者的顺序</li>
<li>节点选择-给定任务/执行程序，找到一个节点以安排任务/执行程序。</li>
</ol>

<p>在两个计划阶段都进行了增强</p>

<h3 id="task-selection-enhancements">任务选择增强</h3>

<p>代替使用拓扑图的广度优先遍历来创建组件及其执行程序的顺序，而是使用一种新的启发式方法，该启发式方法按组件的入入和出入边缘（潜在连接）的数量对组件进行排序。发现这是一种将执行器放置在彼此之间并减少网络延迟的更有效的方法。</p>

<h3 id="node-selection-enhancements">节点选择增强</h3>

<p>节点选择首先出现，首先选择哪个机架（服务器机架），然后选择该机架上的哪个节点。选择机架和节点的策略要点是找到具有“最大”可用资源的机架，并在该机架中找到具有“最大”可用资源的节点。我们为此策略所做的假设是，拥有最多空闲资源的节点或机架将具有最高的概率，这使我们能够安排在节点或机架上共同部署最多数量的执行程序，以减少网络通信延迟</p>

<p>机架和节点的分类从最佳选择到最差选择。当找到执行者时，该策略将在放弃之前从最佳到最差遍历所有机架和节点。机架和节点将按以下顺序排序：</p>

<ol>
<li><p>机架或节点上已经调度了多少执行程序<br>-这样做是为了使执行程序的执行时间更接近已调度并正在运行的执行程序。如果拓扑部分崩溃，并且需要重新安排拓扑执行程序的子集，我们希望将这些执行程序重新安排到与运行良好且运行良好的执行程序尽可能近的位置（从网络角度）。</p></li>
<li><p>从属资源可用性或机架或节点上的“有效”资源量<br>-请参阅有关从属资源可用性的部分</p></li>
<li><p>所有资源可用性的平均值<br>-这仅是取可用百分比的平均值（节点或机架上的可用资源分别除以机架或群集上的可用资源）。仅当两个对象（机架或节点）的“有效资源”相同时，才使用这种情况。然后，我们将所有资源百分比的平均值作为排序指标。例如：```Avail Resources：节点1：CPU = 50内存= 1024插槽= 20节点2：CPU = 50内存= 8192插槽= 40节点3：CPU = 1000内存= 0插槽= 0</p>
<div class="highlight"><pre><code class="language-" data-lang="">Effective resources for nodes:
node 1 = 50 / (50+50+1000) = 0.045 (CPU bound)
node 2 = 50 / (50+50+1000) = 0.045 (CPU bound)
node 3 = 0 (memory and slots are 0)
</code></pre></div><div class="highlight"><pre><code class="language-" data-lang="">ode 1 and node 2 have the same effective resources but clearly node 2 has more resources (memory and slots) than node 1 and we would want to pick node 2 first since there is a higher probability we will be able to schedule more executors on it. This is what the phase 2 averaging does
</code></pre></div></li>
</ol>

<p>因此，排序遵循以下过程。基于1）进行比较，如果相等，则基于2）比较，如果相等，则基于3）比较，如果相等，则通过基于比较节点或机架的ID任意分配顺序来打破联系。</p>

<p><strong>下级资源可用性</strong></p>

<p>最初，用于RAS的getBestClustering算法通过查找具有最大可用内存总和+跨机架中所有节点可用的机架，根据哪个机架具有“最可用”资源来找到“最佳”机架。该方法不是很准确，因为内存和CPU使用率在不同的范围内同意值，并且这些值未标准化。该方法也不有效，因为它不考虑可用的插槽数，并且由于内存，CPU或插槽之一资源的耗尽而无法识别无法调度的机架。同样，先前的方法没有考虑工人的失败。当未分配拓扑的执行程序并需要对其进行重新调度时，getBestClustering中的当前逻辑可能不足，因为它可能会返回与大多数拓扑执行程序最初在其中进行调度的群集不同的集群。</p>

<p>我通过查找从属资源可用性排序（受“主导资源公平”启发）来寻找“最佳”机架或节点的新策略/算法，并根据从属（非主导）资源可用性对机架和节点进行排序。</p>

<p>例如，给定4个具有以下资源可用性的机架<code>//generate some that has a lot of memory but little of cpu rack-3 Avail [ CPU 100.0 MEM 200000.0 Slots 40 ] Total [ CPU 100.0 MEM 200000.0 Slots 40 ] //generate some supervisors that are depleted of one resource rack-2 Avail [ CPU 0.0 MEM 80000.0 Slots 40 ] Total [ CPU 0.0 MEM 80000.0 Slots 40 ] //generate some that has a lot of cpu but little of memory rack-4 Avail [ CPU 6100.0 MEM 10000.0 Slots 40 ] Total [ CPU 6100.0 MEM 10000.0 Slots 40 ] //generate another rack of supervisors with less resources than rack-0 rack-1 Avail [ CPU 2000.0 MEM 40000.0 Slots 40 ] Total [ CPU 2000.0 MEM 40000.0 Slots 40 ] //best rack to choose rack-0 Avail [ CPU 4000.0 MEM 80000.0 Slots 40( ] Total [ CPU 4000.0 MEM 80000.0 Slots 40 ] Cluster Overall Avail [ CPU 12200.0 MEM 410000.0 Slots 200 ] Total [ CPU 12200.0 MEM 410000.0 Slots 200 ]</code>显然，机架0是最好的集群，因为它是最平衡的集群，并且可能调度最多的执行者，而机架2是最坏的机架，因为机架2的CPU资源已耗尽，因此即使有其他资源也无法调度可用资源。</p>

<p>我们首先通过计算来计算每种资源的所有机架的资源可用性百分比：</p>
<div class="highlight"><pre><code class="language-" data-lang="">(resource available on rack) / (resource available in cluster)
</code></pre></div>
<p>我们执行此计算以标准化值，否则资源值将不可比较。</p>

<p>因此，对于我们的示例： <code>rack-3 Avail [ CPU 0.819672131147541% MEM 48.78048780487805% Slots 20.0% ] effective resources: 0.00819672131147541 rack-2 Avail [ 0.0% MEM 19.51219512195122% Slots 20.0% ] effective resources: 0.0 rack-4 Avail [ CPU 50.0% MEM 2.4390243902439024% Slots 20.0% ] effective resources: 0.024390243902439025 rack-1 Avail [ CPU 16.39344262295082% MEM 9.75609756097561% Slots 20.0% ] effective resources: 0.0975609756097561 rack-0 Avail [ CPU 32.78688524590164% MEM 19.51219512195122% Slots 20.0% ] effective resources: 0.1951219512195122</code>机架的有效资源（也是从属资源）的计算方法如下：</p>
<div class="highlight"><pre><code class="language-" data-lang="">MIN(resource availability percentage of {CPU, Memory, # of free Slots}).
</code></pre></div>
<p>然后，我们根据有效资源订购机架。</p>

<p>因此，对于我们的示例：</p>
<div class="highlight"><pre><code class="language-" data-lang="">Sorted rack: [rack-0, rack-1, rack-4, rack-3, rack-2]
</code></pre></div>
<p>该指标用于节点和机架的排序。在对机架进行排序时，我们考虑机架上和整个集群（包含所有机架）中可用的资源。在对节点进行排序时，我们考虑节点上可用的资源和机架中可用的资源（机架中所有节点可用的所有资源的总和）</p>

<p>此增强功能的原始Jira： <a href="https://issues.apache.org/jira/browse/STORM-1766">STORM-1766</a></p>

<h3 id="improvements-in-scheduling">调度方面的改进</h3>

<p>本节提供了一些性能方面的实验结果，并在原始调度策略的基础上进行了增强。实验基于以下运行模拟：</p>

<p><a href="https://github.com/jerrypeng/storm-scheduler-test-framework">https://github.com/jerrypeng/storm-scheduler-test-framework</a></p>

<p>仿真中使用了随机拓扑和群集，还使用了一个综合数据集，该数据集由Yahoo所有风暴群集中运行的所有实际拓扑组成。</p>

<p>下图比较了各种策略调度拓扑以最小化网络延迟的程度。通过每个调度策略为拓扑的每个调度计算网络度量。网络度量是根据拓扑中每个执行程序必须与驻留在同一工作程序（JVM进程）中，不同工作程序但同一主机，不同主机，不同机架中的另一执行程序建立的连接数来计算的。我们所做的假设如下</p>

<ol>
<li>员工之间的沟通是最快的</li>
<li>员工之间的沟通速度很快</li>
<li>节点间通讯较慢</li>
<li>机架间通信最慢</li>
</ol>

<p>对于此网络指标，数字越大，拓扑对于此调度将具有的潜在网络等待时间越长。进行两种类型的实验。使用随机生成的拓扑和随机生成的簇执行一组实验。另一组实验是使用一个数据集执行的，该数据集包含所有在Yahoo上运行的拓扑以及基于拓扑大小的半随机生成的群集。两组实验都运行数百万次迭代，直到结果收敛为止。</p>

<p>对于涉及随机生成的拓扑的实验，实施了一种最佳策略，如果存在解决方案，该策略将彻底找到最佳解决方案。本实验中使用的拓扑和群集相对较小，因此最佳策略遍历解决方案空间以在合理的时间内找到最佳解决方案。Yahoo拓扑不适用于此策略，因为拓扑很大，运行时间会不合理，因为解决方案空间为W ^ N（在一个工作人员中排序无关紧要），其中W是工作人员的数量， N是执行者的数量。NextGenStrategy代表具有这些增强功能的调度策略。DefaultResourceAwareStrategy代表原始调度策略。RoundRobinStrategy表示一种幼稚的策略，它简单地以循环方式调度执行程序，同时遵守资源约束。下图显示了网络指标的平均值。CDF图也显示在下方。</p>

<table><thead>
<tr>
<th>随机拓扑</th>
<th>雅虎拓扑</th>
</tr>
</thead><tbody>
<tr>
<td><img src="images/ras_new_strategy_network_metric_random.png" alt=""></td>
<td><img src="images/ras_new_strategy_network_metric_yahoo_topologies.png" alt=""></td>
</tr>
</tbody></table>

<p>下一张图显示了来自各个调度策略的调度与最佳策略的调度有多接近。如前所述，仅对随机生成的拓扑和群集执行此操作。</p>

<table><thead>
<tr>
<th>随机拓扑</th>
</tr>
</thead><tbody>
<tr>
<td><img src="images/ras_new_strategy_network_metric_improvement_random.png" alt=""></td>
</tr>
</tbody></table>

<p>下图是网络指标的CDF：</p>

<table><thead>
<tr>
<th>随机拓扑</th>
<th>雅虎拓扑</th>
</tr>
</thead><tbody>
<tr>
<td><img src="images/ras_new_strategy_network_cdf_random.png" alt=""></td>
<td><img src="images/ras_new_strategy_network_metric_cdf_yahoo_topologies.png" alt=""></td>
</tr>
</tbody></table>

<p>以下是对策略执行时间的比较：</p>

<table><thead>
<tr>
<th>随机拓扑</th>
<th>雅虎拓扑</th>
</tr>
</thead><tbody>
<tr>
<td><img src="images/ras_new_strategy_runtime_random.png" alt=""></td>
<td><img src="images/ras_new_strategy_runtime_yahoo.png" alt=""></td>
</tr>
</tbody></table>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>