<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>保证消息处理</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=1">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">保证消息处理</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>Storm提供了几种不同级别的保证消息处理，包括尽力而为，至少一次，通过<a href="Trident-tutorial.html">Trident</a>一次，恰好一次。本页说明Storm如何保证至少处理一次。</p>

<h3 id="what-does-it-mean-for-a-message-to-be-fully-processed">消息被“完全处理”是什么意思？</h3>

<p>从喷嘴流出的元组可以触发基于它创建数千个元组。例如，考虑流字计数拓扑：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TopologyBuilder</span><span class="o">();</span>
<span class="n">builder</span><span class="o">.</span><span class="na">setSpout</span><span class="o">(</span><span class="s">"sentences"</span><span class="o">,</span> <span class="k">new</span> <span class="n">KestrelSpout</span><span class="o">(</span><span class="s">"kestrel.backtype.com"</span><span class="o">,</span>
                                               <span class="mi">22133</span><span class="o">,</span>
                                               <span class="s">"sentence_queue"</span><span class="o">,</span>
                                               <span class="k">new</span> <span class="nf">StringScheme</span><span class="o">()));</span>
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"split"</span><span class="o">,</span> <span class="k">new</span> <span class="n">SplitSentence</span><span class="o">(),</span> <span class="mi">10</span><span class="o">)</span>
        <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"sentences"</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"count"</span><span class="o">,</span> <span class="k">new</span> <span class="n">WordCount</span><span class="o">(),</span> <span class="mi">20</span><span class="o">)</span>
        <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"split"</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">));</span>
</code></pre></div>
<p>此拓扑从Kestrel队列中读取句子，将句子拆分成其组成的单词，然后为每个单词发出它之前看到该单词的次数。从喷嘴流出的元组会触发基于该元组的许多元组：句子中每个单词的元组和每个单词的更新计数的元组。消息树如下所示：</p>

<p><img src="images/tuple_tree.png" alt="元组树"></p>

<p>当元组树已用尽并且树中的每条消息均已处理时，Storm认为元组从喷口中脱落出来了。当元组的消息树无法在指定的超时时间内完全处理时，则认为该元组已失败。可以使用<a href="javadocs/org/apache/storm/Config.html#TOPOLOGY_MESSAGE_TIMEOUT_SECS">Config在特定于拓扑的基础上配置此超时</a><a href="javadocs/org/apache/storm/Config.html#TOPOLOGY_MESSAGE_TIMEOUT_SECS">。TOPOLOGY_MESSAGE_TIMEOUT_SECS</a>配置，默认为30秒。</p>

<h3 id="what-happens-if-a-message-is-fully-processed-or-fails-to-be-fully-processed">如果邮件已完全处理或未能完全处理，会发生什么？</h3>

<p>为了理解这个问题，让我们看一看从喷嘴喷出的元组的生命周期。作为参考，这是spouts实现的接口（有关更多信息，请参见<a href="javadocs/org/apache/storm/spout/ISpout.html">Javadoc</a> ）：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ISpout</span> <span class="kd">extends</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">SpoutOutputCollector</span> <span class="n">collector</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">close</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">nextTuple</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">ack</span><span class="o">(</span><span class="n">Object</span> <span class="n">msgId</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">fail</span><span class="o">(</span><span class="n">Object</span> <span class="n">msgId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>首先，Storm向<code>Spout</code>通过调用<code>nextTuple</code>上的方法<code>Spout</code> 。的<code>Spout</code>使用<code>SpoutOutputCollector</code>在提供<code>open</code>将元组发送到其输出流之一的方法。发出元组时， <code>Spout</code>提供一个“消息ID”，该消息将在以后用于标识元组。例如， <code>KestrelSpout</code>从Kestrel队列中读取一条消息，并发出Kestrel为该消息提供的ID作为“消息ID”。向...发送消息<code>SpoutOutputCollector</code>看起来像这样：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="s">"field1"</span><span class="o">,</span> <span class="s">"field2"</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">,</span> <span class="n">msgId</span><span class="o">);</span>
</code></pre></div>
<p>接下来，将元组发送到消耗的螺栓，Storm负责跟踪创建的消息树。如果Storm检测到元组已完全处理，Storm将调用<code>ack</code>原始方法<code>Spout</code>消息ID为<code>Spout</code>提供给Storm。同样，如果元组超时Storm将调用<code>fail</code>上的方法<code>Spout</code> 。请注意，元组将完全相同地被确认或失败<code>Spout</code>创建它的任务。所以如果<code>Spout</code>在整个集群中执行了尽可能多的任务，一个元组不会被创建该任务的任务承担或失败。</p>

<p>让我们用<code>KestrelSpout</code>再次看到什么<code>Spout</code>需要做的是保证消息处理。什么时候<code>KestrelSpout</code>从Kestrel队列中删除一条消息，它“打开”该消息。这意味着该消息实际上尚未从队列中移出，而是处于“挂起”状态，等待确认消息已完成。处于挂起状态时，将不会将消息发送到队列的其他使用者。此外，如果客户端断开连接，则该客户端的所有未决消息将重新放入队列。打开消息后，Kestrel将为客户端提供消息的数据以及消息的唯一ID。的<code>KestrelSpout</code>在将元组发送到时，使用该确切ID作为元组的“消息ID”。 <code>SpoutOutputCollector</code> 。以后的某个时候<code>ack</code>要么<code>fail</code>被称为<code>KestrelSpout</code> ， <code>KestrelSpout</code>将带有消息ID的确认或失败消息发送给Kestrel，以使该消息脱离队列或重新放置。</p>

<h3 id="what-is-storms-reliability-api">什么是Storm的可靠性API？</h3>

<p>要想从Storm的可靠性功能中受益，您必须做两件事。首先，每当在元组树中创建新链接时，都需要告诉Storm。其次，您需要在完成单个元组处理后告诉Storm。通过执行这两项操作，Storm可以检测到元组树何时被完全处理，并且可以适当地确认或失败喷嘴组。Storm的API提供了完成这两项任务的简洁方法。</p>

<p>在元组树中指定链接称为<em>锚定</em> 。在发出新的元组的同时完成锚定。让我们以以下螺栓为例。该螺栓将包含句子的元组拆分为每个单词的元组：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SplitSentence</span> <span class="kd">extends</span> <span class="n">BaseRichBolt</span> <span class="o">{</span>
        <span class="n">OutputCollector</span> <span class="n">_collector</span><span class="o">;</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">_collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">sentence</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">sentence</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">tuple</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="n">_collector</span><span class="o">.</span><span class="na">ack</span><span class="o">(</span><span class="n">tuple</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">));</span>
        <span class="o">}</span>        
    <span class="o">}</span>
</code></pre></div>
<p>通过将输入元组指定为的第一个参数来<em>锚定</em>每个单词元组<code>emit</code> 。由于单词元组是锚定的，如果单词元组未能在下游进行处理，则稍后将重播树根处的喷嘴元组。相比之下，让我们看看如果发出元组这样的单词会发生什么情况：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
</code></pre></div>
<p>发射元组这种方式，导致其对<em>非锚定的</em>字。如果元组在下游无法处理，则不会重播根元组。根据拓扑中所需的容错保证，有时发出未锚定的元组是适当的。</p>

<p>一个输出元组可以锚定到多个输入元组。在进行流连接或聚合时，这很有用。无法处理的多锚定元组将导致从喷嘴中重播多个元组。通过指定元组列表而不是单个元组来完成多锚定。例如：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">anchors</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;();</span>
<span class="n">anchors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tuple1</span><span class="o">);</span>
<span class="n">anchors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tuple2</span><span class="o">);</span>
<span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">anchors</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
</code></pre></div>
<p>多重锚定将输出元组添加到多个元组树中。请注意，多重锚定还可能破坏树结构并创建元组DAG，如下所示：</p>

<p><img src="images/tuple-dag.png" alt="元组DAG"></p>

<p>Storm的实现适用于DAG和树（预发行版仅适用于树，并且名称为“ tuple tree”）。</p>

<p>锚定是您指定元组树的方式-Storm的可靠性API的下一个也是最后一个部分是指定何时完成对元组树中单个元组的处理。这是通过使用<code>ack</code>和<code>fail</code>上的方法<code>OutputCollector</code> 。如果您回头看一下<code>SplitSentence</code>例如，您可以看到在发出所有单词元组之后，输入元组被确认。</p>

<p>您可以使用<code>fail</code>上的方法<code>OutputCollector</code>立即使元组树根上的喷嘴元组失败。例如，您的应用程序可能选择从数据库客户端捕获异常，并明确使输入元组失败。通过显式使元组失败，与等待元组超时相比，可以更快速地重放出水嘴元组。</p>

<p>您处理的每个元组必须被确认或失败。Storm使用内存来跟踪每个元组，因此，如果您不对每个元组进行确认/失败，则该任务最终将耗尽内存。</p>

<p>许多螺栓遵循以下通用模式：读取输入元组，基于该元组发出元组，然后在输入末尾确认该元组。 <code>execute</code>方法。这些螺栓属于过滤器和简单功能类别。Storm有一个名为<code>BasicBolt</code>为您封装了此模式。的<code>SplitSentence</code>例子可以写成<code>BasicBolt</code>如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SplitSentence</span> <span class="kd">extends</span> <span class="n">BaseBasicBolt</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">BasicOutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">sentence</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">sentence</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">));</span>
        <span class="o">}</span>        
    <span class="o">}</span>
</code></pre></div>
<p>此实现比以前的实现更简单，并且在语义上是相同的。元组发出给<code>BasicOutputCollector</code>会自动锚定到输入元组，并且execute方法完成后，输入元组会自动为您确认。</p>

<p>相反，执行聚集或联接的螺栓可能会延迟对元组的确认，直到它基于一堆元组计算出结果为止。聚合和联接通常也将对它们的输出元组进行多锚定。这些都不属于简单的模式<code>IBasicBolt</code> 。</p>

<h3 id="how-do-i-make-my-applications-work-correctly-given-that-tuples-can-be-replayed">考虑到元组可以重播，如何使我的应用程序正常工作？</h3>

<p>与软件设计一样，答案是“取决于情况”。如果您真的只想要一次语义，请使用<a href="Trident-tutorial.html">Trident</a> API。在某些情况下，例如进行大量分析，删除数据就可以了，因此可以通过将acker螺栓的数量设置为0 <a href="javadocs/org/apache/storm/Config.html#TOPOLOGY_ACKERS">Config来禁用容错功能</a><a href="javadocs/org/apache/storm/Config.html#TOPOLOGY_ACKERS">。TOPOLOGY_ACKERS</a> 。但是在某些情况下，您需要确保所有内容至少处理一次且没有任何内容被丢弃。如果所有操作都是幂等的，或者重复发生重复数据，这将特别有用。</p>

<h3 id="how-does-storm-implement-reliability-in-an-efficient-way">Storm如何有效地实现可靠性？</h3>

<p>Storm拓扑具有一组特殊的“ acker”任务，这些任务跟踪每个喷嘴元组的元组的DAG。当acker看到DAG已完成时，它会向spout任务发送一条消息，该任务创建了spout元组以确认该消息。您可以使用<a href="javadocs/org/apache/storm/Config.html#TOPOLOGY_ACKERS">Config在拓扑配置中</a><a href="javadocs/org/apache/storm/Config.html#TOPOLOGY_ACKERS">设置拓扑的确认任务数</a><a href="javadocs/org/apache/storm/Config.html#TOPOLOGY_ACKERS">。TOPOLOGY_ACKERS</a> 。 Storm默认将TOPOLOGY_ACKERS设置为每个工作人员一项任务。</p>

<p>了解Storm的可靠性实现的最好方法是查看元组和元组DAG的生命周期。在拓扑中创建元组时，无论是在喷嘴中还是在螺栓中，都将为其分配一个随机的64位ID。ackers使用这些id来跟踪每个喷嘴元组的元组DAG。</p>

<p>每个元组都知道存在于其元组树中的所有喷嘴元组的ID。当您用螺栓发射新的元组时，来自元组锚点的出水口元组ID将被复制到新的元组中。元组被确认后，它将向消息发送适当的确认任务，其中包含有关元组树如何更改的信息。它特别告诉acker：“我现在已经在树中完成了这个喷水元组，这是树中锚定在我身上的新元组”。</p>

<p>例如，如果基于元组“ C”创建元组“ D”和“ E”，则当确认“ C”时，元组树将发生以下变化：</p>

<p><img src="images/ack_tree.png" alt="ack会发生什么"></p>

<p>由于在添加“ D”和“ E”的同时从树中删除了“ C”，因此永远不会过早完成树。</p>

<p>关于Storm如何跟踪元组树还有更多细节。如前所述，您可以在拓扑中具有任意数量的acker任务。这导致了以下问题：当元组在拓扑中被确认时，它如何知道向哪个确认任务发送该信息？</p>

<p>Storm使用mod哈希将喷嘴元组id映射到acker任务。由于每个元组都带有它们所在的所有树的喷嘴元组ID，因此他们知道要与之通信的确认任务。</p>

<p>Storm的另一个细节是acker任务如何跟踪哪些喷嘴任务对其所跟踪的每个喷嘴元组负责。当spout任务发出新的元组时，它只是向相应的acker发送一条消息，告诉它其任务ID负责该spout元组。然后，当确认者看到树已完成时，它知道向哪个任务ID发送完成消息。</p>

<p>Acker任务不会明确跟踪元组树。对于具有成千上万个节点（或更多节点）的大型元组树，跟踪所有元组树可能会淹没ackers占用的内存。取而代之的是，确认者采取了另一种策略，即每个喷口元组仅需要固定的空间量（约20个字节）。这种跟踪算法是Storm运作方式的关键，也是它的主要突破之一。</p>

<p>acker任务存储从喷嘴元组id到一对值的映射。第一个值是创建喷口元组的任务ID，稍后将其用于发送完成消息。第二个值是64位数字，称为“ ack val”。ack val表示整个元组树的状态，无论大小。它只是树中已创建和/或确认的所有元组ID的异或。</p>

<p>当acker任务看到“ ack val”已变为0时，它就知道元组树已完成。由于元组id是随机的64位数字，因此“ ack val”偶然变为0的机会非常小。如果您以每秒1万次的速度进行数学运算，则需要花费5千万年才能犯错。即使那样，如果该元组碰巧在拓扑结构中发生故障，也只会导致数据丢失。</p>

<p>既然您已经了解了可靠性算法，那么让我们看一下所有故障案例，看看Storm在每种情况下如何避免数据丢失：</p>

<ul>
<li><strong>由于任务已死</strong> ，所以未确认元组：在这种情况下，失败元组在树根处的喷嘴元组ID将超时并被重播。</li>
<li><strong>Acker任务死了</strong> ：在这种情况下，acker跟踪的所有喷嘴元组将超时并重播。</li>
<li><strong>喷口任务死亡</strong> ：在这种情况下，喷口与之交谈的源负责重播消息。例如，当客户端断开连接时，诸如Kestrel和RabbitMQ的队列会将所有待处理的消息放回队列。</li>
</ul>

<p>如您所见，Storm的可靠性机制是完全分布式的，可伸缩的和容错的。</p>

<h3 id="tuning-reliability">调整可靠性</h3>

<p>Acker任务是轻量级的，因此您在拓扑中不需要太多任务。您可以通过Storm UI（组件ID为“ __acker”）跟踪其性能。如果吞吐量看起来不正确，则需要添加更多确认任务。</p>

<p>如果可靠性对您而言并不重要-也就是说，您不在乎在失败情况下丢失元组-那么您可以通过不跟踪喷嘴组的元组树来提高性能。不跟踪元组树将传输的消息数量减半，因为通常在元组树中每个元组都有一个确认消息。此外，它要求在每个下游元组中保留更少的ID，从而减少带宽使用。</p>

<p>有三种删除可靠性的方法。首先是设置Config。TOPOLOGY_ACKERS为0。在这种情况下，Storm将呼叫<code>ack</code>喷口发出元组后立即对喷口进行方法。元组树将不会被跟踪。</p>

<p>第二种方法是逐个消息地删除可靠性。您可以通过以下方式关闭对单个喷口组的跟踪： <code>SpoutOutputCollector.emit</code>方法。</p>

<p>最后，如果您不关心拓扑下游的元组的特定子集是否无法处理，则可以将它们作为未锚定元组发出。由于它们没有锚定在任何喷嘴元组上，因此即使它们不被认可，也不会导致任何喷嘴元组失败。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>