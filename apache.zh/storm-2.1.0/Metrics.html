<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>风暴指标</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=3">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">风暴指标</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>Storm公开了一个指标界面，用于报告整个拓扑中的摘要统计信息。您在UI上看到的数字来自其中一些内置指标，但通过工作人员心跳而不是通过下面描述的IMetricsConsumer报告。</p>

<p>如果您正在寻找群集范围的监视，请参阅“ <a href="ClusterMetrics.html">群集指标”</a> 。</p>

<h3 id="metric-types">指标类型</h3>

<p>指标必须实施<a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/IMetric.java"><code>IMetric</code></a>仅包含一种方法<code>getValueAndReset</code> -进行所有剩余的工作以找到汇总值，然后重置回初始状态。例如，MeanReducer将运行总计除以其运行计数以找到平均值，然后将两个值初始化回零。</p>

<p>Storm为您提供了以下指标类型：</p>

<ul>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/AssignableMetric.java">AssignableMetric-</a>将指标设置为您提供的显式值。如果它是一个外部值，或者您已经在自己计算汇总统计信息，则很有用。</li>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/CombinedMetric.java">CombinedMetric-</a>可以关联更新的指标的通用接口。</li>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/CountMetric.java">CountMetric-</a>提供的值的总计。呼叫<code>incr()</code>加一， <code>incrBy(n)</code>添加/减去给定的数字。

<ul>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/MultiCountMetric.java">MultiCountMetric-</a>计数指标的哈希表。</li>
</ul></li>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/ReducedMetric.java">减少指标</a>

<ul>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/MeanReducer.java">MeanReducer-</a>跟踪为其赋予的值的运行平均值<code>reduce()</code>方法。（它接受<code>Double</code> ， <code>Integer</code>要么<code>Long</code>值，并将内部平均值保持为<code>Double</code> ）尽管享有声誉，MeanReducer实际上是一个非常不错的人。</li>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/MultiReducedMetric.java">MultiReducedMetric-</a>简化指标的哈希图。</li>
</ul></li>
</ul>

<p>请注意，即使<code>getValueAndReset</code>可以返回对象返回任何对象都很难<code>IMetricsConsumer</code>知道如何将其转换为可用的东西。另请注意，因为它已发送到<code>IMetricsConsumer</code>作为元组的一部分，返回的值必须能够通过您的拓扑进行<a href="Serialization.html">序列化</a> 。</p>

<h3 id="metrics-consumer">指标消费者</h3>

<p>您可以通过将Metrics Consumer注册到您的拓扑中来监听和处理拓扑度量。</p>

<p>要将指标使用者注册到您的拓扑，请添加到拓扑的配置中，如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">conf</span><span class="o">.</span><span class="na">registerMetricsConsumer</span><span class="o">(</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">storm</span><span class="o">.</span><span class="na">metric</span><span class="o">.</span><span class="na">LoggingMetricsConsumer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</code></pre></div>
<p>您可以从Javadoc引用<a href="javadocs/org/apache/storm/Config.html#registerMetricsConsumer-java.lang.Class-">Config＃registerMetricsConsumer</a>和重载方法。</p>

<p>否则，请编辑storm.yaml配置文件：</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">topology.metrics.consumer.register</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">class</span><span class="pi">:</span> <span class="s2">"</span><span class="s">org.apache.storm.metric.LoggingMetricsConsumer"</span>
    <span class="s">parallelism.hint</span><span class="pi">:</span> <span class="s">1</span>
  <span class="pi">-</span> <span class="na">class</span><span class="pi">:</span> <span class="s2">"</span><span class="s">org.apache.storm.metric.HttpForwardingMetricsConsumer"</span>
    <span class="s">parallelism.hint</span><span class="pi">:</span> <span class="s">1</span>
    <span class="na">argument</span><span class="pi">:</span> <span class="s2">"</span><span class="s">http://example.com:8080/metrics/my-topology/"</span>
</code></pre></div>
<p>Storm为您的拓扑中的每个类添加了MetricsConsumerBolt <code>topology.metrics.consumer.register</code>清单。每个MetricsConsumerBolt都订阅以接收来自拓扑中所有任务的度量。每个Bolt的并行度设置为<code>parallelism.hint</code>和<code>component id</code>该螺栓设置为<code>__metrics_<metrics consumer class name></code> 。如果您多次注册相同的类名，请后缀<code>#<sequence number></code>附加到组件ID。</p>

<p>Storm为您提供了一些内置指标使用者，您可以尝试查看拓扑中提供了哪些指标。</p>

<ul>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/LoggingMetricsConsumer.java"><code>LoggingMetricsConsumer</code></a> -监听所有指标并将其转储到带有TSV（制表符分隔值）的日志文件中。</li>
<li><a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-loadgen/src/main/java/org/apache/storm/loadgen/HttpForwardingMetricsConsumer.java"><code>HttpForwardingMetricsConsumer</code></a> -监听所有指标，并通过HTTP将其序列化为配置的URL。风暴还提供<a href="http://github.com/apache/storm/blob/v2.1.0/storm-core/src/jvm/org/apache/storm/metric/HttpForwardingMetricsServer.java"><code>HttpForwardingMetricsServer</code></a>作为抽象类，因此您可以扩展此类并作为HTTP服务器运行，并处理HttpForwardingMetricsConsumer发送的度量。</li>
</ul>

<p>此外，Storm公开了界面<a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/metric/api/IMetricsConsumer.java"><code>IMetricsConsumer</code></a>用于实施Metrics Consumer，因此您可以创建自定义指标使用者并附加到其拓扑，或者使用Storm社区提供的Metrics Consumers的其他出色实现。一些示例是<a href="https://github.com/verisign/storm-graphite">versign / storm-graphite</a>和<a href="https://github.com/endgameinc/storm-metrics-statsd">storm-metrics-statsd</a> 。</p>

<p>当您实现自己的指标使用者时， <code>argument</code>是在<a href="javadocs/org/apache/storm/metric/api/IMetricsConsumer.html#prepare-java.util.Map-java.lang.Object-org.apache.storm.task.TopologyContext-org.apache.storm.task.IErrorReporter-">调用IMetricsConsumer＃prepare</a>时传递给Object的，因此您需要推断yaml上Java配置值的类型，并进行显式类型转换。</p>

<p>请记住，MetricsConsumerBolt只是一种Bolt，因此当注册的度量使用者无法继续处理传入度量时，拓扑的整体吞吐量将下降，因此您可能需要像普通的Bolt一样照顾这些Bolt。避免这种情况的一种方法是使您的Metrics Consumer实现为<code>non-blocking</code>时尚。</p>

<h3 id="build-your-own-metric-task-level">建立自己的指标（任务级别）</h3>

<p>您可以通过注册来衡量自己的指标<code>IMetric</code>到公制注册表。</p>

<p>假设我们要测量Bolt＃execute的执行计数。让我们从定义指标实例开始。CountMetric似乎适合我们的用例。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">transient</span> <span class="n">CountMetric</span> <span class="n">countMetric</span><span class="o">;</span>
</code></pre></div>
<p>注意，我们将其定义为瞬态。IMertic不可序列化，因此我们将其定义为瞬态，以避免任何序列化问题。</p>

<p>接下来，让我们初始化并注册指标实例。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// other initialization here.</span>
    <span class="n">countMetric</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CountMetric</span><span class="o">();</span>
    <span class="n">context</span><span class="o">.</span><span class="na">registerMetric</span><span class="o">(</span><span class="s">"execute_count"</span><span class="o">,</span> <span class="n">countMetric</span><span class="o">,</span> <span class="mi">60</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>第一个和第二个参数的含义很简单，指标名称和IMetric实例。<a href="javadocs/org/apache/storm/task/TopologyContext.html#registerMetric-java.lang.String-T-int-">TopologyContext＃registerMetric的</a>第三个参数是发布和重置指标的时间段（秒）。</p>

<p>最后，让我们在执行Bolt.execute（）时增加该值。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">countMetric</span><span class="o">.</span><span class="na">incr</span><span class="o">();</span>
    <span class="c1">// handle tuple here.   </span>
<span class="o">}</span>
</code></pre></div>
<p>请注意，由于我们自己调用了incr（），因此拓扑指标的采样率不会应用于自定义指标。</p>

<p>做完了！ <code>countMetric.getValueAndReset()</code> 在注册为周期时每60秒调用一次，并且对（“ execute_count”，value）将被推送到MetricsConsumer。</p>

<h3 id="build-your-own-metrics-worker-level">建立自己的指标（员工级别）</h3>

<p>您可以将自己的工作人员级别指标添加到<code>Config.WORKER_METRICS</code>对于集群中的所有工人，或<code>Config.TOPOLOGY_WORKER_METRICS</code>适用于特定拓扑中的所有工作人员。</p>

<p>例如，我们可以添加<code>worker.metrics</code>集群中的storm.yaml，</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">worker.metrics</span><span class="pi">:</span> 
  <span class="na">metricA</span><span class="pi">:</span> <span class="s2">"</span><span class="s">aaa.bbb.ccc.ddd.MetricA"</span>
  <span class="na">metricB</span><span class="pi">:</span> <span class="s2">"</span><span class="s">aaa.bbb.ccc.ddd.MetricB"</span>
  <span class="s">...</span>
</code></pre></div>
<p>或放<code>Map<String, String></code> （度量标准名称，度量标准类名称）和键<code>Config.TOPOLOGY_WORKER_METRICS</code>配置地图。</p>

<p>工作者级别指标实例有一些限制：</p>

<p>A）工作者级别的度量标准应该是一种度量标准，因为它是从SystemBolt初始化和注册的，并且不会暴露给用户任务。</p>

<p>B）指标将使用默认构造函数初始化，并且不会为配置或对象进行注入。</p>

<p>C）指标的存储桶大小（秒）固定为<code>Config.TOPOLOGY_BUILTIN_METRICS_BUCKET_SIZE_SECS</code> 。</p>

<h3 id="builtin-metrics">内置指标</h3>

<p><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/daemon/metrics/BuiltinMetricsUtil.java">内置指标</a>工具Storm本身。</p>

<p><a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/daemon/metrics/BuiltinMetricsUtil.java">BuiltinMetricsUtil.java</a>为内置指标以及其他框架组件可以用来更新它们的Facade方法设置数据结构。指标本身是在调用代码中计算的-例如<a href="http://github.com/apache/storm/blob/v2.1.0/storm-client/src/jvm/org/apache/storm/executor/Executor.java"><code>ackSpoutMsg</code></a> 。</p>

<h4 id="reporting-rate">报告率</h4>

<p>内置指标的报告速率可以通过以下方式配置<code>topology.builtin.metrics.bucket.size.secs</code>配置。如果将此值设置得太低，则可能会使消耗者过载，因此在修改它时请格外小心。</p>

<h4 id="tuple-counting-metrics">元组计数指标</h4>

<p>有几个不同的指标与计算螺栓或喷嘴对元组的作用有关。其中包括元组的发出，传输，确认和失败。</p>

<p>通常，除非另有说明，否则所有这些元组计数指标都是随机子采样的。这意味着您在UI和内置指标上看到的计数不一定准确。实际上，默认情况下，我们仅对5％的事件进行采样，并据此估算事件的总数。采样百分比可通过以下方式针对每个拓扑进行配置<code>topology.stats.sample.rate</code>配置。将其设置为1.0将使计数准确，但是请注意，我们采样的事件越多，拓扑运行的速度就越慢（因为指标是在与处理元组相同的代码路径中计数的）。这就是为什么我们将5％的采样率作为默认值的原因。</p>

<p>除非另外明确说明，否则通常将元组计数度量作为映射报告给度量消费者。他们将每个计数分解为更细粒度的报告。这些地图的关键分为两类<code>"${stream_name}"</code>要么<code>"${upstream_component}:${stream_name}"</code> 。前者用于所有出水口度量标准和外向螺栓度量标准（ <code>__emit-count</code>和<code>__transfer-count</code> ）。后者用于处理传入元组的螺栓度量。</p>

<p>因此，对于字数统计拓扑而言，计数螺栓可能会显示以下内容<code>__ack-count</code>公制</p>
<div class="highlight"><pre><code class="language-" data-lang="">{
    "split:default": 80080
}
</code></pre></div>
<p>但是，喷口将显示如下所示的内容<code>__ack-count</code>指标。</p>
<div class="highlight"><pre><code class="language-" data-lang="">{
    "default": 12500
}
</code></pre></div>
<h5 id="__ack-count"><code>__ack-count</code></h5>

<p>对于螺栓，具有<code>ack</code>方法调用它们。对于喷口来说，是完全被确认的元组树的数量。请参阅保证消息处理<a href="Guaranteeing-message-processing.html"></a>有关什么是元组树的更多信息。如果禁用了确认，则仍会报告此指标，但它实际上没有意义。</p>

<h5 id="__fail-count"><code>__fail-count</code></h5>

<p>对于螺栓，这是具有<code>fail</code>方法调用它们。对于喷嘴，这是失败的元组树的数量。元组树可能会因超时而失败，或者是因为其中一个称为螺栓的失败。这两个指标未分开。</p>

<h5 id="__emit-count"><code>__emit-count</code></h5>

<p>这是总次数<code>emit</code>调用方法来发送元组。螺栓和喷嘴都一样。</p>

<h5 id="__transfer-count"><code>__transfer-count</code></h5>

<p>这是传输到下游螺栓/喷嘴以进行处理的元组总数。这个数字并不总是匹配<code>__emit_count</code> 。如果未注册任何内容以接收元组下游，则即使发出元组，该数字也将为0。同样，如果有多个下游使用者，则它可能是发出的数目的倍数。如果分组将元组发送到单个螺栓下游的多个实例，则分组也可以发挥作用。</p>

<h5 id="__execute-count"><code>__execute-count</code></h5>

<p>此计数指标是特定于螺栓的。它计算螺栓的次数<code>execute</code>方法被调用。</p>

<h4 id="tuple-latency-metrics">元组延迟指标</h4>

<p>与元组计数指标类似，风暴也收集螺栓和喷口的平均延迟指标。它们遵循与螺栓/喷口贴图相同的结构，并且也以相同的方式进行子采样。在所有情况下，延迟都以毫秒为单位。</p>

<h5 id="__complete-latency"><code>__complete-latency</code></h5>

<p>完整的延迟仅适用于喷口。这是花费的平均时间<code>ack</code>要么<code>fail</code>在元组发出后被称为元组。如果禁用确认，则该指标可能为空白或所有值均为0，因此应将其忽略。</p>

<h5 id="__execute-latency"><code>__execute-latency</code></h5>

<p>这仅用于螺栓。它是销钉在调用中花费的平均时间<code>execute</code>方法。此值越高，每个螺栓实例的元组的吞吐量越低。</p>

<h5 id="__process-latency"><code>__process-latency</code></h5>

<p>这也仅适用于螺栓。这是之间的平均时间间隔<code>execute</code>被称为开始处理元组，直到元组被螺栓确认或失败。如果您的螺栓是非常简单的螺栓并且处理是同步的，则<code>__process-latency</code>和<code>__execute-latency</code>彼此之间应该非常接近，并且处理延迟会稍短一些。如果您正在执行联接或具有异步处理，则可能需要一段时间才能确认元组，因此处理延迟将高于执行延迟。</p>

<h5 id="__skipped-max-spout-ms"><code>__skipped-max-spout-ms</code></h5>

<p>该指标记录了喷嘴闲置了多少时间，因为元组多于<code>topology.max.spout.pending</code>仍然很出色这是总时间（以毫秒为单位），而不是平均时间量，并且未进行二次采样。</p>

<h5 id="__skipped-backpressure-ms"><code>__skipped-backpressure-ms</code></h5>

<p>该度量记录了喷嘴空闲的时间，因为背压表明拓扑中的下游队列太满。这是总时间（以毫秒为单位），而不是平均时间量，并且未进行二次采样。这类似于Storm 1.x中的skip-throttle-ms。</p>

<h5 id="skipped-inactive-ms"><code>skipped-inactive-ms</code></h5>

<p>该度量记录了由于停用了拓扑而喷口空闲的时间。这是总时间（以毫秒为单位），而不是平均时间，并且未进行二次采样。</p>

<h4 id="error-reporting-metrics">错误报告指标</h4>

<p>Storm还收集有关螺栓和喷嘴的错误报告指标。</p>

<h5 id="__reported-error-count"><code>__reported-error-count</code></h5>

<p>此度量标准记录喷口/螺栓报告的错误数量。它是总次数<code>reportError</code>方法被调用。</p>

<h4 id="queue-metrics">队列指标</h4>

<p>拓扑中的每个螺栓或喷口实例都有一个接收队列和一个发送队列。每个工作人员还具有用于向其他工作人员发送消息的队列。所有这些都有报告的指标。</p>

<p>接收队列指标报告在<code>__receive</code>名称和发送队列指标在“ <code>__sendqueue</code>对于给定的螺栓/喷嘴，它们是其中的一部分。向其他工作人员发送消息的队列的指标位于<code>__transfer</code>系统螺栓的度量标准名称（ <code>__system</code> ）。</p>

<p>他们都有表格。</p>
<div class="highlight"><pre><code class="language-" data-lang="">{
    "arrival_rate_secs": 1229.1195171893523,
    "overflow": 0,
    "read_pos": 103445,
    "write_pos": 103448,
    "sojourn_time_ms": 2.440771591407277,
    "capacity": 1024,
    "population": 19
    "tuple_population": 200
}
</code></pre></div>
<p>在风暴中，有时我们将多个元组批处理到中断队列中的单个条目中。此批处理是从一开始就以某种形式出现的最优化，但是度量标准并不总是能够反映这一点，因此在解释度量标准时要格外小心，并注意哪些度量标准用于元组，哪些度量标准用于条目中。破坏者队列。的<code>__receive</code>和<code>__transfer</code>队列可以批量处理，但是<code>__sendqueue</code>不应该。</p>

<p><code>arrival_rate_secs</code>尽管实际上是出队率，但它是在一秒钟内插入到队列中的元组数的估计。的<code>sojourn_time_ms</code>是根据到达率计算得出的，并且是每个元组在处理之前位于队列中的毫秒数的估计值。在STORM-2621（v1.1.1，v1.2.0和v2.0.0）之前，这些是条目的比率，而不是元组的比率。</p>

<p>干扰者队列具有设置的最大条目数。如果常规队列已满，则溢出队列将接管。存储在此溢出部分中的元组批处理的数量由<code>overflow</code>指标。由于性能/效率的原因，Storm还对元组进行了一些微批处理，因此即使队列未满，您也可能会看到其中包含非常小的溢出。</p>

<p><code>read_pos</code>和<code>write_pos</code>是内部破坏者会计编号。您几乎可以将它们视为写入的条目总数（ <code>write_pos</code> ）或阅读（ <code>read_pos</code> ），因为队列已创建。它们允许整数溢出，因此如果您使用它们，请考虑到这一点。</p>

<p><code>capacity</code>是破坏者队列中的最大条目数。 <code>population</code>是当前填充在队列中的条目数。</p>

<p><code>tuple_population</code>是当前队列中的元组数，而不是条目数。它与STORM-2621（v1.1.1，v1.2.0和v2.0.0）同时添加</p>

<h4 id="system-bolt-worker-metrics">系统螺栓（工人）指标</h4>

<p>系统螺栓<code>__system</code>提供了许多适用于不同工人的指标。此处未描述的一个指标是<code>__transfer</code>队列指标，因为它符合上述其他干扰指标。</p>

<p>请注意<code>__system</code>螺栓是实际的螺栓，因此也会报告上述常规螺栓指标。</p>

<h5 id="receive-nettyserver">接收（NettyServer）</h5>

<p><code>__recv-iconnection</code>报告工作服务器上Netty服务器的统计信息。这就是从其他工作人员那里获取消息的原因。它的形式</p>
<div class="highlight"><pre><code class="language-" data-lang="">{
    "dequeuedMessages": 0,
    "enqueued": {
      "/127.0.0.1:49952": 389951
    }
}
</code></pre></div>
<p><code>dequeuedMessages</code>是对旧代码的回溯，在旧代码中，服务器与螺栓/喷口之间存在内部队列。情况不再如此，该值可以忽略。
<code>enqueued</code>是远程工作程序的地址和从其发送给该工作程序的元组数之间的映射。</p>

<h5 id="send-netty-client">发送（Netty客户）</h5>

<p>的<code>__send-iconnection</code>度量标准保存有关该工作程序的所有客户端的信息。它的形式</p>
<div class="highlight"><pre><code class="language-" data-lang="">{
    NodeInfo(node:7decee4b-c314-41f4-b362-fd1358c985b3-127.0.01, port:[6701]): {
        "reconnects": 0,
        "src": "/127.0.0.1:49951",
        "pending": 0,
        "dest": "localhost/127.0.0.1:6701",
        "sent": 420779,
        "lostOnSend": 0
    }
}
</code></pre></div>
<p>该值是一个映射，其中的键是向其发送消息的下游工作程序的NodeInfo类。这是SupervisorId +端口。该值是包含字段的另一张地图</p>

<ul>
<li><code>src</code>该客户端用来连接接收方工作者的主机/端口。</li>
<li><code>dest</code>该客户端连接到的主机/端口。</li>
<li><code>reconnects</code>发生的重新连接次数。</li>
<li><code>pending</code>尚未发送的消息数。（这对应于消息，而不是元组）</li>
<li><code>sent</code>已发送的消息数。（这不是消息元组）</li>
<li><code>lostOnSend</code> 。这是由于连接问题而丢失的消息数。（这是消息而不是元组）。</li>
</ul>

<h5 id="jvm-memory">JVM内存</h5>

<p>JVM内存使用情况通过以下方式报告<code>memory/nonHeap</code>用于堆外内存和<code>memory/heap</code>用于堆内存。这些值来自<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/MemoryUsage.html">MemoryUsage</a> mxbean。每个度量标准都报告为带有以下键的映射，以及相应的Java代码返回的值。</p>

<table><thead>
<tr>
<th>键</th>
<th>对应代码</th>
</tr>
</thead><tbody>
<tr>
<td><code>maxBytes</code></td>
<td><code>memUsage.getMax()</code></td>
</tr>
<tr>
<td><code>committedBytes</code></td>
<td><code>memUsage.getCommitted()</code></td>
</tr>
<tr>
<td><code>initBytes</code></td>
<td><code>memUsage.getInit()</code></td>
</tr>
<tr>
<td><code>usedBytes</code></td>
<td><code>memUsage.getUsed()</code></td>
</tr>
<tr>
<td><code>virtualFreeBytes</code></td>
<td><code>memUsage.getMax() - memUsage.getUsed()</code></td>
</tr>
<tr>
<td><code>unusedBytes</code></td>
<td><code>memUsage.getCommitted() - memUsage.getUsed()</code></td>
</tr>
</tbody></table>

<h5 id="jvm-garbage-collection">JVM垃圾回收</h5>

<p>确切的GC指标名称取决于您的工作人员使用的垃圾收集器。数据全部收集自<code>ManagementFactory.getGarbageCollectorMXBeans()</code>指标的名称是<code>"GC/"</code>然后是删除的空格返回的bean的名称。报告的指标只是</p>

<ul>
<li><code>count</code>发生的gc事件的数量以及</li>
<li><code>timeMs</code>执行gc的总毫秒数。<br></li>
</ul>

<p>请参阅<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/management/ManagementFactory.html#getGarbageCollectorMXBeans--">JVM文档</a>以获取更多详细信息。</p>

<h5 id="jvm-misc">JVM杂项</h5>

<ul>
<li><code>threadCount</code>是JVM中当前的线程数。</li>
</ul>

<h5 id="uptime">正常运行时间</h5>

<ul>
<li><code>uptimeSecs</code>报告工作人员已经工作的秒数</li>
<li><code>newWorkerEvent</code>首次启动工作者时为1，其他所有时间均为0。这可以用来告诉工人何时崩溃并重新启动。</li>
<li><code>startTimeSecs</code>是从时代开始几秒钟内工人开始工作的时间</li>
</ul>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>