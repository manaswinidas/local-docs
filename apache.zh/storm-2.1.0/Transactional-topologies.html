<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>事务拓扑</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=0">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">事务拓扑</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p><strong>注意</strong> ：不推荐使用事务拓扑-改用<a href="Trident-tutorial.html">Trident</a>框架。</p>

<hr>

<p>Storm通过提供至少一次处理保证来<a href="Guaranteeing-message-processing.html">保证数据处理</a> 。关于Storm的最常见问题是“鉴于元组可以重播，您如何做的事情像指望Storm？你不会夸大吗？”</p>

<p>Storm 0.7.0引入了事务拓扑，使您几乎可以为任何计算获得一次消息传递语义。因此，您可以执行诸如以完全准确，可扩展且容错的方式进行计数之类的事情。</p>

<p>像<a href="Distributed-RPC.html">分布式RPC</a>一样，事务拓扑也不是Storm的功能，因为它们是基于Storm的流，喷嘴，螺栓和拓扑原语构建的更高层次的抽象。</p>

<p>本页说明事务拓扑抽象，如何使用API，并提供有关其实现的详细信息。</p>

<h2 id="concepts">概念</h2>

<p>让我们一次一步地建立Storm对事务拓扑的抽象。让我们从最简单的方法开始，然后迭代设计直到达到Storm的设计。</p>

<h3 id="design-1">设计1</h3>

<p>事务拓扑背后的核心思想是为数据处理提供<em>强大的排序</em> 。最简单的体现以及我们将要研究的第一个设计是一次处理一个元组，直到拓扑成功地处理了当前元组后，才继续处理下一个元组。</p>

<p>每个元组都与一个事务ID相关联。如果元组失败并且需要重播，则将使用完全相同的事务ID发出它。交易ID是一个整数，每个元组都会递增，因此第一个元组将具有交易ID <code>1</code> ，第二个ID <code>2</code> ， 等等。</p>

<p>元组的强顺序使您即使在元组重播的情况下也可以实现一次精确的语义。让我们看一个如何做的例子。</p>

<p>假设您要对流中的元组进行全局计数。您可以将计数和最新的事务ID作为一个值存储在数据库中，而不仅仅是将计数存储在数据库中。当您的代码更新db中的计数时， <em>仅当数据库中的事务ID与当前正在处理的元组的事务ID</em>不同时，才应更新计数。考虑以下两种情况：</p>

<ol>
<li><em>数据库中的事务ID与当前事务ID不同：</em>由于<em>事务</em>的顺序很强，我们可以确定当前元组未在该计数中表示。因此，我们可以安全地增加计数并更新交易ID。</li>
<li><em>事务ID与当前事务ID相同：</em>然后我们知道该元组已经合并到计数中，可以跳过更新。在更新数据库之后但在将成功报告给Storm之前，该元组必须失败。</li>
</ol>

<p>这种逻辑和强大的事务顺序确保即使重播元组，数据库中的计数也将准确。这种将交易ID与值一起存储在数据库中的窍门归功于Kafka开发人员，尤其是<a href="http://incubator.apache.org/kafka/07/design.html">该设计文档</a> 。</p>

<p>此外，请注意，拓扑可以安全地更新同一事务中的许多状态源，并实现一次精确的语义。如果出现故障，则已成功执行的任何更新将在重试时跳过，而所有失败的更新将被正确重试。例如，如果您正在处理一条tweeted url流，则可以更新一个存储每个URL的tweet计数的数据库以及一个存储每个域的tweet计数的数据库。</p>

<p>但是，这种同时处理一个元组的设计存在很大的问题。在继续前进到下一个元组之前，必须等待每个元组被<em>完全处理</em> ，这是非常低效的。它需要大量的数据库调用（每个元组至少一个），并且这种设计很少使用Storm的并行化功能。因此它不是很可扩展。</p>

<h3 id="design-2">设计2</h3>

<p>更好的方法不是每次处理一个元组，而是为每个事务处理一批元组。因此，如果要进行全局计数，则可以将整个批次中的元组数增加计数。如果批次失败，则重播失败的确切批次。无需为每个元组分配事务ID，而是为每个批次分配事务ID，并且对这些批次的处理进行了严格的排序。这是此设计的图：</p>

<p><img src="images/transactional-batches.png" alt="风暴群"></p>

<p>因此，如果每批处理1000个元组，则您的应用程序执行的数据库操作将比设计1少1000倍。此外，它还利用了Storm的并行化功能，因为每个批次的计算可以并行化。</p>

<p>尽管此设计明显优于设计1，但仍无法尽可能节省资源。拓扑中的工作人员会花费大量时间空闲，以等待计算的其他部分完成。例如，在这样的拓扑中：</p>

<p><img src="images/transactional-design-2.png" alt="风暴群"></p>

<p>螺栓1完成其部分处理后，它将一直处于闲置状态，直到其余的螺栓完成并且可以从喷嘴中排出下一批。</p>

<h3 id="design-3-storms-design">设计3（风暴的设计）</h3>

<p>一个关键的认识是，并非所有处理批处理元组的工作都需要有序地进行。例如，在计算全局计数时，计算分为两个部分：</p>

<ol>
<li>计算批次的部分计数</li>
<li>使用部分计数更新数据库中的全局计数</li>
</ol>

<p>＃2的计算需要在批之间进行严格排序，但是没有理由您不能通过为多个批并行计算＃1来<em>流水线化</em>批的计算。因此，当批次1正在更新数据库时，批次2至10可以计算其部分计数。</p>

<p>Storm通过将批处理的计算分为两个阶段来实现这一区别：</p>

<ol>
<li>处理阶段：这是可以并行完成许多批次的阶段</li>
<li>提交阶段：批处理的提交阶段是有序的。因此，直到成功完成批次1的提交后，批次2的提交才完成。</li>
</ol>

<p>这两个阶段一起称为“交易”。在给定的时刻，许多批次可以处于处理阶段，但是只有一个批次可以处于提交阶段。如果批处理或提交阶段发生任何故障，则将重播整个事务（两个阶段）。</p>

<h2 id="design-details">设计细节</h2>

<p>使用事务拓扑时，Storm会为您执行以下操作：</p>

<ol>
<li><em>管理状态：</em> Storm在Zookeeper中存储执行事务拓扑所需的所有状态。这包括当前交易ID以及为每个批次定义参数的元数据。</li>
<li><em>协调事务：</em> Storm将管理一切必要的事务，以确定在任何时候都应处理或提交哪些事务。</li>
<li><em>故障检测：</em> Storm利用确认框架来有效地确定何时成功处理，成功提交或失败批处理。然后，Storm将适当地重播批次。您无需做任何确认或锚定操作-Storm会为您管理所有这些操作。</li>
<li><em>一流的批处理API</em> ：Storm在常规螺栓之上分层API，以允许对元组进行批处理。Storm管理所有协调，以确定任务何时收到该特定事务的所有元组。Storm还负责清理每个事务的任何累积状态（例如部分计数）。</li>
</ol>

<p>最后，要注意的另一件事是事务拓扑需要一个源队列，该源队列可以重播确切的消息批。诸如<a href="https://github.com/robey/kestrel">Kestrel之类的</a>技术无法做到这一点。<a href="http://incubator.apache.org/kafka/index.html">Apache Kafka</a>非常适合这种喷口， <a href="https://github.com/apache/storm/tree/master/external/storm-kafka-client">storm-kafka-client</a>包含针对Kafka的事务性喷口实现。</p>

<h2 id="the-basics-through-example">通过示例的基础</h2>

<p>您可以使用<a href="javadocs/org/apache/storm/transactional/TransactionalTopologyBuilder.html">TransactionalTopologyBuilder</a>构建事务拓扑。这是拓扑的事务拓扑定义，该拓扑从输入流中计算元组的全局计数。此代码来自Storm-starter中的<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/jvm/org/apache/storm/starter/TransactionalGlobalCount.java">TransactionalGlobalCount</a> 。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">MemoryTransactionalSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MemoryTransactionalSpout</span><span class="o">(</span><span class="n">DATA</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">),</span> <span class="n">PARTITION_TAKE_PER_BATCH</span><span class="o">);</span>
<span class="n">TransactionalTopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TransactionalTopologyBuilder</span><span class="o">(</span><span class="s">"global-count"</span><span class="o">,</span> <span class="s">"spout"</span><span class="o">,</span> <span class="n">spout</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"partial-count"</span><span class="o">,</span> <span class="k">new</span> <span class="n">BatchCount</span><span class="o">(),</span> <span class="mi">5</span><span class="o">)</span>
        <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"spout"</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"sum"</span><span class="o">,</span> <span class="k">new</span> <span class="n">UpdateGlobalCount</span><span class="o">())</span>
        <span class="o">.</span><span class="na">globalGrouping</span><span class="o">(</span><span class="s">"partial-count"</span><span class="o">);</span>
</code></pre></div>
<p><code>TransactionalTopologyBuilder</code>在构造函数中将事务拓扑的ID，拓扑内喷口的ID，事务喷口以及可选的事务喷口的并行性作为构造函数的输入。事务性拓扑的ID用于在Zookeeper中存储有关拓扑进度的状态，因此，如果重新启动拓扑，它将在中断的地方继续。</p>

<p>事务拓扑只有一个<code>TransactionalSpout</code>在构造函数中定义的<code>TransactionalTopologyBuilder</code> 。在这个例子中<code>MemoryTransactionalSpout</code>用于从内存分区的数据源中读取数据（ <code>DATA</code>变量）。第二个参数定义数据的字段，第三个参数指定每批元组从每个分区发出的最大元组数。本教程稍后将讨论定义自己的事务处理喷口的界面。</p>

<p>现在到螺栓上。这种拓扑使全局计数的计算并行化。第一个螺栓<code>BatchCount</code> ，使用随机分组对输入流进行随机分区，并为每个分区发出计数。第二个螺栓<code>UpdateGlobalCount</code> ，进行全局分组，并将部分计数求和，以获得批次的计数。然后，如有必要，它将更新数据库中的全局计数。</p>

<p>这是<code>BatchCount</code> ：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">BatchCount</span> <span class="kd">extends</span> <span class="n">BaseBatchBolt</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">_id</span><span class="o">;</span>
    <span class="n">BatchOutputCollector</span> <span class="n">_collector</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">BatchOutputCollector</span> <span class="n">collector</span><span class="o">,</span> <span class="n">Object</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
        <span class="n">_id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_count</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">finishBatch</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">_id</span><span class="o">,</span> <span class="n">_count</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="s">"count"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>将为每个正在处理的批次创建该对象的新实例。运行在其中的实际螺栓称为<a href="https://github.com/apache/storm/blob/0.7.0/src/jvm/org/apache/storm/coordination/BatchBoltExecutor.java">BatchBoltExecutor，</a>并管理这些对象的创建和清除。</p>

<p>的<code>prepare</code>方法使用Storm配置，拓扑上下文，输出收集器和该批元组的ID参数化此批处理螺栓。对于事务拓扑，该ID将是<a href="javadocs/org/apache/storm/transactional/TransactionAttempt.html">TransactionAttempt</a>对象。批处理螺栓抽象也可以在分布式RPC中使用，它为批处理使用不同类型的ID。 <code>BatchBolt</code>实际上可以使用id的类型进行参数化，因此，如果您仅打算将批处理螺栓用于事务拓扑，则可以扩展<code>BaseTransactionalBolt</code>具有以下定义：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">BaseTransactionalBolt</span> <span class="kd">extends</span> <span class="n">BaseBatchBolt</span><span class="o">&lt;</span><span class="n">TransactionAttempt</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div>
<p>事务拓扑中发出的所有元组必须具有<code>TransactionAttempt</code>作为元组的第一个字段。这使Storm可以识别哪些元组属于哪些批次。因此，在发出元组时，需要确保满足此要求。</p>

<p>的<code>TransactionAttempt</code>包含两个值：“交易ID”和“尝试ID”。“交易ID”是为此批次选择的唯一ID，无论批次重播多少次，ID都是相同的。“尝试ID”是该特定批处理元组的唯一ID，并使Storm可以将元组与同一批处理的不同排放区分开。如果没有尝试ID，Storm可能会使批处理的重播与元组在之前发出该批处理时的重播混淆。这将是灾难性的。</p>

<p>每发出一个批次，交易编号增加1。因此，第一批的ID为“ 1”，第二批的ID为“ 2”，依此类推。</p>

<p>的<code>execute</code>批处理中的每个元组都会调用方法。每次调用此方法时，都应在本地实例变量中累积批处理的状态。的<code>BatchCount</code>螺栓为每个元组增加一个本地计数器变量。</p>

<p>最后， <code>finishBatch</code>当任务已收到针对该特定批处理的所有元组时，将调用。 <code>BatchCount</code>调用此方法时，将部分计数发送到输出流。</p>

<p>这是<code>UpdateGlobalCount</code> ：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">UpdateGlobalCount</span> <span class="kd">extends</span> <span class="n">BaseTransactionalBolt</span> <span class="kd">implements</span> <span class="n">ICommitter</span> <span class="o">{</span>
    <span class="n">TransactionAttempt</span> <span class="n">_attempt</span><span class="o">;</span>
    <span class="n">BatchOutputCollector</span> <span class="n">_collector</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">BatchOutputCollector</span> <span class="n">collector</span><span class="o">,</span> <span class="n">TransactionAttempt</span> <span class="n">attempt</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
        <span class="n">_attempt</span> <span class="o">=</span> <span class="n">attempt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_sum</span><span class="o">+=</span><span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">finishBatch</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Value</span> <span class="n">val</span> <span class="o">=</span> <span class="n">DATABASE</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">GLOBAL_COUNT_KEY</span><span class="o">);</span>
        <span class="n">Value</span> <span class="n">newval</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">val</span><span class="o">.</span><span class="na">txid</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">_attempt</span><span class="o">.</span><span class="na">getTransactionId</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">newval</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Value</span><span class="o">();</span>
            <span class="n">newval</span><span class="o">.</span><span class="na">txid</span> <span class="o">=</span> <span class="n">_attempt</span><span class="o">.</span><span class="na">getTransactionId</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">val</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">newval</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">_sum</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">newval</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">_sum</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">DATABASE</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">GLOBAL_COUNT_KEY</span><span class="o">,</span> <span class="n">newval</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">newval</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">_attempt</span><span class="o">,</span> <span class="n">newval</span><span class="o">.</span><span class="na">count</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="s">"sum"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>UpdateGlobalCount</code>特定于事务拓扑，因此它扩展了<code>BaseTransactionalBolt</code> 。在里面<code>execute</code>方法， <code>UpdateGlobalCount</code>通过将部分批次加在一起来累积此批次的计数。有趣的事情发生在<code>finishBatch</code> 。</p>

<p>首先，请注意此螺栓实现了<code>ICommitter</code>接口。这告诉Storm <code>finishBatch</code>该螺栓方法应该是事务的提交阶段的一部分。因此致电<code>finishBatch</code>该螺栓将由交易ID强烈排序（ <code>execute</code>另一方面可能在处理或提交阶段发生）。将螺栓标记为提交者的另一种方法是使用<code>setCommitterBolt</code>方法中<code>TransactionalTopologyBuilder</code>代替<code>setBolt</code> 。</p>

<p>的代码<code>finishBatch</code>在<code>UpdateGlobalCount</code>从数据库获取当前值，并将其交易ID与该批次的交易ID进行比较。如果它们相同，则不执行任何操作。否则，它将通过该批次的部分计数使数据库中的值递增。</p>

<p>可以在Storm-starter的<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/jvm/org/apache/storm/starter/TransactionalWords.java">TransactionalWords</a>类中找到更广泛涉及的事务拓扑示例，该示例可以等效地更新多个数据库。</p>

<h2 id="transactional-topology-api">事务拓扑API</h2>

<p>本节概述了事务拓扑API的不同部分。</p>

<h3 id="bolts">螺栓</h3>

<p>事务拓扑中可能存在三种螺栓：</p>

<ol>
<li><a href="javadocs/org/apache/storm/topology/base/BaseBasicBolt.html">BasicBolt</a> ：此螺栓不处理批处理元组，仅根据单个输入元组发出元组。</li>
<li><a href="javadocs/org/apache/storm/topology/base/BaseBatchBolt.html">BatchBolt</a> ：此螺栓处理批处理元组。 <code>execute</code>每个元组都被调用，并且<code>finishBatch</code>批处理完成时调用。</li>
<li>标记为提交者的BatchBolt：此螺栓与常规批次螺栓之间的唯一区别是何时<code>finishBatch</code>叫做。提交螺栓具有<code>finishedBatch</code>在提交阶段调用。保证只有在成功完成所有先前的批次之后，才发生提交阶段，并且将重试该阶段，直到拓扑中的所有螺栓成功完成该批次的提交为止。有两种方法可以使<code>BatchBolt</code>提交者，通过<code>BatchBolt</code>实现<a href="javadocs/org/apache/storm/transactional/ICommitter.html">ICommitter</a>标记接口，或使用<code>setCommiterBolt</code>方法中<code>TransactionalTopologyBuilder</code> 。</li>
</ol>

<h4 id="processing-phase-vs-commit-phase-in-bolts">螺栓的处理阶段与提交阶段</h4>

<p>为了确定事务的处理阶段和提交阶段之间的区别，让我们看一个示例拓扑：</p>

<p><img src="images/transactional-commit-flow.png" alt="风暴群"></p>

<p>在此拓扑中，只有红色轮廓的螺栓才是提交者。</p>

<p>在处理阶段，螺栓A将处理出料口中的整个批次，称为<code>finishBatch</code>并将其元组发送到螺栓B和C。螺栓B是提交者，因此它将处理所有元组，但不会调用finishBatch。螺栓C也不会<code>finishBatch</code>之所以调用，是因为它尚不知道是否已从Bolt B接收到所有元组（因为Bolt B正在等待事务提交）。最后，螺栓D将收到在调用螺栓C时发出的任何元组<code>execute</code>方法。</p>

<p>批处理提交后， <code>finishBatch</code>在Bolt B上被调用。完成后，Bolt C现在可以检测到它已收到所有元组，并且将调用<code>finishBatch</code> 。最后，螺栓D将收到完整的批处理并致电<code>finishBatch</code> 。</p>

<p>请注意，即使Bolt D是提交者，当它接收到整个批处理时，也不必等待第二个提交消息。由于它在提交阶段收到了整个批处理，因此继续进行并完成了事务。</p>

<p>在提交阶段，提交器螺栓的行为就像批处理螺栓。提交螺栓和批处理螺栓之间的唯一区别是，提交螺栓不会调用<code>finishBatch</code>在交易的处理阶段。</p>

<h4 id="acking">king</h4>

<p>请注意，在使用事务拓扑时，您无需进行任何确认或锚定。Storm处理了引擎盖下的所有内容。确认策略已进行了优化。</p>

<h4 id="failing-a-transaction">交易失败</h4>

<p>使用常规螺栓时，您可以调用<code>fail</code>方法开启<code>OutputCollector</code>使该元组所属的元组树失败。由于事务拓扑对您隐藏了确认框架，因此它们提供了使批处理失败（并导致重播该批处理）的不同机制。只是抛出一个<a href="javadocs/org/apache/storm/topology/FailedException.html">FailedException</a> 。与常规例外不同，这只会导致特定批次的重放，并且不会使过程崩溃。</p>

<h3 id="transactional-spout">交易喷口</h3>

<p>的<code>TransactionalSpout</code>界面与常规界面完全不同<code>Spout</code>接口。一种<code>TransactionalSpout</code>实现会发出一批元组，并且必须确保始终为同一事务ID发出同一批元组。</p>

<p>当执行拓扑时，事务性喷口看起来像这样：</p>

<p><img src="images/transactional-spout-structure.png" alt="风暴群"></p>

<p>左侧的协调器是常规的Storm喷口，每当需要为交易发出批次时，该喷嘴就会发出一个元组。发射器执行为常规Storm螺栓，并负责发射该批处理的实际元组。发射器使用全部分组订阅协调器的“批量发射”流。</p>

<p>就其发出的元组而言，需要等幂<code>TransactionalSpout</code>存储少量状态。状态存储在Zookeeper中。</p>

<p>具体实施<code>TransactionalSpout</code>在<a href="javadocs/org/apache/storm/transactional/ITransactionalSpout.html">Javadoc中</a> 。</p>

<h4 id="partitioned-transactional-spout">分区交易喷口</h4>

<p>一种常见的事务处理喷嘴是从许多队列代理中的一组分区中读取批处理的喷嘴。例如，这就是<a href="http://github.com/apache/storm/tree/v2.1.0/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/trident/KafkaTridentSpoutTransactional.java">KafkaTridentSpoutTransactional的</a>工作方式。一个<code>IPartitionedTransactionalSpout</code>使簿记工作自动化，以管理每个分区的状态，以确保幂等可重播性。有关更多详细信息，请参见<a href="javadocs/org/apache/storm/transactional/partitioned/IPartitionedTransactionalSpout.html">Javadoc</a> 。</p>

<h3 id="configuration">组态</h3>

<p>事务拓扑有两个重要的配置位：</p>

<ol>
<li><em>Zookeeper：</em>默认情况下，事务拓扑会将状态存储在用于管理Storm集群的同一Zookeeper实例中。您可以使用“ transactional.zookeeper.servers”和“ transactional.zookeeper.port”配置覆盖此设置。</li>
<li><em>一次允许的活动批次数：</em>您必须设置一次可以处理的批次数的限制。您可以使用“ topology.max.spout.pending”配置进行配置。如果不设置此配置，它将默认为1。</li>
</ol>

<h2 id="what-if-you-cant-emit-the-same-batch-of-tuples-for-a-given-transaction-id">如果您不能为给定的交易ID发出同一批元组，该怎么办？</h2>

<p>到目前为止，有关事务拓扑的讨论假定您始终可以为相同的事务ID发出完全相同的批处理元组。那么，如果不可能的话该怎么办？</p>

<p>考虑一个不可能的例子。假设您正在从一个分区的消息代理读取元组（流在许多机器之间进行了分区），并且单个事务将包括所有单独机器的元组。现在，假设一个节点在事务失败的同时发生故障。没有该节点，就无法重播刚刚为该事务处理ID播放的同一批元组。拓扑中的处理将因无法重播同一批而停止。唯一可能的解决方案是针对该事务ID发出与之前发出的批次不同的批次。即使批次发生更改，是否仍然可以实现一次准确的消息传递语义？</p>

<p>事实证明，使用非幂等事务处理喷口仍可以在处理过程中实现一次准确的消息传递语义，尽管这在开发拓扑方面需要付出更多的努力。</p>

<p>如果批处理可以针对给定的交易ID进行更改，那么到目前为止，“如果数据库中的交易ID与当前交易的ID相同，则跳过更新”的逻辑将不再有效。这是因为当前批次与上次提交事务时的批次不同，因此结果不一定相同。您可以通过在数据库中存储更多状态来解决此问题。让我们再次使用在数据库中存储全局计数的示例，并假设批处理的部分计数存储在数据库中。 <code>partialCount</code>变量。</p>

<p>而不是在数据库中存储如下所示的值：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Value</span> <span class="o">{</span>
  <span class="n">Object</span> <span class="n">count</span><span class="o">;</span>
  <span class="n">BigInteger</span> <span class="n">txid</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>对于非等幂事务处理喷口，您应该改为存储如下所示的值：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Value</span> <span class="o">{</span>
  <span class="n">Object</span> <span class="n">count</span><span class="o">;</span>
  <span class="n">BigInteger</span> <span class="n">txid</span><span class="o">;</span>
  <span class="n">Object</span> <span class="n">prevCount</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>更新的逻辑如下：</p>

<ol>
<li>如果当前批次的交易ID与数据库中的交易ID相同，请设置<code>val.count = val.prevCount + partialCount</code> 。</li>
<li>否则，设置<code>val.prevCount = val.count</code> ， <code>val.count = val.count + partialCount</code>和<code>val.txid = batchTxid</code> 。</li>
</ol>

<p>此逻辑之所以有效，是因为一旦您首次提交特定的事务ID，就不会再提交所有先前的事务ID。</p>

<p>事务拓扑还有一些细微的方面，使不透明的事务喷口成为可能。</p>

<p>当交易失败时，处理阶段中的所有后续交易也将视为失败。这些交易中的每一个都将被重新发送和重新处理。如果没有这种行为，则可能会发生以下情况：</p>

<ol>
<li>事务A发出元组1-50</li>
<li>事务B发出元组51-100</li>
<li>交易A失败</li>
<li>事务A发出元组1-40</li>
<li>事务A提交</li>
<li>事务B提交</li>
<li>交易C发出元组101-150</li>
</ol>

<p>在这种情况下，元组41-50被跳过。通过使所有后续事务都失败，将会发生这种情况：</p>

<ol>
<li>事务A发出元组1-50</li>
<li>事务B发出元组51-100</li>
<li>事务A失败（并导致事务B失败）</li>
<li>事务A发出元组1-40</li>
<li>事务B发出元组41-90</li>
<li>事务A提交</li>
<li>事务B提交</li>
<li>交易C发出元组91-140</li>
</ol>

<p>通过使所有后续事务均失败，将不会跳过任何元组。这也表明事务处理喷口的要求是它们始终在上一个事务中断的位置发出。</p>

<p>非幂等事务喷口更简洁地称为“ OpaqueTransactionalSpout”（不透明与幂等相反）。<a href="javadocs/org/apache/storm/transactional/partitioned/IOpaquePartitionedTransactionalSpout.html">IOpaquePartitionedTransactionalSpout</a>是用于实现不透明分区事务处理喷口的接口，其中<a href="http://github.com/apache/storm/tree/v2.1.0/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/Trident/KafkaTridentSpoutOpaque.java">KafkaTridentSpoutOpaque</a>是一个示例。 <code>KafkaTridentSpoutOpaque</code>只要您使用本节中说明的更新策略，就可以承受丢失单个Kafka节点而不会牺牲准确性的情况。</p>

<h2 id="implementation">实作</h2>

<p>事务拓扑的实现非常优雅。管理提交协议，检测故障和流水线批处理似乎很复杂，但是事实证明，所有操作都可以直接映射到Storm的原语。</p>

<p>数据流如何工作：</p>

<p>这是事务性喷口的工作方式：</p>

<ol>
<li>事务性喷嘴是一种由协调器喷嘴和发射器螺栓组成的子拓扑</li>
<li>协调器是平行度为1的常规喷口</li>
<li>发射器是平行度为P的螺栓，使用所有分组连接到协调器的“批”流</li>
<li>当协调者确定是时候进入交易的处理阶段时，它将向“批处理”流中发送一个包含TransactionAttempt和该交易的元数据的元组。</li>
<li>由于所有分组，每个单个发射器任务都会收到有关该交易尝试发射其元组部分的通知。</li>
<li>Storm自动管理整个拓扑中必需的锚定/确认，以确定事务何时完成处理阶段。这里的关键是*根元组是由协调器创建的，因此如果处理阶段成功，则协调器将收到“ ack”，如果由于任何原因（失败或超时）而未成功，则协调器将收到“ fail”。</li>
<li>如果处理阶段成功，并且所有先前的事务都已成功提交，则协调器将发出一个包含TransactionAttempt到“ commit”流的元组。</li>
<li>所有提交螺栓都使用all分组订阅提交流，以便在提交发生时它们都将收到通知。</li>
<li>像处理阶段一样，协调器使用确认框架来确定提交阶段是否成功。如果收到“确认”，它将在zookeeper中将该交易标记为已完成。</li>
</ol>

<p>更多说明：</p>

<ul>
<li>事务性喷嘴是由喷嘴和螺栓组成的子拓扑<ul>
<li>出口是协调员，包含一个任务</li>
<li>螺栓是发射器</li>
<li>螺栓通过所有分组订阅协调器</li>
<li>元数据的序列化由kryo处理。仅使用在transactionalspout的组件配置中定义的注册来初始化kryo</li>
</ul></li>
<li>协调器使用确认框架来确定何时成功处理了批处理，然后确定了何时成功提交了批处理。</li>
<li>状态使用RotatingTransactionalState存储在Zookeeper中</li>
<li>提交螺栓使用所有分组订阅协调器提交流</li>
<li>CoordinatedBolt用于检测螺栓何时接收到特定批次的所有元组。

<ul>
<li>这与DRPC中使用的抽象相同</li>
<li>对于提交螺栓，它会在调用finishbatch之前等待从协调器的提交流中接收元组</li>
<li>因此它无法调用finishbatch，直到它从所有订阅的组件接收到所有元组并且接收到提交流元组（对于提交者）为止。这样可以确保它不会过早地调用finishBatch</li>
</ul></li>
</ul>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>