<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>Storm JDBC集成</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=1">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">Storm JDBC集成</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>JDBC的Storm / Trident集成。该软件包包括核心螺栓和三叉戟状态，它们允许风暴拓扑在数据库表中插入风暴元组或对数据库执行选择查询，并丰富风暴拓扑中的元组。</p>

<p><strong>注意</strong> ：在以下示例中，我们都使用com.google.common.collect。列表和com.google.common.collect。地图。</p>

<h2 id="inserting-into-a-database">插入数据库。</h2>

<p>该程序包中用于将数据插入数据库表的螺栓和三叉戟状态与一个表相关联。</p>

<h3 id="connectionprovider">连接提供者</h3>

<p>应该由不同的连接池机制实现的接口<code>org.apache.storm.jdbc.common.ConnectionProvider</code></p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ConnectionProvider</span> <span class="kd">extends</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="cm">/**
     * method must be idempotent.
     */</span>
    <span class="kt">void</span> <span class="nf">prepare</span><span class="o">();</span>

    <span class="cm">/**
     *
     * @return a DB connection over which the queries can be executed.
     */</span>
    <span class="n">Connection</span> <span class="nf">getConnection</span><span class="o">();</span>

    <span class="cm">/**
     * called once when the system is shutting down, should be idempotent.
     */</span>
    <span class="kt">void</span> <span class="nf">cleanup</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>开箱即用，我们支持<code>org.apache.storm.jdbc.common.HikariCPConnectionProvider</code>这是使用HikariCP的实现。</p>

<h3 id="jdbcmapper">JdbcMapper</h3>

<p>使用JDBC在表中插入数据的主要API是<code>org.apache.storm.jdbc.mapper.JdbcMapper</code>接口：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JdbcMapper</span>  <span class="kd">extends</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="nf">getColumns</span><span class="o">(</span><span class="n">ITuple</span> <span class="n">tuple</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>的<code>getColumns()</code>方法定义Storm元组如何映射到表示数据库中某一行的列的列表。
<strong>返回列表的顺序很重要。提供的查询中的占位符以与返回列表相同的顺序解析。</strong>例如，如果用户提供的插入查询为<code>insert into user(user_id, user_name, create_date) values (?,?, now())</code>返回的列表的第一项<code>getColumns</code>方法将映射到第一个占位符，第二个到第二个，依此类推。我们不会解析提供的查询，以尝试按列名解析占位符。不对查询语法做任何假设，就可以让某些非标准sql框架（例如仅支持upsert into的Pheonix）使用此连接器。</p>

<h3 id="jdbcinsertbolt">JdbcInsertBolt</h3>

<p>要使用<code>JdbcInsertBolt</code> ，您可以通过指定一个实例来构造实例<code>ConnectionProvider</code>实施和<code>JdbcMapper</code>将Storm元组转换为DB行的实现。此外，您必须使用以下方式提供表名： <code>withTableName</code>方法或使用的插入查询<code>withInsertQuery</code> 。如果您指定插入查询，则应确保<code>JdbcMapper</code>实现将以与插入查询相同的顺序返回列列表。您可以选择指定查询超时秒数参数，该参数指定插入查询可以花费的最大秒数。默认值设置为topology.message.timeout.secs的值，值-1表示不设置任何查询超时。您应该将查询超时值设置为<= topology.message.timeout.secs。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Map</span> <span class="n">hikariConfigMap</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSourceClassName"</span><span class="o">,</span><span class="s">"com.mysql.jdbc.jdbc2.optional.MysqlDataSource"</span><span class="o">);</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSource.url"</span><span class="o">,</span> <span class="s">"jdbc:mysql://localhost/test"</span><span class="o">);</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSource.user"</span><span class="o">,</span><span class="s">"root"</span><span class="o">);</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSource.password"</span><span class="o">,</span><span class="s">"password"</span><span class="o">);</span>
<span class="n">ConnectionProvider</span> <span class="n">connectionProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HikariCPConnectionProvider</span><span class="o">(</span><span class="n">hikariConfigMap</span><span class="o">);</span>

<span class="n">String</span> <span class="n">tableName</span> <span class="o">=</span> <span class="s">"user_details"</span><span class="o">;</span>
<span class="n">JdbcMapper</span> <span class="n">simpleJdbcMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleJdbcMapper</span><span class="o">(</span><span class="n">tableName</span><span class="o">,</span> <span class="n">connectionProvider</span><span class="o">);</span>

<span class="n">JdbcInsertBolt</span> <span class="n">userPersistenceBolt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JdbcInsertBolt</span><span class="o">(</span><span class="n">connectionProvider</span><span class="o">,</span> <span class="n">simpleJdbcMapper</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">withTableName</span><span class="o">(</span><span class="s">"user"</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">withQueryTimeoutSecs</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
                                    <span class="n">Or</span>
<span class="n">JdbcInsertBolt</span> <span class="n">userPersistenceBolt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JdbcInsertBolt</span><span class="o">(</span><span class="n">connectionProvider</span><span class="o">,</span> <span class="n">simpleJdbcMapper</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">withInsertQuery</span><span class="o">(</span><span class="s">"insert into user values (?,?)"</span><span class="o">)</span>
                                    <span class="o">.</span><span class="na">withQueryTimeoutSecs</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>                                    
</code></pre></div>
<h3 id="simplejdbcmapper">SimpleJdbcMapper</h3>

<p><code>storm-jdbc</code>包括通用<code>JdbcMapper</code>实现称为<code>SimpleJdbcMapper</code>可以将Storm元组映射到Database行。 <code>SimpleJdbcMapper</code>假设风暴元组的字段名称与您要写入的数据库表中的列名称相同。</p>

<p>使用<code>SimpleJdbcMapper</code> ，您只需告诉它要写入的tableName并提供一个connectionProvider实例。</p>

<p>以下代码创建了一个<code>SimpleJdbcMapper</code>实例表明：</p>

<ol>
<li>将允许映射器将风暴元组转换为映射到表test.user_details中的行的列列表。</li>
<li>将使用提供的HikariCP配置建立具有指定数据库配置的连接池，并自动找出您要写入的表的列名和对应的数据类型。请参阅<a href="https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby">https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby</a>了解有关hikari配置属性的更多信息。</li>
</ol>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Map</span> <span class="n">hikariConfigMap</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSourceClassName"</span><span class="o">,</span><span class="s">"com.mysql.jdbc.jdbc2.optional.MysqlDataSource"</span><span class="o">);</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSource.url"</span><span class="o">,</span> <span class="s">"jdbc:mysql://localhost/test"</span><span class="o">);</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSource.user"</span><span class="o">,</span><span class="s">"root"</span><span class="o">);</span>
<span class="n">hikariConfigMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dataSource.password"</span><span class="o">,</span><span class="s">"password"</span><span class="o">);</span>
<span class="n">ConnectionProvider</span> <span class="n">connectionProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HikariCPConnectionProvider</span><span class="o">(</span><span class="n">hikariConfigMap</span><span class="o">);</span>
<span class="n">String</span> <span class="n">tableName</span> <span class="o">=</span> <span class="s">"user_details"</span><span class="o">;</span>
<span class="n">JdbcMapper</span> <span class="n">simpleJdbcMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleJdbcMapper</span><span class="o">(</span><span class="n">tableName</span><span class="o">,</span> <span class="n">connectionProvider</span><span class="o">);</span>
</code></pre></div>
<p>在上面的示例中初始化的映射器假定一个风暴元组对于您要向其中插入数据的表的所有列具有值，并且<code>getColumn</code>方法将按Jdbc连接实例的顺序返回列<code>connection.getMetaData().getColumns();</code>方法返回它们。</p>

<p><strong>如果您指定了自己的插入查询<code>JdbcInsertBolt</code>你必须初始化<code>SimpleJdbcMapper</code>具有显式columnchema，以便架构中的列与插入查询的顺序相同。</strong>例如，如果您的插入查询是<code>Insert into user (user_id, user_name) values (?,?)</code>然后你的<code>SimpleJdbcMapper</code>应该使用以下语句初始化：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="n">columnSchema</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">Column</span><span class="o">(</span><span class="s">"user_id"</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">.</span><span class="na">Types</span><span class="o">.</span><span class="na">INTEGER</span><span class="o">),</span>
    <span class="k">new</span> <span class="nf">Column</span><span class="o">(</span><span class="s">"user_name"</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">.</span><span class="na">Types</span><span class="o">.</span><span class="na">VARCHAR</span><span class="o">));</span>
<span class="n">JdbcMapper</span> <span class="n">simpleJdbcMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleJdbcMapper</span><span class="o">(</span><span class="n">columnSchema</span><span class="o">);</span>
</code></pre></div>
<p>如果您的风暴元组仅具有一部分列的字段，即表中的某些列具有默认值，并且您只想为没有默认值的列插入值，则可以通过初始化<code>SimpleJdbcMapper</code>具有明确的列方案。例如，如果您有一个user_details表<code>create table if not exists user_details (user_id integer, user_name varchar(100), dept_name varchar(100), create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP);</code>在此表中，create_time列具有默认值。为了确保仅插入没有默认值的列，您可以初始化<code>jdbcMapper</code>如下：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="n">columnSchema</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">Column</span><span class="o">(</span><span class="s">"user_id"</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">.</span><span class="na">Types</span><span class="o">.</span><span class="na">INTEGER</span><span class="o">),</span>
    <span class="k">new</span> <span class="nf">Column</span><span class="o">(</span><span class="s">"user_name"</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">.</span><span class="na">Types</span><span class="o">.</span><span class="na">VARCHAR</span><span class="o">),</span>
    <span class="k">new</span> <span class="nf">Column</span><span class="o">(</span><span class="s">"dept_name"</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">.</span><span class="na">Types</span><span class="o">.</span><span class="na">VARCHAR</span><span class="o">));</span>
<span class="n">JdbcMapper</span> <span class="n">simpleJdbcMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleJdbcMapper</span><span class="o">(</span><span class="n">columnSchema</span><span class="o">);</span>
</code></pre></div>
<h3 id="jdbctridentstate">JdbcTridentState</h3>

<p>我们还支持可与三叉戟拓扑一起使用的三叉戟持久状态。要创建jdbc持久三叉戟状态，您需要使用表名或插入查询，JdbcMapper实例和连接提供程序实例对其进行初始化。请参阅以下示例：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">JdbcState</span><span class="o">.</span><span class="na">Options</span> <span class="n">options</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JdbcState</span><span class="o">.</span><span class="na">Options</span><span class="o">()</span>
        <span class="o">.</span><span class="na">withConnectionProvider</span><span class="o">(</span><span class="n">connectionProvider</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withMapper</span><span class="o">(</span><span class="n">jdbcMapper</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withTableName</span><span class="o">(</span><span class="s">"user_details"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withQueryTimeoutSecs</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
<span class="n">JdbcStateFactory</span> <span class="n">jdbcStateFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JdbcStateFactory</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>
</code></pre></div>
<p>相似<code>JdbcInsertBolt</code>您可以使用以下命令指定自定义插入查询<code>withInsertQuery</code>而不是指定表名。</p>

<h2 id="lookup-from-database">从数据库查找</h2>

<p>我们支持<code>select</code>来自数据库的查询，以丰富拓扑中的风暴元组。使用JDBC对数据库执行选择查询的主要API是<code>org.apache.storm.jdbc.mapper.JdbcLookupMapper</code>接口：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="nf">getColumns</span><span class="o">(</span><span class="n">ITuple</span> <span class="n">tuple</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Values</span><span class="o">&gt;</span> <span class="nf">toTuple</span><span class="o">(</span><span class="n">ITuple</span> <span class="n">input</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="n">columns</span><span class="o">);</span>
</code></pre></div>
<p>的<code>declareOutputFields</code>方法用于指示将哪些字段作为处理风暴元组的输出元组的一部分发出。</p>

<p>的<code>getColumns</code>方法指定选择查询中的占位符列及其SQL类型和要使用的值。例如，如果您正在执行查询，则在上面提到的user_details表中<code>select user_name from user_details where user_id = ? and create_time > ?</code>的<code>getColumns</code>方法将使用Storm输入元组并返回包含两个项目的List。的第一个实例<code>Column</code>类型的<code>getValue()</code>方法将用作的值<code>user_id</code>查找和第二个实例<code>Column</code>类型的<code>getValue()</code>方法将用作的值<code>create_time</code> 。
<strong>注意：返回列表中的顺序确定占位符的值。换句话说，列表中的第一项映射到第一项<code>?</code>在选择查询中，第二项到第二项<code>?</code>在查询中等等。</strong> </p>

<p>的<code>toTuple</code>方法将输入元组和代表数据库行的列列表作为选择查询的结果，并返回要发出的值的列表。
<strong>请注意，它返回的列表<code>Values</code>而不只是一个实例<code>Values</code> 。</strong> 这允许将单个数据库行映射到多个输出风暴元组。</p>

<h3 id="simplejdbclookupmapper">SimpleJdbcLookupMapper</h3>

<p><code>storm-jdbc</code>包括通用<code>JdbcLookupMapper</code>实现称为<code>SimpleJdbcLookupMapper</code> 。</p>

<p>使用<code>SimpleJdbcMapper</code> ，则必须使用螺栓输出的字段以及在选择查询中用作占位符的列的列表对其进行初始化。以下示例显示了<code>SimpleJdbcLookupMapper</code>宣布<code>user_id,user_name,create_date</code>作为输出字段和<code>user_id</code>作为选择查询中的占位符列。SimpleJdbcMapper假定您的元组中的字段名称等于占位符列名称，即在我们的示例中<code>SimpleJdbcMapper</code>会寻找一个领域<code>use_id</code>输入元组中，并将其值用作选择查询中的占位符值。对于构造输出元组，它将查找在中指定的字段<code>outputFields</code>首先在输入元组中查找，如果在输入元组中未找到，则在选择查询的输出行中查找与字段名称同名的列。因此，在下面的示例中，如果输入元组具有字段<code>user_id, create_date</code>而选择查询是<code>select user_name from user_details where user_id = ?</code> ，对于每个输入元组<code>SimpleJdbcLookupMapper.getColumns(tuple)</code>将返回的值<code>tuple.getValueByField("user_id")</code>将用作其中的值<code>?</code>选择查询。对于数据库中的每个输出行， <code>SimpleJdbcLookupMapper.toTuple()</code>将使用<code>user_id, create_date</code>从输入元组中，仅添加<code>user_name</code>从结果行中返回，并将这3个字段作为单个输出元组返回。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Fields</span> <span class="n">outputFields</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"user_id"</span><span class="o">,</span> <span class="s">"user_name"</span><span class="o">,</span> <span class="s">"create_date"</span><span class="o">);</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="n">queryParamColumns</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="k">new</span> <span class="n">Column</span><span class="o">(</span><span class="s">"user_id"</span><span class="o">,</span> <span class="n">Types</span><span class="o">.</span><span class="na">INTEGER</span><span class="o">));</span>
<span class="k">this</span><span class="o">.</span><span class="na">jdbcLookupMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleJdbcLookupMapper</span><span class="o">(</span><span class="n">outputFields</span><span class="o">,</span> <span class="n">queryParamColumns</span><span class="o">);</span>
</code></pre></div>
<h3 id="jdbclookupbolt">JdbcLookupBolt</h3>

<p>要使用<code>JdbcLookupBolt</code> ，使用<code>ConnectionProvider</code>实例<code>JdbcLookupMapper</code>实例和要执行的选择查询。您可以选择指定查询超时秒数参数，该参数指定选择查询可以花费的最大秒数。默认设置为topology.message.timeout.secs的值。您应该将此值设置为<= topology.message.timeout.secs。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">selectSql</span> <span class="o">=</span> <span class="s">"select user_name from user_details where user_id = ?"</span><span class="o">;</span>
<span class="n">SimpleJdbcLookupMapper</span> <span class="n">lookupMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleJdbcLookupMapper</span><span class="o">(</span><span class="n">outputFields</span><span class="o">,</span> <span class="n">queryParamColumns</span><span class="o">)</span>
<span class="n">JdbcLookupBolt</span> <span class="n">userNameLookupBolt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JdbcLookupBolt</span><span class="o">(</span><span class="n">connectionProvider</span><span class="o">,</span> <span class="n">selectSql</span><span class="o">,</span> <span class="n">lookupMapper</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withQueryTimeoutSecs</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
</code></pre></div>
<h3 id="jdbctridentstate-for-lookup">JdbcTridentState用于查找</h3>

<p>我们还支持可与三叉戟拓扑一起使用的三叉戟查询状态。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">JdbcState</span><span class="o">.</span><span class="na">Options</span> <span class="n">options</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JdbcState</span><span class="o">.</span><span class="na">Options</span><span class="o">()</span>
        <span class="o">.</span><span class="na">withConnectionProvider</span><span class="o">(</span><span class="n">connectionProvider</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withJdbcLookupMapper</span><span class="o">(</span><span class="k">new</span> <span class="n">SimpleJdbcLookupMapper</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"user_name"</span><span class="o">),</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="k">new</span> <span class="n">Column</span><span class="o">(</span><span class="s">"user_id"</span><span class="o">,</span> <span class="n">Types</span><span class="o">.</span><span class="na">INTEGER</span><span class="o">))))</span>
        <span class="o">.</span><span class="na">withSelectQuery</span><span class="o">(</span><span class="s">"select user_name from user_details where user_id = ?"</span><span class="o">);</span>
        <span class="o">.</span><span class="na">withQueryTimeoutSecs</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
</code></pre></div>
<h2 id="example">例：</h2>

<p>一个可运行的示例可以在<code>src/test/java/topology</code>目录。</p>

<h3 id="setup">设定</h3>

<ul>
<li>确保已将所选数据库的JDBC实现依赖项作为构建配置的一部分包括在内。</li>
<li>测试拓扑执行以下查询，因此您想要的数据库必须支持这些查询才能使测试拓扑正常工作。</li>
</ul>
<div class="highlight"><pre><code class="language-SQL" data-lang="SQL">create table if not exists user (user_id integer, user_name varchar(100), dept_name varchar(100), create_date date);
create table if not exists department (dept_id integer, dept_name varchar(100));
create table if not exists user_department (user_id integer, dept_id integer);
insert into department values (1, 'R&amp;D');
insert into department values (2, 'Finance');
insert into department values (3, 'HR');
insert into department values (4, 'Sales');
insert into user_department values (1, 1);
insert into user_department values (2, 2);
insert into user_department values (3, 3);
insert into user_department values (4, 4);
select dept_name from department, user_department where department.dept_id = user_department.dept_id and user_department.user_id = ?;
</code></pre></div>
<h3 id="execution">执行</h3>

<p>跑过<code>org.apache.storm.jdbc.topology.UserPersistenceTopology</code>类使用Storm jar命令。该类期望5个args风暴罐org.apache.storm.jdbc.topology。UserPersistenceTopology <datasourceclassname><datasource.url><user><password>[拓扑名称]</password></user></datasource.url></datasourceclassname></p>

<p>要使其与Mysql一起使用，可以将以下内容添加到pom.xml中</p>
<div class="highlight"><pre><code class="language-" data-lang="">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.31&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>您可以使用mvn程序集插件生成具有依赖性的单个jar。要使用插件，请将以下内容添加到pom.xml并执行<code>mvn clean compile assembly:single</code></p>
<div class="highlight"><pre><code class="language-" data-lang="">&lt;plugin&gt;
    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;archive&gt;
            &lt;manifest&gt;
                &lt;mainClass&gt;fully.qualified.MainClass&lt;/mainClass&gt;
            &lt;/manifest&gt;
        &lt;/archive&gt;
        &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
        &lt;/descriptorRefs&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre></div>
<p>Mysql示例：</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm jar ~/repo/incubator-storm/external/storm-jdbc/target/storm-jdbc-0.10.0-SNAPSHOT-jar-with-dependencies.jar org.apache.storm.jdbc.topology.UserPersistenceTopology  com.mysql.jdbc.jdbc2.optional.MysqlDataSource jdbc:mysql://localhost/test root password UserPersistenceTopology
</code></pre></div>
<p>您可以对用户表执行选择查询，该表应显示新插入的行：</p>
<div class="highlight"><pre><code class="language-" data-lang="">select * from user;
</code></pre></div>
<p>对于三叉戟，您可以查看<code>org.apache.storm.jdbc.topology.UserPersistenceTridentTopology</code> 。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>