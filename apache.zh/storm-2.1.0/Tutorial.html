<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>讲解</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=2">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">讲解</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>在本教程中，您将学习如何创建Storm拓扑并将其部署到Storm集群。Java将成为主要的语言，但是一些示例将使用Python来说明Storm的多语言功能。</p>

<h2 id="preliminaries">初赛</h2>

<p>本教程使用<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter">storm-starter</a>项目中的示例。建议您克隆项目并按照示例进行操作。阅读“ <a href="Setting-up-development-environment.html">设置开发环境</a>并<a href="Creating-a-new-Storm-project.html">创建新的Storm项目”</a>以设置计算机。</p>

<h2 id="components-of-a-storm-cluster">风暴集群的组成</h2>

<p>Storm集群从表面上类似于Hadoop集群。在Hadoop上运行“ MapReduce作业”，在Storm上运行“拓扑”。 “作业”和“拓扑”本身非常不同-一个主要区别是MapReduce作业最终完成，而拓扑将永远处理消息（或直到您杀死它）。</p>

<p>Storm集群上有两种节点：主节点和工作节点。主节点运行一个名为“ Nimbus”的守护程序，该守护程序类似于Hadoop的“ JobTracker”。Nimbus负责在集群中分发代码，向计算机分配任务以及监视故障。</p>

<p>每个工作程序节点都运行一个称为“ Supervisor”的守护程序。主管侦听分配给它的机器的工作，并根据Nimbus分配给它的东西在必要时启动和停止工作进程。每个工作进程执行一个拓扑子集；一个正在运行的拓扑由分布在许多计算机上的许多工作进程组成。</p>

<p><img src="images/storm-cluster.png" alt="风暴群"></p>

<p>Nimbus和主管之间的所有协调都是通过<a href="http://zookeeper.apache.org/">Zookeeper</a>集群完成的。此外，Nimbus守护程序和Supervisor守护程序是快速故障且无状态的。所有状态都保存在Zookeeper或本地磁盘中。这意味着您可以杀死-9个Nimbus或Supervisor，它们会像没有任何反应一样开始备份。这种设计使Storm集群非常稳定。</p>

<h2 id="topologies">拓扑结构</h2>

<p>要在Storm上进行实时计算，您可以创建所谓的“拓扑”。拓扑是计算图。拓扑中的每个节点都包含处理逻辑，节点之间的链接指示如何在节点之间传递数据。</p>

<p>运行拓扑非常简单。首先，将所有代码和依赖项打包到一个jar中。然后，您运行如下命令：</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm jar all-my-code.jar org.apache.storm.MyTopology arg1 arg2
</code></pre></div>
<p>这跑课<code>org.apache.storm.MyTopology</code>与参数<code>arg1</code>和<code>arg2</code> 。该类的主要功能定义拓扑并将其提交给Nimbus。的<code>storm jar</code>部分负责连接到Nimbus并上传jar。</p>

<p>由于拓扑定义只是Thrift结构，而Nimbus是Thrift服务，因此您可以使用任何编程语言来创建和提交拓扑。上面的示例是使用基于JVM的语言完成此操作的最简单方法。有关启动和停止拓扑的更多信息，请参见<a href="Running-topologies-on-a-production-cluster.html">在生产集群</a>上运行拓扑。</p>

<h2 id="streams">流</h2>

<p>Storm中的核心抽象是“流”。流是无限制的元组序列。Storm提供了用于以分布式且可靠的方式将流转换为新流的原语。例如，您可以将推文流转换为趋势主题流。</p>

<p>Storm为进行流转换提供的基本原语是“喷嘴”和“螺栓”。喷嘴和螺栓具有您实现的接口，以运行特定于应用程序的逻辑。</p>

<p>壶嘴是溪流的源头。例如，喷口可能会从<a href="http://github.com/nathanmarz/storm-kestrel">Kestrel</a>队列中读取元组并将其作为流发出。或者，喷口可能会连接到Twitter API并发出一连串推文。</p>

<p>螺栓消耗任何数量的输入流，进行一些处理，并可能发出新的流。复杂的流转换，就像从一条推文流中计算趋势主题流一样，需要多个步骤，因此需要多个步骤。螺栓可以执行任何功能，包括运行功能，过滤元组，进行流聚合，进行流连接，与数据库对话等等。</p>

<p>喷口和螺栓网络打包成一个“拓扑”，这是您提交给Storm集群以执行的顶层抽象。拓扑是流转换的图形，其中每个节点都是喷嘴或螺栓。图中的边缘指示哪些螺栓正在订阅哪些流。当喷嘴或螺栓向流中发送元组时，它将元组发送给订阅该流的每个螺栓。</p>

<p><img src="images/topology.png" alt="风暴拓扑"></p>

<p>拓扑中节点之间的链接指示元组应如何传递。例如，如果出口A和螺栓B之间存在链接，从出口A到螺栓C之间存在链接，并且从螺栓B到螺栓C之间存在链接，那么每次出口A发出一个元组时，它将将该元组发送到两个螺栓B和BoltC。BoltB的所有输出元组也将进入BoltC。</p>

<p>Storm拓扑中的每个节点都并行执行。在拓扑中，您可以指定每个节点要多少并行度，然后Storm将在集群中产生该数量的线程来执行。</p>

<p>拓扑将永远运行，或者直到您杀死它为止。Storm将自动重新分配所有失败的任务。此外，Storm保证即使机器宕机和消息丢失也不会丢失数据。</p>

<h2 id="data-model">资料模型</h2>

<p>Storm使用元组作为其数据模型。元组是值的命名列表，元组中的字段可以是任何类型的对象。开箱即用，Storm支持所有原始类型，字符串和字节数组作为元组字段值。要使用其他类型的对象，您只需为该类型实现<a href="Serialization.html">一个序列化</a>器。</p>

<p>拓扑中的每个节点都必须声明其发出的元组的输出字段。例如，此螺栓声明它发出带有“ double”和“ triple”字段的2元组：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DoubleAndTripleBolt</span> <span class="kd">extends</span> <span class="n">BaseRichBolt</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">OutputCollectorBase</span> <span class="n">_collector</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollectorBase</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>        
        <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">val</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">val</span><span class="o">*</span><span class="mi">3</span><span class="o">));</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">ack</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"double"</span><span class="o">,</span> <span class="s">"triple"</span><span class="o">));</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div>
<p>的<code>declareOutputFields</code>函数声明输出字段<code>["double", "triple"]</code>对于组件。其余的螺栓将在后面的章节中进行解释。</p>

<h2 id="a-simple-topology">一个简单的拓扑</h2>

<p>让我们看一个简单的拓扑，以进一步探索这些概念，并查看代码的形状。让我们看一下<code>ExclamationTopology</code>来自暴风雨启动器的定义：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TopologyBuilder</span><span class="o">();</span>        
<span class="n">builder</span><span class="o">.</span><span class="na">setSpout</span><span class="o">(</span><span class="s">"words"</span><span class="o">,</span> <span class="k">new</span> <span class="n">TestWordSpout</span><span class="o">(),</span> <span class="mi">10</span><span class="o">);</span>        
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"exclaim1"</span><span class="o">,</span> <span class="k">new</span> <span class="n">ExclamationBolt</span><span class="o">(),</span> <span class="mi">3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"words"</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"exclaim2"</span><span class="o">,</span> <span class="k">new</span> <span class="n">ExclamationBolt</span><span class="o">(),</span> <span class="mi">2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"exclaim1"</span><span class="o">);</span>
</code></pre></div>
<p>该拓扑包含一个喷嘴和两个螺栓。喷口发出声音，每个螺栓都在字符串后面加上“ !!!”。”输入。节点排列成一条线：喷口向第一个螺栓发射，然后向第二个螺栓发射。如果喷口发出元组[“ bob”]和[“ john”]，则第二个螺栓将发出单词[“ bob !!!!!!“]和[” john !!!!!!“]。</p>

<p>此代码使用<code>setSpout</code>和<code>setBolt</code>方法。这些方法将用户指定的id，包含处理逻辑的对象以及所需的节点并行度作为输入。在此示例中，喷口的ID为“单词”，螺栓的ID为“ exclaim1”和“ exclaim2”。</p>

<p>包含处理逻辑实现了该目的<a href="javadocs/org/apache/storm/topology/IRichSpout.html">IRichSpout</a>接口喷口和<a href="javadocs/org/apache/storm/topology/IRichBolt.html">IRichBolt</a>螺栓接口。</p>

<p>最后一个参数，即节点所需的并行度是可选的。它指示应在群集中执行多少线程的组件。如果您忽略它，Storm只会为该节点分配一个线程。</p>

<p><code>setBolt</code>返回一个<a href="javadocs/org/apache/storm/topology/InputDeclarer.html">InputDeclarer</a>对象，该对象用于定义Bolt的输入。在此，组件“ exclaim1”声明要使用随机分组读取组件“ words”发出的所有元组，而组件“ exclaim2”声明要使用随机分组读取组件“ exclaim1”发出的所有元组。 。 “随机分组”是指元组应该从输入任务随机分布到螺栓任务。有许多方法可以在组件之间对数据进行分组。这些将在几节中进行解释。</p>

<p>如果您希望组件“ exclaim2”读取组件“ words”和组件“ exclaim1”发出的所有元组，则应编写组件“ exclaim2”的定义，如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"exclaim2"</span><span class="o">,</span> <span class="k">new</span> <span class="n">ExclamationBolt</span><span class="o">(),</span> <span class="mi">5</span><span class="o">)</span>
            <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"words"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"exclaim1"</span><span class="o">);</span>
</code></pre></div>
<p>如您所见，可以将输入声明链接起来为Bolt指定多个源。</p>

<p>让我们深入研究此拓扑中的喷嘴和螺栓的实现。喷口负责将新消息发送到拓扑中。 <code>TestWordSpout</code>在这种拓扑结构中，每100ms从列表中发出一个随机词，即“ nathan”，“ mike”，“ jackson”，“ golda”，“ bertels”]。实施<code>nextTuple()</code>在TestWordSpout中看起来像这样：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">nextTuple</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Utils</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">"nathan"</span><span class="o">,</span> <span class="s">"mike"</span><span class="o">,</span> <span class="s">"jackson"</span><span class="o">,</span> <span class="s">"golda"</span><span class="o">,</span> <span class="s">"bertels"</span><span class="o">};</span>
    <span class="kd">final</span> <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">)];</span>
    <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div>
<p>如您所见，实现非常简单。</p>

<p><code>ExclamationBolt</code>追加字符串“ ！！！”输入。让我们看一下完整的实现<code>ExclamationBolt</code> ：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ExclamationBolt</span> <span class="kd">implements</span> <span class="n">IRichBolt</span> <span class="o">{</span>
    <span class="n">OutputCollector</span> <span class="n">_collector</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">tuple</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="s">"!!!"</span><span class="o">));</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">ack</span><span class="o">(</span><span class="n">tuple</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cleanup</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="nf">getComponentConfiguration</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>的<code>prepare</code>方法为螺栓提供了<code>OutputCollector</code>用于从该螺栓发射元组。元组可以随时从螺栓中发出- <code>prepare</code> ， <code>execute</code> ， 要么<code>cleanup</code>方法，甚至在另一个线程中异步。这个<code>prepare</code>实现只是保存了<code>OutputCollector</code>作为实例变量，稍后将在<code>execute</code>方法。</p>

<p>的<code>execute</code>方法从螺栓输入之一接收元组。的<code>ExclamationBolt</code>从元组中获取第一个字段，并发出带有字符串“ !!!的新元组””。如果您实现了一个预订多个输入源的螺栓，则可以使用以下命令来查找<a href="/javadoc/apidocs/org/apache/storm/tuple/Tuple.html">元组</a>来自哪个组件<code>Tuple#getSourceComponent</code>方法。</p>

<p>还有一些其他事情正在发生<code>execute</code>方法，即将输入元组作为第一个参数传递给<code>emit</code>输入的元组被确认在最后一行。这些是Storm可靠性API的一部分，可确保不丢失任何数据，并将在本教程的后面部分进行说明。</p>

<p>的<code>cleanup</code>在关闭Bolt时调用方法，该方法应清除所有打开的资源。无法保证将在群集上调用此方法：例如，如果正在运行任务的计算机崩溃，则无法调用该方法。的<code>cleanup</code>此方法适用于在<a href="Local-mode.html">本地模式下</a>运行拓扑（在其中模拟了Storm集群），并且希望能够运行并杀死许多拓扑而不会遭受任何资源泄漏。</p>

<p>的<code>declareOutputFields</code>方法声明<code>ExclamationBolt</code>发出1元组，其中一个字段称为“单词”。</p>

<p>的<code>getComponentConfiguration</code>方法允许您配置此组件的运行方式的各个方面。这是一个更高级的主题，将在<a href="Configuration.html">Configuration上</a>进一步说明。</p>

<p>像<code>cleanup</code>和<code>getComponentConfiguration</code>螺栓实施中通常不需要。您可以使用基类更简洁地定义螺栓，该基类在适当的地方提供默认的实现。 <code>ExclamationBolt</code>通过扩展可以更简洁地编写<code>BaseRichBolt</code> ，就像这样：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ExclamationBolt</span> <span class="kd">extends</span> <span class="n">BaseRichBolt</span> <span class="o">{</span>
    <span class="n">OutputCollector</span> <span class="n">_collector</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">tuple</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="s">"!!!"</span><span class="o">));</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">ack</span><span class="o">(</span><span class="n">tuple</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">));</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div>
<h2 id="running-exclamationtopology-in-local-mode">在本地模式下运行ExclamationTopology</h2>

<p>让我们看看如何运行<code>ExclamationTopology</code>在本地模式下，看到它正在工作。</p>

<p>Storm有两种操作模式：本地模式和分布式模式。在本地模式下，Storm通过使用线程模拟工作程序节点来完全在过程中执行。本地模式对于测试和开发拓扑很有用。你可以阅读更多有关在本地模式下运行拓扑<a href="Local-mode.html">本地模式</a> 。</p>

<p>要以本地模式运行拓扑，请运行以下命令<code>storm local</code>代替<code>storm jar</code> 。</p>

<h2 id="stream-groupings">流分组</h2>

<p>流分组告诉拓扑如何在两个组件之间发送元组。请记住，喷口和螺栓在集群中并行执行许多任务。如果您查看拓扑在任务级别上的执行方式，则它看起来像这样：</p>

<p><img src="images/topology-tasks.png" alt="拓扑中的任务"></p>

<p>当Bolt A的任务向Bolt B发射一个元组时，应将其发送给哪个任务？</p>

<p>“流分组”通过告诉Storm如何在任务集之间发送元组来回答这个问题。在深入研究不同类型的流分组之前，让我们看一下<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter">storm-starter的</a>另一种拓扑。这个<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/jvm/org/apache/storm/starter/WordCountTopology.java">WordCountTopology</a>从喷口中读取句子，并从中弹出<code>WordCountBolt</code>之前看到该词的总次数：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TopologyBuilder</span><span class="o">();</span>

<span class="n">builder</span><span class="o">.</span><span class="na">setSpout</span><span class="o">(</span><span class="s">"sentences"</span><span class="o">,</span> <span class="k">new</span> <span class="n">RandomSentenceSpout</span><span class="o">(),</span> <span class="mi">5</span><span class="o">);</span>        
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"split"</span><span class="o">,</span> <span class="k">new</span> <span class="n">SplitSentence</span><span class="o">(),</span> <span class="mi">8</span><span class="o">)</span>
        <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"sentences"</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"count"</span><span class="o">,</span> <span class="k">new</span> <span class="n">WordCount</span><span class="o">(),</span> <span class="mi">12</span><span class="o">)</span>
        <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"split"</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">));</span>
</code></pre></div>
<p><code>SplitSentence</code>在收到的每个句子中为每个单词发出一个元组，并且<code>WordCount</code>将地图保存在记忆中，一字不漏。每一次<code>WordCount</code>接收一个单词，它更新其状态并发出新的单词计数。</p>

<p>有几种不同的流分组。</p>

<p>最简单的分组方式称为“随机分组”，将元组发送到随机任务。随机分组用于<code>WordCountTopology</code>从发送元组<code>RandomSentenceSpout</code>到<code>SplitSentence</code>螺栓。它的作用是将处理元组的工作平均分配给所有<code>SplitSentence</code>螺栓的任务。</p>

<p>一种更有趣的分组方式是“字段分组”。字段分组用于<code>SplitSentence</code>螺栓和<code>WordCount</code>螺栓。这对于<code>WordCount</code>断定同一词总是去做同样的事情。否则，一个以上的任务将看到相同的单词，并且每个任务都会发出不正确的计数值，因为每个任务都有不完整的信息。字段分组使您可以按流的子集对流进行分组。这将导致该字段子集的相等值执行相同任务。以来<code>WordCount</code>订阅<code>SplitSentence</code>使用分组在“单词”字段上的字段的输出流，相同的单词始终执行相同的任务，并且螺栓产生正确的输出。</p>

<p>字段分组是实现流连接和流聚合以及大量其他用例的基础。在幕后，使用mod哈希实现字段分组。</p>

<p>还有其他几种流分组。您可以在<a href="Concepts.html">Concepts</a>上阅读有关它们的更多信息。</p>

<h2 id="defining-bolts-in-other-languages">用其他语言定义螺栓</h2>

<p>螺栓可以用任何语言定义。用另一种语言编写的螺栓将作为子流程执行，Storm通过stdin / stdout通过JSON消息与这些子流程进行通信。通信协议仅需要一个约100行的适配器库，Storm随附了用于Ruby，Python和Fancy的适配器库。</p>

<p>这是<code>SplitSentence</code>螺栓从<code>WordCountTopology</code> ：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SplitSentence</span> <span class="kd">extends</span> <span class="n">ShellBolt</span> <span class="kd">implements</span> <span class="n">IRichBolt</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">SplitSentence</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="s">"python"</span><span class="o">,</span> <span class="s">"splitsentence.py"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>SplitSentence</code>覆写<code>ShellBolt</code>并声明它正在使用运行<code>python</code>与参数<code>splitsentence.py</code> 。这是实现<code>splitsentence.py</code> ：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">storm</span>

<span class="k">class</span> <span class="nc">SplitSentenceBolt</span><span class="p">(</span><span class="n">storm</span><span class="o">.</span><span class="n">BasicBolt</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tup</span><span class="p">):</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">tup</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">" "</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
          <span class="n">storm</span><span class="o">.</span><span class="n">emit</span><span class="p">([</span><span class="n">word</span><span class="p">])</span>

<span class="n">SplitSentenceBolt</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>
<p>有关使用其他语言编写喷口和螺栓的更多信息，以及有关如何创建其他语言的拓扑（并完全避免使用JVM）的更多信息，请参阅<a href="Using-non-JVM-languages-with-Storm.html">对Storm使用非JVM语言</a> 。</p>

<h2 id="guaranteeing-message-processing">保证消息处理</h2>

<p>在本教程的前面，我们跳过了元组如何发出的几个方面。这些方面是Storm可靠性API的一部分：Storm如何保证从喷嘴发出的每条消息都将得到完全处理。请参阅<a href="Guaranteeing-message-processing.html">保证消息处理，</a>以获取有关此方法的工作方式以及您作为用户使用Storm的可靠性功能所必须执行的操作的信息。</p>

<h2 id="trident">三叉戟</h2>

<p>Storm保证每个消息将至少通过拓扑播放一次。常见的问题是“您如何做的事情像指望Storm？你不会夸大吗？“ Storm具有一个称为Trudent的更高级别的API，该API可让您为大多数计算实现一次准确的消息传递语义。<a href="Trident-tutorial.html">在此处</a>阅读有关Trident的更多信息。</p>

<h2 id="distributed-rpc">分布式RPC</h2>

<p>本教程展示了如何在Storm之上进行基本的流处理。使用Storm的原语可以做更多的事情。Storm最有趣的应用程序之一是分布式RPC，您可以在其中动态地并行处理强大功能的计算。<a href="Distributed-RPC.html">在此处</a>阅读有关分布式RPC的更多信息。</p>

<h2 id="conclusion">结论</h2>

<p>本教程对开发，测试和部署Storm拓扑进行了广泛概述。本文档的其余部分深入探讨了使用Storm的所有方面。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>