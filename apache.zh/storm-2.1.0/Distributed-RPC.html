<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>分布式RPC</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=0">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">分布式RPC</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>分布式RPC（DRPC）背后的思想是使用Storm即时并行处理真正密集的函数。Storm拓扑接受函数参数流作为输入，并为这些函数调用中的每一个发出结果输出流。</p>

<p>DRPC并不是Storm的功能，而是一种由Storm的流，喷口，螺栓和拓扑的原始表达的模式。DRPC可能被打包为与Storm分开的独立库，但是它是如此有用，以至于它与Storm捆绑在一起。</p>

<h3 id="high-level-overview">高级概述</h3>

<p>分布式RPC由“ DRPC服务器”协调（Storm随附于此实现）。DRPC服务器协调接收RPC请求，将请求发送到Storm拓扑，接收来自Storm拓扑的结果并将结果发送回等待的客户端。从客户端的角度来看，分布式RPC调用看起来就像常规的RPC调用。例如，这是客户端如何使用参数“ <a href="http://twitter.com":">http://twitter.com”</a>计算“ reach”函数的结果的方式<a href="http://twitter.com":">：</a></p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Config</span> <span class="n">conf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Config</span><span class="o">();</span>
<span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"storm.thrift.transport"</span><span class="o">,</span> <span class="s">"org.apache.storm.security.auth.plain.PlainSaslTransportPlugin"</span><span class="o">);</span>
<span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Config</span><span class="o">.</span><span class="na">STORM_NIMBUS_RETRY_TIMES</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Config</span><span class="o">.</span><span class="na">STORM_NIMBUS_RETRY_INTERVAL</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
<span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Config</span><span class="o">.</span><span class="na">STORM_NIMBUS_RETRY_INTERVAL_CEILING</span><span class="o">,</span> <span class="mi">20</span><span class="o">);</span>
<span class="n">DRPCClient</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DRPCClient</span><span class="o">(</span><span class="n">conf</span><span class="o">,</span> <span class="s">"drpc-host"</span><span class="o">,</span> <span class="mi">3772</span><span class="o">);</span>
<span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">"reach"</span><span class="o">,</span> <span class="s">"http://twitter.com"</span><span class="o">);</span>
</code></pre></div>
<p>或者，如果您只想使用预先配置的客户端，则可以致电。将从配置的主机集中随机选择确切的主机，如果该主机似乎已关闭，它将在所有配置的主机中循环寻找可用的主机。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DRPCClient</span> <span class="n">client</span> <span class="o">=</span> <span class="n">DRPCClient</span><span class="o">.</span><span class="na">getConfiguredClient</span><span class="o">(</span><span class="n">conf</span><span class="o">);</span>
<span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">"reach"</span><span class="o">,</span> <span class="s">"http://twitter.com"</span><span class="o">);</span>
</code></pre></div>
<p>分布式RPC工作流如下所示：</p>

<p><img src="images/drpc-workflow.png" alt="拓扑中的任务"></p>

<p>客户端向DRPC服务器发送要执行的函数的名称以及该函数的参数。实现该功能的拓扑使用<code>DRPCSpout</code>从DRPC服务器接收函数调用流。DRPC服务器用唯一的ID标记每个函数调用。然后，拓扑计算结果，并在拓扑结束时使用称为<code>ReturnResults</code>连接到DRPC服务器，并为其提供函数调用ID的结果。然后，DRPC服务器使用该ID来匹配客户端正在等待的结果，解除阻止正在等待的客户端，并将其发送给结果。</p>

<h3 id="lineardrpctopologybuilder">LinearDRPCTopologyBuilder</h3>

<p>Storm带有一个名为<a href="javadocs/org/apache/storm/drpc/LinearDRPCTopologyBuilder.html">LinearDRPCTopologyBuilder</a>的拓扑构建器，该构建器可自动执行执行DRPC涉及的几乎所有步骤。这些包括：</p>

<ol>
<li>设置喷嘴</li>
<li>将结果返回到DRPC服务器</li>
<li>为螺栓提供功能，以在元组组上进行有限聚合</li>
</ol>

<p>让我们看一个简单的例子。这是DRPC拓扑的实现，该拓扑返回带有“！”的输入参数。”附加：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ExclaimBolt</span> <span class="kd">extends</span> <span class="n">BaseBasicBolt</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">BasicOutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">tuple</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">input</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="s">"result"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">LinearDRPCTopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinearDRPCTopologyBuilder</span><span class="o">(</span><span class="s">"exclamation"</span><span class="o">);</span>
    <span class="n">builder</span><span class="o">.</span><span class="na">addBolt</span><span class="o">(</span><span class="k">new</span> <span class="n">ExclaimBolt</span><span class="o">(),</span> <span class="mi">3</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div>
<p>如您所见，几乎没有什么。创建时<code>LinearDRPCTopologyBuilder</code> ，您可以告诉它拓扑的DRPC函数的名称。单个DRPC服务器可以协调许多功能，并且功能名称将功能彼此区分开。您声明的第一个螺栓将作为输入2元组，其中第一个字段是请求ID，第二个字段是该请求的参数。 <code>LinearDRPCTopologyBuilder</code>期望最后一个螺栓发出包含[id，result]形式的2元组的输出流。最后，所有中间元组必须包含请求ID作为第一个字段。</p>

<p>在这个例子中<code>ExclaimBolt</code>只需附加一个“！”到元组的第二个字段。 <code>LinearDRPCTopologyBuilder</code>处理连接到DRPC服务器并将结果发送回的其余协调工作。</p>

<h3 id="local-mode-drpc">本地模式DRPC</h3>

<p>过去在本地模式下使用DRPC时，需要创建一个特殊的LocalDRPC实例。在为代码编写测试时仍可以使用此方法，但是在Storm的当前版本中，当您在本地模式下运行时，还将创建LocalDRPC实例，并且创建的任何DRPCClient都将链接到该实例，而不是外部环境。这意味着您要测试的任何交互都必须是启动拓扑的脚本的一部分，就像LocalDRPC一样。</p>

<h3 id="remote-mode-drpc">远程模式DRPC</h3>

<p>在实际群集上使用DRPC也是很简单的。分三个步骤：</p>

<ol>
<li>启动DRPC服务器</li>
<li>配置DRPC服务器的位置</li>
<li>将DRPC拓扑提交到Storm集群</li>
</ol>

<p>可以使用以下命令启动DRPC服务器<code>storm</code>脚本，就像启动Nimbus或UI一样：</p>
<div class="highlight"><pre><code class="language-" data-lang="">bin/storm drpc
</code></pre></div>
<p>接下来，您需要配置Storm集群以了解DRPC服务器的位置。这就是<code>DRPCSpout</code>知道从哪里读取函数调用。这可以通过<code>storm.yaml</code>文件或拓扑配置。您还应该指定storm.thrift.transport属性以匹配DRPCClient设置。通过配置<code>storm.yaml</code>看起来像这样：</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">drpc.servers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">drpc1.foo.com"</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">drpc2.foo.com"</span>
<span class="s">drpc.http.port</span><span class="pi">:</span> <span class="s">8081</span>
<span class="s">storm.thrift.transport</span><span class="pi">:</span> <span class="s2">"</span><span class="s">org.apache.storm.security.auth.plain.PlainSaslTransportPlugin"</span>
</code></pre></div>
<p>最后，您使用以下命令启动DRPC拓扑<code>StormSubmitter</code>就像您启动任何其他拓扑一样。要在远程模式下运行上述示例，请执行以下操作：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">StormSubmitter</span><span class="o">.</span><span class="na">submitTopology</span><span class="o">(</span><span class="s">"exclamation-drpc"</span><span class="o">,</span> <span class="n">conf</span><span class="o">,</span> <span class="n">builder</span><span class="o">.</span><span class="na">createRemoteTopology</span><span class="o">());</span>
</code></pre></div>
<p><code>createRemoteTopology</code>用于创建适用于Storm集群的拓扑。</p>

<p>假设拓扑正在监听<code>exclaim</code>函数，您可以执行几种不同的方式。</p>

<p>以编程方式：<code>java Config conf = new Config(); try (DRPCClient drpc = DRPCClient.getConfiguredClient(conf)) { //User the drpc client String result = drpc.execute("exclaim", "argument"); }</code></p>

<p>通过卷曲：<code>curl http://hostname:8081/drpc/exclaim/argument</code></p>

<p>通过命令行：<code>bin/storm drpc-client exclaim argument</code></p>

<h3 id="a-more-complex-example">一个更复杂的例子</h3>

<p>感叹号DRPC示例是一个说明DRPC概念的玩具示例。让我们看一个更复杂的示例，它确实需要Storm集群提供的并行性来计算DRPC函数。我们将看的示例是计算Twitter上URL的范围。</p>

<p>URL的覆盖范围是在Twitter上暴露给URL的唯一身份人数。要计算覆盖率，您需要：</p>

<ol>
<li>获取所有推特网址的人</li>
<li>得到所有这些人的所有追随者</li>
<li>唯一的追随者</li>
<li>计算唯一的关注者</li>
</ol>

<p>在一次计算中，一次覆盖范围计算可能涉及数千个数据库调用和数千万个跟踪者记录。这是一个非常非常密集的计算。如您所见，在Storm之上实现此功能非常简单。在单台计算机上，覆盖范围可能需要几分钟才能计算出来；在Storm集群上，您甚至可以在几秒钟内计算出最困难的URL的覆盖范围。</p>

<p>在<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/jvm/org/apache/storm/starter/ReachTopology.java">此处的</a> storm-starter中定义了样本范围拓扑。这是定义范围拓扑的方法：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">LinearDRPCTopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinearDRPCTopologyBuilder</span><span class="o">(</span><span class="s">"reach"</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">addBolt</span><span class="o">(</span><span class="k">new</span> <span class="n">GetTweeters</span><span class="o">(),</span> <span class="mi">3</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">addBolt</span><span class="o">(</span><span class="k">new</span> <span class="n">GetFollowers</span><span class="o">(),</span> <span class="mi">12</span><span class="o">)</span>
        <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">();</span>
<span class="n">builder</span><span class="o">.</span><span class="na">addBolt</span><span class="o">(</span><span class="k">new</span> <span class="n">PartialUniquer</span><span class="o">(),</span> <span class="mi">6</span><span class="o">)</span>
        <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="s">"follower"</span><span class="o">));</span>
<span class="n">builder</span><span class="o">.</span><span class="na">addBolt</span><span class="o">(</span><span class="k">new</span> <span class="n">CountAggregator</span><span class="o">(),</span> <span class="mi">2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"id"</span><span class="o">));</span>
</code></pre></div>
<p>拓扑执行四个步骤：</p>

<ol>
<li><code>GetTweeters</code>获取推文网址的用户。它转换一个输入流<code>[id, url]</code>进入<code>[id, tweeter]</code> 。每<code>url</code>元组将映射到许多<code>tweeter</code>元组。</li>
<li><code>GetFollowers</code>获得高音扬声器的关注者。它转换一个输入流<code>[id, tweeter]</code>进入<code>[id, follower]</code> 。在所有任务中，当有人关注发推同一个URL的多个人时，跟随者元组当然可能会重复。</li>
<li><code>PartialUniquer</code>按照关注者ID对关注者流进行分组。这具有相同的关注者执行相同任务的效果。所以每个任务<code>PartialUniquer</code>将获得相互独立的关注者集。一旦<code>PartialUniquer</code>接收针对它的所有请求ID的关注者元组，它发出其关注者子集的唯一计数。</li>
<li>最后， <code>CountAggregator</code>从每个接收部分计数<code>PartialUniquer</code>任务并对其进行汇总以完成覆盖率计算。</li>
</ol>

<p>让我们来看看<code>PartialUniquer</code>螺栓：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PartialUniquer</span> <span class="kd">extends</span> <span class="n">BaseBatchBolt</span> <span class="o">{</span>
    <span class="n">BatchOutputCollector</span> <span class="n">_collector</span><span class="o">;</span>
    <span class="n">Object</span> <span class="n">_id</span><span class="o">;</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">_followers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">BatchOutputCollector</span> <span class="n">collector</span><span class="o">,</span> <span class="n">Object</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
        <span class="n">_id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_followers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">finishBatch</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">_collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">_id</span><span class="o">,</span> <span class="n">_followers</span><span class="o">.</span><span class="na">size</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">declareOutputFields</span><span class="o">(</span><span class="n">OutputFieldsDeclarer</span> <span class="n">declarer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">declarer</span><span class="o">.</span><span class="na">declare</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="s">"partial-count"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>PartialUniquer</code>贯彻<code>IBatchBolt</code>通过扩展<code>BaseBatchBolt</code> 。批处理螺栓提供了一流的API，可将一批元组作为一个具体单元进行处理。将为每个请求ID创建一个新的批处理螺栓实例，Storm会在适当时负责清理实例。</p>

<p>什么时候<code>PartialUniquer</code>在中收到一个追随者元组<code>execute</code>方法，它将其添加到内部内部请求ID的集合中<code>HashSet</code> 。</p>

<p>批量螺栓提供<code>finishBatch</code>在处理了针对此任务的该批处理的所有元组之后调用的方法。在回调中， <code>PartialUniquer</code>发出一个元组，其中包含其跟随者ID子集的唯一计数。</p>

<p>在引擎盖下<code>CoordinatedBolt</code>用于检测给定螺栓何时已收到任何给定请求ID的所有元组。 <code>CoordinatedBolt</code>利用直接流来管理这种协调。</p>

<p>拓扑的其余部分应该是不言自明的。如您所见，范围计算的每个步骤都是并行完成的，并且定义DRPC拓扑非常简单。</p>

<h3 id="non-linear-drpc-topologies">非线性DRPC拓扑</h3>

<p><code>LinearDRPCTopologyBuilder</code>仅处理“线性” DRPC拓扑，其中计算表示为一系列步骤（如到达）。不难想象功能需要通过螺栓的分支和合并来实现更复杂的拓扑。现在，要做到这一点，您需要深入到使用<code>CoordinatedBolt</code>直。一定要在邮件列表上谈论您的非线性DRPC拓扑用例，以告知DRPC拓扑更一般的抽象构造。</p>

<h3 id="how-lineardrpctopologybuilder-works">LinearDRPCTopologyBuilder的工作方式</h3>

<ul>
<li>DRPCSpout发出[args，return-info]。 return-info是DRPC服务器的主机和端口，以及DRPC服务器生成的ID</li>
<li>构造包含以下内容的拓扑：<ul>
<li>DRPC喷口</li>
<li>PrepareRequest（生成请求ID并为返回信息创建流，为args创建流）</li>
<li>协调螺栓包装器和直接分组</li>
<li>JoinResult（将结果与返回信息结合在一起）</li>
<li>ReturnResult（连接到DRPC服务器并返回结果）</li>
</ul></li>
<li>LinearDRPCTopologyBuilder是在Storm原语之上构建的更高级别抽象的一个很好的示例</li>
</ul>

<h3 id="advanced">高级</h3>

<ul>
<li>KeyedFairBolt，用于同时编织处理多个请求</li>
<li>如何使用<code>CoordinatedBolt</code>直</li>
</ul>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>