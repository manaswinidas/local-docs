<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>Clojure DSL</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=1">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">Clojure DSL</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>Storm通过storm-clojure软件包提供了Clojure DSL，用于定义喷口，螺栓和拓扑。Clojure DSL可以访问Java API公开的所有内容，因此，如果您是Clojure用户，则可以编写Storm拓扑，而无需接触Java。Clojure DSL在<a href="http://github.com/apache/storm/blob/v2.1.0/storm-clojure/src/clj/org/apache/storm/clojure.clj">org.apache.storm.clojure</a>命名空间的源代码中定义。</p>

<p>此页面概述了Clojure DSL的所有部分，包括：</p>

<ol>
<li>定义拓扑</li>
<li><code>defbolt</code></li>
<li><code>defspout</code></li>
<li>在本地模式或群集上运行拓扑</li>
<li>测试拓扑</li>
</ol>

<h3 id="defining-topologies">定义拓扑</h3>

<p>要定义拓扑，请使用<code>topology</code>功能。 <code>topology</code>接受两个参数：“喷口规格”图和“螺栓规格”图。每个管嘴和螺栓规格都通过指定诸如输入和并行性之类的东西将组件的代码连接到拓扑中。</p>

<p>让我们看一下<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/clj/org/apache/storm/starter/clj/word_count.clj">来自Storm-starter项目</a>的示例拓扑定义：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">topology</span><span class="w">
 </span><span class="p">{</span><span class="s">"1"</span><span class="w"> </span><span class="p">(</span><span class="nf">spout-spec</span><span class="w"> </span><span class="n">sentence-spout</span><span class="p">)</span><span class="w">
  </span><span class="s">"2"</span><span class="w"> </span><span class="p">(</span><span class="nf">spout-spec</span><span class="w"> </span><span class="p">(</span><span class="nf">sentence-spout-parameterized</span><span class="w">
                   </span><span class="p">[</span><span class="s">"the cat jumped over the door"</span><span class="w">
                    </span><span class="s">"greetings from a faraway land"</span><span class="p">])</span><span class="w">
                   </span><span class="no">:p</span><span class="w"> </span><span class="mi">2</span><span class="p">)}</span><span class="w">
 </span><span class="p">{</span><span class="s">"3"</span><span class="w"> </span><span class="p">(</span><span class="nf">bolt-spec</span><span class="w"> </span><span class="p">{</span><span class="s">"1"</span><span class="w"> </span><span class="no">:shuffle</span><span class="w"> </span><span class="s">"2"</span><span class="w"> </span><span class="no">:shuffle</span><span class="p">}</span><span class="w">
                 </span><span class="n">split-sentence</span><span class="w">
                 </span><span class="no">:p</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
  </span><span class="s">"4"</span><span class="w"> </span><span class="p">(</span><span class="nf">bolt-spec</span><span class="w"> </span><span class="p">{</span><span class="s">"3"</span><span class="w"> </span><span class="p">[</span><span class="s">"word"</span><span class="p">]}</span><span class="w">
                 </span><span class="n">word-count</span><span class="w">
                 </span><span class="no">:p</span><span class="w"> </span><span class="mi">6</span><span class="p">)})</span><span class="w">
</span></code></pre></div>
<p>喷口和螺栓规格的映射是从组件ID到相应规格的映射。组件ID在整个地图上必须唯一。就像在Java中定义拓扑一样，在声明拓扑中螺栓的输入时也会使用组件ID。</p>

<h4 id="spout-spec">喷口规格</h4>

<p><code>spout-spec</code>将<a href="javadocs/org/apache/storm/topology/IRichSpout.html">spout</a>实现（一个实现<a href="javadocs/org/apache/storm/topology/IRichSpout.html">IRichSpout</a>的对象）和可选的关键字参数作为参数。当前存在的唯一选项是<code>:p</code>选项，用于指定喷嘴的并行性。如果你省略<code>:p</code> ，喷口将作为单个任务执行。</p>

<h4 id="bolt-spec">螺栓规格</h4>

<p><code>bolt-spec</code>将螺栓的输入声明，螺栓实现（一个实现<a href="javadocs/org/apache/storm/topology/IRichBolt.html">IRichBolt</a>的对象）和可选的关键字参数作为参数。</p>

<p>输入声明是从流ID到流分组的映射。流ID可以采用以下两种形式之一：</p>

<ol>
<li><code>[==component id== ==stream id==]</code> ：订阅组件上的特定流</li>
<li><code>==component id==</code> ：订阅组件上的默认流</li>
</ol>

<p>流分组可以是以下之一：</p>

<ol>
<li><code>:shuffle</code> ：以随机分组订阅</li>
<li>字段名称的向量，例如<code>["id" "name"]</code> ：订阅在指定字段上分组的字段</li>
<li><code>:global</code> ：订阅全球分组</li>
<li><code>:all</code> ：订阅所有分组</li>
<li><code>:direct</code> ：订阅直接分组</li>
</ol>

<p>有关流分组的更多信息，请参见<a href="Concepts.html">概念</a> 。这是一个输入声明示例，展示了声明输入的各种方法：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{[</span><span class="s">"2"</span><span class="w"> </span><span class="s">"1"</span><span class="p">]</span><span class="w"> </span><span class="no">:shuffle</span><span class="w">
 </span><span class="s">"3"</span><span class="w"> </span><span class="p">[</span><span class="s">"field1"</span><span class="w"> </span><span class="s">"field2"</span><span class="p">]</span><span class="w">
 </span><span class="p">[</span><span class="s">"4"</span><span class="w"> </span><span class="s">"2"</span><span class="p">]</span><span class="w"> </span><span class="no">:global</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>此输入声明总共订阅三个流。它使用混洗分组订阅组件“ 2”上的流“ 1”，使用字段“ field1”和“ field2”上的字段分组订阅组件“ 3”的默认流，并订阅上的流“ 2”具有全局分组的组件“ 4”。</p>

<p>喜欢<code>spout-spec</code> ，是当前唯一支持的关键字参数<code>bolt-spec</code>是<code>:p</code>指定螺栓的平行度。</p>

<h4 id="shell-bolt-spec">壳螺栓规格</h4>

<p><code>shell-bolt-spec</code>用于定义以非JVM语言实现的螺栓。它以输入声明，要运行的命令行程序，实现螺栓的文件名，输出规范以及相同的关键字参数作为参数。 <code>bolt-spec</code>接受。</p>

<p>这是一个例子<code>shell-bolt-spec</code> ：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">shell-bolt-spec</span><span class="w"> </span><span class="p">{</span><span class="s">"1"</span><span class="w"> </span><span class="no">:shuffle</span><span class="w"> </span><span class="s">"2"</span><span class="w"> </span><span class="p">[</span><span class="s">"id"</span><span class="p">]}</span><span class="w">
                 </span><span class="s">"python"</span><span class="w">
                 </span><span class="s">"mybolt.py"</span><span class="w">
                 </span><span class="p">[</span><span class="s">"outfield1"</span><span class="w"> </span><span class="s">"outfield2"</span><span class="p">]</span><span class="w">
                 </span><span class="no">:p</span><span class="w"> </span><span class="mi">25</span><span class="p">)</span><span class="w">
</span></code></pre></div>
<p>输出声明的语法在<code>defbolt</code>下面的部分。有关在Storm中多语言的工作方式的更多详细信息，请参见<a href="Using-non-JVM-languages-with-Storm.html">将非JVM语言与Storm一起使用</a> 。</p>

<h3 id="defbolt">拆弹</h3>

<p><code>defbolt</code>用于在Clojure中定义螺栓。螺栓具有必须可序列化的约束，这就是为什么您不能只进行序列化<code>IRichBolt</code>实施螺栓（封闭件不可序列化）。 <code>defbolt</code>可以解决此限制，并且提供比定义Java接口更好的语法来定义螺栓。</p>

<p>以最充分的表现力， <code>defbolt</code>支持参数化的螺栓并在螺栓实施周围的闭合处保持状态。它还提供了用于定义不需要此额外功能的螺栓的快捷方式。的签名<code>defbolt</code>看起来如下：</p>

<p>（defbolt <em>名称</em> <em>输出声明</em> * <em>option-map</em> ＆ <em>impl</em> ）</p>

<p>省略选项图等效于具有<code>{:prepare false}</code> 。</p>

<h4 id="simple-bolts">简单的螺栓</h4>

<p>让我们从最简单的形式开始<code>defbolt</code> 。这是一个示例螺栓，用于将包含句子的元组拆分为每个单词的元组：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defbolt</span><span class="w"> </span><span class="n">split-sentence</span><span class="w"> </span><span class="p">[</span><span class="s">"word"</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">tuple</span><span class="w"> </span><span class="n">collector</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">words</span><span class="w"> </span><span class="p">(</span><span class="nf">.split</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="s">" "</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">w</span><span class="w"> </span><span class="n">words</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">emit-bolt!</span><span class="w"> </span><span class="n">collector</span><span class="w"> </span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="no">:anchor</span><span class="w"> </span><span class="n">tuple</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">ack!</span><span class="w"> </span><span class="n">collector</span><span class="w"> </span><span class="n">tuple</span><span class="p">)</span><span class="w">
    </span><span class="p">))</span><span class="w">
</span></code></pre></div>
<p>由于省略了选件图，因此这是未准备的螺栓。DSL只是期望实现<code>execute</code>的方法<code>IRichBolt</code> 。该实现采用两个参数，元组和<code>OutputCollector</code> ，然后是<code>execute</code>功能。DSL会自动为您键入参数的提示，因此，如果您使用Java互操作，则无需担心反射。</p>

<p>该实现绑定<code>split-sentence</code>到实际<code>IRichBolt</code>您可以在拓扑中使用的对象，如下所示：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">bolt-spec</span><span class="w"> </span><span class="p">{</span><span class="s">"1"</span><span class="w"> </span><span class="no">:shuffle</span><span class="p">}</span><span class="w">
           </span><span class="n">split-sentence</span><span class="w">
           </span><span class="no">:p</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span></code></pre></div>
<h4 id="parameterized-bolts">参数化螺栓</h4>

<p>很多时候，您想使用其他参数来参数化螺栓。例如，假设您想要一个螺栓，在其接收的每个输入字符串后附加一个后缀，并且希望在运行时设置该后缀。你这样做<code>defbolt</code>通过包含一个<code>:params</code>选项图中的选项，如下所示：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defbolt</span><span class="w"> </span><span class="n">suffix-appender</span><span class="w"> </span><span class="p">[</span><span class="s">"word"</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">[</span><span class="n">suffix</span><span class="p">]}</span><span class="w">
  </span><span class="p">[</span><span class="n">tuple</span><span class="w"> </span><span class="n">collector</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">emit-bolt!</span><span class="w"> </span><span class="n">collector</span><span class="w"> </span><span class="p">[(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">suffix</span><span class="p">)]</span><span class="w"> </span><span class="no">:anchor</span><span class="w"> </span><span class="n">tuple</span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span></code></pre></div>
<p>与前面的示例不同， <code>suffix-appender</code>将绑定到一个返回<code>IRichBolt</code>而不是成为<code>IRichBolt</code>直接反对。这是由于指定<code>:params</code>在其选项图中。所以用<code>suffix-appender</code>在拓扑中，您将执行以下操作：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">bolt-spec</span><span class="w"> </span><span class="p">{</span><span class="s">"1"</span><span class="w"> </span><span class="no">:shuffle</span><span class="p">}</span><span class="w">
           </span><span class="p">(</span><span class="nf">suffix-appender</span><span class="w"> </span><span class="s">"-suffix"</span><span class="p">)</span><span class="w">
           </span><span class="no">:p</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span></code></pre></div>
<h4 id="prepared-bolts">准备好的螺栓</h4>

<p>为了执行更复杂的螺栓，例如进行联接和流式聚合的螺栓，螺栓需要存储状态。您可以通过创建一个准备好的螺栓来做到这一点，该螺栓由<code>{:prepare true}</code>在选项图中。例如，考虑使用实现字数统计的螺栓：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defbolt</span><span class="w"> </span><span class="n">word-count</span><span class="w"> </span><span class="p">[</span><span class="s">"word"</span><span class="w"> </span><span class="s">"count"</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:prepare</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w">
  </span><span class="p">[</span><span class="n">conf</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">collector</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">counts</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{})]</span><span class="w">
    </span><span class="p">(</span><span class="nf">bolt</span><span class="w">
     </span><span class="p">(</span><span class="nf">execute</span><span class="w"> </span><span class="p">[</span><span class="n">tuple</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">word</span><span class="w"> </span><span class="p">(</span><span class="nf">.getString</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="mi">0</span><span class="p">)]</span><span class="w">
         </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">counts</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">merge-with</span><span class="w"> </span><span class="nb">+</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">word</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
         </span><span class="p">(</span><span class="nf">emit-bolt!</span><span class="w"> </span><span class="n">collector</span><span class="w"> </span><span class="p">[</span><span class="n">word</span><span class="w"> </span><span class="p">(</span><span class="o">@</span><span class="n">counts</span><span class="w"> </span><span class="n">word</span><span class="p">)]</span><span class="w"> </span><span class="no">:anchor</span><span class="w"> </span><span class="n">tuple</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">ack!</span><span class="w"> </span><span class="n">collector</span><span class="w"> </span><span class="n">tuple</span><span class="p">)</span><span class="w">
         </span><span class="p">)))))</span><span class="w">
</span></code></pre></div>
<p>准备好的螺栓的实现是将拓扑配置作为输入的功能， <code>TopologyContext</code>和<code>OutputCollector</code> ，并返回的实现<code>IBolt</code>接口。这种设计使您可以封闭实施<code>execute</code>和<code>cleanup</code> 。</p>

<p>在此示例中，字数存储在名为的映射的闭包中<code>counts</code> 。的<code>bolt</code>宏用于创建<code>IBolt</code>实施。的<code>bolt</code>宏是一种比实现接口更简洁的方法，它可以自动键入所有方法的参数提示。该螺栓实现了execute方法，该方法更新映射中的计数并发出新的单词计数。</p>

<p>请注意<code>execute</code>准备螺栓的方法仅将元组作为输入，因为<code>OutputCollector</code>已关闭该功能（对于简单的螺栓，收集器是第二个参数<code>execute</code>功能）。</p>

<p>可以像简单螺栓一样对准备好的螺栓进行参数化。</p>

<h4 id="output-declarations">输出声明</h4>

<p>Clojure DSL具有用于声明螺栓输出的简洁语法。声明输出的最通用方法是将流id作为流规范的映射。例如：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="s">"1"</span><span class="w"> </span><span class="p">[</span><span class="s">"field1"</span><span class="w"> </span><span class="s">"field2"</span><span class="p">]</span><span class="w">
 </span><span class="s">"2"</span><span class="w"> </span><span class="p">(</span><span class="nf">direct-stream</span><span class="w"> </span><span class="p">[</span><span class="s">"f1"</span><span class="w"> </span><span class="s">"f2"</span><span class="w"> </span><span class="s">"f3"</span><span class="p">])</span><span class="w">
 </span><span class="s">"3"</span><span class="w"> </span><span class="p">[</span><span class="s">"f1"</span><span class="p">]}</span><span class="w">
</span></code></pre></div>
<p>流id是一个字符串，而流规范是字段的向量或由以下命令包装的字段的向量<code>direct-stream</code> 。 <code>direct stream</code>将流标记为直接流（有关直接流的更多详细信息，请参见<a href="Concepts.html">概念</a>和<a href="">直接分组</a> ）。</p>

<p>如果螺栓只有一个输出流，则可以通过使用向量而不是输出声明的映射来定义螺栓的默认流。例如：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[</span><span class="s">"word"</span><span class="w"> </span><span class="s">"count"</span><span class="p">]</span><span class="w">
</span></code></pre></div>
<p>这会将螺栓的输出声明为默认流ID上的字段[“ word”“ count”]。</p>

<h4 id="emitting-acking-and-failing">发射，确认和失败</h4>

<p>而不是使用Java方法<code>OutputCollector</code> DSL直接提供了一组更好的功能供您使用<code>OutputCollector</code> ： <code>emit-bolt!</code> ， <code>emit-direct-bolt!</code> ， <code>ack!</code>和<code>fail!</code> 。</p>

<ol>
<li><code>emit-bolt!</code> ：以参数<code>OutputCollector</code> ，要发出的值（Clojure序列）和关键字参数<code>:anchor</code>和<code>:stream</code> 。 <code>:anchor</code>可以是单个元组或元组列表，并且<code>:stream</code>是要发送到的流的ID。省略关键字参数会向默认流发出未锚定的元组。</li>
<li><code>emit-direct-bolt!</code> ：以参数<code>OutputCollector</code> ，将元组发送到的任务ID，要发出的值以及用于的关键字参数<code>:anchor</code>和<code>:stream</code> 。此函数只能向声明为直接流的流发出。</li>
<li><code>ack!</code> ：以参数<code>OutputCollector</code>和要确认的元组。</li>
<li><code>fail!</code> ：以参数<code>OutputCollector</code>和元组失败。</li>
</ol>

<p>有关确认和锚定的更多信息，请参阅<a href="Guaranteeing-message-processing.html">保证消息处理</a> 。</p>

<h3 id="defspout">defspout</h3>

<p><code>defspout</code>用于在Clojure中定义喷口。像螺栓一样，喷口必须可序列化，因此您不能仅仅进行序列化<code>IRichSpout</code>在Clojure中执行spout实现。 <code>defspout</code>可以解决此限制，并且提供了用于定义喷口的更好语法，而不仅仅是实现Java接口。</p>

<p>的签名<code>defspout</code>看起来如下：</p>

<p>（defspout <em>名称</em> <em>输出声明</em> * <em>option-map</em> ＆ <em>impl</em> ）</p>

<p>如果省略选项映射，则默认为{：prepare true}。的输出声明<code>defspout</code>具有与以下相同的语法<code>defbolt</code> 。</p>

<p>这是一个例子<code>defspout</code>从<a href="http://github.com/apache/storm/blob/v2.1.0/examples/storm-starter/src/clj/org/apache/storm/starter/clj/word_count.clj">storm-starter</a>实施：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defspout</span><span class="w"> </span><span class="n">sentence-spout</span><span class="w"> </span><span class="p">[</span><span class="s">"sentence"</span><span class="p">]</span><span class="w">
  </span><span class="p">[</span><span class="n">conf</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="n">collector</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">sentences</span><span class="w"> </span><span class="p">[</span><span class="s">"a little brown dog"</span><span class="w">
                   </span><span class="s">"the man petted the dog"</span><span class="w">
                   </span><span class="s">"four score and seven years ago"</span><span class="w">
                   </span><span class="s">"an apple a day keeps the doctor away"</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nf">spout</span><span class="w">
     </span><span class="p">(</span><span class="nf">nextTuple</span><span class="w"> </span><span class="p">[]</span><span class="w">
       </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">emit-spout!</span><span class="w"> </span><span class="n">collector</span><span class="w"> </span><span class="p">[(</span><span class="nf">rand-nth</span><span class="w"> </span><span class="n">sentences</span><span class="p">)])</span><span class="w">         
       </span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">ack</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w">
        </span><span class="c1">;; You only need to define this method for reliable spouts</span><span class="w">
        </span><span class="c1">;; (such as one that reads off of a queue like Kestrel)</span><span class="w">
        </span><span class="c1">;; This is an unreliable spout, so it does nothing here</span><span class="w">
        </span><span class="p">))))</span><span class="w">
</span></code></pre></div>
<p>该实现将拓扑配置作为输入， <code>TopologyContext</code>和<code>SpoutOutputCollector</code> 。实现返回一个<code>ISpout</code>宾语。在这里<code>nextTuple</code>函数从发出一个随机句子<code>sentences</code> 。</p>

<p>该喷嘴不可靠，因此<code>ack</code>和<code>fail</code>方法将永远不会被调用。可靠的喷嘴会在发出元组时添加一条消息ID，然后<code>ack</code>要么<code>fail</code>元组分别完成或失败时将被调用。有关在Storm中可靠性如何工作的更多信息，请参阅<a href="Guaranteeing-message-processing.html">保证消息处理</a> 。</p>

<p><code>emit-spout!</code>接受参数<code>SpoutOutputCollector</code>和要发出的新元组，并接受作为关键字参数<code>:stream</code>和<code>:id</code> 。 <code>:stream</code>指定要发送到的流，并且<code>:id</code>指定元组的消息ID（用于<code>ack</code>和<code>fail</code>回调）。忽略这些参数将向默认输出流发射一个未锚定的元组。</p>

<p>还有一个<code>emit-direct-spout!</code>该函数将元组发送到直接流，并接受一个附加参数作为任务ID的第二个参数以将元组发送到。</p>

<p>喷口可以像螺栓一样进行参数化，在这种情况下，符号绑定到返回的函数<code>IRichSpout</code>而不是<code>IRichSpout</code>本身。您还可以声明一个未准备好的喷口，该喷口仅定义了<code>nextTuple</code>方法。这是一个未准备好的喷嘴的示例，该喷嘴在运行时发出参数化的随机语句：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defspout</span><span class="w"> </span><span class="n">sentence-spout-parameterized</span><span class="w"> </span><span class="p">[</span><span class="s">"word"</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:params</span><span class="w"> </span><span class="p">[</span><span class="n">sentences</span><span class="p">]</span><span class="w"> </span><span class="no">:prepare</span><span class="w"> </span><span class="n">false</span><span class="p">}</span><span class="w">
  </span><span class="p">[</span><span class="n">collector</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">500</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">emit-spout!</span><span class="w"> </span><span class="n">collector</span><span class="w"> </span><span class="p">[(</span><span class="nf">rand-nth</span><span class="w"> </span><span class="n">sentences</span><span class="p">)]))</span><span class="w">
</span></code></pre></div>
<p>以下示例说明了如何在<code>spout-spec</code> ：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">spout-spec</span><span class="w"> </span><span class="p">(</span><span class="nf">sentence-spout-parameterized</span><span class="w">
                   </span><span class="p">[</span><span class="s">"the cat jumped over the door"</span><span class="w">
                    </span><span class="s">"greetings from a faraway land"</span><span class="p">])</span><span class="w">
            </span><span class="no">:p</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre></div>
<h3 id="running-topologies-in-local-mode-or-on-a-cluster">在本地模式或群集上运行拓扑</h3>

<p>这就是Clojure DSL的全部内容。要以远程模式或本地模式提交拓扑，只需使用<code>StormSubmitter</code>就像您从Java中学习类一样。</p>

<p>要创建拓扑配置，最简单的方法是使用<code>org.apache.storm.config</code>定义所有可能配置常量的名称空间。这些常数与<code>Config</code>类，除了破折号而不是下划线。例如，这是一个拓扑配置，该配置将工作程序数设置为15，并以调试模式配置拓扑：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="n">TOPOLOGY-DEBUG</span><span class="w"> </span><span class="n">true</span><span class="w">
 </span><span class="n">TOPOLOGY-WORKERS</span><span class="w"> </span><span class="mi">15</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<h3 id="testing-topologies">测试拓扑</h3>

<p><a href="http://www.pixelmachine.org/2011/12/17/Testing-Storm-Topologies.html">该博客文章</a>及其<a href="http://www.pixelmachine.org/2011/12/21/Testing-Storm-Topologies-Part-2.html">后续</a> <a href="http://www.pixelmachine.org/2011/12/17/Testing-Storm-Topologies.html">文章</a>很好地概述了Storm强大的内置工具，用于测试Clojure中的拓扑。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>