<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>Core Storm中的窗口支持</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=1">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">Core Storm中的窗口支持</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>Storm core支持处理窗口内的一组元组。Windows使用以下两个参数指定：</p>

<ol>
<li>窗口长度-窗口的长度或持续时间</li>
<li>滑动间隔-窗口滑动的间隔</li>
</ol>

<h2 id="sliding-window">滑动窗口</h2>

<p>元组在窗口和窗口幻灯片中按每个滑动间隔分组。一个元组可以属于多个窗口。</p>

<p>例如，基于时间的滑动窗口的长度为10秒，滑动间隔为5秒。</p>
<div class="highlight"><pre><code class="language-" data-lang="">........| e1 e2 | e3 e4 e5 e6 | e7 e8 e9 |...
-5      0       5            10          15   -&gt; time
|&lt;------- w1 --&gt;|
        |&lt;---------- w2 -----&gt;|
                |&lt;-------------- w3 ----&gt;|
</code></pre></div>
<p>该窗口每5秒评估一次，第一个窗口中的一些元组与第二个窗口重叠。</p>

<p>注意：窗口首先在t = 5秒处滑动，并且将包含直到前5秒为止接收到的事件。</p>

<h2 id="tumbling-window">翻滚窗口</h2>

<p>元组基于时间或计数分组在单个窗口中。任何元组仅属于其中一个窗口。</p>

<p>例如，基于时间的翻滚窗口的长度为5秒。</p>
<div class="highlight"><pre><code class="language-" data-lang="">| e1 e2 | e3 e4 e5 e6 | e7 e8 e9 |...
0       5             10         15    -&gt; time
   w1         w2            w3
</code></pre></div>
<p>该窗口每五秒钟评估一次，并且没有一个窗口重叠。</p>

<p>Storm支持将窗口长度和滑动间隔指定为元组数的计数或持续时间。</p>

<p>螺栓接口<code>IWindowedBolt</code>由需要开窗支持的螺栓实现。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IWindowedBolt</span> <span class="kd">extends</span> <span class="n">IComponent</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">stormConf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">);</span>
    <span class="cm">/**
     * Process tuples falling within the window and optionally emit 
     * new tuples based on the tuples in the input window.
     */</span>
    <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TupleWindow</span> <span class="n">inputWindow</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">cleanup</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>每次激活窗口时， <code>execute</code>方法被调用。TupleWindow参数可访问窗口中的当前元组，过期的元组和自上次窗口计算以来添加的新元组，这将对有效的窗口计算有用。</p>

<p>需要开窗支持的螺栓通常会延伸<code>BaseWindowedBolt</code>它具有用于指定窗口长度和滑动间隔的API。</p>

<p>例如</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SlidingWindowBolt</span> <span class="kd">extends</span> <span class="n">BaseWindowedBolt</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">stormConf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TupleWindow</span> <span class="n">inputWindow</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span><span class="o">(</span><span class="n">Tuple</span> <span class="nl">tuple:</span> <span class="n">inputWindow</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// do the windowing computation</span>
        <span class="o">...</span>
      <span class="o">}</span>
      <span class="c1">// emit the results</span>
      <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">computedValue</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TopologyBuilder</span><span class="o">();</span>
     <span class="n">builder</span><span class="o">.</span><span class="na">setSpout</span><span class="o">(</span><span class="s">"spout"</span><span class="o">,</span> <span class="k">new</span> <span class="n">RandomSentenceSpout</span><span class="o">(),</span> <span class="mi">1</span><span class="o">);</span>
     <span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"slidingwindowbolt"</span><span class="o">,</span> 
                     <span class="k">new</span> <span class="nf">SlidingWindowBolt</span><span class="o">().</span><span class="na">withWindow</span><span class="o">(</span><span class="k">new</span> <span class="n">Count</span><span class="o">(</span><span class="mi">30</span><span class="o">),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(</span><span class="mi">10</span><span class="o">)),</span>
                     <span class="mi">1</span><span class="o">).</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"spout"</span><span class="o">);</span>
    <span class="n">Config</span> <span class="n">conf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Config</span><span class="o">();</span>
    <span class="n">conf</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="n">conf</span><span class="o">.</span><span class="na">setNumWorkers</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

    <span class="n">StormSubmitter</span><span class="o">.</span><span class="na">submitTopologyWithProgressBar</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">conf</span><span class="o">,</span> <span class="n">builder</span><span class="o">.</span><span class="na">createTopology</span><span class="o">());</span>

<span class="o">}</span>
</code></pre></div>
<p>支持以下窗口配置。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">withWindow</span><span class="o">(</span><span class="n">Count</span> <span class="n">windowLength</span><span class="o">,</span> <span class="n">Count</span> <span class="n">slidingInterval</span><span class="o">)</span>
<span class="n">Tuple</span> <span class="n">count</span> <span class="n">based</span> <span class="n">sliding</span> <span class="n">window</span> <span class="n">that</span> <span class="n">slides</span> <span class="n">after</span> <span class="err">`</span><span class="n">slidingInterval</span><span class="err">`</span> <span class="n">number</span> <span class="n">of</span> <span class="n">tuples</span><span class="o">.</span>

<span class="nf">withWindow</span><span class="o">(</span><span class="n">Count</span> <span class="n">windowLength</span><span class="o">)</span>
<span class="n">Tuple</span> <span class="n">count</span> <span class="n">based</span> <span class="n">window</span> <span class="n">that</span> <span class="n">slides</span> <span class="n">with</span> <span class="n">every</span> <span class="n">incoming</span> <span class="n">tuple</span><span class="o">.</span>

<span class="nf">withWindow</span><span class="o">(</span><span class="n">Count</span> <span class="n">windowLength</span><span class="o">,</span> <span class="n">Duration</span> <span class="n">slidingInterval</span><span class="o">)</span>
<span class="n">Tuple</span> <span class="n">count</span> <span class="n">based</span> <span class="n">sliding</span> <span class="n">window</span> <span class="n">that</span> <span class="n">slides</span> <span class="n">after</span> <span class="err">`</span><span class="n">slidingInterval</span><span class="err">`</span> <span class="n">time</span> <span class="n">duration</span><span class="o">.</span>

<span class="nf">withWindow</span><span class="o">(</span><span class="n">Duration</span> <span class="n">windowLength</span><span class="o">,</span> <span class="n">Duration</span> <span class="n">slidingInterval</span><span class="o">)</span>
<span class="n">Time</span> <span class="n">duration</span> <span class="n">based</span> <span class="n">sliding</span> <span class="n">window</span> <span class="n">that</span> <span class="n">slides</span> <span class="n">after</span> <span class="err">`</span><span class="n">slidingInterval</span><span class="err">`</span> <span class="n">time</span> <span class="n">duration</span><span class="o">.</span>

<span class="nf">withWindow</span><span class="o">(</span><span class="n">Duration</span> <span class="n">windowLength</span><span class="o">)</span>
<span class="n">Time</span> <span class="n">duration</span> <span class="n">based</span> <span class="n">window</span> <span class="n">that</span> <span class="n">slides</span> <span class="n">with</span> <span class="n">every</span> <span class="n">incoming</span> <span class="n">tuple</span><span class="o">.</span>

<span class="nf">withWindow</span><span class="o">(</span><span class="n">Duration</span> <span class="n">windowLength</span><span class="o">,</span> <span class="n">Count</span> <span class="n">slidingInterval</span><span class="o">)</span>
<span class="n">Time</span> <span class="n">duration</span> <span class="n">based</span> <span class="n">sliding</span> <span class="n">window</span> <span class="n">configuration</span> <span class="n">that</span> <span class="n">slides</span> <span class="n">after</span> <span class="err">`</span><span class="n">slidingInterval</span><span class="err">`</span> <span class="n">number</span> <span class="n">of</span> <span class="n">tuples</span><span class="o">.</span>

<span class="nf">withTumblingWindow</span><span class="o">(</span><span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Count</span> <span class="n">count</span><span class="o">)</span>
<span class="n">Count</span> <span class="n">based</span> <span class="n">tumbling</span> <span class="n">window</span> <span class="n">that</span> <span class="n">tumbles</span> <span class="n">after</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">count</span> <span class="n">of</span> <span class="n">tuples</span><span class="o">.</span>

<span class="nf">withTumblingWindow</span><span class="o">(</span><span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Duration</span> <span class="n">duration</span><span class="o">)</span>
<span class="n">Time</span> <span class="n">duration</span> <span class="n">based</span> <span class="n">tumbling</span> <span class="n">window</span> <span class="n">that</span> <span class="n">tumbles</span> <span class="n">after</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">time</span> <span class="n">duration</span><span class="o">.</span>

</code></pre></div>
<h2 id="tuple-timestamp-and-out-of-order-tuples">元组时间戳和乱序元组</h2>

<p>默认情况下，窗口中跟踪的时间戳是由螺栓处理元组的时间。窗口计算是基于处理时间戳执行的。Storm支持根据源生成的时间戳跟踪窗口。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
* Specify a field in the tuple that represents the timestamp as a long value. If this
* field is not present in the incoming tuple, an {@link IllegalArgumentException} will be thrown.
*
* @param fieldName the name of the field that contains the timestamp
*/</span>
<span class="kd">public</span> <span class="n">BaseWindowedBolt</span> <span class="nf">withTimestampField</span><span class="o">(</span><span class="n">String</span> <span class="n">fieldName</span><span class="o">)</span>
</code></pre></div>
<p>上面的值<code>fieldName</code>将从传入的元组中查找并考虑进行开窗计算。如果该元组中不存在该字段，则将引发异常。或者，可以使用<a href="../storm-client/src/jvm/org/apache/storm/windowing/TimestampExtractor.java">TimestampExtractor</a>从元组导出时间戳值（例如，从元组内的嵌套字段中提取时间戳）。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
* Specify the timestamp extractor implementation.
*
* @param timestampExtractor the {@link TimestampExtractor} implementation
*/</span>
<span class="kd">public</span> <span class="n">BaseWindowedBolt</span> <span class="nf">withTimestampExtractor</span><span class="o">(</span><span class="n">TimestampExtractor</span> <span class="n">timestampExtractor</span><span class="o">)</span>
</code></pre></div>
<p>连同时间戳字段名称/提取器一起，还可以指定一个时滞参数，该参数指示时间戳不正确的元组的最大时间限制。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
* Specify the maximum time lag of the tuple timestamp in milliseconds. It means that the tuple timestamps
* cannot be out of order by more than this amount.
*
* @param duration the max lag duration
*/</span>
<span class="kd">public</span> <span class="n">BaseWindowedBolt</span> <span class="nf">withLag</span><span class="o">(</span><span class="n">Duration</span> <span class="n">duration</span><span class="o">)</span>
</code></pre></div>
<p>例如，如果滞后是5秒和一个元组<code>t1</code>带有时间戳<code>06:00:05</code>元组时间戳不能早于元组到达<code>06:00:00</code> 。如果元组在以下时间05:59:59到达时间戳<code>t1</code>窗户已经过去了<code>t1</code> ，它将被视为晚期元组。默认情况下，不处理后期元组，仅以INFO级别登录工作日志。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
 * Specify a stream id on which late tuples are going to be emitted. They are going to be accessible via the
 * {@link org.apache.storm.topology.WindowedBoltExecutor#LATE_TUPLE_FIELD} field.
 * It must be defined on a per-component basis, and in conjunction with the
 * {@link BaseWindowedBolt#withTimestampField}, otherwise {@link IllegalArgumentException} will be thrown.
 *
 * @param streamId the name of the stream used to emit late tuples on
 */</span>
<span class="kd">public</span> <span class="n">BaseWindowedBolt</span> <span class="nf">withLateTupleStream</span><span class="o">(</span><span class="n">String</span> <span class="n">streamId</span><span class="o">)</span>

</code></pre></div>
<p>通过指定上述行为可以更改此行为<code>streamId</code> 。在这种情况下，后期元组将在指定的流上发出并可以通过字段访问<code>WindowedBoltExecutor.LATE_TUPLE_FIELD</code> 。</p>

<h3 id="watermarks">水印</h3>

<p>为了处理带有时间戳字段的元组，Storm在内部根据传入的元组时间戳计算水印。水印是所有输入流中最新元组时间戳（减去滞后）的最小值。在更高层次上，这类似于Flink和Google的MillWheel用于跟踪基于事件的时间戳的水印概念。</p>

<p>定期（每秒钟默认）发出水印时间戳，如果使用基于元组的时间戳，则将其视为窗口计算的时钟滴答。可以使用以下api更改发出水印的时间间隔。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
* Specify the watermark event generation interval. For tuple based timestamps, watermark events
* are used to track the progress of time
*
* @param interval the interval at which watermark events are generated
*/</span>
<span class="kd">public</span> <span class="n">BaseWindowedBolt</span> <span class="nf">withWatermarkInterval</span><span class="o">(</span><span class="n">Duration</span> <span class="n">interval</span><span class="o">)</span>
</code></pre></div>
<p>收到水印后，将评估该时间戳之前的所有窗口。</p>

<p>例如，考虑具有以下窗口参数的基于元组时间戳的处理，</p>

<p><code>Window length = 20s, sliding interval = 10s, watermark emit frequency = 1s, max lag = 5s</code></p>
<div class="highlight"><pre><code class="language-" data-lang="">|-----|-----|-----|-----|-----|-----|-----|
0     10    20    30    40    50    60    70
</code></pre></div>
<p>当前ts =<code>09:00:00</code></p>

<p>元组<code>e1(6:00:03), e2(6:00:05), e3(6:00:07), e4(6:00:18), e5(6:00:26), e6(6:00:36)</code>收到之间<code>9:00:00</code>和<code>9:00:01</code></p>

<p>在时间t = <code>09:00:01</code> ，水印w1 = <code>6:00:31</code>因为没有元组早于<code>6:00:31</code>可以到达。</p>

<p>将评估三个窗口。通过获取最早的事件时间戳（06:00:03）并基于滑动间隔（10s）计算上限，可以计算出第一窗口结束点ts（06:00:10）。</p>

<ol>
<li><code>5:59:50 - 06:00:10</code>与元组e1，e2，e3</li>
<li><code>6:00:00 - 06:00:20</code>与元组e1，e2，e3，e4</li>
<li><code>6:00:10 - 06:00:30</code>与元组e4，e5</li>
</ol>

<p>自水印时间戳记以来未评估e6 <code>6:00:31</code>比元组还老<code>6:00:36</code> 。</p>

<p>元组<code>e7(8:00:25), e8(8:00:26), e9(8:00:27), e10(8:00:39)</code>收到之间<code>9:00:01</code>和<code>9:00:02</code></p>

<p>在时间t = <code>09:00:02</code>另一个水印w2 = <code>08:00:34</code>因为没有元组早于<code>8:00:34</code>现在可以到达。</p>

<p>将评估三个窗口，</p>

<ol>
<li><code>6:00:20 - 06:00:40</code>与元组e5，e6（来自较早的批处理）</li>
<li><code>6:00:30 - 06:00:50</code>与元组e6（来自较早的批处理）</li>
<li><code>8:00:10 - 08:00:30</code>与元组e7，e8，e9</li>
</ol>

<p>自元组ts以来，不评估e10 <code>8:00:39</code>超出水印时间<code>8:00:34</code> 。</p>

<p>窗口计算考虑时间间隔，并根据元组时间戳计算窗口。</p>

<h2 id="guarantees">保证金</h2>

<p>当前，Storm Core中的窗口功能至少提供一次保证。螺栓发出的值<code>execute(TupleWindow inputWindow)</code>方法会自动锚定到inputWindow中的所有元组。预期下游螺栓将确认接收到的元组（即，从开窗螺栓发射的元组）以完成元组树。否则，将重播元组，并重新评估窗口计算。</p>

<p>窗口中的元组在过期时即被自动确认，即当它们从窗口中掉出时<code>windowLength + slidingInterval</code> 。注意配置<code>topology.message.timeout.secs</code>应该足够<code>windowLength + slidingInterval</code>用于基于时间的窗口；否则，元组将超时并被重播，并可能导致重复的评估。对于基于计数的窗口，应将配置调整为<code>windowLength + slidingInterval</code>在超时时间内可以接收到元组。</p>

<h2 id="example-topology">拓扑示例</h2>

<p>拓扑示例<code>SlidingWindowTopology</code>展示了如何使用API计算滑动窗口总和和滚动窗口平均值。</p>

<h2 id="stateful-windowing">有状态的窗口</h2>

<p>Storm中的默认窗口实现将元组存储在内存中，直到它们被处理并从窗口中过期为止。这将用例限制在完全适合内存的窗口中。同样，直到窗口到期需要大消息超时（topology.message.timeout.secs应该大于窗口长度+滑动间隔）之后，才能确认源元组。由于复杂的压紧和锚固要求，这还会带来额外的负载。</p>

<p>为了解决上述限制并支持更大的窗口大小，storm通过以下方式提供了有状态的窗口支持： <code>IStatefulWindowedBolt</code> 。用户螺栓通常应伸出<code>BaseStatefulWindowedBolt</code>窗口操作，框架自动管理后台窗口的状态。</p>

<p>如果源提供单调递增的标识符作为消息的一部分，则框架可以使用该标识符定期检查点最后过期和评估的消息id，以避免在失败或重新启动时重复进行窗口评估。在恢复期间，消息ID低于最后过期ID的元组将被丢弃，消息ID在最后过期和最后评估的消息ID之间的元组将被馈送到系统中，而不会激活任何先前激活的窗口。照常处理最后评估的消息ID之后的元组。可以通过设置<code>messageIdField</code>如下所示，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">topologyBuilder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"mybolt"</span><span class="o">,</span>
                   <span class="k">new</span> <span class="nf">MyStatefulWindowedBolt</span><span class="o">()</span>
                   <span class="o">.</span><span class="na">withWindow</span><span class="o">(...)</span> <span class="c1">// windowing configuarations</span>
                   <span class="o">.</span><span class="na">withMessageIdField</span><span class="o">(</span><span class="s">"msgid"</span><span class="o">),</span> <span class="c1">// a monotonically increasing 'long' field in the tuple</span>
                   <span class="n">parallelism</span><span class="o">)</span>
               <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"spout"</span><span class="o">);</span>
</code></pre></div>
<p>但是，只有当源可以在元组中提供单调增加的标识符并且在失败的情况下重新发送消息时，在保留该标识符的同时，此选项才可行。使用此选项，元组仍将缓冲在内存中，直到从窗口处理并过期为止。</p>

<p>有关更多详细信息，请查看风暴启动程序<a href="../examples/storm-starter/src/jvm/org/apache/storm/starter/StatefulWindowingTopology.java">StatefulWindowingTopology</a>中的示例拓扑，它将帮助您入门。</p>

<h3 id="window-checkpointing">窗口检查点</h3>

<p>使用窗口检查点时，不再需要单调递增的id，因为框架透明地将窗口的状态定期保存到配置的状态后端中。保存的状态包括窗口中的元组，恢复处理状态所需的任何系统状态以及用户状态。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">topologyBuilder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"mybolt"</span><span class="o">,</span>
                   <span class="k">new</span> <span class="nf">MyStatefulPersistentWindowedBolt</span><span class="o">()</span>
                   <span class="o">.</span><span class="na">withWindow</span><span class="o">(...)</span> <span class="c1">// windowing configuarations</span>
                   <span class="o">.</span><span class="na">withPersistence</span><span class="o">()</span> <span class="c1">// persist the window state</span>
                   <span class="o">.</span><span class="na">withMaxEventsInMemory</span><span class="o">(</span><span class="mi">25000</span><span class="o">),</span> <span class="c1">// max number of events to be cached in memory</span>
                    <span class="n">parallelism</span><span class="o">)</span>
               <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"spout"</span><span class="o">);</span>

</code></pre></div>
<p>的<code>withPersistence</code>指示框架将窗口中的元组以及任何关联的系统和用户状态透明地保存到状态后端。的<code>withMaxEventsInMemory</code>是一个可选配置，指定可以在内存中保留的最大元组数。元组根据需要从状态后端透明地加载，并且最有可能再次使用的元组保留在内存中。</p>

<p>可以通过设置拓扑状态提供程序config来配置状态后端，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// use redis for state persistence</span>
<span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Config</span><span class="o">.</span><span class="na">TOPOLOGY_STATE_PROVIDER</span><span class="o">,</span> <span class="s">"org.apache.storm.redis.state.RedisKeyValueStateProvider"</span><span class="o">);</span>

</code></pre></div>
<p>目前，storm支持将Redis和HBase作为状态后端，并使用基础状态检查点框架保存窗口状态。有关状态检查点的更多详细信息，请参见<a href="State-checkpointing.html">State-checkpointing</a> 。</p>

<p>这是使用窗口检查点保存其状态的持久窗口螺栓的示例。的<code>initState</code>在初始化时以最后保存的状态（用户状态）调用。根据配置的窗口参数调用execute方法，并且可以通过一个活动窗口访问活动窗口中的元组。 <code>iterator</code>如下所示。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyStatefulPersistentWindowedBolt</span> <span class="kd">extends</span> <span class="n">BaseStatefulWindowedBolt</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">KeyValueState</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">state</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initState</span><span class="o">(</span><span class="n">KeyValueState</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
   <span class="c1">// ...</span>
   <span class="c1">// restore the state from the last saved state.</span>
   <span class="c1">// ...</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TupleWindow</span> <span class="n">window</span><span class="o">)</span> <span class="o">{</span>      
    <span class="c1">// iterate over tuples in the current window</span>
    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="na">getIter</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// compute some result based on the tuples in window</span>
    <span class="o">}</span>

    <span class="c1">// possibly update any state to be maintained across windows</span>
    <span class="n">state</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">STATE_KEY</span><span class="o">,</span> <span class="n">updatedValue</span><span class="o">);</span>

    <span class="c1">// emit the results downstream</span>
    <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><strong>注意：</strong>如果是固定窗螺栓，请使用<code>TupleWindow.getIter</code>检索窗口中事件的迭代器。如果Windows中的元组数量巨大，则调用<code>TupleWindow.get</code>会尝试将所有元组加载到内存中，并可能引发OOM异常。</p>

<p><strong>注意：</strong>如果是固定窗螺栓，则<code>TupleWindow.getNew</code>和<code>TupleWindow.getExpired</code>目前不受支持，并将抛出<code>UnsupportedOperationException</code> 。</p>

<p>有关更多详细信息，请查看风暴启动程序<a href="../examples/storm-starter/src/jvm/org/apache/storm/starter/PersistentWindowingTopology.java">PersistentWindowingTopology</a>中的示例拓扑，它将帮助您入门。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>