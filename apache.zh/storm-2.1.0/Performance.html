<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>性能调优</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=3">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">性能调优</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>延迟，吞吐量和资源消耗是性能调整涉及的三个关键维度。在以下各节中，我们将讨论可用于调整这些尺寸并了解其取舍的设置。</p>

<p>重要的是要了解，这些设置可能会根据拓扑，硬件类型和拓扑使用的主机数量而有所不同。</p>

<h2 id="1-buffer-size">1。缓冲区大小</h2>

<p>喷口和螺栓使用消息传递异步操作。用于此目的的消息队列具有固定但可配置的大小。缓冲区大小是指这些队列的大小。每个使用者都有自己的接收队列。消息在队列中等待，直到使用者准备处理它们为止。队列通常将几乎为空或几乎已满，这取决于消费者操作的速度是比生产者为其生成消息的速度快还是慢。风暴队列始终只有一个消费者，并可能有多个生产者。有两个感兴趣的缓冲区大小设置：</p>

<ul>
<li><code>topology.executor.receive.buffer.size</code> ：这是每个喷口和螺栓执行器使用的消息队列的大小。</li>
<li><code>topology.transfer.buffer.size</code> ：这是用于同事间消息传递的出站消息队列的大小。此队列称为“ <em>工人转移队列”</em> 。</li>
</ul>

<p><strong>注意：</strong>如果指定的缓冲区大小不是2的幂，则在内部将其舍入到下一个2的幂。</p>

<h4 id="guidance">指导</h4>

<p>很小的消息队列（大小<1024）可能由于没有在使用者和生产者之间提供足够的隔离而阻碍了吞吐量。这可能会影响处理的异步性质，因为生产者可能会发现下游队列已满。</p>

<p>也不希望有很大的消息队列来处理速度较慢的使用者。最好在更多的CPU内核上雇用更多的使用者（即螺栓）。如果队列很大且经常满了，则消息将在处理的每个步骤中最终在这些队列中等待更长的时间，从而导致在Storm UI上报告的延迟很短。大队列还意味着更高的内存消耗，尤其是在队列通常已满的情况下。</p>

<h2 id="2-batch-size">2。批量大小</h2>

<p>生产者可以将一批消息写到使用者的队列中，也可以分别编写每条消息。可以配置此批处理大小。批量将消息插入下游队列有助于减少插入所需的同步操作数。因此，这有助于实现更高的吞吐量。但是，有时在将缓冲区刷新到下游队列之前，可能需要一点时间来填充缓冲区。这意味着缓冲的消息将需要更长的时间才能被等待处理它们的下游使用者看到。这会增加这些消息的平均端到端延迟。如果批处理量很大并且拓扑没有遇到高流量，则延迟可能会非常糟糕。</p>

<ul>
<li><p><code>topology.producer.batch.size</code> ：通过此设置控制写入任何喷嘴/螺栓的接收队列的批处理大小。此设置会影响工作进程中的通信。每个上游生产者都将一个单独的批次维护到组件的接收队列。因此，如果两个喷口实例正在写入同一下游Bolt实例，则每个喷口实例将维护一个单独的批次。</p></li>
<li><p><code>topology.transfer.batch.size</code> ：将发往另一个工作进程上运行的喷口/螺栓的消息发送到称为“ <strong>工作人员传送队列”的队列</strong> 。Worker Transfer Thread负责清空此队列中的消息，并将其通过网络发送到适当的Worker进程。此设置控制写入Worker Transfer Queue的批处理大小。这会影响工作进程之间的通信。</p></li>
</ul>

<h4 id="guidance">指导</h4>

<p><strong>对于低延迟：</strong>将批量大小设置为1。这基本上禁用了批处理。这可能会降低繁忙交通条件下的峰值可持续吞吐量，但在低/中等交通状况下不太可能对吞吐量产生太大影响。</p>

<p><strong>对于高吞吐量：</strong>设置批次大小> 1。尝试使用10、100、1000或什至更高的值，并查看为拓扑产生最佳吞吐量的值。超过某个点，吞吐量可能会变差。</p>

<p><strong>吞吐量各不相同：</strong>拓扑通常在一天中会经历波动的传入流量。其他主题可能会在某些路径上同时经历较高的流量，而在其他路径上同时经历较低的吞吐量。如果不担心等待时间，则较小的bach（例如10）大小以及正确的刷新频率可为此类情况提供合理的折衷方案。为了满足更严格的延迟SLA，请考虑将其设置为1。</p>

<h2 id="3-flush-tuple-frequency">3。刷新元组频率</h2>

<p>在中低流量的情况下或当批次大小太大时，批次可能需要很长时间才能填满，因此消息可能需要很长时间才能被下游组件看到。在这种情况下，必须定期刷新批处理以保持消息移动并避免在启用批处理时损害延迟。</p>

<p>启用批处理后，会定期将称为<em>冲洗元组的</em>特殊消息插入所有喷嘴和螺栓实例的接收队列。这导致每个喷嘴/螺栓实例将所有未完成的批次冲洗到其各自的下游组件。</p>

<p><code>topology.flush.tuple.freq.millis</code> ：此设置控制刷新元组的生成频率。如果此配置设置为0或（ <code>topology.producer.batch.size</code> = 1并且<code>topology.transfer.batch.size</code> = 1）。</p>

<h4 id="guidance">指导</h4>

<p>刷新间隔可以用作保留批处理的更高吞吐量优势的工具，并避免批处理的消息在等待消息时停留太长时间。批量填充。优选地，该值应大于拓扑中螺栓的平均执行等待时间。尝试刷新队列的频率超过生成消息所花费的时间，可能会影响性能。了解每个螺栓的平均执行延迟将有助于确定两次刷新之间的队列中消息的平均数量。</p>

<p><strong>对于低延迟：</strong>较小的值有助于实现更紧密的延迟SLA。</p>

<p><strong>对于高吞吐量：</strong>在高流量情况下尝试最大化吞吐量时，批次可能会自动填充和冲洗。为了针对这种情况进行优化，可以将该值设置为更大的数字。</p>

<p><strong>吞吐量变化：</strong>如果不考虑延迟，则较大的值将针对高流量情况进行优化。为了满足更严格的SLA，请将其设置为较低的值。</p>

<h2 id="4-wait-strategy">4。等待策略</h2>

<p>等待策略用于通过权衡一些延迟和吞吐量来节省CPU使用率。它们适用于以下情况：</p>

<p>4.1 <strong>Spout等待：</strong>在交通不繁忙的情况下，Spout的nextTuple（）可能不会产生任何新的发射。为了防止过于频繁地调用Spout的nextTuple，在nextTuple（）调用之间使用此等待策略，以允许Spout的执行程序线程空闲并节省CPU。当<code>topology.max.spout.pending</code>启用ACKers后，已达到限制。使用选择策略<code>topology.spout.wait.strategy</code> 。使用以下选项之一配置所选的等待策略<code>topology.spout.wait.*</code>设置。</p>

<p>4.2 <strong>螺栓等待：：</strong>螺栓轮询时，它正在接收队列以待处理新消息，该队列很可能为空。这通常发生在交通流量低/没有交通情况或上游喷口/螺栓本来就较慢的情况下。在这种情况下使用此等待策略。由于螺栓连续检查通常为空的队列，因此可以避免CPU使用率过高。使用选择策略<code>topology.bolt.wait.strategy</code> 。可以使用<code>topology.bolt.wait.*</code>设置。</p>

<p>4.3 <strong>背压等待</strong> ：使用<code>topology.backpressure.wait.strategy</code> 。当喷口/螺栓尝试写入下游组件的接收队列时，队列可能已满。在这种情况下，需要重试写入。此等待策略用于在重新尝试之间引起一些空闲，以节省CPU。可以使用<code>topology.backpressure.wait.*</code>设置。</p>

<h4 id="built-in-wait-strategies">内置等待策略：</h4>

<p>这些等待策略可用于上述所有等待情况。</p>

<ul>
<li><strong>ProgressiveWaitStrategy</strong> ：此策略可用于Bolt Wait或Backpressure Wait情况。将策略设置为“ org.apache.storm.policy”。WaitStrategyProgressive”以选择此等待策略。这是一种动态等待策略，如果“背压等待”或“螺栓等待”情况持续存在，则会进入CPU保留状态的逐步深入状态。它具有3个级别的空转，并允许配置每个级别的停留时间：</li>
</ul>

<ol>
<li><p>级别1 /无等待-前几次它将立即返回。这不会节省任何CPU。使用以下命令配置它保持在此状态的次数<code>topology.spout.wait.progressive.level1.count</code>要么<code>topology.bolt.wait.progressive.level1.count</code>要么<code>topology.backpressure.wait.progressive.level1.count</code>取决于正在使用的情况。</p></li>
<li><p>级别2 / Park Nanos-在此状态下，使用LockSupport.parkNanos（）禁用当前线程进行线程调度，持续1纳秒。这使CPU处于最小保护状态。它保持这种状态<code>topology.spout.wait.progressive.level2.count</code>要么<code>topology.bolt.wait.progressive.level2.count</code>要么<code>topology.backpressure.wait.progressive.level2.count</code>迭代。</p></li>
<li><p>级别3 / Thread.sleep（）-在此级别中，它使用在<code>topology.spout.wait.progressive.level3.sleep.millis</code>要么<code>topology.bolt.wait.progressive.level3.sleep.millis</code>要么<code>topology.backpressure.wait.progressive.level3.sleep.millis</code> 。这是最节省CPU的级别，在其余的迭代中仍保持在该级别。</p></li>
</ol>

<ul>
<li><strong>ParkWaitStrategy</strong> ：此策略可用于螺栓等待或背压等待情况。将策略设定为<code>org.apache.storm.policy.WaitStrategyPark</code>使用这个。此策略通过调用LockSupport.parkNanos（）禁用当前线程以进行线程调度。使用以下任一方式配置停车时间<code>topology.bolt.wait.park.microsec</code>要么<code>topology.backpressure.wait.park.microsec</code>根据等待情况使用它。将暂存时间设置为0，可以有效地禁用LockSupport.parkNanos的调用，并且该模式可用于实现繁忙的轮询（即使闲置时，这也会以高CPU使用率为代价，可能会提高延迟和/或吞吐量）。</li>
</ul>

<h2 id="5-max-spout-pending">5，最大喷口待定</h2>

<p>那个设定<code>topology.max.spout.pending</code>在喷口级别限制未确认的元组的数量。一旦喷口达到此限制，在收到一些未决发射的ACK之前，将不会调用喷口的nextTuple（）方法。如果禁用了ACKing，则此设置没有任何影响。这是一个喷口节流机制，可能会影响吞吐量和延迟。将其设置为null会禁用风暴核心拓扑。对吞吐量的影响取决于拓扑及其并发性（工作人员/执行人员），因此必须进行实验以确定最佳设置。通常，延迟和内存消耗通常会随着此值的增加而增加。</p>

<h2 id="6-load-aware-messaging">6。加载感知消息</h2>

<p>启用负载感知消息传递后（默认），随机分组将消息路由考虑其他因素。这对性能的影响取决于拓扑及其部署范围（即，在过程和计算机上的分布）。因此，评估设置的影响很有用<code>topology.disable.loadaware.messaging</code>至<code>true</code>要么<code>false</code>针对您的具体情况。</p>

<h2 id="7-sampling-rate">7。采样率</h2>

<p>采样率用于控制在Spout和Bolt执行器上计算某些指标的频率。这是使用配置<code>topology.stats.sample.rate</code>将其设置为1表示，将为每个发出的消息计算统计信息。例如，要每1000条消息采样一次，可以将其设置为0.001。通过降低采样率可以提高吞吐量和延迟。</p>

<h2 id="8-budgeting-cpu-cores-for-executors">8。为执行器预算CPU内核</h2>

<p>在为执行器预算CPU内核时，要考虑三种主要执行器（即线程）。喷口执行器，螺栓执行器，工作者转移（处理出站消息）和NettyWorker（处理入站消息）。前两个用于运行喷口，螺栓和锚杆实例。Worker Transfer线程用于序列化消息并将其发送给其他工作程序（在多工作人员模式下）。</p>

<p>应当由于执行器正在处理大量消息，或者由于其处理本质上是占用大量CPU的执行器，因此应该为每个执行器分配1个物理核心。为CPU密集型执行程序分配逻辑核心（而不是物理核心）或少于1个物理核心会增加CPU竞争，并且性能可能会受到影响。可以将不期望繁忙的执行器分配给物理核心（甚至逻辑核心）的一小部分。为不太可能使CPU饱和的执行程序分配一个完整的物理核心可能并不经济。</p>

<p><em>系统螺栓</em>通常每秒处理很少的消息，因此需要的CPU很少（通常少于物理内核的10％）。</p>

<h2 id="9-garbage-collection">9。垃圾收集</h2>

<p>对于延迟或吞吐量敏感的拓扑，GC的选择是一个重要的问题。建议同时尝试CMS和G1收集器。收集器的性能特征可以在单工模式和多工模式之间变化，并且取决于硬件特征，例如CPU数量和内存位置。GC线程数也会影响性能。有时，较少的GC线程可以产生更好的性能。建议选择一个收集器并通过模仿与生产中使用的硬件类似的预期峰值数据速率来对其进行调整。</p>

<h2 id="10-scaling-out-with-single-worker-mode">10。使用单工模式扩展</h2>

<p>工作进程中执行程序之间的通信非常快，因为既不需要序列化和反序列化消息，也不需要通过网络堆栈进行通信。在多工模式下，消息通常跨越工作进程边界。对于性能敏感的情况，如果可以配置一个拓扑以运行尽可能多的单工实例（例如，每个输入分区一个工）而不是一个多工实例，则它可以在同一硬件上显着提高吞吐量和延迟。这种方法的缺点是，它增加了监视和管理许多实例而不是一个多工实例的开销。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>