<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>高可用的Nimbus设计</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=0">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">高可用的Nimbus设计</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><h2 id="problem-statement">问题陈述：</h2>

<p>当前，Storm Master（又名Nimbus）是在单个计算机上运行的进程。在大多数情况下，灵气故障是暂时性的，由主管重新启动。但是，有时当磁盘出现故障并发生网络分区时，nimbus会关闭。在这些情况下，拓扑正常运行，但是无法提交新的拓扑，无法杀死/停用/激活现有的拓扑，并且如果主管节点发生故障，则不会执行重新分配，从而导致性能下降或拓扑故障。在这个项目中，我们打算通过在主备份模式下运行nimbus来解决此问题，以确保即使nimbus服务器出现故障，其中一个备份也可以接管。</p>

<h2 id="requirements">要求：</h2>

<ul>
<li>提高灵气的整体可用性。</li>
<li>允许nimbus主机随时离开并加入集群。新加入的主持人应自动追赶并自动加入潜在领导者列表。</li>
<li>如果有nimbus故障转移，则无需重新提交拓扑。</li>
<li>任何活动的拓扑都不应丢失。</li>
</ul>

<h2 id="leader-election">领导人选举：</h2>

<p>Nimbus服务器将使用以下界面：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ILeaderElector</span> <span class="o">{</span>
    <span class="cm">/**
     * queue up for leadership lock. The call returns immediately and the caller                     
     * must check isLeader() to perform any leadership action.
     */</span>
    <span class="kt">void</span> <span class="nf">addToLeaderLockQueue</span><span class="o">();</span>

    <span class="cm">/**
     * Removes the caller from the leader lock queue. If the caller is leader
     * also releases the lock.
     */</span>
    <span class="kt">void</span> <span class="nf">removeFromLeaderLockQueue</span><span class="o">();</span>

    <span class="cm">/**
     *
     * @return true if the caller currently has the leader lock.
     */</span>
    <span class="kt">boolean</span> <span class="nf">isLeader</span><span class="o">();</span>

    <span class="cm">/**
     *
     * @return the current leader's address , throws exception if noone has has    lock.
     */</span>
    <span class="n">InetSocketAddress</span> <span class="nf">getLeaderAddress</span><span class="o">();</span>

    <span class="cm">/**
     * 
     * @return list of current nimbus addresses, includes leader.
     */</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">InetSocketAddress</span><span class="o">&gt;</span> <span class="nf">getAllNimbusAddresses</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>在启动时，nimbus将检查其是否具有本地可用的所有活动拓扑的代码。一旦进入此状态，它将调用addToLeaderLockQueue（）函数。当一个灵气被告知要成为领导者时，它将在担任领导角色之前检查它是否在本地具有所有代码。如果缺少任何活动的拓扑代码，则该节点将不接受领导角色，而是释放锁定并等待直到拥有所有代码，然后再重新请求领导者锁定。</p>

<p>第一个实现将基于Zookeeper。如果Zookeeper连接丢失/重置导致锁丢失或队列中的地点，则实现将负责更新状态，以使isLeader（）反映当前状态。领导者之类的动作必须在小于minimumOf（connectionTimeout，SessionTimeout）的时间内完成，以确保在整个动作期间该锁均由nimbus持有（不确定我们是否只想陈述这一期望并确保zk配置设置得足够高这将导致更长的故障转移时间，或者我们实际上想为所有操作创建某种回滚机制，第二个选项需要大量代码）。如果不是领导者的灵气接收到只有领导者可以执行的请求，它将抛出RunTimeException。</p>

<p>以下步骤描述了一个nimbus故障转移方案：*假设我们有4个拓扑，它们运行着3个nimbus节点，并且代码复制因子= 2。我们假设不变式“ Leader nimbus在本地具有所有拓扑的代码”一开始就是正确的。 nonleader-1具有用于前两种拓扑的代码，nonleader-2具有用于其他两种拓扑的代码。*领导者灵光飞逝，硬盘故障，因此无法恢复。* nonLeader-1收到了动物园管理员的通知，表明它现在是新的领导者。在接受领导之前，它会检查代码是否适用于所有4种拓扑（这些拓扑在/ storm / storms /下）。它意识到它仅具有2种拓扑的代码，因此它放弃了该锁定，并在/ storm / code-distributor / topologyId下查找以查找从何处下载缺少的拓扑的代码/元文件。它查找领导者nimbus和nonleader-2的条目。作为重试机制的一部分，它将尝试从两者下载。* nonLeader-2的代码同步线程还意识到它缺少2种拓扑的代码，并按照步骤3中所述的相同过程下载了缺少拓扑的代码。*最终，至少有一个肢体将在本地拥有所有代码，并将接受领导。此序列图描述了领导者选举和故障转移如何与多个组件一起工作。</p>

<p><img src="images/nimbus_ha_leader_election_and_failover.png" alt="雨云故障转移"></p>

<h2 id="nimbus-state-store">Nimbus状态存储：</h2>

<p>当前，nimbus存储2种数据*元信息（如超级用户信息，分配信息）存储在zookeeper中*实际的拓扑配置和jars存储在nimbus主机的本地磁盘上。</p>

<p>为了实现从主服务器到备份服务器的故障转移，需要在所有nimbus主机之间复制nimbus状态/数据，或者需要将其存储在分布式存储中。正确地复制数据涉及状态管理，一致性检查，并且很难测试其正确性。但是，许多风暴用户不希望对HDFS等另一个复制的存储系统产生额外的依赖，仍然需要高可用性。最终，考虑到jar的大小，我们希望转向bittorrent协议进行代码分发，并在超级用户总数很高时实现更好的扩展。当前基于文件系统的代码分发模型可以很好地与具有类似文件系统结构的系统配合使用，但是它无法支持基于非文件系统的方法，例如bit torrent。为了支持bit torrent和所有基于文件系统的复制存储系统，我们建议使用以下接口：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
 * Interface responsible to distribute code in the cluster.
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICodeDistributor</span> <span class="o">{</span>
    <span class="cm">/**
     * Prepare this code distributor.
     * @param conf
     */</span>
    <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">);</span>

    <span class="cm">/**
     * This API will perform the actual upload of the code to the distributed implementation.
     * The API should return a Meta file which should have enough information for downloader 
     * so it can download the code e.g. for bittorrent it will be a torrent file, in case of something         
     * like HDFS or s3  it might have the actual directory or paths for files to be downloaded.
     * @param dirPath local directory where all the code to be distributed exists.
     * @param topologyId the topologyId for which the meta file needs to be created.
     * @return metaFile
     */</span>
    <span class="n">File</span> <span class="nf">upload</span><span class="o">(</span><span class="n">Path</span> <span class="n">dirPath</span><span class="o">,</span> <span class="n">String</span> <span class="n">topologyId</span><span class="o">);</span>

    <span class="cm">/**
     * Given the topologyId and metafile, download the actual code and return the downloaded file's list.
     * @param topologyid
     * @param metafile 
     * @param destDirPath the folder where all the files will be downloaded.
     * @return
     */</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="nf">download</span><span class="o">(</span><span class="n">Path</span> <span class="n">destDirPath</span><span class="o">,</span> <span class="n">String</span> <span class="n">topologyid</span><span class="o">,</span> <span class="n">File</span> <span class="n">metafile</span><span class="o">);</span>

    <span class="cm">/**
      * Given the topologyId, returns number of hosts where the code has been replicated.
      */</span>
    <span class="kt">int</span> <span class="nf">getReplicationCount</span><span class="o">(</span><span class="n">String</span> <span class="n">topologyId</span><span class="o">);</span>

   <span class="cm">/**
     * Performs the cleanup.
     * @param topologyid
     */</span>
    <span class="kt">void</span> <span class="nf">cleanup</span><span class="o">(</span><span class="n">String</span> <span class="n">topologyid</span><span class="o">);</span>

    <span class="cm">/**
     * Close this distributor.
     * @param conf
     */</span>
    <span class="kt">void</span> <span class="nf">close</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>为了支持复制，我们将允许用户定义代码复制因子，该因子将反映启动拓扑之前必须将代码复制到的nimbus主机的数量。复制带来了一致性问题。我们会将zookeeper的活动拓扑列表视作代码必须存在于灵气主机上的拓扑的授权机构。任何不具有在Zookeeper中标记为活动的所有拓扑的所有代码的nimbus主机都会放弃其锁定，因此其他一些nimbus主机可以成为领导者。所有nimbus主机上的后台线程将不断尝试从成功复制了代码的其他主机上同步代码，因此最终，至少一个nimbus将接受领导，只要每个活动拓扑至少存在一个种子主机即可。</p>

<p>以下步骤描述了在nimbus主机之间针对拓扑复制代码的步骤：*客户端上载jar时，没有任何变化。*当客户提交拓扑时，领导者nimbus会调用代码分发器的上载功能，这将创建一个存储在领导者nimbus本地的图元文件。领导者nimbus将在/ storm / code-distributor / topologyId下写入新条目，以通知所有非领导者nimbuse他们应下载此新代码。*我们等待领导者雨云，以确保至少N个非领导者雨云已复制了代码，并且用户可以配置超时。*当非领导者nimbus接收到有关新代码的通知时，它将从领导者nimbus下载元文件，然后通过调用代码分发者的下载功能并以图元文件作为输入来下载实际代码。*一旦非领导者完成了下载代码，它将在/ storm / code-distributor / topologyId下写入一个条目，以指示如果领导者雨云死了，这是下载代码/元文件的可能位置之一。*领导者nimbus继续进行并做所有常规工作，作为提交拓扑的一部分。</p>

<p>以下序列图描述了代码分发中涉及的不同组件之间的通信。</p>

<p><img src="images/nimbus_ha_topology_submission.png" alt="Nimbus HA拓扑提交"></p>

<h2 id="thrift-and-rest-api">节俭API</h2>

<p>为了避免工作人员/主管/用户界面与Zookeeper交谈以获得主雨云台地址，我们将修改<code>getClusterInfo</code> API，因此它也可以返回雨云信息。 getClusterInfo当前返回<code>ClusterSummary</code>具有以下列表的实例<code>supervisorSummary</code>以及“拓扑摘要”列表<code>instances. We will add a list of</code>雨云摘要<code>to the</code> ClusterSummary`。请参阅以下结构：</p>
<div class="highlight"><pre><code class="language-thrift" data-lang="thrift">struct ClusterSummary {
  1: required list&lt;SupervisorSummary&gt; supervisors;
  3: required list&lt;TopologySummary&gt; topologies;
  4: required list&lt;NimbusSummary&gt; nimbuses;
}

struct NimbusSummary {
  1: required string host;
  2: required i32 port;
  3: required i32 uptime_secs;
  4: required bool isLeader;
  5: required string version;
}
</code></pre></div>
<p>StormSubmitter，Nimbus客户，主管和ui将使用它来发现当前的领导者和参与的nimbus主机。任何灵气主机都将能够响应这些请求。灵气主机可以一次从Zookeeper读取此信息并将其缓存，并在激发观察者指示任何更改时继续更新缓存，这在一般情况下很少见。</p>

<h2 id="configuration">组态</h2>

<p>您可以将nimbus ha与默认配置一起使用，但是默认配置假定单个nimbus主机，因此可以权衡复制以降低拓扑提交延迟。根据您的用例，您可以调整以下配置：* storm.codedistributor.class：这是一个字符串，表示实现org.apache.storm.codedistributor的类的完全限定的类名。ICodeDistributor。默认设置为“ org.apache.storm.codedistributor”。LocalFileSystemCodeDistributor”。此类利用本地文件系统存储元文件和代码/配置。即使在下载了它联系Zookeeper的代码分发器元文件之后，该类也会在zookeeper上增加额外的负载，以便找出可以从中下载实际代码/配置并获取当前复制计数的主机。一种替代方法是使用“ org.apache.storm.hdfs.ha.codedistributor。HDFSCodeDistributor”，它依赖于HDFS，但不会在zookeeper上增加额外的负载，并且可以使拓扑提交更快。* topology.min.replication.count：在领导者nimbus可以将拓扑标记为活动并创建分配之前，必须在其中复制代码的最少数量的nimbus主机。默认值为1。* topology.max.replication.wait.time.sec：nimbus主机复制达到nimbus.min.replication.count的最大等待时间。此时间过后，即使未达到所需的nimbus.min.replication.count，nimbus也会继续执行拓扑激活任务。默认值为60秒，值-1表示等待。* nimbus.code.sync.freq.secs：nimbus上的后台线程的运行频率，该后台线程同步代码以局部丢失拓扑。默认值为5分钟。</p>

<p>注意：即使所有nimbus主机在zookeeper上都有观察者，一旦有新的拓扑可用于代码下载，便会立即得到通知，但回调几乎不会导致代码下载。在实践中，我们观察到只有在后台线程运行后才能实现所需的复制。因此，对于任何nimbus.min.replication.count> 1，您应该期望拓扑提交时间在0到（2 * nimbus.code.sync.freq.secs）之间。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>