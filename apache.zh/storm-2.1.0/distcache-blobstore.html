<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>Storm分布式缓存API</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=3">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">Storm分布式缓存API</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><h1 id="storm-distributed-cache-api">Storm分布式缓存API</h1>

<p>Storm中的分布式缓存功能用于有效地分发文件（或blob，这是分布式缓存中文件的等效术语，在本文档中可以互换使用），这些文件很大并且可以在拓扑的生命周期内进行更改，例如例如地理位置数据，字典等。典型的用例包括短语识别，实体提取，文档分类，URL重写，位置/地址检测等。此类文件的大小可能在几KB到几GB之间。对于不需要动态更新的小型数据集，将它们包括在拓扑jar中可能很好。但是对于大文件，启动时间可能会非常长。在这些情况下，分布式缓存功能可以提供快速的拓扑启动，特别是如果以前为同一提交者下载了文件并且仍在缓存中。这对于频繁部署（有时一天使用更新的jar有时一天几次）很有用，因为大型缓存的文件将保持可用而无需更改。不会频繁更改的大型缓存Blob将在分布式缓存中保持可用。</p>

<p>在拓扑开始时，用户指定拓扑所需的文件集。拓扑运行后，用户可以随时请求使用更高版本更新分布式缓存中的任何文件。斑点的更新发生在最终的一致性模型中。如果拓扑需要知道它可以访问的文件版本，则用户有责任找出此信息。这些文件存储在具有最近最少使用（LRU）驱逐策略的高速缓存中，管理员可以在其中决定不再需要哪些高速缓存的文件，并可以删除它们以释放磁盘空间。Blob可以被压缩，并且用户可以在访问Blob之前请求对其进行解压缩。</p>

<h2 id="motivation-for-distributed-cache">分布式缓存的动机</h2>

<ul>
<li>允许在拓扑之间共享Blob。</li>
<li>允许从命令行更新Blob。</li>
</ul>

<h2 id="distributed-cache-implementations">分布式缓存实现</h2>

<p>当前的BlobStore接口具有以下两个实现* LocalFsBlobStore * HdfsBlobStore</p>

<p>附录A包含用于Blobstore实现的接口。</p>

<h2 id="localfsblobstore">LocalFsBlobStore</h2>

<p><img src="images/local_blobstore.png" alt="LocalFsBlobStore"></p>

<p>上面的时间线图中可以描述Blobstore的本地文件系统实现。</p>

<p>从创建Blob到Blob下载以及相应执行拓扑，有几个阶段。主要阶段可以描述如下</p>

<h3 id="blob-creation-command">Blob创建命令</h3>

<p>可以使用以下命令通过命令行在Blobstore中创建Blob。</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore create --file README.txt --acl o::rwa --replication-factor 4 key1
</code></pre></div>
<p>上面的命令创建一个与文件README.txt对应的键名称为“ key1”的Blob。授予所有正在读取，写入和管理用户的访问权限，复制因子为4。</p>

<h3 id="topology-submission-and-blob-mapping">拓扑提交和Blob映射</h3>

<p>用户可以使用以下命令提交其拓扑。该命令包括拓扑图配置。该配置包含两个密钥“ key1”和“ key2”，其中密钥“ key1”具有名为“ blob_file”的本地文件名映射，并且未压缩。</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm jar /home/y/lib/storm-starter/current/storm-starter-jar-with-dependencies.jar 
org.apache.storm.starter.clj.word_count test_topo -c topology.blobstore.map='{"key1":{"localname":"blob_file", "uncompress":false},"key2":{}}'
</code></pre></div>
<h3 id="blob-creation-process">Blob创建过程</h3>

<p>通过接口“ ClientBlobStore”进行Blob的创建。附录B包含“ ClientBlobStore”接口。该接口的具体实现是“ NimbusBlobStore”。对于本地文件系统，客户端会调用nimbus在本地文件系统内创建blob。Nimbus使用本地文件系统实现来创建这些Blob。用户提交拓扑时，jar，配置和代码文件将在blobstore的帮助下作为blob上传。同样，借助topology.blobstore.map配置，将拓扑指定的所有其他blob映射到它。</p>

<h3 id="blob-download-by-the-supervisor">主管下载的Blob</h3>

<p>最后，管理者一旦通过上载blob的同一“ NimbusBlobStore”旧版客户端从nimbus接收到分配，便下载了与拓扑相对应的blob。主管通过直接调用“ NimbusBlobStore”客户端来下载代码，jar和conf blob，同时在Localizer的帮助下，本地下载并映射了topology.blobstore.map中指定的blob。本地化程序与“ NimbusBlobStore”旧版客户端进行对话，以下载blob，并添加blob压缩和本地blob名称映射逻辑以适合拓扑的实现。一旦下载了所有Blob，便启动工作程序以运行拓扑。</p>

<h2 id="hdfsblobstore">HdfsBlobStore</h2>

<p><img src="images/hdfs_blobstore.png" alt="HdfsBlobStore"></p>

<p>HdfsBlobStore功能具有类似的实现以及blob创建和下载过程，除非在两个blobstore实现中如何处理复制。HDFS blobstore中的复制非常明显，因为HDFS具有处理复制的功能，并且不需要在Zookeeper内部存储任何状态。另一方面，本地文件系统blobstore要求将状态存储在zookeeper上，以便其与nimbus HA一起使用。 Nimbus HA通过将有关正在运行的拓扑的状态存储在zookeeper中并同步各种nimbuse上的blob，从而允许本地文件系统无缝地实现复制功能。在主管端，主管和本地化人员通过“ HdfsClientBlobStore”实现与HdfsBlobStore进行对话。</p>

<h2 id="additional-features-and-documentation">附加功能和文档</h2>
<div class="highlight"><pre><code class="language-" data-lang="">storm jar /home/y/lib/storm-starter/current/storm-starter-jar-with-dependencies.jar org.apache.storm.starter.clj.word_count test_topo 
-c topology.blobstore.map='{"key1":{"localname":"blob_file", "uncompress":false},"key2":{}}'
</code></pre></div>
<h3 id="compression">压缩</h3>

<p>Blobstore允许用户将“解压缩”配置指定为true或false。可以在上述命令中提到的topology.blobstore.map中指定此配置。这允许用户上载压缩文件，例如tarball / zip。在本地文件系统blobstore中，压缩的blob存储在nimbus节点上。本地化程序代码负责解压缩blob并将其存储在主管节点上。在执行开始之前，将在工作器中创建指向主管节点上的Blob的符号链接。</p>

<h3 id="local-file-name-mapping">本地文件名映射</h3>

<p>除了压缩外，blobstore还有助于为blob提供一个可供工人使用的名称。本地化程序负责将blob映射到主管节点上的本地名称。</p>

<h2 id="additional-blobstore-implementation-details">其他Blobstore实施细节</h2>

<p>Blobstore使用哈希函数根据密钥创建Blob。这些Blob通常存储在blobstore.dir配置指定的目录内。默认情况下，它存储在本地文件系统的“ storm.local.dir / blobs”下，并且存储在hdfs文件系统上的类似路径下。</p>

<p>提交文件后，blobstore会读取配置并为具有所有访问控制详细信息的blob创建元数据。元数据通常在访问Blob时用于授权。Blob键和版本有助于哈希码，并在其中放置数据的“ storm.local.dir / blobs / data”目录下。斑点通常放在正数目录中，例如193822等。</p>

<p>一旦启动了拓扑并创建了相关的Blob，主管将首先下载与storm.conf，storm.ser和storm.code相关的Blob，并使用定位器分别通过命令行上载的所有Blob解压缩并映射它们到在topology.blobstore.map配置中指定的本地名称。主管通过检查版本更改来定期更新Blob。这允许动态更新blob，从而使其成为非常有用的功能。</p>

<p>对于本地文件系统，主管节点上的分布式缓存设置为10240 MB作为软限制，清理代码会根据LRU策略每600秒尝试清除超出软限制的任何内容。</p>

<p>HDFS blobstore实现通过减轻存储在blob上的nimbus的负担来更好地处理负载，从而避免了它成为瓶颈。而且，它提供了斑点的无缝复制。另一方面，本地文件系统blobstore在复制blob方面效率不高，并且受nimbuses数量的限制。此外，主管无需HDB的参与即可直接与HDFS Blob存储进行对话，从而减少了对Nimbus的负担和依赖性。</p>

<h2 id="highly-available-nimbus">高可用的雨云</h2>

<h3 id="problem-statement">问题陈述：</h3>

<p>当前，Storm Master（又名Nimbus）是在单个计算机上运行的进程。在大多数情况下，nimbus故障是暂时性的，并由进行监视的过程重新启动。但是，有时当磁盘出现故障并发生网络分区时，nimbus会关闭。在这种情况下，拓扑正常运行，但是无法提交新拓扑，无法杀死/停用/激活现有拓扑，并且如果主管节点发生故障，则不会执行重新分配，从而导致性能下降或拓扑故障。在这个项目中，我们打算通过在主备份模式下运行nimbus来解决此问题，以确保即使nimbus服务器出现故障，也可以接替其中一个备份。</p>

<h3 id="requirements-for-highly-available-nimbus">高可用性雨云器的要求：</h3>

<ul>
<li>提高灵气的整体可用性。</li>
<li>允许nimbus主机随时离开并加入集群。新加入的主持人应自动追赶并自动加入潜在领导者列表。</li>
<li>如果有nimbus故障转移，则无需重新提交拓扑。</li>
<li>任何活动的拓扑都不应丢失。</li>
</ul>

<h4 id="leader-election">领导人选举：</h4>

<p>Nimbus服务器将使用以下界面：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ILeaderElector</span> <span class="o">{</span>
    <span class="cm">/**
     * queue up for leadership lock. The call returns immediately and the caller                     
     * must check isLeader() to perform any leadership action.
     */</span>
    <span class="kt">void</span> <span class="nf">addToLeaderLockQueue</span><span class="o">();</span>

    <span class="cm">/**
     * Removes the caller from the leader lock queue. If the caller is leader
     * also releases the lock.
     */</span>
    <span class="kt">void</span> <span class="nf">removeFromLeaderLockQueue</span><span class="o">();</span>

    <span class="cm">/**
     *
     * @return true if the caller currently has the leader lock.
     */</span>
    <span class="kt">boolean</span> <span class="nf">isLeader</span><span class="o">();</span>

    <span class="cm">/**
     *
     * @return the current leader's address , throws exception if noone has has    lock.
     */</span>
    <span class="n">InetSocketAddress</span> <span class="nf">getLeaderAddress</span><span class="o">();</span>

    <span class="cm">/**
     * 
     * @return list of current nimbus addresses, includes leader.
     */</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">InetSocketAddress</span><span class="o">&gt;</span> <span class="nf">getAllNimbusAddresses</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>一旦出现灵气，它将调用addToLeaderLockQueue（）函数。领导者选举代码从队列中选择一个领导者。如果缺少拓扑代码，jar或config blob，它将从已启动并正在运行的任何其他nimbus下载blob。</p>

<p>第一个实现将基于Zookeeper。如果Zookeeper连接丢失/重置导致锁丢失或队列中的斑点，则实现将负责更新状态，以使isLeader（）反映当前状态。领导者之类的动作必须在小于minimumOf（connectionTimeout，SessionTimeout）的时间内完成，以确保在整个动作期间该锁均由nimbus持有（不确定我们是否只想陈述这一期望并确保zk配置设置得足够高这将导致更长的故障转移时间，或者我们实际上想为所有操作创建某种回滚机制，第二个选项需要大量代码）。如果不是领导者的灵气收到仅领导者可以执行的请求，它将抛出RunTimeException。</p>

<h3 id="nimbus-state-store">Nimbus状态存储：</h3>

<p>为了实现从主服务器到备份服务器的故障转移，需要在所有nimbus主机之间复制nimbus状态/数据，或者需要将其存储在分布式存储中。正确地复制数据涉及状态管理，一致性检查，并且很难测试其正确性。但是，许多风暴用户不希望对HDFS等另一个复制的存储系统产生额外的依赖，仍然需要高可用性。Blobstore实施与状态存储一起有助于克服领导者灵气瘫痪时的故障转移方案。</p>

<p>为了支持复制，我们将允许用户定义代码复制因子，该因子将反映启动拓扑之前必须将代码复制到的nimbus主机的数量。复制带来了一致性问题。一旦基于“ topology.min.replication”配置复制了代码，jar和conf blob文件，便会启动拓扑。维护故障转移方案的状态对于本地文件系统很重要。当前的实现方式确保在发生故障的情况下，可用的灵气之一被选为领导者。如果缺少特定于拓扑的Blob，则领导Nimbus会尝试在需要时下载它们。使用当前的体系结构，我们无需下载拓扑所需的所有blob，以使灵气总线能够接受领导力。这在斑点很大的情况下为我们提供了帮助，并避免了选举领导者时造成的任何疏忽。</p>

<p>每个Blob的状态都与本地Blobstore实现相关。对于HDFS blobstore，HDFS会注意复制。为了处理本地Blobstore的故障转移方案，我们需要在Zookeeper中存储领导者和非领导者的肢体状态。</p>

<p>状态存储在/ storm / blobstore / key / nimbusHostPort：SequenceNumber下，blobstore可以使nimbus高度可用。本地文件系统blobstore中使用此状态来支持复制。HDFS blobstore不必将状态存储在zookeeper中。</p>

<ul>
<li><p>NimbusHostPort：该信息通常包含解析的字符串，其中包含nimbus的主机名和端口。它使用代码分配器接口先前使用的同一类“ NimbusHostPortInfo”来存储状态并解析数据。</p></li>
<li><p>SequenceNumber：这是Blob序列号信息。SequenceNumber信息由KeySequenceNumber类实现。为每个键生成序列号。对于每次更新，序列号都是基于存储在/ storm / blobstoremaxsequencenumber / key下的全局序列号分配的。有关如何生成数字的更多详细信息，可以查看KeySequenceNumber的Java文档。</p></li>
</ul>

<p><img src="images/nimbus_ha_blobstore.png" alt="Nimbus高可用性-BlobStore"></p>

<p>序列图提出了Blobstore的工作方式，以及Zookeeper内部的状态存储使灵气高度可用。当前，用于同步非领导者上的Blob的线程在灵气中。将来，最好将线程移动到Blob存储区，以使Blob存储区根据状态图协调状态更改和Blob下载。</p>

<h2 id="thrift-and-rest-api">节俭API</h2>

<p>为了避免工作人员/主管/用户界面与Zookeeper交谈以获得主雨云台地址，我们将修改<code>getClusterInfo</code> API，因此它也可以返回雨云信息。 getClusterInfo当前返回<code>ClusterSummary</code>具有以下列表的实例<code>supervisorSummary</code>和清单<code>topologySummary</code>实例。我们将添加一个列表<code>NimbusSummary</code>到<code>ClusterSummary</code> 。请参阅以下结构：</p>
<div class="highlight"><pre><code class="language-" data-lang="">struct ClusterSummary {
  1: required list&lt;SupervisorSummary&gt; supervisors;
  3: required list&lt;TopologySummary&gt; topologies;
  4: required list&lt;NimbusSummary&gt; nimbuses;
}

struct NimbusSummary {
  1: required string host;
  2: required i32 port;
  3: required i32 uptime_secs;
  4: required bool isLeader;
  5: required string version;
}
</code></pre></div>
<p>StormSubmitter，Nimbus客户，主管和ui将使用它来发现当前的领导者和参与的nimbus主机。任何灵气主机都将能够响应这些请求。灵气主机可以一次从Zookeeper读取此信息并将其缓存，并在激发观察者指示任何更改时继续更新缓存，这在一般情况下很少见。</p>

<p>注意：所有nimbus主机在zookeeper上都有观察者，一旦有新的blob可供下载，便会立即得到通知，回调可能会也可能不会下载代码。因此，触发了后台线程来下载相应的Blob以运行拓扑。当将斑点下载到非领导者的肢体上时，即可实现复制。因此，对于任何nimbus.min.replication.count> 1，您应该期望拓扑提交时间在0到（2 * nimbus.code.sync.freq.secs）之间。</p>

<h2 id="configuration">组态</h2>
<div class="highlight"><pre><code class="language-" data-lang="">blobstore.dir: The directory where all blobs are stored. For local file system it represents the directory on the nimbus
node and for HDFS file system it represents the hdfs file system path.

supervisor.blobstore.class: This configuration is meant to set the client for  the supervisor  in order to talk to the blobstore. 
For a local file system blobstore it is set to “org.apache.storm.blobstore.NimbusBlobStore” and for the HDFS blobstore it is set 
to “org.apache.storm.blobstore.HdfsClientBlobStore”.

supervisor.blobstore.download.thread.count: This configuration spawns multiple threads for from the supervisor in order download 
blobs concurrently. The default is set to 5

supervisor.blobstore.download.max_retries: This configuration is set to allow the supervisor to retry for the blob download. 
By default it is set to 3.

supervisor.localizer.cache.target.size.mb: The jvm opts provided to workers launched by this supervisor. All "%ID%" substrings 
are replaced with an identifier for this worker. Also, "%WORKER-ID%", "%STORM-ID%" and "%WORKER-PORT%" are replaced with 
appropriate runtime values for this worker. The distributed cache target size in MB. This is a soft limit to the size 
of the distributed cache contents. It is set to 10240 MB.

supervisor.localizer.cleanup.interval.ms: The distributed cache cleanup interval. Controls how often it scans to attempt to 
cleanup anything over the cache target size. By default it is set to 600000 milliseconds.

nimbus.blobstore.class:  Sets the blobstore implementation nimbus uses. It is set to "org.apache.storm.blobstore.LocalFsBlobStore"

nimbus.blobstore.expiration.secs: During operations with the blobstore, via master, how long a connection is idle before nimbus 
considers it dead and drops the session and any associated connections. The default is set to 600.

storm.blobstore.inputstream.buffer.size.bytes: The buffer size it uses for blobstore upload. It is set to 65536 bytes.

client.blobstore.class: The blobstore implementation the storm client uses. The current implementation uses the default 
config "org.apache.storm.blobstore.NimbusBlobStore".

blobstore.replication.factor: It sets the replication for each blob within the blobstore. The “topology.min.replication.count” 
ensures the minimum replication the topology specific blobs are set before launching the topology. You might want to set the 
“topology.min.replication.count &lt;= blobstore.replication”. The default is set to 3.

topology.min.replication.count : Minimum number of nimbus hosts where the code must be replicated before leader nimbus
can mark the topology as active and create assignments. Default is 1.

topology.max.replication.wait.time.sec: Maximum wait time for the nimbus host replication to achieve the nimbus.min.replication.count.
Once this time is elapsed nimbus will go ahead and perform topology activation tasks even if required nimbus.min.replication.count is not achieved. 
The default is 60 seconds, a value of -1 indicates to wait for ever.
* nimbus.code.sync.freq.secs: Frequency at which the background thread on nimbus which syncs code for locally missing blobs. Default is 2 minutes.
</code></pre></div>
<h2 id="using-the-distributed-cache-api-command-line-interface-cli">使用分布式缓存API，命令行界面（CLI）</h2>

<h3 id="creating-blobs">创建斑点</h3>

<p>要使用分布式缓存功能，用户首先必须“引入”需要缓存的文件并将其绑定到密钥字符串。为此，用户使用storm可执行文件的“ blobstore create”命令，如下所示：</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore create [-f|--file FILE] [-a|--acl ACL1,ACL2,...] [--replication-factor NUMBER] [keyname]
</code></pre></div>
<p>如果由-f或--file选项提供，则内容来自FILE，否则来自STDIN。<br>ACL可以是许多ACL的逗号分隔列表，其格式如下：</p>
<div class="highlight"><pre><code class="language-" data-lang="">&gt; [u|o]:[username]:[r-|w-|a-|_]
</code></pre></div>
<p>哪里：</p>

<ul>
<li>u =用户<br></li>
<li>o =其他<br></li>
<li>用户名=此特定ACL的用户<br></li>
<li>r =读取访问<br></li>
<li>w =写访问<br></li>
<li>a =管理员访问权限<br></li>
<li>_ =忽略<br></li>
</ul>

<p>可以使用--replication-factor将复制因子设置为大于1的值。</p>

<p>注意：现在可以为hdfs blobstore配置复制，但是对于本地blobstore，复制始终保持为1。对于hdfs blobstore，默认复制设置为3。</p>

<h6 id="example">例：</h6>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore create --file README.txt --acl o::rwa --replication-factor 4 key1
</code></pre></div>
<p>在上面的示例中， <em>README.txt</em>文件被添加到分布式缓存中。可以使用关键字字符串“ <em>key1</em> ”访问需要它的任何拓扑。该文件被设置为对其他人（也就是世界一切）具有读/写/管理员访问权限，并且复制设置为4。</p>

<h6 id="example">例：</h6>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore create mytopo:data.tgz -f data.tgz -a u:alice:rwa,u:bob:rw,o::r  
</code></pre></div>
<p>上面的示例使用存储在data.tgz中的数据创建一个mytopo：data.tgz密钥。用户alice将具有完全访问权限，bob将具有读/写访问权限，其他所有人将具有读访问权限。</p>

<h3 id="making-dist-cache-files-accessible-to-topologies">制作dist。缓存拓扑可访问的文件</h3>

<p>一旦创建了Blob，我们就可以将其用于拓扑。通常，可以通过以下格式将关键字字符串包括在拓扑配置中来实现。快捷方式是使用<strong>-c</strong>命令在启动拓扑时在命令行上添加配置项：</p>
<div class="highlight"><pre><code class="language-" data-lang="">-c topology.blobstore.map='{"[KEY]":{"localname":"[VALUE]", "uncompress":[true|false]}}'
</code></pre></div>
<p>注意：请注意引号。</p>

<p>这样，拓扑文件就可以作为名称为[VALUE]的本地文件访问该缓存文件。<br>localname参数是可选的，如果省略，则本地缓存的文件将具有与[KEY]相同的名称。<br>uncompress参数是可选的，如果省略，本地缓存的文件将不会被解压缩。请注意，密钥字符串需要具有适当的类似于文件名的格式和扩展名，因此可以正确地将其解压缩。</p>

<h6 id="example">例：</h6>
<div class="highlight"><pre><code class="language-" data-lang="">storm jar /home/y/lib/storm-starter/current/storm-starter-jar-with-dependencies.jar org.apache.storm.starter.clj.word_count test_topo -c topology.blobstore.map='{"key1":{"localname":"blob_file", "uncompress":false},"key2":{}}'
</code></pre></div>
<p>注意：请注意引号。</p>

<p>在上面的示例中，我们启动了<em>word_count</em>拓扑（存储在<em>storm-starter-jar-with-dependencies.jar</em>文件中），并要求其有权访问以键字符串= <em>key1</em>存储的缓存文件。然后，该文件将作为本地文件<em>blob_file</em>可供拓扑访问，并且主管不会尝试解压缩该文件。请注意，在我们的示例中，文件的内容最初来自<em>README.txt</em> 。我们还要求以密钥字符串= <em>key2</em>存储的文件可被拓扑访问。由于省略了两个可选参数，因此此文件将获得本地名称= <em>key2</em> ，并且不会被解压缩。</p>

<h3 id="updating-a-cached-file">更新缓存的文件</h3>

<p>拓扑运行时，可能会更新缓存的文件。更新发生在最终的一致性模型中，在此模型中，主管每30秒轮询一次Nimbus，并更新其本地副本。在当前版本中，用户有责任检查是否有新文件可用。</p>

<p>要更新缓存的文件，请使用以下命令。内容来自FILE或STDIN。需要写访问权限才能更新缓存的文件。</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore update [-f|--file NEW_FILE] [KEYSTRING]
</code></pre></div>
<h6 id="example">例：</h6>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore update -f updates.txt key1
</code></pre></div>
<p>在以上示例中，即使拓扑仍通过名为<em>blob_file</em>的文件访问拓扑，也将向它们显示<em>updates.txt</em>文件的内容，而不是<em>README.txt</em> （来自上一个示例）。</p>

<h3 id="removing-a-cached-file">删除缓存的文件</h3>

<p>要从分布式缓存中删除文件，请使用以下命令。删除文件需要写访问权限。</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore delete [KEYSTRING]
</code></pre></div>
<h3 id="listing-blobs-currently-in-the-distributed-cache-blobstore">列出当前在分布式缓存blobstore中的Blob</h3>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore list [KEY...]
</code></pre></div>
<p>列出当前在Blobstore中的Blob</p>

<h3 id="reading-the-contents-of-a-blob">读取Blob的内容</h3>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore cat [-f|--file FILE] KEY
</code></pre></div>
<p>读取blob，然后将其写入文件或STDOUT。读取Blob需要读取权限。</p>

<h3 id="setting-the-access-control-for-a-blob">设置Blob的访问控制</h3>
<div class="highlight"><pre><code class="language-" data-lang="">set-acl [-s ACL] KEY
</code></pre></div>
<p>ACL的格式为[uo]：[用户名]：[r-] [w-] [a-]可以是逗号分隔的列表（需要管理员访问权限）。</p>

<h3 id="update-the-replication-factor-for-a-blob">更新Blob的复制因子</h3>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore replication --update --replication-factor 5 key1
</code></pre></div>
<h3 id="read-the-replication-factor-of-a-blob">读取斑点的复制因子</h3>
<div class="highlight"><pre><code class="language-" data-lang="">storm blobstore replication --read key1
</code></pre></div>
<h3 id="command-line-help">命令行帮助</h3>
<div class="highlight"><pre><code class="language-" data-lang="">storm help blobstore
</code></pre></div>
<h2 id="using-the-distributed-cache-api-from-java">使用Java中的分布式缓存API</h2>

<p>我们首先通过调用以下函数来获取ClientBlobStore对象：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Config</span> <span class="n">theconf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Config</span><span class="o">();</span>
<span class="n">theconf</span><span class="o">.</span><span class="na">putAll</span><span class="o">(</span><span class="n">Utils</span><span class="o">.</span><span class="na">readStormConfig</span><span class="o">());</span>
<span class="n">ClientBlobStore</span> <span class="n">clientBlobStore</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="na">getClientBlobStore</span><span class="o">(</span><span class="n">theconf</span><span class="o">);</span>
</code></pre></div>
<p>所需的Utils软件包可以通过以下方式导入：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.storm.utils.Utils</span><span class="o">;</span>
</code></pre></div>
<p>可以通过以下方式导入ClientBlobStore和其他与Blob相关的类：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.storm.blobstore.ClientBlobStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.storm.blobstore.AtomicOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.storm.blobstore.InputStreamWithMeta</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.storm.blobstore.BlobStoreAclHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.storm.generated.*</span><span class="o">;</span>
</code></pre></div>
<h3 id="creating-acls-to-be-used-for-blobs">创建用于Blob的ACL</h3>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">stringBlobACL</span> <span class="o">=</span> <span class="s">"u:username:rwa"</span><span class="o">;</span>
<span class="n">AccessControl</span> <span class="n">blobACL</span> <span class="o">=</span> <span class="n">BlobStoreAclHandler</span><span class="o">.</span><span class="na">parseAccessControl</span><span class="o">(</span><span class="n">stringBlobACL</span><span class="o">);</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">AccessControl</span><span class="o">&gt;</span> <span class="n">acls</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">AccessControl</span><span class="o">&gt;();</span>
<span class="n">acls</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">blobACL</span><span class="o">);</span> <span class="c1">// more ACLs can be added here</span>
<span class="n">SettableBlobMeta</span> <span class="n">settableBlobMeta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SettableBlobMeta</span><span class="o">(</span><span class="n">acls</span><span class="o">);</span>
<span class="n">settableBlobMeta</span><span class="o">.</span><span class="na">set_replication_factor</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> <span class="c1">// Here we can set the replication factor</span>
</code></pre></div>
<p>settableBlobMeta对象是下一步需要创建的Blob。</p>

<h3 id="creating-a-blob">创建斑点</h3>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">AtomicOutputStream</span> <span class="n">blobStream</span> <span class="o">=</span> <span class="n">clientBlobStore</span><span class="o">.</span><span class="na">createBlob</span><span class="o">(</span><span class="s">"some_key"</span><span class="o">,</span> <span class="n">settableBlobMeta</span><span class="o">);</span>
<span class="n">blobStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Some String or input data"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
<span class="n">blobStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div>
<p>请注意，这里的settableBlobMeta对象来自创建ACL的最后一步。建议对于非常大的文件，用户以较小的块（例如64 KB，最大1 MB的块）写入字节。</p>

<h3 id="updating-a-blob">更新一滴</h3>

<p>与创建Blob类似，但是我们以不同的方式获取AtomicOutputStream：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">blobKey</span> <span class="o">=</span> <span class="s">"some_key"</span><span class="o">;</span>
<span class="n">AtomicOutputStream</span> <span class="n">blobStream</span> <span class="o">=</span> <span class="n">clientBlobStore</span><span class="o">.</span><span class="na">updateBlob</span><span class="o">(</span><span class="n">blobKey</span><span class="o">);</span>
</code></pre></div>
<p>和以前一样，将字节流传递给返回的AtomicOutputStream。</p>

<h3 id="updating-the-acls-of-a-blob">更新Blob的ACL</h3>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">blobKey</span> <span class="o">=</span> <span class="s">"some_key"</span><span class="o">;</span>
<span class="n">AccessControl</span> <span class="n">updateAcl</span> <span class="o">=</span> <span class="n">BlobStoreAclHandler</span><span class="o">.</span><span class="na">parseAccessControl</span><span class="o">(</span><span class="s">"u:USER:--a"</span><span class="o">);</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">AccessControl</span><span class="o">&gt;</span> <span class="n">updateAcls</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">AccessControl</span><span class="o">&gt;();</span>
<span class="n">updateAcls</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">updateAcl</span><span class="o">);</span>
<span class="n">SettableBlobMeta</span> <span class="n">modifiedSettableBlobMeta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SettableBlobMeta</span><span class="o">(</span><span class="n">updateAcls</span><span class="o">);</span>
<span class="n">clientBlobStore</span><span class="o">.</span><span class="na">setBlobMeta</span><span class="o">(</span><span class="n">blobKey</span><span class="o">,</span> <span class="n">modifiedSettableBlobMeta</span><span class="o">);</span>

<span class="c1">//Now set write only</span>
<span class="n">updateAcl</span> <span class="o">=</span> <span class="n">BlobStoreAclHandler</span><span class="o">.</span><span class="na">parseAccessControl</span><span class="o">(</span><span class="s">"u:USER:-w-"</span><span class="o">);</span>
<span class="n">updateAcls</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">AccessControl</span><span class="o">&gt;();</span>
<span class="n">updateAcls</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">updateAcl</span><span class="o">);</span>
<span class="n">modifiedSettableBlobMeta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SettableBlobMeta</span><span class="o">(</span><span class="n">updateAcls</span><span class="o">);</span>
<span class="n">clientBlobStore</span><span class="o">.</span><span class="na">setBlobMeta</span><span class="o">(</span><span class="n">blobKey</span><span class="o">,</span> <span class="n">modifiedSettableBlobMeta</span><span class="o">);</span>
</code></pre></div>
<h3 id="updating-and-reading-the-replication-of-a-blob">更新和读取Blob的复制</h3>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">blobKey</span> <span class="o">=</span> <span class="s">"some_key"</span><span class="o">;</span>
<span class="n">BlobReplication</span> <span class="n">replication</span> <span class="o">=</span> <span class="n">clientBlobStore</span><span class="o">.</span><span class="na">updateBlobReplication</span><span class="o">(</span><span class="n">blobKey</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">replication_factor</span> <span class="o">=</span> <span class="n">replication</span><span class="o">.</span><span class="na">get_replication</span><span class="o">();</span>
</code></pre></div>
<p>注意：复制因子仅针对hdfs blobstore进行更新和反映</p>

<h3 id="reading-a-blob">读一滴</h3>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">blobKey</span> <span class="o">=</span> <span class="s">"some_key"</span><span class="o">;</span>
<span class="n">InputStreamWithMeta</span> <span class="n">blobInputStream</span> <span class="o">=</span> <span class="n">clientBlobStore</span><span class="o">.</span><span class="na">getBlob</span><span class="o">(</span><span class="n">blobKey</span><span class="o">);</span>
<span class="n">BufferedReader</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">blobInputStream</span><span class="o">));</span>
<span class="n">String</span> <span class="n">blobContents</span> <span class="o">=</span>  <span class="n">r</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
</code></pre></div>
<h3 id="deleting-a-blob">删除斑点</h3>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">blobKey</span> <span class="o">=</span> <span class="s">"some_key"</span><span class="o">;</span>
<span class="n">clientBlobStore</span><span class="o">.</span><span class="na">deleteBlob</span><span class="o">(</span><span class="n">blobKey</span><span class="o">);</span>
</code></pre></div>
<h3 id="getting-a-list-of-blob-keys-already-in-the-blobstore">获取Blob存储区中已存在的Blob键列表</h3>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Iterator</span> <span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stringIterator</span> <span class="o">=</span> <span class="n">clientBlobStore</span><span class="o">.</span><span class="na">listKeys</span><span class="o">();</span>
</code></pre></div>
<h2 id="appendix-a">附录A</h2>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="n">String</span> <span class="n">baseDir</span><span class="o">);</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">AtomicOutputStream</span> <span class="nf">createBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">SettableBlobMeta</span> <span class="n">meta</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyAlreadyExistsException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">AtomicOutputStream</span> <span class="nf">updateBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">ReadableBlobMeta</span> <span class="nf">getBlobMeta</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">setBlobMeta</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">SettableBlobMeta</span> <span class="n">meta</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">deleteBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">InputStreamWithMeta</span> <span class="nf">getBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">listKeys</span><span class="o">(</span><span class="n">Subject</span> <span class="n">who</span><span class="o">);</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">BlobReplication</span> <span class="nf">getBlobReplication</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">BlobReplication</span> <span class="nf">updateBlobReplication</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">replication</span><span class="o">,</span> <span class="n">Subject</span> <span class="n">who</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">,</span> <span class="n">IOException</span>
</code></pre></div>
<h2 id="appendix-b">附录B</h2>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">);</span>

<span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">AtomicOutputStream</span> <span class="nf">createBlobToExtend</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">SettableBlobMeta</span> <span class="n">meta</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyAlreadyExistsException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">AtomicOutputStream</span> <span class="nf">updateBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">ReadableBlobMeta</span> <span class="nf">getBlobMeta</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">setBlobMetaToExtend</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">SettableBlobMeta</span> <span class="n">meta</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">deleteBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">InputStreamWithMeta</span> <span class="nf">getBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">listKeys</span><span class="o">();</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">watchBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">IBlobWatcher</span> <span class="n">watcher</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">stopWatchingBlob</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">BlobReplication</span> <span class="nf">getBlobReplication</span><span class="o">(</span><span class="n">String</span> <span class="n">Key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="n">BlobReplication</span> <span class="nf">updateBlobReplication</span><span class="o">(</span><span class="n">String</span> <span class="n">Key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">replication</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">AuthorizationException</span><span class="o">,</span> <span class="n">KeyNotFoundException</span>
</code></pre></div>
<h2 id="appendix-c">附录C</h2>
<div class="highlight"><pre><code class="language-" data-lang="">service Nimbus {
...
string beginCreateBlob(1: string key, 2: SettableBlobMeta meta) throws (1: AuthorizationException aze, 2: KeyAlreadyExistsException kae);

string beginUpdateBlob(1: string key) throws (1: AuthorizationException aze, 2: KeyNotFoundException knf);

void uploadBlobChunk(1: string session, 2: binary chunk) throws (1: AuthorizationException aze);

void finishBlobUpload(1: string session) throws (1: AuthorizationException aze);

void cancelBlobUpload(1: string session) throws (1: AuthorizationException aze);

ReadableBlobMeta getBlobMeta(1: string key) throws (1: AuthorizationException aze, 2: KeyNotFoundException knf);

void setBlobMeta(1: string key, 2: SettableBlobMeta meta) throws (1: AuthorizationException aze, 2: KeyNotFoundException knf);

BeginDownloadResult beginBlobDownload(1: string key) throws (1: AuthorizationException aze, 2: KeyNotFoundException knf);

binary downloadBlobChunk(1: string session) throws (1: AuthorizationException aze);

void deleteBlob(1: string key) throws (1: AuthorizationException aze, 2: KeyNotFoundException knf);

ListBlobsResult listBlobs(1: string session);

BlobReplication getBlobReplication(1: string key) throws (1: AuthorizationException aze, 2: KeyNotFoundException knf);

BlobReplication updateBlobReplication(1: string key, 2: i32 replication) throws (1: AuthorizationException aze, 2: KeyNotFoundException knf);
...
}

struct BlobReplication {
1: required i32 replication;
}

exception AuthorizationException {
 1: required string msg;
}

exception KeyNotFoundException {
 1: required string msg;
}

exception KeyAlreadyExistsException {
 1: required string msg;
}

enum AccessControlType {
 OTHER = 1,
 USER = 2
 //eventually ,GROUP=3
}

struct AccessControl {
 1: required AccessControlType type;
 2: optional string name; //Name of user or group in ACL
 3: required i32 access; //bitmasks READ=0x1, WRITE=0x2, ADMIN=0x4
}

struct SettableBlobMeta {
 1: required list&lt;AccessControl&gt; acl;
 2: optional i32 replication_factor
}

struct ReadableBlobMeta {
 1: required SettableBlobMeta settable;
 //This is some indication of a version of a BLOB.  The only guarantee is
 // if the data changed in the blob the version will be different.
 2: required i64 version;
}

struct ListBlobsResult {
 1: required list&lt;string&gt; keys;
 2: required string session;
}

struct BeginDownloadResult {
 //Same version as in ReadableBlobMeta
 1: required i64 version;
 2: required string session;
 3: optional i64 data_size;
}
</code></pre></div></div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>