<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>流API概述</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=5">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">流API概述</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><ul>
<li><a href="#concepts">概念</a>

<ul>
<li><a href="#streambuilder">流生成器</a></li>
<li><a href="#valuemapper">价值映射器</a></li>
</ul></li>
<li><a href="#streamapis">流API</a>

<ul>
<li><a href="#basictransformations">基本转换</a>

<ul>
<li><a href="#filter">过滤</a></li>
<li><a href="#map">地图</a></li>
<li><a href="#flatmap">平面图</a></li>
</ul></li>
<li><a href="#windowing">加窗</a></li>
<li><a href="#keyvaluepairs">转换为键值对</a>

<ul>
<li><a href="#mapflatmaptopair">mapToPair</a></li>
<li><a href="#mapflatmaptopair">flatMapToPair</a></li>
</ul></li>
<li><a href="#aggregations">集合体</a>

<ul>
<li><a href="#aggregatereduce">骨料</a></li>
<li><a href="#aggregatereduce">降低</a></li>
<li><a href="#aggregatereducebykey">aggregateByKey</a></li>
<li><a href="#aggregatereducebykey">reduceByKey</a></li>
<li><a href="#groupbykey">groupByKey</a></li>
<li><a href="#countbykey">countByKey</a></li>
</ul></li>
<li><a href="#repartition">分区</a></li>
<li><a href="#outputoperations">输出操作</a>

<ul>
<li><a href="#print">打印</a></li>
<li><a href="#peek">窥视</a></li>
<li><a href="#foreach">每次</a></li>
<li><a href="#to">至</a></li>
</ul></li>
<li><a href="#branching">科</a></li>
<li><a href="#joins">加入</a></li>
<li><a href="#cogroupbykey">CoGroupByKey</a></li>
<li><a href="#state">州</a>

<ul>
<li><a href="#updatestatebykey">updateStateByKey</a></li>
<li><a href="#statequery">状态查询</a></li>
</ul></li>
</ul></li>
<li><a href="#guarantees">保证金</a><br></li>
<li><a href="#example">例</a></li>
</ul>

<p>从历史上看，Storm提供了Spout和Bolt API来表达流计算。尽管这些api使用起来非常简单，但没有可重用的结构来表达常见的流操作，例如过滤，转换，窗口，联接，聚合等。</p>

<p>流API在Storm的喷嘴和螺栓的基础上构建，以提供用于表达流计算的类型化API，并支持功能样式操作，例如map-reduce。</p>

<h1 id="concepts"><a name="concepts"></a>概念</h1>

<p>从概念上讲<code>Stream</code>可以认为是流经管道的消息流。一种<code>Stream</code>可以通过从诸如spout之类的源中读取消息，或通过转换其他流来生成消息。例如，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// imports</span>
<span class="kn">import</span> <span class="nn">org.apache.storm.streams.Stream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.storm.streams.StreamBuilder</span><span class="o">;</span>
<span class="o">...</span>

<span class="n">StreamBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StreamBuilder</span><span class="o">();</span>

<span class="c1">// a stream of sentences obtained from a source spout</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sentences</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">RandomSentenceSpout</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="n">tuple</span> <span class="o">-&gt;</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>

<span class="c1">// a stream of words obtained by transforming (splitting) the stream of sentences</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="n">sentences</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)));</span>

<span class="c1">// output operation that prints the words to console</span>
<span class="n">words</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">w</span><span class="o">));</span>
</code></pre></div>
<p>大多数流操作都接受参数，这些参数通常通过lambda表达式来描述用户指定的行为，例如<code>s -> Arrays.asList(s.split(" "))</code>如上例所示。</p>

<p>一种<code>Stream</code>支持两种操作，</p>

<ol>
<li>从当前流产生另一个流的<strong>转换</strong> （例如<code>flatMap</code>上例中的操作）</li>
<li>产生结果的<strong>输出操作</strong> 。 （如<code>forEach</code>以上示例中的操作）。</li>
</ol>

<h2 id="stream-builder"><a name="streambuilder"></a>流生成器</h2>

<p><code>StreamBuilder</code>提供构建器API来创建新的流。通常，喷嘴形成流的源。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">StreamBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StreamBuilder</span><span class="o">();</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="n">sentences</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">TestSentenceSpout</span><span class="o">());</span>
</code></pre></div>
<p>的<code>StreamBuilder</code>跟踪通过Stream表示的操作的总体流程。然后可以通过以下方式创建Storm拓扑<code>build()</code>并通过普通的风暴拓扑提交<code>StormSubmitter</code> 。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">StormSubmitter</span><span class="o">.</span><span class="na">submitTopologyWithProgressBar</span><span class="o">(</span><span class="s">"test"</span><span class="o">,</span> <span class="k">new</span> <span class="n">Config</span><span class="o">(),</span> <span class="n">streamBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
</code></pre></div>
<h2 id="value-mapper"><a name="valuemapper"></a>价值映射器</h2>

<p>值映射器可用于从喷嘴发出的元组中提取特定字段，以生成类型化的值流。值映射器作为参数传递给<code>StreamBuilder.newStream</code> 。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">StreamBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StreamBuilder</span><span class="o">();</span>

<span class="c1">// extract the first field from the tuple to get a Stream&lt;String&gt; of sentences</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sentences</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">TestWordSpout</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ValueMapper</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">));</span>
</code></pre></div>
<p>Storm通过以下方式提供了强类型的元组<code>Pair</code>和Tuple类（Tuple3到Tuple10）。一个人可以使用<code>TupleValueMapper</code>生成如下所示的类型化元组流。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// extract first three fields of the tuple emitted by the spout to produce a stream of typed tuples.</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">TestSpout</span><span class="o">(),</span> <span class="n">TupleValueMappers</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div>
<h1 id="stream-apis"><a name="streamapis"></a>流API</h1>

<p>Storm的流式api（在<a href="../storm-client/src/jvm/org/apache/storm/streams/Stream.java">Stream</a>和<a href="../storm-client/src/jvm/org/apache/storm/streams/PairStream.java">PairStream中</a>定义）目前支持各种操作，例如转换，过滤器，窗口，聚合，分支，联接，有状态，输出和调试操作。</p>

<h2 id="basic-transformations"><a name="basictransformations"></a>基本转换</h2>

<h3 id="filter"><a name="filter"></a>过滤</h3>

<p><code>filter</code>返回由与给定匹配的流的元素组成的流<code>Predicate</code> （其谓词返回true）。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">logs</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">logs</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">line</span> <span class="o">-&gt;</span> <span class="n">line</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"ERROR"</span><span class="o">));</span>
</code></pre></div>
<p>在上面的示例中，带有“ ERROR”的日志行被过滤到错误流中，然后可以对其进行进一步处理。</p>

<h3 id="map"><a name="map"></a>地图</h3>

<p><code>map</code>返回一个流，该流包括将给定的映射函数应用于该流的值的结果。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordLengths</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">length</span><span class="o">);</span>
</code></pre></div>
<p>该示例通过将String.length函数应用于每个值，从单词流中生成单词长度的流。注意，映射操作的结果流的类型可以与原始流的类型不同。</p>

<h3 id="flatmap"><a name="flatmap"></a> flatMap</h3>

<p><code>flatMap</code>返回一个流，该流包含将流的每个值替换为通过将提供的映射函数应用于每个值所产生的内容而得到的结果。这类似于map，但是每个值都可以映射为0个或多个值。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sentences</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="n">sentences</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)));</span>
</code></pre></div>
<p>在上面的示例中，lambda函数将流中的每个值拆分为单词列表，flatMap函数从中生成一个扁平的单词流。</p>

<h2 id="windowing"><a name="windowing"></a>加窗</h2>

<p>一种<code>window</code>操作将生成窗口流，该窗口流由window参数指定的属于窗口内的元素组成。通过Stream api支持基础窗口螺栓中支持的所有窗口选项。</p>

<p><code>Stream<T> windowedStream = stream.window(Window<?, ?> windowConfig);</code></p>

<p>windowConfig参数根据持续时间或事件计数指定窗口配置，例如滑动窗口或滚动窗口。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// time based sliding window</span>
<span class="n">stream</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">SlidingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">minutes</span><span class="o">(</span><span class="mi">10</span><span class="o">),</span> <span class="n">Duration</span><span class="o">.</span><span class="na">minutes</span><span class="o">(</span><span class="mi">1</span><span class="o">)));</span>

<span class="c1">// count based sliding window</span>
<span class="n">stream</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">SlidingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Count</span><span class="o">.(</span><span class="mi">10</span><span class="o">),</span> <span class="n">Count</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2</span><span class="o">)));</span>

<span class="c1">// tumbling window</span>
<span class="n">stream</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>

<span class="c1">// specifying timestamp field for event time based processing and a late tuple stream.</span>
<span class="n">stream</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">withTimestampField</span><span class="o">(</span><span class="s">"ts"</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">withLateTupleStream</span><span class="o">(</span><span class="s">"late_events"</span><span class="o">));</span>
</code></pre></div>
<p>窗口操作将值的连续流分成子集，并且对于执行诸如联接和聚合之类的操作是必需的。</p>

<h2 id="transformation-to-key-value-pairs"><a name="keyvaluepairs"></a>转换为键值对</h2>

<h3 id="maptopair-and-flatmaptopair"><a name="mapflatmaptopair"></a> mapToPair和flatMapToPair</h3>

<p>这些操作将值流转换为键值对流。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="err">…</span> <span class="c1">// 1, 2, 3, 4, ... </span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">squares</span> <span class="o">=</span> <span class="n">integers</span><span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">));</span> <span class="c1">// (1, 1), (2, 4), (3, 9), (4, 16), ...</span>
</code></pre></div>
<p>键值对流是groupByKey，aggregateByKey，join等操作所必需的。</p>

<h2 id="aggregations"><a name="aggregations"></a>集合体</h2>

<p>汇总操作汇总流中的值（或键值）。通常，聚合操作是在窗口流上执行的，其中在每次窗口激活时都会发出聚合结果。</p>

<h3 id="aggregate-and-reduce"><a name="aggregatereduce"></a>聚集并减少</h3>

<p><code>aggregate</code>和<code>reduce</code>计算全局聚合，即将所有分区上的值转发给单个任务以计算聚合。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="err">…</span>
<span class="c1">// aggregate the numbers and produce a stream of last 10 sec sums.</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">sums</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">10</span><span class="o">)).</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Sum</span><span class="o">());</span>

<span class="c1">// the last 10 sec sums computed using reduce</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">sums</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">window</span><span class="o">(...).</span><span class="na">reduce</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
</code></pre></div>
<p><code>aggreagate</code>和<code>reduce</code>聚集结果的计算方式不同。</p>

<p>一种<code>reduce</code>运算会重复应用给定的reducer并将两个值减少为一个值，直到仅剩一个值为止。对于所有类型的合并（例如avg），这可能都不可行或不容易。</p>

<p>一个<code>aggregate</code>操作确实减少了。可变的折减会在处理值时将结果累加到累加器。</p>

<p>聚合操作（聚合和缩减）会在进行网络改组之前尽可能自动进行本地聚合，以最大程度地减少通过网络传输的消息量。例如，为了计算总和，将计算每个分区的部分总和，并且只有部分总和会通过网络传输到目标螺栓，在此目标中，将部分总和合并以生成最终总和。一种<code>CombinerAggregator</code>接口用作参数<code>aggregate</code>启用它。</p>

<p>例如<code>Sum</code> （在上面的示例中作为aggregate的参数传递）可以实现为<code>CombinerAggregator</code>如下。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Sum</span> <span class="kd">implements</span> <span class="n">CombinerAggregator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// The initial value of the sum</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Updates the sum by adding the value (this could be a partial sum)</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">apply</span><span class="o">(</span><span class="n">Long</span> <span class="n">aggregate</span><span class="o">,</span> <span class="n">Long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">aggregate</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// merges the partial sums</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">merge</span><span class="o">(</span><span class="n">Long</span> <span class="n">accum1</span><span class="o">,</span> <span class="n">Long</span> <span class="n">accum2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">accum1</span> <span class="o">+</span> <span class="n">accum2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// extract result from the accumulator (here the accumulator and result is the same)</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">result</span><span class="o">(</span><span class="n">Long</span> <span class="n">accum</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">accum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h3 id="aggregatebykey-and-reducebykey"><a name="aggregatereducebykey"></a> AggregateByKey和reduceByKey</h3>

<p>这些类似于聚合和归约操作，但每个键都进行聚合。</p>

<p><code>aggregateByKey</code>使用给定的Aggregator聚合流中每个键的值。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...</span>                                              <span class="c1">// a windowed stream of words</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">w</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>     <span class="c1">// convert to a stream of (word, 1) pairs</span>
                                       <span class="o">.</span><span class="na">aggregateByKey</span><span class="o">(</span><span class="k">new</span> <span class="n">Count</span><span class="o">&lt;&gt;());</span>  <span class="c1">// compute counts per word</span>
</code></pre></div>
<p><code>reduceByKey</code>通过重复应用缩减程序，对此流的每个键的值执行缩减。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...</span>                                              <span class="c1">// a windowed stream of words</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">w</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>     <span class="c1">// convert to a stream of (word, 1) pairs</span>
                                       <span class="o">.</span><span class="na">reduceByKey</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>   <span class="c1">// compute counts per word</span>
</code></pre></div>
<p>像全局聚合/归约一样，将计算每个分区的局部聚合（每个键），并将部分结果发送到目标螺栓，在此目标中，将部分结果合并以生成最终聚合。</p>

<h3 id="groupbykey"><a name="groupbykey"></a> groupByKey</h3>

<p><code>groupByKey</code>在键值对流上返回一个新流，该流中的值按键分组。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// a stream of (user, score) pairs e.g. ("alice", 10), ("bob", 15), ("bob", 20), ("alice", 11), ("alice", 13)</span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="o">...</span> 

<span class="c1">// list of scores per user in the last window, e.g. ("alice", [10, 11, 13]), ("bob", [15, 20])</span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">userScores</span> <span class="o">=</span>  <span class="n">scores</span><span class="o">.</span><span class="na">window</span><span class="o">(...).</span><span class="na">groupByKey</span><span class="o">();</span> 
</code></pre></div>
<h3 id="countbykey"><a name="countbykey"></a> countByKey</h3>

<p><code>countByKey</code>计算此流的每个键的值。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="o">...</span>                                              <span class="c1">// a windowed stream of words</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">w</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>     <span class="c1">// convert to a stream of (word, 1) pairs</span>
                                       <span class="o">.</span><span class="na">countByKey</span><span class="o">();</span>                   <span class="c1">// compute counts per word</span>
</code></pre></div>
<p>内部地<code>countByKey</code>用途<code>aggregateByKey</code>计算计数。</p>

<h2 id="repartition"><a name="repartition"></a>分区</h2>

<p>一种<code>repartition</code>操作将对当前流进行重新分区，并返回具有指定数量的分区的新流。对结果流的进一步操作将在该并行级别上执行。重新分配可用于增加或减少流中操作的并行性。</p>

<p>在创建流时，也可以指定分区的初始数量（通过StreamBuilder.newStream）</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Stream 's1' will have 2 partitions and operations on s1 will execute at this level of parallelism</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">TestWordSpout</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ValueMapper</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">),</span> <span class="mi">2</span><span class="o">);</span>

<span class="c1">// Stream 's2' and further operations will have three partitions</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">function1</span><span class="o">).</span><span class="na">repartition</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

<span class="c1">// perform a map operation on s2 and print the result</span>
<span class="n">s2</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">function2</span><span class="o">).</span><span class="na">print</span><span class="o">();</span>
</code></pre></div>
<p>注意： <code>repartition</code>操作意味着网络传输。在上面的示例中，第一个映射操作（函数1）将以2的并行度执行（在s1的两个分区上），而第二个映射操作（函数2）将以3的并行度执行（在s2的三个分区上） 。这也意味着第一和第二映射操作必须在两个单独的螺栓上执行，并且涉及网络传输。</p>

<h2 id="output-operations"><a name="outputoperations"></a>输出操作</h2>

<p>输出操作将流中的转换后的值推送到控制台，外部接收器（如数据库，文件或什至Storm螺栓）。</p>

<h3 id="print"><a name="print"></a>打印</h3>

<p><code>print</code>将流中的值打印到控制台。例如，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// transforms words to uppercase and prints to the console</span>
<span class="n">words</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">).</span><span class="na">print</span><span class="o">();</span>
</code></pre></div>
<h3 id="peek"><a name="peek"></a>窥视</h3>

<p><code>peek</code>返回由流元素组成的流，并在从结果流中消耗掉每个元素时另外对每个元素执行提供的操作。这可用于“检查”流中任何阶段流动的值。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(...).</span><span class="na">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)))</span>
       <span class="c1">// print the results of the flatMap operation as the values flow across the stream.</span>
      <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
      <span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">Pair</span><span class="o">&lt;&gt;(</span><span class="n">w</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
</code></pre></div>
<h3 id="foreach"><a name="foreach"></a>每次</h3>

<p>这是最通用的输出操作，可用于对流中的每个值执行任意代码，例如将结果存储到外部数据库，文件等中。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// log it</span>
    <span class="n">LOG</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="c1">// store the value into a db and so on...</span>
    <span class="n">statement</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">(..);</span>
  <span class="o">}</span>
<span class="o">);</span>
</code></pre></div>
<h3 id="to"><a name="to"></a>至</h3>

<p>这样就可以将现有的螺栓插入水槽中。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// The redisBolt is a standard storm bolt</span>
<span class="n">IRichBolt</span> <span class="n">redisBolt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RedisStoreBolt</span><span class="o">(</span><span class="n">poolConfig</span><span class="o">,</span> <span class="n">storeMapper</span><span class="o">);</span>
<span class="o">...</span>
<span class="c1">// generate the word counts and store it in redis using redis bolt</span>
<span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">TestWordSpout</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ValueMapper</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">))</span>
       <span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
       <span class="o">.</span><span class="na">countByKey</span><span class="o">()</span>
       <span class="c1">// the (word, count) pairs are forwarded to the redisBolt which stores it in redis</span>
       <span class="o">.</span><span class="na">to</span><span class="o">(</span><span class="n">redisBolt</span><span class="o">);</span>
</code></pre></div>
<p>请注意，这仅根据螺栓提供的内容提供保证。</p>

<h2 id="branch"><a name="branching"></a>科</h2>

<p>一种<code>branch</code>操作可用于表示流中的“如果-则-否则”逻辑。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;[]</span> <span class="n">streams</span>  <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">branch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;...</span> <span class="n">predicates</span><span class="o">)</span>
</code></pre></div>
<p>谓词以给定的顺序应用于流的值，并且基于匹配的第一个谓词将结果转发到相应的（基于索引）结果流。如果没有一个谓词与某个值匹配，则将该值删除。</p>

<p>例如，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[]</span> <span class="n">streams</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">RandomIntegerSpout</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ValueMapper</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">))</span>
                                   <span class="o">.</span><span class="na">branch</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> 
                                          <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">evenNumbers</span> <span class="o">=</span> <span class="n">streams</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">oddNumbers</span> <span class="o">=</span> <span class="n">streams</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
</code></pre></div>
<h2 id="joins"><a name="joins"></a>加入</h2>

<p>一种<code>join</code>操作将一个流的值与来自另一个流的具有相同键的值合并在一起。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PairStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">squares</span> <span class="o">=</span> <span class="err">…</span> <span class="c1">// (1, 1), (2, 4), (3, 9) ...</span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">cubes</span> <span class="o">=</span> <span class="err">…</span> <span class="c1">// (1, 1), (2, 8), (3, 27) ...</span>

<span class="c1">// join the sqaures and cubes stream to produce (1, [1, 1]), (2, [4, 8]), (3, [9, 27]) ...</span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="n">joined</span> <span class="o">=</span> <span class="n">squares</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))).</span><span class="na">join</span><span class="o">(</span><span class="n">cubes</span><span class="o">);</span>
</code></pre></div>
<p>联接通常在窗口流上调用，联接到达当前窗口中每个流上的键值。在其上调用联接的流的并行性被转发到联接的流。可选的<code>ValueJoiner</code>可以作为参数传递来进行联接，以指定如何将每个匹配键的两个值联接在一起（默认行为是返回一个<code>Pair</code>来自两个流的值）。</p>

<p>支持左，右和完全外部联接。</p>

<h2 id="cogroupbykey"><a name="cogroupbykey"></a> CoGroupByKey</h2>

<p><code>coGroupByKey</code>将此流的值与其他流中具有相同键的值进行分组。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// a stream of (key, value) pairs e.g. (k1, v1), (k2, v2), (k2, v3)</span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">stream1</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// another stream of (key, value) pairs e.g. (k1, x1), (k1, x2), (k3, x3)</span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">stream2</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// the co-grouped values per key in the last window, e.g. (k1, ([v1], [x1, x2]), (k2, ([v2, v3], [])), (k3, ([], [x3]))</span>
<span class="n">PairStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">coGroupedStream</span> <span class="o">=</span>  <span class="n">stream1</span><span class="o">.</span><span class="na">window</span><span class="o">(...).</span><span class="na">coGroupByKey</span><span class="o">(</span><span class="n">stream2</span><span class="o">);</span>
</code></pre></div>
<h2 id="state"><a name="state"></a>州</h2>

<p>Storm为应用程序提供了API，以保存和更新其计算状态以及查询状态。</p>

<h3 id="updatestatebykey"><a name="updatestatebykey"></a> updateStateByKey</h3>

<p><code>updateStateByKey</code>通过将给定的状态更新功能应用于键的先前状态和新值来更新状态。 <code>updateStateByKey</code>可以使用状态的初始值和状态更新功能来调用，也可以直接提供<code>StateUpdater</code>实施。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PairStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="o">...</span>
<span class="c1">// Update the word counts in the state; here the first argument 0L is the initial value for the state and </span>
<span class="c1">// the second argument is a function that adds the count to the current value in the state.</span>
<span class="n">StreamState</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">streamState</span> <span class="o">=</span> <span class="n">wordCounts</span><span class="o">.</span><span class="na">updateStateByKey</span><span class="o">(</span><span class="mi">0L</span><span class="o">,</span> <span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">state</span> <span class="o">+</span> <span class="n">count</span><span class="o">)</span>
<span class="n">streamState</span><span class="o">.</span><span class="na">toPairStream</span><span class="o">().</span><span class="na">print</span><span class="o">();</span>
</code></pre></div>
<p>状态值可以是任何类型。在上面的示例中，其类型<code>Long</code>并存储字数。</p>

<p>内部Storm使用状态螺栓存储状态。风暴配置<code>topology.state.provider</code>可以用来选择状态提供程序的实现。例如将此设置为<code>org.apache.storm.redis.state.RedisKeyValueStateProvider</code>用于基于Redis的状态存储。</p>

<h3 id="statequery"><a name="statequery"></a>状态查询</h3>

<p><code>stateQuery</code>可用于查询状态（由更新<code>updateStateByKey</code> ）。的<code>StreamState</code> updateStateByKey操作返回的值必须用于查询流状态。流中的值用作查询状态的键。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
<span class="c1">// The stream of words emitted by the QuerySpout is used as the keys to query the state.</span>
<span class="n">builder</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">QuerySpout</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ValueMapper</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">))</span>
<span class="c1">// Queries the state and emits the matching (key, value) as results. </span>
<span class="c1">// The stream state returned by updateStateByKey is passed as the argument to stateQuery.</span>
<span class="o">.</span><span class="na">stateQuery</span><span class="o">(</span><span class="n">streamState</span><span class="o">).</span><span class="na">print</span><span class="o">();</span>
</code></pre></div>
<h1 id="guarantees"><a name="guarantees"></a>保证金</h1>

<p>现在，使用Stream API构建的拓扑<strong>至少可以</strong>保证<strong>一次</strong> 。</p>

<p>请注意，只有<code>updateStateByKey</code>该操作当前在基础StatefulBolt上执行。其他有状态操作（联接，窗口，聚合等）在IRichBolt上执行并将其状态存储在内存中。它依靠风暴确认和重播机制来重建状态。</p>

<p>将来，Stream API的基础框架将得到增强，以提供<strong>恰好一次的</strong>保证。</p>

<h1 id="example"><a name="example"></a>例</h1>

<p>这是使用Stream API表示的字数拓扑，</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">StreamBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StreamBuilder</span><span class="o">();</span>

<span class="n">builder</span>
   <span class="c1">// A stream of random sentences with two partitions</span>
   <span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="k">new</span> <span class="n">RandomSentenceSpout</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ValueMapper</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="mi">0</span><span class="o">),</span> <span class="mi">2</span><span class="o">)</span>
   <span class="c1">// a two seconds tumbling window</span>
   <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span>
   <span class="c1">// split the sentences to words</span>
   <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)))</span>
   <span class="c1">// create a stream of (word, 1) pairs</span>
   <span class="o">.</span><span class="na">mapToPair</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
   <span class="c1">// compute the word counts in the last two second window</span>
   <span class="o">.</span><span class="na">countByKey</span><span class="o">()</span>
   <span class="c1">// print the results to stdout</span>
   <span class="o">.</span><span class="na">print</span><span class="o">();</span>
</code></pre></div>
<p>的<code>RandomSentenceSpout</code>是常规的风暴喷口，连续发出随机句子。句子流被分为两个第二窗口，每个窗口内的单词计数都被计算并打印出来。</p>

<p>然后可以像常规拓扑一样提交流，如下所示。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">  <span class="n">Config</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Config</span><span class="o">();</span>
  <span class="n">config</span><span class="o">.</span><span class="na">setNumWorkers</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
  <span class="n">StormSubmitter</span><span class="o">.</span><span class="na">submitTopologyWithProgressBar</span><span class="o">(</span><span class="s">"topology-name"</span><span class="o">,</span> <span class="n">config</span><span class="o">,</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
</code></pre></div>
<p><a href="../examples/storm-starter/src/jvm/org/apache/storm/starter/streams">Storm-starter</a>下提供了更多示例，可帮助您入门。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>