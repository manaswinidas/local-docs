<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>三叉戟教程</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=5">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">三叉戟教程</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><p>Trident是用于在Storm之上进行实时计算的高级抽象。它使您可以无缝混合高吞吐量（每秒数百万条消息），状态流处理和低延迟分布式查询。如果您熟悉Pig或Cascading等高级批处理工具，则Trident的概念将非常熟悉-Trident具有联接，聚合，分组，功能和过滤器。除了这些之外，Trident还添加了用于在任何数据库或持久性存储之上进行有状态的增量处理的原语。Trident具有一致的，精确的一次语义，因此很容易推断出Trident拓扑。</p>

<p>Trident是在早期的努力下发展起来的，旨在为Storm提供一次准确的保证。尽管Storm中不再提供此早期的API，但是该<a href="Transactional-topologies.html">文档</a>对Trident使用的一些概念进行了简要介绍，并且可能值得作为Trident文档的附录阅读。</p>

<h2 id="illustrative-example">说明性例子</h2>

<p>让我们看一下Trident的一个示例。本示例将做两件事：</p>

<ol>
<li>根据句子输入流计算流字数</li>
<li>实施查询以获取单词列表的计数总和</li>
</ol>

<p>为了便于说明，本示例将从以下来源读取无限的句子流：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">FixedBatchSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FixedBatchSpout</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="mi">3</span><span class="o">,</span>
               <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"the cow jumped over the moon"</span><span class="o">),</span>
               <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"the man went to the store and bought some candy"</span><span class="o">),</span>
               <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"four score and seven years ago"</span><span class="o">),</span>
               <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"how many apples can you eat"</span><span class="o">));</span>
<span class="n">spout</span><span class="o">.</span><span class="na">setCycle</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</code></pre></div>
<p>该喷口反复遍历该组句子以产生句子流。这是执行计算中流字计数部分的代码：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>        
<span class="n">TridentState</span> <span class="n">wordCounts</span> <span class="o">=</span>
     <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">)</span>
       <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">MemoryMapState</span><span class="o">.</span><span class="na">Factory</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>                
       <span class="o">.</span><span class="na">parallelismHint</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
</code></pre></div>
<p>让我们逐行浏览代码。首先创建一个TridentTopology对象，该对象公开用于构造Trident计算的接口。TridentTopology有一个称为newStream的方法，该方法在拓扑结构中从输入源读取数据以创建新的数据流。在这种情况下，输入源就是之前定义的FixedBatchSpout。输入源也可以是队列代理，例如Kestrel或Kafka。Trident跟踪Zookeeper中每个输入源的少量状态（有关已消耗的元数据），并且此处的“ spout1”字符串指定Zookeeper中Trident应当保留该元数据的节点。</p>

<p>Trident将流作为小批元组处理。例如，句子的传入流可能被分为以下几批：</p>

<p><img src="images/batched-stream.png" alt="批处理流"></p>

<p>通常，这些小批量的大小将成千上万个元组，具体取决于您的传入吞吐量。</p>

<p>Trident提供了完整的批处理API，可以处理那些小批量。该API与您在Hadoop的高级抽象（例如Pig或Cascading）中看到的非常相似：您可以进行分组依据，联接，聚合，运行函数，运行过滤器等。当然，单独处理每个小批量并不是什么有趣的事，因此Trident提供了用于在批之间进行聚合并将这些聚合持久存储的功能-无论是在内存中，在Memcached中，在Cassandra中还是在其他存储中。最后，Trident具有用于查询实时状态源的一流功能。该状态可以由Trident更新（例如在此示例中），也可以是独立的状态源。</p>

<p>回到该示例，喷口发出一个流，其中包含一个称为“句子”的字段。拓扑定义的下一行将拆分功能应用于流中的每个元组，并采用“句子”字段并将其拆分为单词。每个句子元组都可能创建许多单词元组–例如，句子“牛越过月亮”创建了六个“单词”元组。这是Split的定义：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Split</span> <span class="kd">extends</span> <span class="n">BaseFunction</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">String</span> <span class="n">sentence</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
       <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">word:</span> <span class="n">sentence</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span> <span class="o">{</span>
           <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>                
       <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>如您所见，这确实很简单。它只是简单地抓住句子，将其在空白处分割，然后为每个单词发出一个元组。</p>

<p>拓扑的其余部分将计算字数，并将结果永久存储。首先，将流按“单词”字段分组。然后，使用Count聚合器持久地聚合每个组。persistentAggregate函数知道如何在状态源中存储和更新聚合结果。在此示例中，单词计数保留在内存中，但是可以轻松地互换以使用Memcached，Cassandra或任何其他持久性存储。交换此拓扑以将计数存储在Memcached中非常简单，只需将其替换为persistentAggregate行（使用trident <a href="https://github.com/nathanmarz/trident-memcached">-memcached</a> ），其中“ serverLocations”是Memcached集群的主机/端口列表：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="n">MemcachedState</span><span class="o">.</span><span class="na">transactional</span><span class="o">(</span><span class="n">serverLocations</span><span class="o">),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>        
<span class="n">MemcachedState</span><span class="o">.</span><span class="na">transactional</span><span class="o">()</span>
</code></pre></div>
<p>persistentAggregate存储的值表示流曾经发出的所有批次的聚合。</p>

<p>关于Trident的一件很酷的事情是，它具有完全的容错性，一次处理能力。这使您可以轻松推断实时处理。Trident以某种方式保持状态，这样，如果发生故障并且需要重试，它将不会对同一源数据执行对数据库的多次更新。</p>

<p>persistentAggregate方法将Stream转换为TridentState对象。在这种情况下，TridentState对象表示所有单词计数。我们将使用该TridentState对象来实现计算的分布式查询部分。</p>

<p>拓扑的下一部分将对字数实现低延迟的分布式查询。查询以空格分隔的单词列表作为输入，并返回这些单词的计数总和。这些查询的执行与普通RPC调用一样，只是它们在后台并行化。这是您如何调用其中一个查询的示例：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">DRPCClient</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DRPCClient</span><span class="o">(</span><span class="s">"drpc.server.location"</span><span class="o">,</span> <span class="mi">3772</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">"words"</span><span class="o">,</span> <span class="s">"cat dog the man"</span><span class="o">);</span>
<span class="c1">// prints the JSON-encoded result, e.g.: "[[5078]]"</span>
</code></pre></div>
<p>如您所见，它看起来像常规的远程过程调用（RPC），只是它跨Storm集群并行执行。像这样的小型查询的延迟通常约为10毫秒。虽然延迟时间在很大程度上取决于您为计算分配了多少资源，但是更激烈的DRPC查询当然会花费更长的时间。</p>

<p>拓扑的分布式查询部分的实现如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">topology</span><span class="o">.</span><span class="na">newDRPCStream</span><span class="o">(</span><span class="s">"words"</span><span class="o">)</span>
       <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"args"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">stateQuery</span><span class="o">(</span><span class="n">wordCounts</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">),</span> <span class="k">new</span> <span class="n">MapGet</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">),</span> <span class="k">new</span> <span class="n">FilterNull</span><span class="o">())</span>
       <span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sum"</span><span class="o">));</span>
</code></pre></div>
<p>相同的TridentTopology对象用于创建DRPC流，该函数名为“ words”。使用DRPCClient时，函数名称对应于execute第一个参数中给出的函数名称。</p>

<p>每个DRPC请求都被视为自己的小批处理作业，该作业将代表该请求的单个元组作为输入。元组包含一个称为“ args”的字段，其中包含客户端提供的参数。在这种情况下，参数是由空格分隔的单词列表。</p>

<p>首先，Split函数用于将请求的参数分为其组成词。流按“单词”分组，stateQuery运算符用于查询拓扑的第一部分生成的TridentState对象。 stateQuery接收状态源-在这种情况下，是由拓扑的另一部分计算的字数-以及用于查询该状态的函数。在这种情况下，将调用MapGet函数，该函数获取每个单词的计数。由于DRPC流的分组方式与TridentState完全相同（通过“单词”字段），因此每个单词查询都路由到TridentState对象的确切分区，该对象管理该单词的更新。</p>

<p>接下来，通过FilterNull过滤器过滤掉没有计数的单词，并使用Sum聚合器对计数求和以获得结果。然后，Trident自动将结果发送回等待的客户端。</p>

<p>Trident非常了解如何执行拓扑以最大化性能。在此拓扑中，有两件事会自动发生：</p>

<ol>
<li>从状态读取或写入状态的操作（例如persistentAggregate和stateQuery）会自动将操作批处理至该状态。因此，如果当前批次的处理需要对数据库进行20次更新，而不是对数据库进行20次读取请求和20次写入请求，则Trident将自动批处理读写，仅执行1次读取请求并1个写入请求（在许多情况下，您可以在State实现中使用缓存来消除读取请求）。因此，您可以充分利用便利性这两个词-能够根据每个元组应该做什么来表达您的计算-以及性能。</li>
<li>Trident聚合器经过了优化。Trident将在可能的情况下进行部分聚合，而不是将组中的所有元组转移到同一台计算机上，然后再运行聚合器，然后再通过网络发送元组。例如，计数聚合器计算每个分区上的计数，通过网络发送部分计数，然后将所有部分计数求和，以获得总计数。此技术类似于MapReduce中组合器的使用。</li>
</ol>

<p>让我们看一下Trident的另一个示例。</p>

<h2 id="reach">达到</h2>

<p>下一个示例是纯DRPC拓扑，可按需计算URL的到达范围。覆盖率是在Twitter上暴露给URL的唯一身份人数。要计算覆盖率，您需要提取所有发布过Twitter URL的人员，提取所有这些人员的所有关注者，并确定其唯一的关注者，并对其进行计数。对于一台机器来说，计算能力太强了-它可能需要数千个数据库调用和数千万个元组。使用Storm和Trident，您可以并行化集群中每个步骤的计算。</p>

<p>该拓扑将从两个状态源读取。一个数据库将URL映射到发推特URL的人员列表。另一个数据库将一个人映射到该人的关注者列表。拓扑定义如下所示：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentState</span> <span class="n">urlToTweeters</span> <span class="o">=</span>
       <span class="n">topology</span><span class="o">.</span><span class="na">newStaticState</span><span class="o">(</span><span class="n">getUrlToTweetersState</span><span class="o">());</span>
<span class="n">TridentState</span> <span class="n">tweetersToFollowers</span> <span class="o">=</span>
       <span class="n">topology</span><span class="o">.</span><span class="na">newStaticState</span><span class="o">(</span><span class="n">getTweeterToFollowersState</span><span class="o">());</span>

<span class="n">topology</span><span class="o">.</span><span class="na">newDRPCStream</span><span class="o">(</span><span class="s">"reach"</span><span class="o">)</span>
       <span class="o">.</span><span class="na">stateQuery</span><span class="o">(</span><span class="n">urlToTweeters</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"args"</span><span class="o">),</span> <span class="k">new</span> <span class="n">MapGet</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"tweeters"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"tweeters"</span><span class="o">),</span> <span class="k">new</span> <span class="n">ExpandList</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"tweeter"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">shuffle</span><span class="o">()</span>
       <span class="o">.</span><span class="na">stateQuery</span><span class="o">(</span><span class="n">tweetersToFollowers</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"tweeter"</span><span class="o">),</span> <span class="k">new</span> <span class="n">MapGet</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"followers"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">parallelismHint</span><span class="o">(</span><span class="mi">200</span><span class="o">)</span>
       <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"followers"</span><span class="o">),</span> <span class="k">new</span> <span class="n">ExpandList</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"follower"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"follower"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">One</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"one"</span><span class="o">))</span>
       <span class="o">.</span><span class="na">parallelismHint</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
       <span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"reach"</span><span class="o">));</span>
</code></pre></div>
<p>拓扑使用newStaticState方法创建表示每个外部数据库的TridentState对象。然后可以在拓扑中查询这些。像所有状态源一样，对这些数据库的查询将自动进行批处理，以实现最大效率。</p>

<p>拓扑定义很简单–只是简单的批处理工作。首先，查询urlToTweeters数据库以获取在Twitter上为此请求发送URL的人员列表。这将返回一个列表，因此将调用ExpandList函数为每个高音扬声器创建一个元组。</p>

<p>接下来，必须获取每个高音扬声器的关注者。重要的是，此步骤必须并行化，以便调用shuffle来将高音扬声器平均分配给拓扑的所有工作人员。然后，查询关注者数据库以获取每个高音扬声器的关注者列表。您可以看到，拓扑的这一部分具有很大的并行度，因为这是计算中最密集的部分。</p>

<p>接下来，唯一的关注者集合并进行计数。这分两个步骤完成。首先，通过“跟随者”对批生产完成“分组依据”，在每个组上运行“一个”聚合器。“一个”聚合器只发出一个元组，每个组包含一个数字。然后，将这些总和相加以获得关注者集合的唯一计数。这是“一个”聚合器的定义：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">One</span> <span class="kd">implements</span> <span class="n">CombinerAggregator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">init</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">combine</span><span class="o">(</span><span class="n">Integer</span> <span class="n">val1</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">val2</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">zero</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
   <span class="o">}</span>        
<span class="o">}</span>
</code></pre></div>
<p>这是一个“合并器聚合器”，它知道在通过网络传输元组之前如何进行部分聚合以最大化效率。总和也定义为组合器聚合器，因此在拓扑末尾完成的全局总和将非常有效。</p>

<p>现在让我们更详细地了解Trident。</p>

<h2 id="fields-and-tuples">字段和元组</h2>

<p>Trident数据模型是TridentTuple，它是值的命名列表。在拓扑期间，通过一系列操作来逐步建立元组。操作通常采用一组输入字段，并发出一组“功能字段”。输入字段用于选择元组的子集作为操作的输入，而“功能字段”则命名操作发出的字段。</p>

<p>考虑这个例子。假设您有一个名为“ stream”的流，其中包含字段“ x”，“ y”和“ z”。要运行以“ y”作为输入的过滤器MyFilter，您应该说：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"y"</span><span class="o">),</span> <span class="k">new</span> <span class="n">MyFilter</span><span class="o">())</span>
</code></pre></div>
<p>假设MyFilter的实现是这样的：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFilter</span> <span class="kd">extends</span> <span class="n">BaseFilter</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isKeep</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>这将保留所有“ y”字段小于10的元组。作为MyFilter输入的TridentTuple仅包含“ y”字段。请注意，在选择输入字段时，Trident能够非常有效地投影元组的子集：投影基本上是自由的。</p>

<p>现在让我们看一下“功能域”的工作原理。假设您具有以下功能：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddAndMultiply</span> <span class="kd">extends</span> <span class="n">BaseFunction</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
       <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
       <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
       <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="o">,</span> <span class="n">i1</span> <span class="o">*</span> <span class="n">i2</span><span class="o">));</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>此函数将两个数字作为输入并发出两个新值：数字的加法和数字的乘法。假设您有一个字段为“ x”，“ y”和“ z”的流。您将使用以下功能：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"x"</span><span class="o">,</span> <span class="s">"y"</span><span class="o">),</span> <span class="k">new</span> <span class="n">AddAndMultiply</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"added"</span><span class="o">,</span> <span class="s">"multiplied"</span><span class="o">));</span>
</code></pre></div>
<p>函数的输出是可加的：将字段添加到输入元组。因此，每个调用的输出将包含具有五个字段“ x”，“ y”，“ z”，“ added”和“ multiplied”的元组。 “添加”对应于AddAndMultiply发出的第一个值，而“乘”对应于第二个值。</p>

<p>另一方面，使用聚合器时，功能字段将替换输入元组。因此，如果您有一个包含字段“ val1”和“ val2”的流，则可以这样做：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"val2"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sum"</span><span class="o">))</span>
</code></pre></div>
<p>输出流将仅包含一个元组，其中包含一个名为“ sum”的字段，该字段表示该批次中所有“ val2”字段的总和。</p>

<p>对于分组流，输出将包含分组字段，其后是聚合器发出的字段。例如：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"val1"</span><span class="o">))</span>
     <span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"val2"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sum"</span><span class="o">))</span>
</code></pre></div>
<p>在此示例中，输出将包含字段“ val1”和“ sum”。</p>

<h2 id="state">州</h2>

<p>实时计算要解决的一个关键问题是如何管理状态，以便面对故障和重试时更新是幂等的。消除故障是不可能的，因此，当节点死亡或其他原因出错时，需要重试批次。问题是–您如何进行状态更新（无论是外部数据库还是拓扑内部状态），以便每条消息仅被处理一次？</p>

<p>这是一个棘手的问题，可以通过以下示例进行说明。假设您正在对流进行计数汇总，并且想要将运行中的计数存储在数据库中。如果仅将计数存储在数据库中，并且是时候为批次应用状态更新，则无法知道您之前是否已应用状态更新。该批处理以前可能已经尝试过，成功地更新了数据库，但随后又失败了。否则可能以前曾尝试过该批处理，但未能更新数据库。你就是不知道</p>

<p>Trident通过做两件事解决了这个问题：</p>

<ol>
<li>每个批次都有一个唯一的ID，称为“交易ID”。如果重试一个批次，它将具有完全相同的交易ID。</li>
<li>状态更新是按批次排序的。也就是说，直到成功完成批次2的状态更新后，才会应用批次3的状态更新。</li>
</ol>

<p>使用这两个原语，您可以在状态更新中实现一次语义。您不仅可以将计数存储在数据库中，还可以将事务ID和计数作为原子值存储在数据库中。然后，在更新计数时，您只需将数据库中的交易ID与当前批次的交易ID进行比较即可。如果它们相同，则跳过更新-由于顺序强大，因此您可以确定数据库中的值包含当前批次。如果它们不同，则增加计数。</p>

<p>当然，您不必在拓扑中手动执行此逻辑。该逻辑由状态抽象包装并自动完成。您也不需要State对象来实现事务ID技巧：如果您不想支付将事务ID存储在数据库中的费用，则不必这样做。在这种情况下，如果发生故障，州政府将至少具有一次处理语义（这可能对您的应用程序来说很好）。您可以<a href="Trident-state.html">在此文档中</a>了解有关如何实现状态以及各种容错权衡的更多信息。</p>

<p>允许一个州使用它想存储状态的任何策略。因此，它可以将状态存储在外部数据库中，也可以将状态保留在内存中，但由HDFS支持（例如HBase的工作方式）。不需要州永久保留州。例如，您可能有一个内存中的State实现，该实现仅保留最近X个小时的可用数据，而丢弃任何较旧的数据。对于示例State实现，请看一下<a href="https://github.com/nathanmarz/trident-memcached/blob/master/src/jvm/trident/memcached/MemcachedState.java">Memcached集成</a>的实现。</p>

<h2 id="execution-of-trident-topologies">三叉戟拓扑的执行</h2>

<p>三叉戟拓扑会尽可能地简化为Storm拓扑。元组仅在需要对数据重新分区时（例如，执行groupBy或shuffle时）才通过网络发送。因此，如果您具有以下Trident拓扑：</p>

<p><img src="images/trident-to-storm1.png" alt="编译三叉戟到风暴1"></p>

<p>它将编译为Storm喷口/螺栓，如下所示：</p>

<p><img src="images/trident-to-storm2.png" alt="编译三叉戟到风暴2"></p>

<h2 id="conclusion">结论</h2>

<p>Trident使实时计算变得优雅。您已经了解了如何通过Trident的API无缝地混合使用高吞吐量流处理，状态处理和低延迟查询。 Trident使您可以自然地表达实时计算，同时仍能获得最佳性能。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>