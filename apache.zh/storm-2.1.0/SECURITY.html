<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>安全地运行Apache Storm</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=3">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">安全地运行Apache Storm</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><h1 id="running-apache-storm-securely">安全地运行Apache Storm</h1>

<p>尝试保护群集时，Apache Storm提供了一系列配置选项。默认情况下，所有身份验证和授权都是禁用的，但可以根据需要将其打开。</p>

<h2 id="firewall-os-level-security">防火墙/操作系统级别的安全性</h2>

<p>您仍然可以具有安全的风暴群集，而无需打开正式的身份验证和授权。但是，这样做通常需要配置操作系统以限制可以完成的操作。即使您计划使用Auth运行群集，通常这也是一个好主意。</p>

<p>Storm的操作系统级别的安全性依赖于使用仅具有所需权限的OS帐户运行Storm进程。请注意，默认情况下，工作程序与Supervisor守护程序使用相同的OS帐户运行。</p>

<p>有关如何设置这些预防措施的确切细节差异很大，并且超出了本文档的范围。</p>

<p>通常，启用防火墙并将进入的网络连接限制为仅来自群集本身以及受信任的主机和服务的网络连接是一个好主意，以下是风暴使用的端口的完整列表。</p>

<p>如果群集正在处理的数据敏感，则最好设置IPsec来加密群集中主机之间发送的所有流量。</p>

<h3 id="ports">港口</h3>

<table><thead>
<tr>
<th>默认端口</th>
<th>风暴配置</th>
<th>客户端主机/进程</th>
<th>服务器</th>
</tr>
</thead><tbody>
<tr>
<td>2181</td>
<td><code>storm.zookeeper.port</code></td>
<td>Nimbus，主管和工人流程</td>
<td>动物园管理员</td>
</tr>
<tr>
<td>6627</td>
<td><code>nimbus.thrift.port</code></td>
<td>Storm客户端，主管和UI</td>
<td>雨云</td>
</tr>
<tr>
<td>8080</td>
<td><code>ui.port</code></td>
<td>客户端Web浏览器</td>
<td>用户界面</td>
</tr>
<tr>
<td>8000</td>
<td><code>logviewer.port</code></td>
<td>客户端Web浏览器</td>
<td>日志查看器</td>
</tr>
<tr>
<td>3772</td>
<td><code>drpc.port</code></td>
<td>外部DRPC客户端</td>
<td>DRPC</td>
</tr>
<tr>
<td>3773</td>
<td><code>drpc.invocations.port</code></td>
<td>工人流程</td>
<td>DRPC</td>
</tr>
<tr>
<td>3774</td>
<td><code>drpc.http.port</code></td>
<td>外部HTTP DRPC客户端</td>
<td>DRPC</td>
</tr>
<tr>
<td>670 {0,1,2,3}</td>
<td><code>supervisor.slots.ports</code></td>
<td>工人流程</td>
<td>工人流程</td>
</tr>
</tbody></table>

<h3 id="ui-logviewer">用户界面/日志查看器</h3>

<p>UI和logviewer进程提供了一种不仅可以查看集群正在执行的操作，还可以操纵正在运行的拓扑的方法。通常，这些过程不应向集群用户公开。</p>

<p>通常需要某种形式的身份验证，并且可以使用Java Servlet过滤器来完成</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">ui.filter</span><span class="pi">:</span> <span class="s2">"</span><span class="s">filter.class"</span>
<span class="s">ui.filter.params</span><span class="pi">:</span> <span class="s2">"</span><span class="s">param1":"value1"</span>
<span class="s">logviewer.filter</span><span class="pi">:</span> <span class="s2">"</span><span class="s">filter.class"</span>
<span class="s">logviewer.filter.params</span><span class="pi">:</span> <span class="s2">"</span><span class="s">param1":"value1"</span>
</code></pre></div>
<p>的<code>ui.filter</code>是...的实例<code>javax.servlet.Filter</code>旨在过滤所有传入到UI的请求并验证将该请求映射到“用户”的请求。通常，这是通过修改或包装<code>HttpServletRequest</code>通过返回用户主体<code>getUserPrincipal()</code>方法或通过返回用户名<code>getRemoteUser()</code>方法。如果您的过滤器以其他方式进行身份验证，则可以查看设置<code>ui.http.creds.plugin</code>指向一个实例<code>IHttpCredentialsPlugin</code>可以采取<code>HttpServletRequest</code>并返回用户名并在当前字段中填充所需的字段<code>ReqContext</code> 。这些是高级功能，您可能需要看看<code>DefaultHttpCredentialsPlugin</code>作为如何执行此操作的示例。</p>

<p>这些相同的设置也适用于logviewer。如果要对日志查看器中身份验证的方式进行单独控制，则可以选择设置<code>logviewer.filter</code>相反，它将覆盖任何<code>ui.filter</code>日志查看器进程的设置。</p>

<p>如果群集是单个租户，则您可能只想限制对UI /日志查看器端口的访问，以仅接受来自本地主机的连接，然后将它们置于另一个Web服务器（例如Apache httpd）的前面，该服务器可以对传入的连接和代理进行身份验证/授权与风暴过程的联系。为了使此工作有效，ui进程必须在其storm.yaml中将logviewer.port设置为代理的端口，而logviewers必须将其设置为将要绑定到的实际端口。</p>

<p>首选servlet过滤器，因为它允许各个拓扑指定谁是谁，哪些人不允许访问与它们关联的页面。</p>

<p>可以将Storm UI（或logviewer）配置为使用hadoop-auth中的AuthenticationFilter。
<code>yaml ui.filter: "org.apache.hadoop.security.authentication.server.AuthenticationFilter" ui.filter.params: "type": "kerberos" "kerberos.principal": "HTTP/nimbus.witzend.com" "kerberos.keytab": "/vagrant/keytabs/http.keytab" "kerberos.name.rules": "RULE:[2:$1@$0]([jt]t@.*EXAMPLE.COM)s/.*/$MAPRED_USER/ RULE:[2:$1@$0]([nd]n@.*EXAMPLE.COM)s/.*/$HDFS_USER/DEFAULT"</code>确保创建主体“ HTTP / {hostname}”（此处，主机名应为运行UI守护程序的主机名。请注意，UI用户<em>必须</em>为HTTP。</p>

<p>配置完成后，用户需要先进行kinit才能访问UI。例如：curl -i --negotiate -u：anyUser -b〜/ cookiejar.txt -c〜/ cookiejar.txt <a href="http://storm-ui-hostname:8080/api/v1/cluster/summary">http：// storm-ui-hostname：8080 / api / v1 / cluster / summary</a></p>

<ol>
<li>Firefox：转到about：config并搜索network.negotiate-auth.trusted-uris双击以添加值“ <a href="http://storm-ui-hostname:8080">http：// storm-ui-hostname：8080</a> ”</li>
<li>Google-chrome：从命令行开始：google-chrome --auth-server-whitelist =“ * storm-ui-hostname” --auth-negotiate-delegate-whitelist =“ * storm-ui-hostname”<br></li>
<li>IE：将受信任的网站配置为包括“ storm-ui-hostname”，并允许对该网站进行协商</li>
</ol>

<p><strong>注意</strong> ：用于通过查看任何日志<code>logviewer</code>在安全模式下，所有运行的主机<code>logviewer</code>还应添加到上述白名单中。对于大型群集，您可以将主机的域列入白名单（例如，设置<code>network.negotiate-auth.trusted-uris</code>至<code>.yourdomain.com</code> ）。</p>

<p><strong>注意</strong> ：在AD MIT Keberos设置中，密钥大小大于默认的UI码头服务器请求标头大小。确保在storm.yaml中将ui.header.buffer.bytes设置为65536。有关更多详细信息，请参见<a href="https://issues.apache.org/jira/browse/STORM-633">STORM-633</a></p>

<h2 id="drpc-http">DRPC HTTP</h2>

<p>DRPC服务器也可以选择支持REST端点，并且您可以在该端点上配置身份验证，类似于ui / logviewer。</p>

<p>的<code>drpc.http.filter</code>和<code>drpc.http.filter.params</code> configs可以用来设置一个<code>Filter</code>用于DRPC服务器。与logviewer不同，它不会回退到UI配置，因为DRPC服务器旨在仅是REST，并且经常会受到无头用户的攻击。</p>

<p>的<code>drpc.http.creds.plugin</code> config可以用于默认插件由于身份验证方式而不够好的情况。</p>

<h2 id="ui-drpc-logviewer-ssl">UI / DRPC / LOGVIEWER SSL</h2>

<p>UI，DRPC和LOGVIEWER允许用户配置ssl。</p>

<h3 id="ui">用户界面</h3>

<p>对于UI用户，需要在storm.yaml中设置以下配置。在执行此步骤之前，用户应注意使用适当的密钥和证书生成密钥库。</p>

<ol>
<li>ui.https.port</li>
<li>ui.https.keystore.type（例如“ jks”）</li>
<li>ui.https.keystore.path（例如“ /etc/ssl/storm_keystore.jks”）</li>
<li>ui.https.keystore.password（密钥库密码）</li>
<li>ui.https.key.password（私钥密码）</li>
</ol>

<p>可选配置6. ui.https.truststore.path（例如“ /etc/ssl/storm_truststore.jks”）7. ui.https.truststore.password（信任库密码）8. ui.https.truststore.type（例如“ jks” ”）</p>

<p>如果用户想设置双向认证9. ui.https.want.client.auth（如果设置为true，则服务器请求客户端证书认证，但是如果未提供认证，则保持连接）10. ui.https.need。 client.auth（如果设置为true，则服务器要求客户端提供身份验证）</p>

<h3 id="drpc">DRPC</h3>

<p>与UI类似，用户需要为DRPC配置以下内容</p>

<ol>
<li>drpc.https.port</li>
<li>drpc.https.keystore.type（例如“ jks”）</li>
<li>drpc.https.keystore.path（例如“ /etc/ssl/storm_keystore.jks”）</li>
<li>drpc.https.keystore.password（密钥库密码）</li>
<li>drpc.https.key.password（私钥密码）</li>
</ol>

<p>可选配置6. drpc.https.truststore.path（示例“ /etc/ssl/storm_truststore.jks”）7. drpc.https.truststore.password（信任库密码）8. drpc.https.truststore.type（示例“ jks” ”）</p>

<p>如果用户要设置2向身份验证9. drpc.https.want.client.auth（如果设置为true，则服务器请求客户端证书身份验证，但如果未提供身份验证，则保持连接）10. drpc.https.need。 client.auth（如果设置为true，则服务器要求客户端提供身份验证）</p>

<h3 id="logviewer">日志浏览器</h3>

<p>与UI和DRPC相似，用户需要为LOGVIEWER配置以下内容</p>

<ol>
<li>logviewer.https.port</li>
<li>logviewer.https.keystore.type（例如“ jks”）</li>
<li>logviewer.https.keystore.path（例如“ /etc/ssl/storm_keystore.jks”）</li>
<li>logviewer.https.keystore.password（密钥库密码）</li>
<li>logviewer.https.key.password（私钥密码）</li>
</ol>

<p>可选配置6. logviewer.https.truststore.path（例如“ /etc/ssl/storm_truststore.jks”）7. logviewer.https.truststore.password（信任库密码）8. logviewer.https.truststore.type（例如“ jks” ”）</p>

<p>如果用户想设置2-way auth 9. logviewer.https.want.client.auth（如果设置为true，则服务器请求客户端证书身份验证，但如果未提供身份验证，则保持连接）10. logviewer.https.need。 client.auth（如果设置为true，则服务器要求客户端提供身份验证）</p>

<h2 id="authentication-kerberos">验证（Kerberos）</h2>

<p>Storm通过节俭和SASL提供可插入身份验证支持。该示例仅适用于Kerberos，因为它是大多数大数据项目的常用设置。</p>

<p>在每个节点上设置KDC和配置kerberos不在本文档的讨论范围之内，并且假定您已完成此操作。</p>

<h3 id="create-headless-principals-and-keytabs">创建无头的主体和密钥表</h3>

<p>每个Zookeeper服务器，Nimbus和DRPC服务器都需要一个服务主体，按照惯例，该主体包括将在其上运行的主机的FQDN。请注意，动物园管理员用户<em>必须</em>是动物园管理员。<br>主管和UI也需要一个主体来运行，但是由于它们是传出连接，因此它们不必是服务主体。以下是如何设置kerberos主体的示例，但具体信息可能会因您的KDC和OS而异。</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Zookeeper (Will need one of these for each box in the Zk ensemble)</span>
<span class="nb">sudo </span>kadmin.local <span class="nt">-q</span> <span class="s1">'addprinc zookeeper/zk1.example.com@STORM.EXAMPLE.COM'</span>
<span class="nb">sudo </span>kadmin.local <span class="nt">-q</span> <span class="s2">"ktadd -k /tmp/zk.keytab  zookeeper/zk1.example.com@STORM.EXAMPLE.COM"</span>
<span class="c"># Nimbus and DRPC</span>
<span class="nb">sudo </span>kadmin.local <span class="nt">-q</span> <span class="s1">'addprinc storm/storm.example.com@STORM.EXAMPLE.COM'</span>
<span class="nb">sudo </span>kadmin.local <span class="nt">-q</span> <span class="s2">"ktadd -k /tmp/storm.keytab storm/storm.example.com@STORM.EXAMPLE.COM"</span>
<span class="c"># All UI logviewer and Supervisors</span>
<span class="nb">sudo </span>kadmin.local <span class="nt">-q</span> <span class="s1">'addprinc storm@STORM.EXAMPLE.COM'</span>
<span class="nb">sudo </span>kadmin.local <span class="nt">-q</span> <span class="s2">"ktadd -k /tmp/storm.keytab storm@STORM.EXAMPLE.COM"</span>
</code></pre></div>
<p>确保将密钥表分发到适当的框并设置FS权限，以便只有运行ZK或Storm的无头用户才能访问它们。</p>

<h4 id="storm-kerberos-configuration">Storm Kerberos配置</h4>

<p>Storm和Zookeeper都使用jaas配置文件来登录用户。每个jaas文件都可以具有多个节，用于使用不同的接口。</p>

<p>要在Storm中启用Kerberos身份验证，您需要设置以下storm.yaml配置<code>yaml storm.thrift.transport: "org.apache.storm.security.auth.kerberos.KerberosSaslTransportPlugin" java.security.auth.login.config: "/path/to/jaas.conf"</code></p>

<p>Nimbus和主管进程也将连接到ZooKeeper（ZK），我们希望将它们配置为使用Kerberos进行ZK身份验证。为此追加<code>-Djava.security.auth.login.config=/path/to/jaas.conf</code></p>

<p>给nimbus，ui和supervisor的子代。这是一个示例，给出了编写本文时的默认childopts设置：</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">nimbus.childopts</span><span class="pi">:</span> <span class="s2">"</span><span class="s">-Xmx1024m</span><span class="nv"> </span><span class="s">-Djava.security.auth.login.config=/path/to/jaas.conf"</span>
<span class="s">ui.childopts</span><span class="pi">:</span> <span class="s2">"</span><span class="s">-Xmx768m</span><span class="nv"> </span><span class="s">-Djava.security.auth.login.config=/path/to/jaas.conf"</span>
<span class="s">supervisor.childopts</span><span class="pi">:</span> <span class="s2">"</span><span class="s">-Xmx256m</span><span class="nv"> </span><span class="s">-Djava.security.auth.login.config=/path/to/jaas.conf"</span>
</code></pre></div>
<p>风暴节点的jaas.conf文件应类似于以下内容。Nimbus和DRPC节点使用StormServer部分。它不需要包含在主管节点上。想要与nmbus进行通信的所有风暴客户端（包括ui，logviewer和超级用户）都使用StormClient部分。我们还将在网关上使用此部分，但是其结构将有所不同。“客户”部分供希望与动物园管理员交谈的流程使用，实际上只需要包含在雨云和主管中。Zookeeper服务器使用“服务器”部分。在jaas中使用未使用的部分不是问题。</p>
<div class="highlight"><pre><code class="language-" data-lang="">StormServer {
   com.sun.security.auth.module.Krb5LoginModule required
   useKeyTab=true
   keyTab="$keytab"
   storeKey=true
   useTicketCache=false
   principal="$principal";
};
StormClient {
   com.sun.security.auth.module.Krb5LoginModule required
   useKeyTab=true
   keyTab="$keytab"
   storeKey=true
   useTicketCache=false
   serviceName="$nimbus_user"
   principal="$principal";
};
Client {
   com.sun.security.auth.module.Krb5LoginModule required
   useKeyTab=true
   keyTab="$keytab"
   storeKey=true
   useTicketCache=false
   serviceName="zookeeper"
   principal="$principal";
};
Server {
   com.sun.security.auth.module.Krb5LoginModule required
   useKeyTab=true
   keyTab="$keytab"
   storeKey=true
   useTicketCache=false
   principal="$principal";
};
</code></pre></div>
<p>以下是基于生成的密钥表的示例<code>StormServer { com.sun.security.auth.module.Krb5LoginModule required useKeyTab=true keyTab="/keytabs/storm.keytab" storeKey=true useTicketCache=false principal="storm/storm.example.com@STORM.EXAMPLE.COM"; }; StormClient { com.sun.security.auth.module.Krb5LoginModule required useKeyTab=true keyTab="/keytabs/storm.keytab" storeKey=true useTicketCache=false serviceName="storm" principal="storm@STORM.EXAMPLE.COM"; }; Client { com.sun.security.auth.module.Krb5LoginModule required useKeyTab=true keyTab="/keytabs/storm.keytab" storeKey=true useTicketCache=false serviceName="zookeeper" principal="storm@STORM.EXAMPLE.COM"; }; Server { com.sun.security.auth.module.Krb5LoginModule required useKeyTab=true keyTab="/keytabs/zk.keytab" storeKey=true useTicketCache=false serviceName="zookeeper" principal="zookeeper/zk1.example.com@STORM.EXAMPLE.COM"; };</code></p>

<p>Nimbus还将主体转换为本地用户名，以便其他服务可以使用此名称。为Kerberos身份验证集配置此设置</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm.principal.tolocal: "org.apache.storm.security.auth.KerberosPrincipalToLocal"
</code></pre></div>
<p>这仅需要在nimbus上完成，但不会对任何节点造成伤害。从ZooKeeper的角度来看，我们还需要通知拓扑管理程序守护程序和nimbus守护程序正在运行。</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm.zookeeper.superACL: "sasl:${nimbus-user}"
</code></pre></div>
<p>这里的<em>nimbus-user</em>是nimbus用于通过ZooKeeper进行身份验证的Kerberos用户。如果ZooKeeeper正在剥离主机和领域，则也需要剥离主机和领域。</p>

<h4 id="zookeeper-ensemble">ZooKeeper合奏</h4>

<p>如何设置安全ZK的完整详细信息超出了本文的范围。但是通常，您希望在每台服务器上启用SASL身份验证，并有选择地剥离主机和领域</p>
<div class="highlight"><pre><code class="language-" data-lang="">authProvider.1 = org.apache.zookeeper.server.auth.SASLAuthenticationProvider
kerberos.removeHostFromPrincipal = true
kerberos.removeRealmFromPrincipal = true
</code></pre></div>
<p>并且您希望在启动服务器时在命令行中包含jaas.conf，以便它可以使用它来找到密钥表。
<code>-Djava.security.auth.login.config=/jaas/zk_jaas.conf</code></p>

<h4 id="gateways">网关</h4>

<p>理想情况下，最终用户只需要在与Storm交互之前运行kinit。为了使这一过程无缝发生，我们需要网关上的默认jaas.conf类似于</p>
<div class="highlight"><pre><code class="language-" data-lang="">StormClient {
   com.sun.security.auth.module.Krb5LoginModule required
   doNotPrompt=false
   useTicketCache=true
   serviceName="$nimbus_user";
};
</code></pre></div>
<p>如果最终用户有一个具有密钥表的无头用户，则可以覆盖此设置。</p>

<h3 id="authorization-setup">授权设置</h3>

<p><em>身份验证</em>可以完成验证用户<em>身份</em>的工作，但是我们还需要<em>授权</em>来执行每个用户可以执行的操作。</p>

<p>nimbus的首选授权插件是<em>SimpleACLAuthorizer</em> 。要使用<em>SimpleACLAuthorizer</em> ，请设置以下内容：</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">nimbus.authorizer</span><span class="pi">:</span> <span class="s2">"</span><span class="s">org.apache.storm.security.auth.authorizer.SimpleACLAuthorizer"</span>
</code></pre></div>
<p>DRPC具有单独的授权者配置。不要将SimpleACLAuthorizer用于DRPC。</p>

<p><em>SimpleACLAuthorizer</em>插件需要知道管理员用户是谁，并且需要知道所有管理员用户，包括运行ui守护程序的用户。</p>

<p>这些分别通过<em>nimbus.supervisor.users</em>和<em>nimbus.admins</em>设置。每个名称可以是完整的Kerberos主体名称，也可以是剥离了主机和领域的用户名称。</p>

<p>日志服务器具有自己的授权配置。这些是通过<em>logs.users</em>和<em>logs.groups</em>设置的。这些应设置为群集中所有节点的管理员用户或组。</p>

<p>提交拓扑后，提交用户也可以在此列表中指定用户。除了在群集范围内的设置中指定的用户外，还将为指定的用户和组授予访问日志查看器中提交的拓扑的工作日志的权限。</p>

<h3 id="supervisors-headless-user-and-group-setup">主管无头用户和组设置</h3>

<p>为了确保多租户中的用户隔离，需要运行管理器以及无头的用户和组，这对于在管理器节点上执行是唯一的。要启用此功能，请执行以下步骤。1。将headlessuser添加到所有主管主机。2。创建唯一组，并使其成为主管节点上无头用户的主要组。3。这些主管节点在风暴中设置以下属性。</p>

<h3 id="multi-tenant-scheduler">多租户调度程序</h3>

<p>为了更好地支持多租户，我们编写了新的调度程序。要启用此调度程序集。
<code>yaml storm.scheduler: "org.apache.storm.scheduler.multitenant.MultitenantScheduler"</code>请注意，此调度程序的许多功能都依赖于风暴认证。没有它们，调度程序将不知道用户是什么，也无法正确隔离拓扑。</p>

<p>多租户调度程序的目标是提供一种将拓扑相互隔离的方法，但同时也限制单个用户可以在群集中拥有的资源。</p>

<p>调度程序当前具有一个配置，可以通过= storm.yaml =或通过单独的配置文件= multitenant-scheduler.yaml =进行设置，该文件应与= storm.yaml =放在同一目录中。最好使用= multitenant-scheduler.yaml =，因为它可以更新而无需重新启动nimbus。</p>

<p>当前，= multitenant-scheduler.yaml =中只有一个配置，= multitenant.scheduler.user.pools =是从用户名到用户可以保证可用于其拓扑的最大节点数的映射。</p>

<p>例如：</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">multitenant.scheduler.user.pools</span><span class="pi">:</span> 
    <span class="s2">"</span><span class="s">evans"</span><span class="pi">:</span> <span class="s">10</span>
    <span class="s2">"</span><span class="s">derek"</span><span class="pi">:</span> <span class="s">10</span>
</code></pre></div>
<h3 id="run-worker-processes-as-user-who-submitted-the-topology">以提交拓扑的用户身份运行工作进程</h3>

<p>默认情况下，storm以运行超级用户的用户身份运行工作程序。这对于安全性而言并不理想。为了使风暴运行，启动它们的用户设置拓扑。</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">supervisor.run.worker.as.user</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div>
<p>有一些与此相关的文件需要正确配置以确保风暴安全。</p>

<p>worker-launcher可执行文件是一个特殊程序，允许主管以不同用户身份启动worker。为此，它必须由root拥有，但必须将组设置为只有主管无头用户参与的组。它还需要具有6550权限。还有一个worker-launcher.cfg文件，通常位于/ etc /下，应该类似于以下内容</p>
<div class="highlight"><pre><code class="language-" data-lang="">storm.worker-launcher.group=$(worker_launcher_group)
min.user.id=$(min_user_id)
</code></pre></div>
<p>其中worker_launcher_group是主管所属的同一组，并且min.user.id设置为系统上的第一个实际用户ID。此配置文件还需要由root拥有，并且没有世界或组写入权限。</p>

<h3 id="impersonating-a-user">冒充用户</h3>

<p>风暴客户端可以代表另一个用户提交请求。例如，如果<code>userX</code>提交oozie工作流程，如果用户执行则作为工作流程执行的一部分<code>oozie</code>想要代表提交拓扑<code>userX</code>它可以通过模拟功能来实现。为了以其他用户身份提交拓扑，可以使用<code>StormSubmitter.submitTopologyAs</code> API。或者，您可以使用<code>NimbusClient.getConfiguredClientAs</code>以获得其他用户的nimbus客户端并使用此客户端执行任何nimbus动作（即kill / rebalance / activate / deactivate）。</p>

<p>默认情况下，模拟授权是禁用的，这意味着任何用户都可以执行模拟。为确保只有授权用户才能进行模拟，您应使用以下命令启动nimbus： <code>nimbus.impersonation.authorizer</code>调成<code>org.apache.storm.security.auth.authorizer.ImpersonationAuthorizer</code> 。的<code>ImpersonationAuthorizer</code>用途<code>nimbus.impersonation.acl</code>作为授权用户的ACL。以下是支持模拟的示例nimbus配置：</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">nimbus.impersonation.authorizer</span><span class="pi">:</span> <span class="s">org.apache.storm.security.auth.authorizer.ImpersonationAuthorizer</span>
<span class="s">nimbus.impersonation.acl</span><span class="pi">:</span>
    <span class="na">impersonating_user1</span><span class="pi">:</span>
        <span class="na">hosts</span><span class="pi">:</span>
            <span class="pi">[</span><span class="nv">comma separated list of hosts from which impersonating_user1 is allowed to impersonate other users</span><span class="pi">]</span>
        <span class="na">groups</span><span class="pi">:</span>
            <span class="pi">[</span><span class="nv">comma separated list of groups whose users impersonating_user1 is allowed to impersonate</span><span class="pi">]</span>
    <span class="na">impersonating_user2</span><span class="pi">:</span>
        <span class="na">hosts</span><span class="pi">:</span>
            <span class="pi">[</span><span class="nv">comma separated list of hosts from which impersonating_user2 is allowed to impersonate other users</span><span class="pi">]</span>
        <span class="na">groups</span><span class="pi">:</span>
            <span class="pi">[</span><span class="nv">comma separated list of groups whose users impersonating_user2 is allowed to impersonate</span><span class="pi">]</span>
</code></pre></div>
<p>为了支持oozie用例，可以提供以下配置：<code>yaml nimbus.impersonation.acl: oozie: hosts: [oozie-host1, oozie-host2, 127.0.0.1] groups: [some-group-that-userX-is-part-of]</code></p>

<h3 id="automatic-credentials-push-and-renewal">自动凭证推送和续订</h3>

<p>各个拓扑可以将凭证（票证和令牌）推送给工作人员，以便他们可以访问安全服务。将其暴露给所有用户可能令他们感到痛苦。要在常见情况下将其隐藏起来，可以使用插件来填充凭据，在另一侧将它们解包到java主题中，并在需要时允许Nimbus更新凭据。这些由以下配置控制。</p>

<p><code>topology.auto-credentials</code>是Java插件的列表，所有这些插件都必须实现<code>IAutoCredentials</code>界面，在网关上填充凭据，并在工作端解压缩它们。在kerberos安全集群上，它们应默认设置为指向<code>org.apache.storm.security.auth.kerberos.AutoTGT</code></p>

<p><code>nimbus.credential.renewers.classes</code>还应该设置为<code>org.apache.storm.security.auth.kerberos.AutoTGT</code>这样nimbus可以代表用户定期更新TGT。</p>

<p>希望实现IMetricsRegistrant接口的所有自动凭证类都可以为每个拓扑自动注册度量。AutoTGT类当前实现此接口，并添加了一个名为TGT-TimeToExpiryMsecs的度量，该度量显示了需要更新TGT之前的剩余时间。</p>

<p><code>nimbus.credential.renewers.freq.secs</code>控制更新程序多久轮询一次以查看是否需要更新任何内容，但是默认值应该合适。</p>

<p>此外，Nimbus本身可用于代表提交拓扑的用户获取凭据。可以使用<code>nimbus.autocredential.plugins.classes</code>这是完全合格的类名的列表，所有这些都必须实现<code>INimbusCredentialPlugin</code> 。Nimbus将调用所有已配置实现的populateCredentials方法，作为拓扑提交的一部分。您应该将此配置与<code>topology.auto-credentials</code>和<code>nimbus.credential.renewers.classes</code>因此可以在工作人员端填充凭据，并且nimbus可以自动更新它们。当前有两个使用此配置的示例，AutoHDFS和AutoHBase，它们自动为拓扑提交者填充hdfs和hbase委派令牌，因此它们不必在所有可能的工作主机上分发密钥表。</p>

<h3 id="limits">限度</h3>

<p>默认情况下，storm允许提交任何大小的拓扑。但是ZK和其他公司在拓扑实际上可以有多大方面存在限制。以下配置允许您限制拓扑可以的最大大小。</p>

<table><thead>
<tr>
<th>YAML设置</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>nimbus.slots.perTopology</td>
<td>拓扑可以使用的最大插槽/工作人员数。</td>
</tr>
<tr>
<td>nimbus.executors.perTopology</td>
<td>拓扑可以使用的执行程序/线程的最大数量。</td>
</tr>
</tbody></table>

<h3 id="log-cleanup">日志清理</h3>

<p>Logviewer守护程序现在还负责清除旧的日志文件中的无效拓扑。</p>

<table><thead>
<tr>
<th>YAML设置</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>logviewer.cleanup.age.mins</td>
<td>在考虑对工作日志进行清理之前，工作人员的日志必须多大（在最后修改时间之前）。（日志查看器永远不会清除生活工人的日志：他们的日志通过logback进行滚动。）</td>
</tr>
<tr>
<td>logviewer.cleanup.interval.secs</td>
<td>Logviewer清理工作日志的时间间隔（以秒为单位）。</td>
</tr>
</tbody></table>

<h3 id="allowing-specific-users-or-groups-to-access-storm">允许特定用户或组访问风暴</h3>

<p>使用SimpleACLAuthorizer，具有有效kerberos票证的任何用户都可以部署拓扑或执行进一步的操作，例如激活，停用，访问集群信息。可以通过指定nimbus.users或nimbus.groups来限制此访问。如果配置了nimbus.users，则仅列表中的用户可以部署拓扑或访问集群。同样，nimbus.groups将风暴群集的访问权限限制为属于那些组的用户。</p>

<p>要配置，请在storm.yaml中指定以下配置</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">nimbus.users</span><span class="pi">:</span> 
   <span class="pi">-</span> <span class="s2">"</span><span class="s">testuser"</span>
</code></pre></div>
<p>要么</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">nimbus.groups</span><span class="pi">:</span> 
   <span class="pi">-</span> <span class="s2">"</span><span class="s">storm"</span>
</code></pre></div>
<h3 id="drpc">DRPC</h3>

<p>Storm提供了DRPC授权者的访问控制列表。用户可以看到<a href="javadocs/org/apache/storm/security/auth/authorizer/DRPCSimpleACLAuthorizer.html">org.apache.storm.security.auth.authorizer。有关更多详细信息，请参见DRPCSimpleACLAuthorizer</a> 。</p>

<p>有几种与DRPC ACL相关的配置。</p>

<table><thead>
<tr>
<th>YAML设置</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>drpc.authorizer.acl</td>
<td>将对DRPC操作执行授权的类。将此设置为org.apache.storm.security.auth.authorizer。使用安全性时使用DRPCSimpleACLAuthorizer。</td>
</tr>
<tr>
<td>drpc.authorizer.acl。文件名</td>
<td>这是将从中加载ACL的文件的名称。它与storm.yaml分开，以允许在不关闭DRPC服务器的情况下更新文件。默认为drpc-auth-acl.yaml</td>
</tr>
<tr>
<td>drpc.authorizer.acl.strict</td>
<td>将其设置为false很有用，以便在用户可能要进行试验的阶段进行设置，而对于需要用户安全的生产环境则将其设置为true。默认为false。</td>
</tr>
</tbody></table>

<p>drpc.authorizer.acl.filename指向的文件中只有一个配置drpc.authorizer.acl，其格式应为</p>
<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">drpc.authorizer.acl</span><span class="pi">:</span>
   <span class="s2">"</span><span class="s">functionName1"</span><span class="pi">:</span>
     <span class="s2">"</span><span class="s">client.users"</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="s2">"</span><span class="s">alice"</span>
       <span class="pi">-</span> <span class="s2">"</span><span class="s">bob"</span>
     <span class="s2">"</span><span class="s">invocation.user"</span><span class="pi">:</span> <span class="s2">"</span><span class="s">bob"</span>
</code></pre></div>
<p>在这种情况下，用户bob和alice作为client.users被允许针对functionName1运行DRPC请求，但是仅bob作为invocation.user被允许运行实际处理那些请求的拓扑。</p>

<h2 id="cluster-zookeeper-authentication">集群Zookeeper身份验证</h2>

<p>用户可以通过设置以下配置来实现集群Zookeeper身份验证。</p>

<table><thead>
<tr>
<th>YAML设置</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>Storm.zookeeper.auth.scheme</td>
<td>要使用的集群Zookeeper身份验证方案，例如“摘要”。默认为不认证。</td>
</tr>
<tr>
<td>storm.zookeeper.auth.payload</td>
<td>一个字符串，代表集群Zookeeper身份验证的有效负载。仅应在storm-cluster-auth.yaml中进行设置。用户可以查看storm-cluster-auth.yaml.example了解更多详细信息。</td>
</tr>
</tbody></table>

<p>另外，拓扑Zookeeper身份验证有几种配置：</p>

<table><thead>
<tr>
<th>YAML设置</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>Storm.zookeeper.topology.auth.scheme</td>
<td>要使用的拓扑Zookeeper身份验证方案，例如“摘要”。这是内部配置，用户不应设置它。</td>
</tr>
<tr>
<td>storm.zookeeper.topology.auth.payload</td>
<td>表示拓扑Zookeeper验证的有效负载的字符串。</td>
</tr>
</tbody></table>

<p>注意：如果未设置storm.zookeeper.topology.auth.payload，Storm将使用generateZookeeperDigestSecretPayload（）方法为MD5-digest生成ZooKeeper秘密有效负载。</p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>