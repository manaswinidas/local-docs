<html ><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>风暴状态管理</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="/assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="asset?aid=0">
    <link href="/css/style.css" rel="stylesheet">
    <link href="/assets/css/owl.theme.css" rel="stylesheet">
    <link href="/assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="/assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body >
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="/index.html"><img src="/images/logo.png" class="logo"></a>
          </div>
          <div class="col-md-5">
            
              <h1>版本：2.1.0</h1>
            
          </div>
          <div class="col-md-2">
            <a href="/downloads.html" class="btn-std btn-block btn-download">下载</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse"></button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="/index.html" id="home">家</a></li>
                <li><a href="/getting-help.html" id="getting-help">获得帮助</a></li>
                <li><a href="/about/integrates.html" id="project-info">项目信息</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="documentation" data-toggle="dropdown">文献资料<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li><a href="/releases/2.1.0/index.html">2.1.0</a></li>
                        
                      
                        
                          <li><a href="/releases/2.0.0/index.html">2.0.0</a></li>
                        
                      
                        
                          <li><a href="/releases/1.2.3/index.html">1.2.3</a></li>
                        
                      
                    </ul>
                </li>
                <li><a href="/talksAndVideos.html">讲座和幻灯片</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" id="contribute" data-toggle="dropdown">社区<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="/contribute/Contributing-to-Storm.html">贡献</a></li>
                        <li><a href="/contribute/People.html">人</a></li>
                        <li><a href="/contribute/BYLAWS.html">按照法律规定</a></li>
                    </ul>
                </li>
                <li><a href="/2019/10/31/storm210-released.html" id="news">新闻</a></li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">风暴状态管理</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<div class="documentation-content"><h1 id="state-support-in-core-storm">国家对核心风暴的支持</h1>

<p>Storm核心具有用于螺栓的抽象，以保存和检索其操作状态。有一个默认的基于内存的状态实现，还有一个提供状态持久性的Redis支持的实现。</p>

<h2 id="state-management">国家管理</h2>

<p>要求状态由框架管理和持久化的螺栓应实施<code>IStatefulBolt</code>接口或扩展<code>BaseStatefulBolt</code>并实施<code>void initState(T state)</code>方法。的<code>initState</code>框架在螺栓初始化期间使用先前保存的螺栓状态调用该方法。在准备之后但在螺栓开始处理任何元组之前调用此方法。</p>

<p>目前唯一的一种<code>State</code>支持的实现是<code>KeyValueState</code>提供键值映射。</p>

<p>例如，单词计数螺栓可以将键值状态抽象用于单词计数，如下所示。</p>

<ol>
<li>扩展BaseStatefulBolt并使用KeyValueState对其进行参数化，该类型将存储要计数的单词的映射。</li>
<li>在init方法中，螺栓以其先前保存的状态初始化。这将包含框架在上一次运行期间最后提交的字数统计。</li>
<li>在execute方法中，更新字数。</li>
</ol>
<div class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordCountBolt</span> <span class="kd">extends</span> <span class="n">BaseStatefulBolt</span><span class="o">&lt;</span><span class="n">KeyValueState</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">KeyValueState</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">wordCounts</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">;</span>
    <span class="o">...</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="n">Map</span> <span class="n">stormConf</span><span class="o">,</span> <span class="n">TopologyContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">OutputCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">collector</span> <span class="o">=</span> <span class="n">collector</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initState</span><span class="o">(</span><span class="n">KeyValueState</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">wordCounts</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Tuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
          <span class="n">Integer</span> <span class="n">count</span> <span class="o">=</span> <span class="n">wordCounts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
          <span class="n">count</span><span class="o">++;</span>
          <span class="n">wordCounts</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
          <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">tuple</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>
          <span class="n">collector</span><span class="o">.</span><span class="na">ack</span><span class="o">(</span><span class="n">tuple</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">...</span>
    <span class="o">}</span>
</code></pre></div>
<ol>
<li>框架会定期检查点螺栓的状态（每秒默认一次）。可以通过设置风暴配置来更改频率<code>topology.state.checkpoint.interval.ms</code></li>
<li>对于状态持久性，请通过设置<code>topology.state.provider</code>在风暴配置中。例如，使用基于Redis的键值状态实现集<code>topology.state.provider: org.apache.storm.redis.state.RedisKeyValueStateProvider</code>在storm.yaml中。提供者实现jar应该位于类路径中，在这种情况下，这意味着添加<code>storm-redis</code>依赖于您的拓扑，或添加<code>--artifacts "org.apache.storm:storm-sql-redis:<storm-version>"</code>在提交拓扑时<code>storm jar</code> 。</li>
<li>可以通过设置覆盖状态提供者属性<code>topology.state.provider.config</code> 。对于Redis状态，这是具有以下属性的json配置。</li>
</ol>
<div class="highlight"><pre><code class="language-" data-lang="">{
  "keyClass": "Optional fully qualified class name of the Key type.",
  "valueClass": "Optional fully qualified class name of the Value type.",
  "keySerializerClass": "Optional Key serializer implementation class.",
  "valueSerializerClass": "Optional Value Serializer implementation class.",
  "jedisPoolConfig": {
    "host": "localhost",
    "port": 6379,
    "timeout": 2000,
    "database": 0,
    "password": "xyz"
    }
}
</code></pre></div>
<p>对于Redis集群状态，这是具有以下属性的json配置。</p>
<div class="highlight"><pre><code class="language-" data-lang=""> {
   "keyClass": "Optional fully qualified class name of the Key type.",
   "valueClass": "Optional fully qualified class name of the Value type.",
   "keySerializerClass": "Optional Key serializer implementation class.",
   "valueSerializerClass": "Optional Value Serializer implementation class.",
   "jedisClusterConfig": {
     "nodes": ["localhost:7379", "localhost:7380", "localhost:7381"],
     "timeout": 2000,
     "maxRedirections": 5
   }
 }
</code></pre></div>
<p>注意：如果您将Redis状态与Storm版本1.1.0或更早版本一起使用，则由于状态的表示已更改，您还需要迁移状态<br>从Base64编码的字符串到二进制以减少巨大的开销。Storm提供了一个迁移工具来提供帮助，该工具位于<code>storm-redis-example</code>模块。</p>

<p>请从下载页面下载源代码或克隆项目，然后键入以下命令：</p>
<div class="highlight"><pre><code class="language-" data-lang="">mvn clean install -DskipTests
cd examples/storm-redis-examples
&lt;storm-installation-dir&gt;/bin/storm jar target/storm-redis-examples-*.jar org.apache.storm.redis.tools.Base64ToBinaryStateMigrationUtil [options]
</code></pre></div>
<p>支持的选项在这里列出：</p>
<div class="highlight"><pre><code class="language-" data-lang=""> -d,--dbnum &lt;arg&gt;       Redis DB number (default: 0)
 -h,--host &lt;arg&gt;        Redis hostname (default: localhost)
 -n,--namespace &lt;arg&gt;   REQUIRED the list of namespace to migrate.
 -p,--port &lt;arg&gt;        Redis port (default: 6379)
    --password &lt;arg&gt;    Redis password (default: no password)
</code></pre></div>
<p>您可以提供多个<code>namespace</code>一次迁移多个名称空间的选项。（例如： <code>--namespace total-7 --namespace partialsum-3</code> ）其他选项不是必需的。请注意，由于密钥是状态的内部名称空间，因此还需要迁移以“ $ checkpointspout-”开头的密钥。</p>

<h2 id="checkpoint-mechanism">检查点机制</h2>

<p>检查点由指定位置的内部检查点喷口触发<code>topology.state.checkpoint.interval.ms</code> 。如果至少有一个<code>IStatefulBolt</code>在拓扑中，检查点喷口由拓扑生成器自动添加。对于有状态拓扑，拓扑构建器将<code>IStatefulBolt</code>在一个<code>StatefulBoltExecutor</code>它在接收检查点元组时处理状态提交。非状态螺栓被包裹在一个<code>CheckpointTupleForwarder</code>它只是转发检查点元组，以便检查点元组可以流经拓扑DAG。检查点元组流过单独的内部流，即<code>$checkpoint</code> 。拓扑构建器将整个拓扑上的检查点流与根的检查点喷口连接起来。</p>
<div class="highlight"><pre><code class="language-" data-lang="">              default                         default               default
[spout1]   ---------------&gt; [statefulbolt1] ----------&gt; [bolt1] --------------&gt; [statefulbolt2]
                          |                 ----------&gt;         --------------&gt;
                          |                   ($chpt)               ($chpt)
                          |
[$checkpointspout] _______| ($chpt)
</code></pre></div>
<p>每隔一个检查点间隔，检查点元组就会发出检查点元组。接收到检查点元组时，将保存螺栓的状态，然后将检查点元组转发到下一个组件。每个螺栓在保存状态之前都等待检查点到达其所有输入流，这样该状态才能表示整个拓扑中的一致状态。一旦检查点喷口从所有螺栓接收到ACK，状态提交即告完成，并且交易记录为检查点喷口已提交。</p>

<p>状态检查点当前不检查喷嘴的状态。但是，一旦所有螺栓的状态都经过检查点，并且检查点元组被确认，则由喷嘴发出的元组也将被确认。这也意味着<code>topology.state.checkpoint.interval.ms</code>低于<code>topology.message.timeout.secs</code> 。</p>

<p>状态提交的工作方式类似于带有准备和提交阶段的三相提交协议，因此拓扑中的状态以一致且原子的方式保存。</p>

<h3 id="recovery">复苏</h3>

<p>首次启动拓扑时，将触发恢复阶段。如果之前的交易未成功准备，则<code>rollback</code>消息通过拓扑发送，因此如果螺栓具有一些准备好的事务，则可以将其丢弃。如果先前的事务已成功准备但未提交，则<code>commit</code>跨拓扑发送消息，以便可以提交准备好的事务。完成这些步骤后，将使用状态初始化螺栓。</p>

<p>如果其中一个螺栓无法确认检查点消息或说工人在中间坠毁，也会触发恢复。因此，当工作人员由主管重新启动时，检查点机制可确保螺栓以其先前的状态初始化，并且检查点从其停止处继续。</p>

<h3 id="guarantee">保证</h3>

<p>Storm依靠确认机制在发生故障的情况下重播元组。状态可能已提交，但工作人员在确认元组之前崩溃了。在这种情况下，元组将被重播，从而导致重复的状态更新。同样，当前StatefulBoltExecutor在收到一个流上的检查点元组之后，仍在继续处理流中的元组，同时等待检查点到达其他输入流以保存状态。这也可能导致恢复期间重复状态更新。</p>

<p>状态抽象不会消除重复的评估，并且目前仅提供至少一次保证。</p>

<p>为了提供至少一次保证，有状态拓扑中的所有螺栓都应在发射并确认输入元组后对其进行锚定，同时对元组进行处理。对于无状态螺栓，可通过扩展<code>BaseBasicBolt</code> 。有状态的螺栓有望在发射和确认元组的同时锚定元组，就像在<code>WordCountBolt</code>上面的状态管理部分中的示例。</p>

<h3 id="istateful-bolt-hooks">I状态螺栓钩</h3>

<p>IStateful螺栓接口提供了挂钩方法，在这些方法中，有状态螺栓可以实现一些自定义操作。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">    <span class="cm">/**
     * This is a hook for the component to perform some actions just before the
     * framework commits its state.
     */</span>
    <span class="kt">void</span> <span class="nf">preCommit</span><span class="o">(</span><span class="kt">long</span> <span class="n">txid</span><span class="o">);</span>

    <span class="cm">/**
     * This is a hook for the component to perform some actions just before the
     * framework prepares its state.
     */</span>
    <span class="kt">void</span> <span class="nf">prePrepare</span><span class="o">(</span><span class="kt">long</span> <span class="n">txid</span><span class="o">);</span>

    <span class="cm">/**
     * This is a hook for the component to perform some actions just before the
     * framework rolls back the prepared state.
     */</span>
    <span class="kt">void</span> <span class="nf">preRollback</span><span class="o">();</span>
</code></pre></div>
<p>这是可选的，有状态的螺栓不应提供任何实现。提供此功能是为了可以在有状态抽象的基础上构建其他系统级组件，在这些状态我们可能希望在有状态螺栓的状态准备，提交或回滚之前采取一些措施。</p>

<h2 id="providing-custom-state-implementations">提供自定义状态实现</h2>

<p>目前唯一的一种<code>State</code>支持的实现是<code>KeyValueState</code>提供键值映射。</p>

<p>自定义状态实现应提供针对<code>org.apache.storm.State</code>接口。这些是<code>void prepareCommit(long txid)</code> ， <code>void commit(long txid)</code> ， <code>rollback()</code>方法。 <code>commit()</code>方法是可选的，如果螺栓自行管理状态，则此方法很有用。当前仅由内部系统螺栓（例如CheckpointSpout）使用它来保存其状态。</p>

<p><code>KeyValueState</code>实施还应实施<code>org.apache.storm.state.KeyValueState</code>接口。</p>

<h3 id="state-provider">国家提供者</h3>

<p>框架通过相应的实例化状态<code>StateProvider</code>实施。自定义状态还应提供<code>StateProvider</code>可以基于名称空间加载和返回状态的实现。每个状态都属于唯一的名称空间。名称空间通常对于每个任务都是唯一的，因此每个任务可以具有自己的状态。StateProvider和相应的State实现应在Storm的类路径中可用（通过将它们放在extlib目录中）。</p>

<h3 id="supported-state-backends">支持的州后端</h3>

<h4 id="redis">雷迪斯</h4>

<ul>
<li>州提供者类别名称（ <code>topology.state.provider</code> ）</li>
</ul>

<p><code>org.apache.storm.redis.state.RedisKeyValueStateProvider</code></p>

<ul>
<li>提供者配置（ <code>topology.state.provider.config</code> ）</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang=""> {
   "keyClass": "Optional fully qualified class name of the Key type.",
   "valueClass": "Optional fully qualified class name of the Value type.",
   "keySerializerClass": "Optional Key serializer implementation class.",
   "valueSerializerClass": "Optional Value Serializer implementation class.",
   "jedisPoolConfig": {
     "host": "localhost",
     "port": 6379,
     "timeout": 2000,
     "database": 0,
     "password": "xyz"
   }
 }
</code></pre></div>
<ul>
<li>要添加的工件（ <code>--artifacts</code> ）</li>
</ul>

<p><code>org.apache.storm:storm-redis:<storm-version></code></p>

<h4 id="hbase">HBase的</h4>

<p>为了使状态可伸缩，HBaseKeyValueState将状态KV存储到一行。这介绍<code>non-atomic</code>提交阶段，并确保HBase端最终的一致性。从状态的角度来看这无关紧要，因为HBaseKeyValueState仍然可以提供尚未提交的值。即使worker在提交阶段崩溃，重新启动后它也会从HBase读取（原子存储的）未决提交状态，状态将最终存储。</p>

<p>注意：HBase状态提供程序使用预先创建的表和列系列，因此用户需要创建一个提供程序并将其提供给提供程序配置。</p>

<p>您可以简单地通过创建表<code>create 'state', 'cf'</code>在<code>hbase shell</code>但是在生产中，您可能需要提供更多属性。</p>

<ul>
<li>州提供者类别名称（ <code>topology.state.provider</code> ）</li>
</ul>

<p><code>org.apache.storm.hbase.state.HBaseKeyValueStateProvider</code></p>

<ul>
<li>提供者配置（ <code>topology.state.provider.config</code> ）</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang=""> {
   "keyClass": "Optional fully qualified class name of the Key type.",
   "valueClass": "Optional fully qualified class name of the Value type.",
   "keySerializerClass": "Optional Key serializer implementation class.",
   "valueSerializerClass": "Optional Value Serializer implementation class.",
   "hbaseConfigKey": "config key to load hbase configuration from storm root configuration. (similar to storm-hbase)",
   "tableName": "Pre-created table name for state.",
   "columnFamily": "Pre-created column family for state."
 }
</code></pre></div>
<p>如果要从代码库初始化HBase状态提供程序，请参见以下示例：</p>
<div class="highlight"><pre><code class="language-" data-lang="">Config conf = new Config();
    Map&lt;String, Object&gt; hbConf = new HashMap&lt;String, Object&gt;();
    hbConf.put("hbase.rootdir", "file:///tmp/hbase");
    conf.put("hbase.conf", hbConf);
    conf.put("topology.state.provider",  "org.apache.storm.hbase.state.HBaseKeyValueStateProvider");
    conf.put("topology.state.provider.config", "{" +
            "   \"hbaseConfigKey\": \"hbase.conf\"," +
            "   \"tableName\": \"state\"," +
            "   \"columnFamily\": \"cf\"" +
            " }");
</code></pre></div>
<ul>
<li>要添加的工件（ <code>--artifacts</code> ）</li>
</ul>

<p><code>org.apache.storm:storm-hbase:<storm-version></code></p>
</div>


	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>聚会</h5>
                    <ul class="latest-news">
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Apache-Kafka/">Apache Storm和Apache Kafka</a> <span class="small">（加利福尼亚州桑尼维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Apache Storm和Kafka用户</a> <span class="small">（华盛顿州西雅图）</span></li>
                        
                        <li><a href="http://www.meetup.com/New-York-City-Storm-User-Group/">NYC Storm用户组</a> <span class="small">（纽约州纽约）</span></li>
                        
                        <li><a href="http://www.meetup.com/Bay-Area-Stream-Processing">湾区流处理</a> <span class="small">（加利福尼亚州埃默里维尔）</span></li>
                        
                        <li><a href="http://www.meetup.com/Boston-Storm-Users/">波士顿实时数据</a> <span class="small">（马萨诸塞州波士顿）</span></li>
                        
                        <li><a href="http://www.meetup.com/storm-london">伦敦风暴用户组</a> <span class="small">（英国伦敦）</span></li>
                        
                        <!-- <li><a href="http://www.meetup.com/Apache-Storm-Kafka-Users/">Seatle, WA</a> <span class="small">(27 Jun 2015)</span></li> -->
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>关于Apache Storm</h5>
                    <p>Apache Storm与任何排队系统和任何数据库系统集成。Apache Storm的喷口抽象使集成新排队系统变得容易。同样，将Apache Storm与数据库系统集成很容易。</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>第一眼</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/Rationale.html">基本原理</a></li>
                        <li><a href="/releases/current/Tutorial.html">讲解</a></li>
                        <li><a href="/releases/current/Setting-up-development-environment.html">搭建开发环境</a></li>
                        <li><a href="/releases/current/Creating-a-new-Storm-project.html">创建一个新的Apache Storm项目</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>文献资料</h5>
                    <ul class="footer-list">
                        <li><a href="/releases/current/index.html">指数</a></li>
                        <li><a href="/releases/current/javadocs/index.html">Java文档</a></li>
                        <li><a href="/releases/current/FAQ.html">常问问题</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">版权所有©2019 <a href="http://www.apache.org">Apache Software Foundation</a> 。版权所有。
                    <br>Apache Storm，Apache，Apache Feather徽标和Apache Storm项目徽标是The Apache Software Foundation的商标。
                    <br>提及的所有其他商标可能是其各自所有者的商标或注册商标。</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 





</body></html>