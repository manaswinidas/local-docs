<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - How It Works">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-工作原理</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="ws-support.html">WS- *支持</a> > <a href="ws-policy.html">WS-Policy</a> > <a href="how-it-works.html">工作</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h2 id="HowItWorks-RetrievalofPolicies">检索政策</h2>

<p>策略与策略主题相关联。在Web服务上下文中，有四个不同的主题：</p>
<ul><li>服务</li><li>终点</li><li>运作方式</li><li>信息</li></ul>


<p>使用WSDL 1.1，策略主题关联通常采用<strong>xml元素附件</strong>的形式： <strong>附加</strong>了wsp：Policy元素（wsp前缀表示<a shape="rect" class="external-link" href="http://www.w3.org/2006/07/ws-policy" rel="nofollow">http://www.w3.org/2006/07/ws-policy</a>命名空间）到诸如wsdl：port之类的WSDL元素。或者，将wsp：PolicyReference元素附加到wsdl元素。在那种情况下，实际的wsp：Policy元素可以驻留在wsdl之外。<br clear="none">请注意，主题并不直接对应于wsdl元素。相反，它们映射到一组wsdl元素（请参见下文）。例如，wsdl：port，wsdl：portType和wsdl：binding元素一起将端点描述为主题。</p>

<p>将策略与策略主题相关联的另一种形式是<strong>外部附件</strong> ：wsp：PolicyAttachment元素（可以驻留在任意位置）在其ApplyliesTo子元素中显式指定它们要应用的主题。</p>

<p>在CXF中，附加到wsdl元素的元素可用作该wsdl元素的服务模型表示中的扩展器。 wsp：Policy或wsp：PolicyReference元素可以作为UnknownExtensibilityElement类型的扩展器获得，其中元素名称与wsp：Policy或wsp：PolicyReference元素的名称匹配。请注意，构建服务模型时不会解析这些附加的元素。<br clear="none">使用WSDL 1.1中的xml元素附件，给定一个Message对象，因此可以通过从存储在消息中（或存储在交换）。</p>

<p>另一方面，框架需要告知包含PolicyAttachment文档的文档的位置。这可以通过配置轻松实现，请参阅<a shape="rect" href="wspconfiguration.html">指定外部附件的位置</a> 。</p>

<p>PolicyAttachments对于域表达式的类型是灵活的。域表达式用于标识可以与策略相关联的实体，例如端点，操作或消息：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
&lt;wsp:PolicyAttachment&gt;
    &lt;wsp:AppliesTo&gt; 
        &lt;x:DomainExpression/&gt; +
    &lt;/wsp:AppliesTo&gt;
    (&lt;wsp:Policy&gt;...&lt;/wsp:Policy&gt; | 
          &lt;wsp:PolicyReference&gt;...&lt;/wsp:PolicyReference&gt;)
&lt;/wsp:PolicyAttachment&gt;
</pre>
</div></div>
<p>当前，CXF仅支持类型为wsa：EndpointReferenceType的域表达式：它们允许将附件中的策略或策略引用与端点关联（通过将端点的地址与EndpointReferenceType元素中的地址进行匹配）。但是，无法通过这种方式将策略与操作或消息相关联。<br clear="none">可以通过实现DomainExpressionBuilder接口并将相应的bean添加到您的配置文件中来插入对其他类型域表达式的支持（以这种方式加载的所有DomainExpressionBuilder实例将自动向DomainExpressionBuilder注册，因此在解析PolicyAttachment元素的过程中会被考虑） 。</p>

<p>一旦框架知道在哪里寻找wsp：Policy元素，它就可以解析这些元素并为其创建运行时演示。这就是AssertionBuilders发挥作用的地方：wsp：Policy元素中不在wsp名称空间中的所有子元素都被视为断言。框架将使用其AssertionBuilderRegistry查找为所讨论的元素类型注册的AssertionBuilder，如果找到一个，则继续从该元素构建Assertion对象（否则抛出PolicyException）。</p>

<h2 id="HowItWorks-ComputationofEffectivePolicies">有效政策的计算</h2>

<p>如上所述，策略与策略主题相关联。使用WSDL 1.1，针对主题的有效策略是对代表该主题的wsdl元素附加的策略的聚合或<strong>合并</strong> ：<br clear="none">服务主题的有效策略是将应用于wsdl：service元素的所有策略合并。<br clear="none">端点主题的有效策略是将应用于wsdl：port，wsdl：portType和wsdl：binding元素的所有策略合并。<br clear="none">操作主题的有效策略是将适用于wsdl：portType / wsdl：operation和wsdl：binding / wsdl：operation元素的所有策略合并。<br clear="none">（输入|输出|故障）消息主题的有效策略是应用于wsdl：message的所有策略的合并，（wsdl：portType / wsdl：operation / wsdl：input | wsdl：portType / wsdl：operation / wsdl：输出| wsdl：portType / wsdl：operation / wsdl：fault）和（wsdl：binding / wsdl：operation / wsdl：input | wsdl：binding / wsdl：operation / wsdl：output | wsdl：binding / wsdl：operation / wsdl：故障）。</p>

<p>发生其他聚合以确定端点的有效策略：<br clear="none">服务的有效策略是服务主题的有效策略。<br clear="none">端点的有效策略是服务主题和端点主题的有效策略的合并。<br clear="none">操作的有效策略是服务主题，端点主题和操作主题的有效策略的合并。<br clear="none">（输入|输出|故障）消息的有效策略是服务主题，端点主题，操作主题和消息主题的有效策略的合并。</p>

<p><img class="emoticon emoticon-information" src="https://cwiki.apache.org/confluence/s/en_GB/5997/6f42626d00e36f53fe51440403446ca61552e2a2.1/_/images/icons/emoticons/information.png" alt="（信息）" data-emoticon-name="information">可以使用<strong>多个来源</strong>将策略应用于同一主题。例如，在端点主题的情况下，其关联的wsdl：port元素可以具有多个wsp：Policy子元素。另外，一个单独的文档可以包含wsp：PolicyAttachment元素，其中AppliesTo子级将有问题的端点标识为目标主题。然后，附加在port元素上的策略以及匹配的PolicyAttachment元素中的策略都将有助于端点主题的有效策略。</p>

<p><img class="emoticon emoticon-information" src="https://cwiki.apache.org/confluence/s/en_GB/5997/6f42626d00e36f53fe51440403446ca61552e2a2.1/_/images/icons/emoticons/information.png" alt="（信息）" data-emoticon-name="information">同样重要的是要记住，上述聚合过程使有效的策略可以<strong>在一个替代方案中</strong>具有<strong>多个相同类型的断言元素</strong> （尽管这不会被视为正常情况）。同一替代方案中相同类型的不同断言<strong><em>不会</em></strong>相互覆盖。实际上，如果使用不当，它们可能会相互矛盾。但是它们也可以相互补充。无论哪种方式，框架都不会删除此类重复项，而是将其留给声明过程中涉及的拦截器（或其他声明者）来决定它们是否可以有意义地处理同一类型的多个声明。</p>

<p>显然，上述聚合过程可能会占用大量资源。因此，框架会缓存消息和端点的有效策略，以备将来参考。管理有效策略缓存的实体是PolicyEngine。</p>

<p>在计算端点或消息的有效策略时，框架还会选择有效策略的替代方法之一。目前，它的动产，其中所有的断言<strong><em>可</em></strong>通过拦截器被支持，或者（即，存在用于断言类型PolicyInterceptorProvider）或通过导管/目的地的第一替代（如果这实现了Assertor接口，并通过其canAssert方法确认其可以支持断言类型）。但是，即使可以找到这样的替代方案，也不一定支持所选择的替代方案：拦截器原则上可能能够支持特定类型的声明，但实际上可能无法支持该声明类型的单个实例。 。</p>

<p>替代项的选择以及拦截器集（从PolicyInterceptorProviderRegistry中的PolicyInterceptorProviders获取）与实际的有效消息或终结点策略一起以EffectivePolicy或EffectiveEndpointPolicy对象的形式进行缓存。在有效端点策略的情况下，选择拦截器的方式应使其能够支持所选择的有效端点策略的替代方案中的断言，也可以支持任何操作和消息特定策略的替代方案中的任何断言。在不知道基础消息的情况下，例如在服务器入站路径上，这是必要的：一旦为服务器端点的有效策略选择了替代方法，我们便知道无论基础消息/操作如何，都必须肯定支持哪些断言。 。为支持仅在特定操作或输入消息策略中出现的断言所必需的其他拦截器被抢先添加。请注意，这通常要求对拦截器进行防御性编码-无论如何都是好的做法，但对于PolicyInterceptorProviders返回的拦截器尤其如此！</p>

<h2 id="HowItWorks-On-the-flyProvisionofInterceptors">即时提供拦截器</h2>

<p>策略框架被激活时（通过加载PolicyEngine并将其“ enabled”属性设置为true），将在总线级别安装几个拦截器，它们在各自的拦截器链中较早执行：</p>
<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>角色</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>链</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>相</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>拦截器</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>已知有效的主题政策</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>客户</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>出</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>设定</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>ClientPolicyOutInterceptor</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>服务，端点，操作（（输入）消息）</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>客户</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>在</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>接收</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>ClientPolicyInInterceptor</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>服务，端点</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>客户</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>断层</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>接收</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>ClientPolicyInFaultInterceptor</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>服务，端点</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>服务器</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>在</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>接收</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>ServerPolicyInInterceptor</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>服务，端点</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>服务器</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>OutFault</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>设定</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>ServerPolicyOutFaultInterceptor</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>服务，端点，操作（（故障）消息）</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>服务器</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>出</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>设定</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>ServerPolicyOutInterceptor</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>服务，端点，操作（（出）消息）</p></td></tr></tbody></table></div>


<p>这些策略拦截器的主要目的是添加更多支持基础消息有效策略的拦截器-即使在执行策略拦截器时尚不知道该策略（因为该操作当时还未知）时间）。<br clear="none">如果有效消息策略是已知的，则将其选定替代项的断言以AssertionInfoMap的形式插入消息中。这是一个由断言类型名称作为关键字的AssertionInfo对象集合的映射，后者是Assertion对象的有状态（断言/未断言）表示形式。<br clear="none">当未知有效消息策略时，不仅在AssertionInfoMap中包括有效终结点策略中所选替代方案的断言，而且还包括所有操作和消息特定策略的所有替代方案中的所有断言。并非所有这些都将在链的末尾被断言，但是如果事实证明未声明的断言适用于操作sayHi，则很好，而实际上链已在处理针对greetMe请求的消息！</p>


<p>您可以在下图上看到它的设计方式：</p>

<p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="how-it-works.data/cxf-ws-policies.jpg"></span></p>

<p>简要地说，策略拦截器执行以下步骤：</p>
<ol><li>检查消息属性<em>PolicyConstants。POLICY_OVERRIDE</em> 。</li><li>如果<em>PolicyConstants。POLICY_OVERRIDE</em>包含政策，它将被采取进一步处理。</li><li>如果属性为空，则会从ServiceModel询问策略。这里，CXF加载附加到WSDL或通过Spring配置提供的策略。</li><li>如果在第2步或第3步中找到任何策略，则将创建<em>EffectivePolicy</em> 。适当的WS-policies将为当前消息合并，并内置到Neethi <em>Policy</em>对象中。</li><li>所有为结果策略声明注册的拦截器都将添加到消息拦截器链中。</li></ol>


<h2 id="HowItWorks-PolicyAwareInterceptors">策略感知拦截器</h2>

<p>可以识别策略的拦截器从消息中的AssertionInfoMap提取其理解的断言类型的AssertionInfo对象的集合。然后，他们可以使用包装的Assertion对象微调其行为，可能表现出特定于消息的行为。他们还可以表达他们是否可以支持这些主张。<br clear="none">给定一个具有属性的断言类型，并假设存在这种类型的断言的两个实例，则拦截器可以断言一个，但不能断言另一个。无论如何，无法支持拦截器理解的所有断言不一定表示失败。如上文有关抢先式拦截器安装所述，可能不受支持的拦截器实际上根本不会应用于基础消息。<br clear="none">通常，拦截器会努力支持尽可能多的这些断言，但是这样做可以利用AssertionBuilder的能力来计算兼容的断言。例如，通过安排在3秒内发送确认，RM拦截器将支持以下两个RMAssertions：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
&lt;wsrmp:RMAssertion xmlns:wsrmp="http://schemas.xmlsoap.org/ws/2005/02/rm/policy"&gt;
    &lt;wsrmp:AcknowledgementInterval Milliseconds="30000"/&gt;
&lt;/wsrmp:RMAssertion&gt;
&lt;wsrmp:RMAssertion xmlns:wsrmp="http://schemas.xmlsoap.org/ws/2005/02/rm/policy"&gt;
    &lt;wsrmp:AcknowledgementInterval Milliseconds="50000"/&gt;
&lt;/wsrmp:RMAssertion&gt;
</pre>
</div></div>

<h2 id="HowItWorks-Verification">验证</h2>

<p>策略框架安装的另一组拦截器负责验证是否确实支持基础消息的有效策略中的替代方法之一。这些拦截器是：</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>链</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>相</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>拦截器</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>Out，OutFault</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>POST_STREAM</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PolicyVerificationOutInterceptor</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>在</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_INVOKE</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PolicyVerificationInInterceptor</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>断层</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_INVOKE</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PolicyVerificationInFaultInterceptor</p></td></tr></tbody></table></div>


<p>它们的行为在客户端和服务器端是对称的。<br clear="none">在出站链上，有效的消息策略是在SETUP阶段执行的策略拦截器将AssertionInfoMap插入消息中时才知道的。由于该映射是完全根据Assertion对象构建的，Assertion对象是有效消息策略的所选替代方案的一部分，因此必须支持所有对象。换句话说，所有AssertionInfo对象都必须处于断言状态。如果其中之一不是，则拦截器将引发Fault（包装PolicyException）。</p>

<p>在入站路径上，还需要做更多的工作：如果消息是错误消息，我们现在就知道它是什么类型的错误以及它所适用的操作。如果该消息不是故障消息，则可以从拦截器（客户端或服务器端）的位置了解底层操作，从而推断出消息的主题（输入或输出消息）。无论哪种方式，现在都可以使用所有信息来获取有效的消息策略。要检查是否支持任何替代方案，策略验证拦截器然后只需检查其每个断言是否对应于映射中的关联AssertionInfo对象就处于断言状态。如果不支持任何替代方法，则拦截器将引发Fault（包装PolicyException）。</p>

<p>值得注意的一件事是-在出站和入站链上-可能存在只有管道或目的地可以支持的断言。尽管管道或目标可以在发送或接收当前消息时访问Assertion对象并调整其行为，但目前尚不知道此“定制”是否成功为基础消息（即问题的断言是否可以得到支持）在这一点上是不知道的。因此，策略验证拦截器将检查管道或目标是否实现了Assertor接口。确实如此，他们将其传递给Message对象，以便确认对这些断言的支持（或缺乏支持）。上述AssertionInfo映射的遍历仅在管道或目的地有机会做出其贡献之后发生。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=51375">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51375&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>