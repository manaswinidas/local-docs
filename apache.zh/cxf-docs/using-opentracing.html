<html ><head></head><body  onload="init()">﻿

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Using OpenTracing">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-使用OpenTracing</title>
  



<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="distributed-tracing.html">分布式跟踪</a> > <a href="using-opentracing.html">使用OpenTracing</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1546725419019 {padding: 0px;}
div.rbtoc1546725419019 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1546725419019 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1546725419019">
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-Overview">总览</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracinginApacheCXFusingOpenTracing">使用OpenTracing在Apache CXF中进行分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenTracing-ANoteonOpenTracingAPIs">有关OpenTracing API的说明</a></li><li><a shape="rect" href="#UsingOpenTracing-OpenTracingAPIv0.30.0andApacheCXF3.2.x">OpenTracing API v0.30.0和Apache CXF 3.2.x</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-ConfiguringClient">配置客户端</a></li><li><a shape="rect" href="#UsingOpenTracing-ConfiguringServer">配置服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingInAction:UsageScenarios">实际中的分布式跟踪：使用方案</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-Example">示例1：配置了默认分布式跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例2：具有嵌套跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃3：带有时间轴的客户端和服务器跟踪</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">例4：具有二进制注释（键/值）的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃7：具有异步调用的客户端和服务器（客户端）</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport">具有OpenTracing和JAX-WS支持的分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi">使用OpenTracing和OSGi进行分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenTracing-Samples">样品</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-OpenTracingAPIv0.31.0andApacheCXF3.3.x">OpenTracing API v0.31.0和Apache CXF 3.3.x</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-ConfiguringClient.1">配置客户端</a></li><li><a shape="rect" href="#UsingOpenTracing-ConfiguringServer.1">配置服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingInAction:UsageScenarios.1">实际中的分布式跟踪：使用方案</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-Example">示例1：配置了默认分布式跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例2：具有嵌套跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃3：带有时间轴的客户端和服务器跟踪</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">例4：具有注释（键/值）的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</a></li><li><a shape="rect" href="#UsingOpenTracing-Example">示例＃7：具有异步调用的客户端和服务器（客户端）</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport.1">具有OpenTracing和JAX-WS支持的分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi.1">使用OpenTracing和OSGi进行分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenTracing-Samples.1">样品</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-AccessingOpenTracingAPIs">访问OpenTracing API</a></li></ul>
</div><h1 id="UsingOpenTracing-Overview">总览</h1><p><a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>是供应商中立的分布式跟踪开放标准。本质上，对于基于Java的项目，该规范以一组<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API的</a>形式存在，欢迎任何分布式跟踪解决方案实现。有<a shape="rect" class="external-link" href="http://opentracing.io/documentation/pages/supported-tracers" rel="nofollow">很多</a>与<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>兼容的<a shape="rect" class="external-link" href="http://opentracing.io/documentation/pages/supported-tracers" rel="nofollow">分布式跟踪框架</a> ，尤其是<a shape="rect" class="external-link" href="http://zipkin.io/" rel="nofollow">Zipkin</a> （通过社区贡献，例如<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave-opentracing" rel="nofollow">从Brave到OpenTracing的桥梁</a> ）， <a shape="rect" class="external-link" href="http://lightstep.com/" rel="nofollow">Lightstep</a>和<a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a> 。从<strong>3.2.1</strong>版本开始，Apache CXF完全支持（通过<strong>cxf-integration-tracing-opentracing</strong>模块）与任何提供<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a>实现的分布式跟踪器<strong>的集成</strong> 。</p><p><a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+Apache+HTrace">专门用于Apache HTrace</a>的部分<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+Apache+HTrace">对</a>分布式跟踪基础进行了很好的介绍，但是<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>规范抽象了很多内容，仅概述了表示<strong>Span</strong>生命周期的通用API和用于在多个分布式组件之间传播上下文的注入点。这样，有关HTTP标头fe的固有详细信息将成为您选择的分布式跟踪器的组成部分，而Apache CXF则无法做到。</p><h1 id="UsingOpenTracing-DistributedTracinginApacheCXFusingOpenTracing">使用OpenTracing在Apache CXF中进行分布式跟踪</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>是用于构建服务和Web API的非常流行的框架。毫无疑问，它在微服务架构的背景下将发挥更大的作用，使开发人员能够快速构建和部署单独的JAX-RS / JAX-WS服务。分布式跟踪是观察整个应用程序平台的一项必不可少的技术，它可以在遍历并跨越线程，进程和机器的边界时，将请求分解为单个服务跟踪。</p><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF中</a>当前的分布式跟踪集成支持<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> <strong class="external-link">0.30.0+，</strong>并提供对JAX-RS 2.x / JAX-WS应用程序的全面支持。从高级的角度来看，JAX-RS集成包括三个主要部分：</p><ul><li><strong>TracerContext</strong> （可通过<strong>@Context</strong>注释<strong>注入</strong> ）</li><li><strong>OpenTracingProvider</strong> （服务器端JAX-RS提供程序）和<strong>OpenTracingClientProvider</strong> （客户端JAX-RS提供程序）</li><li class="external-link"><strong>OpenTracingFeature</strong> （服务器端JAX-RS功能）可简化配置和集成</li></ul><p>同样，从高级角度看，JAX-WS集成包括：</p><ul><li><strong>OpenTracingStartInterceptor</strong> / <strong>OpenTracingStopInterceptor</strong> / <strong>OpenTracingFeature</strong> <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>功能（服务器端JAX-WS支持）</li><li><strong>OpenTracingClientStartInterceptor</strong> / <strong>OpenTracingClientStopInterceptor</strong> / <strong>OpenTracingClientFeature</strong> <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>功能（客户端JAX-WS支持）</li></ul><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>使用HTTP标头将跟踪上下文从客户端传递到服务，并从服务传递到服务。这些标头特定于您选择的分发跟踪框架，并且当前无法配置（除非框架本身有这样做的方式）。</p><p>默认情况下， <strong>OpenTracingClientProvider</strong>会在每次服务调用时尝试通过HTTP标头传递当前活动的<strong>跨度</strong> 。如果没有活动范围，则将基于每次调用创建新范围并通过HTTP标头传递。实质上，JAX-RS应用只是在客户端和<strong>OpenTracingProvider</strong>服务器上注册<strong>OpenTracingClientProvider</strong>足有跟踪角度来正确地传递无处不在。唯一必要的配置部分是<strong>跨度报告</strong> <strong>器</strong>和<strong>采样器</strong> ，这并不奇怪，它们特定于您选择的分布式跟踪框架。</p><p>还值得一提的是<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>将描述附加到<strong>spans的方式</strong> 。关于客户端集成，该描述将成为由HTTP方法作为前缀调用的完整URL，例如： <strong>GET</strong> <a shape="rect" class="external-link" href="http://localhost:8282/books" rel="nofollow"><strong>http：// localhost：8282</strong> / books</a> 。在服务器端集成上，描述成为以HTTP方法为前缀的相对JAX-RS资源路径，例如： <strong>GET书籍，POST书籍/ 123</strong></p><h1 id="UsingOpenTracing-ANoteonOpenTracingAPIs">有关OpenTracing API的说明</h1><p><a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a>的发展非常迅速，令人遗憾但并不奇怪的是，所做的更改通常不向后兼容。截至目前， <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> <strong>3.2.x</strong>发行分支仍保留在<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> <strong class="external-link">0.30.0</strong>上，而<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> <strong>3.3.x</strong>则使用<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> <strong class="external-link">0.31.0</strong> 。有<strong class="external-link"> </strong>这两个API之间有很多主要区别，但是<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>努力使其平滑。值得一提的是，与<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>兼容的客户端和服务器可能不依赖于相同的API版本，您遇到的唯一问题与所选择的跟踪器所提供的Java客户端的兼容性有关。</p><h1 id="UsingOpenTracing-OpenTracingAPIv0.30.0andApacheCXF3.2.x">OpenTracing API v0.30.0和Apache CXF 3.2.x</h1><h2 id="UsingOpenTracing-ConfiguringClient">配置客户端</h2><p>在本节及以下各节中，所有代码段都将基于<a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>分布式跟踪框架（ <strong>版本0.20.6+</strong> ），尽管我们将讨论的内容同样适用于任何其他现有替代方法。本质上， <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>集成唯一依赖的依赖项是<strong>Tracer</strong>实例。</p><p>根据客户端的实现，可以通过多种方式配置JAX-RS客户端。<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>提供了自己的<strong>WebClient</strong> ，可以像这样配置（在将来的版本中，将使用客户端特定的功能来实现此目的的更简单方法）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("web-client", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();
                
Response response = WebClient
    .create("http://localhost:9000/catalog", Arrays.asList(new OpenTracingClientProvider(tracer)))
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>基于使用标准JAX-RS <strong>客户端</strong>的配置非常相似：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();
                
final OpenTracingClientProvider provider = new OpenTracingClientProvider(tracer);
final Client client = ClientBuilder.newClient().register(provider);
    
final Response response = client
  .target("http://localhost:9000/catalog")
  .request()
  .accept(MediaType.APPLICATION_JSON)
  .get();</pre>
</div></div><p>或者，您可以使用<strong>GlobalTracer</strong>来传递跟踪程序，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();

// This method should only be called once during the application initialization phase.
GlobalTracer.register(tracer);

// No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
final OpenTracingClientProvider provider = new OpenTracingClientProvider();</pre>
</div></div><h2 id="UsingOpenTracing-ConfiguringServer">配置服务器</h2><p><strong>借助</strong>可用的功能类<strong>OpenTracingFeature</strong> ，服务器配置比客户端配置简单一些。根据<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>用于配置JAX-RS服务的方式，它可能是JAX-RS应用程序配置的一部分，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        final Tracer tracer = new Configuration("tracer-server", 
                new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
                new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
            ).getTracer();

            
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    new OpenTracingFeature(tracer)
                )
            );
    } 
}</pre>
</div></div><p>或者也可以使用<strong>JAXRSServerFactoryBean</strong>对其进行配置，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer-server", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();

final JAXRSServerFactoryBean factory = RuntimeDelegate.getInstance().createEndpoint(/* application instance */, JAXRSServerFactoryBean.class);
factory.setProvider(new OpenTracingFeature(tracer));
...
return factory.create();</pre>
</div></div><p>或者，您可以依靠<strong>GlobalTracer</strong>来传递跟踪程序，因此在这种情况下， <strong>OpenTracingFeature</strong>将从那里开始进行跟踪，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    // No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
                    new OpenTracingFeature()
                )
            );
    } 
}</pre>
</div></div><p>一旦正确配置了<strong>跨度报告</strong> <strong>器</strong>和<strong>采样器</strong> ，将收集所有生成的<strong>跨度</strong>并将其用于分析和/或可视化。</p><h2 id="UsingOpenTracing-DistributedTracingInAction:UsageScenarios">实际中的分布式跟踪：使用方案</h2><p class="confluence-link">在以下小节中，我们将通过许多不同的场景来说明实际中的分布式跟踪，从最简单的场景开始，以异步JAX-RS服务结束。所有示例均假设<strong>已完成</strong> <a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringClient"><span class="confluence-link"><span class="confluence-link">配置</span></span></a> （请参阅<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringClient"><span class="confluence-link"><span class="confluence-link">配置客户端</span></span></a> <span class="confluence-link"> </span>和<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-configuringserver"><span class="confluence-link"> </span></a>以上<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringServer"><span class="confluence-link">配置服务器</span></a>部分）。</p><h3 id="UsingOpenTracing-Example#1:ClientandServerwithdefaultdistributedtracingconfigured">示例1：配置了默认分布式跟踪的客户端和服务器</h3><p>在第一个示例中，我们将看到仅在注册了<strong>OpenTracingClientProvider</strong>和<strong><strong>OpenTracing</strong> Provider的</strong>情况下在客户端和服务器上使用默认配置的效果。JAX-RS资源端点是非常基本的存根方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>客户端就是这么简单：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Response response = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>客户端（使用服务名称<strong>tracer-client</strong> ）对请求的实际调用以及服务器端（服务名称<strong>tracer-server</strong> ）的服务随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 12:41:7.png"></span></p><p>使用传统的<a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a>前端，相同的跟踪将看起来非常相似：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 13:18:20.png"></span></p><h3 id="UsingOpenTracing-Example#2:ClientandServerwithnestedtrace">示例2：具有嵌套跟踪的客户端和服务器</h3><p>在此示例中，JAX-RS服务的服务器端实现将在其自己的跨度内调用外部系统（模拟为500ms的简单延迟）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    try(final ActiveSpan scope = tracer.startSpan("Calling External System")) {
        // Simulating a delay of 500ms required to call external system
        Thread.sleep(500);
            
        return Arrays.asList(
            new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
        );
    }
}</pre>
</div></div><p>由客户端的请求（具有服务名称<strong><span class="label label-default service-filter-label service-tag-filtered"><strong>示踪剂</strong> -client）</span></strong>和在服务器端的服务（服务名称<strong><span class="label label-default service-filter-label"><strong>的示踪物-</strong>服务器</span></strong> <span class="label label-default service-filter-label">）</span>的随后调用的调用实际将要产生下面的示例迹线（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">积UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:9:7.png"></span></p><p>使用传统的<a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a>前端，相同的跟踪将看起来非常相似：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:10:40.png"></span></p><h3 id="UsingOpenTracing-Example#3:ClientandServertracewithtimeline">示例＃3：带有时间轴的客户端和服务器跟踪</h3><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加时间线。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    tracer.timeline("Preparing Books");
    // Simulating some work using a delay of 100ms
    Thread.sleep(100);
         
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>客户端（使用服务名<strong><span class="label label-default service-filter-label service-tag-filtered">tracer-client</span></strong> ）对请求的实际调用以及服务器端（服务名<strong><span class="label label-default service-filter-label">traceser-server</span></strong> ）的服务随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="using-opentracing.data/image2017-9-10 14:26:23.png"></span></p><p> </p><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>请注意，时间轴在<a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>中被视为<strong>日志事件</strong> 。</p></div></div><p>使用传统的<a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a>前端，相同的跟踪将看起来非常相似：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:19:1.png"></span></p><h3 id="UsingOpenTracing-Example#4:ClientandServerwithbinaryannotations(key/value)">例4：具有二进制注释（键/值）的客户端和服务器</h3><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加键/值注释。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Collection&lt;Book&gt; books = Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
         
    tracer.annotate("# of books", Integer.toString(books.size()));
    return books;
}</pre>
</div></div><p>由客户端的请求（具有服务名称<strong><span class="label label-default service-filter-label service-tag-filtered"><strong><span class="label label-default service-filter-label service-tag-filtered"><strong>示踪剂</strong></span></strong> -client）</span></strong>和在服务器端的服务的结果调用（服务名<strong>的示踪物- <span class="label label-default service-filter-label">服务器</span></strong> ）的实际调用将要产生下面的示例服务器跟踪属性（摘自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">积UI</a> ） ：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="using-opentracing.data/image2017-9-10 14:40:20.png"></span></p><p>使用传统的<a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a>前端，相同的跟踪将看起来非常相似：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:46:4.png"></span></p><h3 id="UsingOpenTracing-Example#5:ClientandServerwithparalleltrace(involvingthreadpools)">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</h3><p>在此示例中，JAX-RS服务的服务器端实现将把一些工作卸载到线程池中，然后将响应返回给客户端，以模拟并行执行。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Future&lt;Book&gt; book1 = executor.submit(
        tracer.wrap("Getting Book 1", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(100);
                     
                return new Book("Apache CXF Web Service Development", 
                    "Naveen Balani, Rajeev Hathi");
            }
        })
    );
         
    final Future&lt;Book&gt; book2 = executor.submit(
        tracer.wrap("Getting Book 2", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(200);
                     
                return new Book("Developing Web Services with Apache CXF and Axis2", 
                    "Kent Ka Iok Tong");
            }
        })
    );
        
    return Arrays.asList(book1.get(), book2.get());
}</pre>
</div></div><p>客户端（使用服务名称<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端（流程名称<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的服务随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:49:4.png"></span></p><p>使用传统的<a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a>前端，相同的跟踪将看起来非常相似：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:50:2.png"></span></p><h3 id="UsingOpenTracing-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side)">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</h3><p>在此示例中，JAX-RS服务的服务器端实现将异步执行。由于在不同线程（通常）中处理请求和响应，因此从跟踪预期对象构成了挑战。目前， <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>不支持透明的跟踪范围管理（默认用例除外），但是提供了实现此目的的简单方法（允许跨线程转移范围）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public void getBooks(@Suspended final AsyncResponse response, @Context final TracerContext tracer) throws Exception {
    tracer.continueSpan(new Traceable&lt;Future&lt;Void&gt;&gt;() {
        public Future&lt;Void&gt; call(final TracerContext context) throws Exception {
            return executor.submit(
                tracer.wrap("Getting Book", new Traceable&lt;Void&gt;() {
                    public Void call(final TracerContext context) throws Exception {
                        // Simulating a processing delay of 50ms
                        Thread.sleep(50);
                             
                        response.resume(
                            Arrays.asList(
                                new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
                            )
                        );
                             
                        return null;
                    }
                })
            );
        }
    });
}</pre>
</div></div><p>客户端（使用服务名称<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端服务（服务名称<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:54:2.png"></span></p><p>使用传统的<a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a>前端，相同的跟踪将看起来非常相似：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:55:0.png"></span></p><h3 id="UsingOpenTracing-Example#7:ClientandServerwithasynchronousinvocation(client-side)">示例＃7：具有异步调用的客户端和服务器（客户端）</h3><p>在此示例中，JAX-RS服务的服务器端实现将是默认的：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>当JAX-RS客户端实现将执行异步调用时：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Future&lt;Response&gt; future = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .async()
    .get();</pre>
</div></div><p>在这方面，与调用方预期对象没有什么区别，但是要进行更多的工作以将活动跟踪范围从JAX-RS客户端请求过滤器转移到客户端响应过滤器，因为通常在不同线程中执行（类似服务器端异步JAX-RS资源调用）。客户端（使用服务名称<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端服务（服务名称<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 15:0:49.png"></span></p><p>使用传统的<a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a>前端，相同的跟踪将看起来非常相似：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10 14:58:53.png"></span></p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport">具有OpenTracing和JAX-WS支持的分布式跟踪</h2><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>中的分布式跟踪主要围绕JAX-RS 2.x实现而构建。但是，还支持JAX-WS，但它需要编写一些样板代码并直接使用<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> （将来将增强JAX-WS集成）。本质上，应该从服务器端预期的输入/输出拦截器分别手动或使用<strong><strong>OpenTracing</strong> Feature</strong>将<strong>OpenTracingStartInterceptor</strong>和<strong><strong>OpenTracing</strong> StopInterceptor</strong>配置为拦截器链的一部分。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();

final JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();
...
sf.getFeatures().add(new OpenTracingFeature(trace));
...
sf.create();</pre>
</div></div><p>与服务器端类似，客户端需要自己的一组Out / <strong>In</strong>拦截器，即<strong><strong>OpenTracing</strong> ClientStartInterceptor</strong>和<strong><strong>OpenTracing</strong> ClientStopInterceptor</strong> （或<strong><strong>OpenTracing</strong> ClientFeature</strong> ）。请注意与服务器端的区别： <strong><strong>OpenTracing</strong> ClientStartInterceptor</strong>成为拦截器，而<strong><strong>OpenTracing</strong> ClientStopInterceptor</strong>成为拦截器。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();
              
final JaxWsProxyFactoryBean sf = new JaxWsProxyFactoryBean();
...
sf.getFeatures().add(new OpenTracingClientFeature(tracer));
...
sf.create();

</pre>
</div></div><p>如前所述，您可以使用<strong>GlobalTracer</strong>实用工具类来传递跟踪程序，例如，任何JAX-WS服务都可以通过调用<strong>GlobalTracer.get（）</strong>方法来检索当前的跟踪程序。</p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi">使用OpenTracing和OSGi进行分布式跟踪</h2><p class="external-link">可以将与<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> API兼容的大多数分布式跟踪器部署到<strong>OSGi</strong>容器中，这样，该集成对于容器内运行的<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>服务完全可用。有关完整示例，请查看<a shape="rect" class="external-link" href="https://github.com/apache/cxf/master/distribution/src/main/release/samples/jax_rs_tracing_opentracing_osgi/README.txt" rel="nofollow">jax_rs_tracing_opentracing_osgi</a>示例项目，但是如果是<a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a> ，这是典型的<strong>OSGi</strong>蓝图片段。</p><p class="external-link"> </p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://cxf.apache.org/blueprint/core"
       xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"

       xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
                           http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd
                           http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd"&gt;

    &lt;bean id="tracingFeature" class="org.apache.cxf.tracing.opentracing.jaxrs.OpenTracingFeature"&gt;
        &lt;argument index="0"&gt;
            &lt;bean factory-ref="builder" factory-method="build" /&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="metrics" class="com.uber.jaeger.metrics.Metrics"&gt;
        &lt;argument index="0"&gt;
            &lt;bean class="com.uber.jaeger.metrics.StatsFactoryImpl"&gt;
                &lt;argument index="0"&gt;
                    &lt;bean class="com.uber.jaeger.metrics.NullStatsReporter" /&gt;
                &lt;/argument&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="builder" class="com.uber.jaeger.Tracer.Builder"&gt;
        &lt;argument index="0" value="cxf-server" /&gt;
        &lt;argument index="1"&gt;
            &lt;bean class="com.uber.jaeger.reporters.RemoteReporter"&gt;
                &lt;argument index="0" ref="sender" /&gt;
                &lt;argument index="1" value="1000"/&gt;
                &lt;argument index="2" value="100"/&gt;
                &lt;argument index="3" ref="metrics"/&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
        &lt;argument index="2"&gt;
            &lt;bean class="com.uber.jaeger.samplers.ConstSampler"&gt;
                &lt;argument index="0" value="true" /&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sender" class="com.uber.jaeger.senders.HttpSender"&gt;
        &lt;argument index="0" value="http://localhost:14268/api/traces" /&gt;
    &lt;/bean&gt;
    
    &lt;cxf:bus&gt;
        &lt;cxf:features&gt;
            &lt;cxf:logging /&gt;
        &lt;/cxf:features&gt;
    &lt;/cxf:bus&gt;

    &lt;jaxrs:server id="catalogServer" address="/"&gt;
        &lt;jaxrs:serviceBeans&gt;
            ...
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:providers&gt;
            &lt;ref component-id="tracingFeature" /&gt;
        &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;
&lt;/blueprint&gt;</pre>
</div></div><h2 id="UsingOpenTracing-Samples">样品</h2><ul style="list-style-type:square"><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing" rel="nofollow">https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel" rel="nofollow">https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi" rel="nofollow">https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi</a></li></ul><h1 id="UsingOpenTracing-OpenTracingAPIv0.31.0andApacheCXF3.3.x">OpenTracing API v0.31.0和Apache CXF 3.3.x</h1><h2 id="UsingOpenTracing-ConfiguringClient.1">配置客户端</h2><p>在本节及以下各节中，所有代码段都将基于<a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>分布式跟踪框架（ <strong>发行版0.30.3+</strong> ），尽管我们将要讨论的所有内容同样适用于任何其他现有替代方案。本质上， <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>集成唯一依赖的依赖项是<strong>Tracer</strong>实例。<a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>使用服务Java的<a shape="rect" class="external-link" href="https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html" rel="nofollow">ServiceLoader</a>机制来确定要使用的跟踪程序的实例，因此有必要提供<strong>META-INF / services / io.jaegertracing.spi。SenderFactory</strong>绑定，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">io.jaegertracing.thrift.internal.senders.ThriftSenderFactory</pre>
</div></div><p>或者，您可以只提供带有重写<strong>getSender</strong>方法的<strong>SenderConfiguration</strong>自己的实现，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final SenderConfiguration senderConfiguration = new SenderConfiguration() {
    @Override
    public Sender getSender() {
        return ...; /* the desired Sender implementation */
    }
}</pre>
</div></div><p>根据客户端的实现，可以通过多种方式配置JAX-RS客户端。<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>提供了自己的<strong>WebClient</strong> ，可以像这样配置（在将来的版本中，将使用客户端特定的功能来实现此目的的更简单方法）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("web-client")
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();
                
Response response = WebClient
    .create("http://localhost:9000/catalog", Arrays.asList(new OpenTracingClientProvider(tracer)))
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>基于使用标准JAX-RS <strong>客户端</strong>的配置非常相似：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client") 
     .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
                
final OpenTracingClientProvider provider = new OpenTracingClientProvider(tracer);
final Client client = ClientBuilder.newClient().register(provider);
    
final Response response = client
  .target("http://localhost:9000/catalog")
  .request()
  .accept(MediaType.APPLICATION_JSON)
  .get();</pre>
</div></div><p>或者，您可以使用<strong>GlobalTracer</strong>来传递跟踪程序，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client")
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();

// This method should only be called once during the application initialization phase.
GlobalTracer.register(tracer);

// No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
final OpenTracingClientProvider provider = new OpenTracingClientProvider();</pre>
</div></div><h2 id="UsingOpenTracing-ConfiguringServer.1">配置服务器</h2><p><strong>借助</strong>可用的功能类<strong>OpenTracingFeature</strong> ，服务器配置比客户端配置简单一些。根据<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>用于配置JAX-RS服务的方式，它可能是JAX-RS应用程序配置的一部分，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        final Tracer tracer = new Configuration("tracer-server") 
            .withSampler(
                new SamplerConfiguration()
                    .withType(ConstSampler.TYPE) /* or any other Sampler */
                    .withParam(1)
            )
            .withReporter(
                new ReporterConfiguration()
                    .withSender(
                        new SenderConfiguration() /* or any other Sender configuration */
                            .withEndpoint("http://localhost:14268/api/traces")
                    )
            )
            .getTracer();
            
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    new OpenTracingFeature(tracer)
                )
            );
    } 
}</pre>
</div></div><p>或者也可以使用<strong>JAXRSServerFactoryBean</strong>对其进行配置，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer-server") 
    .withSampler(
        new SamplerConfiguration()
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();

final JAXRSServerFactoryBean factory = RuntimeDelegate.getInstance().createEndpoint(/* application instance */, JAXRSServerFactoryBean.class);
factory.setProvider(new OpenTracingFeature(tracer));
...
return factory.create();</pre>
</div></div><p>或者，您可以依靠<strong>GlobalTracer</strong>来传递跟踪程序，因此在这种情况下， <strong>OpenTracingFeature</strong>将从那里开始进行跟踪，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    // No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
                    new OpenTracingFeature()
                )
            );
    } 
}</pre>
</div></div><p>一旦正确配置了<strong>跨度报告</strong> <strong>器</strong>和<strong>采样器</strong> ，将收集所有生成的<strong>跨度</strong>并将其用于分析和/或可视化。</p><h2 id="UsingOpenTracing-DistributedTracingInAction:UsageScenarios.1">实际中的分布式跟踪：使用方案</h2><p class="confluence-link">在以下小节中，我们将通过许多不同的场景来说明实际中的分布式跟踪，从最简单的场景开始，以异步JAX-RS服务结束。所有示例均假设<strong>已完成</strong> <a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringClient.1"><span class="confluence-link"><span class="confluence-link">配置</span></span></a> （请参阅<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringClient.1"><span class="confluence-link"><span class="confluence-link">配置客户端</span></span></a> <span class="confluence-link"> </span>和<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-configuringserver"><span class="confluence-link"> </span></a>以上<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringServer.1"><span class="confluence-link">配置服务器</span></a>部分）。</p><h3 id="UsingOpenTracing-Example#1:ClientandServerwithdefaultdistributedtracingconfigured.1">示例1：配置了默认分布式跟踪的客户端和服务器</h3><p>在第一个示例中，我们将看到仅在注册了<strong>OpenTracingClientProvider</strong>和<strong><strong>OpenTracing</strong> Provider的</strong>情况下在客户端和服务器上使用默认配置的效果。JAX-RS资源端点是非常基本的存根方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>客户端就是这么简单：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Response response = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>客户端（使用服务名称<strong>tracer-client</strong> ）对请求的实际调用以及服务器端（服务名称<strong>tracer-server</strong> ）的服务随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_14-59-19.png"></span></p><h3 id="UsingOpenTracing-Example#2:ClientandServerwithnestedtrace.1">示例2：具有嵌套跟踪的客户端和服务器</h3><p>在此示例中，JAX-RS服务的服务器端实现将在其自己的跨度内调用外部系统（模拟为500ms的简单延迟）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    try(final Scope scope = tracer.startSpan("Calling External System")) {
        // Simulating a delay of 500ms required to call external system
        Thread.sleep(500);
            
        return Arrays.asList(
            new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
        );
    }
}</pre>
</div></div><p>由客户端的请求（具有服务名称<strong><span class="label label-default service-filter-label service-tag-filtered"><strong>示踪剂</strong> -client）</span></strong>和在服务器端的服务（服务名称<strong><span class="label label-default service-filter-label"><strong>的示踪物-</strong>服务器</span></strong> <span class="label label-default service-filter-label">）</span>的随后调用的调用实际将要产生下面的示例迹线（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">积UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-1-39.png"></span></p><h3 id="UsingOpenTracing-Example#3:ClientandServertracewithtimeline.1">示例＃3：带有时间轴的客户端和服务器跟踪</h3><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加时间线。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    tracer.timeline("Preparing Books");
    // Simulating some work using a delay of 100ms
    Thread.sleep(100);
         
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>客户端（使用服务名<strong><span class="label label-default service-filter-label service-tag-filtered">tracer-client</span></strong> ）对请求的实际调用以及服务器端（服务名<strong><span class="label label-default service-filter-label">traceser-server</span></strong> ）的服务随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="920" src="using-opentracing.data/image2018-8-12_15-7-45.png"></span></p><h3 id="UsingOpenTracing-Example#4:ClientandServerwithannotations(key/value)">例4：具有注释（键/值）的客户端和服务器</h3><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加键/值注释。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Collection&lt;Book&gt; books = Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
         
    tracer.annotate("# of books", Integer.toString(books.size()));
    return books;
}</pre>
</div></div><p>由客户端的请求（具有服务名称<strong><span class="label label-default service-filter-label service-tag-filtered"><strong><span class="label label-default service-filter-label service-tag-filtered"><strong>示踪剂</strong></span></strong> -client）</span></strong>和在服务器端的服务的结果调用（服务名<strong>的示踪物- <span class="label label-default service-filter-label">服务器</span></strong> ）的实际调用将要产生下面的示例服务器跟踪属性（摘自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">积UI</a> ） ：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2018-8-12_15-11-42.png"></span></p><h3 id="UsingOpenTracing-Example#5:ClientandServerwithparalleltrace(involvingthreadpools).1">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</h3><p>在此示例中，JAX-RS服务的服务器端实现将把一些工作卸载到线程池中，然后将响应返回给客户端，以模拟并行执行。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Future&lt;Book&gt; book1 = executor.submit(
        tracer.wrap("Getting Book 1", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(100);
                     
                return new Book("Apache CXF Web Service Development", 
                    "Naveen Balani, Rajeev Hathi");
            }
        })
    );
         
    final Future&lt;Book&gt; book2 = executor.submit(
        tracer.wrap("Getting Book 2", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(200);
                     
                return new Book("Developing Web Services with Apache CXF and Axis2", 
                    "Kent Ka Iok Tong");
            }
        })
    );
        
    return Arrays.asList(book1.get(), book2.get());
}</pre>
</div></div><p>客户端（使用服务名称<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端（流程名称<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的服务随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-13-13.png"></span></p><h3 id="UsingOpenTracing-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side).1">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</h3><p>在此示例中，JAX-RS服务的服务器端实现将异步执行。由于在不同线程（通常）中处理请求和响应，因此从跟踪预期对象构成了挑战。目前， <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>不支持透明的跟踪范围管理（默认用例除外），但是提供了实现此目的的简单方法（允许跨线程转移范围）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public void getBooks(@Suspended final AsyncResponse response, @Context final TracerContext tracer) throws Exception {
    tracer.continueSpan(new Traceable&lt;Future&lt;Void&gt;&gt;() {
        public Future&lt;Void&gt; call(final TracerContext context) throws Exception {
            return executor.submit(
                tracer.wrap("Getting Book", new Traceable&lt;Void&gt;() {
                    public Void call(final TracerContext context) throws Exception {
                        // Simulating a processing delay of 50ms
                        Thread.sleep(50);
                             
                        response.resume(
                            Arrays.asList(
                                new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
                            )
                        );
                             
                        return null;
                    }
                })
            );
        }
    });
}</pre>
</div></div><p>客户端（使用服务名称<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端服务（服务名称<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-15-19.png"></span></p><h3 id="UsingOpenTracing-Example#7:ClientandServerwithasynchronousinvocation(client-side).1">示例＃7：具有异步调用的客户端和服务器（客户端）</h3><p>在此示例中，JAX-RS服务的服务器端实现将是默认的：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>当JAX-RS客户端实现将执行异步调用时：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Future&lt;Response&gt; future = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .async()
    .get();</pre>
</div></div><p>在这方面，与调用方预期对象没有什么区别，但是要进行更多的工作以将活动跟踪范围从JAX-RS客户端请求过滤器转移到客户端响应过滤器，因为通常在不同线程中执行（类似服务器端异步JAX-RS资源调用）。客户端（使用服务名称<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端服务（服务名称<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的随后调用将生成以下示例跟踪（取自<a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a> ）：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-17-38.png"></span></p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport.1">具有OpenTracing和JAX-WS支持的分布式跟踪</h2><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>中的分布式跟踪主要围绕JAX-RS 2.x实现而构建。但是，还支持JAX-WS，但它需要编写一些样板代码并直接使用<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> （将来将增强JAX-WS集成）。本质上，应该从服务器端预期的输入/输出拦截器分别手动或使用<strong><strong>OpenTracing</strong> Feature</strong>将<strong>OpenTracingStartInterceptor</strong>和<strong><strong>OpenTracing</strong> StopInterceptor</strong>配置为拦截器链的一部分。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer")
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration() 
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();;

final JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();
...
sf.getFeatures().add(new OpenTracingFeature(trace));
...
sf.create();</pre>
</div></div><p>与服务器端类似，客户端需要自己的一组Out / <strong>In</strong>拦截器，即<strong><strong>OpenTracing</strong> ClientStartInterceptor</strong>和<strong><strong>OpenTracing</strong> ClientStopInterceptor</strong> （或<strong><strong>OpenTracing</strong> ClientFeature</strong> ）。请注意与服务器端的区别： <strong><strong>OpenTracing</strong> ClientStartInterceptor</strong>成为拦截器，而<strong><strong>OpenTracing</strong> ClientStopInterceptor</strong>成为拦截器。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer") 
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();;
              
final JaxWsProxyFactoryBean sf = new JaxWsProxyFactoryBean();
...
sf.getFeatures().add(new OpenTracingClientFeature(tracer));
...
sf.create();

</pre>
</div></div><p>如前所述，您可以使用<strong>GlobalTracer</strong>实用工具类来传递跟踪程序，例如，任何JAX-WS服务都可以通过调用<strong>GlobalTracer.get（）</strong>方法来检索当前的跟踪程序。</p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi.1">使用OpenTracing和OSGi进行分布式跟踪</h2><p class="external-link">可以将与<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> API兼容的大多数分布式跟踪器部署到<strong>OSGi</strong>容器中，这样，该集成对于容器内运行的<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>服务完全可用。有关完整示例，请查看<a shape="rect" class="external-link" href="https://github.com/apache/cxf/master/distribution/src/main/release/samples/jax_rs_tracing_opentracing_osgi/README.txt" rel="nofollow">jax_rs_tracing_opentracing_osgi</a>示例项目，但是如果是<a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a> ，这是典型的<strong>OSGi</strong>蓝图片段。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://cxf.apache.org/blueprint/core"
       xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"

       xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
                           http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd
                           http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd"&gt;

    &lt;bean id="tracingFeature" class="org.apache.cxf.tracing.opentracing.jaxrs.OpenTracingFeature"&gt;
        &lt;argument index="0"&gt;
            &lt;bean factory-ref="withReporter" factory-method="getTracer" /&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;

    &lt;bean id="samplerBuilder" class="io.jaegertracing.Configuration.SamplerConfiguration" /&gt;
    
    &lt;bean id="withType" factory-ref="samplerBuilder" factory-method="withType"&gt;
        &lt;argument index="0" value="const"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sampler" factory-ref="withType" factory-method="withParam"&gt;
        &lt;argument index="0"&gt;
            &lt;bean class="java.lang.Integer"&gt;
                &lt;argument value="1" /&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="senderBuilder" class="io.jaegertracing.Configuration.SenderConfiguration" /&gt;
    
    &lt;bean id="sender" factory-ref="senderBuilder" factory-method="withEndpoint"&gt;
        &lt;argument index="0" value="http://localhost:14268/api/traces"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="reporterBuilder" class="io.jaegertracing.Configuration.ReporterConfiguration" /&gt;
    
    &lt;bean id="reporter" factory-ref="reporterBuilder" factory-method="withSender"&gt;
        &lt;argument index="0" ref="sender"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="builder" class="io.jaegertracing.Configuration"&gt;
        &lt;argument index="0" value="cxf-server" /&gt;
    &lt;/bean&gt;

    &lt;bean id="withSampler" factory-ref="builder" factory-method="withSampler"&gt;
        &lt;argument index="0" ref="sampler"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="withReporter" factory-ref="withSampler" factory-method="withReporter"&gt;
        &lt;argument index="0" ref="reporter"/&gt;
    &lt;/bean&gt;
    
    &lt;cxf:bus&gt;
        &lt;cxf:features&gt;
            &lt;cxf:logging /&gt;
        &lt;/cxf:features&gt;
    &lt;/cxf:bus&gt;

    &lt;jaxrs:server id="catalogServer" address="/"&gt;
        &lt;jaxrs:serviceBeans&gt;
            ...
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:providers&gt;
            &lt;ref component-id="tracingFeature" /&gt;
        &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;
&lt;/blueprint&gt;</pre>
</div></div><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>到目前为止， <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>跟踪器尚未提供OSGi捆绑软件，并且服务加载程序机制无法很好地工作。您很可能需要声明自己的发送者配置实例（重写<strong>getSender</strong>方法）或使用系统属性来选择正确的发送者配置实例。</p></div></div><h2 id="UsingOpenTracing-Samples.1">样品</h2><ul><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing" rel="nofollow">https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel" rel="nofollow">https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi" rel="nofollow">https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi</a></li></ul><h1 id="UsingOpenTracing-AccessingOpenTracingAPIs">访问OpenTracing API</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>尽可能在<strong>TracerContext</strong>之后抽象出许多特定于跟踪器的API。但是，有时需要访问<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> API，以利用丰富的可用工具集。为了能够<strong>，TracerContext</strong>有返回底层<strong>示踪</strong>例如专用<strong>的解包</strong> 。下面的代码段演示了如何使用此API以及如何将<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>工具用于<a shape="rect" class="external-link" href="https://github.com/OpenFeign/feign-opentracing" rel="nofollow">OpenFeign客户端</a> 。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/search")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject search(@QueryParam("q") final String query, @Context final TracerContext tracing) throws Exception {
    final GoogleBooksApi api = Feign.builder()
        .client(new TracingClient(new ApacheHttpClient(), tracing.unwrap(Tracer.class)))
        .target(GoogleBooksApi.class, "https://www.googleapis.com");

    final Response response = api.search(query);
    try (final Reader reader = response.body().asReader()) {
        return Json.createReader(reader).readObject();
    }
}</pre>
</div></div></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=73637478">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=73637478&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>