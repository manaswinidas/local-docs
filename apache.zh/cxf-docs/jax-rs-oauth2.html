<html ><head></head><body  onload="init()">﻿

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS OAuth2">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS OAuth2</title>
  



<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-oauth2.html">JAX-RS OAuth2</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="JAX-RSOAuth2-JAX-RS:OAuth2">JAX-RS：OAuth2</h1><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1573736203932 {padding: 0px;}
div.rbtoc1573736203932 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1573736203932 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1573736203932">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-JAX-RS:OAuth2">JAX-RS：OAuth2</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Introduction">介绍</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Mavendependencies">Maven依赖</a></li><li><a shape="rect" href="#JAX-RSOAuth2-ClientRegistration">客户注册</a></li><li><a shape="rect" href="#JAX-RSOAuth2-DevelopingOAuth2Servers">开发OAuth2服务器</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-AuthorizationService">授权服务</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-HowtocreateAuthorizationView">如何创建授权视图</a></li><li><a shape="rect" href="#JAX-RSOAuth2-EndUserNameinAuthorizationForm">授权表格中的最终用户名</a></li><li><a shape="rect" href="#JAX-RSOAuth2-PublicClients(Devices)">公共客户（设备）</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-OOBResponse">OOB回应</a></li><li><a shape="rect" href="#JAX-RSOAuth2-PKCEsupport">PKCE支持</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-FormPostResponseMode">表单发布响应模式</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-AccessTokenService">AccessTokenService</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-AccessTokenTypes">访问令牌类型</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-Bearer">承载者</a></li><li><a shape="rect" href="#JAX-RSOAuth2-HAWK">鹰</a></li><li><a shape="rect" href="#JAX-RSOAuth2-MAC">苹果电脑</a></li><li><a shape="rect" href="#JAX-RSOAuth2-EncryptedTokens">加密令牌</a></li><li><a shape="rect" href="#JAX-RSOAuth2-JWTTokens">JWT代币</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Customtokens">自定义令牌</a></li><li><a shape="rect" href="#JAX-RSOAuth2-SimpleTokensandAudience">简单令牌和受众</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-OAuthJSONProvider">OAuthJSONProvider</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-AccessTokenValidationService">访问令牌验证服务</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-AccessTokenValidatorService">AccessTokenValidatorService</a></li><li><a shape="rect" href="#JAX-RSOAuth2-TokenIntrospectionService">TokenIntrospectionService</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-TokenRevocationService">令牌撤销服务</a></li><li><a shape="rect" href="#JAX-RSOAuth2-DynamicRegistrationService">动态注册服务</a></li><li><a shape="rect" href="#JAX-RSOAuth2-AuthorizationMetadataService">AuthorizationMetadataService</a></li><li><a shape="rect" href="#JAX-RSOAuth2-SupportedGrants">支持的补助金</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-AuthorizationCode">授权码</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Implicit">隐含的</a></li><li><a shape="rect" href="#JAX-RSOAuth2-ClientCredentials">客户凭证</a></li><li><a shape="rect" href="#JAX-RSOAuth2-ResourceOwnerPasswordCredentials">资源所有者密码凭证</a></li><li><a shape="rect" href="#JAX-RSOAuth2-RefreshToken">刷新令牌</a></li><li><a shape="rect" href="#JAX-RSOAuth2-SAMLandJWTAssertions">SAML和JWT断言</a></li><li><a shape="rect" href="#JAX-RSOAuth2-CustomGrants">海关补助</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-RedirectionFlowFilters">重定向流过滤器</a></li><li><a shape="rect" href="#JAX-RSOAuth2-AccessTokenResponseFilters">AccessTokenResponse筛选器</a></li><li><a shape="rect" href="#JAX-RSOAuth2-PreAuthorizedaccesstokens">预授权访问令牌</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Pre-registeredscopes">预注册范围</a></li><li><a shape="rect" href="#JAX-RSOAuth2-WritingOAuthDataProvider">编写OAuthDataProvider</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-DefaultProviders">默认提供者</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-OAuthServerJAX-RSendpoints">OAuth服务器JAX-RS端点</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-AuthorizationCodeandImplicitServicesonthesamerelativepath">相对路径上的AuthorizationCode和隐式服务</a></li></ul>
</li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-ThirdPartyClientAuthentication">第三方客户认证</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-ClientCertificateAuthentication">客户端证书认证</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-UserSessionAuthenticity">用户会话真实性</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-Keepingthestateinthesession">在会话中保持状态</a></li><li><a shape="rect" href="#JAX-RSOAuth2-MultipleFactorVerification">多因素验证</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-CustomizingEndUserSubjectinitialization">自定义最终用户主题初始化</a></li><li><a shape="rect" href="#JAX-RSOAuth2-ProtectingresourceswithOAuthfilters">使用OAuth过滤器保护资源</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-OAuth2tokensandSOAPendpoints">OAuth2令牌和SOAP端点</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-Scope-basedaccesscontrol">基于范围的访问控制</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Howtogettheuserloginname">如何获得用户登录名</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Client-sidesupport">客户端支持</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-AdvancedOAuth2clientapplications">先进的OAuth2客户端应用程序</a></li><li><a shape="rect" href="#JAX-RSOAuth2-OAuth2clientapplicationswithcode-grantfilters">带有代码授予过滤器的OAuth2客户端应用程序</a></li><li><a shape="rect" href="#JAX-RSOAuth2-OAuth2clientauthenticatorsfornon-dynamicclients">非动态客户端的OAuth2客户端身份验证器</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-OAuth2withouttheExplicitAuthorization">没有明确授权的OAuth2</a></li><li><a shape="rect" href="#JAX-RSOAuth2-OAuthWithoutaBrowser">没有浏览器的OAuth</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Reportingerrordetails">报告错误详细信息</a></li><li><a shape="rect" href="#JAX-RSOAuth2-OAuth2andJOSE">OAuth2和JOSE</a></li><li><a shape="rect" href="#JAX-RSOAuth2-OAuth2andOIDC">OAuth2和OIDC</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Designconsiderations">设计注意事项</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-ControllingtheAccesstoResourceServer">控制对资源服务器的访问</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth2-Sharingthesameaccesspathbetweenendusersandclients">在最终用户和客户端之间共享相同的访问路径</a></li><li><a shape="rect" href="#JAX-RSOAuth2-Providingdifferentaccesspointstoendusersandclients">为最终用户和客户端提供不同的访问点</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth2-SingleSignOn">单点登录</a></li></ul>
</li></ul>
</div><h1 id="JAX-RSOAuth2-Introduction">介绍</h1><p>新：</p><ul style="list-style-type:square"><li>JCache和JPA2 OAuthDataProviders（以及CXF 3.3.0之前的Ehcache 2.x）可以表示JWT中的访问令牌</li><li>支持客户端证书身份验证和令牌绑定</li><li>DynamicRegistrationService得到增强<br clear="none"><br clear="none"></li></ul><p>CXF提供了<a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc6749" rel="nofollow">OAuth 2.0</a>的实现。另请参阅<a shape="rect" href="jax-rs-oauth.html">JAX-RS OAuth</a>页面以获取有关OAuth 1.0的信息。</p><p>当前支持授权代码，隐式，客户端凭据，资源所有者密码凭据，刷新令牌，SAML2声明和JWT声明授予。</p><p>可以注册自定义授予处理程序。</p><p>OAuth2是一种新协议，可为最终用户（资源所有者）授权第三方提供商访问其资源提供复杂而优雅的解决方案。</p><p>与原始OAuth 1.0 3条腿流紧密相关的OAuth2流称为授权代码，涉及3个参与方：最终用户，第三方服务（客户端）和受OAuth2过滤器保护的资源服务器。通常，客户端提供最终用户请求的服务功能，并且要求前者代表该用户访问位于资源服务器上的一个或多个受保护资源。例如，客户可能需要访问最终用户的照片以便打印它们并发布给用户，或者阅读并可能更新用户的日历以进行预订。</p><p>为了实现这一点，第三方服务应用程序/客户端需要向OAuth2服务器注册自己。这是带外发生的，注册后，客户端会取回客户端密钥和密钥对。通常，期望客户端提供应用程序的名称和描述，应用程序徽标URI，一个或多个重定向URI以及其他可以帮助OAuth2授权服务器在授权时向最终用户标识此客户端的信息。</p><p>从那时起，授权代码流程如下所示：<br clear="none">1。最终用户使用浏览器请求第三方服务。</p><p>2。客户端将最终用户重定向到OAuth2授权服务，并将其客户端ID，状态，重定向URI和可选范围添加到目标URI。 state参数表示当前最终用户的请求，重定向URI（预期将向其返回授权代码），范围是客户端访问受保护资源所需的不透明权限的列表。</p><p>3。授权服务将使用客户端ID检索有关客户端的信息，构建HTML表单并将其返回给最终用户。该表格将询问用户是否可以允许给定的第三方应用程序代表该用户访问某些资源。</p><p>4。如果用户批准，那么授权服务将生成一个授权代码，并将用户重定向回客户端提供的重定向uri，还将状态参数添加到重定向URI。</p><p>5，客户端通过提供授权码授权从OAuth2访问令牌服务请求访问令牌。</p><p>6。获得访问令牌令牌后，服务最终继续访问当前用户的资源并完成用户的请求。</p><p>如您所见，流程可能很复杂，但却非常有效。在此过程中可能需要注意许多问题，例如管理过期的令牌，确保OAuth2安全层正常运行并且不会干扰尝试访问其自身资源的最终用户本身，等等。</p><p>请检查<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc6749" rel="nofollow">规格</a>以及WEB上的其他资源，以获取有关OAuth2可能需要了解的更多信息。</p><p>CXF JAX-RS尽最大努力使此过程尽可能简单，并且代表OAuth2服务器开发人员仅需最少的工作。它还提供了实用程序代码，可大大简化第三方应用程序与OAuth2服务端点进行交互的方式。</p><h1 id="JAX-RSOAuth2-Mavendependencies">Maven依赖</h1><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-rs-security-oauth2&lt;/artifactId&gt;
  &lt;version&gt;3.1.7&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><h1 id="JAX-RSOAuth2-ClientRegistration">客户注册</h1><p>客户注册通常在带外完成，动态客户注册也是可能的。<br clear="none">客户端注册服务将提供一个HTML表单，客户端将在其中输入其详细信息，有关当前支持的属性，请参见<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/Client.java" rel="nofollow">Client</a> bean。</p><p>有关一种可能的方法，请参<a shape="rect" class="external-link" href="https://github.com/apache/cxf-fediz/blob/master/services/oidc/src/main/java/org/apache/cxf/fediz/service/oidc/clients/ClientRegistrationService.java" rel="nofollow">见此JAX-RS服务实现</a> 。</p><h1 id="JAX-RSOAuth2-DevelopingOAuth2Servers">开发OAuth2服务器</h1><p>OAuth2服务器是完整的基于OAuth2的解决方案的核心部分。通常，它包含3种服务：<br clear="none">1。通过要求最终用户允许客户端访问其一些资源并返回请求令牌来授权请求令牌<br clear="none">授予客户端（授权服务）<br clear="none">2。将令牌授予与访问令牌交换（访问令牌服务）</p><p>3。验证访问令牌</p><p><br clear="none"></p><p>CXF提供了几种可用于快速创建OAuth2服务器的JAX-RS服务实现：用于管理基于重定向的流的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AuthorizationCodeGrantService.java" rel="nofollow">AuthorizationCodeGrantService</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/ImplicitGrantService.java" rel="nofollow">ImplicitGrantService</a> ，以及用于将授权交换为新令牌的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AccessTokenService.java" rel="nofollow">AccessTokenService</a> 。</p><p>所有这些服务都依赖于自定义的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a> ，该自定义的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a>保留访问令牌并将不透明范围值转换为可以呈现给用户的信息。另外， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeDataProvider.java" rel="nofollow">AuthorizationCodeDataProvider</a>是<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a> ，它可以保留有关授权码授予的临时信息，在请求交换令牌后需要将其删除。</p><p>请注意，一些不需要基于重定向的支持的授予，例如客户端凭据或SAML2或JWT断言授予，并且可能仅要求访问令牌服务可操作。</p><p>如果您的OAuth2服务器确实支持授权码或隐式流，则需要注册<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AuthorizationCodeGrantService.java" rel="nofollow">AuthorizationCodeGrantService</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/ImplicitGrantService.java" rel="nofollow">ImplicitGrantService</a> 。如果需要同时支持这两个服务，则只需注册其中两个即可，但请注意，每个服务都有其自己的@Path段，即“ / authorize”和“ / authorize-implicit”。如果您希望两个服务都在同一路径上侦听，请使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AuthorizationService.java" rel="nofollow">AuthorizationService</a>并将<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AuthorizationCodeGrantService.java" rel="nofollow">AuthorizationCodeGrantService</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/ImplicitGrantService.java" rel="nofollow">ImplicitGrantService</a> Bean注入其中。</p><p>如果不支持AuthorizationCode重定向流程，则<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">只需</a>实现<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a> 。</p><p>要启动和运行OAuth2服务器，需要编写自己的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeDataProvider.java" rel="nofollow">AuthorizationCodeDataProvider</a>或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a>实现。在许多情况下，您需要做的是保存或删除“授权代码授予”数据，使用可用的实用程序类之一创建新的访问令牌，然后保存或删除过期的令牌，最后转换可选的不透明作用域值（如果支持的话）以查看更多信息。</p><p>CXF附带了几种默认的提供程序实现，请参阅下面的“编写提供程序”部分。</p><p><br clear="none"></p><h2 id="JAX-RSOAuth2-AuthorizationService">授权服务</h2><p>OAuth2授权服务的主要职责是向最终用户提供一个表格，要求用户允许或拒绝客户端访问某些用户资源。CXF提供了<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AuthorizationCodeGrantService.java" rel="nofollow">AuthorizationCodeGrantService</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/ImplicitGrantService.java" rel="nofollow">ImplicitGrantService</a>来接受重定向请求，使用授权表向最终用户提出挑战，处理最终用户的决定并将结果返回给客户端。</p><p>授权代码流与隐式流之间的区别之一是，在后一种情况下，授予是实际的访问令牌，该令牌作为URI片段值返回给在浏览器中运行的客户端脚本。在这两个流程之间，要求最终用户授权客户端请求的方式是相似的。在本节中，我们将假定正在使用授权码流程。</p><p>第三方客户端将当前用户重定向到AuthorizationCodeGrantService，例如，以下是可能发生的重定向：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 303
Headers: {Location=[http://localhost:8080/services/social/authorize?client_id=123456789&amp;scope=updateCalendar-7&amp;response_type=code
&amp;redirect_uri=http%3A//localhost%3A8080/services/reservations/reserve/complete&amp;state=1], 
Date=[Thu, 12 Apr 2012 12:26:21 GMT], Content-Length=[0]}
</pre>
</div></div><p>客户端应用程序要求当前用户（浏览器）转到Location标头提供的新地址，对AuthorizationCodeGrantService的后续请求将如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/social/authorize?client_id=123456789&amp;scope=updateCalendar-7&amp;response_type=code
&amp;redirect_uri=http%3A//localhost%3A8080/services/reservations/reserve/complete&amp;state=1
Http-Method: GET
Headers: {
Accept=[text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8],
Authorization=[Basic YmFycnlAc29jaWFsLmNvbToxMjM0], 
Cookie=[JSESSIONID=suj2wyl54c4g], 
Referer=[http://localhost:8080/services/forms/reservation.jsp]
...
}
</pre>
</div></div><p>请注意，最终用户需要进行身份验证。请求URI包括client_id，自定义范围值，设置为“ code”的response_type，当前请求状态和重定向uri。请注意，范围是可选的-授权服务通常会分配一个默认范围；但是，即使客户端确实包含其他自定义范围，最终用户仍可能不会批准它。重定向uri也是可选的，假设在客户端注册时已提供一个或多个重定向URI。</p><p>如果未使用安全的HTTPS传输，则AuthorizationCodeGrantService将报告警告：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">12-Apr-2012 13:26:21 org.apache.cxf.rs.security.oauth2.services.AbstractOAuthService checkTransportSecurity
WARNING: Unsecure HTTP, Transport Layer Security is recommended
</pre>
</div></div><p>也可以将其配置为通过不安全的HTTP传输拒绝请求。</p><p>AuthorizationCodeGrantService将检索有关<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/Client.java" rel="nofollow">客户端应用程序</a>的信息，以填充<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData</a> bean的实例并返回它。OAuthAuthorizationData包含应用程序名称和URI属性， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthPermission.java" rel="nofollow">Permission</a>的可选列表以及其他属性，这些属性可以呈现给用户或保留在隐藏的表单字段中，以便在最终用户返回决策时唯一标识实际的授权请求。</p><p>OAuthAuthorizationData重要属性之一是“ authenticityToken”。它用于验证当前会话是否未被劫持-AuthorizationCodeGrantService生成一个随机密钥，将其存储在Servlet HTTPSession实例中，并期望返回的authenticityToken值与之匹配-这是推荐的方法，并且还意味着authenticityToken值对用户是隐藏的，例如，将其保留在“隐藏”表单字段中。另请参见“用户会话真实性”，以了解<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/SessionAuthenticityTokenProvider.java" rel="nofollow">SessionAuthenticityTokenProvider</a>如何提供帮助。</p><p>当用户做出授权决定时，使用自动授权同意书对用户提出质疑后，需要使用原始用户重定向将已提交给授权端点的许多属性变为可用。这些是如“的clientId”，“州”，“redirectUri”，和其它性质的特性，请参见<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthRedirectionState.java" rel="nofollow">这个类</a>是由OAuthAuthorizationData延长。一种简单的方法是让视图处理程序使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData</a>准备授权表单，以将这些属性隐藏在表单中。另一种选择是将它们保护在会话中，从而使视图创建过程更加简单，有关一个示例，请参见“用户会话真实性”。</p><p>帮助程序的“ replyTo”属性是一个绝对URI，用于标识处理用户决策的AuthorizationCodeGrantService处理程序，可以在构建表单时由视图处理程序使用，也可以由其他OAuthAuthorizationData处理程序使用。</p><p>因此，最终返回了填充的OAuthAuthorizationData。请注意，这是一个带有JAXB XMLRootElement注释的bean，并且如果AuthorizationCodeGrantService支持生成“ application / xml”和“ application / json”，则可以由注册的JAXB或JSON提供程序进行处理（有关更多信息，请参见下面的“没有浏览器的OAuth”部分）。但是在这种情况下，我们让最终用户使用浏览器，因此HTML表单才是真正期望的。</p><p>AuthorizationCodeGrantService支持生成“ text / html”，并且仅依赖于注册的<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-redirection.html#JAX-RSRedirection-WithRequestDispatcherProvider">RequestDispatcherProvider</a>即可将OAuthAuthorizationData bean设置为HttpServletRequest属性，并将响应重定向到视图处理程序（可以是JSP或某些其他Servlet）以实际构建表单并将其返回给用户。有关如何创建视图的其他替代方法，请参见下面的部分。</p><p>假设使用RequestDispatcherProvider，以下示例日志显示了来自AuthorizationCodeGrantService的初始响应：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">12-Apr-2012 13:26:21 org.apache.cxf.jaxrs.provider.RequestDispatcherProvider logRedirection
INFO: Setting an instance of "org.apache.cxf.rs.security.oauth2.common.OAuthAuthorizationData" as HttpServletRequest 
attribute "data" and redirecting the response to "/forms/oauthAuthorize.jsp".
</pre>
</div></div><p>请注意，“ / forms / oauthAuthorize.jsp”视图处理程序将创建一个HTML视图-这是一个自定义JSP处理程序，可以使用OAuthAuthorizationData bean构建该视图，从而在其中创建所需的任何HTML视图。您很可能希望提供一个表格，要求用户允许或拒绝客户端访问该用户的某些资源。如果OAuthAuthorizationData具有权限列表，则需要添加有关权限的信息。</p><p>接下来，用户做出决定并选择一个按钮，该按钮允许或拒绝客户端访问资源。表单数据被提交到AuthorizationCodeGrantService：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/social/authorize/decision
Encoding: ISO-8859-1
Http-Method: POST
Content-Type: application/x-www-form-urlencoded
Headers: {
Authorization=[Basic YmFycnlAc29jaWFsLmNvbToxMjM0],
Content-Type=[application/x-www-form-urlencoded],
...
}
--------------------------------------
12-Apr-2012 15:36:29 org.apache.cxf.jaxrs.utils.FormUtils logRequestParametersIfNeeded
INFO: updateCalendar-7_status=allow&amp;readCalendar_status=allow&amp;scope=updateCalendar-7+readCalendar
&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Fservices%2Freservations%2Freserve%2Fcomplete
&amp;session_authenticity_token=4f0005d9-565f-4309-8ffb-c13c72139ebe&amp;oauthDecision=allow&amp;state=1&amp;client_id=123456789
</pre>
</div></div><p>AuthorizationCodeGrantService将使用“ session_authenticity_token”来验证会话是否有效，然后将处理用户的决定。</p><p>如果决定为“允许”，则它将检查各个范围值的状态。它依赖于“ scopename_status”约定，如果表单为用户提供了选择性启用各个范围的机会，则将提交名称/值对，例如“ updateCalendar-7_status = allow”。如果没有任何这样的对返回，则意味着用户已经批准了所有默认范围和其他范围（如果有）。</p><p>接下来，它将要求OAuthDataProvider生成授权代码授权，并通过将当前用户重定向回重定向URI来返回授权代码以及状态（如果有）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 303
Headers: {
 Location=[http://localhost:8080/services/reservations/reserve/complete?state=1
&amp;code=5c993144b910bccd5977131f7d2629ab], 
 Date=[Thu, 12 Apr 2012 14:36:29 GMT], 
 Content-Length=[0]}
</pre>
</div></div><p>这导致浏览器重定向用户：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/reservations/reserve/complete?state=1&amp;code=5c993144b910bccd5977131f7d2629ab
Http-Method: GET
Headers: {
Accept=[text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8],
Authorization=[Basic YmFycnlAcmVzdGF1cmFudC5jb206NTY3OA==], 
Cookie=[JSESSIONID=1c289vha0cxfe],
}
</pre>
</div></div><p>如果用户决定设置为“拒绝”，则错误将返回给客户端。</p><p>假设该决定为“允许”，则客户端现在已收到授权码授予，并准备将其交换为新的访问令牌。</p><h3 id="JAX-RSOAuth2-HowtocreateAuthorizationView">如何创建授权视图</h3><p>通常，可以使用RequestDispatcherProvider重定向到诸如JSP的视图处理程序。通过委托给超类重写RedirectionBasedService.startAuthorization，然后将Response转换为HTML或编写将执行转换的自定义MessageBodyWriter，这是另外两个选项。</p><p>另一个选择是注册<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-advanced-xml.html#JAX-RSAdvancedXML-XSLTsupport">XSLTJaxbProvider</a> ，它将通过引用XSLT样式表将OAuthAuthorizationData转换为HTML或JAXBProvider集合。</p><h3 id="JAX-RSOAuth2-EndUserNameinAuthorizationForm">授权表格中的最终用户名</h3><p>您可能希望以该用户将要面对的授权形式显示资源所有者/最终用户名，您可以获取org.apache.cxf.rs.security.oauth2.provider。向AuthorizationCodeGrantService或ImplicitGrantService注册的ResourceOwnerNameProvider。<br clear="none">org.apache.cxf.rs.security.oauth2.provider。如果注册了DefaultResourceOwnerNameProvider，它将返回实际的登录名，自定义实现可以选择返回完整的用户名，等等。</p><h3 id="JAX-RSOAuth2-PublicClients(Devices)">公共客户（设备）</h3><p>如果客户端已注册为公共客户端，且没有客户端秘密，则客户端可以是“公共的”，服务本身已启用“ canSupportPublicClients”属性。对于公共客户端，还必须在AccessTokenService上启用相同的属性（在下一节中介绍），而不能秘密地为访问令牌交换代码授权。</p><h4 id="JAX-RSOAuth2-OOBResponse">OOB回应</h4><p>如果公共客户端尚未在授权服务中注册重定向URI，则可以带外（OOB）返回授权代码，请参阅<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OOBAuthorizationResponse.java" rel="nofollow">OOBAuthorizationResponse</a> bean。默认情况下，它将直接返回给最终用户，除非在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OOBResponseDeliverer.java" rel="nofollow">AuthorizationCodeGrantService</a>中注册了自定义的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OOBResponseDeliverer.java" rel="nofollow">OOBResponseDeliverer</a> ，该<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OOBResponseDeliverer.java" rel="nofollow">OOBResponseDeliverer</a>可能会通过某个自定义的反向渠道将其传递给客户端。</p><p>当公共客户端（通常是无法保留客户端机密且不支持重定向URI的设备）需要获得代码授权时，支持OOB响应非常有用。将会发生的事情是，设备所有者将向授权服务发送请求，该请求可能如下所示：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>GET
http://localhost:8080/services/social/authorize?client_id=mobileClient&amp;response_type=code   
</pre>
</div></div><p>假设“ mobileClient”已被注册为没有秘密的公共帐户，并且已设置服务来支持此类客户端，则最终用户将有机会以与可以处理机密客户端相同的方式来授权此客户端，并且在此用户之后取回代码（默认情况下直接在响应HTML页面中直接提供），用户将安全地将代码输入设备，然后通过与AccessTokenService联系，将其替换为时间范围内的访问令牌。</p><h4 id="JAX-RSOAuth2-PKCEsupport">PKCE支持</h4><p>CXF支持<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7636" rel="nofollow">RFC-7636</a> ：OAuth公共客户端（PKCE）进行代码交换的证明密钥。如果对公共客户端使用授权码授予，建议使用PKCE以避免利用授权码请求和令牌请求之间缺乏绑定的攻击。通过在两个请求中都包含client_id，可以为机密客户端实现此绑定，但是对于公共客户端，我们没有注册的client_id。</p><p>公共（移动）客户端生成“ code_verifier”值，并包括与授权服务相关的“ code_challenge”和可选的“ code_challenge_method”。授权服务将在注册的AuthorizationCodeDataProvider的帮助下将code_challenge值保存到ServerAuthorizationCodeGrant的实例中。客户端接下来将请求提供“ code_verifier”的令牌-AuthorizationCodeGrantHandler会将其与原始“ code_challenge”值进行比较。默认情况下，“ code_challenge”应等于原始的“ code_verifier”，但可以使用自定义org.apache.cxf.rs.security.oauth2.grants.code注册授予处理程序。CodeVerifierTransformer-CXF附带了DigestCodeVerifier，它实现了扩展中提到的转换。</p><h3 id="JAX-RSOAuth2-FormPostResponseMode">表单发布响应模式</h3><p><a shape="rect" class="external-link" href="http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html" rel="nofollow">表单发布响应模式</a>通常是为OpenId Connect引入的，但最近被重新推荐，作为将OAuth2授权服务响应返回给客户端的一种更安全的选择。从CXF 3.1.9开始，如果客户端在原始重定向期间发送“ response_mode = form_post”参数，则CXF AuthorizationCodeService将返回带有其“ redirectUri”属性集的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OOBAuthorizationResponse.java" rel="nofollow">OOBAuthorizationResponse</a> -JSP / etc处理程序将转换为HTML格式， -将数据发布到客户端回调地址。</p><h2 id="JAX-RSOAuth2-AccessTokenService">AccessTokenService</h2><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AccessTokenService.java" rel="nofollow">AccessTokenService</a>的作用是为新的访问令牌交换令牌授予，客户端将使用该令牌来访问最终用户的资源。<br clear="none">这是一个示例请求日志：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/oauth/token
Http-Method: POST

Headers: {
Accept=[application/json], 
Authorization=[Basic MTIzNDU2Nzg5Ojk4NzY1NDMyMQ==], 
Content-Type=[application/x-www-form-urlencoded]
}
Payload: 

grant_type=authorization_code&amp;code=5c993144b910bccd5977131f7d2629ab
&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Fservices%2Freservations%2Freserve%2Fcomplete
</pre>
</div></div><p>该请求包含一个client_id和client_secret（授权标头），grant_type，授权值（代码）以及授权授权返回的重定向URI，这是其他验证所必需的。请注意，其他客户端身份验证方法也是可行的，在这种情况下，令牌服务将期望客户端凭据和代表可用客户端注册的client_id之间的映射。</p><p>验证请求之后，服务将找到匹配的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AccessTokenGrantHandler.java" rel="nofollow">AccessTokenGrantHandler</a>并请求创建<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/ServerAccessToken.java" rel="nofollow">ServerAccessToken</a> ，它是访问令牌的服务器端表示形式。<br clear="none">授予处理程序（例如<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeGrantHandler.java" rel="nofollow">AuthorizationCodeGrantHandler）</a>可以将实际访问令牌的创建委派给数据提供者，数据提供者将在CXF附带的实用程序类的帮助下或依赖于其他第三方令牌库来创建访问令牌。</p><p>并不严格要求数据提供者保留诸如访问令牌之类的数据，而是令牌密钥可以充当捕获所有相关信息的加密包。</p><p>请注意，AccessTokenService可能不需要注入<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AccessTokenGrantHandler.java" rel="nofollow">AccessTokenGrantHandler-</a>如果它发现数据提供者为AuthorizationCodeDataProvider，则它将自己创建<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeGrantHandler.java" rel="nofollow">AuthorizationCodeGrantHandler</a> 。除非需要自定义<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeGrantHandler.java" rel="nofollow">AuthorizationCodeGrantHandler</a>本身，然后将其直接注入AccessTokenService，否则它将很好地工作。</p><p>现在已经创建了令牌，该令牌已由服务映射到<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/ClientAccessToken.java">客户端访问令牌表示形式，</a>并作为JSON有效负载返回：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 200
Content-Type: application/json
Headers: {
 Cache-Control=[no-store], 
 Pragma=[no-cache], 
 Date=[Thu, 12 Apr 2012 14:36:29 GMT]
}

Payload: 

{"access_token":"5b5c8e677413277c4bb8b740d522b378", "token_type":"bearer"}

</pre>
</div></div><p>客户端将使用此访问令牌访问当前用户的资源，以完成原始用户的请求，例如，访问用户日历的请求可能如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/thirdPartyAccess/calendar
Http-Method: GET
Headers: 
{
  Authorization=[Bearer 5b5c8e677413277c4bb8b740d522b378], 
  Accept=[application/xml]
}
</pre>
</div></div><p>注意，访问令牌密钥作为承载方案值传递。其他令牌类型（例如MAC令牌等）可以用不同的方式表示。</p><h3 id="JAX-RSOAuth2-AccessTokenTypes">访问令牌类型</h3><p>如上所述，AccessTokenService可以使用给定数据提供者创建的任何令牌。本节提供有关CXF如何帮助支持Bearer和其他令牌类型的更多信息。</p><h4 id="JAX-RSOAuth2-Bearer">承载者</h4><p>以下代码片段显示了如何使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/tokens/bearer/BearerAccessToken.java" rel="nofollow">BearerAccessToken</a>实用工具类创建Bearer令牌：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.oauth2.common.AccessTokenRegistration;
import org.apache.cxf.rs.security.oauth2.common.ServerAccessToken;
import org.apache.cxf.rs.security.oauth2.tokens.bearer.BearerAccessToken;

public class CustomOAuthDataProvider implements AuthorizationCodeDataProvider {

    public ServerAccessToken createAccessToken(AccessTokenRegistration reg)
		throws OAuthServiceException {

		ServerAccessToken token = new BearerAccessToken(reg.getClient(), 3600L);
		
		List&lt;String&gt; scope = reg.getApprovedScope().isEmpty() ? reg.getRequestedScope() 
				                                        : reg.getApprovedScope();
		token.setScopes(convertScopeToPermissions(reg.getClient(), scope));
		token.setSubject(reg.getSubject());
		token.setGrantType(reg.getGrantType());
		
        // persist or encrypt and return

		return token;
   }
   // other methods are not shown
}
</pre>
</div></div><p>如果没有注册Bearer令牌验证程序，OAuthRequestFilter还将要求CustomOAuthDataProvider验证传入的Bearer令牌，因为它们通常充当数据库密钥或密钥别名。</p><p>请注意，CXF附带的所有默认提供程序都会自己创建并保留Bearer访问令牌。</p><h4 id="JAX-RSOAuth2-HAWK">鹰</h4><p>从CXF 3.0.0-milestone2开始，将支持<a shape="rect" class="external-link" href="https://github.com/hueniverse/hawk" rel="nofollow">Hawk</a>方案而不是MAC（在下一节中介绍）。它的支持方式与早期CXF版本中支持MAC方案的方式相同。唯一的区别是：“ Hawk”替换了Authorization标头中的“ Mac”，服务器返回的Hawk令牌将具有“ secret”和“ algorithm”参数，而不是“ mac_key”和“ mac_algorithm”参数。</p><h4 id="JAX-RSOAuth2-MAC">苹果电脑</h4><p>下面的文本适用于3.0.0-milestone2以下的CXF。从3.0.0-milestone2开始，不支持MAC方案，有关Hawk方案，请参见上文。另请参阅<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7800" rel="nofollow">OAuth2拥有权令牌证明</a> ，以后将在CXF中支持。</p><p>CXF 2.6.2支持由Eran Hammer等人创建的最新<a shape="rect" class="external-link" href="http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-05" rel="nofollow">MAC访问认证草案中</a>指定的MAC令牌。MAC令牌为客户端提供了一个选项，以证明客户端“持有” AccessTokenService颁发给他们的令牌密钥。<br clear="none">建议发出MAC令牌的AccessTokenService端点强制执行双向TLS，以额外保护返回给客户端的MAC令牌数据。</p><p>以下代码片段显示了如何使用<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/branches/2.7.x//rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/tokens/mac/MacAccessToken.java">MacAccessToken</a>实用工具类创建MAC令牌：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.oauth2.common.AccessTokenRegistration;
import org.apache.cxf.rs.security.oauth2.common.ServerAccessToken;
import org.apache.cxf.rs.security.oauth2.tokens.mac.HmacAlgorithm;
import org.apache.cxf.rs.security.oauth2.tokens.mac.MacAccessToken;

public class CustomOAuthDataProvider implements AuthorizationCodeDataProvider {

    public ServerAccessToken createAccessToken(AccessTokenRegistration reg)
		throws OAuthServiceException {
                
                // generate
		ServerAccessToken token = new MacAccessToken(reg.getClient(), 
                                                             HmacAlgorithm.HmacSHA1, 
                                                             3600L);
		
		// set other token fields as shown in the Bearer section
		
                // persist as needed and then return

		return token;
   }
   // other methods are not shown
}
</pre>
</div></div><p>可以期待以下响应：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response-Code: 200
Content-Type: application/json
Headers: {
 Cache-Control=[no-store], 
 Pragma=[no-cache], 
 Date=[Thu, 12 Apr 2012 14:36:29 GMT]
}

Payload: 

{"access_token":"5b5c8e677413277c4bb8b740d522b378", "token_type":"mac", "mac_key"="1234568", 
"mac_algorithm"="hmac-sha-1"}
</pre>
</div></div><p>请注意，“ access_token”是MAC密钥标识符。</p><p><a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/branches/2.7.x/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/tokens/mac/MacAccessTokenValidator.java">MacAccessTokenValidator</a>必须向<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/branches/2.7.x/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/tokens/mac/MacAccessTokenValidator.java">OAuthRequestFilter</a>注册以验证传入的MAC令牌。该验证器可以使用CXF获得对自定义<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/tokens/mac/NonceVerifier.java">NonceVerifier</a>的引用， <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/tokens/mac/NonceVerifier.java">将来</a>可能会提供默认实现。</p><p>客户端可以使用CXF OAuthClientUtils创建授权MAC标头。需要做的就是提供对ClientAccessToken的引用，该引用代表由AccessTokenService和<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/client/HttpRequestProperties.java">HttpRequestProperties</a>发出的MAC令牌，以捕获有关当前请求URI的信息：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">String requestURI = "http://localhost:8080/calendar";
WebClient wc = WebClient.create(requestURI);

// represents client registration
OAuthClientUtils.Consumer consumer = getConsumer();
// the token issued by AccessTokenService
ClientAccessToken token = getToken();

HttpRequestProperties httpProps = new HttpRequestProperties(wc, "GET");
String authHeader = OAuthClientUtils.createAuthorizationHeader(consumer, token, httpProps);
wc.header("Authorization", authHeader);

Calendar calendar = wc.get(Calendar.class);
</pre>
</div></div><p>这段代码将导致类似：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">GET /calendar HTTP/1.1
Host: localhost
Accept: application/xml
Authorization: MAC id="5b5c8e677413277c4bb8b740d522b378",
                   nonce="di3hvdf8",
                   mac="W7bdMZbv9UWOTadASIQHagZyirA="
                   ts="12345678" 
</pre>
</div></div><p>其中的“ ts”属性用于传递时间戳值。</p><h4 id="JAX-RSOAuth2-EncryptedTokens">加密令牌</h4><p><strong>注意</strong> ：考虑将<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-jose.html#JAX-RSJOSE-JWEEncryption">JWE加密</a>与JWT访问令牌一起使用（请参阅下一节）。</p><p>通常，令牌将保留在存储中。另一种方法是完全加密令牌状态并将加密的表示形式返回给客户端：与加密和解密有关的处理时间可能会增加，但是服务器会避免使用DB /存储查找。</p><p>CXF 3.0.0-milestone2引入了实用程序支持，用于加密BearerAccessToken和RefreshToken的状态。</p><p>可以使用对称（秘密）密钥或证书（公钥和私钥）以及证书和私钥的组合对令牌进行加密和解密。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/utils/crypto/ModelEncryptionSupport.java" rel="nofollow">ModelEncryptionSupport</a>可用于使用自定义序列化格式对令牌进行加密。</p><p>请注意，ServerAuthorizationGrant和Client也可以被加密。</p><p><br clear="none"></p><p>最简单的策略是使用对称/秘密密钥对令牌进行加密和解密。可以使用唯一的密钥对每个新令牌进行加密，也可以使用单个密钥对所有新令牌进行加密。该实用程序提供了几种创建具有默认和高级属性的秘密密钥的方法，此外，还有许多有关如何创建具有特定属性的密钥的示例。</p><p>例如，请参阅org.apache.cxf.rs.security.oauth2.grants.code。DefaultEncryptingCodeDataProvider和org.apache.cxf.rs.security.oauth2.provider。从CXF 3.0.2开始提供的DefaultEncryptingOAuthDataProvider。</p><p>这是演示加密/解密如何工作的典型代码：</p><p><br clear="none"></p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SecretKey key = CryptoUtils.getSecretKey();

// create a new token, encrypt its state and return

ServerAccessToken token = new BearerAccessToken(client, 3600L);

String encryptedToken = ModelEncryptionSupport.encryptAccessToken(token, key);

token.setTokenKey(encryptedToken);

return token;

// decrypt a token given a token key

ModelEncryptionSupport.decryptAccessToken(this, encryptedToken, key);</pre>
</div></div><pre><br clear="none"></pre><h4 id="JAX-RSOAuth2-JWTTokens">JWT代币</h4><p>从CXF 3.1.8开始，某些CXF OAuthDataProvider实现（基于JCache和JPA2以及CXF 3.3.0之前的EhCache 2.x）支持JWT中的访问令牌表示。这意味着将由数据提供者创建的ServerAccessTokens转换为JSON JWT声明序列，然后由JWS签名和/或加密JWE。</p><p>定制数据提供者可以扩展<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AbstractOAuthDataProvider.java" rel="nofollow">AbstractOAuthDataProvider，</a>以依赖于将ServerAccessTokens转换为JWT的代码，并使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/utils/JwtTokenUtils.java" rel="nofollow">JwtTokenUtils</a>将JOSE令牌表示形式转换回ServerAccessToken。</p><p>例如，以下是如何配置一个CXF数据提供程序以使用JWT的方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="oauthProvider" class="org.apache.cxf.rs.security.oauth2.grants.code.DefaultEHCacheCodeDataProvider"&gt;
       &lt;property name="useJwtFormatForAccessTokens" value="true"/&gt;
&lt;/bean&gt;</pre>
</div></div><p>另外，为了签名和/或加密，可以使用以下示例配置向此提供程序注入的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthJoseJwtProducer.java" rel="nofollow">OAuthJoseJwtProducer</a>或AccessTokenService端点实例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="oauthServer1" address="https://localhost:${testutil.ports.jaxrs-oauth2-serviceJwt}/services"&gt;
    &lt;jaxrs:serviceBeans&gt;
&#160;&#160;      &lt;ref bean="tokenService"/&gt;
    &lt;/jaxrs:serviceBeans&gt;
    &lt;!-- Sign --&gt;
    &lt;jaxrs:properties&gt;
        &lt;entry key="rs.security.signature.properties" value="org/apache/cxf/systest/jaxrs/security/alice.rs.properties"/&gt;
        &lt;entry key="rs.security.signature.key.password.provider" value-ref="keyPasswordProvider"/&gt;
    &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;</pre>
</div></div><p>请注意，在这种情况下，Ehcache，JCache和JPA2提供程序仍将保留完整的ServerAccessToken表示形式-创建JOSE序列后，它将成为当前ServerAccessToken的新tokenId，而原始tokenId将成为JWT'jti'声明。</p><p>主要优点是可以在资源服务器端本地自省此类令牌，从而避免了远程令牌验证调用。</p><p>可以将提供程序（目前仅JCache以及CXF 3.3.0之前的EhCache 2.x）配置为仅将这些新创建的JOSE序列持久存储在访问令牌中：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="oauthProvider" class="org.apache.cxf.systest.jaxrs.security.oauth2.common.OAuthDataProviderImpl"&gt;
       &lt;property name="useJwtFormatForAccessTokens" value="true"/&gt;
       &lt;property name="storeJwtTokenKeyOnly" value="true"/&gt;
&lt;/bean&gt;</pre>
</div></div><p>仅代表给定ServerAccessToken的JOSE序列将被保留。当运行时需要令牌时，提供者将根据此序列重新创建ServerAccessToken，同时需要更少的存储空间来保留此类令牌。在这种情况下，如果需要，可以进一步优化它，甚至不存储这些安全的字符串令牌表示形式-但是主要缺点是，由于不会记录此类令牌，因此无法从管理控制台中管理此类令牌。在存储中可用。</p><p>资源服务器（RS）将需要决定如何验证此JWT令牌。它可以继续使用AccessTokenValidationService或TokenIntrsopectionService（有关这些服务的更多信息，请参见下文）进行远程验证，或者如果RS可以访问用于对JWT进行签名/加密的密钥，则可以使用本地JWT验证，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jwtTokenValidator" class="org.apache.cxf.rs.security.oauth2.filters.JwtAccessTokenValidator"/&gt;
&lt;bean id="oAuthFilterLocalValidation" class="org.apache.cxf.rs.security.oauth2.filters.OAuthRequestFilter"&gt;
    &lt;property name="tokenValidator" ref="jwtTokenValidator"/&gt;
&lt;/bean&gt;
   
&lt;jaxrs:server 
    depends-on="tls-config" 
    address="https://localhost:${testutil.ports.jaxrs-oauth2-filtersJwt}/securedLocalValidation"&gt;
    &lt;jaxrs:serviceBeans&gt;
        &lt;ref bean="serviceBean"/&gt;
    &lt;/jaxrs:serviceBeans&gt;
    &lt;jaxrs:providers&gt;
        &lt;ref bean="oAuthFilterLocalValidation"/&gt;
    &lt;/jaxrs:providers&gt;
    &lt;jaxrs:properties&gt;
         &lt;entry key="rs.security.signature.in.properties" value="org/apache/cxf/systest/jaxrs/security/alice.rs.properties"/&gt;
    &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;</pre>
</div></div><p><br clear="none"></p><p>什么时候使用JWT？优点是：可能更容易与一些较新的OAuth2相关规范保持一致，可能避免远程验证调用，可能的OAuth2服务器存储优化。缺点：验证（或解密），报告给客户端并由客户端使用的访问令牌值的额外成本变得更大。如果仅使用JWS，则应注意避免提出一些敏感的JWT声明，因为可以自省JWS有效负载。</p><p>有关如何对JSON Web令牌进行签名和加密的更多信息，请参见<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-jose.html">JAX-RS JOSE</a> Wiki页面。具体来说，如果您需要在自定义提供程序中创建JWT值，请查看<span class="confluence-link"> </span> <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-jose.html#JAX-RSJOSE-JOSEinJAX-RSapplicationcode"><span class="confluence-link">本节</span></a> ：可以委托或扩展<strong>JoseJwtConsumer</strong>或<strong>JoseJwtProducer</strong> 。另外是org.apache.cxf.rs.security.oauth2.provider。<strong>OAuthJoseJwtConsumer</strong> （和<strong>OAuthJoseJwtProducer</strong> ）可以在以下情况下提供帮助：OAuth2客户端密钥用作基于HMAC的签名或加密的密钥，而<strong>OAuthServerJoseJwtConsumer</strong> （和<strong>OAuthServerJoseJwtProducer</strong> ）也可以使用OAuth2客户端证书。</p><p><br clear="none"></p><h4 id="JAX-RSOAuth2-Customtokens">自定义令牌</h4><p>如果需要，用户可以使用自己的自定义令牌类型，但唯一的限制是自定义令牌类型实现必须扩展org.apache.cxf.rs.security.oauth2.common。ServerAccessToken。</p><h4 id="JAX-RSOAuth2-SimpleTokensandAudience">简单令牌和受众</h4><p>从CXF 2.7.7开始，在客户端令牌请求期间支持<a shape="rect" class="external-link" href="http://tools.ietf.org/html/draft-tschofenig-oauth-audience-00" rel="nofollow">受众</a>参数。</p><h3 id="JAX-RSOAuth2-OAuthJSONProvider">OAuthJSONProvider</h3><p>org.apache.cxf.rs.security.oauth2.provider。OAuthJSONProvider是一个JAX-RS MessageBodyWriter，它支持以OAuth2规范要求的JSON格式将ClientAccessToken和OAuthError表示形式返回给客户端。这也是一个JAX-RS MessageBodyReader，客户端OAuthClientUtils（请参见下文）使用它来读取AccessTokenService的响应。</p><p>使用JAXRS AccessTokenService端点将其注册为提供程序。</p><p>另外，如果您愿意，也可以注册自定义MessageBodyWriter实现。</p><h2 id="JAX-RSOAuth2-AccessTokenValidationService">访问令牌验证服务</h2><h3 id="JAX-RSOAuth2-AccessTokenValidatorService">AccessTokenValidatorService</h3><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AccessTokenValidatorService.java" rel="nofollow">AccessTokenValidatorService</a>是CXF特定的OAuth2服务，用于接受远程访问令牌验证请求。OAuthRequestFilter需要与<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/AccessTokenValidatorClient.java" rel="nofollow">AccessTokenValidatorClient</a>一起注入，这将要求AccessTokenValidatorService在设置安全上下文之前返回与当前访问令牌相关的信息。</p><h3 id="JAX-RSOAuth2-TokenIntrospectionService">TokenIntrospectionService</h3><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/TokenIntrospectionService.java" rel="nofollow">TokenIntrospectionService</a>是用于接受远程访问令牌自省请求的标准OAuth2服务。参见<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7662" rel="nofollow">RFC 7662</a> 。OAuthRequestFilter需要与<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/AccessTokenIntrospectionClient.java" rel="nofollow">AccessTokenIntrospectionClient</a>一起注入<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/AccessTokenIntrospectionClient.java" rel="nofollow">。</a></p><h2 id="JAX-RSOAuth2-TokenRevocationService">令牌撤销服务</h2><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/TokenRevocationService.java" rel="nofollow">TokenRevocationService</a>是一个简单的OAuth2服务，支持希望撤消其自己拥有的访问或刷新令牌的客户端，请参阅<a shape="rect" class="external-link" href="http://tools.ietf.org/html/draft-ietf-oauth-revocation-09" rel="nofollow">OAuth2令牌撤销草案</a>以获取更多信息。</p><p>TokenRevocationService和AccessTokenService共享相同的代码，以强制要求客户端已正确验证。</p><p>请注意，OAuthDataProvider实现处理撤销请求应按照规范的建议简单地忽略无效令牌，这将使TokenRevocationService返回HTTP 200，这样做是为了最大程度地减少可能的攻击面（特别是对于不良客户端，不要看他们的请求是否成功或失败）。并仅在当前不支持令牌吊销功能时抛出异常。</p><h2 id="JAX-RSOAuth2-DynamicRegistrationService">动态注册服务</h2><p>此服务从CXF 3.1.8开始可用。它支持动态客户端<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7591" rel="nofollow">注册</a>和<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7592" rel="nofollow">管理</a> 。目前，一些高级注册属性尚未处理，并已链接到核心OAuth2服务的运行方式，但该服务将根据需要进行增强。</p><h2 id="JAX-RSOAuth2-AuthorizationMetadataService">AuthorizationMetadataService</h2><p>此服务从CXF 3.1.8开始可用。它支持“ .well-known / oauth-authorization-server”上的OAuth2 <a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc8414" rel="nofollow">服务器配置</a>查询。</p><h2 id="JAX-RSOAuth2-SupportedGrants">支持的补助金</h2><p>以下各节简要描述了如何在服务器端支持众所周知的授权类型。还请检查“客户端支持”部分，以了解如何使用相关的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/AccessTokenGrant.java" rel="nofollow">AccessTokenGrant</a>实现来请求访问令牌。</p><h3 id="JAX-RSOAuth2-AuthorizationCode">授权码</h3><p>如上所述， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AuthorizationCodeGrantService.java" rel="nofollow">AuthorizationCodeGrantService</a>服务和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeDataProvider.java" rel="nofollow">AuthorizationCodeDataProvider</a>数据提供程序可以支持基于重定向的授权码流。</p><p>客户端在重定向过程结束时收到的代码将需要与AccessTokenService交换新的访问令牌。基于CXF的客户端可以使用帮助程序<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeGrant.java">AuthorizationCodeGrant</a> bean通过OAuthClientUtils请求新的访问令牌。</p><h3 id="JAX-RSOAuth2-Implicit">隐含的</h3><p>支持隐式授予的方式与“授权代码”授予的方式相同，只是不创建任何代码，立即颁发令牌并将其返回给在Web浏览器中运行的客户端。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/ImplicitGrantService.java" rel="nofollow">ImplicitGrantService</a>服务要求<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a>数据提供者在用户批准新令牌后发出它。</p><p>请注意，唯一的区别是使用ImplicitGrantService而不是AuthorizationCodeGrantService。</p><p>还要注意，当隐式授予客户端（在浏览器中运行）替换新访问令牌的代码授予并尝试访问最终用户的资源时，很可能需要在最后启用跨源资源共享（CORS）支持用户的资源服务器。<br clear="none">最简单的方法是在OAuth2过滤器之前注册一个CXF <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-cors.html">CORS过滤</a>器（请参见下面的内容）。</p><p>从CXF 2.7.5开始，可以请求ImplicitGrantService将注册的客户端ID返回给浏览器托管的客户端。建议这样做，以便客户端可以验证令牌是否打算传递给此客户端。</p><h3 id="JAX-RSOAuth2-ClientCredentials">客户凭证</h3><p>向AccessTokenService注册<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/clientcred/ClientCredentialsGrantHandler.java" rel="nofollow">ClientCredentialsGrantHandler</a>处理程序，以支持此授予。</p><p>基于CXF的客户端可以使用助手<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/clientcred/ClientCredentialsGrant.java" rel="nofollow">ClientCredentialsGrant</a> bean来通过OAuthClientUtils请求新的访问令牌。</p><h3 id="JAX-RSOAuth2-ResourceOwnerPasswordCredentials">资源所有者密码凭证</h3><p>向AccessTokenService注册<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/owner/ResourceOwnerGrantHandler.java" rel="nofollow">ResourceOwnerGrantHandler</a>处理程序，以支持此授予。</p><p>基于CXF的客户端可以使用助手<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/owner/ResourceOwnerGrant.java">ResourceOwnerGrant</a> bean来通过OAuthClientUtils请求新的访问令牌。</p><h3 id="JAX-RSOAuth2-RefreshToken">刷新令牌</h3><p>如果客户端拥有的当前访问令牌已过期或已被撤销，并且与当前无效的访问令牌一起发布了刷新令牌，则客户端可以发出刷新令牌授予，并获得新的“刷新”访问令牌。这可以使客户端避免寻求最终用户的新授权批准。</p><p>向AccessTokenService注册<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/refresh/RefreshTokenGrantHandler.java">RefreshTokenGrantHandler</a>处理程序，以支持此授予。请注意，此授予处理程序仅对刷新现有访问令牌有用，因此一个或多个其他授予处理程序（授权代码，隐式等）也必须向AccessTokenService注册。</p><p>基于CXF的客户端可以使用帮助程序<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/owner/ResourceOwnerGrant.java" rel="nofollow">RefreshTokenGrant</a> bean通过OAuthClientUtils请求新的访问令牌。</p><h3 id="JAX-RSOAuth2-SAMLandJWTAssertions">SAML和JWT断言</h3><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7522" rel="nofollow">SAML2断言</a>和<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7523" rel="nofollow">JWT断言</a>可用作令牌授予。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/jwt" rel="nofollow">此程序包</a>支持JWT断言授予。<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/jwt/JwtBearerAuthHandler.java" rel="nofollow">JwtBearerAuthHandler</a>可以用作通用客户端身份验证过滤器（其中，客户端使用JWT令牌而不是使用username：password对等进行身份验证）。</p><p>另请参见<a shape="rect" href="jaxrs-oauth2-assertions.html">JAXRS OAuth2断言</a>部分以获取更多信息。</p><p><br clear="none"></p><h3 id="JAX-RSOAuth2-CustomGrants">海关补助</h3><p>如果您需要自定义众所周知的授权请求的处理方式，请考虑扩展前面小节中列出的授权处理程序之一。</p><p>或者，创建一个自定义<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AccessTokenGrantHandler.java" rel="nofollow">AccessTokenGrantHandler</a>并向<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AccessTokenGrantHandler.java" rel="nofollow">AccessTokenService</a>注册。另外，请考虑提供相关的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/AccessTokenGrant.java" rel="nofollow">AccessTokenGrant</a>实现，以使客户端代码可以轻松地使用此自定义授予请求新的访问令牌。</p><h2 id="JAX-RSOAuth2-RedirectionFlowFilters">重定向流过滤器</h2><p>可以向AuthorizationCodeGrantService或ImplicitGrantService注册<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AuthorizationRequestFilter.java" rel="nofollow">AuthorizationRequestFilter</a>实现，以便预处理代码请求。例如， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/JwtRequestCodeFilter.java" rel="nofollow">JwtRequestCodeFilter</a>可用于处理JWS签名或JWE加密的代码请求。</p><p>可以向AuthorizationCodeService注册<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AuthorizationCodeResponseFilter.java" rel="nofollow">AuthorizationCodeResponseFilter</a>实现，以便对代码响应进行后处理。</p><h2 id="JAX-RSOAuth2-AccessTokenResponseFilters">AccessTokenResponse筛选器</h2><p>可以向AccessTokenService注册<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AccessTokenResponseFilter.java" rel="nofollow">AccessTokenResponseFilter</a>实现，以便对访问令牌响应进行后处理。例如，OIDC IdToken可以被添加到具有一个响应<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/sso/oidc/src/main/java/org/apache/cxf/rs/security/oidc/idp/IdTokenResponseFilter.java" rel="nofollow">IdTokenResponseFilter</a> 。</p><h2 id="JAX-RSOAuth2-PreAuthorizedaccesstokens">预授权访问令牌</h2><p>当使用需要最终用户/资源所有者明确授权客户端的流（例如，基于重定向的流的情况）时，使用预授权的访问令牌是使最终用户干预的需求最小化的一种选择。<br clear="none">如果给定客户端的预授权访问令牌存在，则始终首先检查OAuthDataProvider，如果存在，则将立即返回OAuthDataProvider，而无需启动涉及最终用户的授权过程（某些流程要求）。</p><p>考虑提供一个用户界面，该界面将使最终用户/资源所有者尽早对特定客户端进行预授权。注意，将来可能会引入CXF服务，以支持用户对客户端进行预授权或为某些客户端吊销令牌。</p><p>还应注意，在当前访问令牌已过期的情况下，使用刷新令牌授予可能进一步有助于最大程度地减少最终用户的参与。</p><h2 id="JAX-RSOAuth2-Pre-registeredscopes">预注册范围</h2><p>客户可以注册希望使用的自定义范围，然后在请求代码授予或访问令牌时避免指定范围。<br clear="none">另外，它可以更轻松地支持所谓的通配符作用域。例如，客户端预先注册了一个范围“更新”，而实际上使用了一个“ update-7”范围：基于重定向的服务和访问令牌授予可以配置为进行部分范围匹配，在这种情况下，请验证“更新” -7”从“更新”开始</p><h2 id="JAX-RSOAuth2-WritingOAuthDataProvider">编写OAuthDataProvider</h2><p>使用CXF OAuth服务实现对设置OAuth服务器有很大帮助。从以上部分可以看到，这些服务依赖于自定义的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a>实现。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a>的主要任务是持久化并生成访问令牌。此外，如上所述， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AuthorizationCodeDataProvider.java" rel="nofollow">AuthorizationCodeDataProvider</a>需要保留并删除代码授权注册。完成的方式实际上是特定于应用程序的。考虑从基于内存的基本实现开始，然后继续将数据保留在某些DB中。</p><p>最后，OAuthDataProvider可能需要将不透明的范围值（例如“ readCalendar”）转换为<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthPermission.java" rel="nofollow">OAuthPermission</a>的列表。AuthorizationCodeGrantService和OAuth2安全筛选器将依赖于它（假定范围首先被使用）。</p><h3 id="JAX-RSOAuth2-DefaultProviders">默认提供者</h3><p>CXF 3.1.7附带了JPA2（ <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/JPAOAuthDataProvider.java" rel="nofollow">JPAOAuthDataProvider</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/JPACodeDataProvider.java" rel="nofollow">JPACodeDataProvider</a> ），Ehcache 2.x（ <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/3.2.x-fixes/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/DefaultEHCacheOAuthDataProvider.java" rel="nofollow">DefaultEHCacheOAuthDataProvider</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/3.2.x-fixes/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/DefaultEHCacheCodeDataProvider.java" rel="nofollow">DefaultEHCacheCodeDataProvider</a> ）和JCache（ <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/JCacheOAuthDataProvider.java" rel="nofollow">JCacheOAuthDataProvider</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/JCacheCodeDataProvider.java" rel="nofollow">JCacheCodeDataProvider</a> ）提供程序实现，这些实现负责所有持久性任务：保存或删除注册的客户端，令牌和代码授予。这些提供程序可以轻松进行定制。</p><p>定制实现还可以扩展<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AbstractOAuthDataProvider.java" rel="nofollow">AbstractOAuthDataProvider</a>或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/AbstractCodeDataProvider.java" rel="nofollow">AbstractCodeDataProvider，</a>并且仅实现其抽象持久性相关的方法或进一步自定义其某些代码。</p><h2 id="JAX-RSOAuth2-OAuthServerJAX-RSendpoints">OAuth服务器JAX-RS端点</h2><p>使用提供OAuth服务实现的CXF和自定义的OAuthDataProvider提供程序，就可以部署OAuth2服务器了。<br clear="none">您很可能希望将AccessTokenService部署为独立的JAX-RS端点，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;!-- implements OAuthDataProvider --&gt;
&lt;bean id="oauthProvider" class="oauth.manager.OAuthManager"/&gt;
     
&lt;bean id="accessTokenService" class="org.apache.cxf.rs.security.oauth2.services.AccessTokenService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;jaxrs:server id="oauthServer" address="/oauth"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="accessTokenService"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>AccessTokenService侦听相对的“ /令牌”路径。假设jaxrs：server / @ adress为“ / oauth”，并假定上下文名称为“ / services”，则AccessTokenService的绝对地址将类似于“ http：// localhost：8080 / services / oauth / token”。</p><p>如果支持远程令牌验证，则也要添加AccessTokenValidatorService：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;!-- implements OAuthDataProvider --&gt;
&lt;bean id="oauthProvider" class="oauth.manager.OAuthManager"/&gt;
     
&lt;bean id="accessTokenService" class="org.apache.cxf.rs.security.oauth2.services.AccessTokenService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;
&lt;bean id="accessTokenValidateService" class="org.apache.cxf.rs.security.oauth2.services.AccessTokenValidatorService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;jaxrs:server id="oauthServer" address="/oauth"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="accessTokenService"/&gt;
      &lt;ref bean="accessTokenValidateService"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>AccessTokenValidateService的绝对地址类似于“ http：// localhost：8080 / services / oauth / validate”。</p><p>AuthorizationCodeGrantService更容易放在应用程序端点的位置。它可以与AccessTokenService一起使用，但是理想情况下，还将部署基于SSO的身份验证解决方案，以使最终用户避免多次单独登录（请参阅下文中的更多内容）。这是AuthorizationCodeGrantService和ImplicitGrantService与应用程序端点并置的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="authorizationService" class="org.apache.cxf.rs.security.oauth2.services.AuthorizationCodeGrantService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;bean id="implicitService" class="org.apache.cxf.rs.security.oauth2.services.ImplicitGrantService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;bean id="jaxrsService" class="org.myapp.MyService"/&gt;

&lt;jaxrs:server id="appServer" address="/myapp"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="jaxrsService"/&gt;
      &lt;ref bean="authorizationService"/&gt;
      &lt;ref bean="implicitService"/&gt;
   &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>AuthorizationCodeGrantService侦听相对的“ / authorize”路径，因此在这种情况下，其绝对地址将类似于“ http：// localhost：8080 / services / myapp / authorize”。该地址和AccessTokenService的地址将由第三方客户端使用。</p><p>ImplictGrantService侦听相对的“ / authorize-implicit”路径</p><h3 id="JAX-RSOAuth2-AuthorizationCodeandImplicitServicesonthesamerelativepath">相对路径上的AuthorizationCode和隐式服务</h3><p>如上一节所述，AuthorizationCodeGrantService和ImplictGrantService侦听两个不同的相对路径：“ / authorize”和“ / authorize-implicit”。但是，并非总是倾向于在不同地址使用两种服务。如果愿意，可以使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/services/AuthorizationService.java" rel="nofollow">AuthorizationService'container</a> '服务：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="authorizationService" class="org.apache.cxf.rs.security.oauth2.services.AuthorizationCodeGrantService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;bean id="implicitService" class="org.apache.cxf.rs.security.oauth2.services.ImplicitGrantService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;util:list id="servicesList"&gt;
  &lt;ref bean="authorizationService"/&gt;
  &lt;ref bean="implicitService"/&gt;
&lt;/util:list&gt;

&lt;bean id="oauth2Service" class="org.apache.cxf.rs.security.oauth2.services.AuthorizationService"&gt;
    &lt;property name="services" ref="servicesList"/&gt;
&lt;/bean&gt;

&lt;bean id="jaxrsService" class="org.myapp.MyService"/&gt;

&lt;jaxrs:server id="appServer" address="/myapp"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="jaxrsService"/&gt;
      &lt;ref bean="oauth2Service"/&gt;
   &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>有关另一个示例，请参见此<a shape="rect" class="external-link" href="https://github.com/apache/cxf-fediz/blob/master/services/oidc/src/main/webapp/WEB-INF/applicationContext.xml" rel="nofollow">应用程序上下文</a> 。</p><h1 id="JAX-RSOAuth2-ThirdPartyClientAuthentication">第三方客户认证</h1><p>客户端从访问令牌服务请求令牌时，需要进行身份验证。作为基本授权方案的一部分提供其client_id和客户端机密或将其直接作为表单参数发布是典型的选项，但是如果需要，可以轻松地支持其他身份验证方案。</p><p>例如，使用客户端证书或SAML2 Bearer或JWT之类的断言都是可以接受的-在这种情况下，唯一的附加要求是，处理特定身份验证方案的给定安全过滤器会将客户端凭据映射到实际的client_id-CXF访问令牌服务将检查在当前消息上下文中的“ client_id”属性是最后的选择。请注意，org.apache.cxf.rs.security.oauth2.provider。如果基于容器或筛选器的身份验证无法设置“ client_id”上下文属性，则可以向AccessTokenService注册ClientIdProvider，以促进已身份验证的客户端与其数据提供者期望的ID之间的映射。</p><p>如果使用基本身份验证方案，并且容器或过滤器均未通过身份验证，则客户端AccessTokenService将向数据提供者请求客户端，并将客户端的机密与基本方案数据中找到的密码进行比较。 org.apache.cxf.rs.security.oauth2.provider。从CXF 3.0.3开始，可以使用ClientSecretVerifier，以支持客户端仅保存密码哈希。它的org.apache.cxf.rs.security.oauth2.provider。ClientSecretHashVerifier（计算SHA-256密码哈希并将其与客户端的机密进行比较）或自定义实现都可以使用AccessTokenService注册。</p><p>请参阅<a shape="rect" href="jaxrs-oauth2-assertions.html">JAXRS OAuth2断言</a>部分以获取有关其工作方式的更多信息。</p><h2 id="JAX-RSOAuth2-ClientCertificateAuthentication">客户端证书认证</h2><p>如果使用2向TLS对客户端进行身份验证，并且客户端的“ applicationCertificates”属性中具有可用的X509证书的Base64编码表示，则AccessTokenService将对这些证书与当前TLS会话中可用的证书进行额外的比较。</p><p><strong>新增功能</strong> ：自CXF 3.1.12起，完全支持<a shape="rect" class="external-link" href="https://tools.ietf.org/html/draft-ietf-oauth-mtls-17" rel="nofollow">OAuth 2.0相互TLS客户端身份验证和证书绑定访问令牌</a> 。请注意，此草稿中使用的某些参数可能会更改。</p><h1 id="JAX-RSOAuth2-UserSessionAuthenticity">用户会话真实性</h1><p>基于重定向的授权码和隐式流取决于最终用户是否需要在初始重定向期间登录，受到客户端授权表的挑战并返回其决定。默认情况下，CXF通过将会话状态保存在servlet容器的HTTPSession中来强制用户会话真实性。如果首选备用存储，则可以向AuthorizationCodeGrantService或ImplicitGrantService Bean注册新的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/SessionAuthenticityTokenProvider.java" rel="nofollow">SessionAuthenticityTokenProvider</a> 。</p><p>CXF提供了<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/JoseSessionTokenProvider.java" rel="nofollow">JoseSessionTokenProvider</a> ，后者使用<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-jose.html">CXF JOSE</a>创建紧凑的JWS和/或JWE序列，以捕获当用户返回授权表单决定且此安全序列成为会话令牌时所需的所有数据。</p><h3 id="JAX-RSOAuth2-Keepingthestateinthesession">在会话中保持状态</h3><p>请注意， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/SessionAuthenticityTokenProvider.java" rel="nofollow">SessionAuthenticityTokenProvider</a>在CXF 3.1.0中进行了进一步更新，以支持对某些重定向属性进行签名和/或加密，否则这些重定向属性必须保留为HTML表单隐藏字段（请参阅“授权服务”部分）。</p><p>CXF提供了使用<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-jose.html">CXF JOSE的</a> <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/JoseSessionTokenProvider.java" rel="nofollow">JoseSessionTokenProvider</a> ，该<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/JoseSessionTokenProvider.java" rel="nofollow">COSE</a>可以用作SessionAuthenticityTokenProvider，它通过JWS对和/或JWE加密属性并将结果保存在会话中。HTML授权表单将仅具有“ authenticityToken”属性，提供者将使用该属性来匹配会话签名/加密的数据以及解密和/或验证会话数据。</p><h3 id="JAX-RSOAuth2-MultipleFactorVerification">多因素验证</h3><p>请注意， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/SessionAuthenticityTokenProvider.java" rel="nofollow">SessionAuthenticityTokenProvider</a>已在CXF 3.0.2中更新，可以接受请求参数和对已验证用户的引用。这允许引入多因素会话验证：当提供者创建会话属性时，它可以例如向用户的手机发送消息，以期望授权同意书返回发送的值。</p><p>另一个较小的增强功能是RedirectionBasedGrantService将使用“ session_authenticity_token_param_name”属性名称来检查授权内容表单中包含会话身份验证属性的表单属性的名称。这允许“旋转”包含实际会话真实性值的隐藏表单属性。</p><h1 id="JAX-RSOAuth2-CustomizingEndUserSubjectinitialization">自定义最终用户主题初始化</h1><p>默认情况下，基于重定向的授权服务将使用当前CXF SecurityContext来初始化表示已验证资源所有者/最终用户的主题。如果需要定制，则可以使用定制CXF筛选器来创建UserSubject并将其设置在消息或org.apache.cxf.rs.security.oauth2.provider上。可以使用AuthorizationCodeGrantService或ImplicitGrantService注册SubjectCreator接口实现。</p><h1 id="JAX-RSOAuth2-ProtectingresourceswithOAuthfilters">使用OAuth过滤器保护资源</h1><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/OAuthRequestFilter.java" rel="nofollow">OAuthRequestFilter</a>请求处理程序可用于在处理来自第三方客户端的请求时保护资源服务器。将它作为jaxrs：provider添加到处理请求资源的客户端的端点。</p><p>当检查这样的请求时：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Address: http://localhost:8080/services/thirdPartyAccess/calendar
Http-Method: GET
Headers: 
{
  Authorization=[Bearer 5b5c8e677413277c4bb8b740d522b378], 
  Accept=[application/xml]
}
</pre>
</div></div><p>过滤器将执行以下操作：</p><p>1。通过委派给匹配的已注册<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/AccessTokenValidator.java" rel="nofollow">AccessTokenValidator</a>来检索ServerAccessToken。预期AccessTokenValidator将检查传入令牌参数的有效性，并可能委派给OAuthDataProvider以查找令牌表示形式-如果未找到匹配的AccessTokenValidator且授权方案为“承载”，则这是过滤器的默认设置。</p><p>2。检查令牌尚未过期</p><p>3。AccessToken可能具有<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthPermission.java" rel="nofollow">OAuthPermission</a>列表。对于每个许可，它将：</p><ul class="alternate"><li>如果设置了uri属性，则将根据该属性检查当前请求URI</li><li>如果设置了httpVerb属性，则将根据该属性检查当前的HTTP动词</li></ul><p>如果设置了allPermissionsMatch属性，则过滤器将检查是否已满足所有令牌权限。</p><p>如果设置了requestScopes属性，则过滤器将检查一个或多个令牌权限是否已“覆盖”所有范围。</p><p>4。最后，它将使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthPermission.java" rel="nofollow">OAuthPermissions的</a>此列表创建CXF SecurityContext， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/UserSubject.java" rel="nofollow">UserSubject</a>代表授权用于获取此令牌的授权的客户端或最终用户。</p><p>对于某些OAuth2应用程序，此SecurityContext不一定很重要。大多数安全检查将由OAuth2过滤器和安全过滤器完成，这些过滤器和保护最终用户自己使用的主要应用程序路径。仅当您希望共享相同的JAX-RS资源代码并在最终用户和客户端之间访问URI时，它才变得很方便。下面有更多内容。</p><p>这是如何配置OAuthRequestFilter的一个示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="oauthProvider" class="oauth.manager.OAuthManager"/&gt;
&lt;bean id="oauthFiler" class="org.apache.cxf.rs.security.oauth2.filters.OAuthRequestFilter"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;bean id="myApp" class="org.myapp.MyApp"/&gt;

&lt;jaxrs:server id="fromThirdPartyToMyApp" address="/thirdparty-to-myapp"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="myApp"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
  &lt;jaxrs:providers&gt;
      &lt;ref bean="oauthFilter"/&gt;
  &lt;/jaxrs:providers&gt;
  
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>它将依赖OAuthDataProvider的实例来获取有关当前访问令牌的信息并对其进行验证。<br clear="none">当很容易在此过滤器以及授权和AccessToken服务之间共享相同的OAuthDataProvider时，此选项可以正常使用。OAuthDataProvider也可以实现为以分布式方式管理信息，因此上述配置选项可以很好地扩展以用于更复杂的部署。</p><p>当授权和AccessToken服务未与应用程序端点并置时，以下方法可能会更好：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="tvServiceClientFactory" class="org.apache.cxf.jaxrs.client.JAXRSClientFactoryBean"&gt;
    &lt;property name="address" value="http://localhost:${http.port}/services/oauth/validate"/&gt;
    &lt;property name="headers"&gt;
        &lt;map&gt;
            &lt;entry key="Accept" value="application/xml"/&gt;
            &lt;entry key="Content-Type" value="application/x-www-form-urlencoded"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
     
&lt;bean id="tvServiceClient" factory-bean="tvServiceClientFactory" factory-method="createWebClient"/&gt;

&lt;bean id="tokenValidator" class="org.apache.cxf.rs.security.oauth2.filters.AccessTokenValidatorClient"&gt;
    &lt;property name="tokenValidatorClient" ref="tvServiceClient"/&gt;
&lt;/bean&gt;

&lt;bean id="oauthFiler" class="org.apache.cxf.rs.security.oauth2.filters.OAuthRequestFilter"&gt;
    &lt;property name="tokenValidator" ref="tokenValidator"/&gt;
&lt;/bean&gt;

&lt;bean id="myApp" class="org.myapp.MyApp"/&gt;

&lt;jaxrs:server id="fromThirdPartyToMyApp" address="/thirdparty-to-myapp"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="myApp"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
  &lt;jaxrs:providers&gt;
      &lt;ref bean="oauthFilter"/&gt;
  &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><h2 id="JAX-RSOAuth2-OAuth2tokensandSOAPendpoints">OAuth2令牌和SOAP端点</h2><p>如果使用HTTP授权标头或WS-Security Binary令牌将OAuth2令牌传递到SOAP端点，则可以使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/OAuthRequestInterceptor.java" rel="nofollow">OAuthRequestInterceptor</a>来验证此类令牌。它是作为CXF拦截器运行的OAuthRequestFilter，它将对通过Authorization标头传递的令牌使用OOB，并且可以轻松扩展以支持WS-Security二进制令牌</p><h1 id="JAX-RSOAuth2-Scope-basedaccesscontrol">基于范围的访问控制</h1><p>如上所述，可以将OAuthRequestFilter配置为执行很多安全检查。</p><p>此外，从CXF 3.1.5开始，还可以控制可以调用哪些服务方法</p><p>带有新的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/Scopes.java" rel="nofollow">Scopes</a>批注和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/OAuthScopesFilter.java" rel="nofollow">OAuthScopesFilter</a> （需要与OAuthRequestFilter一起注册）。</p><p>例如：</p><pre>@Path("calendar")
public class CalendarResource {

   
   @PUT
   @Path("{id}")<br clear="none">   @Scopes("update-calendar")<br clear="none">   @ConfidentialClient<br clear="none">   public void updateCalendar(@PathParam("id") long id, Calendar c) {
       // update the calendar for a user identified by 'id'
   }
}<br clear="none">&#160;</pre><p>在此示例中，如果客户端的访问令牌包含“ update-calendar”作用域，并且客户端的访问令牌包含以下内容，则该客户端只能调用updateCalendar方法：</p><p>它是一个<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/filters/ConfidentialClient.java" rel="nofollow">ConfidentialClient</a> 。如前所述，OAuthRequestFilter可以使用'requestScopes'属性进行配置，但是使用Scopes批注可以提供更细腻，更细腻的输入</p><p>访问控制。</p><h1 id="JAX-RSOAuth2-Howtogettheuserloginname">如何获得用户登录名</h1><p>在编写需要参与OAuth2流的自定义服务器应用程序时，需要解决的主要问题是，如何访问最终用户授权第三方客户端期间使用的用户登录名。此用户名将有助于唯一标识第三方客户端现在尝试访问的资源。以下代码显示了完成此操作的一种方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> 
import org.apache.cxf.rs.security.oauth2.utils.OAuthContextUtils;

@Path("/userResource")
public class ThirdPartyAccessService {

    @Context 
    private MessageContext mc;
	
    @GET
    public UserResource getUserResource() {
        
	String endUserName = OAuthContextUtils.resolveUserName(mc);

	return findUserResource(endUserName)
    }

    private UserResource findUserResource(String endUserName) {
        // find and return UserResource
    }
}

</pre>
</div></div><p>上面显示了JAX-RS服务的一个片段，该片段管理来自授权的第三方客户端对用户资源的访问（有关更多信息，请参见“设计注意事项”部分）。</p><p>注入的MessageContext提供对<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthContext.java" rel="nofollow">OAuthContext</a>的访问，该访问已由上一节中描述的OAuth2过滤器设置。OAuthContext将充当信息的容器，这对不需要处理OAuth2内部的自定义应用程序代码很有用。OAuthContextUtils提供了许多实用程序方法来检索和使用OAuthContext。</p><p>请注意，从CXF 2.7.6开始，还可以将OAuthContext作为JAX-RS上下文注入：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> 
import org.apache.cxf.rs.security.oauth2.common.OAuthContext;

@Path("/userResource")
public class ThirdPartyAccessService {

    @Context 
    private OAuthContext context;
	
    @GET
    public UserResource getUserResource() {
	//....
    }
}
</pre>
</div></div><p>org.apache.cxf.rs.security.oauth2.provider。OAuthContextProvider必须被注册为jaxrs：provider才能运行。</p><h1 id="JAX-RSOAuth2-Client-sidesupport">客户端支持</h1><p>开发需要参与OAuth2流程的第三方应用程序时，必须处理将用户重定向到OAuth2 AuthorizationCodeGrantService，与AccessTokenService进行交互以交换访问令牌的代码授权以及在访问最终用户时正确构建Authorization OAuth2标头的问题。资源。</p><h2 id="JAX-RSOAuth2-AdvancedOAuth2clientapplications">先进的OAuth2客户端应用程序</h2><p>在许多情况下，支持代码流的OAuth2客户端应用程序需要直接编写特定于OAuth2的代码。鉴于编写这样的代码需要他们了解OAuth2的详细信息，因此此类客户具有高级资格。那就是</p><p>JAX-RS使直接支持重定向变得很简单，而<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/client/OAuthClientUtils.java" rel="nofollow">OAuthClientUtils</a>类使封装大多数复杂性远离客户端应用程序代码成为可能，因此最终支持的代码通常根本没有那么复杂，而同时提供最大的灵活性。</p><p>例如，第三方应用程序可以使用以下自定义代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class OAuthClientManager {
	
	private WebClient accessTokenService;
    private String authorizationServiceURI;
    private Consumer consumer;

    // inject properties, register the client application...

	public URI getAuthorizationServiceURI(ReservationRequest request,
			                              URI redirectUri,
			                              /* state */String reservationRequestKey) {
	    String scope = OAuthConstants.UPDATE_CALENDAR_SCOPE + request.getHour();
	    return OAuthClientUtils.getAuthorizationURI(authorizationServiceURI, 
	    		                                consumer.getKey(),
	    		                                redirectUri.toString(),
	    		                                reservationRequestKey,
	    		                                scope);
	}
	public ClientAccessToken getAccessToken(AuthorizationCodeGrant codeGrant) {
	    try {
	        return OAuthClientUtils.getAccessToken(accessTokenService, consumer, codeGrant);
	    } catch (OAuthServiceException ex) {
	        return null;
	    }
	}
	
	public String createAuthorizationHeader(ClientAccessToken token) {
		return OAuthClientUtils.createAuthorizationHeader(consumer, token);
	}
}
</pre>
</div></div><p>可以引入这种简单包装的原因是将主应用程序代码对OAuth2的暴露程度降至最低，这就是为什么在此示例中捕获OAuthServiceExceptions，大概记录并返回空值的原因，该值将指示主代码。该请求失败。显然，也可以直接使用OAuthClientUtils。</p><p>请注意，在上面的示例中，AuthorizationCodeGrant实例作为最后一个参数传递到OAuthClientUtils.getAccessToken（）方法，同时还引用了AccessTokenService客户端和OAuthClientUtils。消费者Bean保留客户端ID和秘密。</p><p>CXF为它支持的所有授予提供实用程序授予Bean，请参阅上面有关授予的信息。在请求访问令牌或创建自定义AccessTokenGrant bean实现时，请使用与您的应用程序相关的适当的Grant bean。</p><p>例如，考虑以下情况：已经拥有授权访问令牌并且正在访问最终用户资源的客户端返回HTTP 401错误，并且客户端还拥有刷新令牌。这是一种解决方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.ws.rs.NotAuthorizedException;
import javax.ws.rs.core.HttpHeaders;

import org.apache.cxf.rs.security.oauth2.client.OAuthClientUtils;
import org.apache.cxf.rs.security.oauth2.client.OAuthClientUtils.Consumer;
import org.apache.cxf.rs.security.oauth2.grants.code.AuthorizationCodeGrant;
import org.apache.cxf.rs.security.oauth2.grants.refresh.RefreshTokenGrant;
import org.apache.cxf.rs.security.oauth2.common.ClientAccessToken;

// the pseudo-code for getting the access token
Consumer consumer = ...
AuthorizationCodeGrant codeGrant = ...

ClientAccessToken accessToken = OAuthClientUtils.getAccessToken(codeGrant, consumer);

WebClient endUserResourceClient = WebClient.create(endUserServerAddress);

endUserResourceClient.header(HttpHeaders.AUTHORIZATION, 
                             OAuthClientUtils.createAuthorizationHeader(accessToken));
try {
   return endUserResourceClient.get();
} catch (NotAuthorizedException ex) {
    String refreshToken = accessToken.getRefreshToken();
    if (refreshToken != null) {
        // retry once

        // refresh the token
        accessToken = OAuthClientUtils.getAccessToken(new RefreshTokenGrant(refreshToken), consumer);

        // reset Authorization header
        endUserResourceClient.replaceHeader(HttpHeaders.AUTHORIZATION, 
                             OAuthClientUtils.createAuthorizationHeader(accessToken)); 

        // try to access the end user resource again
        return endUserResourceClient.get();
        
    } else {
        throw ex;
    }

}
</pre>
</div></div><p>直接处理OAuth2细节的客户端代码可能是最容易实现的选择：同时具有访问令牌和刷新令牌的客户端可以检查当前访问令牌的到期时间，如果已知已到期，则可以主动</p><p>刷新令牌，避免执行徒劳的HTTP请求，该请求必须返回401。或者/并且确实可以处理JAX-RS NotAuthorizedException（401）并刷新令牌。复杂的客户端可能希望检查已为给定的访问令牌批准了哪些范围，并动态决定是否可以进行给定的HTTP服务调用。客户还可以使用令牌吊销机制主动吊销令牌。</p><h2 id="JAX-RSOAuth2-OAuth2clientapplicationswithcode-grantfilters">带有代码授予过滤器的OAuth2客户端应用程序</h2><p>上一节中的代码显示了直接支持OAuth2动态（重定向，访问令牌获取）的客户端应用程序代码。从CXF 3.0.6开始，借助ClientCodeRequestFilter，可以使用一个更简单的选项。此过滤器管理初始重定向，交换代码授予的令牌，保留请求状态，然后使令牌和状态可用于应用程序代码，例如，以下代码不处理重定向本身或与OAuth2服务器交互：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.jaxrs.client.WebClient;
import org.apache.cxf.rs.security.oauth2.client.ClientTokenContext;

@Path("reserve")
public class ReservationService {

private WebClient socialService;
private WebClient restaurantService;

@GET
@Path("table")
@Produces("text/html")
public Response reserve(@Context ClientTokenContext context) {
    // Check if token is available
    if (context.getToken() == null) {
       return redirectToFailureHandler(NO_CODE_GRANT);
    }
    // Prepare Authorization header
    socialService.authorization(context.getToken());
    
    // Get the state that was captured by the filter before redirecting the user to OAuth2 server
    ReservationRequest request = context.getState(ReservationRequest.class);
    
    // Work with the service on behalf of a user    
    Calendar c = null;
    try {
      c = socialService.get(Calendar.class);
    } catch (RuntimeException ex) {
      return redirectToFailureHandler(CALENDAR_ACCESS_PROBLEM);
    }
        
    CalendarEntry entry = c.getEntry(request.getHour());
    if (entry.getEventDescription() == null || entry.getEventDescription().trim().isEmpty()) { 
        String address = restaurantService.post(new Form().param("name", request.getReserveName()) 
                                         .param("phone", request.getContactPhone()) 
                                         .param("hour", Integer.toString(request.getHour())),
                                          String.class);
        if (address == null) {
            return redirectToFailureHandler(NO_RESERVATION);
        }
            
        // update the user's calendar
        Response response = socialService.form(new Form().param("hour", Integer.toString(request.getHour()))
                                         .param("description", "Table reserved at " + address));
        boolean calendarUpdated = response.getStatus() == 200 || response.getStatus() == 204;
            
        return Response.ok(new ReservationConfirmation(address, request.getHour(), calendarUpdated))
                           .build();
        } else {
            return redirectToFailureHandler(CALENDAR_BUSY);
        }
    }
}

</pre>
</div></div><p><br clear="none"></p><p>过滤器的配置如下：</p><p><br clear="none"></p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;beans&gt;
    
&lt;jaxrs:server id="reservationsServer" address="/reservations"&gt;
    &lt;jaxrs:serviceBeans&gt;
       &lt;ref bean="restaurantReserveService"/&gt;
    &lt;/jaxrs:serviceBeans&gt;
    &lt;jaxrs:providers&gt;
       &lt;!-- other providers --&gt;

       &lt;bean class="oauth2.thirdparty.CustomClientTokenContextProvider"/&gt;
       &lt;bean class="org.apache.cxf.rs.security.oauth2.client.ClientCodeRequestFilter"&gt;
           &lt;property name="authorizationServiceUri" value="http://localhost:8080/services/authorize"/&gt;
           &lt;property name="accessTokenServiceClient" ref="atServiceClient"/&gt;
           &lt;property name="startUri" value="reserve/table"/&gt;
           &lt;property name="clientCodeStateManager" ref="codeManager"/&gt;
           &lt;property name="consumer" ref="consumer"/&gt;
       &lt;/bean&gt;
    &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;
     
&lt;bean id="codeManager" class="oauth2.thirdparty.ClientCodeStateManagerImpl"/&gt;

&lt;!-- the consumer pre-registered with OAuth2 servers --&gt;
&lt;bean id="consumer" class="org.apache.cxf.rs.security.oauth2.client.Consumer"&gt;
    &lt;property name="key" value="123456789"/&gt;
    &lt;property name="secret" value="987654321"/&gt;
&lt;/bean&gt;

&lt;!-- WebClient for communicating with OAuth2 AccessTokenService --&gt;
&lt;jaxrs-client:client id="atServiceClient" serviceClass="org.apache.cxf.jaxrs.client.WebClient"
    address="http://localhost:8080/services/oauth2Token/token"&gt;
    &lt;jaxrs-client:headers&gt;
       &lt;entry key="Accept" value="application/json"/&gt;
    &lt;/jaxrs-client:headers&gt;
&lt;/jaxrs-client:client&gt;

&lt;/beans&gt;
</pre>
</div></div><p>当匹配“ startUri”时，ClientCodeRequestFilter重定向到“ authorizationServiceUri”。</p><p>在上面的示例中，过滤器使用了自定义的“ clientCodeStateManager”（org.apache.cxf.rs.security.oauth2.client。ClientCodeStateManager实现），用于在重定向之前保留原始请求状态，以便以后可以在应用程序代码上使用-这是可选的，仅当重定向请求取决于请求参数时才需要（例如，Oauth2范围值是动态的，例如updateCalendar -7，其中“ 7”是小时）。默认情况下，CXF开箱即用地提供了一些状态管理器，目前它们是MemoryClientCodeStateManager和JoseClientCodeStateManager实现，后者对请求状态进行签名和/或加密，并将其保存在HTTP会话中。</p><p>将用户重定向回后，过滤器将代码交换为新的访问令牌，并在ClientTokenContext中设置此令牌和原始重定向状态。注意CllientTokenContext将原始请求状态作为MultivaluedMap提供给应用程序。</p><p>CXF还提供了默认的ClientTokenContext实现，即一个简单的org.apache.cxf.rs.security.oauth2.client。ClientTokenContextImpl bean。最后，CXF交付了org.apache.cxf.rs.security.oauth2.client。ClientTokenContextProvider，以确保ClientTokenContext可以作为JAX-RS上下文使用。请注意，尽管上述配置注册了自定义ClientTokenContext提供程序（'oauth2.thirdparty。而是使用CustomClientTokenContextProvider'）-这是可选的，并且仅当应用程序代码希望以一种类型安全的方式（例如，通过上面所示的ReservationRequest类型）访问状态时才需要，这样的提供者可以这样实现：</p><p><br clear="none"></p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.ws.rs.core.MultivaluedMap;
import org.apache.cxf.jaxrs.ext.ContextProvider;
import org.apache.cxf.message.Message;
import org.apache.cxf.rs.security.oauth2.client.ClientTokenContext;
import org.apache.cxf.rs.security.oauth2.client.ClientTokenContextProvider;
import org.apache.cxf.rs.security.oauth2.common.ClientAccessToken;

public class CustomClientTokenContextProvider extends ClientTokenContextProvider {
    @Override
    public ClientTokenContext createContext(Message m) {
        return new WrapClientTokenContext(super.createContext(m));
    }
    private static class WrapClientTokenContext implements ClientTokenContext {
        private ClientTokenContext ctx;
        public WrapClientTokenContext(ClientTokenContext ctx) { 
            this.ctx = ctx;
        }
        @Override
        public MultivaluedMap&lt;String, String&gt; getState() {
            return ctx.getState();
        }
        @Override
        public &lt;T&gt; T getState(Class&lt;T&gt; cls) {
            if (ReservationRequest.class == cls) {
                MultivaluedMap&lt;String, String&gt; state = getState();
                return (T)new ReservationRequest(state.getFirst("name"),
                                              state.getFirst("phone"),
                                              Integer.parseInt(state.getFirst("hour")));
            }
            return ctx.getState(cls);
        }
        @Override
        public ClientAccessToken getToken() {
            return ctx.getToken();
        }
    }
}</pre>
</div></div><p><br clear="none"></p><p>还可以使用org.apache.cxf.rs.security.oauth2.client配置ClientCodeRequestFilter。ClientTokenContextManager（'clientTokenContextManager'属性）用于支持以下情况：同一用户正在返回同一请求，并且先前授予的访问令牌尚未过期。目前，CXF仅随附具有JOSE感知提供程序的MemoryClientTokenContextManager。如果注册了管理员，并且找到了当前用户的上下文（和访问令牌），则请求将继续进行而无需重定向。在这种情况下，如果令牌已经过期或接近过期，过滤器可以主动刷新令牌（例如，“ expiryThreshold”属性设置为5秒，并且过滤器看到令牌将在不到5天内到期秒，然后它将尝试刷新）。</p><p>当所有用户都使用静态OAuth2范围时，ClientCodeRequestFilter也可以配置为“范围”属性（请注意，“范围”是通常发送给OAuth2服务器的重定向参数之一）</p><p>请注意，取决于OIDC RP身份验证，客户端应用程序也可以使用类似的过滤器支持。</p><h2 id="JAX-RSOAuth2-OAuth2clientauthenticatorsfornon-dynamicclients">非动态客户端的OAuth2客户端身份验证器</h2><p>并非所有可能需要访问受OAuth2保护的应用程序服务器的客户端都可以修改。此外，并非所有的OAuth2客户端都可以参与高级流，例如授权码流，并且需要使用访问令牌和刷新令牌进行初始化。</p><p>从CXF 3.0.5开始附带支持访问和刷新令牌的CXF HTTPConduit HttpAuthSupplier。</p><p>org.apache.cxf.rs.security.oauth2.client。BearerAuthSupplier支持从承载访问令牌创建HTTP授权标头，主动刷新它们或响应401故障，并从刷新的令牌重新创建HTTP授权。</p><p>无法从JAX-RS ClientRequestFilter刷新令牌，因为这样的筛选器无法处理HTTP响应，因此它无法检测到401（如果访问令牌已过期，则由服务器返回），而HTTPConduit HttpAuthSupplier则有机会做出反应到401，然后重试。</p><p>这是一个配置示例：</p><p><br clear="none"></p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;beans&gt;
&lt;bean id="consumer" class="org.apache.cxf.rs.security.oauth2.client.Consumer"&gt;
   &lt;property name="clientId" value="1"/&gt;
   &lt;property name="clientSecret" value="2"/&gt;
&lt;/bean&gt;
&lt;bean id="bearerAuthSupplier" class="org.apache.cxf.rs.security.oauth2.client.BearerAuthSupplier"&gt;
   &lt;!-- access token --&gt;
   &lt;property name="accessToken" value="12345678"/&gt;
   &lt;!-- refresh token and the info needed to use it to refersh the expired access token proactively or in response to 401 --&gt; 
   &lt;property name="refreshToken" value="87654321"/&gt;
   &lt;!-- 
       Set this property for the authenticator to check the access token expiry date and refresh the token proactively.
       Note that this property can also become effective after the first token refresh as it is not known in advance when 
       the injected access token will expire
   --&gt;
   &lt;property name="refreshEarly" value="true"/&gt;
   &lt;!-- client OAuth2 id and secret - needed to use a refresh token grant --&gt; 
   &lt;property name="consumer" ref="consumer"/&gt;
   &lt;!-- address of OAuth2 token service that supports a refresh token grant
   &lt;property name="accessTokenServiceUri" value="https://server/oauth2/accessToken"/&gt;
&lt;/bean&gt;
&lt;conduit name="*.http-conduit" xmlns="http://cxf.apache.org/transports/http/configuration"&gt;
  &lt;authSupplier&gt;
     &lt;ref bean="bearerAuthSupplier"/&gt;
  &lt;/authSupplier&gt;
&lt;/conduit&gt;
&lt;/beans&gt;</pre>
</div></div><p><br clear="none"></p><p>目前，仅支持载体访问令牌的BearerAuthSupplier可用；将来会提供支持其他众所周知令牌类型的身份验证器。</p><p>org.apache.cxf.rs.security.oauth2.client。还提供了CodeAuthSupplier。它与BearerAuthSupplier相似，不同之处在于它是从带外获得的授权码授予中不完整的，它使用该授予来获取令牌，然后委托给BearerAuthSupplier。例：</p><p><br clear="none"></p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;beans&gt;
&lt;bean id="consumer" class="org.apache.cxf.rs.security.oauth2.client.Consumer"&gt;
   &lt;property name="clientId" value="1"/&gt;
   &lt;property name="clientSecret" value="2"/&gt;
&lt;/bean&gt;
&lt;bean id="codeAuthSupplier" class="org.apache.cxf.rs.security.oauth2.client.CodeAuthSupplier"&gt;
   &lt;!-- authorization code --&gt;
   &lt;property name="code" value="12345678"/&gt;

   &lt;!-- Set this property for the authenticator to check the access token expiry date and refresh the token proactively --&gt;
   &lt;property name="refreshEarly" value="true"/&gt;
   &lt;!-- client OAuth2 id and secret - needed to use a refresh token grant --&gt; 
   &lt;property name="consumer" ref="consumer"/&gt;
   &lt;!-- address of OAuth2 token service that supports a refresh token grant
   &lt;property name="accessTokenServiceUri" value="https://server/oauth2/accessToken"/&gt;
&lt;/bean&gt;
&lt;conduit name="*.http-conduit" xmlns="http://cxf.apache.org/transports/http/configuration"&gt;
  &lt;authSupplier&gt;
     &lt;ref bean="codeAuthSupplier"/&gt;
  &lt;/authSupplier&gt;
&lt;/conduit&gt;
&lt;/beans&gt;</pre>
</div></div><p><br clear="none"></p><p>此外，还有一个基本的JAX-RS 2.0 ClientRequestFilter，org.apache.cxf.rs.security.oauth2.client。BearerClientFilter已发货，并且仅使用“ accessToken”属性进行了初始化。在只有非到期的访问令牌可用的情况下，可以使用它。</p><p>如上所述，无法使用在ClientRequestFilter中过期的令牌。但是，将来可能会增强BearerClientFilter，以支持主动刷新访问令牌。</p><h1 id="JAX-RSOAuth2-OAuth2withouttheExplicitAuthorization">没有明确授权的OAuth2</h1><p>客户端凭据是OAuth2授予之一，不需要显式授权，并且目前由CXF支持。</p><h1 id="JAX-RSOAuth2-OAuthWithoutaBrowser">没有浏览器的OAuth</h1><p>当最终用户访问第三方应用程序并稍后对其进行授权时，通常可以预期该用户依赖于浏览器。<br clear="none">但是，支持其他类型的最终用户非常容易。使用JAX-RS可以很容易地编写用于处理来自第三方应用程序和AuthorizationCodeGrantService的重定向请求的客户端代码，并且可以将CXF配置为在客户端进行自动重定向。</p><p>还要注意，AuthorizationCodeGrantService可以返回XML或JSON OAuthAuthorizationData表示形式。这样，客户端代码就可以轻松获取OAuthAuthorizationData并提供一个弹出窗口或从命令行获取输入。在这种情况下，甚至可以自动授权第三方应用程序-这可能会导致实施完整的三段式OAuth流程而无需人工参与。</p><h1 id="JAX-RSOAuth2-Reportingerrordetails">报告错误详细信息</h1><p>本<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc6749#section-5.2" rel="nofollow">节</a>列出了可以返回给客户端应用程序的所有错误属性。CXF OAuth2服务将始终报告必需的“错误”属性，但默认情况下将忽略可选的错误属性（例如，在访问令牌授予处理程序抛出<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthServiceException.java" rel="nofollow">OAuthServiceException并</a>初始化为<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthError.java" rel="nofollow">OAuthError的</a>情况下，该<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/common/OAuthError.java" rel="nofollow">OAuthErrorException</a>可能设置了可选属性）。<br clear="none">当实际需要报告可选错误属性时，则将'writeCustomErrors'属性设置为'true'将有所帮助：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="oauthProvider" class="oauth2.manager.OAuthManager"/&gt;

&lt;bean id="accessTokenService" class="org.apache.cxf.rs.security.oauth2.services.AccessTokenService"&gt;
    &lt;property name="dataProvider" ref="oauthProvider"/&gt;
    &lt;property name="writeCustomErrors" value="true"/&gt;
&lt;/bean&gt;
</pre>
</div></div><h1 id="JAX-RSOAuth2-OAuth2andJOSE">OAuth2和JOSE</h1><p>有关JOSE以及CXF如何支持JOSE的信息，请参见<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-jose.html">JAX-RS JOSE</a> Wiki页面。</p><p>CXF OAuth2取决于其JOSE实现，请参见上面的部分。尤其：</p><ul style="list-style-type:square"><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/JoseSessionTokenProvider.java" rel="nofollow">JoseSessionTokenProvider</a>可以与AuthorizationCodeGrantService或ImplicitService一起用作自定义SessionAuthenticityTokenProvider</li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/client/JoseClientCodeStateManager.java" rel="nofollow">JoseClientCodeStateManager</a>可以与机密客户端Web应用程序中的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/client/ClientCodeRequestFilter.java" rel="nofollow">ClientCodeRequestFilter</a>一起使用。</li><li>JWT断言客户端和服务器授予处理程序在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/jwt" rel="nofollow">此软件包中提供</a> 。</li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/JwtRequestCodeFilter.java" rel="nofollow">提供JwtRequestCodeFilter</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/grants/code/JwtRequestCodeGrant.java" rel="nofollow">JwetRequestCodeGrant</a>以支持保护授权代码和隐式流请求属性。</li><li>提供了将JWT表示为访问令牌的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/tokens/jwt" rel="nofollow">初始实用程序代码</a> ，并将进一步扩展。</li><li>有许多使用JWT的实用程序类： <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthJoseJwtConsumer.java" rel="nofollow">OAuthJoseJwtConsumer</a> ， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthJoseJwtProducer.java" rel="nofollow">OAuthJoseJwtProducer</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth2/src/main/java/org/apache/cxf/rs/security/oauth2/provider/OAuthServerJoseJwtProducer.java" rel="nofollow">OAuthServerJoseJwtProducer</a> 。这些类扩展了JOSE生产者和消费者帮助者，并支持在JWS或JWE操作中使用OAuth2客户机密和公共证书。</li></ul><h1 id="JAX-RSOAuth2-OAuth2andOIDC">OAuth2和OIDC</h1><p>CXF附带了OIDC RP和IDP服务代码，具体取决于其OAuth2和JOSE实现。有关更多信息，请参<a shape="rect" href="jax-rs-oidc.html">见此页面</a> 。</p><h1 id="JAX-RSOAuth2-Designconsiderations">设计注意事项</h1><p>本节将讨论在部署基于OAuth的解决方案时需要考虑的各种设计注意事项。</p><h2 id="JAX-RSOAuth2-ControllingtheAccesstoResourceServer">控制对资源服务器的访问</h2><p>需要解决的最重要的问题之一是如何对资源服务器应用程序的URI空间进行分区。</p><p>我们有两个不同的方试图访问它，即访问资源服务器以获取其拥有资源的最终用户和已被最终用户授权访问其某些资源的第三方客户端。</p><p>在前一种情况下，身份验证的管理方式完全取决于资源服务器应用程序：您可以将其命名为基本身份验证，双向TLS，OpenId（请参见下文）。</p><p>在后一种情况下，OAuth过滤器必须强制使用已提供的客户端密钥注册了第三方客户端，并且该客户端具有有效的访问令牌，该令牌代表最终用户的批准。</p><p>让双方通过相同的URI访问资源服务器会使安全过滤器的寿命变得复杂，但是所有各方都只知道它们将使用的单个资源服务器URI。</p><p>向最终用户和客户端提供不同的访问点可能会大大简化身份验证过程-可能的缺点是资源服务器需要维护多个访问点。</p><p>接下来讨论这两个选项。</p><h3 id="JAX-RSOAuth2-Sharingthesameaccesspathbetweenendusersandclients">在最终用户和客户端之间共享相同的访问路径</h3><p>需要解决的第一个问题是如何将最终用户与第三方客户端区分开，并根据需要对双方进行身份验证。<br clear="none">也许最简单的选择是扩展一个CXF OAuth2过滤器（JAX-RS或servlet一个），检查Authorization标头，如果它是OAuth2，则委托给超类，或者-继续验证最终用户：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class SecurityFilter extends org.apache.cxf.rs.security.oauth2.filters.OAuthRequestFilter {
   @Context
   private HttpHeaders headers;

   public Response handleRequest(ClassResourceInfo cri, Message message) {
       String header = headers.getRequestHeaders().getFirst("Authorization");
       if (header.startsWith("Bearer ")) {
           return super.handleRequest(cri, message);
       } else {
           // authenticate the end user
       }
   }

} 
</pre>
</div></div><p>下一个问题是如何强制最终用户只能访问他们被授权访问的资源。<br clear="none">例如，考虑以下JAX-RS资源类：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("calendar")
public class CalendarResource {

   @GET
   @Path("{id}")
   public Calendar getPublicCalendar(@PathParam("id") long id) {
       // return the calendar for a user identified by 'id'
   }

   @GET
   @Path("{id}/private")
   public Calendar getPrivateCalendar(@PathParam("id") long id) {
       // return the calendar for a user identified by 'id'
   }

   @PUT
   @Path("{id}")
   public void updateCalendar(@PathParam("id") long id, Calendar c) {
       // update the calendar for a user identified by 'id'
   }
}
</pre>
</div></div><p>假设仅允许第三方客户端读取“ / calendar / {id}”上的公共用户日历，如何确保客户端不会尝试：<br clear="none">1.更新在相同路径下可用的日历<br clear="none">2.阅读“ / calendar / {id} / private”中的私人日历。</p><p>如上所述，OAuthPermission具有可选的URIs属性。因此，解决私有日历问题的一种方法是在OAuthPermission中添加一个uri“ / calendar / {id}”或“ / calendar / 1”（等）属性（表示一个范围，例如“ readCalendar”）， OAuth过滤器将确保无法访问“ / calendar / {id}”以外的任何子资源。请注意，在给定URI属性的末尾添加“ *”，例如“ / a *”将使客户端访问“ / a”，“ / a / b”等。</p><p>通过将httpVerb属性添加到给定的OAuthPermission，可以轻松解决解决阻止更新的问题。</p><p>另一种选择是依靠基于角色的访问控制并分配@RolesAllowed，这样，只有角色（如“客户端”或“最终用户”）中的用户才能调用getCalendar（）方法，并仅允许“最终用户”角色中的用户访问getPrivateCalendar（）和updateCalendar（）。如有关使用OAuth适配程序的部分所述，OAuthPermission也可以在此处提供帮助。</p><h3 id="JAX-RSOAuth2-Providingdifferentaccesspointstoendusersandclients">为最终用户和客户端提供不同的访问点</h3><p>与其让最终用户和第三方客户端都使用相同的URI（例如“ http://myapp.com/service/calendars/{id}”），不如让他们引入两个URI，一个用于最终用户，另一个用于。第三方客户，例如“ http://myapp.com/service/calendars/{id}”（对于最终用户），“ http://myapp.com/partners/calendars/{id}”（对于第三位用户）客户端并部署2个jaxrs端点，其中一个由检查最终用户的安全过滤器保护，另一个由OAuth过滤器保护。</p><p>另外，管理第三方客户端的端点将部署资源，该资源将提供限制的URI空间支持。例如，如果应用程序仅允许第三方客户端读取日历，则该资源将仅具有支持@GET和“ / calendar / {id}”的方法。</p><h2 id="JAX-RSOAuth2-SingleSignOn">单点登录</h2><p>在处理对最终用户的身份验证时，使用SSO解决方案非常方便。这是因为最终用户与第三方及其资源服务器Web应用程序都进行了交互，并且还从客户端应用程序重定向到资源服务器，然后再次重定向。此外，如果最终用户未与应用程序端点并置，则最终用户可能需要通过授权服务进行身份验证。OpenID或说WebBrowser SSO配置文件可以提供帮助。</p><p>CXF 2.6.1为<a shape="rect" href="http://cxf.apache.org/docs/saml-web-sso.html">SAML2 SSO SP配置文件</a>提供了初始支持。这样可以更轻松地将单次登录的次数减少到最少，并与应用程序端点分开运行OAuth2授权服务器。</p><p>CXF 3.1.7报价<span class="confluence-link"> </span> <a shape="rect" href="jax-rs-oidc.html"><span class="confluence-link">OpenId Connect RP支持</span></a> 。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=27843869">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=27843869&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>