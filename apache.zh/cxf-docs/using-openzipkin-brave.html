<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Using OpenZipkin Brave">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-使用OpenZipkin Brave</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="distributed-tracing.html">分布式跟踪</a> > <a href="using-openzipkin-brave.html">使用OpenZipkin Brave</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1546718208744 {padding: 0px;}
div.rbtoc1546718208744 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1546718208744 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1546718208744">
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenZipkinBrave-Overview">总览</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-DistributedTracinginApacheCXFusingOpenZipkinBrave">使用OpenZipkin Brave在Apache CXF中进行分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-configuringclientConfiguringClient">配置客户端</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-configuringserverConfiguringServer">配置服务器</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-DistributedTracingInAction:UsageScenarios">实际中的分布式跟踪：使用方案</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenZipkinBrave-Example">示例1：配置了默认分布式跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Example">示例2：具有嵌套跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Example">示例＃3：带有注释的客户端和服务器跟踪</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Example">例4：具有二进制注释（键/值）的客户端和服务器</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Example">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Example">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Example">示例＃7：具有异步调用的客户端和服务器（客户端）</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenZipkinBrave-DistributedTracingwithOpenZipkinBraveandJAX-WSsupport">带有OpenZipkin Brave和JAX-WS支持的分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-DistributedTracingwithOpenZipkinBraveandOSGi">使用OpenZipkin Brave和OSGi进行分布式跟踪</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Migratingfrombrave-cxf3">从brave-cxf3迁移</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-SpringXML-Configuration">Spring XML配置</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-Usingnon-JAX-RSclients">使用非JAX-RS客户端</a></li><li><a shape="rect" href="#UsingOpenZipkinBrave-AccessingBraveAPIs">访问勇敢的API</a></li></ul>
</div><h1 id="UsingOpenZipkinBrave-Overview">总览</h1><p><a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>是与Java编写的<a shape="rect" class="external-link" href="http://zipkin.io/" rel="nofollow">Twitter Zipkin</a>后端服务兼容的分布式跟踪实现。相当长一段时间<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">以来，OpenZipkin Brave</a>提供了一个专用模块来与Apache CXF框架集成，即<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave/tree/master/brave-cxf3" rel="nofollow">brave-cxf3</a> 。但是，最近<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave/issues/313" rel="nofollow">开始</a>进行讨论以使该集成成为Apache CXF代码库的一部分，因此CXF团队将负责维护它。这样，它将在<strong>cxf-integration-tracing-brave</strong>模块下的<strong>3.2.0 / 3.1.12</strong>版本开始可用，同时支持客户端和服务器端。本节完整概述了如何将使用<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a> （ <strong>4.3.x +</strong> ）进行的分布式跟踪集成到基于Apache CXF的JAX-RS / JAX-WS应用程序中。</p><p><a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>受到<a shape="rect" class="external-link" href="http://zipkin.io/" rel="nofollow">Twitter Zipkin</a>和<a shape="rect" class="external-link" href="http://research.google.com/pubs/pub36356.html" rel="nofollow">Dapper（大型分布式系统跟踪基础结构</a>论文）的启发，是一个成熟的分布式跟踪框架。<a shape="rect" href="using-apache-htrace.html">专门</a>介绍<a shape="rect" href="using-apache-htrace.html">Apache HTrace</a>的部分<a shape="rect" href="using-apache-htrace.html">对</a>分布式跟踪基础进行了很好的介绍。但是， <a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>和<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>之间有一些关键区别。在《 <a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">勇敢传说》中，</a>每个<strong>跨度</strong>都与128或64位长的<strong>跟踪ID</strong>关联，该逻辑在逻辑上将与同一分布式工作单元有关的<strong>跨度</strong>分组。在过程<strong>跨度</strong>内，由<strong>报告</strong>者收集（可以是控制台，本地文件，数据存储等）。<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>为<a shape="rect" class="external-link" href="http://zipkin.io/" rel="nofollow">Twitter Zipkin</a>和<strong>java.util.logging</strong>记录器提供跨度报告器。</p><p>在后台， <strong>跨度</strong>连接到其线程（通常，创建<strong>跨度的</strong>线程应将其关闭），这与其他分布式跟踪实现所采用的技术相同。 <a shape="rect" href="http://cxf.apache.org/"> Apache CXF</a>集成使用<strong>HttpTracing</strong> （勇敢的HTTP工具的一部分）在客户端（提供程序和拦截器）上实例化跨度以划分发送/接收周期，而在服务器端（提供程序和拦截器）上划分跨度以定义接收/发送周期，同时使用常规在流程中实例化的任何范围的<strong>跟踪器</strong> 。</p><h1 id="UsingOpenZipkinBrave-DistributedTracinginApacheCXFusingOpenZipkinBrave">使用OpenZipkin Brave在Apache CXF中进行分布式跟踪</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF中</a>当前的分布式跟踪集成支持JAX-RS 2.x +和JAX-WS应用程序（包括部署在<a shape="rect" class="external-link" href="https://www.osgi.org/" rel="nofollow">OSGi</a>容器中的应用程序）中的<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a> （ <strong>4.3.x +</strong>版本分支）。从高级角度看，JAX-RS 2.x +集成包括三个主要部分：</p><ul><li><strong>TracerContext</strong> （可通过<strong>@Context</strong>注释<strong>注入</strong> ）</li><li><strong>BraveProvider</strong> （服务器端JAX-RS提供程序）和<strong>BraveClientProvider</strong> （客户端JAX-RS提供程序）</li><li><strong>BraveFeature</strong> （简化<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>配置和集成的服务器端JAX-RS功能）</li></ul><p>同样，从高级角度看，JAX-WS集成包括：</p><ul style="list-style-type:square"><li><strong>BraveStartInterceptor</strong> / <strong>BraveStopInterceptor</strong> / <strong>BraveFeature</strong> <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>功能（服务器端JAX-WS支持）</li><li><strong>BraveClientStartInterceptor</strong> / <strong>BraveClientStopInterceptor</strong> / <strong>BraveClientFeature</strong> <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>功能（客户端JAX-WS支持）</li></ul><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>使用HTTP标头将跟踪上下文从客户端传递到服务，并从服务传递到服务。这些标题由<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>在内部使用，目前无法配置。标头名称在<strong>B3Propagation</strong>类中声明，目前包括：</p><ul style="list-style-type:square"><li><strong>X-B3-TraceId</strong> ：128或64位跟踪ID</li><li><strong>X-B3-SpanId</strong> ：64位跨度ID</li><li><strong>X-B3-ParentSpanId</strong> ：64位父范围ID</li><li><p><strong>X-B3-Sampled</strong> ：“ 1”表示将此范围报告给跟踪系统，“ 0”表示不报告</p></li><li><strong>X-B3-Flags</strong> ：“ 1”表示已采样，并且是覆盖集合层采样策略的请求</li></ul><p>默认情况下， <strong>BraveClientProvider</strong>会尝试在每次服务调用时通过HTTP标头传递当前活动的<strong>跨度</strong> 。如果没有活动范围，则将基于每次调用创建新范围并通过HTTP标头传递。实质上，JAX-RS应用只是在客户端和<strong>BraveProvider</strong>服务器上注册<strong>BraveClientProvider</strong>足有跟踪角度来正确地传递无处不在。唯一必要的配置部分是<strong>跨度报告</strong>和<strong>采样器</strong> 。</p><p>还值得一提的是<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>将描述附加到<strong>spans的方式</strong> 。关于客户端集成，该描述将成为由HTTP方法作为前缀调用的完整URL，例如： <strong>GET</strong> <a shape="rect" class="external-link" href="http://localhost:8282/books" rel="nofollow"><strong>http：// localhost：8282</strong> / books</a> 。在服务器端集成上，描述成为以HTTP方法为前缀的相对JAX-RS资源路径，例如： <strong>GET书籍，POST书籍/ 123</strong></p><h1 id="UsingOpenZipkinBrave-configuringclientConfiguringClient"><span class="confluence-anchor-link" id="UsingOpenZipkinBrave-configuringclient"></span>配置客户端</h1><p>根据客户端的实现，可以通过多种方式配置JAX-RS客户端。<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>提供了自己的<strong>WebClient</strong> ，可以像这样配置（在将来的版本中，将使用客户端特定的功能来实现此目的的更简单方法）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Configure the spans transport sender
final Sender sender = ...; 

/**
 * For example:
 *
&#160;* final Sender sender = LibthriftSender.create("localhost");; 
 */
        
final Tracing brave = Tracing
    .newBuilder()
    .localServiceName("web-client")
    .reporter(AsyncReporter.builder(sender).build())
    .traceSampler(Sampler.ALWAYS_SAMPLE) /* or any other Sampler */
   &#160;.build();
        
Response response = WebClient
    .create("http://localhost:9000/catalog", Arrays.asList(new BraveClientProvider(brave)))
    .accept(MediaType.APPLICATION_JSON)
    .get();

</pre>
</div></div><p>基于使用标准JAX-RS <strong>客户端</strong>的配置非常相似：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Configure the spans transport sender
final Sender sender = ...; 

/**
 * For example:
 *
&#160;* final Sender sender = LibthriftSender.create("localhost");; 
 */
        
final Tracing brave = Tracing
    .newBuilder()
    .localServiceName("jaxrs-client")
    .reporter(AsyncReporter.builder(sender).build())
    .traceSampler(Sampler.ALWAYS_SAMPLE) /* or any other Sampler */
   &#160;.build();
                
final BraveClientProvider provider = new BraveClientProvider(brave);
final Client client = ClientBuilder.newClient().register(provider);

final Response response = client
    .target("http://localhost:9000/catalog")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><h1 id="UsingOpenZipkinBrave-configuringserverConfiguringServer"><span class="confluence-anchor-link" id="UsingOpenZipkinBrave-configuringserver"></span>配置服务器</h1><p><strong>借助</strong>可用的功能类<strong>BraveFeature</strong> ，服务器配置比客户端配置简单一些。根据<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>用于配置JAX-RS服务的方式，它可能是JAX-RS应用程序配置的一部分，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath("/")
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        // Configure the spans transport sender
        final Sender sender = ...; 

        /**
         * For example:
         *
         * final Sender sender = LibthriftSender.create("localhost");; 
         */
        
        final Tracing brave = Tracing
            .newBuilder()
            .localServiceName("tracer")
            .reporter(AsyncReporter.builder(sender).build())
            .traceSampler(Sampler.ALWAYS_SAMPLE) /* or any other Sampler */ 
            .build();
            
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    new BraveFeature(brave)
                )
            );
    }
}</pre>
</div></div><p>或者也可以使用<strong>JAXRSServerFactoryBean</strong>对其进行配置，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Configure the spans transport sender
final Sender sender = ...; 

/**
 * For example:
 *
 * final Sender sender = LibthriftSender.create("localhost");; 
 */
        
final Tracing brave = Tracing
    .newBuilder()
    .localServiceName("tracer")
    .reporter(AsyncReporter.builder(sender).build())
    .traceSampler(Sampler.ALWAYS_SAMPLE) /* or any other Sampler */ 
    .build();

final JAXRSServerFactoryBean factory = RuntimeDelegate.getInstance().createEndpoint(/* application instance */, JAXRSServerFactoryBean.class);
factory.setProvider(new BraveFeature(brave));
...
return factory.create();

</pre>
</div></div><p>一旦正确配置了<strong>跨度报告</strong> <strong>器</strong>和<strong>采样器</strong> ，将收集所有生成的<strong>跨度</strong>并将其用于分析和/或可视化。</p><h1 id="UsingOpenZipkinBrave-DistributedTracingInAction:UsageScenarios">实际中的分布式跟踪：使用方案</h1><p>在以下小节中，我们将通过许多不同的场景来说明实际中的分布式跟踪，从最简单的场景开始，以异步JAX-RS服务结束。所有示例均假设<strong>已完成</strong> <a shape="rect" href="using-openzipkin-brave.html"><span class="confluence-link"><span class="confluence-link">配置</span></span></a> （请参阅<a shape="rect" href="using-openzipkin-brave.html"><span class="confluence-link"><span class="confluence-link">配置客户端</span></span></a> <span class="confluence-link"> </span>和上面的<a shape="rect" href="using-openzipkin-brave.html"><span class="confluence-link">配置服务器</span></a>部分）。</p><h2 id="UsingOpenZipkinBrave-Example#1:ClientandServerwithdefaultdistributedtracingconfigured">示例1：配置了默认分布式跟踪的客户端和服务器</h2><p>在第一个示例中，我们将看到仅在<strong>BraveClientProvider</strong>和<strong><strong>Brave</strong> Provider</strong>注册的情况下在客户端和服务器上使用默认配置的效果。JAX-RS资源端点是非常基本的存根方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>客户端就是这么简单：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Response response = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>客户端（使用服务名称<strong>tracer-client</strong> ）对请求的实际调用以及服务器端（服务名称<strong>tracer-server</strong> ）的服务随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="150" src="using-openzipkin-brave.data/image2017-2-6 20:16:19.png"></span></p><p> </p><p>请注意，在客户端发送/接收和服务器发送/接收分界的情况下，客户端和服务器跟踪折叠在一条跟踪下，详细信息请参见<span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="using-openzipkin-brave.data/image2017-2-6 20:18:51.png"></span></p><h2 id="UsingOpenZipkinBrave-Example#2:ClientandServerwithnestedtrace">示例2：具有嵌套跟踪的客户端和服务器</h2><p>在此示例中，JAX-RS服务的服务器端实现将在其自己的跨度内调用外部系统（模拟为500ms的简单延迟）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    try(final TraceScope scope = tracer.startSpan("Calling External System")) {
        // Simulating a delay of 500ms required to call external system
        Thread.sleep(500);
           
        return Arrays.asList(
            new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
        );
    }
}</pre>
</div></div><p class="label label-default service-filter-label">由客户端的请求（具有服务名称<strong><span class="label label-default service-filter-label service-tag-filtered"><strong>示踪剂</strong> -client）</span></strong>和在服务器端的服务（服务名称<strong><span class="label label-default service-filter-label"><strong>的示踪物-</strong>服务器</span></strong> <span class="label label-default service-filter-label">）</span>的随后调用的调用实际将要产生下面的示例迹线：</p><p class="label label-default service-filter-label"><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="using-openzipkin-brave.data/image2017-2-6 20:21:46.png"></span></p><h2 id="UsingOpenZipkinBrave-Example#3:ClientandServertracewithannotations">示例＃3：带有注释的客户端和服务器跟踪</h2><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加时间线。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    tracer.timeline("Preparing Books");
    // Simulating some work using a delay of 100ms
    Thread.sleep(100);
        
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p class="label label-default service-filter-label">客户端（使用服务名称<strong><span class="label label-default service-filter-label service-tag-filtered">tracer-client</span></strong> ）对请求的实际调用以及服务器端（服务名称<strong><span class="label label-default service-filter-label">traceser-server</span></strong> ）的服务随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="using-openzipkin-brave.data/image2017-2-6-20:56:27.png"></span></p><h2 id="UsingOpenZipkinBrave-Example#4:ClientandServerwithbinaryannotations(key/value)">例4：具有二进制注释（键/值）的客户端和服务器</h2><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加键/值注释。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Collection&lt;Book&gt; books = Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
        
    tracer.annotate("# of books", Integer.toString(books.size()));
    return books;
}</pre>
</div></div><p class="label label-default service-filter-label service-tag-filtered">由客户端的请求（具有服务名称<strong><span class="label label-default service-filter-label service-tag-filtered"><strong><span class="label label-default service-filter-label service-tag-filtered"><strong>示踪剂</strong></span></strong> -client）</span></strong>和在服务器端的服务的结果调用（服务名<strong>的示踪物- <span class="label label-default service-filter-label">服务器</span></strong> ）的实际调用将要产生下面的示例服务器跟踪属性：</p><p class="label label-default service-filter-label service-tag-filtered"><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-openzipkin-brave.data/image2017-2-6 20:49:43.png"></span></p><h2 id="UsingOpenZipkinBrave-Example#5:ClientandServerwithparalleltrace(involvingthreadpools)">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</h2><p>在此示例中，JAX-RS服务的服务器端实现将把一些工作卸载到线程池中，然后将响应返回给客户端，以模拟并行执行。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Future&lt;Book&gt; book1 = executor.submit(
        tracer.wrap("Getting Book 1", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(100);
                    
                return new Book("Apache CXF Web Service Development", 
                    "Naveen Balani, Rajeev Hathi");
            }
        })
    );
        
    final Future&lt;Book&gt; book2 = executor.submit(
        tracer.wrap("Getting Book 2", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(200);
                    
                return new Book("Developing Web Services with Apache CXF and Axis2", 
                    "Kent Ka Iok Tong");
            }
        })
    );
       
    return Arrays.asList(book1.get(), book2.get());
}</pre>
</div></div><p>客户端（使用服务名称<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端（流程名称<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的服务随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="using-openzipkin-brave.data/image2017-2-6-21:41:1.png"></span></p><h2 id="UsingOpenZipkinBrave-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side)">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</h2><p>在此示例中，JAX-RS服务的服务器端实现将异步执行。由于在不同线程（通常）中处理请求和响应，因此从跟踪预期对象构成了挑战。目前， <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>不支持透明的跟踪范围管理（默认用例除外），但是提供了实现此目的的简单方法（允许跨线程转移范围）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public void getBooks(@Suspended final AsyncResponse response, @Context final TracerContext tracer) throws Exception {
    tracer.continueSpan(new Traceable&lt;Future&lt;Void&gt;&gt;() {
        public Future&lt;Void&gt; call(final TracerContext context) throws Exception {
            return executor.submit(
                tracer.wrap("Getting Book", new Traceable&lt;Void&gt;() {
                    public Void call(final TracerContext context) throws Exception {
                        // Simulating a processing delay of 50ms
                        Thread.sleep(50);
                            
                        response.resume(
                            Arrays.asList(
                                new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
                            )
                        );
                            
                        return null;
                    }
                })
            );
        }
    });
}</pre>
</div></div><p class="label label-default service-filter-label service-tag-filtered">客户端（使用服务名<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端（服务名<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的服务的后续调用将生成以下示例跟踪：</p><p class="label label-default service-filter-label service-tag-filtered"><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="using-openzipkin-brave.data/image2017-2-6-21:46:48.png"></span></p><h2 id="UsingOpenZipkinBrave-Example#7:ClientandServerwithasynchronousinvocation(client-side)">示例＃7：具有异步调用的客户端和服务器（客户端）</h2><p>在此示例中，JAX-RS服务的服务器端实现将是默认的：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>当JAX-RS客户端实现将执行异步调用时：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Future&lt;Response&gt; future = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .async()
    .get();</pre>
</div></div><p>在这方面，与调用方预期对象没有什么区别，但是要进行更多的工作以将活动跟踪范围从JAX-RS客户端请求过滤器转移到客户端响应过滤器，因为通常在不同线程中执行（类似服务器端异步JAX-RS资源调用）。客户端（使用服务名<strong>tracer- <span class="label label-default service-filter-label service-tag-filtered">client</span></strong> ）对请求的实际调用以及服务器端（服务名<strong>tracer- <span class="label label-default service-filter-label">server</span></strong> ）的服务的后续调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="900" src="using-openzipkin-brave.data/image2017-2-6-21:6:56.png"></span></p><h1 id="UsingOpenZipkinBrave-DistributedTracingwithOpenZipkinBraveandJAX-WSsupport">带有OpenZipkin Brave和JAX-WS支持的分布式跟踪</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>中的分布式跟踪主要围绕JAX-RS 2.x实现而构建。但是，还支持JAX-WS，但它需要编写一些样板代码并直接使用<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a> API（将来将增强JAX-WS集成）。本质上，应该从服务器端预期的<strong>In</strong> / out拦截器，分别将<strong>BraveStartInterceptor</strong>和<strong>BraveStopInterceptor</strong>配置为拦截器链的一部分，可以手动或使用<strong>BraveFeature</strong>进行<strong>配置</strong> 。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Configure the spans transport sender
final Sender sender = ...; 

/**
 * For example:
 *
 * final Sender sender = LibthriftSender.create("localhost");; 
 */
        
final Tracing brave = Tracing
    .newBuilder()
    .localServiceName("tracer")
    .reporter(AsyncReporter.builder(sender).build())
    .traceSampler(Sampler.ALWAYS_SAMPLE) /* or any other Sampler */ 
    .build();
             
final JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();
...
sf.getFeatures().add(new BraveFeature(brave));
...
sf.create();

</pre>
</div></div><p>与服务器端类似，客户端需要自己的一组out / in拦截器<strong>BraveClientStartInterceptor</strong>和<strong>BraveClientStopInterceptor</strong> （或<strong>BraveClientFeature</strong> ）。请注意与服务器端的区别： <strong>BraveClientStartInterceptor</strong>变为外拦截器，而<strong>BraveClientStopInterceptor</strong>变为内拦截器。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Configure the spans transport sender
final Sender sender = ...; 

/**
 * For example:
 *
 * final Sender sender = LibthriftSender.create("localhost");; 
 */
        
final Tracing brave = Tracing
    .newBuilder()
    .localServiceName("tracer")
    .reporter(AsyncReporter.builder(sender).build())
    .traceSampler(Sampler.ALWAYS_SAMPLE) /* or any other Sampler */ 
    .build();
             
final JaxWsProxyFactoryBean sf = new JaxWsProxyFactoryBean();
...
sf.getFeatures().add(new BraveClientFeature(brave));
...
sf.create();

</pre>
</div></div><h1 id="UsingOpenZipkinBrave-DistributedTracingwithOpenZipkinBraveandOSGi">使用OpenZipkin Brave和OSGi进行分布式跟踪</h1><p><a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>可以部署到<strong>OSGi</strong>容器中，因此，分布式跟踪集成完全可用于容器中运行的<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>服务。有关完整示例，请查看<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/180d0fcc5e0d061f339e1a3cb32ec53a3ab32b97/distribution/src/main/release/samples/jaxws_tracing_brave_osgi/README.txt" rel="nofollow">jax_ws_tracing_brave_osgi</a>示例项目，但这是典型的<strong>OSGi</strong>蓝图片段：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://cxf.apache.org/blueprint/core"
       xmlns:jaxws="http://cxf.apache.org/blueprint/jaxws"

       xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
                           http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd
                           http://cxf.apache.org/blueprint/jaxws http://cxf.apache.org/schemas/blueprint/jaxws.xsd"&gt;

    &lt;!-- CXF BraveFeature --&gt;
    &lt;bean id="braveFeature" class="org.apache.cxf.tracing.brave.BraveFeature"&gt;
        &lt;argument index="0" ref="brave" /&gt;
    &lt;/bean&gt;
    
    &lt;cxf:bus&gt;
        &lt;cxf:features&gt;
            &lt;cxf:logging /&gt;
        &lt;/cxf:features&gt;
    &lt;/cxf:bus&gt;
    
    &lt;bean id="catalogServiceImpl" class="demo.jaxws.tracing.server.impl.CatalogServiceImpl"&gt;
        &lt;argument index="0" ref="brave" /&gt;
    &lt;/bean&gt;
    
    &lt;bean id="braveBuilder" class="brave.Tracing" factory-method="newBuilder" /&gt;
   
    &lt;bean id="braveCatalogBuilder" factory-ref="braveBuilder" factory-method="localServiceName"&gt;
        &lt;argument index="0" value="catalog-service" /&gt;
    &lt;/bean&gt;
    
    &lt;bean id="brave" factory-ref="braveCatalogBuilder" factory-method="build" /&gt;

   &#160;&lt;jaxws:endpoint
        implementor="#catalogServiceImpl"
        address="/catalog"
        implementorClass="demo.jaxws.tracing.server.impl.CatalogServiceImpl"&gt;
        &lt;jaxws:features&gt;
            &lt;ref component-id="braveFeature" /&gt;
        &lt;/jaxws:features&gt;
    &lt;/jaxws:endpoint&gt;
&lt;/blueprint&gt;</pre>
</div></div><h1 id="UsingOpenZipkinBrave-Migratingfrombrave-cxf3">从brave-cxf3迁移</h1><p>从<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave/tree/master/brave-cxf3" rel="nofollow">OpenZipkin Brave / CXF</a>到<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>集成的迁移路径非常简单，实质上可以归结为使用JAX-RS（服务器端为<strong>BraveFeature</strong> /客户端为<strong>BraveClientFeature</strong> （从<strong>org.apache.cxf.tracing.brave.jaxrs</strong>包中导入） ， 例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JAXRSServerFactoryBean serverFactory = new JAXRSServerFactoryBean();
serverFactory.setServiceBeans(new RestFooService());
serverFactory.setAddress("http://localhost:9001/");
serverFactory.getFeatures().add(new BraveFeature(brave));
serverFactory.create();</pre>
</div></div><p>尽管您可以继续直接使用<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a> API，但是对于服务器端，最好将<strong>@Context TracerContext</strong>注入到JAX-RS服务中，以便与跟踪器进行交互。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JAXRSClientFactoryBean clientFactory = new JAXRSClientFactoryBean();
clientFactory.setAddress("http://localhost:9001/");
clientFactory.setServiceClass(FooService.class);
clientFactory.getFeatures().add(new BraveClientFeature(brave));
FooService client = (FooService) clientFactory.create()</pre>
</div></div><p> </p><p>同样，对于服务器端的JAX-WS <strong>BraveFeature</strong> /客户端的<strong>BraveClientFeature</strong> （从<strong>org.apache.cxf.tracing.brave</strong>包导入），例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JaxWsServerFactoryBean serverFactory = new JaxWsServerFactoryBean();
serverFactory.setAddress("http://localhost:9000/test");
serverFactory.setServiceClass(FooService.class);
serverFactory.setServiceBean(fooServiceImplementation);
serverFactory.getFeatures().add(new BraveFeature(brave));

serverFactory.create();</pre>
</div></div><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JAXRSClientFactoryBean clientFactory = new JAXRSClientFactoryBean();
clientFactory.setAddress("http://localhost:9001/");
clientFactory.setServiceClass(FooService.class);
clientFactory.getFeatures().add(new BraveClientFeature(brave));
FooService client = (FooService) clientFactory.create();</pre>
</div></div><h1 id="UsingOpenZipkinBrave-SpringXML-Configuration">Spring XML配置</h1><p>如果您的项目使用经典的Spring XML-Configuration，则应考虑使用<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave/tree/master/spring-beans" rel="nofollow">brave-spring-beans</a> 。工厂bean允许创建如下配置：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;bean id="braveFeature" class="org.apache.cxf.tracing.brave.BraveFeature"&gt;&lt;!-- JAX-WS server feature --&gt;
   &lt;constructor-arg ref="httpTracing" /&gt;
&lt;/bean&gt;

&lt;bean id="httpTracing" class="brave.spring.beans.HttpTracingFactoryBean"&gt;
   &lt;property name="tracing"&gt;
      &lt;bean class="brave.spring.beans.TracingFactoryBean"&gt;
         &lt;property name="localServiceName" value="myService"/&gt;
         &lt;property name="reporter"&gt;
            &lt;bean class="brave.spring.beans.AsyncReporterFactoryBean"&gt;
               &lt;property name="sender"&gt;
                  &lt;bean class="zipkin.reporter.urlconnection.URLConnectionSender" factory-method="create"&gt;
                     &lt;constructor-arg value="http://localhost:9411/api/v1/spans"/&gt;
                  &lt;/bean&gt;
               &lt;/property&gt;
            &lt;/bean&gt;
         &lt;/property&gt;
         &lt;property name="currentTraceContext"&gt;
            &lt;bean class="brave.context.slf4j.MDCCurrentTraceContext" factory-method="create"/&gt;
         &lt;/property&gt;
      &lt;/bean&gt;
   &lt;/property&gt;
   &lt;property name="clientParser"&gt;
      &lt;bean class="org.apache.cxf.tracing.brave.HttpClientSpanParser" /&gt;
   &lt;/property&gt;
   &lt;property name="serverParser"&gt;
      &lt;bean class="org.apache.cxf.tracing.brave.HttpServerSpanParser" /&gt;
   &lt;/property&gt;
&lt;/bean&gt;</pre>
</div></div><h1 id="UsingOpenZipkinBrave-Usingnon-JAX-RSclients">使用非JAX-RS客户端</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>使用本机<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>功能，因此用于不同HTTP客户端的现有工具可以按预期工作。不需要仅使用JAX-RS客户端。例如，以下代码片段演示了如何使用Traceble <a shape="rect" class="external-link" href="http://square.github.io/okhttp/" rel="nofollow">OkHttp</a>客户端调用由<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>支持的JAX-RS资源。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracing brave = Tracing
    .newBuilder()
    .localServiceName("web-client")
    .reporter(AsyncReporter.builder(sender).build())
    .traceSampler(Sampler.ALWAYS_SAMPLE) /* or any other Sampler */
    .build();

final OkHttpClient client = new OkHttpClient();
final Call.Factory factory = TracingCallFactory.create(brave, client);
            
final Request request = new Request.Builder()
    .url("http://localhost:9000/catalog")
    .header("Accept", "application/json")
    .build();

try (final Response response = factory.newCall(request).execute()) {
    // Do something with response.body()
}</pre>
</div></div><h1 id="UsingOpenZipkinBrave-AccessingBraveAPIs">访问勇敢的API</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>尽可能在<strong>TracerContext</strong>之后抽象出许多特定于跟踪器的API。但是，有时需要访问<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a> API，以利用丰富的可用工具集。为了使得有可能<strong>，TracerContext</strong>有一个专用<strong>的unwrap</strong>方法，该方法返回底层<strong>HttpTracing，</strong> <strong>示踪</strong>或<strong>跟踪</strong>实例。下面的代码片段展示了如何使用此API以及如何对<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave/tree/master/instrumentation/httpclient" rel="nofollow">Apache HttpClient</a>使用<a shape="rect" class="external-link" href="https://github.com/openzipkin/brave" rel="nofollow">OpenZipkin Brave</a>工具。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/search")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject search(@QueryParam("q") final String query, @Context final TracerContext tracing) throws Exception {
    final CloseableHttpClient httpclient = TracingHttpClientBuilder
        .create(tracing.unwrap(HttpTracing.class))
        .build();
    
    try {
        final URI uri = new URIBuilder("https://www.googleapis.com/books/v1/volumes")
            .setParameter("q", query)
            .build();
            
        final HttpGet request = new HttpGet(uri);
        request.setHeader("Accept", "application/json");
            
        final HttpResponse response = httpclient.execute(request);
        final String data = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
        try (final StringReader reader = new StringReader(data)) {
            return Json.createReader(reader).readObject();
        }
    } finally {
        httpclient.close();
    }
}</pre>
</div></div><p>通常不建议使用特定于跟踪器的API（由于可移植性原因），但是如果没有其他可用选项，则可以使用。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=67640243">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=67640243&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>