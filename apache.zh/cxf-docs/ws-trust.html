<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - WS-Trust">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-WS-信任</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="ws-support.html">WS- *支持</a> > <a href="ws-trust.html">WS-Trust</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="WS-Trust-WS-Trust">WS-信任</h1><p>CXF中的WS-Trust支持建立在<a shape="rect" href="ws-securitypolicy.html">WS-SecurityPolicy</a>实现的基础上，以处理在WS-SecurityPolicy片段中可以找到的IssuedToken策略断言。</p><p><strong>注意：</strong>由于WS-IssuedToken支持是基于WS-SecurityPolicy支持的，因此当前仅可用于“ wsdl first”项目。</p><p>WS-Trust扩展了WS-Security规范，以允许发布，更新和验证安全性令牌。WS-Trust所做的很多工作都围绕“安全令牌服务”（STS）的使用。与STS联系以获得安全令牌，这些令牌用于创建与服务进行对话的消息。STS的主要用途是获取用于与服务对话的SAML令牌。为什么这很有趣？</p><p>当使用“直接” WS-Security时，客户端和服务器需要预先交换密钥。如果客户端和服务器都在同一个安全域中，通常不会出现问题，但是对于跨多个域的大型，复杂的应用程序而言，这可能是一个负担。同样，如果多个服务需要相同的安全凭据，则可以通过主要操作在这些凭据更改时更新所有服务。</p><p>WS-Trust通过使用从受信任的安全令牌服务获得的安全令牌来解决此问题。客户端根据STS定义的策略和要求向STS进行身份验证。然后，STS提供一个安全令牌（例如：SAML令牌），客户端随后将使用该安全令牌与目标服务进行对话。该服务可以验证该令牌以确保它确实来自受信任的STS。</p><p>当CXF中的WS-SecurityPolicy运行时在策略中遇到IssuedToken断言时，运行时需要org.apache.cxf.ws.security.trust的实例。STSClient与STS对话以获得所需的令牌。由于STSClient是WS-SecurityPolicy客户端，因此它将需要配置项才能创建其安全SOAP消息以与STS对话。</p><h2 id="WS-Trust-GeneralConfiguration">常规配置</h2><p>有几种方法可以配置STSClient：</p><p><strong>在属性中直接配置STSClient Bean：</strong><br clear="none">在这种情况下，将STSClient对象直接创建为客户端对象的属性。wsdlLocation，服务/端点名称等都已为该客户端在线配置。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;jaxws:client name="{http://cxf.apache.org/}MyService" createdFromAPI="true"&gt;
    &lt;jaxws:properties&gt;
        &lt;entry key="ws-security.sts.client"&gt;
            &lt;!-- direct STSClient config and creation --&gt;
            &lt;bean class="org.apache.cxf.ws.security.trust.STSClient"&gt;
                &lt;constructor-arg ref="cxf"/&gt;
                &lt;property name="wsdlLocation" 
                   value="target/wsdl/trust.wsdl"/&gt;
                &lt;property name="serviceName" 
                   value="{http://cxf.apache.org/securitytokenservice}SecurityTokenService"/&gt;
                &lt;property name="endpointName" 
                   value="{http://cxf.apache.org/securitytokenservice}SecurityTokenEndpoint"/&gt;
                &lt;property name="properties"&gt;
                    &lt;map&gt;
                       &lt;entry key="ws-security.username" value="alice"/&gt;
                       &lt;entry key="ws-security.callback-handler" 
                          value="client.MyCallbackHandler"/&gt;
                       &lt;entry key="ws-security.signature.properties" 
                          value="clientKeystore.properties"/&gt;
                       &lt;entry key="ws-security.encryption.properties" 
                          value="clientKeystore.properties"/&gt;
                       &lt;entry key="ws-security.encryption.username" 
                          value="mystskey"/&gt; 
                    &lt;/map&gt;
                &lt;/property&gt;
            &lt;/bean&gt;            
        &lt;/entry&gt; 
    &lt;/jaxws:properties&gt;
&lt;/jaxws:client&gt;
</pre>
</div></div><p>上面的示例显示了一种配置，其中STS使用UsernameToken配置文件来验证客户端。假定在clientKeystore.properties中标识的密钥库既包含客户端的私钥，又包含STS的公钥（在上面标识为mystskey）。如果不是，请为签名属性和加密属性创建单独的属性文件，分别指向密钥库和信任库。</p><p>请记住，如果通过CXF API（即Endpoint.publish（）或Service.getPort（））以编程方式创建了客户端，则需要将jaxws：client createdFromAPI属性设置为true（如上所示）。</p><p>您也可以这样做，适用于“代码优先”的情况：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">STSClient sts = new STSClient(...);
sts.setXXXX(....)
.....
((BindingProvider)port).getRequestContext().put("ws-security.sts.client", sts);
</pre>
</div></div><p>示例样例clientKeystore.properties格式：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=KeystorePasswordHere
org.apache.ws.security.crypto.merlin.keystore.alias=ClientKeyAlias
org.apache.ws.security.crypto.merlin.keystore.file=NameOfKeystore.jks 
</pre>
</div></div><p><strong>基于端点名称的间接配置：</strong><br clear="none">如果运行时找不到直接在客户端上配置的STSClient Bean，则它将检查STSClient Bean的配置，该端点的名称附加“ .sts-client”。例如，如果您的客户端的端点名称是“ { <a shape="rect" href="http://cxf.apache.org/">http://cxf.apache.org/</a> } TestEndpoint”，则可以将其配置为：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean name="{http://cxf.apache.org/}TestEndpoint.sts-client" 
    class="org.apache.cxf.ws.security.trust.STSClient" abstract="true"&gt;
    &lt;property name="wsdlLocation" value="WSDL/wsdl/trust.wsdl"/&gt;
    &lt;property name="serviceName" 
        value="{http://cxf.apache.org/securitytokenservice}SecurityTokenService"/&gt;
    &lt;property name="endpointName" 
        value="{http://cxf.apache.org/securitytokenservice}SecurityTokenEndpoint"/&gt;
    &lt;property name="properties"&gt;
        &lt;map&gt;
            &lt;entry key="ws-security.signature.properties" 
                value="etc/alice.properties"/&gt; 
            &lt;entry key="ws-security.encryption.properties" 
                value="etc/bob.properties"/&gt;	
            &lt;entry key="ws-security.encryption.username" value="stskeyname"/&gt;	
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</pre>
</div></div><p>在此示例中配置的此属性演示了使用X.509令牌配置文件对客户端进行STS验证。Bean的abstract =“ true”设置推迟了STSClient对象的创建，直到实际需要它为止。发生这种情况时，CXF运行时将使用为此bean配置的值实例化一个新的STSClient。</p><p><strong>默认配置：</strong><br clear="none">如果从上述方法中未找到STSClient，则它将尝试查找类似于间接配置但名称为“ default.sts-client”的STSClient。这可用于为多个服务配置sts客户端。</p><h2 id="WS-Trust-WS-Trust1.4Support">WS-Trust 1.4支持</h2><p>CXF支持WS-Trust 1.4规范中定义的一些新功能。下面列出了当前支持的功能。</p><h3 id="WS-Trust-ActAs">充当</h3><p>ActAs功能允许启动程序请求安全令牌，使其可以像其他人一样操作。此功能在复合服务中很重要，在复合服务中，中间服务代表真正的发起者发出附加请求。在这种情况下，依赖方（间接服务请求的最终目的地）可能需要有关请求真实来源的信息。 ActAs功能允许中介机构请求可以传达此信息的令牌。</p><p>可以通过以下两种方式之一设置要在STS RequestSecurityToken调用中发送的ActAs元素的内容：</p><ol><li>通过为JAX-WS属性SecurityConstants指定一个值。STS_TOKEN_ACT_AS（“ ws-security.sts.token.act-as”）</li><li>通过为STSClient.actAs属性指定一个值。</li></ol><p>无论哪种情况，该值都可以是以下值之一：</p><ul><li>一个弦</li><li>DOM元素</li><li>用于获取令牌的CallbackHandler对象</li></ul><p>例如，以下代码片段演示了如何通过指定SecurityConstants的值，使用拦截器在STS RST中动态设置ActAs元素的内容。STS_TOKEN_ACT_AS。请注意，此拦截器将应用于受保护的客户端，启动器，而不应用于STSClient的拦截器链。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public class ActAsOutInterceptor extends AbstractPhaseInterceptor&lt;Message&gt; {
   
    ActAsOutInterceptor () {
        // This can be in any stage before the WS-SP interceptors
        // setup the STS client and issued token interceptor.
        super(Phase.SETUP);
    }

    @Override
    public void handleMessage(Message message) throws Fault {
        message.put(SecurityConstants.STS_TOKEN_ACT_AS, ...);
    }
}
</pre>
</div></div><p>或者，可以如下所示直接在STS上设置ActAs内容。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean name="{http://cxf.apache.org/}TestEndpoint.sts-client" 
    class="org.apache.cxf.ws.security.trust.STSClient" abstract="true"&gt;
    &lt;property name="wsdlLocation" value="WSDL/wsdl/trust.wsdl"/&gt;
    &lt;property name="serviceName" 
        value="{http://cxf.apache.org/securitytokenservice}SecurityTokenService"/&gt;
    &lt;property name="endpointName" 
        value="{http://cxf.apache.org/securitytokenservice}SecurityTokenEndpoint"/&gt;
    &lt;property name="actAs" value="..."/&gt;
    &lt;property name="properties"&gt;
        &lt;map&gt;
            ...	
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</pre>
</div></div><h3 id="WS-Trust-OnBehalfOf">代表</h3><p>OnBehalfOf功能允许启动程序代表其他人请求安全令牌。可以通过以下两种方式之一设置要在STS RequestSecurityToken调用中发送的OnBehalfOf元素的内容：</p><ol><li>通过为JAX-WS属性SecurityConstants指定一个值。STS_TOKEN_ON_BEHALF_OF（“代表ws-security.sts.token.on”）</li><li>通过为STSClient.onBehalfOf属性指定一个值。</li></ol><p>无论哪种情况，该值都可以是以下值之一：</p><ul><li>一个弦</li><li>DOM元素</li><li>用于获取令牌的CallbackHandler对象</li></ul><h2 id="WS-Trust-WS-TrustusingSPNego">使用SPNego的WS-Trust</h2><p>从CXF 2.4.7和2.5.3开始，CXF包含（客户端）使用SPNego对WS-Trust的支持。请参阅以下<a shape="rect" class="external-link" href="http://coheigea.blogspot.com/2012/02/ws-trust-spnego-support-in-apache-cxf.html" rel="nofollow">博客</a> ，以了解这需要什么以及如何在CXF中为此功能运行一些系统测试。</p><h2 id="WS-Trust-WS-TrustusingXKMS">使用XKMS的WS-Trust</h2><p>从CXF 2.7.7开始，可以将安全令牌服务（STS）配置为使用<a shape="rect" href="xml-key-management-service-xkms.html">XKMS</a>加密提供程序。在这种情况下，可以将X509证书集中放置并使用标准XKMS接口进行管理。STS将自动调用XKMS客户端以查找或验证相应的X509证书。有关详细信息和示例，请参见以下<a shape="rect" class="external-link" href="http://ashakirin.blogspot.de/2013/07/cxf-security-integrate-pki-to-security.html" rel="nofollow">博客</a> 。</p><p>对于使用SymmetricKey的STS方案，此功能特别有用。在这种情况下，STS和WS使用者协商一个对称密钥：</p><ol><li>WS-Client向STS进行身份验证，并为创建对称密钥做出贡献。</li><li>STS验证WS-Client身份验证并使用从WS-Client接收的材料生成对称密钥</li><li>STS使用WS-Service公共密钥对对称密钥进行加密，并将加密的密钥与安全性令牌一起插入SAML声明中</li><li>STS签名SAML断言，并将其与用于生成对称密钥的密钥材料一起发送给WS-Client。</li><li>WS-Client从自己的材料和STS的密钥材料生成短暂的对称密钥。</li><li>WS-Client将SAML令牌插入消息头中。它加密消息文本或/和使用生成的对称密钥对消息签名。然后，它将用户的消息发送到WS-Service。</li><li>WS-Service检查SAML令牌中的签名，并使用其私钥解密SAML令牌中包含的对称密钥。</li><li>WS-Service使用解密的对称密钥验证WS-Client（密钥持有者）的签名。通过这种方式，STS确认密钥持有者是断言中的主题（用户）。</li><li>WS-Service使用对称密钥来解密消息文本。</li></ol><p>在步骤（3）上，STS需要目标WS-Service的公钥（证书）。通常，STS服务器不仅提供一种服务，而且还提供多种服务（受TokenServiceProvider中的url模式限制）。将所有服务的公共证书管理到STS本地密钥库中可能是一个严重的缺点。</p><p>XKMS Crypto provider使用以下配置为此提供了优雅的解决方案：</p><ul><li>EncryptionUsername（在StaticSTSProperties或jaxws：endpoint属性中）应设置为特殊值： <em>useEndpointAsCertAlias</em> （STSConstants。USE_ENDPOINT_AS_CERT_ALIAS）</li><li>EncryptionCrypto应该设置为XKMS Crypto实现</li><li>服务证书应保存在服务端点下的XKMS中（使用应用程序<a shape="rect" class="external-link" href="http://urnapachecxfserviceendpoint" rel="nofollow">“ <em>urn：apache：cxf：service：endpoint</em></a> ”和服务端点作为标识符）</li></ul><p>在这种情况下，STS会识别encryptionName常量，并将使用AppliesTo端点地址向XKMS Crypto请求服务证书。XKMS将使用此终结点地址查找服务证书。</p><p>STS可以为多个WS-Service提供服务器，并且不在本地关心服务证书-它们在中央XKMS存储库中存储和管理。</p><p>以下<a shape="rect" class="external-link" href="http://ashakirin.blogspot.de/2013/07/cxf-security-integrate-pki-to-security.html" rel="nofollow">博客</a>介绍了详细信息，并包含示例代码。</p><h2 id="WS-Trust-BlogsonWS-TrustinCXF">CXF中的WS-Trust博客</h2><p>一些博客，提供有关WS-Trust和CXF中其他安全主题的最新信息：<br clear="none"> <a shape="rect" class="external-link" href="http://coheigea.blogspot.com/" rel="nofollow">http://coheigea.blogspot.com/</a><br clear="none"> <a shape="rect" class="external-link" href="http://owulff.blogspot.com/" rel="nofollow">http://owulff.blogspot.com/</a><br clear="none"><a shape="rect" class="external-link" href="http://janbernhardt.blogspot.com/" rel="nofollow">http://janbernhardt.blogspot.com/</a></p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=112641">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=112641&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>