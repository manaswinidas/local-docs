<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><span style="font-size:2em;font-weight:bold">JAX-RS</span>


<br clear="none"></p><p><br clear="none"></p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1571417770142 {padding: 0px;}
div.rbtoc1571417770142 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1571417770142 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1571417770142">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RS-Introduction">介绍</a></li><li><a shape="rect" href="#JAX-RS-JAX-RSCompliance">符合JAX-RS</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RS-2.1Final">2.1决赛</a></li><li><a shape="rect" href="#JAX-RS-2.0Final">2.0决赛</a></li><li><a shape="rect" href="#JAX-RS-1.1">1.1</a></li></ul>
</li><li><a shape="rect" href="#JAX-RS-Projectsetupandconfiguration">项目设置和配置</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RS-Migration">移民</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RS-FromJAX-RS2.0toJAX-RS2.1">从JAX-RS 2.0到JAX-RS 2.1</a></li><li><a shape="rect" href="#JAX-RS-FromJAX-RS1.1to2.0">从JAX-RS 1.1到2.0</a></li><li><a shape="rect" href="#JAX-RS-FromCXF2.7.xtoCXF3.0.xor3.1.x">从CXF 2.7.x到CXF 3.0.x或3.1.x</a></li><li><a shape="rect" href="#JAX-RS-CXF3.1.2ProviderSortingChanges">CXF 3.1.2提供程序排序更改</a></li></ul>
</li><li><a shape="rect" href="#JAX-RS-Mavendependencies">Maven依赖</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RS-CXF3.2.0">CXF 3.2.0</a></li><li><a shape="rect" href="#JAX-RS-CXF3.1.x">CXF 3.1.x</a></li></ul>
</li><li><a shape="rect" href="#JAX-RS-CXFJAX-RSbundle">CXF JAX-RS捆绑包</a></li></ul>
</li><li><a shape="rect" href="#JAX-RS-WhatisNew">新功能</a></li><li><a shape="rect" href="#JAX-RS-GettingStartedwithJAX-RS">JAX-RS入门</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RS-UnderstandingtheBasics">了解基础</a></li><li><a shape="rect" href="#JAX-RS-SupportforDataBindings">支持数据绑定</a></li><li><a shape="rect" href="#JAX-RS-HowRequestURIisMatched">请求URI如何匹配</a></li><li><a shape="rect" href="#JAX-RS-ClientAPI">客户端API</a></li><li><a shape="rect" href="#JAX-RS-BeanValidation">Bean验证</a></li><li><a shape="rect" href="#JAX-RS-Filters,InterceptorsandInvokers">过滤器，拦截器和调用者</a></li><li><a shape="rect" href="#JAX-RS-ServicelistingsandWADLsupport">服务清单和WADL支持</a></li><li><a shape="rect" href="#JAX-RS-ConfiguringJAX-RSservices">配置JAX-RS服务</a></li><li><a shape="rect" href="#JAX-RS-Testing">测试中</a></li><li><a shape="rect" href="#JAX-RS-Debugging">调试</a></li><li><a shape="rect" href="#JAX-RS-Logging">记录中</a></li></ul>
</li><li><a shape="rect" href="#JAX-RS-AdvancedFeatures">高级功能</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RS-Multiparts">多部分</a></li><li><a shape="rect" href="#JAX-RS-SecureJAX-RSservices">安全的JAX-RS服务</a></li><li><a shape="rect" href="#JAX-RS-FailoverandLoadDistributionFeatures">故障转移和负载分配功能</a></li><li><a shape="rect" href="#JAX-RS-Redirection">重新导向</a></li><li><a shape="rect" href="#JAX-RS-XSLTandXPath">XSLT和XPath</a></li><li><a shape="rect" href="#JAX-RS-ComplexSearchQueries">复杂的搜索查询</a></li><li><a shape="rect" href="#JAX-RS-Model-View-Controllersupport">模型-视图-控制器支持</a></li><li><a shape="rect" href="#JAX-RS-CombiningJAX-WSandJAX-RS">结合JAX-WS和JAX-RS</a></li><li><a shape="rect" href="#JAX-RS-IntegrationwithDistributedOSGi">与分布式OSGi集成</a></li><li><a shape="rect" href="#JAX-RS-ODataSupport">OData支持</a></li><li><a shape="rect" href="#JAX-RS-OtherAdvancedFeatures">其他高级功能</a></li></ul>
</li><li><a shape="rect" href="#JAX-RS-MavenPlugins">Maven插件</a></li><li><a shape="rect" href="#JAX-RS-Deployment">部署方式</a></li><li><a shape="rect" href="#JAX-RS-Third-partyprojects">第三方项目</a></li><li><a shape="rect" href="#JAX-RS-References">参考文献</a></li><li><a shape="rect" href="#JAX-RS-Howtocontribute">如何贡献</a></li></ul>
</div><h1 id="JAX-RS-Introduction">介绍</h1><p><a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/JAX-RS" rel="nofollow">JAX-RS</a> ：RESTful Web服务的Java API是一种Java编程语言API，它提供了根据代表性状态转移（REST）体系结构样式创建Web服务的支持。</p><p>CXF支持JAX-RS 2.1（ <a shape="rect" class="external-link" href="https://www.jcp.org/en/jsr/detail?id=370" rel="nofollow">JSR-370</a> ），2.0（ <a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=339" rel="nofollow">JSR-339</a> ）和1.1（ <a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=311" rel="nofollow">JSR-311</a> ）。</p><p>CXF 3.2.0支持JAX-RS 2.1。所有现有的JAX-RS 2.0和1.1应用程序都可以与CXF 3.2.0一起运行。</p><p>CXF 3.1.x和3.0.x支持JAX-RS 2.0。现有的JAX-RS 1.1应用程序可以与CXF 3.1.x / 3.0.x一起运行。</p><p>有关合规性的更多信息，请参见<a shape="rect" href="jax-rs.html">下文</a> 。</p><p>与JAX-RS相关的演示位于<a shape="rect" class="external-link" href="http://svn.apache.org/viewvc/cxf/trunk/distribution/src/main/release/samples/jax_rs/">samples / jax_rs</a>目录下。</p><p>可以在<a shape="rect" class="external-link" href="https://issues.apache.org/jira/secure/IssueNavigator.jspa?reset=true&jqlQuery=project+%3D+CXF+AND+resolution+%3D+Unresolved+AND+component+%3D+JAX-RS+ORDER+BY+priority+DESC&mode=hide">这里</a>找到未解决的JAX-RS JIRA问题。</p><h1 id="JAX-RS-JAX-RSCompliance">符合JAX-RS</h1><p><span class="confluence-anchor-link" id="JAX-RS-2_0_FINAL"></span></p><h2 id="JAX-RS-2.1Final">2.1决赛</h2><p>CXF 3.2.0已更新，以尽可能完全地实现JAX-RS 2.1 API。</p><p>如果另一个在其产品中使用CXF的JAX-RS 2.1实现的TCK被许可方发现与CXF的合规性相关的问题，我们非常乐意修复所引发的错误。</p><h2 id="JAX-RS-2.0Final">2.0决赛</h2><p>CXF 3.1.x和CXF 3.0.x已更新，以尽可能完整地实现JAX-RS 2.0 API，而无需访问最终的JAX-RS 2.0 TCK。<br clear="none">我们已经对JAX-RS 2.0用户应用程序，样本和初步的TCK进行了广泛的测试，以确保CXF的实现尽可能完整和兼容。<br clear="none">CXF并将继续尽最大努力，使JAX-RS 2.0和新的JAX-RS版本实施在技术上完成，并为运行便携式JAX-RS 2.0应用程序提供环境。<br clear="none">如果最终的2.0 TCK可供Apache使用，我们将确保CXF已更新为可以通过。<br clear="none">如果另一个在其产品中使用CXF的JAX-RS 2.0实现的TCK被许可方发现与CXF的合规性有关的问题，我们非常乐意修复所引发的错误。</p><h2 id="JAX-RS-1.1">1.1</h2><p>Apache CXF 2.6.x通过了最终的JAX-RS 1.1 TCK，并正式符合1.1。</p><p>请在基于Apache CXF的JAX-RS运行时中，查阅有关Java EE相关的JAX-RS 1.1选项支持的<a shape="rect" class="external-link" href="http://tomee.apache.org/apache-tomee.html">TomEE</a>文档。</p><p>CXF 2.7.x和CXF 3.0.0将完全支持并运行JAX-RS 1.1应用程序，但由于以下原因将无法通过JAX-RS 1.1 TCK签名测试：</p><p>CXF 2.7.x和CXF 3.0.0，取决于JAX-RS 2.0 API的2.0-m10和2.0最终版本。</p><p><br clear="none"></p><h1 id="JAX-RS-Projectsetupandconfiguration">项目设置和配置</h1><h2 id="JAX-RS-Migration">移民</h2><h3 id="JAX-RS-FromJAX-RS2.0toJAX-RS2.1">从JAX-RS 2.0到JAX-RS 2.1</h3><p>JAX-RS 2.1向后兼容JAX-RS 2.0。有关JAX-RS 2.1的更多信息，请参见<a shape="rect" href="jax-rs-basics.html">JAX-RS基础</a> 。</p><p>所有现有的JAX-RS 2.0和1.1应用程序都将在CXF 3.2.0上运行。</p><h3 id="JAX-RS-FromJAX-RS1.1to2.0">从JAX-RS 1.1到2.0</h3><p>JAX-RS 2.0向后兼容JAX-RS 1.1。有关JAX-RS 2.0的更多信息，请参见<a shape="rect" href="jax-rs-basics.html">JAX-RS基础</a> 。</p><p>预计CXF 3.1.x和CXF 3.0.x将支持现有的JAX-RS 1.1应用程序。</p><h3 id="JAX-RS-FromCXF2.7.xtoCXF3.0.xor3.1.x">从CXF 2.7.x到CXF 3.0.x或3.1.x</h3><p>请查看《 <a shape="rect" href="http://cxf.apache.org/docs/30-migration-guide.html">CXF 3.0.0迁移指南》</a>以获取有关所有更改的信息。<br clear="none">在CXF 3.0.0中。以下是有关专门影响JAX-RS用户的更改的更多详细信息：</p><p>1。CXF RequestHandler和ResponseHandler过滤器已删除。</p><p>2.7.x仍支持这些旧版CXF筛选器，但3.0.0中不再支持。请改用<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerRequestFilter.html" rel="nofollow">ContainerRequestFilter</a>和<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerResponseFilter.html" rel="nofollow">ContainerResponseFilter</a> 。另外，也可以使用<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ReaderInterceptor.html" rel="nofollow">ReaderInterceptor</a>和<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/WriterInterceptor.html" rel="nofollow">WriterInterceptor</a> 。</p><p>注意，CXF筛选器具有org.apache.cxf.message。签名中的消息可用。如果在现有的CXF RequestHandler或ResponseHandler中使用了CXF消息，则使用“ org.apache.cxf.phase。PhaseInterceptorChain.getCurrentMessage（）”或“ org.apache.cxf.jaxrs.util。JAXRSUtils.getCurrentMessage（）”以获取具有所有可用上下文信息的消息。</p><p>例如，代替</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class CustomRequestHandler implements RequestHandler {
    public Response handleRequest(Message message, ClassResourceInfo cri) {
    }
}

public class CustomResponseHandler implements ResponseHandler {
    public Response handleResponse(Message message, OperationResourceInfo ori, Response response) {
    }
}

</pre>
</div></div><p>做</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class CustomRequestFilter implements ContainerRequestFilter {
    public void filter(ContainerRequestContext context) {
        Message message = JAXRSUtils.getCurrentMessage();
       ClassResourceInfo cri = message.getExchange().get(OperationResourceInfo.class).getClassResourceInfo();

        // or consider using JAX-RS 2.0 ResourceInfo context

        // finally use context.abortWith(Response) if you need to block the request 
    }
}

public class CustomResponseFilter implements ContainerResponseFilter {
    public void filter(ContainerRequestContext inContext, ContainerResponseContext outContext) {
        Message message = JAXRSUtils.getCurrentMessage();
        OperationResourceInfo cri = message.getExchange().get(OperationResourceInfo.class);

        // or consider using JAX-RS 2.0 ResourceInfo context 
        
        // finally, work with ContainerResponseContext to modify specific Response properties
    }
}

</pre>
</div></div><p>仅需要上述内容来简化现有RequestHandler或ResponseHandler实现的迁移。如果可能，最好编写可移植的JAX-RS 2.0过滤器实现。如果需要，可以使用CXF拦截器来执行CXF特定的代码。</p><p>2。CXF org.apache.cxf.jaxrs.ext.form。表单已删除，请改用JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Form.html" rel="nofollow">表单</a> 。例如，使用：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.ws.rs.core.Form;

Form form = new Form().param("a", "b");
</pre>
</div></div><p>代替</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.jaxrs.ext.form.Form;

Form form = new Form().set("a", "b");
</pre>
</div></div><p>3。CXF WebClient和代理代码已移至新的cxf-rt-rs-client模块。<br clear="none">另外，用于注入代理的jaxrs：client元素的名称空间已从“ http://cxf.apache.org/jaxrs”更改为“ http://cxf.apache.org/jaxrs-client”。</p><p>请参阅<a shape="rect" href="jax-rs-client-api.html">JAX-RS客户端API</a>页面了解更多信息。</p><p>4。WADL自动生成器代码已移至新的cxf-rt-rs-service-description模块。</p><p>5，CXF ParameterHandler已删除。请使用<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ParamConverterProvider.html" rel="nofollow">ParameterConverterProvider</a>相反，它可以在服务器端和客户端均可使用。</p><p>6。JAX-RS 2.0引入了一个有争议的要求，即默认的内置JAX-RS MessageBodyWriter和JAX-RS MessageBodyReader提供程序要<strong>优于</strong>支持相同类型的定制提供程序，除非对定制提供程序进行精确键入，例如，如果您具有定制InputStream的话。阅读器正确实现isReadable：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class MyStreamProvider implements MessageBodyReader&lt;Object&gt; {
    public boolean isReadable(Class&lt;?&gt; cls, ...) {
        return InputStream.class.isAssignableFrom(cls) || Reader.class.isAssignableFrom(cls);
    }
    // other methods
}
</pre>
</div></div><p>那么运行时将忽略它，并选择默认的InputStream / Reader阅读器，因为MyStreamProvider是在Object上键入的。这样做是为了处理著名的JSON / etc提供程序通过始终返回“ true”然后在被要求直接将传入流直接读取到InputStream / etc中时失败而盲目地在其isReadable方法中支持所有类型的情况。如果是MyStreamProvider，则需要将其分为分别在InputStream和Reader上键入的MyInputStreamProvider和MyReaderProvider。</p><p>在CXF级别上，依赖CXF MultipartProvider的InputStream或String引用多部分附件的用户将受到影响，除非他们使用@Multipart批注。例如，如果我们只有一个零件/附件的多部分有效载荷，则以下代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@POST
@Consumes("multipart/form-data")
public void upload(InputStream is) {
}
</pre>
</div></div><p>在CXF 2.7.x或更早版本中，该函数将返回指向第一/单个单个部分的指针，实际上将返回一个流，该流代表完整的未处理的多部分有效负载。添加@Multipart标记将使现有代码按预期运行：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@POST
@Consumes("multipart/form-data")
public void upload(@Multipart InputStream is) {
}
</pre>
</div></div><p>或者，可以设置“ support.type.as.multipart”上下文属性。</p><p>7。如果自定义代码抛出带有包含非空实体的Response的JAX-RS WebApplicationException，则将绕过自定义WebApplicationException映射器-另一个有问题的要求，例如，进行日志记录的自定义映射器将错过此类异常。<br clear="none">将CXF的“ support.wae.spec.optimization”属性设置为false可将其禁用。</p><p>8。在某些情况下，将删除匹配的子资源定位符以精确地满足当前的JAX-RS匹配算法文本，请参阅<a shape="rect" class="external-link" href="https://issues.apache.org/jira/browse/CXF-5650">CXF-5650</a>以获取更多信息。如果需要，使用新的“ keep.subresource.candidates”属性来支持现有的应用程序。</p><h3 id="JAX-RS-CXF3.1.2ProviderSortingChanges">CXF 3.1.2提供程序排序更改</h3><p>从CXF 3.1.2 customMessageBodyReader（MBR）开始，MessageBodyWriter（MBW）和ExceptionMapper提供程序与默认提供程序一起排序。</p><p>在CXF 3.1.2之前，如果自定义MBR或MBW符合读取或写入选择条件，例如，如果MBR Consumes符合Content-Type，并且其isReadable（）返回true，则</p><p>甚至不检查默认提供程序。但是，该规范仅在没有更高优先级的默认提供者可用时才选择自定义提供者。</p><p>例如，假设您有一个自定义StringReader，它不是由String键入的，而是由Object键入的。在这种情况下，由String键入的默认提供程序将获胜。要使自定义String提供程序获胜，需要通过String进行键入。</p><p>检查规格或在用户列表中询问更多详细信息。</p><p><br clear="none"></p><h2 id="JAX-RS-Mavendependencies">Maven依赖</h2><h3 id="JAX-RS-CXF3.2.0">CXF 3.2.0</h3><p>需要cxf-rt-frontend-jaxrs依赖项：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">   &lt;dependency&gt;
      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
      &lt;artifactId&gt;cxf-rt-frontend-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;3.2.0&lt;/version&gt;
   &lt;/dependency&gt;
</pre>
</div></div><p>这将反过来拉动其他<a shape="rect" href="http://cxf.apache.org/project-status.html">CXF模块，</a>例如<code>cxf-core</code>和<code>cxf-rt-transports-http</code> ，请检查<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/frontend/jaxrs/pom.xml" rel="nofollow">pom</a>以获取更多信息。</p><p><code><a shape="rect" class="external-link" href="http://javax.ws" rel="nofollow">javax.ws</a>.rs/<a shape="rect" class="external-link" href="http://javax.ws" rel="nofollow">javax.ws</a>.rs-api/2.1</code>依赖项提供了JAX-RS 2.1 Final API。</p><h3 id="JAX-RS-CXF3.1.x">CXF 3.1.x</h3><p>需要cxf-rt-frontend-jaxrs依赖项：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">   &lt;dependency&gt;
      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
      &lt;artifactId&gt;cxf-rt-frontend-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;3.1.12&lt;/version&gt;
   &lt;/dependency&gt;
</pre>
</div></div><p>这将反过来拉动其他<a shape="rect" href="http://cxf.apache.org/project-status.html">CXF模块，</a>例如<code>cxf-core</code>和<code>cxf-rt-transports-http</code> ，请检查<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/3.1.x-fixes/rt/frontend/jaxrs/pom.xml" rel="nofollow">pom</a>以获取更多信息。</p><p><code>javax.ws.rs/javax.ws.rs-api/2.0</code>依赖项提供了JAX-RS 2.0 Final API。</p><pre>javax.annotation/javax.annotation-api/1.2 dependency is needed if custom JAX-RS 2.0 filters or interceptors use a javax.annotation.Priority annotation.</pre><p>现有的JAX-RS 1.1应用程序可以在CXF 3.1.x和CXF 3.0.x中运行。</p><h2 id="JAX-RS-CXFJAX-RSbundle">CXF JAX-RS捆绑包</h2><p>注意CXF JAX-RS捆绑软件已在CXF 3.0.0中删除。直接根据JAX-RS前端而定。在CXF 3.0.0中，如果确实需要，仍可以使用完整的CXF全包<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/osgi/bundle/all/pom.xml">软件包</a> 。</p><p>仅在CXF 2.7.x或更早版本中：<br clear="none">一个独立的<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/branches/2.7.x-fixes/osgi/bundle/all/pom.xml">JAX-RS捆绑包</a>是可用的，仅从事JAX-RS工作的用户可能会感兴趣。</p><p>请注意，该捆绑软件对Jetty服务器模块具有可传递的Maven依赖性。如果您正在使用Maven并与其他servlet容器（例如Tomcat）一起使用，请添加以下排除项：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">   &lt;dependency&gt;
      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
      &lt;artifactId&gt;cxf-bundle-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;${cxf.version}&lt;/version&gt;
      &lt;exclusions&gt;
          &lt;exclusion&gt;
            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
            &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;
          &lt;/exclusion&gt;
      &lt;/exclusions&gt; 

   &lt;/dependency&gt;
</pre>
</div></div><h1 id="JAX-RS-WhatisNew">新功能</h1><ul><li>完全支持JAX-RS 2.1，请参阅<a shape="rect" href="jax-rs-basics.html">JAX-RS基础</a>以获取更多信息。</li><li>基于早期JAX-RS 2.1 API原型的<a shape="rect" href="jax-rs-nio.html">JAX-RS NIO</a>扩展。</li><li><a shape="rect" href="jax-rs-rxjava.html">JAX-RS RxJava</a>可观察的支持：作为标准的JAX-RS 2.1 RxInvoker客户端提供程序，并从资源方法异步返回它（CXF扩展）</li><li>同样基于JAX-RS 2.1 RxInvoker范例的<a shape="rect" href="jax-rs-project-reactor-support.html">JAX-RS Project Reactor</a>支持</li><li>完全支持JAX-RS 2.0，请参阅<a shape="rect" href="jax-rs-basics.html">JAX-RS基础</a>以获取更多信息。</li><li>Bean Validation 1.1支持，请参阅<a shape="rect" href="http://cxf.apache.org/docs/validationfeature.html">http://cxf.apache.org/docs/validationfeature.html</a>了解更多信息</li><li><a shape="rect" href="http://cxf.apache.org/docs/swagger2feature.html">扬鞭特征</a>用于产生<a shape="rect" class="external-link" href="http://swagger.io/specification/" rel="nofollow">扬鞭API</a>从JAX-RS端点文档</li></ul><h1 id="JAX-RS-GettingStartedwithJAX-RS">JAX-RS入门</h1><h2 id="JAX-RS-UnderstandingtheBasics">了解基础</h2><p>建议您阅读JAX-RS 2.1 <a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=370" rel="nofollow">JSR-370</a>规范，以查找本文档未涵盖的信息。该规范通过引入对Reactive Client API扩展，服务器发送事件（客户端和服务器），从资源方法返回CompletableFuture和从子资源定位符返回子资源类（与实例相对）的支持，增强了JAX-RS 2.0。 。</p><p>还鼓励您阅读JAX-RS 2.0 <a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=339" rel="nofollow">JSR-339</a>规范，以查找本文档未涵盖的信息。该规范引入了许多术语，例如根资源，资源方法，子资源和子资源定位符，消息正文读取器和写入器。JAX-RS 2.0还引入了过滤器，拦截器，新的客户端API，功能，新的异常类以及对异步调用的服务器端支持。</p><p>请参阅<a shape="rect" href="jax-rs-basics.html">JAX-RS基础</a>页面以获取更多信息。</p><h2 id="JAX-RS-SupportforDataBindings">支持数据绑定</h2><p>JAX-RS MessageBodyReader和MessageBodyWriter可用于创建数据绑定，以多种不同格式读取和写入数据。兼容的JAX-RS实现应支持带JAXB注释的Bean，JAXP Source对象，InputStreams等。</p><p>此外，CXF JAX-RS允许用户重用现有的CXF数据绑定以与JAXB，XBean，Aegis和SDO一起使用。</p><p>请参阅<a shape="rect" href="jax-rs-data-bindings.html">JAX-RS数据绑定</a>页面以获取更多信息。</p><h2 id="JAX-RS-HowRequestURIisMatched">请求URI如何匹配</h2><p>假设您有一个名为“ rest”的Web应用程序（例如，“ rest.war”档案）。CXFServlet的url模式是“ / test / *”。最后，jaxrs：server的地址为“ / bar”。</p><p>/ rest / test / bar或/ rest / test / bar / baz之类的请求将传递到给定jaxrs：server端点中的资源类之一。对于要处理的前一个请求，具有@Path（“ /”）的资源类应该可用，在后一种情况下-至少是@Path（“ /”）或更具体的@Path（“ / baz”）。</p><p>可以通过使CXFServlet带有“ / *”和jaxrs：server带有“ / test / bar”来表达相同的要求。</p><p>当CXFServlet和jaxrs：server都使用“ /”时，它是一个根资源类，该类应该为@Path提供至少带有“ / test / bar”的@Path，以匹配上述请求。</p><p>通常，最好使用CXFServlets或jaxrs：server指定更可能不时更改的URI段。</p><h2 id="JAX-RS-ClientAPI">客户端API</h2><p>CXF 3.0.0实现了JAX-RS 2.0客户端API。</p><p>CXF 2.7.x或更早版本通过支持三种客户端API：基于代理，以HTTP为中心和以XML为中心，为开发RESTful客户端提供了全面的支持。支持CXF特定的客户端API，以及CXF 3.0.0中新的JAX-RS 2.0客户端API。</p><p>请参阅<a shape="rect" href="jax-rs-client-api.html">JAX-RS客户端API</a>页面以获取更多信息。</p><h2 id="JAX-RS-BeanValidation">Bean验证</h2><p>从CXF 3.0.0-milestone1开始支持Bean验证1.1。有关更多信息，请参见<a shape="rect" href="http://cxf.apache.org/docs/validationfeature.html">http://cxf.apache.org/docs/validationfeature.html</a> 。</p><h2 id="JAX-RS-Filters,InterceptorsandInvokers">过滤器，拦截器和调用者</h2><p>借助CXF JAX-RS过滤器和/或CXF拦截器，可以拦截和修改入站和出站呼叫。另外，自定义调用程序提供了在调用服务bean之前立即拦截呼叫的选项。</p><p>请参阅<a shape="rect" href="jax-rs-filters.html">JAX-RS过滤器</a>页面以获取更多信息。</p><p>有关CXF 2.7.x和3.0.0中可用的新JAX-RS 2.0过滤器和拦截器的更多信息，请参见<a shape="rect" href="jax-rs-basics.html">JAX-RS基础</a>页面。</p><h2 id="JAX-RS-ServicelistingsandWADLsupport">服务清单和WADL支持</h2><p><strong>新增</strong> ：引入了Swagger功能。</p><p>CXF JAX-RS支持<a shape="rect" class="external-link" href="http://www.w3.org/Submission/wadl" rel="nofollow">WADL</a> 。 CXF JAX-RS服务端点可以在服务列表页面中列出，并且用户可以检查WADL文档。</p><p>请参阅<a shape="rect" href="jaxrs-services-description.html">JAXRS服务描述</a>页面以获取更多信息。</p><h2 id="JAX-RS-ConfiguringJAX-RSservices">配置JAX-RS服务</h2><p>可以使用Blueprint，Spring或CXFNonSpringJAXRSServlet以编程方式配置JAX-RS服务。</p><p>请参阅“ <a shape="rect" href="jaxrs-services-configuration.html">JAXRS服务配置”</a>页面以获取更多信息。</p><h2 id="JAX-RS-Testing">测试中</h2><p>使用嵌入式Jetty或CXF Local Transport可以轻松测试JAX-RS服务。<br clear="none">请参阅“ <a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAXRS+Testing">JAXRS测试”</a>页面以获取更多信息。</p><h2 id="JAX-RS-Debugging">调试</h2><p>可能需要使用浏览器来测试给定的HTTP资源如何对不同的HTTP Accept或Accept-Language标头值和请求方法作出反应。例如，如果资源类支持“ / resource” URI，则可以使用以下查询之一测试该资源类：</p><p><code>> GET /resource.xml</code> <br clear="none"><code>> GET /resource.en</code></p><p>运行时将使用适当的标头值替换“ .xml”或“ .en”。为了了解与给定URI后缀关联的类型或语言值，需要进行一些配置。这是使用Spring可以完成的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">  &lt;jaxrs:server id="customerService" address="/"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;bean class="org.apache.cxf.jaxrs.systests.CustomerService" /&gt;
    &lt;/jaxrs:serviceBeans&gt;
    &lt;jaxrs:extensionMappings&gt;
      &lt;entry key="json" value="application/json"/&gt;
      &lt;entry key="xml" value="application/xml"/&gt;
    &lt;/jaxrs:extensionMappings&gt;
    &lt;jaxrs:languageMappings&gt;
       &lt;entry key="en" value="en-gb"/&gt;  
    &lt;/jaxrs:languageMappings&gt;
  &lt;/jaxrs:server&gt;
</pre>
</div></div><p>CXF还支持_type查询，作为附加诸如.xml之类的扩展名以请求URI的替代方法：</p><p>{{>获取/资源？_type = xml}}</p><p>CXF还支持重写请求方法。但是请注意，默认情况下（自CXF 3.3.4起）CXF服务不允许这样做。要启用HTTP方法覆盖，请将端点属性“ org.apache.cxf.jaxrs.allow.http.method.override”指定为“ true”。</p><p>有两种覆盖HTTP请求方法的选项-通过查询参数：</p><p><code>> GET /resource?_method=POST</code></p><p>或者，可以指定HTTP标头X-HTTP-Method-Override：</p><p><code>> POST /books</code> <br clear="none"><code>> X-HTTP-Method-Override : PATCH</code></p><p>例如，目前以http为中心的客户端API不支持任意HTTP动词，但所支持的除外<br clear="none">通过Java HTTPUrlConnection。如果需要，可以设置X-HTTP-Method-Override来克服此限制。</p><p>最后，“ _ ctype”查询允许覆盖Content-Type。</p><p>有关如何在CXF中调试和记录服务调用的更多信息，请参见“ <a shape="rect" href="debugging-and-logging.html">调试和记录”</a>页面。</p><h2 id="JAX-RS-Logging">记录中</h2><p>许多现有的CXF功能都可以应用于<code>jaxrs:server</code>要么<code>jaxrs:client</code> 。例如，要启用记录请求和响应，只需执行以下操作：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:cxf="http://cxf.apache.org/core" 
   xsi:schemaLocation="http://cxf.apache.org/core 
      http://cxf.apache.org/schemas/core.xsd"&gt;
&lt;jaxrs:server&gt;
&lt;jaxrs:features&gt;
     &lt;cxf:logging/&gt;
&lt;/jaxrs:features&gt;
&lt;jaxrs:server&gt;
&lt;/beans&gt;
</pre>
</div></div><p>请确保<code><a shape="rect" href="http://cxf.apache.org/core">http://cxf.apache.org/core</a></code>名称空间在范围内。</p><p>从CXF 2.3.0开始，还可以将日志事件转换为Atom条目，然后将其推送到接收者或使其可用于轮询。</p><p>请参阅“ <a shape="rect" href="debugging-and-logging.html">调试和日志记录”</a>页面以获取更多信息。</p><h1 id="JAX-RS-AdvancedFeatures">高级功能</h1><h2 id="JAX-RS-Multiparts">多部分</h2><p>可以以多种方式处理多部分。CXF核心运行时为处理CXF JAX-RS构建的附件提供了高级支持。</p><p>请参阅<a shape="rect" href="jax-rs-multiparts.html">JAX-RS Multiparts</a>页面以获取更多信息。</p><h2 id="JAX-RS-SecureJAX-RSservices">安全的JAX-RS服务</h2><p>传输级HTTPS安全性可用于保护CXF JAX-RS端点和提供程序之间交换的消息。</p><p>身份验证和授权可以通过多种方式实施。</p><p>请参阅<a shape="rect" href="secure-jax-rs-services.html">Secure JAX-RS服务</a>页面以获取更多信息。</p><p>也请检查<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-xml-security.html">JAX-RS XML安全性</a> ， <a shape="rect" href="jax-rs-saml.html">JAX-RS SAML，</a> <a shape="rect" href="jax-rs-token-authorization.html">JAX-RS令牌授权</a>和<a shape="rect" href="jax-rs-oauth2.html">JAX-RS OAuth2</a>页面，以获取有关高级安全性主题的更多信息。</p><h2 id="JAX-RS-FailoverandLoadDistributionFeatures">故障转移和负载分配功能</h2><p>从CXF 2.4.1开始，可以通过故障转移和负载分配功能来备份CXF JAX-RS代理和WebClient使用者。<br clear="none">请参阅<a shape="rect" href="jax-rs-failover.html">JAX-RS故障转移</a>页面以获取更多信息。</p><h2 id="JAX-RS-Redirection">重新导向</h2><p>从CXF 2.2.5开始，可以通过配置CXFServlet或使用CXF JAX-RS RequestDispatcherProvider将请求或响应调用重定向到其他Servlet资源。</p><p>请参阅<a shape="rect" href="jax-rs-redirection.html">JAX-RS重定向</a>页面以获取更多信息。</p><h2 id="JAX-RS-XSLTandXPath">XSLT和XPath</h2><p>XSLT和XPath在CXF JAX-RS中得到提升并被视为一流公民。当生成复杂数据或从复杂XML片段中检索感兴趣的数据时，这些技术可能会非常强大。</p><p>请参阅<a shape="rect" href="jax-rs-advanced-xml.html">JAX-RS高级XML</a>页面了解更多信息。</p><h2 id="JAX-RS-ComplexSearchQueries">复杂的搜索查询</h2><p>使用<a shape="rect" href="http://cxf.apache.org/docs/jax-rs.html#JAX-RS-Parameterbeans">查询参数bean</a>提供了一种捕获搜索需求的方法，该需求可以通过枚举名称/值对来表示，例如，诸如'？之类的查询。包含setName和setVersion方法的bean可以捕获name = CXF＆version = 2.3'。可以在代码中使用此“模板” bean来将其与所有可用的本地数据进行比较。</p><p>CXF JAXRS的2.3版和更高版本支持使用“ <a shape="rect" class="external-link" href="http://tools.ietf.org/html/draft-nottingham-atompub-fiql-00" rel="nofollow">提要项查询语言”</a> （FIQL）进行高级搜索查询的另一个选项。</p><p>请参阅<a shape="rect" href="jax-rs-search.html">JAX-RS搜索</a>页面以获取更多信息。</p><h2 id="JAX-RS-Model-View-Controllersupport">模型-视图-控制器支持</h2><p><strong>XSLT</strong> <br clear="none">请参阅<a shape="rect" href="jax-rs-advanced-xml.html">JAX-RS Advanced XML</a>页面以获取更多信息。如何<code>XSLTJaxbProvider</code>可用于生成复杂的（X）HTML视图。</p><p><strong>JSP</strong></p><p>随着介绍<code>RequestDispatcherProvider</code>现在可以将JAXRS服务响应重定向到JSP页面以进行进一步处理。请参阅<a shape="rect" href="jax-rs-redirection.html">JAX-RS重定向</a>页面以获取更多信息。</p><h2 id="JAX-RS-CombiningJAX-WSandJAX-RS">结合JAX-WS和JAX-RS</h2><p>CXF JAX-RS试图使SOAP开发人员更容易尝试JAX-RS，并在需要时将JAX-WS和JAX-RS合并在同一个服务bean中。</p><p>请参阅<a shape="rect" href="jax-rs-and-jax-ws.html">JAX-RS和JAX-WS</a>页面了解更多信息。</p><h2 id="JAX-RS-IntegrationwithDistributedOSGi">与分布式OSGi集成</h2><p>分布式OSGi RI是CXF <a shape="rect" href="http://cxf.apache.org/distributed-osgi.html">子项目</a> 。DOSGi规定了如何公开已注册的Java接口<br clear="none">并作为远程服务使用。DOSGi单捆绑包和多捆绑包发行版包含成功发布CXF端点所需的所有OSGI捆绑包。</p><p>CXF JAX-RS实现已与DOSGi RI 1.1-SNAPSHOT集成在一起，这使得可以将Java接口公开为RESTful服务，并使用基于代理的客户端API使用此类服务。</p><p>请参阅《 <a shape="rect" href="http://cxf.apache.org/distributed-osgi-reference.html#DistributedOSGiReference-ServiceProviderproperties">DOSGI参考》页面</a> （'org.apache.cxf.rs'属性）和<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/dosgi/trunk/samples/greeter_rest/">greeter_rest</a>示例以获取更多信息。请注意，此演示可以注册和使用类似的（但） <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/dosgi/trunk/samples/greeter_rest/interface/src/main/java/org/apache/cxf/dosgi/samples/greeter/rest/GreeterService.java">带有</a> JAX-RS注释的<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/dosgi/trunk/samples/greeter_rest/interface/src/main/java/org/apache/cxf/dosgi/samples/greeter/rest/GreeterService.java">GreeterService</a> ，因此可以完全像基于SOAP的<a shape="rect" href="http://cxf.apache.org/distributed-osgi-greeter-demo-walkthrough.html">欢迎</a>演示一样<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/dosgi/trunk/samples/greeter_rest/interface/src/main/java/org/apache/cxf/dosgi/samples/greeter/rest/GreeterService.java">运行</a> 。此外，此演示还演示了如何在不使用显式JAX-RS注释但提供带外<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/dosgi/trunk/samples/greeter_rest/interface/src/main/resources/OSGI-INF/cxf/jaxrs/GreeterService2-model.xml">用户模型描述的</a>情况下注册和使用给定接口（ <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/dosgi/trunk/samples/greeter_rest/interface/src/main/java/org/apache/cxf/dosgi/samples/greeter/rest/GreeterService2.java">GreeterService2</a> ）。</p><h2 id="JAX-RS-ODataSupport">OData支持</h2><p>CXF JAX-RS端点可以依靠<a shape="rect" class="external-link" href="https://olingo.apache.org/">Apache Olingo</a>以两种方式支持<a shape="rect" class="external-link" href="http://www.odata.org/" rel="nofollow">OData</a> 。</p><p>首先， <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-search.html#JAX-RSSearch-OpenDataProtocol">搜索扩展</a>支持OData“ $ filter”查询，其中具有特定于应用程序的API的端点可以响应过滤器查询，例如，返回符合填充器搜索标准的书籍的集合。</p><p>其次，CXF JAX-RS可用于在Olingo上插入，如此处<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/odata" rel="nofollow">演示</a> 。实际上，这样的CXF端点变成了OData服务器：它所做的全部都<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/distribution/src/main/release/samples/jax_rs/odata/src/main/java/odata/server/JaxrsODataService.java" rel="nofollow">委派给Olingo</a> 。这个想法是为了能够在Olingo的前面添加CXF特定的功能和拦截器。</p><h2 id="JAX-RS-OtherAdvancedFeatures">其他高级功能</h2><p>CXF JAX-RS提供了许多高级扩展，例如对JMS传输的支持，单向调用（HTTP和JMS），挂起的调用（HTTP和JMS），通过应用外部用户模型使现有代码具有REST意识等。 。</p><p>请参阅<a shape="rect" href="jax-rs-advanced-features.html">JAX-RS高级功能</a>页面以获取更多信息。</p><h1 id="JAX-RS-MavenPlugins">Maven插件</h1><p>请参阅<a shape="rect" href="jax-rs-maven-plugins.html">JAX-RS Maven插件</a>页面，以获取有关Maven插件和原型的更多信息，这些信息可以帮助创建CXF JAX-RS应用程序。</p><h1 id="JAX-RS-Deployment">部署方式</h1><p>打包为WAR存档的CXF JAX-RS应用程序可以部署到独立的Servlet容器中，例如Tomcat或Jetty。<br clear="none">请参阅“ <a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/JAX-RS+Deployment">JAX-RS部署”</a>页面，以获取有关如何将CXF JAX-RS应用程序成功部署到各种Java EE和OSGI应用程序服务器中的提示。</p><h1 id="JAX-RS-Third-partyprojects">第三方项目</h1><ul><li>REST实用程序： <a shape="rect" class="external-link" href="https://github.com/taimos/RESTUtils" rel="nofollow">RESTUtils</a></li></ul><h1 id="JAX-RS-References">参考文献</h1><ul><li><a shape="rect" class="external-link" href="http://jcp.org/aboutJava/communityprocess/final/jsr311/index.html" rel="nofollow">JSR-000311 JAX-RS：用于RESTful Web服务的JavaTM API</a></li><li><a shape="rect" class="external-link" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" rel="nofollow">架构风格和基于网络的软件架构设计</a></li><li><a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" rel="nofollow">代表性国家转移-维基百科</a></li><li><a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596801694/" rel="nofollow">RESTful Web服务食谱</a> <em>-Subbu Allamarajuy提出的</em> <a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596801694/" rel="nofollow">用于提高可伸缩性和简单性</a> <em>的</em> <a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596801694/" rel="nofollow">解决方案</a> （O'Reilly Media，2010年2月）</li><li><a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596158057/" rel="nofollow">带有JAX-RS</a> <em>的</em> <a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596158057/" rel="nofollow">RESTful Java，</a> <em>作者Bill Burke</em> （O'Reilly Media，2009年11月）</li><li><a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596521134/" rel="nofollow">Java Web服务：</a> <em>Martin Kalin的</em> <a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596521134/" rel="nofollow">启动和运行</a> （O'Reilly Media，2009年2月）</li><li><a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596529260/" rel="nofollow">RESTful Web服务-现实世界中</a> <em>的</em> <a shape="rect" class="external-link" href="http://oreilly.com/catalog/9780596529260/" rel="nofollow">Web服务，</a> <em>作者Leonard Richardson，Sam Ruby</em> （O'Reilly Media，2007年5月）</li><li><em>Sameer Tyagi的</em> <a shape="rect" class="external-link" href="http://www.oracle.com/technetwork/articles/javase/index-137171.html" rel="nofollow">RESTful Web服务</a> （Oracle，2006年8月）</li><li><a shape="rect" class="external-link" href="http://www.crummy.com/writing/RESTful-Web-Services/" rel="nofollow">RESTful Web服务-“有关简单Web服务的书的非官方主页。”</a> <em>未知</em></li><li><a shape="rect" class="external-link" href="http://tomayko.com/writings/rest-to-my-wife" rel="nofollow">我如何向我的妻子解释REST</a> <em>（作者Ryan Tomayko）</em> （ <a shape="rect" class="external-link" rel="nofollow" href="http://tomayko.com">http：</a> <em>//tomayko.com，2004年</em> 12月）</li></ul><h1 id="JAX-RS-Howtocontribute">如何贡献</h1><p>CXF JAX-RS实现位于核心CXF运行时之上，并且是完全独立的并且与其他CXF模块（例如jaxws和简单的前端）隔离。</p><p>请检查<a shape="rect" class="external-link" href="http://issues.apache.org/jira/secure/IssueNavigator.jspa?reset=true&mode=hide&pid=12310511&sorter/order=DESC&sorter/field=priority&resolution=-1&component=12311911">问题列表</a> ，看看您是否有兴趣解决其中一个问题。</p><p>如果您决定继续前进，那么最快的开始方法就是</p><ul><li>使用'做快速干线构建<code>mvn install -Pfastinstall</code> '</li><li>设置工作空间“ mvn -Psetup.eclipse”，它将在“工作空间”文件夹中的“ trunk”旁边创建一个工作空间</li><li>从主干导入cxf模块到工作区，并开始使用cxf-frontend-jaxrs模块</li></ul><p>如果要在构建trunk / rt / frontend / jaxrs之后提交补丁，那么还请在trunk / systests / jaxrs中运行JAX-RS系统测试：<br clear="none"><code>> mvn install</code></p><p>您也可以查看一般的“ <a shape="rect" href="http://cxf.apache.org/getting-involved.html">参与”</a>网页，以获取有关贡献的更多信息。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=70366">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=70366&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>