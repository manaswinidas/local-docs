<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Developing Assertions">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-开发断言</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="ws-support.html">WS- *支持</a> > <a href="ws-policy.html">WS-Policy</a> > <a href="developing-assertions.html">开发断言</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p>开发特定于域的断言涉及两个步骤，分别是：</p>
<ol><li>实现Assertion和AssertionBuilder接口，并向AssertionBuilderRegistry注册AssertionBuilder</li><li>以拦截器的形式或在管道或目标内部为断言提供运行时支持，并在必要时注册该支持。</li></ol>


<p>下面将更详细地概述这些步骤：</p>

<h2 id="DevelopingAssertions-ImplementingtheAssertionInterface">实施断言接口</h2>

<p>您可以选择从头开始实现Assertion接口，或者决定使用cxf-api模块中的现有Assertion实现之一，并根据需要扩展它们：</p>

<h3 id="DevelopingAssertions-PrimitiveAssertion">原始断言</h3>

<p>此类表示没有任何属性或子元素（尤其是没有嵌套的Policy元素）的断言。寻址元数据命名空间<a shape="rect" class="external-link" href="http://www.w3.org/2007/01/addressing/metadata" rel="nofollow">http://www.w3.org/2007/01/addressing/metadata</a>中的AnonymousResponses或NonAnonymousResponses断言就是这种断言的示例。该类中equal和normalize方法的实现很简单，因此不需要扩展该类。</p>

<h3 id="DevelopingAssertions-NestedPrimitiveAssertion">NestedPrimitiveAssertion</h3>

<p>此类表示不带任何属性的声明，但具有一个强制嵌套的Policy子元素。寻址元数据名称空间中的寻址断言就是这种断言的示例。equal和normalize方法的实现是通用的，因此无需扩展此类。</p>

<h3 id="DevelopingAssertions-JaxbAssertion">JaxbAssertion</h3>

<p>此类表示由已映射到Java类的xml模式类型描述的声明。RM断言以及HTTP模块中使用的断言是此类的扩展。尽管equal和normalize方法不是抽象的，但您可能想要覆盖这些方法。</p>

<h2 id="DevelopingAssertions-ImplementingandRegisteringtheAssertionBuilderInterface">实施和注册AssertionBuilder接口</h2>

<p>用于自定义断言的Assertion Builder类应实现<em>AssertionBuilder <t></t></em>接口。接口类型可以是<em>Element</em> ， <em>XMLStreamReader</em>或<em>OMElement</em> 。<br clear="none">接口包含两个方法： <em>build（）</em>和<em>getKnownElements（）</em> 。<br clear="none"><em>build（）</em>方法的实现应从传入的类型构造Assertion。它可以是<em>PrimitiveAssertion</em> （不带属性或子元素），NestedPrimitiveAssertion（不带属性，但带有嵌套的策略元素）和<em>JaxbAssertion</em> （由任何XML模式描述的声明）。<br clear="none">
<em>getKnownElements（）</em>方法必须返回可以从中建立断言的断言元素的QNames。</p>

<p>实现AssertionBuilder接口的构建方法非常简单（在JaxbAssertions的情况下，您可以扩展JaxbAssertionBuilder类，该类提供适当的JAXB上下文和一些其他有用的方法）。</p>

<p>如果您的断言表示具有属性和/或子元素的元素，则可能需要更多考虑buildCompatible的实现。</p>

<p>使用AssertionBuilderRegistry注册AssertionBuilder很容易：只需将用于AssertionBuilder的bean添加到模块的cxf- *文件或应用程序的自定义cfg文件中。</p>

<h2 id="DevelopingAssertions-ImplementingaPolicy-AwareInterceptor">实施策略感知拦截器</h2>

<p>这是为断言提供运行时支持的最简单方法。<a shape="rect" href="ws-policy-framework-overview.html">与框架交互中</a>列出的步骤1.和2.通常可以如下编码：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
package mycompany.com.interceptors;
import org.apache.cxf.ws.policy.AssertionInfoMap;

class MyPolicyAwareInterceptor {
   static final QName assertionType = new QName("http://mycompany.com}", 
       "MyType"});

   public void handleMessage(Message message) {

      // get AssertionInfoMap
       org.apache.cxf.ws.policy.AssertionInfoMap aim = 
           message.get(org.apache.cxf.ws.policy.AssertionInfoMap.class);
       Collection&lt;AssertionInfo ais&gt; = aim.get(assertionType );

       // extract Assertion information
       for (AssertionInfo ai : ais) {
           org.apache.neethi.Assertion a = ai.getAssertion();
           MyAssertionType ma = (MyAssertionType)a;
          // digest ....
       }

       // process message ...
            // express support

       for (AssertionInfo ai : ais) {
           ai.setAsserted(...);
       }          }
}
</pre>
</div></div>

<p>有时，可能会根据链（进，出，出，出故障）跨多个拦截器使用上述功能，可能会更加方便。无论如何，您还需要提供一个PolicyInterceptorProvider并声明一个相应的bean。要么从头开始实现一个，要么在api包中使用PolicyInterceptorProviderImpl并按如下所示对其进行自定义（假设所有路径都使用一个拦截器）。策略拦截器提供程序的主要任务是说，必须为指定的策略声明激活哪些拦截器：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">

&lt;bean name="MyPolicyAwareInterceptor" 
      class="mycompany.com.interceptors.MyPolicyAwareInterceptor"/&gt;

&lt;bean class="org.apache.cxf.ws.policy.PolicyInterceptorProviderImpl"&gt;
        &lt;constructor-arg&gt;
            &lt;!-- the list of assertion types supported by this 
                 PolicyInterceptorProvider --&gt;
            &lt;list&gt;
                &lt;bean class="javax.xml.namespace.QName"&gt;
                    &lt;constructor-arg value="http://mycompany.com}"/&gt;
                    &lt;constructor-arg value="MyType"/&gt;
                &lt;/bean&gt;
            &lt;/list&gt;
        &lt;/constructor-arg&gt;
        &lt;property name="inInterceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="MyPolicyAwareInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="inFaultInterceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="MyPolicyAwareInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="outInterceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="MyPolicyAwareInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="outFaultInterceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="MyPolicyAwareInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</pre>
</div></div>

<p>所有类型为PolicyInterceptorProvider的bean都会自动向框架的PolicyInterceptorProviderRegistry注册。</p>

<p>也可以从头开始以编程方式实现策略拦截器提供程序。它的构造函数将声明QNames作为超级构造函数的参数，并使用getter添加相应的拦截器：</p>

<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
public class MyInterceptorProvider extends AbstractPolicyInterceptorProvider {
    private static final long serialVersionUID = -5248428637449096540L;
    private static final MyInInterceptor IN_INTERCEPTOR = new MyInInterceptor();
    private static final MyOutInterceptor OUT_INTERCEPTOR = new MyOutInterceptor();
    private static final MyOutFaultInterceptor OUT_FAULT_INTERCEPTOR = new MyOutFaultInterceptor();
    
    private static final Collection&lt;QName&gt; ASSERTION_TYPES;
    static {
        ASSERTION_TYPES = new ArrayList&lt;QName&gt;();
        ASSERTION_TYPES.add(new QName("www.mycompany.org", "myassertion"));
    }

    public MyInterceptorProvider() {
        super(ASSERTION_TYPES);
        getInInterceptors().add(IN_INTERCEPTOR);        
        getOutInterceptors().add(OUT_INTERCEPTOR);        
        getOutFaultInterceptors().add(OUT_FAULT_INTERCEPTOR);        
    }
}
</pre>
</div></div>

<p>从2.5.2版开始，可以使用CXF总线扩展机制注册Assertion构建器和策略拦截器提供程序：只需创建一个包含以下内容的文件META-INF / cxf / bus-extensions.txt：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
org.company.MyInterceptorProvider::true
org.company.MyAssertionBuilder::true
</pre>
</div></div>
<p>最后的布尔值指定延迟加载策略。<br clear="none">CXF自动识别断言生成器和策略拦截器提供程序，并将它们存储到注册表中： <em>AssertionBuilderRegistry</em>和<em>PolicyInterceptorProviderRegistry</em> 。<br clear="none">从CXF 2.6.0开始，可以为单个声明注册多个拦截器提供程序。</p>

<h2 id="DevelopingAssertions-ImplementingaPolicy-AwareConduit/Destination">实施策略感知管道/目标</h2>

<h3 id="DevelopingAssertions-Initialisation">初始化</h3>
<p>管道/目的地可以在其构造函数中访问EndpointInfo对象。假设它们也可以访问总线，则它们可以在其生命周期中的任何时间获取端点的有效策略，如下所示：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
class MyPolicyAwareConduit {
    static final QName assertionType = new QName("http://mycompany.com}", 
        "MyType"});
    ...

    void init() {
        PolicyEngine engine = bus.getExtenation(PolicyEngine.class);
        if (null != engine &amp;&amp; engine.isEnabled()) {
        EffectiveEndpointPolicy ep = engine.getEndpointPolicy(endpoint, this);
        Collection&lt;Assertion&gt; as = ep.getChosenAlternative();
        for (Assertion a : as) {
            if (assertType.equals(a.getName()) {
                // do something with it ...
            }
       }
       ... 
    }
}
</pre>
</div></div>
<p>以及类似的目的地</p>

<h3 id="DevelopingAssertions-Policy-AwareMessageSending">策略感知消息发送</h3>

<p>授予对Message对象的访问权限，管道可以使用其send方法，以与handleMessage中的拦截器相同的方式进行处理。它可以推迟AssertionInfo对象中断言状态的更新，直到由PolicyVerificationOutInterceptor调用为止，即，在assertMessage方法中实现状态更新。如果状态更新发生在send方法本身内部，则assertMessage（至少对于出站消息而言）可以实现为无操作。</p>

<h3 id="DevelopingAssertions-ImplementingtheAssertorInterface">实施Assertor接口</h3>

<p>使用canAssert，管道/目标可以简单地通知框架是否了解给定类型的断言。另一方面，在assertMessage中，管道/目标表示对特定断言实例的支持（或缺少）。有关在POST_STREAM或PRE_INVOKE阶段中验证策略拦截器如何使用此API的描述，请参见<a shape="rect" href="how-it-works.html">验证</a> 。<br clear="none">HTTPConduit是具有策略意识的管道的范例。它支持HTTPClientPolicy类型的断言，这些断言在运行时中表示为JaxbAssertion <httpclientpolicy>对象。HTTPConduit也具有HTTPClientPolicy类型的数据成员。它实现了assertMessage，如下所示：对于出站消息，它断言<httpclientpolicy>与此数据成员兼容的所有JaxbAssertion <httpclientpolicy>。对于内置消息，所有HTTPClientPolicy断言均被断言，而不论其属性如何。这样做的理由是，HTTPClientPolicy断言的语义实际上不会对入站消息强制执行任何特定操作。<br clear="none">类似地，HTTPDestination在其入站路径上声明与为目标配置的HTTPServerPolicy声明相同的所有HTTPServerPolicy声明，并在出站路径上声明该类型的所有声明。</httpclientpolicy></httpclientpolicy></httpclientpolicy></p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
class MyPolicyAwareConduit implements Assertor {
    static final QName MYTYPE = new QName("http://mycompany.com}", 
        "MyType"});

    public boolean canAssert(QName name) {
        return MTYPE.equals(name);
    }

    public void assertMessage(Mesage message) {
        AssertionInfoMap = message.get(AssertioninfoMap.class);
        ...
    }
}
</pre>
</div></div></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=51417">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51417&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>