<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Developing a Consumer">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-开发使用者</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="frontends.html">前端</a> > <a href="jax-ws.html">JAX-WS</a> > <a href="developing-a-consumer.html">开发使用者</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="DevelopingaConsumer-DevelopingaConsumerwithCXF">用CXF开发消费者</h1><h2 id="DevelopingaConsumer-GeneratingtheStubCode">生成存根代码</h2><p>在CXF中开发服务使用者（或客户端）的起点是WSDL合同，其中包含端口类型，绑定和服务定义。然后，您可以使用<a shape="rect" href="wsdl-to-java.html">wsdl2java</a>实用程序从WSDL合同生成Java存根代码。存根代码提供了调用远程服务上的操作所需的支持代码。<br clear="none">对于CXF客户端，wsdl2java实用程序可以生成以下类型的代码：</p><ul><li>存根代码-用于实现CXF客户端的支持文件。</li><li>客户端起点代码-连接到远程服务并调用远程服务上的每个操作的示例客户端代码。</li><li>蚂蚁构建文件-一个<code>build.xml</code>旨在与ant build实用程序一起使用的文件。它具有构建和运行示例客户端应用程序的目标。</li></ul><h4 id="DevelopingaConsumer-BasicHelloWorldWSDLcontract">基本的HelloWorld WSDL合同</h4><p>下面显示了HelloWorld WSDL合同。该合同定义了单个端口类型， <code>Greeter</code> ，通过SOAP绑定， <code>Greeter_SOAPBinding</code> ，以及一项服务， <code>SOAPService</code> ，它有一个端口， <code>SoapPort</code> 。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example1"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>HelloWorld WSDL合同</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;wsdl:definitions name="HelloWorld" targetNamespace="http://apache.org/hello_world_soap_http" 
    xmlns="http://schemas.xmlsoap.org/wsdl/" 
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
    xmlns:tns="http://apache.org/hello_world_soap_http"
    xmlns:x1="http://apache.org/hello_world_soap_http/types"
    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;wsdl:types&gt;
        &lt;schema targetNamespace="http://apache.org/hello_world_soap_http/types" 
            xmlns="http://www.w3.org/2001/XMLSchema"
	    xmlns:tns="http://apache.org/hello_world_soap_http/types"
            elementFormDefault="qualified"&gt;
	    &lt;simpleType name="MyStringType"&gt;
		&lt;restriction base="string"&gt;
		    &lt;maxLength value="30" /&gt;
		&lt;/restriction&gt;
	    &lt;/simpleType&gt;

            &lt;element name="sayHi"&gt;
                &lt;complexType/&gt;
            &lt;/element&gt;
            &lt;element name="sayHiResponse"&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name="responseType" type="string"/&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
            &lt;element name="greetMe"&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name="requestType" type="tns:MyStringType"/&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
            &lt;element name="greetMeResponse"&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name="responseType" type="string"/&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
            &lt;element name="greetMeOneWay"&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name="requestType" type="string"/&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
            &lt;element name="pingMe"&gt;
                &lt;complexType/&gt;
            &lt;/element&gt;
            &lt;element name="pingMeResponse"&gt;
                &lt;complexType/&gt;
            &lt;/element&gt;
            &lt;element name="faultDetail"&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name="minor" type="short"/&gt;
                        &lt;element name="major" type="short"/&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
        &lt;/schema&gt;
    &lt;/wsdl:types&gt;
    &lt;wsdl:message name="sayHiRequest"&gt;
        &lt;wsdl:part element="x1:sayHi" name="in"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="sayHiResponse"&gt;
        &lt;wsdl:part element="x1:sayHiResponse" name="out"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="greetMeRequest"&gt;
        &lt;wsdl:part element="x1:greetMe" name="in"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="greetMeResponse"&gt;
        &lt;wsdl:part element="x1:greetMeResponse" name="out"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="greetMeOneWayRequest"&gt;
        &lt;wsdl:part element="x1:greetMeOneWay" name="in"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="pingMeRequest"&gt;
        &lt;wsdl:part name="in" element="x1:pingMe"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="pingMeResponse"&gt;
        &lt;wsdl:part name="out" element="x1:pingMeResponse"/&gt;
    &lt;/wsdl:message&gt;		
    &lt;wsdl:message name="pingMeFault"&gt;
        &lt;wsdl:part name="faultDetail" element="x1:faultDetail"/&gt;
    &lt;/wsdl:message&gt;
    
    &lt;wsdl:portType name="Greeter"&gt;
        &lt;wsdl:operation name="sayHi"&gt;
            &lt;wsdl:input message="tns:sayHiRequest" name="sayHiRequest"/&gt;
            &lt;wsdl:output message="tns:sayHiResponse" name="sayHiResponse"/&gt;
        &lt;/wsdl:operation&gt;
        
        &lt;wsdl:operation name="greetMe"&gt;
            &lt;wsdl:input message="tns:greetMeRequest" name="greetMeRequest"/&gt;
            &lt;wsdl:output message="tns:greetMeResponse" name="greetMeResponse"/&gt;
        &lt;/wsdl:operation&gt;
        
        &lt;wsdl:operation name="greetMeOneWay"&gt;
            &lt;wsdl:input message="tns:greetMeOneWayRequest" 
                name="greetMeOneWayRequest"/&gt;
        &lt;/wsdl:operation&gt;

        &lt;wsdl:operation name="pingMe"&gt;
            &lt;wsdl:input name="pingMeRequest" message="tns:pingMeRequest"/&gt;
            &lt;wsdl:output name="pingMeResponse" message="tns:pingMeResponse"/&gt;
            &lt;wsdl:fault name="pingMeFault" message="tns:pingMeFault"/&gt;
        &lt;/wsdl:operation&gt; 
    &lt;/wsdl:portType&gt;
    &lt;wsdl:binding name="Greeter_SOAPBinding" type="tns:Greeter"&gt;
        &lt;soap:binding style="document" 
             transport="http://schemas.xmlsoap.org/soap/http"/&gt;
        
        &lt;wsdl:operation name="sayHi"&gt;
            &lt;soap:operation soapAction="" style="document"/&gt;
            &lt;wsdl:input name="sayHiRequest"&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output name="sayHiResponse"&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
        
        &lt;wsdl:operation name="greetMe"&gt;
            &lt;soap:operation soapAction="" style="document"/&gt;
            &lt;wsdl:input name="greetMeRequest"&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output name="greetMeResponse"&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
        
        &lt;wsdl:operation name="greetMeOneWay"&gt;
            &lt;soap:operation soapAction="" style="document"/&gt;
            &lt;wsdl:input name="greetMeOneWayRequest"&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:input&gt;
        &lt;/wsdl:operation&gt;

        &lt;wsdl:operation name="pingMe"&gt;
            &lt;soap:operation style="document"/&gt;
            &lt;wsdl:input&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:output&gt;
            &lt;wsdl:fault name="pingMeFault"&gt;
                &lt;soap:fault name="pingMeFault" use="literal"/&gt;
            &lt;/wsdl:fault&gt;
        &lt;/wsdl:operation&gt;
        
    &lt;/wsdl:binding&gt;
    &lt;wsdl:service name="SOAPService"&gt;
        &lt;wsdl:port binding="tns:Greeter_SOAPBinding" name="SoapPort"&gt;
            &lt;soap:address 
                location="http://localhost:9000/SoapContext/SoapPort"/&gt;
        &lt;/wsdl:port&gt;
    &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;
</pre>
</div></div><p>的<code>Greeter</code>端口类型定义以下WSDL操作：</p><ul><li><code>sayHi</code> -具有单个输出参数， <code>xsd:string</code> 。</li><li><code>greetMe</code> -输入参数为<code>xsd:string</code>和输出参数<code>xsd:string</code> 。</li><li><code>greetMeOneWay</code> -具有一个输入参数， <code>xsd:string</code> 。由于此操作没有输出参数，因此CXF可以将此调用优化为单向调用（即，客户端不等待服务器的响应）。</li><li><code>pingMe</code> -没有输入参数和输出参数，但是会引发故障异常。</li></ul><p>该WSDL还定义了绑定， <code>Greeter_SOAPBinding</code> ，用于SOAP协议。实际上，绑定通常是自动生成的-例如，通过运行CXF wsdl2soap或wsdl2xml实用程序。同样， <code>SOAPService</code>通过运行CXF wsdl2service实用程序可以自动生成服务。</p><h4 id="DevelopingaConsumer-Generatingthestubcode">生成存根代码</h4><p>定义WSDL合同后，您可以使用CXF wsdl2java实用程序生成客户机代码。在命令行提示符下输入以下命令：</p><div class="panel" style="border-width:1px"><div class="panelContent">
<p><code>wsdl2java -ant -client -d <em>ClientDir</em> hello_world.wsdl</code></p>
</div></div><p>其中<em>ClientDir</em>是您要在其中放置生成的文件的目录的位置， <code>hello_world.wsdl</code>是包含上面WSDL中显示的合同的文件。的<code>-ant</code>选项生成一只蚂蚁<code>build.xml</code>文件，与ant build实用程序一起使用。的<code>-client</code>选项为客户端生成起点代码<code>main()</code>方法。</p><p>前面的wsdl2java命令生成以下Java软件包：</p><ul><li><code>org.apache.hello_world_soap_http</code> <br clear="none">此软件包名称是从<code><span class="nolink">http://apache.org/hello_world_soap_http</span></code>目标名称空间。此目标名称空间中定义的所有WSDL实体（例如，Greeter端口类型和SOAPService服务）都映射到相应Java包中的Java类。</li><li><code>org.apache.hello_world_soap_http.types</code> <br clear="none">此软件包名称是从<code><span class="nolink">http://apache.org/hello_world_soap_http/types</span></code>目标名称空间。此目标名称空间中定义的所有XML类型（即， <code>wsdl:types</code> HelloWorld合约的元素）映射到相应Java包中的Java类。</li></ul><p>wsdl2java命令生成的存根文件分为以下几类：</p><ul><li>代表WSDL实体的类（在<code>org.apache.hello_world_soap_http</code>软件包）-生成以下类来表示WSDL实体：<ul><li><code>Greeter</code>是表示Greeter WSDL端口类型的Java接口。用JAX-WS术语，此Java接口是服务端点接口。</li><li><code>SOAPService</code>是表示SOAPService WSDL的Java类<code>service</code>元件。</li><li><code>PingMeFault</code>是Java异常类（扩展<code>java.lang.Exception</code> ），代表pingMeFault WSDL <code>fault</code>元件。</li></ul></li><li>表示XML类型的类（在<code>org.apache.hello_world_soap_http.types</code>包）-在HelloWorld示例中，唯一生成的类型是请求和回复消息的各种包装。其中一些数据类型对于异步调用模型很有用。</li></ul><h2 id="DevelopingaConsumer-ImplementingaCXFClient">实施CXF客户端</h2><p>本节将介绍如何编写一个简单的Java客户端的代码，基于WSDL契约的<a shape="rect" href="developing-a-consumer.html">上方</a> 。要实现客户端，您需要使用以下存根类：</p><ul><li>服务等级（即<code>SOAPService</code> ）。</li><li>服务端点接口（即， <code>Greeter</code> ）。</li></ul><h4 id="DevelopingaConsumer-Generatedserviceclass">生成的服务等级</h4><p>下面显示了生成的服务类的典型轮廓， <code>ServiceName</code> ，扩展了<code>javax.xml.ws.Service</code>基类。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example2"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>生成的服务类的概述</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class ServiceName extends javax.xml.ws.Service {
  ...
  public ServiceName(URL wsdlLocation, QName serviceName) { }
  
  public ServiceName() { }

  public Greeter getPortName() { }
  .
  .
  .
}
</pre>
</div></div><p>的<code>ServiceName</code>类定义以下方法：</p><ul><li>构造方法-定义以下形式的构造方法：<ul><li><code><em>ServiceName</em>(URL <em>wsdlLocation</em>, QName <em>serviceName</em>)</code>根据可从<em>wsdlLocation</em>获得的WSDL合同中<em>serviceName</em>服务中的数据构造一个服务对象。</li><li><code><em>ServiceName</em>()</code>是默认的构造函数，该构造函数根据生成存根代码时提供的服务名称和WSDL协定来构造服务对象（例如，在运行CXF wsdl2java命令时）。使用此构造函数的前提是WSDL合同在其原始位置仍然可用。</li></ul></li><li><code>get_PortName_()</code>方法-对于<em>ServiceName</em>服务上定义的每个<em>PortName</em>端口，CXF都会生成一个对应的<code>get_PortName_()</code> Java中的方法。因此， <code>wsdl:service</code>定义多个端口的元素将生成具有多个端口的服务类<code>get_PortName_()</code>方法。</li></ul><h4 id="DevelopingaConsumer-Serviceendpointinterface">服务端点接口</h4><p>对于原始WSDL合同中定义的每种端口类型，您都可以使用Java生成相应的服务端点接口。服务端点接口是WSDL端口类型的Java映射。原始WSDL端口类型中定义的每个操作都映射到服务端点接口中的相应方法。该操作的参数映射如下：</p><ol><li>输入参数映射到方法参数。</li><li>第一个输出参数映射到一个返回值。</li><li>如果有多个输出参数，则第二个及后续输出参数将映射到方法参数（此外，必须使用Holder类型传递这些参数的值）。</li></ol><p>例如，下面显示了Greeter服务端点接口，该接口是根据<a shape="rect" href="developing-a-consumer.html">＃Example1中</a>定义的Greeter端口类型生成的。为简单起见， <a shape="rect" href="developing-a-consumer.html">＃Example3</a>省略了标准的JAXB和JAX-WS批注。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example3"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>迎宾服务端点接口</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">/* Generated by WSDLToJava Compiler. */

package org.objectweb.hello_world_soap_http;
  ...
public interface Greeter {
  public java.lang.String sayHi();
  
  public java.lang.String greetMe(java.lang.String requestType);

  public void greetMeOneWay(java.lang.String requestType);

  public void pingMe() throws PingMeFault;
}
</pre>
</div></div><h4 id="DevelopingaConsumer-Clientmainfunction">客户端主要功能</h4><p>这是实现HelloWorld客户端的Java代码。总之，客户端连接到<code>SoapPort</code>上的端口<code>SOAPService</code>服务，然后继续调用该服务支持的每个操作<code>Greeter</code>端口类型。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example4"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>客户实施代码</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package demo.hw.client;

import java.io.File;
import java.net.URL;
import javax.xml.namespace.QName;
import org.apache.hello_world_soap_http.Greeter;
import org.apache.hello_world_soap_http.PingMeFault;
import org.apche.hello_world_soap_http.SOAPService;

public final class Client {

  private static final QName SERVICE_NAME = 
    new QName("http://apache.org/hello_world_soap_http", 
    "SOAPService");

  private Client() { }

  public static void main(String args[]) throws Exception {
    if (args.length == 0) {
      System.out.println("please specify wsdl");
      System.exit(1);
    }

    URL wsdlURL;
    File wsdlFile = new File(args[0]);
    if (wsdlFile.exists()) {
      wsdlURL = wsdlFile.toURL();
    } else {
      wsdlURL = new URL(args[0]);
    }

    System.out.println(wsdlURL);
    SOAPService ss = new SOAPService(wsdlURL, SERVICE_NAME);
    Greeter port = ss.getSoapPort();
    String resp;

    System.out.println("Invoking sayHi...");
    resp = port.sayHi();
    System.out.println("Server responded with: " + resp);
    System.out.println();

    System.out.println("Invoking greetMe...");
    resp = port.greetMe(System.getProperty("user.name"));
    System.out.println("Server responded with: " + resp);
    System.out.println();

    System.out.println("Invoking greetMeOneWay...");
    port.greetMeOneWay(System.getProperty("user.name"));
    System.out.println("No response from server as method is OneWay");
    System.out.println();

    try {
      System.out.println("Invoking pingMe, expecting exception...");
      port.pingMe();
    } catch (PingMeFault ex) {
      System.out.println("Expected exception: PingMeFault has occurred.");
      System.out.println(ex.toString());
    }
    System.exit(0);
  }
}
</pre>
</div></div><p>的<code>Client.main()</code>函数进行如下：</p><ol><li>CXF运行时是隐式初始化的-也就是说，只要加载了CXF运行时类。因此，无需调用特殊函数即可初始化CXF。</li><li>客户端需要一个字符串参数，该参数提供HelloWorld的WSDL合同的位置。WSDL位置存储在<code>wsdlURL</code> 。</li><li><p>分两个步骤创建一个新的端口对象（使您可以访问远程服务器端点），如以下代码片段所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SOAPService ss = new SOAPService(wsdlURL, SERVICE_NAME);
Greeter port = ss.getSoapPort();</pre>
</div></div><p>要创建新的端口对象，您首先要创建一个服务对象（传递WSDL位置和服务名称），然后调用适当的对象。 <code>get <em>PortName</em> ()</code>获得所需特定端口的实例的方法。在这种情况下， <code>SOAPService</code>服务仅支持<code>SoapPort</code>端口，属于<code>Greeter</code>类型。</p></li><li>客户端继续调用支持的每个方法<code>Greeter</code>服务端点接口。</li><li>在这种情况下<code>pingMe()</code>操作，示例代码显示了如何捕获<code>PingMeFault</code>故障异常。</li></ol><h2 id="DevelopingaConsumer-SettingConnectionPropertieswithContexts">使用上下文设置连接属性</h2><p>您可以使用JAX-WS上下文来自定义客户端代理的属性。特别是，上下文可用于修改连接属性并在协议标头中发送数据。例如，您可以使用上下文将SOAP标头添加到请求消息或响应消息。客户端支持以下类型的上下文：</p><ul><li><strong>请求上下文</strong> -在客户端，请求上下文使您可以设置影响出站消息的属性。请求上下文属性将应用于特定的端口实例，并且一旦设置，该属性就会影响在该端口上进行的每个后续操作调用，直到明确清除该属性为止。例如，您可以使用请求上下文属性来设置连接超时或初始化要在标头中发送的数据。</li><li><strong>响应上下文</strong> -在客户端，您可以访问响应上下文以从上次操作调用中读取入站消息设置的属性值。每次操作调用后都会重置响应上下文属性。例如，您可以访问响应上下文属性以读取从最后一个入站消息接收到的标头信息。</li></ul><h4 id="DevelopingaConsumer-Settingarequestcontext">设置请求上下文</h4><p>要将特定的请求上下文属性<em>ContextPropertyName</em>设置为<em>PropertyValue</em> ，请使用此处显示的代码：</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example4"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>在客户端设置请求上下文属性</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Set request context property.
java.util.Map&lt;String, Object&gt; requestContext =
  ((javax.xml.ws.BindingProvider)port).getRequestContext();
requestContext.put(ContextPropertyName, PropertyValue);

// Invoke an operation.
port.SomeOperation();
</pre>
</div></div><p>您必须将端口对象强制转换为<code>javax.xml.ws.BindingProvider</code>为了访问请求上下文。请求上下文本身是类型， <code>java.util.Map<String, Object></code> ，这是一个哈希图，其键为<code>String</code>和任意类型的值。使用<code>java.util.Map.put()</code>在哈希图中创建一个新条目。</p><h4 id="DevelopingaConsumer-Readingaresponsecontext">阅读响应上下文</h4><p>要检索特定的响应上下文属性<em>ContextPropertyName</em> ，请使用此处显示的代码：</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example5"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>在客户端读取响应上下文属性</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Invoke an operation.
port.SomeOperation();

// Read response context property.
java.util.Map&lt;String, Object&gt; responseContext =
  ((javax.xml.ws.BindingProvider)port).getResponseContext();
PropertyType propValue = (PropertyType) responseContext.get(ContextPropertyName);
</pre>
</div></div><p>响应上下文是类型， <code>java.util.Map<String, Object></code> ，这是具有类型为key的哈希映射<code>String</code>和任意类型的值。使用<code>java.util.Map.get()</code>访问响应上下文属性的哈希图中的条目。</p><h4 id="DevelopingaConsumer-Supportedcontexts">支持的上下文</h4><p>CXF支持以下上下文属性：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>上下文属性名称</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>上下文属性类型</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>org.apache.cxf.ws.addressing.JAXWSAConstants.CLIENT_ADDRESSING_PROPERTIES</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p><code>org.apache.cxf.ws.addressing.AddressingProperties</code></p></td></tr></tbody></table></div><h2 id="DevelopingaConsumer-AsynchronousInvocationModel">异步调用模型</h2><p>除了通常的同步调用方式之外，CXF还支持两种形式的异步调用，如下所示：</p><ul><li><strong>轮询方法</strong> -在这种情况下，要调用远程操作，您将调用一个没有输出参数的特殊方法，但是会返回一个<code>javax.xml.ws.Response</code>实例。的<code>Response</code>对象（继承自<code>javax.util.concurrency.Future</code>接口）可以被轮询以检查响应消息是否已到达。</li><li><strong>回调方法</strong> -在这种情况下，要调用远程操作，您可以调用另一个特殊方法，该方法引用一个回调对象（ <code>javax.xml.ws.AsyncHandler</code>类型）作为其参数之一。每当响应消息到达客户端时，CXF运行时都会在<code>AsyncHandler</code>对象以向其提供响应消息的内容。</li></ul><p>这两种异步调用方法均在此处进行描述，并通过代码示例进行说明。</p><h4 id="DevelopingaConsumer-Contractforasynchronousexample">异步示例合同</h4><p>下面的示例显示了用于异步示例的WSDL协定。合同定义了单个端口类型， <code>GreeterAsync</code> ，其中包含一个操作， <code>greetMeSometime</code> 。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example6"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>HelloWorld WSDL异步示例合同</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;wsdl:definitions xmlns="http://schemas.xmlsoap.org/wsdl/"
           xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
           xmlns:tns="http://apache.org/hello_world_async_soap_http"
           xmlns:x1="http://apache.org/hello_world_async_soap_http/types"
           xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
           xmlns:xsd="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://apache.org/hello_world_async_soap_http"
           name="HelloWorld"&gt;
    &lt;wsdl:types&gt;
        &lt;schema targetNamespace="http://apache.org/hello_world_async_soap_http/types"
           xmlns="http://www.w3.org/2001/XMLSchema"
           xmlns:x1="http://apache.org/hello_world_async_soap_http/types"
           elementFormDefault="qualified"&gt;
            &lt;element name="greetMeSometime"&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name="requestType" type="xsd:string"/&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;
            &lt;element name="greetMeSometimeResponse"&gt;
                &lt;complexType&gt;
                    &lt;sequence&gt;
                        &lt;element name="responseType" type="xsd:string"/&gt;
                    &lt;/sequence&gt;
                &lt;/complexType&gt;
            &lt;/element&gt;      
        &lt;/schema&gt;
    &lt;/wsdl:types&gt;
    &lt;wsdl:message name="greetMeSometimeRequest"&gt;
        &lt;wsdl:part name="in" element="x1:greetMeSometime"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:message name="greetMeSometimeResponse"&gt;
        &lt;wsdl:part name="out" element="x1:greetMeSometimeResponse"/&gt;
    &lt;/wsdl:message&gt;
    &lt;wsdl:portType name="GreeterAsync"&gt;
        &lt;wsdl:operation name="greetMeSometime"&gt;
            &lt;wsdl:input name="greetMeSometimeRequest" 
                message="tns:greetMeSometimeRequest"/&gt;
            &lt;wsdl:output name="greetMeSometimeResponse" 
                message="tns:greetMeSometimeResponse"/&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:portType&gt;
    &lt;wsdl:binding name="GreeterAsync_SOAPBinding" type="tns:GreeterAsync"&gt;
        &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
        &lt;wsdl:operation name="greetMeSometime"&gt;
            &lt;soap:operation style="document"/&gt;
            &lt;wsdl:input&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:input&gt;
            &lt;wsdl:output&gt;
                &lt;soap:body use="literal"/&gt;
            &lt;/wsdl:output&gt;
        &lt;/wsdl:operation&gt;
    &lt;/wsdl:binding&gt;
    &lt;wsdl:service name="SOAPService"&gt;
        &lt;wsdl:port name="SoapPort" binding="tns:GreeterAsync_SOAPBinding"&gt;
            &lt;soap:address 
                location="http://localhost:9000/SoapContext/SoapPort"/&gt;
        &lt;/wsdl:port&gt;
    &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;
</pre>
</div></div><h4 id="DevelopingaConsumer-Generatingtheasynchronousstubcode">生成异步存根代码</h4><p>异步调用方式需要额外的存根代码（例如，在服务端点接口上定义的专用异步方法）。但是，默认情况下不会生成此特殊存根代码。要打开异步功能并生成必需的存根代码，必须使用WSDL 2.0规范中的映射定制功能。</p><p>通过定制，您可以修改wsdl2java实用程序生成存根代码的方式。特别是，它使您能够修改WSDL到Java的映射并打开某些功能。在此，自定义用于打开异步调用功能。使用绑定声明指定自定义，您可以使用<code>jaxws:bindings</code>标记（jaxws前缀与<code><span class="nolink">http://java.sun.com/xml/ns/jaxws</span></code>命名空间）。指定绑定声明有两种方法：</p><ul><li><strong>外部绑定声明</strong> - <code>jaxws:bindings</code>元素是在与WSDL合同分开的文件中定义的。在生成存根代码时，可以将绑定声明文件的位置指定给wsdl2java实用程序。</li><li><strong>嵌入式绑定声明</strong> -您也可以嵌入<code>jaxws:bindings</code>元素直接在WSDL合同中，将其视为WSDL扩展。在这种情况下， <code>jaxws:bindings</code>仅适用于直接父元素。</li></ul><p>本节仅考虑第一种方法，即外部绑定声明。接下来显示了一个用于打开异步调用的绑定声明文件的模板：</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example7"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>异步绑定声明的模板</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bindings xmlns:xsd="http://www.w3.org/2001/XMLSchema"
          xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
          wsdlLocation="&lt;at:var at:name="WSDL_LOCATION" /&gt;/hello_world_async.wsdl"
          xmlns="http://java.sun.com/xml/ns/jaxws"&gt;
  &lt;bindings node="wsdl:definitions"&gt;
    &lt;enableAsyncMapping&gt;true&lt;/enableAsyncMapping&gt;
  &lt;/bindings&gt;
&lt;/bindings&gt;
</pre>
</div></div><p>其中<em>AffectedWSDLContract</em>指定<em>受此</em>绑定声明影响的WSDL合同的URL。<em>AffectedNode</em>是一个XPath值，它指定此绑定声明影响WSDL合同中的哪个节点。您可以将<em>AffectedNode</em>设置为<code>wsdl:definitions</code> ，如果您希望整个WSDL合同都受到影响。{jaxws：enableAsyncMapping}}元素设置为<code>true</code>启用异步调用功能。</p><p>例如，如果您只想为<code>GreeterAsync</code>端口类型，您可以指定<code><bindings node="wsdl:definitions/wsdl:portType<u><a shape="rect" class="unresolved" href="#">@name='GreeterAsync'</a></u>"></code>在前面的绑定声明中。</p><p>假设绑定声明存储在文件中， <code>async_binding.xml</code> ，您可以通过输入以下wsdl2java命令来生成具有异步支持的必需的存根文件：</p><div class="panel" style="border-width:1px"><div class="panelContent">
<p><code>wsdl2java -ant -client -d ClientDir -b async_binding.xml hello_world.wsdl</code></p>
</div></div><p>运行wsdl2java命令时，可以使用-b选项指定绑定声明文件的位置。以这种方式生成存根代码后， <code>GreeterAsync</code>服务端点接口（在文件中<code>GreeterAsync.java</code> ）的定义如下所示：</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example8"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>服务端点接口以及用于异步调用的方法</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">/* Generated by WSDLToJava Compiler. */
package org.apache.hello_world_async_soap_http;
...
import java.util.concurrent.Future;
import javax.xml.ws.AsyncHandler;
import javax.xml.ws.Response;
...
public interface GreeterAsync {

  public Future&lt;?&gt; greetMeSometimeAsync(
    String requestType,
    AsyncHandler&lt;org.myorg.types.GreetMeSometimeResponse&gt; asyncHandler
  );

  public Response&lt;org.myorg.types.GreetMeSometimeResponse&gt; greetMeSometimeAsync(
     String requestType);

  public java.lang.String greetMeSometime(
     String requestType
  );
}
</pre>
</div></div><p>除了通常的同步方法之外， <code>greetMeSometime()</code> ，还会为<code>greetMeSometime</code>操作如下：</p><ul><li><code>greetMeSometimeAsync()</code>方法<code>Future<?></code>返回类型和一个额外的<code>javax.xml.ws.AsyncHandler</code>参数-调用此方法以进行异步调用的回调方法。</li><li><code>greetMeSometimeAsync()</code>方法<code>Response<GreetMeSometimeResponse></code>返回类型-为异步调用的轮询方法调用此方法。</li></ul><p>以下小节将讨论回调方法和轮询方法的详细信息。</p><h4 id="DevelopingaConsumer-Implementinganasynchronousclientwiththepollingapproach">使用轮询方法实现异步客户端</h4><p>下面的示例说明了进行异步操作调用的轮询方法。客户端使用这种方法通过调用特殊的Java方法来调用操作， <code>_OperationName_Async()</code> ，则返回一个<code>javax.xml.ws.Response<T></code>对象，其中T是操作的响应消息的类型。的<code>Response<T></code>可以在以后的阶段轮询对象，以检查操作的响应消息是否到达。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example9"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>异步操作调用的轮询方法</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package demo.hw.client;

import java.io.File;
import java.util.concurrent.Future;

import javax.xml.namespace.QName;
import javax.xml.ws.Response;

import org.apache.hello_world_async_soap_http.GreeterAsync;
import org.apache.hello_world_async_soap_http.SOAPService;
import org.apche.hello_world_async_soap_http.types.GreetMeSometimeResponse;

public final class Client {
  private static final QName SERVICE_NAME
    = new QName("http://objectweb.org/hello_world_async_soap_http", "SOAPService");

  private Client() {}

  public static void main(String args[]) throws Exception {
    ...
    // Polling approach:
    Response&lt;GreetMeSometimeResponse&gt; greetMeSomeTimeResp =
      port.greetMeSometimeAsync(System.getProperty("user.name"));
    while (!greetMeSomeTimeResp.isDone()) {
      Thread.sleep(100);
    }
    GreetMeSometimeResponse reply = greetMeSomeTimeResp.get();
    ...
    System.exit(0);
  }
}
</pre>
</div></div><p>的<code>greetMeSometimeAsync()</code>方法调用<code>greetMeSometimes</code>操作，将输入参数传输到远程服务，并返回对<code>javax.xml.ws.Response<GreetMeSometimeResponse></code>宾语。的<code>Response</code>通过扩展标准定义类<code>java.util.concurrency.Future<T></code>接口，专门用于轮询并发线程执行的工作结果。基本上有两种使用<code>Response</code>宾语：</p><ul><li><p><strong>非阻塞轮询</strong> -尝试获取结果之前，请通过调用<strong>非阻塞轮询</strong>来检查响应是否到达<br clear="none"> <code>Response<T>.isDone()</code>方法。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response&lt;GreetMeSometimeResponse&gt; greetMeSomeTimeResp = ...;

if (greetMeSomeTimeResp.isDone()) {
  GreetMeSometimeResponse reply = greetMeSomeTimeResp.get();
}
</pre>
</div></div></li><li><p><strong>阻止轮询</strong> -呼叫<code>Response<T>.get()</code>立即阻止，直到响应到达为止（可选地指定超时）。例如，以60秒的超时来轮询响应：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Response&lt;GreetMeSometimeResponse&gt; greetMeSomeTimeResp = ...;

GreetMeSometimeResponse reply = greetMeSomeTimeResp.get(
  60L,
  java.util.concurrent.TimeUnit.SECONDS
);
</pre>
</div></div></li></ul><h4 id="DevelopingaConsumer-Implementinganasynchronousclientwiththecallbackapproach">使用回调方法实现异步客户端</h4><p>进行异步操作调用的另一种方法是通过从<code>javax.xml.ws.AsyncHandler</code>接口。该回调类必须实现一个<code>handleResponse()</code>方法，由CXF运行时调用以通知客户端响应已到达。以下显示了<code>AsyncHandler</code>您需要实现的接口。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example10"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>javax.xml.ws。AsyncHandler接口</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package javax.xml.ws;

public interface AsyncHandler&lt;T&gt;
{
  void handleResponse(Response&lt;T&gt; res);
}
</pre>
</div></div><p>在此示例中，一个回调类， <code>TestAsyncHandler</code>定义如下。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example11"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>TestAsyncHandler回调类</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package demo.hw.client;

import javax.xml.ws.AsyncHandler;
import javax.xml.ws.Response;

import org.apache.hello_world_async_soap_http.types.GreetMeSometimeResponse;

public class TestAsyncHandler implements AsyncHandler&lt;GreetMeSometimeResponse&gt; {
  private GreetMeSometimeResponse reply;

  public void handleResponse(Response&lt;GreetMeSometimeResponse&gt; response) {
    try {
      reply = response.get();
    } catch (Exception ex) {
      ex.printStackTrace();
    }
  }

  public String getResponse() {
    return reply.getResponseType();
  }
}
</pre>
</div></div><p>实施<code>handleResponse()</code> <a shape="rect" href="developing-a-consumer.html">＃Example11中显示的内容</a>只是获取响应数据并将其存储在成员变量中， <code>reply</code> 。额外的<code>getResponse()</code>方法只是提取唯一输出参数（即， <code>responseType</code> ）的回应。</p><p><a shape="rect" href="developing-a-consumer.html">＃Example12</a>说明了进行异步操作调用的回调方法。客户端使用这种方法通过调用特殊的Java方法来调用操作， <code>_OperationName_Async()</code> ，则返回一个<code>java.util.concurrency.Future<?></code>对象并采用额外的参数<code>AsyncHandler<T></code> 。</p><p><span class="confluence-anchor-link" id="DevelopingaConsumer-Example12"></span></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>异步操作调用的回调方法</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package demo.hw.client;

import java.io.File;
import java.util.concurrent.Future;

import javax.xml.namespace.QName;
import javax.xml.ws.Response;

import org.apache.hello_world_async_soap_http.GreeterAsync;
import org.apache.hello_world_async_soap_http.SOAPService;
import org.apache.hello_world_async_soap_http.types.GreetMeSometimeResponse;

public final class Client {
  private static final QName SERVICE_NAME
    = new QName("http://apache.org/hello_world_async_soap_http", "SOAPService");

  private Client() {}

  public static void main(String args[]) throws Exception {
    ...
    // Callback approach
    TestAsyncHandler testAsyncHandler = new TestAsyncHandler();
    System.out.println("Invoking greetMeSometimeAsync using callback object...");
    Future&lt;?&gt; response = port.greetMeSometimeAsync(System.getProperty("user.name"), testAsyncHandler);
    while (!response.isDone()) {
      Thread.sleep(100);
    }
    resp = testAsyncHandler.getResponse();
    ...
    System.exit(0);
  }
}
</pre>
</div></div><p>的<code>Future<?></code>传回的物件<code>greetMeSometimeAsync()</code>只能用于测试响应是否已经到达-例如，通过调用<code>response.isDone()</code> 。响应的值仅对回调对象可用， <code>testAsyncHandler</code> 。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=27179">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=27179&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>