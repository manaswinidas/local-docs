<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Client API">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS客户端API</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-client-api.html">JAX-RS客户端API</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p> <span style="font-size:2em;font-weight:bold">JAX-RS：客户端API</span>


 </p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1552503433924 {padding: 0px;}
div.rbtoc1552503433924 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1552503433924 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1552503433924">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-MavenDependency">Maven依赖</a></li><li><a shape="rect" href="#JAX-RSClientAPI-JAX-RS2.0ClientAPI">JAX-RS 2.0客户端API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-JAX-RS2.0andCXFspecificAPI">JAX-RS 2.0和CXF特定的API</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSClientAPI-Proxy-basedAPI">基于代理的API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-Customizingproxies">定制代理</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConvertingproxiestoWebClientsandviceversa">将代理转换为Web客户端，反之亦然</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Handlingexceptions">处理异常</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringproxiesinSpring">在Spring中配置代理</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Injectingproxies">注入代理</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Asynchronousproxyinvocations">异步代理调用</a></li><li><a shape="rect" href="#JAX-RSClientAPI-BufferingResponses">缓冲响应</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Limitations">局限性</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Workingwithusermodels">使用用户模型</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSClientAPI-CXFWebClientAPI">CXF WebClient API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-Asynchronousinvocations">异步调用</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Workingwithexplicitcollections">使用显式集合</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Handlingexceptions.1">处理异常</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringHTTPclientsinSpring">在Spring中配置HTTP客户端</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSClientAPI-XML-centricclients">以XML为中心的客户端</a></li><li><a shape="rect" href="#JAX-RSClientAPI-SupportforarbitraryHTTPmethodsforsyncinvocations.">支持用于同步调用的任意HTTP方法。</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ThreadSafety">线程安全</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringClientsatRuntime">在运行时配置客户端</a></li><li><a shape="rect" href="#JAX-RSClientAPI-CreatingclientsprogrammaticallywithnoSpringdependencies">以编程方式创建没有Spring依赖项的客户端</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringanHTTPConduitfromSpring">从Spring配置HTTP管道</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ClientsandAuthentication">客户端和认证</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ClientsinSpringBoot">Spring Boot中的客户端</a></li></ul>
</div><h1 id="JAX-RSClientAPI-MavenDependency">Maven依赖</h1><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-rs-client&lt;/artifactId&gt;
  &lt;version&gt;3.0.15&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><p>在CXF 2.7.x中，不支持JAX-RS 2.0客户端API，并且在cxf-rt-frontend-jaxrs模块中位于CXF特定的客户端API中。</p><p>需要CXF基于Apache HttpClient的传输才能使异步调用正常工作：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-transports-http-hc&lt;/artifactId&gt;
  &lt;!-- 2.7.8 or 3.0.15 --&gt; 
  &lt;version&gt;${cxf.version}&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><h1 id="JAX-RSClientAPI-JAX-RS2.0ClientAPI">JAX-RS 2.0客户端API</h1><p>CXF 3.0.0实现了JAX-RS 2.0客户端API。在内部，它是根据CXF特定的WebClient实施的。</p><p><a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/index.html" rel="nofollow">javax.ws.rs.client</a>提供了JAX-RS 2.0客户端API的工作原理的简短概述。</p><p>通常，从<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/ClientBuilder.html" rel="nofollow">ClientBuilder</a>开始以创建<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Client.html" rel="nofollow">Client</a> 。<br clear="none">接下来将创建<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/WebTarget.html" rel="nofollow">WebTarget</a> ，并根据需要进一步自定义。</p><p>接下来， <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Invocation.Builder.html" rel="nofollow">调用。构建器</a>被初始化，并且可以使用<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/SyncInvoker.html" rel="nofollow">SyncInvoker</a>方法之一立即发出请求，而构建器直接实现SyncInvoker。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Client client = ClientBuilder.newBuilder().newClient();
WebTarget target = client.target("http://localhost:8080/rs");
target = target.path("service").queryParam("a", "avalue");

Invocation.Builder builder = target.request();
Response response = builder.get();
Book book = builder.get(Book.class);

</pre>
</div></div><p>如果愿意的话，上述序列可以很容易地折叠成一个单一的代码序列。<br clear="none">请注意，SyncInvoker（和AsyncInvoker）期望<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Entity.html" rel="nofollow">Entity</a>代表请求主体。</p><p>调用。Builder通过其build（...）方法具有<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Invocation.html" rel="nofollow">调用</a>的快捷方式，以进一步自定义调用。</p><p>调用。Builder.async（）链接到AsyncInvoker。</p><p>Client和WebTarget都可以单独配置，实现<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/Configurable.html" rel="nofollow">Configurable</a>接口，可以接受提供者和属性并返回<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/Configuration.html" rel="nofollow">Configuration</a> 。通过ClientBuilder.withConfig方法直接或间接配置客户端会影响给定客户端产生的所有WebClient。</p><h2 id="JAX-RSClientAPI-JAX-RS2.0andCXFspecificAPI">JAX-RS 2.0和CXF特定的API</h2><p>CXF代理和WebClient客户端代码已经过改进，以支持JAX-RS 2.0客户端过滤器，读取器和写入器拦截器，新的异常类和Response API。</p><p>WebClient提供了JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/AsyncInvoker.html" rel="nofollow">AsyncInvoker</a>和<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/SyncInvoker.html" rel="nofollow">SyncInvoker</a>界面的快捷方式。</p><p>WebClient.getConfig（Object client）支持JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/WebTarget.html" rel="nofollow">WebTarget</a>和<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Invocation.Builder.html" rel="nofollow">Invocation。用于2.0客户端的Builder</a>能够进入较低级别的CXF配置并设置诸如“ receiveTimeout”等属性。</p><h1 id="JAX-RSClientAPI-Proxy-basedAPI">基于代理的API</h1><p>使用基于代理的API，可以在客户端重用接口或什至已经设计用于在服务器端处理HTTP请求的资源类（请注意， <a shape="rect" class="external-link" href="http://cglib.sourceforge.net/" rel="nofollow">cglib</a> -nodeps依赖项将需要在服务器端可用）从具体类创建的代理的类路径）。当在客户端重用时，它们只是充当远程代理。</p><p><a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactory.java">JAXRSClientFactory</a>是包装<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java">JAXRSClientFactoryBean</a>的实用程序类。JAXRSClientFactory提供了许多实用程序方法，但如果需要，也可以直接使用JAXRSClientFactoryBean。</p><p>例如，给定这些类定义：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/bookstore")
public interface BookStore {
   @GET
   Books getAllBooks();
   
   @Path("{id}")
   BookResource getBookSubresource(@PathParam("id") long id) throws NoBookFoundException;
}

public class BookStoreImpl implements BookStore {
   public Books getAllBooks() {}
   
   public BookResource getBookSubresource(long id) throws NoBookFoundException {}
}

public interface BookResource {
   @GET
   Book getBook();
}

public class BookResourceImpl implements BookResource {
   Book getBook() {}
}

</pre>
</div></div><p>以下客户端代码检索ID为'1'的Book和一系列图书：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore store = JAXRSClientFactory.create("http://bookstore.com", BookStore.class);
// (1) remote GET call to http://bookstore.com/bookstore
Books books = store.getAllBooks();
// (2) no remote call
BookResource subresource = store.getBookSubresource(1);
// {3} remote GET call to http://bookstore.com/bookstore/1
Book b = subresource.getBook();
</pre>
</div></div><p>创建代理时，最初或调用子资源方法时，将使用相应的@ Path，@ PathParam，@ QueryParam或@MatrixParam值来更新当前URI，而@HttpHeader和@CookieParam值将构成当前的HTTP标头集。在完成远程调用之前，也会发生相同的情况。</p><p>重要的是要理解，严格来说，客户端上的给定方法与服务器端上的给定方法之间没有直接关系。代理的工作是根据给定的类和方法规范构造一个正确的URI-可能是也可能不是与将被调用的相应服务器类上的方法相同的方法（当然，它是带有JAX-RS注释的服务器）资源类-但事实并非如此！）通常，每当在相应的远程代理上调用相同的方法时，就会在服务器资源类上看到方法foo（）的调用-但是，如果存在带有任意正则表达式的@Path批注，则无法保证，但是没关系，因为最重要的是代理将产生正确的URI，并将按服务器类的<strong>预期</strong>进行匹配。</p><p>客户端MessageBodyReaders和MessageBodyWriters用于处理请求或响应主体，就像它们在服务器端所做的一样。更具体地说，只要将远程方法参数假定为请求正文（即，没有附加JAX-RS批注），或者在@FormParams或JAX的帮助下模拟表单提交时，就会调用方法主体编写器。 -RS MultivaluedMap。</p><p>您可以在同一代理（初始资源或子资源）上进行多个远程调用，当前URI和标头将针对每个调用正确更新。</p><p>例如，如果您想代理诸如BookStoreImpl之类的具体类（例如您不能提取接口），则将cglib-nodeps.jar放在类路径上。此类必须具有默认构造函数。所有与JAX-RS无关的方法都只会在客户端被忽略，并标记为不支持。</p><h2 id="JAX-RSClientAPI-Customizingproxies">定制代理</h2><p>代理最终不仅实现代理创建时请求的接口，还实现<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/Client.java">客户端</a>接口。在许多情况下，不需要显式指定常用的HTTP标头（例如Content-Type或Accept），因为此信息很可能可以从@Consumes或@Produces批注中获得。同时，您可以显式设置这些标头中的任何一个，或者实际上是其他一些标头。您可以使用简单的<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java">WebClient</a>实用程序方法将代理转换为基本客户端：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
WebClient.client(proxy).accept("text/xml");
// continue using the proxy    
</pre>
</div></div><p>您还可以检查当前的标头集，当前和基本URI以及客户端响应。</p><h2 id="JAX-RSClientAPI-ConvertingproxiestoWebClientsandviceversa">将代理转换为Web客户端，反之亦然</h2><p>使用代理仅仅是使用服务的一种方式。代理隐藏了如何构成URI的细节，而以HTTP为中心的WebClient提供了显式的URI创建功能。代理和http客户端都依赖于相同的基本信息（例如标头和当前URI），因此您可以随时从现有代理中创建WebClient实例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
Client client = WebClient.client(proxy);
WebClient httpClient = WebClient.fromClient(client);
// continue using the http client    
</pre>
</div></div><p>您也可以随时将http客户端转换为代理：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy1 = JAXRSClientFactory.create("http://books", BookStore.class);
Client client = WebClient.client(proxy1);
BookStore proxy2 = JAXRSClientFactory.fromClient(client, BookStore.class);
</pre>
</div></div><h2 id="JAX-RSClientAPI-Handlingexceptions">处理异常</h2><p>您可以通过两种方式处理代理的远程异常。<br clear="none">一种方法是使用jaxrs：client或使用相应的JAXRSClientFactory实用程序方法从Spring将<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/ResponseExceptionMapper.java">ResponseExceptionMapper</a>注册为提供程序。这样，您可以根据需要将远程错误代码映射到预期的检查异常或运行时异常。</p><p>如果在远程调用失败时没有可用的ResponseExceptionMapper，则为javax.ws.rs的实例。将引发WebApplicationException（请注意org.apache.cxf.jaxrs.client。ServerWebApplicationException用于表示CXF 2.7.0之前的服务器异常。此时，您可以检查实际的响应并从此处继续：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
try {
    proxy.getBook();
} catch(WebApplicationException ex) {
  Response r = ex.getResponse();
  String message = ex.getMessage();
}
</pre>
</div></div><p>javax.ws.rs。如果由于以下两个原因之一而发生异常，将抛出ProcessingException：</p><ul class="alternate"><li>远程调用成功，但在客户端未找到正确的MessageBodyReader；在这种情况下，表示调用结果的Response对象仍然可用</li><li>远程调用由于客户端的原因而失败，例如，没有MessageBodyWriter。</li></ul><p>注意org.apache.cxf.jaxrs.client。ClientWebApplicationException用于表示CXF 2.7.0之前的客户端处理异常。</p><h2 id="JAX-RSClientAPI-ConfiguringproxiesinSpring">在Spring中配置代理</h2><p>使用JAXRSClientFactory创建代理时，可以将Spring配置位置作为参数之一传递。或者，您可以使用Spring配置创建默认总线，然后所有代理都会选择它：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SpringBusFactory bf = new SpringBusFactory();
Bus bus = bf.createBus("org/apache/cxf/systest/jaxrs/security/jaxrs-https.xml");
BusFactory.setDefaultBus(bus);
// BookStore proxy will get the configuration from Spring
BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
</pre>
</div></div><h2 id="JAX-RSClientAPI-Injectingproxies">注入代理</h2><p>要通过spring上下文注入代理，请使用jaxrs：client元素，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:client id="restClient"
    address="http://localhost:${testutil.ports.BookServerRestSoap}/test/services/rest"
    serviceClass="org.apache.cxf.systest.jaxrs.BookStoreJaxrsJaxws"
    inheritHeaders="true"&gt;
    &lt;jaxrs:headers&gt;
        &lt;entry key="Accept" value="text/xml"/&gt;
    &lt;/jaxrs:headers&gt;
&lt;/jaxrs:client&gt;  
</pre>
</div></div><p>有关如何使用jaxrs：client注入代理的完整示例，请参见此<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs_soap_rest/WEB-INF/beans.xml" rel="nofollow">bean</a> 。注意，WebClient也可以作为jaxrs：client注入。</p><p> </p><h2 id="JAX-RSClientAPI-Asynchronousproxyinvocations">异步代理调用</h2><p>从CXF 3.1.7开始，可以执行异步代理调用。需要将JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html" rel="nofollow">InvocationCallback</a>注册为代理请求上下文属性：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);

Book book = null;
final InvocationCallback&lt;Book&gt; callback = new InvocationCallback&lt;Book&gt;() {
  public void completed(Book response) {
     book = response;
  }
  public void failed(Throwable error) {
  }
};


WebClient.getConfig(proxy).getRequestContext().put(InvocationCallback.class.getName(), callback);
assertNull(proxy.getBook());
Thread.sleep(3);
assertNotNull(book);</pre>
</div></div><p>如果您有使用不同方法返回不同响应类型的代理，则可以注册一个对象绑定的InvocationCallback或注册一个特定于类型的回调的集合：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);

// Book
Book book = null;
final InvocationCallback&lt;Book&gt; bookCallback = new InvocationCallback&lt;Book&gt;() {
  public void completed(Book response) {
     book = response;
  }
  public void failed(Throwable error) {
  }
};
// Chapter
Chapter chapter = null;
final InvocationCallback&lt;Chapter&gt; chapterCallback = new InvocationCallback&lt;Chapter&gt;() {
  public void completed(Chapter response) {
     chapter = response;
  }
  public void failed(Throwable error) {
  }
};
&#160;
WebClient.getConfig(proxy).getRequestContext().put(InvocationCallback.class.getName(),&#160;
                                                   Arrays.asList(bookCallback, chapterCallback));
// Get Book
assertNull(proxy.getBook(123L));
Thread.sleep(3);
assertNotNull(book);
&#160;
// Get Book Chapter
assertNull(proxy.getBookChapter(123L));
Thread.sleep(3);
assertNotNull(chapter);</pre>
</div></div><p>如果多个线程正在访问每个新的请求线程以拥有自己的回调，请确保以线程安全模式创建代理。</p><h2 id="JAX-RSClientAPI-BufferingResponses">缓冲响应</h2><p>缓冲代理响应的一种方法是让代理方法返回JAX-RS响应，使用其bufferEntity（）方法（在JAX-RS 2.0中可用），并使用Response.readEntity，如果需要，它可以返回类型化的响应。</p><p>另一个选项是在给定的代理实例上启用“ buffer.proxy.response”属性。</p><h2 id="JAX-RSClientAPI-Limitations">局限性</h2><p>返回对象的代理子资源方法不能被调用。最好让子资源方法返回类型化的类：接口，抽象类或具体的实现。</p><p> </p><h2 id="JAX-RSClientAPI-Workingwithusermodels">使用用户模型</h2><p>可以通过将外部用户模型应用于代理类来创建代理，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JAXRSClientFactory.createFromModel("http://books", BookNoAnnotations.class, "classpath:/resources/model.xml", null);
</pre>
</div></div><p>BookNoAnnotations是不带JAX-RS批注的接口或具体类。客户端代理和服务器端点都可以通过应用外部用户模型将其“转换”为RESTful资源。</p><h1 id="JAX-RSClientAPI-CXFWebClientAPI">CXF WebClient API</h1><p>以HTTP为中心的客户端是<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java">WebClient</a>实例，它也实现了<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/Client.java">Client</a>接口。除了设置各种客户端请求属性之外，您还可以使用HTTP动词作为给定操作的名称来进行显式HTTP调用：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient client = WebClient.create("http://books");
Book book = client.path("bookstore/books").accept("text/xml").get(Book.class);
</pre>
</div></div><p>您可以选择获取显式的JAX-RS响应，并检查响应代码，标头或实体主体（如果有）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient client = WebClient.create("http://books");
client.path("bookstore/books");
client.type("text/xml").accept("text/xml")
Response r = client.post(new Book());
Book b = r.readEntity(Book.class);
</pre>
</div></div><p>WebClient使您可以返回到基本URI或上一个路径段并继续前进，这对于从服务中获取许多单独的条目非常方便，其中ID嵌入在路径段中：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient client = WebClient.create("http://books");
List&lt;Book&gt; books = getBooks(client, 1L, 2L, 3L)

private List&lt;Book&gt; getBooks(WebClient client, Long ...ids) {
   List&lt;Book&gt; books = new ArrayList&lt;Book&gt;(); 
   for (Long id : ids) {
       books.add(client.path(id).get(Book.class));
       client.back(); 
   } 
   return books;
}
</pre>
</div></div><p>上面的代码将发送“ GET <span class="nolink">http：// books / 1</span> ”，“ GET <span class="nolink">http：// books / 2</span> ”等请求。</p><p>如果可以对请求URI进行参数化，则可能需要使用以下代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Book book = WebClient.create("http://books").path("{year}/{id}", 2010, 123).get(Book.class);
// as opposed to
// WebClient.create("http://books").path(2010).path(123).get(Book.class);
</pre>
</div></div><p>当将同一WebClient实例重用于多次调用时，例如，当需要更改Accept标头值并且需要将当前URI重置为baseURI时，可能需要借助reset（）方法来重置其状态。 （作为back（true）调用的替代方法）。resetQuery（）方法仅可用于重置查询值。这两个选项也可用于代理。</p><p><span class="confluence-anchor-link" id="JAX-RSClientAPI-asynchronousinvocations"></span></p><h2 id="JAX-RSClientAPI-Asynchronousinvocations">异步调用</h2><p>WebClient有几种接受JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html" rel="nofollow">InvocationCallback</a>并返回Future的方法。或者，用户也可以使用WebClient.async（）快捷方式来使用标准<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/AsyncInvoker.html" rel="nofollow">AsyncInvoker</a> 。</p><h2 id="JAX-RSClientAPI-Workingwithexplicitcollections">使用显式集合</h2><p>WebClient直接或通过JAX-RS 2.0 SyncInvoker和AsyncInvoker直接支持<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/GenericEntity.html" rel="nofollow">GenericEntity</a>和JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/GenericType.html" rel="nofollow">GenericType</a> ，从而使使用显式集合更容易。</p><p>WebClient也有一些可识别集合的方法，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Collection&lt;? extends Book&gt; books = WebClient.getCollection(Book.class);
Collection&lt;? extends Book&gt; books = WebClient.postAndGetCollection(new ArrayList&lt;Book&gt;(), Book.class);

</pre>
</div></div><h2 id="JAX-RSClientAPI-Handlingexceptions.1">处理异常</h2><p>您可以通过显式获取上面显示的Response对象并根据需要处理错误状态来处理远程异常，也可以捕获javax.ws.rs。WebApplicationException或javax.ws.rs。ProcessingException异常，与使用代理的方式相同。</p><h2 id="JAX-RSClientAPI-ConfiguringHTTPclientsinSpring">在Spring中配置HTTP客户端</h2><p>像代理一样，可以使用许多WebClient静态实用程序方法来创建HTTP客户端：您可以根据需要将位置传递给Spring配置Bean，也可以如上所述设置默认总线。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="myJsonProvider" class="org.apache.cxf.jaxrs.provider.JSONProvider" &gt; 
    &lt;property name="supportUnwrapped" value="true" /&gt; 
    &lt;property name="wrapperName" value="nodeName" /&gt; 
&lt;/bean&gt; 

&lt;util:list id="webClientProviders"&gt; 
    &lt;ref bean="myJsonProvider"/&gt; 
&lt;/util:list&gt; 

&lt;bean id="myWebClient" class="org.apache.cxf.jaxrs.client.WebClient" factory-method="create"&gt; 
    &lt;constructor-arg type="java.lang.String" value="http://some.base.url.that.responds/" /&gt; 
    &lt;constructor-arg ref="webClientProviders" /&gt; 
&lt;/bean&gt; 
</pre>
</div></div><p>注意，从CXF 2.7.5开始，可以使用jaxrs：client以与代理相同的方式设置WebClient实例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:client id="webClient"
    address="https://localhost:${port}/services/rest"
    serviceClass="org.apache.cxf.jaxrs.client.WebClient"&gt;
    &lt;jaxrs:headers&gt;
        &lt;entry key="Accept" value="text/xml"/&gt;
    &lt;/jaxrs:headers&gt;
&lt;/jaxrs:client&gt;
</pre>
</div></div><p>使用此选项的唯一限制是jaxrs：client属性（“ inheritHeaders”，“ modelRef”）和元素（“ model”）中的某些内容实际上不适用于WebClient。</p><h1 id="JAX-RSClientAPI-XML-centricclients">以XML为中心的客户端</h1><p>以XML为中心的客户端是使用<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XMLSource.java">XMLSource</a>实用工具类的WebClient。XMLSource具有多种方法，可借助XPath表达式来方便地检索JAXB bean，单个属性或链接。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient wc = WebClient.create("http://aggregated/data");
XMLSource source = wc.get(XMLSource.class);
source.setBuffering(true);
Book b1 = source.getNode("/books/book[position() = 1]", Book.class);
Book b2 = source.getNode("/books/book[position() = 2]", Book.class);
</pre>
</div></div><p>请注意，可以将XMLSource实例设置为缓冲输入流，从而允许执行多个XPath查询。<br clear="none">XMlSource还可以帮助获取将链接或XML实例表示为String的URI。</p><h1 id="JAX-RSClientAPI-SupportforarbitraryHTTPmethodsforsyncinvocations.">支持用于同步调用的任意HTTP方法。</h1><p>要获得同步客户端调用支持的任意HTTP方法或绕过某些已知的Java HTTPUrlConnection问题（例如，它将阻止空的DELETE请求），请添加基于HttpClient的传输依赖项并设置“ use.async.http.conduit”上下文属性。</p><p>鉴于需要基于HttpClient的传输，这将与异步调用一样工作。</p><h1 id="JAX-RSClientAPI-ThreadSafety">线程安全</h1><p>代理和Web客户端（客户端）默认情况下不是线程安全的。在某些情况下，这可能是一个限制，尤其是在注入客户端时；对它们进行同步可能会导致性能副作用。</p><p>使客户端成为线程安全的一种方法是对Web客户端使用WebClient.fromClient（Client）或将所有原始配置属性复制并可以用于为每个请求创建新客户端实例的JAXRSClientFactoryBean.fromClient（）工厂方法。</p><p>单个客户端在不更改当前URI或标头的情况下执行多次调用是线程安全的（在创建调用时）。并发生成器实例不是线程安全的，因为在后台使用了非线程安全类ClientProviderFactory的共享实例。在这种情况下，唯一的限制适用于代理，因为它们不能不同步就无法获得“带外”报头，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// get some response headers passed to us 'out of band', which is not thread-safe for a plain proxy: 
String bookHeader = WebClient.client(injectedBookStoreProxy).getHeaders().getFirst("BookHeader"); 
</pre>
</div></div><p>最后的选择是在创建代理或Web客户端（从Spring或以编程方式）时使用'threadSafe'布尔属性，请参阅此<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSMultithreadedClientTest.java">测试</a>以了解更多详细信息。以这种方式创建的线程安全客户端将其状态保存在线程本地存储中。</p><p>如果输入线程的数量受到限制，那么一个选项就是什么也不做，而另一个选项是重置线程本地状态：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">try { 
   webClient.path("bar") 
   webClient.header("bar", baz); 
   webClient.invoke(...); 
} finally { 
   // if using a proxy: WebClient.client(proxy).reset(); 
   webClient.reset(); 
} 
</pre>
</div></div><p>另一个选择是使用JAXRSClientFactoryBean和'secondsToKeepState'属性来创建线程安全的客户端-这将指示客户端定期清理线程本地状态。</p><h1 id="JAX-RSClientAPI-ConfiguringClientsatRuntime">在运行时配置客户端</h1><p>代理和以HTTP为中心的客户端通常由JAXRSClientFactory或WebClient工厂方法创建，但是<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java">JAXRSClientFactoryBean</a>也可以用于在创建客户端之前对其进行预配置。</p><p>有时，您可能要在创建客户端实例后对其进行配置。例如，与使用Spring设置其属性相反，可能需要以编程方式配置HTTPConduit。ClientConfiguration代表特定于客户端的配置状态，可以这样访问：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Book proxy = JAXRSClientFactory.create("http://books", Book.class);
ClientConfiguration config = WebClient.getConfig(proxy);
HTTPConduit conduit1 = (HTTPConduit)config.getConduit();

WebClient webclient = WebClient.create("http://books");
HTTPConduit conduit2 = (HTTPConduit)WebClient.getConfig(webclient).getConduit();
</pre>
</div></div><p>当使用JAX-RS 2.0客户端API时，可以通过可配置接口设置一些低级HTTP属性：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">//http.connection.timeout
//http.receive.timeout
//http.proxy.server.uri
//http.proxy.server.port
Client client = ClientBuilder.newClient();
client.property("http.receive.timeout", 1000000);&#160;</pre>
</div></div><h1 id="JAX-RSClientAPI-CreatingclientsprogrammaticallywithnoSpringdependencies">以编程方式创建没有Spring依赖项的客户端</h1><p>范例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JAXRSClientFactoryBean sf = new JAXRSClientFactoryBean();
sf.setResourceClass(CustomerService.class);
sf.setAddress("http://localhost:9000/");
BindingFactoryManager manager = sf.getBus().getExtension(BindingFactoryManager.class);
JAXRSBindingFactory factory = new JAXRSBindingFactory();
factory.setBus(sf.getBus());
manager.registerBindingFactory(JAXRSBindingFactory.JAXRS_BINDING_ID, factory);
CustomerService service = sf.create(CustomerService.class);
WebClient wc = sf.createWebClient();
</pre>
</div></div><h1 id="JAX-RSClientAPI-ConfiguringanHTTPConduitfromSpring">从Spring配置HTTP管道</h1><p>有很多方法可以为代理和WebClient配置HTTPConduits。</p><p>可以具有HTTPConduit配置，该配置将适用于使用不同请求URI的所有客户端，或仅应用于使用特定URI的客户端。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="http://books:9095/bookstore.*"/&gt; 
</pre>
</div></div><p>此配置将影响所有具有以'http：// books：9095 / bookstore'开头的requestURI的代理和WebClient。注意http：conduit元素名称的后缀“。*”。</p><p>请参阅<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/jaxrs-https-url.xml">此配置文件</a>以获取更多示例。</p><p>或者，您可以执行以下操作：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="*.http-conduit"/&gt; 
</pre>
</div></div><p>此配置将影响所有客户端，而不管要处理的URI。</p><p>如果使用代理，则可以使用扩展的QName表示法进行特定于代理的配置：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="{http://foo.bar}BookService.http-conduit"/&gt; 
</pre>
</div></div><p>在此示例中，“ foo.bar”是BookService代理类的反向包名称。</p><p>同样，对于WebClient，您可以执行以下操作：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="{http://localhost:8080}WebClient.http-conduit"/&gt; 
</pre>
</div></div><p>在此示例中，“ http：// localhost：8080”是基本服务URI。</p><p>请参阅<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/jaxrs-https-client1.xml">jaxrs-https-client1.xml</a>和<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/jaxrs-https-client2.xml">jaxrs-https-client2.xml</a>配置文件以获取更多示例。</p><p>另请参阅<a shape="rect" href="client-http-transport-including-ssl-support.html">此Wiki页面</a> ，了解如何配置HTTPConduits。</p><h1 id="JAX-RSClientAPI-ClientsandAuthentication">客户端和认证</h1><p>代理和以HTTP为中心的客户端可以显式设置HTTP授权标头：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Replace 'user' and 'password' by the actual values
String authorizationHeader = "Basic " 
    + org.apache.cxf.common.util.Base64Utility.encode("user:password".getBytes());

// proxies
WebClient.client(proxy).header("Authorization", authorizationHeader);

// web clients
webClient.header("Authorization", authorizationHeader);

</pre>
</div></div><p>或在创建客户端时提供用户名和密码对，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class, "username", "password", "classpath:/config/https.xml");

WebClient client = WebClient.create("http://books", "username", "password", "classpath:/config/https.xml");
</pre>
</div></div><p>从Spring注入客户端时，可以将“用户名”和“密码”值作为属性添加到jaxrs：client元素中，或将其添加到WebClient工厂创建方法中。</p><h1 id="JAX-RSClientAPI-ClientsinSpringBoot">Spring Boot中的客户端</h1><p>请参阅<a shape="rect" href="jaxrsclientspringboot.html">JAXRSClientSpringBoot</a>文档，了解如何在SpringBoot应用程序中使用CXF <span class="confluence-link">JAX-RS客户端</span> 。</p><p> </p><p> </p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=24190809">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=24190809&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>