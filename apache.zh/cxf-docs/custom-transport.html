<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Custom Transport">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-自定义传输</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="transports.html">运输</a> > <a href="custom-transport.html">自定义运输</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p>该页面总结了实现新的自定义CXF传输的经验和用例。</p>


<h2 id="CustomTransport-UseCases">用例</h2>
<p>基本上，有两种主要的用例来实现新的CXF传输：</p>
<ol><li>提供CXF尚不支持的新物理协议（例如，udp或ftp）。可以通过与相应的Camel组件集成使用来解决某些此类情况，但是如果没有此类组件可用或不可行，则应考虑创建新的自定义CXF传输。</li><li>支持与另一个框架（如JBI或Camel）的紧密集成。在这种情况下，集成对于CXF应用程序将保持透明-它们只是在传输级别直接与目标框架对话。在这里，传输实现将负责将CXF交换，消息和故障转换并传输到目标框架。</li></ol>


<p>当前，CXF发行版提供以下协议的传输实现：HTTP（S），JBI，JMS和Local（在一个JVM中）。骆驼还为骆驼交换实现了CXF传输。</p>

<h2 id="CustomTransport-ArchitectureandDesign">建筑与设计</h2>
<p>传输功能基于两个基本定义：管道和目的地。管道负责将消息发送到收件人和目的地，以便从发件人接收消息。为了发送响应，目的地需要其自己的反向通道管道（在请求-响应通信的情况下）。管道和目的地由TransportFactory创建。CXF根据传输URL选择正确的TransportFactory。 SOAP也被认为是高级传输，并且在CXF中具有自己的管道和目的地。<br clear="none">要将消息发送到物理通道，管道应访问消息上下文。在这种情况下，通常的做法是使用OutputStream的子类扩展CachedOutputStream。自定义流将被馈送消息，并提供根据传输要求以流或缓冲形式访问上下文的可能性。CachedOutputStream配置为仅将消息保留在内存中，直到达到预定义的大小。如果超过此大小，则消息将交换到磁盘。</p>

<p>下面显示了TransportFactory，Conduit，Destination和OutputStream的类图：<br clear="none">
<span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="custom-transport.data/cxf-transport-class-diagram.jpg"></span></p>


<h2 id="CustomTransport-HowitWorks">怎么运行的</h2>
<p>下图表示了JAX-WS客户端与使用CXF传输的服务之间的交互：<br clear="none">
<span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" src="custom-transport.data/cxf-transport.jpg"></span></p>


<h3 id="CustomTransport-SimplifiedClientWorkflow:">简化的客户工作流程：</h3>
<ul><li>步骤1：JAX-WS客户端以这种方式调用服务：<div class="code panel pdl" style="border-style:solid;border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
        URL wsdlURL = this.getClass().getResource("/HelloWorld.wsdl");
        HelloWorldService service = new HelloWorldService(wsdlURL, SERVICE_NAME);        
        HelloWorld hw = service.getHelloWorldPort();       
        String result = hw.sayHi(TEST_REQUEST); }}
</pre>
</div></div></li><li>步骤2：CXF运行时根据一些条件选择正确的TransportFactory（如下所述）</li><li>步骤3：CXF运行时调用<em>TransportFactory.getConduit（）</em>方法来获取管道</li><li>步骤4：CXF运行时调用<em>Conduit.prepare（）</em>并将传出消息作为参数传递</li><li>步骤5：管道将自己的OutputStream（通常扩展为CachedOutputStream）设置为传出消息内容</li><li>步骤6：CXF运行时处理传出消息，调用拦截器链，并将传出消息写入管道的OutputStream流。CXF中的消息传递是面向流的；因此，该消息通常会继续发送，而不是以一束的形式发送，而是以流的形式发送。发件人仍可以处理邮件的最后字节，但第一个字节已发送给收件人。基本上，Conduit负责如何发送消息：使用流传输或收集整个消息并立即发送</li><li>步骤7：当CXF运行时完全处理传出消息时，它将调用<em>Conduit.close（Message）</em>方法。这意味着消息已完全写入<em>OutputStream</em> 。相应地，将调用<em>OutputStream.doClose（）</em>方法。</li><li>步骤8：在<em>doClose（）</em>方法中，Conduit将其余消息（或整个消息）发送给收件人</li><li>步骤9：在单向通信的情况下将关闭。跳至步骤14</li><li>步骤10：在请求-响应通信的情况下，管道将以同步或异步方式等待服务响应</li><li>步骤11：如果收到成功的响应，则管道会创建一个新消息，设置其上下文并将其作为传入消息在交换中作为传入消息放入</li><li>步骤12：如果接收到故障，则管道创建新消息，设置其上下文，并将其放置为故障消息，以作为故障消息交换</li><li>第13步：管道使用<em>入站</em>调用Observer.onMessage <em>（）</em>通知响应响应（即ClientImpl对象）。</li><li>步骤14：导管的实现会减少网络连接的参考计数，如果计数为零，则有可能关闭连接</li><li>步骤15：JAX-WS客户端代码以同步或异步方式接收响应</li></ul>


<h3 id="CustomTransport-SimplifiedServiceWorkflow:">简化服务流程：</h3>
<ul><li>步骤1：例如，以这种方式注册JAX-WS服务：<div class="code panel pdl" style="border-style:solid;border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
	HelloWorldImpl serverImpl = new HelloWorldImpl();
	Endpoint.publish("udp://localhost:9000/hello", serverImpl);
</pre>
</div></div></li><li>步骤2：CXF运行时根据某些条件选择正确的TransportFactory（如下所述）</li><li>步骤3：CXF运行时调用<em>TransportFactory.getDestination（）</em>方法以获取目标</li><li>步骤4：一旦CXF运行时激活了端点（添加了侦听器等）， <em>Destination.activate（）</em>方法将被自动调用。</li><li>步骤5： <em>Destination.activate（）</em>的实现通常会打开网络传输连接并侦听传入的请求</li><li>步骤6：当请求到来时，目的地创建一条消息，设置内容，并通过<em>传入</em> <em>Observer.onMessage</em> <em>（）</em>通知消息观察者（即<em>ChainInitializationObserver</em>对象<em>）</em>有关请求。消息内容另存为流；因此，运行时和业务逻辑即使未完全接收到的消息也可以开始处理。通常，传入的连接会保存在关联图中，以提取出来以发送适当的响应</li><li>步骤7：将以流形式的请求消息调用业务服务实现。如果是单向通信，则交换现在完成。在请求响应的情况下，业务实现会返回响应或引发错误异常</li><li>步骤8：CXF运行时通过<em>Destination.getInbuiltBackChannel（）</em>从目标请求反向通道管道</li><li>步骤9：将使用响应消息作为参数调用反向通道管道的<em>prepare（）</em>方法</li><li>步骤10：反向通道管道将其自己的OutputStream设置为消息上下文</li><li>步骤11：CXF运行时处理响应消息，调用拦截器链并为响应消息调用<em>Conduit.close（Message）</em></li><li>第十二步最后，调用响应消息的<em>OutputStream.doClose（）</em>方法</li><li>步骤13：在<em>doClose（）</em>方法中， <em>OutputStream</em>类可以访问封送处理的响应消息，并将通过网络将此消息作为对客户端的响应进行发送。在进行流传输的情况下，此时消息的一部分可以已经发送到网络，而Conduit仅发送最后一部分并关闭发送。通常，仅在必要时缓存和创建指定协议的传入连接</li></ul>


<h2 id="CustomTransport-RegistrationofTransportFactory">运输工厂登记</h2>
<p>有两种注册运输工厂的方式：以编程方式或通过Spring配置。<br clear="none">要以编程方式注册运输工厂，必须执行以下代码：</p>
<div class="code panel pdl" style="border-style:solid;border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
     Bus bus = BusFactory.getThreadDefaultBus();
     DestinationFactoryManagerImpl dfm = bus.getExtension(DestinationFactoryManagerImpl.class);
     CustomTransportFactory customTransport = new CustomTransportFactory();
     dfm.registerDestinationFactory(TRANSPORT_IDENTIFIER, customTransport);

     ConduitInitiatorManager extension = bus.getExtension(ConduitInitiatorManager.class);
     extension.registerConduitInitiator(TRANSPORT_IDENTIFIER, customTransport);
</pre>
</div></div>
<p>TRANSPORT_IDENTIFIER是唯一的传输ID（通常以“ <a shape="rect" class="external-link" href="http://apache.org/transports/PROTOCOL_PREFIX">http://apache.org/transports/PROTOCOL_PREFIX</a> ”的形式）。</p>

<p>对于Spring配置，可以改为使用以下内容：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
	&lt;bean class="org.company.cxf.transport.CustomTransportFactory"
		lazy-init="false"&gt;
		&lt;property name="transportIds"&gt;
			&lt;list&gt;
			  &lt;value&gt;TRANSPORT_IDENTIFIER&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
</pre>
</div></div>

<h2 id="CustomTransport-TransportFactoryselection">运输工厂选择</h2>
<p>就找到绑定TransportFactory而言，CXF寻找负责物理网络通信的协议TransportFactory。在这种情况下，重要的是方法<em>TransportFactory.getUriPrefixes（）</em> 。此方法返回此TransportFactory支持的协议前缀列表。<br clear="none">当CXF客户端或服务尝试使用具有指定协议前缀（http：//，https：//，jms：//，local：//）的URL进行通信时，CXF会查看已注册的传输工厂映射，并为此找到合适的映射字首。如果找不到此协议的TransportFactory，则CXF引发相应的异常。</p>

<p>客户端配置：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
&lt;jaxws:client id="FlightReservationClient"
	xmlns:serviceNamespace="http://www.apache.org/cxf/samples/FlightReservation"

serviceClass="org.apache.cxf.samples.flightreservation.FlightReservation"
	serviceName="serviceNamespace:FlightReservationService" endpointName="serviceNamespace:FlightReservationSOAP"&gt;
	address="http://localhost:8040/services/FlightReservationService"&gt;
&lt;/jaxws:client&gt;
&#8230;
</pre>
</div></div>

<p>TransportFactory类：</p>
<div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">
&#8230;
    private static final Set&lt;String&gt; URI_PREFIXES = new HashSet&lt;String&gt;();
    static {
        URI_PREFIXES.add("http://");
        URI_PREFIXES.add("https:");
    }    
    public Set&lt;String&gt; getUriPrefixes() {
        return URI_PREFIXES;
    }
</pre>
</div></div>

<h2 id="CustomTransport-ConduitandDestinationLifecycle">导管和目标生命周期</h2>
<p>目标通常由服务在启动时创建，并由关机释放。可以为每个请求重新创建管道，也可以基于端点信息在整个客户端生命周期内对其进行缓存。客户端可以使用不同的协议对端点进行并发调用，并将它们绑定到不同的管道。</p>

<h2 id="CustomTransport-ConcurrencyAspects">并发方面</h2>
<p>管道和目标对象可以由多个线程同时访问。实现应注意该类的线程安全性。</p>

<h2 id="CustomTransport-Streaming">流媒体</h2>
<p>如果物理协议支持，则强烈建议不要中断Conduit和Destination实现中的流。CXF完全以流为导向–带来高性能和可伸缩性。</p>

<h2 id="CustomTransport-References">参考文献</h2>
<p>理解CXF传输层并实现自己的传输的起点是什么？阅读CXF文档<a shape="rect" href="http://cxf.apache.org/docs/transports.html">CXF传输概述</a>并分析现有CXF传输的源代码很有意义（本地和JMS更为简单）。它们位于相应的包中：org.apache.cxf.transport.local和org.apache.cxf.transport.jms。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=27839372">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=27839372&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>