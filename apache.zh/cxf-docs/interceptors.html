<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Interceptors">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-拦截器</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="advanced-integration.html">高级集成</a> > <a href="interceptors.html">拦截器</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="Interceptors-InterceptorsandPhases">拦截器和阶段</h1><p>拦截器是CXF内部的基本处理单元。调用服务时，将创建并调用InterceptorChain。每个拦截器都有机会根据消息做他们想做的事情。这可以包括读取，转换，处理标题，验证消息等。</p><p>拦截器与CXF客户端和CXF服务器一起使用。当CXF客户端调用CXF服务器时，该客户端有一个传出拦截链，而服务器则有一个传入链。当服务器将响应发送回客户端时，服务器有一条传出链，而客户端有一条传入链。另外，对于<a shape="rect" class="external-link" href="https://docs.oracle.com/javase/7/docs/api/javax/xml/soap/SOAPFault.html" rel="nofollow">SOAPFaults而言</a> ，CXF Web服务将创建一个单独的出站错误处理链，而客户端将创建一个入站错误处理链。</p><p>CXF内部的一些拦截器示例包括：</p><ul><li>SoapActionInterceptor-处理SOAPAction标头并选择一个操作（如果已设置）。</li><li>StaxInInterceptor-从传输输入流创建Stax XMLStreamReader。</li><li>Attachment（In / Out）Interceptor-将多部分/相关消息转换为一系列附件。</li></ul><p>InterceptorChains分为多个阶段。每个拦截器运行的阶段在拦截器的构造函数中声明。每个阶段可能包含许多拦截器。在传入链上，您将分为以下几个阶段：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>相</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>功能</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>接收</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>运输等级处理</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>（PRE / USER / POST）_STREAM</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>流级处理/转换</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>读</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>这是通常发生标头读取的地方。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>（PRE / USER / POST）_PROTOCOL</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>协议处理，例如JAX-WS SOAP处理程序</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>UNMARSHAL</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>解组请求</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>（PRE / USER / POST）_LOGICAL</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>处理授权请求</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_INVOKE</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>调用前动作</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>调用</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>服务调用</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>POST_INVOKE</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>如果有一条，则调用传出链</p></td></tr></tbody></table></div><p>在传出链上，分为以下几个阶段：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>相</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>功能</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>设定</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>以下阶段的任何设置</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>（PRE / USER / POST）_LOGICAL</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>处理将要编组的对象</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PREPARE_SEND</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>打开连接</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_STREAM</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_PROTOCOL</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>协议操作杂项。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>写</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>编写协议消息，例如SOAP Envelope。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>元帅</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>编组对象</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>（USER / POST）_PROTOCOL</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>协议消息的处理。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>（USER / POST）_STREAM</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>字节级消息的处理</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>发送</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr></tbody></table></div><p>在SEND阶段之后，有一堆与上述阶段对称的“ * _ENDING”阶段，以允许拦截器清除并关闭在上述阶段中打开或启动的所有内容：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>相</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>功能</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>SEND_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>POST_STREAM_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>USER_STREAM_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>POST_PROTOCOL_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>USER_PROTOCOL_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>MARSHAL_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>WRITE_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_PROTOCOL_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_STREAM_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PREPARE_SEND_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>POST_LOGICAL_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>USER_LOGICAL_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PRE_LOGICAL_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>SETUP_ENDING</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>通常导致所有流关闭，并且最终数据通过网络发送。</p></td></tr></tbody></table></div><h1 id="Interceptors-InterceptorProviders">拦截器提供者</h1><p>CXF内部的几个不同组件可以为InterceptorChain提供拦截器。这些实现了InterceptorProvider接口：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public interface InterceptorProvider {

    List&lt;Interceptor&gt; getInInterceptors();

    List&lt;Interceptor&gt; getOutInterceptors();

    List&lt;Interceptor&gt; getOutFaultInterceptors();

    List&lt;Interceptor&gt; getInFaultInterceptors();
}
</pre>
</div></div><p>要将拦截器添加到拦截器链，您需要将其添加到拦截器提供程序之一。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">MyInterceptor interceptor = new MyInterceptor();
provider.getInInterceptors().add(interceptor);
</pre>
</div></div><p>CXF中的一些InterceptorProviders是：</p><ul><li>客户</li><li>终点</li><li>服务</li><li>总线</li><li>捆绑</li></ul><h1 id="Interceptors-WritingandconfiguringanInterceptor">编写和配置拦截器</h1><p>CXF发行版随附一个名为<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/configuration_interceptor" rel="nofollow">configuration_interceptor</a>的演示，该演示显示了如何开发用户拦截器并将其配置为拦截器链。</p><h2 id="Interceptors-WritinganInterceptor">编写拦截器</h2><p>编写拦截器相对简单。您的拦截器需要从AbstractPhaseInterceptor或其<a shape="rect" class="external-link" href="http://tinyurl.com/3bkho8" rel="nofollow">多个子类</a>之一（例如AbstractSoapInterceptor）扩展。从AbstractPhaseInterceptor扩展允许您的拦截器访问<a shape="rect" class="external-link" href="http://tinyurl.com/24gj28" rel="nofollow">Message</a>接口的方法。例如，在CXF中使用AttachmentInInterceptor将多部分/相关消息转换为一系列附件。如下图所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.io.IOException;

import org.apache.cxf.attachment.AttachmentDeserializer;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;

public class AttachmentInInterceptor extends AbstractPhaseInterceptor&lt;Message&gt; {
    public AttachmentInInterceptor() {
        super(Phase.RECEIVE);
    }

    public void handleMessage(Message message) {
        String contentType = (String) message.get(Message.CONTENT_TYPE);
        if (contentType != null &amp;&amp; contentType.toLowerCase().indexOf("multipart/related") != -1) {
            AttachmentDeserializer ad = new AttachmentDeserializer(message);
            try {
                ad.initializeAttachments();
            } catch (IOException e) {
                throw new Fault(e);
            }
        }
    }

    public void handleFault(Message messageParam) {
    }
}
</pre>
</div></div><p>从AbstractPhaseInterceptor的子类扩展后，拦截器可以访问比Message接口中的信息更具体的信息。AbstractPhaseInterceptor的子类之一是<a shape="rect" class="external-link" href="http://tinyurl.com/2xqyg6" rel="nofollow">AbstractSoapInterceptor</a> 。从此类扩展，使您的拦截器可以访问SOAP标头和<a shape="rect" class="external-link" href="http://tinyurl.com/2gxj2c" rel="nofollow">SoapMessage类的</a>版本信息。例如，CXF中使用SoapActionInInterceptor来解析SOAP操作，如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.util.Collection;
import java.util.List;
import java.util.Map;

import org.apache.cxf.binding.soap.Soap11;
import org.apache.cxf.binding.soap.Soap12;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.model.SoapOperationInfo;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;

public class SoapActionInInterceptor extends AbstractSoapInterceptor {

    public SoapActionInInterceptor() {
        super(Phase.READ);
        addAfter(ReadHeadersInterceptor.class.getName());
        addAfter(EndpointSelectionInterceptor.class.getName());
    }

    public void handleMessage(SoapMessage message) throws Fault {
        if (message.getVersion() instanceof Soap11) {
            Map&lt;String, List&lt;String&gt;&gt; headers = CastUtils.cast((Map)message.get(Message.PROTOCOL_HEADERS));
            if (headers != null) {
                List&lt;String&gt; sa = headers.get("SOAPAction");
                if (sa != null &amp;&amp; sa.size() &gt; 0) {
                    String action = sa.get(0);
                    if (action.startsWith("\"")) {
                        action = action.substring(1, action.length() - 1);
                    }
                    getAndSetOperation(message, action);
                }
            }
        } else if (message.getVersion() instanceof Soap12) {
          ...........
        }
    }

    private void getAndSetOperation(SoapMessage message, String action) {
        if ("".equals(action)) {
            return;
        }

        Exchange ex = message.getExchange();
        Endpoint ep = ex.get(Endpoint.class);

        BindingOperationInfo bindingOp = null;

        Collection&lt;BindingOperationInfo&gt; bops = ep.getBinding().getBindingInfo().getOperations();
        for (BindingOperationInfo boi : bops) {
            SoapOperationInfo soi = (SoapOperationInfo) boi.getExtensor(SoapOperationInfo.class);
            if (soi != null &amp;&amp; soi.getAction().equals(action)) {
                if (bindingOp != null) {
                    //more than one op with the same action, will need to parse normally
                    return;
                }
                bindingOp = boi;
            }
        }
        if (bindingOp != null) {
            ex.put(BindingOperationInfo.class, bindingOp);
            ex.put(OperationInfo.class, bindingOp.getOperationInfo());
        }
    }

}
</pre>
</div></div><p>请注意，您将需要指定拦截器将包含的阶段。这是在拦截器的构造函数中完成的：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class MyInterceptor extends AbstractSoapInterceptor {
  public MyInterceptor() {
    super(Phase.USER_PROTOCOL);
  }
  ...
}
</pre>
</div></div><p>您还可以表示您希望拦截器在同一阶段中定义的某些其他拦截器之前/之后运行：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class MyInterceptor extends AbstractSoapInterceptor {
  public MyInterceptor() {
    super(Phase.USER_PROTOCOL);

    // MyInterceptor needs to run after SomeOtherInterceptor
    getAfter().add(SomeOtherInterceptor.class.getName());

    // MyInterceptor needs to run before YetAnotherInterceptor
    getBefore().add(YetAnotherInterceptor.class.getName());
  }
  ...
}
</pre>
</div></div><p>您可以通过编程或通过配置将拦截器添加到拦截器链中。</p><h2 id="Interceptors-Addinginterceptorsprogrammatically">以编程方式添加拦截器</h2><p>要将其添加到服务器，您将需要访问Server对象（有关更多信息，请参见<a shape="rect" href="server-service-and-client-factorybeans.html">此处</a> ）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.endpoint.Server;
import org.apache.cxf.frontend.ServerFactoryBean;
...

MyInterceptor myInterceptor = new MyInterceptor();

Server server = serverFactoryBean.create();
server.getEndpoint().getInInterceptor().add(myInterceptor);
</pre>
</div></div><p>在客户端，过程非常相似：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.endpoint.Client;
import org.apache.cxf.frontend.ClientProxy;
...

MyInterceptor myInterceptor = new MyInterceptor();
FooService client = ... ; // created from ClientProxyFactoryBean or generated JAX-WS client

//You could also call clientProxyFactroyBean.getInInterceptor().add(myInterceptor) to add the interceptor

Client cxfClient = ClientProxy.getClient(client);
cxfClient.getInInterceptors().add(myInterceptor);

// then you can call the service
client.doSomething();
</pre>
</div></div><p>您还可以使用批注从SEI或服务类添加拦截器。当CXF创建服务器或客户端时，CXF将根据注释添加拦截器。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@org.apache.cxf.interceptor.InInterceptors (interceptors = {"com.example.Test1Interceptor" })
@org.apache.cxf.interceptor.InFaultInterceptors (interceptors = {"com.example.Test2Interceptor" })
@org.apache.cxf.interceptor.OutInterceptors (interceptors = {"com.example.Test1Interceptor" })
@org.apache.cxf.interceptor.InFaultInterceptors (interceptors = {"com.example.Test2Interceptor","com.example.Test3Intercetpor" })
@WebService(endpointInterface = "org.apache.cxf.javascript.fortest.SimpleDocLitBare",
            targetNamespace = "uri:org.apache.cxf.javascript.fortest")
public class SayHiImplementation implements SayHi {
   public long sayHi(long arg) {
       return arg;
   }
   ...
}
</pre>
</div></div><h2 id="Interceptors-Addinginterceptorsthroughconfiguration">通过配置添加拦截器</h2><p><a shape="rect" href="configuration.html">配置文件</a>页面提供了有关使用配置文件添加拦截器的示例。</p><p>将MyInterceptor添加到总线：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://cxf.apache.org/core"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd"&gt;

    &lt;bean id="MyInterceptor" class="demo.interceptor.MyInterceptor"/&gt;

    &lt;!-- We are adding the interceptors to the bus as we will have only one endpoint/service/bus. --&gt;

    &lt;cxf:bus&gt;
        &lt;cxf:inInterceptors&gt;
            &lt;ref bean="MyInterceptor"/&gt;
        &lt;/cxf:inInterceptors&gt;
        &lt;cxf:outInterceptors&gt;
            &lt;ref bean="MyInterceptor"/&gt;
       &lt;/cxf:outInterceptors&gt;
    &lt;/cxf:bus&gt;
&lt;/beans&gt;

</pre>
</div></div><p>对于基于嵌入式Jetty的Web服务，可以通过使用-Dcxf.config.file = server.xml选项启动服务来声明配置文件。有关为基于Servlet WAR文件的Web服务实现指定文件的信息，请参阅配置文件页面上的<a shape="rect" class="external-link" href="http://tinyurl.com/2c9fuf" rel="nofollow">服务器配置</a>部分。</p><p>将MyInterceptor添加到您的客户端：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:http="http://cxf.apache.org/transports/http/configuration"
       xsi:schemaLocation="http://cxf.apache.org/transports/http/configuration http://cxf.apache.org/schemas/configuration/http-conf.xsd
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;http:conduit name="{http://apache.org/hello_world_soap_http}SoapPort9001.http-conduit"&gt;
      &lt;http:client DecoupledEndpoint="http://localhost:9990/decoupled_endpoint"/&gt;
    &lt;/http:conduit&gt;

    &lt;bean id="MyInterceptor" class="demo.interceptor.MyInterceptor"/&gt;

    &lt;!-- We are adding the interceptors to the bus as we will have only one endpoint/service/bus. --&gt;

    &lt;bean id="cxf" class="org.apache.cxf.bus.CXFBusImpl"&gt;
        &lt;property name="inInterceptors"&gt;
            &lt;ref bean="MyInterceptor"/&gt;
        &lt;/property&gt;
        &lt;property name="outInterceptors"&gt;
            &lt;ref bean="MyInterceptor"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</pre>
</div></div><p>要指定客户端配置文件，请使用-Dcxf.config.file = client.xml选项启动客户端。</p><h2 id="Interceptors-CXFcontributedinterceptors">CXF贡献拦截器</h2><p>在CXF中，处理消息的所有功能都是通过拦截器完成的。因此，在调试消息流时，您会在链中遇到一堆拦截器。这是一些常见拦截器及其提供的功能的列表。这些拦截器的源代码可在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/" rel="nofollow">github上找到</a> 。</p><h4 id="Interceptors-DefaultJAX-WSIncominginterceptorchain(Server):">默认的JAX-WS传入拦截器链（服务器）：</h4><ul><li><strong>AttachmentInInterceptor</strong>解析mime标头中的mime边界，找到“根”部分并将其输入流重置，并将其他部分存储在Attachments的集合中</li><li><strong>StaxInInterceptor</strong>从消息上的传输InputStream创建一个XMLStreamReader</li><li><strong>ReadHeadersInterceptor</strong>解析SOAP标头并将其存储在Message中</li><li><strong>SoapActionInInterceptor</strong>解析“ soapaction”头，如果可以找到该操作的唯一操作，则查找该操作。</li><li><strong>MustUnderstandInterceptor</strong>检查MustUnderstand标头，其适用性并进行处理（如果需要）</li><li>根据JAX-WS的<strong>SOAPHandlerInterceptor</strong> SOAP处理程序</li><li>根据JAX-WS的<strong>LogicalHandlerInInterceptor</strong>逻辑处理程序</li><li><strong>CheckFaultInterceptor</strong>检查错误（如果存在）中止拦截器链并调用故障处理程序链</li><li><strong>URIMappingInterceptor</strong> （对于<= 2.x的CXF版本）可以处理HTTP GET，提取操作信息并在Message中进行设置</li><li><strong>DocLiteralnInterceptor</strong>检查SOAP正文中的第一个元素以确定适当的Operation（如果soapAction找不到一个），然后调用Databinding读取数据。</li><li><strong>SoapHeaderInterceptor</strong>对映射到参数的标头执行SOAP标头的数据绑定</li><li><strong>WrapperClassInInterceptor</strong>对于包装的doc / lit，DocLiteralInInterceptor可能在单个JAXB bean中读取。该拦截器将单个部分从该bean中拉出，以构造调用服务所需的Object []。</li><li><strong>带有</strong>附件的<strong>SwAInInterceptor</strong>肥皂，找到合适的附件并将其分配给参数列表中的正确位置。</li><li><strong>HolderInInterceptor</strong>对于OUT和IN / OUT参数，JAX-WS需要创建Holder对象。该拦截器创建Holder并将其放入参数列表中。</li><li><strong>ServiceInvokerInInterceptor</strong>实际调用服务。</li></ul><h3 id="Interceptors-DefaultOutgoingchainstack(Server):">默认传出链堆栈（服务器）：</h3><ul><li><strong>HolderOutInterceptor</strong>对于OUT和IN / OUT参数，将值从JAX-WS Holder对象（在HolderInInterceptor中创建）中拉出，并将它们添加到out消息的参数列表中。</li><li><strong>SwAOutInterceptor</strong>对于作为Soap附件的OUT零件，将其从列表中拉出并保存以备后用。</li><li><strong>WrapperClassOutInterceptor</strong>对于doc / lit打包的文件，请采用其余部分并创建一个包装JAXB bean来表示整个消息。</li><li><strong>SoapHeaderOutFilterInterceptor</strong>删除入站标记的标题</li><li><strong>SoapActionOutInterceptor</strong>设置SOAP操作</li><li><strong>MessageSenderInterceptor</strong>回调到Destination对象，以使其设置输出流，标头等，以准备传出传输。</li><li><strong>SoapPreProtocolOutInterceptor</strong>此拦截器负责设置SOAP版本和标头，以便任何需要使用它们的预协议拦截器都可以使用。</li><li><strong>AttachmentOutInterceptor</strong>如果此服务使用附件（SwA或启用了MTOM），它将设置附件编组器和所需的MIME内容。</li><li><strong>StaxOutInterceptor</strong>从Message上的OutputStream创建一个XMLStreamWriter。</li><li><strong>SoapHandlerInterceptor</strong> JAX-WS SOAPHandler</li><li><strong>SoapOutInterceptor</strong>为消息中的soap：envelope写入开始元素，为其他标头块写入complete元素。也添加了soap：body的开始元素。</li><li><strong>LogicalHandlerOutInterceptor</strong> JAX-WS逻辑处理程序内容</li><li><strong>WrapperOutInterceptor</strong>如果包装的doc / lit不使用包装器bean，或者RPC点亮，则将包装器元素输出到流。</li><li><strong>BareOutInterceptor</strong>使用数据绑定将参数写出。</li><li><strong>SoapOutInterceptor $ SoapOutEndingInterceptor</strong>关闭soap：body和soap：envelope</li><li><strong>StaxOutInterceptor $ StaxOutEndingInterceptor</strong>刷新stax流。</li><li><strong>MessageSenderInt $ MessageSenderEnding</strong>关闭交换，使传输知道一切已完成，应刷新到客户端。</li></ul></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=49956">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=49956&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>