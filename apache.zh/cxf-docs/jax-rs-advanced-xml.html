<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Advanced XML">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS高级XML</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-advanced-xml.html">JAX-RS高级XML</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p> </p><p> </p><p> </p><p></p><p><span style="font-size:2em;font-weight:bold">JAX-RS：高级XML</span>


</p><p></p><p> </p><p> </p><p> </p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1524513385073 {padding: 0px;}
div.rbtoc1524513385073 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1524513385073 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1524513385073">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSAdvancedXML-XPathsupport">XPath支持</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSAdvancedXML-Introduction">介绍</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-UsingXMLSourceandXPathProviderintheapplicationcode">在应用程序代码中使用XMLSource和XPathProvider</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSAdvancedXML-XSLTsupport">XSLT支持</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-XMLProcessingInstructions">XML处理说明</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-XSLTTransform">XSLTTransform</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-XSISchemaLocation">XSI架构位置</a></li></ul>
</div><h1 id="JAX-RSAdvancedXML-XPathsupport">XPath支持</h1><p>在<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XMLSource.java">XMLSource</a>实用程序和<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/XPathProvider.java">XPathProvider</a>提供程序类的帮助下，服务器端和客户端均支持XPath。两者之间的区别在于XPathProvider允许在外部配置中指定XPath表达式。</p><h2 id="JAX-RSAdvancedXML-Introduction">介绍</h2><p>XMLSource允许将匹配的XML DOM元素，属性和文本节点转换为类型化的复杂类和原始类。也可以使用DOM Node和Element类以及JAXP Source和DOMSource。如果启用了缓冲模式，则可以使用单个XMLSource实例多次查询同一输入源。</p><p>这里有些例子：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">InputStream is = new ByteArrayInputStream("&lt;foo&gt;&lt;bar attr=\"3\"&gt;barValue&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);
// query 1
String value = xp.getValue("/foo/bar/@attr");
assertEquals("3", value);

// query 2
Integer intValue = xp.getNode("/foo/bar/@attr", Integer.class);
assertEquals(3, intValue);

// query 3
Node node = xp.getNode("/foo/bar/@attr", Node.class);
assertEquals("3", node.getTextValue());
</pre>
</div></div><p>在上面的示例中，使用相同的XMLSource实例以多种方式访问原始属性节点。<br clear="none">匹配的XML复杂（元素）节点可以通过类似的方式进行转换：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public class Bar {
    @XmlAttribute
    private String attr;  
    public String getAttribute() {
        return attr;
    } 
}

InputStream is = new ByteArrayInputStream("&lt;foo&gt;&lt;bar attr=\"3\"&gt;barValue&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);

// query 1
Bar bean = xp.getNode("/foo/bar", Bar.class);
assertEquals("3", bean.getAttribute());
 
// query 2
String value = xp.getValue("/foo/bar");
assertEquals("&lt;bar attr=\"3\"&gt;barValue&lt;/bar&gt;", value);
</pre>
</div></div><p>请注意，JAXB在内部用于将匹配的XML元素转换为Bar之类，而该类不必具有@XmlRootElement批注。上例中的第二个查询如何捕获匹配的复杂节点的字符串表示形式。</p><p>XMLSource还提供了捕获多个节点的方法，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">InputStream is = new ByteArrayInputStream("&lt;foo&gt;&lt;bar attr=\"3\"&gt;value1&lt;/bar&gt;&lt;bar attr=\"4\"&gt;value2&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);
// query 1
String[] values = xp.getValue("/foo/bar/text()");
assertEquals("value1", values[0]);
assertEquals("value2", values[1]);

// query 2
Integer[] intValues = xp.getNodes("/foo/bar/@attr", Integer.class);
assertEquals(3, intValues[0]);
assertEquals(4, intValues[1]);

// query 3
Bar[] nodes = xp.getNodes("/foo/bar", Bar.class);
</pre>
</div></div><p>以上所有示例均已简化，因为未使用任何名称空间。大多数真实的XML实例都会有很多实例，XMLSource的方法可以接受包含前缀作为键和名称空间作为值的可选映射：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">InputStream is = new ByteArrayInputStream("&lt;foo xmlns=\"http://foo\"&gt;&lt;ns1:bar xmlns:ns1=\"http://bar\" attr=\"3\"&gt;barValue&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);

Foo foo = xp.getNode("/ps1:foo", Collections.singletonMap("ps1", "http://foo"), Foo.class);
assertNotNull(foo);

Bar foo = xp.getNode("/ps2:bar", Collections.singletonMap("ps2", "http://bar"), Bar.class);
assertNotNull(foo);
</pre>
</div></div><p>在上面的示例中，默认的“ http：// foo”命名空间限定了根“ foo”元素，而其“ bar”子元素则受到了<br clear="none">“ http：// bar”命名空间。请注意，XMLSource配置为确保选中了这些名称空间，但是使用的前缀不必与实际XML实例中的前缀匹配，实际的XML实例甚至根本没有它们，例如，使用默认名称空间时。</p><p>XMLSource还提供了几种方法来捕获表示HTTP链接的属性或文本值：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">String xmlString = "&lt;customers xmlns=\"http://customers\"&gt;
                    + "&lt;customer id="1" homepage=\"http://customers/1\"/&gt;"
                    + "&lt;/customers&gt;";
InputStream is = new ByteArrayInputStream(xmlString.getBytes());
XMLSource xp = new XMLSource(is);

URI homePage = xp.getLink("/ps1:customer[@id='1']/@homePage", 
                           Collections.singletonMap("ps1", "http://customers"));
WebClient client = WebClient.create(homePage);
// access the home page
</pre>
</div></div><p>在上面的示例中，检索到ID等于“ 1”的客户主页的链接，该链接用于创建WebClient实例。</p><p>在某些情况下，链接是相对的。在这种情况下，应用程序代码已经知道基本URI，或者可以将其指定为<a shape="rect" class="external-link" href="http://www.w3.org/TR/xmlbase/" rel="nofollow">xml：base</a>属性的值。在后一种情况下，XMLSource使得获取此基本URI变得容易：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">String xmlString = "&lt;customers xmlns=\"http://customers\" xml:base="http://customers"&gt;
                    + "&lt;customer id="1"/&gt;&lt;customer id="2"/&gt;"
                    + "&lt;/customers&gt;";
InputStream is = new ByteArrayInputStream(xmlString.getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);

URI baseURI = xp.getBaseURI();
URI[] relativeURIs = xp.getLinks("/ps1:customer/@id", Collections.singletonMap("ps1", "http://customers"));

WebClient client = WebClient.create(baseURI);
for (URI uri: relativeURIs) {
  client.path(uri);
  // access the home page
  
  // and get back to the base URI
  client.back(true); 
}
</pre>
</div></div><p>在最后一个示例中，客户id还表示相对URI，其中xml：base属性指向基本URI。<br clear="none">XMLSource用于获取所有相对URI，使用基本URI创建一个WebClient，然后使用各个相对URI进行迭代。</p><h2 id="JAX-RSAdvancedXML-UsingXMLSourceandXPathProviderintheapplicationcode">在应用程序代码中使用XMLSource和XPathProvider</h2><p>请参阅<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-client-api.html#JAX-RSClientAPI-XMLcentricclients">本节</a> ，以HTTP为中心的WebClient如何使用XPath，下面是服务器端的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("/root")
public class Root {
   @POST
   public void post(XMLSource source) {
       String value = source.getProperty("/books/book/@name");
   }    
}
</pre>
</div></div><p>通过在客户端或服务器端注册XPathProvider（即JAX-RS MessageBodyReader），用户可以选择隐藏XPath表达式。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">XPathProvider provider = new XPathProvider();
provider.setGlobalExpression("/books/book[position() = 1]");
WebClient wc = WebClient.create("http://aggregated/data", Collections.singletonList(provider));
Book b = wc.get(Book.class);
</pre>
</div></div><h1 id="JAX-RSAdvancedXML-XSLTsupport">XSLT支持</h1><p><a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/XSLTJaxbProvider.java">XSLTJaxbProvider</a>当前支持XSLT。该提供程序的工作依赖于JAXB来启动转换过程，并且可以用于产生几乎所有格式，包括非XML格式。同样，它可以用于从传入的XML片段中提取XML数据。可以在服务器和客户端上使用此提供程序。</p><p>请参阅此<a shape="rect" class="external-link" href="http://sberyozkin.blogspot.com/2009/05/mvc-xml-way-with-cxf-jax-rs.html" rel="nofollow">博客条目</a> ，以概述该提供程序如何帮助将表示逻辑与主要应用程序代码分离。</p><p>可以将XSLTJaxbProvider配置为处理输入或输出数据，如果需要，可以根据媒体类型确定范围。例如，可以配置一个模板，以便一个模板仅处理“ application / xml”格式，而另一个模板仅处理“ application / json”写入。</p><p>XSLTJaxbProvider使用注入的JAX-RS UriInfo将所有常见的JAX-RS信息（例如模板或查询参数）注入给定的XSLT模板。这些参数将使用与相应的@ PathParam，QueryParam等值相等的名称进行注入。另外，绝对，基本和相对路径URI将作为“ absolute.path”，“ base.path”和“ relative.path”参数注入。最后，还可以注入自定义的inParameters和outParameters映射属性，并将它们添加到所有XSLT模板实例中。</p><p>例如，给定此资源方法定义：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("/root")
public class Root {
   @GET
   @Path("{id}") 
   @Produces({"application/xml", "application/json", "text/html"} )
   public Book get(@PathParam("id") String id, @QueryParam("name") String name) {
       return getBook(id, name);
   }    
}
</pre>
</div></div><p>XSLT模板将注入名称为“ id”和“ name”的参数。在这种特殊情况下，拥有两个模板可能是有意义的，一个模板仅用于处理Book XML流（由JAXB生成），另一个模板用于添加HTML特定元素。特定于HTML的模板很可能会导入处理Book流的模板。</p><p>以下是一些如何配置XSLTJaxbTemplate的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">   &lt;map id="outTemplates"&gt;
      &lt;entry key="application/xml" value="classpath:/WEB-INF/templates/book-xml.xsl"/&gt;
      &lt;entry key="text/html" value="classpath:/WEB-INF/templates/book-html.xsl"/&gt;
      &lt;entry key="application/json" value="classpath:/WEB-INF/templates/book-json.xsl"/&gt;
  &lt;/map&gt;
  
  &lt;bean id="uriResolver" class="org.apache.cxf.systest.jaxrs.URIResolverImpl"/&gt;
  
  &lt;bean id="xsltProvider" class="org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"&gt;    
      &lt;property name="outMediaTemplates" ref="outTemplates"/&gt;
      &lt;property name="resolver" ref="uriResolver"/&gt;
  &lt;/bean&gt;
</pre>
</div></div><p>在此示例中，该提供程序注入了三个输出模板，一个用于修改Book XML流，另一个用于创建HTML Book表示，最后一个用于编写现有JSON提供程序可能无法编写的JSON序列。生成。</p><p>可以使用“ uriResolver”属性指向自定义javax.xml.transform。URIResolver实现，可用于解析一些XSLT指令中的相对链接，例如“ import” / etc。也可以设置“ systemId”属性。此外，可以注入inProperty和outProperty映射属性，并在创建XSLT模板实例时使用它们。</p><p>这是一个更简单的配置示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">   &lt;bean id="xsltProvider" class="org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"&gt;    
      &lt;property name="outTemplate" value="classpath:/WEB-INF/templates/book-xml.xsl"/&gt;
      &lt;property name="inTemplate" class="classpath:/WEB-INF/templates/fromNewBookToOldBook.xsl"/&gt;
  &lt;/bean&gt;
</pre>
</div></div><p>提供者配置有一个输出模板和一个输入模板，它们将应用于所有请求和响应数据。</p><p>当使用XSLTJaxbProvider处理传入请求时，其主要目标是确保可以根据需要调整传入XML，以使JAXB解组成功。in模板可以通过多种方式修改传入的XML，也可以从更大的XML实例中提取XML片段，这与XMLSource和XPathProvider可以执行的操作类似。另请检查新的<a shape="rect" href="http://cxf.apache.org/docs/transformationfeature.html">转换</a>功能。</p><p>请注意，如果需要，XSLTJaxbProvider可以与同一端点上的其他XML感知提供程序一起使用。在这种情况下，需要限制它可以处理的类集，以免干扰其他XML提供程序。可以使用inClassNames和outClassNames列表属性（枚举支持的类名）来完成此操作。或者，可以设置新的“ supportJaxbOnly”属性，在这种情况下，如果给定类没有模板，则XSLTJaxbProvider将仅委托给JAXBElementProvider。</p><p>请注意，在客户端使用XSLTJaxbProvider时，在使用以HTTP为中心的客户端（而不是代理）的情况下，并非总是可以注入模板参数。例如 ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">WebClient client = WebClient.create("http://books");
client.path("/store/1").get();
</pre>
</div></div><p>不可能推断出“ 1”代表“ / store / 1”表达式中的模板参数。但是，如果XSLT模板需要使用“ 1”，则可以改用以下代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">WebClient client = WebClient.create("http://books");
client.path("/store/{id}", 1).get();
</pre>
</div></div><h1 id="JAX-RSAdvancedXML-XMLProcessingInstructions">XML处理说明</h1><p>一种将出站XML转换为HTML或进一步用CSS标签修饰的XHTML有效负载的方法是将<a shape="rect" class="external-link" href="http://www.w3.org/TR/xml-stylesheet/" rel="nofollow">xml样式表处理指令</a>与XML有效负载<a shape="rect" class="external-link" href="http://www.w3.org/TR/xml-stylesheet/" rel="nofollow">相关联</a> ，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;?xml-stylesheet type="text/xsl" href="http://localhost/myapp/stylesheets/toHTML.xsl"?&gt;
&lt;products xmlns="http://products"&gt;
   &lt;product id="1"/&gt;
&lt;/products&gt;
</pre>
</div></div><p>浏览器将从服务器获取样式表，并在客户端计算机上转换此XML。<br clear="none">该选项是使用XSLTJaxbProvider在服务器端创建HTML的替代方法。如果XSL样式表导入其他文档或依靠其他参数来生成HTML，则使用起来可能会变得不那么容易，但是在某些情况下，它肯定可以用来减轻服务器转换的成本。</p><p>您还可以结合使用XSLTJaxbProvider在服务器上创建复杂的HTML，并使用xml-stylesheet指令来使浏览器下载和缓存CSS样式表，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;?xml-stylesheet type="text/css" href="http://localhost/myapp/stylesheets/HTMLDecorator.css"?&gt;
&lt;! 
   XSLTJaxbProvider transformed the XML products payload into well-formed XHTML.
   The browser will get HTMLDecorator.css at the next step and apply it to this HTML 
--&gt;
&lt;html&gt;
   &lt;title&gt;The products&lt;/title&gt;
   &lt;table&gt;
     &lt;!-- description of products --&gt;
   &lt;/table&gt;
&lt;/html&gt;
</pre>
</div></div><p>使用JAXB时，添加此类xml处理指令的方法是设置一个<br clear="none">JAXB Marshaller上的“ com.sun.xml.bind.xmlHeaders”或“ com.sun.xml.internal.bind.xmlHeaders”。</p><p>直到CXF 2.5.1为止，方法是使用JAXBElementProvider'marshallerProperties'映射属性，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
&lt;map&gt;
&lt;entry key="com.sun.xml.bind.xmlHeaders" 
       value="&lt;?xml-stylesheet type='text/xsl' href='/stylesheets/toHTML.xsl'?&gt;"/&gt;
&lt;/map&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</pre>
</div></div><p>这里的问题是如何正确指向标识toHTML.xsl资源的绝对URI。<br clear="none">假设浏览器将正确解析相对URI，例如“ /stylesheets/toHTML.xsl”，则全部设置完毕。<br clear="none">否则，最好的选择是扩展JAXBElementProvider并通过使用JAX-RS UriInfo来获取基本请求URI来设置marshaller属性。</p><p>从CXF 2.5.1和2.4.5开始，可以使用<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XMLInstruction.java">XMLInstruction</a>注释：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XMLInstruction("&lt;?xml-stylesheet type='text/xsl' href='/stylesheets/toHTML.xsl'?&gt;")
   public Products getProducts() {}
}
</pre>
</div></div><p>让我们假设一个运行带有“ / services / *”的CXFServlet的“ myapp” Web应用程序，它可以接受诸如“ GET <a shape="rect" class="external-link" href="http://localhost/myapp/services/products" rel="nofollow">http：// localhost / myapp / services / products</a> ”之类的请求。</p><p>上面的相对href值将转换为“ http：//localhost/myapp/stylesheets/toHTML.xsl”，从而使CXFServlet不会“覆盖”资源变得容易。考虑到资源文件夹的名称可能更改，如果您甚至不想在href ='/ stylesheets / toHTML.xsl'中甚至列出'stylesheets'怎么办？<br clear="none">使用JAXBElementProvider的'xmlResourceOffset'属性：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
&lt;property name="xmlResourceOffset" value="stylesheets"/&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</pre>
</div></div><p>并且只有href ='toHTML.xsl'。如果需要，还可以使用xmlResourceOffset来确保CXFServlet覆盖绝对URI。</p><h1 id="JAX-RSAdvancedXML-XSLTTransform">XSLTTransform</h1><p> </p><p><a shape="rect" class="external-link" href="https://git-wip-us.apache.org/repos/asf?p=cxf.git;a=blob;f=rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XSLTTransform.java;h=245106caa903c4ec4612fb65ecc01061004fae67;hb=HEAD">XSLTTransform</a>是CXF 3.0.0中引入的新注释。它可以支持服务器或客户端驱动的转换。</p><p>单个XSLTTransform批注也可以支持客户端和服务器转换。</p><p>其“ mediaTypes”属性（如果启用）用于将基于服务器的转换仅限制为列出的媒体类型，并且应是“ JAX-RS产生值”的子集。</p><p> </p><p>XSLTTransform可以在SERVER，CLIENT或BOTH模式下使用。</p><p>为了使其对服务器端转换（SERVER，BOTH）有效，必须将其与XSLTJaxbProvider结合使用。</p><p>默认的JAXBElementProvider将独立支持XSLTransform CLIENT模式。</p><p>当在CLIENT或BOTH模式下使用它来让客户端运行转换时，它由JAXBElementProvider处理并转换为XML XSL指令。</p><p>在BOTH模式下使用它可以有效地支持转换“协商”：可以自行执行转换的客户端将在响应XML有效负载中添加XML XSL指令，</p><p>在其他情况下，服务器将运行转换。</p><p>例子：</p><p> </p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">// server based Products to XML transformation
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XSLTTransform("template.xsl")
   public Products getProducts() {}
}

// server based Products to HTML transformation, 
// Product to XML is not affected
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml", "text/html")
   @XSLTTransform(value = "template.xsl", mediaTypes = {"text/html"})
   public Products getProducts() {}
}

// client based Products XML to XML transformation
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XSLTTransform(value = "template.xsl", type = CLIENT)
   public Products getProducts() {}
}

// client based Products XML to HTML transformation, 
// Product to XML is not affected
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml", "text/html")
   @XSLTTransform(value = "template.xsl", type = CLIENT, mediaTypes = {"text/html"})
   public Products getProducts() {}
}

// clients with "Accept: application/xml" will do Products XML to HTML transformation 
// clients with "Accept: text/html" will have server-based Products to HTML transformation
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml", "text/html")
   @XSLTTransform(value = "template.xsl", type = BOTH, mediaTypes = {"text/html"})
   public Products getProducts() {}
}&#160;





&#160;</pre>
</div></div><p> </p><p>通常，除非使用BOTH模式，否则不需要使用XSLTTransform的附加属性来配置XSLT或JAXB提供程序，在这种情况下，只需将XSLTJaxbProvider设置为“ supportJaxbOnly”：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean id="xsltProvider" class="org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"&gt;
&lt;property name="supportJaxbOnly" value="true"/&gt;
&lt;/bean&gt;
</pre>
</div></div><p>上面的配置足以支持XSLTTransform BOTH模式。</p><h1 id="JAX-RSAdvancedXML-XSISchemaLocation">XSI架构位置</h1><p>某些工具（例如<a shape="rect" class="external-link" href="http://office.microsoft.com/en-us/excel-help/get-and-analyze-data-from-the-web-in-excel-HA001054848.aspx" rel="nofollow">Microsoft Excel）</a>可以执行WEB查询并导入XML有效负载，但是该有效负载应使用xsi：schemaLocation属性，该属性指向描述该XML的XML模式文档，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;products xmlns="http://products"
   xmlns:xsi=""http://www.w3.org/2000/10/XMLSchema-instance""
   xsi:schemaLocation="http://localhost/myapp/schemas/product.xsd"&gt;
   &lt;product id="1"/&gt;
&lt;/products&gt;
</pre>
</div></div><p>为了使用JAXB设置此属性，需要使用“ javax.xml.bind”。马歇尔。可以直接在JAXBElementProvider上设置“ JAXB_SCHEMA_LOCATION”属性（类似于XML处理指令的设置方法，请参见上一节），或者从CXF 2.5.1开始，借助新的<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XSISchemaLocation.java">XSISchemaLocation</a>批注：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XSISchemaLocation("schemas/products.xsd")
   public Products getProducts() {}
}
</pre>
</div></div><p>请参阅上一部分，关于如何借助JAXBElementProvider来影响给定架构的绝对URI。<br clear="none">请注意，如果给定架构没有目标名称空间，则XSISchemaLocation的noNamespace属性可能设置为“ true”。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=24190965">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=24190965&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>