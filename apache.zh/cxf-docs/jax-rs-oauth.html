<html ><head></head><body  onload="init()">﻿

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS OAuth">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS OAuth</title>
  



<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-oauth.html">JAX-RS OAuth</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><span style="font-size:2em;font-weight:bold">JAX-RS：OAuth</span>


 </p><p> </p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1524513373682 {padding: 0px;}
div.rbtoc1524513373682 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1524513373682 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1524513373682">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth-Introduction">介绍</a></li><li><a shape="rect" href="#JAX-RSOAuth-Mavendependencies">Maven依赖</a></li><li><a shape="rect" href="#JAX-RSOAuth-DevelopingOAuth1.0Servers">开发OAuth 1.0服务器</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth-RequestTokenService">RequestTokenService</a></li><li><a shape="rect" href="#JAX-RSOAuth-AuthorizationRequestService">AuthorizationRequestService</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth-OOBcallbacks">OOB回调</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth-AccessTokenService">AccessTokenService</a></li><li><a shape="rect" href="#JAX-RSOAuth-WritingOAuthDataProvider">编写OAuthDataProvider</a></li><li><a shape="rect" href="#JAX-RSOAuth-OAuthServerJAX-RSendpoints">OAuth服务器JAX-RS端点</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth-ProtectingresourceswithOAuthfilters">使用OAuth过滤器保护资源</a></li><li><a shape="rect" href="#JAX-RSOAuth-Howtogettheuserloginname">如何获得用户登录名</a></li><li><a shape="rect" href="#JAX-RSOAuth-Client-sidesupport">客户端支持</a></li><li><a shape="rect" href="#JAX-RSOAuth-2-legOAuthFlow">两段式OAuth流程</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth-ClientrequestsPreAuthorizedRequestToken">客户端请求预授权的RequestToken</a></li><li><a shape="rect" href="#JAX-RSOAuth-SignaturewithConsumerKeyandSecret">带有消费者密钥和秘密的签名</a></li><li><a shape="rect" href="#JAX-RSOAuth-OnlyConsumerKeyandSecretinAuthorizationheader">授权标头中只有使用者密钥和机密</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth-OAuthWithoutaBrowser">没有浏览器的OAuth</a></li><li><a shape="rect" href="#JAX-RSOAuth-Reportingtheerrordetails">报告错误详细信息</a></li><li><a shape="rect" href="#JAX-RSOAuth-Designconsiderations">设计注意事项</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth-ControllingtheAccesstoResourceServer">控制对资源服务器的访问</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSOAuth-Sharingthesameaccesspathbetweenendusersandconsumers">在最终用户和消费者之间共享相同的访问路径</a></li><li><a shape="rect" href="#JAX-RSOAuth-Providingdifferentaccesspointstoendusersandconsumers">为最终用户和消费者提供不同的访问点</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth-SingleSignOn">单点登录</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSOAuth-WhatIsNext">接下来是什么</a></li></ul>
</div><h1 id="JAX-RSOAuth-Introduction">介绍</h1><p>CXF 2.5.0实现了<a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc5849" rel="nofollow">OAuth 1.0</a> 。另请参阅有关CXF中OAuth2支持的<a shape="rect" href="jax-rs-oauth2.html">JAX-RS OAuth2</a> 。</p><p>虽然<a shape="rect" class="external-link" href="http://oauth.net/2/" rel="nofollow">OAuth 2.0</a> （即将成为最终建议）是OAuth的下一个主要版本，但许多提供程序都已实现OAuth 1.0，并且CXF OAuth 1.0模块应使开发人员可以轻松地开始编写OAuth 1.0应用程序。</p><p>OAuth 1.0提供了一个复杂而优雅的解决方案，以帮助最终用户（资源所有者）授权第三方提供商访问其资源。</p><p>传统的OAuth流也称为3腿OAuth流，因为它涉及3个参与方：最终用户（资源所有者），第三方服务（客户端，消费者）和受OAuth过滤器保护的资源服务器。通常，消费者提供最终用户请求的服务功能，并且要求前者访问位于资源服务器上的该最终用户的一个或多个资源。例如，消费者可能需要访问最终用户的照片以便将其打印并发布给用户，或者阅读并可能更新用户的日历以进行预订。</p><p>为了实现这一点，第三方服务应用程序/消费者需要向OAuth服务器注册自己。这是带外发生的，注册后，消费者将获得消费者密钥和秘密对。例如，请参阅此页面了解一种<a shape="rect" class="external-link" href="http://code.google.com/apis/accounts/docs/RegistrationForWebAppsAuto.html" rel="nofollow">方法</a> 。对于较简单的应用程序，不必过多地涉及第三方应用程序的注册。</p><p>从那时起，典型流程如下所示：<br clear="none">1。最终用户使用浏览器请求第三方服务。</p><p>2。第三方服务向OAuth RequestToken Service请求临时请求令牌；此令牌将表示消费者打算访问其需要完成当前用户请求的任何最终用户资源。</p><p>3。取回请求令牌后，使用者将最终用户重定向到OAuth授权服务，并将请求令牌添加到目标URI。</p><p>4。授权服务将使用请求令牌获取有关当前使用者的所有详细信息，构建一个HTML表单并将其返回给最终用户。该表格将询问用户是否可以允许给定的第三方应用程序代表该用户访问某些资源。</p><p>5，如果用户批准，则授权服务将在请求请求令牌时将用户重定向回消费者提供的回调uri，其中包括生成的验证程序（授权密钥），该验证程序将用户的批准与请求令牌“链接”。</p><p>6。现在，第三方服务通过提供请求令牌及其验证程序，从OAuth AccessToken Service请求访问令牌。</p><p>7。获取访问令牌后，服务最终继续访问当前用户的资源并完成用户的请求。</p><p>如上所述，使用者需要先向OAuth服务器注册。提供应用程序名称和所谓的connect URI（这通常是此应用程序的公共URI）是一个好习惯。前者将由OAuth授权服务在上面的第4步中使用，后者将在第2步中用于验证所提供的回调URI，以确保其从注册过程中实际提供的URI开始。</p><p>如您所见，流程可能很复杂，但是可以正常工作。在此过程中可能需要注意许多问题，例如管理过期的令牌，确保OAuth安全层正常运行并且不会干扰尝试访问其自身资源的最终用户本身，等等。</p><p>请检查<a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc5849" rel="nofollow">规范</a>和<a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/OAuth" rel="nofollow">Wikipedia文章</a>以及WEB上的其他资源，以获取有关OAuth可能需要了解的更多信息。</p><p>CXF JAX-RS尽最大努力使此过程尽可能简单，并且代表OAuth服务器开发人员仅需最少的工作。它还提供了实用程序代码，可大大简化第三方应用程序与OAuth服务端点进行交互的方式。</p><h1 id="JAX-RSOAuth-Mavendependencies">Maven依赖</h1><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-rs-security-oauth&lt;/artifactId&gt;
  &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><h1 id="JAX-RSOAuth-DevelopingOAuth1.0Servers">开发OAuth 1.0服务器</h1><p>OAuth服务器是完整的基于OAuth的解决方案的核心部分。通常，它包含3种服务：</p><ul class="alternate"><li>通过向消费者临时发行令牌来启动流程</li><li>通过要求最终用户让消费者访问其一些资源并返回请求的令牌来授权请求令牌<br clear="none">确认回消费者</li><li>将授权的请求令牌交换为访问令牌</li></ul><p>CXF提供了3种JAX-RS服务实现，可用于快速创建OAuth 1.0服务器： <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/RequestTokenService.java" rel="nofollow">RequestTokenService</a> ， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AccessTokenService.java" rel="nofollow">AccessTokenService</a> 。</p><p>所有这三个服务都依赖于管理请求和访问令牌的自定义<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a> 。要启动和运行OAuth服务器，需要编写自己的OAuthDataProvider实现。</p><h2 id="JAX-RSOAuth-RequestTokenService">RequestTokenService</h2><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/RequestTokenService.java" rel="nofollow">RequestTokenService</a>的主要职责是创建一个临时请求令牌，并将其返回给使用者。它支持POST和GET请求，并返回包含新请求令牌及其密码的表单有效内容。</p><p>这是一个示例请求日志：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/oauth/initiate
Encoding: ISO-8859-1
Http-Method: POST
Content-Type: */*
Headers: {
Accept=[application/x-www-form-urlencoded], 

Content-Length=[0],

Authorization=[OAuth oauth_callback="http%3A%2F%2Flocalhost%3A8080%2Fservices%2Freservations%2Freserve%2Fcomplete", 
                     oauth_nonce="e365fa02-772e-4e33-900d-00a766ccadf8", 
                     oauth_consumer_key="123456789", 
                     oauth_signature_method="HMAC-SHA1", 
                     oauth_timestamp="1320748683", 
                     oauth_version="1.0", 
                     oauth_signature="ztTQuqaJS7L6dNQwn%2Fqi1MdaqQQ%3D"] 
}
</pre>
</div></div><p>这是一个空的POST请求，其中包含Authorization OAuth标头。标头的值具有使用者密钥（在第三方注册期间获得），指向AuthorizationRequestService返回授权令牌的位置的回调URI和使用<a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc5849#section-3.4.2" rel="nofollow">规范中所述</a>的使用者密钥和秘密对计算的签名。</p><p>首先，RequestTokenService验证签名，然后使用使用者密钥从OAuthDataProvider检索<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java">Client</a>实例。</p><p>在要求OAuthDataProvider生成请求令牌之前，它会尝试针对<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">客户端</a>的应用程序URI验证回调URI。</p><p>最后，它委托给OAuthDataProvider创建一个请求令牌，并向其中传递一个填充的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/RequestTokenRegistration.java" rel="nofollow">RequestTokenRegistration</a> bean。</p><p>该bean引用一个Client实例，回调URI和一个状态。状态是消费者在使用“状态”参数进行请求令牌请求期间可能还包括的东西，并且在请求令牌被授权后将与验证程序一起返回给消费者。例如，它可以表示一个密钥，供消费者在请求令牌时用来检索请求正在处理的请求的状态。对于OAuth 1.0<br clear="none">使用者，请求令牌本身可能代表用于此目的的足够好的密钥，但是可能也需要使用“状态”，并且对于OAuth 2.0来说将变得更加有用。</p><p>Bean还包括“ issuedAt”和“ lifetime”值，它们表示将要创建新令牌的时间以及该令牌将“存在”的可配置时间（以毫秒为单位）。如果需要，OAuthDataProvider可以在实际创建请求令牌之前随意重置这些值。</p><p>最后，可以在此bean实例上设置另一个属性：作用域列表。作用域列表表示使用者访问资源可能需要的可选权限。这些可以通过“ x_oauth_scope”（OAuth 2.0中为“ scope”）请求参数提供，例如，</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Authorization=[OAuth ..., 
                     x_oauth_scope="readCalendar updateCalendar"]
</pre>
</div></div><p>预期在创建新请求令牌期间，每个x_oauth_scope值（例如“ readCalendar”和“ updateCalendar”）都将转换为<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermission</a> 。如果未提供x_oauth_scope参数，则OAuth数据提供程序可能会将默认OAuthPermission实例分配给新令牌。</p><p>OAuthDataProvider创建新的请求令牌后，RequestTokenService将令牌密钥和秘密对返回给使用者：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Response-Code: 200
Content-Type: application/x-www-form-urlencoded
Headers: {Date=[Tue, 08 Nov 2011 10:38:03 GMT]}
Payload: 
oauth_callback_confirmed=true&amp;oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2&amp;oauth_token_secret=ca8273df-b9b0-43f9-9875-cfbb54ced550
</pre>
</div></div><p>使用者现在准备将当前最终用户重定向到<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a> 。</p><h2 id="JAX-RSOAuth-AuthorizationRequestService">AuthorizationRequestService</h2><p>AuthorizationRequestService的主要职责是向最终用户提供一个表格，要求用户允许或拒绝消费者访问某些用户资源。</p><p>请记住，第三方使用者将当前用户重定向到<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a> ，例如，以下是可能发生的重定向：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Response-Code: 303
Headers: {Location=[http://localhost:8080/services/social/authorize?oauth_token=f4415e16-56ea-465f-9df1-8bd769253a7d]}
</pre>
</div></div><p>使用者应用程序要求当前用户（浏览器）转到Location标头提供的新地址，对AuthorizationRequestService的后续请求将如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/social/authorize?oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2
Http-Method: GET
Content-Type: 
Headers: {
Accept=[text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8],   
Referer=[http://localhost:8080/services/forms/reservation.jsp], 
...
}
</pre>
</div></div><p>首先， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/AuthorizationRequestService.java" rel="nofollow">AuthorizationRequestService</a>将使用“ oauth_token”查询参数提供的值从OAuthDataProvider检索<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/RequestToken.java" rel="nofollow">RequestToken</a> （它扩展了基本<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Token.java" rel="nofollow">Token</a>类）。</p><p>接下来，它使用此令牌（也链接到客户端）填充<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData</a> bean的实例并返回它。OAuthAuthorizationData包含应用程序名称和URI属性， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Permission.java" rel="nofollow">Permission</a>和URI的可选列表。</p><p>另外两个重要的OAuthAuthorizationData属性是“ oauthToken”和“ authenticityToken”，这两个属性对于处理来自授权表单的决策请求都很重要。前者是请求令牌密钥，AuthorizationRequestService将使用该令牌再次检索RequestToken，后者用于验证当前会话未被劫持-AuthorizationRequestService生成一个随机密钥，将其存储在Servlet HTTPSession实例中，并期望返回的authenticityToken值以匹配它-这是一种推荐方法，它还意味着对用户隐藏了authenticityToken值，例如，将其保存在“隐藏”表单字段中。</p><p>帮助程序的“ replyTo”属性是一个绝对URI，用于标识处理用户决策的AuthorizationRequestService处理程序，并且在构建表单时可以由视图处理程序或其他OAuthAuthorizationData处理程序使用。</p><p>因此，最终返回了填充的OAuthAuthorizationData。请注意，它是一个带有JAXB XMLRootElement注释的bean，并且如果AuthorizationRequestService支持生成“ application / xml”和“ application / json”，则可以由注册的JAXB或JSON提供程序进行处理（有关更多信息，请参见下面的“没有浏览器的OAuth”部分）。但是在这种情况下，我们让最终用户使用浏览器，因此HTML表单才是真正期望的。</p><p>AuthorizationRequestService支持生成“ text / html”，并且仅依赖于注册的<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-redirection.html#JAX-RSRedirection-WithRequestDispatcherProvider">RequestDispatcherProvider</a>即可将OAuthAuthorizationData bean设置为HttpServletRequest属性，并将响应重定向到视图处理程序（可以是JSP或某些其他Servlet）以实际构建表单并将其返回给用户。另外，注册<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-advanced-xml.html#JAX-RSAdvancedXML-XSLTsupport">XSLTJaxbProvider</a>也是创建HTML视图的一个不错的选择。</p><p>假设使用RequestDispatcherProvider，以下示例日志显示了来自AuthorizationRequestService的初始响应：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">08-Nov-2011 13:32:40 org.apache.cxf.jaxrs.provider.RequestDispatcherProvider logRedirection
INFO: Setting an instance of "org.apache.cxf.rs.security.oauth.data.OAuthAuthorizationData" 
as HttpServletRequest attribute "data" and redirecting the response to "/forms/oauthAuthorize.jsp".

08-Nov-2011 13:32:40 org.apache.cxf.interceptor.LoggingOutInterceptor
---------------------------
Response-Code: 200
Content-Type: text/html
</pre>
</div></div><p>请注意，“ / forms / oauthAuthorize.jsp”视图处理程序将创建一个HTML视图-这是一个自定义JSP处理程序，可以使用OAuthAuthorizationData bean构建该视图，从而在其中创建所需的任何HTML视图。您很可能希望提供一个表格，要求用户允许或拒绝消费者访问该用户的某些资源。如果OAuthAuthorizationData设置了权限列表，则需要添加有关权限的信息，这与URI列表相同。</p><p>接下来，用户做出决定并选择允许或拒绝消费者访问资源的按钮。AuthorizationRequestService不需要知道如何要求用户做出决定，但是它希望接收基于表单的提交，该提交包含以下三个参数，它们的值与OAuthAuthorizationData的“ authenticityToken”的值匹配，分别为“ session_authenticity_token”和“ oauth_token”。和“ oauthToken”属性，以及带有“ allow”或“ deny”值的“ oAuthDecision”：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/social/authorize/decision
Http-Method: POST
Content-Type: application/x-www-form-urlencoded
Headers: {
Authorization=[Basic YmFycnlAc29jaWFsLmNvbToxMjM0],
Cookie=[JSESSIONID=eovucah9rwqp], 
Referer=[http://localhost:8080/services/social/authorize?oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2], 
User-Agent=[Mozilla/5.0 (X11; Linux x86_64; rv:2.0) Gecko/20100101 Firefox/4.0]}
--------------------------------------
09-Nov-2011 16:41:58 org.apache.cxf.jaxrs.utils.FormUtils logRequestParametersIfNeeded
INFO: session_authenticity_token=e52b5033-9bf5-4b34-9d3a-39a7d5b7e686&amp;oauthDecision=allow
&amp;oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2
</pre>
</div></div><p>AuthorizationRequestService将使用session_authenticity_token验证会话是否有效，然后将处理用户决定。<br clear="none">如果将其设置为“ allow”，它将要求OAuthDataProvider生成授权密钥（验证程序），并通过将当前用户重定向回请求期间提供的回调URI来返回此验证程序以及请求令牌密钥和状态（如果有）令牌请求：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Response-Code: 303
Headers: {
Location=[http://localhost:8080/services/reservations/reserve/complete?
oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2&amp;oauth_verifier=00bd8fa7-4233-42a2-8957-0a0a22c684ba]
}
</pre>
</div></div><p>这导致浏览器重定向用户：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/reservations/reserve/complete?
oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2&amp;oauth_verifier=00bd8fa7-4233-42a2-8957-0a0a22c684ba
Http-Method: GET
Content-Type: 
Headers: {
Authorization=[Basic YmFycnlAc29jaWFsLmNvbToxMjM0], 
Cookie=[JSESSIONID=eovucah9rwqp],
Referer=[http://localhost:8080/services/social/authorize?oauth_token=6dfd5e52-236c-4939-8df8-a53212f7d2a2], 
User-Agent=[Mozilla/5.0 (X11; Linux x86_64; rv:2.0) Gecko/20100101 Firefox/4.0]}
</pre>
</div></div><p>如果用户决定设置为“拒绝”，则不会将任何验证程序发送回消费者。</p><p>假设该决定是“允许的”，那么消费者现在已经收到了返回请求令牌及其验证者的信息，并准备将这对交换为访问令牌。</p><h3 id="JAX-RSOAuth-OOBcallbacks">OOB回调</h3><p>OAuth 1.0提到了所谓的“ oob”（带外）回调。如果第三方客户端未作为Web应用程序运行，或者已知第三方客户端由于某种原因而无法从AuthorizationRequestService接收重定向响应，则可以在请求令牌为的情况下将回调URI设置为“ oob”。<br clear="none">要求：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/oauth/initiate
Encoding: ISO-8859-1
Http-Method: POST
Content-Type: */*
Headers: {
Accept=[application/x-www-form-urlencoded], 

Content-Length=[0],

Authorization=[OAuth oauth_callback="oob", 
                     oauth_nonce="e365fa02-772e-4e33-900d-00a766ccadf8", 
                     oauth_consumer_key="123456789", 
                     oauth_signature_method="HMAC-SHA1", 
                     oauth_timestamp="1320748683", 
                     oauth_version="1.0", 
                     oauth_signature="ztTQuqaJS7L6dNQwn%2Fqi1MdaqQQ%3D"] 
}
</pre>
</div></div><p>如果在客户端应用程序注册过程中将客户端callbackURI属性设置为“ oob”，则RequestTokenService将仅接受“ oob”值。具体来说，RequestTokenService将期望<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">Client</a> bean将其callbackURI属性设置为“ oob”。</p><p>当回调URI设置为“ oob”时，这意味着需要将用户决策响应直接呈现给当前用户-这将使请求令牌和验证者信息以某种方式可用于客户端应用程序。在“ oob”的情况下，AuthorizationRequestService不会简单地返回<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/services/OOBAuthorizationResponse.java" rel="nofollow">OOBAuthorizationResponse</a>的实例，而不是将用户重定向到回调URI，如先前所示。需要使用RequestDispatcherProvider将数据重定向到视图处理程序时，该操作实际上是在要求用户授权客户端应用程序时执行的操作，其中视图处理程序格式化数据并将其实际返回给用户</p><h2 id="JAX-RSOAuth-AccessTokenService">AccessTokenService</h2><p>AccessTokenService的作用是将授权的请求令牌交换为新的访问令牌，消费者将使用该新的访问令牌来访问最终用户的资源。<br clear="none">这是一个示例请求日志：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/oauth/token
Http-Method: POST
Headers: {
Accept=[application/x-www-form-urlencoded], 
Authorization=[OAuth oauth_signature_method="HMAC-SHA1", 
                     oauth_consumer_key="123456789", 
                     oauth_token="6dfd5e52-236c-4939-8df8-a53212f7d2a2", 
                     oauth_verifier="00bd8fa7-4233-42a2-8957-0a0a22c684ba", 
                     oauth_timestamp="1320760259", 
                     oauth_nonce="16237669362301", 
                     oauth_version="1.0", 
                     oauth_signature="dU%2BhXPNFfFpX2sC74IOxzTjdVrY%3D"]
}
</pre>
</div></div><p>该请求与临时令牌请求非常相似。请注意，请求令牌密钥也包括在内，并且此令牌密钥及其秘密对以及使用者密钥和秘密对用于计算签名。</p><p>AccessTokenService验证签名，要求OAuthDataProvider删除由“ oauth_token”标识的RequestToken，并将“ oauth_verifier”值与此RequestToken中存储的值进行比较。</p><p>请注意，如果缺少“ oauth_verifier”，则AccessTokenService将检查RequestToken是否已被预授权，并且其UserSubject属性已初始化。如果两个条件都满足，则允许访问令牌请求继续。</p><p>接下来，它要求数据提供者基于此RequestToken创建一个新的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/AccessToken.java" rel="nofollow">AccessToken</a> 。生成的访问令牌密钥和秘密对将返回给使用者：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Response-Code: 200
Content-Type: application/x-www-form-urlencoded
Headers: {Date=[Tue, 08 Nov 2011 13:50:59 GMT]}
Payload: oauth_token=abc15aca-2073-4bde-b1be-1a02dc7ccafe&amp;oauth_token_secret=859dfe9e-ca4c-4b36-9e60-044434ab636c
</pre>
</div></div><p>消费者将使用此访问令牌访问当前用户的资源，以完成原始用户的请求，例如，访问用户日历的请求可能如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[OAuth oauth_signature_method="HMAC-SHA1", 
                     oauth_consumer_key="123456789", 
                     oauth_token="abc15aca-2073-4bde-b1be-1a02dc7ccafe", 
                     oauth_version="1.0", 
                     oauth_signature="dU%2BhXPNFfFpX2sC74IOxzTjdVrY%3D"]
}
</pre>
</div></div><p>请注意，已设置访问令牌，并且使用访问令牌密钥和秘密对以及消费者密钥和秘密对来创建签名。</p><h2 id="JAX-RSOAuth-WritingOAuthDataProvider">编写OAuthDataProvider</h2><p>使用CXF OAuth服务实现对设置OAuth服务器有很大帮助。从以上部分可以看到，这些服务依赖于自定义的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/provider/OAuthDataProvider.java" rel="nofollow">OAuthDataProvider</a>实现。</p><p>OAuthDataProvider的主要任务是持久保存请求和访问令牌并生成授权/验证者密钥。完成的方式实际上是特定于应用程序的。考虑从基于内存的基本实现开始，然后继续将数据保留在某些DB中。</p><p>请注意，OAuthDataProvider支持检索<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">客户端</a>实例，但是它没有创建或删除客户端的方法。这样做的原因是，注册第三方使用者的过程非常特定于特定的OAuth应用程序，因此CXF不提供注册支持服务，因此OAuthDataProvider没有客户端创建/更新方法。您可能需要执行以下操作：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public class CustomOAuthProvider implements OAuthDataProvider {
   public Client registerClient(String applicationName, String applicationURI, ...) {}
   public void removeClient(String cliendId) {}
   // etc
   // OAuthDataProvider methods
}
</pre>
</div></div><p>CustomOAuthProvider还将在removeClient（String cliendId）中删除与给定客户端关联的所有令牌。</p><p>在创建RequestToken或AccessToken令牌以及授权密钥时，OAuthDataProvider将需要创建唯一的标识符。<br clear="none">它的完成方式是特定于应用程序的，并且自定义实现也可以使用CXF附带的实用程序<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/provider/MD5SequenceGenerator.java" rel="nofollow">MD5SequenceGenerator</a> ，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public String setRequestTokenVerifier(RequestToken requestToken) throws OAuthServiceException {
    requestToken.setVerifier(generateSequence());
    return requestToken.getVerifier();
}

private String generateSequence() throws OAuthServiceException {
    try {
       return tokenGenerator.generate(UUID.randomUUID().toString().getBytes("UTF-8"));
    } catch (Exception e) {
       throw new OAuthServiceException("Unable to generate the key", e.getCause());
    }
}

</pre>
</div></div><p>生成令牌/密钥并有效地持久存储它们是OAuthDataProvider的全部目的。<br clear="none">请注意，CXF将在每次使用请求和访问令牌时检查它们是否没有过期，并将要求OAuthDataProvider删除过期的令牌，但是自定义OAuthDataProvider实现也可以自己进行检查。</p><p>最后，OAuthDataProvider可能需要将不透明的范围值（例如“ readCalendar”）转换为<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermission</a>的列表。AuthorizationRequestService和OAuth安全过滤器将依赖于它（假设首先使用范围）。在前一种情况下，AuthorizationRequestService将使用此列表填充<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData-</a>该bean仅看到<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Permission.java" rel="nofollow">Permission</a>的原因是OAuthPermission保留的属性对OAuthAuthorizationData处理程序不感兴趣。</p><h2 id="JAX-RSOAuth-OAuthServerJAX-RSendpoints">OAuth服务器JAX-RS端点</h2><p>使用提供OAuth服务实现的CXF和自定义的OAuthAuthorizationData提供程序，就可以部署OAuth服务器了。<br clear="none">您很可能希望将RequestTokenService和AccessTokenService部署为单个JAX-RS端点内的两个根资源（或具有一个RequestTokenService和一个AccessTokenService端点），例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;!-- implements OAuthDataProvider --&gt;
&lt;bean id="oauthProvider" class="oauth.manager.OAuthManager"/&gt;

&lt;bean id="requestTokenService" class="org.apache.cxf.rs.security.oauth.services.RequestTokenService"&gt;
   &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;
     
&lt;bean id="accessTokenService" class="org.apache.cxf.rs.security.oauth.services.AccessTokenService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;jaxrs:server id="oauthServer" address="/oauth"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="requestTokenService"/&gt;
      &lt;ref bean="accessTokenService"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>RequestTokenService侦听相对的“ / initiate”路径，AccessTokenService-侦听“ / token”。假设jaxrs：server / @ adress为“ / oauth”，并假定上下文名称为“ / services”，则RequestTokenService的绝对地址将类似于“ http：// localhost：8080 / services / oauth / initiate”，并且AccessTokenService的-“ http：// localhost：8080 / services / oauth / token”。</p><p>最好将AuthorizationRequestService放在主应用程序端点所在的位置。可以将其与RequestTokenService和AccessTokenService一起放置-但是问题在于，最终用户需要由第三方使用者将其重定向到AuthorizationRequestService之后，再通过资源服务器对自己进行身份验证。这会使OAuth服务器端点同时管理OAuth（第三方使用者）和常规用户身份验证变得更加复杂-可以做到，请在下面的“设计注意事项”部分中查看更多信息，但更简单的选择是在执行最终用户身份验证的安全筛选器的控制下获取AuthorizationRequestService：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean id="authorizationService" class="org.apache.cxf.rs.security.oauth.services.AuthorizationRequestService"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;bean id="myApp" class="org.myapp.MyApp"&gt;
  &lt;property name="dataProvider" ref="oauthProvider"/&gt;
&lt;/bean&gt;

&lt;jaxrs:server id="oauthServer" address="/myapp"&gt;
   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="myApp"/&gt;
      &lt;ref bean="authorizationService"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>AuthorizationRequestService侦听相对的“ / authorize”路径，因此在这种情况下，其绝对地址将类似于“ http：// localhost：8080 / services / myapp / authorize”。该地址以及RequestTokenService和AccessTokenService的地址将由第三方使用者使用。</p><h1 id="JAX-RSOAuth-ProtectingresourceswithOAuthfilters">使用OAuth过滤器保护资源</h1><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/filters/OAuthRequestFilter.java" rel="nofollow">OAuthRequestFilter</a>请求处理程序可用于在处理来自第三方使用者的请求时保护资源服务器。将其作为jaxrs：provider添加到处理请求资源的使用者的端点。</p><p>当检查这样的请求时：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[OAuth oauth_signature_method="HMAC-SHA1", 
                     oauth_consumer_key="123456789", 
                     oauth_token="abc15aca-2073-4bde-b1be-1a02dc7ccafe", 
                     oauth_version="1.0", 
                     oauth_signature="dU%2BhXPNFfFpX2sC74IOxzTjdVrY%3D"]
}
</pre>
</div></div><p>过滤器将执行以下操作：</p><p>1。它将验证签名，并从OAuthDataProvider获取客户端和AccessToken。</p><p>2。它将检查<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/AccessToken.java" rel="nofollow">AccessToken</a>是否设置了“ uris”属性，如果是，则将针对它验证当前的请求URI。</p><p>3。如果AccessToken具有<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermissions</a>列表。对于每个许可，它将：</p><ul class="alternate"><li>如果设置了uri属性，则将根据该属性检查当前请求URI</li><li>如果设置了httpVerb属性，则将根据该属性检查当前的HTTP动词</li></ul><p>4。最后，它将使用此<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthPermission.java" rel="nofollow">OAuthPermissions</a>列表和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/Client.java" rel="nofollow">Client</a> loginName属性创建一个CXF SecurityContext。</p><p>此loginName属性是可以在注册期间与新客户端关联的内容-如果未设置，则过滤器将改为使用客户端“ applicationName”属性。检查用户主体的应用程序代码将看到所选的值。另外，每个OAuthPermission可能具有特定于应用程序的角色列表，例如“消费者”等，这些角色将添加到SecurityContext中，并在SecurityContext.isUserInRole（roleName）调用期间进行检查。</p><p>如果在过滤器上设置了“ useUserSubject”属性，则将使用与访问令牌关联的UserSubject来填充SecurityContext。</p><p>对于某些OAuth应用程序，此SecurityContext不一定很重要。大多数安全检查将由OAuth过滤器和安全过滤器完成，这些过滤器可以保护最终用户自己使用的主要应用程序路径。仅当您希望在最终用户和使用者之间共享相同的JAX-RS资源代码并访问URI时，它才变得很方便。下面有更多内容。</p><p>请注意，可以改为部署<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/filters/OAuthServletFilter.java" rel="nofollow">OAuthServletFilter</a> 。它将需要OAuthDataProvider完整的类名称，该名称作为“ oauth.data.provider-class” servlet上下文参数引用。</p><h1 id="JAX-RSOAuth-Howtogettheuserloginname">如何获得用户登录名</h1><p>当编写一个需要参与三站式OAuth流的自定义服务器应用程序时，需要解决的主要问题是<br clear="none">如何访问最终用户授权第三方客户端期间使用的用户登录名。此用户名将有助于唯一标识第三方客户端现在尝试访问的资源。<br clear="none">以下代码显示了一种从CXF 2.5.1开始的方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;"> 
@Path("/userResource")
public class ThirdPartyAccessService {

    @Context 
    private MessageContext mc;
	
    @GET
    public UserResource getUserResource() {
        OAuthContext oauth = mc.getContent(OAuthContext.class);
        if (oauth == null || oauth.getSubject() == null || oauth.getSubject().getLogin() == null) {
	   throw new WebApplicationException(403);
	}
	String userName = oauth.getSubject().getLogin();
	return findUserResource(userName)
    }

    private UserResource findUserResource(String userName) {
        // find and return UserResource
    }
}

</pre>
</div></div><p>上面显示了JAX-RS服务的一个片段，该片段管理来自授权的第三方客户端对用户资源的访问（有关更多信息，请参见“设计注意事项”部分）。</p><p>注入的MessageContext提供对<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthContext.java" rel="nofollow">OAuthContext</a>的访问，该访问已由上一节中描述的OAuth过滤器设置。OAuthContext将充当信息的容器，这对自定义应用程序代码很有用，因为自定义应用程序代码无需处理可能会在OAuth 1.0和OAuth 2.0之间发生变化的OAuth内部结构。目前，OAuthContext提供了对<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/UserSubject.java" rel="nofollow">UserSubject</a>的访问，该访问由CXF AuthorizationService在最终用户授权第三方客户端时创建，并捕获最终用户的登录名（以及使用CXF JAASLoginInterceptor来验证最终用户身份时将可用的角色）用户），并将其与当前的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/RequestToken.java" rel="nofollow">RequestToken</a>关联。自定义OAuthDataProviders的责任是确保将此UserSubject Bean复制到对应的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/AccessToken.java" rel="nofollow">AccessToken中</a> 。OAuthContext还引用当前客户端请求已再次验证的权限列表。</p><p>此外，您可能会获得OAuth过滤器来设置SecurityContext，该SecurityContext将使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/UserSubject.java" rel="nofollow">UserSubject</a>中可用的信息，换句话说，获得在当前持续时间内模拟最终用户（首先授权此客户端）的第三方客户端请求。为此，请将jaxrs上下文的“ org.apache.cxf.rs.security.oauth.use_user_subject”属性设置为“ true”。</p><h1 id="JAX-RSOAuth-Client-sidesupport">客户端支持</h1><p>开发需要参与OAuth流程的第三方应用程序时，必须编写将用户重定向到OAuth AuthorizationRequestService，与RequestTokenService和AccessTokenService进行交互的代码，以获取请求和访问令牌，以及在访问时正确构建Authorization OAuth标头最终用户的资源。JAX-RS使直接支持重定向变得很简单，而<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/client/OAuthClientUtils.java" rel="nofollow">OAuthClientUtils</a>类使封装大多数复杂性成为可能，而<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/client/OAuthClientUtils.java" rel="nofollow">没有</a>客户端应用程序代码。</p><p>OAuthClientUtils具有用于获取请求和访问令牌的实用程序方法，预计使用者将提供一个正确初始化的WebClient，该WebClient指向RequestTokenService和AccessTokenService，包含注册密钥和机密的使用者bean，用于请求请求令牌和请求令牌的回调URI，以及验证访问令牌的验证程序非常简单。它还有助于创建适当的URI，以重定向到AuthorizationRequestService。访问资源服务器上的用户资源时，还需要使用正确的Authorization标头，OAuthClientUtils也将帮助创建此标头。</p><p>例如，第三方应用程序可以使用以下自定义代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public class OAuthClientManager {
	
	private WebClient accessTokenService;
        private WebClient requestTokenService;
        private String authorizationServiceURI;
    
        // inject properties...
	
	public URI getAuthorizationServiceURI(String token) {
	    return OAuthClientUtils.getAuthorizationURI(authorizationServiceURI, token);
	}
	
	public Token getRequestToken(URI callback) {
	    try {
	        return OAuthClientUtils.getRequestToken(requestTokenService, consumer, callback, null);
	    } catch (OAuthServiceException ex) {
               return null;
            }    
	}
	
	public Token getAccessToken(Token requestToken, String verifier) {
	    try {
	        return OAuthClientUtils.getAccessToken(accessTokenService, consumer, requestToken, verifier);
	    } catch (OAuthServiceException ex) {
	        return null;
	    }
	}
	
	public String createAuthorizationHeader(Token token, String method, String requestURI) {
            return OAuthClientUtils.createAuthorizationHeader(consumer, token, method, requestURI);
	}
}
</pre>
</div></div><p>可以引入这种简单包装的原因是将主应用程序代码对OAuth的暴露程度降至最低，这就是为什么在此示例中捕获OAuthServiceExceptions，大概记录并返回空值的原因，该值将指示主代码。该请求失败。显然，也可以直接使用OAuthClientUtils。</p><h1 id="JAX-RSOAuth-2-legOAuthFlow">两段式OAuth流程</h1><p>请参阅此博客<a shape="rect" class="external-link" href="http://blog.nerdbank.net/2011/06/what-is-2-legged-oauth.html" rel="nofollow">条目</a> ，以全面了解OAuth 2条腿流程。<br clear="none">这是CXF支持的2条腿流程的变体：</p><h2 id="JAX-RSOAuth-ClientrequestsPreAuthorizedRequestToken">客户端请求预授权的RequestToken</h2><p>在此变体中，客户端照常访问请求令牌，但跳过显式授权步骤。<br clear="none">取而代之的是，在获得请求令牌之后，它在不提供“ oauth_verifier”参数的情况下请求访问令牌。<br clear="none">为此，需要对RequestToken进行预授权并设置其UserSubject属性。</p><p>这是与典型的3-OAuth流的唯一区别。OAuth过滤器将照常验证请求。</p><h2 id="JAX-RSOAuth-SignaturewithConsumerKeyandSecret">带有消费者密钥和秘密的签名</h2><p>在这种模式下，使用消费者密钥和秘密对来创建“ oauth_signature”，Authorization标头的外观与RequestToken请求期间的外观几乎相同。</p><p>在这种模式下，客户端应引用预授权的AccessToken。OAuth过滤器照常验证此令牌。</p><h2 id="JAX-RSOAuth-OnlyConsumerKeyandSecretinAuthorizationheader">授权标头中只有使用者密钥和机密</h2><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;"> 
Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[OAuth oauth_consumer_key="123456789",oauth_consumer_secret="987654321"] 
}
</pre>
</div></div><p>另外，使用者密钥和机密可以由“：”字符连接，并使用Base64编码进行编码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;"> 
Address: http://localhost:8080/services/user/calendar
Http-Method: GET
Headers: {
Accept=[application/XML], 
Authorization=[Basic base64EncodedValue] 
}
</pre>
</div></div><p>在这种模式下，客户端应引用预授权的AccessToken。OAuth过滤器照常验证此令牌。</p><h1 id="JAX-RSOAuth-OAuthWithoutaBrowser">没有浏览器的OAuth</h1><p>当最终用户访问第三方应用程序并稍后对其进行授权时，通常可以预期该用户依赖于浏览器。<br clear="none">但是，支持其他类型的最终用户非常容易。使用JAX-RS可以很容易地编写处理来自第三方应用程序和AuthorizationRequestService的重定向请求的客户端代码，并且可以将CXF配置为在客户端进行自动重定向。</p><p>还要注意，AuthorizationRequestService可以返回XML或JSON <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/oauth-parent/oauth/src/main/java/org/apache/cxf/rs/security/oauth/data/OAuthAuthorizationData.java" rel="nofollow">OAuthAuthorizationData</a>表示形式。这样，客户端代码就可以轻松获取OAuthAuthorizationData并提供一个弹出窗口或从命令行获取输入。在这种情况下，甚至可以自动授权第三方应用程序-这可能会导致实施完整的三段式OAuth流程而无需人工参与。</p><h1 id="JAX-RSOAuth-Reportingtheerrordetails">报告错误详细信息</h1><p>如果发生各种与OAuth相关的错误，CXF OAuth 1.0服务将仅报告HTTP状态代码，以最大程度地减少有关实际失败原因的信息，并将在本地记录详细信息。如果提供额外的错误信息可以帮助调试第三方应用程序，或者如果此类应用程序确实可以基于此类详细信息从故障中恢复，则将上下文的“ report.failure.details”属性设置为“ true”将获得错误消息。在响应正文中可用。一些OAuth1.0实现者选择返回自定义的“ oauth_problem” HTTP标头-可以通过将上下文的“ report.failure.details.as.header”属性另外设置为“ true”来支持此选项，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;jaxrs:server id="oauthServer" address="/initiate"&gt;
        &lt;jaxrs:serviceBeans&gt;
            &lt;bean class="org.apache.cxf.rs.security.oauth.services.RequestTokenService"/&gt;
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:properties&gt;
           &lt;entry key="report.failure.details" value="true"/&gt;
           &lt;entry key="report.failure.details.as.header" value="true"/&gt;
        &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;

</pre>
</div></div><h1 id="JAX-RSOAuth-Designconsiderations">设计注意事项</h1><p>本节将讨论在部署基于OAuth的解决方案时需要考虑的各种设计注意事项。</p><h2 id="JAX-RSOAuth-ControllingtheAccesstoResourceServer">控制对资源服务器的访问</h2><p>需要解决的最重要的问题之一是如何对资源服务器应用程序的URI空间进行分区。</p><p>我们有两个不同的参与者试图访问它，最终用户访问资源服务器以获取他们拥有的资源，以及第三方用户，该第三方消费者已被最终用户授权访问他们的某些资源。</p><p>在前一种情况下，身份验证的管理方式完全取决于资源服务器应用程序：您可以将其命名为基本身份验证，双向TLS，OpenId（请参见下文）。</p><p>在后一种情况下，OAuth过滤器必须强制使用提供的使用者密钥来注册第三方使用者，并且该第三方具有有效的访问令牌（OAuth 2.0中的授权密钥），该令牌代表最终用户的批准。这是同时进行身份验证和授权检查的一种。</p><p>让双方通过相同的URI访问资源服务器会使安全过滤器的寿命变得复杂，但是所有各方都只知道它们将使用的单个资源服务器URI。</p><p>向最终用户和消费者提供不同的访问点可能会大大简化身份验证过程-可能的不利之处是，资源服务器需要管理多个访问点。</p><p>接下来讨论这两个选项。</p><h3 id="JAX-RSOAuth-Sharingthesameaccesspathbetweenendusersandconsumers">在最终用户和消费者之间共享相同的访问路径</h3><p>需要解决的第一个问题是如何将最终用户与第三方消费者区分开来，并根据需要对双方进行身份验证。<br clear="none">也许最简单的选择是扩展一个CXF OAuth过滤器（JAX-RS或servlet一个），检查Authorization标头，如果它是OAuth，则委托给超类，或者-验证最终用户：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public class SecurityFilter extends org.apache.cxf.rs.security.oauth.filters.OAuthRequestFilter {
   @Context
   private HttpHeaders headers;

   public Response handleRequest(ClassResourceInfo cri, Message message) {
       String header = headers.getRequestHeaders().getFirst("Authorization");
       if (header.startsWith("OAuth ")) {
           return super.handleRequest(cri, message);
       } else {
           // authenticate the end user
       }
   }

} 
</pre>
</div></div><p>下一个问题是如何强制最终用户只能访问他们被授权访问的资源。<br clear="none">例如，考虑以下JAX-RS资源类：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("calendar")
public class CalendarResource {

   @GET
   @Path("{id}")
   public Calendar getPublicCalendar(@PathParam("id") long id) {
       // return the calendar for a user identified by 'id'
   }

   @GET
   @Path("{id}/private")
   public Calendar getPrivateCalendar(@PathParam("id") long id) {
       // return the calendar for a user identified by 'id'
   }

   @PUT
   @Path("{id}")
   public void updateCalendar(@PathParam("id") long id, Calendar c) {
       // update the calendar for a user identified by 'id'
   }
}
</pre>
</div></div><p>让我们假设仅允许第三方消费者阅读“ / calendar / {id}”上的公共用户日历，如何确保消费者不会尝试：<br clear="none">1.更新在相同路径下可用的日历<br clear="none">2.阅读“ / calendar / {id} / private”中的私人日历。</p><p>如上所述，客户端，AccessToken（在其令牌超类中）和OAuthPermission都具有可选的URIs属性。因此，解决私有日历问题的一种方法是在OAuthPermission中添加一个uri“ / calendar / {id}”或“ / calendar / 1”（等）属性（表示一个范围，例如“ readCalendar”）， OAuth过滤器将确保无法访问“ / calendar / {id}”以外的任何子资源。注意，在给定URI属性的末尾添加“ *”，例如“ / a *”将使使用者访问“ / a”，“ / a / b”等。</p><p>通过将httpVerb属性添加到给定的OAuthPermission，可以轻松解决解决阻止更新的问题。</p><p>另一种选择是依靠基于角色的访问控制并分配@RolesAllowed，以便只有角色（如“消费者”或“最终用户”）中的用户才能调用getCalendar（）方法，并仅允许那些“最终用户”角色中的用户访问getPrivateCalendar（）和updateCalendar（）。如有关使用OAuth适配程序的部分所述，OAuthPermission也可以在此处提供帮助。</p><h3 id="JAX-RSOAuth-Providingdifferentaccesspointstoendusersandconsumers">为最终用户和消费者提供不同的访问点</h3><p>与其让最终用户和第三方消费者都使用相同的URI（例如“ http://myapp.com/service/calendars/{id}”），不如要引入两个URI，一个用于最终用户，另一个用于。第三方消费者，例如“ http://myapp.com/service/calendars/{id}”（对于最终用户），“ http://myapp.com/partners/calendars/{id}”（对于第三位用户）使用者并部署2个jaxrs端点，其中一个由检查最终用户的安全过滤器保护，另一个由OAuth过滤器保护。</p><p>另外，管理第三方使用者的端点将部署资源，该资源将提供限制的URI空间支持。例如，如果应用程序仅允许第三方消费者阅读日历，则该资源将仅具有支持@GET和“ / calendar / {id}”的方法。</p><h2 id="JAX-RSOAuth-SingleSignOn">单点登录</h2><p>在处理对最终用户的身份验证时，使用SSO解决方案非常方便。这是因为最终用户与第三方及其资源服务器Web应用程序都进行了交互，并且还从使用者应用程序重定向到资源服务器，然后再次重定向。OpenID或说<a shape="rect" href="http://cxf.apache.org/docs/saml-web-sso.html">WebBrowser SSO配置文件</a>可以提供帮助。</p><h1 id="JAX-RSOAuth-WhatIsNext">接下来是什么</h1><p>将继续微调当前的OAuth 1.0，并将欢迎实施者提供反馈。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=27830330">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=27830330&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>