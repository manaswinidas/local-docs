<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - CXF Architecture">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-CXF体系结构</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="cxf-architecture.html">CXF体系结构</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="CXFArchitecture-ApacheCXFSoftwareArchitectureGuide">Apache CXF软件架构指南</h1><p>本文档提供了Apache CXF服务框架的体系结构概述。</p><h2 id="CXFArchitecture-TableofContents">目录</h2><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1524513404037 {padding: 0px;}
div.rbtoc1524513404037 ul {list-style: outline;margin-left: 0px;}
div.rbtoc1524513404037 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1524513404037">
<ul class="toc-indentation"><li><a shape="rect" href="#CXFArchitecture-ApacheCXFSoftwareArchitectureGuide">Apache CXF软件架构指南</a>
<ul class="toc-indentation"><li><a shape="rect" href="#CXFArchitecture-TableofContents">目录</a></li><li><a shape="rect" href="#CXFArchitecture-ArchitecturalGoalsandConstraints">建筑目标和约束</a></li><li><a shape="rect" href="#CXFArchitecture-CXF-API">CXF API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#CXFArchitecture-Bus">总线</a></li><li><a shape="rect" href="#CXFArchitecture-Howservicecallsareprocessed">如何处理服务电话</a></li><li><a shape="rect" href="#CXFArchitecture-Front-ends">前端</a></li><li><a shape="rect" href="#CXFArchitecture-Messaging&Interceptors">消息和拦截器</a></li><li><a shape="rect" href="#CXFArchitecture-TheServiceModel">服务模式</a></li><li><a shape="rect" href="#CXFArchitecture-DataBindings">数据绑定</a></li><li><a shape="rect" href="#CXFArchitecture-ProtocolBindings">协议绑定</a></li><li><a shape="rect" href="#CXFArchitecture-Transports">运输工具</a></li><li><a shape="rect" href="#CXFArchitecture-AJAX-WSexample">一个JAX-WS示例</a></li></ul>
</li><li><a shape="rect" href="#CXFArchitecture-Dependencies">依存关系</a></li><li><a shape="rect" href="#CXFArchitecture-Quality">质量</a>
<ul class="toc-indentation"><li><a shape="rect" href="#CXFArchitecture-References">参考文献</a></li></ul>
</li></ul>
</li></ul>
</div><h2 id="CXFArchitecture-ArchitecturalGoalsandConstraints">建筑目标和约束</h2><p>Apache CXF服务框架寻求为服务构建必要的基础架构组件。CXF的目标很多，包括：</p><ul><li>可嵌入</li><li>高性能</li><li>易于配置</li><li>直观易用</li><li>前端与核心代码的清晰分离</li><li>数据格式支持</li><li>数据绑定支持</li><li>协议绑定支持</li><li>多种运输支持</li><li>多种编程语言支持</li><li>WS- *和相关规范支持</li><li>用于代码生成和WSDL验证的工具</li><li>灵活的部署</li></ul><h2 id="CXFArchitecture-CXF-API">CXF API</h2><p>整个CXF体系结构主要由以下部分组成：</p><ol><li>总线：包含扩展名，拦截器和属性的注册表</li><li>前端：前端提供用于创建服务的编程模型。</li><li>消息传递和拦截器：它们提供了底层消息和管道层，可在其中构建大多数功能。</li><li>服务模型：服务托管一个服务模型，该模型是描述服务的类似于WSDL的模型。</li><li>可插拔数据绑定：...</li><li>协议绑定：绑定提供了解释协议的功能。</li><li>运输：运输工厂创建目的地（收货）和管道（发送）</li></ol><p>在接下来的部分中，我们将依次查看每个图层，并研究它们如何协同工作。</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-thumbnail" src="cxf-architecture.data/cxf_architecture.png"></span></p><h3 id="CXFArchitecture-Bus">总线</h3><p>总线是CXF的骨干，是CXF运行时共享资源的提供者。此类共享资源的示例包括WSDL管理器和绑定工厂管理器。可以轻松扩展总线以包括您自己的自定义资源或服务，或者您可以用自己的（可能基于另一个Web容器，例如Apache Tomcat）替换默认资源，例如HTTP目标工厂（基于Jetty）。</p><p>通过依赖注入可以实现这种可扩展性。默认的总线实现基于<a shape="rect" class="external-link" href="http://www.springsource.com/developer/spring" rel="nofollow">Spring Framework</a> ，它将为您连接运行时组件。</p><p>的<code>SpringBusFactory</code>在以下位置搜索所有bean配置文件<code>META-INF/cxf</code>目录放在您的类路径上，并从中建立应用程序上下文。应用程序上下文构造中包括的bean配置文件是：</p><ul><li><code>META-INF/cxf/cxf.xml</code> （例如，在<code>cxf-core</code>只要）</li><li><code>META-INF/cxf/cxf-extension.xml</code> （例如<code>cxf-rt-bindings-soap</code> ）</li><li><code>META-INF/cxf/cxf-property-editors.xml</code> （例如<code>cxf-rt-transports-http</code> ）</li></ul><p>见<a shape="rect" href="configuration-of-the-bus.html">总线的配置</a>对于如何通过提供自己的bean配置文件和自定义总线为例<a shape="rect" href="configuration-of-runtime-constructed-objects.html">运行时的配置构造的对象</a>上注入运行时（创建对象的特殊情况的更多信息，而不是由创建的对象IoC容器本身）。</p><h3 id="CXFArchitecture-Howservicecallsareprocessed">如何处理服务电话</h3><p>    




<span class="gliffy-container" id="gliffy-container-25591945-7658" data-fullwidth="1269" data-ceoid="44806" data-edit="${diagramEditLink.getLinkUrl()}" data-full="${diagramZoomLink.getLinkUrl()}" data-filename="MessageFlowOnClientSide">

    <map id="gliffy-map-25591945-8193" name="gliffy-map-25591945-8193"></map>

    <img class="gliffy-image" id="gliffy-image-25591945-7658" width="600" height="274" src="https://cwiki.apache.org/confluence/download/attachments/44806/MessageFlowOnClientSide.png?version=4&modificationDate=1298215366000&api=v2" alt="MessageFlowOnClientSide" usemap="#gliffy-map-25591945-8193" data-full-width="1269" data-full-height="580">

    <map class="gliffy-dynamic" id="gliffy-dynamic-map-25591945-7658" name="gliffy-dynamic-map-25591945-7658"></map>
</span>


</p><p>客户端</p><p>    




<span class="gliffy-container" id="gliffy-container-25591953-5191" data-fullwidth="1222" data-ceoid="44806" data-edit="${diagramEditLink.getLinkUrl()}" data-full="${diagramZoomLink.getLinkUrl()}" data-filename="MessageFlowOnServerSide">

    <map id="gliffy-map-25591953-6154" name="gliffy-map-25591953-6154"></map>

    <img class="gliffy-image" id="gliffy-image-25591953-5191" width="600" height="295" src="https://cwiki.apache.org/confluence/download/attachments/44806/MessageFlowOnServerSide.png?version=4&modificationDate=1298310696000&api=v2" alt="MessageFlowOnServerSide" usemap="#gliffy-map-25591953-6154" data-full-width="1222" data-full-height="600">

    <map class="gliffy-dynamic" id="gliffy-dynamic-map-25591953-5191" name="gliffy-dynamic-map-25591953-5191"></map>
</span>


</p><p>服务器端</p><h3 id="CXFArchitecture-Front-ends">前端</h3><p>前端提供了与CXF交互的编程模型。 CXF提供了JAX-WS，JAX-RS，Simple和Javascript前端API。每个实现都与CXF的其余部分完全分开，就像绑定和核心一样。前端通过添加到服务和端点的拦截器提供功能。另请参见<a shape="rect" href="frontends.html">前端</a></p><h3 id="CXFArchitecture-Messaging&Interceptors">消息和拦截器</h3><p>CXF构建在由消息，拦截器和拦截器链组成的通用消息传递层上。拦截器是功能的基本单位。通过划分消息的处理和发送方式，这为CXF提供了非常灵活的体系结构。可以在处理过程中的任何时候对其进行重新配置。这也使CXF能够暂停和恢复拦截器链。</p><p>拦截器有一种方法， <code>handleMessage</code> ，这使他们可以对消息采取行动。然后，可以将这些拦截器构建为拦截器链，直接称为InterceptorChains。一些示例包括：</p><ul><li>拦截器，仅将SOAP消息的标头解析为DOM元素</li><li>WS-Security拦截器，用于解密或认证传入的消息。</li><li>传出结果的传出数据绑定拦截器</li></ul><p>拦截器是单向的，并且固有地不知道它们是在处理请求，响应还是故障。</p><h4 id="CXFArchitecture-PhaseInterceptors">相位拦截器</h4><p>CXF提供了<code>InterceptorChain</code>实现称为<code>PhaseInterceptorChain</code> 。将拦截器添加到链中后，它们将分为有序阶段。一种<code>PhaseInterceptor</code>可以提供有关在该阶段如何订购的指导。</p><p>让我们以一个假设的简化示例（注意：这些阶段和拦截器不一定存在于CXF中）。假设我们正在解析SOAP消息。我们可能需要两个阶段。首先，是一个分发阶段，该阶段分析soap标头并确定将消息路由到的服务。其次，解组阶段将SOAP主体绑定到JAXB对象。在第一个调度阶段，我们可以通过两个拦截器实现此目标，首先是一个ReadHeadersInterceptor，它解析头，然后是一个WS-AddressingInInterceptor，它确定我们要从WS-Addressing头中调用哪个服务。在第二个解组阶段，我们只有一个JAXBUnmarshallerIntercptor。这俩<code>ReadHeadersInterceptor</code>和<code>AddressingInInterceptor</code>会告诉<code>PhaseInterceptorChain</code>当它们返回“ dispatch”时，它们处于“ dispatch”阶段<code>getPhase()</code>叫做。此外， <code>ReadHeadersInterceptor</code>可以指定它要在<code>AddressingInInterceptor</code>通过返回拦截器ID <code>Interceptor.getBefore()</code>叫做。</p><p>在此之前，连锁店是如何非常动态和灵活的。在上面的示例中，我们可以在解决该服务后添加特定于该服务的拦截器。或者，我们可以在等待某个外部链（例如异步服务响应）时将链暂停一次。</p><h4 id="CXFArchitecture-FaultHandling">故障处理</h4><p>在处理过程中的任何时候，拦截器都可能抛出Fault或Fault的派生类，例如<code>SoapFault</code> 。这将导致链停止调用并展开。展开包括在以相反顺序调用的每个拦截器上调用handleFault。</p><p>InterceptorChains具有故障观察者的概念。链解开后，将使用引起故障的消息调用故障拦截器。故障观察者可以触发一条新链，然后该新链调用一组指定的用于处理故障的拦截器。</p><h4 id="CXFArchitecture-Exchanges">交流交流</h4><p>除了消息的概念外，还有<code>Exchange</code> 。交换类保存对当前消息交换的输入，输出和故障消息的引用。</p><p>它还具有特定于交换的属性，而不仅仅是消息。例如<code>Exchange</code>持有<code>Service</code>当前正在其中调用。</p><h4 id="CXFArchitecture-ReentrantInterceptorChains">可重入拦截器链</h4><p>一个有趣的功能<code>PhaseInterceptorChain</code>是可重入的。这可能是强大的，并且有些危险。此功能仅在发送外发消息时在CXF中使用， <code>SoapOutInterceptor</code>最好的例子是：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public void handleMessage(Message m) {
  writeSoapEnvelopeStart();
  writeSoapBodyStart();

  // invoke next interceptor, which writes the contents of the SOAP Body
  m.getInterceptorChain().doIntercept(m);
  writeSoapBodyEnd();

  writeSoapEnvelopeEnd();
}
</pre>
</div></div><h3 id="CXFArchitecture-TheServiceModel">服务模式</h3><p>服务模型是CXF中服务的表示。它由两部分组成。首先是<code>ServiceInfo</code>它包含服务的WSDL型模型及其操作，绑定，端点和模式。其次，有服务本身，其中包含<code>ServiceInfo</code> ，数据绑定信息，服务拦截器，服务属性等。</p><p>可以从许多不同的来源构建服务，包括类和WSDL（1.1或2.0）。通常，前端负责通过服务工厂创建服务。工厂组件如<code>ServerFactoryBean</code>和<code>ClientProxyFactoryBean</code>可以与前端一起使用，以创建，发布和使用Web服务。工厂类建立服务模型并配置服务拦截器，数据绑定等等。</p><p>服务模型本身包含在<code>ServiceInfo</code>类。下图描绘了服务模型的打包API的子集：</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-thumbnail" src="cxf-architecture.data/service_model.png"></span></p><h3 id="CXFArchitecture-DataBindings">数据绑定</h3><p>数据绑定实现XML元素和Java对象之间的映射。数据绑定将数据与XML相互转换，产生XML模式，并提供对wsdl2java代码生成的支持。并非所有的数据绑定都支持所有这些功能。至少，数据绑定必须提供数据转换。有关详细信息，请参见<a shape="rect" href="data-binding-architecture.html">数据绑定体系结构</a> 。当前支持的数据绑定包括JAXB 2.x（默认）和Aegis。</p><h3 id="CXFArchitecture-ProtocolBindings">协议绑定</h3><p>绑定提供了在传输之上映射具体格式和协议的方法。绑定包含两个主要部分， <code>BindingFactory</code>和一个<code>Binding</code> 。一种<code>BindingFactory</code>建立一个<code>Binding</code>从服务模型的<code>BindingInfo</code> 。绑定包含特定于绑定的拦截器，并且还实现了<code>createMessage()</code>方法，它创建一个<code>Message</code>特定于该绑定的实现。</p><p>CXF当前支持以下绑定协议：SOAP 1.1，SOAP 1.2，REST / HTTP，纯XML和CORBA。</p><h4 id="CXFArchitecture-TheSoapBinding">肥皂绑定</h4><p>原型绑定是SOAP。它有自己的<code>Message</code>类称为<code>SoapMessage</code> 。它增加了保持电流的能力<code>SoapVersion</code>以及邮件的标题。</p><p>的<code>Soap</code>绑定还添加了一种特殊的拦截器类型，称为<code>SoapInterceptor</code> 。的<code>SoapInterceptor</code>将两种方法添加到<code>Interceptor</code>类：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">Set&lt;URI&gt; getRoles();
Set&lt;QName&gt; getUnderstoodHeaders();
</pre>
</div></div><p>这些通知SOAP拦截器特定的SOAP拦截器可以理解哪些标头和角色。</p><p>它具有许多旨在处理SOAP消息的拦截器：</p><ol><li><code>StaxInInterceptor</code> ：创建一个<code>XMLStreamReader</code>从传入<code>InputStream</code></li><li><code>ReadHeadersInterceptor</code> ：将标题读入<code>SoapMessage</code></li><li><code>MustUnderstandInterceptor</code> ：检查<code>MustUnderstand</code>所有标头的属性<code>SoapInterceptor</code>的<code>getUnderstoodHeaders</code>方法。</li><li><code>SoapOutInterceptor</code> ：</li></ol><h4 id="CXFArchitecture-AdditionalBindings">附加绑定</h4><p>其他绑定包括REST / HTTP绑定，纯XML绑定和CORBA绑定。</p><h3 id="CXFArchitecture-Transports">运输工具</h3><p>CXF包括其自己的传输抽象层，以从绑定和前端层隐藏传输特定的细节。当前支持的传输包括：通过Camel的CXF传输，包括SMTP / POP3，TCP和Jabber，HTTP，HTTP，HTTP-Jetty，HTTP-OSGI，Servlet，本地，JMS，In-VM以及许多其他传输。<a shape="rect" href="http://cxf.apache.org/docs/transports.html">在此处</a>了解有关运输的更多信息。</p><h4 id="CXFArchitecture-Conduits">管道</h4><p>管道为传出消息的发送提供了基础。一种<code>Conduit</code>由一个创建<code>ConduitInitiator</code> 。发送消息是一个多步骤的过程：</p><ol><li>调用pipeline.prepare（message）：这将开始发送消息。在这一点上<code>Conduit</code>可以启动连接并为传出消息设置OutputStream。</li><li>将实际信息写到<code>OutputStream</code></li><li>拨电至<code>conduit.close(message)</code> ：这将关闭并处置用于消息发送的所有现有资源。<br clear="none">邮件发送者也可以注册一个<code>MessageObserver</code>与导管。如果<code>Conduit</code>是同步的<code>MessageObserver</code>收到回复后将通知您。</li></ol><h4 id="CXFArchitecture-Destinations">目的地</h4><p>目标是接收传入消息的基础。目标是从<code>DestinationFactory</code> ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">DestinationFactoryManager dfManager = bus.getExtension(DestinationFactoryManager.class);

// Find a DestinationFactory for the SOAP HTTP transport
DestinationFactory df = dfManager.getDestinationFactory("http://schemas.xmlsoap.org/wsdl/soap/http");

// TODO: outline building of EndpointInfo
EndpointInfo endpointInfo = ...;
Destination destination = df.getDestination(endpointInfo);
</pre>
</div></div><p>然后可以将MessageObservers注册到Destinations。这些侦听传入的消息：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">MessageObserver myObserver = ...;
destination.setMessageObserver(myObserver);
</pre>
</div></div><p>最普遍的<code>MessageObserver</code>在CXF中使用的是<code>ChainInitiationObserver</code> 。这将接收传入的消息，创建一条消息Exchange＆ <code>PhaseInterceptorChain</code> ，然后启动链。</p><h3 id="CXFArchitecture-AJAX-WSexample">一个JAX-WS示例</h3><p>这是我们通过JAX-WS发布服务时可能发生的情况的一个小示例<code>Endpoint.publish()</code>方法。</p><ol><li>拨电至<code>Endpoint.publish("http://localhost/service", myService)</code></li><li>的<code>EndpointImpl</code>从创建服务<code>myService</code>使用对象<code>JaxWsServiceFactoryBean</code>使用类和/或WSDL</li><li>一个<code>EndpointInfo</code>为<code>Endpoint.publish</code>网址</li><li>一种<code>JaxWsEndpointImpl</code>从创建<code>EndpointInfo</code> 。它包含JAX-WS端点特定的拦截器</li><li>的<code>JaxWsEndpointImpl</code>创建一个<code>Binding</code>和<code>Destination</code>听。</li></ol><h2 id="CXFArchitecture-Dependencies">依存关系</h2><p><a shape="rect" href="http://cxf.apache.org/docs/cxf-dependency-graphs.html">CXF的依赖项</a></p><h2 id="CXFArchitecture-Quality">质量</h2><p>CXF的软件质量方法<a shape="rect" href="http://cxf.apache.org/coding-guidelines.html">在此处</a>详细介绍。</p><h3 id="CXFArchitecture-References">参考文献</h3><ul><li><a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/Software_architecture" rel="nofollow">软件构架</a> ， <em>维基百科</em></li><li><a shape="rect" class="external-link" href="http://www.ecs.csun.edu/~rlingard/COMP684/Example2SoftArch.htm#Logical View" rel="nofollow">S / W体系结构文档样本</a> ， <em>Rational软件公司</em></li><li><a shape="rect" class="external-link" href="http://www.oreillynet.com/xml/blog/2006/03/documenting_your_software_arch.html" rel="nofollow">记录您的软件体系结构</a> ， <em>作者Jim Alateras</em> （2006年3月）</li></ul></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=44806">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=44806&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>