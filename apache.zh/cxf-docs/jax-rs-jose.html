<html ><head></head><body  onload="init()">﻿

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS JOSE">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushJScript.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS JOSE</title>
  



<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-oauth2.html">JAX-RS OAuth2</a> > <a href="jax-rs-jose.html">JAX-RS JOSE</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1553637438026 {padding: 0px;}
div.rbtoc1553637438026 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1553637438026 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1553637438026">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-Introduction">介绍</a></li><li><a shape="rect" href="#JAX-RSJOSE-MavenDependencies">Maven依赖</a></li><li><a shape="rect" href="#JAX-RSJOSE-JavaandJCEPolicy">Java和JCE政策</a></li><li><a shape="rect" href="#JAX-RSJOSE-JOSEOverviewandImplementation">JOSE概述和实施</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-JWAAlgorithms">JWA算法</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWKKeys">JWK键</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSSignature">JWS签名</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-SignatureandVerificationProviders">签名和验证提供者</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSCompact">JWS紧凑版</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSJSON">JWS JSON</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSwithDetachedContent">具有分离内容的JWS</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSwithUnencodedPayload">具有未编码净荷的JWS</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-JWEEncryption">JWE加密</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-KeyandContentEncryptionProviders">密钥和内容加密提供程序</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWECompact">JWE紧凑型</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWEJSON">JWE JSON</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-JSONWebToken">JSON Web令牌</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSandJWECombined">JWS和JWE合并</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-JOSEJAX-RSFilters">JOSE JAX-RS过滤器</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-JWS">JWS</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-JWSCompact.1">JWS紧凑版</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSCompactWithUnencodedPayload">具有未编码净荷的JWS Compact</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSJSON.1">JWS JSON</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWSJSONwithUnencodedPayload">具有未编码净荷的JWS JSON</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-SigningandVerificationofHTTPAttachments">HTTP附件的签名和验证</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWE">杰威</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-JWECompact.1">JWE紧凑型</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWEJSON.1">JWE JSON</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-LinkingJWTauthenticationstoJWSorJWEcontent">将JWT身份验证链接到JWS或JWE内容</a></li><li><a shape="rect" href="#JAX-RSJOSE-JWTauthorization">JWT授权</a></li><li><a shape="rect" href="#JAX-RSJOSE-OptionalprotectionofHTTPheaders">HTTP标头的可选保护</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-JOSEinJAX-RSapplicationcode">JOSE在JAX-RS中的应用代码</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-Option1:ProcessJOSEdirectly">选项1：直接处理JOSE</a></li><li><a shape="rect" href="#JAX-RSJOSE-Option2:UseJOSElibraryhelpersandEndpointConfiguration">选项2：使用JOSE库帮助程序和端点配置</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-ProduceJOSEdata">产生JOSE资料</a></li><li><a shape="rect" href="#JAX-RSJOSE-ConsumeJOSEdata">消耗JOSE数据</a></li><li><a shape="rect" href="#JAX-RSJOSE-ProduceandConsumeJOSEdata">产生和消费JOSE数据</a></li><li><a shape="rect" href="#JAX-RSJOSE-Configuretheendpoint">配置端点</a></li></ul>
</li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-Configuration">组态</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-ConfigurationPropertyContainers">配置属性容器</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSJOSE-Signature">签名</a></li><li><a shape="rect" href="#JAX-RSJOSE-Encryption">加密</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-Configurationthatappliestobothencryptionandsignature">适用于加密和签名的配置</a></li><li><a shape="rect" href="#JAX-RSJOSE-Configurationthatappliestosignatureonly">仅适用于签名的配置</a></li><li><a shape="rect" href="#JAX-RSJOSE-Configurationthatappliestoencryptiononly">仅适用于加密的配置</a></li><li><a shape="rect" href="#JAX-RSJOSE-ConfigurationthatappliestoJWTtokensonly">仅适用于JWT令牌的配置</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSJOSE-Interoperability">互通性</a></li><li><a shape="rect" href="#JAX-RSJOSE-Third-PartyLibraries">第三方图书馆</a></li></ul>
</div><h1 id="JAX-RSJOSE-Introduction">介绍</h1><p><a shape="rect" class="external-link" href="https://datatracker.ietf.org/wg/jose/documents/" rel="nofollow">JOSE</a>是一组高质量规范，用于指定如何使用JSON格式的元数据（标头）中设置的密码属性对数据有效载荷进行签名/验证和/或加密/解密。要保护的数据可以采用JSON或其他格式（纯文本，XML，二进制数据）。</p><p><a shape="rect" class="external-link" href="https://datatracker.ietf.org/wg/jose/documents/" rel="nofollow">JOSE</a>是高级OAuth2和OpenId Connect应用程序的关键部分，但也可以成功用于保护常规HTTP Web服务通信。</p><p>CXF 3.0.x，3.1.x和3.2.0提供了<a shape="rect" class="external-link" href="https://datatracker.ietf.org/wg/jose/documents/" rel="nofollow">JOSE</a>的完整实现，并提供了全面的实用程序和过滤器支持，以在<a shape="rect" class="external-link" href="https://datatracker.ietf.org/wg/jose/documents/" rel="nofollow">JOSE</a>的帮助下保护JAX-RS服务和客户端。</p><p>CXF <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-oauth2.html">OAuth2</a>和<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-oidc.html">OIDC</a>模块也取决于它。</p><p><strong>新增功能</strong> ：使用JWS分离内容模式对多部分进行签名和验证支持。</p><p><strong>新增</strong> ：可选的HTTP标头保护。</p><h1 id="JAX-RSJOSE-MavenDependencies">Maven依赖</h1><p>具有以下依赖关系将使开发人员可以编写JOSE JWS或JWE代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-rs-security-jose&lt;/artifactId&gt;
  &lt;version&gt;3.1.7&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><p>具有以下依赖性将使开发人员可以使用JAX-RS JOSE过滤器，该过滤器将对数据流进行签名和/或加密，解密或/和验证传入的JOSE序列并使原始数据可用于处理。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-rs-security-jose-jaxrs&lt;/artifactId&gt;
  &lt;version&gt;3.1.7&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><p>您可能还需要包括BouncyCastle，以支持某些JWE加密算法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
     &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
     &lt;artifactId&gt;bcprov-ext-jdk15on&lt;/artifactId&gt;
     &lt;version&gt;1.60&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><p>BouncyCastle提供程序可以按以下方式注册和注销：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>BouncyCastle提供程序</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.security.Security;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

private static void registerBouncyCastle() throws Exception {
    Security.addProvider(new BouncyCastleProvider());    
}

private static void unregisterBouncyCastle() throws Exception {
    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);    
}</pre>
</div></div><p><br clear="none"></p><h1 id="JAX-RSJOSE-JavaandJCEPolicy">Java和JCE政策</h1><p>在大多数情况下，建议使用Java7或更高版本。</p><p><strong>杰威</strong></p><p>Java6不支持JWE AES GCM密钥包装和内容加密算法（而对于BouncyCastle，无法将JWE Header属性作为加密过程的额外输入来获得其完整性保护），但是对于Java 6，则可以使用AesCbcHmac内容如果安装了BouncyCastle，则加密。</p><p>如果加密密钥的大小为256位（例如，JWE A256GCM），则需要安装Java 7/8/9无限JCE策略。</p><p><strong>JWS</strong></p><p>Java 6也应该很好，但请注意，只有CXF 3.0.x可以与Java 6一起运行。</p><h1 id="JAX-RSJOSE-JOSEOverviewandImplementation">JOSE概述和实施</h1><p>JOSE包含以下关键部分：</p><ul><li><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518" rel="nofollow">JWA-</a>列出所有受支持的签名和加密算法的JSON Web算法</li><li><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7517" rel="nofollow">JWK</a> -JSON Web密钥-引入了一种JSON格式，用于描述JWA算法使用的公钥和私钥</li><li><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515" rel="nofollow">JWS</a> -JSON Web签名-描述了如何对数据进行签名或验证，并介绍了用于表示已签名数据的紧凑型和JSON JWS格式</li><li><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7516" rel="nofollow">JWE</a> -JSON Web加密-描述如何对数据进行加密或解密，并引入紧凑的JSON JWE格式来表示加密的数据</li></ul><p>此外， <a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7519" rel="nofollow">JWT</a> （JSON Web令牌）虽然在技术上不属于JOSE，但通常用作JWS和JWE处理器的输入材料，尤其是在OAuth2流中（例如：OAuth2访问令牌可以在内部表示为JWT，OpenIdConnect IdToken和UserInfo实际上是JWT）。<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7519" rel="nofollow">JWT</a>描述了如何以JWS签名和/或使用JWE加密一组JSON格式的声明。</p><h2 id="JAX-RSJOSE-JWAAlgorithms">JWA算法</h2><p>所有JOSE签名和加密算法都在<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518" rel="nofollow">JWA</a> （JSON Web算法）规范中进行了分组和描述。</p><p>该算法分为三类：签名算法（HMAC，RSA，椭圆曲线），用于支持内容加密密钥加密的算法（RSA-OAEP，AES密钥包装等）以及用于加密实际内容的算法（AES GCM）或AES CBC HMAC）。</p><div>该规范列出了可用于签名或加密数据的所有算法，并描述了某些情况下这些算法的工作方式</div><div>Java JCA（或BouncyCastle）不直接支持它们的地方，例如AES-CBC-HMAC-SHA2。</div><div>算法名称是类型+提示，例如：HS256（带有SHA-256的HMAC），RSA-OAEP-256（带有SHA-256的RSA OAEP密钥加密）等。</div><p>所有JWS和JWE算法不仅处理实际数据，还处理元数据（算法属性），从而确保它们受到完整性保护，此外，JWE算法还会生成身份验证标签，以确保不会对已加密的内容进行处理。</p><p>请参考<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518" rel="nofollow">规范</a>以获取有关特定签名或加密算法所需的所有信息（包括适用的RFC的后续链接）：属性，建议的密钥大小以及与所有或某些特定算法有关的其他安全注意事项。CXF JOSE代码已经强制实施了许多建议的约束。</p><p>CXF在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwa" rel="nofollow">此软件包中</a>提供了使用JWA算法的实用程序支持。</p><p>通常，将以类型安全的方式向JWS或JWE处理器提供算法属性，例如SignatureAlgorithm。JWS的HS256，KeyAlgorithm。A256KW加上ContentAlgorithm。用于JWE等的A256GCM。每个枚举都有检查密钥大小，JWA和Java JCA算法名称的方法。</p><h2 id="JAX-RSJOSE-JWKKeys">JWK键</h2><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7517" rel="nofollow">JWK</a> （JSON Web密钥）是描述加密密钥属性的JSON文档。JWK非常灵活，可以期望JWK成为表示和存储密码密钥的主要机制之一。虽然不必为了签名或加密文档而依靠Java JCA秘密和非对称密钥来将密钥表示为JWK，但是JWK是JOSE中签名或加密密钥的一种首选表示形式。</p><p>例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>秘密HMAC密钥</b></div><div class="codeContent panelContent pdl">
<pre class="brush: js; gutter: false; theme: Default">{
   "kty":"oct",
   "k":"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow",
   "kid":"Secret HMAC key"
}</pre>
</div></div><p>要么</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>公开RSA密钥</b></div><div class="codeContent panelContent pdl">
<pre class="brush: js; gutter: false; theme: Default">{
  "kty":"RSA",
  "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx
     4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMs
     tn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2
     QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbI
     SD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqb
     w0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw",
  "e":"AQAB",
  "alg":"RS256",
  "kid":"Public RSA Key"
}</pre>
</div></div><p>“孩子”属性可能特别受关注，因为它既可以识别密钥，又可以帮助实现简单的密钥旋转机制（例如， <a shape="rect" class="external-link" href="http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys" rel="nofollow">OIDC非对称密钥旋转</a> ）。</p><p>JWK密钥的集合称为JWK密钥集，它表示为JWK的JSON数组。</p><p>如果需要，JWK可以包含X509证书或其指纹。</p><p>CXF提供了一种实用程序支持，用于读写JWK密钥和密钥集以及使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk" rel="nofollow">此程序包中</a>的加密内联和独立JWK存储。</p><p>例如，可以在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/certs/jwkPublicSet.txt" rel="nofollow">此处</a>看到包含公共JWK密钥的密钥集，并可以从<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jws.ec.public.properties#L19" rel="nofollow">配置属性中对其进行</a>引用。私有（测试）密钥集可以以<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/certs/jwkPrivateSet.txt" rel="nofollow">清晰的形式</a>表示，尽管您很可能希望对私有密钥集进行<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/certs/encryptedJwkPrivateSet.txt" rel="nofollow">加密</a>并<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/secret.aescbchmac.properties#L19" rel="nofollow">像这样</a>引用。</p><p>可以直接在配置属性中内联加密密钥或密钥集。例如，这<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/secret.aescbchmac.inlinejwk.properties#L18" rel="nofollow">是内联</a>加密的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/secret.aescbchmac.inlinejwk.properties#L18" rel="nofollow">单个JWK密钥的方式</a> 。同样，这<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/secret.aescbchmac.inlineset.properties#L18" rel="nofollow">是内联</a>加密密钥<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/secret.aescbchmac.inlineset.properties#L18" rel="nofollow">集合的方式</a> 。</p><p>如果在请求上下文中有<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/common/PrivateKeyPasswordProvider.java" rel="nofollow">密码提供者</a>可用，则CXF假定JWK密钥已经加密，通常在JAX-RS端点上注册了该<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/common/PrivateKeyPasswordProvider.java" rel="nofollow">密码提供者</a> 。加密是通过基于密码的<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4.8" rel="nofollow">PBES2算法完成的</a> 。</p><p>地图上支持用于加载JWK的可插拔策略。</p><p>例如，以下是使用“孩子”来加载JWK密钥的方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>JWK示例</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">InputStream is = JsonWebKeyTest.class.getResourceAsStream(fileName);
JsonWebKeys keySet = JwkUtils.readJwkSet(is);
JsonWebKey key = keySet.getKey("Public RSA Key");
String thumbprint = JwkUtils.getThumbprint(key);
assertEquals("NzbLsXh8uDCcd-6MNwXF4W_7noWXFZAfHkxZsRGC9Xs", thumbprint);
KeyType keyType = key.getKeyType();
assertEquals(KeyType.RSA, keyType);</pre>
</div></div><p>JsonWebKeys还支持按其类型（RSA，EC，八位位组）和操作（ENCRYPT，SIGN等）检索密钥。<br clear="none">加载JWK后，通常会将其提交给JWS或JWE提供者。</p><h2 id="JAX-RSJOSE-JWSSignature">JWS签名</h2><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515" rel="nofollow">JWS</a> （JSON Web签名）文档描述了如何对文档内容进行签名。例如， <a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#appendix-A.1" rel="nofollow">附录A1</a>显示了如何使用HMAC密钥对内容进行签名</p><p>CXF在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws" rel="nofollow">此软件包中</a>附带了与JWS相关的类，并提供对所有JWA <a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-3" rel="nofollow">签名算法</a>的支持。</p><h3 id="JAX-RSJOSE-SignatureandVerificationProviders">签名和验证提供者</h3><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsSignatureProvider.java" rel="nofollow">JwsSignatureProvider</a>支持对内容签名<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsSignatureVerifier.java" rel="nofollow">JwsSignatureVerifier-</a>验证签名。</p><p>请注意，签名和验证功能由2个不同的接口表示-这样做是为了使接口保持最小化，并使关注点分离开来，这在代码仅签名或仅进行验证的情况下最为明显。</p><p>下表显示了算法和相应的提供程序（ <span class="pl-smi">org.apache.cxf.rs.security.jose.jws</span>程序包）：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd"><strong>算法</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>JWS标头“ alg”</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>JwsSignatureProvider</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>JwsSignatureVerifier</strong></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-3.2" rel="nofollow">HMAC</a></td><td colspan="1" rowspan="1" class="confluenceTd">HS256，HS384，HS512</td><td colspan="1" rowspan="1" class="confluenceTd"><p>HmacJwsSignatureProvider</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>HmacJwsSignatureVerifier</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-3.3" rel="nofollow">RSASSA-PKCS1-v1_5</a></td><td colspan="1" rowspan="1" class="confluenceTd">RS256，RS384，RS512</td><td colspan="1" rowspan="1" class="confluenceTd">PrivateKeyJwsSignatureProvider</td><td colspan="1" rowspan="1" class="confluenceTd">PublicKeyJwsSignatureVerifier</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-3.4" rel="nofollow">ECDSA</a></td><td colspan="1" rowspan="1" class="confluenceTd">ES256，ES384，ES512</td><td colspan="1" rowspan="1" class="confluenceTd">EcDsaJwsSignatureProvider</td><td colspan="1" rowspan="1" class="confluenceTd">EcDsaJwsSignatureVerifier</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-3.5" rel="nofollow">RSASSA-PSS</a></td><td colspan="1" rowspan="1" class="confluenceTd">PS256，PS384，PS512</td><td colspan="1" rowspan="1" class="confluenceTd">PrivateKeyJwsSignatureProvider</td><td colspan="1" rowspan="1" class="confluenceTd">PublicKeyJwsSignatureVerifier</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-3.6" rel="nofollow">没有</a></td><td colspan="1" rowspan="1" class="confluenceTd">没有</td><td colspan="1" rowspan="1" class="confluenceTd">NoneJwsSignatureProvider</td><td colspan="1" rowspan="1" class="confluenceTd">NoneJwsSignatureVerifier</td></tr></tbody></table></div><p>可以使用从JWK或Java JKS存储或从内存表示形式加载的密钥来初始化这两个提供程序（无除外）中的任何一个。</p><p>由于现有的JKS商店随处可见，并且使公开验证密钥可用的相对简单的方法，因此目前可能最常使用RS256 / 384/512算法。当随后对JWS序列进行JWE加密或使用2向TLS（带有客户端和服务器证书）时，“无”算法可能很有用。</p><p>确定需要支持哪种算法后，如果同时需要对数据签名和验证，则可以初始化一对适当的JwsSignatureProvider和JwsSignatureVerifier。如果仅需要签名-选择JwsSignatureProvider，仅验证-选择JwsSignatureVerifier。选定的提供程序将提交给JWS Compact或JWS JSON生产者或使用者。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsUtils.java" rel="nofollow">JwsUtils</a>实用程序类具有许多帮助程序方法，用于加载JwsSignatureProvider或JwsSignatureVerifier以及获取创建和验证的JWS序列。</p><h3 id="JAX-RSJOSE-JWSCompact">JWS紧凑版</h3><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#section-3.3" rel="nofollow">JWS Compact表示形式</a>是最常用的JWS序列格式。它是由JWS标头的Base64URL编码序列（算法和其他属性），受保护的实际数据的Base64URL编码序列和签名算法输出字节的Base64URL编码序列连接而成。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsCompactProducer.java" rel="nofollow">JwsCompactProducer</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsCompactConsumer.java" rel="nofollow">JwsCompactConsumer</a>提供了对生成和使用紧凑JWS序列的支持，以JSON或非JSON格式保护数据。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsJwtCompactProducer.java" rel="nofollow">JwsJwtCompactProducer</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsJwtCompactConsumer.java" rel="nofollow">JwsJwtCompactConsumer</a>是它们的简单扩展，有助于处理类型化的JWT令牌。</p><p>例如，以下是在CXF中如何完成<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#appendix-A.1" rel="nofollow">附录A1</a>示例的方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>CXF JWS Compact HMac</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JwtClaims claims = new JwtClaims();
claims.setIssuer("joe");
claims.setExpiryTime(1300819380L);
claims.setClaim("http://example.com/is_root", Boolean.TRUE);

JwsCompactProducer jwsProducer = new JwsJwtCompactProducer(claims);

// Sign
// Load HmacJwsSignatureProvider directly, see the next example for the alternative approach
String jwsSequence = jwsProducer.signWith(new HmacJwsSignatureProvider(ENCODED_MAC_KEY, SignatureAlgorithm.HS256));

// Validate
JwsJwtCompactConsumer jwsConsumer = new JwsJwtCompactConsumer(jwsSequence);

// Load HmacJwsSignatureVerifier directly, see the next example for the alternative approach
jwsConsumer.verifySignatureWith(new HmacJwsSignatureVerifier(ENCODED_MAC_KEY, SignatureAlgorithm.HS256)));

// Get the data
JwtClaims protectedClaims = jws.getJwtClaims();
</pre>
</div></div><p>在上面的示例中，数据（JwtToken）提交到JwsCompactProducer（JwsJwtCompactProducer）实例，并使用HMac密钥签名。</p><p>这是另一个示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>CXF JWS Compact RSA</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JwsCompactProducer jwsProducer = new JwsCompactProducer("Hello World");

// Load private RSA key from the JWK Key set stored on the disk
InputStream is = JsonWebKeyTest.class.getResourceAsStream(fileName);
JsonWebKeys keySet = JwkUtils.readJwkSet(is);
JsonWebKey jwkPrivateRsaKey = keySet.getKey("Private RSA Key");

// Sign
String jwsSequence = jwsProducer.signWith(jwkPrivateRsaKey);

// Validate
JwsCompactConsumer jwsConsumer = new JwsCompactConsumer(jwsSequence);

// Load Public RSA Key from Java JKS Store
PublicKey publicRsaKey = CryptoUtils.loadPublicKey(keyStoreLocation, keyStorePassword, keyAlias, KeyStore.getDefaultType()); 

jws.verifySignatureWith(publicRsaKey);

// Get the data
String helloWorldString = jwsConsumer.getDecodedJwsPayload();
</pre>
</div></div><p>在这个最新示例中，纯文本序列使用从JWK存储加载的私有RSA密钥进行编码，并使用从现有Java JKS存储加载的公共RSA密钥进行验证。</p><h3 id="JAX-RSJOSE-JWSJSON">JWS JSON</h3><p>尽管优化了JWS Compact并表示3个Base64URL值的串联，但是JWS JSON是一个开放的JSON容器，请参阅<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#appendix-A.6" rel="nofollow">附录6</a> 。</p><p>JWS JSON最有趣的功能是允许为多个收件人签名内容。例如，直接消费者将使用一个密钥来验证签名，将有效载荷转发给下一个消费者，后者还将使用另一个密钥来验证内容，等等。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsJsonProducer.java" rel="nofollow">JwsJsonProducer</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsJsonConsumer.java" rel="nofollow">JwsJsonConsumer</a>支持生成和使用JWS JSON序列。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>CXF JWS JSON</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JwsJsonProducer producer = new JwsJsonProducer(UNSIGNED_PLAIN_JSON_DOCUMENT);
JwsHeaders headerEntries = new JwsHeaders(SignatureAlgorithm.HS256);
              
producer.signWith(new HmacJwsSignatureProvider(ENCODED_MAC_KEY_1, SignatureAlgorithm.HS256),
                  headerEntries);
producer.signWith(new HmacJwsSignatureProvider(ENCODED_MAC_KEY_2, SignatureAlgorithm.HS256),
                  headerEntries);
assertEquals(DUAL_SIGNED_JWS_JSON_DOCUMENT, producer.getJwsJsonSignedDocument());

JwsJsonConsumer consumer = new JwsJsonConsumer(DUAL_SIGNED_DOCUMENT); 

// Validate both signatures, see below how to validate and produce
JsonWebKeys jwks = readKeySet("jwkSet.txt");
        
List&lt;JwsJsonSignatureEntry&gt; sigEntries = consumer.getSignatureEntries();
assertEquals(2, sigEntries.size());

// 1st signature
String firstKid = (String)sigEntries.get(0).getKeyId();
JsonWebKey firstKey = jwks.getKey(firstKid);
assertTrue(sigEntries.get(0).verifySignatureWith(firstKey));
// 2nd signature
String secondKid = (String)sigEntries.get(1).getKeyId();
JsonWebKey secondKey = jwks.getKey(secondKid);
assertTrue(sigEntries.get(1).verifySignatureWith(secondKey));

// or if you wish to validate (ex with the firstKey loaded above) and forward it to the next consumer, do:
JwsSignatureProvider provider = JwsUtils.getSignatureProvider(firstKey);
String nextJwsJson = consumer.validateAndProduce(Collections.singletonList(provider));
// use WebClient to post nextJwsJson to the next consumer, with nextJwsJson being nearly identical to the original
// double-signed JWS JSON signature, minus the signature which was already validated, in this case nextJwsJson will 
// only have a single signature </pre>
</div></div><p>上面的代码生成一个包含两个签名的JWS JSON序列，类似于<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#appendix-A.6.4" rel="nofollow">本示例</a> 。如果序列仅包含一个签名，那么JWS JSON“签名”数组将包含一个“签名”元素，或者可以放<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#appendix-A.6.4" rel="nofollow">平</a>整个序列，而无需放置实际的“签名”数组。默认情况下，仅使用单个签名时，JwsJsonProducer不会生成平坦化的序列，因为第三方JWS JSON使用者可能只能处理带有“签名”数组的序列，因此如果需要，可以向JwsJsonProducer传递“ supportFlattened”标志。</p><p>如果您不打算执行多个签名，那么使用JWS JSON是否有意义？确实，如果仅是单个签名，那么使用JWS Compact是一个很好的选择，它很可能经常使用。</p><p>但是，即使您执行单个签名，您仍可能要尝试JWS JSON，因为例如在检查日志或TCP跟踪HTTP请求/响应时，更易于观察各个JWS JSON结构部分。当我们开始谈论未编码的有效负载选项时，尤其如此，请参见下文。</p><h3 id="JAX-RSJOSE-JWSwithDetachedContent">具有分离内容的JWS</h3><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#appendix-F" rel="nofollow">具有分离内容的JWS</a>提供了一种完整性保护某些数据的方法，而无需实际将这些数据包含在生成的JWS序列中。</p><p>例如，如果生产者和消费者都可以访问相同的共享数据，则生产者可以对这些数据进行签名，并将JWS序列（不包含数据）发布给消费者。使用者将验证此JWS序列，并断言在接收到该数据之前尚未修改数据并开始验证序列。JWS Compact和JWS JSON Producer和Consumer提供者构造函数接受可选的“ detached”标志，以备不时之需。</p><p>请注意，分离内容模式用于支持CXF多部分附件的签名和验证，请参阅下面的更多信息。</p><h3 id="JAX-RSJOSE-JWSwithUnencodedPayload">具有未编码净荷的JWS</h3><p>默认情况下，JWS Compact和JWS JSON序列首先对数据进行Base64Url编码，然后将其内联到结果序列中。这对于在OAuth2 / OIDC流中用于表示已签名访问或ID令牌的JWS Compact尤其有用。</p><p>关于要内联的数据的一个担忧是，对Base64Url进行编码需要花费额外的时间，这对于较大的有效负载而言可能会变得明显，而另一个担忧是，在查看日志或跟踪屏幕中的JWS序列时，无法看到数据。</p><p>因此<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7797" rel="nofollow">，引入</a>了<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7797" rel="nofollow">具有未编码有效负载</a>选项（JWS标头'b64'属性设置为false）的JWS，以使用户配置JWS签名提供程序不对实际数据有效负载进行编码，请参见<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7797#page-7" rel="nofollow">本示例</a> 。</p><p>JWS JSON和JWS Compact都为分离和嵌入的有效负载支持'b64'属性。</p><p>在CXF中，您可以将此选项应用于JWS Compact（从CXF 3.1.7嵌入的有效负载）和JWS JSON序列，这是JWS JSON代码片段：</p><p><br clear="none"></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>JWS JSON未编码</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JwsJsonProducer producer = new JwsJsonProducer(UNSIGNED_PLAIN_JSON_DOCUMENT, true);
JwsHeaders headers = new JwsHeaders(SignatureAlgorithm.HS256);
headers.setPayloadEncodingStatus(false);
producer.signWith(new HmacJwsSignatureProvider(ENCODED_MAC_KEY_1, SignatureAlgorithm.HS256),
                  headers);</pre>
</div></div><p>注意，JWS Compact使用“。”。作为其3个部分之间的分隔符。<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7797#section-5" rel="nofollow">具有</a>未编码净荷的<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7797#section-5" rel="nofollow">JWS</a>建议应用程序负责处理可能具有“。”的未编码净荷。字符。同样，应用程序需要注意带有双引号的JWS JSON未编码有效载荷。</p><p>请注意，CXF多部分附件的签名和验证确实取决于此未编码的有效负载功能，请参阅下面的更多信息。</p><h2 id="JAX-RSJOSE-JWEEncryption">JWE加密</h2><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7516" rel="nofollow">JWE</a> （JSON Web加密）文档描述了如何加密文档内容以及适用时的内容加密密钥。例如， <a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7516#appendix-A.1" rel="nofollow">附录A1</a>显示了如何使用AesGcm使用密钥对内容进行加密，而使用RSA-OAEP对实际内容加密密钥进行加密。</p><p>CXF在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe" rel="nofollow">此软件包中</a>附带了JWE相关类，并提供对所有JWA <a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4" rel="nofollow">密钥加密</a>和<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-5" rel="nofollow">内容加密</a>算法的支持。</p><h3 id="JAX-RSJOSE-KeyandContentEncryptionProviders">密钥和内容加密提供程序</h3><p>JWE加密过程通常涉及生成内容加密密钥，然后使用消费者已知的密钥对该密钥进行加密/包装。因此，CXF提供了用于支持密钥加密算法的提供者和用于支持内容加密算法的提供者。还支持直接密钥加密（其中，内容加密密钥是在带外建立的）。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/KeyEncryptionProvider.java" rel="nofollow">KeyEncryptionProvider</a>支持对内容加密密钥<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/KeyDecryptionProvider.java" rel="nofollow">KeyDecryptionProvider</a>进行加密-对其进行解密。</p><p>下表显示了密钥加密算法和相应的提供程序（ <span class="pl-smi">org.apache.cxf.rs.security.jose.jwe</span>程序包）：</p><div class="table-wrap"><table class="confluenceTable"><colgroup span="1"><col span="1"><col span="1"><col span="1"><col span="1"></colgroup><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd"><strong>算法</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>JWE标头“ alg”</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>KeyEncryptionProvider</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>密钥解密提供者</strong></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4.2" rel="nofollow">RSAES-PKCS1-v1_5</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">RSA1_5</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>RSAKeyEncryptionAlgorithm</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>RSA密钥解密算法</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4.3" rel="nofollow">RSAES OAEP</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">RSA-OAEP，RSA-OAEP-256</p></td><td colspan="1" rowspan="1" class="confluenceTd">RSAKeyEncryptionAlgorithm</td><td colspan="1" rowspan="1" class="confluenceTd">RSA密钥解密算法</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4.4" rel="nofollow">AES密钥包装</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">A128KW，A192KW，A256KW</p></td><td colspan="1" rowspan="1" class="confluenceTd">AesKeyWrapEncryptionAlgorithm</td><td colspan="1" rowspan="1" class="confluenceTd">AesKeyWrapDecryptionAlgorithm</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4.5" rel="nofollow">直接</a></td><td colspan="1" rowspan="1" class="confluenceTd">目录</td><td colspan="1" rowspan="1" class="confluenceTd">DirectKeyEncryptionAlgorithm</td><td colspan="1" rowspan="1" class="confluenceTd">DirectKeyDecryptionAlgorithm</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#page-15" rel="nofollow">ECDH-ES钥匙扣</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">ECDH-ES + A128KW（+ A192KW，+ 256KW）</p></td><td colspan="1" rowspan="1" class="confluenceTd">EcdhAesWrapKeyEncryptionAlgorithm</td><td colspan="1" rowspan="1" class="confluenceTd">EcdhAesWrapKeyDecryptionAlgorithm</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#page-15" rel="nofollow">ECDH-ES直接</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">心电图</p></td><td colspan="1" rowspan="1" class="confluenceTd"><span class="pl-en">EcdhDirectKeyJweEncryption</span></td><td colspan="1" rowspan="1" class="confluenceTd"><span class="pl-en">EcdhDirectKeyJweDecryption</span></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4.7" rel="nofollow">AES-GCM密钥包装</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">A128GCMKW，A192GCMKW，A256GCMKW</p></td><td colspan="1" rowspan="1" class="confluenceTd">AesGcmWrapKeyEncryptionAlgorithm</td><td colspan="1" rowspan="1" class="confluenceTd">AesGcmWrapKeyDecryptionAlgorithm</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-4.8" rel="nofollow">PBES2</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">PBES2-HS256 + A128KW</p><p class="newpage">PBES2-HS384 + A192KW</p><p class="newpage">PBES2-HS512 + A256KW</p></td><td colspan="1" rowspan="1" class="confluenceTd">PbesHmacAesWrapKeyEncryptionAlgorithm</td><td colspan="1" rowspan="1" class="confluenceTd">PbesHmacAesWrapKeyDecryptionAlgorithm</td></tr></tbody></table></div><p><br clear="none"></p><p>由于现有的JKS商店随处可见，并且相对容易地使公共验证密钥可用，因此RSA-OAEP算法目前可能最常用。</p><p>如果使用AES密钥或AES-GCM密钥包装或PBES2密钥加密，则需要BouncyCastle。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/ContentEncryptionProvider.java" rel="nofollow">ContentEncryptionProvider</a>支持对生成的内容加密密钥<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/ContentDecryptionProvider.java" rel="nofollow">ContentDecryptionProvider</a>进行加密-对其进行解密。</p><p>下表显示了内容加密算法和相应的提供程序：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd"><strong>算法</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>JWE标头“ enc”</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>ContentEncryptionProvider</strong></td><td colspan="1" rowspan="1" class="confluenceTd"><strong>ContentDecryptionProvider</strong></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-5.2" rel="nofollow">AES_CBC_HMAC_SHA2</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">A128CBC-HS256（-HS384，-HS512）</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>AesCbcHmacJweEncryption，</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>AesCbcHmacJweDecryption</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-5.3" rel="nofollow">AES-GCM</a></td><td colspan="1" rowspan="1" class="confluenceTd"><p class="newpage">A128GCM，A92GCM，A256GCM</p></td><td colspan="1" rowspan="1" class="confluenceTd">AesGcmContentEncryptionAlgorithm</td><td colspan="1" rowspan="1" class="confluenceTd">AesGcmContentDecryptionAlgorithm</td></tr></tbody></table></div><p>可以使用从JWK或Java JKS存储或内存中表示形式加载的密钥来初始化上述所有提供程序。</p><p>如果使用AES_CBC_HMAC内容加密，则需要BouncyCastle。</p><p>一旦确定了需要支持哪种密钥和内容加密算法，就可以初始化<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweEncryptionProvider.java" rel="nofollow">JwsEncryptionProvider</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweDecryptionProvider.java" rel="nofollow">JwsDecryptionProvider</a> ，它们通过与密钥和内容加密提供者协调来完成实际的JWE加密/解密工作。CXF附带了<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweEncryption.java" rel="nofollow">JweEncryption</a> （JwsEncryptionProvider）和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweDecryption.java" rel="nofollow">JweDecryption</a> （JweDecryptionProvider）帮助程序，只需将它们传递给首选的密钥和内容加密提供程序，并对内容进行加密或解密。</p><p>JweEncryption和JweDecryption帮助创建和处理JWE Compact序列（请参阅下一节）。JweEncryption还可以帮助处理流JWE JSON序列（请参阅JAX-RS JWE过滤器部分）。</p><p>请注意，支持<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-5.2" rel="nofollow">AES_CBC_HMAC_SHA2竞争</a>加密的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/AesCbcHmacJweEncryption.java" rel="nofollow">AesCbcHmacJweEncryption</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/AesCbcHmacJweDecryption.java" rel="nofollow">AesCbcHmacJweDecryption</a>提供程序分别扩展了JweEncryption和JweDecryption。它们<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-5.2.2" rel="nofollow">在</a>内部实现<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7518#section-5.2.2" rel="nofollow">内容加密，</a>但确实接受首选的密钥加密/解密提供程序。</p><p>同样， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/DirectKeyJweEncryption.java" rel="nofollow">DirectKeyJweEncryption</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/DirectKeyJweDecryption.java" rel="nofollow">DirectKeyJweDecryption</a>是简单的JweEncryption和JweDecryption扩展，可以直接进行直接密钥内容加密/解密。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweUtils.java" rel="nofollow">JweUtils</a>实用程序类具有许多帮助程序方法，用于加载密钥和内容加密提供程序并获取加密和解密的数据。</p><h3 id="JAX-RSJOSE-JWECompact">JWE紧凑型</h3><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7516#section-3.3" rel="nofollow">JWE Compact表示形式</a>是最常用的JWE序列格式。它是5个部分的串联：JWE标头的Base64URL编码序列（算法和其他属性），JWE加密密钥的Base64URL编码序列（直接加密的情况下为空），JWE初始化向量的Base64URL编码序列，Base64URL -生成的密文的编码序列（加密的数据），最后是身份验证标签的Base64URL编码的序列（标头和密文本身的完整性保护）。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweCompactProducer.java" rel="nofollow">JweCompactProducer</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweCompactConsumer.java" rel="nofollow">JweCompactConsumer</a>提供了创建和使用紧凑JWE序列的基本支持。在大多数情况下，您可能更喜欢使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweEncryption.java" rel="nofollow">JweEncryption</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweDecryption.java" rel="nofollow">JweDecryption</a> ： <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweEncryption.java" rel="nofollow">JweEncryption</a>在调用其<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweEncryptionProvider.java#L27" rel="nofollow">加密</a>方法时在内部使用JweCompactProducer（ <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweEncryptionProvider.java#L32" rel="nofollow">getEncryptedOutput</a>将在JAX-RS JWE过滤器部分中讨论），并且<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweDecryption.java" rel="nofollow">JweDecryption</a>仅接受JWE Compact并在内部使用JweCompactConsumer。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweJwtCompactProducer.java" rel="nofollow">JweJwtCompactProducer</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsJwtCompactConsumer.java" rel="nofollow">JwsJwtCompactConsumer</a>帮助直接加密键入的JWT令牌。</p><p>这是在CXF中执行AES密钥包装和AES CBC HMAC的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>CXF Jwe AesWrapAesCbcHMac</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final String specPlainText = "Live long and prosper.";
        
AesWrapKeyEncryptionAlgorithm keyEncryption = new AesWrapKeyEncryptionAlgorithm(KEY_ENCRYPTION_KEY_A3, KeyAlgorithm.A128KW);
JweEncryptionProvider encryption = new AesCbcHmacJweEncryption(ContentAlgorithm.A128CBC_HS256,
                                                               keyEncryption);
String jweContent = encryption.encrypt(specPlainText.getBytes("UTF-8"), null);
        
AesWrapKeyDecryptionAlgorithm keyDecryption = new AesWrapKeyDecryptionAlgorithm(cekEncryptionKey);
JweDecryptionProvider decryption = new AesCbcHmacJweDecryption(keyDecryption);
String decryptedText = decryption.decrypt(jweContent).getContentText();
assertEquals(specPlainText, decryptedText);</pre>
</div></div><p><br clear="none"></p><p>这是另一个使用RSA-OAEP密钥加密和AES-GCM内容加密的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>CXF Jwe RsaOaepAesGcm</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final String content = "Live long and prosper.";
// Load public RSA key from the JWK Key set stored on the disk
InputStream is = JsonWebKeyTest.class.getResourceAsStream(fileName);
JsonWebKeys keySet = JwkUtils.readJwkSet(is);
JsonWebKey jwkPublicRsaKey = keySet.getKey("Public RSA Key");
KeyEncryptionProvider keyEncryptionAlgo = JweUtils.getKeyEncryptionProvider(jwkPublicRsaKey); 
ContentEncryptionProvider contentEncryptionAlgo = JweUtils.getContentEncryptionProvider(ContentAlgorithm.A256GCM);
JweEncryptionProvider encryptor = new JweEncryption(keyEncryptionAlgo, contentEncryptionAlgo);

// or simply
// JweEncryptionProvider encryptor = JweUtils.createJweEncryptionProvider(jwkPublicRsaKey, ContentAlgorithm.A256GCM);

String jweOut = encryptor.encrypt(content.getBytes(StandardCharsets.UTF_8), null); 

// Load Private RSA Key from Java JKS Store
PrivateKey privateRsaKey = 
    CryptoUtils.loadPrivateKey(keyStoreLocation, keyStorePassword, privateKeyPassword, keyAlias, KeyStore.getDefaultType());

JweDecryptionProvider decryptor = JweUtils.createJweDecryptionProvider(jwkPrivateRsaKey, ContentAlgorithm.A256GCM);
String decryptedText = decryption.decrypt(jweContent).getContentText();
assertEquals(content, decryptedText);</pre>
</div></div><h3 id="JAX-RSJOSE-JWEJSON">JWE JSON</h3><p>尽管优化了JWE Compact并表示5个Base64URL值的串联，但是JWE JSON是一个开放的JSON容器，请参阅<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7516#appendix-A.4" rel="nofollow">附录A4</a> 。</p><p>JWE JSON最有趣的功能是允许使用多个密钥加密密钥对内容进行加密，并将结果序列定向到多个收件人。例如，直接消费者将使用其自己的密钥解密密钥解密内容，将有效负载转发给下一个消费者，等等。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweJsonProducer.java" rel="nofollow">JweJsonProducer</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweJsonConsumer.java" rel="nofollow">JweJsonConsumer</a>支持生成和使用JWS JSON序列。</p><p>这是代码示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>杰森</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final String text = "The true sign of intelligence is not knowledge but imagination.";
// Create the secret keys for encrypting the content encryption key:
SecretKey wrapperKey1 = CryptoUtils.createSecretKeySpec(WRAPPER_BYTES1, "AES");
SecretKey wrapperKey2 = CryptoUtils.createSecretKeySpec(WRAPPER_BYTES2, "AES");

// Create KeyEncryptionProviders initialized with these secret keys: 
KeyEncryptionProvider keyEncryption1 = JweUtils.getSecretKeyEncryptionAlgorithm(wrapperKey1, KeyAlgorithm.A128KW);
KeyEncryptionProvider keyEncryption2 = JweUtils.getSecretKeyEncryptionAlgorithm(wrapperKey2, KeyAlgorithm.A128KW);

// If you work with the public keys do this instead:
// PublicKey publicKey1 = ...;
// KeyEncryptionProvider keyEncryption1 = JweUtils.getPublicKeyEncryptionProvider(publicKey1, KeyAlgorithm.RSA_AEP);
// PublicKey publicKey2 = ...;
// KeyEncryptionProvider keyEncryption2 = JweUtils.getPublicKeyEncryptionProvider(publicKey2, KeyAlgorithm.RSA_AEP);


// Create ContentEncryptionProvider:
// Starting from CXF 3.1.11:
ContentEncryptionProvider contentEncryption = new AesGcmContentEncryptionAlgorithm(ContentAlgorithm.A128GCM, true);
// or 
// ContentEncryptionProvider contentEncryption = JweUtils.getContentEncryptionProvider(ContentAlgorithm.A128GCM, true);

// Before CXF 3.1.1 a CEK needs to be pre-generated when dealing with multiple recipients:
//ContentEncryptionProvider contentEncryption = new AesGcmContentEncryptionAlgorithm(CEK_BYTES, ContentAlgorithm.A128GCM);

// If a single recipient then this line is enough:
//ContentEncryptionProvider contentEncryption = JweUtils.getContentEncryptionProvider(ContentAlgorithm.A128GCM);

// Prepare JweEncryptionProviders, one per each recipient.
List&lt;JweEncryptionProvider&gt; jweProviders = new LinkedList&lt;JweEncryptionProvider&gt;();
jweProviders.add(new JweEncryption(keyEncryption1, contentEncryption));
jweProviders.add(new JweEncryption(keyEncryption2, contentEncryption));


// Let the recipients know that the key encryption algorithm is A128KW. 
// This step is optional if the recipients support A128KW only.
// Note because these headers are shared A128KW needs to be supported by all the recipients.
// Per-reciepient specific headers can be used instead to note the key encryption algorithm if required.
// One can also consider setting this property in the shared protected headers, same as it is done below
// with the content algorithm

JweHeaders sharedUnprotectedHeaders = new JweHeaders();
sharedUnprotectedHeaders.setKeyEncryptionAlgorithm(KeyAlgorithm.A128KW);
// Set some other custom shared unprotected header
sharedUnprotectedHeaders.setHeader("customHeader", "customValue");

// Let the recipients know that the content encryption algorithm is A128GCM. 
// This step is optional if the recipients support A128GCM only.
JweHeaders protectedHeaders = new JweHeaders(ContentAlgorithm.A128GCM);

// Set per-recipient specific headers        
List&lt;JweHeaders&gt; perRecipientHeades = new LinkedList&lt;JweHeaders&gt;();
perRecipientHeades.add(new JweHeaders("key1"));
perRecipientHeades.add(new JweHeaders("key2"));

JweJsonProducer p = new JweJsonProducer(protectedHeaders,
                                        sharedUnprotectedHeaders,
                                        StringUtils.toBytesUTF8(text),
                                        StringUtils.toBytesUTF8(EXTRA_AAD_SOURCE),
                                        false);
String jweJsonOut = p.encryptWith(jweProviders, perRecipientHeades);

JweJsonConsumer consumer = new JweJsonConsumer(jweJsonOut);
KeyAlgorithm keyAlgo = consumer.getSharedUnprotectedHeader().getKeyEncryptionAlgorithm();
ContentAlgorithm ctAlgo = consumer.getProtectedHeader().getContentEncryptionAlgorithm();

// first recipient:
JweDecryptionProvider jwe1 = JweUtils.createJweDecryptionProvider(wrapperKey1, keyAlgo, ctAlgo);

// the consumer will iterate over JWE entries and will try to find the one which can be decrypted with this decryptor
// or do consumer.getRecipientsMap() returning a list of entries and their metadata to do a more precise selection.

String content = consumer.decryptWith(jwe1, Collections.singletonMap("kid", "key1")).getContent();

// second recipient:
JweDecryptionProvider jwe2 = JweUtils.createJweDecryptionProvider(wrapperKey2, keyAlgo, ctAlgo);
content = consumer.decryptWith(jwe2, Collections.singletonMap("kid", "key2")).getContent();
</pre>
</div></div><p>如果序列仅包含一个收件人条目，则JWE JSON“收件人”数组将包含一个条目，或者可以将整个序列放<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7516#appendix-A.5" rel="nofollow">平，</a>而无需放置实际的“收件人”数组。默认情况下，仅执行一次加密时，JweJsonProducer不会生成平坦化的序列，因为第三方JWE JSON使用者可能只能够使用“收件人”数组处理序列，因此如果需要，可以向JwEJsonProducer传递“ canBeFlat”标志</p><p>如果您不打算进行多次加密，那么使用JWE JSON是否有意义？如果仅针对单个收件人，则很可能您会更喜欢JWE Compact。</p><h2 id="JAX-RSJOSE-JSONWebToken">JSON Web令牌</h2><p><a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7519" rel="nofollow">JWT</a> （JSON Web令牌）是JSON格式的声明的集合。它只是一个普通的JSON文档，其中每个顶级elevel属性都称为“ claim”。</p><p>可以像其他任何数据结构一样，对JWT进行JWS签名和/或JWE加密。</p><p>JWT主要用于OAuth2和OIDC应用程序中，以表示独立的OAuth2访问令牌，OIDC IdToken，UserInfo，但也可以在其他上下文中使用。例如，请参阅以下有关将JWT身份验证令牌链接到JWS或JWE安全的有效负载的部分。</p><p>CXF在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwt" rel="nofollow">此软件包中</a>提供了JWT支持。通常，将创建一组声明并将其提交给JWS / JWE JWT处理器，例如，请参见上面的JWS部分。</p><h2 id="JAX-RSJOSE-JWSandJWECombined">JWS和JWE合并</h2><p>如果您需要对数据进行签名，然后对签名的有效载荷进行加密，则可以通过选择所需的JWS Producer并创建JWS Compact序列，然后将该序列提交给JWE producer并在反向顺序。</p><h1 id="JAX-RSJOSE-JOSEJAX-RSFilters">JOSE JAX-RS过滤器</h1><p><br clear="none"></p><p>虽然在应用程序代码中可能需要直接与JWS和JWE提供程序一起工作，但是JAX-RS用户编写如下代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>典型的JAX-RS代码</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/bookstore")
public class BookStore {
    
    public BookStore() {
    }
    
    @POST
    @Path("/books")
    @Produces("text/plain")
    @Consumes("text/plain")
    public String echoText(String text) {
        return text;
    }
    
    @POST
    @Path("/books")
    @Produces("application/json")
    @Consumes("application/json")
    public Book echoBook(Book book) {
        return book;
    }
}</pre>
</div></div><p>会期望在调用资源方法之前或在此方法返回一些响应之后完成JWS和/或JWE处理。</p><p>这就是CXF JOSE JAX-RS过滤器的作用，它们帮助客户端或服务器代码获取JWS或JWE保护的应用程序数据。过滤器通过按以下“配置”部分所述加载配置属性来执行此操作，并生成或使用JWS或JWE序列。</p><p>注意，JWS Compact和JSON以及JWE Compact客户端和服务器输出过滤器可以在<strong>对流</strong>进行签名或加密有效负载时尽最大的努力来保持<strong>流式</strong>处理的进行。JWE JSON客户端/服务器输出过滤器和JWS Compact客户端/服务器输入过滤器将在适当时候得到增强，以支持流。大多数CXF JOSE系统测试都使具有流功能的过滤器能够流式传输。</p><p>JWS和JWE JSON输入过滤器应处理具有随机顺序设置的属性的JSON容器，因此默认情况下，它们将不流送数据。</p><p>如果需要对数据进行签名和加密（对过滤器进行排序，以便首先对数据进行签名和下一步加密），则注册JWS和JWE出过滤器；如果需要先对签名的数据进行解密然后进行验证，则在过滤器中注册JWS和JWE 。</p><h2 id="JAX-RSJOSE-JWS">JWS</h2><h3 id="JAX-RSJOSE-JWSCompact.1">JWS紧凑版</h3><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwsWriterInterceptor.java" rel="nofollow">JwsWriterInterceptor</a>在客户机或服务器输出指令上创建紧凑的JWS序列。例如，如果让客户代码发布一本Book，或者让服务器代码返回一本Book，并且该Book表示形式应该被签名，则添加<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwsWriterInterceptor.java" rel="nofollow">JwsWriterInterceptor</a>并在JAX-RS客户端或服务器上设置签名属性。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwsClientResponseFilter.java" rel="nofollow">JwsClientResponseFilter</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwsContainerRequestFilter.java" rel="nofollow">JwsContainerRequestFilter</a>处理传入的客户端或服务器Compact JWS序列。</p><p>这是一个HS256签名并转换为Compact JWS并过帐到目标服务的JSON Book表示形式的示例：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>Address: https://localhost:9001/jwsjwkhmac/bookstore/books
Http-Method: POST
Content-Type: application/jose
Payload: 
eyJhbGciOiJIUzI1NiIsImN0eSI6Impzb24ifQ.
eyJCb29rIjp7ImlkIjoxMjMsIm5hbWUiOiJib29rIn19.
hg1T41ESuX6JvRR--huTA3HnbrsdIZSwkxQdyWj9j6c

org.apache.cxf.rs.security.jose.common.JoseUtils traceHeaders
INFO: JWS Headers: 
{"alg":"HS256",
 "cty":"json"}</pre>
</div></div><p><br clear="none"></p><p>您可以看到3个JWS部件（为了更好的可读性而放在单独的行上）由点分隔。第一部分是Base64Url编码的受保护标头，下一部分是Base64Url编码的Book JSON有效负载，最后是签名。</p><p>请注意，可以通过启用“ jose.debug”上下文属性来跟踪受保护的标头：曾经可以看到签名算法为“ HS256”，签名有效负载的内容类型为“ json”，这是内容类型“ application / json”，其中省略了“ application”。</p><p>以下客户端代码可用于设置客户端JWS Compact拦截器：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>客户端JWS设置</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">    public void testJwsJwkBookHMac() throws Exception {
        String address = "https://localhost:" + PORT + "/jwsjwkhmac";
        BookStore bs = createJwsBookStore(address);
        Book book = bs.echoBook(new Book("book", 123L));
        assertEquals("book", book.getName());
        assertEquals(123L, book.getId());
    }
    private BookStore createJwsBookStore(String address, 
                                         List&lt;?&gt; mbProviders) throws Exception {
        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();
        bean.setServiceClass(BookStore.class);
        bean.setAddress(address);
        List&lt;Object&gt; providers = new LinkedList&lt;Object&gt;();
        // JWS Compact Out
       &#160;JwsWriterInterceptor jwsWriter = new JwsWriterInterceptor();
        // enable streaming 
       &#160;jwsWriter.setUseJwsOutputStream(true);
        // The payload is encoded by default, disable it if required
        // jwsWriter.setEncodePayload(false);
       &#160;providers.add(jwsWriter);
        // JWS Compact In
       &#160;providers.add(new JwsClientResponseFilter());
        // Book to/from JSON
        providers.add(new JacksonJsonProvider());
        bean.setProviders(providers);
        // point to the JWS security properties
        bean.getProperties(true).put("rs.security.signature.properties", 
            "org/apache/cxf/systest/jaxrs/security/secret.jwk.properties");
        // enable the tracing of JWS headers
        bean.getProperties(true).put("jose.debug", true);
        
        return bean.create(BookStore.class);
    }</pre>
</div></div><p>上面的代码显示了客户端代理代码，但是可以创建WebClient。在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L197" rel="nofollow">这里</a>配置服务器。客户端也可以在Spring / Blueprint中配置。</p><h3 id="JAX-RSJOSE-JWSCompactWithUnencodedPayload">具有未编码净荷的JWS Compact</h3><p>从CXF 3.1.7开始，还可以使用未编码的有效负载来生成JWS Compact序列（有关限制，请参见上面的JWS带有未编码的有效负载）。</p><p>这是一个带有HS256签名的纯文本“ book”的示例，将其转换为JWS Compact并发布到目标服务：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>Address: https://localhost:9001/jwsjwkhmac/bookstore/books
Http-Method: POST
Content-Type: application/jose
Payload: eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4iLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ.
         book.
         fM7O2IVO3NsQeTGrFiMeLf_TKTsMSqnqmjnK40PwQ88</pre>
</div></div><p>请注意，第二部分“ book”未进行Base64Url编码。将请求或响应JWS Compact过滤器上的“ encodePayload”选项设置为“ false”。</p><h3 id="JAX-RSJOSE-JWSJSON.1">JWS JSON</h3><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwsJsonWriterInterceptor.java" rel="nofollow">JwsJsonWriterInterceptor</a>在客户端或服务器输出指令上创建JWS JSON序列。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwsJsonClientResponseFilter.java" rel="nofollow">JwsJsonClientResponseFilter</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwsJsonContainerRequestFilter.java" rel="nofollow">JwsJsonContainerRequestFilter</a>处理传入的客户端或服务器Compact JWS序列。</p><p>这是一个示例示例，该示例具有HS256签名的纯文本“ book”，转换为JWS JSON并发布到目标服务：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>Http-Method: POST
Content-Type: application/jose+json
Payload: 
{
  "payload" : "Ym9vaw",
  "signatures":
   [
     {
       "protected" : "eyJhbGciOiJIUzI1NiIsImN0eSI6Impzb24ifQ",
       "signature" : "dRUibW7F6LyXuOc78DHubUIave0QUSvte5iv6xoJaL4"
     }
   ]
}</pre>
</div></div><p>请注意，首先进行Base64Url编码的有效负载，然后是“签名”数组，每个元素都包含受保护的标头和特定于给定签名密钥的实际签名。</p><h3 id="JAX-RSJOSE-JWSJSONwithUnencodedPayload">具有未编码净荷的JWS JSON</h3><p>启用未编码的JWS有效负载选项将产生：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>{
 "payload" : "book",  
 "signatures": 
   [
      {
       "protected" : "eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4iLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ",
       "signature" : "fM7O2IVO3NsQeTGrFiMeLf_TKTsMSqnqmjnK40PwQ88"
      }
   ]
}</pre>
</div></div><p>客户端代码和服务器配置几乎与设置JWS Compact过滤器所需的代码/配置相同，如上所述，只需在客户端代码中将JwsWriterInterceptor / JwsClientResponseFilter替换为JwsJsonWriterInterceptor / JwsJsonClientResponseFilter，并将JwsContainerRequestFilter / JwsContainerResponseFilter用JwsJsonJsonJsonJsonJFilter</p><h2 id="JAX-RSJOSE-SigningandVerificationofHTTPAttachments">HTTP附件的签名和验证</h2><p>从CXF 3.1.12开始，支持HTTP请求和响应附件的签名和验证。</p><p>此功能不缓冲请求和响应附件数据，完全“友好”流式传输。</p><p>请注意，在某些情况下，数据可能需要在接收器端进行缓冲。</p><p>它取决于<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7515#appendix-F" rel="nofollow">具有分离内容的</a> <a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7797" rel="nofollow">JWS和具有未编码有效负载</a>选项的<a shape="rect" class="external-link" href="https://tools.ietf.org/html/rfc7797" rel="nofollow">JWS，</a>以及新引入的CXF <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-multiparts.html#JAX-RSMultiparts-MultipartFilters">多部分过滤器</a> ，其工作方式如下。</p><p>当请求或响应附件部分将要提交给Multipart序列化提供程序时，JWS Multipart输出过滤器（ <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/multipart/JwsMultipartClientRequestFilter.java" rel="nofollow">JwsMultipartClientRequestFilter</a>和/或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/multipart/JwsMultipartContainerResponseFilter.java" rel="nofollow">JwsMultipartContainerResponseFilter</a> ）将初始化<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsSignature.java" rel="nofollow">JWSSignature</a>对象。接下来，将每个部件的输出流替换为过滤输出流，该过滤输出流在每次写操作时都会更新签名对象。最后，此多部分过滤器将一个附加的附件部分添加到要编写的附件列表中-该部分包含对JWS签名的引用。在写完最后一部分时，JWSSignature生成签名字节，这些签名字节使用JWS Compact或JWS JSON格式进行编码，分离和未编码的内容已经被推送到输出流。</p><p>当多部分反序列化提供者将要读取附件部分时，将需要验证在最后一部分中继承的附件签名。在即将读取这些部分以使其对应用程序代码可用之前，JWS Multipart输入过滤器（ <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/multipart/JwsMultipartContainerRequestFilter.java" rel="nofollow">JwsMultipartContainerRequestFilter</a>和/或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/multipart/JwsMultipartClientResponseFilter.java" rel="nofollow">JwsMultipartClientResponseFilter</a> ）检查最后一部分并初始化<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsVerificationSignature.java" rel="nofollow">JWSVerificationSignature</a>对象。接下来的每个附件（最后一个附件除外）将其替换为过滤输入流，从而在每次读取操作时更新签名验证对象。读取完所有数据后，它将计算出的签名与接收到的签名进行比较。</p><p>请注意，当接收的应用程序代码访问附件时，如果验证失败，则读取过程将无法完成。例如，如果应用程序代码将给定部件的InputStream复制到磁盘，则此复制操作将失败。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@POST
@Path("/books")
@Consumes("multipart/related")
public void uploadBookMultipart(@Multipart(type = "application/xml") Book book) {
        // This method will not be even invoked if the data signature verification fails 
        // causing the construction of Book bean to fail
}


@POST
@Path("/pdf")
@Consumes("multipart/related")
public void uploadStreamMultipart(@Multipart(type = "application/pdf") InputStream is) {
        OutputStream os = getTargetOutputStream();
        // This copy operation will fail
        IOUtils.copy(is, os); 
}

</pre>
</div></div><p><br clear="none"></p><p>请注意，除了签名验证过程之外，CXF还提供了其他一些间接支持，以确保附件数据不受影响。例如， <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-multiparts.html#JAX-RSMultiparts-Readinglargeattachments">可以限制附件的大小</a> ，并且如果从XML转换数据流，则转换过程将由安全XML解析器控制。</p><p>但是，例如，如果接收方立即开始对附件的InputStream进行操作，则将从服务返回到客户端的附件数据流式传输到可以激活脚本的UI显示器，则重要的是要启用“ <strong>bufferPayload</strong> ”属性<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/multipart/JwsMultipartContainerRequestFilter.java" rel="nofollow">JwsMultipartContainerRequestFilter</a>或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/multipart/JwsMultipartClientResponseFilter.java" rel="nofollow">JwsMultipartClientResponseFilter</a> 。它将确保在应用程序访问数据流之前先对数据流进行验证。</p><p>如果多部分有效载荷包含许多附件部分，则可能还需要启用' <strong>bufferPayload</strong> '属性。在这种情况下，如果编写接收代码来消耗所有部分的顺序与部分在多部分有效负载中的排序顺序不同，或者如果接收方代码可以选择跳过某些部分，则“ <strong>bufferPayload</strong> ”属性必须启用。</p><p>这是一个示例，显示了如何保护Book对象（在网络上表示为XML附件）。</p><p>给定此客户端代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Test
public void testJwsJwkBookHMacMultipart() throws Exception {
    String address = "https://localhost:" + PORT + "/jwsjwkhmacSinglePart";
    BookStore bs = createJwsBookStoreHMac(address, true, false);
    Book book = bs.echoBookMultipart(new Book("book", 123L));
    assertEquals("book", book.getName());
    assertEquals(123L, book.getId());
}
private BookStore createJwsBookStoreHMac(String address, 
                                         boolean supportSinglePart,
                                         boolean useJwsJsonSignatureFormat) throws Exception {
     JAXRSClientFactoryBean bean = createJAXRSClientFactoryBean(address, supportSinglePart, 
                                                                   useJwsJsonSignatureFormat);
     bean.getProperties(true).put("rs.security.signature.properties",
         "org/apache/cxf/systest/jaxrs/security/secret.jwk.properties");

     bean.setServiceClass(BookStore.class);
     bean.setAddress(address);
     List&lt;Object&gt; providers = new LinkedList&lt;Object&gt;();
     JwsMultipartClientRequestFilter outFilter = new JwsMultipartClientRequestFilter();
     outFilter.setSupportSinglePartOnly(supportSinglePart);
     outFilter.setUseJwsJsonSignatureFormat(useJwsJsonSignatureFormat);
     providers.add(outFilter);
     JwsMultipartClientResponseFilter inFilter = new JwsMultipartClientResponseFilter();
     inFilter.setSupportSinglePartOnly(supportSinglePart);
     providers.add(inFilter);
     providers.add(new JwsDetachedSignatureProvider());
     bean.setProviders(providers);
     return bean.create(BookStore.class);
}</pre>
</div></div><p>以及相关的服务器代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/bookstore")
public class BookStore {
    
    @POST
    @Path("/books")
    @Produces("multipart/related")
    @Consumes("multipart/related")
    @Multipart(type = "application/xml")
    public Book echoBookMultipart(@Multipart(type = "application/xml") Book book) {
        // This method will not be even invoked if the data signature verification fails 
       &#160;return book;
    }
}</pre>
</div></div><p>和服务器配置：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:jaxrs="http://cxf.apache.org/jaxrs"&gt;
    &lt;bean id="serviceBean" class="org.apache.cxf.systest.jaxrs.security.jose.BookStore"/&gt;
    &lt;bean id="jwsInMultipartFilter" class="org.apache.cxf.rs.security.jose.jaxrs.multipart.JwsMultipartContainerRequestFilter"/&gt;
    &lt;bean id="jwsOutMultipartFilter" class="org.apache.cxf.rs.security.jose.jaxrs.multipart.JwsMultipartContainerResponseFilter"/&gt;
    &lt;bean id="jwsDetachedSignatureWriter" class="org.apache.cxf.rs.security.jose.jaxrs.JwsDetachedSignatureProvider"/&gt;
    &lt;jaxrs:server address="https://localhost:${testutil.ports.jaxrs-jws-multipart}/jwsjwkhmacSinglePart"&gt;
        &lt;jaxrs:serviceBeans&gt;
            &lt;ref bean="serviceBean"/&gt;
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:providers&gt;
            &lt;ref bean="jwsInMultipartFilter"/&gt;
            &lt;ref bean="jwsOutMultipartFilter"/&gt;
            &lt;ref bean="jwsDetachedSignatureWriter"/&gt;
        &lt;/jaxrs:providers&gt;
        &lt;jaxrs:properties&gt;
            &lt;entry key="rs.security.signature.properties" value="org/apache/cxf/systest/jaxrs/security/secret.jwk.properties"/&gt;
        &lt;/jaxrs:properties&gt;
    &lt;/jaxrs:server&gt;
&lt;/beans</pre>
</div></div><p>电线上产生以下请求：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>ID: 1
Address: https://localhost:9001/jwsjwkhmacSinglePart/bookstore/books
Http-Method: POST
Content-Type: multipart/related; type="application/xml"; boundary="uuid:35b4dd32-470d-4f27-b3c2-2c194f924770"; start="&lt;root.message@cxf.apache.org&gt;"
Headers: {Accept=[multipart/related], Connection=[Keep-Alive]}
Payload: 
--uuid:35b4dd32-470d-4f27-b3c2-2c194f924770
Content-Type: application/xml
Content-Transfer-Encoding: binary
Content-ID: &lt;root.message@cxf.apache.org&gt;

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;Book&gt;&lt;id&gt;123&lt;/id&gt;&lt;name&gt;book&lt;/name&gt;&lt;/Book&gt;
--uuid:35b4dd32-470d-4f27-b3c2-2c194f924770
Content-Type: application/jose
Content-Transfer-Encoding: binary
Content-ID: &lt;signature&gt;

eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJIUzI1NiJ9..LWMjPoronjdGmJFAAIuCc_qh9sI2i5Jc2onBd-fHdMM
--uuid:35b4dd32-470d-4f27-b3c2-2c194f924770--</pre>
</div></div><p>响应的格式相同。</p><p>启用JWS JSON格式将在最后一部分中生成平坦的JWS JSON签名：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>ID: 1
Address: https://localhost:9001/jwsjwkhmacSinglePartJwsJson/bookstore/books
Http-Method: POST
Content-Type: multipart/related; type="application/xml"; boundary="uuid:75b37fab-1745-45b7-93ac-15aa9add9b25"; start="&lt;root.message@cxf.apache.org&gt;"
Headers: {Accept=[multipart/related], Connection=[Keep-Alive]}
Payload: 
--uuid:75b37fab-1745-45b7-93ac-15aa9add9b25
Content-Type: application/xml
Content-Transfer-Encoding: binary
Content-ID: &lt;root.message@cxf.apache.org&gt;

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;Book&gt;&lt;id&gt;123&lt;/id&gt;&lt;name&gt;book&lt;/name&gt;&lt;/Book&gt;
--uuid:75b37fab-1745-45b7-93ac-15aa9add9b25
Content-Type: application/jose
Content-Transfer-Encoding: binary
Content-ID: &lt;signature&gt;

{"protected":"eyJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdLCJhbGciOiJIUzI1NiJ9","signature":"LWMjPoronjdGmJFAAIuCc_qh9sI2i5Jc2onBd-fHdMM"}
--uuid:75b37fab-1745-45b7-93ac-15aa9add9b25--</pre>
</div></div><h2 id="JAX-RSJOSE-JWE">杰威</h2><h3 id="JAX-RSJOSE-JWECompact.1">JWE紧凑型</h3><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JweWriterInterceptor.java" rel="nofollow">JweWriterInterceptor</a>在客户端或服务器输出指令上创建紧凑JWE序列。例如，如果让客户代码发布一本书，或者让服务器代码返回一本书，并且该Book表示形式应该被加密，则添加<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JweWriterInterceptor.java" rel="nofollow">JweWriterInterceptor</a>并在JAX-RS客户端或服务器上设置加密属性。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JweClientResponseFilter.java" rel="nofollow">JweClientResponseFilter</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JweContainerRequestFilter.java" rel="nofollow">JweContainerRequestFilter</a>处理传入的客户端或服务器Compact JWE序列。</p><p>这是使用A128KW密钥和A128GCM内容加密（请参见上面的JWE部分）加密的纯文本“ book”的示例，将其转换为Compact JWE并发布到目标服务：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>Address: https://localhost:9001/jwejwkaeswrap/bookstore/books
Http-Method: POST
Content-Type: application/jose
Payload: 
eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4R0NNIiwiY3R5IjoidGV4dC9wbGFpbiJ9.
SQul1USvHmADDLpBvY2Dnqk5GpoowOkJ.
cFuCSzRsl6GZuvHL.
akVT5g.
i8rpTk-v0b1IyE1sVT1IOA

org.apache.cxf.rs.security.jose.common.JoseUtils traceHeaders
INFO: JWE Headers: 
{"alg":"A128KW",
 "enc":"A128GCM",
 "cty":"text/plain"}</pre>
</div></div><p>您可以看到由点分隔的5个JWE部分（为了更好的可读性而放在单独的行上）。第一部分是Base64Url编码的受保护标头，下一个是-Base64Url编码的内容加密密钥，下一个是-Base64Url编码的IV，下一个是-Base64Url编码的密文，最后是身份验证标签。</p><p>请注意，可以通过启用“ jose.debug”上下文属性来跟踪受保护的标头：一次可以看到密钥加密算法是“ A128KW”，内容加密算法是“ A128GCM”，加密有效负载的内容类型是“ text /平原”。</p><p>以下客户端代码可用于设置客户端JWE Compact拦截器：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>客户端JWE设置</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">    public void testJweJwkAesWrap() throws Exception {
        String address = "https://localhost:" + PORT + "/jwejwkaeswrap";
        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();
        bean.setServiceClass(BookStore.class);
        bean.setAddress(address);
        List&lt;Object&gt; providers = new LinkedList&lt;Object&gt;();
        JweWriterInterceptor jweWriter = new JweWriterInterceptor();
        jweWriter.setUseJweOutputStream(true);
        providers.add(jweWriter);
        providers.add(new JweClientResponseFilter());
        bean.setProviders(providers);
        bean.getProperties(true).put("rs.security.encryption.properties",
                                     "org/apache/cxf/systest/jaxrs/security/secret.jwk.properties");
        bean.getProperties(true).put("jose.debug", true);
        BookStore bs = bean.create(BookStore.class);
        String text = bs.echoText("book");
        assertEquals("book", text);
    }</pre>
</div></div><p>上面的代码显示了客户端代理代码，但是可以创建WebClient。在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L153" rel="nofollow">这里</a>配置服务器。客户端也可以在Spring / Blueprint中配置。</p><h3 id="JAX-RSJOSE-JWEJSON.1">JWE JSON</h3><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JweWriterInterceptor.java" rel="nofollow">JweJsonWriterInterceptor</a>在客户端或服务器输出指令上创建JWE JSON序列。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JweJsonClientResponseFilter.java" rel="nofollow">JweJsonClientResponseFilter</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JweContainerRequestFilter.java" rel="nofollow">JweContainerRequestFilter</a>处理传入的客户端或服务器JWE JSON序列。</p><p>这是用于加密“ book”的相同示例，但是使用JWS JSON拦截器：</p><div class="preformatted panel" style="border-width:1px"><div class="preformattedContent panelContent">
<pre>Address: https://localhost:9001/jwejsonhmac/bookstore/books
Http-Method: POST
Content-Type: application/jose+json
Payload: 
{
  "protected" : "eyJlbmMiOiJBMTI4R0NNIiwiY3R5IjoidGV4dC9wbGFpbiIsImFsZyI6IkExMjhLVyJ9",
  "recipients":
   [
     {
       "encrypted_key": "iq1vJBpOHKRkMDoY2GTakWE6M_uPGVsh"
     }
   ],
   "iv":"SUpOEf-7Q1tT0JV_",
   "ciphertext":"alKm_g",
   "tag":"DkW2pZCd7lhR0KqIGQ69-A"
}</pre>
</div></div><p>请注意，首先是受Base64Url编码的受保护标头，其后是“收件人”数组，每个元素都包含可以由收件人私钥解密的加密内容加密密钥，收件人数组后面是IV，密文和身份验证标签Base64Url序列。</p><h2 id="JAX-RSJOSE-LinkingJWTauthenticationstoJWSorJWEcontent">将JWT身份验证链接到JWS或JWE内容</h2><p>CXF引入了“ JWT” HTTP身份验证方案，其中Base64Url编码的JWT令牌表示针对能够发布JWT断言（或简称为JWT令牌）的IDP的用户身份验证。JWT断言类似于SAML断言，但它采用JSON格式。如果您想加密绑定此JWT令牌通过JWS保护数据和/或JWE处理器则只需添加<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwtAuthenticationClientFilter.java" rel="nofollow">JwtAuthenticationClientFilter</a>在客户端和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose-jaxrs/src/main/java/org/apache/cxf/rs/security/jose/jaxrs/JwtAuthenticationFilter.java" rel="nofollow">JwtAuthenticationFilter</a>在服务器端。这些过滤器将认证令牌与随机生成的安全值链接，该安全值被添加到令牌和主体JWS / JWE受保护的标头中。</p><p>与将主体哈希提交给签名创建函数之前将其作为HTTP标头添加到签名之前计算主体哈希的方法相比，该方法更为有效。</p><h2 id="JAX-RSJOSE-JWTauthorization">JWT授权</h2><p>CXF支持基于接收到的JWT中包含的信息的JAX-RS端点的基于角色和声明的授权。请参阅<a shape="rect" href="jax-rs-token-authorization.html">JAX-RS令牌授权</a>页面以获取更多信息。</p><h2 id="JAX-RSJOSE-OptionalprotectionofHTTPheaders">HTTP标头的可选保护</h2><p>从CXF 3.1.12开始，可以使用JWS，JWS JSON，JWE和JWE JSON过滤器来保护所选的HTTP标头集。这些过滤器产生的JOSE有效载荷确保JOSE标头受到完整性保护。鉴于此，如果启用了请求过滤器上的'protectHttpHeaders'布尔属性，则默认情况下，HTTP Content-Type和Accept标头值将被注册为JOSE标头属性，前缀为“ http。”，例如“ http”。接受”：“文本/纯文本”。可以使用“ protectedHttpHeaders” set属性来自定义要保护的标头列表。</p><p>这些属性将与接收端当前的HTTP标头进行比较。</p><p>这种方法不会阻止传出数据的流传输（也将受到过滤器的保护），并提供了一种保护HTTP标头的方法，这对于正确处理传入的有效负载非常重要</p><h1 id="JAX-RSJOSE-JOSEinJAX-RSapplicationcode">JOSE在JAX-RS中的应用代码</h1><p>在某些情况下，您可能需要直接在服务或客户端应用程序代码中创建或处理JOSE数据。例如，请求或响应有效负载中的属性之一需要进行JWS签名/验证和/或JWE加密/解密。可以尝试以下2个选项。</p><h2 id="JAX-RSJOSE-Option1:ProcessJOSEdirectly">选项1：直接处理JOSE</h2><p>此选项是关于使用CXF JOSE库对<a shape="rect" href="jax-rs-jose.html">如上所述</a>的数据进行签名，加密或/和解密以及验证数据。如果需要保持更紧密的控制，例如设置自定义JWS或JWE标头等，则应首选此选项。</p><h2 id="JAX-RSJOSE-Option2:UseJOSElibraryhelpersandEndpointConfiguration">选项2：使用JOSE库帮助程序和端点配置</h2><p>此选项使直接在应用程序代码中执行JOSE成为可能。必须扩展或委托给特定的JOSE帮助程序实例，并使用设置JWS或JWE算法和密钥存储属性的JOSE属性文件的位置配置端点。</p><h3 id="JAX-RSJOSE-ProduceJOSEdata">产生JOSE资料</h3><p>如果您需要保护某些非JWT属性-扩展或委托给<strong>JoseProducer</strong> ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.jose.common.JoseProducer;
@Path("service")
public class SecureService extends JoseProducer {
    @GET
    public String getProtectedValue() {
        // encrypt and/or sign the data
        return super.processData("some data");
    }
}

// or

@Path("service")
public class SecureService extends AbstractSecureService {
    
    private JoseProducer producer = new JoseProducer();
    @GET
    public String getProtectedValue() {
        // encrypt and/or sign the data
        return producer.processData("some data");
    }
}</pre>
</div></div><p>如果需要保护某些JWT属性，请扩展或委托给<strong>JoseJwtProducer</strong> ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.jose.jwt.JoseJwtProducer;
@Path("service")
public class SecureService extends JoseJwtProducer {
    @GET
    public String getProtectedToken() {
        // encrypt and/or sign JWT
        JwtClaims claims = new JwtClaims();
        claims.setIssuer("some issuer");
        // set other claims
        return super.processJwt(new JwtToken(claims));
    }
}

// or

@Path("service")
public class SecureService extends AbstractSecureService {
    
    private JoseJwtProducer producer = new JoseJwtProducer();
    @GET
    public String getProtectedValue() {
        // encrypt and/or sign JWT
        return producer.processJwt(new JwtToken(new JwtClaims()));
    }
}</pre>
</div></div><p>在这两种情况下，生产者帮助程序都将检测到特定于端点的配置，因此不需要预先配置-但是，如果需要，它们具有可用于注入JwsSignatureProvider和/或JweEncryptionProvider实例的'encryptionProvider'和'signatureProvider'设置程序。</p><p>生产者助手仅在默认情况下才需要创建签名。使用其'setJwsRequired'或'setJwsRequired'属性对其进行自定义-例如，禁用JWS但需要JWE，或启用JWE来也对受JWS保护的数据进行加密。</p><h3 id="JAX-RSJOSE-ConsumeJOSEdata">消耗JOSE数据</h3><p>如果您需要解密和/或验证某些非JWT JOSE属性-扩展或委托给<strong>JoseConsumer</strong> ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.jose.common.JoseConsumer;
@Path("service")
public class SecureService extends JoseConsumer {
    @POST
    public void acceptProtectedValue(String joseValue) {
        // decrypt the value first if needed, verify the signature
        String data = super.getData(joseValue);
    }
}

// or

@Path("service")
public class SecureService extends AbstractSecureService {
    
    private JoseConsumer consumer = new JoseConsumer();
    @POST
    public void acceptProtectedValue(String joseValue) {
        // decrypt the value first if needed, verify the signature
        String data = consumer.getData(joseValue);
    }
}</pre>
</div></div><p>如果您需要解密和/或验证某些JWT属性，则可以扩展或委托给<strong>JoseJwtConsumer</strong> ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.jose.jwt.JoseJwtConsumer;
@Path("service")
public class SecureService extends JoseJwtConsumer {
    @POST
    public void acceptProtectedToken(String joseValue) {
        // decrypt the value first if needed, verify the signature
        JwtToken data = super.getJwtToken(joseValue);
    }
}

// or

@Path("service")
public class SecureService extends AbstractSecureService {
    
    private JoseJwtConsumer consumer = new JoseJwtConsumer();
    @POST
    public void acceptProtectedToken(String joseValue) {
        // decrypt the value first if needed, verify the signature
        JwtToken data = consumer.getJwtToken(joseValue);
    }
}</pre>
</div></div><p>在这两种情况下，生产者帮助程序都将检测到特定于端点的配置，因此不需要预先配置-但是，如果需要，它们具有“ jweDecryptor”和“ jwsVerifier”设置程序，可用于注入JwsSignatureVerifier和/或JweDecryptionProvider实例。</p><p>生产者助手仅在默认情况下才需要创建签名。使用其'setJwsRequired'或'setJwsRequired'属性对其进行自定义-例如，禁用JWS但需要JWE，或启用JWE来也对受JWS保护的数据进行加密。</p><h3 id="JAX-RSJOSE-ProduceandConsumeJOSEdata">产生和消费JOSE数据</h3><p>如果您需要生产和消费一些非JWT JOSE属性-扩展或委托给<strong>JoseProducerConsumer</strong> ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.jose.common.JoseProducerConsumer;
@Path("service")
public class SecureService extends JoseProducerConsumer {
    @POST
    public String echoProtectedValue(String joseValue) {
        // decrypt the value first if needed, verify the signature
        String data = super.getData(joseValue);
        // sign and/or encrypt the data
        return super.processData(data); 
    }
}

// or

@Path("service")
public class SecureService extends AbstractSecureService {
    
    private JoseProducerConsumer jose = new JoseProducerConsumer();
    @POST
    public String echoProtectedValue(String joseValue) {
        // decrypt the value first if needed, verify the signature
        String data = jose.getData(joseValue);
        // sign and/or encrypt the data
        return jose.processData(data); 
    }
}</pre>
</div></div><p>如果您需要解密和/或验证某些JWT属性，请扩展或委托给<strong>JoseJwtProducerConsumer</strong> ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.cxf.rs.security.jose.jwt.JoseJwtProducerConsumer;
@Path("service")
public class SecureService extends JoseJwtProducerConsumer {
    @POST
    public String echoProtectedToken(String joseValue) {
        // decrypt the value first if needed, verify the signature
        JwtToken data = super.getJwtToken(joseValue);
        // sign and/or encrypt the data
        return super.processJwt(data);
   &#160;}
}

// or

@Path("service")
public class SecureService extends AbstractSecureService {
    
    private JoseJwtProducerConsumer jose = new JoseJwtProducerConsumer();
    @POST
    public String echoProtectedToken(String joseValue) {
        // decrypt the value first if needed, verify the signature
        JwtToken data = jose.getJwtToken(joseValue);
        // sign and/or encrypt the data
        return jose.processJwt(data);
    }
}</pre>
</div></div><p>在这两种情况下，该复合生产者-消费者将使用内部生产者和/或消费者帮助者，它们将检测特定于端点的配置，但也可以注入某些特定的JWE和/或JWS处理程序。</p><h3 id="JAX-RSJOSE-Configuretheendpoint">配置端点</h3><p>这些属性将包含密钥存储的位置，签名和/或加密算法属性等。有关所有可用的配置选项，请参阅“ <a shape="rect" href="jax-rs-jose.html">配置”部分</a> 。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:jaxrs="http://cxf.apache.org/jaxrs"&gt;
    &lt;bean id="serviceBean" class="org.apache.cxf.systest.jaxrs.security.jose.SecureService"/&gt;
    &lt;jaxrs:server address="/secure"&gt;
        &lt;jaxrs:serviceBeans&gt;
            &lt;ref bean="serviceBean"/&gt;
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:properties&gt;
            &lt;entry key="rs.security.signature.properties" value="org/apache/cxf/systest/jaxrs/security/secret.jwk.properties"/&gt;
            &lt;entry key="rs.security.encryption.properties" value="org/apache/cxf/systest/jaxrs/security/secret.jwk.properties"/&gt;
         &lt;/jaxrs:properties&gt;
    &lt;/jaxrs:server&gt;
&lt;/beans</pre>
</div></div><h1 id="JAX-RSJOSE-Configuration">组态</h1><p>CXF JOSE配置提供了加载JWS和JWE密钥并支持各种处理选项的功能。可以在JWS和JWE处理器之间共享配置属性，也可以仅输入/输出JWS和或JWE属性。</p><p>通常，使用JWS和或JWE属性初始化安全的JAX-RS端点或客户端。</p><p>例如， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L197" rel="nofollow">此端点</a>配置有<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L207" rel="nofollow">单个JWS属性文件</a> ，该<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L207" rel="nofollow">文件</a>将同时应用于输入（签名验证）和输出（签名创建）JWS操作。<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L210" rel="nofollow">该端点</a>依赖于<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L218" rel="nofollow">两个JWS属性文件</a> ，一个-用于输入JWS，另一个-用于输出JWS。同样， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L153" rel="nofollow">此端点</a>使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L162" rel="nofollow">单个JWE属性文件</a>来加密/解密数据，而<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L139" rel="nofollow">此端点</a>使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L139" rel="nofollow">两个JWE属性文件</a> 。<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L178" rel="nofollow">该端点</a>支持具有<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L189" rel="nofollow">输入/输出特定属性的</a> JWS和JSON。如果需要从受密码保护的存储（JKS，加密的JWK）中加载JWS或JWE私钥，那么还需要<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/rs-security/src/test/resources/org/apache/cxf/systest/jaxrs/security/jose/jwejws/server.xml#L194" rel="nofollow">注册</a>一个<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/common/PrivateKeyPasswordProvider.java" rel="nofollow">密码提供者</a> ，它可以在JWS或JWS之间共享，也可以是JWS专用的输入/输出。或JWE。</p><p>当JAX-RS JOSE过滤器在不了解应用程序服务代码的情况下处理输入/输出有效负载时，这些配置属性将提供主要帮助。虽然可以直接向JWS或JWE提供程序注入过滤器，但通常会将相关属性设置为端点或客户端设置的一部分，并期望过滤器根据需要加载所需的JWS或JWE提供程序。</p><p>如果您需要直接在服务或拦截器代码中进行JWS或JWE处理，那么拥有这些属性也可能会有所帮助，例如，以下代码可以工作，因为这些属性间接支持它，指示使用哪种签名或加密算法，其中获取密钥（如果需要），等等：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>加载JWS和JWE提供程序</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JwsSignatureProvider jwsOut = JwsUtils.loadSignatureProvider(true);
JwsSignatureVerifier jwsIn = JwsUtils.loadSignatureVerifier(true);

JweEncryptionProvider jweOut = JweUtils.loadEncryptionProvider(true);
JweDecryptionProvider jweIn = JweUtils.loadDecryptionProvider(true);</pre>
</div></div><p>提供程序可以从单个属性文件初始化，也可以为每个属性文件分配特定的属性。</p><p>有时，仅加载属性并检查签名或加密算法并直接加载JWS或JWE提供程序是很有用的，如上面的JWS和JWE部分所示。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>加载JWS和JWE属性</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Properties jwsProps = JweUtils.loadEncryptionProperties("jws.properties", true);
Properties jweProps = JweUtils.loadEncryptionProperties("jwe.properties", true);</pre>
</div></div><p>加载属性后，可以检查各种属性值（签名算法等）并使用它创建所需的提供程序。</p><p>上面的代码需要在当前请求的上下文中执行（在服务器或客户端输入/输出拦截器或服务器服务代码中），因为它期望当前的CXF消息可用，以便推断从何处加载配置属性。但是， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsUtils.java" rel="nofollow">JwsUtils</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwe/JweUtils.java" rel="nofollow">JweUtils</a>提供了许多实用程序方法，用于在不首先加载属性的情况下加载提供程序，这些方法可以在设置客户端代码或当前请求上下文中没有可用属性时使用。</p><p>当代码需要加载配置属性时，它首先查找属性“容器”文件，其中包含指示需要使用哪些键和算法的特定属性。可以提供输入/输出操作的特征或加密属性。</p><h2 id="JAX-RSJOSE-ConfigurationPropertyContainers">配置属性容器</h2><h3 id="JAX-RSJOSE-Signature">签名</h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.out.properties</td><td colspan="1" rowspan="1" class="confluenceTd"><p>用于创建Compact或JSON签名的签名属性文件。如果未指定，则回退到“ rs.security.signature.properties”。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.in.properties</td><td colspan="1" rowspan="1" class="confluenceTd"><p>用于Compact或JSON签名验证的签名属性文件。如果未指定，则回退到“ rs.security.signature.properties”。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.properties</td><td colspan="1" rowspan="1" class="confluenceTd">用于Compact或JSON签名创建/验证的签名属性文件。</td></tr></tbody></table></div><h3 id="JAX-RSJOSE-Encryption">加密</h3><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.out.properties</td><td colspan="1" rowspan="1" class="confluenceTd"><p>用于Compact或JSON加密创建的加密属性文件。如果未指定，则回退到“ rs.security.encryption.properties”。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.in.properties</td><td colspan="1" rowspan="1" class="confluenceTd"><p>用于Compact或JSON解密的加密属性文件。如果未指定，则回退到“ rs.security.encryption.properties”。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.properties</td><td colspan="1" rowspan="1" class="confluenceTd">用于加密/解密的加密属性文件。</td></tr></tbody></table></div><p>请注意，这些属性容器可用于创建/处理JWS，JWE Compact和JSON序列。如果它是JWS JSON或JWE JSON，并且您希望创建多个签名或加密，则将该属性值作为逗号分隔的位置列表，每个位置都指向一个唯一的签名或加密操作属性文件。</p><p>加载属性后，运行时将相应地初始化JWS / JWE提供程序。以下部分列出了属性，某些属性是公用的，而某些属性对于签名/验证和加密/解密过程是唯一的。</p><p>请注意，可以覆盖某些属性，例如，可以将“ rs.security.store”设置为动态请求属性，该属性指向预加载的Java KeyStore对象。</p><h2 id="JAX-RSJOSE-Configurationthatappliestobothencryptionandsignature">适用于加密和签名的配置</h2><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.keystore</td><td colspan="1" rowspan="1" class="confluenceTd">要使用的Java KeyStore对象。如果要动态传递KeyStore对象，则使用此配置标签。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>rs.security.keystore.type</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>密钥库类型。合适的值为“ jks”或“ jwk”。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.keystore.password</td><td colspan="1" rowspan="1" class="confluenceTd">访问密钥库所需的密码。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.keystore.alias</td><td colspan="1" rowspan="1" class="confluenceTd">与要使用的密钥相对应的密钥库别名。您可以将以下内容之一附加到此标签上，以获取更具体操作的别名：<br clear="none">-jwe.out<br clear="none">-jwe.in<br clear="none">-jws.out<br clear="none">-jws.in</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.keystore.aliases</td><td colspan="1" rowspan="1" class="confluenceTd">使用JSON序列化表单时，对应于要使用的密钥的密钥库别名。您可以将以下内容之一附加到此标签上，以获取更具体操作的别名：<br clear="none">-jws.out<br clear="none">-jws.in</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.keystore.file</td><td colspan="1" rowspan="1" class="confluenceTd">密钥库文件的路径。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.key.password</td><td colspan="1" rowspan="1" class="confluenceTd">访问私钥（在密钥库中）所需的密码。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.key.password.provider</td><td colspan="1" rowspan="1" class="confluenceTd">对PrivateKeyPasswordProvider实例的引用，该实例用于检索访问密钥的密码。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.accept.public.key</td><td colspan="1" rowspan="1" class="confluenceTd"><p>是否允许使用标头中接收的JWK进行签名验证。默认值为“ false”。</p></td></tr></tbody></table></div><h2 id="JAX-RSJOSE-Configurationthatappliestosignatureonly">仅适用于签名的配置</h2><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>rs.security.signature.key.password.provider</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>对PrivateKeyPasswordProvider实例的引用，该实例用于检索密码以访问用于签名的密钥。如果未指定，则回退使用“ rs.security.key.password.provider”。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.algorithm</td><td colspan="1" rowspan="1" class="confluenceTd">要使用的签名算法。如果未指定，则默认算法为“ RS256”。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.include.public.key</td><td colspan="1" rowspan="1" class="confluenceTd">在“ jwk”标头中包含用于签名的JWK公钥。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.include.cert</td><td colspan="1" rowspan="1" class="confluenceTd">在“ x5c”标头中包括X.509证书以用于签名。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.include.key.id</td><td colspan="1" rowspan="1" class="confluenceTd">在“ kid”标头中包含用于签名的JWK密钥ID。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.include.cert.sha1</td><td colspan="1" rowspan="1" class="confluenceTd">在“ x5t”标头中包括X.509证书SHA-1摘要以进行签名。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.signature.include.cert.sha256</td><td colspan="1" rowspan="1" class="confluenceTd">在“ x5t＃S256”标头中包括X.509证书SHA-256摘要以进行签名。</td></tr></tbody></table></div><h2 id="JAX-RSJOSE-Configurationthatappliestoencryptiononly">仅适用于加密的配置</h2><div class="table-wrap"><table class="confluenceTable"><colgroup span="1"><col span="1"><col span="1"></colgroup><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>rs.security.decryption.key.password.provider</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>对PrivateKeyPasswordProvider实例的引用，该实例用于检索密码以访问用于解密的密钥。如果未指定，则回退使用“ rs.security.key.password.provider”。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.content.algorithm</td><td colspan="1" rowspan="1" class="confluenceTd">要使用的加密内容算法。如果未指定，则默认算法为“ A128GCM”。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.key.algorithm</td><td colspan="1" rowspan="1" class="confluenceTd"><p>要使用的加密密钥算法。如果未指定，则默认算法为“ RSA-OAEP”（如果密钥是RSA密钥），“ ECDH-ES-A128KW”（如果密钥是EC密钥）和“ A128GCMKW”（如果是八位字节序列）。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.zip。算法</td><td colspan="1" rowspan="1" class="confluenceTd">要使用的加密zip算法。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.include.public.key</td><td colspan="1" rowspan="1" class="confluenceTd">在“ jwk”标头中包含用于加密的JWK公钥。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.include.cert</td><td colspan="1" rowspan="1" class="confluenceTd">在“ x5c”标头中包含用于加密的X.509证书。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.include.key.id</td><td colspan="1" rowspan="1" class="confluenceTd">在“ kid”标头中包含用于加密的JWK密钥ID。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.include.cert.sha1</td><td colspan="1" rowspan="1" class="confluenceTd">在“ x5t”标头中包含用于加密的X.509证书SHA-1摘要。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">rs.security.encryption.include.cert.sha256</td><td colspan="1" rowspan="1" class="confluenceTd">在“ x5t＃S256”标头中包含用于加密的X.509证书SHA-256摘要。</td></tr></tbody></table></div><h2 id="JAX-RSJOSE-ConfigurationthatappliestoJWTtokensonly">仅适用于JWT令牌的配置</h2><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>rs.security.enable.unsigned-jwt.principal</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>是否允许将未签名的JWT令牌用作SecurityContext主体。默认为false。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">预期索赔听众</td><td colspan="1" rowspan="1" class="confluenceTd">如果定义了此属性，则接收到的JWT必须具有“ aud”声明，其值与该属性匹配。</td></tr></tbody></table></div><h1 id="JAX-RSJOSE-Interoperability">互通性</h1><p><a shape="rect" class="external-link" href="https://datatracker.ietf.org/wg/jose/documents/" rel="nofollow">JOSE</a>已经在OAuth2和OIDC应用程序中得到广泛支持。除此之外，CXF JOSE客户端或服务器将与能够产生或使用JWS / JWE序列的第三方客户端/服务器进行互操作。例如，请参阅<a shape="rect" class="external-link" href="https://www.w3.org/TR/WebCryptoAPI/#jose" rel="nofollow">WebCrypto API用例</a>和<a shape="rect" class="external-link" href="https://mobilepki.org/WCPPSignatureDemo/home" rel="nofollow">演示</a> ， <a shape="rect" class="external-link" href="https://mobilepki.org/WCPPSignatureDemo/home" rel="nofollow">该演示</a>演示了如何由能够处理JWS的服务器应用程序验证由浏览器托管脚本生成的JWS序列，并且演示浏览器客户端也要针对CXF JWS服务器进行测试。 。</p><h1 id="JAX-RSJOSE-Third-PartyLibraries">第三方图书馆</h1><p><a shape="rect" class="external-link" href="https://bitbucket.org/b_c/jose4j/wiki/Home" rel="nofollow">何塞4J</a></p><p><a shape="rect" class="external-link" href="http://connect2id.com/products/nimbus-jose-jwt" rel="nofollow">雨云·约瑟</a></p><p><br clear="none"></p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=41812304">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=41812304&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>