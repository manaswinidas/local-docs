<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Using Apache HTrace">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-使用Apache HTrace</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="distributed-tracing.html">分布式跟踪</a> > <a href="using-apache-htrace.html">使用Apache HTrace</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><div class="aui-message aui-message-error"><p class="title"><strong>呈现宏'html'时出错</strong></p><p>您的Confluence管理员不允许在HTML宏中使用Javascript。可以使用HTML for Confluence Configuration更改此设置。请与您的管理员联系以获取详细信息。</p></div><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1566525464347 {padding: 0px;}
div.rbtoc1566525464347 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1566525464347 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1566525464347">
<ul class="toc-indentation"><li><a shape="rect" href="#UsingApacheHTrace-Overview">总览</a></li><li><a shape="rect" href="#UsingApacheHTrace-DistributedTracinginNutshell">简而言之，分布式跟踪</a></li><li><a shape="rect" href="#UsingApacheHTrace-DistributedTracinginApacheCXFusingApacheHTrace">使用Apache HTrace的Apache CXF中的分布式跟踪</a></li><li><a shape="rect" href="#UsingApacheHTrace-ConfiguringClientconfigure.client">配置客户端</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingApacheHTrace-Configuringtracingheadernames">配置跟踪标头名称</a></li></ul>
</li><li><a shape="rect" href="#UsingApacheHTrace-ConfiguringServerconfigure.server">配置服务器</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingApacheHTrace-Configuringtracingheadernames.1">配置跟踪标头名称</a></li></ul>
</li><li><a shape="rect" href="#UsingApacheHTrace-DistributedTracingInAction:UsageScenarios">实际中的分布式跟踪：使用方案</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingApacheHTrace-Example">示例1：配置了默认分布式跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingApacheHTrace-Example">示例2：具有嵌套跟踪的客户端和服务器</a></li><li><a shape="rect" href="#UsingApacheHTrace-Example">示例＃3：带有时间轴的客户端和服务器跟踪</a></li><li><a shape="rect" href="#UsingApacheHTrace-Example">例4：带注释的跟踪（键/值）的客户端和服务器</a></li><li><a shape="rect" href="#UsingApacheHTrace-Example">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</a></li><li><a shape="rect" href="#UsingApacheHTrace-Example">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</a></li><li><a shape="rect" href="#UsingApacheHTrace-Example">示例＃7：具有异步调用的客户端和服务器（客户端）</a></li></ul>
</li><li><a shape="rect" href="#UsingApacheHTrace-DistributedTracingApacheHTraceandJAX-WSsupport">分布式跟踪Apache HTrace和JAX-WS支持</a></li><li><a shape="rect" href="#UsingApacheHTrace-PropagatingTraceDetailsToLogs">将跟踪详细信息传播到日志</a></li><li><a shape="rect" href="#UsingApacheHTrace-AccessingApacheHTraceAPIs">访问Apache HTrace API</a></li><li><a shape="rect" href="#UsingApacheHTrace-FutureWork">未来的工作</a></li></ul>
</div><div class="confluence-information-macro confluence-information-macro-warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>该<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">阿帕奇HTRACE</a>项目已经退休了<strong>2018年4月11日</strong> ，不再被开发。从<strong>3.3.0</strong>版本开始，Apache CXF退出了<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>集成。</p></div></div><h1 id="UsingApacheHTrace-Overview">总览</h1><p><a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>是一个跟踪框架，旨在与用Java编写的分布式系统一起使用。从<strong>3.1.3</strong>版开始，Apache CXF在客户端和服务器端完全支持与<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>集成。本节完整概述了在Apache CXF之上构建的JAX-RS应用程序中如何支持分布式跟踪支持。</p><h1 id="UsingApacheHTrace-DistributedTracinginNutshell">简而言之，分布式跟踪</h1><p>分布式跟踪（最初由Google在<a shape="rect" class="external-link" href="http://research.google.com/pubs/pub36356.html" rel="nofollow">Dapper中</a>描述） <a shape="rect" class="external-link" href="http://research.google.com/pubs/pub36356.html" rel="nofollow">是“大型分布式系统跟踪基础结构”，</a>这一天变得越来越重要。随着微服务（又名SOA）获得越来越多的采用，典型的应用程序是使用数十甚至数百个小型分布式组件构建的。请求的端到端可跟踪性（或代表用户执行的任何类型的工作）是一项艰巨的任务，尤其是考虑到异步或/和并发调用时。<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>受<a shape="rect" class="external-link" href="http://research.google.com/pubs/pub36356.html" rel="nofollow">Dapper（大型分布式系统跟踪基础结构</a>论文）的启发，本质上是一个成熟的分布式跟踪框架。</p><p>分布式跟踪是新的或现有应用程序之上的附加检测层。就分布式跟踪而言， <strong>跨度</strong>代表工作的基本单位。例如，执行数据库查询是一个<strong>span</strong> 。<strong>跨度</strong>由唯一的128位ID标识。 <strong>跨区</strong>还具有其他数据，例如<strong>描述</strong> ， <strong>时间轴</strong> ， <strong>键值批注</strong> ，引起它们的<strong>跨度</strong>的<strong>ID</strong> （父级）以及<strong>进程/跟踪器的</strong> ID（通常是IP地址和进程名）。跨度开始和停止，并且它们跟踪其定时信息。创建<strong>跨度后</strong> ，应在将来的某个时间点将其停止。反过来， <strong>迹线</strong>是形成树状结构的一组跨度。例如，如果您正在运行JAX-RS服务，则跟踪可能由<strong>PUT</strong>请求和下游工作形成。</p><p>从实现的角度来看，在Java应用程序的上下文中，将<strong>范围</strong>附加到其线程上（通常，创建<strong>范围的</strong>线程应将其关闭）。但是，可以在线程之间传递<strong>跨度</strong> ，以便对复杂的执行流进行建模。只要正确创建和关闭<strong>跨接</strong> ，也可以在同一线程中具有多个<strong>跨接</strong> 。在下一节中，我们将看到其中的示例。</p><p>分布式跟踪中的另外两个重要概念是<strong>跨度接收器</strong>和<strong>采样器</strong> 。本质上，所有跨度（包括开始/停止时间，键/值注释，时间线等）应保留（或收集）在某个地方。<strong>跨度接收器</strong>是进程中的收集器，该进程是运行跟踪时<strong>跨度</strong>的目的地（它可以是控制台，本地文件，数据存储等）。<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>为<a shape="rect" class="external-link" href="http://hbase.apache.org">Apache HBase</a> ， <a shape="rect" class="external-link" href="https://flume.apache.org/">Apache Flume</a>和<a shape="rect" class="external-link" href="http://zipkin.io/" rel="nofollow">Twitter Zipkin</a>提供了跨度接收器。从另一方面讲， <strong>采样器</strong>允许控制跟踪的频率（始终，永远，不受概率驱动，...）。使用<strong>采样器</strong>是通过将跟踪开销限制为特定条件来最大程度地减少跟踪开销（或仅跟踪数量）的方法。</p><h1 id="UsingApacheHTrace-DistributedTracinginApacheCXFusingApacheHTrace">使用Apache HTrace的Apache CXF中的分布式跟踪</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>是用于构建服务和Web API的非常流行的框架。毫无疑问，它在微服务架构的背景下将发挥更大的作用，使开发人员能够快速构建和部署单独的JAX-RS / JAX-WS服务。正如前面所提到的，分布式跟踪是监视整个应用程序的一项必不可少的技术，它可以在遍历并跨越线程，进程和机器的边界时，将请求分解为单个服务跟踪。</p><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF中</a>当前的分布式跟踪集成仅在JAX-RS 2.x应用程序中支持<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a> （ <strong>4.x +</strong>版本分支）。从高层的角度来看，它包括三个主要部分：</p><ul style="list-style-type:square"><li><strong>TracerContext</strong> （可通过<strong>@Context</strong>注释<strong>注入</strong> ）</li><li><strong>HTraceProvider</strong> （服务器端JAX-RS提供程序）和<strong>HTraceClientProvider</strong> （客户端JAX-RS提供程序）</li><li><strong>HTraceFeature</strong> （服务器端<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>功能可简化<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>配置和集成）</li></ul><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>使用HTTP标头将跟踪上下文从客户端传递到服务，并从服务传递到服务。这些标头由<strong>HTraceProvider</strong>和<strong>HTraceClientProvider</strong>内部使用，但可以配置。默认的标头名称在TracerHeaders类中声明：</p><ul style="list-style-type:square"><li><strong>X-Span-Id</strong> ：包含当前的跨度ID</li></ul><p>默认情况下， <strong>HTraceProvider</strong>将尝试在每次服务调用时通过HTTP标头传递当前活动的<strong>跨度</strong> 。如果没有活动范围，则将基于每次调用创建新范围并通过HTTP标头传递。从本质上讲，只要注册客户端上的<strong>HTraceClientProvider</strong>和<strong>HTraceProvider</strong>在服务器上足有跟踪角度来正确地传递无处不在。唯一必要的配置部分是<strong>跨度接收器</strong>和<strong>采样器</strong> 。</p><p>还值得一提的是<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>将描述附加到<strong>spans的方式</strong> 。关于客户端集成，该描述将成为由HTTP方法作为前缀调用的完整URL，例如： <strong>GET</strong> <a shape="rect" class="external-link" href="http://localhost:8282/books" rel="nofollow"><strong>http：// localhost：8282</strong> / books</a> 。在服务器端集成上，描述成为以HTTP方法为前缀的相对JAX-RS资源路径，例如： <strong>GET书籍，POST书籍/ 123</strong></p><h1 id="UsingApacheHTrace-ConfiguringClientconfigure.client">配置客户端<span class="confluence-anchor-link" id="UsingApacheHTrace-configure.client"></span></h1><p>根据客户端的实现，可以通过多种方式配置JAX-RS客户端。<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>提供了自己的<strong>WebClient</strong> ，可以像这样配置（在将来的版本中，将使用客户端特定的功能来实现此目的的更简单方法）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();
properties.put(Tracer.SPAN_RECEIVER_CLASSES_KEY, ...);
properties.put(Tracer.SAMPLER_CLASSES_KEY, ...);

/**
 * For example:
 *
 * properties.put(Tracer.SPAN_RECEIVER_CLASSES_KEY, StandardOutSpanReceiver.class.getName());
 * properties.put(Tracer.SAMPLER_CLASSES_KEY, AlwaysSampler.class.getName());
 */
        
final Tracer tracer = new Tracer.Builder("web-client")
    .conf(HTraceConfiguration.fromMap(properties))
    .build();
                
final HTraceClientProvider provider = new HTraceClientProvider(tracer);
final Response response = WebClient
    .create("http://localhost:9000/catalog", Arrays.asList(provider))
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>基于使用标准JAX-RS <strong>客户端</strong>的配置非常相似：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();
properties.put(Tracer.SPAN_RECEIVER_CLASSES_KEY, ...);
properties.put(Tracer.SAMPLER_CLASSES_KEY, ...);

/**
 * For example:
 *
 * properties.put(Tracer.SPAN_RECEIVER_CLASSES_KEY, StandardOutSpanReceiver.class.getName());
 * properties.put(Tracer.SAMPLER_CLASSES_KEY, AlwaysSampler.class.getName());
 */
        
final Tracer tracer = new Tracer.Builder("jaxrs-client")
    .conf(HTraceConfiguration.fromMap(properties))
    .build();
                
final HTraceClientProvider provider = new HTraceClientProvider(tracer);
final Client client = ClientBuilder.newClient().register(provider);

final Response response = client
    .target("http://localhost:9000/catalog")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><h3 id="UsingApacheHTrace-Configuringtracingheadernames">配置跟踪标头名称</h3><p>要更改用于将跟踪上下文从客户端传输到服务器的默认HTTP标头名称，只需定义一个属性即可： <strong>TracerHeaders。HEADER_SPAN_ID</strong> 。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final ClientConfiguration config = WebClient.getConfig(client);
config.getRequestContext().put(TracerHeaders.HEADER_SPAN_ID, "CUSTOM_HEADER_SPAN_ID");
</pre>
</div></div><div class="confluence-information-macro confluence-information-macro-warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>保持客户端和服务器HTTP标头配置同步非常重要，否则服务器将无法正确建立当前的跟踪上下文。</p></div></div><h1 id="UsingApacheHTrace-ConfiguringServerconfigure.server">配置服务器<span class="confluence-anchor-link" id="UsingApacheHTrace-configure.server"></span></h1><p>由于可用的功能类<strong>HTraceFeature</strong> ，服务器配置比客户端配置简单一些。根据<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>用于配置JAX-RS服务的方式，它可能是JAX-RS应用程序配置的一部分，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath("/")
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        final HashMap&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();
        properties.put(Tracer.SPAN_RECEIVER_CLASSES_KEY, ...);
        properties.put(Tracer.SAMPLER_CLASSES_KEY, ...);
       
        /**
         * For example:
         *
         * properties.put(Tracer.SPAN_RECEIVER_CLASSES_KEY, StandardOutSpanReceiver.class.getName());
         * properties.put(Tracer.SAMPLER_CLASSES_KEY, AlwaysSampler.class.getName());
         */

       &#160;return new HashSet&lt;Object&gt;(
            Arrays.asList(
                new HTraceFeature(HTraceConfiguration.fromMap(properties), "tracer")
            )
        );
    }
}</pre>
</div></div><p>或者也可以使用<strong>JAXRSServerFactoryBean</strong>对其进行配置，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();
properties.put(Tracer.SPAN_RECEIVER_CLASSES_KEY, ...);
properties.put(Tracer.SAMPLER_CLASSES_KEY, ...);

final JAXRSServerFactoryBean factory = 
    RuntimeDelegate.getInstance().createEndpoint(/* application instance */, JAXRSServerFactoryBean.class);
factory.setFeatures(Arrays.&lt; Feature &gt;asList(new HTraceFeature(HTraceConfiguration.fromMap(properties), "tracer")));
...
return factory.create();</pre>
</div></div><p>正确配置<strong>跨度接收器</strong>和<strong>采样器后</strong> ，将收集所有生成的<strong>跨度</strong> ，并将其用于分析和/或可视化。</p><h3 id="UsingApacheHTrace-Configuringtracingheadernames.1">配置跟踪标头名称</h3><p>与客户端一样，要更改用于在服务器上建立跟踪上下文的默认HTTP标头名称，只需定义一个属性即可： <strong>TracerHeaders。HEADER_SPAN_ID</strong> 。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();
headers.put(TracerHeaders.HEADER_SPAN_ID, "CUSTOM_HEADER_SPAN_ID");
            
final JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();
sf.setProperties(headers);
...
sf.create();</pre>
</div></div><div class="confluence-information-macro confluence-information-macro-warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>保持客户端和服务器HTTP标头配置同步非常重要，否则服务器将无法正确建立当前的跟踪上下文。</p></div></div><h1 id="UsingApacheHTrace-DistributedTracingInAction:UsageScenarios">实际中的分布式跟踪：使用方案</h1><p>在以下小节中，我们将通过许多不同的场景来说明实际中的分布式跟踪，从最简单的场景开始，以异步JAX-RS服务结束。所有示例均假设<strong>已完成</strong> <a shape="rect" href="using-apache-htrace.html">配置</a> （请参阅上面的“ <a shape="rect" href="using-apache-htrace.html">配置客户端”</a>和“ <a shape="rect" href="using-apache-htrace.html">配置服务器”</a>部分）。</p><h2 id="UsingApacheHTrace-Example#1:ClientandServerwithdefaultdistributedtracingconfigured">示例1：配置了默认分布式跟踪的客户端和服务器</h2><p>在第一个示例中，我们将看到仅在<strong>HTraceClientProvider</strong>和<strong>HTraceProvider</strong>注册的情况下在客户端和服务器上使用默认配置的效果。JAX-RS资源端点是非常基本的存根方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>客户端就是这么简单：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Response response = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>客户端（具有进程名称<strong><span class="label label-default service-filter-label service-tag-filtered">jaxrsclient / 192.168.0.100</span></strong> ）对请求的实际调用以及服务器端（进程名称<strong><span class="label label-default service-filter-label">jaxrsserver / 192.168.0.100</span></strong> ）的服务的随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-apache-htrace.data/image2015-9-13 16:17:53.png"></span></p><h2 id="UsingApacheHTrace-Example#2:ClientandServerwithnestedtrace">示例2：具有嵌套跟踪的客户端和服务器</h2><p>在此示例中，JAX-RS服务的服务器端实现将在其自己的跨度内调用外部系统（模拟为500ms的简单延迟）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    try(final TraceScope scope = tracer.startSpan("Calling External System")) {
        // Simulating a delay of 500ms required to call external system
        Thread.sleep(500);
           
        return Arrays.asList(
            new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
        );
    }
}</pre>
</div></div><p>客户端（具有进程名称<strong><span class="label label-default service-filter-label service-tag-filtered">jaxrsclient / 192.168.0.100</span></strong> ）对请求的实际调用以及服务器端（进程名称<strong><span class="label label-default service-filter-label">jaxrsserver / 192.168.0.100</span></strong> ）的服务的随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-apache-htrace.data/image2015-9-13 17:5:12.png"></span></p><h2 id="UsingApacheHTrace-Example#3:ClientandServertracewithtimeline">示例＃3：带有时间轴的客户端和服务器跟踪</h2><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加时间线。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    tracer.timeline("Preparing Books");
    // Simulating some work using a delay of 100ms
    Thread.sleep(100);
        
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>客户端（具有进程名称<strong><span class="label label-default service-filter-label service-tag-filtered">jaxrsclient / 192.168.0.100</span></strong> ）对请求的实际调用以及服务器端（进程名称<strong><span class="label label-default service-filter-label">jaxrsserver / 192.168.0.100</span></strong> ）的服务的随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-apache-htrace.data/image2015-9-14 21:4:9.png"></span></p><h2 id="UsingApacheHTrace-Example#4:ClientandServerwithannotatedtrace(key/value)">例4：带注释的跟踪（键/值）的客户端和服务器</h2><p>在此示例中，JAX-RS服务的服务器端实现将向活动范围添加键/值注释。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Collection&lt;Book&gt; books = Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
        
    tracer.annotate("# of books", Integer.toString(books.size()));
    return books;
}</pre>
</div></div><p>客户端对请求的实际调用（进程名为<strong><span class="label label-default service-filter-label service-tag-filtered">jaxrsclient / 192.168.0.100</span></strong> ），随后在服务器端对服务的调用（进程名<strong><span class="label label-default service-filter-label">jaxrsserver / 192.168.0.100</span></strong> ）将生成以下示例服务器跟踪属性：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-apache-htrace.data/image2015-9-14 21:11:56.png"></span></p><h2 id="UsingApacheHTrace-Example#5:ClientandServerwithparalleltrace(involvingthreadpools)">示例＃5：具有并行跟踪的客户端和服务器（涉及线程池）</h2><p>在此示例中，JAX-RS服务的服务器端实现将把一些工作卸载到线程池中，然后将响应返回给客户端，以模拟并行执行。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Future&lt;Book&gt; book1 = executor.submit(
        tracer.wrap("Getting Book 1", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(100);
                    
                return new Book("Apache CXF Web Service Development", 
                    "Naveen Balani, Rajeev Hathi");
            }
        })
    );
        
    final Future&lt;Book&gt; book2 = executor.submit(
        tracer.wrap("Getting Book 2", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(200);
                    
                return new Book("Developing Web Services with Apache CXF and Axis2", 
                    "Kent Ka Iok Tong");
            }
        })
    );
       
    return Arrays.asList(book1.get(), book2.get());
}</pre>
</div></div><p>客户端（具有进程名称<strong><span class="label label-default service-filter-label service-tag-filtered">jaxrsclient / 192.168.0.100</span></strong> ）对请求的实际调用以及服务器端（进程名称<strong><span class="label label-default service-filter-label">jaxrsserver / 192.168.0.100</span></strong> ）的服务的随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-apache-htrace.data/image2015-9-15 20:44:20.png"></span></p><h2 id="UsingApacheHTrace-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side)">示例＃6：具有异步JAX-RS服务的客户端和服务器（服务器端）</h2><p>在此示例中，JAX-RS服务的服务器端实现将异步执行。由于在不同线程（通常）中处理请求和响应，因此从跟踪预期对象构成了挑战。目前， <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>不支持透明的跟踪范围管理（默认用例除外），但是提供了实现此目的的简单方法（允许跨线程转移范围）。客户端代码保持不变。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public void getBooks(@Suspended final AsyncResponse response, @Context final TracerContext tracer) throws Exception {
    tracer.continueSpan(new Traceable&lt;Future&lt;Void&gt;&gt;() {
        public Future&lt;Void&gt; call(final TracerContext context) throws Exception {
            return executor.submit(
                tracer.wrap("Getting Book", new Traceable&lt;Void&gt;() {
                    public Void call(final TracerContext context) throws Exception {
                        // Simulating a processing delay of 50ms
                        Thread.sleep(50);
                            
                        response.resume(
                            Arrays.asList(
                                new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
                            )
                        );
                            
                        return null;
                    }
                })
            );
        }
    });
}</pre>
</div></div><p>客户端（具有进程名称<strong><span class="label label-default service-filter-label service-tag-filtered">jaxrsclient / 192.168.0.100</span></strong> ）对请求的实际调用以及服务器端（进程名称<strong><span class="label label-default service-filter-label">jaxrsserver / 192.168.0.100</span></strong> ）的服务的随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-apache-htrace.data/image2015-9-15 21:26:5.png"></span></p><h2 id="UsingApacheHTrace-Example#7:ClientandServerwithasynchronousinvocation(client-side)">示例＃7：具有异步调用的客户端和服务器（客户端）</h2><p>在此示例中，JAX-RS服务的服务器端实现将是默认的：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>当JAX-RS客户端实现将执行异步调用时：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Future&lt;Response&gt; future = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .async()
    .get();</pre>
</div></div><p>在这方面，与调用方预期对象没有什么区别，但是要进行更多的工作以将活动跟踪范围从JAX-RS客户端请求过滤器转移到客户端响应过滤器，因为通常在不同线程中执行（类似服务器端异步JAX-RS资源调用）。客户端（具有进程名称<strong><span class="label label-default service-filter-label service-tag-filtered">jaxrsclient / 192.168.0.100</span></strong> ）对请求的实际调用以及服务器端（进程名称<strong><span class="label label-default service-filter-label">jaxrsserver / 192.168.0.100</span></strong> ）的服务的随后调用将生成以下示例跟踪：</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-apache-htrace.data/image2015-9-16 21:9:56.png"></span></p><h1 id="UsingApacheHTrace-DistributedTracingApacheHTraceandJAX-WSsupport">分布式跟踪Apache HTrace和JAX-WS支持</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>中的分布式跟踪主要围绕JAX-RS 2.x实现而构建。但是，还支持JAX-WS，但它需要编写一些样板代码并直接使用<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a> API（在不久的将来将增强JAX-WS集成）。本质上，从服务器端预期的输入/输出拦截器，分别将<strong>HTraceStartInterceptor</strong>和<strong>HTraceStopInterceptor</strong>配置为拦截器链的一部分。但是，应使用<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a> API手动配置<strong>span</strong>接收器，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();
final HTraceConfiguration conf = HTraceConfiguration.fromMap(properties);
Trace.addReceiver(new StandardOutSpanReceiver(conf));
            
final JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();
...
sf.getInInterceptors().add(new HTraceStartInterceptor(Phase.PRE_INVOKE, new AlwaysSampler(conf)));
sf.getOutInterceptors().add(new HTraceStopInterceptor(Phase.PRE_MARSHAL));
...
sf.create();</pre>
</div></div><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>为拦截器配置正确的相位非常重要。进入拦截器的建议阶段是<strong>PRE_INVOKE，</strong>而离开拦截器的建议阶段是<strong>PRE_MARSHAL</strong> 。如果使用了错误的阶段，则可以忽略或不处理响应或/和请求标头。</p></div></div><p>与服务器端类似，客户端需要自己的一组输出/输入拦截器<strong>HTraceClientStartInterceptor</strong>和<strong>HTraceClientStopInterceptor</strong> 。请注意与服务器端的区别： <strong>HTraceClientStartInterceptor</strong>变为外拦截器，而<strong>HTraceClientStopInterceptor</strong>变为内拦截器。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
...
factory.getOutInterceptors().add(new HTraceClientStartInterceptor(sampler));
factory.getInInterceptors().add(new HTraceClientStopInterceptor());
...
factory.create();</pre>
</div></div><h1 id="UsingApacheHTrace-PropagatingTraceDetailsToLogs">将跟踪详细信息传播到日志</h1><p>为了在正在进行的跟踪和日志之间更好地关联，从<strong>3.1.11</strong> / <strong>3.2.0</strong>版本开始的<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>为<a shape="rect" class="external-link" href="https://logback.qos.ch/" rel="nofollow">Logback</a>用户<strong>LogbackSpanConverter</strong>分发了一个有用的扩展。该转换器可用于使用当前跟踪详细信息来补充日志记录，例如跟踪器ID和跨度ID。例如，这是一个简单的<strong>logback.xml</strong>配置文件。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration scan="true" scanPeriod="5 seconds"&gt;
    &lt;conversionRule conversionWord="trace" converterClass="org.apache.cxf.tracing.htrace.ext.LogbackSpanConverter" /&gt;
    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%level] [%trace] %d{yyyy-MM-dd HH:mm:ss.SSS} %logger{36} %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;root level="INFO"&gt;
        &lt;appender-ref ref="STDOUT" /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;</pre>
</div></div><p>在这种情况下，跟踪详细信息将以以下格式传播到每个日志记录： <strong><tracer_id>span： <span id=""></span></tracer_id></strong> 。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">[INFO] [-, -] 2017-03-11 14:40:13.603 org.eclipse.jetty.server.Server Started @2731ms
[INFO] [tracer-server/192.168.0.101, span: 6d3e0d975d4c883cce12aee1fd8f3e7e] 
2017-03-11 14:40:24.013 com.example.rs.PeopleRestService Getting all employees
[INFO] [tracer-server/192.168.0.101, span: 6d3e0d975d4c883c7592f4c2317dec22] 
2017-03-11 14:40:28.017 com.example.rs.PeopleRestService Looking up manager in the DB database</pre>
</div></div><p>特殊的<strong>[-，-]</strong>占位符表示在记录记录时没有跟踪详细信息可用。</p><h1 id="UsingApacheHTrace-AccessingApacheHTraceAPIs">访问Apache HTrace API</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>尽可能在<strong>TracerContext</strong>之后抽象出许多特定于跟踪器的API。但是，有时需要访问<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a> API，以利用可用的工具。为了能够<strong>，TracerContext</strong>有返回底层<strong>示踪</strong>例如专用<strong>的解包</strong> 。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/search")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject search(@QueryParam("q") final String query, @Context final TracerContext tracing) throws Exception {
    final Tracer tracer = tracing.unwrap(Tracer.class);
    // ...
}</pre>
</div></div><h1 id="UsingApacheHTrace-FutureWork">未来的工作</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>为提供<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>集成感到非常自豪。在当前阶段，明智的决定是保留最少的API，仅提供必要的功能集。但是，不仅要发展<a shape="rect" class="external-link" href="http://htrace.incubator.apache.org/index.html">Apache HTrace</a>集成，而且要发展分布式跟踪支持，这是一个坚定的承诺。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=61318396">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=61318396&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>