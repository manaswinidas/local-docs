<html ><head></head><body  onload="init()">﻿

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Search">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS搜索</title>
  



<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-advanced-features.html">JAX-RS高级功能</a> > <a href="jax-rs-search.html">JAX-RS搜索</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="JAX-RSSearch-JAX-RSSearch">JAX-RS搜索</h1><p> </p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1543399006854 {padding: 0px;}
div.rbtoc1543399006854 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1543399006854 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1543399006854">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-JAX-RSSearch">JAX-RS搜索</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-AdvancedSearchQueries">进阶搜寻查询</a></li><li><a shape="rect" href="#JAX-RSSearch-SupportedQueryLanguages">支持的查询语言</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-FeedItemQueryLanguage">提要项查询语言</a></li><li><a shape="rect" href="#JAX-RSSearch-OpenDataProtocol">开放数据协议</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-Whentouseadvancedqueries.">何时使用高级查询。</a></li><li><a shape="rect" href="#JAX-RSSearch-DependenciesandConfiguration">依赖关系和配置</a></li><li><a shape="rect" href="#JAX-RSSearch-Workingwiththequeries">处理查询</a></li><li><a shape="rect" href="#JAX-RSSearch-Capturingthequeries">捕获查询</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-Mappingofquerypropertiestobeanproperties">查询属性到bean属性的映射</a></li><li><a shape="rect" href="#JAX-RSSearch-Dealingwithmistypedpropertynames">处理类型错误的属性名称</a></li><li><a shape="rect" href="#JAX-RSSearch-Parserproperties">解析器属性</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-Mappingofquerypropertiestocolumn/fieldnames">查询属性到列/字段名称的映射</a></li><li><a shape="rect" href="#JAX-RSSearch-SearchBean">SearchBean</a></li><li><a shape="rect" href="#JAX-RSSearch-Convertingthequeries">转换查询</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-SQL">的SQL</a></li><li><a shape="rect" href="#JAX-RSSearch-JPA2.0">JPA 2.0</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-Countexpressions">计算表达式</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-Lucene">Lucene</a></li><li><a shape="rect" href="#JAX-RSSearch-LDAP">LDAP</a></li><li><a shape="rect" href="#JAX-RSSearch-HBase">HBase的</a></li><li><a shape="rect" href="#JAX-RSSearch-Customvisitors">自订访客</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-Untypedconverters">无类型转换器</a></li><li><a shape="rect" href="#JAX-RSSearch-Typedconverters">类型转换器</a></li><li><a shape="rect" href="#JAX-RSSearch-Customparsing">自定义解析</a></li></ul>
</li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-ConvertingthequerieswithQueryContext">使用QueryContext转换查询</a></li><li><a shape="rect" href="#JAX-RSSearch-PlainqueriestoFIQLconversion">普通查询到FIQL转换</a></li><li><a shape="rect" href="#JAX-RSSearch-SearchExpressionsinURIPathsegments">URI路径段中的搜索表达式</a></li><li><a shape="rect" href="#JAX-RSSearch-Queriesinvolvingmultipleentities">涉及多个实体的查询</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-Basicqueries">基本查询</a></li><li><a shape="rect" href="#JAX-RSSearch-Complexqueries">复杂查询</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-Validation">验证方式</a></li><li><a shape="rect" href="#JAX-RSSearch-Buildingthequeries">建立查询</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-FIQL">FIQL</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-Usingdatesinqueries">在查询中使用日期</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-Relativedates">相对日期</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-Alternativequerylanguages">替代查询语言</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-OData">数据</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSSearch-ContentExtraction">内容提取</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSSearch-UsingTikaContentExtractor">使用TikaContentExtractor</a></li><li><a shape="rect" href="#JAX-RSSearch-UsingTikaLuceneContentExtractor">使用TikaLuceneContentExtractor</a></li></ul>
</li></ul>
</li></ul>
</div><h2 id="JAX-RSSearch-AdvancedSearchQueries">进阶搜寻查询</h2><p>CXF支持在特定于查询语言的解析器的帮助下将高级查询表达式映射到类型化的Search API。</p><h2 id="JAX-RSSearch-SupportedQueryLanguages">支持的查询语言</h2><h3 id="JAX-RSSearch-FeedItemQueryLanguage">提要项查询语言</h3><p>从CXF 2.3.0开始，支持<a shape="rect" class="external-link" href="http://tools.ietf.org/html/draft-nottingham-atompub-fiql-00" rel="nofollow">Feed项目查询语言</a> （FIQL）。</p><p>例如下面的查询</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_s=name==CXF;version=ge=2.2
</pre>
</div></div><p>允许用户搜索名称为“ CXF”且版本大于或等于“ 2.2”的所有Apache项目。初始“ =”将查询“ _s”的名称与FIQL表达式分开，而“ ==”和“ = ge =”分别传达“等于”和“大于或等于”。<br clear="none">诸如“ name == CXF *”之类的表达式可用于进行部分相等性检查（例如：名称应从“ CXF”开始）。</p><p>更复杂的复合表达式也可以很容易地表达，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Find all employees younger than 25 or older than 35 living in London
/employees?_s=(age=lt=25,age=gt=35);city==London

// Find all books on math or physics published in 1999 only.
/books?_s=date=lt=2000-01-01;date=gt=1999-01-01;(sub==math,sub==physics)

</pre>
</div></div><p>这是FIQL运算符的摘要：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>操作员</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ ==”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“！=“</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>不平等</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ = lt =”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>少于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ = le =”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>少于或等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ = gt =”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>比...更棒</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ = ge =”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>大于或等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“;”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>和</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“，”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>要么</p></td></tr></tbody></table></div><p>最后两个运算符“，”（OR）和“;”（AND）用于连接和构建复合（可能是嵌套的）表达式，而前6个运算符用于构建所谓的原始表达式。</p><p>从CXF 2.7.7开始：可以选择支持单个'='运算符，而不是'=='：将“ fiql.support.single.equals.operator”上下文属性设置为“ true”。</p><p>如您所见，FIQL足够丰富，可以为服务实现提供围绕知名数据的更有趣的搜索体验，同时仍可控制URI表达式的复杂性，这使得共享此类URI查询以及使用无论服务内部使用什么数据存储，都使用相同的查询语言。</p><p>请注意，通过URI查询参数传递FIQL查询时，必须使用'_search'或'_s'查询参数来标记FIQL表达式，以免干扰其他可选查询参数。从CXF 2.7.2开始，也可以使用整个查询组件来传递FIQL表达式，例如，</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Find all books on math or physics published in 1999 only.
/books?date=lt=2000-01-01;date=gt=1999-01-01;(sub==math,sub==physics)

</pre>
</div></div><p>请注意，没有“ _s”或“ _search”查询参数可用，整个查询字符串以“？”开始。”代表实际的FIQL表达式。<br clear="none">请使用“ search.use.all.query.component”上下文属性来支持此选项。</p><p>另外，表达式也可以编码为URI路径段，有关更多信息，请参见下面的部分。</p><h3 id="JAX-RSSearch-OpenDataProtocol">开放数据协议</h3><p>CXF 3.0.0-milestone2支持<a shape="rect" class="external-link" href="http://docs.oasis-open.org/odata/odata/v4.0/cos01/part2-url-conventions/odata-v4.0-cos01-part2-url-conventions.html#_Toc372793792" rel="nofollow">$ filter</a>查询，该查询定义为<a shape="rect" class="external-link" href="http://www.odata.org/" rel="nofollow">开放数据协议的</a>一部分，由<a shape="rect" class="external-link" href="http://olingo.incubator.apache.org/">Apache Olingo提供</a> 。</p><p>$ filter查询可以包含许多逻辑运算符，这是Search API范围内支持的运算符的摘要：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>操作员</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ eq”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ ne”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>不平等</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ lt”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>少于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ le”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>少于或等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ gt”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>比...更棒</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ ge”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>大于或等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“和”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>和</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“要么”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>要么</p></td></tr></tbody></table></div><p> </p><p>请参阅规范文本以获取<a shape="rect" class="external-link" href="http://docs.oasis-open.org/odata/odata/v4.0/cos01/part2-url-conventions/odata-v4.0-cos01-part2-url-conventions.html#_Toc372793804" rel="nofollow">一些示例</a> 。</p><p>请注意，CXF Search API不支持OData协议，仅支持$ filter查询（目前仅逻辑运算符），以使用CXF Search API查询应用程序数据。用户应直接与<a shape="rect" class="external-link" href="http://olingo.incubator.apache.org/">Apache Olingo合作，</a>以在应用程序流程中获得支持的<a shape="rect" class="external-link" href="http://www.odata.org/" rel="nofollow">OData</a>协议。</p><p>由于FIQL已被长期支持，因此此页面上的以下某些示例可能经常引用FIQL，但相同的示例也可用于OData $ filter表达式。例如，将查询“ _s = name == CXF”替换为“ $ filter = name eq CXF”。</p><h2 id="JAX-RSSearch-Whentouseadvancedqueries.">何时使用高级查询。</h2><p>考虑一个典型的查询表达式，例如“ a = avalue＆c = cvalue”。这可能意味着“找到所有具有'a'和'c'属性等于'avalue'和'cvalue'的资源”或“找到所有具有'a'或'c'属性等于'avalue'和'cvalue'的资源”。就多个查询属性的组合而言，它是应用程序特定于“和”还是“或”。</p><p>它还可以使用自定义语言来捕获条件表达式，例如，当多个属性很大或可以动态创建可搜索的实体时，“查找'a'属性小于123的所有资源”。</p><p>使用FIQL或OData捕获简单或中等复杂性查询，通常是在用户可以指定的一组属性众所周知的情况下。例如，书店资源将允许用户搜索具有许多有用属性的书籍（可以使用其中的书籍和/或图书馆的书籍等）。</p><p>此外，当属性和实体的数量很大，动态等时，考虑使用FIQL / OData和SearchConditionVisitor来通用化搜索代码。</p><h2 id="JAX-RSSearch-DependenciesandConfiguration">依赖关系和配置</h2><p>从CXF 2.6.0开始，需要以下依赖项：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;cxf-rt-rs-extension-search&lt;/artifactId&gt;
    &lt;version&gt;2.6.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- If working with OData --&gt;
&lt;!--
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.olingo&lt;/groupId&gt;
    &lt;artifactId&gt;olingo-odata2-core-incubating&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt;/version&gt; 
&lt;/dependency&gt;
--&gt;
</pre>
</div></div><p>另外，从CXF 2.6.0开始， <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchContextProvider.java" rel="nofollow">SearchContextProvider</a>需要注册为jaxrs：provider。</p><h2 id="JAX-RSSearch-Workingwiththequeries">处理查询</h2><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchContext.java" rel="nofollow">SearchContext</a>需要注入到应用程序代码中，并用于检索代表当前FIQL / OData查询的<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchCondition.java" rel="nofollow">SearchCondition</a> 。可以多种方式使用此SearchCondition查找匹配数据。</p><p>在本节中，我们假设要匹配的数据已在内存中可用。关于转换查询的后续部分将显示如何将查询转换为其他查询类型的语言或文本表达式。</p><p>因此，假设有Book实例的列表或映射可用。这是一种可能的方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("books")
public class Books {

    private Map&lt;Long, Book&gt; books;
    @Context
    private SearchContext context;

    @GET
    public List&lt;Book&gt; getBook() {

        SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
        // SearchCondition#isMet method can also be used to build a list of matching beans

        // iterate over all the values in the books map and return a collection of matching beans
        List&lt;Book&gt; found = sc.findAll(books.values());
        return found;
    }
}
</pre>
</div></div><p>请注意，searchContext.getCondition（Book.class）调用可能返回任意复杂的SearchCondition，它可以是简单的原始表达式，也可以是更复杂的复合表达式。</p><h2 id="JAX-RSSearch-Capturingthequeries">捕获查询</h2><p>为了捕获查询表达式，实例化了一个类似Book.class的bean，并将所有搜索属性注入其中。复杂的复合表达式将被“注入”到许多Book实例中，这可能需要进行优化。</p><p>请注意，默认情况下，诸如Book类之类的bean需要在FIQL表达式中找到的每个属性名称都有一个匹配的属性，例如，给定'name == b; id == 123'表达式，Book类将需要具有“名称”和“ id”属性。默认情况下启用此严格模式的原因是，忽略无法捕获的属性可能导致错误或意外的匹配，例如，如果Book'name'属性已重命名为'title'，则忽略'name的属性将导致更广泛的匹配。因此，如果该属性不存在，则为org.apache.cxf.jaxrs.ext.search。PropertyNotFoundException将被抛出；捕获它可以让它返回一个空响应，或者使用更宽松的模式重试，请参阅下一段。</p><p>例如，当期望对FIQL表达式进行更宽松的分析时，可以使用SearchBean（请参阅下一小节）或通过设置上下文属性“ search.lax.property.match”将原始表达式通过“ OR”连接起来。救命。当您需要知道表达式中已使用的所有属性的列表时，甚至在实际搜索中无法使用的那些属性的列表时，前一种方法更好。后一个选项将简单地忽略无法识别的属性。</p><p>请注意，“ search.decode.values”属性可用于具有“保留”字符，例如FIQL'，'或';'作为搜索属性值一部分传递为百分比编码字符的字符。</p><h3 id="JAX-RSSearch-Mappingofquerypropertiestobeanproperties">查询属性到bean属性的映射</h3><p>如上所述，当使用诸如Book.class之类的“类型化” bean捕获表达式时，在查询表达式中找到的无法映射到特定Book属性的属性将导致报告异常，或者可以将其报告为异常。 （可选）忽略。实际上，有很多原因导致查询表达式和捕获bean中的属性之间的直接匹配可能不理想：</p><ul class="alternate"><li>捕获bean可能会独立于实际查询而发展；例如，如果将书的“名称”重命名为“ title”，则诸如“ name == b”之类的有效查询将中断，这将使查询难以添加书签。</li><li>对于实际的bean属性不属于捕获bean本身而是其子属性之一的情况，直接匹配将根本不起作用。例如，JPA2图书实体可能具有OwnerInfo Bean，该Bean的Name Bean属性确实包含原始的“ name”属性。</li></ul><p>使用类型化bean时，首选方法是使用“ search.bean.property.map”上下文属性或直接使用SearchContext注册bean属性映射。例如，给定</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Book {

    private int id;
    private OwnerInfo ownerinfo;
    //setters and getters omitted for brevity
}

@Embeddable
public class OwnerInfo {

    private Address address;
    private Name name;
    //setters and getters omitted for brevity
}

@Embeddable
public class Name {

    private String name;
    //setters and getters omitted for brevity
}
</pre>
</div></div><p>和下面的地图：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;map&gt;
 &lt;!-- 'oname' is alias for the actual nested bean property --&gt;
 &lt;entry key="oname" value="ownerinfo.name.name"/&gt;
&lt;/map&gt;
</pre>
</div></div><p>可以让用户输入和添加书签查询（并且不会看到查询产生意外结果），如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">//Find all the books owned by Fred with id greater than 100
/books?_s=id=gt=100;oname=Fred
</pre>
</div></div><p>注意，诸如“ ownerinfo.name.name”之类的属性名称使用“。”让解析器导航到具有'name'属性的实际Name Bean。例如，在已知拥有者bean具有接受'name'属性的构造函数或静态valueOf（）方法的情况下，可以对此进行优化。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Name {

    private String name;
    public Name() {
    } 
    public Name(String name) {
        this.name = name;
    }
    //setters and getters omitted for brevity
}
</pre>
</div></div><p>“ oname”和“ ownerinfo.name”之间的映射也将起作用。</p><p>您还可以具有多对一映射，例如</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;map&gt;
 &lt;!-- 'oname' and 'owner' are aliases for the 'ownerinfo.name.name' bean property --&gt;
 &lt;entry key="oname" value="ownerinfo.name.name"/&gt;
 &lt;entry key="owner" value="ownerinfo.name.name"/&gt;
&lt;/map&gt;
</pre>
</div></div><h3 id="JAX-RSSearch-Dealingwithmistypedpropertynames">处理类型错误的属性名称</h3><p>考虑一种情况，其中已记录的搜索属性被命名为“地址”（小写），并且查询包含错误键入的“地址”。在这种情况下，除非设置了“ search.lax.property.match”属性，否则将引发PropertyNotFoundException。</p><p>支持不区分大小写的属性映射很容易，将“ search.bean.property.map”（前面提到）映射注册为Java TreeMap。</p><p>使用不区分大小写的字符串。CASE_INSENSITIVE_ORDER比较器。</p><p>但是，如果将“ address”属性错误地键入为“ adress”，则无济于事。在这种情况下，“ search.bean.property.map”可能仍然有用，因为只有很少的键可以支持某些典型的拼写错误，例如“地址”-“地址”，“地址”-“地址”等。</p><p>从CXF 3.1.5开始，org.apache.cxf.jaxrs.ext.search。PropertyNameConverter可用，并且可以用于将错误键入的属性名称更正确地转换为正确的名称。</p><p>可以将实现注册为“ search.bean.property.converter”端点上下文属性。</p><h3 id="JAX-RSSearch-Parserproperties">解析器属性</h3><p>解析器属性是那些告诉解析器如何处理Date值和无法识别的搜索属性名称的转换的属性。</p><p>如上所述，“ search.lax.property.match”可用于告诉解析器它应忽略没有相应bean属性的搜索属性名称。</p><p>“ search.date.format”和“ search.timezone.support”告诉解析器如何转换日期值，请参见“在查询中使用日期”部分。</p><p>将来可能会支持更多属性。</p><p>所有这些属性都可以设置为端点上下文属性，也可以直接使用SearchContext设置。</p><h2 id="JAX-RSSearch-Mappingofquerypropertiestocolumn/fieldnames">查询属性到列/字段名称的映射</h2><p>将FIQL查询转换为SQL或其他非类型查询语言表达式时，以及使用Lucene转换器时，能够在实际查询参数与列或字段名称之间进行映射可能会很有用。CXF附带的所有FIQL转换器都具有构造函数，该构造函数接受用于将查询映射到列/字段的映射。有关示例，请参见下一个“ SearchBean”部分。</p><p>请注意，此属性与“将查询属性映射到bean属性”一节中描述的属性不同。为了将FIQL查询捕获到类型化的，特定于域的Bean（如Book）中，需要后者（在上一节中进行了描述），对于JPA2也已经足够了，JPA2还具有@Column之类的注释。</p><h2 id="JAX-RSSearch-SearchBean">SearchBean</h2><p>org.apache.cxf.jaxrs.ext.search。SearchBean是一个实用程序Bean类，在必须使用可能需要支持的所有属性来更新诸如Book.class之类的Bean类的情况下，它可以简化对捕获的FIQL表达式的分析并将其转换为其他语言表达式。或需要手动管理属性。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// ?_s="level=gt=10"
SearchCondition&lt;SearchBean&gt; sc = searchContext.getCondition(SearchBean.class);

Map\&lt;, String\&gt; fieldMap = new HashMap\&lt;String, String\&gt;();
fieldMap.put("level", "LEVEL_COLUMN");

SQLPrinterVisitor&lt;SearchBean&gt; visitor = new SQLPrinterVisitor&lt;SearchBean&gt;(fieldMap, "table", "LEVEL_COLUMN");
sc.accept(visitor);
assertEquals("SELECT LEVEL_COLUMN FROM table 
              WHERE LEVEL_COLUMN &gt; '10'",
              visitor.getQuery());
</pre>
</div></div><h2 id="JAX-RSSearch-Convertingthequeries">转换查询</h2><p>SearchCondition还可以用于将搜索要求（最初以FIQL / OData表示）转换为其他查询语言。<br clear="none">自定义<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchConditionVisitor.java" rel="nofollow">SearchConditionVisitor</a>实现可用于将SearchCondition对象转换为自定义表达式或类型化对象。CXF附带了用于将表达式转换为SQL，JPA 2.0 CriteriaQuery或TypedQuery，Lucene Query的访问者。</p><h3 id="JAX-RSSearch-SQL">的SQL</h3><p>org.apache.cxf.jaxrs.ext.search.sql。SQLPrinterVisitor可用于创建SQL表达式。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// ?_s="name==ami*;level=gt=10"
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
SQLPrinterVisitor&lt;Book&gt; visitor = new SQLPrinterVisitor&lt;Book&gt;("table");
sc.accept(visitor);
assertEquals("SELECT * FROM table 
              WHERE 
              name LIKE 'ami%' 
              AND 
              level &gt; '10'",
              visitor.getQuery());
</pre>
</div></div><p>请注意，SQLPrinterVisitor也可以使用列名和字段别名映射进行初始化：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// ?_s="level=gt=10"
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);

Map&lt;String, String&gt; fieldMap = new HashMap&lt;String, String&gt;();
fieldMap.put("level", "LEVEL_COLUMN");

SQLPrinterVisitor&lt;Book&gt; visitor = new SQLPrinterVisitor&lt;Book&gt;(fieldMap, "table", "LEVEL_COLUMN");
sc.accept(visitor);
assertEquals("SELECT LEVEL_COLUMN FROM table 
              WHERE LEVEL_COLUMN &gt; '10'",
              visitor.getQuery());
</pre>
</div></div><p>字段映射可以帮助从Web前端隐藏实际表列/记录字段的名称。例如，用户将知道'level'属性可用，而在内部它将被转换为LEVEL_COLUMN名称。</p><p><strong>警告</strong> ：使用SQLPrinterVisitor可能会使您的服务容易受到SQL注入攻击。请采取适当的步骤来避免这些攻击（例如，使用自定义PropertyValidator验证查询，或<a shape="rect" class="external-link" href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User-Supplied_Input" rel="nofollow">手动转义</a>输入值）。</p><h3 id="JAX-RSSearch-JPA2.0">JPA 2.0</h3><p>CXF 2.6.4和CXF 2.7.1引入了org.apache.cxf.jaxrs.ext.search.jpa。JPATypedQueryVisitor和org.apache.cxf.jaxrs.ext.search.jpa。JPACriteriaQueryVisitor，可用于将FIQL / OData表达式捕获到<br clear="none">javax.persistence。TypedQuery或javax.persistence.criteria。CriteriaQuery对象。</p><p>例如，给定：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Book {

    private String title;
    private Date date;
    private OwnerInfo ownerinfo;
    //setters and getters omitted for brevity
}

@Embeddable
public class OwnerInfo {

    private Address address;
    private Name name;
    //setters and getters omitted for brevity
}

@Embeddable
public class Name {

    private String name;
    //setters and getters omitted for brevity
}

@Embeddable
public class Address {

    private String street;
    //setters and getters omitted for brevity
}
</pre>
</div></div><p>可以使用以下代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;

// init EntityManager as required
private EntityManager entityManager;

// Find the books owned by Barry who lives in London, published starting from the first month of 2000 
// ?_s="date=ge=2000-01-01;ownername=barry;address=london"

// this map will have to be set as a contextual property on the jaxrs endpoint
// it assumes that Book bean has nested OwnerInfo bean with nested Address and Name beans, 
// with the latter containing 'street' and 'name' property respectively

Map&lt;String, String&gt; beanPropertiesMap = new HashMap&lt;String, String&gt;();
beanPropertiesMap.put("address", "ownerInfo.address.street");
beanPropertiesMap.put("ownername", "ownerInfo.name.name");

// the actual application code
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
SearchConditionVisitor&lt;Book, TypedQuery&lt;Book&gt;&gt; visitor = 
    new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
sc.accept(visitor);

TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
List&lt;Book&gt; books = typedQuery.getResultList();
</pre>
</div></div><p>如果必须使用JPA2 CriteriaBuilder的shape方法（array（），construct（）或tuple（））之一将实际结果成型为不同类型的Bean，则最好使用CriteriaQuery。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Find the books owned by Barry who lives in London, published starting from the first month of 2000 
// ?_s="date=ge=2000-01-01;ownername=barry;address=london"

// this map will have to be set as a contextual property on the jaxrs endpoint
Map&lt;String, String&gt; beanPropertiesMap = new HashMap&lt;String, String&gt;();
beanPropertiesMap.put("address", "ownerInfo.address.street");
beanPropertiesMap.put("ownername", "ownerInfo.name.name");

// the actual application code
// Only Book 'id' and 'title' properties are extracted from the list of found books
 
SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
JPACriteriaQueryVisitor&lt;Book, Tuple&gt; visitor = 
    new JPACriteriaQueryVisitor&lt;Book, Tuple&gt;(entityManager, Book.class, Tuple.class);
sc.accept(visitor);

List&lt;SingularAttribute&lt;Book, ?&gt;&gt; selections = new LinkedList&lt;SingularAttribute&lt;Book, ?&gt;&gt;();
// Book_ class is generated by JPA2 compiler
selections.add(Book_.id);
selections.add(Book_.title);

visitor.selectTuple(selections);

TypedQuery&lt;Tuple&gt; query = visitor.getQuery();

List&lt;Tuple&gt; tuples = typedQuery.getResultList();
for (Tuple tuple : tuples) {
  int bookId = tuple.get("id", String.class);
  String title = tuple.get("title", String.class);
  // add bookId &amp; title to the response data
}

</pre>
</div></div><p>请注意，JPACriteriaQueryVisitor将自动为诸如“ tuple.get（'id'，String.class）”之类的表达式设置别名。<br clear="none">JPACriteriaQueryVisitor将得到增强，以及时支持更多的JPA2高级构造。</p><p>或者，不要使用Tuple，而应使用像BeanInfo这样的捕获bean：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public static class BookInfo {
    private int id;
    private String title;

    public BookInfo() {
            
    }
        
    public BookInfo(Integer id, String title) {
        this.id = id;
        this.title = title;
    }
    //setters and getters omitted for brevity
 }

// actual application code:

SearchCondition&lt;Book&gt; sc = searchContext.getCondition(Book.class);
JPACriteriaQueryVisitor&lt;Book, BookInfo&gt; visitor = 
    new JPACriteriaQueryVisitor&lt;Book, BookInfo&gt;(entityManager, Book.class, BookInfo.class);
sc.accept(visitor);

List&lt;SingularAttribute&lt;Book, ?&gt;&gt; selections = new LinkedList&lt;SingularAttribute&lt;Book, ?&gt;&gt;();
// Book_ class is generated by JPA2 compiler
selections.add(Book_.id);
selections.add(Book_.title);

visitor.selectConstruct(selections);

TypedQuery&lt;BookInfo&gt; query = visitor.getQuery();

List&lt;BookInfo&gt; bookInfo = typedQuery.getResultList();
return bookInfo;
</pre>
</div></div><p>在使用显式集合的情况下，JPA2类型的转换器还支持联接操作，例如，给定：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Entity(name = "Book")
public class Book {

    private List&lt;BookReview&gt; reviews = new LinkedList&lt;BookReview&gt;();
    private List&lt;String&gt; authors = new LinkedList&lt;String&gt;();
    // other properties omitted

    @OneToMany
    public List&lt;BookReview&gt; getReviews() {
        return reviews;
    }

    public void setReviews(List&lt;BookReview&gt; reviews) {
        this.reviews = reviews;
    }

    @ElementCollection
    public List&lt;String&gt; getAuthors() {
        return authors;
    }

    public void setAuthors(List&lt;String&gt; authors) {
        this.authors = authors;
    }
}

@Entity
public class BookReview {
    private Review review;
    private List&lt;String&gt; authors = new LinkedList&lt;String&gt;();
    private Book book;
    // other properties omitted    

    public Review getReview() {
        return review;
    }

    public void setReview(Review review) {
        this.review = review;
    }

    @OneToOne
    public Book getBook() {
        return book;
    }

    public void setBook(Book book) {
        this.book = book;
    }

    @ElementCollection
    public List&lt;String&gt; getAuthors() {
        return authors;
    }

    public void setAuthors(List&lt;String&gt; authors) {
        this.authors = authors;
    }

    public static enum Review {
        GOOD,
        BAD
    }
}
</pre>
</div></div><p>以下内容将找到“ Ted撰写的所有好评的书”：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchCondition&lt;Book&gt; filter = new FiqlParser&lt;Book&gt;(Book.class).parse("reviews.review==good;reviews.authors==Ted");
// in practice, map "reviews.review" to "review", "reviews.authors" to "reviewAuthor" 
// and have a simple query like "review==good;reviewAuthor==Ted" instead

SearchConditionVisitor&lt;Book, TypedQuery&lt;Book&gt;&gt; jpa = new JPATypedQueryVisitor&lt;Book&gt;(em, Book.class);
filter.accept(jpa);
TypedQuery&lt;Book&gt; query = jpa.getQuery();
return query.getResultList();
</pre>
</div></div><p>org.apache.cxf.jaxrs.ext.search.jpa。还介绍了用于将FIQL / OData表达式转换为JPQL表达式的JPALanguageVisitor。</p><h4 id="JAX-RSSearch-Countexpressions">计算表达式</h4><p>Count表达式在两个级别上受支持，</p><p>首先，可能要获取与给定搜索表达式匹配的记录数，这实际上可以通过检查结果列表的大小来完成：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">TypedQuery&lt;Book&gt; query = jpa.getQuery();
return query.getResultList().size();
</pre>
</div></div><p>但是，这对于大量记录可能效率很低，因此建议使用CriteriaBuilder计数操作，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchCondition&lt;Book&gt; filter = new FiqlParser&lt;Book&gt;(Book.class).parse("reviews.review==good;reviews.authors==Ted");

JPACriteriaQueryVisitor&lt;Book, Long&gt; jpa = new JPACriteriaQueryVisitor&lt;Book, Long&gt;(em, Book.class, Long.class);
filter.accept(jpa);
long count = jpa.count();
</pre>
</div></div><p> </p><p>其次， <strong>仅当使用FIQL时</strong> ， <strong>才</strong>可以使用计数扩展。例如，可能要查找“至少由两位作者撰写的所有书籍或没有评论的所有书籍”。<br clear="none">如果诸如BookReview之类的集合实体具有非原始类型，则只需要键入“ reviews == 0”，否则就需要使用计数扩展名，例如：“ count（authors）= ge = 2”</p><h3 id="JAX-RSSearch-Lucene">Lucene</h3><p>从CXF 2.7.1开始，支持将FIQL / OData表达式映射到Lucene（4.0.0-BETA）查询。请注意，从CXF 3.0.2开始，Lucene版本已升级到4.9.0，以便从查询生成器和其他改进中受益。</p><p>org.apache.cxf.jaxrs.ext.search.lucene。LuceneQueryVisitor可用于支持默认（内容）字段或特定的自定义字段查询。<br clear="none">支持查询特定术语和短语。</p><p>例如，“查找包含“文本”术语的文档”：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import org.apache.lucene.search.Query;

SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("ct==text");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("ct", "contents");
lucene.visit(filter);
org.apache.lucene.search.Query termQuery = lucene.getQuery();
// use Query
</pre>
</div></div><p>注意，“ new LuceneQueryVisitor <searchbean>（“ ct”，“ contents”）;“是一个简单的构造函数，可让您在查询中使用的“ ct”名称与实际默认内容字段之间创建映射。不需要使用此映射，但建议使用此映射，因为它会使查询表达式更短并且不会泄漏实际的内部Lucene字段名称。</searchbean></p><p>所有FIQL运算符都已映射到相关的Lucene查询对象。诸如“小于”或“大于和小于”之类的查询将对诸如“ org.apache.lucene.document”之类的输入字段有效。IntField”。可以使用“ primitiveFieldTypeMap”映射属性配置访问者，以帮助其将给定的查询名称（例如“ id”）映射到Integer.class。</p><p>短语也受支持。假设您只有几个文档，每个文档都包含名称和值对，例如“ name = Fred”，“ name = Barry”，并且您只想列出包含“ name = Fred”的文档：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("name==Fred");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("contents");
lucene.visit(filter);
org.apache.lucene.search.Query phraseQuery = lucene.getQuery();
// use query
</pre>
</div></div><p>在此示例中，要求访问者创建Lucene org.apache.lucene.search。针对指定的内容字段（“内容”）的PhraseQuery。当可能需要根据不同的内容字段检查不同的短语时，访问者也可以接受contentsFieldMap地图属性。</p><p>从CXF 3.0.2开始，LuceneQueryVisitor支持键入的日期范围查询。但是，此功能应与“ primitiveFieldTypeMap”一起使用，以提示访问者哪些字段是时间字段，并应在过滤器表达式中进行处理。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Map&lt; String, Class&lt; ? &gt; &gt; fieldTypes = new LinkedHashMap&lt; String, Class&lt; ? &gt; &gt;();
fieldTypes.put( "modified", Date.class);

SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("modified=gt=2007-09-16");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("ct", "contents");
lucene.setPrimitiveFieldTypeMap(fieldTypes);
lucene.visit(filter);

org.apache.lucene.search.Query query = lucene.getQuery();</pre>
</div></div><p>LuceneQueryVisitor支持多种日期格式，但仍提供使用'search.date-format'属性对其进行自定义的选项。此属性接受SimpleDateFormat格式的日期/时间模式表达式。另外，从CXF 3.0.2开始，可以将LuceneQueryVisitor配置为使用Lucene分析器。使用分析器的原因是，在构建Lucene查询期间，访问者可以使用逐字段过滤器和标记器，同时考虑到词干，停顿世界，低空等，从而可以正确地处理过滤器表达式。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_4_9);

// Lower-case filter and stop-words filter are part of the StandardAnalyzer
SearchCondition&lt;SearchBean&gt; filter = new FiqlParser&lt;SearchBean&gt;(SearchBean.class).parse("contents==pears and APPLES");
LuceneQueryVisitor&lt;SearchBean&gt; lucene = new LuceneQueryVisitor&lt;SearchBean&gt;("contents", analyzer);
lucene.visit(filter);

org.apache.lucene.search.Query query = lucene.getQuery();</pre>
</div></div><p> </p><h3 id="JAX-RSSearch-LDAP">LDAP</h3><p>从CXF 2.7.1开始，借助org.apache.cxf.jaxrs.ext.search.ldap，支持将<a shape="rect" class="external-link" href="http://tools.ietf.org/html/rfc4515" rel="nofollow">RFC-4515</a>定义的FIQL / OData表达式映射到LDAP查询。LdapQueryVisitor。使用LDAP或OSGI时，请使用此访问者。</p><p>以下是LDAP过滤器运算符的摘要：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>操作员</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ =”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“！”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>不平等</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ <=”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>更少或相等</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“> =”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>大于或等于</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“＆”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>和</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“ |”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>要么</p></td></tr></tbody></table></div><p>FIQL“ = le =”和“ = lt =”都将映射到“ <=”，而“ = ge =”和“ = gt =”则映射到“> =”。</p><p>例如：</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>FIQL</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>LDAP</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“名称==栏*”</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>“（名称=栏*）”</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“名称！= bar“</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>“（！名称=栏）”</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“名称！= bar; id = gt = 10“</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>“（＆（！name = bar）（id> = 10））“</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>“名称！= bar;（id = gt = 10，id = lt = 5）“</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>“（＆（！name = bar）（|（id> = 10）（id <= 5）））“</p></td></tr></tbody></table></div><p>转换器与所有其他转换器一样创建：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// FIQL "oclass=Bar"

// map 'oclass' used in the FIQL query to the actual property name, 'objectClass'
LdapQueryVisitor&lt;Condition&gt; visitor = 
   new LdapQueryVisitor&lt;Condition&gt;(Collections.singletonMap("oclass", "objectClass"));

filter.accept(visitor.visitor());
String ldap = visitor.getQuery();
</pre>
</div></div><p>请注意， <a shape="rect" class="external-link" href="https://issues.apache.org/jira/browse/CXF-7701">自</a> CXF 3.2.5 <a shape="rect" class="external-link" href="https://issues.apache.org/jira/browse/CXF-7701">起</a> ，默认情况下对查询值进行编码，以防止可能的LDAP注入攻击。如果要支持从CXF 3.2.5起使用LdapQueryVisitor进行通配符搜索，则必须将LdapQueryVisitor的'encodeQueryValues'属性设置为'false'。</p><h3 id="JAX-RSSearch-HBase">HBase的</h3><p> </p><p>CXF 3.0.2引入了对查询HBase数据库的初始支持。请参阅<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/test/java/org/apache/cxf/jaxrs/ext/search/hbase/HBaseVisitorTest.java" rel="nofollow">此测试</a>以获取更多信息。</p><h3 id="JAX-RSSearch-Customvisitors">自订访客</h3><p>在必须进行自定义转换的情况下，可以提供用于执行无类型（例如SQL）或有类型（例如JPA2 TypedQuery）转换的转换器。</p><h4 id="JAX-RSSearch-Untypedconverters">无类型转换器</h4><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class CustomSQLVisitor&lt;T&gt; extends AbstractSearchConditionVisitor&lt;T, String&gt; {

    private String tableName;
    private StringBuilder sb = new StringBuilder();

    public void visit(SearchCondition&lt;T&gt; sc) {
        
        if (sb == null) {
            sb = new StringBuilder();
            // start the expression as needed, example
            // sb.append("Select from ").append(tableName);
        }
        
        PrimitiveStatement statement = sc.getStatement();
        if (statement != null) {
                // ex "a &gt; b"
                // use statement.getValue()
                // use statement.getConditionType() such as greaterThan, lessThan
                // use statement.getProperty();
                // to convert "a &gt; b" into SQL expression
                sb.append(toSQL(statement));         
        } else {
            // composite expression, ex "a &gt; b;c &lt; d"
            for (SearchCondition&lt;T&gt; condition : sc.getSearchConditions()) {
                // pre-process, example sb.append("(");
                condition.accept(this);
                // post-process, example sb.append(")");
            }
        }
    }

    public String getQuery() {
        return sb.toString();
    }
}
</pre>
</div></div><h4 id="JAX-RSSearch-Typedconverters">类型转换器</h4><p>导入org.custom.search。查询；</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class CustomTypedVisitor&lt;T&gt; extends AbstractSearchConditionVisitor&lt;T, Query&gt; {

    private Stack&lt;List&lt;Query&gt;&gt; queryStack = new Stack&lt;List&lt;Query&gt;&gt;();

    public void visit(SearchCondition&lt;T&gt; sc) {
                
        PrimitiveStatement statement = sc.getStatement();
        if (statement != null) {
                // ex "a &gt; b"
                // use statement.getValue()
                // use statement.getConditionType() such as greaterThan, lessThan
                // use statement.getProperty();
                // to convert "a &gt; b" into Query object
                Query query = buildSimpleQuery(statement);
                queryStack.peek().add(query);                 

        } else {
            // composite expression, ex "a &gt; b;c &lt; d"
            queryStack.push(new ArrayList&lt;Query&gt;());

            for (SearchCondition&lt;T&gt; condition : sc.getSearchConditions()) {
                condition.accept(this);
            }

            boolean orCondition = sc.getConditionType() == ConditionType.OR;
            List&lt;Query&gt; queries = queryStack.pop();
            queryStack.peek().add(createCompositeQuery(queries, orCondition));
        }
    }

    public Query getQuery() {
        return queryStack.peek().get(0);
    }
}
</pre>
</div></div><h4 id="JAX-RSSearch-Customparsing">自定义解析</h4><p>如果需要，您可以直接访问FIQL / OData查询，并将其进一步委托给您自己的自定义FIQL处理程序：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/search")
public class SearchEngine {
    @Context
    private UriInfo ui;

    @GET
    public List&lt;Book&gt; findBooks() {
        MultivaluedMap&lt;String, String&gt; params = ui.getQueryParameters();
        String query = params.getFirst("_s"); // or $filter, etc
        // delegate to your own custom handler 

        // note that the original search expression can also be retrieved 
        // using a SearchContext.getSearchExpression() method
}
</pre>
</div></div><h2 id="JAX-RSSearch-ConvertingthequerieswithQueryContext">使用QueryContext转换查询</h2><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/QueryContext.javahe/cxf/jaxrs/ext/search/QueryContext.java" rel="nofollow">QueryContext</a>是CXF 2.7.1中可用的帮助程序上下文，它使应用程序代码更易于使用<br clear="none">获取转换后的查询表达式，并将实际的转换器/访问者注册为jaxrs上下文属性，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.util.ArrayList;
import java.util.List;
import org.apache.cxf.jaxrs.JAXRSServerFactoryBean;
import org.apache.cxf.jaxrs.ext.search.QueryContextProvider;
import org.apache.cxf.jaxrs.ext.search.SearchBean;
import org.apache.cxf.jaxrs.ext.search.visitor.SBThrealLocalVisitorState;
import org.apache.cxf.jaxrs.ext.search.sql.SQLPrinterVisitor;

import books.BookStore;

// Register the visitor:
JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();
List&lt;Object&gt; providers = new ArrayList&lt;Object&gt;();
providers.add(new QueryContextProvider());
sf.setProviders(providers);

SQLPrinterVisitor&lt;SearchBean&gt; sqlVisitor = new SQLPrinterVisitor&lt;SearchBean&gt;("books");
sqlVisitor.setVisitorState(new SBThrealLocalVisitorState());
sf.getProperties(true).put("search.visitor", sqlVisitor);

sf.setResourceClasses(BookStore.class);
server = sf.create();
</pre>
</div></div><p>并转换查询：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/")
public class BookStore { 
    @GET
    @Path("/books/{expression}")
    @Produces("application/xml")
    public List&lt;Book&gt; getBookQueryContext(@PathParam("expression") String expression, 
                                      @Context QueryContext searchContext) 
        throws BookNotFoundFault {
        String sqlExpression = searchContext.getConvertedExpression(expression, Book.class);
        // pass it to the SQL DB and return the list of Books
    }
}
</pre>
</div></div><p>客户端代码如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">String address = "http://localhost:8080/bookstore/books/id=ge=123";
WebClient client = WebClient.create(address);
client.accept("application/xml");
List&lt;Book&gt; books = client.getCollection(Book.class);
</pre>
</div></div><p>注意，鉴于SQLPrinterVisitor将在多个请求之间共享，因此必须通过注入本地线程来使其成为线程安全的<br clear="none">org.apache.cxf.jaxrs.ext.search.visitor。SBThrealLocalVisitorState。在基于每个请求的代码中创建访问者时，这不是必需的。</p><p>预期为单例且状态在多个访问调用之间累积的自定义访问者必须是线程安全的。实用程序org.apache.cxf.jaxrs.ext.search.visitor。可以使用ThrealLocalVisitorState类。</p><h2 id="JAX-RSSearch-PlainqueriestoFIQLconversion">普通查询到FIQL转换</h2><p>如果您想概括搜索查询的处理并使用FIQL访问者，则可能需要考虑将上下文属性“ search.use.plain.queries”设置为“ true”，并将原始查询表达式转换为FIQL表达式内部。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// GET /search?a=a1&amp;a=v2
String exp = searchContext.getSearchExpression();
assertEquals("(a==a1,a==a2)", exp);

// GET /search?a=a1&amp;b=b1
exp = searchContext.getSearchExpression();
assertEquals("(a==a1;b==b1)", exp);
</pre>
</div></div><p>同样，默认情况下，如果查询属性名称以“ From”结尾，则将使用“ = ge =“（更大或等于），如果查询属性名称以“ Till”结尾，则将使用“ = lt =” ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// GET /search?ageFrom=10&amp;ageTill=20
String exp = searchContext.getSearchExpression();
assertEquals("(age=ge=10,age=le=20)", exp);
</pre>
</div></div><p>这可以允许将简单查询表达式映射到类型化的bean属性，并进一步与所有现有转换器一起使用。</p><h2 id="JAX-RSSearch-SearchExpressionsinURIPathsegments">URI路径段中的搜索表达式</h2><p>默认情况下，'_ s'或'_search'查询中期望FIQL表达式可用。<br clear="none">例如，“查找所有'id'属性值小于123的书”：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">GET /books?_s=id=lt=123
</pre>
</div></div><p>从CXF 2.6.2开始，可以使用URI路径段中包含的FIQL表达式，例如，可以表达相同的查询<br clear="none">通过多种方式：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">GET /books/id=lt=123
GET /books[id=lt=123]
GET /books(id=lt=123)
GET /books;id=lt=123

//etc, etc

</pre>
</div></div><p>可以使用JAX-RS批注在代码中捕获此类表达式：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /books[id=lt=123]
   @GET
   @Path("books[{search}]") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   //GET /books(id=lt=123)
   @GET
   @Path("books({search})") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   //GET /books/id=lt=123
   @GET
   @Path("books/{search}") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   //GET /books;id=lt=123
   @GET
   @Path("books;{search}") 
   public List&lt;Book&gt; findSelectedBooks(@PathParam("search") String searchExpression) {
       return doFindSelectedBooks(searchExpression);
   }

   public List&lt;Book&gt; doFindSelectedBooks(String searchExpression) {
       SearchCondition&lt;Book&gt; sc = context.getCondition(searchExpression, Book.class);
   
       // JPA2 enity manager is initialized earlier
       JPATypedQuery&lt;Book&gt; visitor = new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
       sc.accept(visitor);
   
       TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
       return typedQuery.getResultList();
   }

}
</pre>
</div></div><p>请注意，如果您将表达式添加到带有“;”的URI路径段中用作分隔符的字符，例如“ / books; id = lt = 123”，<br clear="none">或如果表达式本身包含“;”，例如“ / books [id = lt = 123; id = gt = 300]”（“查找所有ID小于123或大于300的书籍”）<br clear="none">然后必须为运行时将布尔上下文属性“ ignore.matrix.parameters”设置为“ true”，以避免将路径段分为路径值和矩阵参数。</p><h2 id="JAX-RSSearch-Queriesinvolvingmultipleentities">涉及多个实体的查询</h2><h3 id="JAX-RSSearch-Basicqueries">基本查询</h3><p>考虑一下这样的查询：“从'id'小于123的所有书籍中查找具有给定章节ID的章节”。<br clear="none">管理此类查询的一种简单方法是使FIQL和JAX-RS协同工作。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /books[id=lt=123]/chapter/1
   @GET
   @Path("books[{search}]/chapter/{id}") 
   public List&lt;Chapter&gt; findSelectedChapters(@PathParam("search") String searchExpression,
                                       @PathParam("id") int chapterIndex) {
       return doFindSelectedChapters(searchExpression, chapterIndex);
   }

   public List&lt;Chapter&gt; doFindSelectedChapters(String searchExpression, int chapterIndex) {
       SearchCondition&lt;Book&gt; sc = context.getCondition(searchExpression, Book.class);
   
       // JPA2 enity manager is initialized earlier
       JPATypedQuery&lt;Book&gt; visitor = new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
       sc.accept(visitor);
   
       TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
       List&lt;Book&gt; books = typedQuery.getResultList();

       List&lt;Chapter&gt; chapters = new ArrayList&lt;Chapter&gt;(books.size);
       for (Book book : books) {
           chapters.add(book.getChapter(chapterIndex)); 
       }   
       return chapters;
   }

}
</pre>
</div></div><h3 id="JAX-RSSearch-Complexqueries">复杂查询</h3><p>在上一节中，我们在查询中使用了两个实体Book和Chapter的属性。该查询被认为是“简单的”，因为实际上只检查了简单的书籍属性，而唯一的章节属性是章节ID，假定它等于章节列表索引。</p><p>考虑“为ID大于300的所有书籍查找ID小于5的所有章节”。</p><p>一种处理方法是遵循上一节中的示例，进行少量修改：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /books(id=gt=300)/chapters(id=lt=5)
   @GET
   @Path("books({search1})/chapter/{search2}") 
   public List&lt;Chapter&gt; findSelectedChapters(@PathParam("search1") String bookExpression,
                                       @PathParam("search2") String chapterExpression) {
       return doFindSelectedBooks(bookExpression, chapterExpression);
   }

   public List&lt;Chapter&gt; doFindSelectedChapters(String bookExpression, String chapterExpression) {
       // find the books first
       
       SearchCondition&lt;Book&gt; bookCondition = context.getCondition(searchExpression, Book.class);
   
       JPATypedQuery&lt;Book&gt; visitor = new JPATypedQueryVisitor&lt;Book&gt;(entityManager, Book.class);
       bookCondition.visit(visitor);
       TypedQuery&lt;Book&gt; typedQuery = visitor.getQuery();
       List&lt;Book&gt; books = typedQuery.getResultList();

       // now get the chapters
       SearchCondition&lt;Chapter&gt; chapterCondition = context.getCondition(chapterExpression, Chapter.class);
       List&lt;Chapter&gt; chapters = new ArrayList&lt;Chapter&gt;();
       for (Book book : books) {
           chapters.addAll(chapterCondition.findAll(book.getChapters()); 
       }   
       return chapters;
   }

}
</pre>
</div></div><p>在这种情况下，将创建两个条件，并使用第二个条件从第一个条件过滤的书籍中过滤章节。</p><p>也许更简单的方法（尤其是在JPA2的情况下）是立即开始查找Chapter，假设Chapter类与Book具有一对一的双向关系：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class Chapter {
   private int id;
   private Book book;

   @OneToOne(mappedBy="book")
   public Book getBook() {}
}

@Path("search")
public class BooksResource {
   @Context
   private SearchContext context;

   //GET /chapters(bookId=gt=300,id=lt=5)
   @GET
   @Path("chapters({search})") 
   public List&lt;Chapter&gt; findSelectedChapters(@PathParam("search") String chapterExpression) {
       
       SearchCondition&lt;Chapter&gt; chapterCondition = context.getCondition(chapterExpression, Chapter.class);
   
       JPATypedQuery&lt;Chapter&gt; visitor = new JPATypedQueryVisitor&lt;Chapter&gt;(entityManager, Chapter.class);
       chapterCondition.visit(visitor);
       TypedQuery&lt;Chapter&gt; typedQuery = visitor.getQuery();
       return typedQuery.getResultList();
   }

}
</pre>
</div></div><p>请注意，此代码假定借助上下文“ search.bean.property.map”属性将“ bookId”映射到“ Book.id”属性，如前所述。</p><h2 id="JAX-RSSearch-Validation">验证方式</h2><p>第一种选择是让一个捕获特定属性值的bean进行特定于域的验证。例如，Book.class可能具有其setName（String name）方法来验证名称值。<br clear="none">另一个选择是将自定义<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/visitor/PropertyValidator.java" rel="nofollow">验证器</a>注入到访问者中，该访问者用于构建无类型或有类型的查询。</p><p>最后，避免让用户使用其属性值无法在应用程序代码中得到很好验证的属性。使用诸如Book.class之类的类型化捕获bean提供了一个完美的选择，将一些受支持的属性限制为已知与Book相关的属性。</p><p>也可以使用Bean Validation 1.1。</p><h2 id="JAX-RSSearch-Buildingthequeries">建立查询</h2><h3 id="JAX-RSSearch-FIQL">FIQL</h3><p>CXF 2.4.0引入了<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/client/SearchConditionBuilder.java" rel="nofollow">SearchConditionBuilder</a> ，它使构建FIQL查询变得更加简单。SearchConditionBuilder是抽象类，默认情况下返回FIQL构建器：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SearchConditionBuilder b = SearchConditionBuilder.instance();
String fiqlQuery = b.is("id").greaterThan(123).query();

WebClient wc = WebClient.create("http://books.com/search");
wc.query("_s", fiqlQuery);
// find all the books with id greater than 123 
Collection books = wc.getCollection(Book.class);
</pre>
</div></div><p>这是构建更复杂查询的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// OR condition
String ret = b.is("foo").greaterThan(20).or().is("foo").lessThan(10).query();
assertEquals("foo=gt=20,foo=lt=10", ret);

// AND condition
String ret = b.is("foo").greaterThan(20).and().is("bar").equalTo("plonk").query();
assertEquals("foo=gt=20;bar==plonk", ret);

// Complex condition
String ret = b.is("foo").equalTo(123.4).or().and(
            b.is("bar").equalTo("asadf*"), 
            b.is("baz").lessThan(20)).query();
assertEquals("foo==123.4,(bar==asadf*;baz=lt=20.0)", ret);
</pre>
</div></div><p>请注意，从CXF 2.7.1开始，可以使用以下内容简化连接多个基本表达式的过程：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// AND condition, '.and("bar")' is a shortcut for "and().is("bar")", similar shortcut is supported for 'or'
String ret = b.is("foo").greaterThan(20).and("bar").equalTo("plonk").query();
assertEquals("foo=gt=20;bar==plonk", ret);
</pre>
</div></div><p>可以在主干上获得对构建器API的更多更新：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// OR condition
String ret = b.is("foo").equalTo(20).or().is("foo").equalTo(10).query();
assertEquals("foo==20,foo==10", ret);

// Same query, shorter expression
String ret = b.is("foo").equalTo(20, 10).query();
assertEquals("foo==20,foo==10", ret);
</pre>
</div></div><p>和</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Connecting composite or() and and() expressions will add "()" implicitly:
String ret = b.is("foo").equalTo(20, 10).and("bar").lessThan(10).query();
assertEquals("(foo==20,foo==10);bar=lt=10", ret);

// wrap() method can be used to wrap explicitly:

String ret = b.is("foo").equalTo(10).and("bar").lessThan(10).wrap().or("bar").greaterThan(25).query();
assertEquals("(foo==20;bar=lt=10),bar=gt=25", ret);
</pre>
</div></div><p> </p><h2 id="JAX-RSSearch-Usingdatesinqueries">在查询中使用日期</h2><p>默认情况下，日期值必须具有以下<a shape="rect" class="external-link" href="http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html" rel="nofollow">格式</a> ：“ yyyy-MM-dd”，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_search=date=le=2010-03-11
</pre>
</div></div><p>可以支持自定义日期格式。使用“ search.date-format”上下文属性，例如，“ search.date-format” =“ yyyy-MM-dd'T'HH：mm：ss”将使用户键入：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_search=time=le=2010-03-11T18:00:00
</pre>
</div></div><p>如果需要，可以启用“ search.timezone.support”以获取受支持的时区。</p><p>目前，要使SearchConditionBuilder能够识别自定义日期格式，必须显式创建FIQLSearchConditionBuilder：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
props.put("search.date-format", "yyyy-MM-dd'T'HH:mm:ss");
props.put("search.timezone.support", "false");

Date d = df.parse("2011-03-01 12:34:00");
        
FiqlSearchConditionBuilder bCustom = new FiqlSearchConditionBuilder(props);
        
String ret = bCustom.is("foo").equalTo(d).query();
assertEquals("foo==2011-03-01T12:34:00", ret);
</pre>
</div></div><div class="action-body flooded"><p> </p><h3 id="JAX-RSSearch-Relativedates">相对日期</h3><p>日期值可以指定为从当前日期/时间开始的持续时间，其字符串表示形式为“ PnYnMnDTnHnMnS”。<br clear="none">结果日期将计算为当前日期+指定的持续时间。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">?_search=date=ge=-P90D
</pre>
</div></div><p> </p><p>此查询将搜索过去90天或更晚的日期。</p></div><h2 id="JAX-RSSearch-Alternativequerylanguages">替代查询语言</h2><p>自定义org.apache.cxf.jaxrs.ext.search。从CXF 3.0.0-milestone2开始，可以将SearchConditionParser实现注册为“ search.parser”上下文属性。</p><h3 id="JAX-RSSearch-OData">数据</h3><p> </p><p>请使用“ search.query.parameter.name”上下文属性向运行时指示，需要为查询表达式检查OData'$ filter'查询选项，并使用“ search.parser”属性指向以下实例： org.apache.cxf.jaxrs.ext.search.odata。如此<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSClientServerODataSearchTest.java">测试中</a>所示，请参见ODataParser，请参见startServers函数。</p><p>这也是一个XML Spring配置示例（在此特定情况下使用SearchBean）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> &lt;cxf:bus&gt;
  &lt;cxf:properties&gt;
    &lt;entry key="search.query.parameter.name" value="$filter" /&gt;
    &lt;entry key="search.parser"&gt;
      &lt;bean class="org.apache.cxf.jaxrs.ext.search.odata.ODataParser"&gt;
         &lt;constructor-arg value="#{ T(org.apache.cxf.jaxrs.ext.search.SearchBean) }" /&gt;
   &#160;  &lt;/bean&gt;
    &lt;/entry&gt;
  &lt;/cxf:properties&gt;
&lt;/cxf:bus&gt;
&#160;</pre>
</div></div><p> </p><p>还要注意， <a shape="rect" class="external-link" href="http://olingo.incubator.apache.org/">Apache Olingo</a>提供了自己的访问者模型，该模型可用于JPA2等。</p><h2 id="JAX-RSSearch-ContentExtraction">内容提取</h2><p>从CXF 3.0.2开始，添加了内容提取支持，以通过从各种文档格式（PDF，ODF，DOC，TXT，RTF等）中提取文本来补充搜索功能。它基于Apache Tika，有两种形式：原始内容提取（TikaContentExtractor）和Lucene文档内容提取（TikaLuceneContentExtractor）。</p><h3 id="JAX-RSSearch-UsingTikaContentExtractor">使用TikaContentExtractor</h3><p>Tika内容提取器的目的是为从支持的文档格式中提取文本提供必要的支持。此外，还根据文档格式（作者，修改，创建，页面等）提取元数据。TikaContentExtractor接受支持的解析器列表，并将提取的元数据与所需的提取内容格式（默认为原始文本）一起返回。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">TikaContentExtractor extractor = new TikaContentExtractor(new PDFParser(), true);
TikaContent content = extractor .extract( Files.newInputStream( new File( "testPDF.pdf" ).toPath() ) );</pre>
</div></div><p>默认情况下，TikaContentExtractor还执行内容类型检测和验证，可以使用“ validateMediaType”构造函数参数将其关闭。</p><h3 id="JAX-RSSearch-UsingTikaLuceneContentExtractor">使用TikaLuceneContentExtractor</h3><p>TikaLuceneContentExtractor与TikaContentExtractor非常相似，但是它返回原始的Lucene文档，而不是原始内容和元数据。但是，为了正确创建准备索引的Lucene文档，TikaLuceneContentExtractor接受带有字段类型和类型转换器的附加参数LuceneDocumentMetadata。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">LuceneDocumentMetadata documentMetadata = new LuceneDocumentMetadata("contents").withField("modified", Date.class);
TikaLuceneContentExtractor extractor = new TikaLuceneContentExtractor(new PDFParser(), true);
Document document = extractor.extract( Files.newInputStream( new File( "testPDF.pdf" ).toPath() ), documentMetadata  );</pre>
</div></div><p>此时，该文档已准备好进行分析和索引。TikaLuceneContentExtractor使用LuceneDocumentMetadata创建正确键入的文档字段，当前支持DoubleField，FloatField，LongField，IntField，IntField，TextField（用于内容）和StringField（也用于存储日期）。</p><p>为了演示CXF 3.0.2内容提取和搜索功能的全部功能，已开发了演示项目“ jax_rs_search”并将其分发到样本包中。该项目可以在<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/search" rel="nofollow">官方的Apache CXF Github存储库中找到</a> 。它将Apache CXF，Apache Lucene和Apache Tika集成在一起，展示了一些与自定义分析器和不同过滤条件（关键字和短语搜索）相关的高级功能。</p><pre>&#160;</pre></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=30748414">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=30748414&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>