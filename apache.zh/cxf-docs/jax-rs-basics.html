<html ><head></head><body  onload="init()">﻿

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Basics">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS基础</title>
  



<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-basics.html">JAX-RS基础</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><br clear="none"></p><p><br clear="none"><span style="font-size:2em;font-weight:bold">JAX-RS：了解基础</span>


<br clear="none"></p><p><br clear="none"></p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1568408164326 {padding: 0px;}
div.rbtoc1568408164326 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1568408164326 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1568408164326">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-WhatisNewinJAX-RS2.1">JAX-RS 2.1的新增功能</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-ReactiveClientAPI">反应性客户端API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-CompletionStage">完成阶段</a></li><li><a shape="rect" href="#JAX-RSBasics-RxJava">RxJava的</a></li><li><a shape="rect" href="#JAX-RSBasics-RxJava2">RxJava2</a></li><li><a shape="rect" href="#JAX-RSBasics-ProjectReactor">项目反应堆</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-CompletableFutureasamethodreturnvalue">CompletableFuture作为方法的返回值</a></li><li><a shape="rect" href="#JAX-RSBasics-ServerSentEvents">服务器发送事件</a></li><li><a shape="rect" href="#JAX-RSBasics-SubResourcesasClasses">子资源作为类</a></li><li><a shape="rect" href="#JAX-RSBasics-CXFNIOExtension">CXF NIO扩展</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-WhatisNewinJAX-RS2.0">JAX-RS 2.0的新增功能</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-Filters">筛选器</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-Server">服务器</a></li><li><a shape="rect" href="#JAX-RSBasics-Client">客户</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-Interceptors">拦截器</a></li><li><a shape="rect" href="#JAX-RSBasics-DynamicFeatures">动态功能</a></li><li><a shape="rect" href="#JAX-RSBasics-Exceptions">例外情况</a></li><li><a shape="rect" href="#JAX-RSBasics-Suspendedinvocations">暂停的调用</a></li><li><a shape="rect" href="#JAX-RSBasics-Parameterconverters">参数转换器</a></li><li><a shape="rect" href="#JAX-RSBasics-Beanparameters">Bean参数</a></li><li><a shape="rect" href="#JAX-RSBasics-ResourceInfo">资源信息</a></li><li><a shape="rect" href="#JAX-RSBasics-Injectionintosubresources">注入子资源</a></li><li><a shape="rect" href="#JAX-RSBasics-Updatestothematchingalgorithm">更新匹配算法</a></li><li><a shape="rect" href="#JAX-RSBasics-Link">链接</a></li><li><a shape="rect" href="#JAX-RSBasics-ClientAPI">客户端API</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-Resourceclass">资源类别</a></li><li><a shape="rect" href="#JAX-RSBasics-@Path">@路径</a></li><li><a shape="rect" href="#JAX-RSBasics-HTTPMethod">HTTP方法</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-DefaultHttpMethod">默认Http方法</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-Returntypes">退货类型</a></li><li><a shape="rect" href="#JAX-RSBasics-ResponseStreaming">响应流</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-JAX-RSStreamingOutput">JAX-RS流输出</a></li><li><a shape="rect" href="#JAX-RSBasics-CXFStreamingResponse">CXF StreamingResponse</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-Exceptionhandling">异常处理</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-MappingexceptionsthrownfromCXFinterceptors">映射从CXF拦截器引发的异常</a></li><li><a shape="rect" href="#JAX-RSBasics-CustomizingdefaultWebApplicationExceptionmapper">自定义默认的WebApplicationException映射器</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-DealingwithParameters">处理参数</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-Parameterbeans">参数bean</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-Resourcelifecycles">资源生命周期</a></li><li><a shape="rect" href="#JAX-RSBasics-Overviewoftheselectionalgorithm.">选择算法概述。</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-Selectingbetweenmultipleresourceclasses">在多个资源类别之间选择</a></li><li><a shape="rect" href="#JAX-RSBasics-Selectingbetweenmultipleresourcemethods">在多种资源方法之间选择</a></li><li><a shape="rect" href="#JAX-RSBasics-Resourcemethodsandmediatypes">资源方法和媒体类型</a></li><li><a shape="rect" href="#JAX-RSBasics-Customselectionbetweenmultipleresourcesoroperations">在多个资源或操作之间进行自定义选择</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-Contextannotations">上下文注释</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-CustomContexts">自定义上下文</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-URIcalculationusingUriInfoandUriBuilder">使用UriInfo和UriBuilder进行URI计算</a></li><li><a shape="rect" href="#JAX-RSBasics-Annotationinheritance">注释继承</a></li><li><a shape="rect" href="#JAX-RSBasics-Sub-resourcelocators.">子资源定位器。</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-Staticresolutionofsubresources">子资源的静态解析</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-MessageBodyProviders">邮件正文提供者</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSBasics-CustomMessageBodyProviders">自定义消息正文提供者</a></li><li><a shape="rect" href="#JAX-RSBasics-Registeringcustomproviders">注册自定义提供程序</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSBasics-Customizingmediatypesformessagebodyproviders">自定义消息正文提供者的媒体类型</a></li><li><a shape="rect" href="#JAX-RSBasics-AdvancedHTTP">进阶HTTP</a></li></ul>
</div><h1 id="JAX-RSBasics-WhatisNewinJAX-RS2.1">JAX-RS 2.1的新增功能</h1><h2 id="JAX-RSBasics-ReactiveClientAPI">反应性客户端API</h2><p>JAX-RS 2.1引入了<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/blob/master/jaxrs-api/src/main/java/javax/ws/rs/client/RxInvoker.java" rel="nofollow">RxInvoker</a> ，它可以帮助从异步客户端代码中删除<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/blob/master/jaxrs-api/src/main/java/javax/ws/rs/client/InvocationCallback.java" rel="nofollow">InvocationCallback</a> 。</p><h3 id="JAX-RSBasics-CompletionStage">完成阶段</h3><p>可以通过<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/blob/master/jaxrs-api/src/main/java/javax/ws/rs/client/RxInvoker.java" rel="nofollow">Invocation.rx（）</a>访问默认的<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/blob/master/jaxrs-api/src/main/java/javax/ws/rs/client/CompletionStageRxInvoker.java" rel="nofollow">CompletionStageRxInvoker</a> 。</p><h3 id="JAX-RSBasics-RxJava">RxJava的</h3><p>定制<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/blob/master/jaxrs-api/src/main/java/javax/ws/rs/client/RxInvokerProvider.java" rel="nofollow">RxInvokerProvider</a>可以作为提供者在客户端注册。CXF提供了这样的三个自定义提供程序org.apache.cxf.jaxrs.rx.client。ObservableRxInvokerProvider（RxJava1），</p><p>org.apache.cxf.jaxrs.rx2.client。ObservableRxInvokerProvider（RxJava2）和org.apache.cxf.jaxrs.rx2.client。FlowableRxInvokerProvider（RxJava2）。</p><p>向客户端注册它可以通过执行<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/blob/master/jaxrs-api/src/main/java/javax/ws/rs/client/Invocation.java#L312" rel="nofollow">Invocation.rx（Class <t>clazz）</t></a>来使用RxJava1 Observable或RxJava2 Observable或Flowable，例如，</p><p>Invocation.rx（org.apache.cxf.jaxrs.rx2.client。FlowableRxInvoker.class）等</p><p>有关更多信息，请参见<a shape="rect" href="jax-rs-rxjava.html">JAX-RS RxJava</a> 。</p><h3 id="JAX-RSBasics-RxJava2">RxJava2</h3><p>注册后，RxJava2可用作rx类型。有关完整信息，请参见<a shape="rect" href="jax-rs-rxjava.html">JAX-RS RxJava</a> 。</p><h3 id="JAX-RSBasics-ProjectReactor">项目反应堆</h3><p>注册时可以将Project Reactor用作rx类型。请参阅<a shape="rect" href="jax-rs-project-reactor-support.html">JAX-RS Project Reactor支持</a>以获取完整信息。</p><h2 id="JAX-RSBasics-CompletableFutureasamethodreturnvalue">CompletableFuture作为方法的返回值</h2><p>在JAX-RS 2.1中，可以从资源方法返回CompletableFuture（或CompletionStage），而不必直接处理JAX-RS AsyncResponse API。</p><p>有关返回RxJava Observable的更多信息，请参见<a shape="rect" href="jax-rs-rxjava.html">JAX-RS RxJava</a> 。</p><h2 id="JAX-RSBasics-ServerSentEvents">服务器发送事件</h2><p>JAX-RS 2.1为<a shape="rect" class="external-link" href="https://en.wikipedia.org/wiki/Server-sent_events" rel="nofollow">SSE</a>提供了<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/tree/master/examples/src/main/java/jaxrs/examples/sse" rel="nofollow">全面的支持</a> 。</p><p>org.apache.cxf / cxf-rt-rs-sse / 3.2.0依赖项将需要添加。CXF SSE实施当前取决于Atmosphere。</p><h2 id="JAX-RSBasics-SubResourcesasClasses">子资源作为类</h2><p>有时子资源可能需要让他们获得请求上下文信息。一种有效而简单的方法是将这些上下文从实例化子资源的父类传递给它们，但是有时这种方法不起作用。</p><p>在JAX-RS 2.0中，可以在运行时使用<a shape="rect" class="external-link" href="https://github.com/jax-rs/api/blob/master/jaxrs-api/src/main/java/javax/ws/rs/container/ResourceContext.java" rel="nofollow">ResourceContext</a>实例化子资源实例，并在需要时负责注入上下文。JAX-RS 2.1引入了一种捷径，其中从子资源定位器方法返回子资源类，并在运行时确定该类并在需要时注入上下文</p><h2 id="JAX-RSBasics-CXFNIOExtension">CXF NIO扩展</h2><p>有关此CXF 3.2.0扩展的更多信息，请参见<a shape="rect" href="jax-rs-nio.html">JAX-RS NIO</a> ，该扩展基于早期的JAX-RS 2.1 API原型。</p><h1 id="JAX-RSBasics-WhatisNewinJAX-RS2.0">JAX-RS 2.0的新增功能</h1><h2 id="JAX-RSBasics-Filters">筛选器</h2><h3 id="JAX-RSBasics-Server">服务器</h3><p><a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/ContainerRequestFilter.html" rel="nofollow">ContainerRequestFilter</a>和<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/ContainerResponseFilter.html" rel="nofollow">ContainerResponseFilter</a>是新的服务器端请求和响应过滤器，可用于自定义给定请求和响应的各种属性。</p><p>在运行时将请求与特定的JAX-RS根资源和方法进行匹配之前，将运行带有<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/PreMatching.html" rel="nofollow">PreMatching</a>注释的ContainerRequestFilter。预匹配过滤器可用于影响匹配过程。</p><p>不选择PreMatching注释的请求过滤器将在选择JAX-RS资源方法之后运行。</p><p>ContainerRequestFilter可用于<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/ContainerRequestContext.html#abortWith(javax.ws.rs.core.Response)" rel="nofollow">阻止</a>请求。</p><p>只能在自定义<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/NameBinding.html" rel="nofollow">NameBinding</a>的帮助下将过滤器绑定到单个资源方法。</p><p>可以使用javax.annotation以特定顺序执行多个请求和响应过滤器。优先注释。有关更多信息，请参见<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/Priorities.html" rel="nofollow">优先级</a> 。请求过滤器按升序排序，响应过滤器-降序排序。</p><h3 id="JAX-RSBasics-Client">客户</h3><p><a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/client/ClientRequestFilter.html" rel="nofollow">ClientRequestFilter</a>和<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/client/ClientResponseFilter.html" rel="nofollow">ClientResponseFilter</a>是新的客户端请求和响应过滤器，可用于自定义给定请求和响应的各种属性。</p><p>ClientRequestFilter可用于<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/client/ClientRequestContext.html#abortWith(javax.ws.rs.core.Response)" rel="nofollow">阻止</a>请求。</p><p>请求过滤器按升序排序，响应过滤器-降序排序。有关更多信息，请参见<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/Priorities.html" rel="nofollow">优先级</a> 。</p><h2 id="JAX-RSBasics-Interceptors">拦截器</h2><p>除了过滤器外，还可以使用<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/ext/ReaderInterceptor.html" rel="nofollow">ReaderInterceptor</a>和<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/ext/WriterInterceptor.html" rel="nofollow">WriterInterceptor</a>单独使用它自定义服务器和客户端上的请求和响应。</p><p>拦截器可用于自定义读取/写入过程并阻止JAX-RS MessageBodyWriter或MessageBodyReader提供程序。</p><p>仅在自定义<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/NameBinding.html" rel="nofollow">NameBinding</a>的帮助下，才能将服务器端使用的拦截器绑定到各个资源方法。</p><p>所有拦截器均按升序排序。有关更多信息，请参见<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/Priorities.html" rel="nofollow">优先级</a> 。</p><h2 id="JAX-RSBasics-DynamicFeatures">动态功能</h2><p><a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/DynamicFeature.html" rel="nofollow">动态功能</a>是服务器端的功能，可用于将请求和响应筛选器以及读取器和写入器拦截器附加到特定资源方法。这是使用NameBindings的一种替代方法，它提供了对绑定过程的更细粒度的控制。</p><h2 id="JAX-RSBasics-Exceptions">例外情况</h2><p>引入了表示各种HTTP错误或重定向条件的专用异常类，请参见“ javax.ws.rs”包<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/package-frame.html" rel="nofollow">异常部分</a> 。</p><p>例如，与其抛出“新的WebApplicationException（404）”，不如抛出“新的NotFoundException（）”。细粒度的异常层次结构允许对异常映射器的细粒度支持。它还提供了一种在客户端捕获HTTP异常时检查WebApplicationException及其所有子类的方法。</p><p>请注意，在客户端，ProcessingException可用于捕获与客户端相关的异常，而ResponseProcessingException可用于缩小与处理响应消息特别相关的客户端异常。</p><h2 id="JAX-RSBasics-Suspendedinvocations">暂停的调用</h2><p>最佳的JAX-RS 2.0功能之一是对服务器端异步调用的支持。请参阅<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/AsyncResponse.html" rel="nofollow">AsyncResponse</a>文档，其中提供了有关此功能的很好的概述。</p><p>另请参阅此<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/BookContinuationStore.java" rel="nofollow">测试资源</a> 。</p><p>通常，接受AsyncResponse的资源方法将存储它并启动一个新线程以完成请求，该方法将返回并调用将被挂起，然后是另一个线程（发起内部作业的线程或其他线程）将恢复暂停的呼叫。请注意，在这种情况下，调用将无限期地暂停，直到恢复为止。</p><p>另一种方法是使AsyncResponse仅在有限的时间内暂停，并注册一个<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/TimeoutHandler.html" rel="nofollow">TimeoutHandler</a> 。超时到期后，当容器恢复调用时，将调用后者，并且处理程序将完成调用或再次将其挂起，直到准备完成为止。</p><p>可以向AsyncResponse注册<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/CompletionCallback.html" rel="nofollow">CompletionCallback</a> ，以在异步响应已发送回时接收通知。</p><p>从CXF 3.0.0-milestone2开始支持<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/ConnectionCallback.html" rel="nofollow">ConnectionCallback</a> 。</p><p>此功能可以帮助开发人员编写非常复杂的异步应用程序。</p><p>另请参阅有关CXF <a shape="rect" href="continuations.html">Continuations</a> API的页面，该页面基于JAX-RS 2.0 AsyncResponse实现，并且<br clear="none"><a shape="rect" href="http://cxf.apache.org/docs/servlet-transport.html">如何配置</a> CXFServlet。</p><h2 id="JAX-RSBasics-Parameterconverters">参数转换器</h2><p>当处理表示URI部分或标头或表单元素的JAX-RS参数并且默认转换机制不起作用时，可以使用<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/ext/ParamConverterProvider.html" rel="nofollow">ParamConverterProvider</a>在服务器和客户端上管理自定义对象到String的转换，反之亦然。例如，java.util。接受String的日期构造函数可能必须替换为自定义的ParamConverter。</p><h2 id="JAX-RSBasics-Beanparameters">Bean参数</h2><p><a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/BeanParam.html" rel="nofollow">BeanParam</a>可用于获取JAX-RS参数，这些参数表示URI部分或标头或表单元素，以及上下文注入到单个bean容器中。</p><p>请注意，支持注入特定JAX-RS类型的所有参数（例如QueryParam（“”）MyBean）的CXF扩展是不同的，它仅允许获取所有注入的查询参数，但是它也不要求bean属性带有QueryParam / etc注释。</p><h2 id="JAX-RSBasics-ResourceInfo">资源信息</h2><p><a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/ResourceInfo.html" rel="nofollow">ResourceInfo</a>是一个新的JAX-RS上下文，可以将其注入到过滤器和拦截器中，并检查将要调用的资源类和方法。</p><h2 id="JAX-RSBasics-Injectionintosubresources">注入子资源</h2><p>子资源可以得到JAX-RS上下文直接注射到他们的帮助下领域<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/container/ResourceContext.html" rel="nofollow">ResourceContext</a> 。</p><p>在可能的情况下，让父资源通过设置器或构造函数将上下文注入给定的子资源实例中，可以提供更简单的选择。</p><h2 id="JAX-RSBasics-Updatestothematchingalgorithm">更新匹配算法</h2><p>如果多个根资源类具有相同的Path值，则JAX-RS 2.0支持正确的资源方法选择，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/")
public class Root1 {
   @Path("/1")
   @GET 
   public Response get() {...}
}

@Path("/")
public class Root2 {
   @Path("/2")
   @GET 
   public Response get() {...}
}
</pre>
</div></div><p>在JAX-RS 1.1中，不能保证具有URI（例如“ / 1”）的请求被匹配，并且在CXF 2.7.x或更早版本中，需要使用CXF特定的ResourceComparator来确保选择Root1及其get（）方法。在CXF 3.0.0中，将始终正确选择Root1 get（）。注意即使在CXF 3.0.0中，ResourceComparator在某些情况下仍然可能会有所帮助。</p><h2 id="JAX-RSBasics-Link">链接</h2><p><a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/core/Link.html" rel="nofollow">Link</a>是一个实用程序类，用于将HTTP链接构建为HTTP Link标头或应用程序数据链接。<br clear="none">UriInfo，UriBuilder，Response和ResponseBuilder类已得到增强，以支持Link。</p><h2 id="JAX-RSBasics-ClientAPI">客户端API</h2><p>JAX-RS 2.0客户端API已在CXF 3.0.0中完全实现，请参阅<a shape="rect" href="http://cxf.apache.org/docs/jax-rs-client-api.html#JAX-RSClientAPI-JAXRS2.0ClientAPI">客户端API页面</a>以获取更多信息。</p><h1 id="JAX-RSBasics-Resourceclass">资源类别</h1><p>资源类是用JAX-RS注释注释的Java类，以表示Web资源。有两种类型的资源类：根资源类和子资源类。根资源类至少带有@Path注释，而子资源类通常没有根@Path值。JAX-RS中典型的根资源类如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package demo.jaxrs.server;

import java.util.HashMap;
import java.util.Map;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Response;

@Path("/customerservice/")
@Produces("application/xml")
public class CustomerService {

    public CustomerService() {
    }

    @GET
    public Customers getCustomers() {
        ......
    }

    @GET
    @Path("/customers/{id}")
    @Produces("application/json")
    public Customer getCustomer(@PathParam("id") String id) {
        ......
    }

    @PUT
    @Path("/customers/{id}")
    @Consumes("application/xml")
    public Response updateCustomer(@PathParam("id") Long id, Customer customer) {
        ......
    }

    @POST
    @Path("/customers")
    public Response addCustomer(Customer customer) {
        ......
    }

    @DELETE
    @Path("/customers/{id}/")
    public Response deleteCustomer(@PathParam("id") String id) {
        ......
    }

    @Path("/orders/{orderId}/")
    public Order getOrder(@PathParam("orderId") String orderId) {
       ......
    }
}
</pre>
</div></div><p>客户资源类可以处理从/ customerservice开始的请求。当/ customerservice请求与此类匹配时，将选择其getCustomers（）方法。 updateCustomer（），deleteCustomer（）和addCustomer（）用于处理从/ customerservice / customer开始的POST，PUT和DELETE请求，而getOrder（）方法将对/ customerservice / orders / 1之类的请求的处理委托给子资源定位器Order 。</p><p>@Produces批注用于指定响应的格式。当resource方法不可用时，它是从类继承的；如果在类上不可用，则它是从相应的消息正文编写器（如果有）继承的。默认值为* / *，但是建议您指定一些确定的值。这同样适用于@Consumes，只是将邮件正文<em>阅读器</em>作为最后的选择。</p><p>例如，getCustomers（）方法从其类继承@Produces批注，而getCustomer（）方法将其自己的值覆盖。</p><h1 id="JAX-RSBasics-@Path">@路径</h1><p>@Path批注应用于资源类或方法。@Path批注的值是相对URI路径，并且遵循URI模板格式，并且可以包含任意正则表达式。当资源方法不可用时，它是从类继承的。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customers/{id}")
public class CustomerResource {

    @GET
    public Customer getCustomer(@PathParam("id") Long id) {
        ......
    }

    @GET
    @Path("/order/{orderid}")
    public Order getOrder(@PathParam("id") Long customerId, @PathParam("orderid") Long orderId) {
        ......
    }

    @GET
    @Path("/order/{orderid}/{search:.*}")
    public Item findItem(@PathParam("id") Long customerId, 
                         @PathParam("orderid") Long orderId,
                         @PathParam("search") String searchString,
                         @PathParam("search") List&lt;PathSegment&gt; searchList) {
        ......
    }
}

</pre>
</div></div><p>此示例与上面的示例相似，但是它还显示了作为{@Path根表达式的一部分指定的{id}模板变量已由资源方法重用，而自定义正则表达式由findItem（）方法指定（注意变量名称与实际表达式之间用'：'分隔）。</p><p>在此示例中，findItem（）方法将为“ GET / customers / 1 / order / 2 / price / 2000 / weight / 2”之类的请求提供服务。<br clear="none">List <pathsegment>可以用于获取正则表达式捕获的“ price / 2000 / weight / 2”中的所有路径段。</pathsegment></p><p>可以从<a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=311" rel="nofollow">JAX-RS规范</a>第2.3节中找到有关路径注释的更多信息。</p><h1 id="JAX-RSBasics-HTTPMethod">HTTP方法</h1><p>JAX-RS规范定义了许多注释，例如@ GET，@ PUT，@ POST和@DELETE。使用@HttpMethod指示符，可以创建自定义注释，例如@Update或@Patch。例如 ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package org.apache.cxf.customverb;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@HttpMethod("PATCH")
public @interface PATCH { 
}
</pre>
</div></div><h2 id="JAX-RSBasics-DefaultHttpMethod">默认Http方法</h2><p>CXF 3.0.4引入了一个新的扩展名org.apache.cxf.jaxrs.ext。DefaultMethod批注。它可用于匹配单个资源方法上的任意HTTP方法。这可以用于某些高级方案中，以将CXF JAX-RS运行时集成到非JAX-RS环境中，以及在给定路径段列出所有HTTP方法很困难/困难的情况下。CXF用户需要注意，使用此选项将导致不可移植的JAX-RS代码。</p><p><br clear="none"></p><h1 id="JAX-RSBasics-Returntypes">退货类型</h1><p>要么是javax.ws.rs.core。可以返回响应或自定义类型。 javax.ws.rs.core。响应可用于设置HTTP响应代码，标头和实体。JAX-RS MessageBodyWriters（请参见下文）负责序列化响应实体，这些响应实体是直接返回或作为javax.ws.rs.core的一部分返回的。响应。</p><h1 id="JAX-RSBasics-ResponseStreaming">响应流</h1><h2 id="JAX-RSBasics-JAX-RSStreamingOutput">JAX-RS流输出</h2><p><a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.0/javax/ws/rs/core/StreamingOutput.html" rel="nofollow">StreamingOutput</a>可用于将数据流传输到客户端，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/books/pdf")
@Produces("application/pdf")
public StreamingOutput getPdf() {
    return new StreamingOutput() {
        public void write(final OutputStream os) {
           // read chunks of data from PDF and write to OutputStream
        } &#160;
    };
}
</pre>
</div></div><h2 id="JAX-RSBasics-CXFStreamingResponse">CXF StreamingResponse</h2><p>CXF 3.0.0引入了<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/StreamingResponse.java" rel="nofollow">StreamingResponse</a>扩展。它可以与WebSocket传输一起使用，或者可以替代使用<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.1/javax/ws/rs/core/StreamingOutput.html" rel="nofollow">StreamingOutput</a>的代码。</p><p>例如，考虑到一些可用资源需要返回：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/books")
@Produces("application/xml")
public StreamingResponse&lt;Book&gt; getBooks() {
    return new StreamingResponse&lt;Book&gt;() {
        public void writeTo(final Writer&lt;Book&gt; writer) {
           writer.getEntityStream().write("&lt;Books&gt;".getBytes());
           writer.write(new Book("CXF"));
           writer.write(new Book("JAX-RS"));
           writer.getEntityStream().write("&lt;/Books&gt;".getBytes());
        } &#160;
    };
}
</pre>
</div></div><h1 id="JAX-RSBasics-Exceptionhandling">异常处理</h1><p>可以抛出未经检查的WebApplicationException或返回带有正确错误代码集的Response。<br clear="none">如果不能将JAX-RS类型添加到方法签名中，则前一种方法可能会更好。</p><p>例如 ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customerservice/")
public class CustomerService {

    
    @PUT
    @Path("/customers/{id}")
    public Response updateCustomer(@PathParam("id") Long id, Customer customer) {
        return Response.status(errorCode).build();
    }

    @POST
    @Path("/customers")
    public Customer addCustomer(Customer customer) {
        throw new WebApplicationException(errorCode);
    }

}
</pre>
</div></div><p>另一个选择是注册ExceptionMapper提供程序。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public BookExceptionMapper implements ExceptionMapper&lt;BookException&gt; {
    public Response toResponse(BookException ex) {
        // convert to Response
    }
}
</pre>
</div></div><p>这允许从应用程序代码引发已检查或运行时异常，并将其映射到注册提供程序中的HTTP响应。</p><p>请查看<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/SecurityExceptionMapper.java">此异常映射器</a> ， <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/SecurityExceptionMapper.java">该映射器</a>将Spring Security异常转换为HTTP 403错误代码作为另一个示例。</p><p>请注意，如果未找到针对自定义异常的映射器，则它们将按照规范要求传播到基础容器，在该容器中通常将它们包装在ServlerException中，最终导致默认情况下返回HTTP 500状态。因此，拦截异常的一种方法是注册一个自定义servlet过滤器，该过滤器将捕获ServletExceptions并处理原因。</p><p>可以通过将布尔值jaxrs属性“ org.apache.cxf.propagate.exception”注册为假值来禁用此传播。如果设置了此类属性，并且找不到给定异常的异常映射器，则CXF <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/bindings/xml/src/main/java/org/apache/cxf/binding/xml/interceptor/XMLFaultOutInterceptor.java">XMLFaultOutInterceptor</a>会将其包装到xml错误响应中。</p><p>还可以注册一个自定义的CXF输出故障拦截器，该拦截器可以通过直接写入HttpServletResponse流或XMLStreamWriter（如XMLFaultOutInterceptor一样）来处理所有异常。例如，请参阅此<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/CustomOutFaultInterceptor.java">测试拦截器</a> 。</p><h2 id="JAX-RSBasics-MappingexceptionsthrownfromCXFinterceptors">映射从CXF拦截器引发的异常</h2><p>从CXF 2.7.8开始，还可以使用已注册的ExceptionMappers将从CXF服务器抛出的异常映射到在JAXRSInInterceptor（阶段）之后注册的拦截器中。UNMARSHAL）并在JAXRSOutInterceptor（阶段。元帅）。<br clear="none">在早期的CXF版本中，此类异常只能在拦截器中处理CXF错误时才能处理。</p><p>为了获得从CXF映射的拦截器中引发的异常，请将“ map.cxf.interceptor.fault”上下文属性设置为true-CXF 2.7.8中需要此属性，以确保不影响故障拦截器中的现有对象；默认情况下，此映射是从CXF 3.0.0开始进行的。</p><p>为了获取从CXF抛出的异常，将其映射到拦截器中，请添加org.apache.cxf.jaxrs.interceptor。JAXRSOutExceptionMapperInterceptor到out拦截器的列表。</p><h2 id="JAX-RSBasics-CustomizingdefaultWebApplicationExceptionmapper">自定义默认的WebApplicationException映射器</h2><p>CXF附带了一个WebApplicationException映射器org.apache.cxf.jaxrs.impl。WebApplicationExceptionMapper。默认情况下，它以警告级别记录堆栈跟踪，并在捕获的异常中返回可用的响应。<br clear="none">通过将'printStackTrace'属性设置为'false'，可以将其配置为在跟踪级别记录堆栈跟踪。或者，如果是org.apache.cxf.logging。FaultListener已注册（作为上下文属性），并指示其处理了给定的异常，因此不再进行日志记录。</p><p>通过将'addMessageToResponse'属性设置为'true'，还可以选择报告一条简单的文本错误消息，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;bean id="exceptionMapper" class="org.apache.cxf.jaxrs.impl.WebApplicationExceptionMapper"&gt;
   &lt;property name="addMessageToResponse" value="true" /&gt;
&lt;/bean&gt;</pre>
</div></div><p><br clear="none">请注意，在正常情况下，自定义WebApplicationExceptionMapper如果已注册，则将优先于默认值。但是，默认的WebApplicationExceptionMapper将赢得自定义的WebApplicationExceptionMapper的要求，后者不那么具体（例如，RuntimeException映射器），但希望捕获WebApplicationException。并且引入了一个属性“ default.wae.mapper.least.specific”，以确保CXF自定义WebApplicationExceptionMapper仍然可以胜任此特定情况。</p><h1 id="JAX-RSBasics-DealingwithParameters">处理参数</h1><p>PathParam批注用于将给定的Path模板变量映射到方法参数。<br clear="none">例如 ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customer/{id}")
public class CustomerService {

    
    @PUT
    @Path("{name}")
    public Response updateCustomer(@PathParam("id") Long id, @PathParam("name") String name) {
        ...
    }
}
</pre>
</div></div><p>在这种情况下，根类注释中可用的模板变量id映射到Long类型的参数，而name变量映射到String类型的参数。</p><p>还支持@ QueryParam，@ HeaderParam，@ MatrixParam，@ FormParam和@CookieParam批注。</p><p>请注意，标有@FormParam批注的参数可以从查询参数中获取值，以防万一（如果请求主体已被使用）。由于过滤器（Spring安全性等）消耗了主体，因此JAX-RS规范中对此进行了定义，因此JAX-RS表单参数变为空。用户可以选择通过将“ set.form.parameters.from.http.parameters”消息属性设置为false来停用标准行为。</p><p>参数可以是String类型，也可以是构造函数接受String参数或静态valueOf（String s）方法的任何类型。<br clear="none">另外，CXF JAXRS检查静态fromString（String）方法，因此也可以处理没有valueOf（String）工厂方法的类型：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public enum Gender {
   MALE,
   FEMALE;

   public static Gender fromString(String s) {
       if ("1".equals(s)) {
           return FEMALE;
       } else if ("1".equals(s)) {
           return MALE;
       }  
       return valueOf(s); 
   }
}

@Path("/{g}")
public class Service {

    
    @PUT
    @Path("{id}")
    public Response update(@PathParam("g") Gender g, @PathParam("id") UUID u) {
        ...
    }
}
</pre>
</div></div><p>请注意，在主干上，还支持带有fromValue（）的工厂方法。</p><p>还支持JAX-RS PathSegment。一系列名称相同的参数（查询，标头等）可以映射到List或Set或SortedSet。</p><p>CXF JAXRS支持ParameterHandler扩展，可用于处理用JAXRS参数注释之一注释的方法参数：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class MapHandler implements ParameterHandler&lt;Map&gt; {
    public Map fromString(String s) {...}
}

@Path("/map")
public class Service {

    
    @PUT
    @Path("/{mapvalue:(.)+}")
    public Response update(@PathParam("mapvalue") Map m, byte[] bytes) {
        ...
    }
}
</pre>
</div></div><p>请注意，不能使用ParameterHandlers处理表示消息正文的参数，在此示例中为“ byte [] byte”。MessageBodyReaders必须处理此任务。也就是说，给定的MessageBodyReader实现也可以实现ParameterHandler。</p><p>可以从Spring或以编程方式将ParameterHandlers注册为提供程序。<br clear="none">请注意，默认情况下，在尝试了JAX-RS规范建议的所有其他选项之后，最后检查处理程序。<br clear="none">从CXF 2.5.3开始，将始终首先检查处理程序的java.util。日期和java.util。语言环境参数。此外，在处理其他类型的参数时，可以使用“ check.parameter.handlers.first”上下文属性来获取首先检查的处理程序。</p><p>所有参数都会自动解码。可以使用@Encoded注解禁用此功能。<br clear="none">参数可以使用DefaultValue批注设置默认值：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">    public Response updateCustomer(@DefaultValue("123") @QueryParam("id") Long id, @PathParam("name") String name) { ... }

</pre>
</div></div><p>JAX-RS要求在资源方法中仅允许使用未使用适用于方法参数的JAXRS注释注释的单个方法参数。例如 ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public Response do(@PathParam("id") String id, String body) {
}
</pre>
</div></div><p>像“字符串主体”之类的参数应代表请求主体/输入流。JAX-RS MessageBodyReaders的工作是将请求主体反序列化为所需类型的对象。</p><p>也可以将所有类型的参数注入字段或通过专用设置器。例如，本节中的第一个代码片段可以这样重写：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customer/{id}")
public class CustomerService {

    @PathParam("id")
    private Long id; 
    
    private String name;

    @PathParam("name")
    public setName(String name) {
        this.name = name;
    } 

    @PUT
    @Path("{name}")
    public Response updateCustomer() {
        // use id and name
    }
}
</pre>
</div></div><h2 id="JAX-RSBasics-Parameterbeans">参数bean</h2><p>有一个CXF扩展，可以将一系列@ PathParam，@ QueryParam，@ FormParam或@MatrixParam参数注入到bean中。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customer/{id}")
public class CustomerService {

    
    @PUT
    @Path("{name}")
    public Response updateCustomer(@PathParam("") Customer customer) {
        ...
    }

    @GET
    @Path("/order")
    public Response getCustomerOrder(@PathParam("id") int customerId, 
                                     @QueryParam("") OrderBean bean,
                                     @MatrixParam("") OrderBean bean) {
        ...
    }

    @POST
    public Response addCustomerOrder(@PathParam("id") int customerId,
                                     @FormParam("") OrderBean bean) {
        ...
    }
}

public class Customer {
   public void setId(Long id) {...}
   public void setName(String s) {...}  
}

public class OrderBean {
   public void setId(Long id) {...}
   public void setWeight(int w) {...}  
}



</pre>
</div></div><p>请注意，在updateCustomer（）中只有一个@PathParam值为空-这是一个扩展位。模板变量“ id”的值注入到Customer.setId（Long id）中，而“名称”的值注入到Customer.setName（String s）中。设置方法应具有单个参数，从实际值到参数实例的转换遵循上述相同的过程。</p><p>同样，在getCustomerOrder（）中，可以从查询字符串（如？）中为OrderBean注入相应的值。id = 1＆weight = 2或来自设置为以下路径段之一的一部分的矩阵参数：/ customer / 1 / order; id = 1; weight = 2。同样，在addCustomerOrder（）中，FormParam（“”）可以捕获从HTML表单提交的所有值，并将它们注入OrderBean。</p><p>还支持嵌套Bean，这尤其使制定高级搜索查询成为可能。例如，给定以下bean定义：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">class Name {
    String first;
    String last;
}

class Address {
    String city;
    String state;
}

class Person {
    Name legalName;
    Address homeAddr;
    String race;
    String sex;
    Date birthDate;
}

class MyService
{
    @GET
    @Path("/getPerson")
    Person getPerson(@QueryParam("") Person person);
} 
</pre>
</div></div><p>像这样的查询</p><p>> / getPerson？sex = M＆legalName.first = John＆legalName.last = Doe＆homeAddr.city = Reno＆homeAddr.state = NV</p><p>将导致Person Bean被正确初始化，所有搜索条件都将被捕获并易于访问。请注意，正在计划在此方面进行更多增强。</p><h1 id="JAX-RSBasics-Resourcelifecycles">资源生命周期</h1><p>默认情况下，支持的范围是Singleton和Prototype（按请求）。<br clear="none">请注意，JAXRS MessageBodyWriter和MessageBodyReader提供程序始终为单例。</p><p>具有原型范围的类可以在构造时获取JAXRS上下文或参数：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/")
public class PerRequestResourceClass {

   public PerRequestResourceClass(@Context HttpHeaders headers, @QueryParam("id") Long id) {}
}
</pre>
</div></div><p>具有单例作用域的类只能在构造时注入上下文，只有CXFNonSpringJaxrsServlet可以做到这一点。在大多数情况下，可以在构造时间之后立即将上下文作为bean属性注入。</p><p>有关更多详细信息，请参见“生命周期管理”部分。</p><h1 id="JAX-RSBasics-Overviewoftheselectionalgorithm.">选择算法概述。</h1><p>JAX-RS选择算法用于选择根资源类，资源方法和子资源定位符。</p><h2 id="JAX-RSBasics-Selectingbetweenmultipleresourceclasses">在多个资源类别之间选择</h2><p>当多个资源类与给定的URI请求匹配时，将使用以下算法：<br clear="none">1。首选在其@Path批注中具有更多文字字符的资源类。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/bar/{id}")
public class Test1 {}
@Path("/bar/{id}/baz")
public class Test2 {}
@Path("/foo")
public class Test3 {}
@Path("/foo/")
public class Test4 {}
</pre>
</div></div><p>这两个类都匹配/ bar / 1 / baz请求，但将选择Test2，因为它具有9个Path文字字符，而Test1中只有5个。同样，当/ foo /请求到达时，Test4胜于Test3。</p><p>2。建议在其@Path批注中具有更多捕获组的资源类。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/bar/{id}/")
public class Test1 {}
@Path("/bar/{id}/{id2}")
public class Test2 {}
</pre>
</div></div><p>这两个类都匹配/ bar / 1/2请求，并且都具有相同数量的文字字符，但是将选择Test2，因为它具有2个路径捕获组（id和id1），而不是Test1中的1。</p><p>3。优先选择资源类，该资源类的@Path批注中具有更多带有任意正则表达式的捕获组。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/bar/{id:.+}/baz/{id2}")
public class Test1 {}
@Path("/bar/{id}/bar/{id2}")
public class Test2 {}
</pre>
</div></div><p>这两个类都匹配/ bar / 1 / baz / 2请求，并且都具有相同数量的文字字符和捕获组，但是将选择Test1，因为它具有1个具有任意正则表达式（id）的路径捕获组，而不是Test2中的0 。</p><h2 id="JAX-RSBasics-Selectingbetweenmultipleresourcemethods">在多种资源方法之间选择</h2><p>一旦选择了资源类别，下一步就是选择一种资源方法。如果可以匹配多个方法，则将应用用于选择资源类的相同规则。另外，使用了另一条规则。</p><p>4。优先使用资源方法而不是子资源定位器方法</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/")
public class Test1 {

 @Path("/bar")
 @GET
 public Order getOrder() {...}

 @Path("/bar")
 public Order getOrderFromSubresource() {...}
}

public class Order {

 @Path("/")
 @GET
 public Order getOrder() { return this; }

}
</pre>
</div></div><p>getOrderFromSubresource（）和getOrder（）方法都可以用于处理/ bar请求。但是，getOrder（）会获胜。</p><h2 id="JAX-RSBasics-Resourcemethodsandmediatypes">资源方法和媒体类型</h2><p>考虑具有2种资源方法的该资源类：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/")
public class Test1 {

 @Path("/bar")
 @POST 
 @Consumes("application/json")
 @Produces("application/json")
 public Order addOrderJSON(OrderDetails details) {...}

 @Path("/bar")
 @POST
 @Consumes("application/xml")
 @Produces("application/xml")
 public Order getOrderXML(OrderDetails details) {...}
 
}
</pre>
</div></div><p>两种方法都匹配/ bar请求。如果在给定的请求中Content-Type和Accept都设置为application / xml，则将选择getOrderXML。如果Content-Type和Accept都设置为application / json，则将选择getOrderJSON。</p><p>对于此特定示例，在两种情况下，都将选择JAXB或JSON消息正文读取器和写入器将输入流反序列化为OrderDetails并将Order序列化为输出流。消息正文提供程序也可以设置@Produces和@Consumes，并且它们必须与所选资源方法上的匹配。</p><p>上面的代码可以用以下代码代替：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/")
public class Test1 {

 @Path("/bar")
 @POST 
 @Consumes({"application/json", "application/xml"})
 @Produces({"application/json", "application/xml"})
 public Order addOrder(OrderDetails details) {...}

}
</pre>
</div></div><h2 id="JAX-RSBasics-Customselectionbetweenmultipleresourcesoroperations">在多个资源或操作之间进行自定义选择</h2><p>就涉及多个匹配资源类或方法之间的选择而言，在设计JAX-RS选择算法时要特别注意各种可能的情况。</p><p>但是，在某些情况下，用户报告说该算法在选择多个资源类的方式上有些限制。例如，默认情况下，在已匹配给定资源类并且如果该类没有匹配的资源方法之后，该算法将停止执行，而不会尝试检查其余匹配的资源类。</p><p>从CXF 2.2.5开始，可以使用jaxrs：server / jaxrs：resourceComparator元素注册自定义<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/ResourceComparator.java">ResourceComparator</a>实现，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;!-- JAX-RS endpoint declaration fragment --&gt;
&lt;jaxrs:server address="/"&gt;
&lt;!-- Usual elements, like serviceBeans or providers, etc --&gt;

&lt;!-- Custom ResourceComparator --&gt;
&lt;jaxrs:resourceComparator&gt;
   &lt;bean class="org.custom.CustomResourceComparator"/&gt;
&lt;/jaxrs:resourceComparator&gt;
&lt;/jaxrs:server&gt;

</pre>
</div></div><p>定制实现可以检查要比较的资源类或方法的名称，并给定当前请求URI，它们可以确保根据需要通过返回-1或1来选择所需的类或方法。如果返回0，则运行时将继续执行默认选择算法。目前，获取诸如当前请求URI之类的详细信息的最简单方法是使用接受消息的构造函数创建CXF JAXRS UriInfoImpl的实例。</p><p>请注意，在调用自定义ResourceComparator时，提供的资源类或方法已被运行时成功匹配。</p><p>例如，可选的HTTP请求和URI参数（查询，矩阵，标头，cookie）和表单参数不会影响选择算法。<br clear="none">当认为此限制有问题时，可以使用自定义ResourceComparator。例如，以下显示了这样的一种实现：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.ws.rs.core.MultivaluedMap;

import org.apache.cxf.jaxrs.ext.ResourceComparator;
import org.apache.cxf.jaxrs.model.ClassResourceInfo;
import org.apache.cxf.jaxrs.model.OperationResourceInfo;
import org.apache.cxf.jaxrs.model.OperationResourceInfoComparator;
import org.apache.cxf.jaxrs.model.Parameter;
import org.apache.cxf.jaxrs.util.JAXRSUtils;
import org.apache.cxf.message.Message;

public class QueryResourceInfoComperator extends OperationResourceInfoComparator implements
         ResourceComparator {

     public QueryResourceInfoComperator() {
         super(null, null);
     }

     @Override
     public int compare(ClassResourceInfo cri1, ClassResourceInfo cri2, Message message) {
         // Leave Class selection to CXF
         return 0;
     }

     @Override
     public int compare(OperationResourceInfo oper1, OperationResourceInfo oper2, Message message) {

         // Check if CXF can make a decision
         int cxfResult = super.compare(oper1, oper2);
         if (cxfResult != 0)
             return cxfResult;

         int op1Counter = getMatchingRate(oper1, message);
         int op2Counter = getMatchingRate(oper2, message);

         return op1Counter == op2Counter
                 ? 0
                 : op1Counter&lt;  op2Counter
                         ? 1
                         : -1;
     }

     /**
      * This method calculates a number indicating a good or bad match between
      * values provided within the request and expected method parameters. A
      * higher number means a better match.
      *
      * @param operation
      *            The operation to be rated, based on contained parameterInfo
      *            values.
      * @param message
      *            A message containing query from user request
      * @return A positive or negative number, indicating a good match between
      *         query and method
      */
     protected int getMatchingRate(OperationResourceInfo operation, Message message) {

         List&lt;Parameter&gt;  params = operation.getParameters();
         if (params == null || params.size() == 0)
             return 0;

         // Get Request QueryParams
         Set&lt;String&gt;  qParams = getParams((String) message.get(Message.QUERY_STRING));

         int rate = 0;
         for (Parameter p : params) {
             switch (p.getType()) {
             case QUERY:
                 if (qParams.contains(p.getName()))
                     rate += 2;
                 else if (p.getDefaultValue() == null)
                     rate -= 1;
                 break;
             // optionally support other parameter types such as headers, etc
             // case HEADER:
             //  break;
             default:
                 break;
             }
         }
         return rate;
     }

     /**
      * @param query
      *            URL Query Example: 'key=value&amp;key2=value2'
      * @return A Set of all keys, contained within query.
      */
     protected Set&lt;String&gt;  getParams(String query) {
         Set&lt;String&gt;  params = new HashSet&lt;String&gt;();
         if (query == null || query.length() == 0)
             return params;

         MultivaluedMap&lt;String, String&gt; allQueries =
             JAXRSUtils.getStructuredParams(query, "&amp;", false, false);
         return allQueries.keySet();
     }
} 
</pre>
</div></div><p>现在考虑以下代码：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/paramTest")
public class MySimpleService {

      @GET
      public String getFoo(@QueryParam("foo") String foo){
          return "foo:" + foo;
      }

      @GET
      public String getFooBar(@QueryParam("foo") String foo,
@QueryParam("bar") String bar){
          return "foo:" + foo + " bar:" + bar;
      }

  
} 
</pre>
</div></div><p>使用自定义比较器将导致当请求URI仅具有一个查询参数时，getFoo（）方法将接受一个查询参数；当请求URI具有至少两个查询参数时，将使用getFoo（）方法接受多个查询参数。进一步的定制也是可能的。</p><h1 id="JAX-RSBasics-Contextannotations">上下文注释</h1><p>可以在字段中或通过专用方法将许多上下文类型作为参数注入。<br clear="none">可以注入UriInfo，SecurityContext，HttpHeaders，Provider，Request，ContextResolver，Servlet类型（HttpServletRequest，HttpServletResponse，ServletContext，ServletConfig）。</p><p>CContext特定于CXF的复合上下文接口也受支持， <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/MessageContext.java">MessageContext</a>使得处理所有受支持的JAX-RS上下文（以及将来的上下文）变得更加容易，还使我们可以检查当前消息的属性。</p><p>例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customer")
public class CustomerService {
    
    @Context 
    private org.apache.cxf.jaxrs.ext.MessageContext mc; 
    @Context 
    private ServletContext sc;
    private UriInfo ui;
    
    @Context
    public void setUriInfo(UriInfo ui) {
        this.ui = ui;
    }

    @PUT
    public Response updateCustomer(@Context HttpHeaders h, Customer c) {
        mc.getHttpHeaders();
    }
}

</pre>
</div></div><p>请注意，所有类型的受支持的JAX-RS提供程序（例如MessageBodyWriter，MessageBodyReader，ExceptionMapper和ContextResolver）以及提供程序可以提供的主体提供程序列表也可以注入上下文。唯一的例外是，由于固定了JAXRS提供程序的方法，提供程序不支持任何参数级别注入。</p><p>注意，Provider和ContextResolver可能是消息主体提供程序感兴趣的，而不是实际的应用程序代码感兴趣。您还可以将所有上下文类型注入到@Resource带注释的字段中。</p><h2 id="JAX-RSBasics-CustomContexts">自定义上下文</h2><p>注册诸如<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/rs/extensions/search/src/main/java/org/apache/cxf/jaxrs/ext/search/SearchContextProvider.java">SearchContextProvider之</a>类的自定义<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/ContextProvider.java">ContextProvider</a>实现，可以将Context批注附加到任意类，当表示当前请求的某些信息需要优化或特殊化时，这将很有帮助：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">package resources;
import org.apache.cxf.jaxrs.ext.search.SearchContext;
@Path("/")
public class RootResource {
    @Context
    private  SearchContext sc;
    // the rest of the code
}
</pre>
</div></div><p>和</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server&gt;
  &lt;serviceBeans&gt;
    &lt;bean class="resources.RootResource"/&gt;
  &lt;/serviceBeans&gt;
  &lt;jaxrs:providers&gt;
    &lt;bean class="org.apache.cxf.jaxrs.ext.search.SearchContextProvider"/&gt;
  &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>自定义上下文实现可以从当前CXF消息中获取有关HTTP请求的所有信息。</p><h1 id="JAX-RSBasics-URIcalculationusingUriInfoandUriBuilder">使用UriInfo和UriBuilder进行URI计算</h1><p>使用@Path批注很容易将特定的URI映射到返回某些资源的服务。但是，经常连接RESTful服务：一个服务返回用作另一个服务中的密钥的数据。列出实体并访问特定实体是一个典型的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customers")
public class CustomerService {

    @GET
    public Customers getCustomers() {
        ......
    }

    @GET
    @Path("/{id}")
    public Customer getCustomer(@PathParam("id") String id) {
        ......
    }

}
</pre>
</div></div><p>对于此服务，我们可以假定返回的客户列表仅显示基本属性，并且使用第二种方法（以客户ID为键）返回更多详细信息。像这样：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">GET http://foobar.com/api/customers

&lt;customers&gt;
    &lt;customer id="1005"&gt;John Doe&lt;/customer&gt;
    &lt;customer id="1006"&gt;Jane Doe&lt;/customer&gt;
    ...
&lt;/customers&gt;
    
GET http://foobar.com/api/customers/1005

&lt;customer id="1005"&gt;
    &lt;first-name&gt;John&lt;/first-name&gt;
    &lt;last-name&gt;Doe&lt;/last-name&gt;
    ...
&lt;/customer&gt;
</pre>
</div></div><p>此服务的客户如何知道如何从客户列表中获取给定客户？一种简单的方法是期望客户端计算适当的URI。但是让服务在响应中提供可直接使用的完整URI会更好吗？这样，客户端将与服务本身进一步分离（这可能会随时间改变URI格式）。例如，可以向客户提供以下响应：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">GET http://foobar.com/api/customers

&lt;customers-list&gt;
    &lt;customer id="1005" url="http://foobar.com/api/customers/1005"&gt;John Doe&lt;/customer&gt;
    &lt;customer id="1006" url="http://foobar.com/api/customers/1006"&gt;Jane Doe&lt;/customer&gt;
    ...
&lt;/customers-list&gt;
</pre>
</div></div><p>服务的问题在于，当路径来自@Path批注时，如何确定这些URI。当我们考虑具有多级模板（变量）或子资源的路径（将动态路由引入到不同的URI）时，情况就变得更加复杂。</p><p>解决方案的核心部分是将<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.1/javax/ws/rs/core/UriInfo.html" rel="nofollow">UriInfo</a>对象注入方法“ getCustomers”中。该帮助器对象允许提取有关当前URI上下文的有用信息，但更重要的是允许获取<a shape="rect" class="external-link" href="https://jax-rs.github.io/apidocs/2.1/javax/ws/rs/core/UriBuilder.html" rel="nofollow">UriBuilder</a>对象。UriBuilder具有用于为每个对象构建URI的多个添加方法。在本例中，我们可以通过多种方式附加路径URI，将路径提供为字符串（我们在此实际上要避免使用）或资源（类或方法）以提取@Path值。最后，UriBuilder必须将值绑定到其模板变量以呈现实际的URI。这种情况实际上是这样的：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customers")
public class CustomerService {

    @GET
    public Customers getCustomers(@Context UriInfo ui) {
        ......
        // builder starts with current URI and has the path of the getCustomer method appended to it
        UriBuilder ub = ui.getAbsolutePathBuilder().path(this.getClass(), "getCustomer");
        for (Customer customer: customers) {
            // builder has {id} variable that must be filled in for each customer
            URI uri = ub.build(customer.getId());
            c.setUrl(uri);
        }
        return customers;
    }

    @GET
    @Path("/{id}")
    public Customer getCustomer(@PathParam("id") String id) {
        ......
    }

}
</pre>
</div></div><h1 id="JAX-RSBasics-Annotationinheritance">注释继承</h1><p>大多数JAX-RS批注都可以从接口或超类继承。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public interface CustomerService {

    @PUT
    @Path("/customers/{id}")
    Response updateCustomer(@PathParam("id") Long id, Customer customer);

    @POST
    @Path("/customers")
    Customer addCustomer(Customer customer);

}

@Path("/customerservice/")
public class Customers implements CustomerService {

    
    public Response updateCustomer(Long id, Customer customer) {
        return Response.status(errorCode).build();
    }

    public Customer addCustomer(Customer customer) {
        throw new WebApplicationException(errorCode);
    }

}
</pre>
</div></div><p>类似地，注释可以从超类继承。在CXF中，资源类将从其已实现的接口及其扩展的任何类继承类级别的注释。</p><h1 id="JAX-RSBasics-Sub-resourcelocators.">子资源定位器。</h1><p>当不存在带有@GET之类的HttpMethod指示符的注释时，使用@Path注释的资源类的方法将成为子资源定位符。子资源定位符用于进一步解析将处理请求的对象。他们可以委派给其他子资源定位器，包括他们自己。</p><p>在下面的示例中，getOrder方法是一个子资源定位器：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customerservice/")
public class CustomerService {

    @Path("/orders/{orderId}/")
    public Order getOrder(@PathParam("orderId") String orderId) {
       ......
    }
}

@XmlRootElement(name = "Order")
public class Order {
    private long id;
    private Items items;

    public Order() {
    }

    public long getId() {
        return id;
    }


    @GET
    @Path("products/{productId}/")
    public Product getProduct(@PathParam("productId")int productId) {
       ......
    }

    @Path("products/{productId}/items")
    public Order getItems(@PathParam("productId") int productId) {
       return this;
    }

    @GET
    public Items getItems() {
       ......
    }

}
</pre>
</div></div><p>首先将对<a shape="rect" class="external-link" href="http://localhost:9000/customerservice/orders/223/products/323" rel="nofollow">http：// localhost：9000 / customerservice / orders / 223 / products / 323</a>的HTTP GET请求分派到getOrder方法。如果找到ID为223的订单资源，则订单223将用于进一步解析产品资源。最终，将返回属于订单223的产品323。同样，对<a shape="rect" class="external-link" href="http://localhost:9000/customerservice/orders/223/products/323/items" rel="nofollow">http：// localhost：9000 / customerservice / orders / 223 / products / 323 / items</a>的请求将传递到getItems（productId）方法。</p><p>请注意，像Order这样的子资源类通常没有根@Path批注，这意味着它们在运行时被动态委派给它们，换句话说，它们不能在首先调用一个根资源类之前被调用。如果根资源类的子资源定位器方法之一委托给它，则根资源类（具有根@ \ Path注释）也可以成为子资源，类似于上面的Order.getItems（productId）。</p><p>注意，给定的子资源可以表示为接口或在运行时解析为实际类的某些基类。在这种情况下，必须在运行时动态发现必须在实际子资源实例上调用的任何资源方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customerservice/")
public class CustomerService {

    @Path("/orders/{orderId}/")
    public Order getOrder(@PathParam("orderId") String orderId) {
       ......
    }
}

public interface Order {
    @GET
    @Path("products/{productId}/")
    Product getProduct(@PathParam("productId")int productId);
}

@XmlRootElement(name = "Order")
public class OrderImpl implements Order {
    
    public Product getProduct(int productId) {
       ......
    }
}

@XmlRootElement(name = "Order")
public class OrderImpl2 implements Order {
    
    // overrides JAXRS annotations
    @GET
    @Path("theproducts/{productId}/")
    Product getProduct(@PathParam("id")int productId) {...}
}

</pre>
</div></div><h2 id="JAX-RSBasics-Staticresolutionofsubresources">子资源的静态解析</h2><p>默认情况下，子资源在运行时动态解析。这是一个较慢的过程，部分原因是，除了在子资源定位器方法所键入的接口上可用的注释之外，具体的子资源实现可能还引入了一些JAXRS注释，这些注释与在实现该子资源的另一子资源实例上可用的注释不同接口。</p><p>如果您知道所有JAXRS批注在子资源定位器方法返回的给定子资源类型（或其超类或接口之一）上都可用，那么您可能要禁用动态解析：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans&gt;
&lt;jaxrs:server staticSubresourceResolution="true"&gt;
&lt;!-- more configuration --&gt;
&lt;/jaxrs:server&gt;
&lt;/beans&gt;
</pre>
</div></div><p>注意-从CXF 2.7.2开始，如果启用了此属性，还将支持JAX-RS上下文和参数的注入。</p><h1 id="JAX-RSBasics-MessageBodyProviders">邮件正文提供者</h1><p>JAX-RS依靠MessageBodyReader和MessageBodyWriter实现来序列化和反序列化Java类型。JAX-RS要求开箱即用地支持某些类型。<br clear="none">默认情况下，CXF支持String，byte []，InputStream，Reader，File，JAXP Source，JAX-RS StreamingOutput，具有application / xml，text / xml和application / json格式以及JAXBElement的JAXB注释类型（请参见下文） 。表单内容也支持JAX-RS MultivaluedMap。</p><p>另请参见下面的“支持数据绑定”部分。</p><h2 id="JAX-RSBasics-CustomMessageBodyProviders">自定义消息正文提供者</h2><p>给定的应用程序可能需要处理默认情况下不支持的类型。或者，开发人员可能希望提供一种更有效的实现来处理诸如InputStream之类的默认类型。</p><p>这是InputStream的自定义MessageBodyReader的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Consumes("application/octet-stream")
@Provider
public class InputStreamProvider implements MessageBodyReader&lt;InputStream&gt; {

    
    public boolean isReadable(Class&lt;InputStream&gt; type, Type genericType, Annotation[] annotations, MediaType mt) {
        return InputStream.class.isAssignableFrom(type);
    }

    public InputStream readFrom(Class&lt;InputStream&gt; clazz, Type t, Annotation[] a, MediaType mt, 
                         MultivaluedMap&lt;String, String&gt; headers, InputStream is) 
        throws IOException {
        return new FilterInputStream(is) {
             @Override
             public int read(byte[] b) throws IOException {
                 // filter out some bytes
             }              
        }     
    }
}

</pre>
</div></div><p>这是Long对象的自定义MessageBodyWriter的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces("text/plain")
@Provider
public class LongProvider implements MessageBodyWriter&lt;Long&gt; {

    public long getSize(Long l, Class&lt;?&gt; type, Type genericType, Annotation[] annotations, MediaType mt) {
        return -1;
    }

    public boolean isWriteable(Class&lt;?&gt; type, Type genericType, Annotation[] annotations, MediaType mt) {
        return long.class.isAssignableFrom(type) || Long.class.isAssignableFrom(type);
    }

    public void writeTo(Long l, Class&lt;?&gt; clazz, Type type, Annotation[] a, 
                        MediaType mt, MultivaluedMap&lt;String, Object&gt; headers, OutputStream os) 
        throws IOException {
        os.write(l.toString().getBytes());
        
    }

</pre>
</div></div><p>CXF还提供了一些自定义提供程序，用于处理Atom（基于Apache Abdera）和XMLObjects。当在输入或输出上使用文本/纯媒体类型时，CXF还支持基本类型及其“数字”朋友。</p><h2 id="JAX-RSBasics-Registeringcustomproviders">注册自定义提供程序</h2><p>在提供程序类上放置@Provider批注应该会导致您的提供程序已在运行时注册。CXF尚不支持此功能。</p><p>可以通过Spring配置或通过编程轻松注册提供程序：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans&gt;
&lt;jaxrs:server id="customerService" address="/"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;bean class="org.CustomerService" /&gt;
    &lt;/jaxrs:serviceBeans&gt;

    &lt;jaxrs:providers&gt;
      &lt;ref bean="isProvider" /&gt;
      &lt;ref bean="longProvider" /&gt;
    &lt;/jaxrs:providers&gt;
    &lt;bean id="isProvider" class="com.bar.providers.InputStreamProvider"/&gt;
    &lt;bean id="longProvider" class="com.bar.providers.LongProvider"/&gt;
&lt;/jaxrs:server&gt;
&lt;/beans&gt;
</pre>
</div></div><p>请注意， <jaxrs:entityproviders>它现在不是较旧<jaxrs:entityproviders>的<jaxrs:providers>。JAX-RS支持不同类型的提供程序，并且具有一个<jaxrs:providers>容器与其他JAX-RS实现仅通过检查@Provider注释来发现提供程序的方式是一致的。</jaxrs:providers></jaxrs:providers></jaxrs:entityproviders></jaxrs:entityproviders></p><p>请参阅下面的更完整的beans.xml定义。</p><p>虽然自动注册带有@Provider注释的提供程序确实是一个方便的功能，但有时可能确实存在问题。例如，在一个大型项目中，来自不同库的用户提供程序可能会发生冲突。</p><p>当使用定制配置（如上所示）时，可以向不同的jaxrs：server实例注册不同类型（处理请求/响应主体的相同格式）的提供程序实例或相同类型的不同配置的实例。另一个要求可能是在多个可用端点中只有给定的jaxrs：server端点来处理具有给定媒体类型的请求：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans&gt;
&lt;jaxrs:server id="customerService1" address="/1"&gt;
   &lt;bean id="serviceBean" class="org.CustomerService" /&gt; 

   &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="serviceBean"/&gt;
   &lt;/jaxrs:serviceBeans&gt;

   &lt;jaxrs:providers&gt;
      &lt;bean class="com.bar.providers.InputStreamProvider"/&gt;
   &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;
&lt;jaxrs:server id="customerService2" address="/2"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="serviceBean"/&gt;
    &lt;/jaxrs:serviceBeans&gt;

    &lt;jaxrs:providers&gt;
      &lt;bean id="isProvider" class="baz.foo.jaxrsproviders.InputStreamProvider"/&gt;
    &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;

&lt;jaxrs:server id="customerService3" address="/3"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="serviceBean"/&gt;
    &lt;/jaxrs:serviceBeans&gt;

    &lt;jaxrs:providers&gt;
      &lt;ref bean="isProvider"/&gt;
    &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;


&lt;bean id="isProvider" class="com.bar.providers.InputStreamProvider"&gt;
   &lt;property name="limit" value="5"/&gt;
&lt;/bean&gt;

&lt;/beans&gt;
</pre>
</div></div><p>在此示例中，可以通过3条不同的路径/ 1，/ 2和/ 3访问单个服务bean。InputStream提供程序在所有3条路径上均可用。 com.bar.providers。InputStreamProvider在2种情况下使用，而特殊的InputStream处理程序baz.foo.jaxrsproviders。在一种情况下，还涉及另一个库的InputStreamProvider。</p><h1 id="JAX-RSBasics-Customizingmediatypesformessagebodyproviders">自定义消息正文提供者的媒体类型</h1><p>如上所述，消息主体提供程序可以在影响目标资源方法匹配的方式中扮演重要角色。如果方法返回自定义类型Foo且MessageBodyWriter <foo>可用，则仅当给定请求的HTTP Accept标头中指定的一种媒体类型与MessageBodyWriter中@Produces批注指定的一种媒体类型匹配或相交时，才使用该方法。 <foo>实施。如果方法接受自定义类型Foo，则同样适用，但是这次MessageBodyReader中的@Consumes的值<foo>将与请求的ContentType值匹配。</foo></foo></foo></p><p>有时，用户可能想尝试使用与给定消息正文读取器/写入器静态支持的媒体类型不同的媒体类型。例如，在某些情况下，application / xml似乎过于通用，人们可能想尝试某些custom / xml类型，但仍使用默认的JAXB提供程序。</p><p>在这种情况下，可以覆盖给定提供程序支持的默认@Produces和/或@Consumes类型。它当前仅适用于JAXBElementProvider和JSONProvider，但是任何定制提供程序都可以通过简单地为生产和/或消费类型使用setter / getter对来利用此支持，并且JAXRS运行时将改为使用它们。<br clear="none">请参阅<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/resources/jaxrs/WEB-INF/beans.xml">此示例，</a>以了解如何从Spring提供自定义媒体类型。</p><h1 id="JAX-RSBasics-AdvancedHTTP">进阶HTTP</h1><p>JAX-RS规范要求支持许多高级HTTP功能。</p><p>JAX-RS请求上下文对象可用于检查通过诸如If-Match，If-None-Match，If-Modified-Since和If-Unmodified-Since之类的标头表达的前提条件。</p><p>JAX-RS还使使用ETag，Vary，CacheControl，Cookie和Set-Cookie标头更加容易。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=24190796">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=24190796&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>