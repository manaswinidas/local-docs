<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Data Bindings">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-JAX-RS数据绑定</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="restful-services.html">RESTful服务</a> > <a href="jax-rs.html">JAX-RS</a> > <a href="jax-rs-data-bindings.html">JAX-RS数据绑定</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><span style="font-size:2em;font-weight:bold">JAX-RS：数据绑定</span>


 </p><p><br clear="none"></p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1532012173962 {padding: 0px;}
div.rbtoc1532012173962 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1532012173962 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1532012173962">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSDataBindings-JAXBsupport">JAXB支持</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSDataBindings-ConfiguringtheJAXBprovider">配置JAXB提供程序</a></li><li><a shape="rect" href="#JAX-RSDataBindings-JAXBandMoxy">JAXB和Moxy</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSDataBindings-JSONsupport">JSON支持</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSDataBindings-Jettison">抛弃</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSDataBindings-ConfiguringJSONprovider">配置JSON提供程序</a></li><li><a shape="rect" href="#JAX-RSDataBindings-DealingwithJettisonarrayserializationissues">处理Jettison阵列序列化问题</a></li><li><a shape="rect" href="#JAX-RSDataBindings-BadgerFishconvention">ger鱼公约</a></li><li><a shape="rect" href="#JAX-RSDataBindings-WrappingandUnwrappingJSONsequences">包装和解包JSON序列</a></li><li><a shape="rect" href="#JAX-RSDataBindings-TypeConverters">类型转换器</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSDataBindings-Jackson">杰克逊</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSDataBindings-CommonJAXBandJSONconfiguration">通用JAXB和JSON配置</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSDataBindings-SingleJAXBContextandextrauserclasses">单个JAXBContext和额外的用户类</a></li><li><a shape="rect" href="#JAX-RSDataBindings-AutomaticJAXBElementconversionduringserialization">序列化期间自动进行JAXBElement转换</a></li><li><a shape="rect" href="#JAX-RSDataBindings-HandlingJAXBbeanswithoutXmlRootElementannotations">处理没有XmlRootElement批注的JAXB bean</a></li><li><a shape="rect" href="#JAX-RSDataBindings-Handlingexplicitcollections">处理显式集合</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSDataBindings-CustomizingJAXBXMLandJSONinputandoutput">自定义JAXB XML和JSON输入和输出</a></li><li><a shape="rect" href="#JAX-RSDataBindings-ControllingLargeJAXBXMLandJSONinputpayloads">控制大型JAXB XML和JSON输入有效负载</a></li><li><a shape="rect" href="#JAX-RSDataBindings-JSR-353JSONProcessing">JSR-353 JSON处理</a></li><li><a shape="rect" href="#JAX-RSDataBindings-SimpleJsonMapObjectsupport">简单的JsonMapObject支持</a></li><li><a shape="rect" href="#JAX-RSDataBindings-JSONWithPadding(JSONP)">带有填充的JSON（JSONP）</a></li><li><a shape="rect" href="#JAX-RSDataBindings-Formpayloads">表格有效载荷</a></li><li><a shape="rect" href="#JAX-RSDataBindings-Atom">原子</a></li><li><a shape="rect" href="#JAX-RSDataBindings-AegisDataBinding">宙斯盾数据绑定</a></li><li><a shape="rect" href="#JAX-RSDataBindings-XMLBeans">XMLBeans</a></li><li><a shape="rect" href="#JAX-RSDataBindings-CXFDataBindingsasJAX-RSproviders">CXF DataBindings作为JAX-RS提供程序</a></li><li><a shape="rect" href="#JAX-RSDataBindings-JAXRSDataBinding">JAXRS数据绑定</a></li><li><a shape="rect" href="#JAX-RSDataBindings-Schemavalidation">模式验证</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSDataBindings-Supportforcatalogs">支持目录</a></li><li><a shape="rect" href="#JAX-RSDataBindings-Outputvalidation">输出验证</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSDataBindings-BeanValidation">Bean验证</a></li><li><a shape="rect" href="#JAX-RSDataBindings-FastInfoset">快速信息集</a></li></ul>
</div><h1 id="JAX-RSDataBindings-JAXBsupport">JAXB支持</h1><p>可以使用JAXB将请求和响应编组到Java对象和从Java对象解编。</p><p>有很多方法可以告诉JAXB提供程序如何序列化对象。最简单的方法是使用@XmlRootElement批注标记给定类型。</p><p>例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@XmlRootElement(name = "Customer")
public class Customer {
    private String name;
    private long id;

    public Customer() {
    }

    public void setName(String n) {
        name = n;
    }

    public String getName() {
        return name;
    }

    public void setId(long i) {
        id = i;
    }

    public long getId() {
        return id;
    }
}
</pre>
</div></div><p>在下面的示例中，使用JAXB数据绑定将getCustomer返回的Customer对象进行编组：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customerservice/")
public class CustomerService {
    @GET
    @Path("/customers/{customerId}/")
    public Customer getCustomer(@PathParam("customerId") String id) {
        ....
    }
}
</pre>
</div></div><p>客户对象的线路表示为：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;Customer&gt;
    &lt;id&gt;123&lt;/id&gt;
    &lt;name&gt;John&lt;/name&gt;
&lt;/Customer&gt;
</pre>
</div></div><p>使用集合的最简单方法是定义一个表示集合的类型。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@XmlRootElement(name = "Customers")
public class Customers {
    private Collection&lt;Customer&gt; customers;

    public Collection&lt;Customer&gt; getCustomer() {
        return customers;
    }

    public void setCustomer(Collection&lt;Customer&gt; c) {
        this.customers = c;
    }
}
@Path("/customerservice/")
public class CustomerService {
    @GET
    @Path("/customers/")
    public Customers getCustomers() {
        ....
    }
}
</pre>
</div></div><p>作为使用@XmlRootElement和Collection包装器的替代方法，可以提供一个Object工厂，该工厂将告诉JAXB如何封送给定类型（如果是Collections，则为其模板类型）。另一个选择是直接从给定方法中返回/接受JAXBElement。</p><p>另一种选择是注册一个或多个能够为多种不同类型创建JAXBContext的JAX-RS ContextResolver提供程序。缺省的JAXBElementProvider将在尝试自行创建JAXBContext之前首先检查这些解析器。</p><p>最后，JAXBProvider支持序列化响应类型和反序列化使用@XmlJavaTypeAdapter批注注释的方法的参数。</p><h2 id="JAX-RSDataBindings-ConfiguringtheJAXBprovider">配置JAXB提供程序</h2><p>可以通过多种方式配置默认的JAXB提供程序。例如，以下是配置编组属性的方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
        &lt;property name="marshallerProperties" ref="propertiesMap"/&gt;
    &lt;/bean&gt;
    &lt;util:map id="propertiesMap"&gt;
        &lt;entry key="jaxb.formatted.output"&gt;
            &lt;value type="java.lang.Boolean"&gt;true&lt;/value&gt;
        &lt;/entry&gt;
    &lt;/util:map&gt;
/&lt;beans&gt;
</pre>
</div></div><p>可以将单个法警属性作为简单属性注入。此刻，马歇尔。JAXB_SCHEMA_LOCATION可以作为“ schemaLocation”属性注入。可以启用架构验证，并可以注入自定义@Consume和@Produce媒体类型，有关更多信息，请参见<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs/WEB-INF/beans.xml" rel="nofollow">本示例</a>以及“为消息正文提供程序自定义媒体类型”和“架构验证”部分。</p><p>可能需要意识到的一个问题是，在某些内容已经被处理并写入输出流之后，在JAXB序列化过程中可能会发生异常。默认情况下，输出直接进入输出HTTP流，因此，如果在过程中途发生异常，则输出可能格式错误。如果将“ enableBuffering”属性设置为“ true”，则JAXB提供程序将改为写入高效的CXF CachedOutputStream，并且如果发生异常，则没有任何已写入的文本将其传递到外界，并且仅此异常将会报告给客户。</p><p>启用缓冲时，您还可以控制如何缓冲序列化的数据。默认情况下，将使用CXF CachedOutputStream的实例。如果在JAXBElementProvider上设置了“ enableStreaming”属性，则它将是CXF CachingXMLEventWriter，它将缓存序列化事件。</p><p>如果您希望自己的自定义提供程序写入高速缓存的流，则可以在jaxrs端点上将“ org.apache.cxf.output.buffering”属性设置为“ true”，或者在提供程序上将“ enableBuffering”属性设置为“ true”。如果此提供程序处理XML，并且具有返回“ true”的“ getEnableStreaming”方法，则将使用CachingXMLEventWriter，在所有其他情况下，将使用CachedOutputStream。</p><p>请注意，如果您的方法没有包装类型，并且使用的类加载器不允许调用defineClass（），则可能需要设置'-Dcom.sun.xml.bind.v2.bytecode。ClassTailor.noOptimize'</p><p>可以同时为JAXB和JSON提供程序配置JAXB Marshaller，Unmarshaller和上下文属性。这两个提供程序也可以配置为跳过isReadable（）和isWriteable（）检查，以通过将'skipChecks'属性设置为true来断言给定实例很可能成功读取/写入。当已知仅读取或写入有效的JAXB实例时，此功能很有用。</p><p>从CXF 2.4.3开始，可以具有与XML名称空间关联的特定前缀。为了使传统使用者能够使用生成的XML，可能需要这样做。使用“ namespacePrefixes”映射属性（名称空间是键，相应的前缀是值）。</p><h2 id="JAX-RSDataBindings-JAXBandMoxy">JAXB和Moxy</h2><p>为了使JAXBElementProvider支持<a shape="rect" class="external-link" href="http://www.eclipse.org/eclipselink/#moxy" rel="nofollow">Moxy，</a>需要在jaxrs：providers中注册自定义的支持<a shape="rect" class="external-link" href="http://www.eclipse.org/eclipselink/#moxy" rel="nofollow">Moxy</a>的JAX-RS ContextProvider实现。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.ws.rs.ext.ContextResolver;
import org.eclipse.persistence.jaxb.JAXBContextFactory;

public class MoxyJaxbContextResolved implements ContextResolver&lt;JAXBContext&gt; {

  JAXBContextFactory factory = new JAXBContextFactory();

  public JAXBContext getContext(Class&lt;?&gt; cls) {
      try {
          return JAXBContextFactory.createContext(new Class[] {cls}, null);
      } catch (JAXBException ex) {
          throw new RuntimeException(ex);
      }
  }

}
</pre>
</div></div><p>或者，添加带有条目“ javax.xml.bind.context.factory = org.eclipse.persistence.jaxb”的“ jaxb.properties”文件。JAXBContextFactory”添加到JAXB Bean所在的包。</p><p>如果使用Moxy来处理没有JAXB注释的bean，则需要将JAXBElementProvider上的'skipJaxbChecks'属性设置为'true'。</p><p>如果需要自定义名称空间前缀或使用Moxy添加XML处理指令，请使用JAXBElementProvider“ namespaceMapperPropertyName”和“ xmlPiPropertyName”属性。在不忽略名称空间的情况下，JSONProvider还将识别“ namespaceMapperPropertyName”。</p><h1 id="JAX-RSDataBindings-JSONsupport">JSON支持</h1><p>以下代码返回封送为JSON格式的Customer对象：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/customerservice/")
public class CustomerService {
    @Produces("application/json")
    @GET
    @Path("/customers/{customerId}/")
    public Customer getCustomer(@PathParam("customerId") String id) {
        ....
    }
} </pre>
</div></div><h2 id="JAX-RSDataBindings-Jettison">抛弃</h2><h3 id="JAX-RSDataBindings-ConfiguringJSONprovider">配置JSON提供程序</h3><p>默认的JSON提供程序依赖于Jettison 1.4.0，它希望处理的类型遵循与JAXB支持部分中所述相同的技术，以便正确处理它们。</p><p>可以通过多种方式配置默认的JSON提供程序。例如，以下是设置名称空间到前缀的映射的方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.json.JSONProvider"&gt;
        &lt;property name="namespaceMap" ref="jsonNamespaceMap"/&gt;
    &lt;/bean&gt;
    &lt;util:map id="jsonNamespaceMap" map-class="java.util.Hashtable"&gt;
        &lt;entry key="http://www.example.org/books" value="b"/&gt;
    &lt;/util:map&gt;
/&lt;beans&gt;
</pre>
</div></div><p><strong>请注意</strong> ，从CXF 2.3.0开始，可能不需要在JSONProvider的写侧设置自定义名称空间映射，而JSONProvider会在“ JAXB Marshaller”调用期间尽最大努力来检索它们。从CXF 2.6.1和2.5.4开始，设置名称空间映射将另外配置Marshaller名称空间映射器。</p><p>可以启用模式验证，并可以注入自定义@Consume和@Produce媒体类型，有关更多信息，请参见<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs/WEB-INF/beans.xml" rel="nofollow">本示例</a>以及“为消息正文提供程序自定义媒体类型”和“模式验证”部分。</p><p><strong>请注意</strong> ，JSONProvider基于Jettison，并且仅支持JAXB注释的bean。您应该使用Jackson提供程序来处理没有JAXB批注的POJO。</p><h3 id="JAX-RSDataBindings-DealingwithJettisonarrayserializationissues">处理Jettison阵列序列化问题</h3><p>默认情况下，Jettison错误地序列化了仅包含单个值的List对象。要解决此问题，需要在JSONProvider上启用“ serializeAsArray”功能，并具有使用“ arrayKeys”属性指定需要相应处理的各个字段的附加选项。请参阅<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs/WEB-INF/beans.xml" rel="nofollow">此示例</a>以获取更多信息。</p><p>请注意，可以将“ serializeAsArray”和“ arrayKeys”组合起来以产生所谓的自然约定序列。例如，给定以下两个类定义：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@XmlRootElement()
@XmlType(name = "", propOrder = {"title", "comments" })
public static class Post {
    private String title;
    private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();
    public void setTitle(String title) {
        this.title = title;
    }
    public String getTitle() {
        return title;
    }
    public void setComments(List&lt;Comment&gt; comments) {
        this.comments = comments;
    }
    public List&lt;Comment&gt; getComments() {
        return comments;
    }
}
   
public static class Comment {
     private String title;

     public void setTitle(String title) {
        this.title = title;
     }

     public String getTitle() {
         return title;
     }
} 
</pre>
</div></div><p>如果JSONProvider的'serializeAsArray'属性设置为'true'并且'arrayKeys'列表属性设置为包含'comments'值，则Post类的实例可以像这样序列化：</p><p>> {“帖子”：{“标题”：“帖子”，“评论”：[{“标题”：“ comment1”}，{“标题”：“ comment2”}]}}</p><p>布尔值“ ignoreMixedContent”属性可以在序列化过程中提供帮助，该属性可以让您绕开Jettison问题，以便处理混合内容树中通常遇到的空字符串时输出'$'属性。</p><p>您可能会要求JSONProvider忽略在某些情况下通过将“ writeXsiType”布尔属性设置为“ false”值来序列化的“ xsi：type”属性。</p><p>您还可以通过将“ ignoreNamespaces”布尔属性设置为“ true”值来请求JSONProvider在序列化过程中忽略所有名称空间。</p><p>从CXF 2.7.6（和Jettison 1.3.4）开始：</p><ul class="alternate"><li>'writeNullAsString'属性可用于影响Jettison写出空值的方式，如果将此属性设置为'false'，则Jettison将写空值而不用双引号引起来。</li><li>可以将新的'dropElementsInXmlStream'设置为false，并与outDropElements属性一起使用，以直接在Jettison级别上影响序列化</li></ul><h3 id="JAX-RSDataBindings-BadgerFishconvention">ger鱼公约</h3><p>从CXF 2.2.5开始，可以配置JSONProvider以支持BadgerFish约定。默认情况下，支持“映射”约定，如果要使用BadgerFish约定，请将JSONProvider的“ convention”属性设置为值“ badgerfish”。</p><h3 id="JAX-RSDataBindings-WrappingandUnwrappingJSONsequences">包装和解包JSON序列</h3><p>可以使用“ wrapperName”字符串属性将删除的根元素名称附加到传入的JSON序列中，以使其正确反序列化。可以使用“ wrapperMap”映射属性来为单个类名指定包装器名称。在这两种情况下，都必须设置一个'supportUnwrapped'布尔属性。</p><p>布尔“ dropRootName”属性可用于告诉JSONProvider需要删除根元素。</p><h3 id="JAX-RSDataBindings-TypeConverters">类型转换器</h3><p>Jettison 1.2支持org.codehaus.jettison.mapped的注册。TypeConverter实现，可用于将类型转换为JSON原语。“ typeConverter”属性可用于向JSONProvider实例注册转换器。“ convertTypesToStrings”属性可用于配置JSONProvider以将所有类型转换为字符串。</p><h2 id="JAX-RSDataBindings-Jackson">杰克逊</h2><p>如果您更喜欢与Jackson JSON提供程序一起工作，请注册任一JacksonJsonProvider：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:providers&gt;
   &lt;bean class="org.codehaus.jackson.jaxrs.JacksonJsonProvider"/&gt;
&lt;/jaxrs:providers&gt;
</pre>
</div></div><p>或JacksonJaxbJsonProvider（使用JAXB Bean时）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:providers&gt;
   &lt;bean class="org.codehaus.jackson.jaxrs.JacksonJaxbJsonProvider"/&gt;
&lt;/jaxrs:providers&gt;
</pre>
</div></div><p>并添加以下Maven依赖项：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.jaxrs&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-jaxrs-json-provider&lt;/artifactId&gt;
  &lt;version&gt;2.9.3&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><h1 id="JAX-RSDataBindings-CommonJAXBandJSONconfiguration">通用JAXB和JSON配置</h1><p>在本节中，预计将使用Jettison处理JSON。</p><h2 id="JAX-RSDataBindings-SingleJAXBContextandextrauserclasses">单个JAXBContext和额外的用户类</h2><p>默认情况下，JAXBContext是按需创建的。从CXF 2.3.2和2.4.0开始，可以配置基于JAXB的提供程序以支持单个JAXBContext的创建，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxb" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
      &lt;property name="singleJaxbContext" value="true"/&gt;
      &lt;property name="extraClass"&gt;
         &lt;list&gt;
           &lt;value&gt;org.apache.cxf.jaxrs.resources.SuperBook&lt;/value&gt;
           &lt;value&gt;org.apache.cxf.jaxrs.resources.SuperBook&lt;/value&gt;  
         &lt;/list&gt;
      &lt;/property&gt;
&lt;/bean&gt;
</pre>
</div></div><p>请注意，如果设置了extraClass属性，则JAXBContext（如上例中的单个或基于每个类或每个包动态创建的属性）也将包括额外的用户类，因此可以避免设置XmlSeeAlso还提供JAXB批注或处理JAXB jaxb.index或ObjectFactory资源。此属性与CXF JAXBDataBinding'extraClass'属性相同。</p><p>尝试创建单个JAXBContext也是一个优化步骤。对于类，只有一个JAXBContext，JAX-RS运行时可以通过检查所有根资源及其子资源（假设jaxrs：server端点已配置为执行子资源的静态解析）来静态发现，这并不排除JAX -RS响应，也包装正在使用的JAXB bean。</p><p>如果已知只能读取或写入有效的JAXB bean，则可能要结合使用“ singleJaxbContext”属性和“ skipChecks”属性。</p><p>还要注意，在没有创建包JAXB上下文的情况下（特别是在没有找到ObjectFactory或jaxb.index的情况下），仅设置“ extraClass”而不设置“ singleJaxbContext”属性也将起作用。从CXF 2.7.2和2.6.4开始，它也将很好地适用于程序包上下文。</p><p>但是，在可能的情况下，最好始终设置“ singleJaxbContext”和“ extraClass”属性。从CXF 2.7.2开始，这对于包级上下文也将很好地工作-添加“ useSingleContextForPackages”属性以获取创建的始终用作包上下文的单个上下文。</p><h2 id="JAX-RSDataBindings-AutomaticJAXBElementconversionduringserialization">序列化期间自动进行JAXBElement转换</h2><p>在某些情况下，将对象实例包装到JAXBElements中可能会影响XML的生成方式。例如，给定Base和Derived类，如果将这个实例包装到JAXBElement中，则返回Derived类的一个实例（基类为方法响应类型）将产生一个额外的xsi：type属性。可以设置一个“ jaxbElementClassNames”列表属性，该属性可以包含诸如“ org.foo”之类的名称。基地”等</p><h2 id="JAX-RSDataBindings-HandlingJAXBbeanswithoutXmlRootElementannotations">处理没有XmlRootElement批注的JAXB bean</h2><p>上一节中提到的“ jaxbElementClassNames”列表属性可能会影响带有XmlRootElement批注的类型的对象的序列化。<br clear="none">在某些情况下，XmlRootElement注释在类型上不可用，并且手动添加它们可能不是一种选择。同样，在方法签名中具有显式的JAXBElements也可能被视为过于侵入。</p><p>在这种情况下，可能要使用“ jaxbElementClassMap”映射属性，其中包含简单或扩展QName对的类名。这也将导致序列化期间的自动JAXBElement转换。最后，当所有实例都需要包装时，可以使用'marshalAsJaxbElement'布尔属性-前提是可以将这些实例的简单类名称用作元素名称。</p><p>反序列化时，可以使用返回JAXBElements的方法更新现有的ObjectFactory，也可以仅在JAXB或JSON提供程序上设置“ unmarshalFromJaxbElement”属性。</p><h2 id="JAX-RSDataBindings-Handlingexplicitcollections">处理显式集合</h2><p>JAXB和JSON提供程序可以处理诸如List，Set或base Collection之类的显式集合。<br clear="none">默认情况下，它们将尝试从集合成员类中推断集合根元素的名称。例如，给定一个@XmlRootElement值为'Book'的Book.class，集合名称的名称为'Books'。<br clear="none">可以通过设置“ collectionWrapperName”字符串属性（例如“ Books”或“ { <span class="nolink">http：// books</span> } Book”）来覆盖它。</p><p>还有一个'collectionWrapperMap'属性可用于更高级的情况，例如，当使用不同类型的集合时，例如，当返回没有@XmlRootElement标记的抽象类派生的对象的混合集合时：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;!-- Configure JAXB Provider --&gt;
&lt;bean id="jaxbProvider"
    class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
    &lt;property name="collectionWrapperMap"&gt;
        &lt;map&gt;
            &lt;entry&gt;
                &lt;key&gt;&lt;value&gt;com.foo.bar.MyObject&lt;/value&gt;&lt;/key&gt;
                &lt;value&gt;MyObjects&lt;/value&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><p>JSONProvider目前只能序列化显式集合。如果需要，可以告诉它使用布尔值“ dropCollectionWrapperElementName”删除集合元素名称。例如，可以使用'dropCollectionWrapperElementName'和'serializeAsArray'属性使Pojo JSON RestStore使用所产生的JSON序列（在CXF 2.2.5中）。</p><h1 id="JAX-RSDataBindings-CustomizingJAXBXMLandJSONinputandoutput">自定义JAXB XML和JSON输入和输出</h1><p>有时，您可能需要调整传入的XML请求或传出的XML响应。例如，您的应用程序已更改，但许多旧客户端尚未更新。<br clear="none">处理XML时，最简单，最快的选择是注册自定义的STAX XMLStreamWriter或XMLStreamReader并根据需要修改XML。您可以注册自定义STAX<br clear="none">RequestHandler或ResponseHandler过滤器或输入/输出CXF拦截器的处理程序。例如，请参阅<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/XmlStreamWriterProvider.java" rel="nofollow">XMLStreamWriterProvider</a>和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/CustomXmlStreamWriter.java" rel="nofollow">CustomXmlStreamWriter</a> 。</p><p>另一种选择是注册自定义JAXB或JSON提供程序，以扩展CXF JAXBElementProvider或JSONProvider并覆盖诸如createStreamWriter（）之类的方法。<br clear="none">通常，首先将一个人委托给一个超类，然后将返回的作家包装在一个自定义作家中，有关示例，请参见<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/CustomXmlStreamWriter.java" rel="nofollow">CustomXmlStreamWriter</a> 。</p><p>也可以使用XSLTJaxbProvider生成或修改传入的XML。实际上，XSLTJaxbProvider可用于为遗留使用者修改JSON之类的格式。</p><p>还请参见CXF中可用的各种相关功能的<a shape="rect" class="external-link" href="http://soa.dzone.com/articles/pragmatic-web-services-apache" rel="nofollow">概述</a> 。</p><p>在CXF 2.2.5中，引入了一项新功能，其目的是在许多情况下归纳和简化自定义JAXB和JSON的方式。</p><p>请注意，从CXF 2.4.0开始，可以改用新的<a shape="rect" href="transformationfeature.html">转换功能</a> 。</p><p>以下配置属性已添加到基本JAXB / JSON AbstractJAXBProvider中：</p><ul class="alternate"><li>映射属性“ outTransformElements”：可用于更改输出元素名称以及更改或删除名称空间；键是要更改的元素，值是新的元素名称。例子：</li></ul><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="outTransformElements"&gt;
    &lt;map&gt;
      &lt;!-- change "book" to "thebook" --&gt;
      &lt;entry key="book" value="thebook"/&gt;
      
      &lt;!-- drop the namespace from "book" --&gt;
      &lt;entry key="{http://books}book" value="book"/&gt; 
      
      &lt;!-- qualify "book" with "http://books" --&gt;
      &lt;entry key="book" value="{http://books}thebook"/&gt; 
      
      &lt;!--  change namespace to "http://books" for all the elements with the "http://book" namespace --&gt;
      &lt;entry key="{http://book}*" value="{http://books}*"/&gt; 
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><ul class="alternate"><li>“ inTransformElements”映射属性：可用于更改输入元素名称以及更改或删除名称空间；有关示例，请参见“ outTransfromElements”属性说明。</li></ul><ul class="alternate"><li>“ outAppendElements”映射属性：可用于将新的简单或限定元素添加到输出；键是新元素，值是新元素之前要附加的元素。例子：</li></ul><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="outAppendElements"&gt;
    &lt;map&gt;
      &lt;!-- append "book" before "thebook" --&gt;
      &lt;entry key="book" value="thebook"/&gt;
      
      &lt;!-- qualify "book" with "http://books" --&gt;
      &lt;entry key="{http://books}book" value="book"/&gt; 
      
      &lt;!-- drop the namespace from the "book" --&gt;
      &lt;entry key="book" value="{http://books}thebook"/&gt; 
      
      &lt;!--  change namespace to "http://book" for all the elements with the "http://books" namespace --&gt;
      &lt;entry key="{http://book}*" value="{http://books}*"/&gt; 
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><ul class="alternate"><li>“ inAppendElements”映射属性：可用于将新的简单或限定元素添加到输入；有关示例，请参见“ outAppendElements”属性说明。</li></ul><ul class="alternate"><li>“ outDropElements”列表属性：可用于在序列化期间删除元素；请注意，子元素（如果有任何给定的放置元素）不会受到影响。例子：</li></ul><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="outDropElements"&gt;
    &lt;list&gt;
      &lt;!-- ignore drop and {http://numbers}number elements --&gt;
      &lt;value&gt;{http://numbers}number&lt;/value&gt;
      &lt;value&gt;index&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt; 
</pre>
</div></div><ul class="alternate"><li>“ inDropElements”列表属性：可用于在反序列化期间删除元素；请注意，子元素（如果有任何给定的放置元素）不会受到影响。请参见示例的“ outDropElements”属性说明。</li></ul><ul class="alternate"><li>“ attributesAsElements”布尔属性：可用于将属性序列化为元素。</li></ul><p>“ attributesAsElements”和“ outDropElements”属性的组合可用于使某些属性在输出中被忽略，方法是先将其转换为元素，然后将其阻止。</p><p>在许多情况下可能会使用此功能。例如，可能有无根的JSON数组集合，例如“ <code>a:b},{c:d</code>通过使用“ wrapperName” JSONProvider属性（具有类似于“ list”的值）来反序列化为bean，该值标识“ bean”字段，并使用“ inAppendMap”属性（其名称附加在“ list”之前） ”，从而有效地将原始JSON序列转换为“ {book：{list： <code>a:b},{c:d</code> }}”。</p><h1 id="JAX-RSDataBindings-ControllingLargeJAXBXMLandJSONinputpayloads">控制大型JAXB XML和JSON输入有效负载</h1><p>从CXF 2.6.0开始，可以在每个端点的基础上控制大型XML和JSON负载的深度，以限制拒绝服务攻击的风险。请参阅<a shape="rect" href="securing-cxf-services.html">本节，</a>以了解如何使用新的DepthRestrictingInterceptor来控制XML负载，该负载由JAXBElementProvider或SourceProvider（支持JAXP Source和DOM Document类型）读取。</p><p>另外，可以使用上下文属性或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/core/src/main/java/org/apache/cxf/staxutils/DocumentDepthProperties.java" rel="nofollow">DocumentDepthProperties</a>配置JAXBElementProvider或JSONProvider：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="depthProperties" class="org.apache.cxf.staxutils.DocumentDepthProperties"&gt;
  &lt;property name="innerElementCountThreshold" value="500"/&gt;
&lt;/bean&gt; 

&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
  &lt;property name="depthProperties" ref="depthProperties"/&gt;
&lt;/bean&gt; 

&lt;bean id="jsonProvider" class="org.apache.cxf.jaxrs.provider.json.JSONProvider"&gt;
  &lt;property name="depthProperties" ref="depthProperties"/&gt;
&lt;/bean&gt; 

&lt;jaxrs:server id="endpoint1"&gt;
  &lt;jaxrs:serviceBeans&gt;
    &lt;bean class="my.package.RootResource"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
  &lt;jaxrs:providers&gt;
    &lt;ref bean="jaxbProvider"/&gt;
    &lt;ref bean="jsonProvider"/&gt;
  &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;

&lt;jaxrs:server id="endpoint2"&gt;
  &lt;jaxrs:serviceBeans&gt;
    &lt;bean class="my.package.RootResource"/&gt;
  &lt;/jaxrs:serviceBeans&gt;
  &lt;jaxrs:properties&gt;
    &lt;entry key="depthInnerElementCountThreshold" value="500"/
  &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;
</pre>
</div></div><h1 id="JAX-RSDataBindings-JSR-353JSONProcessing">JSR-353 JSON处理</h1><p>根据JAX-RS 2.0规范， <a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=353" rel="nofollow">对JSON处理</a>的<a shape="rect" class="external-link" href="http://jcp.org/en/jsr/detail?id=353" rel="nofollow">JSR-353 Java API支持</a>是强制性要求，并且意味着存在以下类型的消息正文阅读器/ <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonStructure.html" rel="nofollow">编写器</a> ： <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonStructure.html" rel="nofollow">JsonStructure</a> ， <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonArray.html" rel="nofollow">JsonArray</a>和<a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonObject.html" rel="nofollow">JsonObject</a> 。Apache CXF以Apache CXF JAX-RS扩展提供程序模块<strong>（cxf-rt-rs-extension-providers）</strong>分发的<strong>JsrJsonpProvider</strong>提供程序的形式提供了这种支持<strong>。</strong></p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:providers&gt;
   &lt;bean class="org.apache.cxf.jaxrs.provider.jsrjsonp.JsrJsonpProvider"/&gt;
&lt;/jaxrs:providers&gt;
</pre>
</div></div><p>单独添加<strong>JsrJsonpProvider</strong>提供程序（或与其他提供程序组合使用），使JAX-RS资源可以将<a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonStructure.html" rel="nofollow">JsonStructure</a> ， <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonArray.html" rel="nofollow">JsonArray</a> ， <a shape="rect" class="external-link" href="http://docs.oracle.com/javaee/7/api/javax/json/JsonObject.html" rel="nofollow">JsonObject</a>本地用作输入参数或返回值。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/books")
@Produces(MediaType.APPLICATION_JSON)
public JsonArray getBooks() {
    // Implementation here
}

@GET
@Path("/books/{bookId}")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject getBook(@PathParam("bookId") Long id) {
    // Implementation here
}

@POST
@Path("/books")
@Consumes(MediaType.APPLICATION_JSON)
public Response addBook(@Context final UriInfo uriInfo, JsonObject obj) {
    // Implementation here
}</pre>
</div></div><p><strong>JsrJsonpProvider</strong>提供程序可以在服务器端或客户端使用。默认情况下，提供程序使用<a shape="rect" class="external-link" href="https://jsonp.java.net/" rel="nofollow">JSR-353 Java API进行JSON处理参考实现</a>来读/写消息正文。</p><h1 id="JAX-RSDataBindings-SimpleJsonMapObjectsupport">简单的JsonMapObject支持</h1><p>org.apache.cxf.jaxrs.provider.json。从CXF 3.0.3和CXF 3.1.0开始可以使用JsonMapObjectProvider。该提供程序可以在org.apache.cxf.jaxrs.provider.json中读取或写入JSON。JsonMapObject是一个简单的Map包装器。</p><p>JsonMapObject可以检测重复的JSON同级属性，这在某些应用程序中可能很有用。</p><h1 id="JAX-RSDataBindings-JSONWithPadding(JSONP)">带有填充的JSON（JSONP）</h1><p>支持“带填充的JSON”（ <a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/JSONP" rel="nofollow">JSONP</a> ）的一种方法是扩展默认的JSONProvider并重写其writeTo方法，如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces("application/javascript")
class JsonpProvider extends JSONProvider {
		
    @Override
    public void writeTo(Object obj, Class&lt;?&gt; cls, Type genericType, Annotation[] anns, MediaType m, 
                        MultivaluedMap&lt;String, Object&gt; headers, OutputStream os) throws IOException {
	    String prefix = getContext().getHttpServletRequest().getParameter("_jsonp");
	    boolean hasPrefix = !isEmpty(prefix);
	    if(hasPrefix) {
	        os.write(prefix.getBytes(HttpUtils.getSetEncoding(m, headers, "UTF-8")));
	        os.write('(');
	    }
	    super.writeTo(obj, cls, genericType, anns, m, headers, os);
	    if(hasPrefix) {
		    os.write(')');
	    }
    }
}
</pre>
</div></div><p>使用杰克逊时，类似的方法也可以使用。</p><p>或者，可以使用自定义servlet过滤器来支持JSONP。</p><p>从CXF 2.3.4和2.4.0开始，借助CXF输入/输出拦截器可以支持JSONP：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="bookJsonp" address="/jsonp"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="serviceBean" /&gt;
    &lt;/jaxrs:serviceBeans&gt;		  

    &lt;jaxrs:inInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpInInterceptor"/&gt;
    &lt;/jaxrs:inInterceptors&gt;
    &lt;jaxrs:outInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPreStreamInterceptor"/&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPostStreamInterceptor"/&gt;
    &lt;/jaxrs:outInterceptors&gt; 
&lt;/jaxrs:server&gt;
</pre>
</div></div><p>JsonpInInterceptor检查JSONP回调查询参数是否可用（默认值为_jsonp），如果是，则将其值保存在当前交换中，以使拦截器知道是否必须编写填充。可以自定义预期的回调参数的名称。JsonpPreStreamInterceptor和JsonpPostStreamInterceptor确保正确地“填充”实际的JSON流。JsonpPreStreamInterceptor还将在默认情况下将Content-Type设置为“ application / x + javascript”，但这可以更改：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="bookJsonp" address="/jsonp"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="serviceBean" /&gt;
    &lt;/jaxrs:serviceBeans&gt;		  

    &lt;jaxrs:inInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpInInterceptor"&gt;
          &lt;property name="callbackParam" value="myjsonp"/&gt;
       &lt;/bean&gt; 
    &lt;/jaxrs:inInterceptors&gt;
    &lt;jaxrs:outInterceptors&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPreStreamInterceptor"&gt;
           &lt;property name="mediaType" value="text/x+javascript"/&gt;
       &lt;/bean&gt;
       &lt;bean class="org.apache.cxf.jaxrs.provider.jsonp.JsonpPostStreamInterceptor"&gt;
           &lt;!-- default is ');' --&gt;
           &lt;property name="paddingEnd" value=")"/&gt;
       &lt;/bean&gt;
    &lt;/jaxrs:outInterceptors&gt; 
&lt;/jaxrs:server&gt;
</pre>
</div></div><h1 id="JAX-RSDataBindings-Formpayloads">表格有效载荷</h1><p>表单有效负载是名称和值对的序列，例如“ name = Barry＆age = 20”。<br clear="none">可以使用JAX-RS FormParam批注或MultivaluedMap捕获表单数据，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">import javax.ws.rs.FormParam;
import javax.ws.rs.MultivaluedMap;

@Path("resource")
public class FormResource {

   @POST
   @Path("/form1")
   @Consumes("application/x-www-form-urlencoded")
   public void form1(@FormParam("name") String name, @FormParam("age") int age) {
   }

   @POST
   @Path("/form2")
   @Consumes("application/x-www-form-urlencoded")
   public void form1(MultivaluedMap&lt;String, String&gt; params) {
       String name = params.getFirst("name");
       String age = params.getFirst("age");
   }

}
</pre>
</div></div><p>注意，可以通过设置上下文属性“ maxFormParameterCount”（在jaxrs：properties中设置）来控制期望的表单参数的最大数量。如果达到限制，客户端将收到HTTP 413。</p><h1 id="JAX-RSDataBindings-Atom">原子</h1><p>CXF JAXRS向用户提供3种处理Atom的选项</p><p>1。注册基于Apache Abdera的Feed和/或Entry提供程序（org.apache.cxf.jaxrs.ext.provider.atom。AtomFeedProvider和org.apache.cxf.jaxrs.ext.provider.atom。AtomEntryProvider）和一个jaxrs端点，并具有显式处理Abdera Feed或Entry类的资源方法。这是最高级的选项，因为它允许用户以最适合的方式构建提要或条目。请注意，Abdera近期并未得到积极维护，但实际上说来，这对于处理开发基于Atom的应用程序可能需要处理的大多数情况非常有用。</p><p>AtomFeedProvider和AtomEntryProvider都支持'formattedOutput'（漂亮打印）属性。</p><p>2。注册一个<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AtomPojoProvider.java" rel="nofollow">AtomPojoProvider</a>注射或者<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AtomElementWriter.java" rel="nofollow">AtomElementWriter</a>或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AtomElementReader.java" rel="nofollow">AtomElementReader</a>由任一馈阿布德拉或Entry和对象，这将具有的类型参数化的实现将被转换到/从进给/条目读出。</p><p>例如，BookAtomElementWriter <feed, book="">将负责将Book实例转换为Feed，而ChapterAtomElementWriter <entry, chapter="">将负责将Chapter实例转换为Entry。</entry,></feed,></p><p>AtomElementWriter和AtomElementReader使用'atomWriters'和'atomReaders'映射属性注入，其中键是要转换为从Feed或条目中读取的对象的类名，例如“ org.apache.cxf.systest.jaxrs”。书”。</p><p>AtomPojoProvider为用户提供了一种方法，使其没有从“主要”应用程序代码中引用的Abdera Feed / Entry类，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("books")
public class BooksRootResource {

    private Books books;

    @GET
    @Produces({"application/xml", "application/json", "application/atom+xml;type=feed"})
    public Books getCollectionOfBooks() {
        return books;
    } 

    @GET
    @Produces({"application/xml", "application/json", "application/atom+xml;type=entry"})
    @Path("{id}")
    public Book getBook(@PathParam("id") Long id) {
        return books.get(id);
    }
}
</pre>
</div></div><p>请注意，当诸如Books之类的对象要从Feed中转换（或从Feed中读取）（在我们的情况下，本质上是一组条目的集合，每个条目代表一本单独的Book），AtomPojoProvider需要了解集合的getter和/或setter。这样它就可以创建单个条目。“ collectionGetters”和“ collectionSetters”映射属性，其中键是集合类的名称，值是方法名称，用于提供此信息，例如，一对“ org.apache.cxf.systest.jaxrs”。Books：getBooks”告诉AtomPojoProvider，在创建Books Feed时，可以借助“ getBooks”从Book中检索代表各个条目的对象。如果未设置这些属性，则AtomPojoProvider将尝试获取将简单类名添加到“ get”或“ set”的方法，例如，“ org.apache.cxf.systest.jaxrs”。如果Books类具有getBooks方法，则Books：getBooks对将是多余的。</p><p>3。此选项与选项2几乎相同，除了用户使用<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AbstractFeedBuilder.java" rel="nofollow">AbstractFeedBuilder</a>或<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AbstractEntryBuilder.java" rel="nofollow">AbstractEntryBuilder的</a>具体实现配置AtomPojoProvider之外。</p><p>区别在于，在这种情况下，用户的代码中没有对诸如Abdera之类的Atom感知库的显式依赖-这可能使尝试各种Atom库更加容易。</p><h1 id="JAX-RSDataBindings-AegisDataBinding">宙斯盾数据绑定</h1><p>使用org.apache.cxf.provider。AegisElementProvider开始使用JAX-RS做Aegis<br clear="none">org.apache.cxf.provider。AegisJSONProvider可用于在Aegis的帮助下输出JSON。<br clear="none">与默认JSONProvider相似，此基于Aegis的JSON提供程序可以设置“ namespaceMap”，“ serializeAsArray”，“ arrayKeys”，“ dropRootElement”和“ writeXsiType”属性。</p><h1 id="JAX-RSDataBindings-XMLBeans">XMLBeans</h1><p>使用org.apache.cxf.provider。XmlBeansElementProvider开始使用JAX-RS做XmlBeans</p><h1 id="JAX-RSDataBindings-CXFDataBindingsasJAX-RSproviders">CXF DataBindings作为JAX-RS提供程序</h1><p>从CXF 2.2.3开始，可以使用jaxrs：databinding元素注册CXF DataBinding bean，并将其包装为能够处理基于XML内容的JAXRS MessageBodyReader / Writer <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/DataBindingProvider.java" rel="nofollow">DataBindingProvider</a> 。结合使用JAX-RS和JAXWS的用户可能会特别感兴趣。因此，可以插入CXF JAXB，JIBX，Aegis，SDO和XMLBeans DataBindings。</p><p>也可以将DataBindingProvider注册为jaxrs：provider，并根据需要设置其dataBinding属性。</p><p><a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/json/DataBindingJSONProvider.java" rel="nofollow">DataBindingJSONProvider</a>还为所有这些数据绑定提供JSON支持。<br clear="none">请参阅<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs_databinding/WEB-INF/beans.xml" rel="nofollow">此配置文件</a>以获取一些示例。</p><p>与默认JSONProvider相似，DataBindingJSONProvider JSON提供程序可以设置“ namespaceMap”，“ serializeAsArray”，“ arrayKeys”，“ dropRootElement”和“ writeXsiType”属性。此外，它可能还设置了“ ignoreMixedContent”属性。</p><p>从CXF 2.4.0和CXF 2.3.2开始，还支持CXF <a shape="rect" href="annotations.html">DataBinding</a>注释。</p><h1 id="JAX-RSDataBindings-JAXRSDataBinding">JAXRS数据绑定</h1><p><strong>从CXF 2.3.2和CXF 2.4.0开始可用</strong></p><p>org.apache.cxf.jaxrs.provider。JAXRSDataBinding是一个CXF DataBinding实现，它包装了JAX-RS提供程序，并且可以由CXF JAX-WS端点使用，因此可以使用JAX-RS提供程序在SOAP和RESTful调用期间读写XML有效负载。范例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="hello_rest" address="/hello-rest"&gt;
    &lt;jaxrs:serviceBeans&gt;
        &lt;bean class="org.apache.cxf.systest.jaxrs.jaxws.HelloWorldImpl"/&gt;
    &lt;/jaxrs:serviceBeans&gt;

    &lt;jaxrs:providers&gt;
        &lt;ref bean="jaxbProviderSoap"/&gt;
    &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;

&lt;jaxws:endpoint xmlns:s="http://hello.com"
    serviceName="s:HelloWorld"
    endpointName="s:HelloWorldPort"
    id="hello_soap-databinding"
    implementor="org.apache.cxf.systest.jaxrs.jaxws.HelloWorldImpl"
    address="/hello-soap-databinding"&gt;
      
    &lt;jaxws:dataBinding&gt;
        &lt;ref bean="jaxrs-data-binding"/&gt;
    &lt;/jaxws:dataBinding&gt;
      
&lt;/jaxws:endpoint&gt;        
 
&lt;bean id="jaxrs-data-binding" class="org.apache.cxf.jaxrs.provider.JAXRSDataBinding"&gt;
    &lt;property name="provider" ref="jaxbProviderSoap"/&gt;
&lt;/bean&gt;

&lt;bean id="jaxbProviderSoap" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"/&gt;
</pre>
</div></div><p>此选项类似于将CXF DataBindings打包为JAX-RS提供程序并将其用于处理JAX-RS端点的数据的选项。这次是SOAP端点依赖于JAX-RS提供程序来正确处理数据。</p><p>如果您想编写自己的自定义XML提供程序并由JAXRSDataBinding进行包装，则自定义MessageBodyReader和MessageBodyWriter实现应准备好接受空的InputStream和OutputStream参数，并从当前CXF消息中检索XMLStreamReader和XMLStreamWriter实例。为了使定制提供程序尽可能地可移植，可能需要遵循以下方法：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">public class PortableXMLProvider implements MessageBodyReader, MessageBodyWriter {

    public Object readFrom(Class&lt;Object&gt; type, Type genericType, Annotation[] anns, MediaType mt, 
                           MultivaluedMap&lt;String, String&gt; headers, InputStream is) 
                           throws IOException {

        XMLStreamReader reader = createReaderUsingStandardStaxApi(is);
        return readFromStream(reader);  

    }

    public void writeTo(Object obj, Class&lt;?&gt; cls, Type genericType, Annotation[] anns,  
                        MediaType m, MultivaluedMap&lt;String, Object&gt; headers, OutputStream os)
                        throws IOException {
        XMLStreamWriter writer = createWriterUsingStandardStaxApi(os);
        writeToStream(writer);  
    }

    // add more parameters if needed
    protected Object readFromStream(XMLStreamReader reader) {
        // read from XMLStreamReader
    }
    
    // add more parameters if needed
    protected void writeToStream(XMLStreamWriter writer) {
        // write to XMLStreamWriter
    }

    
}

public class CXFCustomXMLProvider extends PortableXMLProvider {

    @Override
    public Object readFrom(Class&lt;Object&gt; type, Type genericType, Annotation[] anns, MediaType mt, 
                           MultivaluedMap&lt;String, String&gt; headers, InputStream is) 
                           throws IOException {

        XMLStreamReader reader = getStaxHandlerFromCurrentMessage(XMLStreamReader.class);
        return readFromStream(reader);  

    }

    @Override
    public void writeTo(Object obj, Class&lt;?&gt; cls, Type genericType, Annotation[] anns,  
                        MediaType m, MultivaluedMap&lt;String, Object&gt; headers, OutputStream os)
                        throws IOException {
        XMLStreamWriter writer = getStaxHandlerFromCurrentMessage(XMLStreamWriter.class);
        writeToStream(writer);  
    }


    protected &lt;T&gt; T getStaxHandlerFromCurrentMessage(Class&lt;T&gt; staxCls) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        if (m != null) {
            return staxCls.cast(m.getContent(staxCls));
        }
        return null;
    }
}
</pre>
</div></div><p>请注意，如果您需要对JAX-WS端点的高级数据绑定支持（例如，可能使用WSDL文档中可用的模式进行模式验证-可能会支持将XML有效负载展开为多个方法参数），那么您建议直接使用CXF JAX-WS端点支持的CXF数据绑定之一。</p><p>如果所有资源方法都具有单个参数（例如有效的JAXB类和预期不会包装的响应类型），则此方法可能会起作用。</p><p>使用CXF JAX-RS JAXBElementProvider时，可能需要对其进行调整以正确处理没有XmlRootElement批注的JAXB类，并可以选择创建一个JAXBContext，这是CXF JAXBDataBinding自动完成的。还请注意，JAXBElementProvider并不知道在某些情况下，对于SOAP请求，第一个方法参数的本地名称为“ arg0”，而SOAP响应的本地名称应为“返回”。您可能需要使用JAX-WS WebParam和WebResult批注来创建不同的名称。另外，例如，您可以使用JAXBElementProvider的inTransformElements和outTransformElements属性，将“ arg0”转换为bean名称，例如“ User”，将“ User”转换为“ return”。</p><h1 id="JAX-RSDataBindings-Schemavalidation">模式验证</h1><p><strong>新增内容</strong> ：从CXF 3.0.0-milestone2开始，可能仅指向包含多个架构资源的类路径文件夹。</p><p>可以通过以下方式之一启用模式验证：</p><p>1。使用jaxrs：schemaLocations元素</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans&gt;
    &lt;jaxrs:server address="/" serviceClass="org.apache.cxf.systest.jaxrs.BookStore"&gt;
        &lt;jaxrs:schemaLocations&gt;
             &lt;jaxrs:schemaLocation&gt;classpath:/schemas/a.xsd&lt;/jaxrs:schemaLocation&gt;
             &lt;jaxrs:schemaLocation&gt;classpath:/schemas/b.xsd&lt;/jaxrs:schemaLocation&gt;
             &lt;!-- Possible from CXF 3.0.0 milestone2: --&gt;
             &lt;!-- 
                 &lt;jaxrs:schemaLocation&gt;classpath:/schemas/&lt;/jaxrs:schemaLocation&gt;
             --&gt;  
        &lt;/jaxrs:schemaLocations&gt;
    &lt;/jaxrs:server&gt;
&lt;/beans&gt;
</pre>
</div></div><p>当涉及多个支持架构验证的绑定时，使用此选项非常方便。在这种情况下， <sring>将调用具有方法setSchemas（List <sring>schemaLocations）的各个MessageBodyReader实现， <sring>并注入模式资源的位置。可以启用依赖JAXB的默认JAXBElementProvider和JSONProvider以这种方式进行验证。在上面的示例中，提供了两个模式文档，其中b.xsd模式导入了a.xsd</sring></sring></sring></p><p>2。分别配置提供程序</p><p>可以显式配置JAXB和JSON提供程序，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
   &lt;jaxrs:server address="/" serviceClass="org.apache.cxf.systest.jaxrs.BookStore"&gt;
       &lt;jaxrs:providers&gt;
           &lt;ref bean="jaxbProvider"/&gt;
       &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;

    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
        &lt;property name="schemaLocations" ref="schemaHolder"/&gt;
    &lt;/bean&gt;
  
    &lt;util:list id="theSchemas"&gt;
        &lt;value&gt;classpath:/WEB-INF/schemas/bookid.xsd&lt;/value&gt;
        &lt;value&gt;classpath:/org/apache/cxf/systest/jaxrs/resources/book.xsd&lt;/value&gt;
    &lt;/util:list&gt;
&lt;/beans&gt;
</pre>
</div></div><p>如果同时具有JAXB和JSON提供程序来验证输入数据，则可以获取它们之间共享的模式，例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
    &lt;jaxrs:server address="/" serviceClass="org.apache.cxf.systest.jaxrs.BookStore"&gt;
        &lt;jaxrs:providers&gt;
            &lt;ref bean="jaxbProvider"/&gt;
            &lt;ref bean="jsonProvider"/&gt;
        &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;

    &lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
        &lt;property name="schemaHandler" ref="schemaHolder"/&gt;
    &lt;/bean&gt;

    &lt;bean id="jsonProvider" class="org.apache.cxf.jaxrs.provider.json.JSONProvider"&gt;
        &lt;property name="schemaHandler" ref="schemaHolder"/&gt;
    &lt;/bean&gt;
  
    &lt;bean id="schemaHolder" class="org.apache.cxf.jaxrs.utils.schemas.SchemaHandler"&gt;
        &lt;property name="schemas" ref="theSchemas"/&gt;
    &lt;/bean&gt;
  
    &lt;util:list id="theSchemas"&gt;
        &lt;value&gt;classpath:/WEB-INF/schemas/bookid.xsd&lt;/value&gt;
        &lt;value&gt;classpath:/org/apache/cxf/systest/jaxrs/resources/book.xsd&lt;/value&gt;
    &lt;/util:list&gt;
&lt;/beans&gt;
</pre>
</div></div><p>3。使用SchemaValidation批注</p><p>从CXF 3.0.0开始，可以使用org.apache.cxf.annotations。使用JAX-RS根资源进行SchemaValidation。设置其可选的“ schemas”属性。</p><h2 id="JAX-RSDataBindings-Supportforcatalogs">支持目录</h2><p>从CXF 2.5.5、2.6.2开始可用</p><p>XML目录可用于主模式（用于验证数据），以获取在本地解析的导入或包含的模式资源。<br clear="none">默认情况下，将检查“ META-INF / jax-rs-catalog.xml”，但是可以在JAXBElementProvider或JSONProvider上设置目录位置：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
   &lt;property name="catalogLocation" value="classpath:/schemas/mycatalog.xml"/&gt;
&lt;/bean&gt;
</pre>
</div></div><p>mycatalog.xml可能如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog" prefer="system"&gt;
    &lt;system systemId="http://schemas/bookid.xsd" uri="classpath:WEB-INF/schemas/bookid.xsd"/&gt;
&lt;/catalog&gt;
</pre>
</div></div><h2 id="JAX-RSDataBindings-Outputvalidation">输出验证</h2><p>默认情况下，在找到有效模式后，只有JAXB Unmarshaller会使用它来验证输入。<br clear="none">从CXF 2.3.4和2.4开始，可以使用以下属性来启用输出验证：</p><ul class="alternate"><li>validateOutput</li><li>validateBeforeWrite</li></ul><p>设置'validateOutput'属性将确保JAXBMarshaller在写入数据时将验证输出。可以设置'validateBeforeWrite'属性以确保在将数据写入输出流之前完成验证。</p><h1 id="JAX-RSDataBindings-BeanValidation">Bean验证</h1><p>Bean验证可用于补充模式验证或作为验证的替代形式，请参阅<a shape="rect" href="http://cxf.apache.org/docs/validationfeature.html">此页面</a>以获取更多信息。</p><h1 id="JAX-RSDataBindings-FastInfoset">快速信息集</h1><p>您可以通过在JAXRS端点上显式注册CXF FastInfoset拦截器并配置JAXBElementProvider以支持“ application / fastinfoset”媒体类型来启用<a shape="rect" class="external-link" href="http://www.oracle.com/technetwork/articles/java/fastinfoset-139262.html" rel="nofollow">FastInfoset</a> ：<br clear="none">例如 ：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:server id="restservice3" address="/rest3"&gt;

    &lt;jaxrs:serviceBeans&gt;
        &lt;ref bean="bookstore"/&gt;
    &lt;/jaxrs:serviceBeans&gt;

    &lt;jaxrs:providers&gt;
        &lt;ref bean="jaxbProvider"/&gt;
    &lt;/jaxrs:providers&gt;

    &lt;jaxrs:outInterceptors&gt;
        &lt;ref bean="fastInfosetOutInterceptor"/&gt;
    &lt;/jaxrs:outInterceptors&gt;

    &lt;jaxrs:inInterceptors&gt;
        &lt;ref bean="fastInfosetInInterceptor"/&gt;
    &lt;/jaxrs:inInterceptors&gt;

    &lt;jaxrs:properties&gt;
        &lt;entry key="org.apache.cxf.endpoint.private" value="true"/&gt;
    &lt;/jaxrs:properties&gt;
&lt;/jaxrs:server&gt;

&lt;util:list id="fastinfosetType"&gt;
    &lt;value&gt;application/fastinfoset&lt;/value&gt;
&lt;/util:list&gt;

&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
    &lt;property name="produceMediaTypes" ref="fastinfosetType"/&gt;
    &lt;property name="consumeMediaTypes" ref="fastinfosetType"/&gt;
&lt;/bean&gt;
&lt;bean id="fastInfosetOutInterceptor" class="org.apache.cxf.interceptor.FIStaxOutInterceptor"/&gt;
&lt;bean id="fastInfosetInInterceptor" class="org.apache.cxf.interceptor.FIStaxInInterceptor"/&gt;
</pre>
</div></div><p>请注意，鉴于当前还支持CXF FastInfoset和Feature批注，因此不再需要显式注册拦截器。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=24190800">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=24190800&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>