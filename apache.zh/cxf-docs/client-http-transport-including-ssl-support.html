<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Client HTTP Transport (including SSL support)">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-客户端HTTP传输（包括SSL支持）</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="transports.html">传输</a> > <a href="http-transport.html">HTTP传输</a> > <a href="client-http-transport-including-ssl-support.html">客户端HTTP传输（包括SSL支持）</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1569016566372 {padding: 0px;}
div.rbtoc1569016566372 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1569016566372 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1569016566372">
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Authentication">认证方式</a>
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-BasicAuthentication">基本认证</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-DigestAuthentication">摘要式身份验证</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Supplyingdynamicauthorization">提供动态授权</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-SpnegoAuthentication(Kerberos)">Spnego验证（Kerberos）</a>
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-CredentialDelegation">凭证委派</a></li></ul>
</li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-NTLMAuthentication">NTLM身份验证</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-ProxyAuthentication">代理验证</a></li></ul>
</li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-ConfiguringSSLSupport">配置SSL支持</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-AdvancedConfiguration">进阶设定</a>
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-UsingConfiguration">使用配置</a>
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Namespace">命名空间</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Theconduitelement">导管元件</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Theclientelement">客户端元素</a>
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-ExampleusingtheClientElement">使用客户端元素的示例</a></li></ul>
</li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-ThetlsClientParameterselement">tlsClientParameters元素</a></li></ul>
</li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-UsingWSDL">使用WSDL</a>
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Namespace.1">命名空间</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Theclientelement.1">客户端元素</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Example">例</a></li></ul>
</li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Usingjavacode">使用java代码</a>
<ul class="toc-indentation"><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-HowtoconfiguretheHTTPConduitfortheSOAPClient?">如何为SOAP客户端配置HTTPConduit？</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-HowtouseHTTPConduitConfigurer?">如何使用HTTPConduitConfigurer？</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Howtooverridetheserviceaddress?">如何覆盖服务地址？</a></li></ul>
</li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-ClientCacheControlDirectives">客户端缓存控制指令</a></li></ul>
</li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-ANoteAboutChunking">关于分块的注释</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-Whentosetcustomheaders">何时设置自定义标题</a></li><li><a shape="rect" href="#ClientHTTPTransport(includingSSLsupport)-AsynchronousHTTPConduit">异步HTTP管道</a></li></ul>
</div><h1 id="ClientHTTPTransport(includingSSLsupport)-Authentication">认证方式</h1><h2 id="ClientHTTPTransport(includingSSLsupport)-BasicAuthentication">基本认证</h2><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> &lt;conduit name="{http://example.com/}HelloWorldServicePort.http-conduit"
   xmlns:sec="http://cxf.apache.org/configuration/security"
   xmlns="http://cxf.apache.org/transports/http/configuration"&gt;
   &lt;authorization&gt;
      &lt;sec:UserName&gt;myuser&lt;/sec:UserName&gt;
      &lt;sec:Password&gt;mypasswd&lt;/sec:Password&gt;
      &lt;sec:AuthorizationType&gt;Basic&lt;/sec:AuthorizationType&gt;
   &lt;/authorization&gt;
 &lt;/conduit&gt;
</pre>
</div></div><p>注意：如果您使用的是如上所述的基本身份验证，则可以省略AuthorizationType元素。</p><h2 id="ClientHTTPTransport(includingSSLsupport)-DigestAuthentication">摘要式身份验证</h2><p>与上述相同，但使用AuthorizationType“ Digest”。</p><h2 id="ClientHTTPTransport(includingSSLsupport)-Supplyingdynamicauthorization">提供动态授权</h2><p>您可以实现org.apache.cxf.transport.http.auth。HttpAuthSupplier接口或其实现之一。</p><p>该接口提供的主要方法是：<br clear="none">公共字符串getAuthorization（AuthorizationPolicy authPolicy，URL currentURL，消息，字符串fullHeader）;</p><p>因此，您将获得HttpAuthPolicy，服务URL，CXF消息和完整的Authorization标头。fullHeader是最后一次尝试后服务器发送的授权头。这样，您可以实现多阶段身份验证。您应该返回授权标头以发送到服务器。对于简单的实现，您可以查看org.apache.cxf.transport.http.auth。DefaultBasicAuthSupplier。</p><p>如果在管道上将实现类设置为AuthSupplier，则CXF将使用它。</p><h2 id="ClientHTTPTransport(includingSSLsupport)-SpnegoAuthentication(Kerberos)">Spnego验证（Kerberos）</h2><p>从CXF 2.4.0开始，CXF支持使用标准AuthPolicy机制的Spnego身份验证。通过将AuthPolicy.authorizationType设置为“ Negotiate”来激活Spnego。如果userName留为空白，则将单点登录与TGT（例如Windows登录）一起使用。如果设置了userName，则将建立新的LoginContext并从中创建票证。</p><p>默认情况下，SpnegoAuthSupplier使用Spnego的OID。某些服务器需要用于Kerberos的OID。这可以通过将上下文属性auth.spnego.useKerberosOid设置为“ true”来激活。</p><p>Kerberos配置：</p><p>确保已针对要验证的Kerberos领域正确配置了krb5.conf / krb5.ini<br clear="none">并通过设置java.security.krb5.conf系统属性将其提供给您的应用程序</p><p>登录配置：</p><p>创建一个文件login.conf并使用系统属性java.security.auth.login.config将其提供给CXF。</p><p>该文件应包含：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">CXFClient {
    com.sun.security.auth.module.Krb5LoginModule required client=TRUE useTicketCache=true;
};
</pre>
</div></div><p>样本配置：</p><p>确保Authorization元素包含与login.conf中的Section相同的名称（此处为CXFClient）。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>单点登录的spnego的HTTP管道配置</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> ...
 &lt;conduit name="{http://example.com/}HelloWorldServicePort.http-conduit"
   xmlns="http://cxf.apache.org/transports/http/configuration"&gt;
   &lt;authorization&gt;
      &lt;AuthorizationType&gt;Negotiate&lt;/AuthorizationType&gt;
      &lt;Authorization&gt;CXFClient&lt;/Authorization&gt;
   &lt;/authorization&gt;
 &lt;/conduit&gt;
 ...
</pre>
</div></div><p>如果要显式登录，可以在上述xml配置中使用UserName和Password。如果要使用缓存的票证授予票证，请不要提供它们。</p><p>在Windows上，您还必须确保允许在Java中使用TGT。请参阅： <a shape="rect" class="external-link" href="http://www.javaactivedirectory.com/?page_id=93" rel="nofollow">http</a> : <a shape="rect" class="external-link" href="http://www.javaactivedirectory.com/?page_id=93" rel="nofollow">//www.javaactivedirectory.com/?page_id=93</a></p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>切换到Kerberos OID而不是Spnego</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> ...
 &lt;jaxws:client&gt;
  &lt;jaxws:properties&gt;
   &lt;entry key="auth.spnego.useKerberosOid" value="true"/&gt;
  &lt;/jaxws:properties&gt; 
 &lt;/jaxws:client&gt;
 ...
</pre>
</div></div><h3 id="ClientHTTPTransport(includingSSLsupport)-CredentialDelegation">凭证委派</h3><p>如果需要启用凭据委派，请将“ auth.spnego.requireCredDelegation”属性设置为“ true”。请注意，设置此属性将使接收服务实现凭据委派。</p><p>如果Kerberos凭证在服务请求上下文中已经可用，则可以通过使用'org.ietf.jgss在当前CXF消息上将其设置为Spnego / Kerberos身份验证处理程序来使用该凭证。GSSCredential”密钥。</p><p>这可以通过设置客户端请求上下文属性或扩展'org.apache.cxf.transport.http.auth来在进行客户端调用之前完成。AbstractSpnegoAuthSupplier”。请参阅此<a shape="rect" class="external-link" href="http://cxf.547215.n5.nabble.com/Kerberos-authentication-using-delegation-from-Principal-Ticket-td5711202.html" rel="nofollow">线程</a>以获取有关后一种选项的更多信息。</p><p>请注意，在重用现有凭据的情况下，策略配置不需要引用登录模块名称：</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>单点登录的spnego的HTTP管道配置</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> ...
 &lt;conduit name="{http://example.com/}HelloWorldServicePort.http-conduit"
   xmlns="http://cxf.apache.org/transports/http/configuration"&gt;
   &lt;authorization&gt;
      &lt;AuthorizationType&gt;Negotiate&lt;/AuthorizationType&gt;
   &lt;/authorization&gt;
 &lt;/conduit&gt;
 ...
</pre>
</div></div><h2 id="ClientHTTPTransport(includingSSLsupport)-NTLMAuthentication">NTLM身份验证</h2><p>CXF在Java 5上不支持“开箱即用”的NTLM身份验证，但是通过一些附加的库和配置，我们使用的标准HttpURLConnection对象可以执行NTLM身份验证。在Java 6上，NTLM身份验证内置在Java运行时中，您无需执行任何特殊操作。</p><p>在Java 5上，您需要一个可扩展HttpURLConnection的库来执行此操作。请参阅： <a shape="rect" class="external-link" href="http://jcifs.samba.org/src/docs/httpclient.html" rel="nofollow">http</a> ://jcifs.samba.org/src/docs/httpclient.html注意：jcifs是LGPL许可的，而不是Apache许可的。</p><p>接下来，您需要配置jcifs以使用正确的域，wins服务器等。请注意<br clear="none">注释掉设置用于NTLM的用户名/密码的位。如果凭据是<br clear="none">缺少的jcifs将使用基础NT凭据。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">//Set the jcifs properties
jcifs.Config.setProperty("jcifs.smb.client.domain", "ben.com");
jcifs.Config.setProperty("jcifs.netbios.wins", "xxx.xxx.xxx.xxx");
jcifs.Config.setProperty("jcifs.smb.client.soTimeout", "300000"); // 5 minutes
jcifs.Config.setProperty("jcifs.netbios.cachePolicy", "1200"); // 20 minutes
//jcifs.Config.setProperty("jcifs.smb.client.username", "myNTLogin");
//jcifs.Config.setProperty("jcifs.smb.client.password", "secret");

//Register the jcifs URL handler to enable NTLM
jcifs.Config.registerSmbURLHandler();
</pre>
</div></div><p>最后，您需要设置CXF客户端以关闭分块。原因是NTLM身份验证需要3个部分的握手，这会中断流式传输。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">//Turn off chunking so that NTLM can occur
Client client = ClientProxy.getClient(port);
HTTPConduit http = (HTTPConduit) client.getConduit();
HTTPClientPolicy httpClientPolicy = new HTTPClientPolicy();
httpClientPolicy.setConnectionTimeout(36000);
httpClientPolicy.setAllowChunking(false);
http.setClient(httpClientPolicy);
</pre>
</div></div><p>有关NTLM的更多信息，请参见<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Asynchronous+Client+HTTP+Transport">异步HTTP管道</a> 。</p><h2 id="ClientHTTPTransport(includingSSLsupport)-ProxyAuthentication">代理验证</h2><p>代理身份验证可以配置如下。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> &lt;conduit name="{http://example.com/}HelloWorldServicePort.http-conduit"
   xmlns:sec="http://cxf.apache.org/configuration/security"
   xmlns="http://cxf.apache.org/transports/http/configuration"&gt;
   &lt;proxyAuthorization&gt;
      &lt;sec:UserName&gt;myuser&lt;/sec:UserName&gt;
      &lt;sec:Password&gt;mypasswd&lt;/sec:Password&gt;
   &lt;/proxyAuthorization&gt;
   &lt;client AllowChunking="false" ProxyServer="localhost" ProxyServerPort="8080" /&gt;
 &lt;/conduit&gt;</pre>
</div></div><p>该作品通过HTTPS和HTTPS，但要注意后者，有必要设置下面的系统属性（见<a shape="rect" class="external-link" href="https://www.oracle.com/technetwork/java/javase/8u111-relnotes-3124969.html" rel="nofollow">这里</a>获得更多信息“禁用基本身份验证HTTPS隧道”）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">-Djdk.http.auth.tunneling.disabledSchemes=</pre>
</div></div><p><br clear="none"></p><h1 id="ClientHTTPTransport(includingSSLsupport)-ConfiguringSSLSupport">配置SSL支持</h1><p>使用“ https” URL时，默认情况下，CXF将使用属于JDK的证书和密钥库。对于许多HTTPs应用程序来说，这就足够了，不需要进行任何配置。但是，在使用自定义客户端证书或自签名服务器证书或类似证书时，可能需要在密钥库和信任管理器中进行专门配置，以建立SSL连接。</p><p>要将客户端配置为使用SSL，您需要<http:conduit>在XML配置文件中添加一个<http:conduit>定义。请参阅《 <a shape="rect" href="configuration.html">配置</a>指南》以了解如何向CXF提供您自己的XML配置文件。如果您已经在使用Spring，则可以将其添加到现有的bean定义中。</http:conduit></http:conduit></p><p>在CXF发行版中可以找到<a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/wsdl_first_https/" rel="nofollow">wsdl_first_https</a>示例的更多信息。</p><p>以下是管道定义的示例：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:sec="http://cxf.apache.org/configuration/security"
  xmlns:http="http://cxf.apache.org/transports/http/configuration"
  xmlns:jaxws="http://java.sun.com/xml/ns/jaxws"
  xsi:schemaLocation="
      http://cxf.apache.org/configuration/security
      http://cxf.apache.org/schemas/configuration/security.xsd
      http://cxf.apache.org/transports/http/configuration
      http://cxf.apache.org/schemas/configuration/http-conf.xsd
      http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;

  &lt;http:conduit name="{http://apache.org/hello_world}HelloWorld.http-conduit"&gt;

    &lt;http:tlsClientParameters&gt;
      &lt;sec:keyManagers keyPassword="password"&gt;
        &lt;sec:keyStore type="JKS" password="password"
                      file="my/file/dir/Morpit.jks"/&gt;
      &lt;/sec:keyManagers&gt;
      &lt;sec:trustManagers&gt;
        &lt;sec:keyStore type="JKS" password="password"
                      file="my/file/dir/Truststore.jks"/&gt;
      &lt;/sec:trustManagers&gt;
      &lt;sec:cipherSuitesFilter&gt;
        &lt;!-- these filters ensure that a ciphersuite with
             export-suitable or null encryption is used,
             but exclude anonymous Diffie-Hellman key change as
             this is vulnerable to man-in-the-middle attacks --&gt;
        &lt;sec:include&gt;.*_EXPORT_.*&lt;/sec:include&gt;
        &lt;sec:include&gt;.*_EXPORT1024_.*&lt;/sec:include&gt;
        &lt;sec:include&gt;.*_WITH_DES_.*&lt;/sec:include&gt;
        &lt;sec:include&gt;.*_WITH_AES_.*&lt;/sec:include&gt;
        &lt;sec:include&gt;.*_WITH_NULL_.*&lt;/sec:include&gt;
        &lt;sec:exclude&gt;.*_DH_anon_.*&lt;/sec:exclude&gt;
      &lt;/sec:cipherSuitesFilter&gt;
    &lt;/http:tlsClientParameters&gt;
    &lt;http:authorization&gt;
      &lt;sec:UserName&gt;Betty&lt;/sec:UserName&gt;
      &lt;sec:Password&gt;password&lt;/sec:Password&gt;
    &lt;/http:authorization&gt;
    &lt;http:client AutoRedirect="true" Connection="Keep-Alive"/&gt;

  &lt;/http:conduit&gt;

&lt;/beans&gt;
</pre>
</div></div><p>首先要注意的是上的“名称”属性<http:conduit>。这允许CXF将此HTTP管道配置与特定的WSDL端口相关联。该名称包括服务的名称空间，WSDL端口名称（在WSDL的wsdl：service部分中找到）和“ .http-conduit”。它遵循以下模板：“ {WSDL命名空间} portName.http-conduit”。注意：这是端口名称，而不是服务名称。因此，可能类似于“ MyServicePort”，而不是“ MyService”。如果您无法使模板正常工作，则名称值的另一个（临时）选项就是“ * .http-conduit”。</http:conduit></p><p>名称属性的另一个选项是端点的原始URL的正则表达式（例如，“ http：// localhost：*”）。该配置在管道创建时匹配，因此名称中可以使用WSDL中使用的地址或JAX-WS Service.create（...）调用中使用的地址。例如，您可以执行以下操作：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">   &lt;http:conduit name="http://localhost:8080/.*"&gt;
       ......
   &lt;/http:conduit&gt;
</pre>
</div></div><p>为localhost：8080上的所有交互配置管道。如果您有多个客户端与同一服务器上的不同服务进行交互，则这可能是配置它的最简单方法。</p><p>如果您的服务端点使用SSL WSDL位置（即“ https：// xxx？wsdl”），则可以使用硬编码的http管道名称“ {{ <a shape="rect" href="http://cxf.apache.org/">http：// cxf .apache.org</a> } TransportURIResolver.http-conduit”。仍然可以使用特定的HTTP管道名称或reg-ex表达式。</p><p>密钥库（由上面的sec：keyStore元素标识）可以通过以下三种方式中的任何一种来标识：通过文件，资源或url属性。文件位置可以是绝对路径，也可以是相对于工作目录的路径，资源属性是相对于类路径的路径，URL必须是有效的URL，例如“ http：// ...”，“ file：/// ...”。 ”等。只允许使用“ url”，“ file”或“ resource”的一个属性。</p><h1 id="ClientHTTPTransport(includingSSLsupport)-AdvancedConfiguration">进阶设定</h1><p>HTTP客户端端点可以指定许多HTTP连接属性，包括端点是否自动接受重定向响应，端点是否可以使用分块，端点是否将请求保持活动状态以及端点如何与代理交互。</p><p>可以使用三种机制配置客户端端点：</p><ul><li>组态</li><li>WSDL</li><li>Java代码</li></ul><h2 id="ClientHTTPTransport(includingSSLsupport)-UsingConfiguration">使用配置</h2><h3 id="ClientHTTPTransport(includingSSLsupport)-Namespace">命名空间</h3><p>用于配置HTTP客户端的元素在名称空间中定义<code><a shape="rect" href="http://cxf.apache.org/transports/http/configuration">http://cxf.apache.org/transports/http/configuration</a></code> 。通常使用前缀来指代<code>http-conf</code> 。为了使用HTTP配置元素，您需要将以下所示的行添加到端点的配置文件的bean元素中。此外，您需要将配置元素的名称空间添加到<code>xsi:schemaLocation</code>属性。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>HTTP使用者配置命名空间</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans ...
       xmlns:http-conf="http://cxf.apache.org/transports/http/configuration
       ...
       xsi:schemaLocation="...
           http://cxf.apache.org/transports/http/configuration
           http://cxf.apache.org/schemas/configuration/http-conf.xsd
       ..."&gt;
</pre>
</div></div><h3 id="ClientHTTPTransport(includingSSLsupport)-Theconduitelement">的<code>conduit</code>元件</h3><p>您可以使用<code>http-conf:conduit</code>元素及其子元素。的<code>http-conf:conduit</code>元素具有单个属性， <code>name</code> ，它指定与端点相对应的WSDL端口元素。的价值<code>name</code>属性的形式为<em>portQName</em> <code>.http-conduit</code> 。例如，以下代码显示了<code>http-conf:conduit</code>元素，用于为WSDL片段指定的端点添加配置<code><port binding="widgetSOAPBinding" name="widgetSOAPPort></code>如果端点的目标名称空间是<code><a shape="rect" class="external-link" href="http://widgets.widgetvendor.net" rel="nofollow">http://widgets.widgetvendor.net</a></code> 。或者， <code>name</code>属性可以是与URL匹配的正则表达式。这允许配置不用于基于WSDL的端点（例如JAX-RS）和WSDL检索的管道。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>http-conf：conduit元素</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">...
  &lt;http-conf:conduit name="{http://widgets/widgetvendor.net}widgetSOAPPort.http-conduit"&gt;
    ...
  &lt;/http-conf:conduit&gt;

  &lt;http-conf:conduit name="*.http-conduit"&gt;
  &lt;!-- you can also using the wild card to specify 
       the http-conduit that you want to configure --&gt;
    ...
  &lt;/http-conf:conduit&gt;

  &lt;http-conf:conduit name="http://localhost:8080/.*"&gt;
  &lt;!-- you can also using the reg-ex URL matching for 
       the http-conduit that you want to configure --&gt;
    ...
  &lt;/http-conf:conduit&gt;
...
</pre>
</div></div><p>的<code>http-conf:conduit</code>元素具有许多指定配置信息的子元素。如下所述。有关配置SSL的更多信息，另请参见Sun的<a shape="rect" class="external-link" href="http://java.sun.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html" rel="nofollow">JSSE指南</a> 。</p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>元件</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>http-conf:client</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定HTTP连接属性，例如超时，保持活动请求，内容类型等。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>http-conf:authorization</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定用于配置端点抢先使用的基本身份验证方法的参数。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>http-conf:proxyAuthorization</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定用于针对传出HTTP代理服务器配置基本身份验证的参数。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>http-conf:tlsClientParameters</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定用于配置SSL / TLS的参数。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>http-conf:authSupplier</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定对象的Bean引用或类名，该对象将抢先或响应401 HTTP挑战提供端点使用的身份验证信息。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>http-conf:trustDecider</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定检查HTTP（S）URLConnection对象的对象的bean引用或类名，以便在传输任何信息之前建立对与HTTPS服务提供者的连接的信任。</p></td></tr></tbody></table></div><h3 id="ClientHTTPTransport(includingSSLsupport)-Theclientelement">的<code>client</code>元件</h3><p>的<code>http-conf:client</code>元素用于配置客户端的HTTP连接的非安全性属性。如下所述，其属性指定连接的属性。</p><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup span="1"><col span="1"><col span="1"></colgroup><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>属性</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>ConnectionTimeout</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户端在超时之前将尝试建立连接的时间（以毫秒为单位）。默认值为30000（30秒）。<br class="atl-forced-newline" clear="none">0指定客户端将继续尝试无限期地打开连接。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>ReceiveTimeout</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户端在超时之前等待响应的时间（以毫秒为单位）。默认值为60000。<br class="atl-forced-newline" clear="none">0指定客户端将无限期等待。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>AutoRedirect</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户端是否将自动遵循服务器发出的重定向。默认为false。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>MaxRetransmits</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户端将重新发送请求以满足重定向的最大次数。默认值为-1，它指定允许无限制的重传。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>AllowChunking</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户端是否将使用分块发送请求。默认值为true，它指定客户端在发送请求时将使用分块。<br class="atl-forced-newline" clear="none">如果满足以下任一条件，则不能使用分块：</p><ul><li><code>http-conf:basicAuthSupplier</code>配置为抢先提供凭据。</li><li><code>AutoRedirect</code>设置为true。<br class="atl-forced-newline" clear="none">在这两种情况下， <code>AllowChunking</code>被忽略，不允许分块。<br class="atl-forced-newline" clear="none">请参阅下面有关分块的注释。</li></ul></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>ChunkingThreshold</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定CXF从非分块切换到分块的阈值。默认情况下，小于4K的消息被缓冲并以非分块方式发送。达到此阈值后，将对消息进行分块。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Accept</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户端准备处理的媒体类型。该值用作HTTP的值<code>Accept</code>属性。使用多用途Internet邮件扩展（MIME）类型指定属性的值。请参阅下面有关分块的注释。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>AcceptLanguage</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户为了接收响应而首选的语言（例如，美国英语）。该值用作HTTP AcceptLanguage属性的值。<br class="atl-forced-newline" clear="none">语言标签受国际标准组织（ISO）的监管，通常通过组合由ISO-639标准确定的语言代码和由ISO-3166标准确定的国家代码（由连字符分隔）组成。例如，en-US代表美国英语。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>AcceptEncoding</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定客户端准备处理的内容编码。内容编码标签由互联网号码分配机构（IANA）监管。该值用作HTTP的值<code>AcceptEncoding</code>属性。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>ContentType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定消息正文中要发送的数据的媒体类型。使用多用途Internet邮件扩展（MIME）类型指定媒体类型。该值用作HTTP的值<code>ContentType</code>属性。默认是<code>text/xml</code> 。<br class="atl-forced-newline" clear="none"><strong>提示：</strong>对于Web服务，应将其设置为<code>text/xml</code> 。如果客户端将HTML表单数据发送到CGI脚本，则应将其设置为application / x-www-form-urlencoded。如果HTTP POST请求绑定到固定的有效负载格式（与SOAP相反），则内容类型通常设置为application / octet-stream。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Host</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定在其上调用请求的资源的Internet主机和端口号。该值用作HTTP的值<code>Host</code>属性。<br class="atl-forced-newline" clear="none"><strong>提示：</strong>通常不需要此属性。只有某些DNS方案或应用程序设计才需要它。例如，它指示客户端首选群集的主机（即，映射到同一Internet协议（IP）地址的虚拟服务器）的主机。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Connection</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定在每个请求/响应对话框之后是要保持打开还是关闭特定连接。有两个有效值：</p><ul><li><code>Keep-Alive</code> （默认）指定客户端要在初始请求/响应序列之后保持其连接打开。如果服务器认可它，则连接将保持打开状态，直到使用者关闭它为止。</li><li><code>close</code>指定在每个请求/响应序列之后关闭与服务器的连接。</li></ul></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>CacheControl</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定关于包含从客户端到服务器的请求的链中涉及的缓存必须遵守的行为的指令。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Cookie</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定要与所有请求一起发送的静态cookie。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>BrowserType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定有关发出请求的浏览器的信息。在万维网联合会（W3C）的HTTP规范中，这也称为<em>用户代理</em> 。某些服务器根据正在发送请求的客户端进行优化。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>Referer</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定指示使用者在特定服务上发出请求的资源的URL。该值用作HTTP Referer属性的值。<br class="atl-forced-newline" clear="none"><strong>注意：</strong>当请求是浏览器用户单击超链接而不是键入URL的结果时，将使用此HTTP属性。这可以允许服务器基于先前的任务流优化处理，并生成指向资源的反向链接列表，以进行日志记录，优化缓存，跟踪过时或错误键入的链接等。但是，它通常不用于Web服务应用程序。<br class="atl-forced-newline" clear="none"><strong>重要说明：</strong>如果AutoRedirect属性设置为true，并且请求被重定向，则Refererattribute中指定的任何值都将被覆盖。HTTP Referer属性的值将设置为重定向使用者原始请求的服务的URL。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>DecoupledEndpoint</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定去耦端点的URL，以通过单独的服务器->客户端连接来接收响应。<br class="atl-forced-newline" clear="none"><strong>警告：</strong>必须将客户端和服务器都配置为使用WS-Addressing，以使去耦的端点正常工作。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>ProxyServer</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定通过其路由请求的代理服务器的URL。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>ProxyServerPort</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定通过其路由请求的代理服务器的端口号。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd">非代理主机</td><td colspan="1" rowspan="1" class="confluenceTd">指定应直接路由的主机列表。此值是由“ |”分隔的模式列表，其中每个模式可以以“ *”开头或结尾以进行通配符匹配。</td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><code>ProxyServerType</code></p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定用于路由请求的代理服务器的类型。有效值为：</p><ul><li>HTTP（默认）</li><li>袜子</li></ul></td></tr></tbody></table></div><h4 id="ClientHTTPTransport(includingSSLsupport)-ExampleusingtheClientElement">使用示例<code>Client</code>元件</h4><p>下面的示例显示了一个HTTP客户端的配置，该配置希望在请求之间保持与服务器的连接打开，每次调用仅重传一次请求，并且不能使用分块流。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>HTTP使用者端点配置</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:http-conf="http://cxf.apache.org/transports/http/configuration"
       xsi:schemaLocation="http://cxf.apache.org/transports/http/configuration
           http://cxf.apache.org/schemas/configuration/http-conf.xsd
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

  &lt;http-conf:conduit name="{http://apache.org/hello_world_soap_http}SoapPort.http-conduit"&gt;
    &lt;http-conf:client Connection="Keep-Alive"
                      MaxRetransmits="1"
                      AllowChunking="false" /&gt;
  &lt;/http-conf:conduit&gt;
&lt;/beans&gt;
</pre>
</div></div><p>再次，请参阅“ <a shape="rect" href="configuration.html">配置”页面</a>以获取有关如何获取CXF来检测配置文件的信息。</p><h3 id="ClientHTTPTransport(includingSSLsupport)-ThetlsClientParameterselement">的<code>tlsClientParameters</code>元件</h3><p>请参阅“ <a shape="rect" href="tls-configuration.html">TLS配置”</a>页面以获取更多信息。</p><h2 id="ClientHTTPTransport(includingSSLsupport)-UsingWSDL">使用WSDL</h2><h3 id="ClientHTTPTransport(includingSSLsupport)-Namespace.1">命名空间</h3><p>在名称空间中定义了用于配置HTTP客户端的WSDL扩展元素<code><a shape="rect" href="http://cxf.apache.org/transports/http/configuration">http://cxf.apache.org/transports/http/configuration</a></code> 。通常使用前缀来指代<code>http-conf</code> 。为了使用HTTP配置元素，您需要将以下所示的行添加到<code>definitions</code>端点的WSDL文档的元素。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>HTTP使用者WSDL元素的命名空间</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;definitions ...
   xmlns:http-conf="http://cxf.apache.org/transports/http/configuration
</pre>
</div></div><h3 id="ClientHTTPTransport(includingSSLsupport)-Theclientelement.1">的<code>client</code>元件</h3><p>的<code>http-conf:client</code>元素用于指定WSDL文档中HTTP客户端的连接属性。的<code>http-conf:client</code>元素是WSDL的子元素<code>port</code>元件。它具有与<code>client</code>配置文件中使用的元素。</p><h3 id="ClientHTTPTransport(includingSSLsupport)-Example">例</h3><p>下面的示例显示了一个WSDL片段，该片段配置HTTP客户端以指定它将不与缓存交互。</p><div class="code panel pdl" style="border-width:1px"><div class="codeHeader panelHeader pdl" style="border-bottom-width:1px"><b>WSDL配置HTTP使用者端点</b></div><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;service ...&gt;
  &lt;port ...&gt;
    &lt;soap:address ... /&gt;
    &lt;http-conf:client CacheControl="no-cache" /&gt;
  &lt;/port&gt;
&lt;/service&gt;
</pre>
</div></div><h2 id="ClientHTTPTransport(includingSSLsupport)-Usingjavacode">使用java代码</h2><h3 id="ClientHTTPTransport(includingSSLsupport)-HowtoconfiguretheHTTPConduitfortheSOAPClient?">如何为SOAP客户端配置HTTPConduit？</h3><p>首先，您需要从Proxy对象或客户端获取<a shape="rect" class="external-link" href="http://tinyurl.com/285zll" rel="nofollow">HTTPConduit</a> ，然后可以设置<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/rt/transports/http/src/main/resources/schemas/configuration/http-conf.xsd" rel="nofollow">HTTPClientPolicy</a> ，AuthorizationPolicy，ProxyAuthorizationPolicy和<a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/core/src/main/java/org/apache/cxf/configuration/jsse/TLSParameterBase.java" rel="nofollow">TLSClientParameters。</a></p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">  import org.apache.cxf.endpoint.Client;
  import org.apache.cxf.frontend.ClientProxy;
  import org.apache.cxf.transport.http.HTTPConduit;
  import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;
  ...

  URL wsdl = getClass().getResource("wsdl/greeting.wsdl");
  SOAPService service = new SOAPService(wsdl, serviceName);
  Greeter greeter = service.getPort(portName, Greeter.class);

  // Okay, are you sick of configuration files ?
  // This will show you how to configure the http conduit dynamically
  Client client = ClientProxy.getClient(greeter);
  HTTPConduit http = (HTTPConduit) client.getConduit();

  HTTPClientPolicy httpClientPolicy = new HTTPClientPolicy();

  httpClientPolicy.setConnectionTimeout(36000);
  httpClientPolicy.setAllowChunking(false);
  httpClientPolicy.setReceiveTimeout(32000);

  http.setClient(httpClientPolicy);

  ...
  greeter.sayHi("Hello");
</pre>
</div></div><h3 id="ClientHTTPTransport(includingSSLsupport)-HowtouseHTTPConduitConfigurer?">如何使用HTTPConduitConfigurer？</h3><p>在某些情况下，可以重新创建HTTPConduit，从而失去了预配置的策略。为了克服这个问题，引入了HTTPConduitConfigurer。这是如何使用它的示例。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default"> HTTPConduitConfigurer httpConduitConfigurer = new HTTPConduitConfigurer() {
    public void configure(String name, String address, HTTPConduit c) {
        HTTPClientPolicy httpClientPolicy = new HTTPClientPolicy();
            
        httpClientPolicy.setConnectionTimeout(36000);
        httpClientPolicy.setAllowChunking(false);
        httpClientPolicy.setReceiveTimeout(32000);
             
        c.setClient(httpClientPolicy);
    }
}
    
bus.setExtension(httpConduitConfigurer, HTTPConduitConfigurer.class);
</pre>
</div></div><p class="code-java"><br clear="none"><br clear="none"></p><h3 id="ClientHTTPTransport(includingSSLsupport)-Howtooverridetheserviceaddress?">如何覆盖服务地址？</h3><p>如果您正在使用JAXWS API创建代理对象，那么以下示例是完整的JAX-WS兼容代码</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">   URL wsdlURL = MyService.class.getClassLoader
            .getResource ("myService.wsdl");
   QName serviceName = new QName("urn:myService", "MyService");
   MyService service = new MyService(wsdlURL, serviceName);
   ServicePort client = service.getServicePort();
   BindingProvider provider = (BindingProvider)client;
   // You can set the address per request here
   provider.getRequestContext().put(
        BindingProvider.ENDPOINT_ADDRESS_PROPERTY,
        "http://my/new/url/to/the/service");

</pre>
</div></div><p>如果使用CXF ProxyFactoryBean创建代理对象，则可以这样</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">   
   JaxWsProxyFactoryBean proxyFactory = new JaxWsProxyFactoryBean();
   poxyFactory.setServiceClass(ServicePort.class);
   // you could set the service address with this method
   proxyFactory.setAddress("theUrlyouwant");
   ServicePort client = (ServicePort) proxyFactory.create();    
</pre>
</div></div><p>这是利用JAXWS的Service.addPort（）API的另一种方法</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">   URL wsdlURL = MyService.class.getClassLoader.getResource("service2.wsdl");
   QName serviceName = new QName("urn:service2", "MyService");
   QName portName = new QName("urn:service2", "ServicePort");
   MyService service = new MyService(wsdlURL, serviceName);
   // You can add whatever address as you want
   service.addPort(portName, "http://schemas.xmlsoap.org/soap/", "http://the/new/url/myService");
   // Passing the SEI class that is generated by wsdl2java      
   ServicePort proxy = service.getPort(portName, SEI.class);
</pre>
</div></div><h2 id="ClientHTTPTransport(includingSSLsupport)-ClientCacheControlDirectives">客户端缓存控制指令</h2><p>下表列出了HTTP客户端支持的缓存控制指令。</p><div class="table-wrap"><table class="wrapped confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>指示</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>行为</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>无缓存</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>缓存必须先通过服务器重新验证该响应，然后才能使用特定响应来满足后续请求。如果使用此值指定了特定的响应头字段，则该限制仅适用于响应内的那些头字段。如果未指定响应头字段，则该限制将应用于整个响应。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>没有商店</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>缓存不得存储响应的任何部分或调用响应的请求的任何部分。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>最大年龄</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>消费者可以接受年龄不超过指定时间（以秒为单位）的响应。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>最大陈旧</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>消费者可以接受超过其到期时间的响应。如果将值分配给max-stale，则表示超出响应过期时间的秒数，直到此时间，消费者仍可以接受该响应。如果未分配任何值，则意味着消费者可以接受任何年龄的陈旧响应。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>最小新鲜</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>消费者希望在至少指定的指定秒数内仍保持响应。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>无变换</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>缓存不得在提供者与使用者之间的响应中修改媒体类型或内容的位置。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>仅在缓存时</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>缓存应仅返回当前存储在缓存中的响应，而不返回需要重新加载或重新验证的响应。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>缓存扩展</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>指定其他缓存指令的其他扩展。扩展可能是信息性的或行为性的。扩展指令是在标准指令的上下文中指定的，因此，不了解扩展指令的应用程序至少可以遵守标准指令规定的行为。</p></td></tr></tbody></table></div><h1 id="ClientHTTPTransport(includingSSLsupport)-ANoteAboutChunking">关于分块的注释</h1><p>有两种方法可以将主体放入HTTP流：</p><ul><li>大多数浏览器使用的“标准”方式是在HTTP标头中指定Content-Length标头。这使接收器可以知道将要接收多少数据以及何时停止读取。这种方法的问题是长度需要预先确定。由于需要预先计算长度，因此无法流式生成数据。因此，如果关闭了分块，则需要将数据缓冲在字节缓冲区（如果太大，则为临时文件）中，以便可以计算Content-Length。</li><li>块-在此模式下，数据以块的形式发送到接收器。每个块前面都有一个十六进制的块大小。当块大小为0时，接收方知道已接收到所有数据。这种模式提供了更好的流，因为我们只需要缓冲少量（默认情况下最多8K），并且当缓冲区填满时，写出块。</li></ul><p>通常，Chunked会更好地执行，因为流可以直接进行。但是，分块存在一些问题：</p><ul><li>许多代理服务器不了解它，尤其是较旧的代理服务器。许多代理服务器都希望Content-Length在前面，因此它们可以在将请求传递到真实服务器之前分配一个缓冲区来存储请求。</li><li>一些较旧的WebServices堆栈也存在Chunking问题。具体地说，是旧版本的.NET。</li></ul><p>如果在尝试与服务交互时遇到奇怪的错误（通常不是肥皂故障，而是其他HTTP类型错误），请尝试关闭分块以查看是否有帮助。</p><h1 id="ClientHTTPTransport(includingSSLsupport)-Whentosetcustomheaders">何时设置自定义标题</h1><p>如果您使用自定义CXF拦截器来设置一个或多个出站HTTP标头，则建议在写出站正文之前，使此拦截器在WRITE阶段之前的阶段运行。</p><p>否则，自定义标题可能会丢失。在某些情况下，即使在写完正文之后添加标头，在某些情况下也可能保留标头，例如，当未达到分块阈值（默认为4K）时，</p><p>但是依靠它来确保标题不丢失是脆弱的，应避免使用。</p><h1 id="ClientHTTPTransport(includingSSLsupport)-AsynchronousHTTPConduit">异步HTTP管道</h1><p>有关更多信息，请参见“ <a shape="rect" href="asynchronous-client-http-transport.html">异步HTTP管道”</a>页面。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=49941">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=49941&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>