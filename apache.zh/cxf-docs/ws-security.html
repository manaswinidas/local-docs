<html ><head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - WS-Security">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>Apache CXF-WS-安全性</title>
  </head>
<body  onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td id="cell-0-0" colspan="2"> </td>
    <td id="cell-0-1"> </td>
    <td id="cell-0-2" colspan="2"> </td>
  </tr>
  <tr>
    <td id="cell-1-0"> </td>
    <td id="cell-1-1"> </td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight:bold;font-size:170%;color:white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="阿帕奇软件基金会"><img border="0" alt="ASF徽标" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></tbody></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tbody><tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs --> <a href="index.html">索引</a> > <a href="ws-support.html">WS- *支持</a> > <a href="ws-security.html">WS-Security</a> <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">下载</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">文献资料</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </tbody></table>
      </div>
    </td>
    <td id="cell-1-3"> </td>
    <td id="cell-1-4"> </td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2"> </td>
    <td id="cell-2-1">
      <table>
        <tbody><tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">总览</a></li><li><a shape="rect" href="how-tos.html">操作方法</a></li><li><a shape="rect" href="frontends.html">前端</a></li><li><a shape="rect" href="databindings.html">数据绑定</a></li><li><a shape="rect" href="transports.html">运输工具</a></li><li><a shape="rect" href="configuration.html">组态</a></li><li><a shape="rect" href="debugging-and-logging.html">调试和记录</a></li><li><a shape="rect" href="tools.html">工具类</a></li><li><a shape="rect" href="restful-services.html">RESTful服务</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL绑定</a></li><li><a shape="rect" href="service-routing.html">服务路由</a></li><li><a shape="rect" href="dynamic-languages.html">动态语言</a></li><li><a shape="rect" href="ws-support.html">WS- *支持</a></li><li><a shape="rect" href="advanced-integration.html">进阶整合</a></li><li><a shape="rect" href="deployment.html">部署方式</a></li><li><a shape="rect" href="schemas-and-namespaces.html">模式和命名空间的使用</a></li></ul><hr><ul class="alternate"><li><p>搜索</p></li></ul><form id="cse-search-box" enctype="application/x-www-form-urlencoded" method="get" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="搜索">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x（Javadoc）</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF网站</a></li></ul><p> </p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><h1 id="WS-Security-WS-Security">WS-安全性</h1><p>WS-Security提供了在传输级别协议（例如HTTPS）之上和之外保护服务安全的方法。通过多种标准（例如XML加密）和WS-Security标准中定义的标头，它使您能够：</p><ul><li>在服务之间传递身份验证令牌</li><li>加密消息或部分消息</li><li>签名消息</li><li>时间戳消息</li><li>使用<a shape="rect" href="http://cxf.apache.org/docs/xml-key-management-service-xkms.html">XKMS</a>管理公用密钥</li></ul><p>CXF在很大程度上依靠<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j">WSS4J</a>来实现WS-Security。在您自己的服务中，可以使用<a shape="rect" href="http://cxf.apache.org/docs/ws-securitypolicy.html">WS-SecurityPolicy</a>激活<a shape="rect" href="http://cxf.apache.org/docs/ws-securitypolicy.html">WS-Security</a> ，该服务对接收到的消息的安全性属性进行全面而复杂的验证。非WS-SecurityPolicy方法通常也可以通过添加到您的服务和/或客户端的CXF拦截器来实现，如本文所述。</p><p>请注意，WSS4J 1.6.x（由Apache CXF 2.6.x和2.7.x使用）和2.0.x（由Apache CXF 3.0.x和3.1.x使用）之间存在一些不兼容。本页上的示例和链接主要与WSS4J 2.0.x有关，因此与CXF 3.0.x有关。有关WSS4J 2.0.x中更改的更多信息，请参见下面的<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/migration/wss4j20.html">迁移页面</a> 。</p><h1 id="WS-Security-Overviewofencryptionandsigning">加密和签名概述</h1><p>WS-Security大量使用公共/专用密钥加密。要真正理解如何配置WS-Security，了解这些基础知识（如果没有必要）是有帮助的。维基百科对此有<a shape="rect" class="external-link" href="http://en.wikipedia.org/wiki/Public-key_cryptography" rel="nofollow">很好的</a>介绍，但是我们会在这里尝试总结相关的基础知识（此内容是维基百科内容的修改版本。）</p><p>使用公共密钥密码学，用户具有一对公共和私有密钥。这些是使用大质数和键函数生成的。<br clear="none"> <span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Public_key_making.svg/250px-Public_key_making.svg.png" data-image-src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Public_key_making.svg/250px-Public_key_making.svg.png"></span></p><p>密钥在数学上是相关的，但不能相互推导。使用这些密钥，我们可以加密消息。例如，如果Bob想要向Alice发送消息，则可以使用她的公共密钥对消息进行加密。然后，爱丽丝可以使用她的私钥解密此消息。只有爱丽丝可以解密此消息，因为她是唯一拥有私钥的消息。<br clear="none"> <span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Public_key_encryption.svg/280px-Public_key_encryption.svg.png" data-image-src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Public_key_encryption.svg/280px-Public_key_encryption.svg.png"></span></p><p>消息也可以签名。这样可以确保消息的真实性。如果爱丽丝想向鲍勃发送消息，而鲍勃想要确保它来自爱丽丝，则爱丽丝可以使用她的私钥对消息签名。然后，Bob可以使用她的公钥来验证邮件是否来自Alice。<br clear="none"> <span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Public_key_signing.svg/280px-Public_key_signing.svg.png" data-image-src="http://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Public_key_signing.svg/280px-Public_key_signing.svg.png"></span></p><h1 id="WS-Security-ConfiguringtheWSS4JInterceptors">配置WSS4J拦截器</h1><p>要在CXF中为服务器或客户端启用WS-Security，您需要设置WSS4J拦截器。您可以通过用于独立Web服务的API或通过针对servlet托管服务的Spring XML配置来执行此操作。本节将概述如何执行此操作，而以下各节将更详细地介绍如何为特定的安全措施配置拦截器。</p><p>重要的是要注意：</p><ol><li>如果您使用的是CXF 2.0.x，则如果使用的是WS-Security，则必须添加SAAJ（In / Out）拦截器（此操作将从CXF 2.1起自动为您完成）。这些使每个请求/响应都可以创建DOM树。WS-Security的支持库需要DOM树。</li><li>Web服务提供商可能不需要进出WS-Security拦截器。例如，如果您仅需要对传入消息进行签名，那么Web服务提供者将仅需要传入WSS4J拦截器，而只有SOAP客户端将需要传出消息。</li></ol><h2 id="WS-Security-AddingtheinterceptorsviatheAPI">通过API添加拦截器</h2><p>在服务器端，您需要将拦截器添加到CXF端点。如果要使用JAX-WS API发布服务，则可以这样获得CXF端点：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.jaxws.EndpointImpl;

EndpointImpl jaxWsEndpoint = (EndpointImpl) javax.xml.ws.Endpoint.publish("http://host/service", myServiceImpl);
Endpoint cxfEndpoint = jaxWsEndpoint.getServer().getEndpoint();
</pre>
</div></div><p>如果使用了（JaxWs）ServerFactoryBean，则可以通过Server对象简单地访问它：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.frontend.ServerFactoryBean;

ServerFactoryBean factory = ...;
...
Server server = factory.create();
Endpoint cxfEndpoint = server.getEndpoint();
</pre>
</div></div><p>在客户端，您可以使用ClientProxy帮助程序获得对CXF端点的引用：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">import org.apache.cxf.frontend.ClientProxy;
...

GreeterService gs = new GreeterService();
Greeter greeter = gs.getGreeterPort();
...
org.apache.cxf.endpoint.Client client = ClientProxy.getClient(greeter);
org.apache.cxf.endpoint.Endpoint cxfEndpoint = client.getEndpoint();
</pre>
</div></div><p><span class="confluence-anchor-link" id="WS-Security-addinterceptors"></span>现在您可以添加拦截器了：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">import org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor;
import org.apache.cxf.ws.security.wss4j.WSS4JOutInterceptor;
...

Map&lt;String,Object&gt; inProps = new HashMap&lt;String,Object&gt;();
... // how to configure the properties is outlined below;

WSS4JInInterceptor wssIn = new WSS4JInInterceptor(inProps);
cxfEndpoint.getInInterceptors().add(wssIn);

Map&lt;String,Object&gt; outProps = new HashMap&lt;String,Object&gt;();
... // how to configure the properties is outlined below;

WSS4JOutInterceptor wssOut = new WSS4JOutInterceptor(outProps);
cxfEndpoint.getOutInterceptors().add(wssOut);
</pre>
</div></div><h1 id="WS-Security-SpringXMLConfiguration">Spring XML配置</h1><p>如果您正在使用Spring构建端点（例如，在诸如Tomcat之类的servlet容器上运行的Web服务），则可以使用bean定义轻松地完成上述任务。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt;
&lt;import resource="classpath*:META-INF/cxf/cxf-extension-*.xml" /&gt;

&lt;jaxws:endpoint id="myService"
   implementor="com.acme.MyServiceImpl"
   address="http://localhost:9001/MyService"&gt;

   &lt;bean id="myPasswordCallback"
      class="com.mycompany.webservice.ServerPasswordCallback"/&gt;

   &lt;jaxws:inInterceptors&gt;
      &lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
         &lt;constructor-arg&gt;
            &lt;map&gt;
               &lt;entry key="action" value="UsernameToken"/&gt;
               &lt;entry key="passwordType" value="PasswordDigest"/&gt;
               &lt;entry key="signaturePropFile" value="..."/&gt;
               &lt;entry key="passwordCallbackRef"&gt;
                  &lt;ref bean="myPasswordCallback"/&gt;
               &lt;/entry&gt;
               ...
            &lt;/map&gt;
         &lt;/constructor-arg&gt;
      &lt;/bean&gt;
   &lt;/jaxws:inInterceptors&gt;
&lt;/jaxws:endpoint&gt;
</pre>
</div></div><p>上面的constructor-arg元素（操作，signaturePropFile等）中给出的入口键和值映射到WSS4J的<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/dom/handler/WSHandlerConstants.html">WSHandlerConstants</a>和<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/dom/WSConstants.html">WSConstants</a>类中对应的WSHandlerConstants的文本字符串。XXXXX和WSConstants。您将在下面的部分中看到XXXX常量（另请参阅WSS4J配置<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/config.html">页面</a> ）。因此，例如，通过查看WSHandlerConstants，您可以看到WSHandlerConstants。在进行Spring配置时，下面给出的USERNAME_TOKEN值将需要为“ UsernameToken”。</p><p>如果要避免查找WSHandlerConstants的文本键。XXXXX和WSConstants。XXXX常量，您还可以使用Spring util名称空间在Spring上下文中引用静态常量，如下所示。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;beans
  ...
  xmlns:util="http://www.springframework.org/schema/util"
  ...
  xsi:schemaLocation="
        ...
        http://www.springframework.org/schema/util 
        http://www.springframework.org/schema/util/spring-util.xsd"&gt;

  ...

  &lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
    &lt;constructor-arg&gt;
      &lt;map&gt;
        &lt;entry value="UsernameToken"&gt;
          &lt;key&gt;
            &lt;util:constant 
                static-field="org.apache.wss4j.dom.handler.WSHandlerConstants.ACTION"/&gt;
          &lt;/key&gt;
        &lt;/entry&gt;
        ...
      &lt;/map&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;

  ...  
</pre>
</div></div><h2 id="WS-Security-AdditionalConfigurationOptions">其他配置选项</h2><p>CXF WSS4J拦截器支持WSHandlerConstants中可用的标准配置属性。XXXXX和WSConstants。XXXX，CXF还提供对WSS4J和一些其他与安全性有关的拦截器中的一些其他低级配置功能的访问。</p><h3 id="WS-Security-ValidatingSignatureand/orEncryptionofMessageContents">验证邮件内容的签名和/或加密</h3><p>从CXF 2.2.8开始，CryptoCoverageChecker拦截器允许人们验证消息内容的签名和加密范围，而无需迁移到基于WS-SecurityPolicy的配置。拦截器可以支持在元素和内容级别上执行签名和加密覆盖（请注意，签名和内容的组合并不代表覆盖类型和覆盖范围的有效组合）。要使用API配置此拦截器，请遵循以下示例。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">import org.apache.cxf.ws.security.wss4j.CryptoCoverageChecker;
import org.apache.cxf.ws.security.wss4j.CryptoCoverageChecker.XPathExpression;
import org.apache.cxf.ws.security.wss4j.CryptoCoverageUtil.CoverageScope;
import org.apache.cxf.ws.security.wss4j.CryptoCoverageUtil.CoverageType;

Map&lt;String, String&gt; prefixes = new HashMap&lt;String, String&gt;();
        prefixes.put("ser", "http://www.sdj.pl");
        prefixes.put("soap", "http://schemas.xmlsoap.org/soap/envelope/");

List&lt;XPathExpression&gt; xpaths = Arrays.asList(
    new XPathExpression("//ser:Header", CoverageType.SIGNED, 
        CoverageScope.ELEMENT),
    new XPathExpression("//soap:Body", CoverageType.ENCRYPTED, 
        CoverageScope.CONTENT));

CryptoCoverageChecker checker = new CryptoCoverageChecker(prefixes, xpaths);
</pre>
</div></div><p>拦截器也可以在Spring中使用常规bean定义格式进行配置。</p><p>如上配置拦截器之后，只需将拦截器添加到您的客户端或服务器拦截器链中即可，如先前WSS4J拦截器所示。确保在链中包括WSS4JInInterceptor，否则，如果强制执行任何coverage XPath，则所有请求都将被拒绝。</p><p>CryptoCoverageChecker有点复杂，无法设置用于签名验证和解密的最常见用例，因为它涉及添加XPath表达式和相应的前缀/命名空间对。在Apache CXF 2.4.9、2.5.5和2.6.2中，引入了CryptoCoverageChecker的新子类。DefaultCryptoCoverageChecker提供了一种简单的方法来确保对SOAP正文进行签名或加密，对时间戳进行签名以及对WS-Addressing ReplyTo和FaultTo标头进行签名（如果它们存在于消息有效负载中）。</p><p>缺省配置是必须对SOAP正文，（WSU）时间戳和WS-Addressing ReplyTo和FaultTo标头进行签名（如果它们存在于消息有效负载中）。这提供了一种现成的方式来防止XML签名包装攻击。所需要做的就是将DefaultCryptoCoverageChecker添加到拦截器内部链中。例如：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;jaxws:inInterceptors&gt;
    &lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
        &lt;constructor-arg&gt;
            &lt;map&gt;
                &lt;entry key="action" value="Signature Timestamp"/&gt;
                &lt;entry key="signaturePropFile" value="..."/&gt;
                &lt;entry key="passwordCallbackClass"value="..."/&gt;
           &lt;/map&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean class="org.apache.cxf.ws.security.wss4j.DefaultCryptoCoverageChecker"/&gt;
&lt;/jaxws:inInterceptors&gt;
</pre>
</div></div><p>从CXF 2.5.11、2.6.8和2.7.5开始，如果不是错误，则只能通过CryptoCoverageChecker检查收到的消息是否满足加密要求。这在客户端使用CryptoCoverageChecker拦截器从服务响应中验证安全性要求的情况下很有用。在这种情况下，您可能希望获取原始服务Fault，而不是如果来自该服务的Fault消息不安全，则CryptoCoverageChecker会引发异常。若要启用此行为，然后将CryptoCoverageChecker上的“ checkFaults”布尔属性设置为“ false”。</p><h3 id="WS-Security-CustomProcessors">定制处理器</h3><p>从CXF 2.0.10和2.1.4开始，您可以在WSS4JInInterceptor上指定自定义WSS4J处理器配置。要激活此配置选项，请向WSS4JInInterceptor提供一个非WSS4J定义的属性wss4j.processor.map，如下面的Spring示例所示。也可以通过API实现相同的配置。关键值是要使用给定处理器实现处理的WS-Security标头元素的XML限定名称。条目值可以是表示要实例化的处理器的类名的字符串，实现处理器的对象，也可以是null以禁用对给定WS-Security标头元素的处理。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor"&gt;
  &lt;constructor-arg&gt;
    &lt;map&gt;
      ...
      &lt;!-- This reconfigures the processor implementation that WSS4j uses to 
               process a WS-Security Signature element. --&gt;
      &lt;entry key="wss4j.processor.map"&gt;
        &lt;map key-type="javax.xml.namespace.QName"&gt;
          &lt;entry value="my.class"&gt;
            &lt;key&gt;
              &lt;bean class="javax.xml.namespace.QName"&gt;
                &lt;constructor-arg value="http://www.w3.org/2000/09/xmldsig#"/&gt;
                &lt;constructor-arg value="Signature"/&gt;
              &lt;/bean&gt;
            &lt;/key&gt;
          &lt;/entry&gt;
        &lt;/map&gt;
      &lt;/entry&gt;
      ...
    &lt;/map&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre>
</div></div><h3 id="WS-Security-CustomActions">自定义动作</h3><p>从CXF 2.2.6开始，您可以在WSS4JOutInterceptor上指定自定义WSS4J Action配置。要激活此配置选项，可以向WSS4JOutInterceptor提供一个非WSS4J定义的属性wss4j.action.map，如下面的Spring示例所示。也可以通过API实现相同的配置。密钥值是代表WSS4J操作标识符的整数。条目值可以是表示要实例化的操作的类名称的String或实现Action的对象。使用此配置选项，您可以覆盖内置操作实现或添加自己的实现。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean class="org.apache.cxf.ws.security.wss4j.WSS4JOutInterceptor"&gt;
  &lt;constructor-arg&gt;
    &lt;map&gt;
      ...
      &lt;!-- Redefines the action for SAMLTokenSigned 
               to use a custom implementation.  --&gt;
      &lt;entry key="wss4j.action.map"&gt;
        &lt;map key-type="java.lang.Integer" value-type="java.lang.Object"&gt;
          &lt;entry key="0x10" value-ref="mySamlTokenSignedAction"/&gt;
        &lt;/map&gt;
      &lt;/entry&gt;      ...
    &lt;/map&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;
</pre>
</div></div><p>对于添加新的自定义操作，如果新的密钥int编号为12345，则还必须将新操作名称指定为字符串“ 12345”。</p><h1 id="WS-Security-ConfiguringWS-SecurityActions">配置WS-Security操作</h1><h2 id="WS-Security-UsernameTokenAuthentication">用户名令牌认证</h2><p>WS-Security支持多种指定令牌的方式。其中之一是UsernameToken标头。这是将用户名和密码或密码摘要传送到另一个端点的标准方法。使用UsernameTokens时，请务必查看OASIS <a shape="rect" class="external-link" href="http://tinyurl.com/65n78j" rel="nofollow">UsernameToken配置文件规范</a>以获取重要的安全注意事项。</p><p>如果用户名令牌中存在一个随机数，则消息接收者应将其缓存，以防止重放攻击。从CXF 2.6.0开始，默认情况下启用此行为。从Apache CXF 2.4.7和2.5.3起，也可以使用此功能，但是出于向后兼容的原因，默认情况下完全不启用此功能。以下属性控制随机数缓存：</p><ul><li>“ ws-security.enable.nonce.cache”-是否缓存UsernameToken随机数。对于消息接收者，默认值（对于CXF 2.6.0）为“ true”，对于消息发起者为“ false”。将其设置为true可以缓存两种情况。CXF 2.4.x和2.5.x的默认值为false。有关更多信息，请参见<a shape="rect" href="http://cxf.apache.org/javadoc/latest/org/apache/cxf/ws/security/SecurityConstants.html#ENABLE_NONCE_CACHE">此处</a> 。</li><li>“ ws-security.nonce.cache.instance”-这包含对用于缓存UsernameToken随机数的<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/cache/ReplayCache.html">ReplayCache</a>实例的引用。使用的默认实例是<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/cache/EHCacheReplayCache.html">EHCacheReplayCache</a> 。</li><li>“ ws-security.cache.config.file”-设置此属性以指向基础缓存实现的配置文件。使用的默认配置文件是cxf-rt-ws-security模块中的cxf- <a shape="rect" class="external-link" href="http://svn.apache.org/viewvc/cxf/trunk/rt/ws/security/src/main/resources/cxf-ehcache.xml?view=markup">ehcache.xml</a> 。</li></ul><p>对于服务器端，您将需要在WSS4JInInterceptor上设置以下属性（有关代码示例，请参见<a shape="rect" href="ws-security.html">上文</a> ）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">inProps.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);
// Password type : plain text
inProps.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);
// for hashed password use:
//properties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);
// Callback used to retrieve password for given user.
inProps.put(WSHandlerConstants.PW_CALLBACK_CLASS, 
    ServerPasswordHandler.class.getName());
</pre>
</div></div><p>密码回调类使您可以检索给定用户的密码，以便WS-Security可以确定他们是否被授权。这是一个小例子：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.wss4j.common.ext.WSPasswordCallback;

public class ServerPasswordCallback implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException, 
        UnsupportedCallbackException {

        WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];

        if (pc.getIdentifier().equals("joe")) {
            // set the password on the callback. This will be compared to the
            // password which was sent from the client.
            pc.setPassword("password");
        }
    }

}
</pre>
</div></div><p>请注意，对于CXF 2.3.x（含）以下，纯文本密码（或任何其他未知密码类型）的特殊情况的密码验证将委派给回调类。在这种情况下，ServerPasswordCallback应该类似于以下内容：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public class ServerPasswordCallback implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException, 
        UnsupportedCallbackException {

        WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];

        if (pc.getIdentifer().equals("joe") {
           if (!pc.getPassword().equals("password")) {
                throw new IOException("wrong password");
           }
        }
    }

}
</pre>
</div></div><p>对于CXF 2.4及更高版本，回调处理程序将提供所有情况的密码，并且验证是在内部完成的（但可以配置）。有关更多信息，请参见<a shape="rect" class="external-link" href="http://coheigea.blogspot.com/2011/02/usernametoken-processing-changes-in.html" rel="nofollow">此处</a> 。<br clear="none">在客户端，您需要配置WSS4J传出属性：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">outProps.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);
// Specify our username
outProps.put(WSHandlerConstants.USER, "joe");
// Password type : plain text
outProps.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);
// for hashed password use:
//properties.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_DIGEST);
// Callback used to retrieve password for given user.
outProps.put(WSHandlerConstants.PW_CALLBACK_CLASS, 
    ClientPasswordHandler.class.getName());
</pre>
</div></div><p>再次，我们使用密码回调，但是这次不是在服务器端指定密码，而是在邮件中指定要发送的密码。这样一来，我们就不必在配置文件中存储密码。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">import java.io.IOException;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import org.apache.wss4j.common.ext.WSPasswordCallback;

public class ClientPasswordCallback implements CallbackHandler {

    public void handle(Callback[] callbacks) throws IOException, 
        UnsupportedCallbackException {

        WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];

        // set the password for our message.
        pc.setPassword("password");
    }

}
</pre>
</div></div><p>如果多个用户使用不同的密码，请使用<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/ext/WSPasswordCallback.html">WSPasswordCallback</a>的getIdentifier（）方法来获取当前SOAP请求的用户名。</p><p><a shape="rect" class="external-link" href="http://depressedprogrammer.wordpress.com/2007/07/31/cxf-ws-security-using-jsr-181-interceptor-annotations-xfire-migration/" rel="nofollow">这是</a>使用拦截器注释（使用UsernameToken）实现的WS-Security <a shape="rect" class="external-link" href="http://depressedprogrammer.wordpress.com/2007/07/31/cxf-ws-security-using-jsr-181-interceptor-annotations-xfire-migration/" rel="nofollow">的示例</a> 。</p><h3 id="WS-Security-WS-SecurityUsernameTokenandCustomAuthentication">WS-Security UsernameToken和定制认证</h3><p>如果需要，可能需要配置jaxws：endpoint，并将“ ws-security.validate.token”属性设置为false，并注册自定义org.apache.cxf.interceptor.security。AbstractUsernameTokenInInterceptor实现，用于将WSS4J UsernameToken包裹在CXF特定的UsernameToken中，用于自定义身份验证和主题创建。JAASLoginInterceptor也将识别CXF UsernameToken，因此可以代替自定义org.apache.cxf.interceptor.security使用。AbstractUsernameTokenInterceptor。（在CXF 2.4.0之前，使用值为“ true”而不是“ false”的“ ws-security.ut.no-callbacks”代替“ ws-security.validate.token”来推迟令牌的验证。）</p><h2 id="WS-Security-UsingX.509Certificates">使用X.509证书</h2><p>X.509证书令牌概要文件（ <a shape="rect" class="external-link" href="http://www.oasis-open.org/committees/download.php/16785/wss-v1.1-spec-os-x509TokenProfile.pdf" rel="nofollow">pdf</a> ）提供了另一个实现WS-Security的选项。对于签名和加密操作，您需要为所涉及的实体创建一个公共和私有密钥。您可以通过以下步骤为您的开发环境生成一个自签名密钥对。请记住，这些不会由Verisign这样的外部权威机构签名，因此不适用于生产。</p><p>1。在密钥库中使用给定的别名和密码（例如“ myAlias” /“ myAliasPassword”）创建私钥（受密码保护，用于<br clear="none">安全原因）</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">keytool -genkey -alias myAlias -keypass myAliasPassword -keystore \ 
  privatestore.jks -storepass keyStorePassword -dname "cn=myAlias" -keyalg RSA
</pre>
</div></div><p>别名只是识别密钥对的一种方式。在这种情况下，我们使用RSA算法。</p><p>2。自签名我们的证书（在生产环境中，这将由Verisign这样的公司完成）。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">keytool -selfcert -alias myAlias -keystore privatestore.jks \ 
    -storepass keyStorePassword -keypass myAliasPassword
</pre>
</div></div><p>3。将公钥从我们的私钥存储中导出到名为key.rsa的文件中</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">keytool -export -alias myAlias -file key.rsa -keystore privatestore.jks \ 
    -storepass keyStorePassword
</pre>
</div></div><p>4。将公钥导入新的密钥库：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">keytool -import -alias myAlias  -file key.rsa -keystore publicstore.jks \ 
    -storepass keyStorePassword
</pre>
</div></div><p>因此，现在我们有两个包含密钥的密钥库-一个公共密钥库（publicstore.jks）和一个私有密钥库（privatestore.jks）。他们两个都将keystore密码设置为keyStorePass（不建议在生产中使用，但可以在开发中使用），别名设置为myAlias。可以将key.rsa文件从文件系统中删除，因为它只是临时使用。强烈建议将密钥存储在密钥库中，因为密钥库受密码保护。</p><p>密钥生成的更详细描述可以在这里找到：<br clear="none"> <a shape="rect" class="external-link" href="http://java.sun.com/javase/6/docs/technotes/tools/solaris/keytool.html" rel="nofollow">http://java.sun.com/javase/6/docs/technotes/tools/solaris/keytool.html</a></p><p>可以在此处找到如何创建生产证书：<br clear="none"> <a shape="rect" class="external-link" href="http://support.globalsign.net/en/objectsign/java.cfm" rel="nofollow">http://support.globalsign.net/en/objectsign/java.cfm</a></p><h3 id="WS-Security-Signing">签收</h3><p>签名邮件用于向收件人确认该邮件只能来自某个发件人，并且该邮件在传输过程中没有被更改。它涉及发送方使用其私钥对消息的摘要（哈希）进行加密，以及接收方使用发送方的公钥对哈希进行解密，并重新计算消息的摘要以确保消息在传输过程中未被更改（即，发送方和接收方计算的摘要值相同）。为使此过程发生，您必须确保已使用keytool将客户端的公钥导入到服务器的密钥库中。</p><p>在客户端，我们的输出WS-Security属性将如下所示（请参见<a shape="rect" href="ws-security.html">上面</a>的代码示例）：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">outProps.put(WSHandlerConstants.ACTION, "Signature");
outProps.put(WSHandlerConstants.USER, "myAlias");
outProps.put(WSHandlerConstants.PW_CALLBACK_CLASS, 
    ClientCallbackHandler.class.getName());
outProps.put(WSHandlerConstants.SIG_PROP_FILE, "client_sign.properties");
</pre>
</div></div><p>指定的USER是客户端的密钥别名。密码回调类负责提供该密钥的密码。</p><div class="confluence-information-macro confluence-information-macro-tip"><p class="title">小费</p><span class="aui-icon aui-icon-small aui-iconfont-approve confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>对于X.509支持，您通常会执行多种操作，例如，使用签名加密。对于这些情况，只需将ACTION属性中的动作用空格隔开，如下所示：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">outProps.put(WSHandlerConstants.ACTION, 
    WSHandlerConstants.TIMESTAMP + " " + 
    WSHandlerConstants.SIGNATURE + " " + 
    WSHandlerConstants.ENCRYPT);
</pre>
</div></div><p>或者，您可以在Spring配置中用空格分隔上面看到的字符串文字（例如，“签名加密”）</p></div></div><p>我们的client_sign.properties文件包含几个用于配置WSS4J的设置：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=keyStorePassword
org.apache.ws.security.crypto.merlin.keystore.alias=myAlias
org.apache.ws.security.crypto.merlin.keystore.file=client_keystore.jks
</pre>
</div></div><p>在服务器端，我们需要配置传入的WSS4J拦截器以使用客户端的公钥来验证签名。</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">inProps.put(WSHandlerConstants.ACTION, "Signature");
inProps.put(WSHandlerConstants.SIG_PROP_FILE, "server.properties");
</pre>
</div></div><p>我们的server_sign.properties文件包含几个用于配置WSS4J的设置：</p><div class="code panel pdl" style="border-width:1px"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">org.apache.ws.security.crypto.provider=org.apache.ws.security.components.crypto.Merlin
org.apache.ws.security.crypto.merlin.keystore.type=jks
org.apache.ws.security.crypto.merlin.keystore.password=amex123
org.apache.ws.security.crypto.merlin.keystore.file=server_keystore.jks
</pre>
</div></div><h3 id="WS-Security-Encryption">加密</h3><p>加密涉及发件人使用收件人的公钥加密邮件，以确保只有收件人才能读取邮件（只有收件人具有自己的私钥，这对于解密邮件是必需的。）这要求发件人在其密钥库中拥有收件人的公钥。</p><p>加密过程与上面的签名过程非常相似，并且实际上通常与上面的签名过程结合在一起。我们的<a shape="rect" class="external-link" href="http://svn.apache.org/viewvc/cxf/trunk/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/security/">WS-Security测试样本</a> （svn签出<a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/security/">http://svn.apache.org/repos/asf/cxf/trunk/systests/ws-security/src/test/java/org/apache/cxf/systest/ws/security /</a> ）提供了对请求和响应进行加密的示例，还请查看<a shape="rect" class="external-link" href="http://www.jroller.com/gmazza/entry/cxf_x509_profile" rel="nofollow">此博客条目</a>以获取更多端到端示例，该示例显示了SOAP请求和响应的签名和加密。</p><h1 id="WS-Security-SecurityBestPractices">安全最佳实践</h1><p>WSS4J网站上提供了一些有关使用WS-Security时的<a shape="rect" class="external-link" href="http://ws.apache.org/wss4j/best_practice.html">最佳实践的</a>准则。建议仔细研究指南。</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </tbody></table>
   </td>
   <td id="cell-2-2" colspan="2"> </td>
  </tr>
  <tr>
   <td id="cell-3-0"> </td>
   <td id="cell-3-1"> </td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">隐私政策</a> -（ <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=49572">编辑页面</a> ）（ <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=49572&showComments=true&showCommentArea=true#addcomment">添加评论</a> ）<br>Apache CXF，CXF，Apache，Apache Feather徽标是The Apache Software Foundation的商标。<br>提及的所有其他商标可能是其各自所有者的商标或注册商标。
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3"> </td>
   <td id="cell-3-4"> </td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2"> </td>
    <td id="cell-4-1"> </td>
    <td id="cell-4-2" colspan="2"> </td>
  </tr>
</tbody></table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>




</body></html>