<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="concept">
<meta name="DC.Title" content="Using SQL roles">
<meta name="abstract" content="When the SQL standard authorization mode is enabled, object owners can use the SQL roles facility to administer privileges.">
<meta name="description" content="When the SQL standard authorization mode is enabled, object owners can use the SQL roles facility to administer privileges.">
<meta name="DC.subject" content="access control system, SQL2003, SQL standard authorization mode, SQL roles, using">
<meta name="keywords" content="access control system, SQL2003, SQL standard authorization mode, SQL roles, using">
<meta name="DC.Relation" scheme="URI" content="csecauthorfine.html">
<meta name="DC.Relation" scheme="URI" content="cseccsecuregrantrevokeaccess.html">
<meta name="DC.Relation" scheme="URI" content="cseccsecureprivileges.html">
<meta name="DC.Relation" scheme="URI" content="cseccsecuresqlauthupgrade.html">
<meta name="DC.Relation" scheme="URI" content="rseccsecuresqlauthexceptions.html">
<meta name="DC.Relation" scheme="URI" content="rseccsecurenativeauthex.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="cseccsecureroles">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>使用SQL角色</title>
</head>
<body id="cseccsecureroles" ><a name="cseccsecureroles"><!-- --></a>


<h1 class="topictitle1">使用SQL角色</h1>



<div><p>启用SQL标准授权模式后，对象所有者可以使用SQL角色工具来管理特权。</p>

<p>当数据库有许多用户时，SQL角色对于管理特权很有用。与向数据库的每个用户授予特权相比，角色为向用户的会话授予特权提供了一种更强大的方法，当涉及多个用户时，角色很容易变得乏味且容易出错。角色本身并不能提供更好的数据库安全性，但是正确使用角色可以促进更好的安全性。只有<a href="cseccsecuredbowner.html">数据库所有者</a>可以创建，授予，吊销和删除角色。但是，对象所有者可以在角色之间以及与单个用户和PUBLIC（所有用户）之间来回授予和撤消这些对象的特权。</p>

<div class="note"><span class="notetitle">注意：</span> <span>Derby</span>实现SQL角色的子集。只有数据库所有者才能创建，授予，吊销和删除角色的事实是实现限制。</div>

<div class="section" id="cseccsecureroles__rolecreategrant"><a name="cseccsecureroles__rolecreategrant"><!-- --></a><h2 class="sectiontitle">创建和授予角色</h2>
<p>仅当启用SQL授权模式（即使用NATIVE身份验证或属性时）时，角色才可用<samp class="codeph">derby.database.sqlAuthorization</samp>明确设置为<samp class="codeph">TRUE</samp> ）。</p>

<p>必须先将旧数据库完全升级到至少10.5版，然后才能使用角色。有关更多信息，请参见《 <span><em>Derby开发人员指南</em></span> 》中的“升级”。</p>

<p>如果启用了SQL授权模式，则数据库所有者可以使用CREATE ROLE语句创建角色。然后，数据库所有者可以使用GRANT语句将角色授予一个或多个用户，PUBLIC或另一角色。
</p>

<p>如果将角色B授予角色A或包含在授予角色A的角色C中，则角色A <em>包含</em>另一个角色B。授予包含角色的权限由包含角色继承。因此，由角色A标识的特权集是授予角色A的特权与授予角色A的任何包含角色的特权的并集。</p>

<p>例如，假设数据库所有者发出了以下语句：</p>

<pre>create role reader;
create role updater;
create role taskLeaderA;
create role taskLeaderB;
create role projectLeader;
grant reader to updater;
grant updater to taskLeaderA;
grant updater to taskLeaderB;
grant taskLeaderA to projectLeader;
grant taskLeaderB to projectLeader;</pre>

<p>这些角色将具有以下包含关系：</p>

<ul>
<li>的<samp class="codeph">projectLeader</samp>角色包含<samp class="codeph">taskLeaderA</samp>和<samp class="codeph">taskLeaderB</samp>角色。</li>

<li>的<samp class="codeph">taskLeaderA</samp>和<samp class="codeph">taskLeaderB</samp>角色都包含<samp class="codeph">updater</samp>角色。</li>

<li>的<samp class="codeph">updater</samp>角色包含<samp class="codeph">reader</samp>角色。</li>

</ul>

<p>在这种情况下， <samp class="codeph">projectLeader</samp>角色包含所有其他角色，并拥有所有特权。如果数据库所有者随后撤销<samp class="codeph">updater</samp>从<samp class="codeph">taskLeaderA</samp> ， <samp class="codeph">projectLeader</samp>仍然通过该角色<samp class="codeph">taskLeaderB</samp> 。</p>

<p>SYSCS_DIAG.CONTAINED_ROLES诊断表功能可用于确定角色所包含的角色集。</p>

<p>角色授予中不允许循环。也就是说，如果一个角色包含另一个角色，则不能将容器角色授予所包含的角色。例如，将不允许以下语句：</p>

<pre>grant projectLeader to updater;</pre>

</div>

<div class="section"><h2 class="sectiontitle">设定角色</h2>
<p>用户首次连接到<span>Derby时</span> ，未设置任何角色，并且CURRENT_ROLE函数返回null。在会话期间，用户可以调用SET ROLE语句来设置该会话的当前角色。该角色可以是已授予会话当前用户或PUBLIC的任何角色。要取消设置当前角色，请使用参数NONE调用SET ROLE。在会话期间的任何时候，总是有一个当前用户，但是只有当用非NONE以外的参数调用SET ROLE时，才有当前角色。如果未设置当前角色，则会话仅具有直接或直接授予用户的特权。</p>

<p>例如，如果数据库所有者创建并授予了上一会话中显示的角色，则用户将必须发出SET ROLE语句才能使它们生效。假设用户发出了以下语句：</p>

<pre>SET ROLE taskLeaderA;</pre>

<p>假设数据库所有者已授予<samp class="codeph">taskLeaderA</samp>用户角色，则将允许该用户设置如图所示的角色，并拥有授予该用户的所有特权<samp class="codeph">taskLeaderA</samp> ， <samp class="codeph">updater</samp>和<samp class="codeph">reader</samp>角色。</p>

<p>要在SQL中检索当前角色标识符，请调用CURRENT_ROLE函数。</p>

<p>在包含SQL的存储过程和函数中，当前角色取决于例程是使用调用者权限还是定义者权限执行，如<span><em>Derby参考手册中</em></span> CREATE FUNCTION或CREATE PROCEDURE语句中的EXTERNAL SECURITY子句所指定。在执行期间，当前用户和当前角色保留在授权堆栈中，该授权堆栈在存储的例程调用期间被推送。</p>

<ul>
<li>在以调用者权限执行的例程中，适用以下条件：最初，在嵌套连接内部，当前角色设置为调用上下文的角色。当前用户也是如此。这样的例程可以设置授予调用者或PUBLIC的任何角色。</li>

<li>在使用定义者权限执行的例程中，适用以下规则：最初，在嵌套连接内部，当前角色为NULL，而当前用户为定义者的角色。这样的例程可以设置授予定义者或PUBLIC的任何角色。</li>

</ul>

<p>从存储过程或函数返回后，将弹出授权堆栈，因此调用上下文的当前角色不受被调用过程或函数内部角色的任何设置的影响。如果存储过程打开了多个嵌套连接，则所有这些都共享相同（堆叠）的当前角色（和用户）状态。从存储过程传递的任何动态结果集都会看到嵌套上下文的当前角色（或用户）。</p>

</div>

<div class="section"><h2 class="sectiontitle">授予角色特权</h2>
<p>创建角色后，数据库所有者和对象所有者都可以向该角色授予表和例程的特权。您可以向角色授予与授予用户相同的特权。授予角色特权将隐式授予包含该角色的所有角色特权。例如，如果您授予表删除权限，以<samp class="codeph">updater</samp> ， <samp class="codeph">updater</samp> ， <samp class="codeph">taskLeaderA</samp> ， <samp class="codeph">taskLeaderB</samp>和<samp class="codeph">projectLeader</samp>角色还将对该表具有删除权限，但是<samp class="codeph">reader</samp>角色不会。</p>

</div>

<div class="section"><h2 class="sectiontitle">撤消角色的特权</h2>
<p>数据库所有者或对象所有者都可以撤消角色的特权。</p>

<p>从角色A撤消特权后，该特权将不再由角色A拥有，除非A从其他角色继承该特权。</p>

<p>如果从角色A撤消了对对象的特权，则除非会话具有当前角色设置为A或包含A的角色，否则该会话将失去该特权，除非满足以下一个或多个条件：</p>

<ul>
<li>特权直接授予当前用户</li>

<li>特权授予PUBLIC</li>

<li>该特权也被授予当前角色包含的角色集中的另一个角色B</li>

<li>会话的当前用户是数据库所有者或对象所有者</li>

</ul>

</div>

<div class="section"><h2 class="sectiontitle">撤销角色</h2>
<p>数据库所有者可以使用REVOKE语句从用户，PUBLIC或另一个角色撤消一个角色。</p>

<p>从用户撤消角色后，该会话将不再保留该角色，也无法在SET ROLE语句中担任该角色，除非该角色也已授予PUBLIC。如果该角色是现有会话的当前角色，则该会话的当前特权将丢失通过设置该角色获得的任何额外特权。</p>

<p>默认的放置行为是CASCADE。因此，将删除所有依赖于该角色的持久对象（约束，视图和触发器）。尽管在撤消时可能还有其他方式来实现该特权，但是仍会丢弃任何从属对象。这是一个实现限制。任何可能受影响的准备好的语句将在下一次执行时再次检查。即使某个角色被用户撤消，依赖于该角色的结果集也将保持打开状态。</p>

<p>从角色吊销角色时，默认的放置行为也是CASCADE。假设您从角色B撤消了角色A。撤消该角色将撤消通过A从B获得的所有其他适用特权。包含B的角色也将失去这些特权，除非A仍然包含在其他授予C的角色中。 B，或者特权来自其他角色。有关示例，请参见<a href="#cseccsecureroles__rolecreategrant">创建和授予角色</a> 。</p>

</div>

<div class="section"><h2 class="sectiontitle">放弃角色</h2>
<p>只有数据库所有者可以删除角色。要删除角色，请使用DROP ROLE语句。</p>

<p>有效地删除角色将撤消该角色对用户和其他角色的所有授予。</p>

</div>

<div class="section"><h2 class="sectiontitle">更多信息</h2>
<p>有关以下与角色有关的语句，功能和系统表的详细信息，请参见《 <span><em>Derby参考手册》</em></span> 。</p>

<ul>
<li>CREATE ROLE语句</li>

<li>SET ROLE语句</li>

<li>DROP ROLE语句</li>

<li>GRANT声明</li>

<li>撤销声明</li>

<li>CURRENT_ROLE函数</li>

<li>SYSCS_DIAG.CONTAINED_ROLES表函数</li>

<li>SYSROLES系统表</li>

</ul>

</div>

</div>

<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="csecauthorfine.html" title="您可以使用细粒度的用户授权（也称为SQL标准授权）来限制对特定数据的访问。">配置细粒度的用户授权</a></div>
</div>
<div class="relconcepts"><strong>相关概念</strong><br>
<div><a href="cseccsecuregrantrevokeaccess.html" title="启用SQL标准授权模式后，对象所有者可以使用GRANT和REVOKE SQL语句来设置特定数据库对象或特定SQL操作的用户特权。他们还可以使用角色来管理特权。">使用细粒度的用户授权</a></div>
<div><a href="cseccsecureprivileges.html" title="视图，触发器，约束和生成的列以视图，触发器，约束或生成的列的所有者的特权运行。">视图，触发器，约束和生成的列的特权</a></div>
<div><a href="cseccsecuresqlauthupgrade.html" title="以后可以通过身份验证和SQL授权来屏蔽未受保护的旧数据库。">升级旧数据库以使用SQL标准授权</a></div>
</div>
<div class="relref"><strong>相关参考</strong><br>
<div><a href="rseccsecuresqlauthexceptions.html" title="SQL授权发生错误时，将返回SQL异常。">SQL标准授权例外</a></div>
<div><a href="rseccsecurenativeauthex.html" title="该示例由程序NativeAuthenticationExample.java组成，该程序显示了如何通过嵌入式或客户端驱动程序使用Derby的NATIVE用户身份验证和SQL授权。">NATIVE身份验证和SQL授权示例</a></div>
</div>
</div>



</body></html>