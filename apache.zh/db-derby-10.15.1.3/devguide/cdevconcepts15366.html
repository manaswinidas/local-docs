<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="concept">
<meta name="DC.Title" content="Isolation levels and concurrency">
<meta name="abstract" content="Derby provides four transaction isolation levels. Setting the transaction isolation level for a connection allows a user to specify how severely the user's transaction should be isolated from other transactions.">
<meta name="description" content="Derby provides four transaction isolation levels. Setting the transaction isolation level for a connection allows a user to specify how severely the user's transaction should be isolated from other transactions.">
<meta name="DC.subject" content="Transaction anomalies in generic database systems, description, Dirty reads, definition, Nonrepeatable reads, Phantom reads, TRANSACTION_SERIALIZABLE isolation level, TRANSACTION_REPEATABLE _READ isolation level, TRANSACTION_READ _COMMITTED isolation level, TRANSACTION_READ _UNCOMMITTED isolation level">
<meta name="keywords" content="Transaction anomalies in generic database systems, description, Dirty reads, definition, Nonrepeatable reads, Phantom reads, TRANSACTION_SERIALIZABLE isolation level, TRANSACTION_REPEATABLE _READ isolation level, TRANSACTION_READ _COMMITTED isolation level, TRANSACTION_READ _UNCOMMITTED isolation level">
<meta name="DC.Relation" scheme="URI" content="cdevconcepts22300.html">
<meta name="DC.Relation" scheme="URI" content="cdevconcepts23810.html">
<meta name="DC.Relation" scheme="URI" content="cdevconcepts36402.html">
<meta name="DC.Relation" scheme="URI" content="cdevconcepts28436.html">
<meta name="DC.Relation" scheme="URI" content="rdevconcepts8424.html">
<meta name="DC.Relation" scheme="URI" content="cdevconcepts30291.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="cdevconcepts15366">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>隔离级别和并发</title>
</head>
<body id="cdevconcepts15366" ><a name="cdevconcepts15366"><!-- --></a>


<h1 class="topictitle1">隔离级别和并发</h1>



<div><p><span>Derby</span>提供了四个事务隔离级别。通过设置连接的事务隔离级别，用户可以指定将用户的事务与其他事务隔离的严重程度。</p>

<p>例如，它允许您指定是否允许事务A在事务B提交之前对事务B已查看的数据进行更改。</p>

<p>连接确定其自己的隔离级别，因此JDBC为应用程序提供了一种指定事务隔离级别的方法。它指定了四个级别的事务隔离。事务隔离度越高，就越需要避免冲突。避免冲突有时意味着锁定交易。较低的隔离级别因此允许更大的并发性。</p>

<p>无论隔离级别如何，插入，更新和删除操作始终相同。仅select语句的行为有所不同。</p>

<p>要设置隔离级别，可以使用JDBC <em>Connection.setTransactionIsolation</em>方法或SQL SET ISOLATION语句。</p>

<p>如果存在活动事务，则无论使用JDBC <em>Connection.setTransactionIsolation</em>方法还是SQL SET ISOLATION语句，网络客户端驱动程序都会始终提交活动事务。即使方法调用或语句实际上没有更改隔离级别（也就是将隔离级别设置为其当前值），它也会这样做。如果使用SET ISOLATION语句，则嵌入式驱动程序也会始终提交活动事务。但是，如果使用<em>Connection.setTransactionIsolation</em>方法，则只有在对<em>Connection.setTransactionIsolation</em>的调用实际上更改了隔离级别时，嵌入式驱动程序才会提交活动事务。</p>

<p>隔离级别的名称不同，具体取决于您使用的是JDBC方法还是SQL语句。下表显示了隔离级别的等效名称，无论它们是通过JDBC方法还是通过SQL语句设置的。</p>


<div class="tablenoborder"><table cellspacing="0" cellpadding="4" border="1" summary="This table lists the JDBC isolation levels and shows how they map to SQL isolation levels." frame="border" rules="all"><caption>表格1。JDBC事务隔离级别到<span>Derby</span>隔离级别的映射</caption>


<thead align="left">
<tr valign="bottom">
<th valign="bottom" width="67%" id="N100E8">JDBC的隔离级别</th>

<th valign="bottom" width="33%" id="N100EF">SQL的隔离级别</th>

</tr>

</thead>

<tbody>
<tr>
<td valign="top" width="67%" headers="N100E8">连接。TRANSACTION_READ_UNCOMMITTED（ANSI级别0）</td>

<td valign="top" width="33%" headers="N100EF">UR，脏读，未提交读</td>

</tr>

<tr>
<td valign="top" width="67%" headers="N100E8">连接。TRANSACTION_READ_COMMITTED（ANSI级别1）</td>

<td valign="top" width="33%" headers="N100EF">CS，光标稳定性，已提交读取</td>

</tr>

<tr>
<td valign="top" width="67%" headers="N100E8">连接。TRANSACTION_REPEATABLE_READ（ANSI级别2）</td>

<td valign="top" width="33%" headers="N100EF">RS</td>

</tr>

<tr>
<td valign="top" width="67%" headers="N100E8">连接。TRANSACTION_SERIALIZABLE（ANSI级别3）</td>

<td valign="top" width="33%" headers="N100EF">RR，可重复读取，可序列化</td>

</tr>

</tbody>

</table>
</div>

<p>这些级别使您可以避免特定种类的事务异常，如下表所述。</p>


<div class="tablenoborder"><a name="cdevconcepts15366__cdevconcepts17741"><!-- --></a><table cellspacing="0" cellpadding="4" id="cdevconcepts15366__cdevconcepts17741" border="1" summary="This table lists several kinds of transaction anomalies and gives an example of each." frame="border" rules="all"><caption>表2。交易异常</caption>


<thead align="left">
<tr valign="bottom">
<th valign="bottom" width="50%" id="N1018C">异常现象</th>

<th valign="bottom" width="50%" id="N10193">例</th>

</tr>

</thead>

<tbody>
<tr>
<td valign="top" width="50%" headers="N1018C"><em>脏读</em> <p>当一个事务读取另一个尚未提交的事务正在修改的数据时，就会发生脏读。</p>
</td>

<td valign="top" width="50%" headers="N10193">事务A开始。<pre>UPDATE employee SET salary = 31650
WHERE empno = '000090'</pre>事务B开始。<pre>SELECT * FROM employee</pre>（事务B看到事务A更新的数据。这些更新尚未提交。）</td>

</tr>

<tr>
<td valign="top" width="50%" headers="N1018C"><em>不可重复读</em> <p>当查询返回的数据与在同一事务中重复查询时的数据不同时，将发生不可重复的读取。当其他事务正在修改某个事务正在读取的数据时，可能会发生不可重复的读取。</p>
</td>

<td valign="top" width="50%" headers="N10193">事务A开始。<pre>SELECT * FROM employee
WHERE empno = '000090' </pre>事务B开始。<pre>UPDATE employee SET salary = 30100
WHERE empno = '000090'</pre>（事务B在提交事务A之前更新了事务A查看的行。）如果事务A发出相同的SELECT语句，则结果将不同。</td>

</tr>

<tr>
<td valign="top" width="50%" headers="N1018C"><em>幻影读</em> <p>出现在另一个交易记录集中的记录。当其他事务插入满足另一个事务语句的WHERE子句的行时，可能会发生幻像读取。</p>
</td>

<td valign="top" width="50%" headers="N10193">事务A开始。<pre>SELECT * FROM employee
 WHERE salary &gt; 30000 </pre>事务B开始。<pre>INSERT INTO employee
(empno, firstnme, midinit,
lastname, job,
salary) VALUES ('000350', 'NICK',
'A','GREEN','LEGAL COUNSEL',35000)</pre>如果再次发出事务B，则事务B将插入满足该查询的行。</td>

</tr>

</tbody>

</table>
</div>

<p>事务隔离级别是一种指定是否允许这些事务异常的方式。因此，事务隔离级别会影响由特定事务锁定的数据量。另外，DBMS的锁定模式也可能会影响是否允许这些异常。DBMS可以锁定整个表或仅锁定特定的行，以防止事务异常。</p>

<p>下表显示了在各种锁定模式和隔离级别下可能发生的异常。</p>


<div class="tablenoborder"><table cellspacing="0" cellpadding="4" border="1" summary="This table lists the JDBC isolation levels and shows which transaction anomalies can occur with table-level and row-level locking." frame="border" rules="all"><caption>表3。当交易异常可能</caption>



<thead align="left">
<tr valign="bottom">
<th valign="bottom" width="50%" id="N10271">隔离度</th>

<th valign="bottom" width="25%" id="N10278">表级锁定</th>

<th valign="bottom" width="25%" id="N1027F">行级锁定</th>

</tr>

</thead>

<tbody>
<tr>
<td valign="top" width="50%" headers="N10271">TRANSACTION_READ_UNCOMMITTED</td>

<td valign="top" width="25%" headers="N10278">可能发生脏读，不可重复读和幻像读</td>

<td valign="top" width="25%" headers="N1027F">可能发生脏读，不可重复读和幻像读</td>

</tr>

<tr>
<td valign="top" width="50%" headers="N10271">TRANSACTION_READ_COMMITTED</td>

<td valign="top" width="25%" headers="N10278">不可重复读取和幻像读取</td>

<td valign="top" width="25%" headers="N1027F">不可重复读取和幻像读取</td>

</tr>

<tr>
<td valign="top" width="50%" headers="N10271">TRANSACTION_REPEATABLE_READ</td>

<td valign="top" width="25%" headers="N10278">无法读取幻像，因为整个表都被锁定</td>

<td valign="top" width="25%" headers="N1027F">幻影读取可能</td>

</tr>

<tr>
<td valign="top" width="50%" headers="N10271">TRANSACTION_SERIALIZABLE</td>

<td valign="top" width="25%" headers="N10278">没有</td>

<td valign="top" width="25%" headers="N1027F">没有</td>

</tr>

</tbody>

</table>
</div>

<p>下面的<em>java.sql。支持连接</em>隔离级别：</p>

<ul>
<li><samp class="codeph">TRANSACTION_SERIALIZABLE</samp> <p><samp class="codeph">RR</samp> ， <samp class="codeph">SERIALIZABLE</samp> ， 要么<samp class="codeph">REPEATABLE READ</samp>从SQL。</p>
 <p><em>TRANSACTION_SERIALIZABLE</em>表示<span>Derby</span>将事务视为串行发生（一个接一个）而不是同时发生。<span>德比</span>的问题锁来防止中列出的所有交易异常<a href="cdevconcepts15366.html#cdevconcepts15366__cdevconcepts17741">交易异常情况</a>的发生。它发出的锁定类型有时称为<em>范围锁定</em> 。</p>
</li>

<li><samp class="codeph">TRANSACTION_REPEATABLE_READ</samp>   <p><samp class="codeph">RS</samp>从SQL。</p>
 <p><em>TRANSACTION_REPEATABLE_READ</em>表示<span>Derby</span>发出锁以仅防止脏读和不可重复读，而不能防止幻像。它不会为选择发出范围锁定。</p>
</li>

<li><samp class="codeph">TRANSACTION_READ_COMMITTED</samp>  <p><samp class="codeph">CS</samp>要么<samp class="codeph">CURSOR STABILITY</samp>从SQL。</p>
 <p><em>TRANSACTION_READ_COMMITTED</em>意味着<span>Derby</span>发出锁以仅防止脏读，而不是防止<a href="cdevconcepts15366.html#cdevconcepts15366__cdevconcepts17741">Transaction Anomaly中</a>列出的所有<a href="cdevconcepts15366.html#cdevconcepts15366__cdevconcepts17741">事务异常</a> 。</p>

<p><em>TRANSACTION_READ_COMMITTED</em>是<em>事务</em>的默认隔离级别。</p>
</li>

<li><samp class="codeph">TRANSACTION_READ_UNCOMMITTED</samp>   <p><samp class="codeph">UR</samp> ， <samp class="codeph">DIRTY READ</samp> ， 要么<samp class="codeph">READ UNCOMMITTED</samp>从SQL。</p>
 <p>对于SELECT INTO，具有只读游标的FETCH，在INSERT中使用的完全选择，在UPDATE / DELETE中的完全选择/子查询或标量完全选择（无论在何处使用），READ UNCOMMITTED允许：</p>
 <ul>
<li>在工作单元中读取的任何行，将被其他应用程序进程更改。</li>

<li>即使应用程序进程尚未提交更改，也要读取另一个应用程序进程更改的任何行。</li>

</ul>
<p>对于其他操作，适用于READ COMMITTED的规则也适用于READ UNCOMMITTED。</p>
</li>

</ul>

</div>

<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="cdevconcepts30291.html" title="本节讨论与多用户系统相关的主题，在这些主题中，并发很重要。">锁定，并发和隔离</a></div>
</div>
<div class="relconcepts"><strong>相关概念</strong><br>
<div><a href="cdevconcepts22300.html" title="如果连接未指定其隔离级别，则它将继承Derby系统的默认隔离级别。默认值为CS。">配置隔离级别</a></div>
<div><a href="cdevconcepts23810.html" title="可以将Derby配置为表级锁定。使用表级锁定，当事务锁定数据以防止任何事务异常时，它将始终锁定整个表，而不仅仅是被访问的那些行。">锁粒度</a></div>
<div><a href="cdevconcepts36402.html" title="Derby系统中有几种类型的锁，包括排他锁，共享锁和更新锁。">Derby系统中锁的类型和范围</a></div>
<div><a href="cdevconcepts28436.html" title="在数据库中，死锁是指两个或两个以上的事务正在等待彼此放弃锁的情况。">死锁</a></div>
</div>
<div class="relref"><strong>相关参考</strong><br>
<div><a href="rdevconcepts8424.html" title="语句锁定的数据量可能会有所不同。">锁范围</a></div>
</div>
</div>



</body></html>