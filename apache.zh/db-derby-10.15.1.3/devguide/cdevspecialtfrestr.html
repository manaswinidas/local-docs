<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="concept">
<meta name="DC.Title" content="Writing restricted table functions">
<meta name="abstract" content="Restricted table functions are Derby-style table functions which perform more efficiently because they can be told in advance which columns they will be asked to fetch along with simple limits on those columns. This feature exploits the expressiveness of the Java programming language and does not require any extensions to SQL.">
<meta name="description" content="Restricted table functions are Derby-style table functions which perform more efficiently because they can be told in advance which columns they will be asked to fetch along with simple limits on those columns. This feature exploits the expressiveness of the Java programming language and does not require any extensions to SQL.">
<meta name="DC.subject" content="Functions, programming table functions">
<meta name="keywords" content="Functions, programming table functions">
<meta name="DC.Relation" scheme="URI" content="cdevspecialtabfuncs.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="cdevspecialtfrestr">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>编写受限表函数</title>
</head>
<body id="cdevspecialtfrestr" ><a name="cdevspecialtfrestr"><!-- --></a>


<h1 class="topictitle1">编写受限表函数</h1>



<div><p>受限制的表函数是<span>Derby</span>样式的表函数，它们的执行效率更高，因为可以提前告知它们将被要求提取哪些列以及对这些列的简单限制。此功能利用了Java编程语言的表达能力，并且不需要对SQL进行任何扩展。</p>

<p>表函数返回矩形数据块。如果使用受限表函数，则<span>Derby</span>可以告诉表函数返回更短和更窄的矩形。</p>

<p>考虑对外部数据库中的表进行以下扫描：</p>

<pre>    select id, firstName, lastName
    from table( foreignDatabaseEmployeeTable() ) s
    where lastName = 'Stone'
</pre>

<p>如果<em>foreignDatabaseEmployeeTable</em>是受限制的表函数，则<span>Derby</span>可以告诉该表函数仅获取<em>id</em> ， <em>firstName</em>和<em>lastName</em>列。另外， <span>Derby</span>可以告诉表函数它不需要扫描整个外部表；相反，表函数只需要检索姓氏为“ Stone”的员工的信息。</p>

<p>根据表功能和查询，此功能可以支持1000X，1000000X甚至更大的性能改进。</p>

<div class="section"><h2 class="sectiontitle">如何使用受限表功能</h2>
<p>创建和使用受限表功能涉及以下步骤：</p>

<ol>
<li><strong>实施</strong> -您必须编写一个同时实现<em>java.sql的类<em>。ResultSet</em>和特定于<span>Derby的</span>接口<em>org.apache.derby.vti。受限制的VTI</em> 。该接口定义了一个<em>initScan（）</em>方法。执行查询时， <span>Derby</span>使用该方法告知表函数它将必须获取的列以及应将哪些范围应用于这些列，以减少返回的行数。对于本讨论的其余部分，此用户编写的类将称为<em>MyVTIClass</em> 。</em></li><em>

<li><strong>发布</strong> -您必须通过创建返回<em>MyVTIClass</em>的公共静态方法来发布表函数。这个很重要。<span>Derby</span>编译器必须能够看到table函数返回一个实现了<em>java.sql的对象<em>。ResultSet</em>和<em>org.apache.derby.vti。受限制的VTI</em> 。</em></li><em>

<li><strong>声明</strong> -使用已经熟悉的CREATE FUNCTION语法向<span>Derby</span>声明表函数。此语法不会更改。</li>

<li><strong>调用</strong> -然后在查询中使用表格功能。当<span>Derby</span>编译查询时，它会看到表函数的返回类型实现了<em>org.apache.derby.vti。受限制的VTI</em> 。有了此信息， <span>Derby</span>在运行时将在调用任何<em>ResultSet</em>方法之前调用一次<em>initScan（）</em>方法。
</li>

</em></em></ol><em><em>

<p>例如，您将如下声明函数：</p>

<pre>
public class MyVTIClass implements ResultSet, RestrictedVTI
{
    ...

    public void initScan(java.lang.String[] columnNames, 
        org.apache.derby.vti.Restriction restriction ) 
        throws SQLException {
         ... 
    }
}
</pre>

<p>然后发布表函数方法：</p>

<pre>
public static MyVTIClass foreignDatabaseEmployeeTable() 
    throws SQLException {
    ... 
}
</pre>

<p>然后，您将表函数声明为<span>Derby</span> ：</p>

<pre>
create function foreignDatabaseEmployeeTable()
returns table
(
    id int,
    birthday date,
    taxPayerID varchar( 50 ),
    firstName varchar( 50 ),
    lastName varchar( 50 )
)
language java
parameter style DERBY_JDBC_RESULT_SET
no sql
external name 'com.example.portal.ForeignQueries.foreignDatabaseEmployeeTable'
</pre>

<p>最后，您在查询中调用表函数：</p>

<pre>
select id, firstName, lastName
from table( foreignDatabaseEmployeeTable() ) s
where lastName = 'Stone'
</pre>

<p>调用此查询时， <span>Derby将</span>执行以下操作：</p>

<ul>
<li><strong>准备</strong> -当准备<span>德比</span>查询， <span>德比</span>看到该<em>foreignDatabaseEmployeeTable（）</em>方法返回一个对象，它实现<em>org.apache.derby.vti。受限制的VTI</em> 。这是<span>Derby</span>为了编制利用此功能的计划所需要了解的所有内容。</li>

<li><strong>执行</strong> -当<span>Derby</span>执行查询时， <span>Derby</span>调用<em>initScan（）</em> 。在此示例中， <span>Derby</span>使用以下参数调用<em>initScan（）</em> ：<pre>
initScan( new String[] { "ID", null, null, "FIRSTNAME", "LASTNAME" }, 
    new Restriction.ColumnQualifier(
        "LASTNAME", ORDER_OP_EQUALS, "Stone" ) )
</pre>

<p>反过来，这导致发生以下情况：</p>

  <ul>
  <li><em>宽度</em> -对<em>initScan（）</em>的调用告诉表函数应该<em>读取</em>哪些列。</li>

  <li><em>长度</em> -调用<em>initScan（）</em>告诉表函数如何过滤返回的行。</li>

  <li><em>环</em> - <span>德比</span>然后调用<em>MyVTIClass.next（）</em>和检索行，直到<em>MyVTIClass.next（）</em>返回false。对于每一行， <span>Derby</span>调用：<ul>
     <li><em>MyVTIClass.getInt（1）</em>获取<em>id</em>列。</li>

     <li><em>MyVTIClass.getString（4）</em>获取<em>firstName</em>列。</li>

     <li><em>MyVTIClass.getString（5）</em>以获取<em>lastName</em>列。</li>

     </ul>

  </li>

  </ul>

</li>

</ul>

</em></em></div><em><em>

<div class="section"><h2 class="sectiontitle">合同</h2>
<p><span>Derby会先</span>调用<em>initScan（），</em>然后再调用<em>ResultSet</em>上的任何其他方法。对<em>initScan（）</em>的调用仅传递提示，受限表函数可以利用这些提示以使其表现更好。
<span>Derby</span>在表功能之外实施了限制。因此，受限表函数仍然可以获取额外的列，并且可以忽略通过调用<em>initScan（）</em>设置的部分或全部限制。</p>

</div>

<div class="section"><h2 class="sectiontitle">受影响的行动</h2>
<p>与普通表函数相比，受限表函数在查询中涉及列与常量的以下比较的性能更好：</p>

<pre>
&lt;
&lt;=
=
!=
&lt;&gt;
&gt;
&gt;=
IS NULL
IS NOT NULL
</pre>

<p>此外，对于受限表函数的列上涉及以下运算符的查询，可以实现性能提升：</p>

<pre>
LIKE
BETWEEN
</pre>

<p>但是，此功能不会提高IN运算符的性能，也不会在<span>Derby</span>将OR列表转换为IN列表的情况下提高性能。有关更多信息，请参见<span><em>Tuning Derby中的</em></span> “或转换”。</p>

</div>

</em></em></div><em><em>

<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="cdevspecialtabfuncs.html" title="Derby使您可以创建表函数。表函数是将外部数据打包成类似于Derby表的函数。外部数据可以是XML文件，外部数据库中的表，实时数据源-简而言之，任何可以表示为JDBC ResultSet的信息源。">Derby样式表函数编程</a></div>
</div>
</div>



</em></em></body></html>