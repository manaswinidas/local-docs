<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="concept">
<meta name="DC.Title" content="Programming user-defined types">
<meta name="abstract" content="Derby allows you to create user-defined types. A user-defined type is a serializable Java class whose instances are stored in columns. The class must implement the java.io.Serializable interface, and it must be declared to Derby by means of a CREATE TYPE statement.">
<meta name="description" content="Derby allows you to create user-defined types. A user-defined type is a serializable Java class whose instances are stored in columns. The class must implement the java.io.Serializable interface, and it must be declared to Derby by means of a CREATE TYPE statement.">
<meta name="DC.subject" content="types, user-defined, user-defined types, programming">
<meta name="keywords" content="types, user-defined, user-defined types, programming">
<meta name="DC.Relation" scheme="URI" content="cdevspecial.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="cdevspecialudt">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>编程用户定义类型</title>
</head>
<body id="cdevspecialudt" ><a name="cdevspecialudt"><!-- --></a>


<h1 class="topictitle1">编程用户定义类型</h1>



<div><p><span>Derby</span>允许您创建用户定义的类型。用户定义的类型是可序列化的Java类，其实例存储在列中。该类必须实现<em>java.io。可序列化的</em>接口，必须通过CREATE TYPE语句将其声明给<span>Derby</span> 。</p>

<div class="section">

<p>设计良好的用户定义类型的关键是要记住，数据会随着时间的推移而演变，就像代码一样。良好的用户定义类型具有内置的版本信息。这允许用户定义的数据在应用程序更改时自行升级。因此，对于用户定义的类型，最好实现<em>java.io。可外部化</em> ，而不仅仅是<em>java.io。可序列化</em> 。尽管SQL标准允许Java类仅实现<em>java.io。可序列化</em> ，这是不好的做法，原因如下：</p>

<ul>
<li><strong>重新编译</strong> -如果应用程序的第二版与第一版在不同的平台上编译，则序列化的对象可能无法反序列化。在此<a href="http://java.sun.com/developer/technicalArticles/Programming/serialization/" target="_blank">序列化入门指南</a>结尾处的“版本控制”部分以及<a href="http://java.sun.com/developer/technicalArticles/Programming/serialization/" target="_blank">java.io</a>的标题注释的最后一段中，将讨论此问题和可能的解决<em>方法。可序列化</em> 。</li>

<li><strong>演化</strong> -用于演化仅实现<em>java.io的类的工具。可序列化</em>非常有限。</li>

</ul>

<p>幸运的是，编写实现<em>java.io的具有版本意识的UDT很容易。可序列化，</em>并且可以随着时间的推移而发展。例如，这是此类的第一个版本：</p>

<pre>
package com.example.types;

import java.io.*;
import java.math.*;

public class Price implements Externalizable
{
    // initial version id
    private static final int FIRST_VERSION = 0;

    public String currencyCode;
    public BigDecimal amount;

    // zero-arg constructor needed by Externalizable machinery
    public Price() {}

    public Price( String currencyCode, BigDecimal amount )
    {
        this.currencyCode = currencyCode;
        this.amount = amount;
    }

    // Externalizable implementation
    public void writeExternal(ObjectOutput out) throws IOException
    {
        // first write the version id
        out.writeInt( FIRST_VERSION );

        // now write the state
        out.writeObject( currencyCode );
        out.writeObject( amount );
    }
    
    public void readExternal(ObjectInput in) 
        throws IOException, ClassNotFoundException
    {
        // read the version id
        int oldVersion = in.readInt();
        if ( oldVersion &lt; FIRST_VERSION ) { 
            throw new IOException( "Corrupt data stream." ); 
        }
        if ( oldVersion &gt; FIRST_VERSION ) { 
            throw new IOException( "Can't deserialize from the future." );
        }

        currencyCode = (String) in.readObject();
        amount = (BigDecimal) in.readObject();
    }
}</pre>

<p>此后，很容易编写第二个版本的用户定义类型，以添加一个新字段。当旧版本<samp class="codeph">Price</samp>值是从数据库中读取的，它们会即时进行升级。更改以<strong>粗体显示</strong> ：</p>

<pre>
package com.example.types;

import java.io.*;
import java.math.*;
<strong>import java.sql.*;</strong>

public class Price implements Externalizable
{
    // initial version id
    private static final int FIRST_VERSION = 0;
    <strong>private static final int TIMESTAMPED_VERSION = FIRST_VERSION + 1;</strong>

    <strong>private static final Timestamp DEFAULT_TIMESTAMP = new Timestamp( 0L );</strong>

    public String currencyCode;
    public BigDecimal amount;
    <strong>public Timestamp timeInstant;</strong>

    // 0-arg constructor needed by Externalizable machinery
    public Price() {}

    public Price( String currencyCode, BigDecimal amount<strong>, 
                  Timestamp timeInstant</strong> )
    {
        this.currencyCode = currencyCode;
        this.amount = amount;
        <strong>this.timeInstant = timeInstant;</strong>
    }

    // Externalizable implementation
    public void writeExternal(ObjectOutput out) throws IOException
    {
        // first write the version id
        out.writeInt( <strong>TIMESTAMPED_VERSION</strong> );

        // now write the state
        out.writeObject( currencyCode );
        out.writeObject( amount );
        <strong>out.writeObject( timeInstant );</strong>
    }
      
    public void readExternal(ObjectInput in) 
        throws IOException, ClassNotFoundException
    {
        // read the version id
        int oldVersion = in.readInt();
        if ( oldVersion &lt; FIRST_VERSION ) { 
            throw new IOException( "Corrupt data stream." ); 
        }
        if ( oldVersion &gt; <strong>TIMESTAMPED_VERSION</strong> ) {
            throw new IOException( "Can't deserialize from the future." ); 
        }

        currencyCode = (String) in.readObject();
        amount = (BigDecimal) in.readObject();

        <strong>if ( oldVersion &gt;= TIMESTAMPED_VERSION ) {
            timeInstant = (Timestamp) in.readObject(); 
        }
        else { 
            timeInstant = DEFAULT_TIMESTAMP;</strong> 
        }
    }
}</pre>

<p>应用程序需要使其代码在所有层之间保持同步。对于在客户端和服务器中运行的所有Java代码都是如此。对于在多层中运行的功能和过程而言，这是正确的。对于在多层中运行的用户定义类型也是如此。当客户端和服务器运行不同版本的应用程序代码时，程序员应进行防御性编码。尤其是，程序员应为用户定义的类型编写防御性的序列化逻辑，以便应用程序可以妥善处理客户端/服务器版本不匹配的情况。</p>

</div>

</div>

<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="cdevspecial.html" title="本节讨论Derby的特殊编程。">Derby服务器端编程</a></div>
</div>
</div>



</body></html>