<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="reference">
<meta name="DC.Title" content="CREATE TYPE statement">
<meta name="abstract" content="The CREATE TYPE statement creates a user-defined type (UDT). A UDT is a serializable Java class whose instances are stored in columns.">
<meta name="description" content="The CREATE TYPE statement creates a user-defined type (UDT). A UDT is a serializable Java class whose instances are stored in columns.">
<meta name="DC.subject" content="CREATE TYPE statement, SQL statements, CREATE TYPE, user-defined types, creating, data types, user-defined">
<meta name="keywords" content="CREATE TYPE statement, SQL statements, CREATE TYPE, user-defined types, creating, data types, user-defined">
<meta name="DC.Relation" scheme="URI" content="crefsqlj95081.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqljcreateaggregate.html">
<meta name="DC.Relation" scheme="URI" content="rrefcreatefunctionstatement.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqlj20937.html">
<meta name="DC.Relation" scheme="URI" content="rrefcreateprocedurestatement.html">
<meta name="DC.Relation" scheme="URI" content="rrefcreaterole.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqlj31580.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqljcreatesequence.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqljcreatesynonym.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqlj24513.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqlj43125.html">
<meta name="DC.Relation" scheme="URI" content="rrefsqlj15446.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="rrefsqljcreatetype">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>CREATE TYPE语句</title>
</head>
<body id="rrefsqljcreatetype" ><a name="rrefsqljcreatetype"><!-- --></a>


<h1 class="topictitle1">CREATE TYPE语句</h1>



<div><p>CREATE TYPE语句创建用户定义的类型（UDT）。UDT是可序列化的Java类，其实例存储在列中。</p>

<div class="section"><p>由<a href="rrefsqljexternalname.html#rrefsqljexternalname">EXTERNAL NAME子句</a>指定的Java类必须实现<em>java.io。可序列化的</em>接口。</p>
</div>

<div class="section"><h2 class="sectiontitle">句法</h2>
<pre><strong>CREATE TYPE <em><a href="rreftypename.html#rreftypename">typeName</a></em>
<a href="rrefsqljexternalname.html#rrefsqljexternalname">EXTERNAL NAME</a> <em>singleQuotedString</em>
LANGUAGE JAVA</strong></pre>

<p>类型名称由可选的<em><a href="rrefschemaname.html">schemaName</a></em>和<em><a href="crefsqlj34834.html">SQLIdentifier组成</a></em> 。如果未提供<em>schemaName</em> ，则当前架构为默认架构。如果指定了合格的类型名称，则架构名称不能以SYS开头。</p>

<p>如果<a href="rrefsqljexternalname.html#rrefsqljexternalname">EXTERNAL NAME子句</a>指定的Java类未实现<em>java.io。可序列化</em> ，或者如果它不是公共的并且在类路径上可见，则<span>Derby</span>在准备引用UDT的语句时会引发异常。</p>

<p>UDT不能显式转换为任何其他类型，并且任何其他类型都不能转换为UDT。</p>

<p>UDT没有订购。这意味着您无法比较和排序UDT。您不能在涉及以下内容的表达式中使用它们<samp class="codeph"><</samp> ， <samp class="codeph">=</samp> ， <samp class="codeph">></samp> ，IN，BETWEEN和LIKE运算符。您不能在集合，DISTINCT表达式和GROUP / ORDER BY子句中使用UDT。您不能在它们上建立索引。</p>

<p>您可以在UDT中使用子类型。也就是说，如果使用CREATE TYPE语句将名为C的类绑定到UDT，则可以使用C的任何子类的实例填充该UDT值。</p>

</div>

<div class="example"><h2 class="sectiontitle">例</h2>
<pre><strong>CREATE TYPE price
EXTERNAL NAME 'com.example.types.Price'
LANGUAGE JAVA</strong></pre>

</div>

<div class="section"><h2 class="sectiontitle">使用用户定义的类型</h2>
<p>您可以使用具有UDT的列来创建表和视图。例如：</p>

<pre><strong>CREATE TABLE order
(
    orderID INT GENERATED ALWAYS AS IDENTITY,
    customerID INT REFERENCES customer( customerID ),
    totalPrice typeSchema.price
);</strong></pre>

<p>尽管UDT没有自然顺序，但是您可以使用生成的列来提供有用的排序顺序：</p>

<pre><strong>ALTER TABLE order 
  ADD COLUMN normalizedValue DECIMAL( 31, 5 ) GENERATED ALWAYS AS 
    ( convert( 'EUR', TIMESTAMP('2005-01-01 09:00:00'), totalPrice ) );
CREATE INDEX normalizedOrderPrice ON order( normalizedValue );</strong></pre>

<p>您可以使用工厂函数来构造UDT。例如：</p>

<pre><strong>INSERT INTO order( customerID, totalPrice )
  VALUES ( 12345, 
           makePrice( 'USD', 
                      CAST( 9.99 AS DECIMAL( 31, 5 ) ), 
                      TIMESTAMP('2009-10-16 14:24:43') ) );</strong></pre>

<p>填充UDT列后，您可以在其他INSERT和UPDATE语句中使用它。例如：</p>

<pre><strong>INSERT INTO backOrder SELECT * from order;

UPDATE order SET totalPrice = ( SELECT todaysDiscount FROM discount );
UPDATE order SET totalPrice = adjustForInflation( totalPrice );</strong></pre>

<p>使用函数，可以在SELECT语句中访问UDT内部的字段：</p>

<pre><strong>SELECT getCurrencyCode( totalPrice ) from order;</strong></pre>

<p>您可以使用JDBC API <em>setObject（）</em>和<em>getObject（）</em>方法来存储和检索UDT的值。例如：</p>

<pre><strong>PreparedStatement ps = conn.prepareStatement( "SELECT * from order" );
ResultSet rs = ps.executeQuery();

while( rs.next() )
{
    int    orderID = rs.getInt( 1 );
    int    customerID = rs.getInt( 2 );
    Price  totalPrice = (Price) rs.getObject( 3 );
    ...
}</strong></pre>

</div>

</div>

<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="crefsqlj95081.html" title="">CREATE语句</a></div>
</div>
<div class="relref"><strong>相关参考</strong><br>
<div><a href="rrefsqljcreateaggregate.html" title="CREATE DERBY AGGREGATE语句创建用户定义的聚合（UDA）。UDA是自定义聚合运算符。">CREATE DERBY AGGREGATE语句</a></div>
<div><a href="rrefcreatefunctionstatement.html" title="CREATE FUNCTION语句创建一个Java函数，然后可以在表达式中使用它。">CREATE FUNCTION语句</a></div>
<div><a href="rrefsqlj20937.html" title="CREATE INDEX语句在表上创建索引。索引可以在表中的一列或多列上。">CREATE INDEX语句</a></div>
<div><a href="rrefcreateprocedurestatement.html" title="CREATE PROCEDURE语句创建一个Java存储过程，然后可以使用CALL PROCEDURE语句调用它。">CREATE PROCEDURE语句</a></div>
<div><a href="rrefcreaterole.html" title="CREATE ROLE语句创建一个SQL角色。当数据库有许多用户时，角色对于管理特权很有用。">CREATE ROLE语句</a></div>
<div><a href="rrefsqlj31580.html" title="CREATE SCHEMA语句创建一个模式，该模式是在单个集合中对对象进行逻辑分组并为对象提供唯一名称空间的一种方式。">CREATE SCHEMA语句</a></div>
<div><a href="rrefsqljcreatesequence.html" title="CREATE SEQUENCE语句创建一个序列生成器，该生成器是一种用于一次生成一个精确数值的机制。">CREATE SEQUENCE语句</a></div>
<div><a href="rrefsqljcreatesynonym.html" title="CREATE SYNONYM语句为同一模式或其他模式中存在的表或视图提供了备用名称。">创建SYNONYM语句</a></div>
<div><a href="rrefsqlj24513.html" title="CREATE TABLE语句创建一个表。表包含列和约束，以及数据必须遵循的规则。">CREATE TABLE语句</a></div>
<div><a href="rrefsqlj43125.html" title="CREATE TRIGGER语句创建一个触发器，该触发器定义了在指定表上发生数据库事件时执行的一组操作。">CREATE TRIGGER语句</a></div>
<div><a href="rrefsqlj15446.html" title="CREATE VIEW语句创建一个视图，该视图是由查询形成的虚拟表。">CREATE VIEW语句</a></div>
</div>
</div>



</body></html>