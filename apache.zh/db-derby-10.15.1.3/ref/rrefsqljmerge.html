<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="reference">
<meta name="DC.Title" content="MERGE statement">
<meta name="abstract" content="The MERGE statement scans a table and either INSERTs, UPDATEs, or DELETEs rows depending on whether the rows satisfy a specified condition.">
<meta name="description" content="The MERGE statement scans a table and either INSERTs, UPDATEs, or DELETEs rows depending on whether the rows satisfy a specified condition.">
<meta name="DC.subject" content="MERGE statement, SQL statements, MERGE">
<meta name="keywords" content="MERGE statement, SQL statements, MERGE">
<meta name="DC.Relation" scheme="URI" content="crefsqlj39374.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="rrefsqljmerge">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>合并声明</title>
</head>
<body id="rrefsqljmerge" ><a name="rrefsqljmerge"><!-- --></a>


<h1 class="topictitle1">合并声明</h1>



<div><p>MERGE语句扫描表和INSERT，UPDATE或DELETE行，具体取决于行是否满足指定条件。</p>

<div class="section"><h2 class="sectiontitle">句法</h2>
<pre><strong>MERGE INTO <em>targetTable</em> [ [ AS ] <em>targetCorrelationName</em> ]
USING <em>sourceTable</em> [ [ AS ] <em>sourceCorrelationName</em> ]
ON <em>searchCondition <a href="rrefsqljmerge.html#rrefsqljmerge__mergewhen">mergeWhenClause</a></em> [ <em>mergeWhenClause</em> ]*
</strong></pre>

<p><em>targetTable</em>和<em>sourceTable</em>都是<em><a href="rreftablename.html">tableName</a></em> 。</p>

<p><em>targetTable</em>必须标识一个基表。 <em>targetTable</em>可能不是触发语句中的转换表，也可能不是同义词。</p>

<p> <em>sourceTable</em>必须标识基本表或表函数，并且可能不是同义词。</p>

<p>无论<em>targetCorrelationName</em>和<em>sourceCorrelationName</em>是<em><a href="rrefcorrelationname.html">correlationName</a></em>秒。</p>

<p>不合格的源表名称（或其相关名称）可能与不合格的目标表名称（或其相关名称）不同。</p>

<p><em>searchCondition</em>是一个<em><a href="rrefsqlj23075.html">布尔表达式</a></em> 。<em>searchCondition</em>引用的列必须位于<em>targetTable</em>或<em>sourceTable中</em> 。<em>searchCondition中</em>提到的<em>功能</em>可能无法修改SQL数据。</p>

<p>成功的MERGE语句的行数是该语句插入，更新和删除的总行数。</p>

<div class="note"><span class="notetitle">注意：</span> MERGE语句仅在数据库已完全升级到<span>Derby</span> Release 10.11或更高版本后才有效。（有关更多信息，请参阅《 <span><em>Derby开发人员指南</em></span> 》中的“升级数据库”。）在10.10或更低版本的数据库中，该语句没有任何意义。</div>

</div>

<div class="section" id="rrefsqljmerge__mergewhen"><a name="rrefsqljmerge__mergewhen"><!-- --></a><h2 class="sectiontitle">mergeWhenClause</h2>
<pre><strong><em><a href="rrefsqljmerge.html#rrefsqljmerge__whenmatched">mergeWhenMatched</a></em> | <em><a href="rrefsqljmerge.html#rrefsqljmerge__whennotmatched">mergeWhenNotMatched</a></em>
</strong></pre>

</div>

<div class="section" id="rrefsqljmerge__whenmatched"><a name="rrefsqljmerge__whenmatched"><!-- --></a><h2 class="sectiontitle">mergeWhenMatched</h2>
<pre><strong>WHEN MATCHED [ AND <em>matchRefinement</em> ] THEN { <em><a href="rrefsqljmerge.html#rrefsqljmerge__mergeupdate">mergeUpdate</a></em> | DELETE }
</strong></pre>

<p><em>matchRefinement</em>是一个<em><a href="rrefsqlj23075.html">布尔表达式</a></em> 。<em>matchRefinement</em>引用的列必须位于<em>targetTable</em>或<em>sourceTable中</em> 。<em>matchRefinement中</em>提到的<em>函数</em>可能无法修改SQL数据。</p>

</div>

<div class="section" id="rrefsqljmerge__whennotmatched"><a name="rrefsqljmerge__whennotmatched"><!-- --></a><h2 class="sectiontitle">mergeWhenNotMatched</h2>
<pre><strong>WHEN NOT MATCHED [ AND <em>matchRefinement</em> ] THEN <em><a href="rrefsqljmerge.html#rrefsqljmerge__mergeinsert">mergeInsert</a></em>
</strong></pre>

<p><em>matchRefinement</em>是一个<em><a href="rrefsqlj23075.html">布尔表达式</a></em> 。<em>matchRefinement</em>引用的列必须位于<em>targetTable</em>或<em>sourceTable中</em> 。<em>matchRefinement中</em>提到的<em>函数</em>可能无法修改SQL数据。</p>

<p>尽管SQL标准允许这样做，但<span>Derby</span>当前不支持WHEN [NOT] MATCHED子句中的子查询。</p>

</div>

<div class="section" id="rrefsqljmerge__mergeupdate"><a name="rrefsqljmerge__mergeupdate"><!-- --></a><h2 class="sectiontitle">mergeUpdate</h2>
<pre><strong>UPDATE SET <em><a href="rrefcolumnname.html">column-Name</a></em> = <em>value</em> [, <em>column-Name</em> = <em>value</em> ]*
</strong></pre>

<p>更新的列必须是<em>targetTable中的</em>列。</p>

<p>UPDATE值中提到的函数可能无法修改SQL数据。</p>

<p>在用于UPDATE操作的SET运算符的右侧，DEFAULT是生成的和标识列所允许的唯一值。</p>

<p>没有更新列的列表可以多次提及同一列。</p>

<p>必须根据<a href="rrefsqlj58560.html">数据类型分配和比较，排序和排序中</a>记录的规则，将更新后的值的数据类型分配给相应的列。</p>

</div>

<div class="section" id="rrefsqljmerge__mergeinsert"><a name="rrefsqljmerge__mergeinsert"><!-- --></a><h2 class="sectiontitle">mergeInsert</h2>
<pre><strong>INSERT [ ( <em><a href="rrefsimplecolumnname.html">Simple-column-Name</a></em> [ , <em>Simple-column-Name</em> ]*  ) ] VALUES ( <em>value</em> [, <em>value</em> ]* )
</strong></pre>

<p>插入的列必须是<em>targetTable中的</em>列。</p>

<p>INSERT值中提到的函数可能无法修改SQL数据。</p>

<p>插入列的列表不能提及标识列，也不能多次提及同一列。</p>

<p>在VALUES子句中，DEFAULT是生成的列的唯一允许值。</p>

<p>必须根据<a href="rrefsqlj58560.html">数据类型分配和比较，排序和排序中</a>记录的规则，将插入值的数据类型分配给相应的列。</p>

</div>

<div class="section"><h2 class="sectiontitle">所需特权</h2>
<p>执行MERGE语句的用户必须具有以下特权。有关特权的信息，请参见<a href="rrefsqljgrant.html">GRANT语句</a> 。</p>

<ul>
<li>对<em>targetTable的</em>每个更新列具有UPDATE特权。整个<em>targetTable</em>的全部UPDATE特权将解决此问题。</li>

<li>如果有WHEN NOT MATCHED子句，则对<em>targetTable拥有</em> INSERT特权。</li>

<li>如果有<em>匹配，</em>则对<em>targetTable拥有</em> DELETE特权...THEN DELETE子句。</li>

<li>对布尔表达式和INSERT / UPDATE值中提到的所有函数具有EXECUTE特权。</li>

<li>对布尔表达式和INSERT / UPDATE值中提到的所有序列和用户定义类型具有USAGE特权。有关更多信息，请参见<a href="rrefsqljcreatesequence.html">CREATE SEQUENCE语句</a>和<a href="rrefsqljcreatetype.html">CREATE TYPE语句</a> 。</li>

<li>布尔表达式和SET子句的<em>值</em>表达式中提到的所有列都具有SELECT特权。</li>

</ul>

</div>

<div class="section"><h2 class="sectiontitle">MERGE语句的行为</h2>
<p>MERGE语句的行为如下表所述。</p>


<div class="tablenoborder"><table cellspacing="0" cellpadding="4" border="1" summary="This table lists and describes some specific behaviors of the MERGE statement." frame="border" rules="all"><caption>表格1。合并语句行为</caption>


<thead align="left">
<tr valign="bottom">
<th valign="bottom" width="40%" id="N10380">情况或行为</th>

<th valign="bottom" width="60%" id="N10387">描述</th>

</tr>

</thead>

<tbody>
<tr>
<td valign="top" width="40%" headers="N10380">源表为空</td>

<td valign="top" width="60%" headers="N10387">如果<em>sourceTable</em>为空，则SQLState 02000会引发“无数据”警告。</td>

</tr>

<tr>
<td valign="top" width="40%" headers="N10380">进行初始联接</td>

<td valign="top" width="60%" headers="N10387">在对<em>targetTable</em>进行任何更改之前， <em>sourceTable</em>将通过ON子句连接到<em>targetTable</em> 。将此<em>联接</em>结果<em>称为</em> J。让N表示此<em>联接中</em>缺少的<em>sourceTable中</em>的行。</td>

</tr>

<tr>
<td valign="top" width="40%" headers="N10380">子句顺序很重要</td>

<td valign="top" width="60%" headers="N10387"><em>mergeWhenMatched</em>和<em>mergeWhenNotMatched</em>子句按声明顺序应用。</td>

</tr>

<tr>
<td valign="top" width="40%" headers="N10380">第一个匹配的子句获胜</td>

<td valign="top" width="60%" headers="N10387">对于以J每一行， <span>德比</span>仅适用其<em>matchRefinement</em>满足第一<em>mergeWhenMatched</em>条款。</td>

</tr>

<tr>
<td valign="top" width="40%" headers="N10380">第一个不匹配的子句获胜</td>

<td valign="top" width="60%" headers="N10387">对于N中的每一行， <span>德比</span>仅适用其<em>matchRefinement</em>满足第一<em>mergeWhenNotMatched</em>条款。</td>

</tr>

<tr>
<td valign="top" width="40%" headers="N10380">不允许双浸</td>

<td valign="top" width="60%" headers="N10387">如果MERGE语句尝试两次更改（更新或删除）同一行，则会引发基数冲突。如果多个源行加入同一目标行，则会发生这种情况。</td>

</tr>

</tbody>

</table>
</div>

</div>

<div class="example"><h2 class="sectiontitle">例子</h2>
<pre><strong>MERGE INTO hotIssues h
USING issues i
ON h.issueID = i.issueID
WHEN MATCHED AND i.lastUpdated = CURRENT_DATE 
    THEN UPDATE SET h.lastUpdated = i.lastUpdated
WHEN MATCHED AND i.lastUpdated &lt; CURRENT_DATE THEN DELETE
WHEN NOT MATCHED AND i.lastUpdated = CURRENT_DATE 
    THEN INSERT VALUES ( i.issueID, i.lastUpdated );

MERGE INTO companies c
USING adhocInvoices a
ON a.companyName = c.companyName
WHEN NOT MATCHED THEN INSERT ( companyName ) VALUES ( a.companyName );

MERGE INTO warehouse.productList w
USING production.productList p
ON w.productID = p.productID
WHEN MATCHED and w.lastUpdated != p.lastUpdated
    THEN UPDATE SET lastUpdated = p.lastUpdated, 
                    description = p.description, 
                    price = p.price
WHEN NOT MATCHED
    THEN INSERT values ( p.productID, p.lastUpdated, p.description,
                         p.price );
</strong></pre>

</div>

</div>

<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="crefsqlj39374.html" title="">语句</a></div>
</div>
</div>



</body></html>