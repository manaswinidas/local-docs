<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="reference">
<meta name="DC.Title" content="Simple IN predicate transformations">
<meta name="abstract" content="A simple IN list predicate is a predicate where the left operand is a simple column reference and the IN list is composed entirely of constants or parameter markers.">
<meta name="description" content="A simple IN list predicate is a predicate where the left operand is a simple column reference and the IN list is composed entirely of constants or parameter markers.">
<meta name="DC.subject" content="IN transformations, Internal transformation of statements, IN predicates, IN predicate transformations, probe predicate">
<meta name="keywords" content="IN transformations, Internal transformation of statements, IN predicates, IN predicate transformations, probe predicate">
<meta name="DC.Relation" scheme="URI" content="ctuntransform35783.html">
<meta name="DC.Relation" scheme="URI" content="rtuntransform139.html">
<meta name="DC.Relation" scheme="URI" content="rtuntransform208.html">
<meta name="DC.Relation" scheme="URI" content="rtuntransform866214.html">
<meta name="DC.Relation" scheme="URI" content="rtuntransform590.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="rtuntransform582">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>简单的IN谓词转换</title>
</head>
<body id="rtuntransform582" ><a name="rtuntransform582"><!-- --></a>


<h1 class="topictitle1">简单的IN谓词转换</h1>



<div><p><dfn class="term">简单的</dfn> IN列表谓词是这样的谓词，其中左操作数是简单的列引用，并且IN列表完全由常量或参数标记组成。</p>

<div class="section"><p>有关定义，请参见<a href="ctuntransform13966.html#ctuntransform13966__rtuntransform13785">简单的列参考</a> 。</p>

<p>以下是简单IN谓词的示例：</p>

<pre><strong>orig_airport IN ('ABQ', 'AKL', 'DSM')

orig_airport IN (?, ?, ?)

orig_airport IN ('ABQ', ?, ?, 'YYZ')</strong></pre>
</div>

<div class="section"><h2 class="sectiontitle">探测谓词</h2>
<p><span>Derby</span>将每个IN列表谓词转换为等式谓词，其右操作数是内部创建的参数标记。此内部相等谓词称为<dfn class="term">探测谓词</dfn> 。上面的每个简单IN谓词示例都转换为以下探测谓词：</p>

<pre><strong>orig_airport = ?</strong></pre>

<p>探测谓词与普通相等谓词的处理方式有所不同。在查询优化和执行期间，将以特殊方式处理探测谓词。</p>

<p>在优化过程中， <span>Derby</span>分析探针谓词，以确定探针谓词是否对限制从磁盘检索的行数有用。为了使谓词有用，必须满足以下两个条件：</p>

<ul>
<li>在该列引用所属的表上必须定义一个索引，并且该列引用必须是索引中的第一列。在上面的示例中， <samp class="codeph">orig_airport</samp>是列引用。</li>

<li>使用探测谓词和相应索引之一的访问路径的估计成本必须小于优化器计算的任何其他访问路径的估计成本。通常，这意味着IN列表中的值数明显少于列引用所属的表中的行数。</li>

</ul>

<p>如果同时满足这两个要求，则<span>Derby</span>将在查询执行时使用探测谓词来<em>探测</em> IN列表中值的基础索引。换句话说，探测谓词的右操作数（参数）成为占位符， <span>Derby</span>将从IN列表中插入不同的值。然后，对于每个值， <span>Derby</span>将从索引中读取匹配的行。</p>

<p>如果两个条件中的任何一个都不满足，则<span>Derby</span>丢弃内部探测谓词，并使用原始IN列表谓词执行查询。</p>

</div>

<div class="section"><h2 class="sectiontitle">例子</h2>
<p>以下查询已提交给<span>Derby</span> ：</p>

<pre><strong>SELECT flights.orig_airport, cities.city_name 
    FROM flights, cities
    WHERE flights.orig_airport IN ('ABQ', 'DSM', 'YYZ')
        AND flights.orig_airport = cities.airport</strong></pre>

<p><span>Derby</span>优化器在内部将该查询转换为：</p>

<pre><strong>SELECT flights.orig_airport, cities.city_name
    FROM flights, cities
    WHERE flights.orig_airport = ?
        AND flights.orig_airport = cities.airport</strong></pre>

<p>在此转换后的查询中， <samp class="codeph">flights.orig_airport = ?</samp>是内部探针谓词。</p>

<p>有一个索引<samp class="codeph">org_airport</samp>中的列<samp class="codeph">flights</samp>表。如果探查该索引的三个值（ABQ，DSM，YYZ）的估计费用小于访问该索引的费用， <samp class="codeph">flights</samp>在表中， <span>Derby</span>将在查询执行时对索引进行探测。这种方法可确保<span>Derby</span>仅从<span>Derby</span>表中读取必要的行。</p>

<p>在更高的层次上， <span>Derby</span>使用索引探测IN列表的方法是多次评估转换后的谓词的内部方法。对于IN列表中的每个值，对谓词进行一次评估。</p>

<p>从JDBC的角度来看， <span>Derby</span>逻辑上（但实际上不是）执行以下语句，然后将三个结果集组合在一起（ <samp class="codeph">rs1</samp> ， <samp class="codeph">rs2</samp>和<samp class="codeph">rs3</samp> ）：</p>

<pre>PreparedStatement ps = conn.prepareStatement(
    "select flights.orig_airport, cities.city_name " +
    "from flights, cities " +
    "where flights.orig_airport = ? " +
        "and flights.orig_airport = cities.airport ");

ps.setString(1, "ABQ");
rs1 = ps.executeQuery();

ps.setString(1, "DSM");
rs2 = ps.executeQuery();

ps.setString(1, "YYZ");
rs3 = ps.executeQuery();</pre>

<p>从SQL的角度来看， <span>Derby</span>在逻辑上（但不是实际）执行以下语句：</p>

<pre><strong>SELECT flights.orig_airport, cities.city_name
    FROM flights, cities
    WHERE flights.orig_airport = 'ABQ'
        AND flights.orig_airport = cities.airport

UNION ALL

SELECT flights.orig_airport, cities.city_name
    FROM flights, cities
    WHERE flights.orig_airport = 'DSM'
        AND flights.orig_airport = cities.airport

UNION ALL

SELECT flights.orig_airport, cities.city_name
    FROM flights, cities
    WHERE flights.orig_airport = 'YYZ'
        AND flights.orig_airport = cities.airport</strong></pre>

<p>在上面的SQL示例中，对于每个子查询，相等谓词都会限制从中读取的行数<samp class="codeph">flights</samp>表，以便该过程避免必须从磁盘读取不必要的行。</p>

<p>越大<samp class="codeph">flights</samp>表中，通过探查相对较少的IN列表值的索引， <span>Derby</span>将节省更多时间。</p>

<p>通过使用探测谓词，无论基表有多大， <span>Derby</span>最多只需探测索引N次，其中N是IN列表的大小。如果N显着小于表中的行数，或者显着小于IN列表中的最小值和最大值之间的行数，则选择性探测可确保<span>Derby</span>不会花费时间从磁盘读取不必要的行。</p>

</div>

</div>

<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="ctuntransform35783.html" title="带OR谓词的WHERE子句通常是不可优化的。如果至少一个谓词是可优化的，则可以优化谓词由AND连接的WHERE子句。">谓词转换</a></div>
</div>
<div class="relref"><strong>相关参考</strong><br>
<div><a href="rtuntransform139.html" title="一个BETWEEN谓词被转换为使用> =和<=运算符的等价谓词，它们是可优化的。">转换之间</a></div>
<div><a href="rtuntransform208.html" title="本节介绍如何使用LIKE转换作为比较运算符。">像转换</a></div>
<div><a href="rtuntransform866214.html" title="NOT IN列表转换为使用<>运算符的多个谓词。">不在谓词转换中</a></div>
<div><a href="rtuntransform590.html" title="如果WHERE子句中的所有OR谓词都具有特定形式，则它们可能是可优化的。">或变换</a></div>
</div>
</div>



</body></html>