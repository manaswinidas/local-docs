<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="concept">
<meta name="DC.Title" content="Flattening a subquery into a normal join">
<meta name="abstract" content="Subqueries are allowed to return more than one row when used with IN, EXISTS, and ANY. However, for each row returned in the outer row, Derby evaluates the subquery until it returns one row; it does not evaluate the subquery for all rows returned.">
<meta name="description" content="Subqueries are allowed to return more than one row when used with IN, EXISTS, and ANY. However, for each row returned in the outer row, Derby evaluates the subquery until it returns one row; it does not evaluate the subquery for all rows returned.">
<meta name="DC.subject" content="Subqueries, flattening of">
<meta name="keywords" content="Subqueries, flattening of">
<meta name="DC.Relation" scheme="URI" content="ctuntransform13699.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform25857.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform25868.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform47182.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform867165.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform867201.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="ctuntransform36368">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>将子查询展平为普通联接</title>
</head>
<body id="ctuntransform36368" ><a name="ctuntransform36368"><!-- --></a>


<h1 class="topictitle1">将子查询展平为普通联接</h1>



<div><p>与IN，EXISTS和ANY一起使用时，允许子查询返回多行。但是，对于外部行中返回的每一行， <span>Derby都会</span>评估子查询，直到它返回一行；它不会评估返回的所有行的子查询。</p>

<p>例如，给定两个表， <samp class="codeph">t1</samp>和<samp class="codeph">t2</samp> ：</p>

<pre><strong>c1</strong>
--
 1
 2
 3
 
<strong>c1</strong>
--
 2
 2
 1
</pre>

<p>和以下查询：</p>

<pre><strong>SELECT c1 FROM t1 WHERE c1 IN (SELECT c1 FROM t2)</strong></pre>

<p>结果将是</p>

<pre>1
2</pre>

<p>只需选择<samp class="codeph">t1.c1</samp>当简单地将这些表连接起来会产生不同的结果时：</p>

<pre><strong>SELECT t1.c1 FROM t1, t2 WHERE t1.c1 = t2.c1
   1
   2
   2</strong></pre>

<p>仅当子查询未在结果集中引入任何重复项时，才可以将包含此类子查询的语句展平为联接（在我们的示例中，子查询引入了重复项，因此不能简单地展平为联接）。但是，如果满足此要求和其他要求（在下面列出），则该语句将变平，以使子查询的FROM列表中的表被视为位于外部FROM列表中的表的内部。</p>

<p>例如，如果满足以下条件，则查询可以被平整为联接<samp class="codeph">c1</samp>在<samp class="codeph">t2</samp>有一个唯一的索引。它将不会在结果集中引入任何重复的值。</p>

<p>展平为普通联接的要求如下：</p>

<ul>
<li>子查询不在OR下。</li>

<li>子查询类型为EXISTS，IN或ANY，或者它是比较运算符右侧的表达式子查询。</li>

<li>子查询不在外部查询块的SELECT列表中。</li>

<li>子查询的SELECT列表中没有聚合。</li>

<li>子查询没有GROUP BY子句。</li>

<li>子查询没有ORDER BY，结果偏移量或获取第一子句。</li>

<li>有一个唯一性条件，可以确保子查询在展平到外部查询块中时不会引入任何重复项。</li>

<li>子查询的FROM列表中的每个表（在任何视图，派生表或子查询展平之后）都必须是<a href="ctuntransform13966.html#ctuntransform13966__rtuntransform41494">基本表</a> 。</li>

<li>如果子查询中有WHERE子句，则子查询中至少有一个表的列<a href="ctuntransform13966.html#ctuntransform13966__rtuntransform24389">相等，谓词</a> s的表达式不包含子查询块中的任何列引用。这些列必须是表上任何唯一索引的键列的超集。对于子查询中的所有其他表，相等谓词中带有不包含同一表中列的表达式的列是该表上任何唯一索引的唯一列的超集。</li>

</ul>

<p>展平为普通联接为优化器提供了更多选择最佳查询计划的选项。例如，如果以下语句：</p>

<pre><strong>SELECT huge.* FROM huge
WHERE c1 IN (SELECT c1 FROM tiny)</strong></pre>

<p>可以压成</p>

<pre><strong>SELECT huge.* FROM huge, tiny
WHERE huge.c1 = tiny.c1</strong></pre>

<p>优化器可以选择要扫描的查询计划<samp class="codeph">tiny</samp>然后对大型表进行一些探查，而不是扫描大型表并对小型表进行大量探查。</p>

<p>这是本节前面使用的示例的扩展。给定</p>

<pre><strong>CREATE TABLE t1 (c1 INT)
CREATE TABLE t2 (c1 INT NOT NULL PRIMARY KEY)
CREATE TABLE t3 (c1 INT NOT NULL PRIMARY KEY)
INSERT INTO t1 VALUES (1), (2), (3)
INSERT INTO t2 VALUES (1), (2), (3)
INSERT INTO t3 VALUES (2), (3), (4)</strong></pre>

<p>这个查询</p>

<pre><strong>SELECT t1.* FROM t1 WHERE t1.c1 IN 
    (SELECT t2.c1 FROM t2, t3 WHERE t2.c1 = t3.c1)</strong></pre>

<p>应该返回以下结果：</p>

<pre>2
3</pre>

<p>该查询满足了扁平化为联接的所有要求，并且该语句可以转换为以下语句：</p>

<pre><strong>SELECT t1.*
FROM t1, t2, t3
WHERE t1.c1 = t2.c1
AND t2.c1 = t3.c1
AND t1.c1 = t3.c1</strong></pre>

<p>以下查询：</p>

<pre><strong>SELECT t1.*
FROM t1 WHERE EXISTS
(SELECT * FROM t2, t3 WHERE t2.c1 = t3.c1 AND t2.c1 = t1.c1)</strong></pre>

<p>可以转化为</p>

<pre><strong>SELECT t1.*
FROM t1, t2, t3
WHERE t1.c1 = t2.c1
AND t2.c1 = t3.c1
AND t1.c1 = t3.c1</strong></pre>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="ctuntransform13699.html" title="众所周知，子查询的评估成本很高。本节描述了Derby内部进行的一些转换，以减少评估它们的成本。">子查询处理和转换</a></div>
</div>
<div class="relconcepts"><strong>相关概念</strong><br>
<div><a href="ctuntransform25857.html" title="实现意味着子查询仅评估一次。可以实现几种类型的子查询。">物化</a></div>
<div><a href="ctuntransform25868.html" title="EXISTS联接是其中联接的右侧仅需要为每个外部行探测一次的联接。">将子查询展平为EXISTS联接</a></div>
<div><a href="ctuntransform47182.html" title="Derby展平VALUES子查询以提高性能。">展平VALUES子查询</a></div>
<div><a href="ctuntransform867165.html" title="如果至少有一行导致子查询的结果为true，则IN，ANY或EXISTS子查询的结果为true。这些语义使得在IN，ANY或EXISTS子查询中不需要DISTINCT。">在IN，ANY和EXISTS子查询中进行DISTINCT消除</a></div>
<div><a href="ctuntransform867201.html" title="可以保证最多返回一行的IN或ANY子查询可以转换为等效表达式子查询（不带IN或ANY的标量子查询）。子查询必须不相关。">IN / ANY子查询转换</a></div>
</div>
</div>



</body></html>