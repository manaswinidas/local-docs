<html lang="en-us"  xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us"><!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="copyright" content="(C) Copyright 2005">
<meta name="DC.rights.owner" content="(C) Copyright 2005">
<meta name="security" content="public">
<meta name="Robots" content="index,follow">
<meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">
<meta name="DC.Type" content="concept">
<meta name="DC.Title" content="Flattening a subquery into an EXISTS join">
<meta name="abstract" content="An EXISTS join is a join in which the right side of the join needs to be probed only once for each outer row.">
<meta name="description" content="An EXISTS join is a join in which the right side of the join needs to be probed only once for each outer row.">
<meta name="DC.subject" content="Subqueries, flattening of to an EXISTS join, EXISTS join, definition">
<meta name="keywords" content="Subqueries, flattening of to an EXISTS join, EXISTS join, definition">
<meta name="DC.Relation" scheme="URI" content="ctuntransform13699.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform25857.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform36368.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform47182.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform867165.html">
<meta name="DC.Relation" scheme="URI" content="ctuntransform867201.html">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="ctuntransform25868">
<meta name="DC.Language" content="en-us">
<link href="commonltr.css" type="text/css" rel="stylesheet">
<title>将子查询展平为EXISTS联接</title>
</head>
<body id="ctuntransform25868" ><a name="ctuntransform25868"><!-- --></a>


<h1 class="topictitle1">将子查询展平为EXISTS联接</h1>



<div><p>EXISTS联接是其中联接的右侧仅需要为每个外部行探测一次的联接。</p>

<p>使用这样的定义，EXISTS连接实际上不使用EXISTS关键字。当外部表中给定行的联接右侧最多有一个匹配行时， <span>Derby</span>将一条语句视为EXISTS连接。</p>

<p>如果子查询满足所有要求，则由于唯一性条件而无法将其平化为普通联接，可以将其平整为EXISTS联接（请参见下文）。回想一下将<a href="ctuntransform36368.html">子查询展平为普通联接</a>的第一个示例：</p>

<pre><strong>SELECT c1 FROM t1 
WHERE c1 IN (SELECT c1 FROM t2)</strong></pre>

<p>无法将此查询展平为普通联接，因为这样的联接将返回错误的结果。但是，此查询可以展平为<span>Derby</span>系统在内部识别为EXISTS联接的联接。处理EXISTS联接时， <span>Derby</span>知道在返回单行后停止处理联接的右侧。转换后的语句如下所示：</p>

<pre><strong>SELECT c1 FROM t1, t2
WHERE t1.c1 = t2.c1
EXISTS JOIN INTERNAL SYNTAX</strong></pre>

<p>展平为EXISTS联接的要求如下：</p>
 
<ul>
<li>子查询不在OR下。</li>

<li>子查询类型为EXISTS，IN或ANY。</li>

<li>子查询不在外部查询块的SELECT列表中。</li>

<li>子查询的SELECT列表中没有聚合。</li>

<li>子查询没有GROUP BY子句。</li>

<li>子查询没有ORDER BY，结果偏移量或获取第一子句。</li>

<li>子查询在其FROM列表中有一个<a href="ctuntransform13966.html#ctuntransform13966__rtuntransform41494">基本表项</a> 。</li>

<li>子查询中的所有谓词（包括在子查询运算符的左侧与子查询的SELECT列表中的列（对于IN或ANY子查询）之间形成的附加谓词）都不包含任何子查询，方法调用或字段访问。</li>

</ul>

<p>当将子查询展平为EXISTS联接时，子查询中的表将根据与之相关的所有表进行联接顺序依赖。这意味着一个表必须出现在所有依赖于连接顺序的表的内部。例如，</p>

<pre><strong>SELECT t1.* FROM t1, t2
WHERE EXISTS (SELECT * FROM t3 WHERE t1.c1 = t3.c1)</strong></pre>

<p>变得扁平</p>

<pre><strong>SELECT t1.* FROM t1, t2, t3 
WHERE t1.c1 = t3.c1</strong></pre>

<p>哪里<samp class="codeph">t3</samp>连接顺序取决于<samp class="codeph">t1</samp> 。这意味着可能的加入顺序为（ <samp class="codeph">t1</samp> ， <samp class="codeph">t2</samp> ， <samp class="codeph">t3</samp> ），（ <samp class="codeph">t1</samp> ， <samp class="codeph">t3</samp> ， <samp class="codeph">t2</samp> ）和（ <samp class="codeph">t2</samp> ， <samp class="codeph">t1</samp> ， <samp class="codeph">t3</samp> ）。</p>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>父主题：</strong> <a href="ctuntransform13699.html" title="众所周知，子查询的评估成本很高。本节描述了Derby内部进行的一些转换，以减少评估它们的成本。">子查询处理和转换</a></div>
</div>
<div class="relconcepts"><strong>相关概念</strong><br>
<div><a href="ctuntransform25857.html" title="实现意味着子查询仅评估一次。可以实现几种类型的子查询。">物化</a></div>
<div><a href="ctuntransform36368.html" title="与IN，EXISTS和ANY一起使用时，允许子查询返回多行。但是，对于外部行中返回的每一行，Derby都会评估子查询，直到它返回一行；它不会评估返回的所有行的子查询。">将子查询展平为普通联接</a></div>
<div><a href="ctuntransform47182.html" title="Derby展平VALUES子查询以提高性能。">展平VALUES子查询</a></div>
<div><a href="ctuntransform867165.html" title="如果至少有一行导致子查询的结果为true，则IN，ANY或EXISTS子查询的结果为true。这些语义使得在IN，ANY或EXISTS子查询中不需要DISTINCT。">在IN，ANY和EXISTS子查询中进行DISTINCT消除</a></div>
<div><a href="ctuntransform867201.html" title="可以保证最多返回一行的IN或ANY子查询可以转换为等效表达式子查询（不带IN或ANY的标量子查询）。子查询必须不相关。">IN / ANY子查询转换</a></div>
</div>
</div>



</body></html>