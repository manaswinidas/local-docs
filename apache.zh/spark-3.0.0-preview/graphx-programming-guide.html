<html class="no-js" ><!--<![endif]--><head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>GraphX-Spark 3.0.0-预览文档</title>
        
          <meta name="description" content="GraphX graph processing library guide for Spark 3.0.0-preview">
        

        

        <link rel="stylesheet" href="css/bootstrap.min.css">
        <style>
            body {
                padding-top: 60px;
                padding-bottom: 40px;
            }
        </style>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="css/bootstrap-responsive.min.css">
        <link rel="stylesheet" href="css/main.css">

        <script src="js/vendor/modernizr-2.6.1-respond-1.1.0.min.js"></script>

        <link rel="stylesheet" href="css/pygments-default.css">

        
        <!-- Google analytics script -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-32518208-2']);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        

    </head>
    <body >
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="https://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <!-- This code is taken from http://twitter.github.com/bootstrap/examples/hero.html -->

        <div class="navbar navbar-fixed-top" id="topbar">
            <div class="navbar-inner">
                <div class="container">
                    <div class="brand"><a href="index.html"><img src="img/spark-logo-hd.png" style="height:50px"></a> <span class="version">3.0.0预览版</span>
                    </div>
                    <ul class="nav">
                        <!--TODO(andyk): Add class="active" attribute to li some how.-->
                        <li><a href="index.html">总览</a></li>

                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">编程指南<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="quick-start.html">快速开始</a></li>
                                <li><a href="rdd-programming-guide.html">RDD，累加器，广播变量</a></li>
                                <li><a href="sql-programming-guide.html">SQL，数据框和数据集</a></li>
                                <li><a href="structured-streaming-programming-guide.html">结构化流</a></li>
                                <li><a href="streaming-programming-guide.html">火花流（DStreams）</a></li>
                                <li><a href="ml-guide.html">MLlib（机器学习）</a></li>
                                <li><a href="graphx-programming-guide.html">GraphX（图形处理）</a></li>
                                <li><a href="sparkr.html">SparkR（Spark上的R）</a></li>
                            </ul>
                        </li>

                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">API文件<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="api/scala/index.html#org.apache.spark.package">斯卡拉</a></li>
                                <li><a href="api/java/index.html">爪哇</a></li>
                                <li><a href="api/python/index.html">蟒蛇</a></li>
                                <li><a href="api/R/index.html">[R</a></li>
                                <li><a href="api/sql/index.html">SQL，内置函数</a></li>
                            </ul>
                        </li>

                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">部署中<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="cluster-overview.html">总览</a></li>
                                <li><a href="submitting-applications.html">提交申请</a></li>
                                <li class="divider"></li>
                                <li><a href="spark-standalone.html">Spark独立</a></li>
                                <li><a href="running-on-mesos.html">梅索斯</a></li>
                                <li><a href="running-on-yarn.html">纱</a></li>
                                <li><a href="running-on-kubernetes.html">Kubernetes</a></li>
                            </ul>
                        </li>

                        <li class="dropdown">
                            <a href="api.html" class="dropdown-toggle" data-toggle="dropdown">更多<b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="configuration.html">组态</a></li>
                                <li><a href="monitoring.html">监控方式</a></li>
                                <li><a href="tuning.html">调音指南</a></li>
                                <li><a href="job-scheduling.html">作业调度</a></li>
                                <li><a href="security.html">安全</a></li>
                                <li><a href="hardware-provisioning.html">硬件配置</a></li>
                                <li><a href="migration-guide.html">迁移指南</a></li>
                                <li class="divider"></li>
                                <li><a href="building-spark.html">建筑火花</a></li>
                                <li><a href="https://spark.apache.org/contributing.html">为Spark贡献</a></li>
                                <li><a href="https://spark.apache.org/third-party-projects.html">第三方项目</a></li>
                            </ul>
                        </li>
                    </ul>
                    <!--<p class="navbar-text pull-right"><span class="version-text">v3.0.0-preview</span></p>-->
                </div>
            </div>
        </div>

        <div class="container-wrapper">

            
                <div class="content" id="content">
                    
                        <h1 class="title">GraphX编程指南</h1>
                    

                    <ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">总览</a></li>
  <li><a href="#getting-started" id="markdown-toc-getting-started">入门</a></li>
  <li><a href="#the-property-graph" id="markdown-toc-the-property-graph">属性图</a>    <ul>
      <li><a href="#example-property-graph" id="markdown-toc-example-property-graph">属性图示例</a></li>
    </ul>
  </li>
  <li><a href="#graph-operators" id="markdown-toc-graph-operators">图运算符</a>    <ul>
      <li><a href="#summary-list-of-operators" id="markdown-toc-summary-list-of-operators">运营商摘要列表</a></li>
      <li><a href="#property-operators" id="markdown-toc-property-operators">物业经营者</a></li>
      <li><a href="#structural-operators" id="markdown-toc-structural-operators">结构算子</a></li>
      <li><a href="#join-operators" id="markdown-toc-join-operators">加盟运营商</a></li>
      <li><a href="#neighborhood-aggregation" id="markdown-toc-neighborhood-aggregation">邻里聚集</a>        <ul>
          <li><a href="#aggregate-messages-aggregatemessages" id="markdown-toc-aggregate-messages-aggregatemessages">汇总消息（aggregateMessages）</a></li>
          <li><a href="#map-reduce-triplets-transition-guide-legacy" id="markdown-toc-map-reduce-triplets-transition-guide-legacy">Map Reduce三元组转换指南（旧版）</a></li>
          <li><a href="#computing-degree-information" id="markdown-toc-computing-degree-information">计算学位信息</a></li>
          <li><a href="#collecting-neighbors" id="markdown-toc-collecting-neighbors">收集邻居</a></li>
        </ul>
      </li>
      <li><a href="#caching-and-uncaching" id="markdown-toc-caching-and-uncaching">缓存和取消缓存</a></li>
    </ul>
  </li>
  <li><a href="#pregel-api" id="markdown-toc-pregel-api">Pregel API</a></li>
  <li><a href="#graph-builders" id="markdown-toc-graph-builders">图构建器</a></li>
  <li><a href="#vertex-and-edge-rdds" id="markdown-toc-vertex-and-edge-rdds">顶点和边缘RDD</a>    <ul>
      <li><a href="#vertexrdds" id="markdown-toc-vertexrdds">顶点RDD</a></li>
      <li><a href="#edgerdds" id="markdown-toc-edgerdds">边缘RDD</a></li>
    </ul>
  </li>
  <li><a href="#optimized-representation" id="markdown-toc-optimized-representation">优化表示</a></li>
  <li><a href="#graph-algorithms" id="markdown-toc-graph-algorithms">图算法</a>    <ul>
      <li><a href="#pagerank" id="markdown-toc-pagerank">网页排名</a></li>
      <li><a href="#connected-components" id="markdown-toc-connected-components">连接的组件</a></li>
      <li><a href="#triangle-counting" id="markdown-toc-triangle-counting">三角计数</a></li>
    </ul>
  </li>
  <li><a href="#examples" id="markdown-toc-examples">例子</a></li>
</ul>

<!-- All the documentation links  -->

<p style="text-align:center">
  <img src="img/graphx_logo.png" title="GraphX徽标" alt="GraphX" width="60%">
  <!-- Images are downsized intentionally to improve quality on retina displays -->
</p>

<h1 id="overview">总览</h1>

<p>GraphX是Spark中用于图形和图形并行计算的新组件。在较高的层次上，GraphX通过引入新的<a href="#property_graph">Graph</a>抽象来扩展Spark <a href="api/scala/index.html#org.apache.spark.rdd.RDD">RDD</a> ：一个有向多图，其属性附加到每个顶点和边上。为了支持图计算，GraphX公开了一组基本的操作符（例如， <a href="#structural_operators">子图</a> ， <a href="#join_operators">joinVertices</a>和<a href="#aggregateMessages">aggregateMessages</a> ），以及所述的优化的变体<a href="#pregel">预凝胶</a> API。此外，GraphX包括越来越多的图形<a href="#graph_algorithms">算法</a>和<a href="#graph_builders">构建器</a>集合，以简化图形分析任务。</p>

<h1 id="getting-started">入门</h1>

<p>首先，首先需要将Spark和GraphX导入项目，如下所示：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">import</span> <span class="nn">org.apache.spark._</span>
<span class="k">import</span> <span class="nn">org.apache.spark.graphx._</span>
<span class="c1">// To make some of the examples work we will also need RDD</span>
<span class="k">import</span> <span class="nn">org.apache.spark.rdd.RDD</span></code></pre></figure>

<p>如果您不使用Spark Shell，则还需要一个<code>SparkContext</code> 。要了解有关Spark入门的更多信息，请参考《 <a href="quick-start.html">Spark快速入门指南》</a> 。</p>

<p><a name="property_graph"></a></p>

<h1 id="the-property-graph">属性图</h1>

<p><a href="api/scala/index.html#org.apache.spark.graphx.Graph">属性图</a>是有向多重图，用户定义的对象附加到每个顶点和边缘。有向多图是有向图，其中潜在的多个平行边共享相同的源和目标顶点。支持平行边的功能简化了在相同顶点之间可能存在多个关系（例如，同事和朋友）的建模场景。每个顶点均由<em>唯一的</em> 64位长标识符（ <code>VertexId</code> ）。GraphX对顶点标识符没有施加任何排序约束。同样，边具有相应的源和目标顶点标识符。</p>

<p>属性图在顶点上被参数化（ <code>VD</code> ）和边缘（ <code>ED</code> ）类型。这些是分别与每个顶点和边关联的对象的类型。</p>

<blockquote>
  <p>当顶点和边类型是原始数据类型（例如int，double等）时，GraphX可以优化它们的表示形式，方法是将它们存储在专用数组中，从而减少了内存占用量。</p>
</blockquote>

<p>在某些情况下，可能希望在同一图形中具有具有不同属性类型的顶点。这可以通过继承来实现。例如，要将用户和产品建模为二部图，我们可以执行以下操作：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">VertexProperty</span><span class="o">()</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserProperty</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">VertexProperty</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ProductProperty</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">price</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">VertexProperty</span>
<span class="c1">// The graph might then have the type:</span>
<span class="k">var</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VertexProperty</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="kc">null</span></code></pre></figure>

<p>与RDD一样，属性图是不可变的，分布式的和容错的。图的值或结构的更改是通过生成具有所需更改的新图来完成的。请注意，原始图的实质部分（即不受影响的结构，属性和索引）在新图中被重用，从而降低了这种固有功能数据结构的成本。使用一系列顶点分区试探法在执行程序之间划分图。与RDD一样，发生故障时，可以在不同的计算机上重新创建图形的每个分区。</p>

<p>逻辑上，属性图对应于一对类型化集合（RDD），它们对每个顶点和边的属性进行编码。结果，图类包含访问图的顶点和边的成员：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">vertices</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">edges</span><span class="k">:</span> <span class="kt">EdgeRDD</span><span class="o">[</span><span class="kt">ED</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>班级<code>VertexRDD[VD]</code>和<code>EdgeRDD[ED]</code>扩展和优化的版本<code>RDD[(VertexId, VD)]</code>和<code>RDD[Edge[ED]]</code>分别。都<code>VertexRDD[VD]</code>和<code>EdgeRDD[ED]</code>提供围绕图形计算构建的其他功能，并利用内部优化。我们讨论<code>VertexRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.VertexRDD">VertexRDD</a>和<code>EdgeRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.EdgeRDD">EdgeRDD</a> API在有关<a href="#vertex_and_edge_rdds">顶点和边缘RDD</a>的部分中有更详细的介绍，但目前可以将它们简单地认为是以下形式的RDD： <code>RDD[(VertexId, VD)]</code>和<code>RDD[Edge[ED]]</code> 。</p>

<h3 id="example-property-graph">属性图示例</h3>

<p>假设我们要构造一个由GraphX项目中的各个协作者组成的属性图。顶点属性可能包含用户名和职业。我们可以用描述协作者之间关系的字符串注释边缘：</p>

<p style="text-align:center">
  <img src="img/property_graph.png" title="属性图" alt="属性图" width="50%">
  <!-- Images are downsized intentionally to improve quality on retina displays -->
</p>

<p>结果图将具有类型签名：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">userGraph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)</span>, <span class="kt">String</span><span class="o">]</span></code></pre></figure>

<p>有多种方法可以从原始文件，RDD甚至是合成生成器构造属性图，有关这些<a href="#graph_builders">图的</a>详细信息，请参见图<a href="#graph_builders">构建器</a> 。可能最通用的方法是使用<a href="api/scala/index.html#org.apache.spark.graphx.Graph$">Graph对象</a> 。例如，以下代码从RDD的集合构造一个图形：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// Assume the SparkContext has already been constructed</span>
<span class="k">val</span> <span class="n">sc</span><span class="k">:</span> <span class="kt">SparkContext</span>
<span class="c1">// Create an RDD for the vertices</span>
<span class="k">val</span> <span class="n">users</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">))]</span> <span class="k">=</span>
  <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="o">(</span><span class="nc">Seq</span><span class="o">((</span><span class="mi">3L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;rxin&quot;</span><span class="o">,</span> <span class="s">&quot;student&quot;</span><span class="o">)),</span> <span class="o">(</span><span class="mi">7L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;jgonzal&quot;</span><span class="o">,</span> <span class="s">&quot;postdoc&quot;</span><span class="o">)),</span>
                       <span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;franklin&quot;</span><span class="o">,</span> <span class="s">&quot;prof&quot;</span><span class="o">)),</span> <span class="o">(</span><span class="mi">2L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;istoica&quot;</span><span class="o">,</span> <span class="s">&quot;prof&quot;</span><span class="o">))))</span>
<span class="c1">// Create an RDD for edges</span>
<span class="k">val</span> <span class="n">relationships</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="nc">Edge</span><span class="o">(</span><span class="mi">3L</span><span class="o">,</span> <span class="mi">7L</span><span class="o">,</span> <span class="s">&quot;collab&quot;</span><span class="o">),</span>    <span class="nc">Edge</span><span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="mi">3L</span><span class="o">,</span> <span class="s">&quot;advisor&quot;</span><span class="o">),</span>
                       <span class="nc">Edge</span><span class="o">(</span><span class="mi">2L</span><span class="o">,</span> <span class="mi">5L</span><span class="o">,</span> <span class="s">&quot;colleague&quot;</span><span class="o">),</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="mi">7L</span><span class="o">,</span> <span class="s">&quot;pi&quot;</span><span class="o">)))</span>
<span class="c1">// Define a default user in case there are relationship with missing user</span>
<span class="k">val</span> <span class="n">defaultUser</span> <span class="k">=</span> <span class="o">(</span><span class="s">&quot;John Doe&quot;</span><span class="o">,</span> <span class="s">&quot;Missing&quot;</span><span class="o">)</span>
<span class="c1">// Build the initial Graph</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">(</span><span class="n">users</span><span class="o">,</span> <span class="n">relationships</span><span class="o">,</span> <span class="n">defaultUser</span><span class="o">)</span></code></pre></figure>

<p>在上面的示例中，我们利用了<a href="api/scala/index.html#org.apache.spark.graphx.Edge"><code>Edge</code></a>案例类。边缘有一个<code>srcId</code>和一个<code>dstId</code>对应于源和目标顶点标识符。除此之外<code>Edge</code>班上有一个<code>attr</code>存储edge属性的成员。</p>

<p>我们可以使用来将图解构为相应的顶点和边视图<code>graph.vertices</code>和<code>graph.edges</code>成员。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)</span>, <span class="kt">String</span><span class="o">]</span> <span class="c1">// Constructed from above</span>
<span class="c1">// Count all users which are postdocs</span>
<span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">pos</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">pos</span> <span class="o">==</span> <span class="s">&quot;postdoc&quot;</span> <span class="o">}.</span><span class="n">count</span>
<span class="c1">// Count all the edges where src &gt; dst</span>
<span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">srcId</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">dstId</span><span class="o">).</span><span class="n">count</span></code></pre></figure>

<blockquote>
  <p>注意<code>graph.vertices</code>返回一个<code>VertexRDD[(String, String)]</code>延伸<code>RDD[(VertexId, (String, String))]</code>所以我们使用scala <code>case</code>解构元组的表达式。另一方面， <code>graph.edges</code>返回一个<code>EdgeRDD</code>包含<code>Edge[String]</code>对象。我们还可以使用case类类型构造函数，如下所示：</p>

</blockquote>
<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Edge</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">,</span> <span class="n">prop</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">src</span> <span class="o">&gt;</span> <span class="n">dst</span> <span class="o">}.</span><span class="n">count</span></code></pre></figure>

<p>除了属性图的顶点和边缘视图外，GraphX还公开了一个三元组视图。三元组视图在逻辑上连接顶点和边属性，从而产生一个<code>RDD[EdgeTriplet[VD, ED]]</code>包含的实例<a href="api/scala/index.html#org.apache.spark.graphx.EdgeTriplet"><code>EdgeTriplet</code></a>类。这种<em>连接</em>可以在下面的SQL表达式来表示：</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">SELECT</span> <span class="n">src</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">dst</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span> <span class="n">dst</span><span class="p">.</span><span class="n">attr</span>
<span class="k">FROM</span> <span class="n">edges</span> <span class="k">AS</span> <span class="n">e</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">vertices</span> <span class="k">AS</span> <span class="n">src</span><span class="p">,</span> <span class="n">vertices</span> <span class="k">AS</span> <span class="n">dst</span>
<span class="k">ON</span> <span class="n">e</span><span class="p">.</span><span class="n">srcId</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">Id</span> <span class="k">AND</span> <span class="n">e</span><span class="p">.</span><span class="n">dstId</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">Id</span></code></pre></figure>

<p>或图形化为：</p>

<p style="text-align:center">
  <img src="img/triplet.png" title="边缘三胞胎" alt="边缘三胞胎" width="50%">
  <!-- Images are downsized intentionally to improve quality on retina displays -->
</p>

<p>的<a href="api/scala/index.html#org.apache.spark.graphx.EdgeTriplet"><code>EdgeTriplet</code></a>类扩展了<a href="api/scala/index.html#org.apache.spark.graphx.Edge"><code>Edge</code></a>通过添加<code>srcAttr</code>和<code>dstAttr</code>成员分别包含源和目标属性。我们可以使用图形的三元组视图来呈现描述用户之间关系的字符串集合。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)</span>, <span class="kt">String</span><span class="o">]</span> <span class="c1">// Constructed from above</span>
<span class="c1">// Use the triplets view to create an RDD of facts.</span>
<span class="k">val</span> <span class="n">facts</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">graph</span><span class="o">.</span><span class="n">triplets</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">triplet</span> <span class="k">=&gt;</span>
    <span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="s">&quot; is the &quot;</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">attr</span> <span class="o">+</span> <span class="s">&quot; of &quot;</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">dstAttr</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
<span class="n">facts</span><span class="o">.</span><span class="n">collect</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="k">_</span><span class="o">))</span></code></pre></figure>

<h1 id="graph-operators">图运算符</h1>

<p>就像RDD具有基本操作一样<code>map</code> ， <code>filter</code>和<code>reduceByKey</code> ，属性图还具有一组基本运算符，这些基本运算符采用用户定义的函数并生成具有转换后的属性和结构的新图。具有优化实现的核心运营商在<a href="api/scala/index.html#org.apache.spark.graphx.Graph"><code>Graph</code></a>表示为核心运算符组成的便捷运算符在<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps"><code>GraphOps</code></a> 。但是，由于Scala隐式地将运算符<code>GraphOps</code>可以自动作为以下成员的成员<code>Graph</code> 。例如，我们可以计算每个顶点的度数（在<code>GraphOps</code> ），方法如下：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)</span>, <span class="kt">String</span><span class="o">]</span>
<span class="c1">// Use the implicit GraphOps.inDegrees operator</span>
<span class="k">val</span> <span class="n">inDegrees</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">inDegrees</span></code></pre></figure>

<p>区分核心图操作和<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps"><code>GraphOps</code></a>是为了将来能够支持不同的图形表示。每个图形表示形式都必须提供核心操作的实现，并重用定义在其中的许多有用操作<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps"><code>GraphOps</code></a> 。</p>

<h3 id="summary-list-of-operators">运营商摘要列表</h3>
<p>以下是两者中定义的功能的快速摘要<a href="api/scala/index.html#org.apache.spark.graphx.Graph"><code>Graph</code></a>和<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps"><code>GraphOps</code></a>但为简单起见，以Graph成员的形式呈现。请注意，某些函数签名已得到简化（例如，删除了默认参数和类型约束），并删除了一些更高级的功能，因此请查阅API文档以获取正式的操作列表。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="cm">/** Summary of the functionality in the property graph */</span>
<span class="k">class</span> <span class="nc">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// Information about the Graph ===================================================================</span>
  <span class="k">val</span> <span class="n">numEdges</span><span class="k">:</span> <span class="kt">Long</span>
  <span class="k">val</span> <span class="n">numVertices</span><span class="k">:</span> <span class="kt">Long</span>
  <span class="k">val</span> <span class="n">inDegrees</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">outDegrees</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">degrees</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="c1">// Views of the graph as collections =============================================================</span>
  <span class="k">val</span> <span class="n">vertices</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">edges</span><span class="k">:</span> <span class="kt">EdgeRDD</span><span class="o">[</span><span class="kt">ED</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">triplets</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]]</span>
  <span class="c1">// Functions for caching graphs ==================================================================</span>
  <span class="k">def</span> <span class="n">persist</span><span class="o">(</span><span class="n">newLevel</span><span class="k">:</span> <span class="kt">StorageLevel</span> <span class="o">=</span> <span class="nc">StorageLevel</span><span class="o">.</span><span class="nc">MEMORY_ONLY</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">cache</span><span class="o">()</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">unpersistVertices</span><span class="o">(</span><span class="n">blocking</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="c1">// Change the partitioning heuristic  ============================================================</span>
  <span class="k">def</span> <span class="n">partitionBy</span><span class="o">(</span><span class="n">partitionStrategy</span><span class="k">:</span> <span class="kt">PartitionStrategy</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="c1">// Transform vertex and edge attributes ==========================================================</span>
  <span class="k">def</span> <span class="n">mapVertices</span><span class="o">[</span><span class="kt">VD2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapEdges</span><span class="o">[</span><span class="kt">ED2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="kt">Edge</span><span class="o">[</span><span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">ED2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED2</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapEdges</span><span class="o">[</span><span class="kt">ED2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="o">(</span><span class="kt">PartitionID</span><span class="o">,</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">ED</span><span class="o">]])</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">ED2</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED2</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapTriplets</span><span class="o">[</span><span class="kt">ED2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">ED2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED2</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapTriplets</span><span class="o">[</span><span class="kt">ED2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="o">(</span><span class="kt">PartitionID</span><span class="o">,</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]])</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">ED2</span><span class="o">])</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED2</span><span class="o">]</span>
  <span class="c1">// Modify the graph structure ====================================================================</span>
  <span class="k">def</span> <span class="n">reverse</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">subgraph</span><span class="o">(</span>
      <span class="n">epred</span><span class="k">:</span> <span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>,<span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">),</span>
      <span class="n">vpred</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">((</span><span class="n">v</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">))</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mask</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED2</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED2</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">groupEdges</span><span class="o">(</span><span class="n">merge</span><span class="k">:</span> <span class="o">(</span><span class="kt">ED</span><span class="o">,</span> <span class="kt">ED</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ED</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="c1">// Join RDDs with the graph ======================================================================</span>
  <span class="k">def</span> <span class="n">joinVertices</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">table</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">U</span><span class="o">)])(</span><span class="n">mapFunc</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">outerJoinVertices</span><span class="o">[</span><span class="kt">U</span>, <span class="kt">VD2</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">U</span><span class="o">)])</span>
      <span class="o">(</span><span class="n">mapFunc</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="c1">// Aggregate information about adjacent triplets =================================================</span>
  <span class="k">def</span> <span class="n">collectNeighborIds</span><span class="o">(</span><span class="n">edgeDirection</span><span class="k">:</span> <span class="kt">EdgeDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">VertexId</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">collectNeighbors</span><span class="o">(</span><span class="n">edgeDirection</span><span class="k">:</span> <span class="kt">EdgeDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Array</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VD</span><span class="o">)]]</span>
  <span class="k">def</span> <span class="n">aggregateMessages</span><span class="o">[</span><span class="kt">Msg:</span> <span class="kt">ClassTag</span><span class="o">](</span>
      <span class="n">sendMsg</span><span class="k">:</span> <span class="kt">EdgeContext</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span>, <span class="kt">Msg</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">,</span>
      <span class="n">mergeMsg</span><span class="k">:</span> <span class="o">(</span><span class="kt">Msg</span><span class="o">,</span> <span class="kt">Msg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Msg</span><span class="o">,</span>
      <span class="n">tripletFields</span><span class="k">:</span> <span class="kt">TripletFields</span> <span class="o">=</span> <span class="nc">TripletFields</span><span class="o">.</span><span class="nc">All</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="c1">// Iterative graph-parallel computation ==========================================================</span>
  <span class="k">def</span> <span class="n">pregel</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">initialMsg</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">maxIterations</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">activeDirection</span><span class="k">:</span> <span class="kt">EdgeDirection</span><span class="o">)(</span>
      <span class="n">vprog</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD</span><span class="o">,</span>
      <span class="n">sendMsg</span><span class="k">:</span> <span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">A</span><span class="o">)],</span>
      <span class="n">mergeMsg</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="c1">// Basic graph algorithms ========================================================================</span>
  <span class="k">def</span> <span class="n">pageRank</span><span class="o">(</span><span class="n">tol</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">resetProb</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.15</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">connectedComponents</span><span class="o">()</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VertexId</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">triangleCount</span><span class="o">()</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">stronglyConnectedComponents</span><span class="o">(</span><span class="n">numIter</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VertexId</span>, <span class="kt">ED</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<h2 id="property-operators">物业经营者</h2>

<p>像RDD <code>map</code>运算符，属性图包含以下内容：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapVertices</span><span class="o">[</span><span class="kt">VD2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapEdges</span><span class="o">[</span><span class="kt">ED2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="kt">Edge</span><span class="o">[</span><span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">ED2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED2</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapTriplets</span><span class="o">[</span><span class="kt">ED2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">ED2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED2</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>这些运算符中的每一个都会产生一个新图，其顶点或边的属性由用户定义<code>map</code>功能。</p>

<blockquote>
  <p>请注意，在每种情况下，图形结构均不受影响。这是这些运算符的关键功能，它允许生成的图重用原始图的结构索引。以下代码段在逻辑上是等效的，但第一个代码段不会保留结构索引，也不会从GraphX系统优化中受益：</p>

</blockquote>
<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">newVertices</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">attr</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">mapUdf</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">attr</span><span class="o">))</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">newGraph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">(</span><span class="n">newVertices</span><span class="o">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="o">)</span></code></pre></figure>

<blockquote>
  <p>相反，使用<a href="api/scala/index.html#org.apache.spark.graphx.Graph@mapVertices[VD2]((VertexId,VD)%E2%87%92VD2)(ClassTag[VD2]):Graph[VD2,ED]"><code>mapVertices</code></a>保存索引：</p>

</blockquote>
<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">newGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">mapVertices</span><span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="n">attr</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">mapUdf</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">attr</span><span class="o">))</span></code></pre></figure>

<p>这些运算符通常用于初始化图形以进行特定计算或投影出不必要的属性。例如，给定一个以out度作为顶点属性的图（我们稍后将描述如何构造这种图），我们将其初始化为PageRank：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// Given a graph where the vertex property is the out degree</span>
<span class="k">val</span> <span class="n">inputGraph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">graph</span><span class="o">.</span><span class="n">outerJoinVertices</span><span class="o">(</span><span class="n">graph</span><span class="o">.</span><span class="n">outDegrees</span><span class="o">)((</span><span class="n">vid</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">degOpt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">degOpt</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
<span class="c1">// Construct a graph where each edge contains the weight</span>
<span class="c1">// and each vertex is the initial PageRank</span>
<span class="k">val</span> <span class="n">outputGraph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Double</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">inputGraph</span><span class="o">.</span><span class="n">mapTriplets</span><span class="o">(</span><span class="n">triplet</span> <span class="k">=&gt;</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span><span class="o">).</span><span class="n">mapVertices</span><span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mf">1.0</span><span class="o">)</span></code></pre></figure>

<p><a name="structural_operators"></a></p>

<h2 id="structural-operators">结构算子</h2>

<p>当前，GraphX仅支持一组简单的常用结构运算符，我们希望将来会增加更多。以下是基本结构运算符的列表。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">reverse</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">subgraph</span><span class="o">(</span><span class="n">epred</span><span class="k">:</span> <span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>,<span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">,</span>
               <span class="n">vpred</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mask</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED2</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED2</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">groupEdges</span><span class="o">(</span><span class="n">merge</span><span class="k">:</span> <span class="o">(</span><span class="kt">ED</span><span class="o">,</span> <span class="kt">ED</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ED</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>,<span class="kt">ED</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>的<a href="api/scala/index.html#org.apache.spark.graphx.Graph@reverse:Graph[VD,ED]"><code>reverse</code></a>运算符返回一个新的图形，其中所有边缘方向都反转。例如，在尝试计算逆PageRank时，这将很有用。由于反向操作不会修改顶点或边的属性或更改边的数量，因此可以有效地实现它，而无需移动或复制数据。</p>

<p>的<a href="api/scala/index.html#org.apache.spark.graphx.Graph@subgraph((EdgeTriplet[VD,ED])%E2%87%92Boolean,(VertexId,VD)%E2%87%92Boolean):Graph[VD,ED]"><code>subgraph</code></a>运算符采用顶点和边谓词，并返回仅包含满足顶点谓词的顶点（求值为true）和满足边谓词的边的<em>图，并连接满足顶点谓词的顶点</em> 。的<code>subgraph</code>可以在多种情况下使用运算符将图形限制在感兴趣的顶点和边缘或消除断开的链接。例如，在以下代码中，我们删除了断开的链接：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// Create an RDD for the vertices</span>
<span class="k">val</span> <span class="n">users</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">))]</span> <span class="k">=</span>
  <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="o">(</span><span class="nc">Seq</span><span class="o">((</span><span class="mi">3L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;rxin&quot;</span><span class="o">,</span> <span class="s">&quot;student&quot;</span><span class="o">)),</span> <span class="o">(</span><span class="mi">7L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;jgonzal&quot;</span><span class="o">,</span> <span class="s">&quot;postdoc&quot;</span><span class="o">)),</span>
                       <span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;franklin&quot;</span><span class="o">,</span> <span class="s">&quot;prof&quot;</span><span class="o">)),</span> <span class="o">(</span><span class="mi">2L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;istoica&quot;</span><span class="o">,</span> <span class="s">&quot;prof&quot;</span><span class="o">)),</span>
                       <span class="o">(</span><span class="mi">4L</span><span class="o">,</span> <span class="o">(</span><span class="s">&quot;peter&quot;</span><span class="o">,</span> <span class="s">&quot;student&quot;</span><span class="o">))))</span>
<span class="c1">// Create an RDD for edges</span>
<span class="k">val</span> <span class="n">relationships</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="nc">Edge</span><span class="o">(</span><span class="mi">3L</span><span class="o">,</span> <span class="mi">7L</span><span class="o">,</span> <span class="s">&quot;collab&quot;</span><span class="o">),</span>    <span class="nc">Edge</span><span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="mi">3L</span><span class="o">,</span> <span class="s">&quot;advisor&quot;</span><span class="o">),</span>
                       <span class="nc">Edge</span><span class="o">(</span><span class="mi">2L</span><span class="o">,</span> <span class="mi">5L</span><span class="o">,</span> <span class="s">&quot;colleague&quot;</span><span class="o">),</span> <span class="nc">Edge</span><span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="mi">7L</span><span class="o">,</span> <span class="s">&quot;pi&quot;</span><span class="o">),</span>
                       <span class="nc">Edge</span><span class="o">(</span><span class="mi">4L</span><span class="o">,</span> <span class="mi">0L</span><span class="o">,</span> <span class="s">&quot;student&quot;</span><span class="o">),</span>   <span class="nc">Edge</span><span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="mi">0L</span><span class="o">,</span> <span class="s">&quot;colleague&quot;</span><span class="o">)))</span>
<span class="c1">// Define a default user in case there are relationship with missing user</span>
<span class="k">val</span> <span class="n">defaultUser</span> <span class="k">=</span> <span class="o">(</span><span class="s">&quot;John Doe&quot;</span><span class="o">,</span> <span class="s">&quot;Missing&quot;</span><span class="o">)</span>
<span class="c1">// Build the initial Graph</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">Graph</span><span class="o">(</span><span class="n">users</span><span class="o">,</span> <span class="n">relationships</span><span class="o">,</span> <span class="n">defaultUser</span><span class="o">)</span>
<span class="c1">// Notice that there is a user 0 (for which we have no information) connected to users</span>
<span class="c1">// 4 (peter) and 5 (franklin).</span>
<span class="n">graph</span><span class="o">.</span><span class="n">triplets</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
  <span class="n">triplet</span> <span class="k">=&gt;</span> <span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="s">&quot; is the &quot;</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">attr</span> <span class="o">+</span> <span class="s">&quot; of &quot;</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">dstAttr</span><span class="o">.</span><span class="n">_1</span>
<span class="o">).</span><span class="n">collect</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
<span class="c1">// Remove missing vertices as well as the edges to connected to them</span>
<span class="k">val</span> <span class="n">validGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="o">(</span><span class="n">vpred</span> <span class="k">=</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">attr</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">attr</span><span class="o">.</span><span class="n">_2</span> <span class="o">!=</span> <span class="s">&quot;Missing&quot;</span><span class="o">)</span>
<span class="c1">// The valid subgraph will disconnect users 4 and 5 by removing user 0</span>
<span class="n">validGraph</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">collect</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
<span class="n">validGraph</span><span class="o">.</span><span class="n">triplets</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
  <span class="n">triplet</span> <span class="k">=&gt;</span> <span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="s">&quot; is the &quot;</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">attr</span> <span class="o">+</span> <span class="s">&quot; of &quot;</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">dstAttr</span><span class="o">.</span><span class="n">_1</span>
<span class="o">).</span><span class="n">collect</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="k">_</span><span class="o">))</span></code></pre></figure>

<blockquote>
  <p>注意，在以上示例中，仅提供了顶点谓词。的<code>subgraph</code>运算符默认为<code>true</code>如果未提供顶点或边谓词。</p>
</blockquote>

<p>的<a href="api/scala/index.html#org.apache.spark.graphx.Graph@mask[VD2,ED2](Graph[VD2,ED2])(ClassTag[VD2],ClassTag[ED2]):Graph[VD,ED]"><code>mask</code></a>运算符通过返回包含在输入图中也可以找到的顶点和边的图来构造子图。可以与<code>subgraph</code>操作符基于另一个相关图的属性来限制图。例如，我们可能使用缺少顶点的图来运行连接的组件，然后将答案限制为有效的子图。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// Run Connected Components</span>
<span class="k">val</span> <span class="n">ccGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">connectedComponents</span><span class="o">()</span> <span class="c1">// No longer contains missing field</span>
<span class="c1">// Remove missing vertices as well as the edges to connected to them</span>
<span class="k">val</span> <span class="n">validGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="o">(</span><span class="n">vpred</span> <span class="k">=</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">attr</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">attr</span><span class="o">.</span><span class="n">_2</span> <span class="o">!=</span> <span class="s">&quot;Missing&quot;</span><span class="o">)</span>
<span class="c1">// Restrict the answer to the valid subgraph</span>
<span class="k">val</span> <span class="n">validCCGraph</span> <span class="k">=</span> <span class="n">ccGraph</span><span class="o">.</span><span class="n">mask</span><span class="o">(</span><span class="n">validGraph</span><span class="o">)</span></code></pre></figure>

<p>的<a href="api/scala/index.html#org.apache.spark.graphx.Graph@groupEdges((ED,ED)%E2%87%92ED):Graph[VD,ED]"><code>groupEdges</code></a>运算符合并多图中的平行边（即，成对的顶点之间的重复边）。在许多数字应用程序中，可以将平行边<em>添加</em> （合并它们的权重）到单个边中，从而减小图形的大小。</p>

<p><a name="join_operators"></a></p>

<h2 id="join-operators">加盟运营商</h2>

<p>在许多情况下，有必要将外部集合（RDD）中的数据与图形连接起来。例如，我们可能有想要与现有图合并的额外用户属性，或者可能希望将顶点属性从一个图拉到另一个图。这些任务可以使用<em>联接</em>运算符来完成。下面我们列出了关键的联接运算符：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">joinVertices</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">table</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">U</span><span class="o">)])(</span><span class="n">map</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">outerJoinVertices</span><span class="o">[</span><span class="kt">U</span>, <span class="kt">VD2</span><span class="o">](</span><span class="n">table</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">U</span><span class="o">)])(</span><span class="n">map</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">ED</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>的<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps@joinVertices[U](RDD[(VertexId,U)])((VertexId,VD,U)%E2%87%92VD)(ClassTag[U]):Graph[VD,ED]"><code>joinVertices</code></a>运算符将顶点与输入的RDD连接起来，并返回一个具有通过应用用户定义而获得的顶点属性的新图<code>map</code>函数作用于连接顶点的结果。RDD中没有匹配值的顶点保留其原始值。</p>

<blockquote>
  <p>请注意，如果RDD对于给定的顶点包含多个值，则只会使用一个。因此，建议使用以下命令使输入RDD唯一，这也将对结果值进行<em>预索引</em> ，以显着加快后续连接的速度。</p>

</blockquote>
<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">nonUniqueCosts</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">Double</span><span class="o">)]</span>
<span class="k">val</span> <span class="n">uniqueCosts</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">graph</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">aggregateUsingIndex</span><span class="o">(</span><span class="n">nonUnique</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
<span class="k">val</span> <span class="n">joinedGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">joinVertices</span><span class="o">(</span><span class="n">uniqueCosts</span><span class="o">)(</span>
  <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">oldCost</span><span class="o">,</span> <span class="n">extraCost</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">oldCost</span> <span class="o">+</span> <span class="n">extraCost</span><span class="o">)</span></code></pre></figure>

<p>更一般<a href="api/scala/index.html#org.apache.spark.graphx.Graph@outerJoinVertices[U,VD2](RDD[(VertexId,U)])((VertexId,VD,Option[U])%E2%87%92VD2)(ClassTag[U],ClassTag[VD2]):Graph[VD2,ED]"><code>outerJoinVertices</code></a>行为类似于<code>joinVertices</code>除了用户定义<code>map</code>函数将应用于所有顶点，并且可以更改顶点属性类型。由于并非所有顶点在输入RDD中都可能具有匹配值，因此<code>map</code>功能需要<code>Option</code>类型。例如，我们可以通过初始化顶点属性及其顶点属性来为PageRank设置图形<code>outDegree</code> 。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">outDegrees</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">outDegrees</span>
<span class="k">val</span> <span class="n">degreeGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">outerJoinVertices</span><span class="o">(</span><span class="n">outDegrees</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">oldAttr</span><span class="o">,</span> <span class="n">outDegOpt</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">outDegOpt</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">outDeg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">outDeg</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="c1">// No outDegree means zero outDegree</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<blockquote>
  <p>您可能已经注意到多个参数列表（例如， <code>f(a)(b)</code> ）在以上示例中使用的咖喱函数模式。虽然我们可以同样地写<code>f(a)(b)</code>如<code>f(a,b)</code>这意味着类型推断<code>b</code>不会依赖<code>a</code> 。结果，用户将需要为用户定义的函数提供类型注释：</p>

</blockquote>
<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">joinedGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">joinVertices</span><span class="o">(</span><span class="n">uniqueCosts</span><span class="o">,</span>
  <span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">VertexId</span><span class="o">,</span> <span class="n">oldCost</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">extraCost</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">oldCost</span> <span class="o">+</span> <span class="n">extraCost</span><span class="o">)</span></code></pre></figure>

<blockquote>

</blockquote>

<p><a name="neighborhood-aggregation"></a></p>

<h2 id="neighborhood-aggregation">邻里聚集</h2>

<p>许多图形分析任务中的关键步骤是汇总有关每个顶点邻域的信息。例如，我们可能想知道每个用户拥有的关注者数量或每个用户的关注者平均年龄。许多迭代图算法（例如，PageRank，最短路径和连接的组件）反复聚合相邻顶点的属性（例如，当前的PageRank值，到源的最短路径以及最小的可到达顶点ID）。</p>

<blockquote>
  <p>为了提高性能，主要聚合运算符从<code>graph.mapReduceTriplets</code>到新<code>graph.AggregateMessages</code> 。尽管API的更改相对较小，但我们在下面提供了过渡指南。</p>
</blockquote>

<p><a name="aggregateMessages"></a></p>

<h3 id="aggregate-messages-aggregatemessages">汇总消息（aggregateMessages）</h3>

<p>GraphX中的核心聚合操作是<a href="api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages[A]((EdgeContext[VD,ED,A])%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag[A]):VertexRDD[A]"><code>aggregateMessages</code></a> 。此运算符应用用户定义<code>sendMsg</code>函数对图形中的每个<i>边缘三元组</i>起作用，然后使用<code>mergeMsg</code>函数将这些消息聚合到它们的目标顶点。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">aggregateMessages</span><span class="o">[</span><span class="kt">Msg:</span> <span class="kt">ClassTag</span><span class="o">](</span>
      <span class="n">sendMsg</span><span class="k">:</span> <span class="kt">EdgeContext</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span>, <span class="kt">Msg</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">,</span>
      <span class="n">mergeMsg</span><span class="k">:</span> <span class="o">(</span><span class="kt">Msg</span><span class="o">,</span> <span class="kt">Msg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Msg</span><span class="o">,</span>
      <span class="n">tripletFields</span><span class="k">:</span> <span class="kt">TripletFields</span> <span class="o">=</span> <span class="nc">TripletFields</span><span class="o">.</span><span class="nc">All</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Msg</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>用户定义<code>sendMsg</code>功能需要<a href="api/scala/index.html#org.apache.spark.graphx.EdgeContext"><code>EdgeContext</code></a> ，它公开源和目标属性以及边缘属性和功能（ <a href="api/scala/index.html#org.apache.spark.graphx.EdgeContext@sendToSrc(msg:A):Unit"><code>sendToSrc</code></a>和<a href="api/scala/index.html#org.apache.spark.graphx.EdgeContext@sendToDst(msg:A):Unit"><code>sendToDst</code></a> ）发送消息到源和目标属性。考虑到<code>sendMsg</code>作为map-reduce中的<i>map</i>函数。用户定义<code>mergeMsg</code>函数接受两条发往同一顶点的消息，并产生一条消息。考虑到<code>mergeMsg</code>作为map-reduce中的<i>reduce</i>函数。的<a href="api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages[A]((EdgeContext[VD,ED,A])%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag[A]):VertexRDD[A]"><code>aggregateMessages</code></a>运算符返回一个<code>VertexRDD[Msg]</code>包含汇总消息（类型<code>Msg</code> ）注定要到达每个顶点。未收到消息的顶点不包括在返回的消息中<code>VertexRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.VertexRDD">顶点RDD</a> 。</p>

<!--
> An [`EdgeContext`][EdgeContext] is provided in place of a [`EdgeTriplet`][EdgeTriplet] to
expose the additional ([`sendToSrc`][EdgeContext.sendToSrc],
and [`sendToDst`][EdgeContext.sendToDst]) which GraphX uses to optimize message routing.
 -->

<p>此外， <a href="api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages[A]((EdgeContext[VD,ED,A])%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag[A]):VertexRDD[A]"><code>aggregateMessages</code></a>需要一个可选的<code>tripletsFields</code>指示在<a href="api/scala/index.html#org.apache.spark.graphx.EdgeContext"><code>EdgeContext</code></a> （即，源顶点属性，而不是目标顶点属性）。的可能选项<code>tripletsFields</code>在中定义<a href="api/java/org/apache/spark/graphx/TripletFields.html"><code>TripletFields</code></a>且默认值为<a href="api/java/org/apache/spark/graphx/TripletFields.html#All"><code>TripletFields.All</code></a>表示用户定义了<code>sendMsg</code>函数可以访问<a href="api/scala/index.html#org.apache.spark.graphx.EdgeContext"><code>EdgeContext</code></a> 。的<code>tripletFields</code>参数可用于通知GraphX只有一部分<a href="api/scala/index.html#org.apache.spark.graphx.EdgeContext"><code>EdgeContext</code></a>将需要允许GraphX选择优化的联接策略。例如，如果我们正在计算每个用户的关注者的平均年龄，则仅需要来源字段，因此我们将使用<a href="api/java/org/apache/spark/graphx/TripletFields.html#Src"><code>TripletFields.Src</code></a>表示我们只需要来源字段</p>

<blockquote>
  <p>在GraphX的早期版本中，我们使用字节码检查来推断<a href="api/java/org/apache/spark/graphx/TripletFields.html"><code>TripletFields</code></a>但是，我们发现字节码检查有些不可靠，而是选择了更明确的用户控制。</p>
</blockquote>

<p>在以下示例中，我们使用<a href="api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages[A]((EdgeContext[VD,ED,A])%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag[A]):VertexRDD[A]"><code>aggregateMessages</code></a>运算符，以计算每个用户的高级追随者的平均年龄。</p>

<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.graphx.</span><span class="o">{</span><span class="nc">Graph</span><span class="o">,</span> <span class="nc">VertexRDD</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">org.apache.spark.graphx.util.GraphGenerators</span>

<span class="c1">// Create a graph with &quot;age&quot; as the vertex property.</span>
<span class="c1">// Here we use a random graph for simplicity.</span>
<span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Double</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">GraphGenerators</span><span class="o">.</span><span class="n">logNormalGraph</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="n">numVertices</span> <span class="k">=</span> <span class="mi">100</span><span class="o">).</span><span class="n">mapVertices</span><span class="o">(</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">id</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">)</span>
<span class="c1">// Compute the number of older followers and their total age</span>
<span class="k">val</span> <span class="n">olderFollowers</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">aggregateMessages</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">)](</span>
  <span class="n">triplet</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="c1">// Map Function</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span> <span class="o">&gt;</span> <span class="n">triplet</span><span class="o">.</span><span class="n">dstAttr</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Send message to destination vertex containing counter and age</span>
      <span class="n">triplet</span><span class="o">.</span><span class="n">sendToDst</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">},</span>
  <span class="c1">// Add counter and age</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="c1">// Reduce Function</span>
<span class="o">)</span>
<span class="c1">// Divide total age by number of older followers to get average age of older followers</span>
<span class="k">val</span> <span class="n">avgAgeOfOlderFollowers</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">olderFollowers</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">value</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">totalAge</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">totalAge</span> <span class="o">/</span> <span class="n">count</span> <span class="o">}</span> <span class="o">)</span>
<span class="c1">// Display the results</span>
<span class="n">avgAgeOfOlderFollowers</span><span class="o">.</span><span class="n">collect</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</pre></div>
<div><small>在Spark存储库中的“ examples / src / main / scala / org / apache / spark / examples / graphx / AggregateMessagesExample.scala”中找到完整的示例代码。</small></div>

<blockquote>
  <p>的<code>aggregateMessages</code>当消息（和消息的总和）大小固定（例如，浮点数和加法而不是列表和串联）时，操作将最佳执行。</p>
</blockquote>

<p><a name="mrTripletsTransition"></a></p>

<h3 id="map-reduce-triplets-transition-guide-legacy">Map Reduce三元组转换指南（旧版）</h3>

<p>在GraphX的早期版本中，邻域聚合是使用<code>mapReduceTriplets</code>操作员：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapReduceTriplets</span><span class="o">[</span><span class="kt">Msg</span><span class="o">](</span>
      <span class="n">map</span><span class="k">:</span> <span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">Msg</span><span class="o">)],</span>
      <span class="n">reduce</span><span class="k">:</span> <span class="o">(</span><span class="kt">Msg</span><span class="o">,</span> <span class="kt">Msg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Msg</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Msg</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>的<code>mapReduceTriplets</code>运算符采用了一个用户定义的映射函数，该函数应用于每个三元组，并且可以产生使用该用户定义的汇总<em>消息</em> <code>reduce</code>功能。但是，我们发现返回的迭代器的用户很昂贵，并且它抑制了我们应用其他优化（例如，局部顶点重新编号）的能力。在<a href="api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages[A]((EdgeContext[VD,ED,A])%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag[A]):VertexRDD[A]"><code>aggregateMessages</code></a>我们引入了EdgeContext，它公开了三元组字段，并且还具有将消息显式发送到源和目标顶点的功能。此外，我们删除了字节码检查，而是要求用户指出三元组中实际需要的字段。</p>

<p>下面的代码块使用<code>mapReduceTriplets</code> ：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">def</span> <span class="n">msgFun</span><span class="o">(</span><span class="n">triplet</span><span class="k">:</span> <span class="kt">Triplet</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Float</span><span class="o">])</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Iterator</span><span class="o">((</span><span class="n">triplet</span><span class="o">.</span><span class="n">dstId</span><span class="o">,</span> <span class="s">&quot;Hi&quot;</span><span class="o">))</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">reduceFun</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">mapReduceTriplets</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="n">msgFun</span><span class="o">,</span> <span class="n">reduceFun</span><span class="o">)</span></code></pre></figure>

<p>可以使用重写<code>aggregateMessages</code>如：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">def</span> <span class="n">msgFun</span><span class="o">(</span><span class="n">triplet</span><span class="k">:</span> <span class="kt">EdgeContext</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Float</span>, <span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="n">triplet</span><span class="o">.</span><span class="n">sendToDst</span><span class="o">(</span><span class="s">&quot;Hi&quot;</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">reduceFun</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">b</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">aggregateMessages</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="n">msgFun</span><span class="o">,</span> <span class="n">reduceFun</span><span class="o">)</span></code></pre></figure>

<h3 id="computing-degree-information">计算学位信息</h3>

<p>常见的聚合任务是计算每个顶点的度：每个顶点相邻的边数。在有向图的上下文中，通常必须知道每个顶点的入度，出度和总度。的<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps"><code>GraphOps</code></a>类包含一组运算符，用于计算每个顶点的度。例如，在下面的示例中，我们计算最大进，出和总度数：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// Define a reduce operation to compute the highest degree vertex</span>
<span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">b</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_2</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
<span class="o">}</span>
<span class="c1">// Compute the max degrees</span>
<span class="k">val</span> <span class="n">maxInDegree</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span>  <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">inDegrees</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">max</span><span class="o">)</span>
<span class="k">val</span> <span class="n">maxOutDegree</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">outDegrees</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">max</span><span class="o">)</span>
<span class="k">val</span> <span class="n">maxDegrees</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span>   <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">degrees</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">max</span><span class="o">)</span></code></pre></figure>

<h3 id="collecting-neighbors">收集邻居</h3>

<p>在某些情况下，通过收集每个顶点处的相邻顶点及其属性来表达计算可能会更容易。使用以下命令可以轻松完成此操作<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps@collectNeighborIds(EdgeDirection):VertexRDD[Array[VertexId]]"><code>collectNeighborIds</code></a>和<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps@collectNeighbors(EdgeDirection):VertexRDD[Array[(VertexId,VD)]]"><code>collectNeighbors</code></a>操作员。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">GraphOps</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">collectNeighborIds</span><span class="o">(</span><span class="n">edgeDirection</span><span class="k">:</span> <span class="kt">EdgeDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">VertexId</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">collectNeighbors</span><span class="o">(</span><span class="n">edgeDirection</span><span class="k">:</span> <span class="kt">EdgeDirection</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span> <span class="kt">Array</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VD</span><span class="o">)]</span> <span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<blockquote>
  <p>这些运营商可能会非常昂贵，因为他们复制信息并需要大量沟通。如果可能，请尝试使用<a href="api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages[A]((EdgeContext[VD,ED,A])%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag[A]):VertexRDD[A]"><code>aggregateMessages</code></a>直接操作。</p>
</blockquote>

<h2 id="caching-and-uncaching">缓存和取消缓存</h2>

<p>在Spark中，默认情况下RDD不保留在内存中。为了避免重新计算，在多次使用它们时必须将它们显式缓存（请参见《 <a href="rdd-programming-guide.html#rdd-persistence">Spark编程指南》</a> ）。GraphX中的图形行为相同。<strong>多次使用图形时，请确保调用<a href="api/scala/index.html#org.apache.spark.graphx.Graph@cache():Graph[VD,ED]"><code>Graph.cache()</code></a>首先。</strong></p>

<p>在迭代计算中，为了获得最佳性能，也可能需要<em>取消缓存</em> 。默认情况下，缓存的RDD和图形将保留在内存中，直到内存压力迫使它们按LRU顺序逐出为止。对于迭代计算，先前迭代的中间结果将填满缓存。尽管它们最终将被驱逐，但存储在内存中的不必要数据将减慢垃圾回收速度。一旦不再需要中间结果，取消缓存中间结果将更加有效。这涉及在每次迭代中实现（缓存和强制执行）图或RDD，取消缓存所有其他数据集以及仅在以后的迭代中使用实现的数据集。但是，由于图是由多个RDD组成的，因此很难正确地取消持久化它们。<strong>对于迭代计算，我们建议使用Pregel API，它可以正确地保留中间结果。</strong></p>

<p><a name="pregel"></a></p>

<h1 id="pregel-api">Pregel API</h1>

<p>图是固有的递归数据结构，因为顶点的属性取决于其邻居的属性，而顶点的属性又取决于<em>其</em>邻居的属性。结果，许多重要的图形算法会迭代地重新计算每个顶点的属性，直到达到定点条件为止。已经提出了一系列图并行抽象来表达这些迭代算法。GraphX公开了Pregel API的变体。</p>

<p>在较高层次上，GraphX中的Pregel运算符是<em>受图拓扑约束</em>的批量同步并行消息传递抽象。Pregel运算符在一系列超级步骤中执行，在这些步骤中，顶点从上一个超级步骤接收入站消息的<em>总和</em> ，计算顶点属性的新值，然后在下一个超级步骤中将消息发送到相邻的顶点。与Pregel不同，消息是根据边缘三元组并行计算的，并且消息计算可以访问源顶点和目标顶点属性。在超级步骤中会跳过未收到消息的顶点。当没有消息剩余时，Pregel运算符终止迭代并返回最终图形。</p>

<blockquote>
  <p>注意，与更标准的Pregel实现不同，GraphX中的顶点只能将消息发送到相邻的顶点，并且使用用户定义的消息传递功能并行完成消息的构造。这些限制允许在GraphX中进行其他优化。</p>
</blockquote>

<p>以下是<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps@pregel[A](A,Int,EdgeDirection)((VertexId,VD,A)%E2%87%92VD,(EdgeTriplet[VD,ED])%E2%87%92Iterator[(VertexId,A)],(A,A)%E2%87%92A)(ClassTag[A]):Graph[VD,ED]">Pregel运算符</a>的类型签名及其实现的<em>草图</em> （注意：为避免由于长的血统链而引起的stackOverflowError，pregel通过将“ spark.graphx.pregel.checkpointInterval”设置为a来定期支持检查点图和消息）。正数，例如10。并使用SparkContext.setCheckpointDir（directory：String））设置检查点目录：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">GraphOps</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">pregel</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
      <span class="o">(</span><span class="n">initialMsg</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span>
       <span class="n">maxIter</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nc">Int</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">,</span>
       <span class="n">activeDir</span><span class="k">:</span> <span class="kt">EdgeDirection</span> <span class="o">=</span> <span class="nc">EdgeDirection</span><span class="o">.</span><span class="nc">Out</span><span class="o">)</span>
      <span class="o">(</span><span class="n">vprog</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD</span><span class="o">,</span>
       <span class="n">sendMsg</span><span class="k">:</span> <span class="kt">EdgeTriplet</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">A</span><span class="o">)],</span>
       <span class="n">mergeMsg</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">// Receive the initial message at each vertex</span>
    <span class="k">var</span> <span class="n">g</span> <span class="k">=</span> <span class="n">mapVertices</span><span class="o">(</span> <span class="o">(</span><span class="n">vid</span><span class="o">,</span> <span class="n">vdata</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">vprog</span><span class="o">(</span><span class="n">vid</span><span class="o">,</span> <span class="n">vdata</span><span class="o">,</span> <span class="n">initialMsg</span><span class="o">)</span> <span class="o">).</span><span class="n">cache</span><span class="o">()</span>

    <span class="c1">// compute the messages</span>
    <span class="k">var</span> <span class="n">messages</span> <span class="k">=</span> <span class="nc">GraphXUtils</span><span class="o">.</span><span class="n">mapReduceTriplets</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">sendMsg</span><span class="o">,</span> <span class="n">mergeMsg</span><span class="o">)</span>
    <span class="k">var</span> <span class="n">activeMessages</span> <span class="k">=</span> <span class="n">messages</span><span class="o">.</span><span class="n">count</span><span class="o">()</span>
    <span class="c1">// Loop until no messages remain or maxIterations is achieved</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">activeMessages</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxIterations</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// Receive the messages and update the vertices.</span>
      <span class="n">g</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">joinVertices</span><span class="o">(</span><span class="n">messages</span><span class="o">)(</span><span class="n">vprog</span><span class="o">).</span><span class="n">cache</span><span class="o">()</span>
      <span class="k">val</span> <span class="n">oldMessages</span> <span class="k">=</span> <span class="n">messages</span>
      <span class="c1">// Send new messages, skipping edges where neither side received a message. We must cache</span>
      <span class="c1">// messages so it can be materialized on the next line, allowing us to uncache the previous</span>
      <span class="c1">// iteration.</span>
      <span class="n">messages</span> <span class="k">=</span> <span class="nc">GraphXUtils</span><span class="o">.</span><span class="n">mapReduceTriplets</span><span class="o">(</span>
        <span class="n">g</span><span class="o">,</span> <span class="n">sendMsg</span><span class="o">,</span> <span class="n">mergeMsg</span><span class="o">,</span> <span class="nc">Some</span><span class="o">((</span><span class="n">oldMessages</span><span class="o">,</span> <span class="n">activeDirection</span><span class="o">))).</span><span class="n">cache</span><span class="o">()</span>
      <span class="n">activeMessages</span> <span class="k">=</span> <span class="n">messages</span><span class="o">.</span><span class="n">count</span><span class="o">()</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>
    <span class="n">g</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>请注意，Pregel采用了两个参数列表（即， <code>graph.pregel(list1)(list2)</code> ）。第一个参数列表包含配置参数，包括初始消息，最大迭代次数以及发送消息的边缘方向（默认情况下沿边缘）。第二个参数列表包含用户定义的用于接收消息的函数（顶点程序<code>vprog</code> ），计算消息（ <code>sendMsg</code> ），并合并消息<code>mergeMsg</code> 。</p>

<p>在以下示例中，我们可以使用Pregel运算符来表示诸如单个源最短路径之类的计算。</p>

<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.graphx.</span><span class="o">{</span><span class="nc">Graph</span><span class="o">,</span> <span class="nc">VertexId</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">org.apache.spark.graphx.util.GraphGenerators</span>

<span class="c1">// A graph with edge attributes containing distances</span>
<span class="k">val</span> <span class="n">graph</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">GraphGenerators</span><span class="o">.</span><span class="n">logNormalGraph</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="n">numVertices</span> <span class="k">=</span> <span class="mi">100</span><span class="o">).</span><span class="n">mapEdges</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
<span class="k">val</span> <span class="n">sourceId</span><span class="k">:</span> <span class="kt">VertexId</span> <span class="o">=</span> <span class="mi">42</span> <span class="c1">// The ultimate source</span>
<span class="c1">// Initialize the graph such that all vertices except the root have distance infinity.</span>
<span class="k">val</span> <span class="n">initialGraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">mapVertices</span><span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">sourceId</span><span class="o">)</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">PositiveInfinity</span><span class="o">)</span>
<span class="k">val</span> <span class="n">sssp</span> <span class="k">=</span> <span class="n">initialGraph</span><span class="o">.</span><span class="n">pregel</span><span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="nc">PositiveInfinity</span><span class="o">)(</span>
  <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">dist</span><span class="o">,</span> <span class="n">newDist</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="n">newDist</span><span class="o">),</span> <span class="c1">// Vertex Program</span>
  <span class="n">triplet</span> <span class="k">=&gt;</span> <span class="o">{</span>  <span class="c1">// Send Message</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">attr</span> <span class="o">&lt;</span> <span class="n">triplet</span><span class="o">.</span><span class="n">dstAttr</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Iterator</span><span class="o">((</span><span class="n">triplet</span><span class="o">.</span><span class="n">dstId</span><span class="o">,</span> <span class="n">triplet</span><span class="o">.</span><span class="n">srcAttr</span> <span class="o">+</span> <span class="n">triplet</span><span class="o">.</span><span class="n">attr</span><span class="o">))</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="nc">Iterator</span><span class="o">.</span><span class="n">empty</span>
    <span class="o">}</span>
  <span class="o">},</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="c1">// Merge Message</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">sssp</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">collect</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">))</span>
</pre></div>
<div><small>在Spark存储库中的“ examples / src / main / scala / org / apache / spark / examples / graphx / SSSPExample.scala”中找到完整的示例代码。</small></div>

<p><a name="graph_builders"></a></p>

<h1 id="graph-builders">图构建器</h1>

<p>GraphX提供了几种从RDD或磁盘上的顶点和边的集合构建图形的方法。默认情况下，没有图构建器会重新划分图的边；相反，边缘保留在默认分区中（例如HDFS中的原始块）。 <a href="api/scala/index.html#org.apache.spark.graphx.Graph@groupEdges((ED,ED)%E2%87%92ED):Graph[VD,ED]"><code>Graph.groupEdges</code></a>要求对图进行重新分区，因为它假定相同的边将在同一分区上并置，因此您必须调用<a href="api/scala/index.html#org.apache.spark.graphx.Graph@partitionBy(PartitionStrategy):Graph[VD,ED]"><code>Graph.partitionBy</code></a>致电之前<code>groupEdges</code> 。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">object</span> <span class="nc">GraphLoader</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">edgeListFile</span><span class="o">(</span>
      <span class="n">sc</span><span class="k">:</span> <span class="kt">SparkContext</span><span class="o">,</span>
      <span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
      <span class="n">canonicalOrientation</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span>
      <span class="n">minEdgePartitions</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p><a href="api/scala/index.html#org.apache.spark.graphx.GraphLoader$@edgeListFile(SparkContext,String,Boolean,Int):Graph[Int,Int]"><code>GraphLoader.edgeListFile</code></a>提供了一种从磁盘上的边缘列表加载图形的方法。它解析以下形式的（源顶点ID，目标顶点ID）对的邻接表，并跳过以以下开头的注释行<code>#</code> ：</p>

<pre><code># This is a comment
2 1
4 1
1 2
</code></pre>

<p>它创建一个<code>Graph</code>从指定的边开始，自动创建边提到的任何顶点。所有顶点和边属性默认为1。的<code>canonicalOrientation</code>参数允许沿正方向重新定向边缘（ <code>srcId < dstId</code> ），这是所<a href="api/scala/index.html#org.apache.spark.graphx.lib.ConnectedComponents$">连接组件</a>算法所必需的。的<code>minEdgePartitions</code>参数指定要生成的边缘分区的最小数量；例如，如果HDFS文件具有更多块，则边缘分区可能会比指定的更多。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">object</span> <span class="nc">Graph</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">](</span>
      <span class="n">vertices</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VD</span><span class="o">)],</span>
      <span class="n">edges</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">ED</span><span class="o">]],</span>
      <span class="n">defaultVertexAttr</span><span class="k">:</span> <span class="kt">VD</span> <span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">fromEdges</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">](</span>
      <span class="n">edges</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Edge</span><span class="o">[</span><span class="kt">ED</span><span class="o">]],</span>
      <span class="n">defaultValue</span><span class="k">:</span> <span class="kt">VD</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">ED</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">fromEdgeTuples</span><span class="o">[</span><span class="kt">VD</span><span class="o">](</span>
      <span class="n">rawEdges</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VertexId</span><span class="o">)],</span>
      <span class="n">defaultValue</span><span class="k">:</span> <span class="kt">VD</span><span class="o">,</span>
      <span class="n">uniqueEdges</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">PartitionStrategy</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">)</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">VD</span>, <span class="kt">Int</span><span class="o">]</span>

<span class="o">}</span></code></pre></figure>

<p><a href="api/scala/index.html#org.apache.spark.graphx.Graph$@apply[VD,ED](RDD[(VertexId,VD)],RDD[Edge[ED]],VD)(ClassTag[VD],ClassTag[ED]):Graph[VD,ED]"><code>Graph.apply</code></a>允许根据顶点和边的RDD创建图形。任意选取重复的顶点，并且在边缘RDD中找到的顶点（而不是顶点RDD）指定为默认属性。</p>

<p><a href="api/scala/index.html#org.apache.spark.graphx.Graph$@fromEdges[VD,ED](RDD[Edge[ED]],VD)(ClassTag[VD],ClassTag[ED]):Graph[VD,ED]"><code>Graph.fromEdges</code></a>允许仅从边缘的RDD创建图形，自动创建边缘提及的任何顶点，并为其指定默认值。</p>

<p><a href="api/scala/index.html#org.apache.spark.graphx.Graph$@fromEdgeTuples[VD](RDD[(VertexId,VertexId)],VD,Option[PartitionStrategy])(ClassTag[VD]):Graph[VD,Int]"><code>Graph.fromEdgeTuples</code></a>允许仅从边缘元组的RDD创建图形，为边缘分配值1，并自动创建Edge提及的任何顶点，并为其指定默认值。它还支持对边缘进行重复数据删除；去重复，通过<code>Some</code>的<a href="api/scala/index.html#org.apache.spark.graphx.PartitionStrategy"><code>PartitionStrategy</code></a>作为<code>uniqueEdges</code>参数（例如， <code>uniqueEdges = Some(PartitionStrategy.RandomVertexCut)</code> ）。必须使用分区策略才能将相同边缘并置在同一分区上，以便可以对它们进行重复数据删除。</p>

<p><a name="vertex_and_edge_rdds"></a></p>

<h1 id="vertex-and-edge-rdds">顶点和边缘RDD</h1>

<p>GraphX公开<code>RDD</code>存储在图中的顶点和边的视图。但是，由于GraphX在优化的数据结构中维护了顶点和边，并且这些数据结构提供了附加功能，因此将顶点和边返回为<code>VertexRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.VertexRDD">VertexRDD</a>和<code>EdgeRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.EdgeRDD">EdgeRDD</a>分别。在本节中，我们将介绍这些类型中的一些其他有用功能。请注意，这只是一个不完整的列表，请参阅API文档以获取正式的操作列表。</p>

<h2 id="vertexrdds">顶点RDD</h2>

<p>的<code>VertexRDD[A]</code>延伸<code>RDD[(VertexId, A)]</code>并添加每个<code>VertexId</code>只发生<em>一次</em> 。此外， <code>VertexRDD[A]</code>表示一<em>组</em>顶点，每个顶点的类型为<code>A</code> 。在内部，这是通过将顶点属性存储在可重用的哈希映射数据结构中来实现的。结果，如果两个<code>VertexRDD</code> s来自相同的基数<code>VertexRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.VertexRDD">VertexRDD</a> （例如，通过<code>filter</code>要么<code>mapValues</code> ），它们可以在恒定时间内加入，而无需进行哈希评估。为了利用此索引数据结构， <code>VertexRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.VertexRDD">VertexRDD</a>公开了以下附加功能：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">class</span> <span class="nc">VertexRDD</span><span class="o">[</span><span class="kt">VD</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VD</span><span class="o">)]</span> <span class="o">{</span>
  <span class="c1">// Filter the vertex set but preserves the internal index</span>
  <span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">pred</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">VertexId</span>, <span class="kt">VD</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD</span><span class="o">]</span>
  <span class="c1">// Transform the values without changing the ids (preserves the internal index)</span>
  <span class="k">def</span> <span class="n">mapValues</span><span class="o">[</span><span class="kt">VD2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="kt">VD</span> <span class="o">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD2</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapValues</span><span class="o">[</span><span class="kt">VD2</span><span class="o">](</span><span class="n">map</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD2</span><span class="o">]</span>
  <span class="c1">// Show only vertices unique to this set based on their VertexId&#39;s</span>
  <span class="k">def</span> <span class="n">minus</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VD</span><span class="o">)])</span>
  <span class="c1">// Remove vertices from this set that appear in the other set</span>
  <span class="k">def</span> <span class="n">diff</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD</span><span class="o">])</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD</span><span class="o">]</span>
  <span class="c1">// Join operators that take advantage of the internal indexing to accelerate joins (substantially)</span>
  <span class="k">def</span> <span class="n">leftJoin</span><span class="o">[</span><span class="kt">VD2</span>, <span class="kt">VD3</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VD2</span><span class="o">)])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">VD2</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">VD3</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD3</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">innerJoin</span><span class="o">[</span><span class="kt">U</span>, <span class="kt">VD2</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">U</span><span class="o">)])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VD</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD2</span><span class="o">]</span>
  <span class="c1">// Use the index on this RDD to accelerate a `reduceByKey` operation on the input RDD.</span>
  <span class="k">def</span> <span class="n">aggregateUsingIndex</span><span class="o">[</span><span class="kt">VD2</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">VD2</span><span class="o">)],</span> <span class="n">reduceFunc</span><span class="k">:</span> <span class="o">(</span><span class="kt">VD2</span><span class="o">,</span> <span class="kt">VD2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">VD2</span><span class="o">)</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">VD2</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>注意，例如， <code>filter</code>运算子传回<code>VertexRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.VertexRDD">顶点RDD</a> 。过滤器实际上是使用<code>BitSet</code>从而重用索引并保留与其他对象快速连接的能力<code>VertexRDD</code> s。同样， <code>mapValues</code>运营商不允许<code>map</code>改变功能<code>VertexId</code>从而使相同<code>HashMap</code>要重用的数据结构。这俩<code>leftJoin</code>和<code>innerJoin</code>能够确定何时加入两个<code>VertexRDD</code>来自相同的<code>HashMap</code>并通过线性扫描而不是昂贵的点查找来实现连接。</p>

<p>的<code>aggregateUsingIndex</code>运算符对于新结构的有效构建很有用<code>VertexRDD</code>来自的<a href="api/scala/index.html#org.apache.spark.graphx.VertexRDD">VertexRDD</a> <code>RDD[(VertexId, A)]</code> 。从概念上讲，如果我构建了一个<code>VertexRDD[B]</code>在一组顶点上， <em>这是</em>一些顶点<em>的超集</em> <code>RDD[(VertexId, A)]</code>然后我可以重用索引进行汇总，然后再对<code>RDD[(VertexId, A)]</code> 。例如：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">val</span> <span class="n">setA</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">VertexRDD</span><span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="o">(</span><span class="mi">0L</span> <span class="n">until</span> <span class="mi">100L</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="mi">1</span><span class="o">)))</span>
<span class="k">val</span> <span class="n">rddB</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">VertexId</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="o">(</span><span class="mi">0L</span> <span class="n">until</span> <span class="mi">100L</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">),</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)))</span>
<span class="c1">// There should be 200 entries in rddB</span>
<span class="n">rddB</span><span class="o">.</span><span class="n">count</span>
<span class="k">val</span> <span class="n">setB</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">setA</span><span class="o">.</span><span class="n">aggregateUsingIndex</span><span class="o">(</span><span class="n">rddB</span><span class="o">,</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="c1">// There should be 100 entries in setB</span>
<span class="n">setB</span><span class="o">.</span><span class="n">count</span>
<span class="c1">// Joining A and B should now be fast!</span>
<span class="k">val</span> <span class="n">setC</span><span class="k">:</span> <span class="kt">VertexRDD</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">setA</span><span class="o">.</span><span class="n">innerJoin</span><span class="o">(</span><span class="n">setB</span><span class="o">)((</span><span class="n">id</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span></code></pre></figure>

<h2 id="edgerdds">边缘RDD</h2>

<p>的<code>EdgeRDD[ED]</code> ，扩展了<code>RDD[Edge[ED]]</code>使用在定义的各种分区策略之一中划分的块中组织边缘<a href="api/scala/index.html#org.apache.spark.graphx.PartitionStrategy"><code>PartitionStrategy</code></a> 。在每个分区中，边缘属性和邻接结构分别存储，从而在更改属性值时可实现最大程度的重用。</p>

<p>组件提供的三个附加功能<code>EdgeRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.EdgeRDD">EdgeRDD</a>是：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// Transform the edge attributes while preserving the structure</span>
<span class="k">def</span> <span class="n">mapValues</span><span class="o">[</span><span class="kt">ED2</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Edge</span><span class="o">[</span><span class="kt">ED</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">ED2</span><span class="o">)</span><span class="k">:</span> <span class="kt">EdgeRDD</span><span class="o">[</span><span class="kt">ED2</span><span class="o">]</span>
<span class="c1">// Reverse the edges reusing both attributes and structure</span>
<span class="k">def</span> <span class="n">reverse</span><span class="k">:</span> <span class="kt">EdgeRDD</span><span class="o">[</span><span class="kt">ED</span><span class="o">]</span>
<span class="c1">// Join two `EdgeRDD`s partitioned using the same partitioning strategy.</span>
<span class="k">def</span> <span class="n">innerJoin</span><span class="o">[</span><span class="kt">ED2</span>, <span class="kt">ED3</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">EdgeRDD</span><span class="o">[</span><span class="kt">ED2</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">VertexId</span><span class="o">,</span> <span class="kt">VertexId</span><span class="o">,</span> <span class="nc">ED</span><span class="o">,</span> <span class="nc">ED2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ED3</span><span class="o">)</span><span class="k">:</span> <span class="kt">EdgeRDD</span><span class="o">[</span><span class="kt">ED3</span><span class="o">]</span></code></pre></figure>

<p>在大多数应用中，我们发现<code>EdgeRDD</code> <a href="api/scala/index.html#org.apache.spark.graphx.EdgeRDD">EdgeRDD</a>是通过图运算符完成的，或者依赖于基数中定义的操作<code>RDD</code>类。</p>

<h1 id="optimized-representation">优化表示</h1>

<p>尽管对GraphX表示形式的分布式图形的优化的详细描述超出了本指南的范围，但是一些高级的了解可能有助于可伸缩算法的设计以及API的最佳使用。GraphX采用顶点切割方法进行分布式图分区：</p>

<p style="text-align:center">
  <img src="img/edge_cut_vs_vertex_cut.png" title="边缘切割与顶点切割" alt="边缘切割与顶点切割" width="50%">
  <!-- Images are downsized intentionally to improve quality on retina displays -->
</p>

<p>GraphX不会沿边缘划分图，而是沿顶点划分图，这可以减少通信和存储开销。从逻辑上讲，这对应于为机器分配边并允许顶点跨越多台机器。分配边的确切方法取决于<a href="api/scala/index.html#org.apache.spark.graphx.PartitionStrategy"><code>PartitionStrategy</code></a>并且在各种启发式方法之间存在一些折衷。用户可以通过将图表重新划分为不同的策略来进行选择<a href="api/scala/index.html#org.apache.spark.graphx.Graph@partitionBy(PartitionStrategy):Graph[VD,ED]"><code>Graph.partitionBy</code></a>操作员。默认的分区策略是使用图形构造中提供的边缘的初始分区。但是，用户可以轻松切换到GraphX中包含的2D分区或其他启发式方法。</p>

<p style="text-align:center">
  <img src="img/vertex_routing_edge_tables.png" title="RDD图形表示" alt="RDD图形表示" width="50%">
  <!-- Images are downsized intentionally to improve quality on retina displays -->
</p>

<p>一旦对边缘进行了划分，高效图形并行计算的关键挑战就是将顶点属性与边缘有效结合。由于现实世界中的图通常具有比顶点更多的边，因此我们将顶点属性移到边。由于并非所有分区都包含与所有顶点相邻的边，因此我们在内部维护一个路由表，该路由表在实现诸如<code>triplets</code>和<code>aggregateMessages</code> 。</p>

<p><a name="graph_algorithms"></a></p>

<h1 id="graph-algorithms">图算法</h1>

<p>GraphX包含一组图形算法，以简化分析任务。这些算法包含在<code>org.apache.spark.graphx.lib</code>包，可以作为方法直接访问<code>Graph</code>通过<a href="api/scala/index.html#org.apache.spark.graphx.GraphOps"><code>GraphOps</code></a> 。本节介绍了算法及其使用方法。</p>

<p><a name="pagerank"></a></p>

<h2 id="pagerank">网页排名</h2>

<p>的PageRank测量在图中每个顶点的重要性，假设从<em>u</em>到<em>v</em>的边缘由<em>u</em>表示<em>V</em>的认可的重要性。例如，如果一个Twitter用户被许多其他用户关注，则该用户将获得很高的排名。</p>

<p>GraphX随附PageRank的静态和动态实现，作为页面上的方法<a href="api/scala/index.html#org.apache.spark.graphx.lib.PageRank$"><code>PageRank</code>对象</a> 。静态PageRank运行固定的迭代次数，而动态PageRank运行直到排名收敛（即，停止变化超过指定的公差）。 <a href="api/scala/index.html#org.apache.spark.graphx.GraphOps"><code>GraphOps</code></a>允许直接将这些算法作为方法调用<code>Graph</code> 。</p>

<p>GraphX还包括一个示例社交网络数据集，可在其上运行PageRank。一组用户在<code>data/graphx/users.txt</code> ，并在中给出了一组用户之间的关系<code>data/graphx/followers.txt</code> 。我们计算每个用户的PageRank如下：</p>

<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.graphx.GraphLoader</span>

<span class="c1">// Load the edges as a graph</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">GraphLoader</span><span class="o">.</span><span class="n">edgeListFile</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="s">&quot;data/graphx/followers.txt&quot;</span><span class="o">)</span>
<span class="c1">// Run PageRank</span>
<span class="k">val</span> <span class="n">ranks</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">pageRank</span><span class="o">(</span><span class="mf">0.0001</span><span class="o">).</span><span class="n">vertices</span>
<span class="c1">// Join the ranks with the usernames</span>
<span class="k">val</span> <span class="n">users</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;data/graphx/users.txt&quot;</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">line</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">fields</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fields</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLong</span><span class="o">,</span> <span class="n">fields</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">ranksByUsername</span> <span class="k">=</span> <span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">ranks</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">rank</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">rank</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Print the result</span>
<span class="n">println</span><span class="o">(</span><span class="n">ranksByUsername</span><span class="o">.</span><span class="n">collect</span><span class="o">().</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">))</span>
</pre></div>
<div><small>在Spark存储库中的“ examples / src / main / scala / org / apache / spark / examples / graphx / PageRankExample.scala”中找到完整的示例代码。</small></div>

<h2 id="connected-components">连接的组件</h2>

<p>连通组件算法使用其编号最小的顶点的ID标记图的每个连通组件。例如，在社交网络中，连接的组件可以近似群集。GraphX在<a href="api/scala/index.html#org.apache.spark.graphx.lib.ConnectedComponents$"><code>ConnectedComponents</code> object</a> ，然后从<a href="#pagerank">PageRank部分</a>计算示例社交网络数据集的连接组件，如下所示：</p>

<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.graphx.GraphLoader</span>

<span class="c1">// Load the graph as in the PageRank example</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">GraphLoader</span><span class="o">.</span><span class="n">edgeListFile</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="s">&quot;data/graphx/followers.txt&quot;</span><span class="o">)</span>
<span class="c1">// Find the connected components</span>
<span class="k">val</span> <span class="n">cc</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">connectedComponents</span><span class="o">().</span><span class="n">vertices</span>
<span class="c1">// Join the connected components with the usernames</span>
<span class="k">val</span> <span class="n">users</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;data/graphx/users.txt&quot;</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">line</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">fields</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fields</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLong</span><span class="o">,</span> <span class="n">fields</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">ccByUsername</span> <span class="k">=</span> <span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">cc</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">cc</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">cc</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Print the result</span>
<span class="n">println</span><span class="o">(</span><span class="n">ccByUsername</span><span class="o">.</span><span class="n">collect</span><span class="o">().</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">))</span>
</pre></div>
<div><small>在Spark存储库中的“ examples / src / main / scala / org / apache / spark / examples / graphx / ConnectedComponentsExample.scala”中找到完整的示例代码。</small></div>

<h2 id="triangle-counting">三角计数</h2>

<p>当顶点有两个相邻的顶点且在它们之间有一条边时，该顶点是三角形的一部分。GraphX在<a href="api/scala/index.html#org.apache.spark.graphx.lib.TriangleCount$"><code>TriangleCount</code></a>确定通过每个顶点的三角形数量的<a href="api/scala/index.html#org.apache.spark.graphx.lib.TriangleCount$">对象</a> ，提供对聚类的度量。我们从<a href="#pagerank">PageRank部分</a>计算社交网络数据集的三角形计数。<em>注意<code>TriangleCount</code>要求边缘必须规范（ <code>srcId < dstId</code> ）和要使用进行分区的图<a href="api/scala/index.html#org.apache.spark.graphx.Graph@partitionBy(PartitionStrategy):Graph[VD,ED]"><code>Graph.partitionBy</code></a> 。</em></p>

<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.graphx.</span><span class="o">{</span><span class="nc">GraphLoader</span><span class="o">,</span> <span class="nc">PartitionStrategy</span><span class="o">}</span>

<span class="c1">// Load the edges in canonical order and partition the graph for triangle count</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="nc">GraphLoader</span><span class="o">.</span><span class="n">edgeListFile</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="s">&quot;data/graphx/followers.txt&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
  <span class="o">.</span><span class="n">partitionBy</span><span class="o">(</span><span class="nc">PartitionStrategy</span><span class="o">.</span><span class="nc">RandomVertexCut</span><span class="o">)</span>
<span class="c1">// Find the triangle count for each vertex</span>
<span class="k">val</span> <span class="n">triCounts</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">triangleCount</span><span class="o">().</span><span class="n">vertices</span>
<span class="c1">// Join the triangle counts with the usernames</span>
<span class="k">val</span> <span class="n">users</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;data/graphx/users.txt&quot;</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">line</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">fields</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fields</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLong</span><span class="o">,</span> <span class="n">fields</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">triCountByUsername</span> <span class="k">=</span> <span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">triCounts</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">tc</span><span class="o">))</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">tc</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Print the result</span>
<span class="n">println</span><span class="o">(</span><span class="n">triCountByUsername</span><span class="o">.</span><span class="n">collect</span><span class="o">().</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">))</span>
</pre></div>
<div><small>在Spark存储库中的“ examples / src / main / scala / org / apache / spark / examples / graphx / TriangleCountingExample.scala”中找到完整的示例代码。</small></div>

<h1 id="examples">例子</h1>

<p>假设我想从一些文本文件构建图形，将图形限制在重要的关系和用户上，在子图形上运行page-rank，然后最终返回与顶级用户相关联的属性。我可以使用GraphX在几行中完成所有这些操作：</p>

<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.graphx.GraphLoader</span>

<span class="c1">// Load my user data and parse into tuples of user id and attribute list</span>
<span class="k">val</span> <span class="n">users</span> <span class="k">=</span> <span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;data/graphx/users.txt&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span> <span class="n">parts</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">toLong</span><span class="o">,</span> <span class="n">parts</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span> <span class="o">))</span>

<span class="c1">// Parse the edge data which is already in userId -&gt; userId format</span>
<span class="k">val</span> <span class="n">followerGraph</span> <span class="k">=</span> <span class="nc">GraphLoader</span><span class="o">.</span><span class="n">edgeListFile</span><span class="o">(</span><span class="n">sc</span><span class="o">,</span> <span class="s">&quot;data/graphx/followers.txt&quot;</span><span class="o">)</span>

<span class="c1">// Attach the user attributes</span>
<span class="k">val</span> <span class="n">graph</span> <span class="k">=</span> <span class="n">followerGraph</span><span class="o">.</span><span class="n">outerJoinVertices</span><span class="o">(</span><span class="n">users</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">uid</span><span class="o">,</span> <span class="n">deg</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">attrList</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">attrList</span>
  <span class="c1">// Some users may not have attributes so we set them as empty</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">uid</span><span class="o">,</span> <span class="n">deg</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Array</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// Restrict the graph to users with usernames and names</span>
<span class="k">val</span> <span class="n">subgraph</span> <span class="k">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="o">(</span><span class="n">vpred</span> <span class="k">=</span> <span class="o">(</span><span class="n">vid</span><span class="o">,</span> <span class="n">attr</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">attr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>

<span class="c1">// Compute the PageRank</span>
<span class="k">val</span> <span class="n">pagerankGraph</span> <span class="k">=</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">pageRank</span><span class="o">(</span><span class="mf">0.001</span><span class="o">)</span>

<span class="c1">// Get the attributes of the top pagerank users</span>
<span class="k">val</span> <span class="n">userInfoWithPageRank</span> <span class="k">=</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">outerJoinVertices</span><span class="o">(</span><span class="n">pagerankGraph</span><span class="o">.</span><span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">uid</span><span class="o">,</span> <span class="n">attrList</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">pr</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">pr</span><span class="o">,</span> <span class="n">attrList</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">uid</span><span class="o">,</span> <span class="n">attrList</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="n">attrList</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">println</span><span class="o">(</span><span class="n">userInfoWithPageRank</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">top</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="nc">Ordering</span><span class="o">.</span><span class="n">by</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_2</span><span class="o">.</span><span class="n">_1</span><span class="o">)).</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">))</span>
</pre></div>
<div><small>在Spark存储库中的“ examples / src / main / scala / org / apache / spark / examples / graphx / ComprehensiveExample.scala”中找到完整的示例代码。</small></div>


                </div>
            
             <!-- /container -->
        </div>

        <script src="js/vendor/jquery-3.4.1.min.js"></script>
        <script src="js/vendor/bootstrap.min.js"></script>
        <script src="js/vendor/anchor.min.js"></script>
        <script src="js/main.js"></script>

        <!-- MathJax Section -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: { equationNumbers: { autoNumber: "AMS" } }
            });
        </script>
        <script>
            // Note that we load MathJax this way to work with local file (file://), HTTP and HTTPS.
            // We could use "//cdn.mathjax...", but that won't support "file://".
            (function(d, script) {
                script = d.createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.onload = function(){
                    MathJax.Hub.Config({
                        tex2jax: {
                            inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ],
                            displayMath: [ ["$$","$$"], ["\\[", "\\]"] ],
                            processEscapes: true,
                            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                        }
                    });
                };
                script.src = ('https:' == document.location.protocol ? 'https://' : 'http://') +
                    'cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' +
                    '?config=TeX-AMS-MML_HTMLorMML';
                d.getElementsByTagName('head')[0].appendChild(script);
            }(document));
        </script>
    

</body></html>