<html ><head>
<link rel="stylesheet" type="text/css" href="../css/style.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Apache JMeter-用户手册：测试计划的要素</title>
<style>
  .code { font-weight: bold; }
</style>
</head>

<body bgcolor="#ffffff"  text="#000000" link="#525D76">
<table border="0" cellspacing="0">
<tbody><tr>
<td align="left">
<a href="http://www.apache.org"><img title="Apache软件基金会" width="261" height="106" src="../images/asf-logo.png" border="0" style="margin:0px 30px 0px 0px"></a>
</td>
<td align="right">
<a href="http://jmeter.apache.org/"><img width="259" height="88" src="../images/jmeter.png" alt="Apache JMeter" title="Apache JMeter" border="0"></a>
</td>
</tr>
</tbody></table>
<table border="0" cellspacing="4">
<tbody><tr><td>
<hr noshade size="1">
</td></tr>
<tr>
<td align="left" valign="top">
<table>
<tbody><tr>
<td bgcolor="#525D76">
<div align="right"><a href="index.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">指数</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="build-web-test-plan.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">下一个</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="build-test-plan.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">上一个</font></a></div>
</td>
</tr>
</tbody></table>
<br>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<strong>3。测试计划的要素</strong></font>
</td></tr>
<tr><td>
<blockquote>
<p>本节描述测试计划的不同部分。
</p><p>最少的测试将包括测试计划，线程组和一个或多个采样器。
</p><table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="test_plan"><strong>3.0测试计划</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>测试计划对象具有一个名为“ <tt class="code">功能测试</tt> ”的复选框。如果选择，它将使JMeter记录每个样本从服务器返回的数据。如果您在测试侦听器中选择了文件，则此数据将被写入文件。如果您要进行少量运行以确保正确配置JMeter并确保服务器返回预期结果，则这将很有用。结果是文件将快速增长，JMeter的性能将受到影响。如果要进行压力测试，则应禁用此选项（默认情况下处于禁用状态）。</p><p>如果您没有将数据记录到文件中，则此选项没有区别。</p><p>您还可以使用侦听器上的“ <tt class="code">配置”</tt>按钮来确定要保存的字段。</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="thread_group"><strong>3.1线程组</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>线程组元素是任何测试计划的起点。所有控制器和采样器必须在线程组下。其他元素（例如，侦听器）可以直接放在测试计划下，在这种情况下，它们将应用于所有线程组。顾名思义，线程组元素控制JMeter将用于执行测试的线程数。线程组的控件使您可以：</p><ul><li>设置线程数</li>
<li>设置加速时间</li>
<li>设置执行测试的次数</li>
</ul><p></p><p>每个线程将完整地执行测试计划，并且完全独立于其他测试线程。多个线程用于模拟与服务器应用程序的并发连接。</p><p>加速期告诉JMeter将“加速”到所选线程的总数需要多长时间。如果使用了10个线程，并且启动周期为100秒，那么JMeter将花费100秒来启动和运行所有10个线程。每个线程将在上一个线程开始后10（100/10）秒开始。如果有30个线程，启动周期为120秒，则每个连续线程将延迟4秒。</p><p>升级需要足够长的时间来避免在测试开始时工作量过大，并且还必须足够短以使最后一个线程在第一个线程完成之前开始运行（除非有人希望这样做）。
</p><p>从“上升=线程数”开始，然后根据需要向上或向下调整。
</p><p>默认情况下，线程组配置为在其元素之间循环一次。</p><p>线程组还提供了<b>调度程序</b> 。单击“线程组”面板底部的复选框以启用/禁用其他字段，您可以在其中输入测试持续时间，启动延迟，运行的开始和结束时间。您可以配置<tt class="code">持续时间（秒）</tt>和<tt class="code">启动延迟（秒）</tt>来控制每个线程组的持续时间以及<tt class="code">启动</tt>多少秒后的时间。当测试开始时，JMeter将在启动线程组的线程之前等待<tt class="code">启动延迟（秒），</tt>然后运行配置的<tt class="code">持续时间（秒）</tt> 。请注意，这两个选项会覆盖“ <tt class="code">开始时间”</tt>和“ <tt class="code">结束时间”</tt> 。
     
     </p><p>另外，您也可以使用其他两个字段<tt class="code">Start time</tt>和<tt class="code">End time</tt> （尽管不建议这样做，因为它不太灵活）。测试开始时，如有必要，JMeter将等待直到达到启动时间。在每个周期的末尾，JMeter会检查是否已达到结束时间，如果已结束，则运行将停止，否则，将允许测试继续进行直到达到迭代限制。</p>
     <p></p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="controllers"><strong>3.2控制器</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>JMeter有两种类型的控制器：采样器和逻辑控制器。这些驱动测试的进行。</p><p>采样器告诉JMeter将请求发送到服务器。例如，如果您希望JMeter发送HTTP请求，则添加一个HTTP Request Sampler。您还可以通过将一个或多个配置元素添加到采样器来自定义请求。有关更多信息，请参见<a href="#samplers">采样器</a> 。</p><p>逻辑控制器使您可以自定义JMeter用于决定何时发送请求的逻辑。例如，您可以添加一个Interleave Logic Controller在两个HTTP Request Samplers之间交替。有关更多信息，请参见<a href="#logic_controller">逻辑控制器</a> 。</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="samplers"><strong>3.2.1采样器</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>采样器告诉JMeter将请求发送到服务器并等待响应。它们按照它们在树中出现的顺序进行处理。控制器可用于修改采样器的重复次数。
</p><p>JMeter采样器包括：</p><ul>
    <li>FTP请求</li>
    <li>HTTP请求（也可用于SOAP或REST Web服务）</li>
    <li>JDBC请求</li>
    <li>Java对象请求</li>
    <li>JMS请求</li>
    <li>JUnit测试请求</li>
    <li>LDAP要求</li>
    <li>邮件要求</li>
    <li>操作系统进程请求</li>
    <li>TCP请求</li>
</ul>每个采样器都有几个可以设置的属性。您可以通过向测试计划中添加一个或多个配置元素来进一步自定义采样器。
<p></p><p>如果要将相同类型的多个请求（例如HTTP请求）发送到同一服务器，请考虑使用默认配置元素。每个控制器都有一个或多个Defaults元素（请参见下文）。</p><p>切记在测试计划中添加一个侦听器，以查看和/或将请求结果存储到磁盘。</p><p>如果您有兴趣让JMeter对请求的响应执行基本验证，请将<a href="#assertions">Assertion</a>添加到采样器。例如，在对Web应用程序进行压力测试时，服务器可能返回成功的“ HTTP响应”代码，但是页面上可能有错误或缺少部分。您可以添加断言来检查某些HTML标记，常见错误字符串等。JMeter允许您使用正则表达式创建这些断言。</p><p><a href="component_reference.html#samplers">JMeter的内置采样器</a></p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="logic_controller"><strong>3.2.2逻辑控制器</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>逻辑控制器使您可以自定义JMeter用于决定何时发送请求的逻辑。逻辑控制器可以更改来自其子元素的请求的顺序。他们可以自己修改请求，使JMeter重复请求，等等。</p><p>要了解逻辑控制器对测试计划的影响，请考虑以下测试树：</p><p>
</p><ul>
<li>测试计划</li>
    <ul>
    <li>线程组</li>
        <ul>
        <li>一次性控制器</li>
            <ul>
            <li>登录请求（ <a href="../usermanual/component_reference.html#HTTP_Request">HTTP请求</a> ）</li>
            </ul>
        <li>加载搜索页面（HTTP采样器）</li>
        <li>交错控制器</li>
            <ul>
            <li>搜索“ A”（HTTP采样器）</li>
            <li>搜索“ B”（HTTP采样器）</li>
            <li>HTTP默认请求（配置元素）</li>
            </ul>
        <li>HTTP默认请求（配置元素）</li>
        <li>Cookie管理器（配置元素）</li>
        </ul>
    </ul>
</ul>
<p></p><p>此测试的第一件事是，登录请求将仅在第一次执行。随后的迭代将跳过它。这是由于“ <a href="../usermanual/component_reference.html#Once_Only_Controller">仅一次控制器”的作用</a> 。</p><p>登录后，下一个Sampler加载搜索页面（想象一个用户登录的Web应用程序，然后转到搜索页面进行搜索）。这只是一个简单的请求，不会通过任何逻辑控制器进行过滤。</p><p>加载搜索页面后，我们要进行搜索。实际上，我们要进行两种不同的搜索。但是，我们希望在每次搜索之间重新加载搜索页面本身。我们可以通过具有4个简单的HTTP请求元素（加载搜索，搜索“ A”，加载搜索，搜索“ B”）来实现。取而代之的是，我们使用<a href="../usermanual/component_reference.html#Interleave_Controller">交错控制器</a> ，该<a href="../usermanual/component_reference.html#Interleave_Controller">控制器</a>每次通过测试都会传递一个子请求。它保持其子元素的顺序（即，它不会随机传递，而是“记住”其位置）。交织2个孩子的请求可能会过大，但是很容易就有8个或20个孩子的请求。</p><p>请注意属于Interleave控制器的<a href="../usermanual/component_reference.html#HTTP_Request_Defaults">HTTP请求默认值</a> 。想象一下，“搜索A”和“搜索B”共享相同的PATH信息（HTTP请求规范包括域，端口，方法，协议，路径和参数以及其他可选项）。这很有道理-两者都是搜索请求，都命中了相同的后端搜索引擎（例如servlet或cgi-script）。与其在PATH字段中为两个HTTP Samplers配置相同的信息，不如将这些信息抽象到单个Configuration Element中。当Interleave Controller“传递”来自“搜索A”或“搜索B”的请求时，它将使用HTTP默认请求配置元素中的值填充空白。因此，对于这些请求，我们将PATH字段留空，然后将该信息放入Configuration Element。在这种情况下，这充其量是次要的好处，但可以证明其功能。</p><p>树中的下一个元素是另一个HTTP默认请求，这次已添加到线程组本身。线程组具有内置的逻辑控制器，因此，它完全如上所述使用此配置元素。它填补了所有通过的请求的空白。在Web测试中，将所有HTTP Sampler元素中的DOMAIN字段保留为空白，然后将该信息放入HTTP默认请求元素（添加到线程组中）非常有用。这样，您只需更改测试计划中的一个字段即可在另一台服务器上测试应用程序。否则，您将必须编辑每个Sampler。</p><p>最后一个元素是<a href="../usermanual/component_reference.html#HTTP_Cookie_Manager">HTTP Cookie Manager</a> 。Cookie管理器应添加到所有Web测试中-否则JMeter将忽略cookie。通过在线程组级别添加它，我们确保所有HTTP请求将共享相同的cookie。</p><p>逻辑控制器可以组合使用以获得各种结果。请参阅<a href="component_reference.html#logic_controllers">内置逻辑控制器</a>列表。</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="test_fragments"><strong>3.2.3测试片段</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>测试片段元素是一种特殊类型的<a href="#controllers">控制器</a> ，它与线程组元素位于同一级别的测试计划树上。它与线程组的区别在于，除非被<a href="../usermanual/component_reference.html#Module_Controller">模块控制器</a>或<a href="../usermanual/component_reference.html#Include_Controller">Include_Controller</a>引用，否则它不会执行。
</p><p>此元素仅用于测试计划中的代码重用</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="listeners"><strong>3.3听众</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>侦听器提供对JMeter运行时JMeter收集的有关测试用例的信息的访问。<a href="../usermanual/component_reference.html#Graph_Results">图表结果</a>侦听器在图表上绘制响应时间。“查看结果树”侦听器显示采样器请求和响应的详细信息，并可以显示响应的基本HTML和XML表示形式。其他侦听器提供摘要或聚合信息。
</p><p>此外，侦听器可以将数据定向到文件以供以后使用。JMeter中的每个侦听器都提供一个字段来指示要将数据存储到的文件。还有一个“配置”按钮，可用于选择要保存的字段以及使用CSV还是XML格式。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，所有侦听器都保存相同的数据。唯一的区别在于数据在屏幕上的显示方式。</td></tr>
</tbody></table>
<p></p>

<p></p><p>可以在测试中的任何位置（包括直接在测试计划下）添加侦听器。他们将仅从其级别或以下级别的元素收集数据。
</p><p>JMeter附带了多个<a href="component_reference.html#listeners">侦听器</a> 。</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="timers"><strong>3.4计时器</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>默认情况下，JMeter线程按顺序执行采样器而不会暂停。我们建议您通过将可用计时器之一添加到线程组来指定延迟。如果不增加延迟，JMeter可能会在很短的时间内发出太多请求，从而使服务器不堪重负。</p><p>计时器将导致JMeter在其<a href="#scoping_rules">范围内的</a>每个采样器<b>之前</b>延迟一定的时间。</p><p>如果选择向一个线程组添加多个计时器，JMeter将使用计时器的总和并在执行该计时器所适用的采样器之前暂停该时间。可以将计时器作为采样器或控制器的子级添加，以限制将它们应用到的采样器。
</p><p>要在测试计划中的单个位置提供暂停，可以使用<a href="../usermanual/component_reference.html#Flow_Control_Action">Flow Control Action</a> Sampler。
</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="assertions"><strong>3.5断言</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>断言使您可以断言有关从被测试服务器收到的响应的事实。使用断言，您基本上可以“测试”您的应用程序正在返回期望的结果。</p><p>例如，您可以断言对查询的响应将包含一些特定的文本。您指定的文本可以是Perl样式的正则表达式，并且可以指示响应将包含文本，或者应与整个响应匹配。</p><p>您可以将断言添加到任何采样器。例如，您可以向HTTP请求中添加断言，以检查文本“<tt class="code"></tt></p></blockquote></td></tr></tbody></table></blockquote></td></tr></tbody></table></td></tr></tbody></table></body></html>