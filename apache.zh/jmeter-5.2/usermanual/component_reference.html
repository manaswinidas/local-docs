<html ><head></head><body bgcolor="#ffffff"  text="#000000" link="#525D76">﻿
<link rel="stylesheet" type="text/css" href="../css/style.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Apache JMeter-用户手册：组件参考</title>
<style>
  .code { font-weight: bold; }
</style>



<table border="0" cellspacing="0">
<tbody><tr>
<td align="left">
<a href="http://www.apache.org"><img title="Apache软件基金会" width="261" height="106" src="../images/asf-logo.png" border="0" style="margin:0px 30px 0px 0px"></a>
</td>
<td align="right">
<a href="http://jmeter.apache.org/"><img width="259" height="88" src="../images/jmeter.png" alt="Apache JMeter" title="Apache JMeter" border="0"></a>
</td>
</tr>
</tbody></table>
<table border="0" cellspacing="4">
<tbody><tr><td>
<hr noshade size="1">
</td></tr>
<tr>
<td align="left" valign="top">
<table>
<tbody><tr>
<td bgcolor="#525D76">
<div align="right"><a href="index.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">指数</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="properties_reference.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">下一个</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="boss.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">上一个</font></a></div>
</td>
</tr>
</tbody></table>
<br>
<table width="100%">
<tbody><tr><td valign="top">
<ul>
<li><a href="#introduction">18引言</a></li>
<ul>
</ul>
<li><a href="#samplers">18.1采样器</a></li>
<ul>
<li>
<a href="#FTP_Request">FTP请求</a></li>
<li>
<a href="#HTTP_Request">HTTP请求</a></li>
<li>
<a href="#JDBC_Request">JDBC请求</a></li>
<li>
<a href="#Java_Request">Java请求</a></li>
<li>
<a href="#LDAP_Request">LDAP要求</a></li>
<li>
<a href="#LDAP_Extended_Request">LDAP扩展请求</a></li>
<li>
<a href="#Access_Log_Sampler">访问日志采样器</a></li>
<li>
<a href="#BeanShell_Sampler">BeanShell采样器</a></li>
<li>
<a href="#JSR223_Sampler">JSR223采样器</a></li>
<li>
<a href="#TCP_Sampler">TCP采样器</a></li>
<li>
<a href="#JMS_Publisher">JMS发布者</a></li>
<li>
<a href="#JMS_Subscriber">JMS订户</a></li>
<li>
<a href="#JMS_Point-to-Point">JMS点对点</a></li>
<li>
<a href="#JUnit_Request">JUnit请求</a></li>
<li>
<a href="#Mail_Reader_Sampler">邮件阅读器采样器</a></li>
<li>
<a href="#Flow_Control_Action">流控制动作（原为：测试动作）</a></li>
<li>
<a href="#SMTP_Sampler">SMTP取样器</a></li>
<li>
<a href="#OS_Process_Sampler">操作系统进程采样器</a></li>
<li>
<a href="#MongoDB_Script_(DEPRECATED)">MongoDB脚本（不推荐使用）</a></li>
<li>
<a href="#Bolt_Request">螺栓请求</a></li>
</ul>
<li><a href="#logic_controllers">18.2逻辑控制器</a></li>
<ul>
<li>
<a href="#Simple_Controller">简单控制器</a></li>
<li>
<a href="#Loop_Controller">回路控制器</a></li>
<li>
<a href="#Once_Only_Controller">一次性控制器</a></li>
<li>
<a href="#Interleave_Controller">交错控制器</a></li>
<li>
<a href="#Random_Controller">随机控制器</a></li>
<li>
<a href="#Random_Order_Controller">随机顺序控制器</a></li>
<li>
<a href="#Throughput_Controller">吞吐量控制器</a></li>
<li>
<a href="#Runtime_Controller">运行时控制器</a></li>
<li>
<a href="#If_Controller">如果控制器</a></li>
<li>
<a href="#While_Controller">当控制器</a></li>
<li>
<a href="#Switch_Controller">开关控制器</a></li>
<li>
<a href="#ForEach_Controller">每个控制器</a></li>
<li>
<a href="#Module_Controller">模块控制器</a></li>
<li>
<a href="#Include_Controller">包含控制器</a></li>
<li>
<a href="#Transaction_Controller">交易控制器</a></li>
<li>
<a href="#Recording_Controller">录音控制器</a></li>
<li>
<a href="#Critical_Section_Controller">关键部分控制器</a></li>
</ul>
<li><a href="#listeners">18.3听众</a></li>
<ul>
<li>
<a href="#Sample_Result_Save_Configuration">样本结果保存配置</a></li>
<li>
<a href="#Graph_Results">图形结果</a></li>
<li>
<a href="#Assertion_Results">断言结果</a></li>
<li>
<a href="#View_Results_Tree">查看结果树</a></li>
<li>
<a href="#Aggregate_Report">汇总报告</a></li>
<li>
<a href="#View_Results_in_Table">查看表中的结果</a></li>
<li>
<a href="#Simple_Data_Writer">简单数据写入器</a></li>
<li>
<a href="#Aggregate_Graph">聚合图</a></li>
<li>
<a href="#Response_Time_Graph">响应时间图</a></li>
<li>
<a href="#Mailer_Visualizer">Mailer Visualizer</a></li>
<li>
<a href="#BeanShell_Listener">BeanShell侦听器</a></li>
<li>
<a href="#Summary_Report">总结报告</a></li>
<li>
<a href="#Save_Responses_to_a_file">将回复保存到文件</a></li>
<li>
<a href="#JSR223_Listener">JSR223侦听器</a></li>
<li>
<a href="#Generate_Summary_Results">生成摘要结果</a></li>
<li>
<a href="#Comparison_Assertion_Visualizer">比较断言可视化器</a></li>
<li>
<a href="#Backend_Listener">后端监听器</a></li>
</ul>
</ul></td><td valign="top"><ul>
<li><a href="#config_elements">18.4配置元素</a></li>
<ul>
<li>
<a href="#CSV_Data_Set_Config">CSV数据集配置</a></li>
<li>
<a href="#FTP_Request_Defaults">FTP请求默认值</a></li>
<li>
<a href="#DNS_Cache_Manager">DNS缓存管理器</a></li>
<li>
<a href="#HTTP_Authorization_Manager">HTTP授权管理器</a></li>
<li>
<a href="#HTTP_Cache_Manager">HTTP缓存管理器</a></li>
<li>
<a href="#HTTP_Cookie_Manager">HTTP Cookie管理器</a></li>
<li>
<a href="#HTTP_Request_Defaults">HTTP请求默认值</a></li>
<li>
<a href="#HTTP_Header_Manager">HTTP标头管理器</a></li>
<li>
<a href="#Java_Request_Defaults">Java请求默认值</a></li>
<li>
<a href="#JDBC_Connection_Configuration">JDBC连接配置</a></li>
<li>
<a href="#Keystore_Configuration">密钥库配置</a></li>
<li>
<a href="#Login_Config_Element">登录配置元素</a></li>
<li>
<a href="#LDAP_Request_Defaults">LDAP请求默认值</a></li>
<li>
<a href="#LDAP_Extended_Request_Defaults">LDAP扩展请求默认值</a></li>
<li>
<a href="#TCP_Sampler_Config">TCP采样器配置</a></li>
<li>
<a href="#User_Defined_Variables">用户定义的变量</a></li>
<li>
<a href="#Random_Variable">随机变量</a></li>
<li>
<a href="#Counter">计数器</a></li>
<li>
<a href="#Simple_Config_Element">简单的配置元素</a></li>
<li>
<a href="#MongoDB_Source_Config_(DEPRECATED)">MongoDB源配置（已弃用）</a></li>
<li>
<a href="#Bolt_Connection_Configuration">螺栓连接配置</a></li>
</ul>
<li><a href="#assertions">18.5断言</a></li>
<ul>
<li>
<a href="#Response_Assertion">回应断言</a></li>
<li>
<a href="#Duration_Assertion">持续时间断言</a></li>
<li>
<a href="#Size_Assertion">大小断言</a></li>
<li>
<a href="#XML_Assertion">XML断言</a></li>
<li>
<a href="#BeanShell_Assertion">BeanShell断言</a></li>
<li>
<a href="#MD5Hex_Assertion">MD5Hex断言</a></li>
<li>
<a href="#HTML_Assertion">HTML断言</a></li>
<li>
<a href="#XPath_Assertion">XPath断言</a></li>
<li>
<a href="#XPath2_Assertion">XPath2断言</a></li>
<li>
<a href="#XML_Schema_Assertion">XML模式声明</a></li>
<li>
<a href="#JSR223_Assertion">JSR223断言</a></li>
<li>
<a href="#Compare_Assertion">比较断言</a></li>
<li>
<a href="#SMIME_Assertion">SMIME断言</a></li>
<li>
<a href="#JSON_Assertion">JSON断言</a></li>
<li>
<a href="#JSON_JMESPath_Assertion">JSON JMESPath断言</a></li>
</ul>
<li><a href="#timers">18.6计时器</a></li>
<ul>
<li>
<a href="#Constant_Timer">恒定计时器</a></li>
<li>
<a href="#Gaussian_Random_Timer">高斯随机计时器</a></li>
<li>
<a href="#Uniform_Random_Timer">统一随机计时器</a></li>
<li>
<a href="#Constant_Throughput_Timer">恒定吞吐量计时器</a></li>
<li>
<a href="#Precise_Throughput_Timer">精确的吞吐量计时器</a></li>
<li>
<a href="#Synchronizing_Timer">同步计时器</a></li>
<li>
<a href="#BeanShell_Timer">BeanShell计时器</a></li>
<li>
<a href="#JSR223_Timer">JSR223计时器</a></li>
<li>
<a href="#Poisson_Random_Timer">泊松随机计时器</a></li>
</ul>
<li><a href="#preprocessors">18.7预处理器</a></li>
<ul>
<li>
<a href="#HTML_Link_Parser">HTML链接解析器</a></li>
<li>
<a href="#HTTP_URL_Re-writing_Modifier">HTTP URL重写修饰符</a></li>
<li>
<a href="#User_Parameters">用户参数</a></li>
<li>
<a href="#BeanShell_PreProcessor">BeanShell预处理器</a></li>
<li>
<a href="#JSR223_PreProcessor">JSR223预处理器</a></li>
<li>
<a href="#JDBC_PreProcessor">JDBC预处理器</a></li>
<li>
<a href="#RegEx_User_Parameters">RegEx用户参数</a></li>
<li>
<a href="#Sample_Timeout">样品超时</a></li>
</ul>
<li><a href="#postprocessors">18.8后处理器</a></li>
<ul>
<li>
<a href="#Regular_Expression_Extractor">正则表达式提取器</a></li>
<li>
<a href="#CSS_Selector_Extractor">CSS选择器提取器（以前是：CSS / JQuery提取器）</a></li>
<li>
<a href="#XPath2_Extractor">XPath2提取器</a></li>
<li>
<a href="#XPath_Extractor">XPath提取器</a></li>
<li>
<a href="#JSON_JMESPath_Extractor">JSON JMESPath提取器</a></li>
<li>
<a href="#Result_Status_Action_Handler">结果状态动作处理程序</a></li>
<li>
<a href="#BeanShell_PostProcessor">BeanShell后处理器</a></li>
<li>
<a href="#JSR223_PostProcessor">JSR223后处理器</a></li>
<li>
<a href="#JDBC_PostProcessor">JDBC后处理器</a></li>
<li>
<a href="#JSON_Extractor">JSON提取器</a></li>
<li>
<a href="#Boundary_Extractor">边界提取器</a></li>
</ul>
<li><a href="#Miscellaneous_Features">18.9其他功能</a></li>
<ul>
<li>
<a href="#Test_Plan">测试计划</a></li>
<li>
<a href="#Thread_Group">线程组</a></li>
<li>
<a href="#WorkBench">工作台</a></li>
<li>
<a href="#SSL_Manager">SSL管理器</a></li>
<li>
<a href="#HTTP(S)_Test_Script_Recorder">HTTP（S）测试脚本记录器（以前是：HTTP代理服务器）</a></li>
<li>
<a href="#HTTP_Mirror_Server">HTTP镜像服务器</a></li>
<li>
<a href="#Property_Display">物业展示</a></li>
<li>
<a href="#Debug_Sampler">调试采样器</a></li>
<li>
<a href="#Debug_PostProcessor">调试后处理器</a></li>
<li>
<a href="#Test_Fragment">测试片段</a></li>
<li>
<a href="#setUp_Thread_Group">设置线程组</a></li>
<li>
<a href="#tearDown_Thread_Group">拆线组</a></li>
</ul>
</ul>
</td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="introduction"><strong>18引言</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
<p>

</p>
 <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>几个测试元素使用JMeter属性来控制其行为。这些属性通常在加载类时解析。这通常在测试计划开始之前发生，因此无法通过使用<tt class="code"><a href="../usermanual/functions.html#__setProperty">__setProperty（）</a></tt>函数来更改设置。
</td></tr>
</tbody></table>
<p></p>

<p>
</p>
</div>
</blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="samplers"><strong>18.1采样器</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <p>采样器执行JMeter的实际工作。每个采样器（“ <a href="../usermanual/component_reference.html#Flow_Control_Action">流量控制操作”</a>除外）都会生成一个或多个采样结果。样本结果具有各种属性（成功/失败，经过的时间，数据大小等），并且可以在各种侦听器中查看。
    </p>
</div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="FTP_Request">18.1.1 FTP请求</a>
</h3>
</font>
</td></tr>
<tr><td>通过此控制器，您可以将FTP“检索文件”或“上传文件”请求发送到FTP服务器。如果要将多个请求发送到同一FTP服务器，请考虑使用“ <a href="../usermanual/component_reference.html#FTP_Request_Defaults">FTP请求默认值”</a>配置元素，这样就不必为每个FTP请求生成控制器输入相同的信息。下载文件时，可以将其存储在磁盘（本地文件）或响应数据中，或同时存储在两者中。
<p>延迟设置为登录所需的时间。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="911" height="274" src="../images/screenshots/ftptest/ftp-request.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器名称或IP</td>
<td>FTP服务器的域名或IP地址。</td>
<td>是</td>
</tr>
<tr>
<td>港口</td>
<td>使用的端口。如果<tt class="code">> 0</tt> ，则使用此特定端口，否则JMeter使用默认FTP端口。</td>
<td>没有</td>
</tr>
<tr>
<td>远程文件：</td>
<td>要检索的文件或要上传的目标文件的名称。</td>
<td>是</td>
</tr>
<tr>
<td>本地文件：</td>
<td>要上传的文件或下载的目的地（默认为远程文件名）。</td>
<td>是的，如果上传（*）</td>
</tr>
<tr>
<td>本地文件内容：</td>
<td>提供上载的内容，覆盖“本地文件”属性。</td>
<td>是的，如果上传（*）</td>
</tr>
<tr>
<td>get（RETR）/ put（STOR）</td>
<td>是检索还是上传文件。</td>
<td>是</td>
</tr>
<tr>
<td>使用二进制模式？</td>
<td>选中此项以使用二进制模式（默认ASCII）</td>
<td>是</td>
</tr>
<tr>
<td>保存文件以响应？</td>
<td>是否在响应数据中存储检索到的文件的内容。如果模式是ASCII，则内容将在“ <a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树”中</a>可见。
        </td>
<td>是的，如果下载</td>
</tr>
<tr>
<td>用户名</td>
<td>FTP帐户的用户名。</td>
<td>通常</td>
</tr>
<tr>
<td>密码</td>
<td>FTP帐号密码。注意：这将在测试计划中可见。</td>
<td>通常</td>
</tr>
</tbody></table>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="test_plan.html#assertions">断言</a></li>
<li><a href="../usermanual/component_reference.html#FTP_Request_Defaults">FTP请求默认值</a></li>
<li><a href="build-ftp-test-plan.html">建立FTP测试计划</a></li>
</ul>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_Request">18.1.2 HTTP请求</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>该采样器使您可以将HTTP / HTTPS请求发送到Web服务器。它还使您可以控制JMeter是否解析图像和其他嵌入式资源的HTML文件并发送HTTP请求以检索它们。检索以下类型的嵌入式资源：</p>
        <ul>
        <li>图片</li>
        <li>小程序</li>
        <li>样式表（CSS）和从这些文件引用的资源</li>
        <li>外部脚本</li>
        <li>框架，iframe</li>
        <li>背景图像（车身，桌子，TD，TR）</li>
        <li>背景声音</li>
        </ul>
        <p>默认解析器是<tt class="code">org.apache.jmeter.protocol.http.parser。LagartoBasedHtmlParser</tt> 。可以使用属性“ <tt class="code">htmlparser.className</tt> ”更改此设置-有关详细信息，请参见<tt class="code">jmeter.properties</tt> 。
        </p>
        <p>如果要将多个请求发送到同一Web服务器，请考虑使用<a href="../usermanual/component_reference.html#HTTP_Request_Defaults">HTTP请求默认值</a>配置元素，这样就不必为每个HTTP请求输入相同的信息。</p>

        <p>或者，您可能希望使用JMeter的<a href="../usermanual/component_reference.html#HTTP(S)_Test_Script_Recorder">HTTP（S）测试脚本记录器</a>来创建它们，而不是手动添加HTTP请求。如果您有许多HTTP请求或带有许多参数的请求，则可以节省您的时间。</p>

        <p><b>有两种不同的测试元素用于定义采样器：</b></p>
        <dl>
        <dt>AJP / 1.3采样器</dt><dd>使用Tomcat mod_jk协议（允许在AJP模式下测试Tomcat，而无需Apache httpd）AJP Sampler不支持多个文件上传；仅使用第一个文件。
        </dd>
        <dt>HTTP请求</dt><dd>这有一个实现下拉框，用于选择要使用的HTTP协议实现：<dl>
            <dt><tt class="code">爪哇</tt></dt><dd>使用JVM提供的HTTP实现。与HttpClient实现相比，这有一些限制-参见下文。</dd>
            <dt><tt class="code">HTTP客户端4</tt></dt><dd>使用Apache HttpComponents HttpClient4.x。</dd>
            <dt>空白值</dt><dd>不设置执行关于HTTP取样器，所以依赖于<tt class="code">jmeter.properties</tt>定义HTTP请求默认值（如果存在）或上<tt class="code">jmeter.httpsampler</tt>属性</dd>
          </dl>
        </dd>
        </dl>
         <p>Java HTTP实现具有一些限制：</p>
         <ul>
         <li>无法控制如何重新使用连接。JMeter释放连接后，同一线程可能会或可能不会重新使用该连接。</li>
         <li>该API最适合单线程使用-各种设置是通过系统属性定义的，因此适用于所有连接。</li>
         <li>不支持Kerberos身份验证</li>
         <li>它不支持使用Keystore Config进行基于客户端的证书测试。</li>
         <li>更好地控制重试机制</li>
         <li>它不支持虚拟主机。</li>
         <li>它仅支持以下方法： <tt class="code">GET</tt> ， <tt class="code">POST</tt> ， <tt class="code">HEAD</tt> ， <tt class="code">OPTIONS</tt> ， <tt class="code">PUT</tt> ， <tt class="code">DELETE</tt>和<tt class="code">TRACE</tt></li>
         <li>使用<a href="../usermanual/component_reference.html#DNS_Cache_Manager">DNS缓存管理器</a>更好地控制DNS缓存</li>
         </ul>
         <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意： <tt class="code">FILE</tt>协议仅用于测试目的。不管使用哪个HTTP Sampler，都由相同的代码处理。</td></tr>
</tbody></table>
<p></p>

        <p>如果请求需要服务器或代理登录授权（即浏览器将在其中创建弹出对话框的位置），则还必须添加<a href="../usermanual/component_reference.html#HTTP_Authorization_Manager">HTTP授权管理器</a>配置元素。对于普通登录（即用户在表单中输入登录信息的位置），您将需要确定表单提交按钮的作用，并使用适当的方法（通常为<tt class="code">POST</tt> ）和表单定义中的适当参数创建HTTP请求。 。如果页面使用HTTP，则可以使用JMeter代理捕获登录序列。
        </p>
        <p>每个线程使用一个单独的SSL上下文。如果要使用单个SSL上下文（不是浏览器的标准行为），请设置JMeter属性：</p>
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
https.sessioncontext.shared=true
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>默认情况下，从5.0版开始，在线程组迭代期间将保留SSL上下文，并在每次测试迭代时将其重置。如果在您的测试计划中同一用户多次迭代，则应将其设置为false。
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
httpclient.reset_state_on_thread_group_iteration=true
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：这不适用于Java HTTP实现。
        </td></tr>
</tbody></table>
<p></p>JMeter默认为SSL协议级别TLS。如果服务器需要其他级别，例如<tt class="code">SSLv3</tt> ，则更改JMeter属性，例如：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
https.default.protocol=SSLv3
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

        <p>JMeter还允许通过更改属性<tt class="code">https.socket.protocols</tt>来启用其他协议。
        </p>
        <p>如果请求使用cookie，那么您还将需要<a href="../usermanual/component_reference.html#HTTP_Cookie_Manager">HTTP cookie Manager</a> 。您可以将这些元素之一添加到线程组或HTTP请求中。如果您有多个需要授权或cookie的HTTP请求，则将元素添加到线程组中。这样，所有HTTP请求控制器将共享相同的授权管理器和Cookie管理器元素。</p>

        <p>如果请求使用称为“ URL重写”的技术来维护会话，则请参阅<a href="build-adv-web-test-plan.html#session_url_rewriting">6.1通过URL重写处理用户会话以</a>获取其他配置步骤。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="953" height="611" src="../images/screenshots/http-request.png"></div>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="951" height="284" src="../images/screenshots/http-request-advanced-tab.png"><br>
<font size="-1">HTTP请求高级配置字段</font></td></tr></tbody></table>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器</td>
<td>Web服务器的域名或IP地址，例如<tt class="code">www.example.com</tt> 。[不包含<tt class="code">http：//</tt>前缀。]注意：如果在标题管理器中定义了“ <tt class="code">主机</tt> ”标题，则它将用作虚拟主机名。
             <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>服务器是必需的，除非：<ul>
                <li>由<a href="../usermanual/component_reference.html#HTTP_Request_Defaults">HTTP请求默认值提供</a></li>
                <li>或在“ <b>路径”</b>字段中设置了包含方案，主机和端口的完整URL（ <tt class="code">scheme：// host：port</tt> ）</li>
              </ul>
             </td></tr>
</tbody></table>
<p></p>

        </td>
<td>没有</td>
</tr>
<tr>
<td>港口</td>
<td>Web服务器正在侦听的端口。默认值： <tt class="code">80</tt></td>
<td>没有</td>
</tr>
<tr>
<td>连接超时</td>
<td>连接超时。等待连接打开的毫秒数。</td>
<td>没有</td>
</tr>
<tr>
<td>响应超时</td>
<td>响应超时。等待响应的毫秒数。请注意，这适用于每次等待响应。如果服务器响应以多个块的形式发送，则总的经过时间可能比超时时间长。
        <p><a href="../usermanual/component_reference.html#Duration_Assertion">持续时间断言</a>可以用于检测花费太长时间才能完成的响应。</p>
        </td>
<td>没有</td>
</tr>
<tr>
<td>服务器（代理）</td>
<td>代理服务器执行请求的主机名或IP地址。 [不要包含<tt class="code">http：//</tt>前缀。]</td>
<td>没有</td>
</tr>
<tr>
<td>港口</td>
<td>代理服务器正在侦听的端口。</td>
<td>否，除非指定了代理主机名</td>
</tr>
<tr>
<td>用户名</td>
<td>（可选）代理服务器的用户名。</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>（可选）代理服务器的密码。（注意，这未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
<tr>
<td>实作</td>
<td><tt class="code">Java的</tt> <tt class="code">HttpClient4</tt> 。如果未指定（并且未由HTTP Request Defaults定义），则默认值取决于JMeter属性<tt class="code">jmeter.httpsampler</tt>的值，否则，将使用HttpClient4实现。</td>
<td>没有</td>
</tr>
<tr>
<td>协议</td>
<td><tt class="code">HTTP</tt> ， <tt class="code">HTTPS</tt>或<tt class="code">FILE</tt> 。默认值： <tt class="code">HTTP</tt></td>
<td>没有</td>
</tr>
<tr>
<td>方法</td>
<td><tt class="code">GET</tt> ， <tt class="code">POST</tt> ， <tt class="code">HEAD</tt> ， <tt class="code">TRACE</tt> ， <tt class="code">OPTIONS</tt> ， <tt class="code">PUT</tt> ， <tt class="code">DELETE</tt> ， <tt class="code">PATCH</tt> （ <tt class="code">JAVA</tt>实现不支持）。使用<tt class="code">HttpClient4</tt> ，还允许以下与WebDav相关的方法： <tt class="code">COPY</tt> ， <tt class="code">LOCK</tt> ， <tt class="code">MKCOL</tt> ， <tt class="code">MOVE</tt> ， <tt class="code">PROPFIND</tt> ， <tt class="code">PROPPATCH</tt> ， <tt class="code">UNLOCK</tt> ， <tt class="code">REPORT</tt> ， <tt class="code">MKCALENDAR</tt> ， <tt class="code">SEARCH</tt> 。<p>可以使用JMeter属性<tt class="code">httpsampler.user_defined_methods</tt>为HttpClient4预定义更多方法。</p>
        </td>
<td>是</td>
</tr>
<tr>
<td>内容编码</td>
<td>要使用的内容编码（用于<tt class="code">POST</tt> ， <tt class="code">PUT</tt> ， <tt class="code">PATCH</tt>和<tt class="code">FILE</tt> ）。这是要使用的字符编码，与Content-Encoding HTTP标头无关。
        </td>
<td>没有</td>
</tr>
<tr>
<td>自动重定向</td>
<td>将基础的http协议处理程序设置为自动跟随重定向，以便JMeter无法看到它们，因此不会显示为示例。仅应用于<tt class="code">GET</tt>和<tt class="code">HEAD</tt>请求。HttpClient采样器将拒绝将其用于<tt class="code">POST</tt>或<tt class="code">PUT的</tt>尝试。<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>警告：有关Cookie和标头处理的信息，请参见下文。</td></tr>
</tbody></table>
<p></p>

        </td>
<td>没有</td>
</tr>
<tr>
<td>跟随重定向</td>
<td>仅当未启用“ <tt class="code">自动重定向</tt> ”时，此选项才有效。如果已设置，JMeter采样器将检查响应是否为重定向，如果是，则进行跟踪。初始重定向和其他响应将作为其他示例出现。父样本的URL和数据字段将从最终（非重定向）样本中获取，但是父字节计数和经过时间包括所有样本。等待时间取自初始响应。请注意，HttpClient采样器可能会记录以下消息：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>&quot;Redirect requested but followRedirects is disabled&quot;</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>这可以忽略。
        <br>JMeter会在绝对和相对重定向URL中折叠形式为' <tt class="code">/../segment</tt> '的路径。例如， <tt class="code">http：//host/one/../two</tt>将折叠为<tt class="code">http：// host / two</tt> 。如有必要，可以通过设置JMeter属性<tt class="code">httpsampler.redirect.removeslashdotdot = false</tt>来抑制此行为。
        </td>
<td>没有</td>
</tr>
<tr>
<td>使用KeepAlive</td>
<td>JMeter设置Connection： <tt class="code">keep-alive</tt>标头。这在默认的HTTP实现中无法正常使用，因为连接的重用不受用户控制。它与Apache HttpComponents HttpClient实现一起使用。</td>
<td>没有</td>
</tr>
<tr>
<td>使用multipart / form-data进行HTTP POST</td>
<td>使用<tt class="code">multipart / form-data</tt>或<tt class="code">application / x-www-form-urlencoded</tt>发布请求</td>
<td>没有</td>
</tr>
<tr>
<td>浏览器兼容的标题</td>
<td>当使用<tt class="code">multipart / form-data时</tt> ，这会抑制<tt class="code">Content-Type</tt>和<tt class="code">Content-Transfer-Encoding</tt>标头；仅发送<tt class="code">Content-Disposition</tt>标头。
        </td>
<td>没有</td>
</tr>
<tr>
<td>路径</td>
<td>资源的路径（例如<tt class="code">/ servlets / myServlet</tt> ）。如果资源需要查询字符串参数，请在下面的“随请求发送参数”部分中添加它们。
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>作为特殊情况，如果路径以“ <tt class="code">http：//</tt> ”或“ <tt class="code">https：//</tt> ”开头，则将其用作完整的URL。</td></tr>
</tbody></table>
<p></p>在这种情况下，服务器，端口和协议字段将被忽略； <tt class="code">GET</tt>和<tt class="code">DELETE</tt>方法的参数也将被忽略。还请注意，除了使用<tt class="code">％20</tt>替换空格以外，该路径未进行编码，因此可能需要对不安全的字符进行编码，以避免出现<tt class="code">URISyntaxException之类的</tt>错误。
</td>
<td>没有</td>
</tr>
<tr>
<td>与请求一起发送参数</td>
<td>查询字符串将从您提供的参数列表中生成。每个参数都有一个<tt class="code">名称</tt>和<tt class="code">值</tt> ，编码该参数的选项以及一个包含或排除等号的选项（某些应用程序在值是空字符串时不希望有等号）。查询字符串将以正确的方式生成，具体取决于您对“方法”的选择（即，如果选择<tt class="code">GET</tt>或<tt class="code">DELETE</tt> ，则查询字符串将附加到URL，如果是<tt class="code">POST</tt>或<tt class="code">PUT</tt> ，则将其发送分别）。另外，如果您要使用多部分表单发送文件，则查询字符串将使用多部分表单规范创建。
        <b>有关参数处理的更多信息，请参见下文。</b>
        <p>此外，您可以指定每个参数是否应进行URL编码。如果不确定这意味着什么，最好选择它。如果您的值包含以下字符，则通常需要编码：</p>
        <ul>
            <li>ASCII控制字符</li>
            <li>非ASCII字符</li>
            <li>保留字符：URL使用一些特殊字符来定义其语法。当这些字符未在URL中以其特殊角色使用时，需要对其进行编码，例如：' <tt class="code">$</tt> '，' <tt class="code">＆</tt> '，' <tt class="code">+</tt> '，' <tt class="code">，</tt> '，' <tt class="code">/</tt> '，' <tt class="code">：</tt> '，' <tt class="code">;</tt> '，' <tt class="code">=</tt> '，' <tt class="code">？</tt>'，' <tt class="code">@</tt> '</li>
            <li>不安全的字符：出于各种原因，某些字符可能会在URL中被误解。这些字符也应始终进行编码，例如：' <tt class="code"> </tt> '，' <tt class="code"><</tt> '，' <tt class="code">></tt> '，' <tt class="code">＃</tt> '，' <tt class="code">％</tt> '，…</li>
        </ul>
        </td>
<td>没有</td>
</tr>
<tr>
<td>文件路径：</td>
<td>要发送的文件名。如果保留为空白，则JMeter不发送文件，如果填写，则JMeter自动将请求作为多部分表单请求发送。<p>如果是<tt class="code">POST</tt>或<tt class="code">PUT</tt>或<tt class="code">PATCH</tt>请求，并且有一个文件的“参数名称”属性（以下）被忽略，则该文件将作为请求的整个主体发送，即不添加包装器。这允许发送任意主体。<tt class="code">POST</tt>请求以及<tt class="code">PUT</tt>请求都具有此功能。
        <b>有关参数处理的更多信息，请参见下文。</b>
        </p>
        </td>
<td>没有</td>
</tr>
<tr>
<td>参数名称：</td>
<td>Web请求参数“ <tt class="code">name</tt> ”的值。</td>
<td>没有</td>
</tr>
<tr>
<td>MIME类型</td>
<td>MIME类型（例如<tt class="code">text / plain</tt> ）。如果它是<tt class="code">POST</tt>或<tt class="code">PUT</tt>或<tt class="code">PATCH</tt>请求，并且省略了' <tt class="code">name</tt> '属性（如下），或者仅由参数值构造了请求主体，则此字段的值将用作<tt class="code">内容类型</tt>请求的值标头。
        </td>
<td>没有</td>
</tr>
<tr>
<td>从HTML文件检索所有嵌入式资源</td>
<td>告诉JMeter解析HTML文件并发送文件中引用的所有图像，Java applet，JavaScript文件，CSS等的HTTP / HTTPS请求。请参阅下面的更多细节。
        </td>
<td>没有</td>
</tr>
<tr>
<td>将响应另存为MD5哈希吗？</td>
<td>如果选择此选项，则响应不会存储在样本结果中。相反，将计算并存储数据的32个字符的MD5哈希。这旨在测试大量数据。
       </td>
<td>没有</td>
</tr>
<tr>
<td>嵌入式URL必须匹配：</td>
<td>如果存在，则它必须是用于与找到的任何嵌入式URL匹配的正则表达式。因此，如果您只想从<tt class="code">http://example.com/</tt>下载嵌入式资源，请使用表达式： <tt class="code">http：// example \ .com /。*</tt>
        </td>
<td>没有</td>
</tr>
<tr>
<td>使用并发池</td>
<td>使用并发连接池来获取嵌入式资源。</td>
<td>没有</td>
</tr>
<tr>
<td>尺寸</td>
<td>用于获取嵌入式资源的并发连接的池大小。</td>
<td>没有</td>
</tr>
<tr>
<td>源地址类型</td>
<td>
        <i>[仅适用于带有HTTPClient实现的HTTP请求]</i> <br>要区分源地址值，请选择以下类型：<ul>
        <li>选择<i>IP /主机名</i>以使用特定的IP地址或（本地）主机名</li>
        <li>选择<i>设备</i>以选择该接口的第一个可用地址，该地址可以是IPv4或IPv6</li>
        <li>选择<i>设备IPv4</i>以选择设备名称的IPv4地址（例如<tt class="code">eth0</tt> ， <tt class="code">lo</tt> ， <tt class="code">em0</tt>等）</li>
        <li>选择<i>设备IPv6</i>以选择设备名称的IPv6地址（例如<tt class="code">eth0</tt> ， <tt class="code">lo</tt> ， <tt class="code">em0</tt>等）</li>
        </ul>
        </td>
<td>没有</td>
</tr>
<tr>
<td>源地址字段</td>
<td>
        <i>[仅适用于带有HTTPClient实现的HTTP请求]</i> <br>此属性用于启用IP欺骗。它会覆盖此示例的默认本地IP地址。JMeter主机必须具有多个IP地址（即IP别名，网络接口，设备）。该值可以是主机名，IP地址或网络接口设备，例如“ <tt class="code">eth0</tt> ”或“ <tt class="code">lo</tt> ”或“ <tt class="code">wlan0</tt> ”。<br>如果定义了属性<tt class="code">httpclient.localaddress，</tt>则该属性用于所有HttpClient请求。
        </td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>使用自动重定向时，仅针对初始URL发送cookie。这可能会导致重定向到本地服务器的网站出现意外行为。例如，如果<tt class="code">www.example.com</tt>重定向到<tt class="code">www.example.co.uk</tt> 。在这种情况下，服务器可能会返回两个URL的cookie，但是JMeter将仅看到最后一个主机（即<tt class="code">www.example.co.uk）</tt>的cookie。如果测试计划中的下一个请求使用<tt class="code">www.example.com</tt>而不是<tt class="code">www.example.co.uk</tt> ，它将不会获得正确的cookie。同样，将为初始请求发送标头，而不会为重定向发送标头。对于手动创建的测试计划，这通常只是一个问题，因为使用记录器创建的测试计划将从重定向的URL继续。</td></tr>
</tbody></table>
<p></p>
<p>
<b>参数处理：</b><br>对于<tt class="code">POST</tt>和<tt class="code">PUT</tt>方法，如果没有要发送的文件，并且省略了参数的名称，则通过串联所有参数值来创建主体。请注意，这些值是串联在一起的，没有添加任何行尾字符。这些可以通过在值字段中使用<tt class="code"><a href="../usermanual/functions.html#__char">__char（）</a></tt>函数添加。这允许发送任意主体。如果设置了编码标志，则对值进行编码。另请参见上面的MIME类型，您如何控制发送的<tt class="code">内容类型</tt>请求标头。
<br>对于其他方法，如果缺少参数名称，则忽略该参数。这允许使用由变量定义的可选参数。
</p><br>
<p>当请求仅包含未命名的参数（或根本没有参数）时，您可以选择切换到“ <tt class="code">正文数据”</tt>选项卡。此选项在以下情况下（以及其他情况）很有用：</p><ul>
<li>GWT RPC HTTP请求</li>
<li>JSON REST HTTP请求</li>
<li>XML REST HTTP请求</li>
<li>SOAP HTTP请求</li>
</ul><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，离开“树”节点后，除非从其数据中清除“ <tt class="code">主体数据”</tt>选项卡，否则无法切换回参数选项卡。
</td></tr>
</tbody></table>
<p></p>
<p>在“ <tt class="code">正文数据”</tt>模式下，除了最后一行之外，每行都将附加<tt class="code">CRLF</tt>发送。要在最后一行数据之后发送<tt class="code">CRLF</tt> ，只需确保紧随其后的是空行。（除非注意是否可以将光标放在下一行上，否则无法看到此内容。）
</p><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="902" height="421" src="../images/screenshots/http-request-raw-single-parameter.png"><br>
<font size="-1">图1-具有一个未命名参数的HTTP请求</font></td></tr></tbody></table>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="908" height="212" src="../images/screenshots/http-request-confirm-raw-body.png"><br>
<font size="-1">图2-确认对话框切换</font></td></tr></tbody></table>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="905" height="423" src="../images/screenshots/http-request-raw-body.png"><br>
<font size="-1">图3-使用正文数据的HTTP请求</font></td></tr></tbody></table>
<p>
<b>方法处理：</b><br><tt class="code">GET</tt> ， <tt class="code">DELETE</tt> ， <tt class="code">POST</tt> ， <tt class="code">PUT</tt>和<tt class="code">PATCH</tt>请求方法的工作原理相似，但从3.1版本开始，仅<tt class="code">POST</tt>方法支持分段请求或文件上传。必须以下列方式之一提供<tt class="code">PUT</tt>和<tt class="code">PATCH</tt>方法主体：</p><ul>
<li>将主体定义为带有空“参数名称”字段的文件；在这种情况下，MIME类型用作内容类型</li>
<li>将主体定义为没有名称的参数值</li>
<li>使用“ <tt class="code">身体数据”</tt>选项卡</li>
</ul><p><tt class="code">GET</tt> ， <tt class="code">DELETE</tt>和<tt class="code">POST</tt>方法还有一种通过使用<tt class="code">Parameters</tt>选项卡传递参数的方式。
<tt class="code">GET</tt> ， <tt class="code">DELETE</tt> ， <tt class="code">PUT</tt>和<tt class="code">PATCH</tt>需要Content-Type。如果不使用文件，则将Header Manager附加到采样器并在其中定义Content-Type。
</p><p>JMeter扫描来自嵌入式资源的响应。它使用属性<tt class="code">HTTPResponse.parsers</tt> ，该属性是解析器ID的列表，例如<tt class="code">htmlParser</tt> ， <tt class="code">cssParser</tt>和<tt class="code">wmlParser</tt> 。对于找到的每个ID，JMeter都会检查另外两个属性：</p><ul>
 <li><tt class="code">id.types-</tt>内容类型列表</li>
 <li><tt class="code">id.className-</tt>用于提取嵌入式资源的解析器</li>
 </ul><p>有关设置的详细信息，请参见<tt class="code">jmeter.properties</tt>文件。如果未设置<tt class="code">HTTPResponse.parser</tt>属性，则JMeter会恢复为以前的行为，即仅扫描<tt class="code">text / html</tt>响应</p><b>模拟慢速连接：</b><br>
<p>
<tt class="code">HttpClient4</tt>和<tt class="code">Java</tt> Sampler支持慢速连接的仿真。请参阅<tt class="code">jmeter.properties中</tt>的以下条目：</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
# Define characters per second &gt; 0 to emulate slow connections
#httpclient.socket.http.cps=0
#httpclient.socket.https.cps=0
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>但是， <tt class="code">Java</tt>采样器仅支持慢速HTTPS连接。
<p></p><p><b>响应大小计算</b><br>


</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td><tt class="code">Java</tt>实现不包括传输开销，例如响应主体大小中的块头。<br><tt class="code">HttpClient4</tt>实现的确包含了响应主体大小中的开销，因此该值可能大于响应内容中的字节数。
</td></tr>
</tbody></table>
<p></p>

<p></p><p>
<b>重试处理</b><br>默认情况下，对于HttpClient4和Java实现，重试都设置为0，这意味着不尝试重试。<br>对于HttpClient4，可以通过设置相关的JMeter属性来覆盖重试计数，例如：</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
httpclient4.retrycount=3
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>使用HC4实施时，默认情况下将对等幂Http方法进行重试。如果要重试所有方法，请设置属性<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
httpclient4.request_sent_retry_enabled=true
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</td></tr>
</tbody></table>
<p></p>请注意，Java实现默认情况下都不重试，您可以通过设置<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>http.java.sampler.retries=3</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<p></p><p>
<b>注意：证书不符合算法约束</b><br>您可能会遇到以下错误： <tt class="code">java.security.cert。CertificateException：</tt>如果您在具有SSL证书（本身或信任链中的SSL证书之一），使用MD2的签名算法（例如<tt class="code">md2WithRSAEncryption</tt> ）或SSL的网站上运行HTTPS请求，则证书不符合算法约束小于1024位的证书。
</p><p>此错误与Java 8中提高的安全性有关。
</p><p>为了允许您执行HTTPS请求，您可以通过编辑Java <tt class="code">jdk.certpath.disabledAlgorithms</tt>属性来降低Java安装的安全性。根据具体情况，删除MD2值或大小限制。
</p><p>此属性在此文件中：</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>JAVA_HOME/jre/lib/security/java.security</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>有关详细信息，请参见<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=56357">错误56357</a> 。
</p><p><b>也可以看看：</b></p>
<ul>
<li><a href="test_plan.html#assertions">断言</a></li>
<li><a href="build-web-test-plan.html">制定网络测试计划</a></li>
<li><a href="build-adv-web-test-plan.html">建立高级Web测试计划</a></li>
<li><a href="../usermanual/component_reference.html#HTTP_Authorization_Manager">HTTP授权管理器</a></li>
<li><a href="../usermanual/component_reference.html#HTTP_Cookie_Manager">HTTP Cookie管理器</a></li>
<li><a href="../usermanual/component_reference.html#HTTP_Header_Manager">HTTP标头管理器</a></li>
<li><a href="../usermanual/component_reference.html#HTML_Link_Parser">HTML链接解析器</a></li>
<li><a href="../usermanual/component_reference.html#HTTP(S)_Test_Script_Recorder">HTTP（S）测试脚本记录器</a></li>
<li><a href="../usermanual/component_reference.html#HTTP_Request_Defaults">HTTP请求默认值</a></li>
<li><a href="build-adv-web-test-plan.html#session_url_rewriting">HTTP请求和会话ID：URL重写</a></li>
</ul>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JDBC_Request">18.1.3 JDBC请求</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该采样器使您可以将JDBC请求（SQL查询）发送到数据库。</p>
<p>在使用此功能之前，您需要设置一个<a href="../usermanual/component_reference.html#JDBC_Connection_Configuration">JDBC连接配置</a>配置元素</p>
<p>如果提供了“变量名”列表，则对于Select语句返回的每一行，将使用相应列的值（如果提供了变量名）来设置变量，并且还设置行数。例如，如果Select语句返回2行3列，并且变量列表为<tt class="code">A ,, C</tt> ，则将设置以下变量：</p>
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
A_#=2 (number of rows)
A_1=column 1, row 1
A_2=column 1, row 2
C_#=2 (number of rows)
C_1=column 3, row 1
C_2=column 3, row 2
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<p>如果Select语句返回零行，则将<tt class="code">A_＃</tt>和<tt class="code">C_＃</tt>变量设置为<tt class="code">0</tt> ，并且不设置其他变量。
</p>
<p>如有必要，清除旧变量-例如，如果第一个选择检索六行，而第二个选择仅返回三行，则将删除第四，第五和第六行的其他变量。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>延迟时间从获取连接所花费的时间开始设置。</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="710" height="629" src="../images/screenshots/jdbctest/jdbc-request.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>在JDBC连接配置中声明的池的变量名称</td>
<td>连接池绑定到的JMeter变量的名称。这必须与<a href="../usermanual/component_reference.html#JDBC_Connection_Configuration">JDBC连接配置</a>的“ <tt class="code">变量名</tt> ”字段一致。
        </td>
<td>是</td>
</tr>
<tr>
<td>查询类型</td>
<td>根据语句类型进行设置：<ul>
            <li>选择声明</li>
            <li>更新声明-也可用于插入和删除</li>
            <li>可赎回声明</li>
            <li>准备好的选择声明</li>
            <li>准备好的更新语句-也可用于插入和删除</li>
            <li>承诺</li>
            <li>回滚</li>
            <li>自动提交（false）</li>
            <li>自动提交（true）</li>
            <li>编辑-这应该是一个变量引用，其计算结果为上述之一</li>
            </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>SQL查询</td>
<td>SQL查询。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请勿输入结尾的分号。</td></tr>
</tbody></table>
<p></p>通常不需要使用<tt class="code">{</tt>和<tt class="code">}</tt>来包含Callable语句。但是，如果数据库使用非标准语法，则可以使用它们。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>当语句包含在<tt class="code">{}中</tt>时，JDBC驱动程序会根据需要自动转换该语句。</td></tr>
</tbody></table>
<p></p>例如：<ul>
        <li><tt class="code">从t_customers中选择*，其中id = 23</tt></li>
        <li><tt class="code">呼叫SYSCS_UTIL.SYSCS_EXPORT_TABLE（null，？，？，null，null，null）</tt>
        <ul>
        <li>参数值： <tt class="code">tablename</tt> ， <tt class="code">filename</tt></li>
        <li>参数类型： <tt class="code">VARCHAR</tt> ， <tt class="code">VARCHAR</tt></li>
        </ul>
        </li>
        </ul>第二个示例假定您正在使用Apache Derby。
        </td>
<td>是</td>
</tr>
<tr>
<td>参数值</td>
<td>以逗号分隔的参数值列表。使用<tt class="code">] NULL [</tt>表示<tt class="code">NULL</tt>参数。（如果需要，可以通过定义属性“ <tt class="code">jdbcsampler.nullmarker</tt> ”来更改空字符串。）
        <br>如果任何值包含逗号或双引号，则列表必须用双引号引起来，并且任何嵌入的双引号都必须加倍，例如：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>&quot;Dbl-Quote: &quot;&quot; and Comma: ,&quot;</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>即使您的参数是<tt class="code">OUT</tt>参数，该值也必须与语句中的占位符一样多。即使不使用该值，也请务必设置一个值（例如在CallableStatement中）。</td></tr>
</tbody></table>
<p></p>

        </td>
<td>是，如果一个准备好的或可调用的语句具有参数</td>
</tr>
<tr>
<td>参数类型</td>
<td>SQL参数类型（例如<tt class="code">INTEGER</tt> ， <tt class="code">DATE</tt> ， <tt class="code">VARCHAR</tt> ， <tt class="code">DOUBLE</tt> ）或常量的整数值的逗号分隔列表。当您使用驱动程序建议的自定义数据库类型时，可以使用这些整数值（例如， <tt class="code">OracleTypes。CURSOR</tt>可由其整数值<tt class="code">-10</tt>表示。<br>这些被定义为类<tt class="code">java.sql中的字段<tt class="code">。类型</tt> ，例如：<br>

        <a href="http://docs.oracle.com/javase/8/docs/api/java/sql/Types.html">适用于java.sql的Javadoc。类型</a> 。<br>

        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：JMeter将使用运行时JVM定义的任何类型，因此，如果您在其他JVM上运行，请确保检查相应的文档。</td></tr>
</tbody></table>
<p></p>

        <b>如果调用语句具有<tt class="code">INOUT</tt>或<tt class="code">OUT</tt>参数，那么这些必须由前缀合适的参数类型，例如，而不是“ <tt class="code">整数</tt> ”，使用<tt class="code">“INOUT INTEGER”</tt>表示。</b> <br>如果没有指定<tt class="code">，“IN”</tt>假设，即<tt class="code">“DATE”</tt>是同为<tt class="code">“DATE”。</tt>
        <br>如果类型不是<tt class="code">java.sql中的字段之一<tt class="code">。Types</tt> ，JMeter还接受相应的整数，例如，因为<tt class="code">OracleTypes。CURSOR == -10</tt> ，您可以使用“ <tt class="code">INOUT -10</tt> ”。
        <br>类型必须与语句中的占位符一样多。
        </tt></tt></td>
<td>是，如果一个准备好的或可调用的语句具有参数</td>
</tr>
<tr>
<td>变量名</td>
<td>以逗号分隔的变量名称列表，用于保存Select语句，Prepared Select语句或CallableStatement返回的值。请注意，与CallableStatement一起使用时，变量列表的顺序必须与调用返回的<tt class="code">OUT</tt>参数的顺序相同。如果变量名少于<tt class="code">OUT</tt>参数，则在线程上下文变量中应存储与提供的变量名一样多的结果。如果变量名称多于<tt class="code">OUT</tt>参数，则其他变量将被忽略</td>
<td>没有</td>
</tr>
<tr>
<td>结果变量名称</td>
<td>如果指定，这将创建一个包含行映射列表的Object变量。每个映射都包含列名称作为键，并包含列数据作为值。用法：<br>

        <div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>columnValue = vars.getObject(&quot;resultObject&quot;).get(0).get(&quot;Column Name&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

        </td>
<td>没有</td>
</tr>
<tr>
<td>查询超时</td>
<td>设置查询超时时间（秒），空值表示0，它是无限的。 <tt class="code">-1</tt>表示不设置用例或某些驱动程序不支持超时时可能需要的任何查询超时。预设为0。</td>
<td>没有</td>
</tr>
<tr>
<td>限制结果集</td>
<td>限制要遍历ResultSet的行数。空值表示<tt class="code">-1</tt> ，例如无限制，这也是默认值。这可以帮助减少要通过JDBC驱动程序从数据库中获取的数据量，但是分别影响<tt class="code">Handle ResultSet的</tt>所有可能选项-例如，不完整的ResultSet和记录数≤限制。</td>
<td>没有</td>
</tr>
<tr>
<td>处理结果集</td>
<td>定义如何处理可调用语句返回的ResultSet：<ul>
                <li><tt class="code">另存为字符串</tt> （默认）-“变量名”列表中的所有变量都存储为字符串，当列表中存在时，将不会通过<tt class="code">ResultSet</tt>进行迭代。<tt class="code">CLOB</tt>将被转换为字符串。<tt class="code">BLOB</tt>将被转换为字符串，就好像它们是UTF-8编码的字节数组一样。在<tt class="code">jdbcsampler.max_retain_result_size</tt>字节之后，将剪切<tt class="code">CLOB</tt>和<tt class="code">BLOB</tt> 。</li>
                <li><tt class="code">存储为对象</tt> -变量名称列表上<tt class="code">ResultSet</tt>类型的变量将存储为对象，并且可以在后续测试/脚本中进行访问和迭代，而不会遍历<tt class="code">ResultSet</tt> 。将<tt class="code">如同</tt>选择了“ <tt class="code">存储为字符串”</tt>一样处理<tt class="code">CLOB</tt> 。<tt class="code">BLOB</tt>将存储为字节数组。在<tt class="code">jdbcsampler.max_retain_result_size</tt>字节之后，将剪切<tt class="code">CLOB</tt>和<tt class="code">BLOB</tt> 。</li>
                <li><tt class="code">计数记录</tt> -通过将记录计数显示为结果来迭代<tt class="code">ResultSet</tt>类型的变量。变量将存储为字符串。对于<tt class="code">BLOB</tt> ，将存储对象的大小。</li>
            </ul>
        </td>
<td>没有</td>
</tr>
</tbody></table>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="build-db-test-plan.html">建立数据库测试计划</a></li>
<li><a href="../usermanual/component_reference.html#JDBC_Connection_Configuration">JDBC连接配置</a></li>
</ul>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>当前版本的JMeter使用UTF-8作为字符编码。以前使用平台默认值。</td></tr>
</tbody></table>
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>确保变量名称在测试计划中是唯一的。</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Java_Request">18.1.4 Java请求</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>使用此采样器，您可以控制实现<tt class="code">org.apache.jmeter.protocol.java.sampler的Java类<tt class="code">。JavaSamplerClient</tt>接口。通过编写自己的接口实现，您可以使用JMeter来利用多个线程，输入参数控制和数据收集。</tt></p><tt class="code">
<p>下拉菜单提供了JMeter在其类路径中找到的所有此类实现的列表。然后可以在下表中指定参数-由实现定义。提供了两个简单的示例（ <tt class="code">JavaTest</tt>和<tt class="code">SleepTest</tt> ）。
</p>
<p><tt class="code">JavaTest</tt>示例采样器可用于检查测试计划，因为它允许人们在几乎所有字段中设置值。然后可以由断言等使用它们。这些字段允许使用变量，因此可以很容易地看到它们的值。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="628" height="365" src="../images/screenshots/java_request.png"></div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果<tt class="code"><a href="../api/org/apache/jmeter/protocol/java/sampler/AbstractJavaSamplerClient.html">AbstractJavaSamplerClient</a></tt>的子类未覆盖方法<tt class="code">teardownTest，</tt>则不会调用其<tt class="code">teardownTest</tt>方法。这减少了JMeter的内存需求。这不会对现有的测试计划产生任何影响。
</td></tr>
</tbody></table>
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>目前，“添加/删除”按钮没有任何作用。</td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>班级名称</td>
<td>要采样的JavaSamplerClient接口的特定实现。</td>
<td>是</td>
</tr>
<tr>
<td>随请求发送参数</td>
<td>将传递给样本类的参数列表。所有参数均以字符串形式发送。具体设置请参见下文。</td>
<td>没有</td>
</tr>
</tbody></table>
<p>以下参数适用于<tt class="code">SleepTest</tt>和<tt class="code">JavaTest</tt>实现：</p><p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>睡觉时间</td>
<td>睡眠时间（毫秒）</td>
<td>是</td>
</tr>
<tr>
<td>睡眠面膜</td>
<td>要添加多少“随机性”：<br>睡眠时间计算如下：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>totalSleepTime = SleepTime + (System.currentTimeMillis() % SleepMask)</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

        </td>
<td>是</td>
</tr>
</tbody></table>
<p>以下参数还适用于<tt class="code">JavaTest</tt>实现：</p><p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>标签</td>
<td>要使用的标签。如果提供，则覆盖<tt class="code">名称</tt></td>
<td>没有</td>
</tr>
<tr>
<td>响应码</td>
<td>如果提供，则设置SampleResult ResponseCode。</td>
<td>没有</td>
</tr>
<tr>
<td>ResponseMessage</td>
<td>如果提供，则设置SampleResult ResponseMessage。</td>
<td>没有</td>
</tr>
<tr>
<td>状态</td>
<td>如果提供，请设置SampleResult状态。如果这等于“ <tt class="code">OK</tt> ”（忽略大小写），则状态设置为成功，否则样本被标记为失败。</td>
<td>没有</td>
</tr>
<tr>
<td>采样器数据</td>
<td>如果提供，则设置SampleResult SamplerData。</td>
<td>没有</td>
</tr>
<tr>
<td>结果数据</td>
<td>如果提供，则设置SampleResult ResultData。</td>
<td>没有</td>
</tr>
</tbody></table>
</tt></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="LDAP_Request">18.1.7 LDAP请求</a>
</h3>
</font>
</td></tr>
<tr><td>通过此采样器，您可以将不同的LDAP请求（ <tt class="code">添加</tt> ， <tt class="code">修改</tt> ， <tt class="code">删除</tt>和<tt class="code">搜索</tt> ）发送到LDAP服务器。
    <p>如果要将多个请求发送到同一LDAP服务器，请考虑使用<a href="../usermanual/component_reference.html#LDAP_Request_Defaults">LDAP请求默认值</a>配置元素，这样就不必为每个LDAP请求输入相同的信息。</p><a href="../usermanual/component_reference.html#Login_Config_Element">登录配置元素</a>也用于登录和密码的方式相同。
  <p><b>控制面板</b></p>
<div align="center"><img width="621" height="462" src="../images/screenshots/ldap_request.png"></div>
<p>有两种方法可以创建用于测试LDAP服务器的测试用例。</p><ol>
    <li>内置测试用例。</li>
    <li>用户定义的测试用例。</li>
  </ol><p>有四种测试LDAP的测试方案。测试如下：</p><ol>
    <li>添加测试<ol>
        <li>内置测试：<p>这将在LDAP服务器中添加一个预定义的条目并计算执行时间。执行测试后，创建的条目将从LDAP服务器中删除。</p>
        </li>
        <li>用户定义的测试：<p>这会将条目添加到LDAP服务器中。用户必须在表中输入所有属性。从表中收集条目以添加。计算执行时间。测试后，创建的条目将不会被删除。</p>
        </li>
      </ol>
    </li>
    <li>修改测试<ol>
        <li>内置测试：<p>这将首先创建一个预定义的条目，然后将在LDAP服务器中修改创建的条目。并计算执行时间。执行测试后，创建的条目将从LDAP服务器中删除。</p>
        </li>
        <li>用户定义的测试：<p>这将修改LDAP服务器中的条目。用户必须在表中输入所有属性。从表中收集条目以进行修改。计算执行时间。该条目不会从LDAP服务器中删除。</p>
        </li>
      </ol>
    </li>
    <li>搜索测试<ol>
        <li>内置测试：<p>这将首先创建条目，然后将搜索属性是否可用。它计算搜索查询的执行时间。执行结束时，创建的条目将从LDAP服务器中删除。</p>
        </li>
        <li>用户定义的测试：<p>这将在“搜索”基础（再次由用户定义）中搜索用户定义的条目（“搜索过滤器”）。这些条目应该在LDAP服务器中可用。计算执行时间。</p>
        </li>
      </ol>
    </li>
    <li>删除测试<ol>
        <li>内置测试：<p>这将首先创建一个预定义的条目，然后将其从LDAP服务器中删除。计算执行时间。</p>
        </li>
        <li>用户定义的测试：<p>这将删除LDAP服务器中用户定义的条目。这些条目应该在LDAP服务器中可用。计算执行时间。</p>
        </li>
      </ol>
    </li>
  </ol><p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器名称或IP</td>
<td>LDAP服务器的域名或IP地址。JMeter假定LDAP服务器正在侦听默认端口（ <tt class="code">389</tt> ）。</td>
<td>是</td>
</tr>
<tr>
<td>港口</td>
<td>要连接的端口（默认为<tt class="code">389</tt> ）。</td>
<td>是</td>
</tr>
<tr>
<td>根DN</td>
<td>用于LDAP操作的基本DN</td>
<td>是</td>
</tr>
<tr>
<td>用户名</td>
<td>LDAP服务器用户名。</td>
<td>通常</td>
</tr>
<tr>
<td>密码</td>
<td>LDAP服务器密码。（注意，这未加密存储在测试计划中）</td>
<td>通常</td>
</tr>
<tr>
<td>条目DN</td>
<td>要创建或修改的上下文的名称；可能不为空。
     <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>您必须自己设置对象的正确属性。因此，如果要添加<tt class="code">cn = apache，ou = test</tt> ，则必须在<tt class="code">cn</tt>和<tt class="code">apache中</tt>添加表<tt class="code">名称</tt>和<tt class="code">值</tt> 。
     </td></tr>
</tbody></table>
<p></p>

    </td>
<td>是，如果选择了用户定义的测试和添加测试或修改测试</td>
</tr>
<tr>
<td>删除</td>
<td>要删除的上下文的名称；可能不为空</td>
<td>是，如果选择了用户定义的测试和删除测试</td>
</tr>
<tr>
<td>搜索基地</td>
<td>要搜索的上下文或对象的名称</td>
<td>是，如果选择了用户定义的测试和搜索测试</td>
</tr>
<tr>
<td>搜索过滤器</td>
<td>用于搜索的过滤器表达式；不能为空</td>
<td>是，如果选择了用户定义的测试和搜索测试</td>
</tr>
<tr>
<td>添加测试</td>
<td>使用这些<tt class="code">名称</tt>和<tt class="code">值</tt>对在给定上下文中创建新对象</td>
<td>是，如果选择了“用户定义的测试并添加测试”</td>
</tr>
<tr>
<td>修改测试</td>
<td>使用这些<tt class="code">名称</tt>和<tt class="code">值</tt>对修改给定的上下文对象</td>
<td>是，如果选择了“用户定义的测试”和“修改测试”</td>
</tr>
</tbody></table>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="build-ldap-test-plan.html">建立LDAP测试计划</a></li>
<li><a href="../usermanual/component_reference.html#LDAP_Request_Defaults">LDAP请求默认值</a></li>
</ul>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="LDAP_Extended_Request">18.1.8 LDAP扩展请求</a>
</h3>
</font>
</td></tr>
<tr><td>该采样器可以将所有8个不同的LDAP请求发送到LDAP服务器。它是LDAP采样器的扩展版本，因此较难配置，但可以使其更接近真实的LDAP会话。
    <p>如果要将多个请求发送到同一LDAP服务器，请考虑使用<a href="../usermanual/component_reference.html#LDAP_Extended_Request_Defaults">LDAP扩展请求默认值</a>配置元素，这样就不必为每个LDAP请求输入相同的信息。</p> <p><b>控制面板</b></p>
<div align="center"><img width="619" height="371" src="../images/screenshots/ldapext_request.png"></div>
<p>定义了九种测试操作。这些操作如下：</p><dl>
      <dt><b>线程绑定</b></dt>
      <dd>
        <p>任何LDAP请求都是LDAP会话的一部分，因此应该做的第一件事是启动到LDAP服务器的会话。为了启动此会话，使用了线程绑定，该线程绑定等于LDAP的“ <tt class="code">bind</tt> ”操作。要求用户提供<tt class="code">用户名</tt> （专有名称）和<tt class="code">密码</tt> ，这将用于启动会话。如果没有密码或指定了错误的密码，则会启动匿名会话。请注意，省略密码不会导致此测试失败，而输入错误的密码将会失败。（注意，这未加密存储在测试计划中）</p>
        <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器名称</td>
<td>LDAP服务器的名称（或IP地址）。</td>
<td>是</td>
</tr>
<tr>
<td>港口</td>
<td>LDAP服务器正在侦听的端口号。如果省略此选项，则JMeter假定LDAP服务器正在侦听默认端口（389）。</td>
<td>没有</td>
</tr>
<tr>
<td>DN</td>
<td>将用于任何后续操作的基础对象的专有名称。它可以用作所有操作的起点。您无法以高于此DN的级别启动任何操作！</td>
<td>没有</td>
</tr>
<tr>
<td>用户名</td>
<td>要绑定的用户的全名。</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>上述用户的密码。如果省略，将导致匿名绑定。如果不正确，则采样器将返回错误并恢复为匿名绑定。（注意，这未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
<tr>
<td>连接超时（以毫秒为单位）</td>
<td>连接超时，如果超过连接将中止</td>
<td>没有</td>
</tr>
<tr>
<td>使用安全LDAP协议</td>
<td>使用<tt class="code">ldaps：//</tt>方案，而不是<tt class="code">ldap：//</tt></td>
<td>没有</td>
</tr>
<tr>
<td>信任所有证书</td>
<td>信任所有证书，仅在选中<tt class="code">“使用安全LDAP协议”</tt>时<tt class="code">使用</tt></td>
<td>没有</td>
</tr>
</tbody></table>

      </dd>
      <dt><b>线程解除绑定</b></dt>
      <dd>
        <p>这只是结束会话的操作。它等于LDAP的“ <tt class="code">解除绑定</tt> ”操作。</p>
        <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
</tbody></table>

      </dd>
      <dt><b>单次绑定/取消绑定</b></dt>
      <dd>
        <p>这是LDAP“ <tt class="code">bind</tt> ”和“ <tt class="code">unbind</tt> ”操作的组合。它可以用于任何用户的身份验证请求/密码检查。它将打开一个新会话，仅用于检查用户/密码组合的有效性，然后再次结束会话。</p>
        <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>用户名</td>
<td>要绑定的用户的全名。</td>
<td>是</td>
</tr>
<tr>
<td>密码</td>
<td>上述用户的密码。如果省略，将导致匿名绑定。如果不正确，则采样器将返回错误。（注意，这未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
</tbody></table>

      </dd>
      <dt><b>重命名条目</b></dt>
      <dd>
       <p>这是LDAP的“ <tt class="code">moddn</tt> ”操作。它可用于重命名条目，也可用于将条目或完整的子树移动到LDAP树中的其他位置。</p>
       <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>旧条目名称</td>
<td>您要重命名或移动的对象的当前可分辨名称，相对于线程绑定操作中的给定DN。</td>
<td>是</td>
</tr>
<tr>
<td>新的专有名称</td>
<td>您要重命名或移动的对象的新专有名称，相对于线程绑定操作中的给定DN。</td>
<td>是</td>
</tr>
</tbody></table>

     </dd>
     <dt><b>添加测试</b></dt>
     <dd>
       <p>这是LDAP的“ <tt class="code">添加</tt> ”操作。它可以用于将任何类型的对象添加到LDAP服务器。</p>
       <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>条目DN</td>
<td>相对于线程绑定操作中给定DN的要添加对象的专有名称。</td>
<td>是</td>
</tr>
<tr>
<td>添加测试</td>
<td>您要用于对象的属性及其值的列表。如果需要添加多值属性，则需要多次将相同属性及其各自的值添加到列表中。</td>
<td>是</td>
</tr>
</tbody></table>

     </dd>
     <dt><b>删除测试</b></dt>
     <dd>
       <p>这是LDAP的“ <tt class="code">删除</tt> ”操作，可用于从LDAP树中删除对象</p>
       <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>删除</td>
<td>相对于线程绑定操作中给定DN的要删除对象的专有名称。</td>
<td>是</td>
</tr>
</tbody></table>

     </dd>
     <dt><b>搜索测试</b></dt>
     <dd>
       <p>这是LDAP“ <tt class="code">搜索</tt> ”操作，将用于定义搜索。</p>
       <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>搜索基地</td>
<td>您想要搜索的子树的可分辨名称，相对于线程绑定操作中给定的DN。</td>
<td>没有</td>
</tr>
<tr>
<td>搜索过滤器</td>
<td>searchfilter，必须以LDAP语法指定。</td>
<td>是</td>
</tr>
<tr>
<td>范围</td>
<td>为子树搜索使用onelevel- <tt class="code">0</tt> <tt class="code">baseobject-，1</tt>和<tt class="code">2。</tt>（预设= <tt class="code">0</tt> ）</td>
<td>没有</td>
</tr>
<tr>
<td>大小限制</td>
<td>指定要从服务器返回的最大结果数。 （默认值= <tt class="code">0</tt> ，表示没有限制。）当采样器达到最大结果数时，它将失败并显示错误代码<tt class="code">4</tt></td>
<td>没有</td>
</tr>
<tr>
<td>时限</td>
<td>指定服务器可用于搜索的最大（cpu）时间（以毫秒为单位）。请注意，这没有说明响应时间。 （默认值为<tt class="code">0</tt> ，表示没有限制）</td>
<td>没有</td>
</tr>
<tr>
<td>属性</td>
<td>指定要返回的属性，以分号分隔。空字段将返回所有属性</td>
<td>没有</td>
</tr>
<tr>
<td>返回对象</td>
<td>是否将返回对象（ <tt class="code">true</tt> ）与否（ <tt class="code">false</tt> ）。默认值= <tt class="code">false</tt></td>
<td>没有</td>
</tr>
<tr>
<td>解除引用别名</td>
<td>如果为<tt class="code">true</tt> ，它将取消引用别名；如果为<tt class="code">false</tt> ，它将不跟随别名（默认值= <tt class="code">false</tt> ）</td>
<td>没有</td>
</tr>
<tr>
<td>解析搜索结果？</td>
<td>如果为<tt class="code">true</tt> ，则搜索结果将添加到响应数据中。如果为<tt class="code">false</tt> ，则会将标记（无论是否找到结果）添加到响应数据中。</td>
<td>没有</td>
</tr>
</tbody></table>

     </dd>
     <dt><b>修改测试</b></dt>
     <dd>
       <p>这是LDAP的“ <tt class="code">修改</tt> ”操作。可用于修改对象。它可用于添加，删除或替换属性的值。</p>
       <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>条目名称</td>
<td>您要修改的对象的专有名称，相对于线程绑定操作中的给定DN</td>
<td>是</td>
</tr>
<tr>
<td>修改测试</td>
<td>attribute-value-opCode增加了三倍。<br><tt class="code">opCode</tt>可以是任何有效的LDAP operationCode（ <tt class="code">add</tt> ， <tt class="code">delete</tt> ， <tt class="code">remove</tt>或<tt class="code">replace</tt> ）。<br>如果未通过<tt class="code">删除</tt>操作指定值，则给定属性的所有值都将被删除。<br>如果确实在<tt class="code">删除</tt>操作中指定了一个值，则只会<tt class="code">删除</tt>给定的值。<br>如果此值不存在，则采样器将使测试失败。</td>
<td>是</td>
</tr>
</tbody></table>

     </dd>
     <dt><b>比较</b></dt>
     <dd>
       <p>这是LDAP的“ <tt class="code">比较</tt> ”操作。它可用于将给定属性的值与一些已知值进行比较。实际上，这主要用于检查给定的人是否是某个组的成员。在这种情况下，您可以将用户的DN作为给定值与<tt class="code">groupOfNames</tt>类型的对象的属性“ <tt class="code">member</tt> ”中的值进行比较。如果比较操作失败，则此测试失败，错误代码为<tt class="code">49</tt> 。</p>
       <p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>条目DN</td>
<td>您要比较属性的对象的当前可分辨名称，相对于线程绑定操作中的给定DN。</td>
<td>是</td>
</tr>
<tr>
<td>比较过滤器</td>
<td>形式为“ <tt class="code">属性=值</tt> ”</td>
<td>是</td>
</tr>
</tbody></table>

     </dd>
   </dl><p><b>也可以看看：</b></p>
<ul>
<li><a href="build-ldapext-test-plan.html">建立LDAP测试计划</a></li>
<li><a href="../usermanual/component_reference.html#LDAP_Extended_Request_Defaults">LDAP扩展请求默认值</a></li>
</ul>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Access_Log_Sampler">18.1.9访问日志采样器</a>
</h3>
</font>
</td></tr>
<tr><td>
<center><h2>（测试版）</h2></center><p>AccessLogSampler旨在读取访问日志并生成http请求。对于那些不熟悉访问日志的用户，它是Web服务器维护它接受的每个请求的日志。这意味着每个图像，CSS文件，JavaScript文件，html文件……</p>
<p>Tomcat使用通用格式的访问日志。这意味着任何使用通用日志格式的Web服务器都可以使用AccessLogSampler。使用通用日志格式的服务器包括：Tomcat，Resin，Weblogic和SunOne。常见的日志格式如下：</p>
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>127.0.0.1 - - [21/Oct/2003:05:37:21 -0500] &quot;GET /index.jsp?%2Findex.jsp= HTTP/1.1&quot; 200 8343</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>解析器的当前实现仅查看包含HTTP协议方法之一（ <tt class="code">GET</tt> ， <tt class="code">PUT</tt> ， <tt class="code">POST</tt> ， <tt class="code">DELETE</tt>等）的引号内的文本。其他所有内容都被删除并被忽略。例如，解析器将完全忽略响应代码。</td></tr>
</tbody></table>
<p></p>

<p>将来，最好过滤掉响应代码为<tt class="code">200的</tt>条目。扩展采样器应该非常简单。您必须实现两个接口：</p>
<ul>
<li><tt class="code">org.apache.jmeter.protocol.http.util.accesslog。LogParser</tt></li>
<li><tt class="code">org.apache.jmeter.protocol.http.util.accesslog。发电机</tt></li>
</ul>
<p>AccessLogSampler的当前实现使用生成器来创建新的HTTPSampler。服务器名称，端口和获取映像由AccessLogSampler设置。接下来，使用整数<tt class="code">1</tt>调用解析器，告诉它解析一个条目。之后，将调用<tt class="code">HTTPSampler.sample（）</tt>发出请求。</p>
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
samp = (HTTPSampler) GENERATOR.generateRequest();
samp.setDomain(this.getDomain());
samp.setPort(this.getPort());
samp.setImageParser(this.isImageParser());
PARSER.parse(1);
res = samp.sample();
res.setSampleLabel(samp.toString());
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div><tt class="code">LogParser</tt>中所需的方法是：<ul>
<li><tt class="code">setGenerator（发电机）</tt></li>
<li><tt class="code">解析（int）</tt></li> 
</ul>
<p>实现<tt class="code">Generator</tt>接口的类应为所有方法提供具体实现。有关如何实现这两个接口的示例，请参见<tt class="code">StandardGenerator</tt>和<tt class="code">TCLogParser</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="702" height="305" src="../images/screenshots/accesslogsampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器</td>
<td>Web服务器的域名或IP地址。</td>
<td>是</td>
</tr>
<tr>
<td>协议</td>
<td>方案</td>
<td>否（默认为http</td>
</tr>
<tr>
<td>港口</td>
<td>Web服务器正在侦听的端口。</td>
<td>否（默认为80）</td>
</tr>
<tr>
<td>日志解析器类</td>
<td>日志解析器类负责解析日志。</td>
<td>是（提供默认值）</td>
</tr>
<tr>
<td>过滤</td>
<td>filter类用于过滤掉某些行。</td>
<td>没有</td>
</tr>
<tr>
<td>日志文件的位置</td>
<td>访问日志文件的位置。</td>
<td>是</td>
</tr>
</tbody></table>
<p><tt class="code">TCLogParser</tt>为每个线程独立处理访问日志。<tt class="code">SharedTCLogParser</tt>和<tt class="code">OrderPreservingLogParser</tt>共享对文件的访问权限，即每个线程都获取日志中的下一个条目。
</p><p><tt class="code">SessionFilter</tt>旨在处理跨线程的Cookies。它不会过滤掉任何条目，但是会修改cookie管理器，以便一次通过单个线程处理给定IP的cookie。如果两个线程尝试处理来自同一客户端IP地址的样本，则将迫使一个线程等待，直到另一个线程完成。
</p><p><tt class="code">LogFilter</tt>旨在允许按文件名和正则表达式过滤访问日志条目，并允许替换文件扩展名。但是，当前无法通过GUI进行配置，因此无法真正使用它。
</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="BeanShell_Sampler">18.1.10 BeanShell采样器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该采样器使您可以使用BeanShell脚本语言编写采样器。
</p><p>
<b>有关使用BeanShell的完整详细信息，请访问<a href="http://www.beanshell.org/">BeanShell网站。</a></b>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>强烈建议迁移到<a href="../usermanual/component_reference.html#JSR223_Sampler">JSR223 Sampler</a> + Groovy，以提高性能，支持新的Java功能并限制BeanShell库的维护。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>测试元素支持<tt class="code">ThreadListener</tt>和<tt class="code">TestListener</tt>接口方法。这些必须在初始化文件中定义。有关示例定义，请参见文件<tt class="code">BeanShellListeners.bshrc</tt> 。
</p>
<p>BeanShell采样器还支持<tt class="code">Interruptible</tt>接口。可以在脚本或init文件中定义<tt class="code">interrupt（）</tt>方法。
</p>
    <p><b>控制面板</b></p>
<div align="center"><img width="848" height="566" src="../images/screenshots/beanshellsampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。名称存储在脚本变量Label中</td>
<td>没有</td>
</tr>
<tr>
<td>重置bsh。每次通话前翻译</td>
<td>如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关更多信息，请参见<a href="best-practices#bsh_scripting">Best Practices-BeanShell脚本</a> 。
    </td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给BeanShell脚本的参数。这是供脚本文件使用的。对于GUI中定义的脚本，您可以使用脚本本身需要的任何变量和函数引用。参数存储在以下变量中：<dl>
        <dt><tt class="code">参量</tt></dt><dd>包含参数作为单个变量的字符串</dd>
        <dt><tt class="code">bsh.args</tt></dt><dd>包含参数的字符串数组，在空白处分割</dd>
    </dl></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量<tt class="code">FileName中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>要运行的BeanShell脚本。返回值（如果不为<tt class="code">null</tt> ）存储为采样器结果。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：每个Sampler实例都有其自己的BeanShell解释器，并且Samplers仅从单个线程中调用</td></tr>
</tbody></table>
<p></p>
<p>如果定义了属性“ <tt class="code">beanshell.sampler.init</tt> ”，它将作为源文件的名称传递给Interpreter。这可以用来定义通用方法和变量。bin目录中有一个样本初始化文件： <tt class="code">BeanShellSampler.bshrc</tt> 。
</p><p>如果提供了脚本文件，将使用该脚本文件，否则将使用该脚本。</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter在将脚本字段传递给解释器之前先处理函数和变量引用，因此这些引用将只解析一次。脚本文件中的变量和函数引用将逐字传递给解释器，这可能会导致语法错误。为了使用运行时变量，请使用适当的props方法，例如<tt class="code">props.get（“ START.HMS”）; props.put（“ PROP1”，“ 1234”）;</tt>
<br>BeanShell当前不支持Java 5语法，例如泛型和增强的for循环。
</td></tr>
</tbody></table>
<p></p>
<p>在调用脚本之前，在BeanShell解释器中设置了一些变量：</p><p>“ <tt class="code">参数</tt> ”字段的内容被放入变量“ <tt class="code">Parameters</tt> ”中。还使用单个空格作为分隔符将字符串拆分为单独的标记，并将结果列表存储在String数组<tt class="code">bsh.args中</tt> 。</p><p>设置的BeanShell变量的完整列表如下：</p><ul>
        <li><tt class="code">log-</tt> <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">记录器</a></li>
        <li><tt class="code">标签</tt> -采样器标签</li>
        <li><tt class="code">FileName-</tt>文件名（如果有）</li>
        <li><tt class="code">参数</tt> -参数字段中的文本</li>
        <li><tt class="code">bsh.args-</tt>参数，如上所述进行拆分</li>
        <li><tt class="code">SampleResult-</tt>指向当前<a href="../api/org/apache/jmeter/samplers/SampleResult.html"><tt class="code">SampleResult的</tt></a>指针</li>
            <li><tt class="code">ResponseCode</tt>默认为<tt class="code">200</tt></li>
            <li><tt class="code">ResponseMessage</tt>默认为“ <tt class="code">OK</tt> ”</li>
            <li><tt class="code">IsSuccess</tt>默认为<tt class="code">true</tt></li>
            <li><tt class="code">ctx</tt> - <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a></li>
            <li><tt class="code">vars</tt> - <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables-</a>例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(&quot;VAR1&quot;);
vars.put(&quot;VAR2&quot;,&quot;value&quot;);
vars.remove(&quot;VAR3&quot;);
vars.putObject(&quot;OBJ1&quot;,new Object());</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
            <li><tt class="code">道具</tt> -JMeterProperties（类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><tt class="code">java.util。属性</tt></a> ）-例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>props.get(&quot;START.HMS&quot;);
props.put(&quot;PROP1&quot;,&quot;1234&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
        </ul><p>脚本完成后，控制权返回给Sampler，它将以下脚本变量的内容复制到<a href="../api/org/apache/jmeter/samplers/SampleResult.html"><tt class="code">SampleResult中</tt></a>的相应变量中：</p><ul>
            <li><tt class="code">ResponseCode-</tt>例如<tt class="code">200</tt></li>
            <li><tt class="code">ResponseMessage-</tt>例如“ <tt class="code">OK</tt> ”</li>
            <li><tt class="code">IsSuccess-</tt> <tt class="code">对</tt>或<tt class="code">错</tt></li>
            </ul><p>根据脚本的返回值设置SampleResult ResponseData。如果脚本返回null，则可以使用<tt class="code">SampleResult.setResponseData（data）</tt>方法直接设置响应，其中data是String或字节数组。数据类型默认为“ <tt class="code">text</tt> ”，但是可以通过使用<tt class="code">SampleResult.setDataType（SampleResult方法）设置为二进制<tt class="code">。二进制）</tt> 。
            </tt></p><p><tt class="code">该<tt class="code">SampleResult</tt>变量给出脚本的完全访问权限的<tt class="code">SampleResult</tt>所有字段和方法。例如，脚本可以访问方法<tt class="code">setStopThread（boolean）</tt>和<tt class="code">setStopTest（boolean）</tt> 。这很简单（不是很有用！）示例脚本：</tt></p><div align="left"><tt class="code">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
if (bsh.args[0].equalsIgnoreCase(&quot;StopThread&quot;)) {
    log.info(&quot;Stop Thread detected!&quot;);
    SampleResult.setStopThread(true);
}
return &quot;Data from sample with Label &quot;+Label;
//or
SampleResult.setResponseData(&quot;My data&quot;);
return null;
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</tt></div><tt class="code">
<p>另一个例子：<br>确保在<tt class="code">jmeter.properties中</tt>定义了属性<tt class="code">beanshell.sampler.init = BeanShellSampler.bshrc</tt> 。以下脚本将显示<tt class="code">ResponseData</tt>字段中所有变量的值：</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
return getVariables();
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>有关各种类（ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html"><tt class="code">JMeterVariables</tt></a> ， <a href="../api/org/apache/jmeter/samplers/SampleResult.html"><tt class="code">SampleResult</tt></a>等）可用的方法的详细信息，请检查Javadoc或源代码。但是请注意，任何方法的滥用都会导致可能难以发现的细微故障。
</p></tt></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSR223_Sampler">18.1.11.1 JSR223采样器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JSR223采样器允许JSR223脚本代码用于执行采样或创建/更新变量所需的某些计算。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您不想在运行此采样器时生成<a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ，请调用以下方法：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>SampleResult.setIgnore();</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>JSR223测试元素具有可大大提高性能的功能（编译）。受益于此功能：</p>
<ul>
    <li>使用脚本文件而不是内联它们。如果ScriptEngine上有此功能，这将使JMeter对其进行编译并缓存它们。</li>
    <li>或者使用“脚本文本”，然后检查“ <tt class="code">缓存编译的脚本”（如果有）</tt>属性。
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>使用此功能时，请确保您的脚本代码不直接在脚本代码中使用JMeter变量，因为缓存只会缓存第一次替换。而是使用脚本参数。</td></tr>
</tbody></table>
<p></p>

    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>为了从缓存和编译中受益，用于脚本编写的语言引擎必须实现JSR223 <tt class="code"><a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html">Compilable</a></tt>接口（Groovy是其中之一，而Java，beanshell和javascript不是）</td></tr>
</tbody></table>
<p></p>

    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>当使用Groovy作为脚本语言并且不检查<tt class="code">Cache编译脚本是否可用</tt> （建议使用高速缓存）时，由于2.4.6版<tt class="code">以来</tt>的Groovy内存泄漏，应设置此JVM属性<tt class="code">-Dgroovy.use.classvalue = true</tt> ，请参阅：<ul>
            <li><a href="https://issues.apache.org/jira/browse/GROOVY-7683">GROOVY-7683</a></li>
            <li><a href="https://issues.apache.org/jira/browse/GROOVY-7591">格罗维-7591</a></li>
            <li><a href="https://bugs.openjdk.java.net/browse/JDK-8136353">JDK-8136353</a></li>
        </ul> 
    </td></tr>
</tbody></table>
<p></p>

    </li>
</ul>缓存大小由以下JMeter属性（ <tt class="code">jmeter.properties</tt> ）控制：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>jsr223.compiled_scripts_cache_size=100</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>与<a href="../usermanual/component_reference.html#BeanShell_Sampler">BeanShell Sampler</a>不同，解释器不在两次调用之间保存。</td></tr>
</tbody></table>
<p></p>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果ScriptEngine支持此功能，则现在使用Script文件或Script文本+已检查的<tt class="code">Cache编译脚本（如果可用）</tt>对JSR223测试元素进行编译，这将大大提高性能。
</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="861" height="502" src="../images/screenshots/jsr223-sampler.png"></div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter在将脚本字段传递给解释器之前先处理函数和变量引用，因此这些引用将只解析一次。脚本文件中的变量和函数引用将逐字传递给解释器，这可能会导致语法错误。为了使用运行时变量，请使用适当的props方法，例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>props.get(&quot;START.HMS&quot;);
props.put(&quot;PROP1&quot;,&quot;1234&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

</td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>脚本语言</td>
<td>要使用的JSR223脚本语言的名称。
      <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>除了下拉列表中显示的语言外，还支持其他语言。如果在JMeter lib目录中安装了适当的jar，则其他选项可能可用。<br>注意，某些语言（例如Velocity）可能对JSR223变量使用不同的语法，例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>$log.debug(&quot;Hello &quot; + $vars.get(&quot;a&quot;));</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>速度。
      </td></tr>
</tbody></table>
<p></p>

    </td>
<td>是</td>
</tr>
<tr>
<td>脚本文件</td>
<td>用作JSR223脚本的文件的名称，如果使用相对文件路径，则它将相对于“ <tt class="code">user.dir</tt> ”引用的目录的系统属性</td>
<td>没有</td>
</tr>
<tr>
<td>参量</td>
<td>要传递到脚本文件或脚本的参数列表。</td>
<td>没有</td>
</tr>
<tr>
<td>缓存编译的脚本（如果可用）</td>
<td>如果选中（建议）并且使用的语言支持<tt class="code"><a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html">Compilable</a></tt>接口（Groovy是其中的一种，则Java，beanshell和javascript不支持），JMeter将编译该脚本并将其MD5哈希作为唯一的缓存键进行缓存。</td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>脚本传递给JSR223语言</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>如果提供了脚本文件，将使用该脚本文件，否则将使用该脚本。</p><p>在调用脚本之前，先设置一些变量。请注意，这些是JSR223变量-即它们可以直接在脚本中使用。
</p><ul>
<li><tt class="code">log-</tt> <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">记录器</a></li>
<li><tt class="code">标签</tt> -采样器标签</li>
<li><tt class="code">FileName-</tt>文件名（如果有）</li>
<li><tt class="code">参数</tt> -参数字段中的文本</li>
<li><tt class="code">args-</tt>参数，如上所述拆分</li>
<li><tt class="code">SampleResult-</tt>指向当前<a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult的</a>指针</li>
<li><tt class="code">采样器</tt> -（ <a href="../api/org/apache/jmeter/samplers/Sampler.html">采样器</a> ）-指向当前采样器的指针</li>
<li><tt class="code">ctx</tt> - <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a></li>
<li><tt class="code">vars</tt> - <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables-</a>例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(&quot;VAR1&quot;);
vars.put(&quot;VAR2&quot;,&quot;value&quot;);
vars.remove(&quot;VAR3&quot;);
vars.putObject(&quot;OBJ1&quot;,new Object());</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -JMeterProperties（类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><tt class="code">java.util。属性</tt></a> ）-例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>props.get(&quot;START.HMS&quot;);
props.put(&quot;PROP1&quot;,&quot;1234&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">OUT</tt> -System.out-例如<tt class="code">OUT.println（“ message”）</tt></li>
</ul><p>根据脚本的返回值设置<a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ResponseData。如果脚本返回<tt class="code">null</tt> ，则可以使用<tt class="code">SampleResult.setResponseData（data）</tt>方法直接设置响应，其中data是String或字节数组。数据类型默认为“ <tt class="code">text</tt> ”，但是可以通过使用<tt class="code">SampleResult.setDataType（SampleResult方法）设置为二进制<tt class="code">。二进制）</tt> 。
</tt></p><p><tt class="code">SampleResult变量使脚本可以完全访问SampleResult中的所有字段和方法。例如，脚本可以访问方法<tt class="code">setStopThread（boolean）</tt>和<tt class="code">setStopTest（boolean）</tt> 。
</tt></p><p><tt class="code">与BeanShell Sampler不同，JSR223 Sampler不会通过脚本变量设置<tt class="code">ResponseCode</tt> ， <tt class="code">ResponseMessage</tt>和示例状态。当前，更改它们的唯一方法是通过<a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a>方法：</tt></p><ul><tt class="code">
<li><tt class="code">SampleResult.setSuccessful（true / false）</tt></li>
<li><tt class="code">SampleResult.setResponseCode（“代码”）</tt></li>
<li><tt class="code">SampleResult.setResponseMessage（“ message”）</tt></li>
</tt></ul></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="TCP_Sampler">18.1.12 TCP采样器</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>TCP采样器打开到指定服务器的TCP / IP连接。然后，它发送文本，并等待响应。
        </p><p>如果选择了“ <tt class="code">重用连接</tt> ”，则只要使用完全相同的主机名字符串和端口，就可以在同一线程中的采样器之间共享连接。不同的主机/端口组合将使用不同的连接，不同的线程也将使用。如果同时选择了“ <tt class="code">重用连接</tt> ”和“ <tt class="code">关闭连接</tt> ”，则在运行采样器后将关闭套接字。在下一个采样器上，将创建另一个套接字。您可能想在每个线程循环的结尾关闭套接字。
        </p><p>如果检测到错误-或未选择“ <tt class="code">重新使用连接</tt> ”-插座将关闭。下一个示例将重新打开另一个套接字。
        </p><p>以下属性可用于控制其操作：</p>
        <dl>
            <dt><tt class="code">tcp.status.prefix</tt></dt><dd>状态编号之前的文字</dd>
            <dt><tt class="code">tcp.status.suffix</tt></dt><dd>状态编号后的文字</dd>
            <dt><tt class="code">tcp.status.properties</tt></dt><dd>用于将状态代码转换为消息的属性文件的名称</dd>
            <dt><tt class="code">tcp.handler</tt></dt><dd>TCP处理程序类的名称（默认<tt class="code">TCPClientImpl</tt> ）-仅当未在GUI上指定时使用</dd>
        </dl>如果没有属性<tt class="code">tcp.handler</tt> ，则由GUI定义用于处理连接的类。如果未找到，则在包<tt class="code">org.apache.jmeter.protocol.tcp.sampler中</tt>搜索该类。
        <p>用户可以提供自己的实现。该类必须扩展<tt class="code">org.apache.jmeter.protocol.tcp.sampler。TCPClient</tt> 。
        </p>
        <p>当前提供以下实现。
        </p>
        <ul>
        <li><tt class="code">TCPClientImpl</tt></li>
        <li><tt class="code">BinaryTCPClientImpl</tt></li>
        <li><tt class="code">LengthPrefixedBinaryTCPClientImpl</tt></li>
        </ul>这些实现的行为如下：<dl>
        <dt><tt class="code">TCPClientImpl</tt></dt>
        <dd>此实现是相当基本的。读取响应时，如果通过设置属性<tt class="code">tcp.eolByte进行</tt>定义，它将一直读取到行字节的结尾，否则将一直读取到输入流的结尾。您可以通过设置<tt class="code">tcp.charset</tt>来控制字符集编码，它将默认设置为平台默认编码。
        </dd>
        <dt><tt class="code">BinaryTCPClientImpl</tt></dt>
        <dd>此实现将GUI输入（必须是十六进制编码的字符串）转换为二进制，并在读取响应时执行相反的操作。读取响应时，如果通过设置属性<tt class="code">tcp定义了消息，它将一直读取到消息字节的末尾<tt class="code">。BinaryTCPClient.eomByte</tt> ，否则直到输入流结束。
        </tt></dd><tt class="code">
        <dt><tt class="code">LengthPrefixedBinaryTCPClientImpl</tt></dt>
        <dd>此实现通过为二进制消息数据添加一个二进制长度字节作为前缀来扩展BinaryTCPClientImpl。长度前缀默认为2个字节。可以通过设置属性<tt class="code">tcp.binarylength.prefix.length</tt>来更改。
        </dd>
        <dt><b>超时处理</b></dt>
        <dd>如果设置了超时，则读超时将终止。因此，如果您使用的是<tt class="code">eolByte</tt> / <tt class="code">eomByte</tt> ，请确保超时时间足够长，否则读取将提前终止。
        </dd>
        <dt><b>响应处理</b></dt>
        <dd>如果定义了<tt class="code">tcp.status.prefix</tt> ，则将在响应消息中搜索后缀之后的文本，直至后缀。如果找到任何此类文本，则将其用于设置响应代码。然后，从属性文件（如果提供）中获取响应消息。
        <a name="tcp-prefix-example"></a>
<p><b>前置和后缀的用法</b></p>例如，如果前缀=“ <tt class="code">[</tt> ”和后缀=“ <tt class="code">]</tt> ”，则以下响应：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>[J28] XI123,23,GBP,CR</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>将具有响应代码<tt class="code">J28</tt> 。当前，响应代码在“ <tt class="code">400</tt> ”-“ <tt class="code">499</tt> ”和“ <tt class="code">500</tt> ”-“ <tt class="code">599</tt> ”之间；其他所有人都成功。[这需要设置为可配置！]
        </dd>
        </tt></dl><tt class="code">
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>提供的TCP实现未使用登录名/密码。</td></tr>
</tbody></table>
<p></p>

        <br>在测试运行结束时，套接字已断开连接。
<p><b>控制面板</b></p>
<div align="center"><img width="827" height="521" src="../images/screenshots/tcpsampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>TCPClient类别名称</td>
<td>TCPClient类的名称。默认为属性<tt class="code">tcp.handler</tt> ，否则将失败<tt class="code">TCPClientImpl</tt> 。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器名称或IP</td>
<td>TCP服务器的名称或IP</td>
<td>是</td>
</tr>
<tr>
<td>端口号</td>
<td>使用的端口</td>
<td>是</td>
</tr>
<tr>
<td>重用连接</td>
<td>如果选择，则连接保持打开状态。否则，在读取数据后将其关闭。</td>
<td>是</td>
</tr>
<tr>
<td>紧密连接</td>
<td>如果选择此选项，则在运行采样器后将关闭连接。</td>
<td>是</td>
</tr>
<tr>
<td>SO_LINGER</td>
<td>创建套接字时，以指定的延迟时间（以秒为单位）启用/禁用<tt class="code">SO_LINGER</tt> 。如果将“ <tt class="code">SO_LINGER</tt> ”值设置为<tt class="code">0</tt> ，则可以防止大量套接字处于<tt class="code">TIME_WAIT</tt>状态。</td>
<td>没有</td>
</tr>
<tr>
<td>行尾（EOL）字节值</td>
<td>行尾的字节值，将此值设置为<tt class="code">-128</tt>至<tt class="code">+127</tt>范围之外的<tt class="code">值</tt>可跳过<tt class="code">eol</tt>检查。您也可以在<tt class="code">jmeter.properties</tt>文件中使用<tt class="code">eolByte</tt>属性进行设置。如果您同时在TCP Sampler Config和<tt class="code">jmeter.properties</tt>文件中进行设置，则将使用TCP Sampler Config中的设置值。</td>
<td>没有</td>
</tr>
<tr>
<td>连接超时</td>
<td>连接超时（毫秒， <tt class="code">0</tt>禁用）。</td>
<td>没有</td>
</tr>
<tr>
<td>响应超时</td>
<td>响应超时（毫秒， <tt class="code">0</tt>禁用）。</td>
<td>没有</td>
</tr>
<tr>
<td>设定NoDelay</td>
<td>参见<tt class="code">java.net。Socket.setTcpNoDelay（）</tt> 。如果选中，将禁用Nagle的算法，否则将使用Nagle的算法。</td>
<td>是</td>
</tr>
<tr>
<td>文字发送</td>
<td>要发送的文字</td>
<td>是</td>
</tr>
<tr>
<td>登录用户</td>
<td>用户名-默认实现未使用</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>密码-默认实现中未使用（注意，此密码未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
</tbody></table>
</tt></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JMS_Publisher">18.1.13 JMS发布器</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>JMS Publisher将消息发布到给定的目的地（主题/队列）。对于不熟悉JMS的人来说，它是用于消息传递的J2EE规范。市场上有许多JMS服务器和几种开源选项。
        </p>
        <br>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter不包括任何JMS实现jar；必须从JMS提供程序下载此文件并将其放在lib目录中</td></tr>
</tbody></table>
<p></p>

    <p><b>控制面板</b></p>
<div align="center"><img width="854" height="796" src="../images/screenshots/jmspublisher.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>使用JNDI属性文件</td>
<td>使用<tt class="code">jndi.properties</tt> 。请注意，该文件必须位于类路径上-例如，通过更新<tt class="code">user.classpath</tt> JMeter属性。如果未选择此选项，JMeter将使用“ <tt class="code">JNDI初始上下文工厂</tt> ”和“ <tt class="code">提供者URL</tt> ”字段来创建连接。
  </td>
<td>是</td>
</tr>
<tr>
<td>JNDI初始上下文工厂</td>
<td>上下文工厂的名称</td>
<td>没有</td>
</tr>
<tr>
<td>提供商URL</td>
<td>JMS提供者的URL</td>
<td>是的，除非使用jndi.properties</td>
</tr>
<tr>
<td>目的地</td>
<td>邮件目标（主题或队列名称）</td>
<td>是</td>
</tr>
<tr>
<td>设定</td>
<td>目标设置类型。<tt class="code">在启动时</tt> ，目标名称是静态的（即在测试过程中始终是相同的名称），对于<tt class="code">每个样本</tt> ，目标名称是动态的，并在每个样本中求值（即目标名称可以是变量）</td>
<td>是</td>
</tr>
<tr>
<td>认证方式</td>
<td>JMS提供者的认证要求</td>
<td>是</td>
</tr>
<tr>
<td>用户</td>
<td>用户名</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>密码（注意，密码未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
<tr>
<td>期满</td>
<td>消息过期之前的过期时间（以毫秒为单位）。如果未指定到期时间，则默认值为<tt class="code">0</tt> （永不到期）。
  </td>
<td>没有</td>
</tr>
<tr>
<td>优先</td>
<td>消息的优先级。从<tt class="code">0</tt> （最低）到<tt class="code">9</tt> （最高）有十个优先级。如果未指定优先级，则默认级别为<tt class="code">4</tt> 。
  </td>
<td>没有</td>
</tr>
<tr>
<td>重新连接错误代码（正则表达式）</td>
<td>JMSException错误代码的正则表达式，强制重新连接。如果为空，则不会进行重新连接</td>
<td>没有</td>
</tr>
<tr>
<td>样本总数</td>
<td>样本总数</td>
<td>是</td>
</tr>
<tr>
<td>讯息来源</td>
<td>从何处获取消息：<dl>
    <dt><tt class="code">从文件</tt></dt><dd>意味着所有样本都将读取并重用引用的文件。如果文件名更改，它将自JMeter 3.0起重新加载</dd>
    <dt><tt class="code">下面指定的文件夹中的随机文件</tt></dt><dd>表示将从下面指定的文件夹中选择一个随机文件，该文件夹必须包含扩展名<tt class="code">.dat</tt>的字节消息文件或扩展名<tt class="code">.txt</tt>或<tt class="code">.obj</tt>的对象或文本消息文件</dd>
    <dt><tt class="code">文字区</tt></dt><dd>用于文本或对象消息的消息</dd>
  </dl>
  </td>
<td>是</td>
</tr>
<tr>
<td>讯息类型</td>
<td>文本，地图，对象消息或字节消息</td>
<td>是</td>
</tr>
<tr>
<td>内容编码</td>
<td>指定用于读取消息源文件的编码：<dl> 
    <dt><tt class="code">RAW</tt> ：</dt><dd>该文件没有变量支持，并使用默认系统字符集加载它。</dd>
    <dt><tt class="code">默认值</tt> ：</dt><dd>使用默认的系统编码加载文件，但XML依赖于XML序言。如果文件包含变量，则将对其进行处理。</dd>
    <dt><tt class="code">标准字符集</tt> ：</dt><dd>指定的编码（有效或无效）用于读取文件和处理变量</dd>
  </dl>
  </td>
<td>是</td>
</tr>
<tr>
<td>使用非持久交付模式？</td>
<td>是否设置<tt class="code">DeliveryMode。NON_PERSISTENT</tt> （默认为<tt class="code">false</tt> ）</td>
<td>没有</td>
</tr>
<tr>
<td>JMS属性</td>
<td>JMS属性是特定于基础消息系统的属性。您可以设置名称，值和值的类（类型）。默认类型为<tt class="code">String</tt> 。例如：对于WebSphere 5.1 Web服务，您将需要设置JMS属性targetService以通过JMS测试Web服务。</td>
<td>没有</td>
</tr>
</tbody></table>
<p>对于MapMessage类型，JMeter将源作为文本行读取。每行必须有3个字段，以逗号分隔。字段是：</p><ul>
<li>报名</li>
<li>对象类名称，例如“ <tt class="code">String</tt> ”（如果未指定，则假定为<tt class="code">java.lang</tt>包）</li>
<li>对象字符串值</li>
</ul><tt class="code">valueOf（String）</tt><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
name,String,Example
size,Integer,1234
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>对象消息已实现，其工作方式如下：<ul>
<li>将包含您的对象及其依赖项的JAR放在<tt class="code">jmeter_home / lib /</tt>文件夹中</li>
<li>使用XStream将对象序列化为XML</li>
<li>将结果放入带有<tt class="code">.txt</tt>或<tt class="code">.obj</tt>后缀的文件中，或将XML内容直接放入“文本区域”中</li>  
</ul>请注意，如果消息在文件中，则如果使用“文本区域”，则不会进行属性替换。
</td></tr>
</tbody></table>
<p></p>
<p>下表显示了一些在配置JMS时可能有用的值：</p><table>
<tbody><tr>
<td bgcolor="#039acc" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">Apache <a href="http://activemq.apache.org/">ActiveMQ</a>
</font>
</td>
<td bgcolor="#039acc" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">值</font>
</td>
<td bgcolor="#039acc" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">评论</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">上下文工厂</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">org.apache.activemq.jndi。ActiveMQInitialContextFactory</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">。</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">提供商URL</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">vm：//本地主机</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
 
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">提供商URL</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">vm :(经纪人：（vm：// localhost）？持续=假）</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">禁用持久性</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">队列参考</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">dynamicQueues / QUEUENAME</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<a href="http://activemq.apache.org/jndi-support.html#JNDISupport-Dynamicallycreatingdestinations">动态地将</a> QUEUENAME <a href="http://activemq.apache.org/jndi-support.html#JNDISupport-Dynamicallycreatingdestinations">定义</a>为JNDI</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">主题参考</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">dynamicTopics / TOPICNAME</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<a href="http://activemq.apache.org/jndi-support.html#JNDISupport-Dynamicallycreatingdestinations">动态定义</a> TOPICNAME到JNDI</font>
</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JMS_Subscriber">18.1.14 JMS订阅服务器</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>JMS订阅服务器将订阅给定目标（主题或队列）中的消息。对于不熟悉JMS的人来说，它是用于消息传递的J2EE规范。市场上有许多JMS服务器和几种开源选项。
        </p>
        <br>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter不包括任何JMS实现jar；必须从JMS提供程序下载此文件并将其放在lib目录中</td></tr>
</tbody></table>
<p></p>

    <p><b>控制面板</b></p>
<div align="center"><img width="739" height="607" src="../images/screenshots/jmssubscriber.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>使用JNDI属性文件</td>
<td>使用<tt class="code">jndi.properties</tt> 。请注意，该文件必须位于类路径上-例如，通过更新<tt class="code">user.classpath</tt> JMeter属性。如果未选择此选项，JMeter将使用“ <tt class="code">JNDI初始上下文工厂</tt> ”和“ <tt class="code">提供者URL</tt> ”字段来创建连接。
  </td>
<td>是</td>
</tr>
<tr>
<td>JNDI初始上下文工厂</td>
<td>上下文工厂的名称</td>
<td>没有</td>
</tr>
<tr>
<td>提供商URL</td>
<td>JMS提供者的URL</td>
<td>没有</td>
</tr>
<tr>
<td>目的地</td>
<td>邮件目标（主题或队列名称）</td>
<td>是</td>
</tr>
<tr>
<td>持久订阅ID</td>
<td>用于持久订阅的ID。首次使用时，如果JMS提供程序尚不存在，则各自的队列将由JMS提供程序自动生成。</td>
<td>没有</td>
</tr>
<tr>
<td>客户编号</td>
<td>使用持久订阅时要使用的客户端ID。当您有多个线程时，请确保添加诸如<tt class="code">$ {__ threadNum}之</tt>类的变量。</td>
<td>没有</td>
</tr>
<tr>
<td>JMS选择器</td>
<td>由JMS规范定义的消息选择器，仅提取符合选择器条件的消息。语法使用SQL 92的子部分。</td>
<td>没有</td>
</tr>
<tr>
<td>设定</td>
<td>目标设置类型。<tt class="code">在启动时</tt> ，目标名称是静态的（即在测试过程中始终是相同的名称），对于<tt class="code">每个样本</tt> ，目标名称是动态的，并在每个样本中进行评估（即目标名称可以是变量）</td>
<td>是</td>
</tr>
<tr>
<td>认证方式</td>
<td>JMS提供者的认证要求</td>
<td>是</td>
</tr>
<tr>
<td>用户</td>
<td>用户名</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>密码（注意，密码未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
<tr>
<td>样本总数</td>
<td>样本总数</td>
<td>是</td>
</tr>
<tr>
<td>保存回复</td>
<td>采样器是否应存储响应。如果不是，则仅返回响应长度。</td>
<td>是</td>
</tr>
<tr>
<td>超时</td>
<td>指定要应用的超时（以毫秒为单位）。 <tt class="code">0</tt> =无。这是整体汇总超时，而不是每个样本。</td>
<td>是</td>
</tr>
<tr>
<td>客户</td>
<td>使用哪个客户端实现。他们两个都创建了可以读取消息的连接。但是，它们使用不同的策略，如下所述：<dl>
  <dt><tt class="code">MessageConsumer.receive（）</tt></dt><dd>为每个请求的消息调用<tt class="code">receive（）</tt> 。保留采样之间的连接，但除非采样器处于活动状态，否则不会获取消息。这最适合队列订阅。
  </dd>
  <dt><tt class="code">MessageListener.onMessage（）</tt></dt><dd>建立一个将所有传入消息存储在队列中的侦听器。采样器完成后，侦听器保持活动状态。这最适合主题订阅。</dd>
  </dl>
  </td>
<td>是</td>
</tr>
<tr>
<td>在样本之间停止？</td>
<td>如果选中，则JMeter在每个样本的末尾调用<tt class="code">Connection.stop（）</tt> （并在每个样本之前调用<tt class="code">start（）</tt> ）。在多个示例/线程具有连接到同一队列的某些情况下，这可能很有用。如果未选择，则JMeter在线程开始时调用<tt class="code">Connection.start（）</tt> ，直到线程结束才调用<tt class="code">stop（）</tt> 。
  </td>
<td>是</td>
</tr>
<tr>
<td>分隔器</td>
<td>分隔符用于在消息多于一个时分隔消息（与设置要聚合的样本数有关）。请注意，可以接受<tt class="code">\ n</tt> ， <tt class="code">\ r</tt> ， <tt class="code">\ t</tt> 。
  </td>
<td>没有</td>
</tr>
<tr>
<td>重新连接错误代码（正则表达式）</td>
<td>JMSException错误代码的正则表达式，强制重新连接。如果为空，则不会进行重新连接</td>
<td>没有</td>
</tr>
<tr>
<td>错误之间暂停（毫秒）</td>
<td>发生错误时订户将暂停的毫秒数</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JMS_Point-to-Point">18.1.15 JMS点对点</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>该采样器通过点对点连接（队列）发送和接收JMS消息（可选）。它不同于发布/订阅消息，通常用于处理事务。
        </p>
        <p>
        <tt class="code">request_only</tt>通常用于在JMS系统上施加负载。<br>

        当您要测试处理发送到请求队列的消息的JMS服务的响应时间时，将使用<tt class="code">request_reply</tt> ，因为此模式将等待该服务发送的Reply队列上的响应。<br>

        <tt class="code">浏览</tt>返回当前队列深度，即队列中的消息数。<br>

        <tt class="code">read</tt>从队列中读取一条消息（如果有）。<br>

        <tt class="code">clear</tt>清除队列，即从队列中删除所有消息。<br>

        </p>
        <p>JMeter在创建队列连接时使用属性<tt class="code">java.naming.security。[principal | credentials]</tt> （如果存在）。如果不需要此行为，请设置JMeter属性<tt class="code">JMSSampler.useSecurity.properties = false</tt>
        </p>
        <br>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter不包括任何JMS实现jar；必须从JMS提供程序下载此文件并将其放在lib目录中</td></tr>
</tbody></table>
<p></p>

    <p><b>控制面板</b></p>
<div align="center"><img width="882" height="804" src="../images/screenshots/jms/JMS_Point-to-Point.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>队列连接工厂</td>
<td>队列连接工厂的JNDI名称，用于连接到消息传递系统。
  </td>
<td>是</td>
</tr>
<tr>
<td>JNDI名称请求队列</td>
<td>这是消息发送到的队列的JNDI名称。
  </td>
<td>是</td>
</tr>
<tr>
<td>JNDI名称回复队列</td>
<td>接收队列的JNDI名称。如果在此处提供一个值，并且通信方式为“ <tt class="code">请求响应”，</tt>则将监视此队列以了解对发送的请求的响应。
  </td>
<td>没有</td>
</tr>
<tr>
<td>样本总数</td>
<td>要汇总的样本数。仅适用于通讯方式阅读。</td>
<td>是</td>
</tr>
<tr>
<td>JMS选择器</td>
<td>由JMS规范定义的消息选择器，仅提取符合选择器条件的消息。语法使用SQL 92的子部分。
  </td>
<td>没有</td>
</tr>
<tr>
<td>沟通方式</td>
<td>通讯方式可以是“ <tt class="code">仅请求”</tt> （也称为“开火”和“忘记”），“ <tt class="code">请求响应”</tt> ，“ <tt class="code">阅读”</tt> ，“ <tt class="code">浏览”</tt> ，“ <tt class="code">清除”</tt> ：<dl>
    <dt><tt class="code">仅请求</tt></dt><dd>只会发送消息，不会监视回复。因此，它可以用于在系统上施加负载。</dd>
    <dt><tt class="code">要求回应</tt></dt><dd>将发送消息并监视其收到的回复。行为取决于“ JNDI名称答复队列”的值。如果“ JNDI名称答复队列”具有值，那么此队列用于监视结果。请求和答复的匹配是通过请求的消息ID和答复的相关ID进行的。如果JNDI名称答复队列为空，那么临时队列将用于请求者和服务器之间的通信。这与固定答复队列有很大不同。使用临时队列，发送线程将阻塞，直到收到回复消息为止。在“ <tt class="code">请求响应”</tt>模式下，您需要有一个服务器来侦听发送到“请求队列”的消息，并将答复发送到<tt class="code">message.getJMSReplyTo（）</tt>引用的队列。</dd>
    <dt><tt class="code">读</tt></dt><dd>将从未连接侦听器的传出队列中读取消息。这可以方便进行测试。如果您需要在没有绑定文件的情况下处理队列，则可以使用此方法（如果使用jmeter-jms-skip-jndi库），该文件仅适用于JMS点对点采样器。如果使用绑定文件，则还可以使用JMS订阅服务器采样器从队列中读取。</dd>
    <dt><tt class="code">浏览</tt></dt><dd>将确定当前队列的深度，而不从队列中删除消息，并返回队列中的消息数。</dd>
    <dt><tt class="code">明确</tt></dt><dd>将清除队列，即从队列中删除所有消息。</dd>
    </dl>
  </td>
<td>是</td>
</tr>
<tr>
<td>使用备用字段进行消息关联</td>
<td>这些复选框选择用于将响应消息与原始请求进行匹配的字段。<dl>
    <dt><tt class="code">使用请求消息ID</tt></dt><dd>如果选择，将使用请求JMSMessageID，否则将使用请求JMSCorrelationID。在后一种情况下，必须在请求中指定相关性ID。</dd>
    <dt><tt class="code">使用响应消息ID</tt></dt><dd>如果选择，将使用响应JMSMessageID，否则将使用响应JMSCorrelationID。
    </dd>
    </dl>有两种常用的JMS关联模式：<dl>
    <dt>JMS关联ID模式</dt>
    <dd>也就是说，在相关ID上匹配请求和响应=>取消选中两个复选框，并提供相关ID。</dd>
    <dt>JMS消息ID模式</dt>
    <dd>即，将请求消息ID与响应相关ID匹配=>仅选择“使用请求消息ID”。
    </dd>
    </dl>在这两种情况下，JMS应用程序都负责根据需要填充相关性ID。
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果使用相同的队列发送和接收消息，则响应消息将与请求消息相同。在这种情况下，请提供相关ID并清除两个复选框；或选中两个复选框以使用消息ID进行关联。这对于检查原始JMS吞吐量很有用。</td></tr>
</tbody></table>
<p></p>

  </td>
<td>是</td>
</tr>
<tr>
<td>超时</td>
<td>答复消息的超时时间（以毫秒为单位）。如果在指定时间内未收到答复，则特定测试用例将失败，并且超时后收到的特定答复消息将被丢弃。默认值为<tt class="code">2000</tt>毫秒。 <tt class="code">0</tt>表示没有超时。
  </td>
<td>是</td>
</tr>
<tr>
<td>期满</td>
<td>消息过期之前的过期时间（以毫秒为单位）。如果未指定到期时间，则默认值为<tt class="code">0</tt> （永不到期）。
  </td>
<td>没有</td>
</tr>
<tr>
<td>优先</td>
<td>消息的优先级。从<tt class="code">0</tt> （最低）到<tt class="code">9</tt> （最高）有十个优先级。如果未指定优先级，则默认级别为<tt class="code">4</tt> 。
  </td>
<td>没有</td>
</tr>
<tr>
<td>使用非持久交付模式？</td>
<td>是否设置<tt class="code">DeliveryMode。NON_PERSISTENT</tt> 。</td>
<td>是</td>
</tr>
<tr>
<td>内容</td>
<td>消息的内容。
  </td>
<td>没有</td>
</tr>
<tr>
<td>JMS属性</td>
<td>JMS属性是特定于基础消息系统的属性。您可以设置名称，值和值的类（类型）。默认类型为<tt class="code">String</tt> 。例如：对于WebSphere 5.1 Web服务，您将需要设置JMS属性targetService以通过JMS测试Web服务。</td>
<td>没有</td>
</tr>
<tr>
<td>初始上下文工厂</td>
<td>初始上下文工厂是用于查找JMS资源的工厂。
  </td>
<td>没有</td>
</tr>
<tr>
<td>JNDI属性</td>
<td>JNDI属性是基础JNDI实现的特定属性。
  </td>
<td>没有</td>
</tr>
<tr>
<td>提供商URL</td>
<td>JMS提供程序的URL。
  </td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JUnit_Request">18.1.16 JUnit请求</a>
</h3>
</font>
</td></tr>
<tr><td>当前实现支持标准的JUnit约定和扩展。它还包括诸如<tt class="code">oneTimeSetUp</tt>和<tt class="code">oneTimeTearDown的</tt>扩展。采样器的工作方式类似于<a href="../usermanual/component_reference.html#Java_Request">Java Request</a> ，但有所不同。
<ul>
<li>而不是使用JMeter的测试接口，它会在jar文件中扫描扩展JUnit的<tt class="code">TestCase</tt>类的类。这包括任何类或子类。</li>
<li>JUnit测试jar文件应放在<tt class="code">jmeter / lib / junit中，</tt>而不是<tt class="code">/ lib</tt>目录中。您还可以使用“ <tt class="code">user.classpath</tt> ”属性来指定在何处查找<tt class="code">TestCase</tt>类。</li>
<li>JUnit采样器不使用名称/值对进行配置，例如<a href="../usermanual/component_reference.html#Java_Request">Java Request</a> 。采样器假定<tt class="code">setUp</tt>和<tt class="code">tearDown</tt>将正确配置测试。</li>
<li>采样器仅测量测试方法的经过时间，不包括<tt class="code">setUp</tt>和<tt class="code">tearDown</tt> 。</li>
<li>每次调用测试方法时，JMeter会将结果传递给侦听器。</li>
<li>对<tt class="code">oneTimeSetUp</tt>和<tt class="code">oneTimeTearDown的</tt>支持是通过一种方法完成的。由于JMeter是多线程的，因此我们无法像Maven一样调用<tt class="code">oneTimeSetUp</tt> / <tt class="code">oneTimeTearDown</tt> 。</li>
<li>采样器将意外的异常报告为错误。标准的JUnit测试运行程序和JMeter的实现之间有一些重要的区别。JMeter不会为每个测试创建该类的新实例，而是为每个采样器创建1个实例并重用它。可以通过复选框“ <tt class="code">为每个样本创建一个新实例</tt> ”来更改。</li>
</ul>采样器的当前实现将首先尝试使用字符串构造函数创建实例。如果测试类未声明字符串构造函数，则采样器将查找空的构造函数。下面的例子： <a name="junit_constructor_example"></a>
<p><b>JUnit构造函数</b></p>空构造函数：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public class myTestCase {
  public myTestCase() {}
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>字符串构造函数：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public class myTestCase {
  public myTestCase(String text) {
    super(text);
  }
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>默认情况下，JMeter将为成功/失败代码和消息提供一些默认值。用户应定义一组唯一的成功和失败代码，并在所有测试中统一使用它们。
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<h3>一般准则</h3>如果使用<tt class="code">setUp</tt>和<tt class="code">tearDown</tt> ，请确保将这些方法声明为public。否则，测试可能无法正常运行。
<br>这里是一些编写JUnit测试的通用准则，因此它们可以与JMeter一起很好地工作。由于JMeter运行多线程，因此牢记某些事情很重要。
<ul>
<li>编写<tt class="code">setUp</tt>和<tt class="code">tearDown</tt>方法，使它们是线程安全的。这通常意味着避免使用静态成员。</li>
<li>使测试方法成为离散的工作单元，而不是冗长的动作序列。通过将测试方法保持为离散操作，可以更轻松地组合测试方法以创建新的测试计划。</li>
<li>避免使测试方法相互依赖。由于JMeter允许对测试方法进行任意排序，因此运行时行为与默认JUnit行为不同。</li>
<li>如果测试方法是可配置的，请注意属性的存储位置。建议从Jar文件中读取属性。</li>
<li>每个采样器都会创建测试类的实例，因此编写测试，以便在<tt class="code">oneTimeSetUp</tt>和<tt class="code">oneTimeTearDown中进行设置</tt> 。</li>
</ul>
</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="397" height="536" src="../images/screenshots/junit_sampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>搜索JUnit4批注</td>
<td>选择此项以搜索JUnit4测试（ <tt class="code">@Test</tt>批注）</td>
<td>是</td>
</tr>
<tr>
<td>包装过滤器</td>
<td>以逗号分隔的软件包列表显示。例如， <tt class="code">org.apache.jmeter</tt> ， <tt class="code">junit.framework</tt> 。</td>
<td>没有</td>
</tr>
<tr>
<td>班级名称</td>
<td>JUnit测试类的全限定名称。</td>
<td>是</td>
</tr>
<tr>
<td>构造子字符串</td>
<td>字符串传递给字符串构造函数。如果设置了字符串，则采样器将使用字符串构造函数而不是空构造函数。</td>
<td>没有</td>
</tr>
<tr>
<td>测试方法</td>
<td>测试方法。</td>
<td>是</td>
</tr>
<tr>
<td>成功讯息</td>
<td>描述性消息，指示成功的含义。</td>
<td>没有</td>
</tr>
<tr>
<td>成功代码</td>
<td>表示测试成功的唯一代码。</td>
<td>没有</td>
</tr>
<tr>
<td>失败讯息</td>
<td>描述性消息，指示故障的含义。</td>
<td>没有</td>
</tr>
<tr>
<td>失败码</td>
<td>指示测试失败的唯一代码。</td>
<td>没有</td>
</tr>
<tr>
<td>错误信息</td>
<td>错误说明。</td>
<td>没有</td>
</tr>
<tr>
<td>错误代码</td>
<td>一些错误代码。不需要唯一。</td>
<td>没有</td>
</tr>
<tr>
<td>不要调用setUp和tearDown</td>
<td>设置采样器不要调用<tt class="code">setUp</tt>和<tt class="code">tearDown</tt> 。默认情况下，应调用<tt class="code">setUp</tt>和<tt class="code">tearDown</tt> 。不调用这些方法可能会影响测试并使其不准确。此选项仅应与调用<tt class="code">oneTimeSetUp</tt>和<tt class="code">oneTimeTearDown一起使用</tt> 。如果所选方法是<tt class="code">oneTimeSetUp</tt>或<tt class="code">oneTimeTearDown</tt> ，则应选中此选项。</td>
<td>是</td>
</tr>
<tr>
<td>附加断言错误</td>
<td>是否将断言错误附加到响应消息。</td>
<td>是</td>
</tr>
<tr>
<td>附加运行时异常</td>
<td>是否将运行时异常附加到响应消息。仅在未选择“ <tt class="code">追加断言错误</tt> ”的情况下适用。</td>
<td>是</td>
</tr>
<tr>
<td>为每个样本创建一个新实例</td>
<td>是否为每个样本创建一个新的JUnit实例。默认为false，表示JUnit <tt class="code">TestCase</tt>被创建并重新使用。</td>
<td>是</td>
</tr>
</tbody></table>
<p>可以识别以下JUnit4批注：</p><dl>
<dt><tt class="code">@测试</tt></dt><dd>用于查找测试方法和类。支持“ <tt class="code">期望</tt> ”和“ <tt class="code">超时</tt> ”属性。</dd>
<dt><tt class="code">@之前</tt></dt><dd>与JUnit3中的<tt class="code">setUp（）</tt>相同</dd>
<dt><tt class="code">@后</tt></dt><dd>与JUnit3中的<tt class="code">tearDown（）</tt>相同</dd>
<dt><tt class="code">@ BeforeClass</tt> ，@ <tt class="code">AfterClass</tt></dt><dd>被视为测试方法，因此它们可以根据需要独立运行</dd>
</dl><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意，JMeter当前直接运行测试方法，而不是将其留给JUnit。这是为了将<tt class="code">setUp</tt> / <tt class="code">tearDown</tt>方法从采样时间中排除。结果，采样器时间不包括调用<tt class="code">setUp</tt> / <tt class="code">tearDown</tt>方法及其基于注释的替代方法所花费的时间。
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Mail_Reader_Sampler">18.1.17邮件阅读器采样器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>邮件阅读器采样器可以使用POP3（S）或IMAP（S）协议读取（和删除）邮件消息。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="595" height="413" src="../images/screenshots/mailreader_sampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器类型</td>
<td>提供者使用的协议：例如<tt class="code">pop3</tt> ， <tt class="code">pop3s</tt> ， <tt class="code">imap</tt> ， <tt class="code">imaps</tt> 。或代表服务器协议的另一个字符串。有关在只读邮件文件提供使用示例<tt class="code">文件</tt> 。POP3和IMAP的实际提供程序名称是<tt class="code">pop3</tt>和<tt class="code">imap</tt>
</td>
<td>是</td>
</tr>
<tr>
<td>服务器</td>
<td>服务器的主机名或IP地址。请参阅以下<tt class="code">文件</tt>协议。</td>
<td>是</td>
</tr>
<tr>
<td>港口</td>
<td>用于连接服务器的端口（可选）</td>
<td>没有</td>
</tr>
<tr>
<td>用户名</td>
<td>用户登录名</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>用户登录密码（注意，此密码未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
<tr>
<td>夹</td>
<td>要使用的IMAP（S）文件夹。请参阅以下<tt class="code">文件</tt>协议。</td>
<td>是，如果使用IMAP</td>
</tr>
<tr>
<td>要检索的消息数</td>
<td>设置为检索全部或部分消息</td>
<td>是</td>
</tr>
<tr>
<td>仅获取标题</td>
<td>如果选择，将仅检索邮件标题。</td>
<td>是</td>
</tr>
<tr>
<td>从服务器删除消息</td>
<td>如果设置，则检索后将删除邮件</td>
<td>是</td>
</tr>
<tr>
<td>使用MIME存储消息</td>
<td>是否将消息存储为MIME。如果是这样，则将整个原始消息存储在响应数据中；否则，将所有原始消息存储在响应数据中。标头未存储，因为它们在数据中可用。如果不是，则消息头存储为响应头。正文中存储了一些标头（ <tt class="code">Date</tt> ， <tt class="code">To</tt> ， <tt class="code">From</tt> ， <tt class="code">Subject</tt> ）。
</td>
<td>是</td>
</tr>
<tr>
<td>不使用安全功能</td>
<td>指示与服务器的连接不使用任何安全协议。</td>
<td>没有</td>
</tr>
<tr>
<td>使用SSL</td>
<td>表示与服务器的连接必须使用SSL协议。</td>
<td>没有</td>
</tr>
<tr>
<td>使用StartTLS</td>
<td>指示与服务器的连接应尝试启动TLS协议。</td>
<td>没有</td>
</tr>
<tr>
<td>强制执行StartTLS</td>
<td>如果服务器未启动TLS协议，则连接将终止。</td>
<td>没有</td>
</tr>
<tr>
<td>信任所有证书</td>
<td>选择后，它将接受独立于CA的所有证书。</td>
<td>没有</td>
</tr>
<tr>
<td>使用本地信任库</td>
<td>选中后，它将仅接受本地信任的证书。</td>
<td>没有</td>
</tr>
<tr>
<td>本地信任库</td>
<td>包含受信任证书的文件的路径。相对路径针对当前目录进行解析。
<br>失败，针对包含测试脚本（JMX文件）的目录。
</td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>您可以通过向user.properties添加<a href="https://javaee.github.io/javamail/docs/api/com/sun/mail/pop3/package-summary.html">此处</a>描述的任何属性来传递与邮件相关的环境属性。</td></tr>
</tbody></table>
<p></p>
<p>消息存储为主采样器的子采样。多部分消息部分存储为消息的子样本。
</p><p>
<b>“ <tt class="code">文件</tt> ”协议的特殊处理：</b><br><tt class="code">文件</tt> JavaMail提供程序可用于从文件读取原始消息。<tt class="code">服务器</tt>字段用于指定<tt class="code">文件夹</tt>父<tt class="code">目录</tt>的路径。各个消息文件应以名称<tt class="code">n.msg</tt>进行存储，其中<tt class="code">n</tt>是消息号。或者， <tt class="code">服务器</tt>字段可以是包含单个消息的文件的名称。当前的实现是非常基本的，并且主要用于调试目的。
</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<a name="Test_Action"></a>
<h3>
<a name="Flow_Control_Action">18.1.18流量控制操作（以前是：测试操作）</a>
</h3>
</font>
</td></tr>
<tr><td>Flow Control Action采样器是旨在用于条件控制器中的采样器。测试元素不是生成样本，而是暂停或停止选定的目标。
<p>该采样器还可以与Transaction Controller一起使用，因为它允许包含暂停而无需生成采样。对于可变延迟，请将暂停时间设置为零，然后将Timer作为子级添加。</p>
<p>完成所有正在进行的样本后，“ <tt class="code">停止</tt> ”操作将停止线程或测试。“ <tt class="code">立即停止</tt> ”操作将停止测试，而无需等待样本完成。它将中断所有活动样本。如果某些线程未能在5秒的时限内停止，则将以GUI模式显示一条消息。您可以尝试使用<tt class="code">Stop</tt>命令查看它是否将停止线程，但是如果不停止，则应退出JMeter。在CLI模式下，如果某些线程未能在5秒的时间内停止，JMeter将退出。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>可以使用JMeter属性<tt class="code">jmeterengine.threadstop.wait</tt>更改等待时间。时间以毫秒为单位。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p><b>控制面板</b></p>
<div align="center"><img width="467" height="184" src="../images/screenshots/test_action.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>目标</td>
<td><tt class="code">当前线程</tt> / <tt class="code">所有线程</tt> （ <tt class="code">暂停</tt>和<tt class="code">进入下一个循环迭代</tt> <tt class="code">均被</tt>忽略）</td>
<td>是</td>
</tr>
<tr>
<td>行动</td>
<td><tt class="code">暂停</tt> / <tt class="code">停止</tt> / <tt class="code">立即停止</tt> / <tt class="code">转到下一个循环迭代</tt></td>
<td>是</td>
</tr>
<tr>
<td>持续时间</td>
<td>暂停多长时间（毫秒）</td>
<td>是的，如果选择了暂停</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="SMTP_Sampler">18.1.19 SMTP采样器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>SMTP采样器可以使用SMTP / SMTPS协议发送邮件。可以为连接设置安全协议（SSL和TLS）以及用户身份验证。如果使用安全协议，则将对服务器证书进行验证。<br>有两种方法可以处理此验证：<br>

</p>
<dl>
<dt><tt class="code">信任所有证书</tt></dt><dd>这将忽略证书链验证</dd>
<dt><tt class="code">使用本地信任库</tt></dt><dd>使用此选项，将针对本地信任库文件验证证书链。</dd>
</dl>
<p><b>控制面板</b></p>
<div align="center"><img width="825" height="728" src="../images/screenshots/smtp_sampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>服务器</td>
<td>服务器的主机名或IP地址。请参阅以下<tt class="code">文件</tt>协议。</td>
<td>是</td>
</tr>
<tr>
<td>港口</td>
<td>用于连接服务器的端口。默认值是：SMTP = 25，SSL = 465，StartTLS = 587</td>
<td>没有</td>
</tr>
<tr>
<td>连接超时</td>
<td>连接超时值（以毫秒为单位）（套接字级别）。默认值为无限超时。</td>
<td>没有</td>
</tr>
<tr>
<td>读取超时</td>
<td>读取超时值（以毫秒为单位）（套接字级别）。默认值为无限超时。</td>
<td>没有</td>
</tr>
<tr>
<td>地址来自</td>
<td>出现在电子邮件中的发件人地址</td>
<td>是</td>
</tr>
<tr>
<td>写给</td>
<td>目标电子邮件地址（多个值，用“ <tt class="code">;</tt> ”分隔）</td>
<td>是的，除非指定了抄送或密件抄送</td>
</tr>
<tr>
<td>抄送地址</td>
<td>复本目的地的电子邮件地址（多个值用“ <tt class="code">;</tt> ”分隔）</td>
<td>没有</td>
</tr>
<tr>
<td>地址到密件抄送</td>
<td>抄送目的地盲目电子邮件地址（多个值用“ <tt class="code">;</tt> ”分隔）</td>
<td>没有</td>
</tr>
<tr>
<td>地址回复</td>
<td>备用回复地址（多个值以“ <tt class="code">;</tt> ”分隔）</td>
<td>没有</td>
</tr>
<tr>
<td>使用验证</td>
<td>指示SMTP服务器是否需要用户身份验证</td>
<td>没有</td>
</tr>
<tr>
<td>用户名</td>
<td>用户登录名</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>用户登录密码（注意，此密码未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
<tr>
<td>不使用安全功能</td>
<td>表示与SMTP服务器的连接不使用任何安全协议。</td>
<td>没有</td>
</tr>
<tr>
<td>使用SSL</td>
<td>表示与SMTP服务器的连接必须使用SSL协议。</td>
<td>没有</td>
</tr>
<tr>
<td>使用StartTLS</td>
<td>指示与SMTP服务器的连接应尝试启动TLS协议。</td>
<td>没有</td>
</tr>
<tr>
<td>强制执行StartTLS</td>
<td>如果服务器未启动TLS协议，则连接将终止。</td>
<td>没有</td>
</tr>
<tr>
<td>信任所有证书</td>
<td>选择后，它将接受独立于CA的所有证书。</td>
<td>没有</td>
</tr>
<tr>
<td>使用本地信任库</td>
<td>选中后，它将仅接受本地信任的证书。</td>
<td>没有</td>
</tr>
<tr>
<td>本地信任库</td>
<td>包含受信任证书的文件的路径。相对路径针对当前目录进行解析。
<br>失败，针对包含测试脚本（JMX文件）的目录。
</td>
<td>没有</td>
</tr>
<tr>
<td>覆盖系统SSL / TLS协议</td>
<td>将自定义SSL / TLS协议指定为以空格分隔的列表，以用于握手示例<tt class="code">TLSv1 TLSv1.1 TLSv1.2</tt> 。默认为所有支持的协议。</td>
<td>没有</td>
</tr>
<tr>
<td>学科</td>
<td>电子邮件主题。</td>
<td>没有</td>
</tr>
<tr>
<td>禁止主题标题</td>
<td>如果选中，则从发送的邮件中省略“ <tt class="code">Subject：</tt> ”标题。这与发送空的“ <tt class="code">Subject：</tt> ”标头不同，尽管某些电子邮件客户端可能会相同地显示它。</td>
<td>没有</td>
</tr>
<tr>
<td>在主题中包含时间戳</td>
<td>在主题行中包含<tt class="code">System.currentTimemillis（）</tt> 。</td>
<td>没有</td>
</tr>
<tr>
<td>添加标题</td>
<td>可以使用此按钮定义其他标题。</td>
<td>没有</td>
</tr>
<tr>
<td>信息</td>
<td>邮件正文。</td>
<td>没有</td>
</tr>
<tr>
<td>发送简单的正文（即非分段/混合）</td>
<td>如果选中，则将主体作为普通消息发送，即，如果可能的话，不要进行<tt class="code">多部分/混合</tt> 。如果消息正文为空并且只有一个文件，则将文件内容作为消息正文发送。
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：如果邮件正文不为空，并且至少有一个附件，则该正文将作为<tt class="code">multipart / mixed</tt>发送。
</td></tr>
</tbody></table>
<p></p>

</td>
<td>没有</td>
</tr>
<tr>
<td>附加档案</td>
<td>要附加到邮件的文件。</td>
<td>没有</td>
</tr>
<tr>
<td>发送.eml</td>
<td>如果设置，将发送<tt class="code">.eml</tt>文件，而不发送<tt class="code">主题</tt> ， <tt class="code">消息</tt>和<tt class="code">附加文件</tt>字段中的条目。</td>
<td>没有</td>
</tr>
<tr>
<td>计算邮件大小</td>
<td>计算消息大小并将其存储在样本结果中。</td>
<td>没有</td>
</tr>
<tr>
<td>启用调试日志记录？</td>
<td>如果设置，则“ <tt class="code">mail.debug</tt> ”属性设置为“ <tt class="code">true</tt> ”</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="OS_Process_Sampler">18.1.20 OS Process Sampler</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>OS Process Sampler是一个采样器，可用于在本地计算机上执行命令。<br>它应该允许执行可以从命令行运行的任何命令。<br>可以启用返回码的验证，并可以指定期望的返回码。<br>

</p>
<p>请注意，操作系统外壳程序通常提供命令行解析。这在操作系统之间有所不同，但是通常外壳程序会在空白处分割参数。某些shell会扩展通配符文件名。有些没有。操作系统之间的报价机制也有所不同。采样器故意不执行任何解析或报价处理。该命令及其参数必须以可执行文件期望的形式提供。这意味着采样器设置将无法在操作系统之间移植。
</p>
<p>许多操作系统具有一些内置命令，这些命令未作为单独的可执行文件提供。例如，Windows <tt class="code">DIR</tt>命令是命令解释器（ <tt class="code">CMD.EXE</tt> ）的一部分。这些内置程序不能作为独立程序运行，而必须作为参数提供给适当的命令解释器。
</p>
<p>例如，Windows命令行： <tt class="code">DIR C：\ TEMP</tt>需要指定如下：</p>
<dl>
<dt>命令：</dt><dd><tt class="code">CMD</tt></dd>
<dt>参数1：</dt><dd><tt class="code">/C</tt></dd>
<dt>参数2：</dt><dd><tt class="code">目录</tt></dd>
<dt>参数3：</dt><dd><tt class="code">C：\ TEMP</tt></dd>
</dl>
<p><b>控制面板</b></p>
<div align="center"><img width="683" height="582" src="../images/screenshots/os_process_sampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>命令</td>
<td>要执行的程序名称。</td>
<td>是</td>
</tr>
<tr>
<td>工作目录</td>
<td>从中执行命令的目录，默认为“ <tt class="code">user.dir</tt> ”引用的文件夹系统属性</td>
<td>没有</td>
</tr>
<tr>
<td>命令参数</td>
<td>参数传递给程序名称。</td>
<td>没有</td>
</tr>
<tr>
<td>环境参数</td>
<td>运行命令时将键/值对添加到环境中。</td>
<td>没有</td>
</tr>
<tr>
<td>标准输入（标准输入）</td>
<td>要从中获取输入的文件的名称（ <tt class="code">STDIN</tt> ）。</td>
<td>没有</td>
</tr>
<tr>
<td>标准输出（标准输出</td>
<td>标准输出（ <tt class="code">STDOUT</tt> ）的输出文件的名称。如果省略，则捕获输出并作为响应数据返回。</td>
<td>没有</td>
</tr>
<tr>
<td>标准误差（stderr）</td>
<td>标准错误（ <tt class="code">STDERR</tt> ）的输出文件的名称。如果省略，则捕获输出并作为响应数据返回。</td>
<td>没有</td>
</tr>
<tr>
<td>检查退货代码</td>
<td>如果选中，采样器将比较返回码和<tt class="code">期望返回码</tt> 。</td>
<td>没有</td>
</tr>
<tr>
<td>预期返回码</td>
<td>系统调用的预期返回码，如果<tt class="code">选中</tt> “ <tt class="code">检查返回码</tt> ”，则为必填项。注意500在JMeter中用作错误指示符，因此您不应使用它。</td>
<td>没有</td>
</tr>
<tr>
<td>超时</td>
<td>命令的超时时间（以毫秒为单位），默认为<tt class="code">0</tt> ，表示<em>没有</em>超时。如果超时在命令完成之前到期，JMeter将尝试终止OS进程。
</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="MongoDB_Script_(DEPRECATED)">18.1.21 MongoDB脚本（已弃用）</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该采样器使您可以将请求发送到MongoDB。</p>
<p>在使用此功能之前，您需要设置一个<a href="../usermanual/component_reference.html#MongoDB_Source_Config">MongoDB Source Config</a> Configuration元素</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>该元素当前使用<tt class="code">com.mongodb。DB＃eval</tt>需要全局写锁定，从而对数据库产生性能影响，请参阅<a href="http://docs.mongodb.org/manual/reference/method/db.eval/"><tt class="code">db.eval（）</tt></a> 。因此，最好避免使用这个元素使用负载测试和使用JSR223 + Groovy脚本<a href="../api/org/apache/jmeter/protocol/mongodb/config/MongoDBHolder.html">MongoDBHolder</a>代替。MongoDB Script更适合功能测试或测试设置（设置/拆卸线程）</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="847" height="635" src="../images/screenshots/mongodb-script.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>MongoDB来源</td>
<td>MongoDB连接绑定到的JMeter变量的名称。这必须与MongoDB Source Config的“ <tt class="code">MongoDB Source</tt> ”字段一致。
        </td>
<td>是</td>
</tr>
<tr>
<td>数据库名称</td>
<td>数据库名称，将在您的脚本中使用</td>
<td>是</td>
</tr>
<tr>
<td>用户名</td>
<td>
        </td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>
        </td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>Mongo脚本，因为它将在MongoDB Shell中使用</td>
<td>是</td>
</tr>
</tbody></table>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="../usermanual/component_reference.html#MongoDB_Source_Config">MongoDB源配置</a></li>
</ul>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>确保变量名称在测试计划中是唯一的。</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a><table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Bolt_Request">18.1.22螺栓请求</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>该采样器允许您通过Bolt协议运行Cypher查询。</p>
        <p>在使用此功能之前，您需要设置<a href="../usermanual/component_reference.html#Bolt_Connection_Configuration">螺栓连接配置</a></p>
        <p>每个请求都使用从池中获取的连接，并在采样器完成时将其返回到池中。连接池大小使用驱动程序的默认值（〜100），目前无法配置。</p>
        <p>测得的响应时间对应于“完整”查询执行，包括执行密码查询的时间和使用数据库发送回的结果的时间。</p>
    <p><b>控制面板</b></p>
<div align="center"><img width="711" height="488" src="../images/screenshots/bolt-request.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>评论</td>
<td>免费文本以获取更多详细信息。</td>
<td>没有</td>
</tr>
<tr>
<td>密码声明</td>
<td>要执行的查询。
        </td>
<td>是</td>
</tr>
<tr>
<td>参数</td>
<td>参数值，JSON格式。</td>
<td>没有</td>
</tr>
<tr>
<td>记录查询结果</td>
<td>是否将查询结果数据添加到采样器响应（默认为false）。请注意，激活它会占用内存，请明智地使用它。
        </td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>强烈建议使用查询参数，以允许数据库缓存和重用执行计划。</td></tr>
</tbody></table>
<p></p>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="../usermanual/component_reference.html#Bolt_Connection_Configuration">螺栓连接配置</a></li>
</ul>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="logic_controllers"><strong>18.2逻辑控制器</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <br>

</div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Simple_Controller">18.2.1简单控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>使用简单逻辑控制器，您可以组织采样器和其他逻辑控制器。与其他逻辑控制器不同，该控制器不提供存储设备以外的功能。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="330" height="77" src="../images/screenshots/logic-controller/simple-controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
</tbody></table>
<a name="simple_controller_example"></a>
<p><b>使用简单控制器</b></p>

<p><a href="../demos/SimpleTestPlan.jmx">下载</a>此示例（请参见图6）。在此示例中，我们创建了一个测试计划，该计划发送了两个Ant HTTP请求和两个Log4J HTTP请求。我们通过将Ant和Log4J请求放入简单逻辑控制器中来对它们进行分组。记住，简单逻辑控制器对JMeter如何处理添加到它的控制器没有影响。因此，在此示例中，JMeter按照以下顺序发送请求：Ant主页，Ant新闻页面，Log4J主页，Log4J历史页面。</p>
<p>注意，File Reporter配置为将结果存储在当前目录中名为“ <tt class="code">simple-test.dat</tt> ”的文件中。</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="585" height="213" src="../images/screenshots/logic-controller/simple-example.png"><br>
<font size="-1">图6简单控制器示例</font></td></tr></tbody></table>


</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Loop_Controller">18.2.2回路控制器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>如果将生成控制器或逻辑控制器添加到循环控制器，则JMeter除了为线程组指定的循环值外，还将循环通过它们一定次数。例如，如果您将一个HTTP请求添加到循环计数为2的循环控制器，并将线程组循环计数配置为3，JMeter将总共发送<tt class="code">2 * 3 = 6个</tt> HTTP请求。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter将循环索引公开为名为<tt class="code">__jm__ <name of="" your="" element="">__idx</name></tt>的变量。因此，例如，如果您的循环控制器名为LC，则可以通过<tt class="code">$ {__ jm__LC__idx}</tt>访问循环索引。索引从0开始</td></tr>
</tbody></table>
<p></p>

<p></p><p><b>控制面板</b></p>
<div align="center"><img width="326" height="114" src="../images/screenshots/logic-controller/loop-controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>循环计数</td>
<td>每次通过测试运行，将迭代该控制器的子元素的次数。
                <p>值<tt class="code">-1</tt>等效于检查“ <tt class="code">永久”</tt>切换。</p>
                <p><b>特殊情况：</b> <a href="test_plan.html#thread_group">线程组</a>元素中嵌入的循环控制器的行为略有不同。除非设置为永久，否则它将在完成给定的迭代次数后停止测试。</p>
                <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>在此字段中使用函数时，请注意可能会对其进行多次评估。使用<tt class="code"><a href="../usermanual/functions.html#__Random">__Random的</a></tt>示例将为Loop Controller的每个子采样器将其评估为不同的值，并导致不必要的行为。</td></tr>
</tbody></table>
<p></p>
</td>
<td>是的，除非选中“永远”</td>
</tr>
</tbody></table>
<a name="loop_example"></a>
<p><b>循环示例</b></p>


<p><a href="../demos/LoopTestPlan.jmx">下载</a>此示例（请参见图4）。在此示例中，我们创建了一个测试计划，该计划仅发送一次特定的HTTP请求一次，并发送五次其他HTTP请求。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="506" height="158" src="../images/screenshots/logic-controller/loop-example.png"><br>
<font size="-1">图4-循环控制器示例</font></td></tr></tbody></table>


<p>我们为单个线程配置了线程组，并且循环计数值为1。我们没有让线程组控制循环，而是使用了循环控制器。可以看到，我们向线程组添加了一个HTTP请求，并向循环控制器添加了另一个HTTP请求。我们为循环控制器配置的循环计数值为5。</p>
<p>JMeter将按照以下顺序发送请求：主页，新闻页面，新闻页面，新闻页面，新闻页面和新闻页面。</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意，文件报告器配置为将结果存储在当前目录中名为“ <tt class="code">loop-test.dat</tt> ”的文件中。</td></tr>
</tbody></table>
<p></p>


</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Once_Only_Controller">18.2.3一次性控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>“仅逻辑控制器”告诉JMeter每个线程仅对其内部的控制器进行一次处理，并在进一步迭代期间通过测试计划传递其下的所有请求。</p>

<p>现在，“一次控制器”将始终在任何循环父控制器的第一次迭代期间执行。因此，如果将“仅一次控制器”放置在指定要循环5次的循环控制器下，则“一次控制器”将仅在通过循环控制器的第一次迭代中执行（即每5次）。</p>
<p>请注意，这意味着如果将“一次控制器”放置在“线程组”下（每个线程每个测试仅运行一次），仍然会像以前预期的那样运行，但是现在用户在使用“一次控制器”时有了更大的灵活性。</p>

<p>对于需要登录的测试，请考虑将登录请求放置在此控制器中，因为每个线程只需要登录一次即可建立会话。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="330" height="78" src="../images/screenshots/logic-controller/once-only-controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
</tbody></table>
<a name="once_only_example"></a>
<p><b>仅一次示例</b></p>

<p><a href="../demos/OnceOnlyTestPlan.jmx">下载</a>此示例（请参见图5）。在此示例中，我们创建了一个测试计划，该计划具有两个发送HTTP请求的线程。每个线程向主页发送一个请求，然后向错误页面发送三个请求。尽管我们将线程组配置为迭代3次，但是每个JMeter线程仅将一个请求发送到主页，因为该请求位于“仅一次控制器”中。</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="233" height="138" src="../images/screenshots/logic-controller/once-only-example.png"><br>
<font size="-1">图5。仅一次控制器示例</font></td></tr></tbody></table>

<p>每个JMeter线程将按以下顺序发送请求：主页，错误页面，错误页面，错误页面。</p>
<p>注意，文件报告器配置为将结果存储在当前目录中名为“ <tt class="code">loop-test.dat</tt> ”的文件中。</p>

</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Interleave_Controller">18.2.4交错控制器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>如果将“生成控制器”或“逻辑控制器”添加到“交错控制器”，JMeter将在每个其他控制器之间交替进行每次循环迭代。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="626" height="127" src="../images/screenshots/logic-controller/interleave-controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>忽略子控制器块</td>
<td>如果选中，则交错控制器将把子控制器视为单个请求元素，并且一次只允许每个控制器一个请求。</td>
<td>没有</td>
</tr>
<tr>
<td>跨线程交织</td>
<td>如果选中，则交错控制器将针对每个循环迭代在其每个子控制器之间交替，但在所有线程之间（例如，在具有4个线程和3个子控制器的配置中），在第一次迭代中，线程1将运行第一个子线程，线程2将运行第二个子线程，线程3第三个孩子，线程4第一个孩子，在下一次迭代中，每个线程将运行以下孩子控制器</td>
<td>没有</td>
</tr>
</tbody></table>
<a name="simple_interleave_example"></a>
<p><b>简单交错示例</b></p>


<p><a href="../demos/InterleaveTestPlan.jmx">下载</a>此示例（请参见图1）。在此示例中，我们将线程组配置为具有两个线程，并且循环计数为五个，每个线程总共十个请求。JMeter发送HTTP请求的顺序请参见下表。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="231" height="153" src="../images/screenshots/logic-controller/interleave.png"><br>
<font size="-1">图1-交错控制器示例1</font></td></tr></tbody></table>


<table>
<tbody><tr>
<td bgcolor="#039acc" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">循环迭代</font>
</td>
<td bgcolor="#039acc" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">每个JMeter线程发送这些HTTP请求</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">1个</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">新闻页面</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">1个</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">日志页</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">2</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">常见问题页面</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">2</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">日志页</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">3</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">阿甘页</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">3</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">日志页</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">4</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">由于控制器中没有其他请求，<br>JMeter重新开始并发送第一个HTTP请求，即新闻页面。</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">4</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">日志页</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">5</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">常见问题页面</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">5</font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">日志页</font>
</td>
</tr>
</tbody></table>



<a name="useful_interleave_example"></a>
<p><b>有用的交错示例</b></p>


<p><a href="../demos/InterleaveTestPlan2.jmx">下载</a>另一个示例（请参见图2）。在此示例中，我们将线程组配置为具有单个线程，并且循环计数为8。注意，测试计划有一个外部交错控制器，其中有两个交错控制器。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="251" height="250" src="../images/screenshots/logic-controller/interleave2.png"><br>
<font size="-1">图2-交错控制器示例2</font></td></tr></tbody></table>


<p>外部交错控制器在两个内部交错控制器之间交替。然后，每个内部交错控制器在每个HTTP请求之间交替。每个JMeter线程将按以下顺序发送请求：主页，交错，错误页面，交错，CVS页面，交错，以及FAQ页面，交错。</p>
<p>注意，File Reporter配置为将结果存储在当前目录中名为“ <tt class="code">interleave-test2.dat</tt> ”的文件中。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="257" height="253" src="../images/screenshots/logic-controller/interleave3.png"><br>
<font size="-1">图3-交错控制器示例3</font></td></tr></tbody></table>

<p>如果主交错控制器下的两个交错控制器是简单控制器，则顺序为：主页，CVS页面，交错，错误页面，常见问题页面，交错。</p>
<p>但是，如果在主交错控制器上选中了“ <tt class="code">忽略子控制器块</tt> ”，则顺序为：主页，交错，错误页面，交错，CVS页面，交错和常见问题页面，交错。</p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Random_Controller">18.2.5随机控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>随机逻辑控制器的行为与交错控制器类似，不同之处在于它不是按顺序通过其子控制器和采样器，而是在每次通过时随机选择一个。</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>多个控制器之间的交互会产生复杂的行为。对于随机控制器尤其如此。在假设任何给定的交互将产生什么结果之前进行实验</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="328" height="100" src="../images/screenshots/logic-controller/random-controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>忽略子控制器块</td>
<td>如果选中，则交错控制器将把子控制器视为单个请求元素，并且一次只允许每个控制器一个请求。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Random_Order_Controller">18.2.6随机顺序控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>随机顺序控制器与简单控制器非常相似，它最多将执行每个子元素一次，但是节点的执行顺序将是随机的。</p>
    <p><b>控制面板</b></p>
<div align="center"><img width="328" height="76" src="../images/screenshots/randomordercontroller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Throughput_Controller">18.2.7吞吐量控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>吞吐量控制器允许用户控制执行频率。有两种模式：</p><ul>
<li>执行百分比</li>
<li>总处决</li>
</ul>
<dl>
  <dt><tt class="code">执行百分比</tt></dt><dd>使控制器在测试计划中执行一定百分比的迭代。</dd>
  <dt><tt class="code">执行总数</tt></dt><dd>使控制器在执行一定数量的执行后停止执行。</dd>
</dl>与“一次控制器”一样，当父循环控制器重新启动时，将重置此设置。
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>该控制器的名称不正确，因为它不控制吞吐量。请参阅<a href="../usermanual/component_reference.html#Constant_Throughput_Timer">恒定吞吐量计时器</a>以获取可用于调整吞吐量的元素。
</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="329" height="167" src="../images/screenshots/throughput_controller.png"></div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>当与其他控制器结合使用时，吞吐量控制器可能会产生非常复杂的行为-特别是作为父级的交错或随机控制器（也非常有用）。</td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>执行方式</td>
<td>控制器将以百分比执行方式还是以总执行方式运行。</td>
<td>是</td>
</tr>
<tr>
<td>通量</td>
<td>一个号码。对于百分比执行模式，从<tt class="code">0</tt>到<tt class="code">100</tt>的数字表示控制器将执行的次数的百分比。 “ <tt class="code">50</tt> ”表示控制器将在整个测试计划的一半迭代中执行。对于总执行模式，该数字表示控制器将执行的总次数。</td>
<td>是</td>
</tr>
<tr>
<td>每位使用者</td>
<td>如果选中，则每个用户将使控制器计算是否应基于每个用户（每个线程）执行。如果未选中，则所有用户的计算将是全局的。例如，如果使用总执行模式，并且取消选中“ <tt class="code">每个用户</tt> ”，那么为吞吐量指定的数量将是执行的总数。如果选中“ <tt class="code">每个用户</tt> ”，则执行总数将是用户数乘以给定的吞吐量数。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Runtime_Controller">18.2.8运行时控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>运行时控制器控制其子代运行多长时间。控制器将运行其子级，直到超过已配置的<tt class="code">运行时间</tt> 。
        </p>
    <p><b>控制面板</b></p>
<div align="center"><img width="328" height="100" src="../images/screenshots/runtimecontroller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的该控制器的描述性名称，用于命名事务。</td>
<td>是</td>
</tr>
<tr>
<td>运行时间（秒）</td>
<td>所需的运行时间（以秒为单位）。 0表示不运行。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="If_Controller">18.2.9如果控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>If Controller允许用户控制其下的测试元素（其子元素）是否运行。</p>
        <p>默认情况下，条件在初始输入时仅评估一次，但是您可以选择对控制器中包含的每个可运行元素进行评估。
        </p>
        <p>最好的选择（默认值）是将“ <tt class="code">解释条件”</tt>检查<tt class="code">为“变量表达式”？</tt> ，然后在条件字段中有2个选项：</p><ul>
            <li>选项1：使用包含<tt class="code">true</tt>或<tt class="code">false</tt>的变量
            <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果要测试上一个样本是否成功，则可以使用<tt class="code">$ {JMeterThread.last_sample_ok}</tt>
            <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="815" height="260" src="../images/screenshots/if_controller_variable.png"><br>
<font size="-1">如果控制器使用变量</font></td></tr></tbody></table>

            </td></tr>
</tbody></table>
<p></p>

            </li>
            <li>选项2：使用函数（建议使用<tt class="code">$ {__ jexl3（）}</tt> ）来评估必须返回<tt class="code">true</tt>或<tt class="code">false</tt>的表达式
            <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="815" height="260" src="../images/screenshots/if_controller_expression.png"><br>
<font size="-1">如果控制器使用表达式</font></td></tr></tbody></table>

            </li>
        </ul>例如，以前可以使用以下条件： <tt class="code">$ {__ jexl3（$ {VAR} == 23）}</tt>并将其评估为<tt class="code">true</tt> / <tt class="code">false</tt> ，然后将结果传递给JavaScript，JavaScript随后将返回<tt class="code">true</tt> / <tt class="code">false</tt> 。如果选择了变量表达式选项，则无需使用JavaScript即可对表达式进行求值并将其与“ <tt class="code">true</tt> ”进行比较。
        <p></p>
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>要测试变量是否未定义（或为null），请执行以下操作，假设var名为<tt class="code">myVar</tt> ，表达式将为：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>&quot;${myVar}&quot; == &quot;\${myVar}&quot;</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>或使用：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>&quot;${myVar}&quot; != &quot;\${myVar}&quot;</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>测试变量是否已定义并且不为null。
        </td></tr>
</tbody></table>
<p></p>如果取消选中“ <tt class="code">解释条件为变量表达式”？</tt> ， <tt class="code">如果Controller</tt>会在内部使用javascript评估条件，这会导致性能损失很大，并使测试的可扩展性降低。
        <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="819" height="265" src="../images/screenshots/if_controller_javascript.png"><br>
<font size="-1">如果Controller使用JavaScript</font></td></tr></tbody></table>

    <p><b>控制面板</b></p>
<div align="center"><img width="819" height="265" src="../images/screenshots/if_controller_expression.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>条件（默认JavaScript）</td>
<td>默认情况下，条件被解释为返回“ <tt class="code">true</tt> ”或“ <tt class="code">false</tt> ”的<b>JavaScript</b>代码，但是可以覆盖此条件（请参见下文）</td>
<td>是</td>
</tr>
<tr>
<td>将条件解释为变量表达式？</td>
<td>如果选择此选项，则条件必须是计算结果为“ <tt class="code">true</tt> ”的表达式（忽略大小写）。例如， <tt class="code">$ {FOUND}</tt>或<tt class="code">$ {__ jexl3（$ {VAR}> 100）}</tt> 。与JavaScript情况不同，该条件仅检查其是否匹配“ <tt class="code">true</tt> ”（忽略大小写）。
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>建议检查并在Condition中使用<tt class="code"><a href="../usermanual/functions.html#__jexl3">__jexl3</a></tt>或<tt class="code"><a href="../usermanual/functions.html#__groovy">__groovy</a></tt>函数以提高性能。</td></tr>
</tbody></table>
<p></p>

    </td>
<td>是</td>
</tr>
<tr>
<td>为所有孩子评估</td>
<td>应该为所有儿童评估状况吗？如果未选中，则仅在输入时评估条件。
    </td>
<td>是</td>
</tr>
</tbody></table>
<a name="example_if_javascript"></a>
<p><b>范例（JavaScript）</b></p>

        <ul>
            <li><tt class="code">$ {COUNT} <10</tt></li>
            <li><tt class="code">“ $ {VAR}” ==“ abcd”</tt></li>
        </ul>如果在解释代码时出错，则假定条件为<tt class="code">false</tt> ，并且在<tt class="code">jmeter.log中</tt>记录了一条消息。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，建议避免使用JavaScript模式来提高性能。<br>
<br>使用<tt class="code"><a href="../usermanual/functions.html#__groovy">__groovy时，</a></tt>请注意不要在字符串中使用变量替换，否则，如果使用更改了脚本的变量，则无法缓存。而是使用<tt class="code">vars.get（“ myVar”）</tt>获取变量<tt class="code">。</tt>  请参阅下面的Groovy示例。</td></tr>
</tbody></table>
<p></p>

    <a name="example_if_variable"></a>
<p><b>实例（变量表达式）</b></p>

        <ul>
            <li><tt class="code">$ {__ groovy（vars.get（“ myVar”））！=“ Invalid”）}</tt> （检查myVar不等于Invalid）</li>
            <li><tt class="code">$ {__ groovy（vars.get（“ myInt”）。toInteger（）<= 4）}</tt> （检查myInt小于或等于4）</li>
            <li><tt class="code">$ {__ groovy（vars.get（“ myMissing”））！= null）}</tt> （仔细检查是否未设置myMissing变量）</li>
            <li><tt class="code">$ {__ jexl3（$ {COUNT} <10）}</tt></li>
            <li><tt class="code">$ {RESULT}</tt></li>
            <li><tt class="code">$ {JMeterThread.last_sample_ok}</tt> （检查最后一个样本是否成功）</li>
        </ul>
    </td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="While_Controller">18.2.10 While控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>While控制器将运行其子代，直到条件为“ <tt class="code">false</tt> ”。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter将循环索引公开为名为<tt class="code">__jm__ <name of="" your="" element="">__idx</name></tt>的变量。因此，例如，如果您的While Controller名为WC，则可以通过<tt class="code">$ {__ jm__WC__idx}</tt>访问循环索引。索引从0开始</td></tr>
</tbody></table>
<p></p>

<p></p>

<p>可能的条件值：</p>
<ul>
<li>空白-循环中的最后一个样本失败时退出循环</li>
<li><tt class="code">LAST-</tt>当循环中的最后一个样本失败时退出循环。如果循环之前的最后一个样本失败，请不要进入循环。</li>
<li>否则-当条件等于字符串“ <tt class="code">false</tt> ”时退出（或不进入）循环</li>
</ul>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>条件可以是最终计算为字符串“ <tt class="code">false</tt> ”的任何变量或函数。这允许根据需要使用<tt class="code"><a href="../usermanual/functions.html#__jexl3">__jexl3</a></tt> ， <tt class="code"><a href="../usermanual/functions.html#__groovy">__groovy</a></tt>函数，属性或变量。
</td></tr>
</tbody></table>
<p></p>

<br>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，对条件进行两次评估，一次是在开始对子代采样之前，一次是在子代采样结束时，因此将非幂等函数放入Condition中（例如<tt class="code"><a href="../usermanual/functions.html#__counter">__counter</a></tt> ）可能会带来问题。
</td></tr>
</tbody></table>
<p></p>

<br>例如：<ul>
    <li><tt class="code">$ {VAR}</tt> -其中其他测试元素将<tt class="code">VAR</tt>设置为false</li>
    <li><tt class="code">$ {__ jexl3（$ {C} == 10）}</tt></li>
    <li><tt class="code">$ {__ jexl3（“ $ {VAR2}” ==“ abcd”）}</tt></li>
    <li><tt class="code">$ {_ P（property）}</tt> -在其他位置将属性设置为“ <tt class="code">false</tt> ”</li>
</ul>
    <p><b>控制面板</b></p>
<div align="center"><img width="362" height="102" src="../images/screenshots/whilecontroller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的该控制器的描述性名称，用于命名事务。</td>
<td>没有</td>
</tr>
<tr>
<td>条件</td>
<td>空白， <tt class="code">LAST</tt>或变量/功能</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Switch_Controller">18.2.11开关控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>交换控制器的作用类似于<a href="../usermanual/component_reference.html#Interleave_Controller">交错控制器</a> ，因为它在每次迭代中运行一个从属元素，但不是按顺序运行它们，而是运行由开关值定义的元素。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>开关值也可以是名称。
</td></tr>
</tbody></table>
<p></p>

<p>如果开关值超出范围，它将运行第零个元素，因此它是数字情况的默认值。如果该值为空字符串，它还将运行第零个元素。</p>
<p>如果该值是非数字（非空），则交换控制器将查找具有相同名称的元素（区分大小写）。如果两个名称都不匹配，则选择名为“ <tt class="code">default</tt> ”的元素（大小写无关）。如果没有默认值，则不会选择任何元素，并且控制器将不会运行任何内容。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="361" height="106" src="../images/screenshots/switchcontroller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>切换值</td>
<td>要调用的下级元素的编号（或名称）。元素从0开始编号。默认为0</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="ForEach_Controller">18.2.12 ForEach控制器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>ForEach控制器遍历一组相关变量的值。当您将采样器（或控制器）添加到ForEach控制器时，每个样本（或控制器）将执行一次或多次，其中在每个循环期间，变量都有一个新值。输入应包含几个变量，每个变量都带有下划线和数字。每个此类变量必须具有一个值。因此，例如，当输入变量的名称为<tt class="code">inputVar时</tt> ，应定义以下变量：</p>
        <ul>
        <li><tt class="code">inputVar_1 =温迪</tt></li>
        <li><tt class="code">inputVar_2 =查尔斯</tt></li>
        <li><tt class="code">inputVar_3 =彼得</tt></li>
        <li><tt class="code">inputVar_4 =约翰</tt></li>
        </ul>
        <p>注意：“ <tt class="code">_</tt> ”分隔符现在是可选的。</p>
<p>当将返回变量指定为“ <tt class="code">returnVar</tt> ”时，ForEach控制器下的采样器和控制器的收集将连续执行<tt class="code">4</tt>次，并且返回变量具有上述各自的值，然后可以在采样器中使用它们。
</p>
<p></p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter将循环索引公开为名为<tt class="code">__jm__ <name of="" your="" element="">__idx</name></tt>的变量。因此，例如，如果您的循环控制器名为FEC，则可以通过<tt class="code">$ {__ jm__FEC__idx}</tt>访问循环索引。索引从0开始</td></tr>
</tbody></table>
<p></p>
<p></p>
<p>它特别适合与正则表达式后处理器一起运行。这样可以从先前请求的结果数据中“创建”必要的输入变量。通过省略“ <tt class="code">_</tt> ”分隔符，可以使用输入变量<tt class="code">refName_g</tt>来使用ForEach Controller遍历所有组，也可以使用<tt class="code">refName _ $ {C</tt>形式的输入变量来<tt class="code">遍历</tt>所有匹配项中的所有组。 <tt class="code">} _g</tt> ，其中<tt class="code">C</tt>是计数器变量。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果<tt class="code">inputVar_1</tt>为<tt class="code">null，</tt>则ForEach控制器不会运行任何样本。如果正则表达式未返回匹配项，则将是这种情况。</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="342" height="193" src="../images/screenshots/logic-controller/foreach-controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>输入变量前缀</td>
<td>变量名称的前缀用作输入。默认为一个空字符串作为前缀。</td>
<td>没有</td>
</tr>
<tr>
<td>开始循环索引</td>
<td>循环变量的起始索引（不包括）（第一个元素位于起始索引+1）</td>
<td>没有</td>
</tr>
<tr>
<td>循环结束索引</td>
<td>结束索引（含），用于循环遍历变量</td>
<td>没有</td>
</tr>
<tr>
<td>输出变量</td>
<td>可以在循环中用于在采样器中进行替换的变量的名称。默认为空变量名，很可能不需要。</td>
<td>没有</td>
</tr>
<tr>
<td>使用分隔符</td>
<td>如果未选中，则省略“ <tt class="code">_</tt> ”分隔符。</td>
<td>是</td>
</tr>
</tbody></table>
<a name="foreach_example"></a>
<p><b>每个例子</b></p>


<p><a href="../demos/forEachTestPlan.jmx">下载</a>此示例（请参见图7）。在此示例中，我们创建了一个测试计划，该计划仅发送一个特定的HTTP请求一次，并将另一个HTTP请求发送给页面上可以找到的每个链接。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="300" height="158" src="../images/screenshots/logic-controller/foreach-example.png"><br>
<font size="-1">图7-ForEach控制器示例</font></td></tr></tbody></table>


<p>我们为单个线程配置了线程组，并且循环计数值为1。您可以看到我们向线程组添加了一个HTTP请求，并且向ForEach控制器添加了另一个HTTP请求。</p>
<p>在第一个HTTP请求之后，添加了一个正则表达式提取器，该提取器<tt class="code">将从</tt>返回页面中提取所有html链接并将其放入<tt class="code">inputVar</tt>变量中。</p>
<p>在ForEach循环中，添加了HTTP采样器，该采样器请求从第一个返回的HTML页面提取的所有链接。
</p><a name="foreach_example2"></a>
<p><b>每个例子</b></p>

<p>这是您可以下载的<a href="../demos/ForEachTest2.jmx">另一个示例</a> 。它具有两个正则表达式和ForEach控制器。第一个RE匹配，但是第二个RE不匹配，因此第二个ForEach控制器不运行任何样本</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="237" height="249" src="../images/screenshots/logic-controller/foreach-example2.png"><br>
<font size="-1">图8-ForEach控制器示例2</font></td></tr></tbody></table>

<p>线程组有一个线程，循环计数为两个。
</p><p>示例1使用JavaTest Sampler返回字符串“ <tt class="code">abcd</tt> ”。
</p><p>正则表达式提取器使用与后面跟有空格的字母匹配的表达式<tt class="code">（\ w）\ s</tt> ，并返回字母（而不是空格）。任何匹配项均以字符串“ <tt class="code">inputVar</tt> ”为前缀。
</p><p>ForEach控制器提取所有带有前缀“ <tt class="code">inputVar_</tt> ”的变量，并执行其示例，并将值传递给变量“ <tt class="code">returnVar</tt> ”。在这种情况下，它将依次将变量设置为值“ <tt class="code">a</tt> ”，“ <tt class="code">b</tt> ”和“ <tt class="code">c</tt> ”。
</p><p><tt class="code">For 1</tt>采样器是另一个Java采样器，它使用返回变量“ <tt class="code">returnVar</tt> ”作为采样Label的一部分和采样器Data。
</p><p><tt class="code">示例2</tt> ， <tt class="code">Regex 2</tt>和<tt class="code">For 2</tt>几乎相同，除了Regex已更改为“ <tt class="code">（\ w）\ sx</tt> ”，这显然不匹配。因此， <tt class="code">For 2</tt> Sampler将不会运行。
</p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Module_Controller">18.2.13模块控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>模块控制器提供了一种在运行时将测试计划片段替换为当前测试计划的机制。
</p>
<p>测试计划片段包括一个控制器和其中包含的所有测试元素（采样器等）。该片段可以位于任何线程组中。如果片段位于线程组中，则可以禁用其控制器，以防止片段被模块控制器运行。或者，您可以将片段存储在虚拟线程组中，并禁用整个线程组。
</p>
<p>可以有多个片段，每个片段下面都有不同系列的采样器。然后，只需在其下拉框中选择适当的控制器，即可使用模块控制器轻松地在多个测试用例之间切换。这为快速，轻松地运行许多备用测试计划提供了便利。
</p>
<p>片段名称由控制器名称及其所有父名称组成。例如：</p>
<pre>
Test Plan / Protocol: JDBC / Control / Interleave Controller (Module1)
</pre>
<p><b>模块控制器使用的</b>任何<b>片段都必须具有唯一的名称</b> ，因为该名称用于在重新加载测试计划时查找目标控制器。因此，最好确保将控制器名称更改为默认名称（如上例所示），否则当将新元素添加到测试计划中时，可能会意外地创建一个重复名称。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="526" height="318" src="../images/screenshots/module_controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>运行模块</td>
<td>模块控制器提供了已加载到gui中的所有控制器的列表。选择要在运行时替换的那个。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Include_Controller">18.2.14包含控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>包含控制器设计为使用外部JMX文件。要使用它，请在“测试计划”下创建一个“测试片段”，并在其下方添加任何所需的采样器，控制器等。然后保存测试计划。现在，该文件已准备好包含在其他测试计划中。</p>
<p>为了方便起见，也可以在外部JMX文件中添加<a href="../usermanual/component_reference.html#Thread_Group">线程组</a>以进行调试。可以使用<a href="../usermanual/component_reference.html#Module_Controller">模块控制器</a>来引用测试片段。在包含过程中， <a href="../usermanual/component_reference.html#Thread_Group">线程组</a>将被忽略。
</p>
<p>如果测试使用Cookie管理器或用户定义的变量，则应将其放置在顶级测试计划中，而不是包含的文件中，否则不能保证它们能正常工作。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>该元素在文件名字段中不支持变量/函数。<br>但是，如果定义了属性<tt class="code">includecontroller.prefix</tt> ，则将使用内容作为路径名的前缀。
</td></tr>
</tbody></table>
<p></p>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>使用Include Controller并包含相同的JMX文件时，请确保以不同的方式命名Include Controller，以避免遇到已知问题<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=50898">Bug 50898</a> 。
</td></tr>
</tbody></table>
<p></p>

<p>如果在<tt class="code">前缀</tt> + <tt class="code">Filename所</tt>给定的位置找不到<tt class="code">文件</tt> ，则控制器将尝试打开相对于JMX启动目录的<tt class="code">Filename</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="417" height="130" src="../images/screenshots/includecontroller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>文档名称</td>
<td>要包含的文件。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Transaction_Controller">18.2.15事务控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>事务控制器生成一个额外的样本，该样本测量执行嵌套测试元素所需的总时间。
        </p>
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：选中“ <tt class="code">在生成的样本</tt>中<tt class="code">包括计时器和前置处理器的持续时间</tt> ”复选框时，时间将包括控制器范围内的所有处理，而不仅仅是样本。
        </td></tr>
</tbody></table>
<p></p>

        <p>有两种操作模式：</p>
        <ul>
        <li>在嵌套样本之后添加其他样本</li>
        <li>添加了其他样本作为嵌套样本的父样本</li>
        </ul>
        <p>生成的采样时间包括嵌套采样器的所有时间，默认情况下（自2.11起）不包括计时器和前置/后处理器的处理时间，除非选中了“ <tt class="code">在生成的样本中包括计时器和前置处理器的持续时间</tt> ”复选框。根据时钟分辨率，它可能会比单个采样器加计时器的总和稍长。在控制器记录开始时间之后但在第一个采样开始之前，时钟可能会滴答。最后类似。
        </p>
        <p>如果生成的样本的所有子样本均成功，则仅将其视为成功。</p>
        <p>在父模式下，单个样本仍可以在“树视图”侦听器中看到，但不再在其他侦听器中显示为单独的条目。而且，子样本不会出现在CSV日志文件中，但可以保存到XML文件中。
        </p>
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>在父模式下，可以将断言（等）添加到事务控制器中。但是，默认情况下，它们将同时应用于单个样本和整个交易样本。要限制断言的范围，请使用“简单控制器”包含样本，然后将“断言”添加到“简单控制器”中。父模式控制器当前不正确支持这两种类型的嵌套事务控制器。
        </td></tr>
</tbody></table>
<p></p>

    <p><b>控制面板</b></p>
<div align="center"><img width="622" height="140" src="../images/screenshots/transactioncontroller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的该控制器的描述性名称，用于命名事务。</td>
<td>是</td>
</tr>
<tr>
<td>生成父样本</td>
<td>如果选中，则该样本将作为其他样本的父项生成，否则该样本将作为独立样本生成。
    </td>
<td>是</td>
</tr>
<tr>
<td>在生成的样本中包括计时器和前置处理器的持续时间</td>
<td>是否在生成的样本中包括计时器，预处理和后处理延迟。默认为<tt class="code">假</tt>
    </td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Recording_Controller">18.2.16记录控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>记录控制器是一个占位符，指示代理服务器应将样本记录到何处。在测试运行期间，它没有任何作用，类似于简单控制器。但是在使用<a href="../usermanual/component_reference.html#HTTP(S)_Test_Script_Recorder">HTTP（S）测试脚本记录器进行</a>记录的过程中，默认情况下，所有记录的样本将保存在“记录控制器”下。</p>

<p><b>控制面板</b></p>
<div align="center"><img width="420" height="79" src="../images/screenshots/logic-controller/recording-controller.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此控制器的描述性名称。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Critical_Section_Controller">18.2.17临界区控制器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>关键部分控制器确保其子元素（采样器/控制器等）将仅由一个线程执行，因为在执行控制器的子代之前将使用命名锁。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="469" height="129" src="../images/screenshots/logic-controller/critical-section-controller.png"></div>
<p>下图显示了使用关键部分控制器的示例，在下面的图中，两个关键部分控制器确保：</p><ul>
        <li><tt class="code">DS2-$ {__ threadNum}</tt>一次只能由一个线程执行</li>
        <li><tt class="code">DS4-$ {__ threadNum}</tt>一次只能由一个线程执行</li>
    </ul><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="276" height="237" src="../images/screenshots/logic-controller/critical-section-controller-tp.png"><br>
<font size="-1">使用关键部分控制器的测试计划</font></td></tr></tbody></table>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>锁名</td>
<td>控制器将采取的锁定，请确保对不相关的部分使用不同的锁定名称</td>
<td>是</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>关键部分控制器仅在一个JVM中进行锁定，因此，如果使用分布式测试，请确保您的用例不依赖于所有JVM阻塞的所有线程。
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="listeners"><strong>18.3听众</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <br>除了“侦听”测试结果外，大多数侦听器还扮演多个角色。它们还提供了查看，保存和读取保存的测试结果的方法。
<p>请注意，侦听器在发现它们的作用域的末尾进行处理。</p>
<p>测试结果的保存和读取是通用的。各种侦听器都有一个面板，通过该面板可以指定将结果写入（或读取）的文件。默认情况下，结果存储为XML文件，扩展名通常为“ <tt class="code">.jtl</tt> ”。以CSV格式存储是最有效的选择，但没有XML（其他可用选项）详细。
</p>
<p>
<b>侦听器<i>不会</i>在CLI模式下处理样本数据，但是如果已配置输出文件，则原始数据将被保存。</b>为了分析CLI运行生成的数据，您需要将文件加载到适当的Listener中。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>要读取并显示现有结果，请使用文件面板的“浏览”按钮打开文件。
</td></tr>
</tbody></table>
<p></p>

<p>如果要在加载新文件之前清除任何当前数据，请在加载文件之前使用菜单项<span class="menuchoice"><span class="guimenuitem">运行</span> → <span class="guimenuitem">清除</span> （ <span class="keycombo"><span class="keysym">Ctrl</span> + <span class="keysym">Shift</span> + <span class="keysym">E</span></span> ）</span>或<span class="menuchoice"><span class="guimenuitem">运行</span> → <span class="guimenuitem">全部清除</span> （ <span class="keycombo"><span class="keysym">Ctrl</span> + <span class="keysym">E</span></span> ）</span> 。
</p>
<p>可以从XML或CSV格式的文件中读取结果。从CSV结果文件读取时，标头（如果存在）用于确定存在哪些字段。
<b>为了正确解释无标题的CSV文件，必须在<tt class="code">jmeter.properties中</tt>设置适当的属性。</b>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>由JMeter编写的XML文件的标头中声明了版本1.0，而实际文件则通过1.1规则进行了序列化。（这样做是出于历史兼容性的原因；请参见<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=59973">Bug 59973</a>和<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=58679">Bug 58679</a> ）这将导致严格的XML解析器失败。考虑使用非严格的XML解析器来读取JTL文件。
</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>文件名可以包含函数和/或变量引用。但是，变量引用在客户端-服务器模式下不起作用（功能正常）。这是因为文件是在客户端上创建的，并且客户端未在本地运行测试，因此未设置变量。
</td></tr>
</tbody></table>
<p></p>

<p><b>如果样本很多，则侦听器可以使用大量内存。</b>目前，大多数侦听器会在其范围内保留每个样本的副本，除了：</p>
<ul>
<li>简单数据写入器</li>
<li>BeanShell / JSR223侦听器</li>
<li>Mailer Visualizer</li>
<li>总结报告</li>
</ul>
<p>以下侦听器不再需要保留每个样本的副本。取而代之的是，将经过时间相同的样本进行汇总。现在需要更少的内存，尤其是如果大多数样本最多只花一两秒钟。
</p>
<ul>
<li>汇总报告</li>
<li>聚合图</li>
</ul>
<p>为了最大程度地减少所需的内存量，请使用“简单数据编写器”，然后使用CSV格式。</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>JMeter变量可以保存到输出文件中。只能使用属性来指定。有关详细信息，请参见<a href="listeners.html#sample_variables">侦听器样本变量</a> 。</td></tr>
</tbody></table>
<p></p>

<p>有关设置要保存的默认项目的完整详细信息，请参阅<a href="listeners.html#defaults">Listener Default Configuration</a>文档。有关输出文件内容的详细信息，请参见<a href="listeners.html#csvlogformat">CSV日志</a>格式或<a href="listeners.html#xmlformat2.1">XML日志</a>格式。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td><tt class="code">jmeter.properties</tt>中的条目用于定义默认值。可以使用“配置”按钮为单个侦听器覆盖这些设置，如下所示。<tt class="code">jmeter.properties中</tt>的设置也适用于使用<tt class="code">-l</tt>命令行标志添加的侦听器。
</td></tr>
</tbody></table>
<p></p>

<p>下图显示了结果文件配置面板的示例</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="741" height="141" src="../images/screenshots/simpledatawriter.png"><br>
<font size="-1">结果文件配置面板</font></td></tr></tbody></table>

<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>文档名称</td>
<td>包含样本结果的文件名。可以使用相对路径名或绝对路径名来指定文件名。相对路径相对于当前工作目录（默认为<tt class="code">bin /</tt>目录）进行解析。JMeter还支持相对于包含当前测试计划（JMX文件）的目录的路径。如果路径名以“ <tt class="code">〜/</tt> ”开头（或<tt class="code">jmeter.save.saveservice.base_prefix</tt> JMeter属性中的任何内容），则假定该路径相对于JMX文件位置。
        </td>
<td>没有</td>
</tr>
<tr>
<td>浏览…</td>
<td>文件浏览按钮</td>
<td>没有</td>
</tr>
<tr>
<td>失误</td>
<td>选择此选项可仅写入/读取有错误的结果</td>
<td>没有</td>
</tr>
<tr>
<td>成功案例</td>
<td>选择此选项可仅写入/读取结果而不会出现错误。如果未选择“ <tt class="code">错误”</tt>或“ <tt class="code">成功”</tt> ，则将处理所有结果。</td>
<td>没有</td>
</tr>
<tr>
<td>配置</td>
<td>配置按钮，请参见下文</td>
<td>没有</td>
</tr>
</tbody></table>

</div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Sample_Result_Save_Configuration">18.3.1示例结果保存配置</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>可以使用以下所示的Config弹出窗口将侦听器配置为将不同的项目保存到结果日志文件（JTL）。默认设置如<a href="listeners.html#defaults">Listener Default Configuration</a>文档中所述。名称后面带有（ <tt class="code">CSV</tt> ）的项目仅适用于CSV格式； （ <tt class="code">XML</tt> ）的项目仅适用于XML格式。CSV格式当前不能用于保存任何包含换行符的项目。
</p>
<p>请注意，cookie，方法和查询字符串将作为“ <tt class="code">采样器数据</tt> ”选项的一部分保存。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="760" height="304" src="../images/screenshots/sample_result_config.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Graph_Results">18.3.3图形结果</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>在负载测试期间不得使用图形结果，因为它会消耗大量资源（内存和CPU）。仅将其用于功能测试或在测试计划调试和验证期间使用。
</td></tr>
</tbody></table>
<p></p>

<p>“图形结果”侦听器将生成一个简单的图形，该图形将绘制所有采样时间。在图表底部，以毫秒为单位显示当前样本（黑色），所有样本的当前平均值（蓝色），当前标准偏差（红色）和当前吞吐率（绿色）。</p>
<p>吞吐量数字表示服务器处理的请求/分钟的实际数量。此计算包括您添加到测试中的任何延迟以及JMeter自己的内部处理时间。进行这样的计算的好处是，这个数字代表真实的东西-您的服务器实际上每分钟处理了许多请求，并且您可以增加线程数和/或减少发现服务器最大吞吐量的延迟。而如果您进行的计算将延迟和JMeter的处理排除在外，则不清楚从该数字可以得出什么结论。</p><p><b>控制面板</b></p>
<div align="center"><img width="915" height="686" src="../images/screenshots/graph_results.png"></div>
<p>下表简要描述了图形上的项目。有关统计术语精确含义的更多详细信息，可以在网络上找到-例如Wikipedia-或查阅有关统计的书。
 </p><ul>
 <li><tt class="code">数据</tt> -绘制实际数据值</li>
 <li><tt class="code">平均值</tt> -绘制平均值</li>
 <li><tt class="code">中位数</tt> -绘制中<a href="glossary.html#Median">位数</a> （中间值）</li>
 <li><tt class="code">偏差</tt> -绘制<a href="glossary.html#StandardDeviation">标准偏差</a> （衡量偏差）</li>
 <li><tt class="code">吞吐量</tt> -绘制每单位时间的样本数</li>
 </ul><p>显示屏底部的单个数字是当前值。“ <tt class="code">最新采样</tt> ”是当前经过的采样时间，在图形上显示为“ <tt class="code">数据</tt> ”。</p><p>图表左上方显示的值是响应时间的最大值90 <sup>个</sup>百分点。</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Assertion_Results">18.3.5断言结果</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>断言结果一定不能在负载测试期间使用，因为它会消耗大量资源（内存和CPU）。仅将其用于功能测试或在测试计划调试和验证期间使用。
</td></tr>
</tbody></table>
<p></p>

<p>断言结果可视化工具显示每个采样的标签。它还报告作为测试计划一部分的任何<a href="test_plan.html#assertions">断言的</a>失败。</p><p><b>控制面板</b></p>
<div align="center"><img width="954" height="365" src="../images/screenshots/assertion_results.png"></div>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="../usermanual/component_reference.html#Response_Assertion">回应断言</a></li>
</ul>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="View_Results_Tree">18.3.6查看结果树</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>查看结果树在负载测试期间一定不能使用，因为它会消耗大量资源（内存和CPU）。仅将其用于功能测试或在测试计划调试和验证期间使用。
</td></tr>
</tbody></table>
<p></p>查看结果树显示所有样品响应的树，使您可以查看任何样品的响应。除了显示响应之外，您还可以查看获得此响应所花费的时间以及一些响应代码。请注意，“请求”面板仅显示JMeter添加的标题。它没有显示HTTP协议实现可能添加的任何标头（例如<tt class="code">Host</tt> ）。
<p>有几种查看响应的方法，可通过左侧面板底部的下拉框选择。</p>

<table>
<tbody><tr>
<td bgcolor="#039acc" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<b>渲染器</b>
</font>
</td>
<td bgcolor="#039acc" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<b>描述</b>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">CSS / JQuery测试器</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>CSS / JQuery Tester</i>仅适用于文本响应。它在上部面板中显示纯文本。“ <tt class="code">测试</tt> ”按钮允许用户将CSS / JQuery应用于上面板，结果将显示在下面板中。<br>CSS / JQuery表达式引擎可以是JSoup或Jodd，这两种实现的语法略有不同。<br>例如，将具有属性<tt class="code">href</tt>的Selector <tt class="code">a [class = sectionlink]</tt>应用于当前JMeter函数页面，将提供以下输出：<br>

<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
Match count: 74
Match[1]=#functions
Match[2]=#what_can_do
Match[3]=#where
Match[4]=#how
Match[5]=#function_helper
Match[6]=#functions
Match[7]=#__regexFunction
Match[8]=#__regexFunction_parms
Match[9]=#__counter
… and so on …
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">文献</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">“ <i>文档”视图</i>将显示从各种类型的文档中提取的文本，例如Microsoft Office（Word，Excel，PowerPoint 97-2003、2007-2010（openxml），Apache OpenOffice（作家，calc，印象），HTML，gzip，jar / zip）文件（内容列表）以及“多媒体”文件上的一些元数据（例如mp3，mp4，flv等）。支持格式的完整列表可在<a href="http://tika.apache.org/1.2/formats.html">Apache Tika格式页面上找到。</a>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>“ <tt class="code">文档”视图的</tt>要求是下载<a href="http://tika.apache.org/download.html">Apache Tika二进制软件包</a> （ <tt class="code">tika-app-xxjar</tt> ）并将其放在<tt class="code">JMETER_HOME / lib</tt>目录中。
</td></tr>
</tbody></table>
<p></p>如果文档大于10 MB，则不会显示该文档。要更改此限制，请设置JMeter属性<tt class="code">document.max_size</tt> （单位为字节）或设置为<tt class="code">0</tt>以删除该限制。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">的HTML</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>HTML视图</i>尝试将响应呈现为HTML。呈现的HTML与在任何网络浏览器中获得的视图相比可能差劲。但是，它确实提供了快速近似，有助于初步结果评估。<br>图像，样式表等未下载。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">HTML（下载资源）</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">如果选择了<i>HTML（下载资源）视图</i>选项，则渲染器可以下载HTML代码引用的图像，样式表等。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">HTML源格式</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">如果选择了<em>HTML Source formatted view</em>选项，则渲染器将显示由<a href="https://jsoup.org/">Jsoup</a>格式化和清除的HTML源代码。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">JSON格式</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>JSON视图</i>将以树样式显示响应（还处理JavaScript中嵌入的JSON）。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">JSON路径测试器</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>JSON Path Tester视图</i>将使您可以测试JSON-PATH表达式，并查看从特定响应中提取的数据。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">JSON JMESPath测试器</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>JSON JMESPath Tester视图</i>将允许您测试<a href="http://jmespath.org/">JMESPath</a>表达式并查看从特定响应中提取的数据。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">正则表达式测试仪</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>Regexp Tester视图</i>仅适用于文本响应。它在上部面板中显示纯文本。“ <tt class="code">测试</tt> ”按钮允许用户将正则表达式应用到上部面板，结果将显示在下部面板中。<br>正则表达式引擎与正则表达式提取器中使用的引擎相同。<br>例如，应用于当前JMeter主页的RE <tt class="code">（JMeter \ w *）。*</tt>给出以下输出：<br>

<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
Match count: 26
Match[1][0]=JMeter - Apache JMeter&lt;/title&gt;
Match[1][1]=JMeter
Match[2][0]=JMeter&quot; title=&quot;JMeter&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;
Match[2][1]=JMeter
Match[3][0]=JMeterCommitters&quot;&gt;Contributors&lt;/a&gt;
Match[3][1]=JMeterCommitters
… and so on …
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<br><tt class="code">[]中</tt>的第一个数字是比赛号码；第二个数字是组。组<tt class="code">[0]</tt>与整个RE匹配。基<tt class="code">[1]</tt>的任何相匹配的<sup>1</sup>组，即<tt class="code">，（JMeter \ w *）</tt> 。参见图9b（下）。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">文本</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">默认的“ <i>文本”视图</i>显示响应中包含的所有文本。请注意，这仅在响应<tt class="code">内容类型</tt>被认为是文本时才有效。如果<tt class="code">内容类型</tt>以下列任何<tt class="code">一种</tt>开头，则将其视为二进制，否则将其视为文本。
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
image/
audio/
video/
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">XML格式</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>XML视图</i>将以树样式显示响应。任何DTD节点或Prolog节点都不会显示在树中；但是，响应可能包含那些节点。您可以右键单击任何节点，然后展开或折叠其下面的所有节点。
<br>
</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">XPath测试器</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>XPath Tester</i>仅适用于文本响应。它在上部面板中显示纯文本。“ <tt class="code">测试</tt> ”按钮允许用户将XPath查询应用于上面板，结果将显示在下面板中。<br>

</font>
</td>
</tr>
<tr>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif">
<tt class="code">边界提取仪</tt></font>
</td>
<td bgcolor="#a0ddf0" valign="top" align="left">
<font color="#000000" size="-1" face="arial,helvetica,sanserif"><i>边界提取器测试器</i>仅适用于文本响应。它在上部面板中显示纯文本。“ <tt class="code">测试</tt> ”按钮允许用户将边界提取器查询应用于上面板，结果将显示在下面板中。<br>

</font>
</td>
</tr>
</tbody></table>

<p><tt class="code">自动滚动？</tt> 选项允许在树选择中显示最后一个节点</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>从版本3.2开始，视图中的条目数被限制为属性<tt class="code">view.results.tree.max_results</tt>的值，该属性的默认值为<tt class="code">500</tt>个条目。可以通过将属性设置为<tt class="code">0</tt>来恢复旧的行为。请注意，这可能会消耗大量内存。</td></tr>
</tbody></table>
<p></p>

<p>使用“ <tt class="code">搜索”</tt>选项，大多数视图还允许搜索显示的数据。搜索结果将在上面的显示中突出显示。例如，下面的控制面板屏幕截图显示了搜索“ <tt class="code">Java</tt> ”的结果。请注意，搜索是在可见文本上进行的，因此搜索“文本”和HTML视图时可能会得到不同的结果。
<br>注意：正则表达式使用Java引擎（而不是像正则表达式提取器或Regexp Tester视图那样的ORO引擎）。
</p>
<p>如果没有提供<tt class="code">内容类型</tt> ，则该内容将不会显示在任何“响应数据”面板中。在这种情况下，可以使用“ <a href="../usermanual/component_reference.html#Save_Responses_to_a_file">将响应保存到文件”</a>来保存数据。请注意，响应数据仍将在样本结果中可用，因此仍可以使用后处理器进行访问。
</p>
<p>如果响应数据大于200K，则不会显示。要更改此限制，请设置JMeter属性<tt class="code">view.results.tree.max_size</tt> 。您还可以使用“将响应保存到文件”来<a href="../usermanual/component_reference.html#Save_Responses_to_a_file">将</a>整个响应<a href="../usermanual/component_reference.html#Save_Responses_to_a_file">保存到文件</a> 。
</p>
<p>可以创建其他渲染器。该类必须实现<tt class="code">org.apache.jmeter.visualizers接口<tt class="code">。ResultRenderer</tt>和/或扩展抽象类<tt class="code">org.apache.jmeter.visualizers。SamplerResultTab</tt> ，并且编译后的代码必须对JMeter可用（例如，通过将其添加到<tt class="code">lib / ext</tt>目录）。
</tt></p><tt class="code">
<p><b>控制面板</b></p>
<div align="center"><img width="910" height="659" src="../images/screenshots/view_results_tree.png"></div>
<p>控制面板（上方）显示了HTML显示的示例。<br>下面的图9显示了XML显示的示例。<br>图9a（下图）显示了Regexp测试仪显示的示例。<br>图9b（下）显示了“文档”显示的示例。<br>

</p><div align="center">
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="903" height="657" src="../images/screenshots/view_results_tree_xml.png"><br>
<font size="-1">图9 XML显示示例</font></td></tr></tbody></table>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="904" height="653" src="../images/screenshots/view_results_tree_regex.png"><br>
<font size="-1">图9a示例Regexp测试显示</font></td></tr></tbody></table>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="849" height="655" src="../images/screenshots/view_results_tree_document.png"><br>
<font size="-1">图9b样本文档（此处为PDF）显示</font></td></tr></tbody></table>

</div></tt></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Aggregate_Report">18.3.7汇总报告</a>
</h3>
</font>
</td></tr>
<tr><td>汇总报告为测试中的每个不同名称的请求创建一个表行。对于每个请求，它将总计响应信息，并提供请求计数，最小，最大，平均，错误率，近似吞吐量（请求/秒）和千字节每秒的吞吐量。测试完成后，吞吐量就是整个测试期间的实际吞吐量。<p>从采样器目标（例如，在HTTP采样的情况下为远程服务器）的角度计算吞吐量。JMeter考虑了生成请求的总时间。如果其他采样器和计时器在同一线程中，则它们将增加总时间，从而降低吞吐量值。因此，两个具有不同名称的相同采样器的吞吐量将是两个具有相同名称的采样器的吞吐量的一半。重要的是正确选择采样器名称，以从“聚合报告”中获得最佳结果。
</p>
<p>该计算<a href="glossary.html#Median">中值</a>和90％的线（ <sup>第</sup> 90 <a href="glossary.html#Percentile">百分位</a> ）值需要额外的存储器。现在，JMeter结合了具有相同经过时间的样本，因此所使用的内存更少。但是，对于花费多于几秒钟的样本，则可能是更少的样本将具有相同的时间，在这种情况下，将需要更多的内存。请注意，之后可以使用此侦听器重新加载CSV或XML结果文件，这是避免对性能造成影响的推荐方法。请参阅<a href="../usermanual/component_reference.html#Summary_Report">摘要报告</a>以获取类似的侦听器，该侦听器不存储单个样本，因此需要恒定的内存。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>从JMeter 2.12开始，您可以配置要计算的3个百分点值，这可以通过设置属性来完成：<ul>
    <li><tt class="code">gregate_rpt_pct1</tt> ：默认为<sup>第</sup> 90 <sup>个</sup> <a href="glossary.html#Percentile">百分位数</a></li>
    <li><tt class="code">aggregate_rpt_pct2：</tt>默认为<sup>第</sup> 95 <a href="glossary.html#Percentile">百分位</a></li>
    <li><tt class="code">gregation_rpt_pct3</tt> ：默认为<sup>第</sup> 99 <sup>个</sup> <a href="glossary.html#Percentile">百分点</a></li>
</ul>
</td></tr>
</tbody></table>
<p></p>

<ul>
<li><tt class="code">标签</tt> -样品的标签。如果“是否<tt class="code">在标签中包含组名？</tt>选择“”，然后将线程组的名称添加为前缀。这样，可以根据需要分别整理来自不同线程组的相同标签。
</li>
<li><tt class="code">＃样本</tt> -具有相同标签的样本数</li>
<li><tt class="code">平均</tt> -一组结果的平均时间</li>
<li><tt class="code">中位数</tt> - <a href="glossary.html#Median">中位数</a>是一组结果中间的时间。50％的样品不超过此时间。其余的至少要花时间。</li>
<li><tt class="code">90％的生产线</tt> -90％的样品不超过此时间。剩余的样本至少要花这么长时间。 （ <sup>第</sup> 90 <a href="glossary.html#Percentile">百分位</a> ）</li>
<li><tt class="code">95％的生产线</tt> -95％的样品不超过此时间。剩余的样本至少要花这么长时间。 （ <sup>第</sup> 95 <a href="glossary.html#Percentile">百分位</a> ）</li>
<li><tt class="code">99％</tt>的样本<tt class="code">行</tt> -99％的样本所花费的时间不超过这次。剩余的样本至少要花这么长时间。 （ <sup>第</sup> 99 <a href="glossary.html#Percentile">百分位</a> ）</li>
<li><tt class="code">最小</tt> -具有相同标签的样品的最短时间</li>
<li>最长-具有相同标签的样品的最长时间</li>
<li><tt class="code">错误％</tt> - <tt class="code">错误</tt>的请求百分比</li>
<li><tt class="code">吞吐量</tt> - <a href="glossary.html#Throughput">吞吐量</a>以每秒/分钟/小时的请求数衡量。选择时间单位，以使显示的速率至少为1.0。将吞吐量保存到CSV文件时，以请求/秒表示，即30.0请求/分钟被保存为0.5。
</li>
<li><tt class="code">接收的KB /秒</tt> -吞吐量，以每秒接收的千字节为单位</li>
<li><tt class="code">已发送KB /秒</tt> -吞吐量以每秒发送的千字节为单位</li>
</ul>
<p>时间以毫秒为单位。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="1206" height="306" src="../images/screenshots/aggregate_report.png"></div>
<div align="center">
<p>下图显示了选择“ <tt class="code">包括组名</tt> ”复选框的示例。
</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="1207" height="298" src="../images/screenshots/aggregate_report_grouped.png"><br>
<font size="-1">样品“ <tt class="code">包括组名</tt> ”显示</font></td></tr></tbody></table>

</div></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="View_Results_in_Table">18.3.8查看表中的结果</a>
</h3>
</font>
</td></tr>
<tr><td>该可视化器为每个样本结果创建一行。像“ <a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树”一样</a> ，此可视化工具占用大量内存。
<p>默认情况下，它仅显示主要（父）样本。它不显示子样本（子样本）。JMeter有一个“ <tt class="code">子样本？</tt>”复选框。如果选择此选项，则显示子样本而不是主要样本。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="966" height="683" src="../images/screenshots/table_results.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Simple_Data_Writer">18.3.9简单数据编写器</a>
</h3>
</font>
</td></tr>
<tr><td>该侦听器可以将结果记录到文件中，但不能记录到UI中。它旨在通过消除GUI开销提供一种有效的数据记录方法。在CLI模式下运行时， <tt class="code">-l</tt>标志可用于创建数据文件。要保存的字段由JMeter属性定义。有关详细信息，请参见<tt class="code">jmeter.properties</tt>文件。
<p><b>控制面板</b></p>
<div align="center"><img width="741" height="141" src="../images/screenshots/simpledatawriter.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Aggregate_Graph">18.3.12汇总图</a>
</h3>
</font>
</td></tr>
<tr><td>汇总图类似于汇总报告。主要区别在于聚合图提供了一种生成条形图并将该图另存为PNG文件的简便方法。<p><b>控制面板</b></p>
<div align="center"><img width="1132" height="872" src="../images/screenshots/aggregate_graph.png"></div>
<div align="center">
<p>下图显示了绘制此图形的设置示例。
</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="1147" height="420" src="../images/screenshots/aggregate_graph_settings.png"><br>
<font size="-1">汇总图设置</font></td></tr></tbody></table>

</div><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意：所有这些参数<em>都不会</em>保存在JMeter JMX脚本中。</td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>列设置</td>
<td>
        <ul>
        <li><tt class="code">要显示</tt>的列<tt class="code">：</tt>选择要在图形中显示的列。</li>
        <li><tt class="code">矩形颜色：</tt>单击右侧的颜色矩形，打开一个弹出对话框，为列选择自定义颜色。</li>
        <li><tt class="code">前景颜色</tt>允许更改值文本颜色。</li>
        <li><tt class="code">值字体：</tt>允许定义文本的字体设置。</li>
        <li><tt class="code">绘制轮廓栏？</tt> 在条形图上绘制或不绘制边界线</li>
        <li><tt class="code">显示号码分组？</tt> 是否显示“ Y轴”标签中的数字分组。</li>
        <li><tt class="code">价值标签是垂直的吗？</tt> 更改值标签的方向。（默认为水平）</li>
        <li><tt class="code">列标签选择：</tt>按结果标签过滤。可以使用正则表达式，例如： <tt class="code">。*交易。*</tt>
        <br>在显示图形之前，单击“ <tt class="code">应用过滤器”</tt>按钮以刷新内部数据。</li>
        </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>标题</td>
<td>在图表的顶部定义图表的标题。空值是默认值：“ <tt class="code">Aggregate Graph</tt> ”。<tt class="code">与名称同步</tt>按钮定义带有侦听器标签的标题。并定义图形标题的字体设置</td>
<td>没有</td>
</tr>
<tr>
<td>图形大小</td>
<td>根据当前JMeter的窗口大小，通过宽度和高度计算图形大小。使用“ <tt class="code">宽度”</tt>和“ <tt class="code">高度”</tt>字段定义自定义大小。单位是像素。</td>
<td>没有</td>
</tr>
<tr>
<td>X轴设置</td>
<td>定义X轴标签的最大长度（以像素为单位）。</td>
<td>没有</td>
</tr>
<tr>
<td>Y轴设置</td>
<td>定义Y轴的自定义最大值。</td>
<td>没有</td>
</tr>
<tr>
<td>传说</td>
<td>定义图表图例的位置和字体设置</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Response_Time_Graph">18.3.13响应时间图</a>
</h3>
</font>
</td></tr>
<tr><td>响应时间图绘制了一个折线图，显示了每个标记请求在测试过程中响应时间的变化。如果同一时间戳存在多个样本，则显示平均值。
<p><b>控制面板</b></p>
<div align="center"><img width="921" height="616" src="../images/screenshots/response_time_graph.png"></div>
<div align="center">
<p>下图显示了绘制此图形的设置示例。
</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="919" height="481" src="../images/screenshots/response_time_graph_settings.png"><br>
<font size="-1">响应时间图设置</font></td></tr></tbody></table>

</div><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意：所有这些参数都保存在JMeter <tt class="code">.jmx</tt>文件中。</td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>间隔（毫秒）</td>
<td>X轴间隔的时间（以毫秒为单位）。根据该值将样本分组。在显示图形之前，单击“ <tt class="code">应用间隔”</tt>按钮以刷新内部数据。</td>
<td>是</td>
</tr>
<tr>
<td>采样器标签选择</td>
<td>按结果标签过滤。例如，可以使用正则表达式。 <tt class="code">。*交易。*</tt> 。在显示图形之前，单击“ <tt class="code">应用过滤器”</tt>按钮以刷新内部数据。</td>
<td>没有</td>
</tr>
<tr>
<td>标题</td>
<td>在图表的顶部定义图表的标题。空值为默认值：“ <tt class="code">Response Time Graph</tt> ”。<tt class="code">与名称同步</tt>按钮定义带有侦听器标签的标题。并定义图形标题的字体设置</td>
<td>没有</td>
</tr>
<tr>
<td>线路设置</td>
<td>定义线的宽度。定义每个值点的类型。选择<tt class="code">任何一个</tt>都没有标记的行</td>
<td>是</td>
</tr>
<tr>
<td>图形大小</td>
<td>根据当前JMeter的窗口大小，通过宽度和高度计算图形大小。使用“ <tt class="code">宽度”</tt>和“ <tt class="code">高度”</tt>字段定义自定义大小。单位是像素。</td>
<td>没有</td>
</tr>
<tr>
<td>X轴设置</td>
<td>自定义X轴标签的日期格式。语法是Java <a href="http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat API</a> 。</td>
<td>没有</td>
</tr>
<tr>
<td>Y轴设置</td>
<td>为Y轴定义自定义最大值（以毫秒为单位）。定义比例的增量（以毫秒为单位）在Y轴标签中显示或不显示数字分组。</td>
<td>没有</td>
</tr>
<tr>
<td>传说</td>
<td>定义图表图例的位置和字体设置</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Mailer_Visualizer">18.3.14 Mailer Visualizer</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>如果测试运行从服务器收到太多失败响应，则可以将邮件可视化程序设置为发送电子邮件。</p><p><b>控制面板</b></p>
<div align="center"><img width="860" height="403" src="../images/screenshots/mailervisualizer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>从</td>
<td>用来发送消息的电子邮件地址。</td>
<td>是</td>
</tr>
<tr>
<td>收件人</td>
<td>发送消息的电子邮件地址，以逗号分隔。</td>
<td>是</td>
</tr>
<tr>
<td>成功科目</td>
<td>通过电子邮件发送成功消息的主题行。</td>
<td>没有</td>
</tr>
<tr>
<td>成功极限</td>
<td><strong>在先前达到失败限制后</strong> ，如果超过成功响应的数量，则会发送成功电子邮件。因此，邮件程序将仅以失败，成功，失败，成功等顺序发送消息。</td>
<td>是</td>
</tr>
<tr>
<td>失败主题</td>
<td>电子邮件主题行中包含失败消息。</td>
<td>没有</td>
</tr>
<tr>
<td>失效极限</td>
<td>一旦超过失败响应的数量，将发送失败电子邮件-即将计数设置为<tt class="code">0</tt>以在第一次失败时发送电子邮件。</td>
<td>是</td>
</tr>
<tr>
<td>主办</td>
<td>SMTP服务器（电子邮件重定向器）服务器的IP地址或主机名。</td>
<td>没有</td>
</tr>
<tr>
<td>港口</td>
<td>SMTP服务器的端口（默认为<tt class="code">25</tt> ）。</td>
<td>没有</td>
</tr>
<tr>
<td>登录</td>
<td>用于验证的登录名。</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>用于认证的密码。</td>
<td>没有</td>
</tr>
<tr>
<td>连接安全</td>
<td>SMTP身份验证的加密类型（SSL，TLS或无）。</td>
<td>没有</td>
</tr>
<tr>
<td>测试邮件</td>
<td>按下此按钮发送测试邮件</td>
<td>没有</td>
</tr>
<tr>
<td>失败的</td>
<td>一个字段，可以至今累计接收失败的总数。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="BeanShell_Listener">18.3.15 BeanShell侦听器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>BeanShell侦听器允许使用BeanShell处理样本以进行保存等。</p>
<p>
<b>有关使用BeanShell的完整详细信息，请访问<a href="http://www.beanshell.org/">BeanShell网站。</a></b>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>强烈建议迁移到<a href="../usermanual/component_reference.html#JSR223_Listener">JSR223侦听器</a> + Groovy，以提高性能，支持新的Java功能并限制BeanShell库的维护。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>测试元素支持<tt class="code">ThreadListener</tt>和<tt class="code">TestListener</tt>方法。这些应该在初始化文件中定义。有关示例定义，请参见文件<tt class="code">BeanShellListeners.bshrc</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="844" height="633" src="../images/screenshots/beanshell_listener.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。名称存储在脚本变量Label中</td>
<td>没有</td>
</tr>
<tr>
<td>重置bsh。每次通话前翻译</td>
<td>如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关更多信息，请参见<a href="best-practices#bsh_scripting">Best Practices-BeanShell脚本</a> 。
    </td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给BeanShell脚本的参数。参数存储在以下变量中：<dl>
        <dt><tt class="code">参量</tt></dt><dd>包含参数作为单个变量的字符串</dd>
        <dt><tt class="code">bsh.args</tt></dt><dd>包含参数的字符串数组，在空白处分割</dd>
    </dl></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量<tt class="code">FileName中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>要运行的BeanShell脚本。返回值将被忽略。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>在调用脚本之前，在BeanShell解释器中设置了一些变量：</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><tt class="code">java.util。属性</tt></a> ）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></li>
<li><tt class="code">sampleResult，</tt> <tt class="code">沪指</tt> - （ <a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ） -可以访问以前的<a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a></li>
<li><tt class="code">sampleEvent（</tt> <a href="../api/org/apache/jmeter/samplers/SampleEvent.html">SampleEvent</a> ）可以访问当前采样事件</li>
</ul><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p><p>如果定义了<tt class="code">beanshell.listener.init</tt>属性，则用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Summary_Report">18.3.16摘要报告</a>
</h3>
</font>
</td></tr>
<tr><td>摘要报告为测试中的每个不同名称的请求创建一个表格行。除了使用更少的内存外，这与“ <a href="../usermanual/component_reference.html#Aggregate_Report">聚合报告”</a>相似。
<p>从采样器目标（例如，在HTTP采样的情况下为远程服务器）的角度计算吞吐量。JMeter考虑了生成请求的总时间。如果其他采样器和计时器在同一线程中，则它们将增加总时间，从而降低吞吐量值。因此，两个具有不同名称的相同采样器的吞吐量将是两个具有相同名称的采样器的吞吐量的一半。正确选择采样器标签以从报告中获得最佳结果非常重要。
</p>
<ul>
<li><tt class="code">标签</tt> -样品的标签。如果“是否<tt class="code">在标签中包含组名？</tt>选择“”，然后将线程组的名称添加为前缀。这样，可以根据需要分别整理来自不同线程组的相同标签。
</li>
<li><tt class="code">＃样本</tt> -具有相同标签的样本数</li>
<li><tt class="code">平均</tt> -一组结果的平均经过时间</li>
<li><tt class="code">最小</tt> -具有相同标签的样本的最短经过时间</li>
<li><tt class="code">马克斯</tt> -最长经过时间与相同的标签样本</li>
<li><tt class="code">标准开发人员</tt> -样品经过时间的<a href="glossary.html#StandardDeviation">标准偏差</a></li>
<li><tt class="code">错误％</tt> - <tt class="code">错误</tt>的请求百分比</li>
<li><tt class="code">吞吐量</tt> - <a href="glossary.html#Throughput">吞吐量</a>以每秒/分钟/小时的请求数衡量。选择时间单位，以使显示速率至少为<tt class="code">1.0</tt> 。将吞吐量保存到CSV文件时，以请求/秒表示，即30.0请求/分钟被保存为<tt class="code">0.5</tt> 。
</li>
<li><tt class="code">接收的KB /秒</tt> -吞吐量，以每秒千字节为单位</li>
<li><tt class="code">已发送KB /秒</tt> -吞吐量，以每秒千字节为单位</li>
<li><tt class="code">平均字节</tt> -样本响应的平均大小（以字节为单位）。</li>
</ul>
<p>时间以毫秒为单位。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="1204" height="300" src="../images/screenshots/summary_report.png"></div>
<div align="center">
<p>下图显示了选择“ <tt class="code">包括组名</tt> ”复选框的示例。
</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="1208" height="302" src="../images/screenshots/summary_report_grouped.png"><br>
<font size="-1">样品“ <tt class="code">包括组名</tt> ”显示</font></td></tr></tbody></table>

</div></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Save_Responses_to_a_file">18.3.17将响应保存到文件</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>该测试元素可以放置在测试计划中的任何位置。对于其范围内的每个样本，它将创建一个响应数据文件。这样做的主要用途是创建功能测试，但是如果响应太大而无法在“ <a href="../usermanual/component_reference.html#View_Results_Tree">视图结果树</a>侦听器”中显示，它也很有用。文件名是从指定的前缀加上一个数字创建的（除非已禁用，请参见下文）。文件扩展名是根据文档类型创建的（如果知道）。如果未知，则将文件扩展名设置为“ <tt class="code">未知</tt> ”。如果禁用编号功能，并且禁用添加后缀，则将文件前缀作为整个文件名。这允许在需要时生成固定文件名。生成的文件名存储在样本响应中，并且可以根据需要保存在测试日志输出文件中。
        </p>
        <p>首先保存当前样本，然后保存所有子样本（子样本）。如果提供了变量名，那么将按照子样本出现的顺序保存文件名。见下文。
        </p>
    <p><b>控制面板</b></p>
<div align="center"><img width="488" height="251" src="../images/screenshots/savetofile.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>文件名前缀（可以包含文件夹）</td>
<td>生成文件名的前缀；其中可以包含目录名称。相对路径相对于当前工作目录（默认为<tt class="code">bin /</tt>目录）进行解析。JMeter还支持相对于包含当前测试计划（JMX文件）的目录的路径。如果路径名以“ <tt class="code">〜/</tt> ”开头（或<tt class="code">jmeter.save.saveservice.base_prefix</tt> JMeter属性中的任何内容），则假定该路径相对于JMX文件位置。<br>如果前缀中的父文件夹不存在，JMeter将创建它们并在失败时停止测试。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，文件名前缀不得包含与线程相关的数据，因此请勿在此字段中使用任何变量（ <tt class="code">$ {varName}</tt> ）或<tt class="code">$ {__ threadNum}之</tt>类的函数</td></tr>
</tbody></table>
<p></p>

 </td>
<td>是</td>
</tr>
<tr>
<td>包含已保存文件名的变量名</td>
<td>保存生成的文件名的变量名（以便以后在测试计划中使用）。如果有子样本，则将数字后缀添加到变量名称。例如，如果变量名称为<tt class="code">FILENAME</tt> ，则将父样本文件名保存在变量<tt class="code">FILENAME中</tt> ，并将子采样器的文件名保存在<tt class="code">FILENAME1</tt> ， <tt class="code">FILENAME2</tt>等中。</td>
<td>没有</td>
</tr>
<tr>
<td>序列号的最小长度</td>
<td>如果未选中“ <tt class="code">不要在前缀上添加数字</tt> ”，则添加到前缀的数字将填充<tt class="code">0，</tt>以便前缀的大小为该值。默认为<tt class="code">0</tt> 。</td>
<td>没有</td>
</tr>
<tr>
<td>仅保存失败的响应</td>
<td>如果选择，则仅保存失败的响应</td>
<td>是</td>
</tr>
<tr>
<td>仅保存成功回复</td>
<td>如果选择，则仅保存成功的响应</td>
<td>是</td>
</tr>
<tr>
<td>不要在前缀上添加数字</td>
<td>如果选择，则没有数字添加到前缀。如果选择此选项，请确保前缀是唯一的，否则文件可能会被覆盖。</td>
<td>是</td>
</tr>
<tr>
<td>不要添加内容类型后缀</td>
<td>如果选择，则不添加后缀。如果选择此选项，请确保前缀是唯一的，否则文件可能会被覆盖。</td>
<td>是</td>
</tr>
<tr>
<td>添加时间戳</td>
<td>如果选中，则日期将以<tt class="code">yyyyMMdd-HHmm_</tt>格式包含在文件后缀中</td>
<td>是</td>
</tr>
<tr>
<td>不保存事务控制器SampleResult</td>
<td>如果选中，则事务控制器生成的SamplerResult将被忽略</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSR223_Listener">18.3.18.1 JSR223侦听器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JSR223侦听器允许将JSR223脚本代码应用于示例结果。
</p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>语言</td>
<td>使用的JSR223语言</td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给脚本的参数。参数存储在以下变量中：<dl>
        <dt><tt class="code">参量</tt></dt><dd>包含参数作为单个变量的字符串</dd>
        <dt><tt class="code">args</tt></dt><dd>包含参数的字符串数组，在空白处分割</dd>
    </dl></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于“ <tt class="code">user.dir</tt> ”系统属性引用的目录</td>
<td>没有</td>
</tr>
<tr>
<td>脚本编译缓存</td>
<td>如果所使用的语言支持<tt class="code"><a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html">Compilable</a></tt>接口（Groovy是其中之一，Java，beanshell和javascript不支持），则JMeter将使用该测试计划中的唯一字符串来缓存脚本编译结果。
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您使用的是Groovy而不选中此选项，请参见JSR223 Sampler Java System属性中的注释</td></tr>
</tbody></table>
<p></p>

    </td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>要运行的脚本。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>在调用脚本之前，先设置一些变量。请注意，这些是JSR223变量-即它们可以直接在脚本中使用。
</p><dl>
<dt><tt class="code">日志</tt></dt><dd>（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</dd>
<dt><tt class="code">标签</tt></dt><dd>字符串标签</dd>
<dt><tt class="code">文档名称</tt></dt><dd>脚本文件名（如果有）</dd>
<dt><tt class="code">参量</tt></dt><dd>参数（作为字符串）</dd>
<dt><tt class="code">args</tt></dt><dd>参数作为String数组（在空格上分割）</dd>
<dt><tt class="code">ctx</tt></dt><dd>（ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ）-提供对上下文的访问</dd>
<dt><tt class="code">瓦斯</tt></dt><dd>（ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ）-提供对变量的读/写访问权限：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());
vars.getObject(&quot;OBJ2&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</dd>
<dt><tt class="code">道具</tt></dt><dd>（JMeterProperties-类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><tt class="code">java.util。属性</tt></a> ）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></dd>
<dt><tt class="code">sampleResult，</tt> <tt class="code">沪指</tt></dt><dd>（ <a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ）-允许访问SampleResult</dd>
<dt><tt class="code">sampleEvent</tt></dt><dd>（ <a href="../api/org/apache/jmeter/samplers/SampleEvent.html">SampleEvent</a> ）-允许访问SampleEvent</dd>
<dt><tt class="code">取样器</tt></dt><dd>（ <a href="../api/org/apache/jmeter/samplers/Sampler.html">采样器</a> ）-访问最后一个采样器</dd>
<dt><tt class="code">出</tt></dt><dd><tt class="code">System.out-</tt>例如<tt class="code">OUT.println（“ message”）</tt></dd>
</dl><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Generate_Summary_Results">18.3.19生成摘要结果</a>
</h3>
</font>
</td></tr>
<tr><td>该测试元素可以放置在测试计划中的任何位置。生成到目前为止对日志文件和/或标准输出的测试运行的摘要。显示了运行总计和差异总计。在适当的时间边界每<tt class="code">n</tt>秒（默认为30秒）生成一次输出，因此将同步在同一时间运行的多个测试。请参阅<tt class="code">jmeter.properties</tt>文件以获取<tt class="code">摘要</tt>配置项：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
# Define the following property to automatically start a summariser with that name
# (applies to CLI mode only)
#summariser.name=summary
#
# interval between summaries (in seconds) default 3 minutes
#summariser.interval=30
#
# Write messages to log file
#summariser.log=true
#
# Write messages to System.out
#summariser.out=true
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>该元素主要用于批处理（CLI）运行。输出如下所示：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
label +     16 in 0:00:12 =    1.3/s Avg:  1608 Min:  1163 Max:  2009 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label +     82 in 0:00:30 =    2.7/s Avg:  1518 Min:  1003 Max:  2020 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =     98 in 0:00:42 =    2.3/s Avg:  1533 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     85 in 0:00:30 =    2.8/s Avg:  1505 Min:  1008 Max:  2005 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    183 in 0:01:13 =    2.5/s Avg:  1520 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     79 in 0:00:30 =    2.7/s Avg:  1578 Min:  1089 Max:  2012 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    262 in 0:01:43 =    2.6/s Avg:  1538 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     80 in 0:00:30 =    2.7/s Avg:  1531 Min:  1013 Max:  2014 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    342 in 0:02:12 =    2.6/s Avg:  1536 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     83 in 0:00:31 =    2.7/s Avg:  1512 Min:  1003 Max:  1982 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    425 in 0:02:43 =    2.6/s Avg:  1531 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     83 in 0:00:29 =    2.8/s Avg:  1487 Min:  1023 Max:  2013 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    508 in 0:03:12 =    2.6/s Avg:  1524 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     78 in 0:00:30 =    2.6/s Avg:  1594 Min:  1013 Max:  2016 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    586 in 0:03:43 =    2.6/s Avg:  1533 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     80 in 0:00:30 =    2.7/s Avg:  1516 Min:  1013 Max:  2005 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    666 in 0:04:12 =    2.6/s Avg:  1531 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     86 in 0:00:30 =    2.9/s Avg:  1449 Min:  1004 Max:  2017 Err:     0 (0.00%) Active: 5 Started: 5 Finished: 0
label =    752 in 0:04:43 =    2.7/s Avg:  1522 Min:  1003 Max:  2020 Err:     0 (0.00%)
label +     65 in 0:00:24 =    2.7/s Avg:  1579 Min:  1007 Max:  2003 Err:     0 (0.00%) Active: 0 Started: 5 Finished: 5
label =    817 in 0:05:07 =    2.7/s Avg:  1526 Min:  1003 Max:  2020 Err:     0 (0.00%)
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>“ <tt class="code">label</tt> ”是元素的名称。<tt class="code">“ +”</tt>表示该行是增量行，即显示自上次输出以来的更改。<br><tt class="code">“ =”</tt>表示该行是总计行，即它显示了运行总计。<br>JMeter日志文件中的条目还包括时间戳。示例“ <tt class="code">817 in 0:05:07 = 2.7 / s</tt> ”表示在5分钟7秒内记录了817个样本，并且以每秒2.7个样本的速度工作。<br><tt class="code">平均</tt> （平均）， <tt class="code">最小</tt> （最小）和<tt class="code">最大</tt> （最大）时间以毫秒为单位。<br>“ <tt class="code">Err</tt> ”表示错误数（也显示为百分比）。<br>最后两行将出现在测试结束时。它们将不会同步到适当的时间边界。请注意，初始和最终增量可能少于间隔（在上面的示例中为30秒）。当JMeter同步到间隔边界时，第一个增量通常会较低。由于测试通常不会在确切的时间间隔边界上完成，因此最后一个差值会降低。
<p>标签用于将样本结果分组在一起。因此，如果您有多个线程组并希望对它们进行汇总，请使用相同的标签-或将摘要程序添加到测试计划中（这样所有线程组都在范围内）。通过使用适当的标签并将摘要添加到测试计划的适当部分中，可以实现不同的摘要分组。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>默认情况下，在CLI模式下，配置了名为“ <tt class="code">summariser</tt> ”的“生成摘要结果”侦听器，如果您已经在测试计划中添加了一个名称，请确保使用不同的名称，否则结果将在此标签（摘要）下累积，导致错误的结果（摘要）总样本数+位于“生成摘要结果”侦听器的父项下的样本数）。<br>这不是错误，而是一种允许对线程组进行汇总的设计选择。
</td></tr>
</tbody></table>
<p></p>

    <p><b>控制面板</b></p>
<div align="center"><img width="364" height="76" src="../images/screenshots/summary.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。它在输出中显示为“ <tt class="code">标签</tt> ”。具有相同标签的所有元素的详细信息将被添加在一起。
 </td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Comparison_Assertion_Visualizer">18.3.20比较断言可视化器</a>
</h3>
</font>
</td></tr>
<tr><td>比较断言可视化器显示任何<a href="../usermanual/component_reference.html#Compare_Assertion">比较断言</a>元素的结果。
<p><b>控制面板</b></p>
<div align="center"><img width="718" height="454" src="../images/screenshots/comparison_assertion_visualizer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。
 </td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Backend_Listener">18.3.21后端侦听器</a>
</h3>
</font>
</td></tr>
<tr><td>后端侦听器是一个异步侦听器，使您可以插入<a href="../api/org/apache/jmeter/visualizers/backend/BackendListenerClient.html">BackendListenerClient的</a>自定义实现。默认情况下，提供Graphite实现。
<p><b>控制面板</b></p>
<div align="center"><img width="705" height="350" src="../images/screenshots/backend_listener.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>是</td>
</tr>
<tr>
<td>后端侦听器实现</td>
<td><tt class="code">BackendListenerClient</tt>实现的类。</td>
<td>是</td>
</tr>
<tr>
<td>异步队列大小</td>
<td>异步处理SampleResults时保留它们的队列的大小。</td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td><tt class="code">BackendListenerClient</tt>实现的参数。</td>
<td>是</td>
</tr>
</tbody></table>
<p>以下参数适用于<a href="../api/org/apache/jmeter/visualizers/backend/graphite/GraphiteBackendListenerClient.html">GraphiteBackendListenerClient</a>实现：</p><p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>石墨指标发送者</td>
<td><tt class="code">org.apache.jmeter.visualizers.backend.graphite。TextGraphiteMetricsSender</tt>或<tt class="code">org.apache.jmeter.visualizers.backend.graphite。PickleGraphiteMetricsSender</tt></td>
<td>是</td>
</tr>
<tr>
<td>石墨主体</td>
<td>Graphite或InfluxDB（启用Graphite插件）服务器主机</td>
<td>是</td>
</tr>
<tr>
<td>石墨口</td>
<td>Graphite或InfluxDB（启用Graphite插件）服务器端口，默认为<tt class="code">2003</tt> 。注意<tt class="code">PickleGraphiteMetricsSender</tt> （端口<tt class="code">2004</tt> ）只能与Graphite服务器通信。</td>
<td>是</td>
</tr>
<tr>
<td>rootMetricsPrefix</td>
<td>发送到后端的指标的前缀。默认为“ <tt class="code">jmeter”</tt> 。请注意，JMeter不在根前缀和samplerName之间添加分隔符，这就是当前需要尾随点的原因。</td>
<td>是</td>
</tr>
<tr>
<td>仅摘要</td>
<td>仅发送没有详细信息的摘要。默认为<tt class="code">true</tt> 。</td>
<td>是</td>
</tr>
<tr>
<td>采样器列表</td>
<td>定义要发送到后端的样本结果的名称（标签）。如果<tt class="code">useRegexpForSamplersList = false，则</tt>这是用分号分隔的名称的列表。如果<tt class="code">useRegexpForSamplersList = true，则</tt>这是一个正则表达式，将与名称匹配。</td>
<td>是</td>
</tr>
<tr>
<td>useRegexpForSamplersList</td>
<td>将samplersList视为正则表达式，以选择要向其报告指标到后端的采样器。默认为<tt class="code">false</tt> 。</td>
<td>是</td>
</tr>
<tr>
<td>百分位数</td>
<td>您要发送到后端的百分比。一个百分位数可以包含一个小数部分，例如<tt class="code">12.5</tt> 。（分隔符始终为“。”。）列表必须以分号分隔。通常3或4个值就足够了。</td>
<td>是</td>
</tr>
</tbody></table>
<p>另请参阅<a href="realtime-results.html">实时结果</a>以获取更多详细信息。</p><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="1265" height="581" src="../images/screenshots/grafana_dashboard.png"><br>
<font size="-1">Grafana仪表板</font></td></tr></tbody></table>
<p>从JMeter 3.2开始，添加了一个新的实现，该实现允许使用自定义模式直接在InfluxDB中进行编写，它称为<tt class="code">InfluxdbBackendListenerClient</tt> 。以下参数适用于<a href="../api/org/apache/jmeter/visualizers/backend/influxdb/InfluxdbBackendListenerClient.html">InfluxdbBackendListenerClient</a>实现：</p><p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>influxdbMetricsSender</td>
<td><tt class="code">org.apache.jmeter.visualizers.backend.influxdb。HttpMetricsSender</tt></td>
<td>是</td>
</tr>
<tr>
<td>influxdbUrl</td>
<td>Influx URL（例如：http：// influxHost：8086 / write？db = jmeter）</td>
<td>是</td>
</tr>
<tr>
<td>influxdbToken</td>
<td>InfluxDB 2 <a href="https://v2.docs.influxdata.com/v2.0/security/">认证令牌</a> （例如：HE9yIdAPzWJDspH_tCc2UvdKZpX ==）；从5.2开始。</td>
<td>没有</td>
</tr>
<tr>
<td>应用</td>
<td>已测试应用程序的名称。此值也作为名为“应用程序”的标签存储在“事件”度量中</td>
<td>是</td>
</tr>
<tr>
<td>测量</td>
<td>根据<a href="https://docs.influxdata.com/influxdb/v1.1/write_protocols/line_protocol_reference/">Influx线路协议参考进行</a>测量。默认为“ <tt class="code">jmeter”</tt> 。</td>
<td>是</td>
</tr>
<tr>
<td>仅摘要</td>
<td>仅发送没有详细信息的摘要。默认为<tt class="code">true</tt> 。</td>
<td>是</td>
</tr>
<tr>
<td>采样器</td>
<td>将与样本名称匹配并发送到后端的正则表达式。</td>
<td>是</td>
</tr>
<tr>
<td>testTitle</td>
<td>测试名称。默认为<tt class="code">测试名称</tt> 。此值作为名为“文本”的字段存储在“事件”度量中。JMeter在测试的开始和结束时自动生成注释，该注释的值以“ start”和“ end”结尾</td>
<td>是</td>
</tr>
<tr>
<td>eventTags</td>
<td>Grafana允许为每个注释显示标签。您可以在此处填写。此值作为名为“标签”的标签存储在“事件”度量中。</td>
<td>没有</td>
</tr>
<tr>
<td>百分位数</td>
<td>您要发送到后端的百分比。一个百分位数可以包含一个小数部分，例如<tt class="code">12.5</tt> 。（分隔符始终为“。”。）列表必须以分号分隔。通常3或4个值就足够了。</td>
<td>是</td>
</tr>
<tr>
<td>TAG_WhatEverYouWant</td>
<td>您可以根据需要添加任意数量的自定义标签。对于每一个，只需创建一个新行，并在其名称前添加“ <tt class="code">TAG_</tt> ”</td>
<td>没有</td>
</tr>
</tbody></table>
<p>有关更多详细信息，另请参阅<a href="http://docs.grafana.org/reference/annotations/#influxdb-annotations">Grafana中</a> <a href="realtime-results.html">的实时结果</a>和<a href="http://docs.grafana.org/reference/annotations/#influxdb-annotations">Influxdb注释</a> 。</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="config_elements"><strong>18.4配置元素</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <br>配置元素可用于设置默认值和变量，供采样器稍后使用。注意，这些元素在发现它们的范围的开始即在同一范围内的任何采样器之前进行处理。
    <br>

</div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="CSV_Data_Set_Config">18.4.1 CSV数据集配置</a>
</h3>
</font>
</td></tr>
<tr><td>

    <p>CSV数据集配置用于读取文件中的行，并将其拆分为变量。它比<tt class="code"><a href="../usermanual/functions.html#__CSVRead">__CSVRead（）</a></tt>和<tt class="code"><a href="../usermanual/functions.html#__StringFromFile">__StringFromFile（）</a></tt>函数更容易使用。它非常适合处理大量变量，并且对于“随机”和唯一值的测试也很有用。</p>
    <p>就CPU和内存而言，在运行时生成唯一的随机值非常昂贵，因此只需在测试之前创建数据即可。如有必要，可以将文件中的“随机”数据与运行时参数结合使用，以从每次运行中创建不同的值集（例如，使用串联），这比在运行时生成所有内容便宜得多。
    </p>
    <p>JMeter允许引用值；这允许该值包含定界符。如果启用了“ <tt class="code">允许带引号的数据</tt> ”，则值可以用双引号引起来。这些已删除。要在双引号中包含双引号，请使用两个双引号。例如：</p>
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
1,&quot;2,3&quot;,&quot;4&quot;&quot;5&quot; =&gt;
1
2,3
4&quot;5
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

    <p>JMeter支持CSV文件，该文件的标题行定义了列名称。要启用此功能，请将“ <tt class="code">变量名称</tt> ”字段保留为空。必须提供正确的定界符。
    </p>
    <p>JMeter支持带引号的数据（包括换行符）的CSV文件。
    </p>
    <p>默认情况下，文件仅打开一次，并且每个线程将使用与文件不同的行。但是，将行传递到线程的顺序取决于它们执行的顺序，在迭代之间可能会有所不同。在每次测试迭代的开始读取行。在第一次迭代中解析文件名和模式。
    </p>
    <p>有关其他选项，请参见下面的共享模式说明。如果希望每个线程都有自己的一组值，则需要创建一组文件，每个线程一个。例如， <tt class="code">test1.csv</tt> ， <tt class="code">test2.csv</tt> ，…， <tt class="code">测试<em>n</em> .csv</tt> 。使用文件名<tt class="code">test $ {____ threadNum} .csv</tt>并将“ <tt class="code">共享模式</tt> ”设置为“ <tt class="code">当前线程</tt> ”。
    </p>
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>CSV数据集变量在每次测试迭代开始时定义。因为这是在配置处理完成之后，所以它们不能用于某些配置项（例如JDBC Config），这些项在配置时会处理其内容（请参见<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=40394">Bug 40394</a> ）。但是，变量确实可以在HTTP Auth Manager <a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=40394">中用作用</a> <tt class="code">户名</tt>等。在运行时进行处理。
    </td></tr>
</tbody></table>
<p></p>

    <p>作为特殊情况，定界符字段中的字符串“ <tt class="code">\ t</tt> ”（不带引号）被视为Tab。
    </p>
    <p>当到达文件末尾（ <tt class="code"><abbr title="文件结尾">EOF</abbr></tt> ），并且recycle选项为<tt class="code">true时</tt> ，将从文件的第一行开始重新读取。
    </p>
    <p>如果recycle选项为<tt class="code">false</tt> ，而stopThread为<tt class="code">false</tt> ，则所有变量均设置为<tt class="code"><eof></eof></tt>当到达文件末尾时。可以通过设置JMeter属性<tt class="code">csvdataset.eofstring</tt>来更改此值。
    </p>
    <p>如果Recycle选项为<tt class="code">false</tt> ，并且Stop Thread为<tt class="code">true</tt> ，则达到<tt class="code"><abbr title="文件结尾">EOF</abbr></tt>将导致线程停止。
    </p>
<p><b>控制面板</b></p>
<div align="center"><img width="433" height="281" src="../images/screenshots/csvdatasetconfig.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>文档名称</td>
<td>要读取的文件名。
  <b>相对于活动测试计划的路径解析相对文件名。</b>
  <b>对于分布式测试，CSV文件必须存储在服务器主机系统上正确的相对于JMeter服务器启动的相对目录中。</b>还支持绝对文件名，但是请注意，除非远程服务器具有相同的目录结构，否则它们不太可能在远程模式下工作。如果以两种不同的方式（例如<tt class="code">csvdata.txt</tt>和<tt class="code">./csvdata.txt</tt> ）引用同一物理文件， <tt class="code">则将</tt>它们视为不同的文件。如果操作系统无法区分大小写，请<tt class="code">输入csvData。TXT</tt>也将单独打开。
  </td>
<td>是</td>
</tr>
<tr>
<td>文件编码</td>
<td>如果不是平台默认值，则用于读取文件的编码。</td>
<td>没有</td>
</tr>
<tr>
<td>变量名</td>
<td>变量名称列表。名称必须由定界符分隔。可以使用双引号将它们引起来。JMeter支持CSV标头行：如果变量名字段为空，则读取文件的第一行并将其解释为列名列表。
  </td>
<td>没有</td>
</tr>
<tr>
<td>使用第一行作为变量名</td>
<td>忽略CSV文件的第一行，仅当变量名不为空时才使用，如果变量名为空，则第一行必须包含标题。
  </td>
<td>没有</td>
</tr>
<tr>
<td>定界符</td>
<td>用于分割文件中记录的定界符。如果该行上的值少于变量，则其余变量不会更新-因此它们将保留其先前值（如果有）。</td>
<td>是</td>
</tr>
<tr>
<td>允许引用数据？</td>
<td>CSV文件是否应允许引用值？如果启用，则可以将值括在<tt class="code">“</tt> -双引号-允许值包含定界符中。
  </td>
<td>是</td>
</tr>
<tr>
<td>在EOF上回收？</td>
<td>是否应该从到达<tt class="code"><abbr title="文件结尾">EOF</abbr></tt>开始就重新读取文件？（默认为<tt class="code">true</tt> ）</td>
<td>是</td>
</tr>
<tr>
<td>在EOF上停止线程？</td>
<td>如果Recycle为false，是否应该在<tt class="code"><abbr title="文件结尾">EOF</abbr></tt>上停止线程？（默认为<tt class="code">false</tt> ）</td>
<td>是</td>
</tr>
<tr>
<td>分享模式</td>
<td>
  <ul>
  <li><tt class="code">所有线程</tt> -（默认）文件在所有线程之间共享。</li>
  <li><tt class="code">当前线程组</tt> -每个文件针对出现该元素的每个线程组打开一次</li>
  <li><tt class="code">当前线程</tt> -每个文件分别为每个线程打开</li>
  <li><tt class="code">标识符</tt> -共享相同标识符的所有线程共享同一文件。因此，例如，如果您有4个线程组，则可以为两个或多个组使用通用ID，以在它们之间共享文件。或者，您可以使用线程号在不同线程组中的相同线程号之间共享文件。
  </li>
  </ul>
  </td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="FTP_Request_Defaults">18.4.2 FTP请求默认值</a>
</h3>
</font>
</td></tr>
<tr><td>
<p><b>控制面板</b></p>
<div align="center"><img width="520" height="202" src="../images/screenshots/ftp-config/ftp-request-defaults.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="DNS_Cache_Manager">18.4.3 DNS缓存管理器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>DNS缓存管理器旨在在线程组或测试计划的根目录中使用。请勿将其放置为特定HTTP Sampler的子元素</td></tr>
</tbody></table>
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>DNS缓存管理器仅与使用HTTPClient4实现的HTTP请求一起使用。</td></tr>
</tbody></table>
<p></p>
<p>当用户从不同IP接收内容时，DNS缓存管理器元素允许测试应用程序，该应用程序在负载均衡器（CDN等）后面有多个服务器。默认情况下，JMeter使用JVM DNS缓存。这就是为什么群集中只有一台服务器接收负载的原因。DNS缓存管理器在每次迭代时分别解析每个线程的名称，并将解析结果保存到其内部DNS缓存中，该内部DNS缓存与JVM和OS DNS缓存无关。
    </p>
    <p>静态主机的映射可用于模拟<tt class="code">/ etc / hosts</tt>文件。这些条目将比自定义解析器优先。如果要使用此映射，则必须启用“ <tt class="code">使用自定义DNS解析器”</tt> 。
    </p>
    <a name="static_host_table"></a>
<p><b>静态主机表的用法</b></p>

    <p>假设您有一台测试服务器，您想使用一个名称（尚未在DNS服务器中设置）来访问它。在我们的示例中，这是服务器名称的<tt class="code">www.example.com</tt> ，您想通过服务器<tt class="code">a123.another.example.org</tt>的IP到达该<tt class="code">名称</tt> 。
    </p>
    <p>您可以更改工作站并在<tt class="code">/ etc / hosts</tt>文件中添加一个条目-或与您的操作系统等效的条目，或者在DNS缓存管理器的静态主机表中添加一个条目。
    </p>
    <p>您将在第一列（ <tt class="code">Host</tt> ）中输入<tt class="code">www.example.com</tt> ，并在第二列（ <tt class="code">Hostname或IP address</tt> ）中输入<tt class="code">a123.another.example.org</tt> 。就像第二列的名称所示，您甚至可以在此处使用测试服务器的IP地址。
    </p>
    <p>将使用自定义DNS解析器查找测试服务器的IP地址。如果没有给出，将使用系统DNS解析器。
    </p>
    <p>现在，您可以在HTTPClient4采样器中使用<tt class="code">www.example.com</tt> ，并且将针对<tt class="code">a123.another.example.org发出</tt>请求，并将所有标头设置为<tt class="code">www.example.com</tt> 。
    </p>
    
    <p><b>控制面板</b></p>
<div align="center"><img width="712" height="387" src="../images/screenshots/dns-cache-manager.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>清除每个迭代的缓存</td>
<td>如果选择此选项，则每次启动新迭代时，都会清除每个线程的DNS缓存。</td>
<td>没有</td>
</tr>
<tr>
<td>使用系统DNS解析器</td>
<td>将使用系统DNS解析器。为了正确工作，请编辑<tt class="code">$ JAVA_HOME / jre / lib / security / java.security</tt>并添加<tt class="code">networkaddress.cache.ttl = 0</tt> 
    </td>
<td>不适用</td>
</tr>
<tr>
<td>使用自定义DNS解析器</td>
<td>将使用自定义DNS解析器（来自dnsjava库）。</td>
<td>不适用</td>
</tr>
<tr>
<td>主机名或IP地址</td>
<td>要使用的DNS服务器列表。如果为空，将使用网络配置DNS。</td>
<td>没有</td>
</tr>
<tr>
<td>添加按钮</td>
<td>将条目添加到DNS服务器表。</td>
<td>不适用</td>
</tr>
<tr>
<td>删除按钮</td>
<td>删除当前选择的表条目。</td>
<td>不适用</td>
</tr>
<tr>
<td>主机和主机名或IP地址</td>
<td>主机名到静态主机条目的映射，将使用自定义DNS解析器进行解析。</td>
<td>没有</td>
</tr>
<tr>
<td>添加静态主机按钮</td>
<td>将条目添加到静态主机表。</td>
<td>不适用</td>
</tr>
<tr>
<td>删除静态主机按钮</td>
<td>删除表中当前选定的静态主机。</td>
<td>不适用</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_Authorization_Manager">18.4.4 HTTP授权管理器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果一个采样器范围内有多个授权管理器，则当前无法指定要使用哪个授权管理器。</td></tr>
</tbody></table>
<p></p>

<p>授权管理器使您可以为使用服务器身份验证限制的网页指定一个或多个用户登录。当您使用浏览器访问受限页面时，您会看到这种身份验证，并且浏览器显示一个登录对话框。当遇到此类页面时，JMeter会发送登录信息。</p>
<p>授权标头可能不会显示在树视图侦听器的“ <tt class="code">请求</tt> ”选项卡中。Java实现执行抢占式身份验证，但是当JMeter获取标头时，它不返回Authorization标头。HttpComponents（HC 4.5。X）实施默认为抢先式，因为3.2和标题将显示。要禁用此功能，请按如下所示设置值，在这种情况下，仅在响应质询时才执行身份验证。
</p>
<p>在文件<tt class="code">jmeter.properties中</tt>设置<tt class="code">httpclient4.auth.preemptive = false</tt>
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：以上设置仅适用于HttpClient采样器。
</td></tr>
</tbody></table>
<p></p>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>当查找与URL的匹配项时，JMeter依次检查每个条目，并在找到第一个匹配项时停止。因此，最具体的URL应该首先出现在列表中，然后是不太具体的URL。重复的URL将被忽略。如果要为不同的线程使用不同的用户名/密码，则可以使用变量。可以使用<a href="../usermanual/component_reference.html#CSV_Data_Set_Config">CSV数据集配置</a>元素（例如）进行设置。
</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="538" height="340" src="../images/screenshots/http-config/http-auth-manager.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>在每次迭代中清除身份验证？</td>
<td>由Kerberos身份验证使用。如果选中，则即使在上一个线程组循环中已经进行了身份验证，也将在主线程组循环的每次迭代中进行身份验证。如果每个主线程组迭代都代表一个虚拟用户的行为，则这通常很有用。
        </td>
<td>是</td>
</tr>
<tr>
<td>基本网址</td>
<td>与一个或多个HTTP请求URL匹配的部分或完整URL。例如，假设您指定基本URL为“ <tt class="code">http：// localhost / restricted /</tt> ”， <tt class="code">用户</tt>名为“ <tt class="code">jmeter</tt> ”， <tt class="code">密码</tt>为“ <tt class="code">jmeter</tt> ”。如果将HTTP请求发送到URL“ <tt class="code">http：//localhost/restricted/ant/myPage.html</tt> ”，那么授权管理器将为名为“ <tt class="code">jmeter</tt> ”的用户发送登录信息。</td>
<td>是</td>
</tr>
<tr>
<td>用户名</td>
<td>要授权的用户名。</td>
<td>是</td>
</tr>
<tr>
<td>密码</td>
<td>用户的密码。（注意，这未加密存储在测试计划中）</td>
<td>是</td>
</tr>
<tr>
<td>域</td>
<td>用于NTLM的域。</td>
<td>没有</td>
</tr>
<tr>
<td>领域</td>
<td>用于NTLM的领域。</td>
<td>没有</td>
</tr>
<tr>
<td>机制</td>
<td>要执行的身份验证类型。JMeter可以根据使用的Http Samplers执行不同类型的身份验证：<dl>
<dt>爪哇</dt><dd><tt class="code">基本知识</tt></dd>
<dt>HttpClient 4</dt><dd><tt class="code">BASIC</tt> ， <tt class="code">DIGEST</tt>和<tt class="code">Kerberos</tt></dd>
</dl>
</td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>领域仅适用于HttpClient采样器。
</td></tr>
</tbody></table>
<p></p>
<br>
<b>Kerberos配置：</b><p>要配置Kerberos，您需要至少设置两个JVM系统属性：</p><ul>
    <li><tt class="code">-Djava.security.krb5.conf = krb5.conf</tt></li>
    <li><tt class="code">-Djava.security.auth.login.config = jaas.conf</tt></li>
</ul><p>您还可以在文件<tt class="code">bin / system.properties中</tt>配置这两个属性。查看位于JMeter <tt class="code">bin</tt>文件夹中的两个样本配置文件（ <tt class="code">krb5.conf</tt>和<tt class="code">jaas.conf</tt> ），以获取更多文档的参考，并对其进行调整以匹配您的Kerberos配置。
</p><p>对于SPNEGO，默认情况下禁用凭据委派。如果要启用它，可以通过将<tt class="code">kerberos.spnego.delegate_cred</tt>属性设置为<tt class="code">true</tt>来<tt class="code">实现</tt> 。
</p><p>当为Kerberos SPNEGO身份验证生成SPN时，IE和Firefox将从URL中省略端口号。 Chrome有一个选项（ <tt class="code">--enable-auth-negotiate-port</tt> ）如果端口号与标准端口号（ <tt class="code">80</tt>和<tt class="code">443</tt> ）不同，则可以包含该端口号。可以通过如下设置以下JMeter属性来模拟该行为。
</p><p>在<tt class="code">jmeter.properties</tt>或<tt class="code">user.properties中</tt> ，设置：</p><ul>
<li><tt class="code">kerberos.spnego.strip_port = false</tt></li>
</ul><br>
<b>控制项：</b><ul>
  <li><tt class="code">添加</tt>按钮-将条目添加到授权表。</li>
  <li><tt class="code">删除</tt>按钮-删除当前选择的表条目。</li>
  <li><tt class="code">加载</tt>按钮-加载以前保存的授权表，并将条目添加到现有的授权表条目中。</li>
  <li><tt class="code">另存为</tt>按钮-将当前授权表保存到文件中。</li>
</ul><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>保存测试计划时，JMeter自动保存所有授权表条目-包括未加密的所有密码。</td></tr>
</tbody></table>
<p></p>
<a name="authorization_example"></a>
<p><b>授权示例</b></p>


<p><a href="../demos/AuthManagerTestPlan.jmx">下载</a>此示例。在此示例中，我们在本地服务器上创建了一个测试计划，该计划发送三个HTTP请求，两个请求登录，另一个向所有人开放。请参见图10，以查看我们的测试计划的构成。在我们的服务器上，我们有一个受限制的目录，名为“ <tt class="code">secret</tt> ”，其中包含两个文件“ <tt class="code">index.html</tt> ”和“ <tt class="code">index2.html</tt> ”。我们创建了一个名为“ <tt class="code">kevin</tt> ”的登录ID，其密码为“ <tt class="code">spot</tt> ”。因此，在我们的授权管理器中，我们为受限制的目录以及用户名和密码创建了一个条目（见图11）。这两个HTTP请求名为<tt class="code">“SecretPage1”</tt>和<tt class="code">“SecretPage2”</tt>发出请求，以<tt class="code">“/secret/index.html”</tt>和<tt class="code">“/secret/index2.html”。</tt>另一个名为“ <tt class="code">NoSecretPage</tt> ”的HTTP请求向“ <tt class="code">/index.html</tt> ”发出请求。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="452" height="177" src="../images/screenshots/http-config/auth-manager-example1a.png"><br>
<font size="-1">图10-测试计划</font></td></tr></tbody></table>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="641" height="329" src="../images/screenshots/http-config/auth-manager-example1b.png"><br>
<font size="-1">图11-授权管理器控制面板</font></td></tr></tbody></table>


<p>当我们运行测试计划时，JMeter在授权表中查找它所请求的URL。如果基本URL与URL匹配，则JMeter将该信息与请求一起传递。</p>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>您可以下载测试计划，但是由于它是作为对我们本地服务器的测试而构建的，因此您将无法运行它。但是，您可以将其用作构建自己的测试计划的参考。</td></tr>
</tbody></table>
<p></p>

</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_Cache_Manager">18.4.5 HTTP缓存管理器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>HTTP缓存管理器用于在其范围内向HTTP请求添加缓存功能，以模拟浏览器缓存功能。每个虚拟用户线程都有自己的缓存。默认情况下，缓存管理器将使用LRU算法在每个虚拟用户线程中在缓存中最多存储5000个项目。使用属性“ <tt class="code">maxSize</tt> ”修改此值。请注意，此值增加得越多，HTTP缓存管理器将消耗更多的内存，因此请确保相应地调整<tt class="code">-Xmx</tt> JVM选项。
</p>
<p>如果样本成功（即响应代码为<tt class="code">2xx</tt> ），则将URL的<tt class="code">Last-Modified</tt>和<tt class="code">Etag</tt> （以及相关的<tt class="code">Expired</tt> ）值保存下来。在执行下一个示例之前，采样器将检查高速缓存中是否有条目，如果存在，则为请求设置<tt class="code">If-Last-Modified</tt>和<tt class="code">If-None-Match</tt>条件标头。</p>
<p>此外，如果选择了“ <tt class="code">使用缓存控制/过期标头</tt> ”选项，则会<tt class="code">对照</tt>当前时间检查“ <tt class="code">缓存控制</tt> / <tt class="code">过期”</tt>值。如果请求是<tt class="code">GET</tt>请求，并且时间戳记在将来，则采样器将立即返回，而无需从远程服务器请求URL。这旨在模拟浏览器的行为。请注意，如果<tt class="code">Cache-Control</tt>标头为“ <tt class="code">no-cache</tt> ”，则响应将以预过期的形式存储在缓存中，因此将生成条件<tt class="code">GET</tt>请求。如果<tt class="code">Cache-Control</tt>具有任何其他值，则将处理“ <tt class="code">max-age</tt> ”到期选项以计算条目生存期，如果丢失，则使用到期标头，如果还丢失的条目将按照<a href="https://tools.ietf.org/html/rfc2616#section-13.2.4">RFC 2616第13.2.4节的</a>规定进行缓存，则使用<tt class="code">最后修改</tt>时间和响应日期。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果请求的文档自缓存以来没有更改，则响应主体为空。同样，如果<tt class="code">到期</tt>日期是将来的日期。这可能会导致断言问题。
</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="511" height="196" src="../images/screenshots/http-config/http-cache-manager.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>清除每次迭代的缓存</td>
<td>如果选择此选项，则在线程开始时清除缓存。
  </td>
<td>是</td>
</tr>
<tr>
<td>处理GET请求时使用缓存控制/过期标头</td>
<td>参见上面的描述。</td>
<td>是</td>
</tr>
<tr>
<td>缓存中的最大元素数</td>
<td>参见上面的描述。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_Cookie_Manager">18.4.6 HTTP Cookie管理器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果一个采样器范围内有多个Cookie管理器，则当前无法指定要使用哪个Cookie管理器。另外，存储在一个cookie管理器中的cookie对其他任何管理器均不可用，因此请谨慎使用多个cookie管理器。</td></tr>
</tbody></table>
<p></p>
<p>Cookie Manager元素具有两个功能：<br>首先，它像浏览器一样存储和发送cookie。如果您有HTTP请求，并且响应包含cookie，则cookie管理器会自动存储该cookie，并将其用于将来对该特定网站的所有请求。每个JMeter线程都有其自己的“ cookie存储区”。因此，如果您正在测试使用cookie来存储会话信息的网站，则每个JMeter线程都会拥有自己的会话。请注意，此类cookie不会出现在Cookie Manager的显示屏上，但可以使用“ <a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树</a>侦听器”看到它们。
</p>
<p>JMeter会检查收到的Cookie是否对该URL有效。这意味着不会存储跨域Cookie。如果您有错误的行为或希望使用跨域cookie，请定义JMeter属性“ <tt class="code">CookieManager.check.cookies = false</tt> ”。
</p>
<p>收到的Cookies可以存储为JMeter线程变量。要将cookie保存为变量，请定义属性“ <tt class="code">CookieManager.save.cookies = true</tt> ”。另外，在存储cookie名称之前，它们以“ <tt class="code">COOKIE_</tt> ”为前缀（这避免了局部变量的意外损坏）。若要恢复原始行为，请定义属性“ <tt class="code">CookieManager.name.prefix =</tt> ”（一个或多个空格）。如果启用，则名为<tt class="code">TEST</tt>的cookie的值可以称为<tt class="code">$ {COOKIE_TEST}</tt> 。
</p>
<p>其次，您可以将Cookie手动添加到Cookie Manager。但是，如果执行此操作，则cookie将被所有JMeter线程共享。</p>
<p>请注意，此类Cookie的创建时间是将来的很远</p>
<p>默认情况下，具有<tt class="code">空</tt>值的Cookies被忽略。这可以通过设置JMeter属性来更改： <tt class="code">CookieManager.delete_null_cookies = false</tt> 。请注意，这也适用于手动定义的Cookie-更新后，所有此类Cookie都会从显示中删除。还要注意，cookie名称必须唯一-如果用相同的名称定义了另一个cookie，它将替换第一个。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="653" height="373" src="../images/screenshots/http-config/http-cookie-manager.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>每次迭代清除Cookie</td>
<td>如果选择此选项，则每次执行主线程组循环时，都会清除所有服务器定义的cookie。GUI中定义的任何cookie都不会清除。</td>
<td>是</td>
</tr>
<tr>
<td>Cookie政策</td>
<td>将用于管理cookie的cookie策略。自从3.0开始，“ <tt class="code">standard</tt> ”是默认设置，并且在大多数情况下应该可以使用。请参阅<a href="https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html#d5e515">Cookie规范</a>和<a href="http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/cookie/CookieSpec.html">CookieSpec实现。</a> [注意：“ <tt class="code">ignoreCookies</tt> ”等效于省略CookieManager。
 </td>
<td>是</td>
</tr>
<tr>
<td>实作</td>
<td><tt class="code">HC4CookieHandler</tt> （HttpClient 4.5。X API）。从3.0开始，默认值为<tt class="code">HC4CookieHandler</tt> 。
  <br>

  <i>[注意：如果您有一个要测试IPv6地址的网站，请选择<tt class="code">HC4CookieHandler</tt> （兼容IPv6）]</i></td>
<td>是</td>
</tr>
<tr>
<td>用户定义的Cookie</td>
<td>这使您有机会使用在测试执行期间所有线程都将使用的硬编码cookie。
  <br>“ <tt class="code">domain</tt> ”是服务器的主机名（不带<tt class="code">http：//</tt> ）；该端口当前被忽略。
  </td>
<td>否（心灰意冷，除非您知道自己在做什么）</td>
</tr>
<tr>
<td>添加按钮</td>
<td>将条目添加到cookie表。</td>
<td>不适用</td>
</tr>
<tr>
<td>删除按钮</td>
<td>删除当前选择的表条目。</td>
<td>不适用</td>
</tr>
<tr>
<td>加载按钮</td>
<td>加载以前保存的cookie表，并将条目添加到现有cookie表条目中。</td>
<td>不适用</td>
</tr>
<tr>
<td>另存为按钮</td>
<td>将当前cookie表保存到文件中（不保存从HTTP响应中提取的任何cookie）。
  </td>
<td>不适用</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_Request_Defaults">18.4.7 HTTP请求默认值</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该元素允许您设置HTTP请求控制器使用的默认值。例如，如果您要创建一个包含25个HTTP请求控制器的测试计划，并且所有请求都被发送到同一服务器，则可以添加一个HTTP请求默认值元素，并在其中填写“ <tt class="code">服务器名称或IP</tt> ”字段。然后，当您添加25个HTTP请求控制器时，请将“ <tt class="code">服务器名称或IP</tt> ”字段保留为空。控制器将从HTTP Request Defaults元素继承此字段值。</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>所有端口值均一视同仁。如果指定了端口，则没有指定端口的采样器将使用HTTP Request Defaults端口。
</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="879" height="469" src="../images/screenshots/http-config/http-request-defaults.png"></div>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="881" height="256" src="../images/screenshots/http-config/http-request-defaults-advanced-tab.png"><br>
<font size="-1">HTTP请求高级配置字段</font></td></tr></tbody></table>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器</td>
<td>Web服务器的域名或IP地址。例如<tt class="code">www.example.com</tt> 。[不包含<tt class="code">http：//</tt>前缀。</td>
<td>没有</td>
</tr>
<tr>
<td>港口</td>
<td>Web服务器正在侦听的端口。</td>
<td>没有</td>
</tr>
<tr>
<td>连接超时</td>
<td>连接超时。等待连接打开的毫秒数。</td>
<td>没有</td>
</tr>
<tr>
<td>响应超时</td>
<td>响应超时。等待响应的毫秒数。</td>
<td>没有</td>
</tr>
<tr>
<td>实作</td>
<td><tt class="code">Java的</tt> <tt class="code">HttpClient4</tt> 。如果未指定，则默认值取决于JMeter属性<tt class="code">jmeter.httpsampler</tt>的值，否则，将使用<tt class="code">Java</tt>实现。</td>
<td>没有</td>
</tr>
<tr>
<td>协议</td>
<td><tt class="code">HTTP</tt>或<tt class="code">HTTPS</tt> 。</td>
<td>没有</td>
</tr>
<tr>
<td>内容编码</td>
<td>用于请求的编码。</td>
<td>没有</td>
</tr>
<tr>
<td>路径</td>
<td>资源的路径（例如<tt class="code">/ servlets / myServlet</tt> ）。如果资源需要查询字符串参数，请在下面的“ <tt class="code">随请求发送参数</tt> ”部分中添加它们。请注意，该路径是完整路径的默认路径，而不是要应用于“ HTTP请求”屏幕上指定的路径的前缀。
        </td>
<td>没有</td>
</tr>
<tr>
<td>与请求一起发送参数</td>
<td>查询字符串将从您提供的参数列表中生成。每个参数都有一个<i>名称</i>和<i>值</i> 。查询字符串将以正确的方式生成，具体取决于您对“ <tt class="code">方法</tt> ”的选择（即，如果选择<tt class="code">GET</tt> ，则查询字符串将附加到URL上（如果为<tt class="code">POST</tt> ，则将单独发送）。另外，如果您要使用多部分表单发送文件，则查询字符串将使用多部分表单规范创建。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器（代理）</td>
<td>代理服务器执行请求的主机名或IP地址。 [不要包含<tt class="code">http：//</tt>前缀。]</td>
<td>没有</td>
</tr>
<tr>
<td>港口</td>
<td>代理服务器正在侦听的端口。</td>
<td>否，除非指定了代理主机名</td>
</tr>
<tr>
<td>用户名</td>
<td>（可选）代理服务器的用户名。</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>（可选）代理服务器的密码。（注意，这未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
<tr>
<td>从HTML文件检索所有嵌入式资源</td>
<td>告诉JMeter解析HTML文件并发送文件中引用的所有图像，Java applet，JavaScript文件，CSS等的HTTP / HTTPS请求。
        </td>
<td>没有</td>
</tr>
<tr>
<td>使用并发池</td>
<td>使用并发连接池来获取嵌入式资源。</td>
<td>没有</td>
</tr>
<tr>
<td>尺寸</td>
<td>用于获取嵌入式资源的并发连接的池大小。</td>
<td>没有</td>
</tr>
<tr>
<td>嵌入式URL必须匹配：</td>
<td>如果存在，则它必须是用于与找到的任何嵌入式URL匹配的正则表达式。因此，如果您只想从<tt class="code">http://example.com/</tt>下载嵌入式资源，请使用表达式： <tt class="code">http：// example \ .com /。*</tt>
        </td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：单选按钮只有两种状态-开启或关闭。这使得不可能一致地覆盖设置-“关闭”表示关闭，还是意味着使用当前默认设置？JMeter使用后者（否则默认值根本不起作用）。因此，如果按钮处于关闭状态，则以后的元素可以将其设置为打开，但是如果按钮处于打开状态，则后一个元素不能将其设置为关闭。
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_Header_Manager">18.4.8 HTTP标头管理器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>标头管理器允许您添加或覆盖HTTP请求标头。</p>
<p>
<b>JMeter现在支持多个标题管理器</b> 。标题条目被合并以形成采样器的列表。如果要合并的条目与现有的标题名称匹配，它将替换前一个条目。这样一来，便可以设置一组默认的标题，并将调整应用于特定的采样器。请注意，标头的空值不会删除现有的标头，而只是替换其值。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="767" height="239" src="../images/screenshots/http-config/http-header-manager.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>名称（标题）</td>
<td>请求标头的名称。您可能要试验的两个常见请求标头是“ <tt class="code">User-Agent</tt> ”和“ <tt class="code">Referer</tt> ”。</td>
<td>否（但是，您至少应有一个）</td>
</tr>
<tr>
<td>值</td>
<td>请求标头值。</td>
<td>否（但是，您至少应有一个）</td>
</tr>
<tr>
<td>添加按钮</td>
<td>在标题表中添加一个条目。</td>
<td>不适用</td>
</tr>
<tr>
<td>删除按钮</td>
<td>删除当前选择的表条目。</td>
<td>不适用</td>
</tr>
<tr>
<td>加载按钮</td>
<td>加载先前保存的标题表，并将条目添加到现有的标题表条目中。</td>
<td>不适用</td>
</tr>
<tr>
<td>另存为按钮</td>
<td>将当前标头表保存到文件。</td>
<td>不适用</td>
</tr>
</tbody></table>
<a name="header_manager_example"></a>
<p><b>标头管理器示例</b></p>


<p><a href="../demos/HeaderManagerTestPlan.jmx">下载</a>此示例。在此示例中，我们创建了一个测试计划，该计划告诉JMeter覆盖默认的“ <tt class="code">User-Agent</tt> ”请求标头，并改用特定的Internet Explorer代理字符串。 （见图12和13）。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="247" height="121" src="../images/screenshots/http-config/header-manager-example1a.png"><br>
<font size="-1">图12-测试计划</font></td></tr></tbody></table>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img src="../images/screenshots/http-config/header-manager-example1b.png"><br>
<font size="-1">图13-标头管理器控制面板</font></td></tr></tbody></table>

</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Java_Request_Defaults">18.4.9 Java请求默认值</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>Java Request Defaults组件使您可以设置Java测试的默认值。请参阅<a href="../usermanual/component_reference.html#Java_Request">Java Request</a> 。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="685" height="373" src="../images/screenshots/java_defaults.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JDBC_Connection_Configuration">18.4.10 JDBC连接配置</a>
</h3>
</font>
</td></tr>
<tr><td>根据提供的JDBC连接设置创建数据库连接（由<a href="../usermanual/component_reference.html#JDBC_Request">JDBC Request</a> Sampler使用）。可以选择在线程之间合并连接。否则，每个线程都会获得自己的连接。JDBC Sampler使用连接配置名称来选择适当的连接。使用的池是DBCP，请参见<a href="https://commons.apache.org/proper/commons-dbcp/configuration.html">BasicDataSource配置参数</a>
    <p><b>控制面板</b></p>
<div align="center"><img width="687" height="669" src="../images/screenshots/jdbc-config/jdbc-conn-config.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的连接配置的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>创建池的变量名</td>
<td>连接所绑定的变量的名称。可以使用多个连接，每个连接都绑定到一个不同的变量，从而允许JDBC Samplers选择适当的连接。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>每个名称必须不同。如果有两个使用相同名称的配置元素，则只会保存一个。如果检测到重复名称，JMeter会记录一条消息。</td></tr>
</tbody></table>
<p></p>

        </td>
<td>是</td>
</tr>
<tr>
<td>最大连接数</td>
<td>池中允许的最大连接数。在大多数情况下， <b>将此设置为零（0）</b> 。这意味着每个线程将在其中具有单个连接的情况下获得其自己的池，即，这些连接不在线程之间共享。
        <br>如果您确实要使用共享池（为什么？），则将最大计数设置为与线程数相同，以确保线程不会彼此等待。
        </td>
<td>是</td>
</tr>
<tr>
<td>最大等待时间（毫秒）</td>
<td>如果在尝试检索连接的过程中超过了超时期限，则Pool会引发错误，请参见<a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getMaxWaitMillis--">BasicDataSource.html＃getMaxWaitMillis</a></td>
<td>是</td>
</tr>
<tr>
<td>驱逐运行之间的时间（毫秒）</td>
<td>空闲对象退出线程的两次运行之间要休眠的毫秒数。当为非肯定时，将不运行任何空闲的对象退出线程。（默认为“ <tt class="code">60000</tt> ”，1分钟）。请参阅<a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getTimeBetweenEvictionRunsMillis--">BasicDataSource.html＃getTimeBetweenEvictionRunsMillis</a></td>
<td>是</td>
</tr>
<tr>
<td>自动提交</td>
<td>打开或关闭连接的自动提交。</td>
<td>是</td>
</tr>
<tr>
<td>交易隔离</td>
<td>事务隔离级别</td>
<td>是</td>
</tr>
<tr>
<td>预初始化池</td>
<td>可以立即初始化连接池。如果设置为<tt class="code">False</tt> （默认），则使用此池的JDBC请求采样器可能会为第一个查询测量更高的响应时间-因为包括了整个池的连接建立时间。</td>
<td>没有</td>
</tr>
<tr>
<td>初始化SQL语句，用新行分隔</td>
<td>SQL语句的集合，将在首次创建物理连接时用于初始化它们。这些语句仅执行一次-当配置的连接工厂创建连接时。</td>
<td>没有</td>
</tr>
<tr>
<td>闲置测试</td>
<td>测试池的空闲连接，请参阅<a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getTestWhileIdle--">BasicDataSource.html＃getTestWhileIdle</a> 。验证查询将用于测试它。</td>
<td>是</td>
</tr>
<tr>
<td>软最小可撤消空闲时间（毫秒）</td>
<td>在空闲对象<tt class="code">退出者</tt>有资格驱逐连接之前，连接可能在池中处于空闲状态的最短时间，另外还有至少最少<tt class="code">空闲</tt>连接保留在池中的额外条件。请参阅<a href="https://commons.apache.org/proper/commons-dbcp/api-2.1.1/org/apache/commons/dbcp2/BasicDataSource.html#getSoftMinEvictableIdleTimeMillis--">BasicDataSource.html＃getSoftMinEvictableIdleTimeMillis</a> 。默认值为5000（5秒）</td>
<td>是</td>
</tr>
<tr>
<td>验证查询</td>
<td>一个简单的查询，用于确定数据库是否仍在响应。默认为jdbc驱动程序的' <tt class="code">isValid（）</tt> '方法，该方法适用于许多数据库。但是，有些查询可能需要不同的查询。例如，可以使用Oracle之类的“ <tt class="code">SELECT 1 FROM DUAL</tt> ”。
        <p>验证查询的列表可以使用<tt class="code">jdbc.config.check.query</tt>属性进行配置，并且默认情况下为：</p>
            <dl>
              <dt>hsqldb</dt><dd><tt class="code">从INFORMATION_SCHEMA.SYSTEM_USERS中选择1</tt></dd>
              <dt>甲骨文</dt><dd><tt class="code">从双重选择1</tt></dd>
              <dt>DB2</dt><dd><tt class="code">从sysibm.sysdummy1中选择1</tt></dd>
              <dt>MySQL或MariaDB</dt><dd><tt class="code">选择1</tt></dd>
              <dt>Microsoft SQL Server（MS JDBC驱动程序）</dt><dd><tt class="code">选择1</tt></dd>
              <dt>PostgreSQL的</dt><dd><tt class="code">选择1</tt></dd>
              <dt>英格利斯</dt><dd><tt class="code">选择1</tt></dd>
              <dt>德比</dt><dd><tt class="code">值1</tt></dd>
              <dt>H2</dt><dd><tt class="code">选择1</tt></dd>
              <dt>火鸟</dt><dd><tt class="code">从rdb $ database中选择1</tt></dd>
              <dt>Exasol</dt><dd><tt class="code">选择1</tt></dd>
            </dl>
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>该列表来自<a href="https://stackoverflow.com/questions/10684244/dbcp-validationquery-for-different-databases">不同数据库验证查询上的stackoverflow条目，</a>该列表可能不正确</td></tr>
</tbody></table>
<p></p>

        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，即使“ <tt class="code">Test While Idle</tt> ”建议仅在空闲连接上使用查询，此验证查询也会在池创建中用于对其进行验证。这是DBCP的行为。</td></tr>
</tbody></table>
<p></p>

        </td>
<td>没有</td>
</tr>
<tr>
<td>数据库URL</td>
<td>数据库的JDBC连接字符串。</td>
<td>是</td>
</tr>
<tr>
<td>JDBC驱动程序类</td>
<td>驱动程序类的全限定名称。（必须位于JMeter的类路径中-最容易将<tt class="code">.jar</tt>文件复制到JMeter的<tt class="code">/ lib</tt>目录中）。
        <p>可以使用<tt class="code">jdbc.config.jdbc.driver.class</tt>属性配置预配置的jdbc驱动程序类的列表，默认情况下：</p>
            <dl>
              <dt>hsqldb</dt><dd>org.hsqldb.jdbc。JDBC驱动程序</dd>
              <dt>甲骨文</dt><dd>oracle.jdbc。Oracle驱动程序</dd>
              <dt>DB2</dt><dd>com.ibm.db2.jcc。DB2驱动程序</dd>
              <dt>的MySQL</dt><dd>com.mysql.jdbc。司机</dd>
              <dt>Microsoft SQL Server（MS JDBC驱动程序）</dt><dd>com.microsoft.sqlserver.jdbc。SQLServerDriver或com.microsoft.jdbc.sqlserver。SQLServerDriver</dd>
              <dt>PostgreSQL的</dt><dd>org.postgresql。司机</dd>
              <dt>英格利斯</dt><dd>com.ingres.jdbc。IngresDriver</dd>
              <dt>德比</dt><dd>org.apache.derby.jdbc。ClientDriver</dd>
              <dt>H2</dt><dd>org.h2。司机</dd>
              <dt>火鸟</dt><dd>org.firebirdsql.jdbc。FBDriver</dd>
              <dt>阿帕奇德比</dt><dd>org.apache.derby.jdbc。ClientDriver</dd>
              <dt>玛丽亚数据库</dt><dd>org.mariadb.jdbc。司机</dd>
              <dt>SQLite的</dt><dd>org.sqlite。JDBC</dd>
              <dt>Sybase AES</dt><dd>net.sourceforge.jtds.jdbc。司机</dd>
              <dt>Exasol</dt><dd>com.exasol.jdbc。EXA驱动程序</dd>
            </dl>
        </td>
<td>是</td>
</tr>
<tr>
<td>用户名</td>
<td>连接的用户名。</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>用于连接的密码。（注意，这未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
</tbody></table>
<p>不同的数据库和JDBC驱动程序需要不同的JDBC设置。数据库URL和JDBC驱动程序类由JDBC实现的提供程序定义。</p><p>一些可能的设置如下所示。请检查JDBC驱动程序文档中的确切详细信息。</p><p>如果JMeter报告<tt class="code">没有合适的驱动程序</tt> ，那么这可能意味着：</p><ul>
<li>找不到驱动程序类。在这种情况下，将出现诸如<tt class="code">DataSourceElement的日志消息<tt class="code">：无法加载驱动程序：{classname} java.lang。ClassNotFoundException：{classname}</tt></tt></li><tt class="code">
<li>找到了驱动程序类，但是该类不支持连接字符串。这可能是由于连接字符串中的语法错误，或者是因为使用了错误的类名。</li>
</tt></ul><p><tt class="code">如果数据库服务器未运行或不可访问，则JMeter将报告一个<tt class="code">java.net。ConnectException</tt> 。
</tt></p><p><tt class="code">下面给出了一些数据库及其参数的示例。</tt></p><dl><tt class="code">
  <dt>的MySQL</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">com.mysql.jdbc。司机</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：mysql：// host [：port] / dbname</tt></dd>
    </dl>
  </dd>
  <dt>PostgreSQL的</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">org.postgresql。司机</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：postgresql：{dbname}</tt></dd>
    </dl>
  </dd>
  <dt>甲骨文</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">oracle.jdbc。Oracle驱动程序</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：oracle：thin：@ // host：port / service</tt>或<tt class="code">jdbc：oracle：thin：@（description =（address =（host = {mc-name}）（protocol = tcp）（port = {port-no} ））（connect_data =（sid = {sid}）））</tt></dd>
    </dl>
  </dd>
  <dt>入侵（2006）</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">ingres.jdbc。IngresDriver</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：ingres：// host：port / db [; attr = value]</tt></dd>
    </dl>
  </dd>
  <dt>Microsoft SQL Server（MS JDBC驱动程序）</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">com.microsoft.sqlserver.jdbc。SQLServerDriver</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：sqlserver：// host：port; DatabaseName = dbname</tt></dd>
    </dl>
  </dd>
  <dt>阿帕奇德比</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">org.apache.derby.jdbc。ClientDriver</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：derby：// server [：port] / databaseName [; URLAttributes = value [;…]]</tt></dd>
    </dl>
  </dd>
  <dt>玛丽亚数据库</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">org.mariadb.jdbc。司机</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：mariadb：// host [：port] / dbname [; URLAttributes = value [;…]]</tt></dd>
    </dl>
  </dd>
  <dt>Exasol（另请参见<a href="https://docs.exasol.com/connect_exasol/drivers/jdbc.htm">JDBC驱动程序文档</a> ）</dt>
  <dd>
    <dl>
      <dt>驾驶舱</dt>
      <dd><tt class="code">com.exasol.jdbc。EXA驱动程序</tt></dd>
      <dt>数据库URL</dt>
      <dd><tt class="code">jdbc：exa：host [：port] [; schema = SCHEMA_NAME] [; prop_x = value_x]</tt></dd>
    </dl>
  </dd>
</tt></dl><p><tt class="code">
</tt></p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>以上内容可能不正确-请查看相关的JDBC驱动程序文档。</td></tr>
</tbody></table><tt class="code">
<p></p>
</tt></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Keystore_Configuration">18.4.11密钥库配置</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>密钥库配置元素使您可以配置如何加载密钥库以及它将使用哪些密钥。该组件通常用于HTTPS场景，在该场景中，您不希望在响应时间内将密钥库初始化考虑在内。</p>
<p>要使用此元素，您需要首先使用您要测试的客户端证书来设置Java密钥库：</p>
<ol>
<li>使用Java <tt class="code">keytool</tt>实用程序或通过PKI创建证书</li>
<li>如果由PKI创建，请通过将其转换为JKS可接受的格式将密钥导入Java密钥存储中。</li>
<li>然后通过两个JVM属性引用密钥库文件（或将它们添加到<tt class="code">system.properties中</tt> ）：<ul>
        <li><tt class="code">-Djavax.net.ssl.keyStore =路径_密钥库</tt></li>
        <li><tt class="code">-Djavax.net.ssl.keyStorePassword = password_of_keystore</tt></li>
    </ul>
</li>
</ol>
<p>要将PKCS11用作商店的源，需要将<tt class="code">javax.net.ssl.keyStoreType</tt>设置为<tt class="code">PKCS11</tt>并将<tt class="code">javax.net.ssl.keyStore设置</tt>为<tt class="code">NONE</tt> 。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="441" height="189" src="../images/screenshots/keystore_config.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>预载</td>
<td>是否预加载密钥库。通常将其设置为<tt class="code">true</tt>是最佳选择。</td>
<td>是</td>
</tr>
<tr>
<td>变量名称持有证书别名</td>
<td>变量名称，将包含用于客户端证书身份验证的别名。例如，将从CSV数据集中填充变量值。在屏幕截图中，“ <tt class="code">certificat_ssl</tt> ”也将是CSV数据集中的变量。默认为<tt class="code">clientCertAliasVarName</tt></td>
<td>假</td>
</tr>
<tr>
<td>别名开始索引</td>
<td>从0开始在Keystore中使用的第一个键的索引。</td>
<td>是</td>
</tr>
<tr>
<td>别名结束索引</td>
<td>基于0的密钥库中要使用的最后一个密钥的索引。使用“ <tt class="code">持有证书别名的变量名</tt> ”时，请确保其足够大，以便在启动时加载所有密钥。默认为-1，表示全部加载。</td>
<td>是</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>要使JMeter使用多个证书，您需要确保：<ul>
<li>在<tt class="code">jmeter.properties</tt>或<tt class="code">user.properties中</tt>设置了<tt class="code">https.use.cached.ssl.context</tt> <tt class="code">= false</tt></li>
<li>您对HTTP请求使用HTTPClient 4实现</li>
</ul>
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Login_Config_Element">18.4.12登录配置元素</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>登录配置元素使您可以在使用用户名和密码作为设置一部分的采样器中添加或覆盖用户名和密码设置。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="459" height="126" src="../images/screenshots/login-config.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>用户名</td>
<td>使用的默认用户名。</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>使用的默认密码。（注意，这未加密存储在测试计划中）</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="LDAP_Request_Defaults">18.4.13 LDAP请求默认值</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>LDAP Request Defaults组件使您可以设置LDAP测试的默认值。请参阅<a href="../usermanual/component_reference.html#LDAP_Request">LDAP请求</a> 。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="689" height="232" src="../images/screenshots/ldap_defaults.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="LDAP_Extended_Request_Defaults">18.4.14 LDAP扩展请求默认值</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>LDAP扩展请求默认值组件使您可以设置扩展LDAP测试的默认值。请参阅<a href="../usermanual/component_reference.html#LDAP_Extended_Request">LDAP扩展请求</a> 。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="686" height="184" src="../images/screenshots/ldapext_defaults.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="TCP_Sampler_Config">18.4.15 TCP采样器配置</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>TCP采样器配置为TCP采样器提供默认数据</p>
<p><b>控制面板</b></p>
<div align="center"><img width="826" height="450" src="../images/screenshots/tcpsamplerconfig.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>TCPClient类别名称</td>
<td>TCPClient类的名称。默认为属性<tt class="code">tcp.handler</tt> ，否则将失败<tt class="code">TCPClientImpl</tt> 。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器名称或IP</td>
<td>TCP服务器的名称或IP</td>
<td>没有</td>
</tr>
<tr>
<td>端口号</td>
<td>使用的端口</td>
<td>没有</td>
</tr>
<tr>
<td>重用连接</td>
<td>如果选择，则连接保持打开状态。否则，在读取数据后将其关闭。</td>
<td>是</td>
</tr>
<tr>
<td>紧密连接</td>
<td>如果选择此选项，则在运行采样器后将关闭连接。</td>
<td>是</td>
</tr>
<tr>
<td>SO_LINGER</td>
<td>创建套接字时，以指定的延迟时间（以秒为单位）启用/禁用<tt class="code">SO_LINGER</tt> 。如果将“ <tt class="code">SO_LINGER</tt> ”值设置为<tt class="code">0</tt> ，则可以防止大量套接字处于<tt class="code">TIME_WAIT</tt>状态。</td>
<td>没有</td>
</tr>
<tr>
<td>行尾（EOL）字节值</td>
<td>行尾的字节值，将此值设置为<tt class="code">-128</tt>到<tt class="code">+127</tt>范围之外的<tt class="code">值</tt>可跳过EOL检查。您也可以在<tt class="code">jmeter.properties</tt>文件中使用<tt class="code">tcp.eolByte</tt>属性进行设置。如果您同时在TCP Sampler Config和<tt class="code">jmeter.properties</tt>文件中进行设置，则将使用TCP Sampler Config中的设置值。</td>
<td>没有</td>
</tr>
<tr>
<td>连接超时</td>
<td>连接超时（毫秒，0禁用）。</td>
<td>没有</td>
</tr>
<tr>
<td>响应超时</td>
<td>响应超时（毫秒，0禁用）。</td>
<td>没有</td>
</tr>
<tr>
<td>设置节点布局</td>
<td>应该设置nodelay属性吗？</td>
<td>没有</td>
</tr>
<tr>
<td>文字发送</td>
<td>要发送的文字</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="User_Defined_Variables">18.4.16用户定义的变量</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>用户定义变量元素使您可以定义一组<b>初始变量</b> ，就像在“ <a href="../usermanual/component_reference.html#Test_Plan">测试计划”中一样</a> 。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，测试计划中的所有UDV元素-无论它们在何处-都将在开始时进行处理。
</td></tr>
</tbody></table>
<p></p>因此，您不能引用定义为测试运行的一部分的变量，例如在后处理器中。
<p></p>
<p>
<b>UDV不应与每次调用都会产生不同结果的函数一起使用。仅第一个函数调用的结果将保存在变量中。
</b>但是，UDV可以与<tt class="code"><a href="../usermanual/functions.html#__P">__P（）之类的</a></tt>函数一起使用，例如：</p>
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
HOST      ${__P(host,localhost)} 
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

<p>它将定义变量“ <tt class="code">HOST</tt> ”以具有JMeter属性“ <tt class="code">host</tt> ”的值，如果未定义，则默认为“ <tt class="code">localhost</tt> ”。
</p>
<p>有关在测试运行期间定义变量的信息，请参见<a href="../usermanual/component_reference.html#User_Parameters">用户参数</a> 。UDV按照在计划中出现的顺序从上到下进行处理。
</p>
<p>为简单起见，建议将UDV仅放置在线程组的开头（或可能位于测试计划本身之下）。
</p>
<p>处理完测试计划和所有UDV后，将结果集变量复制到每个线程以提供初始变量集。
</p>
<p>如果运行时元素（例如用户参数预处理器或正则表达式提取器）定义的变量与UDV变量之一具有相同的名称，则它将替换初始值，并且线程中的所有其他测试元素将看到更新的值。值。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="741" height="266" src="../images/screenshots/user_defined_variables.png"></div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您有多个线程组，请确保对不同的值使用不同的名称，因为UDV在线程组之间共享。同样，这些变量在处理完元素之后才可用，因此您不能引用在同一元素中定义的变量。您可以引用在早期UDV或测试计划中定义的变量。
</td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>用户定义的变量</td>
<td>变量名称/值对。需要在<tt class="code">$ {…}</tt>结构的方括号内放置“ <tt class="code">名称</tt> ”（ <tt class="code">Name</tt> ）列下的字符串，以便以后使用变量。然后，整个<tt class="code">$ {…}</tt>将由“ <tt class="code">值</tt> ”列中的字符串替换。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Random_Variable">18.4.17随机变量</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>随机变量配置元素用于生成随机数字字符串并将其存储在变量中，以备后用。这比将<a href="../usermanual/component_reference.html#User_Defined_Variables">用户定义的变量</a>与<tt class="code"><a href="../usermanual/functions.html#__Random">__Random（）</a></tt>函数一起使用要<tt class="code"><a href="../usermanual/functions.html#__Random">简单</a></tt> 。
</p>
<p>通过使用随机数生成器构造输出变量，然后使用格式字符串格式化结果数。使用公式<tt class="code">minimum + Random.nextInt（maximum-minimum + 1）</tt>计算该数字。
<tt class="code">Random.nextInt（）</tt>需要一个正整数。这意味着<tt class="code">最大最小值</tt> （即范围）必须小于<tt class="code">2147483647</tt> ，但是<tt class="code">最小值</tt>和<tt class="code">最大值</tt>可以是任何<tt class="code">长</tt>值，只要范围是可以的。</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>由于随机值是在每次迭代开始时求值的，因此使用除属性以外的变量作为最小值或最大值的值可能不是一个好主意。第一次迭代将为零。</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="495" height="286" src="../images/screenshots/random_variable.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>是</td>
</tr>
<tr>
<td>变量名</td>
<td>存储随机字符串的变量的名称。</td>
<td>是</td>
</tr>
<tr>
<td>格式字符串</td>
<td><tt class="code">java.text。要使用的DecimalFormat</tt>格式字符串。例如，“ <tt class="code">000</tt> ”将生成至少3位数字，或者“ <tt class="code">USER_000</tt> ”将生成<tt class="code">USER_nnn</tt>形式的<tt class="code">输出</tt> 。如果未指定，则默认为使用<tt class="code">Long.toString（）</tt>生成数字。</td>
<td>没有</td>
</tr>
<tr>
<td>最低值</td>
<td>生成的随机数的最小值（ <tt class="code">long</tt> ）。</td>
<td>是</td>
</tr>
<tr>
<td>最大值</td>
<td>生成的随机数的最大值（ <tt class="code">long</tt> ）。</td>
<td>是</td>
</tr>
<tr>
<td>随机种子</td>
<td>随机数生成器的种子。如果在“将每个线程”设置为<tt class="code">true的情况下</tt>使用相同的种子值，则将为每个线程获得与“ <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Random.html">随机”</a>类相同的值。如果未设置种子，则将使用Random的Default构造函数。
  </td>
<td>没有</td>
</tr>
<tr>
<td>每个线程（用户）？</td>
<td>如果为<tt class="code">False</tt> ，则在线程组中的所有线程之间共享生成器。如果为<tt class="code">True</tt> ，那么每个线程都有自己的随机生成器。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Counter">18.4.18计数器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>允许用户创建一个可以在线程组中任何地方引用的计数器。计数器配置使用户可以配置起点，最大值和增量。计数器将从开始到最大循环，然后从头开始，继续这样直到测试结束。</p>
<p>计数器使用long来存储值，因此范围是<tt class="code">-2 ^ 63</tt>到<tt class="code">2 ^ 63-1</tt> 。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="404" height="262" src="../images/screenshots/counter.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>起始值</td>
<td>计数器的起始值。计数器将在第一次迭代期间等于该值（默认为0）。</td>
<td>没有</td>
</tr>
<tr>
<td>增量</td>
<td>每次迭代后计数器增加多少（默认为0，表示不增加）。</td>
<td>是</td>
</tr>
<tr>
<td>最大值</td>
<td>如果计数器超过最大值，则将其重置为<tt class="code">起始值</tt> 。默认值为<tt class="code">长。MAX_VALUE</tt>
        </td>
<td>没有</td>
</tr>
<tr>
<td>格式</td>
<td>可选的格式，如<tt class="code">000</tt>会格式化为<tt class="code"><tt class="code">001，002，</tt></tt>等它传递给<tt class="code">DecimalFormat的</tt> ，所以任何有效的格式都可以使用。如果解释格式存在问题，则将其忽略。[默认格式是使用<tt class="code">Long.toString（）</tt>生成的]</td>
<td>没有</td>
</tr>
<tr>
<td>导出的变量名称</td>
<td>这将是可用的计数器值的变量名称。如果将其命名为<tt class="code">counterA</tt> ，则可以按照<a href="functions.html">用户定义的值中的</a>说明使用<tt class="code">$ {counterA}</tt>来访问它（默认情况下，它会创建一个空字符串变量，可以使用<tt class="code">$ {}</tt>进行访问，但是不建议使用）</td>
<td>没有</td>
</tr>
<tr>
<td>为每个用户独立跟踪计数器</td>
<td>换句话说，这是全局计数器，还是每个用户都有自己的计数器？如果未选中，则计数器为全局计数器（即，用户＃1在第一次迭代中将获得值“ <tt class="code">1</tt> ”，用户＃2将获得“ <tt class="code">2</tt> ”值）。如果选中，则每个用户都有一个独立的计数器。</td>
<td>没有</td>
</tr>
<tr>
<td>在每个线程组迭代上重置计数器</td>
<td>仅当按用户跟踪计数器时，此选项才可用，如果选中，则每次线程组迭代时计数器将重置为“ <tt class="code">开始”</tt>值。当Counter在循环控制器内部时，这很有用。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Simple_Config_Element">18.4.19简单配置元素</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>使用“简单配置元素”，可以在采样器中添加或覆盖任意值。您可以选择值的名称和值本身。尽管一些冒险的用户可能会发现此元素的用法，但它主要是供开发人员在开发新的JMeter组件时使用的基本GUI。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="627" height="282" src="../images/screenshots/simple_config_element.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>是</td>
</tr>
<tr>
<td>参数名称</td>
<td>每个参数的名称。这些值是JMeter工作的内部内容，通常没有记录。只有熟悉代码的人才能知道这些值。</td>
<td>是</td>
</tr>
<tr>
<td>参数值</td>
<td>应用于该参数的值。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="MongoDB_Source_Config_(DEPRECATED)">18.4.20 MongoDB源配置（已弃用）</a>
</h3>
</font>
</td></tr>
<tr><td>从提供的“连接”设置中创建MongoDB连接（由<a href="../usermanual/component_reference.html#MongoDB_Script">MongoDB Script</a> Sampler使用）。每个线程都有自己的连接。JDBC Sampler使用连接配置名称来选择适当的连接。
     <p>然后，您可以访问<tt class="code">com.mongodb。通过使用此代码的元素<a href="../api/org/apache/jmeter/protocol/mongodb/config/MongoDBHolder.html">MongoDBHolder</a> ，Beanshell或JSR223测试元素中的DB</tt>对象</p>
     
    <div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
import com.mongodb.DB;
import org.apache.jmeter.protocol.mongodb.config.MongoDBHolder;
DB db = MongoDBHolder.getDBFromSource(&quot;value of property MongoDB Source&quot;,
            &quot;value of property Database Name&quot;);
…
    </pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

    <p><b>控制面板</b></p>
<div align="center"><img width="1233" height="618" src="../images/screenshots/mongodb-source-config.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的连接配置的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>服务器地址列表</td>
<td>Mongo数据库服务器</td>
<td>是</td>
</tr>
<tr>
<td>MongoDB来源</td>
<td>连接所绑定的变量的名称。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>每个名称必须不同。如果有两个使用相同名称的配置元素，则只会保存一个。</td></tr>
</tbody></table>
<p></p>

        </td>
<td>是</td>
</tr>
<tr>
<td>继续尝试</td>
<td>如果为<tt class="code">true</tt> ，则在无法建立套接字的情况下，驱动程序将继续尝试连接到同一服务器。<br>最长可以重试的时间，默认情况下为15秒。<br>这对于避免通过阻止操作暂时关闭服务器而引发某些异常很有用。
            <br>平滑过渡到新的母版（以便在重试时间内选择一个新的母版）也很有用。<br>

            <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，使用此标志时<ul>
                <li>对于副本集，驱动程序将尝试在该时间连接到旧的主副本，而不是立即故障转移到新的副本副本。</li>
                <li>这不会阻止在套接字上的读/写操作中引发异常，该异常必须由应用程序处理。</li>
              </ul>即使此标志为false，驱动程序已经具有自动重新创建断开的连接并重试读取操作的机制。
            </td></tr>
</tbody></table>
<p></p>默认值为<tt class="code">false</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>每个主机的最大连接数</td>
<td></td>
<td>没有</td>
</tr>
<tr>
<td>连接超时</td>
<td>连接超时（以毫秒为单位）。<br>仅在建立新连接<tt class="code">Socket.connect（java.net。SocketAddress，整数）</tt><br>默认值为<tt class="code">0</tt> ，表示没有超时。
        </td>
<td>没有</td>
</tr>
<tr>
<td>最大重试时间</td>
<td>重试打开与同一服务器的连接所花费的最长时间（以毫秒为单位）。<br>默认值为<tt class="code">0</tt> ，这意味着如果<tt class="code">启用了autoConnectRetry，</tt>则使用默认的15s。
        </td>
<td>没有</td>
</tr>
<tr>
<td>最大等待时间</td>
<td>线程可以等待连接可用的最大等待时间（以毫秒为单位）。<br>默认值为<tt class="code">120,000</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>套接字超时</td>
<td>套接字超时（以毫秒为单位）用于I / O套接字读写操作<tt class="code">Socket.setSoTimeout（int）</tt><br>默认值为<tt class="code">0</tt> ，表示没有超时。
        </td>
<td>没有</td>
</tr>
<tr>
<td>套接字保持活动</td>
<td>此标志控制套接字保持活动功能，该功能可通过防火墙保持连接活动<tt class="code">Socket.setKeepAlive（boolean）</tt><br>默认值为<tt class="code">false</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>ThreadsAllowedToBlockForConnectionMultiplier</td>
<td>此乘数乘以connectionsPerHost设置，可得出等待池中的连接可用的最大线程数。<br>所有其他线程将立即获得异常。<br>例如，如果<tt class="code">connectionsPerHost</tt>为<tt class="code">10，</tt>而<tt class="code">threadsAllowedToBlockForConnectionMultiplier</tt>为<tt class="code">5</tt> ，则最多可以有50个线程等待连接。<br>默认值为<tt class="code">5</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>写关注：安全</td>
<td>如果为<tt class="code">true，</tt>则驱动程序将使用<tt class="code">WriteConcern</tt>的<tt class="code">WriteConcern。安全</tt>的所有操作。<br>如果指定了<tt class="code">w</tt> ， <tt class="code">wtimeout</tt> ， <tt class="code">fsync</tt>或<tt class="code">j</tt> ，则忽略此设置。<br>默认值为<tt class="code">false</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>写问题：Fsync</td>
<td>全局<tt class="code">WriteConcern</tt>的<tt class="code">fsync</tt>值。<br>默认值为<tt class="code">false</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>写关注：等待日志</td>
<td>全局<tt class="code">WriteConcern</tt>的<tt class="code">j</tt>值。<br>默认值为<tt class="code">false</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>写关注点：等待服务器</td>
<td>全局<tt class="code">WriteConcern</tt>的<tt class="code">w</tt>值。<br>默认值为<tt class="code">0</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>写关注点：等待超时</td>
<td>全局<tt class="code">WriteConcern</tt>的<tt class="code">wtimeout</tt>值。<br>默认值为<tt class="code">0</tt> 。
        </td>
<td>没有</td>
</tr>
<tr>
<td>写问题：继续出错</td>
<td>如果批量插入应在第一个错误后继续进行</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a><table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Bolt_Connection_Configuration">18.4.21螺栓连接配置</a>
</h3>
</font>
</td></tr>
<tr><td>根据提供的连接设置创建一个Bolt连接池（由<a href="../usermanual/component_reference.html#Bolt_Request">Bolt Request</a> Sampler使用）。
    <p><b>控制面板</b></p>
<div align="center"><img width="711" height="170" src="../images/screenshots/bolt-connection-config.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此采样器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>评论</td>
<td>免费文本以获取更多详细信息。</td>
<td>没有</td>
</tr>
<tr>
<td>螺栓URI</td>
<td>数据库URI。</td>
<td>是</td>
</tr>
<tr>
<td>用户名</td>
<td>用户帐号。</td>
<td>没有</td>
</tr>
<tr>
<td>密码</td>
<td>用户凭证。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="assertions"><strong>18.5断言</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <p>断言用于对采样器执行其他检查，并在同一范围内的<b>每个采样器</b>之后进行处理。为确保将断言仅应用于特定的采样器，请将其添加为采样器的子代。
    </p>
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：除非另有说明，否则断言不会应用于子样本（子样本），而仅应用于父样本。对于JSR223和BeanShell断言，脚本可以使用<tt class="code">prev.getSubResults（）</tt>方法检索子样本，该方法返回SampleResults的数组。如果没有数组，则该数组将为空。
    </td></tr>
</tbody></table>
<p></p>

    <p>断言可以应用于主样本，子样本或两者。默认设置是仅将断言应用于主样本。如果断言支持此选项，则GUI上将有一个类似于以下内容的条目：</p>
    <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="658" height="54" src="../images/screenshots/assertion/assertionscope.png"><br>
<font size="-1">断言范围</font></td></tr></tbody></table>或以下<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="841" height="55" src="../images/screenshots/assertion/assertionscopevar.png"><br>
<font size="-1">断言范围</font></td></tr></tbody></table>

    <p>如果子采样器失败而主样本成功，则主样本将设置为失败状态，并添加断言结果。如果使用了JMeter变量选项，则假定它与主样本有关，并且任何失败都将仅应用于主样本。
    </p>
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>运行<tt class="code">完</tt>采样器的所有断言后，变量<tt class="code">JMeterThread.last_sample_ok</tt>将更新为“ <tt class="code">true</tt> ”或“ <tt class="code">false</tt> ”。
     </td></tr>
</tbody></table>
<p></p>

</div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Response_Assertion">18.5.1响应断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>响应声明控制面板使您可以添加要与请求或响应的各个字段进行比较的模式字符串。模式字符串是：</p>
    <ul>
    <li><tt class="code">包含</tt> ， <tt class="code">匹配</tt> ：Perl5样式的正则表达式</li>
    <li><tt class="code">等于</tt> ， <tt class="code">子字符串</tt> ：纯文本，区分大小写</li>
    </ul>
    <p>模式匹配字符的摘要可以在<a href="http://jakarta.apache.org/oro/api/org/apache/oro/text/regex/package-summary.html">ORO Perl5正则表达式中找到。</a>
    </p>
    <p>您还可以选择是希望字符串<b>与</b>整个响应<b>匹配</b> ，还是仅期望响应<b>包含</b>模式。您可以将多个断言附加到任何控制器，以提高灵活性。</p>
<p>请注意，模式字符串不应包含封闭的定界符，即使用<tt class="code">Price：\ d +</tt>而不是<tt class="code">/ Price：\ d + /</tt> 。
    </p>
    <p>默认情况下，该模式处于多行模式，这意味着“ <tt class="code">。</tt> ”元字符与换行符不匹配。在多行模式下，“ <tt class="code">^</tt> ”和“ <tt class="code">$</tt> ”匹配字符串中任意位置的任何行的开头或结尾，而不仅仅是整个字符串的开头和结尾。请注意， <tt class="code">\ s</tt>确实与换行符匹配。情况也很重要。要覆盖这些设置，可以使用<i>扩展的正则表达式</i>语法。例如：</p>
<dl>
<dt><tt class="code">（？一世）</tt></dt><dd>忽略大小写</dd>
<dt><tt class="code">（？s）</tt></dt><dd>将目标视为单行，即“ <tt class="code">。</tt> ”匹配换行</dd>
<dt><tt class="code">（？是）</tt></dt><dd>以上两者</dd>
</dl>它们可以在表达式中的任何位置使用，并一直有效直到被覆盖。例如<dl>
<dt><tt class="code">（？i）苹果（？-i）派</tt></dt><dd>匹配“ <tt class="code">ApPLe Pie</tt> ”，但不匹配“ <tt class="code">ApPLe pIe</tt> ”</dd>
<dt><tt class="code">（？s）苹果。+？馅饼</tt></dt><dd>匹配<tt class="code">Apple，</tt>后跟<tt class="code">Pie</tt> ，后者可能在下一行。</dd>
<dt><tt class="code">苹果（？s）。+？馅饼</tt></dt><dd>与上述相同，但使用<tt class="code">（？s）</tt>一开始。</dd>
</dl>

<p><b>控制面板</b></p>
<div align="center"><img width="909" height="607" src="../images/screenshots/assertion/assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -均适用。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -断言将应用于命名变量的内容</li>
        </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>测试领域</td>
<td>指示JMeter测试“请求”或“响应”的哪个字段。<ul>
        <li><tt class="code">文本响应</tt> -来自服务器的响应文本，即正文，不包括任何HTTP标头。</li>
        <li><tt class="code">请求数据</tt> -发送到服务器的请求文本，即正文，不包括任何HTTP标头。</li>
        <li><tt class="code">响应码</tt> -例如<tt class="code">200</tt></li>
        <li><tt class="code">响应消息</tt> -例如， <tt class="code">确定</tt></li>
        <li><tt class="code">响应标头</tt> ，包括Set-Cookie标头（如果有）</li>
        <li><tt class="code">请求标题</tt></li>
        <li><tt class="code">URL采样</tt></li>
        <li><tt class="code">文档（文本）</tt> -通过Apache Tika从各种类型的文档中提取文本（请参见<a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树</a>文档视图部分）。</li>
        </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>忽略状态</td>
<td>指示JMeter最初将状态设置为成功。
                <p>通过将断言的结果与现有响应状态相结合来确定样本的总体成功与否。选中“ <tt class="code">忽略状态”</tt>复选框时，在评估断言之前，将强制响应状态为成功。
                </p>状态为<tt class="code">4xx</tt>和<tt class="code">5xx</tt>范围的HTTP响应通常被视为不成功。“ <tt class="code">忽略状态</tt> ”复选框可用于在执行进一步检查之前成功设置状态。请注意，这将清除所有先前的断言失败，因此请确保仅在第一个断言上设置此项。
        </td>
<td>是</td>
</tr>
<tr>
<td>模式匹配规则</td>
<td>指示如何根据模式检查要测试的文本。
        <ul>
        <li><tt class="code">包含</tt> -如果文本包含正则表达式模式，则为true</li>
        <li><tt class="code">匹配</tt> -如果整个文本与正则表达式模式匹配，则为true</li>
        <li><tt class="code">等于</tt> -如果整个文本等于模式字符串（区分大小写），则为true</li>
        <li><tt class="code">子字符串</tt> -如果文本包含模式字符串（区分大小写），则为true</li>
        </ul>
        <tt class="code">等于</tt>和<tt class="code">子字符串</tt>模式是纯字符串，不是正则表达式。
        也可以选择<tt class="code">NOT</tt>来反转检查结果。
        <tt class="code">或</tt>应用或组合中的每个断言（如果有1个模式要测试匹配，则断言是可以的）而不是与（所有模式必须匹配，以便断言是正确的）。</td>
<td>是</td>
</tr>
<tr>
<td>测试模式</td>
<td>要测试的模式列表。每种模式分别进行测试。如果某个模式失败，则不会检查其他模式。设置一个具有多个模式的断言与设置每个具有一个模式的多个断言之间没有区别（假设其他选项相同）。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>但是，当选择“ <tt class="code">忽略状态”</tt>复选框时，这具有取消任何先前的断言失败的效果-因此，请确保“仅在断言时使用” <tt class="code">忽略状态</tt>复选框。</td></tr>
</tbody></table>
<p></p>

        </td>
<td>是</td>
</tr>
<tr>
<td>自定义失败消息</td>
<td>让您定义将替换生成的失败消息的失败消息</td>
<td>没有</td>
</tr>
</tbody></table>
<p>该模式是Perl5样式的正则表达式，但没有括号。
</p><a name="assertion_examples"></a>
<p><b>断言示例</b></p>

<center>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="266" height="117" src="../images/screenshots/assertion/example1a.png"><br>
<font size="-1">图14-测试计划</font></td></tr></tbody></table>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="920" height="451" src="../images/screenshots/assertion/example1b.png"><br>
<font size="-1">图15-带有模式的断言控制面板</font></td></tr></tbody></table>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="801" height="230" src="../images/screenshots/assertion/example1c-pass.png"><br>
<font size="-1">图16-断言侦听器结果（通过）</font></td></tr></tbody></table>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="800" height="233" src="../images/screenshots/assertion/example1c-fail.png"><br>
<font size="-1">图17-断言监听器结果（失败）</font></td></tr></tbody></table>

</center>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Duration_Assertion">18.5.2持续时间断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>持续时间断言测试在给定的时间内收到了每个响应。任何超过给定毫秒数（由用户指定）的响应都将被标记为失败响应。</p><p><b>控制面板</b></p>
<div align="center"><img width="606" height="187" src="../images/screenshots/duration_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>持续时间（毫秒）</td>
<td>在将每个响应标记为失败之前，允许的最大毫秒数。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Size_Assertion">18.5.3大小断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>大小声明测试每个响应中包含正确数量的字节。您可以指定大小等于，大于，小于或不等于给定的字节数。</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>空响应被视为0字节，而不是报告为错误。</td></tr>
</tbody></table>
<p></p>

<p><b>控制面板</b></p>
<div align="center"><img width="732" height="358" src="../images/screenshots/size_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -断言仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -断言仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -断言适用于两者。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -断言将应用于命名变量的内容</li>
        </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>大小（以字节为单位）</td>
<td>测试响应大小（或JMeter变量的值）时使用的字节数。</td>
<td>是</td>
</tr>
<tr>
<td>比较类型</td>
<td>是否测试响应是否等于，大于，小于或不等于指定的字节数。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="XML_Assertion">18.5.4 XML断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>XML断言测试响应数据包含形式正确的XML文档。它不会基于DTD或架构验证XML，也不会进行任何进一步的验证。</p><p><b>控制面板</b></p>
<div align="center"><img width="470" height="85" src="../images/screenshots/xml_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="BeanShell_Assertion">18.5.5 BeanShell断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>BeanShell断言允许用户使用BeanShell脚本执行断言检查。
</p>
<p>
<b>有关使用BeanShell的完整详细信息，请访问<a href="http://www.beanshell.org/">BeanShell网站。</a></b>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>强烈建议迁移到<a href="../usermanual/component_reference.html#JSR223_Assertion">JSR223断言</a> + Groovy，以提高性能，支持新的Java功能并限制BeanShell库的维护。</td></tr>
</tbody></table>
<p></p>

<p></p><p>请注意，对于测试脚本中每个线程中的每个独立断言事件，将使用不同的解释器，但将相同的解释器用于后续调用。这意味着变量会在对断言的调用之间持续存在。
</p>
<p>所有断言都是从与采样器相同的线程中调用的。
</p>
<p>如果定义了属性“ <tt class="code">beanshell.assertion.init</tt> ”，则将其作为源文件的名称传递给Interpreter。这可以用来定义通用方法和变量。<tt class="code">bin</tt>目录中有一个样本初始化文件： <tt class="code">BeanShellAssertion.bshrc</tt>
</p>
<p>测试元素支持<tt class="code">ThreadListener</tt>和<tt class="code">TestListener</tt>方法。这些应该在初始化文件中定义。有关示例定义，请参见文件<tt class="code">BeanShellListeners.bshrc</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="849" height="633" src="../images/screenshots/beanshell_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。名称存储在脚本变量<tt class="code">Label中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>重置bsh。每次通话前翻译</td>
<td>如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关更多信息，请参见<a href="best-practices#bsh_scripting">Best Practices-BeanShell脚本</a> 。
    </td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给BeanShell脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">bsh.args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的BeanShell脚本的文件。这将覆盖脚本。文件名存储在脚本变量<tt class="code">FileName中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>要运行的BeanShell脚本。返回值将被忽略。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>您可以尝试使用一个<a href="../demos/BeanShellAssertion.bsh">示例脚本</a> 。</p><p>在调用脚本之前，在BeanShell解释器中设置了一些变量。除非另有说明，否则这些都是字符串：</p><ul>
  <li><tt class="code">log-</tt> <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">记录器</a>对象。 （例如） <tt class="code">log.warn（“ Message” [，Throwable]）</tt></li>
  <li><tt class="code">SampleResult，</tt> <tt class="code">上一个</tt> -的<a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a>对象;读写</li>
  <li><tt class="code">响应</tt> -响应对象；读写</li>
  <li><tt class="code">失败</tt> -布尔值；读写用于设置断言状态</li>
  <li><tt class="code">FailureMessage-</tt>字符串；读写用于设置断言消息</li>
  <li><tt class="code">ResponseData-</tt>响应主体（字节[]）</li>
  <li><tt class="code">ResponseCode-</tt>例如<tt class="code">200</tt></li>
  <li><tt class="code">ResponseMessage-</tt>例如， <tt class="code">确定</tt></li>
  <li><tt class="code">ResponseHeaders-</tt>包含HTTP标头</li>
  <li><tt class="code">RequestHeaders-</tt>包含发送到服务器的HTTP标头</li>
  <li><tt class="code">SampleLabel</tt></li>
  <li><tt class="code">SamplerData-</tt>已发送到服务器的数据</li>
  <li><tt class="code">ctx</tt> - <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a></li>
  <li><tt class="code">vars</tt> - <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables-</a>例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(&quot;VAR1&quot;);
vars.put(&quot;VAR2&quot;,&quot;value&quot;);
vars.putObject(&quot;OBJ1&quot;,new Object());</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
  <li><tt class="code">道具</tt> -JMeterProperties（类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><tt class="code">java.util。属性</tt></a> ）-例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>props.get(&quot;START.HMS&quot;);
props.put(&quot;PROP1&quot;,&quot;1234&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
</ul><p>响应对象的以下方法可能有用：</p><ul>
    <li><tt class="code">setStopThread（boolean）</tt></li>
    <li><tt class="code">setStopTest（boolean）</tt></li>
    <li><tt class="code">字符串getSampleLabel（）</tt></li>
    <li><tt class="code">setSampleLabel（String）</tt></li>
</ul></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="MD5Hex_Assertion">18.5.6 MD5Hex断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>MD5Hex断言允许用户检查响应数据的MD5哈希。</p><p><b>控制面板</b></p>
<div align="center"><img width="398" height="130" src="../images/screenshots/assertion/MD5HexAssertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>MD5总和</td>
<td>代表MD5哈希值的32个十六进制数字（大小写无关）</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTML_Assertion">18.5.7 HTML断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>HTML断言允许用户使用JTidy检查响应数据的HTML语法。</p><p><b>控制面板</b></p>
<div align="center"><img width="505" height="341" src="../images/screenshots/assertion/HTMLAssertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>doctype</td>
<td><tt class="code">省略</tt> ， <tt class="code">自动</tt> ， <tt class="code">严格</tt>或<tt class="code">松散</tt></td>
<td>是</td>
</tr>
<tr>
<td>格式</td>
<td><tt class="code">HTML</tt> ， <tt class="code">XHTML</tt>或<tt class="code">XML</tt></td>
<td>是</td>
</tr>
<tr>
<td>仅错误</td>
<td>只记录错误？</td>
<td>是</td>
</tr>
<tr>
<td>误差阈值</td>
<td>将响应分类为失败之前允许的错误数</td>
<td>是</td>
</tr>
<tr>
<td>警告阈值</td>
<td>将响应分类为失败之前允许的警告数</td>
<td>是</td>
</tr>
<tr>
<td>文档名称</td>
<td>写入报告的文件名</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="XPath_Assertion">18.5.8 XPath断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>XPath断言测试文档的格式是否正确，可以选择根据DTD进行验证，也可以将文档通过JTidy进行测试以测试XPath。如果该XPath存在，则断言为true。使用“ <tt class="code">/</tt> ”将匹配任何格式正确的文档，并且是默认的XPath表达式。该断言还支持布尔表达式，例如“ <tt class="code">count（// * error）= 2</tt> ”。有关XPath的更多信息，请参见<a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a> 。
</p>一些示例表达式：<ul>
<li><tt class="code">// title [text（）='要匹配的文本']</tt> -匹配项<tt class="code"><title>文字相符</title></tt>响应中的任何地方</li>
<li><tt class="code">/ title [text（）='要匹配的文本']</tt> -匹配<tt class="code"><title>文字相符</title></tt>在响应的根级</li>
</ul>
<p><b>控制面板</b></p>
<div align="center"><img width="871" height="615" src="../images/screenshots/xpath_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>使用Tidy（容忍的解析器）</td>
<td>使用Tidy，即可以容忍XML / HTML错误</td>
<td>是</td>
</tr>
<tr>
<td>安静</td>
<td>设置整洁安静标志</td>
<td>如果选择整洁</td>
</tr>
<tr>
<td>报告错误</td>
<td>如果出现Tidy错误，则相应地设置断言</td>
<td>如果选择整洁</td>
</tr>
<tr>
<td>显示警告</td>
<td>设置整洁的showWarnings选项</td>
<td>如果选择整洁</td>
</tr>
<tr>
<td>使用命名空间</td>
<td>应该尊重名称空间吗？（请参见下面的NAMESPACES注释）</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>验证XML</td>
<td>根据文档的架构检查文档。</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>忽略空格</td>
<td>忽略元素空格。</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>提取外部DTD</td>
<td>如果选择，则提取外部DTD。</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>XPath断言</td>
<td>在文档中匹配的XPath。</td>
<td>是</td>
</tr>
<tr>
<td>反转断言（如果满足以上条件，将失败）</td>
<td>如果XPath表达式不匹配或返回false，则为true</td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>非容忍的解析器可能非常慢，因为它可能需要下载DTD等。</td></tr>
</tbody></table>
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<b>名称空间</b><br>作为Xalan XPath解析器的名称空间限制的工作回合（JMeter所基于的实现），您需要：<ul>
<li>提供一个属性文件（例如，您的文件名为namespaces.properties），其中包含名称空间前缀的映射：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
prefix1=http\://foo.apache.org
prefix2=http\://toto.apache.org
…
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>

<li>使用属性在<tt class="code">user.properties</tt>文件中引用此文件：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>xpath.namespace.config=namespaces.properties</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
</ul>
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="XPath2_Assertion">18.5.16 XPath2断言</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>XPath2断言测试文档的格式是否正确。使用“ <tt class="code">/</tt> ”将匹配任何格式正确的文档，并且是默认的XPath2表达式。该断言还支持布尔表达式，例如“ <tt class="code">count（// * error）= 2</tt> ”。
</p>一些示例表达式：<ul>
<li><tt class="code">// title [text（）='要匹配的文本']</tt> -匹配项<tt class="code"><title>文字相符</title></tt>响应中的任何地方</li>
<li><tt class="code">/ title [text（）='要匹配的文本']</tt> -匹配<tt class="code"><title>文字相符</title></tt>在响应的根级</li>
</ul>
<p><b>控制面板</b></p>
<div align="center"><img width="871" height="615" src="../images/screenshots/xpath_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>命名空间别名列表</td>
<td>您要用来解析文档的名称空间别名列表，每个声明一行。您必须按以下方式指定它们： <tt class="code">prefix = namespace</tt> 。与旧版本的XPathExtractor相比，此实现使使用名称空间更加容易。</td>
<td>没有</td>
</tr>
<tr>
<td>XPath2断言</td>
<td>在文档中匹配的XPath。</td>
<td>是</td>
</tr>
<tr>
<td>反断言</td>
<td>如果xpath表达式返回true或匹配项将失败，否则将成功</td>
<td>没有</td>
</tr>
<tr>
<td>命名空间别名列表</td>
<td>名称空间别名列表prefix =完整名称空间（每行一个）</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="XML_Schema_Assertion">18.5.9 XML模式声明</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>XML模式声明允许用户验证对XML模式的响应。</p><p><b>控制面板</b></p>
<div align="center"><img width="472" height="132" src="../images/screenshots/assertion/XMLSchemaAssertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>文档名称</td>
<td>指定XML模式文件名</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSR223_Assertion">18.5.11 JSR223断言</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>通过JSR223断言，可以使用JSR223脚本代码检查先前样本的状态。
</p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>语言</td>
<td>使用的JSR223语言</td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于“ <tt class="code">user.dir</tt> ”系统属性引用的目录</td>
<td>没有</td>
</tr>
<tr>
<td>脚本编译缓存</td>
<td>如果使用的语言支持<tt class="code"><a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html">Compilable</a></tt>接口，则JMeter将使用该测试计划中的唯一字符串来缓存脚本编译结果（Groovy是其中之一，而Java，BeanShell和JavaScript不支持）<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您使用的是Groovy而不选中此选项，请参见JSR223 Sampler Java System属性中的注释</td></tr>
</tbody></table>
<p></p>

    </td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>要运行的脚本。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>设置了以下变量供脚本使用：</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">标签</tt> -字符串标签</li>
<li><tt class="code">文件名</tt> -脚本文件名（如果有）</li>
<li><tt class="code">参数</tt> -参数（作为字符串）</li>
<li><tt class="code">args-</tt>作为字符串数组的参数（在空格上分割）</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());
vars.getObject(&quot;OBJ2&quot;);
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><tt class="code">java.util。属性</tt></a> ）-例如<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
props.get(&quot;START.HMS&quot;);
props.put(&quot;PROP1&quot;,&quot;1234&quot;);
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">SampleResult</tt> ， <tt class="code">prev-</tt> （ <a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ）-提供对上一个SampleResult的访问（如果有）</li>
<li><tt class="code">采样器</tt> -（ <a href="../api/org/apache/jmeter/samplers/Sampler.html">采样器</a> ）-提供对当前采样器的访问</li>
<li><tt class="code">OUT</tt> - <tt class="code">System.out-</tt>例如<tt class="code">OUT.println（“ message”）</tt></li>
<li><tt class="code">AssertionResult-</tt> （ <a href="../api/org/apache/jmeter/assertions/AssertionResult.html">AssertionResult</a> ）-断言结果</li>
</ul><p>该脚本可以检查<a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult的</a>各个方面。如果检测到错误，则脚本应使用<tt class="code">AssertionResult.setFailureMessage（“ message”）</tt>和<tt class="code">AssertionResult.setFailure（true）</tt> 。
</p><p>有关上述每个变量可用的所有方法的更多详细信息，请检查Javadoc</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Compare_Assertion">18.5.12比较断言</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>负载测试期间<b>不得使用“</b>比较声明”，因为它消耗大量资源（内存和CPU）。仅将其用于功能测试或在测试计划调试和验证期间使用。
</td></tr>
</tbody></table>
<p></p>比较断言可用于比较其范围内的样本结果。可以比较内容或经过的时间，并且可以在比较之前过滤内容。断言比较可以在“ <a href="../usermanual/component_reference.html#Comparison_Assertion_Visualizer">比较断言可视化器”中</a>看到。
<p><b>控制面板</b></p>
<div align="center"><img width="580" height="302" src="../images/screenshots/assertion/compare.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>比较内容</td>
<td>是否比较内容（响应数据）</td>
<td>是</td>
</tr>
<tr>
<td>比较时间</td>
<td>如果该值≥0，则检查响应时间差是否不大于该值。即，如果该值为<tt class="code">0</tt> ，则响应时间必须完全相等。</td>
<td>是</td>
</tr>
<tr>
<td>比较过滤器</td>
<td>过滤器可用于从内容比较中删除字符串。例如，如果页面有时间戳，则可能与以下内容匹配：“ <tt class="code">时间：\ d \ d：\ d \ d：\ d \ d</tt> ”，并替换为虚拟固定时间“ <tt class="code">时间：HH：MM： SS</tt> ”。
    </td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="SMIME_Assertion">18.5.13 SMIME断言</a>
</h3>
</font>
</td></tr>
<tr><td>SMIME断言可用于评估来自邮件阅读器采样器的样本结果。此断言验证哑剧消息的主体是否已签名。签名也可以针对特定的签名者证书进行验证。由于大多数用户不一定需要此功能，因此需要下载其他jar并将其添加到<tt class="code">JMETER_HOME / lib中</tt> ：<br>
 
<ul>
<li><tt class="code">bcmail-xxx.jar</tt> （BouncyCastle SMIME / CMS）</li>
<li><tt class="code">bcprov-xxx.jar</tt> （BouncyCastle提供程序）</li>
</ul>这些需要<a href="http://www.bouncycastle.org/latest_releases.html">从BouncyCastle下载。</a>
<p>如果使用<a href="../usermanual/component_reference.html#Mail_Reader_Sampler">Mail Reader Sampler</a> ，请确保选择“ <tt class="code">使用MIME存储邮件（原始）</tt> ”，否则断言将无法正确处理邮件。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="471" height="428" src="../images/screenshots/assertion/smime.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>验证签名</td>
<td>如果选中，则声明将根据“ <tt class="code">签署者证书”</tt>框中定义的参数来验证其是否为有效签名。</td>
<td>是</td>
</tr>
<tr>
<td>消息未签名</td>
<td>是否期望消息中的签名</td>
<td>是</td>
</tr>
<tr>
<td>签署人证书</td>
<td>“ <tt class="code">不检查</tt> ”表示将不执行签名验证。 “ <tt class="code">Check values</tt> ”用于根据提供的输入来验证签名。并且“ <tt class="code">证书文件</tt> ”将针对特定的证书文件执行验证。</td>
<td>是</td>
</tr>
<tr>
<td>讯息位置</td>
<td>邮件采样器可以在一个样本中检索多个消息。使用此字段可以指定要检查的消息。消息从<tt class="code">0开始</tt>编号，因此<tt class="code">0</tt>表示第一条消息。从LAST消息开始计算负数； <tt class="code">-1</tt>表示LAST， <tt class="code">-2</tt>表示倒数第二个等。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSON_Assertion">18.5.14 JSON断言</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>该组件使您可以执行JSON文档的验证。首先，它将解析JSON，如果数据不是JSON则失败。其次，它将使用<a href="https://github.com/json-path/JsonPath">Jayway JsonPath 1.2.0中的</a>语法搜索指定的路径。如果找不到该路径，它将失败。第三，如果在文档中找到JSON路径，并且要求对期望值进行验证，它将执行验证。对于<tt class="code">null</tt>值，GUI中有一个特殊的复选框。请注意，如果路径将返回数组对象，则将对其进行迭代，并且如果找到期望值，则断言将成功。要验证空数组，请使用<tt class="code">[]</tt>字符串。另外，如果patch将返回字典对象，则在比较之前将其转换为字符串。
        </p>
    <p><b>控制面板</b></p>
<div align="center"><img width="1095" height="307" src="../images/screenshots/assertion/json_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>断言JSON路径存在</td>
<td>断言的JSON元素的路径。</td>
<td>是</td>
</tr>
<tr>
<td>附加断言值</td>
<td>如果要使断言具有某些值，请选择复选框</td>
<td>没有</td>
</tr>
<tr>
<td>匹配为正则表达式</td>
<td>如果要使用正则表达式，请选中复选框</td>
<td>没有</td>
</tr>
<tr>
<td>期望值</td>
<td>断言的值或匹配的正则表达式</td>
<td>没有</td>
</tr>
<tr>
<td>期望为空</td>
<td>如果期望为空，请选中复选框</td>
<td>没有</td>
</tr>
<tr>
<td>反转断言（如果满足以上条件，将失败）</td>
<td>反转断言（如果满足以上条件，将失败）</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSON_JMESPath_Assertion">18.5.15 JSON JMESPath断言</a>
</h3>
</font>
</td></tr>
<tr><td>

        <p>这个组件允许您使用<a href="http://jmespath.org/" target="blank">JMESPath</a>对JSON文档内容执行断言。首先，它将解析JSON，如果数据不是JSON则失败。<br>其次，它将使用JMESPath语法搜索指定的路径。<br>如果找不到该路径，它将失败。<br>第三，如果在文档中找到JMES路径，并要求针对期望值进行验证，它将执行此附加检查。如果要检查是否为空，请使用<tt class="code">Expect null</tt>复选框。<br>请注意，该路径不能为null，因为将不会编译表达式JMESPath并发生错误。即使期望响应为空或为空，也必须放置有效的JMESPath表达式。
        </p>
    <p><b>控制面板</b></p>
<div align="center"><img width="1095" height="307" src="../images/screenshots/assertion/jmespath_assertion.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>断言JMESPath存在</td>
<td>检查是否存在JMESPath to JSON元素</td>
<td>是</td>
</tr>
<tr>
<td>附加断言值</td>
<td>如果您根据预期的选项检查提取的JMESPath，请选中此复选框</td>
<td>没有</td>
</tr>
<tr>
<td>匹配为正则表达式</td>
<td>如果要使用正则表达式进行匹配，请选中复选框</td>
<td>没有</td>
</tr>
<tr>
<td>期望值</td>
<td>如果选中“ <tt class="code">匹配为正</tt>则表达式”，则用于精确匹配或正<tt class="code">则表达式的</tt>值</td>
<td>没有</td>
</tr>
<tr>
<td>期望为空</td>
<td>如果您期望该值为空，请选择复选框</td>
<td>没有</td>
</tr>
<tr>
<td>反转断言（如果满足以上条件，将失败）</td>
<td>反转断言（如果满足以上条件，将失败）</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="timers"><strong>18.6计时器</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>从3.1版开始，已实现了一项新功能（自JMeter 3.1起处于Beta模式，并且可能会发生更改），该功能提供以下功能。<br>您可以通过设置属性<tt class="code">timer.factor = float number（</tt>其中float号为十进制正数）来对Random计时器计算的睡眠延迟应用乘数因子。<br>JMeter会将这个因子乘以计算出的睡眠延迟。可以通过以下方式使用此功能：<ul> 
        <li><a href="../usermanual/component_reference.html#Gaussian_Random_Timer">高斯随机计时器</a></li>
        <li><a href="../usermanual/component_reference.html#Poisson_Random_Timer">泊松随机计时器</a></li>
        <li><a href="../usermanual/component_reference.html#Uniform_Random_Timer">统一随机计时器</a></li>
    </ul> 
    </td></tr>
</tbody></table>
<p></p>

    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，在发现它们的范围内， <b>在</b>每个采样器<b>之前</b>都要处理定时器。如果同一范围内有多个计时器，则将<b>在每个</b>采样器<b>之前</b>处理<b>所有</b>计时器。
    <br>计时器仅与采样器一起处理。与采样器不在同一范围内的计时器将不会被处理。
    <br>要将计时器应用于单个采样器，请将计时器添加为采样器的子元素。在执行采样器之前将应用计时器。要在采样器之后应用计时器，请将其添加到下一个采样器，或将其添加为<a href="../usermanual/component_reference.html#Flow_Control_Action">Flow Control Action</a> Sampler的子代。
    </td></tr>
</tbody></table>
<p></p>

</div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Constant_Timer">18.6.1恒定计时器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>如果您希望每个线程在两次请求之间暂停相同的时间，请使用此计时器。</p><p><b>控制面板</b></p>
<div align="center"><img width="372" height="100" src="../images/screenshots/timers/constant_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>线程延迟</td>
<td>暂停的毫秒数。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Gaussian_Random_Timer">18.6.2高斯随机计时器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该计时器将每个线程请求暂停一段随机的时间，大多数时间间隔都在某个特定值附近发生。总延迟是高斯分布值（平均值为<tt class="code">0.0</tt> ，标准偏差为<tt class="code">1.0</tt> ）乘以您指定的偏差值与偏移值之和。解释它的另一种方式是，在高斯随机计时器中，恒定偏移周围的变化具有高斯曲线分布。

</p><p><b>控制面板</b></p>
<div align="center"><img width="372" height="156" src="../images/screenshots/timers/gauss_random_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称</td>
<td>没有</td>
</tr>
<tr>
<td>偏差</td>
<td>偏差（以毫秒为单位）。</td>
<td>是</td>
</tr>
<tr>
<td>恒定延迟偏移</td>
<td>除随机延迟外，要暂停的毫秒数。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Uniform_Random_Timer">18.6.3统一随机计时器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该计时器将每个线程请求暂停一个随机的时间量，每个时间间隔的发生概率相同。总延迟是随机值和偏移值之和。</p><p><b>控制面板</b></p>
<div align="center"><img width="372" height="157" src="../images/screenshots/timers/uniform_random_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>随机延迟最大值</td>
<td>要暂停的最大随机毫秒数。</td>
<td>是</td>
</tr>
<tr>
<td>恒定延迟偏移</td>
<td>除随机延迟外，要暂停的毫秒数。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Constant_Throughput_Timer">18.6.4恒定吞吐量计时器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该计时器引入了可变的暂停，其计算目的是使总吞吐量（以每分钟的样本数为单位）尽可能接近给定的数字。当然，如果服务器无法处理吞吐量，或者其他计时器或耗时的测试元素阻止了吞吐量，则吞吐量会降低。</p>
<p>注意：尽管该计时器称为恒定吞吐量计时器，但吞吐量值不需要恒定。可以根据变量或函数调用进行定义，并且可以在测试期间更改其值。该值可以通过多种方式更改：</p>
<ul>
<li>使用计数器变量</li>
<li>使用<tt class="code">__jexl3</tt>和<tt class="code">__groovy</tt>函数提供变化的值</li>
<li>使用远程BeanShell服务器更改JMeter属性</li>
</ul>
<p>有关更多详细信息，请参见<a href="best-practices.html">最佳实践</a> 。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，吞吐量值在测试期间不应过分更改-新值生效需要一段时间。
</td></tr>
</tbody></table>
<p></p>

<p></p>
<p><b>控制面板</b></p>
<div align="center"><img width="636" height="146" src="../images/screenshots/timers/constant_throughput_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>目标吞吐量</td>
<td>吞吐量，我们希望计时器尝试生成。</td>
<td>是</td>
</tr>
<tr>
<td>计算吞吐量基于</td>
<td>
   <ul>
    <li><tt class="code">仅此线程</tt> -每个线程都将尝试维持目标吞吐量。总吞吐量将与活动线程数成比例。</li>
    <li><tt class="code">当前线程组中的所有活动线程</tt> -目标吞吐量在该组中的所有活动线程之间分配。每个线程将根据其上次运行的时间根据需要延迟。</li>
    <li><tt class="code">所有活动线程</tt> -目标吞吐量在所有线程组的所有活动线程之间分配。每个线程将根据其上次运行的时间根据需要延迟。在这种情况下，每个其他线程组将需要一个具有相同设置的恒定吞吐量计时器。</li>
    <li><tt class="code">当前线程组（共享）中的所有活动线程</tt> -如上所述，但是每个线程都会根据该组中的任何线程上次运行的时间而延迟。</li>
    <li><tt class="code">所有活动线程（共享）</tt> -如上所述；每个线程都会根据上一次运行的时间而延迟。</li>
   </ul>
  </td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Precise_Throughput_Timer">18.6.5精确吞吐量计时器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该计时器引入了可变的暂停时间，计算该暂停时间是为了使总吞吐量（例如，每分钟样本数）尽可能接近给定值。当然，如果服务器不能够处理它，或者如果其他计时器，或者没有足够的线程，或者耗时的测试元素阻止了吞吐量，那么吞吐量将会降低。</p>
<p>尽管该计时器称为“精确吞吐量计时器”，但它的目的不是在测试过程中在一秒钟的间隔内产生完全相同数量的样本。</p>
<p>计时器最适合36000个请求/小时以下的速率，但是您的里程可能会有所不同（如果您的目标相差很大，请参见下面的监视部分）。</p>

<h4>测试计划中精确吞吐量计时器的最佳位置</h4>
<p>您可能知道，计时器由所有同级及其子元素继承。这就是为什么“ <tt class="code">精确吞吐量计时器</tt> ”的最佳位置之一是在测试循环中的第一个元素下面。例如，您可以在开始时添加一个虚拟采样器，然后将计时器放置在该虚拟采样器下方</p>

<h4>制作时间表</h4>
<p><tt class="code">精确的吞吐量计时器可</tt>模型化<a href="https://en.wikipedia.org/wiki/Poisson_point_process">泊松到达</a>时间表。该计划通常是在现实生活中发生的，因此将其用于负载测试很有意义。例如，它自然可能会生成相互靠近的样本，因此可能会发现并发问题。即使您设法使用<a href="../usermanual/component_reference.html#Poisson_Random_Timer">Poisson Random Timer</a>生成Poisson到达，它也很容易受到以下问题的影响。例如，真正的泊松到达可能会无限期地停顿，这对于负载测试不切实际。例如，“常规”泊松以每秒1的速率到达可能会在60秒的长时间测试中得到50个样本。</p>
<p><a href="../usermanual/component_reference.html#Constant_Throughput_Timer">恒定吞吐量计时器</a>收敛到指定的速率，但是它倾向于以均匀的间隔生成样本。</p>

<h4>加速和启动高峰</h4>
<p>您可以使用“加速”或类似的方法来避免在测试开始时出现峰值。例如，如果您将“ <a href="../usermanual/component_reference.html#Thread_Group">线程组”</a>配置为具有100个线程，并将“ <tt class="code">启动周期”</tt>设置为0（或较小的数量），则所有线程将同时启动，并且会产生不必要的负载峰值。最重要的是，如果将“ <tt class="code">启动周期”</tt>设置得太高，则可能导致刚开始可用的线程太少，无法达到所需的负载。</p>
<p><tt class="code">精确吞吐量计时器</tt>以随机方式安排执行时间，因此它可用于生成恒定负载，建议将<tt class="code">加速周期</tt>和<tt class="code">延迟均设置</tt>为<tt class="code">0</tt> 。</p>

<h4>多个线程组同时开始</h4>
<p>当<a href="../usermanual/component_reference.html#Test_Plan">测试计划</a>包含多个<a href="../usermanual/component_reference.html#Thead_Group">Thead Group</a>时，可能会出现<tt class="code">升级</tt>问题。为了减轻该问题，通常向每个<a href="../usermanual/component_reference.html#Thead_Group">Thead组</a>添加“随机”延迟，以便线程在不同的时间启动。</p>
<p><tt class="code">精确吞吐量计时器</tt>避免了该问题，因为它以随机方式安排执行时间。您无需添加额外的随机延迟来缓解启动高峰</p>

<h4>每小时迭代次数</h4>
<p>基本要求之一是每M分钟发布N个样本。使其为每小时60次迭代。如果仅仅“因为随机是随机的”，您就报告了57次执行的负载测试结果，那么商业客户将无法理解。为了每小时产生60次迭代，您需要进行以下配置（其他参数可以保留其默认值）</p>
<ul>
    <li><tt class="code">目标吞吐量（样本）</tt> ：60</li>
    <li><tt class="code">吞吐时间（秒）</tt> ：3600</li>
    <li><tt class="code">测试时间（秒）</tt> ：3600</li>
</ul>
<p>前两个选项设置吞吐量。即使60 / 3600、30 / 1800和120/7200表示完全相同的负载水平，也应选择更好地表示业务需求的负载水平。例如，如果要求测试“每小时60个样本”，则设置60/3600。如果要求测试“每分钟1个样品”，则设置为1/60。</p>
<p><tt class="code">测试持续时间（秒）</tt>在此处，因此计时器可确保在给定的测试持续时间内准确的样品数量。<tt class="code">精确吞吐量计时器</tt>会在测试启动时为样品创建时间表。例如，如果您希望以每小时60条的吞吐量执行5分钟的测试，则可以将“ <tt class="code">测试时间”（秒）设置</tt>为300。这样就可以以业务友好的方式配置吞吐量。注： <tt class="code">测试持续时间（秒），</tt> <b>不</b>限制测试时间。这只是计时器的提示。</p>

<h4>线程数和思考时间</h4>
<p>常见的陷阱之一是调整线程数和思考时间，以达到所需的吞吐量。即使可行，该方法也会导致大量时间花费在测试运行上。当新的应用程序版本到达时，可能需要调整线程并再次延迟。</p>
<p><tt class="code">精确的吞吐量计时器</tt>使您可以设置吞吐量目标并为之努力，无论应用程序的性能如何。为此， <tt class="code">Precise Throughput Timer</tt>在测试启动时创建一个计划，然后使用该计划释放线程。思考时间和线程数的主要驱动因素应该是业务需求，而不是某种程度上匹配吞吐量的愿望。</p>
<p>例如，如果您的应用程序被呼叫中心的支持工程师使用。假设呼叫中心有2位工程师，并且目标吞吐量为每分钟1个。假设工程师需要4分钟才能阅读和查看该网页。在这种情况下，您应该在组中设置2个线程，将4分钟用于思考时间延迟，并在“ <tt class="code">精确吞吐量计时器”中</tt>指定每分钟1个线程。当然，这将导致每分钟2个样本/ 4分钟= 0.5左右，并且这样的测试结果意味着“您需要呼叫中心中更多的支持工程师”或“您需要减少工程师完成任务所需的时间” ”。</p>

<h4>测试低费率和可重复的测试</h4>
<p>低速率（例如每小时60个）的测试需要知道所需的测试配置文件。例如，如果您需要以均匀的间隔（例如，间隔60秒）注入负载，则最好使用<a href="../usermanual/component_reference.html#Constant_Throughput_Timer">Constant Throughput Timer</a> 。但是，如果您需要随机安排时间表（例如，对执行报告的真实用户进行建模），那么“ <tt class="code">精确吞吐量计时器”</tt>就是您的朋友。</p>
<p>比较多个负载测试的结果时，能够重复完全相同的测试配置文件很有用。例如，如果在测试开始5分钟后调用了动作X（例如“利润报告”），那么最好将该模式复制用于后续测试执行。复制相同的负载模式可简化对测试结果的分析（例如，CPU％图表）。</p>
<p><tt class="code">随机种子（从0变为随机）</tt>可控制<tt class="code">精确吞吐量计时器</tt>使用的种子值。默认情况下，它用<tt class="code">0</tt>初始化，这意味着每次测试执行都使用随机种子。如果需要具有可重复的加载模式，则更改<tt class="code">随机种子，</tt>以便更改一些随机值。一般建议是使用非零种子，“默认情况下为0”是实现限制。</p>
<p>注意：当使用具有相同吞吐率和相同非零种子的多个线程组时，可能会导致不必要的同时触发样本。</p>

<h4>测试高速率和/或长测试持续时间</h4>
<p>当样本数量很高（例如，超过10 000）时，由于“ <tt class="code">精确吞吐量计时器”</tt>尝试生成准确的样本数量，因此计划生成可能会花费明显的时间（例如，秒）。也有内存消耗，但是不要紧，因为调度中的每个项目都消耗8个字节。为了减少计划生成的开销，“ <tt class="code">精确吞吐量计时器”</tt>在生成较长的计划时允许一些松弛。它由<tt class="code">生成的延迟</tt>属性的<tt class="code">精度</tt>控制。默认情况下，当样本数超过10000时，允许使用不精确的计划。</p>
<p>如果要以每小时5,000的速度执行为期2周的测试，则无需为该2周创建时间表。您可以将计时器的“ <tt class="code">测试持续时间（秒）”</tt>属性设置为1小时。计时器将为一个小时创建5 000个样本的时间表，当时间表用尽时，计时器将为下一个小时生成时间表。</p>

<h4>突发负载</h4>
<p>在某些情况下，所有样本应成对，三元组等。某些情况下可以通过<a href="../usermanual/component_reference.html#Synchronizing_Timer">Synchronizing Timer</a>解决，但是“ <tt class="code">精确吞吐量计时器”</tt>具有本机发出打包请求的方式。默认情况下，此行为是禁用的，并且由“批量出发”设置控制</p>
<ul>
    <li><tt class="code">批处理中的线程数（线程）</tt> 。指定批次中的样本数。请注意，样本总数仍将与<tt class="code">目标吞吐量保持一致</tt></li>
    <li><tt class="code">批中线程之间的延迟（毫秒）</tt> 。例如，如果设置为42，并且批处理大小为3，则线程将以x，x + 42ms，x + 84ms离开</li>
</ul>

<h4>可变负载率</h4>
    <p>尽管可以通过表达式定义属性值（例如，吞吐量），但建议在测试中使该值大致相同，因为重新计算新时间表以适应新值会花费一些时间。</p>

<h4>监控方式</h4>
<p>在生成下一个计划时， <tt class="code">精确吞吐量计时器</tt>会将消息记录到<tt class="code">jmeter.log</tt> ： <tt class="code">2018-01-04</tt> <tt class="code">17：34：03,635信息oajtConstantPoissonProcessGenerator：在0毫秒内生成21个计时（... 20个必需的，速率1.0，持续时间20，精确lim 20000，i21），发出了3次重启。前15个事件将在以下位置触发：1.1869653574244292（+1.1869653574244292），1.4691340403043207（+0.2821686828798915），3.618151706179226（+2.169017665874905），3.836357090410566（+0.19820538423134026），4.709033071408575（+0.8729729809980085），5.6.300769999985</tt>这表明计划生成花费了0ms，并且显示了以秒为单位的绝对时间戳。在上述情况下，速率设置为每秒1次，实际时间戳记变为1.2秒，1.5秒，3.6秒，3.8秒，4.7秒，依此类推。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="523" height="318" src="../images/screenshots/timers/precise_throughput_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称</td>
<td>没有</td>
</tr>
<tr>
<td>目标吞吐量（每个“通量周期”中的样本）</td>
<td>每个受影响的采样器中每个“吞吐量周期”要获取的最大样本数，包括组中的所有线程。</td>
<td>是</td>
</tr>
<tr>
<td>吞吐时间（秒）</td>
<td>吞吐期。例如，如果“吞吐量”设置为42，“吞吐量周期”设置为21秒，则每秒将获得2个样本。</td>
<td>是</td>
</tr>
<tr>
<td>测试时间（秒）</td>
<td>这用于确保在“测试持续时间”时间范围内获得吞吐量*持续时间样本。</td>
<td>是</td>
</tr>
<tr>
<td>批处理中的线程数（线程）</td>
<td>如果该值超过1，则多个线程同时离开计时器。平均吞吐量仍符合“吞吐量”值。</td>
<td>是</td>
</tr>
<tr>
<td>批处理中线程之间的延迟（毫秒）</td>
<td>例如，如果设置为42，且批处理大小为3，则线程将以x，x + 42ms，x + 84ms离开。</td>
<td>是</td>
</tr>
<tr>
<td>当序列长度超过（样本）时，使用近似吞吐量</td>
<td>当所需的样本数小于此限制时，计时器将生成准确的样本数。</td>
<td>是</td>
</tr>
<tr>
<td>允许的吞吐量盈余（百分比）</td>
<td>当需要超过“最大精确样本数”的样本时，计时器可能会产生比吞吐量指定的事件更多的事件。</td>
<td>是</td>
</tr>
<tr>
<td>随机种子（从0变为随机）</td>
<td>注意：不同的计时器最好具有不同的种子值。常数种子可确保计时器在每次测试开始时产生相同的延迟。值“ 0”表示计时器真正是随机的（从一次执行到另一次执行不可重复）。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Synchronizing_Timer">18.6.6同步定时器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>SyncTimer的目的是阻塞线程，直到阻塞了X个线程，然后立即将它们全部释放。因此，SyncTimer可以在测试计划的各个点上创建较大的即时负载。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="410" height="145" src="../images/screenshots/timers/sync_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>分组的同时用户数</td>
<td>一次释放的线程数。将其设置为<tt class="code">0</tt>等效于将其设置为“线程组中的线程数”。</td>
<td>是</td>
</tr>
<tr>
<td>超时时间（以毫秒为单位）</td>
<td>如果设置为<tt class="code">0</tt> ，Timer将等待线程数达到“ <tt class="code">要同时组的用户数</tt> ”中的值。如果大于<tt class="code">0</tt> ，则计时器将在最大“ <tt class="code">超时（以毫秒</tt>为<tt class="code">单位）</tt> ”中等待线程数。如果在超时间隔后仍未达到等待的用户数，计时器将停止等待。默认为<tt class="code">0</tt></td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果超时（以毫秒为单位）设置为<tt class="code">0，</tt>并且线程数从未达到“ <tt class="code">要分组的同时用户数</tt> ”，则测试将无限期暂停。只有强制停止才能停止它。在这种情况下，可以选择设置超时（以毫秒为单位）。
</td></tr>
</tbody></table>
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>仅在一个JVM中同步计时器块，因此，如果使用分布式测试，请确保不要将“ <tt class="code">同时要分组的用户数</tt> ”设置为仅考虑1个注入器就高于其包含线程组的用户数的值。
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="BeanShell_Timer">18.6.7 BeanShell计时器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>BeanShell Timer可用于生成延迟。
</p>
<p>
<b>有关使用BeanShell的完整详细信息，请访问<a href="http://www.beanshell.org/">BeanShell网站。</a></b>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>强烈建议迁移到<a href="../usermanual/component_reference.html#JSR223_Timer">JSR223 Timer</a> + Groovy，以提高性能，支持Java新功能并限制BeanShell库的维护。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>测试元素支持<tt class="code">ThreadListener</tt>和<tt class="code">TestListener</tt>方法。这些应该在初始化文件中定义。有关示例定义，请参见文件<tt class="code">BeanShellListeners.bshrc</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="846" height="636" src="../images/screenshots/timers/beanshell_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。名称存储在脚本变量<tt class="code">Label中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>重置bsh。每次通话前翻译</td>
<td>如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关更多信息，请参见<a href="best-practices#bsh_scripting">Best Practices-BeanShell脚本</a> 。
    </td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给BeanShell脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">bsh.args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul>
    </td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量<tt class="code">FileName中</tt> 。返回值用作等待的毫秒数。
     </td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>BeanShell脚本。返回值用作等待的毫秒数。
    </td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>在调用脚本之前，在BeanShell解释器中设置了一些变量：</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类java.util。属性）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></li>
<li><tt class="code">prev-</tt> （ <a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ）-提供对上一个<tt class="code">SampleResult的</tt>访问权限（如果有）</li>
</ul><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p><p>如果定义了<tt class="code">beanshell.timer.init</tt>属性，则用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSR223_Timer">18.6.9 JSR223计时器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JSR223计时器可用于使用JSR223脚本语言生成延迟，</p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>脚本语言</td>
<td>要使用的脚本语言。
    </td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul>
    </td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于“ <tt class="code">user.dir</tt> ”引用的目录。系统属性返回值转换为长整数，并用作等待的毫秒数。
     </td>
<td>没有</td>
</tr>
<tr>
<td>脚本编译缓存</td>
<td>如果所使用的语言支持<tt class="code"><a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html">Compilable</a></tt>接口，则JMeter将使用该测试计划中的唯一字符串来缓存脚本编译结果（Groovy是其中之一，而Java，beanshell和javascript不支持）<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您使用的是Groovy而不选中此选项，请参见JSR223 Sampler Java System属性中的注释</td></tr>
</tbody></table>
<p></p>

    </td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>剧本。返回值用作等待的毫秒数。
    </td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>在调用脚本之前，在脚本解释器中设置了一些变量：</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类java.util。属性）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></li>
<li><tt class="code">采样器</tt> -（ <a href="../api/org/apache/jmeter/samplers/Sampler.html">采样器</a> ）-当前采样器</li>
<li><tt class="code">标签</tt> -计时器的名称</li>
<li><tt class="code">FileName-</tt>文件名（如果有）</li>
<li><tt class="code">OUT</tt> -System.out</li>
</ul><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Poisson_Random_Timer">18.6.10泊松随机计时器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该计时器将每个线程请求暂停一段随机的时间，大多数时间间隔都在某个特定值附近发生。总延迟是泊松分布值和偏移值之和。</p>
<p>注意：如果要对泊松到达模型进行建模，请考虑改为使用“ <a href="../usermanual/component_reference.html#Precise_Throughput_Timer">精确吞吐量计时器”</a> 。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="341" height="182" src="../images/screenshots/timers/poisson_random_timer.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称</td>
<td>没有</td>
</tr>
<tr>
<td>拉姆达</td>
<td>Lambda值（以毫秒为单位）。</td>
<td>是</td>
</tr>
<tr>
<td>恒定延迟偏移</td>
<td>除随机延迟外，要暂停的毫秒数。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="preprocessors"><strong>18.7预处理器</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <br>预处理程序用于在其范围内修改采样器。
    <br>

    </div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTML_Link_Parser">18.7.1 HTML链接解析器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>该修饰符解析来自服务器的HTML响应，并提取链接和表单。将检查通过此修饰符的URL测试样本，以查看它是否“匹配”从上一个响应中提取的任何链接或表单。然后，它将使用来自匹配链接或表单的适当值替换URL测试样本中的值。Perl类型的正则表达式用于查找匹配项。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="373" height="79" src="../images/screenshots/html_link_parser.png"></div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>使用<tt class="code">协议</tt> ， <tt class="code">主机</tt> ， <tt class="code">路径</tt>和<tt class="code">参数名称</tt>进行匹配。目标采样器不能包含不在响应链接中的参数。
</td></tr>
</tbody></table>
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果使用分布式测试，请确保切换模式（请参阅<tt class="code">jmeter.properties</tt> ），以免剥离它，请参见<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=56376">错误56376。</a>

</td></tr>
</tbody></table>
<p></p>
<a name="spider_example"></a>
<p><b>蜘蛛示例</b></p>

<p>考虑一个简单的示例：假设您希望JMeter通过站点“蜘蛛化”，在从服务器返回的HTML中解析链接后点击链接（这实际上不是最有用的方法，但它是一个很好的例子） 。您将创建一个<a href="../usermanual/component_reference.html#Simple_Controller">简单控制器</a> ，然后向其中添加“ HTML链接解析器”。然后，创建一个HTTP请求，并将域设置为“ <tt class="code">。*</tt> ”，并将路径设置为同样。这将使您的测试样本与返回页面上找到的任何链接匹配。如果您想将搜寻范围限制为特定的域，则将域值更改为所需的值。然后，将仅链接到该域的链接。
</p>
<a name="poll_example"></a>
<p><b>投票示例</b></p>

<p>一个更有用的示例：给定一个Web轮询应用程序，您可能会有一个页面，其中包含多个轮询选项作为单选按钮，供用户选择。假设民意调查选项的值非常动态-可能是用户生成的。如果希望JMeter测试民意测验，则可以创建选择了硬编码值的测试样本，也可以让HTML Link Parser解析表单，然后在URL测试样本中插入随机调查选项。为此，请按照上面的示例进行操作，除了在配置Web测试控制器的URL选项时，请确保选择“ <tt class="code">POST</tt> ”作为方法。输入<tt class="code">domain</tt> ， <tt class="code">path</tt>和任何其他表单参数的硬编码值。然后，对于实际的单选按钮参数，输入名称（假设它称为“ <tt class="code">poll_choice</tt> ”），然后输入“ <tt class="code">。*</tt> ”作为该参数的值。当修饰符检查此URL测试示例时，它将发现它与“轮询”表单“匹配”（假定您已指定了URL测试示例的所有其他方面，则它不应与其他任何表单匹配），并且会将您的表单参数替换为表单中的匹配参数。由于正则表达式“ <tt class="code">。*</tt> ”将与任何内容匹配，因此修饰符可能会包含一个单选按钮列表供您选择。它将随机选择，并替换您的URL测试样本中的值。每次通过测试时，都会选择一个新的随机值。</p>

<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="1250" height="493" src="../images/screenshots/modification.png"><br>
<font size="-1">图18-在线投票示例</font></td></tr></tbody></table>


<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>要记住的重要一件事是，您必须在创建测试样本之前立即创建一个测试样本，该样本将返回一个HTML页面，其中包含与动态测试样本相关的链接和表单。</td></tr>
</tbody></table>
<p></p>

</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_URL_Re-writing_Modifier">18.7.2 HTTP URL重写修饰符</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>该修饰符的工作方式与HTML链接解析器相似，不同之处在于它具有特定的用途，该用途比HTML链接解析器更易于使用，并且效率更高。对于使用URL重写存储会话ID而不是Cookie的Web应用程序，此元素可以附加在ThreadGroup级别，就像<a href="../usermanual/component_reference.html#HTTP_Cookie_Manager">HTTP Cookie Manager一样</a> 。只需为其指定会话ID参数的名称，它将在页面上找到它，并将该参数添加到该ThreadGroup的每个请求中。</p>
<p>或者，可以将此修饰符附加到选择请求，它将仅修改它们。聪明的用户甚至会确定可以使用此修饰符来获取<a href="../usermanual/component_reference.html#HTML_Link_Parser">HTML链接解析器所没有的值</a> 。</p>
<p><b>控制面板</b></p>
<div align="center"><img width="579" height="239" src="../images/screenshots/url_rewriter.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>在测试树中为此元素赋予的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>会话参数名称</td>
<td>要从先前响应中获取的参数的名称。此修饰符将在页面上存在的任何位置查找该参数，并获取分配给它的值（无论是HREF还是表单）。</td>
<td>是</td>
</tr>
<tr>
<td>路径扩展</td>
<td>某些Web应用程序通过附加分号和会话ID参数来重写URL。如果是这样，请选中此框。</td>
<td>没有</td>
</tr>
<tr>
<td>不要在路径扩展中使用等号</td>
<td>某些Web应用程序重写URL时，在参数名称和值之间不使用“ <tt class="code">=</tt> ”符号（例如Intershop Enfinity）。</td>
<td>没有</td>
</tr>
<tr>
<td>不要在路径扩展中使用questionmark</td>
<td>防止查询字符串以路径扩展名结尾（例如Intershop Enfinity）。</td>
<td>没有</td>
</tr>
<tr>
<td>缓存会话ID？</td>
<td>如果会话ID不存在，是否应该保存会话ID的值以供以后使用？
        </td>
<td>是</td>
</tr>
<tr>
<td>网址编码</td>
<td>写入参数时的URL编码值</td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果使用分布式测试，请确保切换模式（请参阅<tt class="code">jmeter.properties</tt> ），以免剥离它，请参见<a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=56376">Bug 56376</a> 。
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="User_Parameters">18.7.5用户参数</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>允许用户为特定于各个线程的用户变量指定值。</p>
<p>用户变量也可以在测试计划中指定，但不特定于单个线程。该面板允许您为任何用户变量指定一系列值。对于每个线程，将依次为变量分配系列中的值之一。如果线程多于值，则将重新使用这些值。例如，这可以用于分配每个线程要使用的不同用户ID。用户变量可以在任何JMeter组件的任何字段中引用。</p>

<p>通过单击面板底部的“ <tt class="code">添加变量”</tt>按钮并在“ <tt class="code">名称：</tt> ”列中填写变量名称来指定变量。要向系列添加新值，请单击“ <tt class="code">添加用户</tt> ”按钮，然后在新添加的列中填写所需的值。</p>

<p>可以使用<a href="functions.html">函数语法</a> ： <tt class="code">$ {variable}</tt>在同一线程组中的任何测试组件中访问值。</p>
<p>另请参阅<a href="../usermanual/component_reference.html#CSV_Data_Set_Config">CSV数据集配置</a>元素，它更适合于大量参数</p>
<p><b>控制面板</b></p>
<div align="center"><img width="703" height="303" src="../images/screenshots/user_params.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>每次更新一次</td>
<td>一个标志，指示用户参数元素是否应仅在每次迭代中更新一次其变量。如果将函数嵌入到UP中，则可能需要更好地控制变量值的更新频率。保持选中此框，以确保每次通过UP的父控制器更新值。取消选中该框，UP将针对其<a href="test_plan.html#scoping_rules">范围</a>内的每个样本请求更新参数。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="BeanShell_PreProcessor">18.7.7 BeanShell预处理器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>BeanShell PreProcessor允许在取样之前应用任意代码。
</p>
<p>
<b>有关使用BeanShell的完整详细信息，请访问<a href="http://www.beanshell.org/">BeanShell网站。</a></b>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>强烈建议迁移到<a href="../usermanual/component_reference.html#JSR223_PreProcessor">JSR223 PreProcessor</a> + Groovy，以提高性能，支持新的Java功能并限制BeanShell库的维护。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>测试元素支持<tt class="code">ThreadListener</tt>和<tt class="code">TestListener</tt>方法。这些应该在初始化文件中定义。有关示例定义，请参见文件<tt class="code">BeanShellListeners.bshrc</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="845" height="633" src="../images/screenshots/beanshell_preprocessor.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。名称存储在脚本变量<tt class="code">Label中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>重置bsh。每次通话前翻译</td>
<td>如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关更多信息，请参见<a href="best-practices#bsh_scripting">Best Practices-BeanShell脚本</a> 。
    </td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给BeanShell脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">bsh.args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量<tt class="code">FileName中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>BeanShell脚本。返回值将被忽略。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>在调用脚本之前，在BeanShell解释器中设置了一些变量：</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类java.util。属性）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></li>
<li><tt class="code">prev-</tt> （ <a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ）-提供对上一个SampleResult的访问权限（如果有）</li>
<li><tt class="code">采样器</tt> -（ <a href="../api/org/apache/jmeter/samplers/Sampler.html">采样器</a> ）-提供对当前采样器的访问</li>
</ul><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p><p>如果定义了<tt class="code">beanshell.preprocessor.init</tt>属性，则此属性用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSR223_PreProcessor">18.7.8 JSR223预处理器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JSR223预处理程序允许在取样之前应用JSR223脚本代码。
</p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>语言</td>
<td>使用的JSR223语言</td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于“ <tt class="code">user.dir</tt> ”系统属性引用的目录</td>
<td>没有</td>
</tr>
<tr>
<td>脚本编译缓存</td>
<td>如果所使用的语言支持<tt class="code"><a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html">Compilable</a></tt>接口，则JMeter将使用该测试计划中的唯一字符串来缓存脚本编译结果（Groovy是其中之一，而Java，beanshell和javascript不支持）<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您使用的是Groovy而不选中此选项，请参见JSR223 Sampler Java System属性中的注释</td></tr>
</tbody></table>
<p></p>

    </td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>要运行的脚本。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>设置了以下JSR223变量供脚本使用：</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">标签</tt> -字符串标签</li>
<li><tt class="code">FileName-</tt>脚本文件名（如果有）</li>
<li><tt class="code">参数</tt> -参数（作为字符串）</li>
<li><tt class="code">args-</tt>作为字符串数组的参数（在空格上分割）</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());
vars.getObject(&quot;OBJ2&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类java.util。属性）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></li>
<li><tt class="code">采样器</tt> -（ <a href="../api/org/apache/jmeter/samplers/Sampler.html">采样器</a> ）-提供对当前采样器的访问</li>
<li><tt class="code">OUT</tt> -System.out-例如<tt class="code">OUT.println（“ message”）</tt></li>
</ul><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JDBC_PreProcessor">18.7.9 JDBC预处理程序</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JDBC PreProcessor使您可以在运行示例之前运行一些SQL语句。如果您的JDBC示例要求某些数据包含在数据库中，而您无法在安装线程组中进行计算，这将很有用。有关详细信息，请参见<a href="../usermanual/component_reference.html#JDBC_Request">JDBC Request</a> 。</p>
<p>请参阅以下测试计划：</p>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="../demos/JDBC-Pre-Post-Processor.jmx">使用JDBC前后处理器的测试计划</a></li>
</ul>

<p>在链接的测试计划中，“ <tt class="code">创建价格切断</tt> ” JDBC PreProcessor调用存储过程在数据库中创建价格切断，“ <tt class="code">计算价格切断</tt> ”将使用此过程。
</p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="818" height="394" src="../images/screenshots/jdbc-pre-processor.png"><br>
<font size="-1">创建降价预处理器</font></td></tr></tbody></table>


</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="RegEx_User_Parameters">18.7.10 RegEx用户参数</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>允许使用正则表达式为从另一个HTTP请求提取的HTTP参数指定动态值。RegEx用户参数特定于单个线程。</p>
        <p>该组件允许您指定正则表达式的引用名称，该正则表达式提取HTTP请求参数的名称和值。必须为参数名称和参数值指定正则表达式组编号。仅会使用名称与该RegEx用户参数匹配的Sampler中的参数进行替换</p>
    <p><b>控制面板</b></p>
<div align="center"><img width="727" height="138" src="../images/screenshots/regex_user_params.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>正则表达式参考名称</td>
<td>引用正则表达式的名称</td>
<td>是</td>
</tr>
<tr>
<td>参数名称regexp组号</td>
<td>用于提取参数名称的正则表达式的组号</td>
<td>是</td>
</tr>
<tr>
<td>参数值正则表达式组号</td>
<td>用于提取参数值的正则表达式的组号</td>
<td>是</td>
</tr>
</tbody></table>
<a name="regex_user_param_example"></a>
<p><b>正则表达式示例</b></p>

    <p>假设我们有一个返回带有3个输入参数的表单的请求，并且我们想要提取其中2个的值以将它们注入下一个请求中</p>
    <ol>
      <li>为第一个HTTP请求创建后处理器正则表达式<ul>
          <li><tt class="code">refName-</tt>设置正则表达式Expression的名称（ <tt class="code">listParams</tt> ）</li>
          <li><tt class="code">正则表达式</tt> -提取输入名称和输入值属性的表达式<br>例如： <tt class="code">输入名称=“（[[^”] +？）“ value =”（[[^“] +？）”</tt></li>
          <li><tt class="code">模板</tt> -将为空</li>
          <li><tt class="code">匹配nr</tt> -- <tt class="code">1</tt> （以便遍历所有可能的匹配）</li>
        </ul>
      </li>
      <li>为第二个HTTP请求创建预处理器RegEx用户参数<ul>
          <li><tt class="code">refName-</tt>设置正则表达式的相同引用名称，在我们的示例中为<tt class="code">listParams</tt></li>
          <li><tt class="code">参数名称组号</tt> - <tt class="code">参数名称</tt>正则表达式的组号在我们的示例中为<tt class="code">1</tt></li>
          <li><tt class="code">参数值组号</tt> - <tt class="code">参数值</tt>正则表达式的组号，在我们的示例中为<tt class="code">2</tt></li>
        </ul>
      </li>
    </ol>
    <p>另请参见<a href="../usermanual/component_reference.html#Regular_Expression_Extractor">正则表达式提取器</a>元素，该元素用于提取参数名称和值</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="../demos/RegEx-User-Parameters.jmx">显示如何使用RegEx用户参数的测试计划</a></li>
</ul>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Sample_Timeout">18.7.11采样超时</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>如果完成时间太长，此预处理器会安排计时器任务来中断样品。如果超时为零或负数，则忽略该超时。为此，采样器必须实现Interruptible。已知以下采样器可以这样做：<br>AJP，BeanShell，FTP，HTTP，Soap，AccessLog，MailReader，JMS订阅服务器，TCPSampler，TestAction，JavaSampler</p>
<p>该测试元素适用于连接超时或响应超时等单独超时不足的情况，或采样器不支持超时的情况。超时应设置得足够长，以使其在正常测试中不会触发，但应足够短以至于中断被卡住的样本。
</p>
<p>[默认情况下，JMeter使用Callable来中断采样器。它在与计时器相同的线程中执行，因此，如果中断需要很长时间，则可能会延迟后续超时的处理。预计这不是问题，但是如果需要，可以将属性<tt class="code">InterruptTimer.useRunnable</tt>设置为<tt class="code">true，</tt>以使用单独的Runnable线程而不是Callable。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="316" height="138" src="../images/screenshots/sample_timeout.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此计时器的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>样品超时</td>
<td>如果样品需要更长的时间才能完成，它将被打断。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="postprocessors"><strong>18.8后处理器</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
    <p>顾名思义，后处理程序在采样器之后应用。请注意，它们将应用于同一范围内的<b>所有</b>采样器，因此，为确保仅将后处理器应用于特定采样器，请将其添加为采样器的子代。
    </p>
    <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：除非另有说明，否则后处理器不会应用于子样本（子样本），而仅应用于父样本。对于JSR223和BeanShell后处理器，脚本可以使用<tt class="code">prev.getSubResults（）</tt>方法检索子样本，该方法返回SampleResults的数组。如果没有数组，则该数组将为空。
    </td></tr>
</tbody></table>
<p></p>

    <p>后处理器在断言之前运行，因此它们无权访问任何断言结果，样本状态也不会反映任何断言的结果。如果您需要访问断言结果，请尝试使用侦听器。还请注意，在运行所有断言之后，将变量<tt class="code">JMeterThread.last_sample_ok</tt>设置为“ <tt class="code">true</tt> ”或“ <tt class="code">false</tt> ”。
    </p>
    </div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Regular_Expression_Extractor">18.8.1正则表达式提取器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>允许用户使用Perl类型的正则表达式从服务器响应中提取值。作为后处理器，此元素将在其范围内的每个Sample请求之后执行，应用正则表达式，提取请求的值，生成模板字符串，并将结果存储到给定的变量名称中。</p><p><b>控制面板</b></p>
<div align="center"><img width="1127" height="277" src="../images/screenshots/regex_extractor.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -均适用。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -提取将应用于命名变量的内容</li>
        </ul>匹配依次应用于所有合格样品。例如，如果有一个主样本和3个子样本，每个样本包含一个正则表达式匹配项（即总共4个匹配项）。对于匹配号码= <tt class="code">3，</tt>只有子样品，提取器将匹配<sup>第三</sup>子样本。对于匹配数= <tt class="code">3</tt> ，主样本和子样本，提取器将匹配<sup>第二</sup>个子样本（ <sup>第一个</sup>匹配是主样本）。如果比赛号码= <tt class="code">0</tt>或负数，则将处理所有合格样本。对于匹配号> <tt class="code">0</tt> ，一旦找到足够的匹配项，匹配就会停止。
        </td>
<td>是</td>
</tr>
<tr>
<td>检查领域</td>
<td>可以检查以下字段：<ul>
        <li><tt class="code">机构</tt> -响应的主体，例如网页的内容（不包括标题）</li>
        <li>正文<tt class="code">（未转义）</tt> -响应的正文，已替换所有HTML转义代码。请注意，HTML转义的处理不考虑上下文，因此可能会进行一些不正确的替换。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，此选项会严重影响性能，因此仅在绝对必要时使用它，并注意其影响</td></tr>
</tbody></table>
<p></p>

        </li>
        <li><tt class="code">主体作为文档</tt> -通过Apache Tika从各种类型的文档中提取文本（请参见<a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树</a>文档视图部分）。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，“将文档作为文档”选项可能会影响性能，因此请确保可以通过测试</td></tr>
</tbody></table>
<p></p>

        </li>
        <li><tt class="code">请求标头</tt> -对于非HTTP示例可能不存在</li>
        <li><tt class="code">响应标头</tt> -对于非HTTP样本可能不存在</li>
        <li><tt class="code">网址</tt></li>
        <li><tt class="code">响应码</tt> -例如<tt class="code">200</tt></li>
        <li><tt class="code">响应消息</tt> -例如， <tt class="code">确定</tt></li>
        </ul>标头可用于HTTP样本。对于其他样品类型可能不存在。
        </td>
<td>是</td>
</tr>
<tr>
<td>创建变量的名称</td>
<td>将结果存储在其中的JMeter变量的名称。还要注意，每个组都存储为<tt class="code">[refname] _g＃</tt> ，其中<tt class="code">[refname]</tt>是您输入为参考名称的字符串，而<tt class="code">＃</tt>是组号，其中group <tt class="code">0</tt>是整个匹配项，group <tt class="code">1</tt>是来自匹配项的匹配项第一组括号等</td>
<td>是</td>
</tr>
<tr>
<td>正则表达式</td>
<td>用于解析响应数据的正则表达式。除非使用组<tt class="code">$ 0 $</tt> ，否则它至少必须包含一组括号“ <tt class="code">（）</tt> ”以捕获字符串的一部分。不要将表达式括在<tt class="code">/ /</tt> -中，除非您当然也想匹配这些字符。
        </td>
<td>是</td>
</tr>
<tr>
<td>模板</td>
<td>用于从找到的匹配项创建字符串的模板。这是一个带有特殊元素的任意字符串，用于引用正则表达式中的组。引用组的语法是：' <tt class="code">$ 1 $</tt> '引用组<tt class="code">1</tt> ，' <tt class="code">$ 2 $</tt> '引用组<tt class="code">2</tt> ，等等。 <tt class="code">$ 0 $</tt>引用整个表达式匹配的内容。</td>
<td>是</td>
</tr>
<tr>
<td>比赛编号（0为随机）</td>
<td>指示要使用的匹配项。正则表达式可以匹配多次。
            <ul>
                <li>使用零值表示JMeter应该随机选择一个匹配项。</li>
                <li>正数N表示选择第n <sup>个</sup>匹配项。</li>
                <li>负数与<a href="../usermanual/component_reference.html#ForEach_Controller">ForEach控制器</a>结合使用-参见下文。</li>
            </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>默认值</td>
<td>如果正则表达式不匹配，则引用变量将设置为默认值。这对于调试测试特别有用。如果未提供默认值，则很难判断正则表达式是否不匹配，或者未处理RE元素，或者使用了错误的变量。
        <p>但是，如果您有多个设置相同变量的测试元素，则如果表达式不匹配，则可能希望使变量保持不变。在这种情况下，调试完成后，请删除默认值。
        </p> 
        </td>
<td>不，但是推荐</td>
</tr>
<tr>
<td>使用空的默认值</td>
<td>如果选中此复选框，并且“ <tt class="code">默认值”</tt>为空，则JMeter会将变量设置为空字符串，而不是不进行设置。因此，例如当您在测试计划中使用<tt class="code">$ {var}</tt> （如果<tt class="code">引用名称</tt>为var）时，如果找不到提取的值，则<tt class="code">$ {var}</tt>将等于空字符串，而不是包含<tt class="code">$ {var}</tt> ，这可能如果提取的值是可选的，则很有用。
        </td>
<td>没有</td>
</tr>
</tbody></table>
<p>如果将匹配号设置为非负数，并且发生匹配，则变量的设置如下：</p><ul>
        <li><tt class="code">refName-</tt>模板的值</li>
        <li><tt class="code">refName_g <em>n，</em></tt>其中<tt class="code">n</tt> = <tt class="code"><tt class="code"><tt class="code">0，1，2</tt></tt></tt> -基团的比赛</li>
        <li><tt class="code">refName_g-</tt>正则表达式中的组数（不包括<tt class="code">0</tt> ）</li>
    </ul><p>如果没有匹配项，则将<tt class="code">refName</tt>变量设置为默认值（除非不存在）。此外，还将删除以下变量：</p><ul>
        <li><tt class="code">refName_g0</tt></li>
        <li><tt class="code">refName_g1</tt></li>
        <li><tt class="code">refName_g</tt></li>
    </ul><p>如果匹配编号设置为负数，则将处理采样器数据中所有可能的匹配。变量设置如下：</p><ul>
        <li><tt class="code">refName_matchNr-</tt>找到的匹配项数；可能是<tt class="code">0</tt></li>
        <li><tt class="code">refName_ <em>n，</em></tt>其中<tt class="code">n</tt> = <tt class="code"><tt class="code"><tt class="code">1，2，3</tt></tt></tt>等-的字符串作为由模板生成</li>
        <li><tt class="code"><em>refName_Ñ_g</em> <em>m，</em></tt>其中<tt class="code">m</tt> = <tt class="code"><tt class="code"><tt class="code">0，1，2</tt></tt></tt> -基团为匹配<tt class="code">Ñ</tt></li>
        <li><tt class="code">refName-</tt>始终设置为默认值</li>
        <li><tt class="code">refName_g <em>n-</em></tt>未设置</li>
    </ul><p>请注意，在这种情况下， <tt class="code">refName</tt>变量始终设置为默认值，并且未设置关联的组变量。
</p><p>另请参见<a href="../usermanual/component_reference.html#Response_Assertion">响应声明，</a>以获取有关如何指定修饰符的一些示例，以及<a href="regular_expressions.html">有关JMeter正则表达式的更多信息。</a></p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<a name="CSS/JQuery_Extractor"></a>
<h3>
<a name="CSS_Selector_Extractor">18.8.2 CSS选择器提取器（以前是：CSS / JQuery提取器）</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>允许用户使用CSS选择器语法从服务器HTML响应中提取值。作为后处理器，此元素将在其范围内的每个Sample请求之后执行，应用CSS / JQuery表达式，提取所请求的节点，将节点提取为文本或属性值，并将结果存储到给定的变量名中。</p><p><b>控制面板</b></p>
<div align="center"><img width="826" height="276" src="../images/screenshots/css_extractor_attr.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -均适用。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -提取将应用于命名变量的内容</li>
        </ul>匹配依次应用于所有合格样品。例如，如果有一个主样本和3个子样本，每个样本包含一个正则表达式匹配项（即总共4个匹配项）。对于匹配号码= <tt class="code">3，</tt>只有子样品，提取器将匹配<sup>第三</sup>子样本。对于匹配数= <tt class="code">3</tt> ，主样本和子样本，提取器将匹配<sup>第二</sup>个子样本（ <sup>第一个</sup>匹配是主样本）。如果比赛号码= <tt class="code">0</tt>或负数，则将处理所有合格样本。对于匹配号> <tt class="code">0</tt> ，一旦找到足够的匹配项，匹配就会停止。
        </td>
<td>是</td>
</tr>
<tr>
<td>CSS选择器实现</td>
<td>2支持基于CSS / JQuery的语法实现：<ul>
                <li><a href="http://jsoup.org/">汤</a></li>
                <li><a href="http://jodd.org/doc/lagarto/index.html">Jodd-Lagarto（CSSelly）</a></li>
        </ul>如果选择器设置为空，则将使用默认实现（JSoup）。
        </td>
<td>假</td>
</tr>
<tr>
<td>创建变量的名称</td>
<td>将结果存储在其中的JMeter变量的名称。</td>
<td>是</td>
</tr>
<tr>
<td>CSS / JQuery表达式</td>
<td>CSS / JQuery选择器，用于从响应数据中选择节点。支持选择器，选择器组合和伪选择器，示例：<ul>
            <li><tt class="code">E [foo]</tt> -具有“ <tt class="code">foo</tt> ”属性的<tt class="code">E</tt>元素</li>
            <li><tt class="code">祖先的孩子</tt> -子元素，从祖先下降，如<tt class="code">。体p</tt>认定<tt class="code">p</tt>元素下一个块任何地方类“ <tt class="code">身体</tt> ”</li>
            <li><tt class="code">：lt（n）</tt> -查找兄弟索引（即，它在DOM树中相对于其父级的位置）小于<tt class="code">n的</tt>元素；例如<tt class="code">td：lt（3）</tt></li>
            <li><tt class="code">：contains（text）</tt> -查找包含给定<tt class="code">text的</tt>元素。搜索不区分大小写；例如<tt class="code">p：contains（jsoup）</tt></li>
            <li>…</li>
        </ul>有关语法的更多详细信息，请参见：<ul>
                <li><a href="http://jsoup.org/cookbook/extracting-data/selector-syntax">汤</a></li>
                <li><a href="http://jodd.org/doc/csselly/">Jodd-Lagarto（CSSelly）</a></li>
            </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>属性</td>
<td>从匹配选择器的节点中提取的属性名称（按照HTML语法）。如果为空，则将返回此元素及其所有子元素的组合文本。<br>如果设置了属性，则这是JSoup的等效<a href="http://jsoup.org/apidocs/org/jsoup/nodes/Node.html#attr%28java.lang.String%29">Element＃attr（name）</a>函数。<br>

            <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="826" height="275" src="../images/screenshots/css_extractor_attr.png"><br>
<font size="-1">设置了属性值的CSS提取器</font></td></tr></tbody></table>
<br>如果为空，则等于JSoup的<a href="http://jsoup.org/apidocs/org/jsoup/nodes/Element.html#text%28%29">Element＃text（）</a>函数（如果未为属性设置值）。
            <table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="825" height="275" src="../images/screenshots/css_extractor_noattr.png"><br>
<font size="-1">未设置属性的CSS提取器</font></td></tr></tbody></table>

        </td>
<td>假</td>
</tr>
<tr>
<td>比赛编号（0为随机）</td>
<td>指示要使用的匹配项。CSS / JQuery选择器可以匹配多次。
            <ul>
                <li>使用零值表示JMeter应该随机选择一个匹配项。</li>
                <li>正数<tt class="code">N</tt>表示选择第n <sup>个</sup>匹配项。</li>
                <li>负数与<a href="../usermanual/component_reference.html#ForEach_Controller">ForEach控制器</a>结合使用-参见下文。</li>
            </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>默认值</td>
<td>如果表达式不匹配，则参考变量将设置为默认值。这对于调试测试特别有用。如果没有提供默认值，则很难判断表达式是否不匹配，或者CSS / JQuery元素未处理，或者使用了错误的变量。
        <p>但是，如果您有多个设置相同变量的测试元素，则如果表达式不匹配，则可能希望使变量保持不变。在这种情况下，调试完成后，请删除默认值。
        </p> 
        </td>
<td>不，但是推荐</td>
</tr>
<tr>
<td>使用空的默认值</td>
<td>如果选中此复选框，并且“ <tt class="code">默认值”</tt>为空，则JMeter会将变量设置为空字符串，而不是不进行设置。因此，例如当您在测试计划中使用<tt class="code">$ {var}</tt> （如果<tt class="code">引用名称</tt>为var）时，如果找不到提取的值，则<tt class="code">$ {var}</tt>将等于空字符串，而不是包含<tt class="code">$ {var}</tt> ，这可能如果提取的值是可选的，则很有用。
        </td>
<td>没有</td>
</tr>
</tbody></table>
<p>如果将匹配号设置为非负数，并且发生匹配，则变量的设置如下：</p><ul>
        <li><tt class="code">refName-</tt>模板的值</li>
    </ul><p>如果没有匹配项，则将<tt class="code">refName</tt>变量设置为默认值（除非不存在）。
</p><p>如果匹配编号设置为负数，则将处理采样器数据中所有可能的匹配。变量设置如下：</p><ul>
        <li><tt class="code">refName_matchNr-</tt>找到的匹配项数；可能是<tt class="code">0</tt></li>
        <li><tt class="code">refName_n，</tt>其中<tt class="code">n</tt> = <tt class="code"><tt class="code"><tt class="code">1，2，3，</tt></tt></tt>等等-一个由模板生成的字符串</li>
        <li><tt class="code">refName-</tt>始终设置为默认值</li>
    </ul><p>请注意，在这种情况下， <tt class="code">refName</tt>变量始终设置为默认值。
</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="XPath2_Extractor">18.8.3 XPath2提取器</a>
</h3>
</font>
</td></tr>
<tr><td>该测试元素允许用户使用XPath2查询语言从结构化响应-XML或（X）HTML中提取值。
   <p><b>控制面板</b></p>
<div align="center"><img width="926" height="333" src="../images/screenshots/xpath2_extractor.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -均适用。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -提取将应用于命名变量的内容</li>
        </ul>XPath匹配将依次应用于所有合格样本，并且将返回所有匹配结果。
       </td>
<td>是</td>
</tr>
<tr>
<td>返回整个XPath片段而不是文本内容？</td>
<td>如果选择，将返回片段而不是文本内容。<br>例如<tt class="code">// title</tt>将返回“<tt class="code"><title>Apache JMeter</title></tt> ”而不是“ <tt class="code">Apache JMeter</tt> ”。<br>在这种情况下， <tt class="code">// title / text（）</tt>将返回“ <tt class="code">Apache JMeter</tt> ”。
    </td>
<td>是</td>
</tr>
<tr>
<td>创建变量的名称</td>
<td>将结果存储在其中的JMeter变量的名称。</td>
<td>是</td>
</tr>
<tr>
<td>XPath查询</td>
<td>XPath 2.0语言中的元素查询。可以返回多个匹配项。</td>
<td>是</td>
</tr>
<tr>
<td>比赛编号（0为随机）</td>
<td>如果XPath Path查询导致许多结果，则可以选择提取哪个作为变量：<ul>
        <li><tt class="code">0</tt> ：表示随机（默认值）</li>
        <li><tt class="code">-1</tt>表示提取所有结果，它们将被命名为<tt class="code"><em><variable name=""></variable></em> _N</tt> （其中<tt class="code">N</tt>从1到结果数）</li>
        <li><tt class="code">X</tt> ：表示提取第X <sup>个</sup>结果。如果此X <sup>th</sup>大于匹配数，则不返回任何内容。将使用默认值</li>
    </ul>
    </td>
<td>没有</td>
</tr>
<tr>
<td>默认值</td>
<td>如果找不到匹配项，则返回默认值。如果节点没有值且未选择fragment选项，则也将返回该值。</td>
<td>是</td>
</tr>
<tr>
<td>命名空间别名列表</td>
<td>您要用来解析文档的名称空间别名列表，每个声明一行。您必须按以下方式指定它们： <tt class="code">prefix = namespace</tt> 。与旧版本的XPathExtractor相比，此实现使使用名称空间更加容易。</td>
<td>没有</td>
</tr>
</tbody></table>
<p>为了允许在<a href="../usermanual/component_reference.html#ForEach_Controller">ForEach Controller中使用</a> ，它的工作原理与上述XPath Extractor完全相同</p><p>XPath2 Extractor提供了一些有趣的工具，例如改进的语法和比第一个版本更多的功能。</p><p>以下是一些示例：</p><dl> 
   <dt><tt class="code">abs（/ book / page [2]）</tt></dt>
     <dd>从书中提取页面的<sup>第二</sup>绝对值</dd>
   <dt><tt class="code">平均（/ librarie / book / page）</tt></dt>
     <dd>从库中的所有书中提取平均页数</dd>
     <dt><tt class="code">比较（/ book [1] / page [2]，/ book [2] / page [2]）</tt></dt>
    <dd>返回整数值等于0，如果第一本书的<sup>第二</sup>页等于<sup>第二</sup>页的<sup>第二</sup>本书，否则返回-1。</dd>
 </dl><p>要查看有关这些功能的更多信息，请检查<a href="http://saxon.sourceforge.net/saxon7.9.1/functions.html">xPath2函数</a></p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="XPath_Extractor">18.8.3 XPath提取器</a>
</h3>
</font>
</td></tr>
<tr><td>该测试元素允许用户使用XPath查询语言从结构化响应-XML或（X）HTML中提取值。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>从JMeter 5.0开始，您应该使用<a href="../usermanual/component_reference.html#XPath2_Extractor">XPath2 Extractor，</a>因为它提供了更好，更轻松的名称空间管理，更好的性能以及对XPath 2.0的支持。</td></tr>
</tbody></table>
<p></p>

   <p><b>控制面板</b></p>
<div align="center"><img width="729" height="317" src="../images/screenshots/xpath_extractor.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -均适用。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -提取将应用于命名变量的内容</li>
        </ul>XPath匹配将依次应用于所有合格样本，并且将返回所有匹配结果。
       </td>
<td>是</td>
</tr>
<tr>
<td>使用Tidy（容忍的解析器）</td>
<td>如果选中，请使用Tidy将HTML响应解析为XHTML。<ul>
           <li>HTML响应应选中“ <tt class="code">Use Tidy</tt> ”。使用Tidy将此类响应转换为有效的XHTML（与XML兼容的HTML）</li>
           <li>对于XHTML或XML响应，都应取消选中“ <tt class="code">Use Tidy</tt> ”（例如RSS）</li>
       </ul>
       <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>对于HTML，CSS选择器提取器是正确且性能良好的解决方案。不要将XPath用于HTML提取。</td></tr>
</tbody></table>
<p></p>

       </td>
<td>是</td>
</tr>
<tr>
<td>安静</td>
<td>设置整洁安静标志</td>
<td>如果选择整洁</td>
</tr>
<tr>
<td>报告错误</td>
<td>如果出现Tidy错误，则相应地设置断言</td>
<td>如果选择整洁</td>
</tr>
<tr>
<td>显示警告</td>
<td>设置整洁的showWarnings选项</td>
<td>如果选择整洁</td>
</tr>
<tr>
<td>使用命名空间</td>
<td>如果选中，则XML解析器将使用名称空间解析。（请参阅下面的NAMESPACES注释）请注意，当前仅可识别在根元素上声明的名称空间。有关其他工作空间名称的用户定义，请参见下文。
</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>验证XML</td>
<td>根据文档的架构检查文档。</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>忽略空格</td>
<td>忽略元素空格。</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>提取外部DTD</td>
<td>如果选择，则提取外部DTD。</td>
<td>如果未选择“整洁”</td>
</tr>
<tr>
<td>返回整个XPath片段而不是文本内容？</td>
<td>如果选择，将返回片段而不是文本内容。<br>例如<tt class="code">// title</tt>将返回“<tt class="code"><title>Apache JMeter</title></tt> ”而不是“ <tt class="code">Apache JMeter</tt> ”。<br>在这种情况下， <tt class="code">// title / text（）</tt>将返回“ <tt class="code">Apache JMeter</tt> ”。
    </td>
<td>是</td>
</tr>
<tr>
<td>创建变量的名称</td>
<td>将结果存储在其中的JMeter变量的名称。</td>
<td>是</td>
</tr>
<tr>
<td>XPath查询</td>
<td>XPath语言中的元素查询。可以返回多个匹配项。</td>
<td>是</td>
</tr>
<tr>
<td>比赛编号（0为随机）</td>
<td>如果XPath Path查询导致许多结果，则可以选择提取哪个作为变量：<ul>
        <li><tt class="code">0</tt> ：表示随机</li>
        <li><tt class="code">-1</tt>表示提取所有结果（默认值），它们将被命名为<tt class="code"><em><variable name=""></variable></em> _N</tt> （其中<tt class="code">N</tt>从1到结果数）</li>
        <li><tt class="code">X</tt> ：表示提取第X <sup>个</sup>结果。如果此X <sup>th</sup>大于匹配数，则不返回任何内容。将使用默认值</li>
    </ul>
    </td>
<td>没有</td>
</tr>
<tr>
<td>默认值</td>
<td>如果找不到匹配项，则返回默认值。如果节点没有值且未选择fragment选项，则也将返回该值。</td>
<td>没有</td>
</tr>
</tbody></table>
<p>为了允许在<a href="../usermanual/component_reference.html#ForEach_Controller">ForEach Controller中</a>使用，在返回时设置了以下变量：</p><ul>
   <li><tt class="code">refName-</tt>设置为第一个（或唯一）匹配项；如果不匹配，则设置为默认值</li>
   <li><tt class="code">refName_matchNr-</tt>设置为匹配数（可以为<tt class="code">0</tt> ）</li>
   <li><tt class="code">refName_n</tt> - <tt class="code">N</tt> = <tt class="code"><tt class="code"><tt class="code">1，2，3</tt></tt></tt>等设置为第<sup>1，</sup>第<sup>2</sup>第<sup>3</sup>匹配等</li>
   </ul><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注：下<tt class="code">refName_n</tt>变量被设置为<tt class="code">空</tt> -例如，如果有2场比赛，然后<tt class="code">refName_3</tt>设置为<tt class="code">空</tt> ，如果没有比赛，然后<tt class="code">refName_1</tt>设置为<tt class="code">null。</tt>
   </td></tr>
</tbody></table>
<p></p>
<p>XPath是主要用于XSLT转换的查询语言。但是，它也可用作结构化数据的通用查询语言。有关更多信息，请参见<a href="http://www.topxml.com/xsl/xpathref.asp">XPath参考</a>或<a href="http://www.w3.org/TR/xpath">XPath规范</a> 。以下是一些示例：</p><dl> 
   <dt><tt class="code">/ html / head / title</tt></dt>
     <dd>从HTML响应中提取标题元素</dd>
   <dt><tt class="code">/ book / page [2]</tt></dt>
     <dd>从书中提取<sup>第二</sup>页</dd>
   <dt><tt class="code">/书/页</tt></dt>
     <dd>从一本书中提取所有页面</dd>
     <dt><tt class="code">// form [@ name ='countryForm'] // select [@ name ='country'] / option [text（）='Czech Republic']）/ @ value</tt></dt>
    <dd>提取选项元素的值属性，该属性与名称属性“ <tt class="code">country</tt> ”的选择元素内的文本“ <tt class="code">捷克共和国</tt> ”匹配，名称属性为“ <tt class="code">countryForm</tt> ”的表单内匹配</dd>
 </dl><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>选中“ <tt class="code">Use Tidy</tt> ”时-生成的XML文档可能与原始HTML响应略有不同：<ul>
         <li>所有元素和属性名称均转换为小写</li>
         <li>整理会尝试纠正不正确的嵌套元素。例如-原始（不正确） <tt class="code">ul / font / li</tt>变成正确的<tt class="code">ul / li / font</tt></li>
     </ul>有关更多信息，请参见<a href="http://jtidy.sf.net">Tidy主页</a> 。
 </td></tr>
</tbody></table>
<p></p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<b>名称空间</b><br>作为Xalan XPath解析器的名称空间限制的工作回合（JMeter所基于的实现），您需要：<ul>
<li>提供一个属性文件（例如，您的文件名为namespaces.properties），其中包含名称空间前缀的映射：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
prefix1=http\://foo.apache.org
prefix2=http\://toto.apache.org
…
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>

<li>使用属性在<tt class="code">user.properties</tt>文件中引用此文件：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>xpath.namespace.config=namespaces.properties</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
</ul>
</td></tr>
</tbody></table>
<p></p>
<p></p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>//mynamespace:tagname</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>//*[local-name()='tagname' and namespace-uri()='uri-for-namespace']</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<tt class="code">uri-for-namespace</tt> <tt class="code">mynamespace</tt></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSON_JMESPath_Extractor">18.8.4 JSON JMESPath提取器</a>
</h3>
</font>
</td></tr>
<tr><td>该测试元素允许用户使用JMESPath查询语言从结构化响应-XML或（X）HTML中提取值。
   <p><b>控制面板</b></p>
<div align="center"><img width="729" height="317" src="../images/screenshots/jmes_extractor.png"></div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>在XPATH提取器中，我们支持同时提取多个xpath，但是在JMES提取器中，一次只能输入一个JMES表达式。
   </td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -均适用。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -提取将应用于命名变量的内容</li>
        </ul>
       </td>
<td>是</td>
</tr>
<tr>
<td>创建变量的名称</td>
<td>将结果存储在其中的JMeter变量的名称。</td>
<td>是</td>
</tr>
<tr>
<td>JMESPath表达式</td>
<td>JMESPath查询语言中的元素查询。可以返回匹配结果。</td>
<td>是</td>
</tr>
<tr>
<td>比赛编号（0为随机）</td>
<td>如果JMESPath查询导致许多结果，则可以选择提取哪个作为变量：<ul>
        <li><tt class="code">0</tt> ：表示随机</li>
        <li><tt class="code">-1</tt>表示提取所有结果（默认值），它们将被命名为<tt class="code"><em><variable name=""></variable></em> _N</tt> （其中<tt class="code">N</tt>从1到结果数）</li>
        <li><tt class="code">X</tt> ：表示提取第X <sup>个</sup>结果。如果此X <sup>th</sup>大于匹配数，则不返回任何内容。将使用默认值</li>
    </ul>
    </td>
<td>没有</td>
</tr>
<tr>
<td>默认值</td>
<td>如果找不到匹配项，则返回默认值。如果节点没有值且未选择fragment选项，则也将返回该值。</td>
<td>没有</td>
</tr>
</tbody></table>
<p>JMESPath是JSON的查询语言。在具有完整规范的ABNF语法中对其进行了描述。这样可以确保精确定义语言语法。有关更多信息，请参见《 <a href="http://jmespath.org/">JMESPath参考</a> 》。这也是一些示例<a href="http://jmespath.org/tutorial.html">JMESPath Example</a> 。
   </p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Result_Status_Action_Handler">18.8.5结果状态操作处理程序</a>
</h3>
</font>
</td></tr>
<tr><td>如果相关的采样器失败，则该测试元素允许用户停止线程或整个测试。
   <p><b>控制面板</b></p>
<div align="center"><img width="613" height="133" src="../images/screenshots/resultstatusactionhandler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>采样器错误后要采取的措施</td>
<td>确定如果由于样本本身失败或断言失败而导致发生采样器错误，该如何处理。可能的选择是：<ul>
   <li><tt class="code">继续</tt> -忽略错误并继续测试</li>
   <li><tt class="code">启动下一个线程循环</tt> -对于当前迭代，不会在错误的采样器之后执行采样器，并在下一次迭代时重新启动循环</li>
   <li><tt class="code">停止线程</tt> -当前线程退出</li>
   <li><tt class="code">停止测试</tt> -整个测试在任何当前样本结束时停止。</li>
   <li><tt class="code">立即停止测试</tt> -整个测试突然停止。如有可能，任何当前采样器都会中断。</li>
   </ul>
   </td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="BeanShell_PostProcessor">18.8.6 BeanShell后处理器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>BeanShell PreProcessor允许在取样后应用任意代码。
</p>
<p>BeanShell后处理器不再忽略具有零长度结果数据的样本</p>
<p>
<b>有关使用BeanShell的完整详细信息，请访问<a href="http://www.beanshell.org/">BeanShell网站。</a></b>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>强烈建议迁移到<a href="../usermanual/component_reference.html#JSR223_PostProcessor">JSR223 PostProcessor</a> + Groovy，以提高性能，支持新的Java功能并限制BeanShell库的维护。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>测试元素支持<tt class="code">ThreadListener</tt>和<tt class="code">TestListener</tt>方法。这些应该在初始化文件中定义。有关示例定义，请参见文件<tt class="code">BeanShellListeners.bshrc</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="847" height="633" src="../images/screenshots/beanshell_postprocessor.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。名称存储在脚本变量<tt class="code">Label中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>重置bsh。每次通话前翻译</td>
<td>如果选择此选项，则将为每个样本重新创建解释器。对于某些长时间运行的脚本，这可能是必需的。有关更多信息，请参见<a href="best-practices#bsh_scripting">Best Practices-BeanShell脚本</a> 。
    </td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给BeanShell脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">bsh.args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的BeanShell脚本的文件。文件名存储在脚本变量<tt class="code">FileName中</tt></td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>BeanShell脚本。返回值将被忽略。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>设置了以下BeanShell变量供脚本使用：</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类java.util。属性）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></li>
<li><tt class="code">prev-</tt> （ <a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ）-提供对上一个SampleResult的访问</li>
<li><tt class="code">数据</tt> -（字节[]）-提供对当前样本数据的访问</li>
</ul><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p><p>如果定义了<tt class="code">beanshell.postprocessor.init</tt>属性，则用于加载初始化文件，该文件可用于定义在BeanShell脚本中使用的方法等。</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSR223_PostProcessor">18.8.7 JSR223后处理器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JSR223 PostProcessor允许在取样后应用JSR223脚本代码。
</p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>语言</td>
<td>使用的JSR223语言</td>
<td>是</td>
</tr>
<tr>
<td>参量</td>
<td>传递给脚本的参数。参数存储在以下变量中：<ul>
        <li><tt class="code">参数</tt> -包含参数作为单个变量的字符串</li>
        <li><tt class="code">args-</tt>包含参数的字符串数组，在空白处分割</li>
    </ul></td>
<td>没有</td>
</tr>
<tr>
<td>脚本文件</td>
<td>包含要运行的脚本的文件，如果使用相对文件路径，则它将相对于“ <tt class="code">user.dir</tt> ”系统属性引用的目录</td>
<td>没有</td>
</tr>
<tr>
<td>脚本编译缓存</td>
<td>如果所使用的语言支持<tt class="code"><a href="https://docs.oracle.com/javase/8/docs/api/javax/script/Compilable.html">Compilable</a></tt>接口，则JMeter将使用该测试计划中的唯一字符串来缓存脚本编译结果（Groovy是其中之一，而Java，beanshell和javascript不支持）<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您使用的是Groovy而不选中此选项，请参见JSR223 Sampler Java System属性中的注释</td></tr>
</tbody></table>
<p></p>

    </td>
<td>没有</td>
</tr>
<tr>
<td>脚本</td>
<td>要运行的脚本。</td>
<td>是（除非提供了脚本文件）</td>
</tr>
</tbody></table>
<p>在调用脚本之前，先设置一些变量。请注意，这些是JSR223变量-即它们可以直接在脚本中使用。
</p><ul>
<li><tt class="code">日志</tt> -（ <a href="https://www.slf4j.org/api/org/slf4j/Logger.html">Logger</a> ）-可用于写入日志文件</li>
<li><tt class="code">标签</tt> -字符串标签</li>
<li><tt class="code">FileName-</tt>脚本文件名（如果有）</li>
<li><tt class="code">参数</tt> -参数（作为字符串）</li>
<li><tt class="code">args-</tt>作为字符串数组的参数（在空格上分割）</li>
<li><tt class="code">CTX</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterContext.html">JMeterContext</a> ） -可以访问上下文</li>
<li><tt class="code">瓦尔</tt> - （ <a href="../api/org/apache/jmeter/threads/JMeterVariables.html">JMeterVariables</a> ） -给出读/写变量的访问：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>vars.get(key);
vars.put(key,val);
vars.putObject(&quot;OBJ1&quot;,new Object());
vars.getObject(&quot;OBJ2&quot;);</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
</li>
<li><tt class="code">道具</tt> -（JMeterProperties-类java.util。属性）-例如<tt class="code">props.get（“ START.HMS”）;</tt> <tt class="code">props.put（“ PROP1”，“ 1234”）;</tt></li>
<li><tt class="code">prev-</tt> （ <a href="../api/org/apache/jmeter/samplers/SampleResult.html">SampleResult</a> ）-提供对上一个SampleResult的访问权限（如果有）</li>
<li><tt class="code">采样器</tt> -（ <a href="../api/org/apache/jmeter/samplers/Sampler.html">采样器</a> ）-提供对当前采样器的访问</li>
<li><tt class="code">OUT</tt> -System.out-例如<tt class="code">OUT.println（“ message”）</tt></li>
</ul><p>有关上述每个变量可用的所有方法的详细信息，请检查Javadoc</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JDBC_PostProcessor">18.8.8 JDBC PostProcessor</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JDBC PostProcessor使您可以在运行示例后立即运行一些SQL语句。如果您的JDBC示例更改了一些数据，并且您想将状态重置为运行JDBC示例之前的状态，这将很有用。
</p>
<p><b>也可以看看：</b></p>
<ul>
<li><a href="../demos/JDBC-Pre-Post-Processor.jmx">使用JDBC前后处理器的测试计划</a></li>
</ul>
<p>在链接的测试计划中，“ <tt class="code">JDBC PostProcessor</tt> ” JDBC PostProcessor调用存储过程，以从数据库中删除由PreProcessor创建的价格下限。
</p><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="818" height="399" src="../images/screenshots/jdbc-post-processor.png"><br>
<font size="-1">JDBC后处理器</font></td></tr></tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="JSON_Extractor">18.8.9 JSON提取器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>JSON PostProcessor使您可以使用JSON-PATH语法从JSON响应中提取数据。该后处理器与正则表达式提取器非常相似。必须将其放置为HTTP Sampler或具有响应的任何其他Sampler的子级。它将允许您以非常简单的方式提取文本内容，请参阅<a href="https://github.com/json-path/JsonPath">JSON Path语法</a> 。
</p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>创建的变量的名称</td>
<td>用分号分隔的变量名称将包含JSON-PATH表达式的结果（必须匹配JSON-PATH表达式的数量）</td>
<td>是</td>
</tr>
<tr>
<td>JSON路径表达式</td>
<td>以分号分隔的JSON-PATH表达式（必须匹配变量数量）</td>
<td>是</td>
</tr>
<tr>
<td>默认值</td>
<td>如果JSON-PATH表达式不返回任何结果（必须与变量数量匹配），则用分号分隔的默认值</td>
<td>没有</td>
</tr>
<tr>
<td>比赛编号（0为随机）</td>
<td>如果JSON Path查询导致许多结果，则可以选择提取哪个作为变量：<ul>
        <li><tt class="code">0</tt> ：表示随机（默认值）</li>
        <li><tt class="code">-1</tt>表示提取所有结果，它们将被命名为<tt class="code"><em><variable name=""></variable></em> _N</tt> （其中<tt class="code">N</tt>从1到结果数）</li>
        <li><tt class="code">X</tt> ：表示提取第X <sup>个</sup>结果。如果此X <sup>th</sup>大于匹配数，则不返回任何内容。将使用默认值</li>
    </ul>
    </td>
<td>没有</td>
</tr>
<tr>
<td>计算串联变量</td>
<td>如果找到许多结果，则插件将使用' <tt class="code">，</tt> '分隔符将它们连接起来，并将其存储在一个名为var的变量中。 <tt class="code"><em><variable name=""></variable></em> _所有</tt></td>
<td>没有</td>
</tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="855" height="276" src="../images/screenshots/json-post-processor.png"><br>
<font size="-1">JSON PostProcessor</font></td></tr></tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Boundary_Extractor">18.8.10边界提取器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>允许用户使用左右边界从服务器响应中提取值。作为后处理器，此元素将在其范围内的每个Sample请求之后执行，测试边界，提取请求的值，生成模板字符串，并将结果存储到给定的变量名称中。</p><p><b>控制面板</b></p>
<div align="center"><img width="1078" height="315" src="../images/screenshots/extractor/boundary_extractor.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>适用于：</td>
<td>这适用于可以生成子样本的采样器，例如具有嵌入式资源的HTTP采样器，邮件阅读器或由事务控制器生成的样本。
        <ul>
        <li><tt class="code">仅主样本</tt> -仅适用于主样本</li>
        <li><tt class="code">仅子样本</tt> -仅适用于子样本</li>
        <li><tt class="code">主样本和子样本</tt> -均适用。</li>
        <li><tt class="code">使用的JMeter变量名称</tt> -断言将应用于命名变量的内容</li>
        </ul>匹配依次应用于所有合格样品。例如，如果有一个主样本和3个子样本，每个样本都包含一个匹配测试（即总共4个匹配项）。对于匹配号码= <tt class="code">3，</tt>只有子样品，提取器将匹配<sup>第三</sup>子样本。对于匹配数= <tt class="code">3</tt> ，主样本和子样本，提取器将匹配<sup>第二</sup>个子样本（ <sup>第一个</sup>匹配是主样本）。如果比赛号码= <tt class="code">0</tt>或负数，则将处理所有合格样本。对于匹配号> <tt class="code">0</tt> ，一旦找到足够的匹配项，匹配就会停止。
        </td>
<td>是</td>
</tr>
<tr>
<td>检查领域</td>
<td>可以检查以下字段：<ul>
        <li><tt class="code">机构</tt> -响应的主体，例如网页的内容（不包括标题）</li>
        <li>正文<tt class="code">（未转义）</tt> -响应的正文，已替换所有HTML转义代码。请注意，HTML转义的处理不考虑上下文，因此可能会进行一些不正确的替换。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，此选项会严重影响性能，因此仅在绝对必要时使用它，并注意其影响</td></tr>
</tbody></table>
<p></p>

        </li>
        <li><tt class="code">主体作为文档</tt> -通过Apache Tika从各种类型的文档中提取文本（请参见<a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树</a>文档视图部分）。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，“将文档作为文档”选项可能会影响性能，因此请确保可以通过测试</td></tr>
</tbody></table>
<p></p>

        </li>
        <li><tt class="code">请求标头</tt> -对于非HTTP示例可能不存在</li>
        <li><tt class="code">响应标头</tt> -对于非HTTP样本可能不存在</li>
        <li><tt class="code">网址</tt></li>
        <li><tt class="code">响应码</tt> -例如<tt class="code">200</tt></li>
        <li><tt class="code">响应消息</tt> -例如， <tt class="code">确定</tt></li>
        </ul>标头可用于HTTP样本。对于其他样品类型可能不存在。
        </td>
<td>是</td>
</tr>
<tr>
<td>创建变量的名称</td>
<td>将结果存储在其中的JMeter变量的名称。还要注意，每个组都存储为<tt class="code">[refname] _g＃</tt> ，其中<tt class="code">[refname]</tt>是您输入为参考名称的字符串，而<tt class="code">＃</tt>是组号，其中group <tt class="code">0</tt>是整个匹配项，group <tt class="code">1</tt>是来自匹配项的匹配项第一组括号等</td>
<td>是</td>
</tr>
<tr>
<td>左边界</td>
<td>查找值的左边界</td>
<td>没有</td>
</tr>
<tr>
<td>右边界</td>
<td>寻找价值的右边界</td>
<td>没有</td>
</tr>
<tr>
<td>比赛编号（0为随机）</td>
<td>指示要使用的匹配项。边界可以匹配多次。
            <ul>
                <li>使用零值表示JMeter应该随机选择一个匹配项。</li>
                <li>正数N表示选择第n <sup>个</sup>匹配项。</li>
                <li>负数与<a href="../usermanual/component_reference.html#ForEach_Controller">ForEach控制器</a>结合使用-参见下文。</li>
            </ul>
        </td>
<td>是</td>
</tr>
<tr>
<td>默认值</td>
<td>如果边界不匹配，则参考变量将设置为默认值。这对于调试测试特别有用。如果没有提供默认值，则很难判断边界是否不匹配，或者可能使用了错误的变量。
        <p>但是，如果您有多个设置相同变量的测试元素，则如果表达式不匹配，则可能希望使变量保持不变。在这种情况下，调试完成后，请删除默认值。
        </p> 
        </td>
<td>不，但是推荐</td>
</tr>
</tbody></table>
<p>如果将匹配号设置为非负数，并且发生匹配，则变量的设置如下：</p><ul>
        <li><tt class="code">refName-</tt>提取的值</li>
    </ul><p>如果没有匹配项，则将<tt class="code">refName</tt>变量设置为默认值（除非不存在）。
</p><p>如果匹配编号设置为负数，则将处理采样器数据中所有可能的匹配。变量设置如下：</p><ul>
        <li><tt class="code">refName_matchNr-</tt>找到的匹配项数；可能是<tt class="code">0</tt></li>
        <li><tt class="code">refName_ <em>n，</em></tt>其中<tt class="code">n</tt> = <tt class="code"><tt class="code"><tt class="code">1，2，3</tt></tt></tt>等-的字符串作为由模板生成</li>
        <li><tt class="code"><em>refName_Ñ_g</em> <em>m，</em></tt>其中<tt class="code">m</tt> = <tt class="code"><tt class="code"><tt class="code">0，1，2</tt></tt></tt> -基团为匹配<tt class="code">Ñ</tt></li>
        <li><tt class="code">refName-</tt>始终设置为默认值</li>
    </ul><p>请注意，在这种情况下， <tt class="code">refName</tt>变量始终设置为默认值，并且未设置关联的组变量。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果左右边界均为空，则返回在范围中选择的整个数据</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
</blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="Miscellaneous_Features"><strong>18.9其他功能</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<div class="description">
        <br>

</div>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Test_Plan">18.9.1测试计划</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>在“测试计划”中指定测试的总体设置。
</p>
<p>可以为在整个测试中重复的值定义静态变量，例如服务器名称。例如，变量<tt class="code">SERVER</tt>可以定义为<tt class="code">www.example.com</tt> ，而测试计划的其余部分可以将其称为<tt class="code">$ {SERVER}</tt> 。这样可以简化以后的名称更改。
</p>
<p>如果在多个“ <a href="../usermanual/component_reference.html#User_Defined_Variables">用户定义的变量</a>配置”元素之一上重用了相同的变量名，则该值将设置为测试计划中的最后一个定义（从上到下读取）。此类变量应用于在测试运行之间可能会更改但在测试运行期间保持不变的项目。
</p>
<p>
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，测试计划不能引用其定义的变量。</td></tr>
</tbody></table>
<p></p>如果需要从“测试计划”变量构造其他变量，请使用“ <a href="../usermanual/component_reference.html#User_Defined_Variables">用户定义的变量”</a>测试元素。
<p></p>
<p>选择功能测试将指示JMeter将其他样本信息（响应数据和采样器数据）保存到所有结果文件中。这增加了运行测试所需的资源，并且可能对JMeter的性能产生不利影响。如果仅特定采样器需要更多数据，则向其添加侦听器，并根据需要配置字段。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>该选项不影响CSV结果文件，该文件当前无法存储此类信息。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>另外，这里存在一个选项来指示JMeter以串行方式而不是并行方式运行<a href="../usermanual/component_reference.html#Thread_Group">线程组</a> 。</p>
<p>在主线程关闭后运行tearDown线程组：如果选中，则在正常关闭主线程后运行tearDown组（如果有）。如果强行停止了测试，tearDown线程将不会运行。
</p>
<p>现在，测试计划提供了一种将类路径设置添加到特定测试计划的简便方法。该功能是可加的，这意味着您可以添加jar文件或目录，但是要删除条目则需要重新启动JMeter。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，这不能用于添加JMeter GUI插件，因为它们是较早处理的。</td></tr>
</tbody></table>
<p></p>但是，它对于实用程序jar（例如JDBC驱动程序）很有用。罐子仅添加到JMeter加载器的搜索路径，而不添加到系统类加载器的搜索路径。
<p></p>
<p>JMeter属性还提供了用于加载其他类路径的条目。在<tt class="code">jmeter.properties中</tt> ，编辑“ <tt class="code">user.classpath</tt> ”或“ <tt class="code">plugin_dependency_paths</tt> ”以包含其他库。有关详细信息，请参见<a href="get-started.html#classpath">JMeter的类路径</a>和<a href="get-started.html#configuring_jmeter">配置JMeter</a> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="560" height="457" src="../images/screenshots/testplan.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Thread_Group">18.9.2线程组</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>线程组定义了将对您的服务器执行特定测试用例的用户池。在线程组GUI中，您可以控制模拟的用户数（线程数），启动时间（启动所有线程需要多长时间），执行测试的次数以及（可选）启动并停止测试时间。</p>
<p>另请参阅<a href="../usermanual/component_reference.html#tearDown_Thread_Group">tearDown线程组</a>和<a href="../usermanual/component_reference.html#setUp_Thread_Group">setUp线程组</a> 。
</p>
<p>使用调度程序时，JMeter运行线程组，直到达到循环数或达到持续时间/结束时间（以先发生的为准）为止。请注意，仅在样本之间检查条件。当达到结束条件时，该线程将停止。JMeter不会中断正在等待响应的采样器，因此结束时间可以任意延迟。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="911" height="390" src="../images/screenshots/threadgroup.png"></div>
<p>从JMeter 3.0开始，您可以通过选择线程组并单击鼠标右键来运行一系列线程组。将会出现一个弹出菜单：</p><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="461" height="818" src="../images/screenshots/threadgroup-popup-menu.png"><br>
<font size="-1">弹出菜单开始选择线程组</font></td></tr></tbody></table>


<br>注意，您有3个选项来运行线程组的选择：<ul>
<li>开始：仅启动选定的线程组</li>
<li>不暂停开始：仅启动选定的线程组，但不运行计时器</li>
<li>验证：仅使用验证模式启动选定的线程组。默认情况下，这会以验证模式运行线程组（请参见下文）</li>
</ul> 

<b>验证方式：</b><br>此模式通过运行1个线程，1次迭代，没有计时器且没有将<tt class="code">启动延迟</tt>设置为0来运行线程组，从而可以快速验证线程组。可以通过在user.properties中设置一些属性来修改行为：<ul>
<li><tt class="code">testplan_validation.nb_threads_per_thread_group</tt> ：默认情况下，用于验证线程组的线程数1</li>
<li><tt class="code">testplan_validation.ignore_timers</tt> ：验证计划的线程组时忽略计时器，默认情况下为1</li>
<li><tt class="code">testplan_validation.number_iterations</tt> ：用于验证线程组的迭代次数</li>
<li><tt class="code">testplan_validation.tpc_force_100_pct</tt> ：用来强制吞吐量控制器以百分比模式运行，就像百分比是100％一样。默认为false</li>
</ul> 
<p></p><p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>采样器错误后要采取的措施</td>
<td>确定如果由于样本本身失败或断言失败而导致发生采样器错误，该如何处理。可能的选择是：<ul>
        <li><tt class="code">继续</tt> -忽略错误并继续测试</li>
        <li><tt class="code">开始下一个线程循环</tt> -忽略错误，开始下一个循环并继续测试</li>
        <li><tt class="code">停止线程</tt> -当前线程退出</li>
        <li><tt class="code">停止测试</tt> -整个测试在任何当前样本结束时停止。</li>
        <li><tt class="code">立即停止测试</tt> -整个测试突然停止。如有可能，任何当前采样器都会中断。</li>
        </ul>
        </td>
<td>没有</td>
</tr>
<tr>
<td>线程数</td>
<td>要模拟的用户数。</td>
<td>是</td>
</tr>
<tr>
<td>加速期</td>
<td>JMeter应该花多长时间才能启动所有线程。如果有10个线程，启动时间为100秒，则每个线程将在前一个线程启动后10秒开始，总时间为100秒，以使测试完全加速。</td>
<td>是</td>
</tr>
<tr>
<td>循环计数</td>
<td>执行测试用例的次数。或者，可以选择“ <tt class="code">infinite</tt> ”使测试运行，直到手动停止或达到线程寿命结束为止。</td>
<td>是的，除非选择了无限</td>
</tr>
<tr>
<td>将线程创建延迟到需要时</td>
<td>如果选择，仅在经过适当比例的加速时间后才创建线程。这最适合加速时间明显长于执行单个线程的时间的测试。即较早的线程在较晚的线程开始之前先完成的位置。
        <br>如果未选择，则会在测试开始时创建所有线程（然后暂停相应的加速时间）。这是原始默认设置，适用于在整个测试的大部分时间里线程都处于活动状态的测试。</td>
<td>是</td>
</tr>
<tr>
<td>指定线程寿命</td>
<td>如果选择，则将线程操作时间限制在给定范围内</td>
<td>是</td>
</tr>
<tr>
<td>持续时间（秒）</td>
<td>如果选中了计划程序复选框，则可以选择相对结束时间。JMeter将使用它来计算结束时间。
        </td>
<td>没有</td>
</tr>
<tr>
<td>启动延迟（秒）</td>
<td>如果选中了计划程序复选框，则可以选择一个相对的启动延迟。JMeter将使用它来计算开始时间。
        </td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="WorkBench">工作台</a>
</h3>
</font>
</td></tr>
<tr><td>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="SSL_Manager">18.9.4 SSL管理器</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>SSL管理器是一种选择客户端证书的方法，因此您可以测试使用公钥基础结构（PKI）的应用程序。仅当您尚未设置适当的系统属性时才需要它。

</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果要测试客户端证书认证，请参阅<a href="../usermanual/component_reference.html#Keystore_Configuration">密钥库配置</a></td></tr>
</tbody></table>
<p></p>
<b>选择客户证书</b><p>您可以将Java密钥库（JKS）格式的密钥库或公用密钥证书标准＃12（PKCS12）文件用于客户端证书。JSSE库的一项功能要求您的密钥上至少有六个字符的密码（至少对于JDK随附的keytool实用程序而言）。
</p><p>要选择客户端证书，请从菜单栏中选择<span class="menuchoice"><span class="guimenuitem">选项</span> → <span class="guimenuitem">SSL管理器</span></span> 。您将看到一个文件查找器，默认情况下会查找PKCS12文件。您的PKCS12文件必须具有扩展名“ <tt class="code">.p12</tt> ”，SSL Manager才能将其识别为PKCS12文件。其他任何文件都将被视为普通的JKS密钥库。如果正确安装了JSSE，系统将提示您输入密码。文本框不会隐藏您此时输入的字符-因此请确保没有人看着您。当前实现假定密钥库的密码也是您要验证为的客户端的私钥的密码。
</p><p>或者，您可以设置适当的系统属性-请参阅<tt class="code">system.properties</tt>文件。</p><p>下次运行测试时，SSL管理器将检查您的密钥存储，以查看它是否至少具有一个可用的密钥。如果只有一个密钥，SSL Manager将为您选择它。如果有多个键，则当前会选择第一个键。当前无法在密钥库中选择其他条目，因此所需的密钥必须是第一个。
</p><b>要注意的事情</b><p>如果未由JDK附带的五个CA证书之一签名，则必须正确安装证书颁发机构（CA）证书。一种安装方法是将CA证书导入JKS文件，并将JKS文件命名为“ <tt class="code">jssecacerts</tt> ”。将文件放在JRE的<tt class="code">lib / security</tt>文件夹中。将在同一目录中的“ <tt class="code">cacerts</tt> ”文件之前读取此文件。请记住，只要存在“ <tt class="code">jssecacerts</tt> ”文件，就不会使用“ <tt class="code">cacerts</tt> ”中安装的证书。这可能会给您带来麻烦。如果您不介意将CA证书导入到“ <tt class="code">cacerts</tt> ”文件中，则可以针对已安装的所有CA证书进行身份验证。
</p></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<a name="HTTP_Proxy_Server"></a>
<h3>
<a name="HTTP(S)_Test_Script_Recorder">18.9.5 HTTP（S）测试脚本记录器（以前是：HTTP代理服务器）</a>
</h3>
</font>
</td></tr>
<tr><td>
<p>HTTP（S）测试脚本记录器允许JMeter在使用常规浏览器浏览Web应用程序时截获并记录您的操作。JMeter将创建测试样本对象，并将它们直接存储到您的测试计划中（这样您就可以在制作它们的同时以交互方式查看样本）。<br>确保阅读此<a href="https://cwiki.apache.org/confluence/display/JMETER/TestRecording210">Wiki页面</a>以正确设置JMeter。
</p>

<p>要使用记录器，请<i>添加</i> HTTP（S）测试脚本记录器元素。右键单击“测试计划”元素以获取“添加”菜单：（“ <span class="menuchoice"><span class="guimenuitem">添加”</span> →“ <span class="guimenuitem">非测试元素”</span> →“ <span class="guimenuitem">HTTP（S）测试脚本记录器”</span></span> ）。
</p>
<p>记录器被实现为HTTP（S）代理服务器。您需要设置浏览器对所有HTTP和HTTPS请求使用代理。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请勿将JMeter用作其他任何请求类型（例如FTP等）的代理，因为JMeter无法处理它们。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>录制会话时，最好使用私有浏览模式。这应该确保浏览器没有存储的cookie开头，并防止保存某些更改。例如，Firefox不允许永久保存证书替代。
</p>
<h4>HTTPS记录和证书</h4>
<p>HTTPS连接使用证书来验证浏览器和Web服务器之间的连接。通过HTTPS连接时，服务器将证书提供给浏览器。要对证书进行身份验证，浏览器会检查服务器证书是否由链接到其内置根CA之一的证书颁发机构（CA）签名。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>浏览器还会检查证书是否适用于正确的主机或域，并且证书有效且未过期。</td></tr>
</tbody></table>
<p></p>如果任何浏览器检查失败，它将提示用户，然后用户可以决定是否允许连接继续进行。
<p></p>
<p>JMeter需要使用自己的证书来使其能够拦截来自浏览器的HTTPS连接。实际上，JMeter必须假装为目标服务器。
</p>
<p>JMeter将生成自己的证书。这些密码是使用属性<tt class="code">proxy.cert.validity</tt>定义的有效期生成的，默认有效期为7天，并使用随机密码。如果JMeter检测到它正在Java 8或更高版本下运行，它将在必要时为每个目标服务器生成证书（动态模式），除非定义了以下属性： <tt class="code">proxy.cert.dynamic_keys = false</tt> 。使用动态模式时，该证书将使用正确的主机名，并由JMeter生成的CA证书签名。默认情况下，浏览器不会信任此CA证书，但是可以将其安装为受信任的证书。完成此操作后，浏览器将接受生成的服务器证书。这样做的好处是，甚至嵌入式HTTPS资源也可以被拦截，并且不需要为每个新服务器覆盖浏览器检查。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>浏览器不提示输入嵌入式资源。因此，对于较早的版本，将仅为浏览器已经“知道”的服务器下载嵌入式资源。</td></tr>
</tbody></table>
<p></p>

<p></p>
<p>除非提供了密钥库（并且您定义了<tt class="code">proxy.cert.alias</tt>属性）， <tt class="code">否则</tt> JMeter需要使用keytool应用程序来创建密钥库条目。JMeter包含用于通过在各种标准位置查看来检查keytool是否可用的代码。如果JMeter无法找到keytool应用程序，它将报告错误。如有必要，可以使用系统属性<tt class="code">keytool.directory</tt>告诉JMeter在哪里可以找到keytool。这应该在文件<tt class="code">system.properties中</tt>定义。
</p>
<p>按下“ <tt class="code">开始”</tt>按钮时，将生成JMeter证书（如有必要）。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>证书生成可能需要一些时间，在此期间，GUI将无响应。</td></tr>
</tbody></table>
<p></p>发生这种情况时，光标将变为沙漏。证书生成完成后，GUI将显示一个弹出对话框，其中包含根CA证书的详细信息。该证书需要由浏览器安装，以便接受JMeter生成的主机证书。有关详情，请参见<a href="#install_cert">下文</a> 。
<p></p>
<p>如有必要，您可以通过从JMeter目录中删除密钥库文件<tt class="code">proxyserver.jks</tt> ，强制JMeter重新生成密钥库（以及导出的证书<tt class="code">-ApacheJMeterTemporaryRootCA [.usr | .crt]</tt> ）。
</p>
<p>该证书不是浏览器通常信任的证书之一，也不适合正确的主机。<br>作为结果：</p>
<ul>
<li>浏览器应显示一个对话框，询问您是否要接受证书。例如：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
1) The server's name &quot;<tt class="code">www.example.com</tt>&quot; does not match the certificate's name
   &quot;<tt class="code">JMeter Proxy (DO NOT TRUST)</tt>&quot;. Somebody may be trying to eavesdrop on you.
2) The certificate for &quot;<tt class="code">JMeter Proxy (DO NOT TRUST)</tt>&quot; is signed by the unknown Certificate Authority
   &quot;<tt class="code">JMeter Proxy (DO NOT TRUST)</tt>&quot;. It is not possible to verify that this is a valid certificate.
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>您将需要接受证书，以允许JMeter代理拦截SSL流量以进行记录。但是，请勿永久接受此证书；只能暂时接受。浏览器仅提示此对话框输入主URL的证书，而不提示页面中加载的资源，例如托管在受保护的外部CDN上的图像，CSS或JavaScript文件。如果您有这样的资源（例如gmail），则必须首先手动浏览到这些其他域，以便为其接受JMeter的证书。在<tt class="code">jmeter.log</tt>中<tt class="code">签入</tt>需要注册证书的安全域。
</li>
<li>如果浏览器已经为该域注册了经过验证的证书，则浏览器会将JMeter检测为安全漏洞，并拒绝加载页面。如果是这样，则必须从浏览器的密钥库中删除受信任的证书。
</li>
</ul>
<p>从2.10开始的JMeter版本仍支持此方法，并且如果定义以下属性，则将继续这样做： <tt class="code">proxy.cert.alias</tt>以下属性可用于更改所使用的证书：</p>
<ul>
<li><tt class="code">proxy.cert.directory-</tt>在其中查找证书的目录（默认= JMeter <tt class="code">bin /</tt> ）</li>
<li><tt class="code">proxy.cert.file-</tt>密钥库文件的名称（默认为“ <tt class="code">proxyserver.jks</tt> ”）</li>
<li><tt class="code">proxy.cert.keystorepass-</tt>密钥库密码（默认为“ <tt class="code">password</tt> ”）[如果使用JMeter证书<tt class="code">则被</tt>忽略]</li>
<li><tt class="code">proxy.cert.keypassword-</tt>证书密钥密码（默认为“ <tt class="code">password</tt> ”）[如果使用JMeter证书<tt class="code">则被</tt>忽略]</li>
<li><tt class="code">proxy.cert.type-</tt>证书类型（默认为“ <tt class="code">JKS</tt> ”）[如果使用JMeter证书<tt class="code">则被</tt>忽略]</li>
<li><tt class="code">proxy.cert.factory-</tt>工厂（默认为“ <tt class="code">SunX509</tt> ”）[如果使用JMeter证书<tt class="code">则被</tt>忽略]</li>
<li><tt class="code">proxy.cert.alias-</tt>要使用的密钥的别名。如果已定义，则JMeter不会尝试生成自己的证书。</li>
<li><tt class="code">proxy.ssl.protocol-</tt>要使用的协议（默认为“ <tt class="code">SSLv3</tt> ”）</li>
</ul>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果您的浏览器当前使用代理（例如，公司Intranet可以通过代理路由所有外部请求），那么您需要使用<a href="get-started.html#options">命令行选项</a> <tt class="code">-H</tt>和<tt class="code">-P</tt> <a href="get-started.html#proxy_server">告诉JMeter</a>在启动JMeter之前<a href="get-started.html#proxy_server">使用该代理</a> 。运行生成的测试计划时，也需要此设置。
</td></tr>
</tbody></table>
<p></p>

<a name="install_cert"></a>
<h4>安装用于HTTPS记录的JMeter CA证书</h4>
<p>如上所述，当在Java 8下运行时，JMeter可以为每个服务器生成证书。为了使此操作顺利进行，浏览器必须信任JMeter使用的根CA签名证书。记录器首次启动时，如有必要，它将生成证书。根CA证书将导出到当前启动目录中名为<tt class="code">ApacheJMeterTemporaryRootCA</tt>的文件中。设置证书后，JMeter将显示一个对话框，其中包含当前证书的详细信息。此时，可以按照以下说明将证书导入浏览器。
</p>
<p>请注意，将根CA证书安装为受信任的CA后，浏览器将信任由它签名的所有证书。在证书过期或从浏览器中删除证书之前，它不会警告用户依赖证书。因此，任何可以掌握密钥库和密码的人都可以使用证书生成证书，这些证书将被信任JMeter根CA证书的所有浏览器接受。因此，将随机生成密钥库和私钥的密码，并使用较短的有效期。密码存储在本地首选项区域中。请确保只有受信任的用户才能使用密钥库访问主机。
</p>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>启动记录器后显示的弹出窗口是一个信息性弹出窗口：<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="1024" height="749" src="../images/screenshots/recorder_popup_info.png"><br>
<font size="-1">记录器安装证书弹出窗口</font></td></tr></tbody></table>只需单击确定，然后继续。
</td></tr>
</tbody></table>
<p></p>

<h5>在Firefox中安装证书</h5>
<p>选择以下选项：</p>
<ul>
<li><tt class="code">工具/选项</tt></li>
<li><tt class="code">高级/证书</tt></li>
<li><tt class="code">查看证书</tt></li>
<li><tt class="code">当局</tt></li>
<li><tt class="code">导入…</tt></li>
<li>浏览到JMeter启动目录，然后单击文件<tt class="code">ApacheJMeterTemporaryRootCA.crt</tt> ，按<tt class="code">Open。</tt></li>
<li>单击<tt class="code">查看，</tt>并检查证书详细信息是否与JMeter测试脚本记录器显示的证书详细信息一致</li>
<li>如果确定，请选择“ <tt class="code">信任此CA以标识网站</tt> ”，然后按<tt class="code">确定</tt></li>
<li>必要时按<tt class="code">确定</tt>关闭对话框</li>
</ul>
<h5>在Chrome或Internet Explorer中安装证书</h5>
<p>Chrome和Internet Explorer都使用同一信任库来存储证书。
</p>
<ul>
<li>浏览到JMeter启动目录，然后单击文件<tt class="code">ApacheJMeterTemporaryRootCA.crt</tt>并将其打开</li>
<li>单击“ <tt class="code">详细信息</tt> ”选项卡，并检查证书详细信息是否与JMeter Test Script Recorder所显示的详细信息一致。</li>
<li>如果确定，请返回“ <tt class="code">常规</tt> ”选项卡，然后单击“ <tt class="code">安装证书...</tt> ”，然后按照向导提示进行操作</li>
</ul>
<h5>在Opera中安装证书</h5>
<ul>
<li><tt class="code">工具/首选项/高级/安全</tt></li>
<li><tt class="code">管理证书...</tt></li>
<li>选择“ <tt class="code">中级</tt> ”选项卡，单击“ <tt class="code">导入...</tt> ”</li>
<li>浏览到JMeter启动目录，然后单击文件<tt class="code">ApacheJMeterTemporaryRootCA.usr</tt> ，然后将其打开。</li>
<li></li>
</ul>
<p><b>控制面板</b></p>
<div align="center"><img width="1024" height="749" src="../images/screenshots/proxy_control.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>港口</td>
<td>HTTP（S）测试脚本记录器侦听的端口。 <tt class="code">8888</tt>是默认设置，但是您可以更改它。</td>
<td>是</td>
</tr>
<tr>
<td>HTTPS域</td>
<td>HTTPS的域（或主机）名称列表。使用此选项可以为要记录的所有服务器预生成证书。
        <br>例如， <tt class="code">*。example.com，*。subdomain.example.com</tt>
        <br>请注意，通配符域仅适用于一个级别，即<tt class="code">abc.subdomain.example.com</tt>与<tt class="code">* .subdomain.example.com</tt>匹配， <tt class="code">而</tt>与<tt class="code">* .example.com</tt>不匹配<tt class="code">。</tt>
        </td>
<td>没有</td>
</tr>
<tr>
<td>目标控制器</td>
<td>代理将在其中存储生成的样本的控制器。默认情况下，它将查找记录控制器并将其存储在任何位置。</td>
<td>是</td>
</tr>
<tr>
<td>分组</td>
<td>是否将采样器归纳为来自单个“单击”的请求（收到的请求没有明显的时间间隔），以及如何在记录中表示该分组：<ul>
             <li><tt class="code">不要对采样</tt>器进行分组-按顺序存储所有记录的采样器，而不进行任何分组。</li>
             <li><tt class="code">在组之间添加分隔符</tt> -添加名为“ <tt class="code">--------------</tt> ”的控制器以在组之间创建可视分隔。否则，采样器将全部按顺序存储。</li>
             <li><tt class="code">将每个组放入新的控制器中</tt> -为每个组创建一个新的<a href="../usermanual/component_reference.html#Simple_Controller">简单控制器</a> ，并将该组的所有采样器存储在其中。</li>
             <li><tt class="code">仅在每个群组的存储1 <sup>次</sup>采样</tt> -仅在每个组中的第一请求将被记录。在这些采样器中，“ <tt class="code">跟随重定向</tt> ”和“ <tt class="code">检索所有嵌入式资源...</tt> ”标志将打开。</li>
             <li><tt class="code">将每个组放入新的事务处理控制器中</tt> -为每个组创建一个新的<a href="../usermanual/component_reference.html#Transaction_Controller">事务处理控制器</a> ，并将该组的所有采样器存储在其中。</li>
           </ul>属性<tt class="code">proxy.pause</tt>确定JMeter在<tt class="code">两次</tt>请求之间将其视为单独的“单击”所需要的最小间隔。默认值为<tt class="code">5000</tt> （毫秒），即5秒。如果您使用分组，请确保在两次点击之间留出所需的间隔。
        </td>
<td>是</td>
</tr>
<tr>
<td>捕获HTTP标头</td>
<td>是否应在计划中添加标题？如果指定，则将头管理器添加到每个HTTP Sampler。代理服务器始终从生成的标头管理器中删除Cookie和授权标头。默认情况下，它还会删除<tt class="code">If-Modified-Since</tt>和<tt class="code">If-None-Match</tt>标头。这些用于确定浏览器缓存项是否最新。录制时通常希望下载所有内容。要更改要删除的其他标头，请将JMeter属性<tt class="code">proxy.headers.remove</tt>定义为以逗号分隔的标头列表。
        </td>
<td>是</td>
</tr>
<tr>
<td>添加断言</td>
<td>向每个采样器添加一个空白断言？</td>
<td>是</td>
</tr>
<tr>
<td>正则表达式匹配</td>
<td>替换变量时使用正则表达式匹配吗？如果选中，替换将使用单词边界，即它将仅替换变量的单词匹配值，而不替换单词的一部分。单词边界遵循Perl5定义，等效于<tt class="code">\ b</tt> 。以下有关“ <tt class="code">用户定义的变量替换</tt> ”的段落中的更多信息。</td>
<td>是</td>
</tr>
<tr>
<td>前缀/交易名称</td>
<td>在录制过程中（采样模式）在采样器名称上添加前缀。或将采样器名称替换为用户选择的名称（交易名称）</td>
<td>没有</td>
</tr>
<tr>
<td>请求后创建新交易（毫秒）</td>
<td>两个请求之间的不活动时间需要将它们分为两个单独的组。</td>
<td>没有</td>
</tr>
<tr>
<td>类型</td>
<td>生成哪种类型的采样器（HTTPClient默认值或Java）</td>
<td>是</td>
</tr>
<tr>
<td>自动重定向</td>
<td>在生成的采样器中自动设置重定向？</td>
<td>是</td>
</tr>
<tr>
<td>跟随重定向</td>
<td>在生成的采样器中设置关注重定向？<br>

        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：有关重要信息，请参见下面的“记录和重定向”部分。</td></tr>
</tbody></table>
<p></p>

        </td>
<td>是</td>
</tr>
<tr>
<td>使用保持活动</td>
<td>在生成的采样器中设置“使用保持活动”吗？</td>
<td>是</td>
</tr>
<tr>
<td>检索所有嵌入式资源</td>
<td>设置在生成的采样器中检索所有嵌入式资源？</td>
<td>是</td>
</tr>
<tr>
<td>内容类型过滤器</td>
<td>根据<tt class="code">内容类型</tt>过滤请求-例如“ <tt class="code">text / html [; charset = utf-8]</tt> ”。这些字段是正则表达式，将对其进行检查以查看它们是否包含在<tt class="code">content-type中</tt> 。[不必匹配整个字段]。首先检查包含过滤器，然后检查排除过滤器。滤出的样品将不会被保存。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意：此过滤适用于响应的内容类型</td></tr>
</tbody></table>
<p></p>

        </td>
<td>没有</td>
</tr>
<tr>
<td>要包含的模式</td>
<td>与采样的完整URL匹配的正则表达式。允许过滤记录的请求。所有请求通过，但只有那些满足<tt class="code">包括</tt>要求/ <tt class="code">排除</tt>的字段被<em>记录</em> 。如果将“ <tt class="code">包含”</tt>和“ <tt class="code">排除”</tt>都保留为空，则将记录所有内容（这可能会导致每页记录数十个样本，因为记录了图像，样式表等）。<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>如果“ <tt class="code">包含”</tt>字段中至少有一个条目，则仅记录与一个或多个“ <tt class="code">包含”</tt>模式匹配的请求</td></tr>
</tbody></table>
<p></p>。</td>
<td>没有</td>
</tr>
<tr>
<td>排除模式</td>
<td>与采样的URL匹配的正则表达式。
        <p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td><em>不</em>记录与一个或多个“ <tt class="code">排除”</tt>模式匹配的任何请求</td></tr>
</tbody></table>
<p></p>。</td>
<td>没有</td>
</tr>
<tr>
<td>通知子侦听器已过滤的采样器</td>
<td>通知子侦听器已过滤的采样器<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>与一个或多个“ <tt class="code">排除”</tt>模式匹配的任何响应都<em>不会</em>传递给子侦听器（“查看结果树”）</td></tr>
</tbody></table>
<p></p>。</td>
<td>没有</td>
</tr>
<tr>
<td>开始按钮</td>
<td>启动代理服务器。代理服务器启动并准备接受请求后，JMeter会将以下消息写入控制台：“ <tt class="code">代理已启动并正在运行！</tt>”。</td>
<td>不适用</td>
</tr>
<tr>
<td>停止按钮</td>
<td>停止代理服务器。</td>
<td>不适用</td>
</tr>
<tr>
<td>重新启动按钮</td>
<td>停止并重新启动代理服务器。当您更改/添加/删除包含/排除过滤器表达式时，这很有用。</td>
<td>不适用</td>
</tr>
</tbody></table>
<h4>记录和重定向</h4><p>在录制期间，浏览器将遵循重定向响应并生成其他请求。代理将记录原始请求和重定向请求（受配置的排除条件约束）。生成的样本默认情况下已选择“ <tt class="code">Follow Redirects</tt> ”，因为这样通常更好。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>重定向可能取决于原始请求，因此重复原始记录的样本可能并不总是有效。</td></tr>
</tbody></table>
<p></p>

<p></p><p>现在，如果将JMeter设置为在重播期间遵循重定向，它将发出原始请求，然后重播已记录的重定向请求。为了避免重复播放，JMeter尝试检测样本是先前重定向的结果。如果当前响应是重定向，则JMeter将保存重定向URL。收到下一个请求时，会将其与保存的重定向URL进行比较，如果存在匹配项，JMeter将禁用生成的样本。它还将注释添加到重定向链。这假定重定向链中的所有请求将彼此跟随，而没有任何中间请求。要禁用重定向检测，请设置属性<tt class="code">proxy.redirect.disabling = false</tt>
</p><h4>包含和排除</h4><p><b>包含和排除模式</b>被视为正则表达式（使用Jakarta ORO）。它们将与每个浏览器请求的主机名，端口（实际或隐含），路径和查询（如果有）匹配。如果您正在浏览的网址是<br>“ <tt class="code">http：//localhost/jmeter/index.html？username = xxxx</tt> ”，<br>然后将针对字符串测试正则表达式：<br>” <tt class="code">localhost：80 / jmeter / index.html？username = xxxx</tt> “。<br>因此，如果要包括所有<tt class="code">.html</tt>文件，则正则表达式可能类似于：<br>“ <tt class="code">。* \。html（\ ?.*）？</tt>“-或” <tt class="code">。* \。html，</tt>如果您知道没有查询字符串，或者您只想要没有查询字符串的html页面。
</p><p>如果有任何包含模式，则URL <b>必须至少与其中一种</b>模式<b>匹配</b> ，否则将不会被记录。如果有任何排除模式，则URL <b>不得与任何</b>模式<b>匹配</b> ，否则将不会被记录。使用包含和排除的组合，您应该能够记录您感兴趣的内容，并跳过您不感兴趣的内容。
</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>注意，由正则表达式匹配的字符串必须与<b>整个</b> host + path字符串相同。<br>因此，“ <tt class="code">\ .html</tt> ”将与<tt class="code">localhost：80 / index.html</tt> <b>不</b>匹配
</td></tr>
</tbody></table>
<p></p>
<h4>捕获二进制POST数据</h4><p>JMeter能够捕获二进制POST数据。要配置将哪些<tt class="code">内容类型</tt>视为二进制，请更新JMeter属性<tt class="code">proxy.binary.types</tt> 。默认设置如下：</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
# These content-types will be handled by saving the request in a file:
proxy.binary.types=application/x-amf,application/x-java-serialized-object
# The files will be saved in this directory:
proxy.binary.directory=user.dir
# The files will be created with this file filesuffix:
proxy.binary.filesuffix=.binary
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<h4>添加计时器</h4><p>也可以让代理将计时器添加到已录制的脚本中。为此，请直接在HTTP（S）测试脚本记录器组件中创建一个计时器。代理会将此计时器的副本放置到它记录的每个样本中，如果使用分组，则放置在每个组的第一个样本中。然后将扫描此副本以查找其属性中变量<tt class="code">$ {T}的</tt>出现，任何此类出现都将被记录的前一个采样器的时间间隔（以毫秒为单位）替换。</p><p>准备开始时，请单击“ <tt class="code">开始</tt> ”。</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>您将需要编辑浏览器的代理设置，以指向适当的服务器和端口，该服务器是JMeter运行所在的计算机，端口号来自上面显示的Proxy Control Panel。</td></tr>
</tbody></table>
<p></p>
<h4>样品在哪里记录？</h4><p>JMeter将记录的样本放置在您选择的目标控制器中。如果选择默认选项“ <tt class="code">Use Recording Controller</tt> ”，它们将存储在测试对象树中找到的第一个Recording Controller中（因此请确保在开始记录之前添加一个Recording Controller）。</p><p>如果代理似乎未记录任何样本，则可能是因为浏览器实际上并未使用代理。要检查是否存在这种情况，请尝试停止代理。如果浏览器仍在下载页面，则说明它没有通过代理发送请求。仔细检查浏览器选项。如果尝试从在同一主机上运行的服务器进行记录，请检查浏览器是否未设置为“ <tt class="code">为本地地址绕过代理服务器</tt> ”（此示例来自IE7，但其他浏览器也有类似的选项）。如果JMeter不记录浏览器URL，例如<tt class="code">http：// localhost /</tt>或<tt class="code">http://127.0.0.1/</tt> ，请尝试使用非回送主机名或IP地址，例如<tt class="code">http：// myhost /</tt>或<tt class="code">http：//192.168。 0.2 /</tt> 。</p><h4>HTTP请求默认值的处理</h4><p>如果HTTP（S）测试脚本记录器直接在存储样本的控制器内或直接在其任何父控制器内找到启用的<a href="../usermanual/component_reference.html#HTTP_Request_Defaults">HTTP请求默认值</a> ，则记录的样本将为您指定的默认值包含空字段。您可以通过将HTTP Request Defaults元素直接放置在HTTP（S）测试脚本记录器中来进一步控制此行为，该元素的非空值将覆盖其他HTTP Request Defaults中的值。有关更多信息，请参阅<a href="best-practices.html#proxy_server">HTTP（S）测试脚本记录器的最佳实践</a> 。</p><h4>用户定义的变量替换</h4><p>同样，如果HTTP（S）测试脚本记录器直接在存储样本的控制器中或其任何父控制器中直接找到<a href="../usermanual/component_reference.html#User_Defined_Variables">用户定义变量</a> （UDV），则记录的样本将出现这些变量的任何值替换为相应的变量。同样，您可以直接在HTTP（S）测试脚本记录器中放置用户定义的变量，以覆盖要替换的值。有关更多信息，请参见<a href="best-practices.html#proxy_server">使用测试脚本记录器的最佳实践</a> 。</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，匹配区分大小写。</td></tr>
</tbody></table>
<p></p>
<p>用变量替换：默认情况下，代理服务器查找所有出现的UDV值。例如，如果使用值<tt class="code">www</tt>定义变量<tt class="code">WEB</tt> ，则无论在何处，字符串<tt class="code">www</tt>都将由<tt class="code">$ {WEB}</tt>替换。为了避免这种情况到处发生，请设置“ <tt class="code">Regex Matching</tt> ”复选框。这告诉代理服务器将值视为正则表达式（使用ORO提供的与perl5兼容的正则表达式匹配器）。</p><p>如果选择“ <tt class="code">Regex Matching</tt> ”，则每个变量都将被编译为<tt class="code">\ b（</tt>和<tt class="code">）\ b中</tt>包含的与perl兼容的regex。这样，每个匹配将在单词边界处开始和结束。</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，边界字符不是匹配组的一部分，例如， <tt class="code">n。*</tt>以匹配<tt class="code">名称</tt>中的“ <tt class="code">您可以称呼我'name'”</tt> 。</td></tr>
</tbody></table>
<p></p>
<p>如果您不希望将正则表达式包含在这些边界匹配器中，则必须将正则表达式包含在括号中，例如<tt class="code">（'。*？'）</tt>匹配<tt class="code">“名称”</tt> ， <tt class="code">您可以称呼我为“名称”</tt> 。</p><p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>变量将以随机顺序检查。因此，请确保潜在的匹配不会重叠。重叠匹配器为<tt class="code">。*</tt> （匹配所有内容）和<tt class="code">www</tt> （仅匹配<tt class="code">www</tt> ）。非重叠的匹配将<tt class="code">是+（</tt> <tt class="code">的</tt>一个序列相匹配的）和<tt class="code">b <tt class="code">+（B</tt></tt>的序列相匹配的）。
</td></tr>
</tbody></table>
<p></p>
<p>如果只想匹配整个字符串，则将其括在<tt class="code">（^</tt>和<tt class="code">$）中</tt> ，例如<tt class="code">（（thus $）</tt> 。括号是必需的，因为通常添加的边界字符将阻止<tt class="code">^</tt>和<tt class="code">$</tt>匹配。</p><p>如果只想在字符串的开头匹配<tt class="code">/ images</tt> ，则使用值<tt class="code">（^ / images）</tt> 。雅加达ORO还支持零宽度先行，所以一个能比得上<tt class="code">/图片/ ...</tt>但使用<tt class="code">（^ /图像（保留尾随<tt class="code">/</tt>输出<tt class="code">？= /））</tt> 。</tt></p><p><tt class="code">
</tt></p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，当前版本的Jakarta ORO不支持向后搜索-即<tt class="code">（？<=…）</tt>或<tt class="code">（？<!--…)</tt gtc:encodedoriginal="PCHigKYpPC90dD4="--> 。
</tt></td></tr>
</tbody></table><tt class="code">
<p></p>
<p>注意重叠的匹配项。例如，在名为<tt class="code">regex</tt>的变量中作为正则表达式的值<tt class="code">。*</tt>将部分匹配先前替换的变量，这将导致类似<tt class="code">$ {{regex}的情况</tt> ，这很可能不是期望的结果。</p><p>如果在将任何变量解释为模式时遇到任何问题，则会在<tt class="code">jmeter.log</tt>中报告这些<tt class="code">问题</tt> ，因此，请确保如果UDV未能按预期工作，请检查此问题。</p><p>记录完测试样本后，请停止代理服务器（单击“ <tt class="code">停止</tt> ”按钮）。切记要重置浏览器的代理设置。现在，您可能想要对测试脚本进行排序和重新排序，添加计时器，侦听器，cookie管理器等。</p><h4>我也如何记录服务器的响应？</h4><p>只需将“ <a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树”</a>侦听器作为HTTP（S）测试脚本记录器的子级放置，就会显示响应。您还可以将“ <a href="../usermanual/component_reference.html#Save_Responses_to_a_file">保存响应”</a>添加<a href="../usermanual/component_reference.html#Save_Responses_to_a_file">到文件</a>后处理器中，这会将响应保存到文件中。
</p><h4>将请求与响应相关联</h4><p>如果定义属性<tt class="code">proxy.number.requests = true，</tt> JMeter将为每个采样器和每个响应添加一个数字。请注意，如果使用了排除或包含，则响应可能比采样器更多。已排除的响应将在<tt class="code">[</tt>和<tt class="code">]中</tt>包含标签<tt class="code">，</tt>例如<tt class="code">[23 /favicon.ico]</tt> 
</p><h4>Cookie经理</h4><p>如果要测试的服务器使用cookie，请在完成记录后记住将<a href="../usermanual/component_reference.html#HTTP_Cookie_Manager">HTTP cookie Manager</a>添加到测试计划中。在记录期间，浏览器会处理所有cookie，但是JMeter需要一个Cookie Manager，以在测试运行期间进行cookie处理。JMeter代理服务器会传递记录期间浏览器发送的所有cookie，但不会将它们保存到测试计划中，因为它们可能在两次运行之间发生变化。
</p><h4>授权经理</h4><p>HTTP（S）测试脚本记录器获取“ <tt class="code">Authentication</tt> ”标头，尝试计算Auth Policy。如果将授权管理器手动添加到目标控制器，则HTTP（S）测试脚本记录器将找到它并添加授权（匹配的授权将被删除）。否则，授权管理器将与授权对象一起添加到目标控制器。录制后，您可能必须修复自动计算的值。

</p><h4>上载档案</h4><p>某些浏览器（例如Firefox和Opera）在上传文件时不包含文件的全名。这可能导致JMeter代理服务器失败。一种解决方案是通过将文件复制到JMeter工作目录中或在包含文件的目录中启动JMeter来确保要上载的任何文件都位于JMeter工作目录中。
</p><h4>记录基于HTTP的非文本协议在JMeter中本地不可用</h4><p>您可能必须记录JMeter默认未处理的HTTP协议（自定义二进制协议，Adobe Flex，Microsoft Silverlight等）。尽管JMeter不提供本地代理实现来记录这些协议，但是您可以通过实现自定义<tt class="code">SamplerCreator</tt>来记录这些协议。这个Sampler Creator将二进制格式转换为<tt class="code">HTTPSamplerBase</tt>子类，该子类可以添加到JMeter测试用例中。有关更多详细信息，请参见“扩展JMeter”。
</p></tt></td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="HTTP_Mirror_Server">18.9.6 HTTP镜像服务器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>HTTP镜像服务器是一个非常简单的HTTP服务器-它仅镜像发送给它的数据。这对于检查HTTP请求的内容很有用。
</p>
<p>它使用默认端口<tt class="code">8081</tt> 。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="794" height="157" src="../images/screenshots/mirrorserver.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>港口</td>
<td>镜像服务器侦听的端口，默认为<tt class="code">8081</tt> 。</td>
<td>是</td>
</tr>
<tr>
<td>最大线程数</td>
<td>如果设置为值> <tt class="code">0时</tt> ，服务请求的线程的数目将被限制在所配置的数目，如果将被创建设置为值<tt class="code">0≤</tt>一个新的线程来服务每个传入请求。默认为<tt class="code">0</tt></td>
<td>没有</td>
</tr>
<tr>
<td>最大队列大小</td>
<td>用于在线程池执行任务之前保留任务的队列的大小，如果超出线程池，传入的请求将保留在此队列中，并在此队列已满时将其丢弃。仅当“最大线程数”大于<tt class="code">0</tt>时才使用此参数。默认为<tt class="code">25</tt></td>
<td>没有</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，您可以通过添加具有以下名称/值对的HTTP标头管理器来更好地控制响应：</td></tr>
</tbody></table>
<p></p>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>X睡眠</td>
<td>发送响应之前的睡眠时间（毫秒）</td>
<td>没有</td>
</tr>
<tr>
<td>X-SetCookie</td>
<td>应响应设置的Cookie</td>
<td>没有</td>
</tr>
<tr>
<td>X-响应状态</td>
<td>响应状态，请参阅<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP状态响应</a> ，例如200 OK，500 Internal Server Error，…。</td>
<td>没有</td>
</tr>
<tr>
<td>X响应长度</td>
<td>响应大小，如果响应大小小于总大小，则将其修整为请求的大小</td>
<td>没有</td>
</tr>
<tr>
<td>X-SetHeaders</td>
<td>管道分隔的标题列表，例如：<br>
 
        <tt class="code">headerA = valueA | headerB = valueB</tt>会将<tt class="code">headerA</tt>设置为<tt class="code">valueA，</tt>而<tt class="code">headerB设置</tt>为<tt class="code">valueB</tt> 。</td>
<td>没有</td>
</tr>
</tbody></table>
<p>您还可以使用以下查询参数：</p><p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>重新导向</td>
<td>使用提供的位置生成302（临时重定向）。例如<tt class="code">？重定向= /路径</tt>
    </td>
<td>没有</td>
</tr>
<tr>
<td>状态</td>
<td>覆盖默认状态返回。例如<tt class="code">？状态= 404找不到</tt></td>
<td>没有</td>
</tr>
<tr>
<td>v</td>
<td>详细标志，将一些详细信息写入标准输出。例如，第一行和重定向位置（如果指定）</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Property_Display">18.9.7属性显示</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>属性显示显示System或JMeter属性的值。可以通过在“值”列中输入新文本来更改值。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="804" height="508" src="../images/screenshots/property_display.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Debug_Sampler">18.9.8调试采样器</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>Debug Sampler会生成一个样本，其中包含所有JMeter变量和/或属性的值。
</p>
<p>可以在“ <a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树</a>侦听器响应数据”窗格中看到这些值。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="431" height="172" src="../images/screenshots/debug_sampler.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>JMeter属性</td>
<td>包括JMeter属性？</td>
<td>是</td>
</tr>
<tr>
<td>JMeter变量</td>
<td>包括JMeter变量吗？</td>
<td>是</td>
</tr>
<tr>
<td>系统属性</td>
<td>包括系统属性？</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Debug_PostProcessor">18.9.8调试PostProcessor</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>Debug PostProcessor将使用先前的Sampler属性，JMeter变量，属性和/或系统属性的详细信息创建一个subSample。
</p>
<p>可以在“ <a href="../usermanual/component_reference.html#View_Results_Tree">查看结果树</a>侦听器响应数据”窗格中看到这些值。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="344" height="193" src="../images/screenshots/debug_postprocessor.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>没有</td>
</tr>
<tr>
<td>JMeter属性</td>
<td>是否显示JMeter属性（默认为<tt class="code">false</tt> ）。</td>
<td>是</td>
</tr>
<tr>
<td>JMeter变量</td>
<td>是否显示JMeter变量（默认为<tt class="code">false</tt> ）。</td>
<td>是</td>
</tr>
<tr>
<td>采样器属性</td>
<td>是否显示Sampler属性（默认为<tt class="code">true</tt> ）。</td>
<td>是</td>
</tr>
<tr>
<td>系统属性</td>
<td>是否显示系统属性（默认为<tt class="code">false</tt> ）。</td>
<td>是</td>
</tr>
</tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="Test_Fragment">18.9.9测试片段</a>
</h3>
</font>
</td></tr>
<tr><td>

<p>测试片段与<a href="../usermanual/component_reference.html#Include_Controller">包含控制器</a>和<a href="../usermanual/component_reference.html#Module_Controller">模块控制器</a>一起使用。
</p>
<p><b>控制面板</b></p>
<div align="center"><img width="236" height="94" src="../images/screenshots/test_fragment.png"></div>
<p>
<b>参量</b>
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tbody><tr><th>属性</th><th>描述</th><th>需要</th></tr>
<tr>
<td>名称</td>
<td>树中显示的此元素的描述性名称。</td>
<td>是</td>
</tr>
</tbody></table>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>将测试片段与<a href="../usermanual/component_reference.html#Module_Controller">模块控制器一起使用时</a> ，请确保禁用测试片段，以避免执行测试片段本身。从JMeter 2.13开始，默认情况下会执行此操作。
</td></tr>
</tbody></table>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="setUp_Thread_Group">18.9.10 setUp线程组</a>
</h3>
</font>
</td></tr>
<tr><td>

    <p>特殊类型的ThreadGroup可用于执行预测试操作。这些线程的行为与普通的“ <a href="../usermanual/component_reference.html#Thread_Group">线程组”</a>元素完全一样。区别在于这些类型的线程在测试进行到常规线程组的执行之前执行。
    </p>
<p><b>控制面板</b></p>
<div align="center"><img width="1252" height="828" src="../images/screenshots/setup_thread_group.png"></div>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<table border="0" cellspacing="0" cellpadding="2">
<tbody><tr><td>
<font face="arial,helvetica,sanserif">
<h3>
<a name="tearDown_Thread_Group">18.9.11 tearDown线程组</a>
</h3>
</font>
</td></tr>
<tr><td>

    <p>特殊类型的ThreadGroup可用于执行测试后操作。这些线程的行为与普通的“ <a href="../usermanual/component_reference.html#Thread_Group">线程组”</a>元素完全一样。区别在于这些类型的线程在测试完成执行其常规线程组之后执行。
    </p>
<p><b>控制面板</b></p>
<div align="center"><img width="1248" height="824" src="../images/screenshots/teardown_thread_group.png"></div>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>请注意，默认情况下，如果正常关闭了Test，它将不会运行，如果要在这种情况下使其运行，请确保选中Test Plan元素上的“在<tt class="code">关闭主线程后运行tearDown线程组</tt> ”选项。如果测试计划已停止，则即使选中该选项，tearDown也不会运行。
</td></tr>
</tbody></table>
<p></p>
<table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td><img width="1130" height="486" src="../images/screenshots/tear_down_on_shutdown.png"><br>
<font size="-1">图1-主线程关闭后运行tearDown线程组</font></td></tr></tbody></table>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<hr>
<a href="#">^</a></blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<br>
<table>
<tbody><tr>
<td bgcolor="#525D76">
<div align="right"><a href="index.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">指数</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="properties_reference.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">下一个</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="boss.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">上一个</font></a></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr><td>
<hr noshade size="1">
</td></tr>
<tr>
<td>
<table width="100%">
<tbody><tr>
<td>
<font color="#525D76" size="-1"><em>版权所有©1999-2019，Apache软件基金会</em></font>
</td>
<td align="right">
<font color="#525D76" size="-1"><em>$ Id $</em></font>
</td>
</tr>
<tr><td colspan="2">
<div align="center"><font color="#525D76" size="-1">Apache，Apache JMeter，JMeter，Apache Feather和Apache JMeter徽标是Apache Software Foundation的商标。
</font>
</div>
</td></tr>
</tbody></table>
</td>
</tr>
</tbody></table>


<!-- end the processing -->














































</body></html>