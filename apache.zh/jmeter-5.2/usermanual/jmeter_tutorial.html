<html ><head></head><body bgcolor="#ffffff"  text="#000000" link="#525D76">﻿
<link rel="stylesheet" type="text/css" href="../../docs/css/style.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" value="JMeter developers">
<meta name="email" value="dev@jmeter.apache.org">

<title>Apache JMeter-如何为JMeter编写插件</title>
<style>
  .code { font-weight: bold; }
</style>



<table border="0" cellspacing="0">
<tbody><tr>
<td align="left">
<a href="http://www.apache.org"><img title="Apache软件基金会" width="261" height="106" src="../../docs/images/asf-logo.png" border="0" style="margin:0px 30px 0px 0px"></a>
</td>
<td align="right">
<a href="http://jmeter.apache.org/"><img width="259" height="88" src="../../docs/images/jmeter.png" alt="Apache JMeter" title="Apache JMeter" border="0"></a>
</td>
</tr>
</tbody></table>
<table border="0" cellspacing="4">
<tbody><tr><td>
<hr noshade size="1">
</td></tr>
<tr>
<td align="left" valign="top">
<table>
<tbody><tr>
<td bgcolor="#525D76">
<div align="right"><a href="index.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">指数</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="jmeter_accesslog_sampler_step_by_step.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">上一个</font></a></div>
</td>
</tr>
</tbody></table>
<br>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#525D76">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="howto"><strong>29。如何为JMeter编写插件</strong></a></font>
</td></tr>
<tr><td>
<blockquote>
<h3>林书豪的介绍</h3><p>用户不止一次地抱怨JMeter的开发人员文档已过时，并且不是很有用。为了使开发人员更容易，我决定编写一个简单的分步教程。当我向Mike提到这一点时，他对本教程应该涵盖的内容有一些想法。
</p><p>在深入学习本教程之前，我想说写插件不一定很容易，即使对于具有几年Java经验的人来说也是如此。我为JMeter编写的第一个扩展是一个简单的实用程序，用于解析HTTP访问日志并生成XML格式的请求。它不是一个真正的插件，因为它是一个独立的命令行实用程序。我的第一个真正的JMeter插件是webservice采样器。我当时正在从事.NET项目，需要对Web服务进行压力测试。大多数用于测试.NET Web服务的商业工具都太费钱了。我决定花几百美元买一个tool脚的测试工具，或者花上几千美元买一个好的工具，我决定为JMeter编写一个插件更容易，更便宜。
</p><p>经过两周的空闲时间编码后，我有了使用Apache Soap驱动程序的可运行原型。我将其提交给JMeter，迈克问我是否要成为提交者。过去，我曾为Jakarta JSTL和tomcat贡献过补丁，因此我感到很荣幸。从那时起，我编写了访问日志采样器，Tomcat 5监视和分布图。从那以后，Mike极大地改进了访问日志采样器，并使其变得更加有用。
</p><h3>Mike Stover的介绍</h3><p>我设计JMeter的主要目标之一是简化编写插件以增强JMeter尽可能多的功能。开源的部分好处是，很多人可能会为改进应用程序而付出努力。我做出了一个明智的决定，就是牺牲代码的一些简单性，以使插件编写成为JMeter开发人员的一种生活方式。
</p><p>虽然有些人已经成功地直接研究了代码并对JMeter进行了改进，但仍然缺少有关如何执行此操作的真正教程。我很久以前就尝试写一些有关它的文档，但是大多数人并不觉得它有用。希望在彼得的帮助下，这种尝试会更加成功。
</p><table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="basic-structure"><strong>29.1 JMeter的基本结构</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>JMeter由协议和功能组织。这样做是为了使开发人员可以为单个协议构建新的jar，而不必构建整个应用程序。在本教程的后面，我们将详细介绍构建JMeter的细节。由于大多数JMeter开发人员都使用eclipse，因此本文将使用eclipse目录作为参考点。
</p><p>根目录- <tt class="code">/ eclipse / workspace / apache-jmeter /</tt>
</p><p><tt class="code">apache-jmeter</tt>内的文件夹
</p><dl>
  <dt><tt class="code">箱子</tt></dt><dd>包含用于启动JMeter的<tt class="code">.bat</tt>和<tt class="code">.sh</tt>文件。它还包含<tt class="code">ApacheJMeter.jar</tt>和属性文件</dd>
  <dt><tt class="code">构建/文档</tt></dt><dd>目录包含JMeter文档文件</dd>
  <dt><tt class="code">临时演员</tt></dt><dd>蚂蚁相关的额外文件</dd>
  <dt><tt class="code">LIB</tt></dt><dd>包含JMeter所需的jar文件</dd>
  <dt><tt class="code">lib / ext</tt></dt><dd>包含JMeter的核心jar文件和协议</dd>
  <dt><tt class="code">src</tt></dt><dd>包含每个协议和组件的子目录</dd>
  <dt><tt class="code">src / * /测试</tt></dt><dd>单元测试相关目录</dd>
  <dt><tt class="code">xdocs</tt></dt><dd>用于文档的XML文件。JMeter从XML生成其文档。</dd>
</dl><p>随着教程的进行，将提供子目录的说明。现在，让我们关注<tt class="code">src</tt>目录。
</p><p><tt class="code">src</tt>内的文件夹
</p><dl>

  <dt><code>宝</code></dt><dd></dd>

  <dt><tt class="code">客户端</tt></dt><dd>基于BeanShell的客户端的代码</dd>
  <dt><tt class="code">螺栓</tt></dt><dd>Bolt协议的代码</dd>
  <dt><tt class="code">组件</tt></dt><dd>包含非协议特定的组件，例如可视化工具，断言等。</dd>

  <dt><code>配置</code></dt><dd>XXX</dd>

  <dt><tt class="code">核心</tt></dt><dd>JMeter的核心代码，包括所有核心接口和抽象类。</dd>
  <dt><tt class="code">dist</tt></dt><dd>构建创建发行版的脚本</dd>
  <dt><tt class="code">远程检查</tt></dt><dd>与测试分发有关的代码。当您要更新生成的源/二进制归档文件的内容时，可以在这里查找</dd>
  <dt><tt class="code">例子</tt></dt><dd>示例采样器，演示如何使用新的bean框架</dd>
  <dt><tt class="code">功能</tt></dt><dd>所有组件使用的标准功能</dd>
  <dt><tt class="code">发电机</tt></dt><dd>代码以生成包含所有元素的测试计划。用于测试分布</dd>
  <dt><tt class="code">乔潘</tt></dt><dd>提供通用实用程序功能的实用程序类</dd>
  <dt><tt class="code">发射器</tt></dt><dd>通过API帮助启动和停止JMeter的代码</dd>
  <dt><tt class="code">执照</tt></dt><dd>包含有关JMeters依赖项中使用的许可证的信息</dd>
  <dt><tt class="code">协议</tt></dt><dd>包含JMeter支持的不同协议</dd>
  <dt><tt class="code">发布</tt></dt><dd>与发布JMeter发行版相关的代码</dd>
  <dt><tt class="code">测试包</tt></dt><dd>测试实用程序代码</dd>
  <dt><tt class="code">测试工具线模拟</tt></dt><dd>使用WireMock进行测试的实用程序代码</dd>
</dl><p>在<tt class="code">协议</tt>目录中，是协议特定的组件。
</p><p><tt class="code">协议</tt>内的文件夹
</p><dl>
  <dt><tt class="code">ftp</tt></dt><dd>ftp服务器负载测试的组件</dd>
  <dt><tt class="code">http</tt></dt><dd>Web服务器负载测试的组件</dd>
  <dt><tt class="code">爪哇</tt></dt><dd>用于测试Java组件的组件</dd>
  <dt><tt class="code">数据库</tt></dt><dd>使用JDBC对数据库服务器进行负载测试的组件</dd>
  <dt><tt class="code">简讯</tt></dt><dd>用于负载测试JMS服务器的组件</dd>
  <dt><tt class="code">unit</tt></dt><dd>使用JUnit测试进行负载测试的组件</dd>
  <dt><tt class="code">样本</tt></dt><dd>基于JUnit的测试实现的示例</dd>
  <dt><tt class="code">ldap</tt></dt><dd>用于负载测试LDAP服务器的组件</dd>
  <dt><tt class="code">邮件</tt></dt><dd>用于负载测试邮件服务器的组件</dd>
  <dt><tt class="code">本机</tt></dt><dd>用于负载测试OS本机命令的组件</dd>
  <dt><tt class="code">tcp</tt></dt><dd>用于负载测试TCP服务的组件</dd>
</dl><p>通常，与HTTP相关的所有采样器都位于<tt class="code">http</tt>目录中。规则的例外是Tomcat5监视器。它是独立的，因为监视器的功能与压力或功能测试略有不同。最终可能会对其进行重组，但现在它位于其自己的目录中。就难度而言，编写可视化工具可能是编写难度较大的插件之一。
</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="testelement-contract"><strong>29.2 JMeter Gui – TestElement合同</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>编写任何JMeter组件时，您必须了解某些约定-如果JMeter组件可以在JMeter环境中正常运行，则期望其行为方式。本节描述了组件的GUI部分必须遵守的合同。
</p><p>JMeter中的GUI代码与测试元素代码严格分开。因此，在编写组件时，将有一个用于Test Element的类，另一个用于GUI演示的类。GUI表示类在从不应该挂在对测试元素的引用上的意义上说是无状态的（尽管这是例外）。
</p><p>GUI元素应扩展提供的适当抽象类：</p><ul>
  <li><tt class="code">抽象采样器</tt></li>
  <li><tt class="code">抽象断言</tt></li>
  <li><tt class="code">抽象配置</tt></li>
  <li><tt class="code">抽象控制器</tt></li>
  <li><tt class="code">抽象后处理器</tt></li>
  <li><tt class="code">抽象预处理器</tt></li>
  <li><tt class="code">抽象可视化器</tt></li>
  <li><tt class="code">抽象计时器</tt></li>
</ul><p>这些抽象类为您提供了很多管道工作，因此您不对其进行扩展，而直接实现接口几乎是一种选择。如果您迫切需要不扩展这些类，则可以加入IRC，在其他方面我可以说服您:-)。
</p><p>因此，您已经扩展了适当的GUI类，剩下要做的是什么？跟着这些步骤：</p><ol>
  <li>实现<tt class="code">getLabelResource（）</tt>
    <ol>
      <li>此方法应返回代表组件标题/名称的资源名称。该资源将必须输入到JMeters <tt class="code">messages.properties</tt>文件中（以及可能的翻译中）。</li>
    </ol>
  </li>
  <li>创建您的GUI。无论您喜欢哪种样式，都可以布局GUI。您的类最终会扩展<tt class="code">JPanel</tt> ，因此您的布局必须在类自己的<tt class="code">ContentPane中</tt> 。不要通过操作和事件将GUI元素连接到<tt class="code">TestElement</tt>类。让swing的内部模型尽可能多地挂在所有数据上。
    <ol>
      <li>一些标准的GUI内容应添加到所有JMeter GUI组件中：<ol>
          <li>为您的类调用<tt class="code">setBorder（makeBorder（））</tt> 。这将为它提供标准的JMeter边框</li>
          <li>通过<tt class="code">makeTitlePanel（）</tt>添加标题窗格。通常，这是添加到GUI的第一件事，应该在Box垂直布局方案中完成，或者与JMeter的<tt class="code">VerticalLayout</tt>类一起完成。这是一个示例<tt class="code">init（）</tt>方法：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
private void init() {
    setLayout(new BorderLayout());
    setBorder(makeBorder());
    Box box = Box.createVerticalBox();
    box.add(makeTitlePanel());
    box.add(makeSourcePanel());
    add(box,BorderLayout.NORTH);
    add(makeParameterPanel(),BorderLayout.CENTER);
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>实现<tt class="code">public void configure（TestElement el）</tt>
    <ol>
      <li>确保调用<tt class="code">super.configure（e）</tt> 。这将为您填充一些数据，例如元素的名称。</li>
      <li>使用此方法将数据设置到GUI元素中。例：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public void configure(TestElement el) {
    super.configure(el);
    useHeaders.setSelected(
            el.getPropertyAsBoolean(RegexExtractor.USEHEADERS));
    useBody.setSelected(
            !el.getPropertyAsBoolean(RegexExtractor.USEHEADERS));
    regexField.setText(
            el.getPropertyAsString(RegexExtractor.REGEX));
    templateField.setText(
            el.getPropertyAsString(RegexExtractor.TEMPLATE));
    defaultField.setText(
            el.getPropertyAsString(RegexExtractor.DEFAULT));
    matchNumberField.setText(
            el.getPropertyAsString(RegexExtractor.MATCH_NUM));
    refNameField.setText(
            el.getPropertyAsString(RegexExtractor.REFNAME));
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

      </li>
      <li>实现<tt class="code">public void ModifyTestElement（TestElement e）</tt> 。在这里，您可以将数据从GUI元素移至<tt class="code">TestElement</tt> 。这与先前方法在逻辑上相反。
         <ol>
           <li>调用<tt class="code">super.configureTestElement（e）</tt> 。这将为您处理一些默认数据。</li>
           <li>例：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public void modifyTestElement(TestElement e) {
    super.configureTestElement(e);
    e.setProperty(new BooleanProperty(
            RegexExtractor.USEHEADERS,
            useHeaders.isSelected()));
    e.setProperty(RegexExtractor.MATCH_NUMBER,
            matchNumberField.getText());
    if (e instanceof RegexExtractor) {
        RegexExtractor regex = (RegexExtractor)e;
        regex.setRefName(refNameField.getText());
        regex.setRegex(regexField.getText());
        regex.setTemplate(templateField.getText());
        regex.setDefaultValue(defaultField.getText());
    }
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

           </li>
         </ol>
       </li>
       <li>实现<tt class="code">公共TestElement createTestElement（）</tt> 。此方法应该创建您的<tt class="code">TestElement</tt>类的新实例，然后将其传递给您在上面<tt class="code">创建</tt>的<tt class="code">ModifyTestElement（TestElement）</tt>方法<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public TestElement createTestElement() {
    RegexExtractor extractor = new RegexExtractor();
    modifyTestElement(extractor);
    return extractor;
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

       </li>
    </ol>
  </li>
</ol><p>之所以不能保留对测试元素的引用，是因为JMeter将GUI类对象的实例重用于多个测试元素。这样可以节省大量内存。它还使编写新组件的GUI部分变得异常容易。您仍然必须为Swing中的布局而苦恼，但是不必担心创建正确的事件和操作来将数据从GUI元素导入到<tt class="code">TestElement中</tt> ，这可以起到一定作用。JMeter知道何时调用您的configure和<tt class="code">ModifyTestElement</tt>方法，您可以在其中以非常简单的方式进行操作。
</p><p>但是，编写Visualizer有点特殊情况。
</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="visualizer"><strong>29.3编写可视化工具</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>在GUI模式下进行负载测试是一种不好的做法，您不应开发此类插件。看看更多最新的组件，例如：<ul>
<li><a href="generating-dashboard.html">网络报告</a></li>
<li><a href="../api/org/apache/jmeter/visualizers/backend/BackendListenerClient.html">BackendListenerClient的</a> <a href="realtime-results.html">实时结果</a></li>
</ul>
</td></tr>
</tbody></table>
<p></p>
<p>在组件类型中，可视化工具比诸如控制器，功能或采样器之类的东西在Swing中需要更大的深度。您可以在<tt class="code">components / org / apache / jmeter / visualizers /中</tt>找到分布图的完整来源。分布图可视化器分为两类。
</p><dl>
  <dt><tt class="code">DistributionGraphVisualizer</tt></dt><dd>JMeter实例化的可视化工具</dd>
  <dt><tt class="code">分布图</tt></dt><dd>绘制实际图形的JComponent</dd>
</dl><p>编写可视化工具的最简单方法是执行以下操作：</p><ol>
  <li>扩展<tt class="code">org.apache.jmeter.visualizers.gui。抽象可视化器</tt></li>
  <li>实现回调和事件通知所需的任何其他接口。例如， <tt class="code">DistributionGraphVisualizer</tt>实现以下接口：<ul>
       <li><tt class="code">ImageVisualizer</tt></li>
       <li><tt class="code">ItemListener</tt> –根据类中的注释， <tt class="code">ItemListener</tt>已过时且不再使用。</li>
       <li><tt class="code">GraphListener</tt></li>
       <li><tt class="code">可清除</tt></li>
     </ul>
   </li>
</ol><p>
<tt class="code">AbstractVisualizer</tt>提供了一些常用功能，例如<tt class="code">Graph Results</tt>等大多数可视化工具都使用。抽象类提供的常见功能包括：</p><ul>
  <li>配置测试元素–这意味着它将创建一个新的<tt class="code">ResultCollector</tt> ，设置文件并设置错误日志</li>
  <li>创建库存菜单</li>
  <li>进行更改时更新测试元素</li>
  <li>为日志文件创建文件面板</li>
  <li>创建标题面板</li>
</ul><p>在某些情况下，您可能不想显示文件文本框的菜单。在这种情况下，您可以覆盖<tt class="code">init（）</tt>方法。这是<tt class="code">DistributionGraphVisualizer</tt>的实现。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
/**
 * Initialize the GUI.
 */
private void init() {
    this.setLayout(new BorderLayout());

    // MAIN PANEL
    Border margin = new EmptyBorder(10, 10, 5, 10);
    this.setBorder(margin);

    // Set up the graph with header, footer, Y axis and graph display
    JPanel graphPanel = new JPanel(new BorderLayout());
    graphPanel.add(createGraphPanel(), BorderLayout.CENTER);
    graphPanel.add(createGraphInfoPanel(), BorderLayout.SOUTH);

    // Add the main panel and the graph
    this.add(makeTitlePanel(), BorderLayout.NORTH);
    this.add(graphPanel, BorderLayout.CENTER);
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p><tt class="code">init</tt>方法要做的第一件事是创建一个新的<tt class="code">BorderLayout</tt> 。根据您要布局小部件的方式，您可能需要使用其他布局管理器。请记住，为专家使用不同的布局管理器。
</p><p><tt class="code">初始化</tt>方法要做的第二件事是创建边框。如果要增加或减少边框，请更改四个整数值。每个整数值代表像素。如果希望可视化器没有边框，请跳过第8和9行。第13行调用<tt class="code">createGraphPanel</tt> ，它负责配置<tt class="code">DistributionGraph</tt>并将其添加到可视化工具。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
private Component createGraphPanel() {
    graphPanel = new JPanel();
    graphPanel.setBorder(BorderFactory.createBevelBorder(
    BevelBorder.LOWERED,Color.lightGray,Color.darkGray));
    graphPanel.add(graph);
    graphPanel.setBackground(Color.white);
    return graphPanel;
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>在第5行，将图形组件添加到图形面板。构造函数是在其中创建<tt class="code">DistributionGraph</tt>新实例的地方。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public DistributionGraphVisualizer() {
    model = new SamplingStatCalculator(&quot;Distribution&quot;);
    graph = new DistributionGraph(model);
    graph.setBackground(Color.white);
    init();
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p><tt class="code">DistributionGraphVisualizer</tt>的构造函数负责创建模型和图形。每当新结果完成时，引擎就会通过调用<tt class="code">add（SampleResult res）</tt>将结果传递给所有侦听器。可视化工具将新的<tt class="code">SampleResult</tt>传递给模型。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public synchronized void add(SampleResult res) {
    model.addSample(res);
    updateGui(model.getCurrentSample());
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>在<tt class="code">DistributionGraphVisualizer</tt>的情况下， <tt class="code">add</tt>方法实际上并不更新图形。而是在第三行中调用<tt class="code">updateGui</tt> 。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public synchronized void updateGui(Sample s) {
    // We have received one more sample
    if (delay == counter) {
        updateGui();
        counter = 0;
    } else {
        counter++;
    }
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>与<tt class="code">GraphVisualizer</tt>不同，分布图试图显示结果如何聚集；因此<tt class="code">DistributionGraphVisualizer会</tt>延迟更新。默认延迟为<tt class="code">10个</tt>样本结果。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public synchronized void updateGui() {
    if (graph.getWidth() &lt; 10) {
        graph.setPreferredSize(
                new Dimension(getWidth() - 40,
                getHeight() - 160));
    }
    graphPanel.updateUI();
    graph.repaint();
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>如果用户调整窗口大小或拖动分隔线，则假定第2至3行会调整图形的大小。第7行更新包含图形的面板。第8行触发了<tt class="code">DistributionGraph</tt>的更新。在介绍书写图形之前，必须有两个重要的可视化工具实现方法。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public String getLabelResource() {
    return &quot;distribution_graph_title&quot;;
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>标签资源从属性文件中检索可视化器的名称。该文件位于<tt class="code">core / org / apache / jmeter / resources中</tt> 。最好不要对可视化工具的名称进行硬编码。
<tt class="code">Message.properties</tt>文件是按字母顺序组织的，因此添加新条目很容易。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public synchronized void clear() {
    this.graph.clear();
    model.clear();
    repaint();
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>JMeter中的每个组件都应实现<tt class="code">clear（）</tt>方法的逻辑。如果不这样做，则当用户尝试清除最后的结果并运行新的测试时，组件将不会清除UI或模型。如果未实现清除，则可能导致内存泄漏。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public JComponent getPrintableComponent() {
    return this.graphPanel;
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>可视化工具应该实现的最后一个方法是<tt class="code">getPrintableComponent（）</tt> 。该方法负责返回可以保存或打印的JComponent。最近添加了此功能，以便用户可以保存任何给定可视化工具的屏幕截图。
</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="graphlistener"><strong>29.4 GraphListener</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>在GUI模式下进行负载测试是一种不好的做法，您不应开发此类插件。看看更多最新的组件，例如：<ul>
<li><a href="generating-dashboard.html">网络报告</a></li>
<li><a href="../api/org/apache/jmeter/visualizers/backend/BackendListenerClient.html">BackendListenerClient的</a> <a href="realtime-results.html">实时结果</a></li>
</ul>
</td></tr>
</tbody></table>
<p></p>
<p>可视化工具应实现<tt class="code">GraphListener</tt> 。这样做是为了简化将新的Sample实例添加到侦听器的过程。通常，如果自定义图形未绘制每个样本，则不需要实现该接口。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public interface GraphListener {
    public void updateGui(Sample s);
    public void updateGui();
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>接口中的重要方法是<tt class="code">updateGui（Sample s）</tt> 。从<tt class="code">DistributionGraphVisualizer中</tt> ，我们看到它调用<tt class="code">graph.repaint（）</tt>刷新图。在大多数情况下， <tt class="code">updateGui（Sample s）的实现</tt>应该做到这一点。
<tt class="code">ItemListenerVisualizers</tt>通常不需要实现此接口。该界面与组合框，复选框和列表一起使用。如果可视化工具使用其中之一，并且需要知道何时更新，则可视化工具将需要实现该接口。有关如何实现该接口的示例，请查看<tt class="code">GraphVisualizer</tt> 。
</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="custom-graphs"><strong>29.5编写自定义图</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>
</p><table border="1" bgcolor="#bbbb00" width="50%" cellspacing="0" cellpadding="2">
<tbody><tr><td>在GUI模式下进行负载测试是一种不好的做法，您不应开发此类插件。看看更多最新的组件，例如：<ul>
<li><a href="generating-dashboard.html">网络报告</a></li>
<li><a href="../api/org/apache/jmeter/visualizers/backend/BackendListenerClient.html">BackendListenerClient的</a> <a href="realtime-results.html">实时结果</a></li>
</ul>
</td></tr>
</tbody></table>
<p></p>
<p>对于那些刚接触Swing且尚未编写自定义JComponents的人，我建议您买一本有关Swing的书，并对Swing小部件的工作方式有一个很好的了解。本教程将不会尝试解释Swing的基本概念，并假定读者已经熟悉Swing API和MVC（模型视图控制器）设计模式。从<tt class="code">DistributionGraphVisualizer</tt>的构造函数中，我们看到使用该模型的实例创建了一个<tt class="code">DistributionGraph</tt>的新实例。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public DistributionGraph(SamplingStatCalculator model) {
    this();
    setModel(model);
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p><tt class="code">setModel</tt>方法的实现很简单。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
private void setModel(Object model) {
    this.model = (SamplingStatCalculator) model;
    repaint();
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>请注意，该方法在设置模型后会调用<tt class="code">repaint</tt> 。如果未调用<tt class="code">重绘</tt> ，则可能导致GUI无法绘制图形。一旦测试开始，图形将重绘，因此调用<tt class="code">重绘</tt>并不重要。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
public void paintComponent(Graphics g) {
    super.paintComponent(g);
    final SamplingStatCalculator m = this.model;
    synchronized (m) {
        drawSample(m, g);
    }
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>更新窗口小部件的另一个重要方面是<tt class="code">将对drawSample</tt>的调用放在一个同步块中。如果<tt class="code">drawSample</tt>不同步，则JMeter将在运行时引发<tt class="code">ConcurrentModificationException</tt> 。根据测试计划，可能会有十几个或更多线程将结果添加到模型中。同步块不会影响每个单独请求和时间测量的准确性，但会影响JMeter生成大负载的能力。随着测试计划中线程数量的增加，在开始新请求之前，线程必须等待直到完成图形重绘的可能性才增加。这是<tt class="code">drawSample</tt>的实现。
</p><div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
private void drawSample(SamplingStatCalculator model, Graphics g) {
    width = getWidth();
    double height = (double)getHeight() - 1.0;

    // first lets draw the grid
    for (int y=0; y &lt; 4; y++){
        int q1 = (int)(height - (height * 0.25 * y));
        g.setColor(Color.lightGray);
        g.drawLine(xborder,q1,width,q1);
        g.setColor(Color.black);
        g.drawString(String.valueOf((25 * y) + &quot;%&quot;),0,q1);
    }
    g.setColor(Color.black);
    // draw the X axis
    g.drawLine(xborder,(int)height,width,(int)height);
    // draw the Y axis
    g.drawLine(xborder,0,xborder,(int)height);
    // the test plan has to have more than 200 samples
    // for it to generate half way decent distribution
    // graph. The larger the sample, the better the
    // results.
    if (model != null &amp;&amp; model.getCount() &gt; 50) {
        // now draw the bar chart
        Number ninety = model.getPercentPoint(0.90);
        Number fifty = model.getPercentPoint(0.50);
        total = model.getCount();
        Collection values = model.getDistribution().values();
        Object[] objval = new Object[values.size()];
        objval = values.toArray(objval);
        // we sort the objects
        Arrays.sort(objval,new NumberComparator());
        int len = objval.length;
        for (int count=0; count &lt; len; count++) {
            // calculate the height
            Number[] num = (Number[])objval[count];
            double iper = (double)num[1].intValue() / (double)total;
            double iheight = height * iper;
            // if the height is less than one, we set it
            // to one pixel
            if (iheight &lt; 1) {
                iheight = 1.0;
            }
            int ix = (count * 4) + xborder + 5;
            int dheight = (int)(height - iheight);
            g.setColor(Color.blue);
            g.drawLine(ix -1,(int)height,ix -1,dheight);
            g.drawLine(ix,(int)height,ix,dheight);
            g.setColor(Color.black);
            // draw a red line for 90% point
            if (num[0].longValue() == ninety.longValue()) {
                g.setColor(Color.red);
                g.drawLine(ix,(int)height,ix,55);
                g.drawLine(ix,(int)35,ix,0);
                g.drawString(&quot;90%&quot;,ix - 30,20);
                g.drawString(
                        String.valueOf(num[0].longValue()),
                        ix + 8, 20);
            }
            // draw an orange line for 50% point
            if (num[0].longValue() == fifty.longValue()) {
                g.setColor(Color.orange);
                g.drawLine(ix,(int)height,ix,30);
                g.drawString(&quot;50%&quot;,ix - 30,50);
                g.drawString(
                        String.valueOf(num[0].longValue()),
                        ix + 8, 50);
            }
        }
    }
}
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>
<p>通常，图形的呈现应该相当快，并且不应该成为瓶颈。通常，配置自定义插件是一个好主意。确保可视化工具不是瓶颈的唯一方法是使用Borland OptimizeIt之类的工具运行它。测试插件的一种好方法是创建一个简单的测试计划并运行它。堆和垃圾回收行为应该是定期且可预测的。
</p></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="testbean"><strong>29.6为JMeter制作TestBean插件</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>在这一部分中，我们将完成使用新的<tt class="code">TestBean</tt>框架为JMeter创建简单组件的过程。
</p><p>该组件将是CSV文件读取元素，它使用户可以使用CSV文件轻松更改其输入数据。为了最有效地使用本教程，请打开下面指定的三个文件（位于JMeter的<tt class="code">src / components</tt>目录中）。
</p><ol>
  <li>选择一个包并制作三个文件：<ul>
      <li>[ComponentName] .java（org.apache.jmeter.config。CSVDataSet.java）</li>
      <li>[ComponentName] BeanInfo.java（org.apache.jmeter.config。CSVDataSetBeanInfo.java）</li>
      <li>[ComponentName] Resources.properties（org.apache.jmeter.config。CSVDataSetResources.properties）</li>
    </ul>
  </li>
  <li><tt class="code">CSVDataSet.java</tt>必须实现<tt class="code">TestBean</tt>接口。另外，它将扩展<tt class="code">ConfigTestElement</tt>并实现<tt class="code">LoopIterationListener</tt> 。
    <ul>
      <li><tt class="code">TestBean</tt>是标记接口，因此没有实现方法。</li>
      <li>扩展<tt class="code">ConfigTestElement</tt>将使我们的组件成为测试计划中的<tt class="code">Config</tt>元素。通过扩展不同的抽象类，您可以控制组件的元素类型（即<tt class="code">AbstractSampler</tt> ， <tt class="code">AbstractVisualizer</tt> ， <tt class="code">GenericController</tt>等），尽管您也可以通过实例化正确的接口来制作不同类型的元素，抽象类可以使您的生活更美好更轻松）。
      </li>
    </ul>
  </li>
  <li><tt class="code">CSVDataSetBeanInfo.java</tt>应该扩展<tt class="code">org.apache.jmeter.testbeans。BeanInfoSupport</tt>
    <ul>
      <li>创建一个零参数构造函数，在其中我们称为<tt class="code">super（CSVDataSet.class）;</tt></li>
      <li>我们将回到这一点。</li>
    </ul>
  </li>
  <li><tt class="code">CSVDataSetResources.properties-</tt>目前为空白</li>
  <li>为您的插件类实现特殊的逻辑。
    <ol>
      <li><tt class="code">CSVDataSet</tt>将读取一个CSV文件，并将找到的值存储到JMeter的运行上下文中。用户将定义文件，为每个“ <tt class="code">列</tt> ”定义变量名。<tt class="code">CSVDataSet</tt>将在测试开始时打开文件，并在测试结束时关闭文件（因此我们实现了<tt class="code">TestListener</tt> ）。<tt class="code">CSVDataSet</tt>将通过读取文件中的新行来更新每个测试线程以及通过其父控制器进行的每次迭代的变量内容。当我们到达文件末尾时，我们将从头开始。在实现<tt class="code">TestBean时</tt> ，请特别注意您的属性。这些属性将成为GUI表单的基础，用户可以通过它配置<tt class="code">CSVDataSet</tt>元素。
      </li>
      <li>测试开始时，JMeter将克隆您的元素。每个线程将获得它自己的实例。但是，如果需要，您将有机会控制克隆的完成方式。
      </li>
      <li>属性： <tt class="code">filename</tt> ， <tt class="code">variableNames</tt> 。与公众获取者和二传手。
        <ul>
          <li><tt class="code">filename</tt>是不言自明的，它将保存我们将读取的CSV文件的名称</li>
          <li><tt class="code">variableNames</tt>是一个字符串，它将允许用户输入将为其分配值的变量的名称。为什么是弦乐？为什么不收藏？用户肯定会需要输入多个（未知数量）变量名吗？的确如此，但是如果我们使用列表或集合，则必须编写一个GUI组件来处理集合，而我只是想快速地做到这一点。相反，我们将让用户输入以逗号分隔的变量名称列表。</li>
        </ul>
      </li>
      <li>然后，我实现了<tt class="code">LoopIterationListener</tt>接口的<tt class="code">IterationStart</tt>方法。该“事件”的意义在于，当测试进入其父控制器时，将通知您的组件。出于我们的目的，每次输入<tt class="code">CSVDataSet</tt>的父控制器时，我们都会读取数据文件的新行并设置变量。因此，对于常规控制器，通过测试的每个循环将导致读取一组新的值。对于循环控制器，每次迭代都将这样做。每个测试线程也会获得不同的值。
      </li>
    </ol>
  </li>
  <li>在<tt class="code">CSVDataSetBeanInfo中</tt>设置您的GUI元素：<ul>
      <li>您可以为组件的属性创建分组。您创建的每个分组都需要一个标签和一个属性名称列表才能包含在该分组中。即：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
createPropertyGroup(&quot;csv_data&quot;,
        new String[] { &quot;filename&quot;, &quot;variableNames&quot; });
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>

      </li>
      <li>创建分组称为<tt class="code">csv_data，</tt>其中将包括作为<tt class="code">文件名</tt>的GUI输入元件和<tt class="code">CSVDataSet</tt>的<tt class="code">variableNames</tt>性质。然后，我们需要定义我们希望这些属性为哪种类型：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
p = property(&quot;filename&quot;);
p.setValue(NOT_UNDEFINED, Boolean.TRUE);
p.setValue(DEFAULT, &quot;&quot;);
p.setValue(NOT_EXPRESSION, Boolean.TRUE);

p = property(&quot;variableNames&quot;);
p.setValue(NOT_UNDEFINED, Boolean.TRUE);
p.setValue(DEFAULT, &quot;&quot;);
p.setValue(NOT_EXPRESSION, Boolean.TRUE);
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>这实际上创建了两个属性，这些属性的值不允许为<tt class="code">null</tt> ，其默认值为<tt class="code">“”</tt> 。可以为每个属性设置几个这样的属性。这是一个概要：<dl>
          <dt><tt class="code">NOT_UNDEFINED</tt></dt><dd>该属性不会保留为<tt class="code">null</tt> 。</dd>
          <dt><tt class="code">默认</tt></dt><dd>如果<tt class="code">NOT_UNDEFINED</tt>为<tt class="code">true，</tt>则必须提供默认值。</dd>
          <dt><tt class="code">NOT_EXPRESSION</tt></dt><dd>如果为<tt class="code">true，</tt>则不会为函数解析该值。</dd>
          <dt><tt class="code">NOT_OTHER</tt></dt><dd>这不是自由格式的输入字段-必须提供值列表。</dd>
          <dt><tt class="code">标签</tt></dt><dd>使用<tt class="code">String []</tt>作为值，这将设置可接受的值的预定义列表，JMeter将创建一个下拉选择。</dd>
        </dl>此外，可以为属性指定自定义属性编辑器：<div align="left">
<table cellspacing="4" cellpadding="0" border="0">
<tbody><tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#ffffff"><pre>
p.setPropertyEditorClass(FileEditor.class);
</pre></td>
<td bgcolor="#023264" width="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
<tr>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
<td bgcolor="#023264" width="1" height="1"><img src="/images/void.gif" width="1" height="1" vspace="0" hspace="0" border="0"></td>
</tr>
</tbody></table>
</div>这将创建一个文本输入加浏览按钮，该按钮将打开一个用于查找文件的对话框。通常，像现在一样，不需要复杂的属性设置。有关更复杂的示例，请参见<tt class="code">org.apache.jmeter.protocol.http.sampler。AccessLogSamplerBeanInfo</tt>
      </li>
    </ul>
  </li>
  <li>定义您的资源字符串。在<tt class="code">CSVDataSetResources.properties中，</tt>我们必须定义所有字符串资源。为了提供翻译，可以创建其他文件，例如<tt class="code">CSVDataSetResources_ja.properties</tt>和<tt class="code">CSVDataSetResources_de.properties</tt> 。对于我们的组件，我们必须定义以下资源：<dl>
      <dt><tt class="code">显示名称</tt></dt><dd>这将为将出现在菜单中的元素提供一个名称。</dd>
      <dt><tt class="code">csv_data.displayName</tt></dt><dd>我们创建了一个名为<tt class="code">csv_data</tt>的属性分组，因此我们必须为分组提供标签</dd>
      <dt><tt class="code">filename.displayName</tt></dt><dd>文件名输入元素的标签。</dd>
      <dt><tt class="code">filename.short描述</tt></dt><dd>类似于工具提示的帮助文本框。</dd>
      <dt><tt class="code">variableNames.displayName</tt></dt><dd>变量名称输入元素的标签。</dd>
      <dt><tt class="code">variableNames.shortDescription</tt></dt><dd><tt class="code">variableNames</tt>输入元素的工具提示。</dd>
    </dl>
  </li>
  <li>调试您的组件。</li>
</ol></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
<tbody><tr><td bgcolor="#828DA6">
<font color="#ffffff" face="arial,helvetica,sanserif">
<a name="building"><strong>29.6建筑JMeter</strong></a>
</font>
</td></tr>
<tr><td>
<blockquote>
<p>JMeter使用Gradle编译和构建发行版。JMeter定义了多个任务，这使开发人员可以更轻松地构建完整的项目。对于不熟悉Gradle的人来说，它是一个类似于Unix上的make工具。<a href="https://github.com/apache/jmeter/blob/master/gradle.md">gradle.md</a>提供了Gradle任务的简短说明<a href="https://github.com/apache/jmeter/blob/master/gradle.md">列表</a> ，可以在根源目录中找到该列表。
</p><p>这是一些示例命令。
</p><dl>
  <dt><tt class="code">./gradlew runGui</tt></dt><dd>构建并启动JMeter GUI</dd>
  <dt><tt class="code">./gradlew createDist</tt></dt><dd>生成项目并将相关的jar文件复制到<tt class="code">./lib</tt>文件夹</dd>
  <dt><tt class="code">./gradlew：src：dist：previewSite</tt></dt><dd>创建网站预览到<tt class="code">./build/docs/site</tt></dd>
</dl></blockquote>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
</blockquote>
<p></p>
</td></tr>
<tr><td><br></td></tr>
</tbody></table>
<br>
<table>
<tbody><tr>
<td bgcolor="#525D76">
<div align="right"><a href="index.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">指数</font></a></div>
</td>
<td bgcolor="#525D76">
<div align="right"><a href="jmeter_accesslog_sampler_step_by_step.html"><font size="-1" color="#ffffff" face="arial,helvetica,sanserif">上一个</font></a></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr><td>
<hr noshade size="1">
</td></tr>
<tr>
<td>
<table width="100%">
<tbody><tr>
<td>
<font color="#525D76" size="-1"><em>版权所有©1999-2019，Apache软件基金会</em></font>
</td>
<td align="right">
<font color="#525D76" size="-1"><em>$ Id $</em></font>
</td>
</tr>
<tr><td colspan="2">
<div align="center"><font color="#525D76" size="-1">Apache，Apache JMeter，JMeter，Apache Feather和Apache JMeter徽标是Apache Software Foundation的商标。
</font>
</div>
</td></tr>
</tbody></table>
</td>
</tr>
</tbody></table>


<!-- end the processing -->














































</body></html>