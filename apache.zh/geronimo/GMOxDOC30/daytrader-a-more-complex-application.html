<html lang="zh-Hans" ><head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="asset?aid=0">
    <link rel="SHORTCUT ICON" href="http://geronimo.apache.org/images/favicon.ico">
    <link rel="schema.DC" href="http://purl.org/DC/elements/1.0/">
    <meta name="Description" content="daytrader - a more complex application">
    <meta name="Keywords" content="Apache Geronimo 3.0 Documentation JavaEE6 OSGi daytrader - a more complex application">
    <meta name="Owner" content="dev@geronimo.apache.org">
    <meta name="Robots" content="index, follow">
    <meta name="Security" content="Public">
    <meta name="Source" content="wiki template">
    <meta name="DC.Date" scheme="iso8601" content="2010-05-11">
    <meta name="DC.Language" scheme="rfc1766" content="en">
    <meta name="DC.Rights" content="Copyright Â© 2003-2013, The Apache Software Foundation">
    <meta http-equiv="PICS-Label" content="(PICS-1.1 " http:="" ="" www.icra.org="" ratingsv02.htm="=" www.rsac.org="" ratingsv01.htm="=" (ss~~000="" 1)="=">

    <script src="http://geronimo.apache.org/functions.js" type="text/javascript"></script>


    <title>Apache Geronimo v3.0文档：daytrader-一个更复杂的应用程序</title>
  </head>

  <body  onload="init()">

        <!-- banner -->
    <table valign="top" border="0" cellspacing="0" cellpadding="0" width="100%" background="http://geronimo.apache.org/images/top_bgstretch_1x64.gif">
      <tbody><tr>
        <td align="left" valing="top">
          <img src="http://geronimo.apache.org/images/topleft_logo_437x64.gif" border="0">
        </td>
      </tr>
    </tbody></table>

        <!-- topNav -->
    <table border="0" cellpadding="2" cellspacing="0" width="100%">
      <tbody><tr class="topBar">
        <td align="left" valign="middle" class="topBarDiv" nowrap>
          <a href="/geronimo">Home</a> > <a href="documentation.html">文档</a> > <a href="reference.html">参考</a> > <a href="samples.html">示例</a> > <a href="java-ee-sample-applications.html">Java EE示例应用程序</a> > <a href="daytrader-a-more-complex-application.html">daytrader-一个更复杂的应用程序</a>
        </td>
        <td align="right" valign="middle" nowrap>
          <form name="search" action="http://www.google.com/search" method="get">
            <input type="hidden" name="ie" value="UTF-8">
            <input type="hidden" name="oe" value="UTF-8">
            <input type="hidden" name="domains" value="">
            <input type="hidden" name="sitesearch" value="">
            <input type="text" name="q" value="" maxlength="255">        
            <input type="submit" name="btnG" value="谷歌搜索">
          </form>
        </td>
      </tr> 
    </tbody></table>

        <!-- pageContent -->
    <div id="PageContent">
      <div class="pageheader" style="padding:6px 0px 0px 0px">
        <!-- We'll enable this once we figure out how to access (and save) the logo resource -->
        <!--img src="http://geronimo.apache.org/images/confluence_logo.gif" style="float: left; margin: 4px 4px 4px 10px;" border="0"-->
        <div class="smalltext" style="margin:0px 10px 0px 10px">Apache Geronimo v3.0</div>
        <div class="pagetitle" style="margin:0px 10px 8px 10px">daytrader-更复杂的应用程序</div>

        <div class="greynavbar" align="right" style="padding:2px 10px;margin:0px">
<!-- --> <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=20645374"><img src="http://geronimo.apache.org/images/icons/notep_16.gif" height="16" width="16" border="0" title="编辑页面"></a> <a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=20645374">编辑页面</a> <a href="https://cwiki.apache.org/confluence/pages/listpages.action?key=GMOxDOC30"><img src="http://geronimo.apache.org/images/icons/browse_space.gif" height="16" width="16" border="0" title="浏览空间"></a> <a href="https://cwiki.apache.org/confluence/pages/listpages.action?key=GMOxDOC30">浏览空间</a> <a href="https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=GMOxDOC30&fromPageId=20645374"><img src="http://geronimo.apache.org/images/icons/add_page_16.gif" height="16" width="16" border="0" title="添加页面"></a> <a href="https://cwiki.apache.org/confluence/pages/createpage.action?spaceKey=GMOxDOC30&fromPageId=20645374">添加页面</a> <a href="https://cwiki.apache.org/confluence/pages/createblogpost.action?spaceKey=GMOxDOC30&fromPageId=20645374"><img src="http://geronimo.apache.org/images/icons/add_blogentry_16.gif" height="16" width="16" border="0" title="新增新闻"></a> <a href="https://cwiki.apache.org/confluence/pages/createblogpost.action?spaceKey=GMOxDOC30&fromPageId=20645374">添加新闻</a> <!-- -->	 
        </div>
      </div>

      <div class="pagecontent">
        <div class="wiki-content">
          <div class="wiki-content maincontent"><plain-text-body>{scrollbar}</plain-text-body>

<p>DayTrader是围绕在线股票交易系统范例构建的基准应用程序。DayTrader最初由IBM作为贸易绩效基准样本开发，并于2005年捐赠给Apache Geronimo社区。该应用程序允许用户登录，查看其投资组合，查找股票报价以及购买或出售股票。借助Mercury LoadRunner，Rational Performance Tester或Apache JMeter等基于Web的负载驱动程序，DayTrader提供的实际工作负载可用于衡量和比较Java平台企业版（Java EE）的性能。各种供应商提供的应用服务器。</p>

<p>除了全部工作量之外，该应用程序还包含一组原语，用于对各种Java EE组件和通用设计模式进行功能和性能测试。</p>

<p>本文档分为以下几节：</p>

<parameter ac:name="maxLevel">3</parameter>

<h1 id="daytrader-amorecomplexapplication-ApplicationArchitecture">应用架构</h1>
<p>DayTrader建立在一组Java EE技术的核心之上，这些技术包括用于表示层和Java数据库连接（JDBC）的Java Servlet和JavaServer Page（JSP），Java消息服务（JMS），企业JavaBeans（EJB）和消息驱动的Bean。 （MDB）用于后端业务逻辑和持久层。下图提供了完整工作负载应用程序体系结构的高层概述。</p>

<p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="daytrader-a-more-complex-application.data/daytrader_simple_arch.gif"></span></p>

<h2 id="daytrader-amorecomplexapplication-PresentationLayer">表示层</h2>
<p>表示层由几个Java Servlet和JSP组成，这些Java Servlet和JSP松散地遵循Model-View-Controller（MVC）设计模式。<em>TradeAppServlet</em>是主要的控制器Servlet，负责接收传入的客户请求，触发所需的业务逻辑并将响应转发到适当的JSP页面。其他servlet和JSP用于配置DayTrader运行时选项和管理支持数据库。</p>

<h2 id="daytrader-amorecomplexapplication-BusinessLogicandPersistenceLayer">业务逻辑和持久层</h2>
<p>业务逻辑和持久层构成了DayTrader应用程序的主体。<em>TradeServices</em>接口定义了应用程序中可用的核心业务操作集，例如注册，登录，getHoldings，buy，completeOrder，注销等。DayTrader提供了这些服务的三种不同实现，对应于三种常用的JavaEE应用程序设计模式。这些实现将在下面讨论。用户可以通过更改运行时模式在配置页面上的这些实现之间进行切换。</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>实作</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>细节</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> <strong>贸易通</strong> <br class="atl-forced-newline" clear="none">（默认）</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> <strong>模式：</strong> Servlet到JDBC<br class="atl-forced-newline" clear="none"> <strong>运行模式：</strong>直接<br class="atl-forced-newline" clear="none"> <br class="atl-forced-newline" clear="none"><em>TradeDirect</em>类使用自定义JDBC代码直接对支持数据库执行CRUD（创建，读取，更新和删除）操作。在代码中手动管理数据库连接，提交和回滚。JTA用户事务用于协调两阶段提交。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> <strong>TradeJDBC</strong> </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> <strong>模式：从</strong> Servlet到SessionBean到JDBC<br class="atl-forced-newline" clear="none"> <strong>运行时模式：</strong>会话直接<br class="atl-forced-newline" clear="none"> <br class="atl-forced-newline" clear="none"><em>TradeJDBC</em>无状态会话bean充当TradeDirect的包装。会话bean承担所有事务管理的控制权，而TradeDirect仍然负责处理JDBC操作和连接。此实现反映了最常用的JavaEE应用程序设计模式。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p> <strong>贸易豆</strong> </p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> <strong>模式：</strong> Servlet到SessionBean到EntityBean<br class="atl-forced-newline" clear="none"> <strong>运行时模式：</strong> EJB<br class="atl-forced-newline" clear="none"> <br class="atl-forced-newline" clear="none"><em>TradeBean</em>无状态会话bean使用容器管理的持久性（CMP）实体bean表示业务对象。这些对象的状态完全由应用程序服务器EJB容器管理。</p></td></tr></tbody></table></div>


<p>该层的另一个微妙组件涉及Java Messaging Service（JMS）。在DayTrader中将JMS用于两个特定目的，即异步处理买/卖定单和发布报价更新。下表进一步讨论了这些操作。</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>运作方式</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>细节</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>异步订单处理</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>当执行购买或出售操作时，使用客户端连接将订单请求放置在TradeBroker JMS队列上。TradeBrokerMDB使用此队列上的消息并完成购买或出售操作。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>报价更新</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>随着股票交易，相关的报价在数据库中更新并发布到JMS主题。TradeStreamerMDB订阅了这些更新，并消耗了价格更新消息，但对它们不执行任何操作。可以启动与DayTrader捆绑在一起的TradeStreamer JavaEE客户端，以实时查看报价更新。</p></td></tr></tbody></table></div>


<h2 id="daytrader-amorecomplexapplication-BusinessObjectsandRelationships">业务对象和关系</h2>
<p>下图表示数据库模式和关联的业务对象。图中还描述了容器管理的关系（CMR）。</p>

<p><strong>创建图并在此处添加</strong></p>

<h2 id="daytrader-amorecomplexapplication-BusinessOperations(asdefinedinTradeServices)">业务运营（在TradeServices中定义）</h2>
<p>如前所述，DayTrader提供的所有主要业务操作都在TradeServices界面中定义。下表中进一步讨论了这些操作。</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>贸易服务业务</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>细节</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>登录</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>登出</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>购买</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>卖</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getMarketSummary</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>queueOrder</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>completeOrder</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>取消订单</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>orderCompleted</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getOrders</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getClosedOrders</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>createQuote</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>获得报价</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getAllQuotes</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>updateQuotePriceVolume</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getHoldings</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getHolding</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getAccountData</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>getAccountProfileData</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>updateAccountProfile</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>寄存器</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>resetTrade</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr></tbody></table></div>


<h2 id="daytrader-amorecomplexapplication-UserInerface(UI)Operations">用户界面（UI）操作</h2>
<p>基于DayTrader JSP / Servlet的Web客户端提供了一组基本操作，希望在任何股票交易和投资组合管理应用程序中都能找到这些操作。这些高级用户操作在业务逻辑和持久层中触发特定的业务操作（如上定义），以执行所需的任务。下表总结了每个用户操作/操作执行的业务任务。</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>客户端（UI）操作</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>业务运作流程</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>寄存器</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>登录</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>查看账户</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>查看帐户资料</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>更新帐户资料</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>查看投资组合</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>卖出控股</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>查看报价</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>购买股票</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>登出</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p> </p></td></tr></tbody></table></div>


<h1 id="daytrader-amorecomplexapplication-Gettingthesource">获取来源</h1>
<p>Daytrader在Apache的subversion存储库中可用，运行以下命令将源文件检出到<strong>daytrader-2.0</strong>目录中。</p>

<p><strong><code>svn co <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/geronimo/daytrader/trunk/">http://svn.apache.org/repos/asf/geronimo/daytrader/trunk/</a> <daytrader_home></code></strong></p>

<p><strong><daytrader_home></daytrader_home></strong>可以是专用于保存daytrader-2.0的任何目录。</p>

<p>此过程可能需要几分钟，具体取决于机器和网络连接速度。</p>

<h1 id="daytrader-amorecomplexapplication-BuildingDaytrader">建筑商</h1>
<p>一旦所有源都签出，下一步就是构建Daytrader。Daytrader需要Maven 2来构建二进制文件。</p>

<p>来自<strong><daytrader_home></daytrader_home></strong>目录运行以下命令。</p>

<p><strong><code>mvn install</code></strong></p>

<p>此过程将花费几分钟。二进制文件将在每个<strong>模块</strong>中的目录模块的相应的<strong>目标</strong>目录中生成。</p>

<h1 id="daytrader-amorecomplexapplication-ConfiguringDaytrader">配置Daytrader</h1>
<p>默认情况下，Daytrader要求使用Geronimo随附的嵌入式Derby数据库创建数据库。通常，将提供的部署计划文件配置为在部署期间在Apache Derby上创建此类数据库（DaytraderDatabase）。但是， <strong><daytrader_home>/ bin / dbscripts / derby</daytrader_home></strong>目录中提供了脚本来手动创建此数据库。请注意，此时此步骤是<strong>可选</strong>步骤，在部署Daytrader并使用应用程序的“ <strong>配置实用程序”</strong>页面中的<strong>（重新）创建DayTrader数据库表和索引</strong>链接之后，您仍然可以创建所需的数据库。</p>

<p>无论是使用命令行脚本还是基于Web的选项，在进入<a shape="rect" href="daytrader-a-more-complex-application.html">#Populating示例数据</a>部分之前，都需要创建表。</p>

<p>本节的目的是向您展示如何使用提供的脚本来创建所需的<strong>DaytraderDatabase，</strong>因此，如果需要，可以使它们适应特定的配置环境。还提供了用于不同数据库的其他脚本。</p>

<ul><li>通过运行以下命令来启动Geronimo：<br class="atl-forced-newline" clear="none">
  <strong><code><geronimo_home>/bin/geronimo start</code></strong>
<br class="atl-forced-newline" clear="none"></li><li>提供的数据库创建脚本需要设置<strong>GERONIMO_HOME</strong>环境变量。在同一窗口上，启动Geronimo，运行以下命令：<br class="atl-forced-newline" clear="none">
<strong><code>set GERONIMO_HOME=<geronimo_home></code></strong>
<br class="atl-forced-newline" clear="none"></li><li>将目录更改为包含数据库创建脚本的目录。
<br class="atl-forced-newline" clear="none">
<strong><code>cd <daytrader_home>/bin/dbscripts/derby</code></strong>
<br class="atl-forced-newline" clear="none"></li><li>打开<strong><code>createDerbyDB</code></strong>脚本并验证/修改Derby版本以匹配Geronimo使用的版本（例如<geronimo_home>/repository/org/apache/derby/derby/10.2.2.0）。验证版本匹配后，运行脚本。
<br class="atl-forced-newline" clear="none">
<strong><code>createDerbyDB</code></strong>
<br class="atl-forced-newline" clear="none">您应该看到类似于以下插图的屏幕。
<parameter ac:name="borderStyle">固定的</parameter> <plain-text-body>D：\ daytrader-2.0 \ bin \ dbscripts \ derby> createDerbyDB.bat“正在调用IJ命令行工具来创建数据库和表...请稍候” ij版本10.2.2.0 ij> ij>错误42Y55：'DROP TABLE无法在'HOLDINGEJB'上执行'，因为它不存在。ij>错误42Y55：无法在“ ACCOUNTPROFILEEJB”上执行“ DROP TABLE”，因为它不存在。ij>错误42Y55：无法在“ QUOTEEJB”上执行“ DROP TABLE”，因为它不存在。ij>错误42Y55：无法在“ KEYGENEJB”上执行“ DROP TABLE”，因为它不存在。ij>错误42Y55：无法在“ ACCOUNTEJB”上执行“ DROP TABLE”，因为它不存在。ij>错误42Y55：无法在'ORDEREJB'上执行'DROP TABLE'，因为它不存在。ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij > 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> 0行插入/更新/删除ij> ij>表创建完成</plain-text-body></geronimo_home></li><li>您可以通过将浏览器指向Geronimo管理控制台并单击<strong>DB Manager</strong>来验证数据库是否已创建。</li><li>此配置的最后一步是更新部署计划。编辑<strong><code>daytrader-g-2.0-SNAPSHOT-plan.xml</code></strong>部署计划位于<strong><daytrader_home>\ plans</daytrader_home></strong>目录中并进行替换<strong><code>ge-activemq-rar/1.2-beta/rar</code></strong>与<strong><code>ge-activemq-rar/1.2/rar</code></strong> 。</li></ul>


<p>现在您可以部署应用程序了。</p>

<h1 id="daytrader-amorecomplexapplication-DeployingDaytrader">部署Daytrader</h1>
<p>到目前为止，我们已经检索了源文件，进行了构建，配置，创建了数据库并更新了部署计划。现在是时候在Geronimo中安装Daytrader应用程序了。</p>

<p>使用Geronimo管理控制台或基于命令行的部署工具，基本上有两种在Geronimo中部署应用程序的方法。对于此示例，我们将使用基于命令行的选项。</p>

<p>从<strong><geronimo_home>/ bin</geronimo_home></strong>目录运行以下命令：</p>

<p><strong><code>deploy --user system --password manager deploy <daytrader_home>\modules\ear\target\daytrader-ear-2.0-SNAPSHOT.ear <daytrader_home>\plans\daytrader-g-2.0-SNAPSHOT-plan.xml</code></strong></p>

<p>首先<strong><code>deploy</code></strong>是调用部署程序工具的脚本，然后我们传递用户名和密码。第二<strong><code>deploy</code></strong>是用于部署<strong><code>daytrader-ear-2.0-SNAPSHOT.ear</code></strong> EAR使用<strong><code>daytrader-g-2.0-SNAPSHOT-plan.xml</code></strong>具体的部署计划。在您自己的应用程序中，您可以调用此计划<code>geronimo-application.xml</code>并将其放在<code>META-INF</code> EAR文件中的目录，您将不需要从命令行明确指定部署计划。</p>

<p>您应该看到类似于以下所示的部署确认屏幕。</p>

<parameter ac:name="borderStyle">固定</parameter> <plain-text-body>D：\ geronimo-tomcat6-javaee5-2.1 \ bin> deploy-用户系统-密码管理器部署\ daytrader-2.0 \ modules \ ear \ target \ daytrader-ear-2.0-SNAPSHOT.ear \ daytrader-2.0 \ plans \ daytrader-g-2.0-SNAPSHOT-plan.xml使用GERONIMO_BASE：D：\ geronimo-tomcat6-javaee5-2.1使用GERONIMO_HOME：D：\ geronimo-tomcat6-javaee5-2.1使用GERONIMO_TMPDIR：D：\ geronimo-tomcat6-javaee5-2.1 2.1 \ var \ temp使用JRE_HOME：C：\ Java \ jdk1.5.0_06 \ jre部署geronimo / daytrader / 2.0-SNAPSHOT / car`-> web.war @ http：// localhost：8080 / daytrader`-> dt- ejb.jar`-> geronimo / daytrader-wsapp-client / 2.0-SNAPSHOT / car`-> geronimo / daytrader-streamer-client / 2.0-SNAPSHOT / car`-> TradeDataSource`-> TradeJMS</plain-text-body>

<p>Daytrader现在可以进行测试了。</p>

<h1 id="daytrader-amorecomplexapplication-Populatingsampledata">填充样本数据</h1>
<p>部署并启动应用程序（部署时默认启动）后，使用Daytrader的下一步是将示例数据填充到我们之前创建的数据库中。以下步骤说明了如何进行。</p>

<ul><li>访问将您的浏览器指向<a shape="rect" class="external-link" href="http://localhost:8080/daytrader" rel="nofollow">http：// localhost：8080 / daytrader</a>的应用程序
<br class="atl-forced-newline" clear="none"> <br class="atl-forced-newline" clear="none">
<span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="daytrader-a-more-complex-application.data/daytrader.jpg"></span>
<br class="atl-forced-newline" clear="none"> <br class="atl-forced-newline" clear="none"></li><li>单击<strong>配置</strong>选项卡。</li><li>单击<strong>（重新）填充DayTrader数据库</strong>以生成示例数据，这将打开一个显示进度的新窗口。<br clear="none">初始人口规模包括200个帐户和400个股票报价。可以通过“配置”选项卡上的“配置DayTrader运行时参数”链接来更新这些值。</li></ul>


<h1 id="daytrader-amorecomplexapplication-RunningDaytrader">连续日间交易</h1>
<p>Daytrader可以在多种配置中运行，并且还提供了一组Web原语以简化测试。这些原语中的每一个都单独测试企业Java编程模型中的关键操作。其中一些可以配置为根据稍后将介绍的配置设置重复运行。以下各节将更详细地描述这些原语测试套件。</p>

<h2 id="daytrader-amorecomplexapplication-WebContainerpingsuite">Web容器ping套件</h2>
<p>下表描述了与Web容器相关的原语集。可以设置为多次运行的原语会<strong>突出显示</strong> 。</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>原始</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>平板电脑</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingHtml是最基本的操作，提供对静态HTML的简单“ Hello World”页面的访问。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>显式GC</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>在AppServer上调用垃圾回收。GC完成后报告堆统计信息。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet通过服务器端Servlet处理来测试基本的动态HTML创建。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServletWriter</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServletWriter通过使用PrintWriter来格式化输出，而不是PingServlet使用的输出流，从而扩展了PingServlet。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2Include</strong> 	</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2Include测试响应包含。Servlet 1包含Servlet 2的响应。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2Servlet</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2Servlet测试请求分配。控制器Servlet 1创建一个新的JavaBean对象，以将请求与添加到Servlet 2的JavaBean一起转发。Servlet 2通过Servlet请求对象获得对JavaBean的访问，并基于JavaBean数据提供动态HTML输出。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>平JSP</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingJSP测试对JavaServer Page的直接调用，该调用通过JSP脚本提供服务器端动态HTML。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>平捷</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingJSPEL测试了对JavaServer Page的直接调用，该调用通过JSP脚本和新JSP 2.0表达式语言的使用来提供服务器端动态HTML。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2JSP</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2JSP测试一种常用的设计模式，在该模式中，向提供服务器端控制处理的Servlet发出请求。Servlet创建一个具有动态设置属性的JavaBean对象，并通过RequestDispatcher将Bean转发到JSP。JSP获得对JavaBean的访问权，并基于JavaBean数据提供带有动态HTML输出的格式化显示。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingHTTPSession1</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingHTTPSession1- <strong><code>SessionID</code></strong>通过为每个用户创建唯一的会话ID来测试基本的HTTP会话功能。该ID存储在用户会话中，并在每个用户请求上访问和显示。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingHTTPSession2</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingHTTPSession2 <strong><code>session create/destroy</code></strong>通过使第5个用户访问的HTTP会话无效，进一步扩展了先前的测试。这导致测试HTTPSession的创建和销毁。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingHTTPSession3</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingHTTPSession3 <strong><code>large session object</code></strong>测试服务器管理和持久保存大型HTTPSession数据对象的能力。Servlet创建一个大型自定义Java对象。该类包含多个数据字段，并产生2048个字节的数据。每次用户请求时，都会检索此大型会话对象并将其存储到会话中。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingJDBCRead</strong> 	</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingJDBCRead测试基本的servlet到JDBC对数据库的JDBC访问，并使用准备好的SQL语句执行单行读取。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingJDBC写入</strong> 	</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingJDBCRead测试基本的servlet到JDBC的数据库访问，以使用准备好的SQL语句执行单行写入。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2JNDI</strong> 	</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2JNDI测试servlet的基本J2EE操作，该servlet分配JNDI上下文并执行JDBC数据源的JNDI查找。</p></td></tr></tbody></table></div>


<h2 id="daytrader-amorecomplexapplication-EJBContainerpingsuite">EJB容器ping套件</h2>
<p>下表描述了与EJB容器相关的原语集。可以设置为多次运行的原语会<strong>突出显示</strong> 。</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>原始</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2SessionEJB</strong>  		</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2SessionEJB测试对无状态SessionEJB的servlet调用的关键功能。 SessionEJB执行简单的计算并返回结果。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2EntityEJBLocal</strong>		<br class="atl-forced-newline" clear="none">	 
<strong>PingServlet2EntityEJBRemote</strong>		</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2EntityEJB测试对EJB 2.0容器管理的实体的servlet调用的关键功能。在此测试中，EJB实体表示数据库表中的单个行。的<strong><code>Local version</code></strong>使用EJB Local接口，而<strong><code>Remote version</code></strong>使用远程EJB接口。<br class="atl-forced-newline" clear="none">（注意：PingServlet2EntityEJBLocal将在将Trade Web和EJB应用程序分开的多层设置中失败。）</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2Session2Entity</strong>		</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>这将测试从会话EJB到实体EJB的完整servlet路径，以从数据库中检索单个行。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2Session2<br class="atl-forced-newline" clear="none">
<strong>实体集合</strong> 			</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>该测试通过调用会话EJB扩展了先前的EJB Entity测试，该会话EJB在Entity上使用finder方法，该方法返回Entity对象的集合。每个对象由servlet显示</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2Session2CMROne2一个</strong> 	</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>此测试驱动实体EJB通过EJB 2.0 CMR一对一关系获取另一个实体EJB的数据。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2Session2CMROne2Many</strong> 	</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>此测试驱动实体EJB通过EJB 2.0 CMR一对多关系获取另一个实体EJB的数据。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2Session2JDBC</strong> 		</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>这将测试从Servlet到Session EJB到JDBC的完整路径，以从数据库中检索单个行。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2Session2<br class="atl-forced-newline" clear="none">
<strong>JDBC收藏</strong> 			</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>该测试通过将会话EJB调用到JDBC路径来扩展先前的JDBC测试，JDBC路径从数据库返回多行。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2MDBQueue</strong> 		</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2MDBQueue将消息驱动到基于队列的消息驱动EJB（MDB）。对Servlet的每个请求都会向队列发送一条消息。MDB异步接收消息，并在每100条消息上打印消息传递统计信息。<br class="atl-forced-newline" clear="none"> <strong><code>Note: Not intended for performance testing.</code></strong> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2MDBTopic</strong> 		</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2MDBTopic将消息驱动到基于主题的发布/订阅消息驱动的EJB（MDB）。对Servlet的每个请求都会向主题发送一条消息。TradeStreamMDB异步接收消息，并在第100条消息上打印消息传递统计信息。主题的其他订阅者也将收到消息。<br class="atl-forced-newline" clear="none"> <strong><code>Note: Not intended for performance testing.</code></strong> </p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p><strong>PingServlet2TwoPhase</strong> 		</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>PingServlet2TwoPhase驱动会话EJB，该会话EJB使用findByPrimaryKey（数据库访问）调用实体EJB，然后通过JMS队列（消息访问）将消息发布到MDB。这些操作包装在全局两阶段事务和提交中。</p></td></tr></tbody></table></div>


<h2 id="daytrader-amorecomplexapplication-ConfigureDayTraderrun-time">配置DayTrader运行时</h2>
<p>因此，现在您知道有哪些可用的原语，哪些可以被设置为可运行多次。下表描述了Daytrader <strong>Configuration Utilities</strong>可以使用哪些参数来设置运行时参数。</p>

<div class="table-wrap"><table class="confluenceTable"><tbody><tr><th colspan="1" rowspan="1" class="confluenceTh"><p>参数</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>选项</p></th><th colspan="1" rowspan="1" class="confluenceTh"><p>描述</p></th></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>运行模式</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>EJB<br class="atl-forced-newline" clear="none">直接<br class="atl-forced-newline" clear="none">SessionDirect<br class="atl-forced-newline" clear="none">JPA</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>运行时模式确定要在DayTrader应用程序的Enterprise Java Bean（包括会话，实体和消息Bean）中使用的TradeServices的服务器实现，还是使用直接数据库和JMS访问的直接模式。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>订单处理模式</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>同步<br class="atl-forced-newline" clear="none">异步_2相</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>订单处理模式确定完成股票购买和出售操作的模式。同步模式立即完成订单。Asychronous_2-Phase对EJB实体/ DB和MDB / JMS事务执行两阶段提交。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>存取模式</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>标准<br class="atl-forced-newline" clear="none">网页服务</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>访问模式确定DayTrader Web应用程序用来访问服务器端服务的协议。标准模式使用默认的Java RMI协议。Web服务模式使用Axis的Web服务实现，包括SOAP，WSDL和UDDI。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>方案工作负载组合</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>标准<br class="atl-forced-newline" clear="none">高音量</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>通过TradeScenarioServlet驱动基准测试时，此设置确定DayTrader操作的运行时工作负载混合。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>Web接口</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>JSP<br class="atl-forced-newline" clear="none">JSP图像</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>此设置确定使用的Web界面技术，JSP还是具有静态图像和GIF的JSP。</p></td></tr></tbody></table></div>


<h3 id="daytrader-amorecomplexapplication-MiscellaneousSettings">其他设定</h3>
<div class="table-wrap"><table class="confluenceTable"><tbody><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>DayTrader最大用户数<br class="atl-forced-newline" clear="none">交易最大报价</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>默认情况下，DayTrader数据库填充了50个用户（uid：0-uid：49）和100个引号（s：0-s：99）。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>原始迭代</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>默认情况下，DayTrader原语对每个Web请求执行一个操作。更改此值可对每个Web请求多次重复操作。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>发布报价更新</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>将报价更改发布到JMS主题。需要运行<a shape="rect" href="daytrader-a-more-complex-application.html">#Streamer应用程序客户端</a> 。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>启用长期支持</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>通过禁用在“帐户”页面上执行的“显示所有订单”查询来启用长期支持。</p></td></tr><tr><td colspan="1" rowspan="1" class="confluenceTd"><p>启用操作跟踪<br class="atl-forced-newline" clear="none">启用完整跟踪</p></td><td colspan="1" rowspan="1" class="confluenceTd"><p>启用DayTrader处理跟踪消息。</p></td></tr></tbody></table></div>


<h2 id="daytrader-amorecomplexapplication-RunningPrimitives">运行原语</h2>
<p>到目前为止，我们已经看到了哪些可用的原语，哪些可以设置为运行多次迭代以及如何配置应用程序运行时参数。</p>

<ul><li>将浏览器指向<a shape="rect" class="external-link" href="http://localhost:8080/daytrader" rel="nofollow">http：// localhost：8080 / daytrader</a></li><li>单击<strong>配置</strong> 。</li><li>单击“ <strong>配置DayTrader运行时参数”</strong> 。</li><li>从<strong>“运行时模式”中</strong>选择<strong>EJB</strong> 。</li><li>从<strong>WebInterface中选择</strong> <strong>JSP-Images</strong> 。</li><li>将<strong>基本迭代</strong>设置为<strong><code>100</code></strong> 。</li><li>点击<strong>更新配置</strong> 。</li><li>单击<strong>基本体</strong> 。</li><li>单击<strong>PingServlet2EntityEJBLocal</strong> 。</li></ul>


<p>使用这些设置，每次您单击<strong>PingServlet2EntityEJBLocal</strong>或刷新将执行原语的页面时， <strong><code>100</code></strong>次。在进行性能分析时，能够“玩弄”这些参数非常有价值。这可以帮助您跟踪这些非常特定的功能的执行时间。当与负载模拟工具结合使用时，不同的配置将帮助您根据环境的特定需求对服务器进行微调。</p>

<h2 id="daytrader-amorecomplexapplication-Gonetrading!!!">交易去了！！！</h2>
<p>我们刚刚看到了如何通过可用的原语运行单个功能/操作测试。您为运行这些原语而配置的设置也完全相同，也会影响用于交易模拟的GUI。</p>

<ul><li>将浏览器指向<a shape="rect" class="external-link" href="http://localhost:8080/daytrader" rel="nofollow">http：// localhost：8080 / daytrader</a></li><li>点击<strong>交易和投资组合</strong> 。</li><li>接受默认的用户名和密码，然后单击<strong>Login</strong> 。</li><li>您现在应该可以开始交易了！</li></ul>


<p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="daytrader-a-more-complex-application.data/daytrader_2a.jpg"></span></p>

<p>通过将Web浏览器指向<a shape="rect" class="external-link" href="http://localhost:8080/daytrader" rel="nofollow">http：// localhost：8080 / daytrader，</a>可以在应用程序<strong>常见问题解答中</strong>找到有关配置和运行Daytrader的其他详细信息。</p>

<h2 id="daytrader-amorecomplexapplication-Backtosquareone">回到原点</h2>
<p>在执行了一些测试并想要从头开始运行新集合之后，您将需要从数据库中重置运行时配置和事务数据。</p>

<ul><li>将浏览器指向<a shape="rect" class="external-link" href="http://localhost:8080/daytrader" rel="nofollow">http：// localhost：8080 / daytrader</a></li><li>单击<strong>配置</strong> 。</li><li>单击<strong>Reset DayTrader（在每次运行之前完成）</strong> 。</li><li>单击<strong>（重新）填充DayTrader数据库</strong> 。</li></ul>


<p>这些简单的步骤是在Daytrader上启动一组新测试所需的全部，但是，您可能仍要根据正在运行的测试类型来重新启动服务器。</p>

<h1 id="daytrader-amorecomplexapplication-Launchingtheapplicationclients">启动应用程序客户端</h1>
<p>DayTrader提供了两个J2EE应用程序客户端，即DayTrader Streamer和一个Web服务应用程序。Streamer应用程序客户端使用JMS主题来订阅股票买卖中的报价更新。跟踪这些更新，并用于确定在更新数据库中的报价时是否发生数据库冲突。Web服务应用程序客户端仅提供一个胖客户端即可使用Web服务界面访问DayTrader服务。</p>

<h2 id="daytrader-amorecomplexapplication-Streamerapplicationclient">流媒体应用程序客户端</h2>
<p>为了使报价更新发布到JMS主题，必须启用配置页面上的“发布报价更新”标志。</p>

<ul><li>将浏览器指向<a shape="rect" class="external-link" href="http://localhost:8080/daytrader" rel="nofollow">http：// localhost：8080 / daytrader</a></li><li>单击<strong>配置</strong> 。</li><li>单击“ <strong>配置DayTrader运行时参数”</strong> 。</li><li>确保选中“ <strong>发布报价更新”</strong>复选框。</li></ul>


<p>要启动Streamer应用程序客户端，请运行以下命令。</p>

<p><strong><code><geronimo_home>/bin/java -jar client.jar geronimo/daytrader-streamer-client/2.0-SNAPSHOT/car</code></strong></p>

<p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="daytrader-a-more-complex-application.data/daytrader_3.jpg"></span></p>

<h2 id="daytrader-amorecomplexapplication-WebServicesapplicationclient">Web服务应用程序客户端</h2>
<p><strong><code><geronimo_home>/bin/java -jar client.jar geronimo/daytrader-wsapp-client/2.0-SNAPSHOT/car</code></strong></p></div>
        </div>

              </div>
    </div>

        <!-- footer -->
    <table border="0" cellpadding="2" cellspacing="0" width="100%">
        <tbody><tr>
          <td align="left" valign="middle" class="footer">
              
            <img src="http://static.delicious.com/img/delicious.small.gif" height="10" width="10" alt="美味的"> <a href="http://delicious.com/save" onclick="window.open('http://delicious.com/save?v=5&noui&jump=close&url='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title),'delicious','toolbar=no,width=550,height=550'); return false;">在Delicious上添加书签</a> <img src="http://digg.com/img/badges/16x16-digg-guy.gif" width="16" height="16" alt="掘客！"> <a href="" onclick="window.open('http://digg.com/submit?url='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title)+'&topic=programming');">挖这个</a> <!-- Slicker, but no text
            <script type="text/javascript">
              digg_skin = 'icon';
              digg_window = 'new';
              digg_title = 'Apache Geronimo v3.0 Documentation : daytrader - a more complex application';
              digg_topic = 'programming';
            </script>
            <script src="http://digg.com/tools/diggthis.js" type="text/javascript"></script>
            -->
              
          </td>
          <td align="right" valign="middle" class="footer">
            <a href="http://cwiki.apache.org/GMOxPMGT/geronimo-privacy-policy.html">隐私权政策</a> -版权所有©2003-2013，Apache软件基金会，根据<a href="http://www.apache.org/licenses/LICENSE-2.0">ASL 2.0</a>许可<a href="http://www.apache.org/licenses/LICENSE-2.0">。</a>  
          </td>
        </tr>
    </tbody></table> 

        <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      var pageTracker = _gat._getTracker("UA-4380560-1");
      pageTracker._initData();
      pageTracker._trackPageview();
    </script>

  

</body></html>