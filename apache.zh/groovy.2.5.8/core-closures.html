<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>关闭</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=0">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>关闭</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_syntax">1。句法</a>
<ul class="sectlevel2">
<li><a href="#_defining_a_closure">1.1。定义闭包</a></li>
<li><a href="#closure-as-object">1.2。封闭对象</a></li>
<li><a href="#_calling_a_closure">1.3。调用关闭</a></li>
</ul>
</li>
<li><a href="#_parameters">2。参量</a>
<ul class="sectlevel2">
<li><a href="#_normal_parameters">2.1。普通参数</a></li>
<li><a href="#implicit-it">2.2。隐式参数</a></li>
<li><a href="#_varargs">2.3。瓦拉格斯</a></li>
</ul>
</li>
<li><a href="#_delegation_strategy">3。授权策略</a>
<ul class="sectlevel2">
<li><a href="#_groovy_closures_vs_lambda_expressions">3.1。Groovy闭包与Lambda表达式</a></li>
<li><a href="#closure-owner">3.2。所有者，委托人和这个</a>
<ul class="sectlevel3">
<li><a href="#closure-this">3.2.1。这个的意思</a></li>
<li><a href="#_owner_of_a_closure">3.2.2。封闭的所有者</a></li>
<li><a href="#_delegate_of_a_closure">3.2.3。委托结束</a></li>
<li><a href="#_delegation_strategy_2">3.2.4。授权策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_closures_in_gstrings">4。GString中的闭包</a></li>
<li><a href="#_closure_coercion">5，强制关闭</a></li>
<li><a href="#_functional_programming">6。功能编程</a>
<ul class="sectlevel2">
<li><a href="#_currying">6.1。咖喱</a>
<ul class="sectlevel3">
<li><a href="#_left_currying">6.1.1。左弯曲</a></li>
<li><a href="#_right_currying">6.1.2。右弯曲</a></li>
<li><a href="#_index_based_currying">6.1.3。基于索引的货币</a></li>
</ul>
</li>
<li><a href="#_memoization">6.2。记忆化</a></li>
<li><a href="#_composition">6.3。组成</a></li>
<li><a href="#_trampoline">6.4。蹦床</a></li>
<li><a href="#_method_pointers">6.5。方法指针</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍Groovy闭包。Groovy中的闭包是开放的匿名代码块，可以接受参数，返回值并分配给变量。闭包可以引用在其周围范围内声明的变量。与正式的封闭定义相反， <code>Closure</code>在Groovy语言中，“语言”也可以包含在其周围范围之外定义的自由变量。在打破封闭的正式概念的同时，它提供了本章中介绍的各种优点。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntax"><a class="anchor" href="#_syntax"></a> 1。句法</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_defining_a_closure"><a class="anchor" href="#_defining_a_closure"></a> 1.1。定义闭包</h3>
<div class="paragraph">
<p>闭包定义遵循以下语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">{ [closureParameters -&gt; ] statements }</code></pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>[closureParameters->]</code>是一个可选的用逗号分隔的参数列表，并且语句为0或多个Groovy语句。这些参数看起来类似于方法参数列表，并且这些参数可以是键入的也可以是未键入的。</p>
</div>
<div class="paragraph">
<p>指定参数列表后， <code>-></code>字符是必需的，用于将参数与闭包主体分开。<em>语句</em>部分由0、1或许多Groovy语句组成。</p>
</div>
<div class="paragraph">
<p>有效的闭包定义的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">{ item++ }                                          <i class="conum" data-value="1"></i><b>(1)</b>

{ -&gt; item++ }                                       <i class="conum" data-value="2"></i><b>(2)</b>

{ println it }                                      <i class="conum" data-value="3"></i><b>(3)</b>

{ it -&gt; println it }                                <i class="conum" data-value="4"></i><b>(4)</b>

{ name -&gt; println name }                            <i class="conum" data-value="5"></i><b>(5)</b>

{ String x, int y -&gt;                                <i class="conum" data-value="6"></i><b>(6)</b>
    println "hey ${x} the value is ${y}"
}

{ reader -&gt;                                         <i class="conum" data-value="7"></i><b>(7)</b>
    def line = reader.readLine()
    line.trim()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个闭包引用一个名为<code>item</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以通过添加箭头来将闭包参数与代码明确分开（ <code>-></code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用隐式参数的闭包（ <code>it</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>替代版本，其中<code>it</code>是一个明确的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>在这种情况下，通常最好为参数使用显式名称</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>一个接受两个类型化参数的闭包</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>一个闭包可以包含多个语句</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="closure-as-object"><a class="anchor" href="#closure-as-object"></a> 1.2。封闭对象</h3>
<div class="paragraph">
<p>闭包是<code>groovy.lang.Closure</code>类，即使是代码块，也可以将其分配给变量或字段，就像其他任何变量一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def listener = { e -&gt; println "Clicked on $e.source" }      <i class="conum" data-value="1"></i><b>(1)</b>
assert listener instanceof Closure
Closure callback = { println 'Done!' }                      <i class="conum" data-value="2"></i><b>(2)</b>
Closure&lt;Boolean&gt; isTextFile = {
    File it -&gt; it.name.endsWith('.txt')                     <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>您可以将闭包分配给变量，并且它是的实例<code>groovy.lang.Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果不使用<code>def</code> ，您可以将闭包分配给类型为的变量<code>groovy.lang.Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>（可选）您可以使用的通用类型指定闭包的返回类型<code>groovy.lang.Closure</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_calling_a_closure"><a class="anchor" href="#_calling_a_closure"></a> 1.3。调用关闭</h3>
<div class="paragraph">
<p>闭包作为一个匿名代码块，可以像其他任何方法一样调用。如果您定义一个不带参数的闭包，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def code = { 123 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，仅在<em>调用</em>闭包时才执行闭包内的代码，这可以通过使用变量来完成，就像使用常规方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert code() == 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，您也可以明确使用<code>call</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert code.call() == 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果闭包接受参数，则原理相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def isOdd = { int i -&gt; i%2 != 0 }                           <i class="conum" data-value="1"></i><b>(1)</b>
assert isOdd(3) == true                                     <i class="conum" data-value="2"></i><b>(2)</b>
assert isOdd.call(2) == false                               <i class="conum" data-value="3"></i><b>(3)</b>

def isEven = { it%2 == 0 }                                  <i class="conum" data-value="4"></i><b>(4)</b>
assert isEven(3) == false                                   <i class="conum" data-value="5"></i><b>(5)</b>
assert isEven.call(2) == true                               <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个接受一个闭包<code>int</code>作为参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以直接调用</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>或使用<code>call</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>对于带有隐式参数的闭包也是如此（ <code>it</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>可以使用直接调用<code>(arg)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>或使用<code>call</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与方法不同，闭包在被调用时<strong>总是</strong>返回一个值。下一节讨论如何声明闭包参数，何时使用它们以及<a href="#implicit-it">隐式“ it”参数</a>是什么。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parameters"><a class="anchor" href="#_parameters"></a> 2。参量</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_normal_parameters"><a class="anchor" href="#_normal_parameters"></a> 2.1。普通参数</h3>
<div class="paragraph">
<p>闭包的参数遵循与常规方法的参数相同的原则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可选类型</p>
</li>
<li>
<p>一个名字</p>
</li>
<li>
<p>可选的默认值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>参数之间用逗号分隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def closureWithOneArg = { str -&gt; str.toUpperCase() }
assert closureWithOneArg('groovy') == 'GROOVY'

def closureWithOneArgAndExplicitType = { String str -&gt; str.toUpperCase() }
assert closureWithOneArgAndExplicitType('groovy') == 'GROOVY'

def closureWithTwoArgs = { a,b -&gt; a+b }
assert closureWithTwoArgs(1,2) == 3

def closureWithTwoArgsAndExplicitTypes = { int a, int b -&gt; a+b }
assert closureWithTwoArgsAndExplicitTypes(1,2) == 3

def closureWithTwoArgsAndOptionalTypes = { a, int b -&gt; a+b }
assert closureWithTwoArgsAndOptionalTypes(1,2) == 3

def closureWithTwoArgAndDefaultValue = { int a, int b=2 -&gt; a+b }
assert closureWithTwoArgAndDefaultValue(1) == 3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="implicit-it"><a class="anchor" href="#implicit-it"></a> 2.2。隐式参数</h3>
<div class="paragraph">
<p>当闭包没有显式定义参数列表时（使用<code>-></code> ），闭包<strong>始终</strong>定义一个隐式参数，名为<code>it</code> 。这意味着该代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def greeting = { "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>完全等同于这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def greeting = { it -&gt; "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要声明一个不接受任何参数且必须限制为不带参数的调用的闭包，则<strong>必须</strong>使用一个明确的空参数列表对其进行声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def magicNumber = { -&gt; 42 }

// this call will fail because the closure doesn't accept any argument
magicNumber(11)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_varargs"><a class="anchor" href="#_varargs"></a> 2.3。瓦拉格斯</h3>
<div class="paragraph">
<p>闭包可以像其他任何方法一样声明变量参数。<em>Vargs</em>方法是一种方法，如果最后一个参数的长度可变（或数组），则可以接受可变数量的参数，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def concat1 = { String... args -&gt; args.join('') }           <i class="conum" data-value="1"></i><b>(1)</b>
assert concat1('abc','def') == 'abcdef'                     <i class="conum" data-value="2"></i><b>(2)</b>
def concat2 = { String[] args -&gt; args.join('') }            <i class="conum" data-value="3"></i><b>(3)</b>
assert concat2('abc', 'def') == 'abcdef'

def multiConcat = { int n, String... args -&gt;                <i class="conum" data-value="4"></i><b>(4)</b>
    args.join('')*n
}
assert multiConcat(2, 'abc','def') == 'abcdefabcdef'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个闭包接受可变数量的字符串作为第一个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以使用任意数量的参数来调用它， <strong>而</strong>不必显式地将它们包装到数组中</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果将<em>args</em>参数声明为数组，则可以直接使用相同的行为</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>只要<strong>最后一个</strong>参数是数组或显式vargs类型</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_delegation_strategy"><a class="anchor" href="#_delegation_strategy"></a> 3。授权策略</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_groovy_closures_vs_lambda_expressions"><a class="anchor" href="#_groovy_closures_vs_lambda_expressions"></a> 3.1。Groovy闭包与Lambda表达式</h3>
<div class="paragraph">
<p>Groovy将闭包定义为<a href="#closure-as-object">Closure类的实例</a> 。它<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">与Java 8中的lambda表达式</a>有很大不同。委派是Groovy闭包中的一个关键概念，在lambda中没有等效的概念。<em>更改委托</em>或<em>更改</em>闭包<em>的委托策略</em>的能力使在Groovy中设计漂亮的域特定语言（DSL）成为可能。</p>
</div>
</div>
<div class="sect2">
<h3 id="closure-owner"><a class="anchor" href="#closure-owner"></a> 3.2。所有者，委托人和这个</h3>
<div class="paragraph">
<p>要理解委托的概念，我们首先必须解释<code>this</code>在一个封闭内。闭包实际上定义了3个不同的东西：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>this</code>对应于定义闭包的<em>封闭类</em></p>
</li>
<li>
<p><code>owner</code>对应于定义闭包的<em>封闭对象</em> ，它可以是类或闭包</p>
</li>
<li>
<p><code>delegate</code>对应于第三方对象，无论何时未定义消息的接收者，方法调用或属性都将被解析</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="closure-this"><a class="anchor" href="#closure-this"></a> 3.2.1。这个的意思</h4>
<div class="paragraph">
<p>最后，打电话<code>getThisObject</code>将返回定义闭包的封闭类。等效于使用显式<code>this</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Enclosing {
    void run() {
        def whatIsThisObject = { getThisObject() }          <i class="conum" data-value="1"></i><b>(1)</b>
        assert whatIsThisObject() == this                   <i class="conum" data-value="2"></i><b>(2)</b>
        def whatIsThis = { this }                           <i class="conum" data-value="3"></i><b>(3)</b>
        assert whatIsThis() == this                         <i class="conum" data-value="4"></i><b>(4)</b>
    }
}
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { this }                               <i class="conum" data-value="5"></i><b>(5)</b>
    }
    void run() {
        def inner = new Inner()
        assert inner.cl() == inner                          <i class="conum" data-value="6"></i><b>(6)</b>
    }
}
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { this }                               <i class="conum" data-value="7"></i><b>(7)</b>
            cl()
        }
        assert nestedClosures() == this                     <i class="conum" data-value="8"></i><b>(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在内部定义了一个闭包<code>Enclosing</code>类，并返回<code>getThisObject</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>调用闭包将返回的实例<code>Enclosing</code>定义闭包的位置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通常，您只想使用快捷方式<code>this</code>符号</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>它返回<strong>完全相同</strong>的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>如果闭包在内部类中定义</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>this</code>在闭包<strong>中将</strong>返回内部类，而不是顶级类</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>如果是嵌套的闭包，例如这里<code>cl</code>在以下范围内定义<code>nestedClosures</code></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后<code>this</code>对应于最接近的外部类，而不是封闭的闭包！</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当然，可以通过以下方式从封闭类中调用方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
    String toString() { "$name is $age years old" }

    String dump() {
        def cl = {
            String msg = this.toString()               <i class="conum" data-value="1"></i><b>(1)</b>
            println msg
            msg
        }
        cl()
    }
}
def p = new Person(name:'Janice', age:74)
assert p.dump() == 'Janice is 74 years old'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>关闭电话<code>toString</code>上<code>this</code> ，实际上会称为<code>toString</code>封闭对象的方法，也就是说<code>Person</code>实例</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_owner_of_a_closure"><a class="anchor" href="#_owner_of_a_closure"></a> 3.2.2。封闭的所有者</h4>
<div class="paragraph">
<p>闭包的所有者与闭包的定义非常相似<a href="#closure-this">，只是</a>有一个微妙的区别：闭包的所有者将返回直接封装的对象，无论是闭包还是类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Enclosing {
    void run() {
        def whatIsOwnerMethod = { getOwner() }               <i class="conum" data-value="1"></i><b>(1)</b>
        assert whatIsOwnerMethod() == this                   <i class="conum" data-value="2"></i><b>(2)</b>
        def whatIsOwner = { owner }                          <i class="conum" data-value="3"></i><b>(3)</b>
        assert whatIsOwner() == this                         <i class="conum" data-value="4"></i><b>(4)</b>
    }
}
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { owner }                               <i class="conum" data-value="5"></i><b>(5)</b>
    }
    void run() {
        def inner = new Inner()
        assert inner.cl() == inner                           <i class="conum" data-value="6"></i><b>(6)</b>
    }
}
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { owner }                               <i class="conum" data-value="7"></i><b>(7)</b>
            cl()
        }
        assert nestedClosures() == nestedClosures            <i class="conum" data-value="8"></i><b>(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在内部定义了一个闭包<code>Enclosing</code>类，并返回<code>getOwner</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>调用闭包将返回的实例<code>Enclosing</code>定义闭包的位置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通常，您只想使用快捷方式<code>owner</code>符号</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>它返回<strong>完全相同</strong>的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>如果闭包在内部类中定义</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>owner</code>在闭包<strong>中将</strong>返回内部类，而不是顶级类</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>但是在嵌套闭包的情况下，例如这里<code>cl</code>在以下范围内定义<code>nestedClosures</code></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后<code>owner</code>对应于封闭的封闭物，因此与<code>this</code> ！</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_delegate_of_a_closure"><a class="anchor" href="#_delegate_of_a_closure"></a> 3.2.3。委托结束</h4>
<div class="paragraph">
<p>闭包的委托可以通过使用<code>delegate</code>财产或致电<code>getDelegate</code>方法。这是在Groovy中构建领域特定语言的强大概念。虽然<a href="#this">closure-this</a>和<a href="#owner">closure-owner</a>引用了closure的词法范围，但委托是closure将使用的用户定义对象。默认情况下，委托设置为<code>owner</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Enclosing {
    void run() {
        def cl = { getDelegate() }                          <i class="conum" data-value="1"></i><b>(1)</b>
        def cl2 = { delegate }                              <i class="conum" data-value="2"></i><b>(2)</b>
        assert cl() == cl2()                                <i class="conum" data-value="3"></i><b>(3)</b>
        assert cl() == this                                 <i class="conum" data-value="4"></i><b>(4)</b>
        def enclosed = {
            { -&gt; delegate }.call()                          <i class="conum" data-value="5"></i><b>(5)</b>
        }
        assert enclosed() == enclosed                       <i class="conum" data-value="6"></i><b>(6)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>您可以获取闭包的委托，调用<code>getDelegate</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>或使用<code>delegate</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>都返回相同的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>这是封闭类或闭包</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>特别是在嵌套闭包的情况下</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>delegate</code>将对应于<code>owner</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>闭包的委托可以更改为<strong>任何对象</strong> 。让我们通过创建两个彼此都不是子类但都定义了一个名为<code>name</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}
class Thing {
    String name
}

def p = new Person(name: 'Norman')
def t = new Thing(name: 'Teapot')</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后让我们定义一个闭包来获取<code>name</code>委托上的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def upperCasedName = { delegate.name.toUpperCase() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后通过更改闭包的委托，您可以看到目标对象将更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">upperCasedName.delegate = p
assert upperCasedName() == 'NORMAN'
upperCasedName.delegate = t
assert upperCasedName() == 'TEAPOT'</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上，行为与拥有<code>target</code>在闭包的词法范围内定义的变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def target = p
def upperCasedNameUsingVar = { target.name.toUpperCase() }
assert upperCasedNameUsingVar() == 'NORMAN'</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，存在主要差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在最后一个示例中， <em>target</em>是从闭包内部引用的局部变量</p>
</li>
<li>
<p>该委托可以透明地使用，也就是说，无需在方法调用前添加前缀<code>delegate.</code>如下一段所述。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_delegation_strategy_2"><a class="anchor" href="#_delegation_strategy_2"></a> 3.2.4。授权策略</h4>
<div class="paragraph">
<p>每当在闭包中访问属性而不显式设置接收者对象时，就会涉及委托策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}
def p = new Person(name:'Igor')
def cl = { name.toUpperCase() }                 <i class="conum" data-value="1"></i><b>(1)</b>
cl.delegate = p                                 <i class="conum" data-value="2"></i><b>(2)</b>
assert cl() == 'IGOR'                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>name</code>在闭包的词法范围内未引用变量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以将闭包的委托更改为的实例<code>Person</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并且方法调用将成功</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该代码起作用的原因是<code>name</code>属性将在<code>delegate</code>宾语！这是解决闭包内部属性或方法调用的一种非常有效的方法。无需设置明确的<code>delegate.</code>接收方：将进行调用，因为关闭的默认委派策略使之如此。闭包实际上定义了多种解决方案策略，您可以选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Closure.OWNER_FIRST</code>是<strong>默认策略</strong> 。如果<strong>所有者</strong>上存在属性/方法，则将在<strong>所有者</strong>上调用它。如果不是，则使用<strong>委托</strong> 。</p>
</li>
<li>
<p><code>Closure.DELEGATE_FIRST</code>颠倒逻辑：首先使用<strong>委托</strong> ，然后使用<strong>所有者</strong></p>
</li>
<li>
<p><code>Closure.OWNER_ONLY</code>只会在所有者上解析属性/方法查找：委托将被忽略。</p>
</li>
<li>
<p><code>Closure.DELEGATE_ONLY</code>只会解决委托上的属性/方法查找：所有者将被忽略。</p>
</li>
<li>
<p><code>Closure.TO_SELF</code>可供需要高级元编程技术并希望实现自定义解析策略的开发人员使用：解析不会在所有者或委托上进行，而只会在闭包类本身上进行。如果您实现自己的子类，则仅使用此方法有意义<code>Closure</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们用下面的代码说明默认的“所有者优先”策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    def pretty = { "My name is $name" }             <i class="conum" data-value="1"></i><b>(1)</b>
    String toString() {
        pretty()
    }
}
class Thing {
    String name                                     <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person(name: 'Sarah')
def t = new Thing(name: 'Teapot')

assert p.toString() == 'My name is Sarah'           <i class="conum" data-value="3"></i><b>(3)</b>
p.pretty.delegate = t                               <i class="conum" data-value="4"></i><b>(4)</b>
assert p.toString() == 'My name is Sarah'           <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>为了说明，我们定义一个引用“名称”的闭包成员</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>这俩<code>Person</code>和<code>Thing</code>类定义一个<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用默认策略， <code>name</code>财产首先由所有者解决</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>所以如果我们改变<code>delegate</code>至<code>t</code>这是<code>Thing</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>结果没有变化： <code>name</code>首先解决<code>owner</code>封闭的</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，可以更改关闭的解决策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p.pretty.resolveStrategy = Closure.DELEGATE_FIRST
assert p.toString() == 'My name is Teapot'</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过更改<code>resolveStrategy</code> ，我们正在修改Groovy解决“隐含此”引用的方式：在这种情况下， <code>name</code>首先将在委托中查找，然后在所有者上查找（如果找不到）。以来<code>name</code>是在委托中定义的<code>Thing</code> ，则使用此值。</p>
</div>
<div class="paragraph">
<p>（RESP所有者）“委派第一”和“仅授权”或“所有者第一”和“仅所有者”可以示之间的差值，如果该委托的一个<strong>不</strong>具有这样的方法或属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
    def fetchAge = { age }
}
class Thing {
    String name
}

def p = new Person(name:'Jessica', age:42)
def t = new Thing(name:'Printer')
def cl = p.fetchAge
cl.delegate = p
assert cl() == 42
cl.delegate = t
assert cl() == 42
cl.resolveStrategy = Closure.DELEGATE_ONLY
cl.delegate = p
assert cl() == 42
cl.delegate = t
try {
    cl()
    assert false
} catch (MissingPropertyException ex) {
    // "age" is not defined on the delegate
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们定义了两个类，每个类都有一个<code>name</code>财产，但只有<code>Person</code>类声明一个<code>age</code> 。的<code>Person</code>类还声明了一个引用的闭包<code>age</code> 。我们可以将默认解决方案策略从“所有者优先”更改为“仅委托”。由于关闭的所有者是<code>Person</code>类，那么我们可以检查委托是否是的实例<code>Person</code> ，则成功调用了闭包，但是如果我们使用一个委托作为它的实例来调用它<code>Thing</code> ，它失败并显示<code>groovy.lang.MissingPropertyException</code> 。尽管在内部定义了闭包<code>Person</code>类，不使用所有者。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><a href="core-domain-specific-languages.html">在手册</a>的<a href="core-domain-specific-languages.html">专用部分中，</a>可以找到有关如何使用此功能开发DSL的全面说明。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_closures_in_gstrings"><a class="anchor" href="#_closures_in_gstrings"></a> 4。GString中的闭包</h2>
<div class="sectionbody">
<div class="paragraph">
<p>采取以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1
def gs = "x = ${x}"
assert gs == 'x = 1'</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码的行为符合您的预期，但是如果添加以下内容，将会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">x = 2
assert gs == 'x = 2'</code></pre>
</div>
</div>
<div class="paragraph">
<p>您将看到断言失败！有两个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GString只懒惰地求值<code>toString</code>值的表示</p>
</li>
<li>
<p>语法<code>${x}</code>在一个的GString <strong>不代表</strong>一个闭合但<strong>表达式</strong>来<code>$x</code> ，在创建GString时进行评估。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我们的示例中， <code>GString</code>用表达式引用创建<code>x</code> 。当。。。的时候<code>GString</code>被创建，的<strong>值</strong> <code>x</code>是1，所以<code>GString</code>创建的值为1。当触发断言时， <code>GString</code>评估并将1转换为<code>String</code>使用<code>toString</code> 。当我们改变<code>x</code>到2，我们确实更改了<code>x</code> ，但这是一个不同的对象， <code>GString</code>仍然引用旧的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">一种<code>GString</code>只会改变它的<code>toString</code>如果它引用的值是变异的，则表示。如果引用发生更改，则不会发生任何事情。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要在GString中进行真正的关闭，例如强制对变量进行延迟计算，则需要使用备用语法<code>${→ x}</code>如固定示例中所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1
def gs = "x = ${-&gt; x}"
assert gs == 'x = 1'

x = 2
assert gs == 'x = 2'</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们用以下代码说明它与突变的区别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    String toString() { name }          <i class="conum" data-value="1"></i><b>(1)</b>
}
def sam = new Person(name:'Sam')        <i class="conum" data-value="2"></i><b>(2)</b>
def lucy = new Person(name:'Lucy')      <i class="conum" data-value="3"></i><b>(3)</b>
def p = sam                             <i class="conum" data-value="4"></i><b>(4)</b>
def gs = "Name: ${p}"                   <i class="conum" data-value="5"></i><b>(5)</b>
assert gs == 'Name: Sam'                <i class="conum" data-value="6"></i><b>(6)</b>
p = lucy                                <i class="conum" data-value="7"></i><b>(7)</b>
assert gs == 'Name: Sam'                <i class="conum" data-value="8"></i><b>(8)</b>
sam.name = 'Lucy'                       <i class="conum" data-value="9"></i><b>(9)</b>
assert gs == 'Name: Lucy'               <i class="conum" data-value="10"></i><b>(10)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Person</code>班上有一个<code>toString</code>方法返回<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们创建第一个<code>Person</code>叫<em>山姆</em></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们创建另一个<code>Person</code>叫<em>露西</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>p</code>变量设置为<code>Sam</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>并创建一个引用的值的闭包<code>p</code> ，也就是说<em>山姆</em></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>因此，当我们评估字符串时，它将返回<em>Sam</em></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>如果我们改变<code>p</code> <em>露西</em></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>该字符串仍为<em>Sam</em>求<strong>值</strong> ，因为它是<code>p</code>当。。。的时候<code>GString</code>被创建</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>所以如果我们变异<em>山姆</em>将他的名字改成<em>露西</em></td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>这次<code>GString</code>已正确突变</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，如果您不想依赖于更改对象或包装对象，则<strong>必须</strong>在<code>GString</code>通过显式声明一个空的参数列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    String toString() { name }
}
def sam = new Person(name:'Sam')
def lucy = new Person(name:'Lucy')
def p = sam
// Create a GString with lazy evaluation of "p"
def gs = "Name: ${-&gt; p}"
assert gs == 'Name: Sam'
p = lucy
assert gs == 'Name: Lucy'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_closure_coercion"><a class="anchor" href="#_closure_coercion"></a> 5，强制关闭</h2>
<div class="sectionbody">
<div class="paragraph">
<p>闭包可以转换为接口或单一抽象方法类型。请参考<a href="core-semantics.html#closure-coercion">本手册</a>的完整说明。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functional_programming"><a class="anchor" href="#_functional_programming"></a> 6。功能编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>像<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Java 8</a>中的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambda表达式</a>一样，闭包是Groovy中功能编程范例的核心。对功能的某些功能编程操作可直接在<code>Closure</code>类，如本节所示。</p>
</div>
<div class="sect2">
<h3 id="_currying"><a class="anchor" href="#_currying"></a> 6.1。咖喱</h3>
<div class="paragraph">
<p>在Groovy中，“ currying”是指部分应用程序的概念。它<strong>不</strong>符合，因为那Groovy的适用于封闭的不同范围的规则在函数式编程讨好的真正概念。用Groovy进行Currying可以让您设置闭包的一个参数的值，并且它将返回一个接受较少参数的新闭包。</p>
</div>
<div class="sect3">
<h4 id="_left_currying"><a class="anchor" href="#_left_currying"></a> 6.1.1。左弯曲</h4>
<div class="paragraph">
<p>左递归是设置闭包的最左边参数的事实，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nCopies = { int n, String str -&gt; str*n }    <i class="conum" data-value="1"></i><b>(1)</b>
def twice = nCopies.curry(2)                    <i class="conum" data-value="2"></i><b>(2)</b>
assert twice('bla') == 'blabla'                 <i class="conum" data-value="3"></i><b>(3)</b>
assert twice('bla') == nCopies(2, 'bla')        <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>nCopies</code>闭包定义两个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>curry</code>将第一个参数设置为<code>2</code> ，创建一个接受单个闭包的新闭包（函数）<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>因此，仅用一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>这相当于打电话<code>nCopies</code>有两个参数</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_right_currying"><a class="anchor" href="#_right_currying"></a> 6.1.2。右弯曲</h4>
<div class="paragraph">
<p>与左递归相似，可以设置闭包的最右边参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nCopies = { int n, String str -&gt; str*n }    <i class="conum" data-value="1"></i><b>(1)</b>
def blah = nCopies.rcurry('bla')                <i class="conum" data-value="2"></i><b>(2)</b>
assert blah(2) == 'blabla'                      <i class="conum" data-value="3"></i><b>(3)</b>
assert blah(2) == nCopies(2, 'bla')             <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>nCopies</code>闭包定义两个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>rcurry</code>将最后一个参数设置为<code>bla</code> ，创建一个接受单个闭包的新闭包（函数）<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>因此，仅使用一个<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>这相当于打电话<code>nCopies</code>有两个参数</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_index_based_currying"><a class="anchor" href="#_index_based_currying"></a> 6.1.3。基于索引的货币</h4>
<div class="paragraph">
<p>如果闭包接受两个以上的参数，则可以使用<code>ncurry</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def volume = { double l, double w, double h -&gt; l*w*h }      <i class="conum" data-value="1"></i><b>(1)</b>
def fixedWidthVolume = volume.ncurry(1, 2d)                 <i class="conum" data-value="2"></i><b>(2)</b>
assert volume(3d, 2d, 4d) == fixedWidthVolume(3d, 4d)       <i class="conum" data-value="3"></i><b>(3)</b>
def fixedWidthAndHeight = volume.ncurry(1, 2d, 4d)          <i class="conum" data-value="4"></i><b>(4)</b>
assert volume(3d, 2d, 4d) == fixedWidthAndHeight(3d)        <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>volume</code>函数定义3个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>ncurry</code>将第二个参数（索引= 1）设置为<code>2d</code> ，创建一个接受长度和高度的新音量功能</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>该功能等同于调用<code>volume</code>省略宽度</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>也可以从指定的索引开始设置多个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>结果函数接受的参数数量与初始参数数量之和减去以下参数设置的数量一样<code>ncurry</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_memoization"><a class="anchor" href="#_memoization"></a> 6.2。记忆化</h3>
<div class="paragraph">
<p>记忆允许对闭包调用的结果进行缓存。如果一个函数（关闭）执行的计算速度很慢，这很有趣，但是您知道该函数将经常使用相同的参数来调用。一个典型的例子是斐波那契套件。天真的实现可能看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def fib
fib = { long n -&gt; n&lt;2?n:fib(n-1)+fib(n-2) }
assert fib(15) == 610 // slow!</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个幼稚的实现，因为通常以相同的参数递归调用“ fib”，从而产生指数算法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计算<code>fib(15)</code>需要的结果<code>fib(14)</code>和<code>fib(13)</code></p>
</li>
<li>
<p>计算<code>fib(14)</code>需要的结果<code>fib(13)</code>和<code>fib(12)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于调用是递归的，因此您已经可以看到我们将一次又一次地计算相同的值，尽管它们可以被缓存。可以通过使用以下方法缓存调用结果来“修复”这种简单的实现<code>memoize</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">fib = { long n -&gt; n&lt;2?n:fib(n-1)+fib(n-2) }.memoize()
assert fib(25) == 75025 // fast!</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">缓存<strong>使用参数的实际值工作</strong> 。这意味着，如果将备注与原始类型或装箱原始类型一起使用时，则应格外小心。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用其他方法来调整缓存的行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>memoizeAtMost</code>将生成一个新的闭包， <strong>最多</strong>缓存<em>n个</em>值</p>
</li>
<li>
<p><code>memoizeAtLeast</code>将生成一个新的闭包，该闭包<strong>至少</strong>缓存<em>n个</em>值</p>
</li>
<li>
<p><code>memoizeBetween</code>将生成一个新的闭包，该闭包<strong>至少</strong>缓存<em>n个</em>值<strong>，最多</strong>缓存<em>n</em> <em>个</em>值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有备忘变体中使用的缓存是LRU缓存。</p>
</div>
</div>
<div class="sect2">
<h3 id="_composition"><a class="anchor" href="#_composition"></a> 6.3。组成</h3>
<div class="paragraph">
<p>闭包组成与函数组成的概念相对应，也就是说，通过组成两个或更多函数（链接调用）来创建新函数，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def plus2  = { it + 2 }
def times3 = { it * 3 }

def times3plus2 = plus2 &lt;&lt; times3
assert times3plus2(3) == 11
assert times3plus2(4) == plus2(times3(4))

def plus2times3 = times3 &lt;&lt; plus2
assert plus2times3(3) == 15
assert plus2times3(5) == times3(plus2(5))

// reverse composition
assert times3plus2(3) == (times3 &gt;&gt; plus2)(3)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trampoline"><a class="anchor" href="#_trampoline"></a> 6.4。蹦床</h3>
<div class="paragraph">
<p>递归算法通常受到物理限制：最大堆栈高度。例如，如果您调用的方法递归调用自身的深度过深，则最终将收到一个<code>StackOverflowException</code> 。</p>
</div>
<div class="paragraph">
<p>在这些情况下有帮助的方法是使用<code>Closure</code>及其蹦床的能力。</p>
</div>
<div class="paragraph">
<p>封闭包装在<code>TrampolineClosure</code> 。接到电话后， <code>Closure</code>会叫原件<code>Closure</code>等待结果。如果通话的结果是<code>TrampolineClosure</code> ，可能是由于调用<code>trampoline()</code>方法， <code>Closure</code>将再次被调用。重复执行的返回的Trapolited Closures实例将继续进行，直到获得非Trapolited Closures值为止。 <code>Closure</code>返回。该值将成为蹦床的最终结果。这样，调用是串行进行的，而不是填充堆栈。</p>
</div>
<div class="paragraph">
<p>这是使用<code>trampoline()</code>实现阶乘函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def factorial
factorial = { int n, def accu = 1G -&gt;
    if (n &lt; 2) return accu
    factorial.trampoline(n - 1, n * accu)
}
factorial = factorial.trampoline()

assert factorial(1)    == 1
assert factorial(3)    == 1 * 2 * 3
assert factorial(1000) // == 402387260.. plus another 2560 digits</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_method_pointers"><a class="anchor" href="#_method_pointers"></a> 6.5。方法指针</h3>
<div class="paragraph">
<p>能够使用常规方法作为闭包通常是很实际的。例如，您可能想使用闭包的currying功能，但是普通方法无法使用这些功能。在Groovy中，您可以使用<a href="core-operators.html#method-pointer-operator">方法指针运算符</a>从任何方法获取闭包。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>上次更新时间2019-08-02 18:30:29 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=1">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>