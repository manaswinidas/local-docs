<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Groovy语言文档</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>Groovy语言文档</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel0">
<li><a href="#_introduction">介绍</a>
<ul class="sectlevel1">
<li><a href="#_groovy_language_specification">1。Groovy语言规范</a>
<ul class="sectlevel2">
<li><a href="#_syntax">1.1。句法</a>
<ul class="sectlevel3">
<li><a href="#_comments">1.1.1。评论</a>
<ul class="sectlevel4">
<li><a href="#_single_line_comment">单行注释</a></li>
<li><a href="#_multiline_comment">多行注释</a></li>
<li><a href="#_groovydoc_comment">Groovydoc评论</a></li>
<li><a href="#_shebang_line">社bang线</a></li>
</ul>
</li>
<li><a href="#_keywords">1.1.2。关键词</a></li>
<li><a href="#_identifiers">1.1.3。身份标识</a>
<ul class="sectlevel4">
<li><a href="#_normal_identifiers">普通标识符</a></li>
<li><a href="#_quoted_identifiers">带引号的标识符</a></li>
</ul>
</li>
<li><a href="#all-strings">1.1.4。弦乐</a>
<ul class="sectlevel4">
<li><a href="#_single_quoted_string">单引号字符串</a></li>
<li><a href="#_string_concatenation">字符串串联</a></li>
<li><a href="#_triple_single_quoted_string">三重单引号字符串</a>
<ul class="sectlevel5">
<li><a href="#_escaping_special_characters">转义特殊字符</a></li>
<li><a href="#_unicode_escape_sequence">Unicode转义序列</a></li>
</ul>
</li>
<li><a href="#_double_quoted_string">双引号字符串</a>
<ul class="sectlevel5">
<li><a href="#_string_interpolation">字符串插值</a></li>
<li><a href="#_special_case_of_interpolating_closure_expressions">内插闭包表达式的特殊情况</a></li>
<li><a href="#_interoperability_with_java">与Java的互操作性</a></li>
<li><a href="#_gstring_and_string_hashcodes">GString和String hashCodes</a></li>
</ul>
</li>
<li><a href="#_triple_double_quoted_string">三重双引号字符串</a></li>
<li><a href="#_slashy_string">斜线</a>
<ul class="sectlevel5">
<li><a href="#_special_cases">特别案例</a></li>
</ul>
</li>
<li><a href="#_dollar_slashy_string">美元斜线字符串</a></li>
<li><a href="#_string_summary_table">字符串汇总表</a></li>
<li><a href="#_characters">性格</a></li>
</ul>
</li>
<li><a href="#_numbers">1.1.5。号码</a>
<ul class="sectlevel4">
<li><a href="#_integral_literals">整体文字</a>
<ul class="sectlevel5">
<li><a href="#_alternative_non_base_10_representations">非基数10的替代表示</a>
<ul class="sectlevel6">
<li><a href="#_binary_literal">二进制文字</a></li>
<li><a href="#_octal_literal">八进制文字</a></li>
<li><a href="#_hexadecimal_literal">十六进制文字</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_decimal_literals">小数文字</a></li>
<li><a href="#_underscore_in_literals">在文字下划线</a></li>
<li><a href="#_number_type_suffixes">数字类型后缀</a></li>
<li><a href="#_math_operations">数学运算</a>
<ul class="sectlevel5">
<li><a href="#integer_division">除法运算符的情况</a></li>
<li><a href="#power_operator">电力经营者的情况</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_booleans">1.1.6。布尔值</a></li>
<li><a href="#_lists">1.1.7。清单</a></li>
<li><a href="#_arrays">1.1.8。数组</a></li>
<li><a href="#_maps">1.1.9。地图</a></li>
</ul>
</li>
<li><a href="#groovy-operators">1.2。经营者</a>
<ul class="sectlevel3">
<li><a href="#_arithmetic_operators">1.2.1。算术运算符</a>
<ul class="sectlevel4">
<li><a href="#_normal_arithmetic_operators">普通算术运算符</a></li>
<li><a href="#_unary_operators">一元运算符</a></li>
<li><a href="#_assignment_arithmetic_operators">分配算术运算符</a></li>
</ul>
</li>
<li><a href="#_relational_operators">1.2.2。关系运算符</a></li>
<li><a href="#_logical_operators">1.2.3。逻辑运算符</a>
<ul class="sectlevel4">
<li><a href="#_precedence">优先顺序</a></li>
<li><a href="#_short_circuiting">短路</a></li>
</ul>
</li>
<li><a href="#_bitwise_operators">1.2.4。按位运算符</a></li>
<li><a href="#_conditional_operators">1.2.5。条件运算符</a>
<ul class="sectlevel4">
<li><a href="#_not_operator">不是操作员</a></li>
<li><a href="#_ternary_operator">三元运算符</a></li>
<li><a href="#_elvis_operator">猫王算子</a></li>
</ul>
</li>
<li><a href="#_object_operators">1.2.6。对象运算符</a>
<ul class="sectlevel4">
<li><a href="#_safe_navigation_operator">安全导航员</a></li>
<li><a href="#_direct_field_access_operator">直接现场操作员</a></li>
<li><a href="#method-pointer-operator">方法指针运算符</a></li>
</ul>
</li>
<li><a href="#_regular_expression_operators">1.2.7。正则表达式运算符</a>
<ul class="sectlevel4">
<li><a href="#_pattern_operator">模式运算符</a></li>
<li><a href="#_find_operator">查找运算符</a></li>
<li><a href="#_match_operator">匹配运算符</a></li>
</ul>
</li>
<li><a href="#_other_operators">1.2.8。其他运营商</a>
<ul class="sectlevel4">
<li><a href="#_spread_operator">点差运算符</a>
<ul class="sectlevel5">
<li><a href="#_spreading_method_arguments">传播方法参数</a></li>
<li><a href="#_spread_list_elements">传播列表元素</a></li>
<li><a href="#_spread_map_elements">传播地图元素</a></li>
</ul>
</li>
<li><a href="#_range_operator">范围运算符</a></li>
<li><a href="#_spaceship_operator">飞船操作员</a></li>
<li><a href="#subscript-operator">下标运算符</a></li>
<li><a href="#_membership_operator">会员运营商</a></li>
<li><a href="#_identity_operator">身份运算符</a></li>
<li><a href="#_coercion_operator">强制运算符</a></li>
<li><a href="#_diamond_operator">钻石算子</a></li>
<li><a href="#_call_operator">呼叫接线员</a></li>
</ul>
</li>
<li><a href="#_operator_precedence">1.2.9。运算符优先级</a></li>
<li><a href="#Operator-Overloading">1.2.10。运算符重载</a></li>
</ul>
</li>
<li><a href="#_program_structure">1.3。程序结构</a>
<ul class="sectlevel3">
<li><a href="#_package_names">1.3.1。包装名称</a></li>
<li><a href="#_imports">1.3.2。进口货</a>
<ul class="sectlevel4">
<li><a href="#_default_imports">默认导入</a></li>
<li><a href="#_simple_import">简单导入</a></li>
<li><a href="#_star_import">星级导入</a></li>
<li><a href="#_static_import">静态导入</a></li>
<li><a href="#_static_import_aliasing">静态导入别名</a></li>
<li><a href="#_static_star_import">静态星导入</a></li>
<li><a href="#_import_aliasing">导入别名</a></li>
</ul>
</li>
<li><a href="#_scripts_versus_classes">1.3.3。脚本与类</a>
<ul class="sectlevel4">
<li><a href="#_public_static_void_main_vs_script">公共静态无效主vs脚本</a></li>
<li><a href="#_script_class">脚本类</a></li>
<li><a href="#_methods">方法</a></li>
<li><a href="#_variables">变数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_object_orientation">1.4。面向对象</a>
<ul class="sectlevel3">
<li><a href="#_types">1.4.1。种类</a>
<ul class="sectlevel4">
<li><a href="#_primitive_types">原始类型</a></li>
<li><a href="#_class">类</a>
<ul class="sectlevel5">
<li><a href="#_normal_class">普通班</a></li>
<li><a href="#_inner_class">内部阶层</a>
<ul class="sectlevel6">
<li><a href="#_anonymous_inner_class">匿名内部阶级</a></li>
</ul>
</li>
<li><a href="#_abstract_class">抽象类</a></li>
</ul>
</li>
<li><a href="#_interface">接口</a></li>
<li><a href="#_constructors">建设者</a>
<ul class="sectlevel5">
<li><a href="#_positional_parameters">位置参数</a></li>
<li><a href="#_named_parameters">命名参数</a></li>
</ul>
</li>
<li><a href="#_methods_2">方法</a>
<ul class="sectlevel5">
<li><a href="#_method_definition">方法定义</a></li>
<li><a href="#_named_parameters_2">命名参数</a>
<ul class="sectlevel6">
<li><a href="#_mixing_named_and_positional_parameters">混合命名和位置参数</a></li>
</ul>
</li>
<li><a href="#_default_arguments">默认参数</a></li>
<li><a href="#_varargs">瓦拉格斯</a></li>
<li><a href="#_method_selection_algorithm">方法选择算法</a></li>
<li><a href="#_exception_declaration">异常声明</a></li>
</ul>
</li>
<li><a href="#_fields_and_properties">字段和属性</a>
<ul class="sectlevel5">
<li><a href="#fields">领域</a></li>
<li><a href="#properties">性质</a></li>
</ul>
</li>
<li><a href="#_annotation">注解</a>
<ul class="sectlevel5">
<li><a href="#ann-definition">注释定义</a></li>
<li><a href="#ann-placement">注解位置</a></li>
<li><a href="#_annotation_member_values">注释成员值</a></li>
<li><a href="#_retention_policy">保留政策</a></li>
<li><a href="#_closure_annotation_parameters">闭包注释参数</a></li>
<li><a href="#_meta_annotations">元注释</a>
<ul class="sectlevel6">
<li><a href="#_declaring_meta_annotations">声明元注释</a></li>
<li><a href="#meta-ann-behavior">元注释的行为</a></li>
<li><a href="#meta-ann-members">元注释参数</a></li>
<li><a href="#handling_duplicate_annotations">处理重复的注释</a></li>
<li><a href="#meta-ann-processor">自定义注释处理器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_inheritance">遗产</a></li>
<li><a href="#generics">泛型</a></li>
</ul>
</li>
<li><a href="#_traits">1.4.2。特质</a>
<ul class="sectlevel4">
<li><a href="#_methods_3">方法</a>
<ul class="sectlevel5">
<li><a href="#_public_methods">公开方法</a></li>
<li><a href="#_abstract_methods">抽象方法</a></li>
<li><a href="#_private_methods">私人方法</a></li>
<li><a href="#_final_methods">最终方法</a></li>
</ul>
</li>
<li><a href="#_the_meaning_of_this">这个的意思</a></li>
<li><a href="#_interfaces">介面</a></li>
<li><a href="#_properties">性质</a></li>
<li><a href="#_fields">领域</a>
<ul class="sectlevel5">
<li><a href="#_private_fields">私人领域</a></li>
<li><a href="#_public_fields">公共领域</a></li>
</ul>
</li>
<li><a href="#_composition_of_behaviors">行为组成</a></li>
<li><a href="#_overriding_default_methods">覆盖默认方法</a></li>
<li><a href="#_extending_traits">扩展特征</a>
<ul class="sectlevel5">
<li><a href="#_simple_inheritance">简单继承</a></li>
<li><a href="#_multiple_inheritance">多重继承</a></li>
</ul>
</li>
<li><a href="#_duck_typing_and_traits">鸭的打字和特征</a>
<ul class="sectlevel5">
<li><a href="#_dynamic_code">动态代码</a></li>
<li><a href="#_dynamic_methods_in_a_trait">特征中的动态方法</a></li>
</ul>
</li>
<li><a href="#_multiple_inheritance_conflicts">多重继承冲突</a>
<ul class="sectlevel5">
<li><a href="#_default_conflict_resolution">默认冲突解决</a></li>
<li><a href="#_user_conflict_resolution">解决用户冲突</a></li>
</ul>
</li>
<li><a href="#_runtime_implementation_of_traits">特征的运行时实现</a>
<ul class="sectlevel5">
<li><a href="#_implementing_a_trait_at_runtime">在运行时实现特征</a></li>
<li><a href="#_implementing_multiple_traits_at_once">一次实现多个特征</a></li>
</ul>
</li>
<li><a href="#_chaining_behavior">链接行为</a>
<ul class="sectlevel5">
<li><a href="#_semantics_of_super_inside_a_trait">特征特质的超语义</a></li>
</ul>
</li>
<li><a href="#_advanced_features">高级功能</a>
<ul class="sectlevel5">
<li><a href="#_sam_type_coercion">SAM型强制</a></li>
<li><a href="#_differences_with_java_8_default_methods">Java 8默认方法的差异</a></li>
</ul>
</li>
<li><a href="#_differences_with_mixins">mixins的差异</a></li>
<li><a href="#_static_methods_properties_and_fields">静态方法，属性和字段</a></li>
<li><a href="#_inheritance_of_state_gotchas">状态陷阱的继承</a></li>
<li><a href="#_self_types">自我类型</a>
<ul class="sectlevel5">
<li><a href="#_type_constraints_on_traits">特征的类型约束</a></li>
<li><a href="#traits-selftype">@SelfType批注</a></li>
</ul>
</li>
<li><a href="#_limitations">局限性</a>
<ul class="sectlevel5">
<li><a href="#_compatibility_with_ast_transformations">与AST转换的兼容性</a></li>
<li><a href="#_prefix_and_postfix_operations">前缀和后缀操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_closures">1.5。关闭</a>
<ul class="sectlevel3">
<li><a href="#_syntax_2">1.5.1。句法</a>
<ul class="sectlevel4">
<li><a href="#_defining_a_closure">定义闭包</a></li>
<li><a href="#closure-as-object">封闭对象</a></li>
<li><a href="#_calling_a_closure">调用关闭</a></li>
</ul>
</li>
<li><a href="#_parameters">1.5.2。参量</a>
<ul class="sectlevel4">
<li><a href="#_normal_parameters">普通参数</a></li>
<li><a href="#implicit-it">隐式参数</a></li>
<li><a href="#_varargs_2">瓦拉格斯</a></li>
</ul>
</li>
<li><a href="#_delegation_strategy">1.5.3。授权策略</a>
<ul class="sectlevel4">
<li><a href="#_groovy_closures_vs_lambda_expressions">Groovy闭包与Lambda表达式</a></li>
<li><a href="#closure-owner">所有者，委托人和这个</a>
<ul class="sectlevel5">
<li><a href="#closure-this">这个的意思</a></li>
<li><a href="#_owner_of_a_closure">封闭的所有者</a></li>
<li><a href="#_delegate_of_a_closure">委托结束</a></li>
<li><a href="#_delegation_strategy_2">授权策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_closures_in_gstrings">1.5.4。GString中的闭包</a></li>
<li><a href="#_closure_coercion">1.5.5。强制关闭</a></li>
<li><a href="#_functional_programming">1.5.6。功能编程</a>
<ul class="sectlevel4">
<li><a href="#_currying">咖喱</a>
<ul class="sectlevel5">
<li><a href="#_left_currying">左弯曲</a></li>
<li><a href="#_right_currying">右弯曲</a></li>
<li><a href="#_index_based_currying">基于索引的货币</a></li>
</ul>
</li>
<li><a href="#_memoization">记忆化</a></li>
<li><a href="#_composition">组成</a></li>
<li><a href="#_trampoline">蹦床</a></li>
<li><a href="#_method_pointers">方法指针</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_semantics">1.6。语义学</a>
<ul class="sectlevel3">
<li><a href="#_statements">1.6.1。陈述</a>
<ul class="sectlevel4">
<li><a href="#_variable_definition">变量定义</a></li>
<li><a href="#_variable_assignment">变量分配</a>
<ul class="sectlevel5">
<li><a href="#_multiple_assignment">多重分配</a></li>
<li><a href="#_overflow_and_underflow">上溢和下溢</a></li>
<li><a href="#_object_destructuring_with_multiple_assignment">具有多个分配的对象分解</a></li>
</ul>
</li>
<li><a href="#_control_structures">控制结构</a>
<ul class="sectlevel5">
<li><a href="#_conditional_structures">条件结构</a>
<ul class="sectlevel6">
<li><a href="#_if_else">如果别的</a></li>
<li><a href="#_switch_case">开关/箱</a></li>
</ul>
</li>
<li><a href="#_looping_structures">循环结构</a>
<ul class="sectlevel6">
<li><a href="#_classic_for_loop">经典循环</a></li>
<li><a href="#_for_in_loop">循环中</a></li>
<li><a href="#_while_loop">while循环</a></li>
</ul>
</li>
<li><a href="#_exception_handling">异常处理</a></li>
<li><a href="#_try_catch_finally">尝试/抓住/最后</a></li>
<li><a href="#_multi_catch">多渔获</a></li>
</ul>
</li>
<li><a href="#_power_assertion">权力主张</a></li>
<li><a href="#_labeled_statements">带标签的声明</a></li>
</ul>
</li>
<li><a href="#_expressions">1.6.2。表达方式</a>
<ul class="sectlevel4">
<li><a href="#gpath_expressions">GPath表达式</a>
<ul class="sectlevel5">
<li><a href="#_object_navigation">对象导航</a></li>
<li><a href="#_expression_deconstruction">表达解构</a></li>
<li><a href="#_gpath_for_xml_navigation">用于XML导航的GPath</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_promotion_and_coercion">1.6.3。促进和强迫</a>
<ul class="sectlevel4">
<li><a href="#_number_promotion">号码促销</a></li>
<li><a href="#closure-coercion">强制关闭</a>
<ul class="sectlevel5">
<li><a href="#_assigning_a_closure_to_a_sam_type">为SAM类型分配闭包</a></li>
<li><a href="#_calling_a_method_accepting_a_sam_type_with_a_closure">用闭包调用接受SAM类型的方法</a></li>
<li><a href="#_closure_to_arbitrary_type_coercion">对任意类型强制的关闭</a></li>
</ul>
</li>
<li><a href="#_map_to_type_coercion">映射为强制类型</a></li>
<li><a href="#_string_to_enum_coercion">强制枚举的字符串</a></li>
<li><a href="#_custom_type_coercion">自定义类型强制</a></li>
<li><a href="#_class_literals_vs_variables_and_the_as_operator">类文字，变量和as运算符</a></li>
</ul>
</li>
<li><a href="#_optionality">1.6.4。可选性</a>
<ul class="sectlevel4">
<li><a href="#_optional_parentheses">可选括号</a></li>
<li><a href="#_optional_semicolons">可选分号</a></li>
<li><a href="#_optional_return_keyword">可选的return关键字</a></li>
<li><a href="#_optional_public_keyword">可选的公共关键字</a></li>
</ul>
</li>
<li><a href="#Groovy-Truth">1.6.5。时髦的真相</a>
<ul class="sectlevel4">
<li><a href="#_boolean_expressions">布尔表达式</a></li>
<li><a href="#_collections_and_arrays">集合和数组</a></li>
<li><a href="#_matchers">匹配器</a></li>
<li><a href="#_iterators_and_enumerations">迭代器和枚举</a></li>
<li><a href="#_maps_2">地图</a></li>
<li><a href="#_strings">弦乐</a></li>
<li><a href="#_numbers_2">号码</a></li>
<li><a href="#_object_references">对象引用</a></li>
<li><a href="#_customizing_the_truth_with_asboolean_methods">使用asBoolean（）方法自定义真相</a></li>
</ul>
</li>
<li><a href="#_typing">1.6.6。打字</a>
<ul class="sectlevel4">
<li><a href="#_optional_typing">可选输入</a></li>
<li><a href="#static-type-checking">静态类型检查</a>
<ul class="sectlevel5">
<li><a href="#_the_code_typechecked_code_annotation">的<code>@TypeChecked</code>注解</a>
<ul class="sectlevel6">
<li><a href="#_activating_type_checking_at_compile_time">在编译时激活类型检查</a></li>
<li><a href="#_skipping_sections">跳过部分</a></li>
</ul>
</li>
<li><a href="#_type_checking_assignments">类型检查分配</a></li>
<li><a href="#_list_and_map_constructors">列表和地图构造函数</a></li>
<li><a href="#_method_resolution">方法解析</a></li>
<li><a href="#type-inference">类型推断</a>
<ul class="sectlevel6">
<li><a href="#_principles">原则</a></li>
<li><a href="#_variables_vs_fields_in_type_inference">类型推断中的变量与字段</a></li>
<li><a href="#_collection_literal_type_inference">集合文字类型推断</a></li>
<li><a href="#section-lub">最小上限</a></li>
<li><a href="#_instanceof_inference">推理实例</a></li>
<li><a href="#section-flow-typing">流式</a></li>
<li><a href="#_advanced_type_inference">高级类型推断</a></li>
</ul>
</li>
<li><a href="#_closures_and_type_inference">闭包和类型推断</a>
<ul class="sectlevel6">
<li><a href="#_return_type_inference">返回类型推断</a></li>
<li><a href="#_parameter_type_inference">参数类型推断</a>
<ul class="sectlevel7">
<li><a href="#_explicit_closure_parameters">显式关闭参数</a></li>
<li><a href="#_parameters_inferred_from_single_abstract_method_types">从单抽象方法类型推断出的参数</a></li>
<li><a href="#_the_code_closureparams_code_annotation">的<code>@ClosureParams</code>注解</a></li>
</ul>
</li>
<li><a href="#_code_delegatesto_code"><code>@DelegatesTo</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_static_compilation">静态编译</a>
<ul class="sectlevel5">
<li><a href="#_dynamic_vs_static">动态与静态</a></li>
<li><a href="#compilestatic-annotation">的<code>@CompileStatic</code>注解</a></li>
<li><a href="#_key_benefits">主要好处</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_type_checking_extensions">1.6.7。类型检查扩展</a>
<ul class="sectlevel4">
<li><a href="#_writing_a_type_checking_extension">编写类型检查扩展</a>
<ul class="sectlevel5">
<li><a href="#_towards_a_smarter_type_checker">迈向更智能的类型检查器</a></li>
<li><a href="#Typecheckingextensions-Howdoesitwork">扩展属性</a></li>
<li><a href="#_a_dsl_for_type_checking">DSL用于类型检查</a></li>
<li><a href="#Typecheckingextensions-TheAPI">类型检查扩展API</a>
<ul class="sectlevel6">
<li><a href="#Typecheckingextensions-AST">AST</a></li>
<li><a href="#Typecheckingextensions-Events">大事记</a></li>
</ul>
</li>
<li><a href="#Typecheckingextensions-Workingwithextensions">使用扩展</a>
<ul class="sectlevel6">
<li><a href="#Typecheckingextensions-Supportclasses">支援课程</a></li>
<li><a href="#Typecheckingextensions-Classnodes">类节点</a></li>
<li><a href="#Typecheckingextensions-Helpingthetypechecker">帮助类型检查器</a></li>
<li><a href="#Typecheckingextensions-Throwinganerror">引发错误</a></li>
<li><a href="#Typecheckingextensions-isXXXExpression">isXXXExpression</a></li>
<li><a href="#Typecheckingextensions-Virtualmethods">虚方法</a></li>
<li><a href="#Typecheckingextensions-Scoping">范围界定</a></li>
<li><a href="#Typecheckingextensions-Otherusefulmethods">其他有用的方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_advanced_type_checking_extensions">高级类型检查扩展</a>
<ul class="sectlevel5">
<li><a href="#_precompiled_type_checking_extensions">预编译类型检查扩展</a></li>
<li><a href="#_using_grab_in_a_type_checking_extension">在类型检查扩展中使用@Grab</a></li>
<li><a href="#_sharing_or_packaging_type_checking_extensions">共享或打包类型检查扩展</a></li>
<li><a href="#_global_type_checking_extensions">全局类型检查扩展</a></li>
<li><a href="#_type_checking_extensions_and_compilestatic">类型检查扩展名和@CompileStatic</a></li>
<li><a href="#mixed-mode">混合模式编译</a></li>
<li><a href="#ast-xform-as-extension">在扩展中转换AST</a></li>
<li><a href="#_examples">例子</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tools">2。工具类</a>
<ul class="sectlevel2">
<li><a href="#_running_groovy_from_the_commandline">2.1。从命令行运行Groovy</a>
<ul class="sectlevel3">
<li><a href="#section-groovy-commandline">2.1.1。 groovy，Groovy命令</a></li>
</ul>
</li>
<li><a href="#_compiling_groovy">2.2。编译Groovy</a>
<ul class="sectlevel3">
<li><a href="#section-groovyc-compiler">2.2.1。 groovyc，Groovy编译器</a></li>
<li><a href="#_ant_task">2.2.2。蚂蚁任务</a>
<ul class="sectlevel4">
<li><a href="#ThegroovycAntTask-groovyc"><code><groovyc></code></a>
<ul class="sectlevel5">
<li><a href="#ThegroovycAntTask-Description">描述</a></li>
<li><a href="#ThegroovycAntTask-Requiredtaskdef">必需的taskdef</a></li>
<li><a href="#ThegroovycAntTask-groovycAttributes"><groovyc>属性</groovyc></a></li>
<li><a href="#ThegroovycAntTask-groovycNestedElements"><groovyc>嵌套元素</groovyc></a></li>
<li><a href="#ThegroovycAntTask-JointCompilation">联合编译</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Gant">2.2.3。甘特</a></li>
<li><a href="#Gradle">2.2.4。摇篮</a></li>
<li><a href="#_maven_integration">2.2.5。Maven整合</a>
<ul class="sectlevel4">
<li><a href="#_gmaven_and_gmavenplus">GMaven和GMavenPlus</a>
<ul class="sectlevel5">
<li><a href="#section-gmaven">GMaven</a></li>
<li><a href="#section-gmavenplus">GMavenPlus</a></li>
<li><a href="#section-gmaven2">GMaven 2</a></li>
</ul>
</li>
<li><a href="#section-groovyeclipse">Groovy Eclipse Maven插件</a></li>
</ul>
</li>
<li><a href="#section-jointcompilation">2.2.6。联合编制</a></li>
<li><a href="#section-android">2.2.7。Android支持</a></li>
</ul>
</li>
<li><a href="#_groovysh_the_groovy_shell">2.3。Groovysh，Groovy外壳</a>
<ul class="sectlevel3">
<li><a href="#_groovy_groovy_shell">2.3.1。Groovy：Groovy Shell</a>
<ul class="sectlevel4">
<li><a href="#GroovyShell-Features">特征</a></li>
<li><a href="#GroovyShell-Command-lineOptionsandArguments">命令行选项和参数</a></li>
<li><a href="#GroovyShell-EvaluatingExpressions">计算表达式</a>
<ul class="sectlevel5">
<li><a href="#GroovyShell-SimpleExpressions">简单表达</a></li>
<li><a href="#GroovyShell-EvaluationResult">评价结果</a></li>
<li><a href="#GroovyShell-Multi-lineExpressions">多行表达式</a>
<ul class="sectlevel6">
<li><a href="#GroovyShell-DefineaClass">定义一个类</a></li>
<li><a href="#GroovyShell-UsetheClass">使用课程</a></li>
</ul>
</li>
<li><a href="#GroovyShell-Variables">变数</a></li>
<li><a href="#GroovyShell-Functions">功能</a></li>
</ul>
</li>
<li><a href="#GroovyShell-Commands">指令</a>
<ul class="sectlevel5">
<li><a href="#GroovyShell-RecognizedCommands">公认的命令</a>
<ul class="sectlevel6">
<li><a href="#GroovyShell-help"><code>help</code></a></li>
<li><a href="#GroovyShell-exit"><code>exit</code></a></li>
<li><a href="#GroovyShell-import"><code>import</code></a></li>
<li><a href="#GroovyShell-grab"><code>grab</code></a></li>
<li><a href="#GroovyShell-display"><code>display</code></a></li>
<li><a href="#GroovyShell-clear"><code>clear</code></a></li>
<li><a href="#GroovyShell-show"><code>show</code></a></li>
<li><a href="#GroovyShell-inspect"><code>inspect</code></a></li>
<li><a href="#GroovyShell-purge"><code>purge</code></a></li>
<li><a href="#GroovyShell-edit"><code>edit</code></a></li>
<li><a href="#GroovyShell-load"><code>load</code></a></li>
<li><a href="#GroovyShell-save"><code>save</code></a></li>
<li><a href="#GroovyShell-record"><code>record</code></a></li>
<li><a href="#GroovyShell-history"><code>history</code></a></li>
<li><a href="#GroovyShell-alias"><code>alias</code></a></li>
<li><a href="#GroovyShell-doc"><code>doc</code></a></li>
<li><a href="#GroovyShell-set"><code>set</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#GroovyShell-Preferences">优先</a>
<ul class="sectlevel5">
<li><a href="#GroovyShell-RecognizedPreferences">公认的偏好</a>
<ul class="sectlevel6">
<li><a href="#GroovyShell-InterpreterMode"><code>interpreterMode</code></a></li>
<li><a href="#GroovyShell-verbosity"><code>verbosity</code></a></li>
<li><a href="#_code_colors_code"><code>colors</code></a></li>
<li><a href="#GroovyShell-show-last-result"><code>show-last-result</code></a></li>
<li><a href="#GroovyShell-sanitize-stack-trace"><code>sanitize-stack-trace</code></a></li>
<li><a href="#GroovyShell-editor"><code>editor</code></a></li>
</ul>
</li>
<li><a href="#GroovyShell-SettingaPreference">设定偏好</a></li>
<li><a href="#GroovyShell-ListingPreferences">列表首选项</a></li>
<li><a href="#GroovyShell-ClearingPreferencesieResettingtoDefaults">清除首选项（即重置为默认值）</a></li>
</ul>
</li>
<li><a href="#GroovyShell-UserProfileScriptsandState">用户配置文件脚本和状态</a>
<ul class="sectlevel5">
<li><a href="#GroovyShell-ProfileScripts">配置文件脚本</a>
<ul class="sectlevel6">
<li><a href="#GroovyShell-HOMEgroovygroovyshprofile"><code>$HOME/.groovy/groovysh.profile</code></a></li>
<li><a href="#GroovyShell-HOMEgroovygroovyshrc"><code>$HOME/.groovy/groovysh.rc</code></a></li>
</ul>
</li>
<li><a href="#GroovyShell-State">州</a>
<ul class="sectlevel6">
<li><a href="#GroovyShell-HOMEgroovygroovyshhistory"><code>$HOME/.groovy/groovysh.history</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#GroovyShell-register">自定义命令</a></li>
<li><a href="#GroovyShell-Troubleshooting">故障排除</a>
<ul class="sectlevel5">
<li><a href="#GroovyShell-PlatformProblems">平台问题</a>
<ul class="sectlevel6">
<li><a href="#GroovyShell-ProblemsloadingtheJLineDLL">加载JLine DLL时出现问题</a></li>
<li><a href="#GroovyShell-ProblemswithCygwinonWindows">Windows上的Cygwin问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#GroovyShell-GMavenPlus">2.3.2。GMavenPlus Maven插件</a></li>
<li><a href="#GroovyShell-GradleGroovyshPlugin">2.3.3。Gradle Groovysh插件</a></li>
</ul>
</li>
<li><a href="#_groovyconsole_the_groovy_swing_console">2.4。 groovy控制台，Groovy摇摆控制台</a>
<ul class="sectlevel3">
<li><a href="#title-heading">2.4.1。Groovy：Groovy控制台</a></li>
<li><a href="#GroovyConsole-Basics">2.4.2。基本</a></li>
<li><a href="#GroovyConsole-Features">2.4.3。特征</a>
<ul class="sectlevel4">
<li><a href="#GroovyConsole-Command-lineOptionsandArguments">命令行选项和参数</a></li>
<li><a href="#GroovyConsole-RunningScripts">运行脚本</a></li>
<li><a href="#GroovyConsole-EditingFiles">编辑档案</a></li>
<li><a href="#GroovyConsole-Historyandresults">历史和结果</a></li>
<li><a href="#GroovyConsole-Interrupt">中断脚本</a></li>
<li><a href="#GroovyConsole-Andmore">和更多</a></li>
</ul>
</li>
<li><a href="#GroovyConsole-EmbeddingtheConsole">2.4.4。嵌入控制台</a></li>
<li><a href="#GroovyConsole-Visualizingscriptoutputresults">2.4.5。可视化脚本输出结果</a></li>
<li><a href="#GroovyConsole-ASTbrowser">2.4.6。AST浏览器</a></li>
</ul>
</li>
<li><a href="#_groovydoc_the_groovy_java_documentation_generator">2.5。 groovydoc，Groovy和Java文档生成器</a>
<ul class="sectlevel3">
<li><a href="#Groovydoc-CommandLine">2.5.1。groovydoc命令行工具</a></li>
<li><a href="#Groovydoc-Ant">2.5.2。groovydoc Ant任务</a>
<ul class="sectlevel4">
<li><a href="#ThegroovydocAnttask-Requiredtaskdef">必需的taskdef</a></li>
<li><a href="#ThegroovydocAnttask-groovydocAttributes"><groovydoc>属性</groovydoc></a></li>
<li><a href="#ThegroovydocAnttask-groovydocNestedElements"><groovydoc>嵌套元素</groovydoc></a>
<ul class="sectlevel5">
<li><a href="#ThegroovydocAnttask-link">链接</a></li>
<li><a href="#ThegroovydocAnttask-Example1-groovydocAnttask">Example＃1- <groovydoc>Ant任务</groovydoc></a></li>
<li><a href="#ThegroovydocAnttask-Example2-ExecutinggroovydocfromGroovy">示例＃2- <groovydoc>从Groovy</groovydoc>执行</a></li>
</ul>
</li>
<li><a href="#_custom_templates">自定义模板</a>
<ul class="sectlevel5">
<li><a href="#_custom_groovydoc_class">自定义Groovydoc类</a></li>
<li><a href="#_using_the_custom_groovydoc_task">使用自定义groovydoc任务</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Groovydoc-GMavenPlus">2.5.3。GMavenPlus Maven插件</a></li>
</ul>
</li>
<li><a href="#_ide_integration">2.6。IDE整合</a></li>
</ul>
</li>
<li><a href="#_user_guides">3。用户指南</a>
<ul class="sectlevel2">
<li><a href="#_getting_started">3.1。入门</a>
<ul class="sectlevel3">
<li><a href="#_download">3.1.1。下载</a>
<ul class="sectlevel4">
<li><a href="#_stable">稳定</a></li>
<li><a href="#_snapshots">快照</a></li>
<li><a href="#_prerequisites">先决条件</a></li>
</ul>
</li>
<li><a href="#_maven_repository">3.1.2。Maven仓库</a>
<ul class="sectlevel4">
<li><a href="#_stable_release">稳定释放</a></li>
</ul>
</li>
<li><a href="#SDKMAN">3.1.3。SDKMAN！（软件开发套件管理器）</a></li>
<li><a href="#_other_ways_to_get_groovy">3.1.4。其他获得Groovy的方法</a>
<ul class="sectlevel4">
<li><a href="#_installation_on_mac_os_x">在Mac OS X上安装</a>
<ul class="sectlevel5">
<li><a href="#_macports">MacPorts</a></li>
<li><a href="#_homebrew">家酿</a></li>
</ul>
</li>
<li><a href="#_installation_on_windows">在Windows上安装</a></li>
<li><a href="#_other_distributions">其他发行</a></li>
<li><a href="#_source_code">源代码</a></li>
<li><a href="#_ide_plugin">IDE插件</a></li>
</ul>
</li>
<li><a href="#_install_binary">3.1.5。安装二进制</a></li>
</ul>
</li>
<li><a href="#_differences_with_java">3.2。与Java的差异</a>
<ul class="sectlevel3">
<li><a href="#_default_imports_2">3.2.1。默认导入</a></li>
<li><a href="#_multi_methods">3.2.2。多方法</a></li>
<li><a href="#_array_initializers">3.2.3。数组初始化器</a></li>
<li><a href="#_package_scope_visibility">3.2.4。包范围可见性</a></li>
<li><a href="#_arm_blocks">3.2.5。ARM块</a></li>
<li><a href="#_inner_classes">3.2.6。内部班</a>
<ul class="sectlevel4">
<li><a href="#_static_inner_classes">静态内部类</a></li>
<li><a href="#_anonymous_inner_classes">匿名内部类</a></li>
<li><a href="#_creating_instances_of_non_static_inner_classes">创建非静态内部类的实例</a></li>
</ul>
</li>
<li><a href="#_lambdas">3.2.7。Lambdas</a></li>
<li><a href="#_gstrings">3.2.8。GStrings</a></li>
<li><a href="#_string_and_character_literals">3.2.9。字符串和字符文字</a></li>
<li><a href="#_primitives_and_wrappers">3.2.10。基元和包装</a></li>
<li><a href="#_behaviour_of_code_code">3.2.11。的行为<code>==</code></a></li>
<li><a href="#_conversions">3.2.12。转换次数</a></li>
<li><a href="#_extra_keywords">3.2.13。额外关键字</a></li>
</ul>
</li>
<li><a href="#_groovy_development_kit">3.3。Groovy开发套件</a>
<ul class="sectlevel3">
<li><a href="#_working_with_io">3.3.1。使用IO</a>
<ul class="sectlevel4">
<li><a href="#_reading_files">读取文件</a></li>
<li><a href="#_writing_files">写文件</a></li>
<li><a href="#_traversing_file_trees">遍历文件树</a></li>
<li><a href="#_data_and_objects">数据与对象</a></li>
<li><a href="#process-management">执行外部流程</a></li>
</ul>
</li>
<li><a href="#_working_with_collections">3.3.2。使用收藏</a>
<ul class="sectlevel4">
<li><a href="#Collections-Lists">清单</a>
<ul class="sectlevel5">
<li><a href="#_list_literals">列出文字</a></li>
<li><a href="#_list_as_a_boolean_expression">以布尔表达式形式列出</a></li>
<li><a href="#_iterating_on_a_list">迭代列表</a></li>
<li><a href="#_manipulating_lists">操作清单</a>
<ul class="sectlevel6">
<li><a href="#List-Filtering">筛选和搜索</a></li>
<li><a href="#_adding_or_removing_elements">添加或删除元素</a></li>
<li><a href="#_set_operations">设定操作</a></li>
<li><a href="#_sorting">排序</a></li>
<li><a href="#_duplicating_elements">复制元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Collections-Maps">地图</a>
<ul class="sectlevel5">
<li><a href="#_map_literals">地图文字</a></li>
<li><a href="#_map_property_notation">地图属性符号</a></li>
<li><a href="#_iterating_on_maps">在地图上迭代</a></li>
<li><a href="#_manipulating_maps">操纵地图</a>
<ul class="sectlevel6">
<li><a href="#_adding_or_removing_elements_2">添加或删除元素</a></li>
<li><a href="#JN1035-Maps-Collectionviewsofamap">键，值和条目</a></li>
<li><a href="#_filtering_and_searching">筛选和搜索</a></li>
<li><a href="#Maps-Grouping">分组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Collections-Ranges">范围</a></li>
<li><a href="#_syntax_enhancements_for_collections">集合的语法增强</a>
<ul class="sectlevel5">
<li><a href="#_gpath_support">GPath支持</a></li>
<li><a href="#_spread_operator_2">点差运算符</a></li>
<li><a href="#Collections-Gettingefficientwiththestar-dotoperator">星点“ *”。算子</a></li>
<li><a href="#Collections-Slicingwiththesubscriptoperator">下标运算符切片</a></li>
</ul>
</li>
<li><a href="#Collections-EnhancedCollectionMethods">增强的收集方法</a></li>
</ul>
</li>
<li><a href="#_working_with_legacy_date_calendar_types">3.3.3。使用旧的日期/日历类型</a></li>
<li><a href="#_working_with_date_time_types">3.3.4。处理日期/时间类型</a>
<ul class="sectlevel4">
<li><a href="#_formatting_and_parsing">格式化和解析</a></li>
<li><a href="#_manipulating_date_time">处理日期/时间</a>
<ul class="sectlevel5">
<li><a href="#_addition_and_subtraction">加减</a></li>
<li><a href="#_multiplication_and_division">乘法与除法</a></li>
<li><a href="#_incrementing_and_decrementing">递增和递减</a></li>
<li><a href="#_negation">否定</a></li>
</ul>
</li>
<li><a href="#_interacting_with_date_time_values">与日期/时间值交互</a>
<ul class="sectlevel5">
<li><a href="#_property_notation">属性符号</a></li>
<li><a href="#_ranges_code_upto_code_and_code_downto_code">范围<code>upto</code>和<code>downto</code></a></li>
<li><a href="#_combining_date_time_values">合并日期/时间值</a></li>
<li><a href="#_creating_periods_and_durations">创建期间和持续时间</a></li>
</ul>
</li>
<li><a href="#_converting_between_legacy_and_jsr_310_types">在旧版和JSR 310类型之间转换</a></li>
</ul>
</li>
<li><a href="#_handy_utilities">3.3.5。方便的实用程序</a>
<ul class="sectlevel4">
<li><a href="#_configslurper">ConfigSlurper</a></li>
<li><a href="#_expando">Expando</a></li>
<li><a href="#_observable_list_map_and_set">可观察的列表，地图和集合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_metaprogramming">3.4。元编程</a>
<ul class="sectlevel3">
<li><a href="#_runtime_metaprogramming">3.4.1。运行时元编程</a>
<ul class="sectlevel4">
<li><a href="#_groovyobject_interface">GroovyObject接口</a>
<ul class="sectlevel5">
<li><a href="#_invokemethod">invokeMethod</a></li>
<li><a href="#_get_setproperty">get / setProperty</a></li>
<li><a href="#_get_setmetaclass">get / setMetaClass</a></li>
</ul>
</li>
<li><a href="#_get_setattribute">get / setAttribute</a></li>
<li><a href="#_methodmissing">方法缺失</a></li>
<li><a href="#_propertymissing">属性缺失</a></li>
<li><a href="#_static_methodmissing">静态方法</a></li>
<li><a href="#_static_propertymissing">静态属性缺失</a></li>
<li><a href="#_groovyinterceptable">GroovyInterceptable</a></li>
<li><a href="#categories">分类目录</a></li>
<li><a href="#_metaclasses">元类</a>
<ul class="sectlevel5">
<li><a href="#_the_default_metaclass_code_metaclassimpl_code">默认元类<code>MetaClassImpl</code></a></li>
<li><a href="#_custom_metaclasses">自定义元类</a>
<ul class="sectlevel6">
<li><a href="#_delegating_metaclass">委托元类</a></li>
<li><a href="#_magic_package">魔术包</a></li>
</ul>
</li>
<li><a href="#_per_instance_metaclass">每个实例元类</a></li>
<li><a href="#metaprogramming_emc">ExpandoMetaClass</a>
<ul class="sectlevel6">
<li><a href="#_methods_4">方法</a></li>
<li><a href="#_properties_2">性质</a></li>
<li><a href="#_constructors_2">建设者</a></li>
<li><a href="#_static_methods">静态方法</a></li>
<li><a href="#_borrowing_methods">借用方法</a></li>
<li><a href="#_dynamic_method_names">动态方法名称</a></li>
<li><a href="#_runtime_discovery">运行时发现</a></li>
<li><a href="#_groovyobject_methods">GroovyObject方法</a></li>
<li><a href="#_overriding_static_invokemethod">重写静态invokeMethod</a></li>
<li><a href="#_extending_interfaces">扩展接口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_extension_modules">扩展模块</a>
<ul class="sectlevel5">
<li><a href="#_extending_existing_classes">扩展现有课程</a></li>
<li><a href="#_instance_methods">实例方法</a></li>
<li><a href="#_static_methods_2">静态方法</a></li>
<li><a href="#module-descriptor">模块描述符</a></li>
<li><a href="#_extension_modules_and_classpath">扩展模块和类路径</a></li>
<li><a href="#_compatibility_with_type_checking">与类型检查的兼容性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_compile_time_metaprogramming">3.4.2。编译时元编程</a>
<ul class="sectlevel4">
<li><a href="#_available_ast_transformations">可用的AST转换</a>
<ul class="sectlevel5">
<li><a href="#_code_generation_transformations">代码生成转换</a>
<ul class="sectlevel6">
<li><a href="#xform-ToString"><code>@groovy.transform.ToString</code></a></li>
<li><a href="#xform-EqualsAndHashCode"><code>@groovy.transform.EqualsAndHashCode</code></a></li>
<li><a href="#xform-TupleConstructor"><code>@groovy.transform.TupleConstructor</code></a></li>
<li><a href="#_implementation_details">实施细节</a></li>
<li><a href="#_immutability_support">不变性支持</a></li>
<li><a href="#_customization_options">定制选项</a></li>
<li><a href="#xform-MapConstructor"><code>@groovy.transform.MapConstructor</code></a></li>
<li><a href="#xform-Canonical"><code>@groovy.transform.Canonical</code></a></li>
<li><a href="#xform-InheritConstructors"><code>@groovy.transform.InheritConstructors</code></a></li>
<li><a href="#xform-Category"><code>@groovy.lang.Category</code></a></li>
<li><a href="#xform-IndexedProperty"><code>@groovy.transform.IndexedProperty</code></a></li>
<li><a href="#xform-Lazy"><code>@groovy.lang.Lazy</code></a></li>
<li><a href="#xform-Newify"><code>@groovy.lang.Newify</code></a></li>
<li><a href="#xform-Sortable"><code>@groovy.transform.Sortable</code></a></li>
<li><a href="#xform-Builder"><code>@groovy.transform.builder.Builder</code></a></li>
<li><a href="#xform-AutoImplement"><code>@groovy.transform.AutoImplement</code></a></li>
</ul>
</li>
<li><a href="#_class_design_annotations">类设计注释</a>
<ul class="sectlevel6">
<li><a href="#xform-BaseScript"><code>@groovy.transform.BaseScript</code></a></li>
<li><a href="#xform-Delegate"><code>@groovy.lang.Delegate</code></a></li>
<li><a href="#xform-Immutable"><code>@groovy.transform.Immutable</code></a></li>
<li><a href="#xform-ImmutableBase"><code>@groovy.transform.ImmutableBase</code></a></li>
<li><a href="#xform-PropertyOptions"><code>@groovy.transform.PropertyOptions</code></a></li>
<li><a href="#xform-VisibilityOptions"><code>@groovy.transform.VisibilityOptions</code></a></li>
<li><a href="#xform-ImumtableOptions"><code>@groovy.transform.ImmutableOptions</code></a></li>
<li><a href="#xform-KnownImmutable"><code>@groovy.transform.KnownImmutable</code></a></li>
<li><a href="#xform-Memoized"><code>@groovy.transform.Memoized</code></a></li>
<li><a href="#xform-TailRecursive"><code>@groovy.transform.TailRecursive</code></a></li>
<li><a href="#xform-Singleton"><code>@groovy.lang.Singleton</code></a></li>
<li><a href="#xform-Mixin"><code>@groovy.lang.Mixin</code></a></li>
</ul>
</li>
<li><a href="#_logging_improvements">记录改进</a>
<ul class="sectlevel6">
<li><a href="#xform-Log"><code>@groovy.util.logging.Log</code></a></li>
<li><a href="#xform-Commons"><code>@groovy.util.logging.Commons</code></a></li>
<li><a href="#xform-Log4j"><code>@groovy.util.logging.Log4j</code></a></li>
<li><a href="#xform-Log4j2"><code>@groovy.util.logging.Log4j2</code></a></li>
<li><a href="#xform-Slf4j"><code>@groovy.util.logging.Slf4j</code></a></li>
</ul>
</li>
<li><a href="#_declarative_concurrency">声明式并发</a>
<ul class="sectlevel6">
<li><a href="#xform-Synchronized"><code>@groovy.transform.Synchronized</code></a></li>
<li><a href="#xform-WithReadLock"><code>@groovy.transform.WithReadLock</code>和<code>@groovy.transform.WithWriteLock</code></a></li>
</ul>
</li>
<li><a href="#_easier_cloning_and_externalizing">轻松克隆和外化</a>
<ul class="sectlevel6">
<li><a href="#xform-AutoClone"><code>@groovy.transform.AutoClone</code></a></li>
<li><a href="#xform-AutoExternalize"><code>@groovy.transform.AutoExternalize</code></a></li>
</ul>
</li>
<li><a href="#_safer_scripting">更安全的脚本</a>
<ul class="sectlevel6">
<li><a href="#xform-ThreadInterrupt"><code>@groovy.transform.ThreadInterrupt</code></a></li>
<li><a href="#xform-TimedInterrupt"><code>@groovy.transform.TimedInterrupt</code></a></li>
<li><a href="#xform-ConditionalInterrupt"><code>@groovy.transform.ConditionalInterrupt</code></a></li>
</ul>
</li>
<li><a href="#_compiler_directives">编译器指令</a>
<ul class="sectlevel6">
<li><a href="#xform-Field"><code>@groovy.transform.Field</code></a></li>
<li><a href="#xform-PackageScope"><code>@groovy.transform.PackageScope</code></a></li>
<li><a href="#xform-AutoFinal"><code>@groovy.transform.AutoFinal</code></a></li>
<li><a href="#xform-AnnotationCollector"><code>@groovy.transform.AnnotationCollector</code></a></li>
<li><a href="#xform-TypeChecked"><code>@groovy.transform.TypeChecked</code></a></li>
<li><a href="#xform-CompileStatic"><code>@groovy.transform.CompileStatic</code></a></li>
<li><a href="#xform-CompileDynamic"><code>@groovy.transform.CompileDynamic</code></a></li>
<li><a href="#xform-DelegatesTo"><code>@groovy.lang.DelegatesTo</code></a></li>
<li><a href="#xform-SelfType"><code>@groovy.transform.SelfType</code></a></li>
</ul>
</li>
<li><a href="#_swing_patterns">摇摆模式</a>
<ul class="sectlevel6">
<li><a href="#xform-Bindable"><code>@groovy.beans.Bindable</code></a></li>
<li><a href="#xform-ListenerList"><code>@groovy.beans.ListenerList</code></a></li>
<li><a href="#xform-Vetoable"><code>@groovy.beans.Vetoable</code></a></li>
</ul>
</li>
<li><a href="#_test_assistance">测试协助</a>
<ul class="sectlevel6">
<li><a href="#xform-NotYetImplemented"><code>@groovy.transform.NotYetImplemented</code></a></li>
<li><a href="#xform-ASTTest"><code>@groovy.transform.ASTTest</code></a></li>
</ul>
</li>
<li><a href="#_grape_handling">葡萄处理</a>
<ul class="sectlevel6">
<li><a href="#xform-Grab"><code>@groovy.lang.Grab</code></a></li>
<li><a href="#xform-GrabConfig"><code>@groovy.lang.GrabConfig</code></a></li>
<li><a href="#xform-GrabExclude"><code>@groovy.lang.GrabExclude</code></a></li>
<li><a href="#xform-GrabResolver"><code>@groovy.lang.GrabResolver</code></a></li>
<li><a href="#xform-Grapes"><code>@groovy.lang.Grapes</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#developing-ast-xforms">开发AST转换</a>
<ul class="sectlevel5">
<li><a href="#_compilation_phases_guide">编译阶段指南</a></li>
<li><a href="#transforms-local">本地转型</a></li>
<li><a href="#transforms-global">全球转型</a></li>
<li><a href="#_ast_api_guide">AST API指南</a>
<ul class="sectlevel6">
<li><a href="#_abstractasttransformation">抽象AST转换</a></li>
<li><a href="#_classcodeexpressiontransformer">ClassCodeExpressionTransformer</a></li>
<li><a href="#_ast_nodes">AST节点</a></li>
</ul>
</li>
<li><a href="#_macros">巨集</a>
<ul class="sectlevel6">
<li><a href="#_introduction_2">介绍</a></li>
<li><a href="#_statements_and_expressions">陈述和表达</a></li>
<li><a href="#_variable_substitution">变量替代</a></li>
<li><a href="#_macroclass">宏类</a></li>
<li><a href="#_macro_methods">@宏方法</a></li>
</ul>
</li>
<li><a href="#_testing_ast_transformations">测试AST转换</a>
<ul class="sectlevel6">
<li><a href="#_separating_source_trees">分离源树</a></li>
<li><a href="#_debugging_ast_transformations">调试AST转换</a></li>
<li><a href="#_astmatcher">ASTMatcher</a></li>
<li><a href="#_asttest">ASTTest</a></li>
</ul>
</li>
<li><a href="#_external_references">外部参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#section-grape">3.5。葡萄的依赖管理</a>
<ul class="sectlevel3">
<li><a href="#_quick_start">3.5.1。快速开始</a>
<ul class="sectlevel4">
<li><a href="#_add_a_dependency">添加依赖</a></li>
<li><a href="#Grape-SpecifyAdditionalRepositories">指定其他存储库</a></li>
<li><a href="#Grape-MavenClassifiers">Maven分类器</a></li>
<li><a href="#Grape-ExcludingTransitiveDependencies">排除传递依存关系</a></li>
<li><a href="#Grape-JDBCDrivers">JDBC驱动程序</a></li>
<li><a href="#Grape-UsingGrapeFromtheGroovyShell">从Groovy Shell使用葡萄</a></li>
<li><a href="#Grape-Proxysettings">代理设定</a></li>
<li><a href="#Grape-Logging">记录中</a></li>
</ul>
</li>
<li><a href="#Grape-Detail">3.5.2。详情</a></li>
<li><a href="#Grape-Usage">3.5.3。用法</a>
<ul class="sectlevel4">
<li><a href="#Grape-Annotation">注解</a></li>
<li><a href="#Grape-MultipleGrapeAnnotations">多个葡萄注释</a></li>
<li><a href="#Grape-Methodcall">方法调用</a>
<ul class="sectlevel5">
<li><a href="#Grape-grabHashMapParameters">GC（HashMap）参数</a></li>
<li><a href="#Grape-ArgumentsMaparguments">参数图参数</a></li>
</ul>
</li>
<li><a href="#Grape-CommandLineTool">命令行工具</a></li>
<li><a href="#Grape-Advancedconfiguration">进阶设定</a>
<ul class="sectlevel5">
<li><a href="#Grape-RepositoryDirectory">资料库目录</a></li>
<li><a href="#Grape-CustomizeIvysettings">自定义常春藤设置</a></li>
</ul>
</li>
<li><a href="#Grape-MoreExamples">更多例子</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_testing_guide">3.6。测试指南</a>
<ul class="sectlevel3">
<li><a href="#_introduction_3">3.6.1。介绍</a></li>
<li><a href="#_language_features">3.6.2。语言功能</a>
<ul class="sectlevel4">
<li><a href="#_power_assertions">功率断言</a></li>
<li><a href="#_mocking_and_stubbing">模拟和存根</a>
<ul class="sectlevel5">
<li><a href="#_map_coercion">地图强制</a></li>
<li><a href="#_closure_coercion_2">封闭强制</a></li>
<li><a href="#_mockfor_and_stubfor">MockFor和StubFor</a></li>
<li><a href="#testing_guide_emc">Expando元类（EMC）</a></li>
</ul>
</li>
<li><a href="#_gdk_methods">GDK方法</a>
<ul class="sectlevel5">
<li><a href="#_iterable_combinations">可迭代的组合</a></li>
<li><a href="#_iterable_eachcombination">Iterable＃eachCombination</a></li>
</ul>
</li>
<li><a href="#_tool_support">工具支援</a>
<ul class="sectlevel5">
<li><a href="#_test_code_coverage">测试代码覆盖率</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_testing_with_junit">3.6.3。使用JUnit进行测试</a>
<ul class="sectlevel4">
<li><a href="#_junit_3">JUnit 3</a>
<ul class="sectlevel5">
<li><a href="#_assertion_methods">断言方法</a></li>
<li><a href="#_shouldfail_methods">应该失败的方法</a></li>
<li><a href="#_notyetimplemented_method">notYetImplemented方法</a></li>
</ul>
</li>
<li><a href="#_junit_4">JUnit 4</a></li>
<li><a href="#_junit_5">JUnit 5</a></li>
</ul>
</li>
<li><a href="#_testing_with_spock">3.6.4。用Spock测试</a>
<ul class="sectlevel4">
<li><a href="#_specifications">技术指标</a></li>
<li><a href="#_more_spock">更多Spock</a></li>
</ul>
</li>
<li><a href="#_functional_tests_with_geb">3.6.5。用Geb进行功能测试</a>
<ul class="sectlevel4">
<li><a href="#_a_geb_script">Geb脚本</a></li>
<li><a href="#_more_geb">更多吉布</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_processing_json">3.7。处理JSON</a>
<ul class="sectlevel3">
<li><a href="#json_jsonslurper">3.7.1。杰森·斯珀珀</a>
<ul class="sectlevel4">
<li><a href="#_parser_variants">解析器变体</a></li>
</ul>
</li>
<li><a href="#_jsonoutput">3.7.2。杰森输出</a>
<ul class="sectlevel4">
<li><a href="#_customizing_output">自定义输出</a>
<ul class="sectlevel5">
<li><a href="#_formatted_output">格式化输出</a></li>
</ul>
</li>
<li><a href="#_builders">建筑商</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_interacting_with_a_sql_database">3.8。与SQL数据库交互</a>
<ul class="sectlevel3">
<li><a href="#_connecting_to_the_database">3.8.1。连接到数据库</a>
<ul class="sectlevel4">
<li><a href="#_connecting_with_a_datasource">连接数据源</a></li>
<li><a href="#_connecting_using_grab">使用@Grab连接</a></li>
</ul>
</li>
<li><a href="#_executing_sql">3.8.2。执行SQL</a>
<ul class="sectlevel4">
<li><a href="#_creating_tables">建立表格</a></li>
</ul>
</li>
<li><a href="#_basic_crud_operations">3.8.3。基本的CRUD操作</a>
<ul class="sectlevel4">
<li><a href="#_creating_inserting_data">创建/插入数据</a></li>
<li><a href="#_reading_rows">读取行</a></li>
<li><a href="#_updating_rows">更新行</a></li>
<li><a href="#_deleting_rows">删除行</a></li>
</ul>
</li>
<li><a href="#_advanced_sql_operations">3.8.4。高级SQL操作</a>
<ul class="sectlevel4">
<li><a href="#_working_with_transactions">处理交易</a></li>
<li><a href="#_using_batches">使用批次</a></li>
<li><a href="#_performing_pagination">执行分页</a></li>
<li><a href="#_fetching_metadata">获取元数据</a></li>
<li><a href="#_named_and_named_ordinal_parameters">命名和命名常规参数</a></li>
<li><a href="#_stored_procedures">储存程序</a></li>
</ul>
</li>
<li><a href="#_using_datasets">3.8.5。使用数据集</a></li>
</ul>
</li>
<li><a href="#_processing_xml">3.9。处理XML</a>
<ul class="sectlevel3">
<li><a href="#_parsing_xml">3.9.1。解析XML</a>
<ul class="sectlevel4">
<li><a href="#_xmlparser_and_xmlslurper">XmlParser和XmlSlurper</a></li>
<li><a href="#_domcategory">DOMC类别</a></li>
</ul>
</li>
<li><a href="#_gpath">3.9.2。GPath</a>
<ul class="sectlevel4">
<li><a href="#_simply_traversing_the_tree">只需遍历树</a></li>
<li><a href="#_flexible_navigation_with_children_depthfirst_and_breadthfirst">带有孩子（*），depthFirst（**）和广度优先的灵活导航</a></li>
</ul>
</li>
<li><a href="#_creating_xml">3.9.3。创建XML</a>
<ul class="sectlevel4">
<li><a href="#_markupbuilder">标记生成器</a></li>
<li><a href="#_streamingmarkupbuilder">StreamingMarkupBuilder</a></li>
<li><a href="#_markupbuilderhelper">MarkupBuilderHelper</a></li>
<li><a href="#_domtogroovy">DOMToGroovy</a></li>
</ul>
</li>
<li><a href="#_manipulating_xml">3.9.4。处理XML</a>
<ul class="sectlevel4">
<li><a href="#_adding_nodes">添加节点</a></li>
<li><a href="#_modifying_removing_nodes">修改/删除节点</a></li>
<li><a href="#_printing_xml">打印XML</a>
<ul class="sectlevel5">
<li><a href="#_xmlutil">XmlUtil</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_scripting_ant_tasks">3.10。编写Ant脚本任务</a></li>
<li><a href="#_the_groovy_ant_task">3.11。<groovy>蚂蚁任务</groovy></a>
<ul class="sectlevel3">
<li><a href="#_required_taskdef">3.11.1。必需的taskdef</a></li>
<li><a href="#_groovy_attributes">3.11.2。 <groovy>属性</groovy></a></li>
<li><a href="#_parameters_specified_as_nested_elements">3.11.3。指定为嵌套元素的参数</a>
<ul class="sectlevel4">
<li><a href="#_classpath"><classpath></classpath></a></li>
<li><a href="#_arg"><arg></arg></a></li>
</ul>
</li>
<li><a href="#_available_bindings">3.11.4。可用绑定</a></li>
<li><a href="#_examples_2">3.11.5。例子</a></li>
</ul>
</li>
<li><a href="#_template_engines">3.12。模板引擎</a>
<ul class="sectlevel3">
<li><a href="#_introduction_4">3.12.1。介绍</a></li>
<li><a href="#_template_framework">3.12.2。模板框架</a></li>
<li><a href="#_simpletemplateengine">3.12.3。SimpleTemplateEngine</a>
<ul class="sectlevel4">
<li><a href="#_advanced_usage_note">高级用法说明</a></li>
</ul>
</li>
<li><a href="#_streamingtemplateengine">3.12.4。StreamingTemplateEngine</a></li>
<li><a href="#_gstringtemplateengine">3.12.5。GStringTemplateEngine</a></li>
<li><a href="#_xmltemplateengine">3.12.6。XmlTemplateEngine</a></li>
<li><a href="#_the_markuptemplateengine">3.12.7。MarkupTemplateEngine</a>
<ul class="sectlevel4">
<li><a href="#_the_template_format">模板格式</a>
<ul class="sectlevel5">
<li><a href="#_basics">基本</a></li>
<li><a href="#_support_methods">支持方式</a></li>
<li><a href="#_includes">包括</a></li>
<li><a href="#_fragments">碎片</a></li>
<li><a href="#_layouts">版面</a></li>
</ul>
</li>
<li><a href="#_rendering_contents">渲染内容</a>
<ul class="sectlevel5">
<li><a href="#_creation_of_a_template_engine">创建模板引擎</a></li>
<li><a href="#markuptemplate-config">配置选项</a></li>
<li><a href="#markuptemplate-autoformat">自动格式化</a></li>
<li><a href="#markuptemplate-autoescape">自动转义</a></li>
<li><a href="#markuptemplate-gotchas">常见陷阱</a>
<ul class="sectlevel6">
<li><a href="#_strings_containing_markup">包含标记的字符串</a></li>
</ul>
</li>
<li><a href="#markuptemplate-i18n">国际化</a></li>
<li><a href="#markuptemplate-basetemplate">自定义模板类</a></li>
</ul>
</li>
<li><a href="#_type_checked_templates">类型检查的模板</a>
<ul class="sectlevel5">
<li><a href="#_optional_type_checking">可选的类型检查</a></li>
<li><a href="#_alternative_declaration_of_types">类型的替代声明</a></li>
<li><a href="#_performance_of_type_checked_templates">类型检查模板的性能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_other_solutions">3.12.8。其他解决方案</a></li>
</ul>
</li>
<li><a href="#_servlet_support">3.13。Servlet支持</a>
<ul class="sectlevel3">
<li><a href="#_implicit_variables">3.13.1。隐式变量</a></li>
<li><a href="#_setting_up_groovylets">3.13.2。设置groovylet</a></li>
</ul>
</li>
<li><a href="#_integrating_groovy_in_a_java_application">3.14。将Groovy集成到Java应用程序中</a>
<ul class="sectlevel3">
<li><a href="#_groovy_integration_mechanisms">3.14.1。Groovy集成机制</a>
<ul class="sectlevel4">
<li><a href="#integ-eval">评估</a></li>
<li><a href="#integ-groovyshell">GroovyShell</a>
<ul class="sectlevel5">
<li><a href="#_multiple_sources">多种来源</a></li>
<li><a href="#_sharing_data_between_a_script_and_the_application">在脚本和应用程序之间共享数据</a></li>
<li><a href="#_custom_script_class">自定义脚本类</a></li>
</ul>
</li>
<li><a href="#groovyclassloader">GroovyClassLoader</a></li>
<li><a href="#_groovyscriptengine">GroovyScriptEngine</a></li>
<li><a href="#_compilationunit">编译单元</a></li>
</ul>
</li>
<li><a href="#_bean_scripting_framework">3.14.2。Bean脚本框架</a>
<ul class="sectlevel4">
<li><a href="#_getting_started_2">入门</a></li>
<li><a href="#_passing_in_variables">传递变量</a></li>
<li><a href="#_other_calling_options">其他通话选项</a></li>
<li><a href="#_access_to_the_scripting_engine">访问脚本引擎</a></li>
</ul>
</li>
<li><a href="#jsr223">3.14.3。JSR 223 javax.script API</a></li>
</ul>
</li>
<li><a href="#_domain_specific_languages">3.15。领域特定语言</a>
<ul class="sectlevel3">
<li><a href="#_command_chains">3.15.1。指挥链</a></li>
<li><a href="#_operator_overloading">3.15.2。运算符重载</a></li>
<li><a href="#_script_base_classes">3.15.3。脚本基类</a>
<ul class="sectlevel4">
<li><a href="#_the_script_class">脚本类</a></li>
<li><a href="#dsl-basescript">@BaseScript批注</a></li>
<li><a href="#_alternate_abstract_method">替代抽象方法</a></li>
</ul>
</li>
<li><a href="#_adding_properties_to_numbers">3.15.4。向数字添加属性</a></li>
<li><a href="#section-delegatesto">3.15.5。@DelegatesTo</a>
<ul class="sectlevel4">
<li><a href="#TheDelegatesToannotation-DSLsmadeeasy">在编译时解释授权策略</a></li>
<li><a href="#TheDelegatesToannotation-DelegatesTo">@DelegatesTo</a></li>
<li><a href="#TheDelegatesToannotation-DelegatesTomodes">代表到模式</a>
<ul class="sectlevel5">
<li><a href="#TheDelegatesToannotation-Simpledelegation">简单委托</a></li>
<li><a href="#TheDelegatesToannotation-Delegationstrategy">授权策略</a></li>
<li><a href="#TheDelegatesToannotation-Delegatetoparameter">委托给参数</a></li>
<li><a href="#TheDelegatesToannotation-Multipleclosures">多重关闭</a></li>
<li><a href="#_delegating_to_a_generic_type">委托给泛型类型</a></li>
<li><a href="#_delegating_to_an_arbitrary_type">委派给任意类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#compilation-customizers">3.15.6。编译定制器</a>
<ul class="sectlevel4">
<li><a href="#_introduction_5">介绍</a></li>
<li><a href="#_import_customizer">导入定制器</a></li>
<li><a href="#_ast_transformation_customizer">AST转换定制器</a></li>
<li><a href="#_secure_ast_customizer">安全的AST定制器</a></li>
<li><a href="#_source_aware_customizer">知道源代码的定制器</a></li>
<li><a href="#_customizer_builder">定制器构建器</a>
<ul class="sectlevel5">
<li><a href="#_import_customizer_2">导入定制器</a></li>
<li><a href="#_ast_transformation_customizer_2">AST转换定制器</a></li>
<li><a href="#_secure_ast_customizer_2">安全的AST定制器</a></li>
<li><a href="#_source_aware_customizer_2">知道源代码的定制器</a></li>
<li><a href="#_inlining_a_customizer">内联定制器</a></li>
<li><a href="#_multiple_customizers">多个定制器</a></li>
</ul>
</li>
<li><a href="#_config_script_flag">配置脚本标志</a>
<ul class="sectlevel5">
<li><a href="#_static_compilation_by_default">默认情况下静态编译</a></li>
</ul>
</li>
<li><a href="#_ast_transformations">AST转换</a></li>
</ul>
</li>
<li><a href="#_custom_type_checking_extensions">3.15.7。自定义类型检查扩展</a></li>
<li><a href="#_builders_2">3.15.8。建筑商</a>
<ul class="sectlevel4">
<li><a href="#_creating_a_builder">创建一个生成器</a>
<ul class="sectlevel5">
<li><a href="#_buildersupport">Builder支持</a></li>
<li><a href="#_factorybuildersupport">FactoryBuilder支持</a></li>
</ul>
</li>
<li><a href="#_existing_builders">现有的建设者</a>
<ul class="sectlevel5">
<li><a href="#_markupbuilder_2">标记生成器</a></li>
<li><a href="#_streamingmarkupbuilder_2">StreamingMarkupBuilder</a></li>
<li><a href="#_saxbuilder">SaxBuilder</a></li>
<li><a href="#_staxbuilder">StaxBuilder</a></li>
<li><a href="#_dombuilder">DOMBuilder</a></li>
<li><a href="#_nodebuilder">节点构建器</a></li>
<li><a href="#_jsonbuilder">JsonBuilder</a></li>
<li><a href="#_streamingjsonbuilder">流JsonBuilder</a></li>
<li><a href="#swingbuilder">SwingBuilder</a></li>
<li><a href="#_antbuilder">蚂蚁建筑</a></li>
<li><a href="#_clibuilder">CliBuilder</a>
<ul class="sectlevel6">
<li><a href="#_using_annotations_and_an_interface">使用注释和界面</a></li>
<li><a href="#_using_annotations_and_an_instance">使用注释和实例</a></li>
<li><a href="#_using_annotations_and_a_script">使用注释和脚本</a></li>
<li><a href="#_options_with_arguments">带参数的选项</a></li>
<li><a href="#_specifying_a_type">指定类型</a></li>
<li><a href="#_custom_parsing_of_the_argument_string">自定义解析参数String</a></li>
<li><a href="#_options_with_multiple_arguments">具有多个参数的选项</a></li>
<li><a href="#_types_and_multiple_arguments">类型和多个参数</a></li>
<li><a href="#_setting_a_default_value">设定默认值</a></li>
<li><a href="#_use_with_code_typechecked_code">用于<code>TypeChecked</code></a></li>
<li><a href="#_advanced_cli_usage">高级CLI使用</a>
<ul class="sectlevel7">
<li><a href="#_apache_commons_cli">Apache Commons CLI</a></li>
<li><a href="#_picocli">皮科克里</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_objectgraphbuilder">ObjectGraphBuilder</a></li>
<li><a href="#_jmxbuilder">JmxBuilder</a></li>
<li><a href="#_filetreebuilder">FileTreeBuilder</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_working_with_jmx">3.16。使用JMX</a>
<ul class="sectlevel3">
<li><a href="#_introduction_6">3.16.1。介绍</a></li>
<li><a href="#_monitoring_the_jvm">3.16.2。监控JVM</a></li>
<li><a href="#_monitoring_tomcat">3.16.3。监视Tomcat</a></li>
<li><a href="#_oc4j_example">3.16.4。OC4J示例</a></li>
<li><a href="#_weblogic_example">3.16.5。WebLogic示例</a></li>
<li><a href="#_spring_example">3.16.6。春天的例子</a></li>
<li><a href="#_troubleshooting">3.16.7。故障排除</a>
<ul class="sectlevel4">
<li><a href="#_java_lang_securityexception">java.lang。SecurityException</a></li>
</ul>
</li>
<li><a href="#jmx_jmxbuilder">3.16.8。JmxBuilder</a>
<ul class="sectlevel4">
<li><a href="#_instantiating_jmxbuilder">实例化JmxBuilder</a></li>
<li><a href="#_jmx_connectors">JMX连接器</a>
<ul class="sectlevel5">
<li><a href="#_connector_server">连接器服务器</a></li>
<li><a href="#_connector_client">连接器客户端</a></li>
</ul>
</li>
<li><a href="#_jmxbuilder_mbean_export">JmxBuilder MBean导出</a>
<ul class="sectlevel5">
<li><a href="#_implicit_vs_explicit_descriptors">隐式与显式描述符</a></li>
<li><a href="#_the_jmxbuilder_export_node">JmxBuilder.export（）节点</a></li>
<li><a href="#_jmxbuilder_export_syntax">JmxBuilder.export（）语法</a></li>
<li><a href="#_integration_with_groovymbean_class">与GroovyMBean类集成</a></li>
<li><a href="#_mbean_registration_with_jmxbuilder_bean">使用JmxBuilder.bean（）进行MBean注册</a>
<ul class="sectlevel6">
<li><a href="#_implicit_export">隐式导出</a>
<ul class="sectlevel7">
<li><a href="#_jconsole_view_of_exported_bean">导出Bean的JConsole视图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_jmxbuilder_bean_syntax">JmxBuilder.bean（）语法</a></li>
<li><a href="#_bean_node_specifying_mbean_objectname">Bean（）节点-指定MBean ObjectName</a></li>
</ul>
</li>
<li><a href="#_bean_node_attribute_export">Bean（）节点-属性导出</a>
<ul class="sectlevel5">
<li><a href="#_export_all_attributes_with_wildcard">导出所有带有通配符“ *”的属性</a></li>
<li><a href="#_export_attribute_list">导出属性列表</a></li>
<li><a href="#_export_attribute_with_explicit_descriptors">带有明确描述符的导出属性</a></li>
</ul>
</li>
<li><a href="#_bean_node_constructor_export">Bean（）节点-构造函数导出</a>
<ul class="sectlevel5">
<li><a href="#_export_all_constructors_with">用“ *”导出所有构造函数</a></li>
<li><a href="#_export_constructors_using_parameter_descriptor">使用参数描述符导出构造函数</a></li>
<li><a href="#_export_constructor_with_explicit_descriptors">具有显式描述符的导出构造函数</a></li>
</ul>
</li>
<li><a href="#_bean_node_operation_export">Bean（）节点-操作导出</a>
<ul class="sectlevel5">
<li><a href="#_export_all_operations_with">用“ *”导出所有操作</a></li>
<li><a href="#_export_operation_list">出口业务清单</a></li>
<li><a href="#_export_operations_by_signature">签名导出操作</a></li>
<li><a href="#_export_operations_with_explicit_descriptors">带有明确描述符的导出操作</a></li>
</ul>
</li>
<li><a href="#_embedding_descriptor">嵌入描述符</a></li>
<li><a href="#_timer_export">计时器导出</a>
<ul class="sectlevel5">
<li><a href="#_timer_node_syntax">计时器节点语法</a></li>
<li><a href="#_exporting_a_timer">导出计时器</a></li>
<li><a href="#_timer_period">计时器周期</a></li>
</ul>
</li>
<li><a href="#_jmxbuilder_and_events">JmxBuilder和事件</a>
<ul class="sectlevel5">
<li><a href="#_event_handling_closures">事件处理关闭</a>
<ul class="sectlevel6">
<li><a href="#_parameterless">无参数</a></li>
<li><a href="#_with_event_parameter">带事件参数</a></li>
</ul>
</li>
<li><a href="#_handling_attribute_onchange_event">处理属性onChange事件</a></li>
<li><a href="#_attribute_onchange_event_object">属性onChange事件对象</a></li>
<li><a href="#_handling_operation_oncall_event">处理onCall事件</a></li>
<li><a href="#_operation_oncall_event_object">操作onCall事件对象</a></li>
</ul>
</li>
<li><a href="#_listener_mbean">侦听器MBean</a>
<ul class="sectlevel5">
<li><a href="#_listening_to_jmx_events">收听JMX事件</a></li>
<li><a href="#_listener_node_syntax">侦听器节点语法</a></li>
</ul>
</li>
<li><a href="#_emitting_jmx_events">发出JMX事件</a>
<ul class="sectlevel5">
<li><a href="#_emitter_syntax">发射器语法</a></li>
<li><a href="#_declare_the_emitter">声明发射器</a></li>
<li><a href="#_broadcast_event">广播事件</a></li>
<li><a href="#_sending_event_objects">发送事件对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_further_jmx_information">3.16.9。更多JMX信息</a></li>
</ul>
</li>
<li><a href="#_creating_swing_uis">3.17。创建Swing UI</a></li>
<li><a href="#_security">3.18。安全</a></li>
<li><a href="#_design_patterns_in_groovy">3.19。Groovy中的设计模式</a>
<ul class="sectlevel3">
<li><a href="#_patterns">3.19.1。模式</a>
<ul class="sectlevel4">
<li><a href="#_abstract_factory_pattern">抽象工厂模式</a>
<ul class="sectlevel5">
<li><a href="#_example">例</a></li>
</ul>
</li>
<li><a href="#_adapter_pattern">适配器图案</a>
<ul class="sectlevel5">
<li><a href="#_delegation_example">委托示例</a></li>
<li><a href="#_inheritance_example">继承实例</a></li>
<li><a href="#_adapting_using_closures">使用闭包进行适应</a></li>
<li><a href="#_adapting_using_the_expandometaclass">使用ExpandoMetaClass进行适应</a></li>
</ul>
</li>
<li><a href="#_bouncer_pattern">弹跳器模式</a>
<ul class="sectlevel5">
<li><a href="#_null_checking_example">空检查示例</a></li>
<li><a href="#_validation_example">验证范例</a></li>
</ul>
</li>
<li><a href="#_chain_of_responsibility_pattern">责任链模式</a>
<ul class="sectlevel5">
<li><a href="#_example_2">例</a></li>
</ul>
</li>
<li><a href="#_composite_pattern">复合图案</a>
<ul class="sectlevel5">
<li><a href="#_example_3">例</a></li>
</ul>
</li>
<li><a href="#_decorator_pattern">装饰图案</a>
<ul class="sectlevel5">
<li><a href="#_traditional_example">传统例子</a></li>
<li><a href="#_a_touch_of_dynamic_behaviour">一点动感的行为</a></li>
<li><a href="#_runtime_behaviour_embellishment">运行时行为修饰</a></li>
<li><a href="#_more_dynamic_decorating">更动感的装饰</a></li>
<li><a href="#_decorating_with_an_interceptor">用拦截器装饰</a></li>
<li><a href="#_decorating_with_java_lang_reflect_proxy">用java.lang.reflect装饰。代理</a></li>
<li><a href="#_decorating_with_spring">用春天装饰</a></li>
<li><a href="#_asynchronous_decorators_using_gpars">使用GPar的异步装饰器</a></li>
</ul>
</li>
<li><a href="#_delegation_pattern">委托模式</a>
<ul class="sectlevel5">
<li><a href="#_implement_delegation_pattern_using_expandometaclass">使用ExpandoMetaClass实现委托模式</a></li>
<li><a href="#_implement_delegation_pattern_using_delegate_annotation">使用@Delegate注释实现委派模式</a></li>
</ul>
</li>
<li><a href="#_flyweight_pattern">跳线模式</a>
<ul class="sectlevel5">
<li><a href="#_example_4">例</a></li>
</ul>
</li>
<li><a href="#_iterator_pattern">迭代器模式</a></li>
<li><a href="#_loan_my_resource_pattern">贷款我的资源模式</a>
<ul class="sectlevel5">
<li><a href="#_example_5">例</a></li>
</ul>
</li>
<li><a href="#_null_object_pattern">空对象模式</a>
<ul class="sectlevel5">
<li><a href="#_simple_example">简单的例子</a></li>
<li><a href="#_tree_example">树例</a></li>
</ul>
</li>
<li><a href="#_pimp_my_library_pattern">皮条客我的图书馆模式</a>
<ul class="sectlevel5">
<li><a href="#_example_6">例</a></li>
</ul>
</li>
<li><a href="#_proxy_pattern">代理模式</a>
<ul class="sectlevel5">
<li><a href="#_example_7">例</a></li>
</ul>
</li>
<li><a href="#_singleton_pattern">单例模式</a>
<ul class="sectlevel5">
<li><a href="#_example_the_classic_java_singleton">示例：经典Java单例</a></li>
<li><a href="#_example_singleton_via_metaprogramming">示例：通过元编程的单例</a></li>
<li><a href="#_guice_example">吉斯例子</a></li>
<li><a href="#_spring_example_2">春天的例子</a></li>
<li><a href="#_further_information">更多信息</a></li>
</ul>
</li>
<li><a href="#_state_pattern">状态模式</a>
<ul class="sectlevel5">
<li><a href="#_example_8">例</a></li>
<li><a href="#_variation_1_leveraging_interface_oriented_design">变体1：利用面向接口的设计</a></li>
<li><a href="#_variation_2_extract_state_pattern_logic">方案2：提取状态模式逻辑</a></li>
<li><a href="#_variation_3_bring_on_the_dsl">变体3：启用DSL</a></li>
</ul>
</li>
<li><a href="#_strategy_pattern">策略模式</a>
<ul class="sectlevel5">
<li><a href="#_example_9">例</a></li>
</ul>
</li>
<li><a href="#_template_method_pattern">模板方法模式</a>
<ul class="sectlevel5">
<li><a href="#_example_10">例</a></li>
</ul>
</li>
<li><a href="#_visitor_pattern">访客模式</a>
<ul class="sectlevel5">
<li><a href="#_simple_example_2">简单的例子</a></li>
<li><a href="#_advanced_example">进阶范例</a>
<ul class="sectlevel6">
<li><a href="#_why_to_use_this">为什么要使用这个</a></li>
<li><a href="#_what_happens_if_we_add_a_new_type">如果添加新类型会怎样？</a></li>
<li><a href="#_what_if_we_want_to_have_different_iteration_patterns">如果我们想拥有不同的迭代模式怎么办？</a></li>
<li><a href="#_make_it_groovy">使其时髦</a></li>
<li><a href="#_summary">摘要</a></li>
</ul>
</li>
<li><a href="#_further_information_2">更多信息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_references">3.19.2。参考文献</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_acknowledgements">4。致谢</a>
<ul class="sectlevel2">
<li><a href="#_contributors">4.1。贡献者</a></li>
<li><a href="#_license">4.2。执照</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<h1 id="_introduction" class="sect0"><a class="anchor" href="#_introduction"></a>介绍</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>时髦...</p>
</div>
<div class="ulist">
<ul>
<li>
<p>是Java虚拟机的敏捷和动态语言</p>
</li>
<li>
<p>基于Java的优势，但具有受Python，Ruby和Smalltalk等语言启发的其他强大功能</p>
</li>
<li>
<p>通过几乎零学习曲线使Java开发人员可以使用现代编程功能</p>
</li>
<li>
<p>提供静态类型检查和静态编译代码的功能，以提高健壮性和性能</p>
</li>
<li>
<p>支持特定领域语言和其他紧凑语法，因此您的代码变得易于阅读和维护</p>
</li>
<li>
<p>强大的处理原语，OO能力和Ant DSL使编写Shell和构建脚本变得容易</p>
</li>
<li>
<p>在开发Web，GUI，数据库或控制台应用程序时，通过减少脚手架代码来提高开发人员的生产力</p>
</li>
<li>
<p>通过支持单元测试和开箱即用的模型来简化测试</p>
</li>
<li>
<p>与所有现有的Java类和库无缝集成</p>
</li>
<li>
<p>直接编译为Java字节码，因此您可以在任何可以使用Java的地方使用它</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_groovy_language_specification"><a class="anchor" href="#_groovy_language_specification"></a> 1。Groovy语言规范</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_syntax"><a class="anchor" href="#_syntax"></a> 1.1。句法</h3>
<div class="paragraph">
<p>本章介绍了Groovy编程语言的语法。该语言的语法源自Java语法，但是通过Groovy的特定构造对其进行了增强，并允许进行某些简化。</p>
</div>
<div class="sect3">
<h4 id="_comments"><a class="anchor" href="#_comments"></a> 1.1.1。评论</h4>
<div class="sect4">
<h5 id="_single_line_comment"><a class="anchor" href="#_single_line_comment"></a>单行注释</h5>
<div class="paragraph">
<p>单行注释以<code>//</code>并且可以在该行的任何位置找到。以下字符<code>//</code> ，直到该行的末尾都被视为注释的一部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// a standalone single line comment
println "hello" // a comment till the end of the line</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_multiline_comment"><a class="anchor" href="#_multiline_comment"></a>多行注释</h5>
<div class="paragraph">
<p>多行注释以<code>/*</code>并且可以在该行的任何位置找到。以下字符<code>/*</code>将被视为评论的一部分，包括换行符，直到第一个<code>*/</code>关闭评论。因此，多行注释可以放在语句的末尾，甚至可以放在语句的内部。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">/* a standalone multiline comment
   spanning two lines */
println "hello" /* a multiline comment starting
                   at the end of a statement */
println 1 /* one */ + 2 /* two */</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_groovydoc_comment"><a class="anchor" href="#_groovydoc_comment"></a> Groovydoc评论</h5>
<div class="paragraph">
<p>与多行注释类似，Groovydoc注释是多行注释，但以<code>/**</code>并以<code>*/</code> 。Groovydoc第一条注释行之后的行可以选择以星号开头<code>*</code> 。这些评论与：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型定义（类，接口，枚举，注释），</p>
</li>
<li>
<p>字段和属性定义</p>
</li>
<li>
<p>方法定义</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管编译器不会抱怨Groovydoc注释与上述语言元素没有关联，但是您应该在这些结构之前添加注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">/**
 * A Class description
 */
class Person {
    /** the name of the person */
    String name

    /**
     * Creates a greeting method for a certain person.
     *
     * @param otherPerson the person to greet
     * @return a greeting message
     */
    String greet(String otherPerson) {
       "Hello ${otherPerson}"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovydoc遵循与Java自己的Javadoc相同的约定。因此，您将能够使用与Javadoc相同的标签。</p>
</div>
</div>
<div class="sect4">
<h5 id="_shebang_line"><a class="anchor" href="#_shebang_line"></a>社bang线</h5>
<div class="paragraph">
<p>在单行注释旁边，有一个特殊的行注释，通常称为UNIX系统理解的<em>shebang</em>行，只要您已安装Groovy发行版和<code>groovy</code>该命令在<code>PATH</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">#!/usr/bin/env groovy
println "Hello from the shebang line"</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>#</code>字符必须是文件的第一个字符。任何缩进都会产生编译错误。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_keywords"><a class="anchor" href="#_keywords"></a> 1.1.2。关键词</h4>
<div class="paragraph">
<p>以下列表代表了Groovy语言的所有关键字：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表格1。关键词</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">如</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">断言</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">打破</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">案件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">抓住</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">const</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">继续</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">做</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其他</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">枚举</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">延伸</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最后</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">去</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">贯彻</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">进口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实例</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">超</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开关</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">扔</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">抛出</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">特征</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尝试</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">而</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_identifiers"><a class="anchor" href="#_identifiers"></a> 1.1.3。身份标识</h4>
<div class="sect4">
<h5 id="_normal_identifiers"><a class="anchor" href="#_normal_identifiers"></a>普通标识符</h5>
<div class="paragraph">
<p>标识符以字母，美元或下划线开头。它们不能以数字开头。</p>
</div>
<div class="paragraph">
<p>字母可以在以下范围内：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“ a”到“ z”（小写的ascii字母）</p>
</li>
<li>
<p>“ A”到“ Z”（大写字母）</p>
</li>
<li>
<p>'\ u00C0'至'\ u00D6'</p>
</li>
<li>
<p>'\ u00D8'至'\ u00F6'</p>
</li>
<li>
<p>'\ u00F8'至'\ u00FF'</p>
</li>
<li>
<p>'\ u0100'到'\ uFFFE'</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，后面的字符可以包含字母和数字。</p>
</div>
<div class="paragraph">
<p>以下是有效标识符（此处为变量名）的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def name
def item3
def with_underscore
def $dollarStart</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是以下是无效的标识符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def 3tier
def a+b
def a#b</code></pre>
</div>
</div>
<div class="paragraph">
<p>当跟随点时，所有关键字也是有效的标识符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">foo.as
foo.assert
foo.break
foo.case
foo.catch</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_quoted_identifiers"><a class="anchor" href="#_quoted_identifiers"></a>带引号的标识符</h5>
<div class="paragraph">
<p>带引号的标识符出现在点分表达式的点后。例如， <code>name</code>的一部分<code>person.name</code>表达式可以用<code>person."name"</code>要么<code>person.'name'</code> 。当某些标识符包含Java语言规范禁止的非法字符，但在引用时Groovy允许使用的非法字符时，这尤其有趣。例如，破折号，空格，感叹号等字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [:]

map."an identifier with a space and double quotes" = "ALLOWED"
map.'with-dash-signs-and-single-quotes' = "ALLOWED"

assert map."an identifier with a space and double quotes" == "ALLOWED"
assert map.'with-dash-signs-and-single-quotes' == "ALLOWED"</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们将在<a href="#all-strings">以下有关字符串的部分中</a>看到的那样，Groovy提供了不同的字符串文字。实际上在点后允许使用所有类型的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">map.'single quote'
map."double quote"
map.'''triple single quote'''
map."""triple double quote"""
map./slashy string/
map.$/dollar slashy string/$</code></pre>
</div>
</div>
<div class="paragraph">
<p>普通字符串和Groovy的GStrings（插值字符串）之间存在区别，在后一种情况下，将插值插入最终字符串中以评估整个标识符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def firstname = "Homer"
map."Simpson-${firstname}" = "Homer Simpson"

assert map.'Simpson-Homer' == "Homer Simpson"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="all-strings"><a class="anchor" href="#all-strings"></a> 1.1.4。弦乐</h4>
<div class="paragraph">
<p>文本文字以称为字符串的字符链的形式表示。Groovy让您实例化<code>java.lang.String</code>对象以及GStrings（ <code>groovy.lang.GString</code> ），在其他编程语言中也称为<em>插值字符串</em> 。</p>
</div>
<div class="sect4">
<h5 id="_single_quoted_string"><a class="anchor" href="#_single_quoted_string"></a>单引号字符串</h5>
<div class="paragraph">
<p>单引号字符串是一系列用单引号引起来的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">'a single-quoted string'</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">单引号字符串是普通的<code>java.lang.String</code>并且不支持插值。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_string_concatenation"><a class="anchor" href="#_string_concatenation"></a>字符串串联</h5>
<div class="paragraph">
<p>所有Groovy字符串都可以与<code>+</code>操作员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 'ab' == 'a' + 'b'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_triple_single_quoted_string"><a class="anchor" href="#_triple_single_quoted_string"></a>三重单引号字符串</h5>
<div class="paragraph">
<p>三重单引号字符串是一系列字符，由单引号的三元组包围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">'''a triple-single-quoted string'''</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">三重单引号字符串是普通的<code>java.lang.String</code>并且不支持插值。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>三重单引号字符串可以跨越多行。字符串的内容可以跨越行边界，而无需将字符串分成几段，也不需要串联或换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def aMultilineString = '''line one
line two
line three'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果代码是缩进的，例如在类的方法主体中，则字符串将包含缩进的空格。Groovy开发工具包包含使用以下方法去除压痕的方法： <code>String#stripIndent()</code>方法，并与<code>String#stripMargin()</code>带有分隔符的方法，该方法标识要从字符串开头删除的文本。</p>
</div>
<div class="paragraph">
<p>创建字符串时，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def startingAndEndingWithANewline = '''
line one
line two
line three
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>您会注意到，结果字符串包含换行符作为第一个字符。可以通过用反斜杠转义换行符来删除该字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def strippedFirstNewline = '''\
line one
line two
line three
'''

assert !strippedFirstNewline.startsWith('\n')</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_escaping_special_characters"><a class="anchor" href="#_escaping_special_characters"></a>转义特殊字符</h6>
<div class="paragraph">
<p>您可以使用反斜杠字符对单引号进行转义，以避免终止字符串文字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">'an escaped single quote: \' needs a backslash'</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用双反斜杠来转义转义字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">'an escaped escape character: \\ needs a double backslash'</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些特殊字符还将反斜杠用作转义字符：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">转义序列</th>
<th class="tableblock halign-left valign-top">字符</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\ t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">制表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\ b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">退格键</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\ n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">新队</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\ r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">回车</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">换页</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\\</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">反斜杠</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单引号字符串中的单引号（对于三重单引号和双引号字符串是可选的）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\“</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双引号字符串中的双引号（对于三重双引号和单引号字符串是可选的）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当稍后讨论其他类型的字符串时，我们将看到更多转义细节。</p>
</div>
</div>
<div class="sect5">
<h6 id="_unicode_escape_sequence"><a class="anchor" href="#_unicode_escape_sequence"></a> Unicode转义序列</h6>
<div class="paragraph">
<p>对于键盘上不存在的字符，可以使用Unicode转义序列：反斜杠，后跟'u'，然后是4个十六进制数字。</p>
</div>
<div class="paragraph">
<p>例如，欧元货币符号可以表示为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">'The Euro currency symbol: \u20AC'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_double_quoted_string"><a class="anchor" href="#_double_quoted_string"></a>双引号字符串</h5>
<div class="paragraph">
<p>双引号字符串是一系列用双引号引起来的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">"a double-quoted string"</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">双引号字符串是普通的<code>java.lang.String</code>如果没有内插表达式，但是<code>groovy.lang.GString</code>实例（如果存在插值）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要转义双引号，可以使用反斜杠字符：“双引号：\”。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_string_interpolation"><a class="anchor" href="#_string_interpolation"></a>字符串插值</h6>
<div class="paragraph">
<p>除了单引号和三重单引号的字符串外，任何Groovy表达式都可以插入所有字符串文字中。插值是在评估字符串时用其值替换字符串中占位符的行为。占位符表达式被包围<code>${}</code> 。对于明确的点分表达式，可以省略花括号，即在这种情况下，我们只能使用$前缀。如果GString曾经传递给采用String的方法，则占位符内的表达式值将评估为其字符串表示形式（通过调用<code>toString()</code>在该表达式上），并将生成的String传递给方法。</p>
</div>
<div class="paragraph">
<p>在这里，我们有一个带有占位符的字符串，该字符串引用一个局部变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def name = 'Guillaume' // a plain string
def greeting = "Hello ${name}"

assert greeting.toString() == 'Hello Guillaume'</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何Groovy表达式都是有效的，如在本示例中使用算术表达式所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sum = "The sum of 2 and 3 equals ${2 + 3}"
assert sum.toString() == 'The sum of 2 and 3 equals 5'</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不仅允许在<code>${}</code>占位符，语句也是如此。但是，一条语句的值仅仅是<code>null</code> 。因此，如果在该占位符中插入了多个语句，则最后一个应以某种方式返回要插入的有意义的值。例如，“和1和2的总和等于$ {def a = 1; def b = 2; a + b}”受支持并按预期工作，但是一种好的做法通常是在GString占位符内部坚持简单的表达式。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此外<code>${}</code>占位符，我们也可以使用一个<code>$</code>虚线表达式前的符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def person = [name: 'Guillaume', age: 36]
assert "$person.name is $person.age years old" == 'Guillaume is 36 years old'</code></pre>
</div>
</div>
<div class="paragraph">
<p>但只能是点缀形式的表达式<code>a.b</code> ， <code>a.b.c</code>等有效。包含圆括号的表达式（例如方法调用，用于闭包的大括号，不属于属性表达式或算术运算符的点）将无效。给定以下数字变量定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def number = 3.14</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下语句将引发<code>groovy.lang.MissingPropertyException</code>因为Groovy认为您正在尝试访问<code>toString</code>该数字的属性，该属性不存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">shouldFail(MissingPropertyException) {
    println "$number.toString()"
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">你可以想到<code>"$number.toString()"</code>被解析器解释为<code>"${number.toString}()"</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>同样，如果表达式不明确，则需要保留花括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String thing = 'treasure'
assert 'The x-coordinate of the treasure is represented by treasure.x' ==
    "The x-coordinate of the $thing is represented by $thing.x"   // <= Not allowed: ambiguous!!
assert 'The x-coordinate of the treasure is represented by treasure.x' ==
        "The x-coordinate of the $thing is represented by ${thing}.x"  // <= Curly braces required</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要逃脱<code>$</code>要么<code>${}</code> GString中的占位符，使它们按原样显示而无需插值，您只需要使用一个<code>\</code>反斜杠字符以逃避美元符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert '$5' == "\$5"
assert '${name}' == "\${name}"</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_special_case_of_interpolating_closure_expressions"><a class="anchor" href="#_special_case_of_interpolating_closure_expressions"></a>内插闭包表达式的特殊情况</h6>
<div class="paragraph">
<p>到目前为止，我们已经看到我们可以在内部插入任意表达式<code>${}</code>占位符，但闭包表达式有特殊情况和表示法。当占位符包含箭头时， <code>${→}</code> ，该表达式实际上是一个闭包表达式-您可以将其视为一个在其前面加有美元的闭包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sParameterLessClosure = "1 + 2 == ${-> 3}" <i class="conum" data-value="1"></i><b>(1)</b>
assert sParameterLessClosure == '1 + 2 == 3'

def sOneParamClosure = "1 + 2 == ${ w -> w << 3}" <i class="conum" data-value="2"></i><b>(2)</b>
assert sOneParamClosure == '1 + 2 == 3'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>闭包是不带参数的无参数闭包。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在这里，关闭只需要一个<code>java.io.StringWriter</code>参数，您可以在其后面附加内容<code><<</code> leftShift运算符。无论哪种情况，两个占位符都是嵌入式闭包。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从外观上看，它似乎是定义要内插的表达式的更详细的方法，但是闭包比单纯的表达式有一个有趣的优点：惰性求值。</p>
</div>
<div class="paragraph">
<p>让我们考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def number = 1 <i class="conum" data-value="1"></i><b>(1)</b>
def eagerGString = "value == ${number}"
def lazyGString = "value == ${ -> number }"

assert eagerGString == "value == 1" <i class="conum" data-value="2"></i><b>(2)</b>
assert lazyGString ==  "value == 1" <i class="conum" data-value="3"></i><b>(3)</b>

number = 2 <i class="conum" data-value="4"></i><b>(4)</b>
assert eagerGString == "value == 1" <i class="conum" data-value="5"></i><b>(5)</b>
assert lazyGString ==  "value == 2" <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们定义一个<code>number</code>变量包含<code>1</code>然后我们在两个GString中进行插值，作为表达式<code>eagerGString</code>作为封闭<code>lazyGString</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们期望结果字符串包含相同的字符串值1 <code>eagerGString</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>同样的<code>lazyGString</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后我们将变量的值更改为新的数字</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>使用普通的内插表达式，该值实际上是在创建GString时绑定的。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>但是使用闭包表达式时，每次将GString强制转换为String时都会调用闭包，从而生成包含新数字值的更新字符串。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">带有多个参数的嵌入式闭包表达式将在运行时生成异常。仅允许使用零个或一个参数的闭包。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_interoperability_with_java"><a class="anchor" href="#_interoperability_with_java"></a>与Java的互操作性</h6>
<div class="paragraph">
<p>当某个方法（无论是用Java还是Groovy实现）期望<code>java.lang.String</code> ，但我们通过了<code>groovy.lang.GString</code>例如， <code>toString()</code>自动透明地调用GString的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String takeString(String message) {         <i class="conum" data-value="4"></i><b>(4)</b>
    assert message instanceof String        <i class="conum" data-value="5"></i><b>(5)</b>
    return message
}

def message = "The message is ${'hello'}"   <i class="conum" data-value="1"></i><b>(1)</b>
assert message instanceof GString           <i class="conum" data-value="2"></i><b>(2)</b>

def result = takeString(message)            <i class="conum" data-value="3"></i><b>(3)</b>
assert result instanceof String
assert result == 'The message is hello'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们创建一个GString变量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们再次检查它是GString的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后，我们将该GString传递给采用String作为参数的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的签名<code>takeString()</code>方法明确表示其唯一的参数是String</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>我们还验证该参数确实是String而不是GString。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_gstring_and_string_hashcodes"><a class="anchor" href="#_gstring_and_string_hashcodes"></a> GString和String hashCodes</h6>
<div class="paragraph">
<p>尽管可以使用内插的字符串代替普通的Java字符串，但是它们以特定的方式与字符串不同：它们的hashCodes不同。纯Java字符串是不可变的，而生成的GString的String表示形式可能有所不同，具体取决于其内插值。即使对于相同的结果字符串，GString和String也没有相同的hashCode。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert "one: ${1}".hashCode() != "one: 1".hashCode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>应避免将GString和具有不同hashCode值的String用作G键作为Map键，尤其是当我们尝试使用String而不是GString检索关联的值时。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def key = "a"
def m = ["${key}": "letter ${key}"]     <i class="conum" data-value="1"></i><b>(1)</b>

assert m["a"] == null                   <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>该地图是使用键对为GString的初始对创建的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>当我们尝试使用String键获取值时，我们将找不到它，因为String和GString具有不同的hashCode值</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_triple_double_quoted_string"><a class="anchor" href="#_triple_double_quoted_string"></a>三重双引号字符串</h5>
<div class="paragraph">
<p>三重双引号字符串的行为类似于双引号字符串，此外，它们是多行的，例如三重单引号字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def name = 'Groovy'
def template = """
    Dear Mr ${name},

    You're the winner of the lottery!

    Yours sincerly,

    Dave
"""

assert template.toString().contains('Groovy')</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">双引号或单引号都不需要在三重双引号字符串中转义。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_slashy_string"><a class="anchor" href="#_slashy_string"></a>斜线</h5>
<div class="paragraph">
<p>除了通常引用的字符串，Groovy还提供了斜线字符串，它们使用<code>/</code>作为开始和结束定界符。斜线字符串对于定义正则表达式和模式特别有用，因为不需要转义反斜杠。</p>
</div>
<div class="paragraph">
<p>斜线字符串的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def fooPattern = /.*foo.*/
assert fooPattern == '.*foo.*'</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅需使用正斜杠将反斜杠转义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def escapeSlash = /The character \/ is a forward slash/
assert escapeSlash == 'The character / is a forward slash'</code></pre>
</div>
</div>
<div class="paragraph">
<p>斜线字符串为多行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def multilineSlashy = /one
    two
    three/

assert multilineSlashy.contains('\n')</code></pre>
</div>
</div>
<div class="paragraph">
<p>斜线字符串可以被认为是定义GString的另一种方式，但是具有不同的转义规则。因此，它们支持插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def color = 'blue'
def interpolatedSlashy = /a ${color} car/

assert interpolatedSlashy == 'a blue car'</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_special_cases"><a class="anchor" href="#_special_cases"></a>特别案例</h6>
<div class="paragraph">
<p>空的斜线字符串不能用双斜杠表示，因为Groovy解析器将其理解为行注释。这就是为什么以下断言实际上不会编译的原因，因为它看起来像是一个非终止的语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert '' == //</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于斜线字符串主要是为了使regexp更容易而设计的，所以有些东西是GString中的错误，例如<code>$()</code>要么<code>$5</code>将使用斜线字符串。</p>
</div>
<div class="paragraph">
<p>请记住，不需要转义反斜杠。另一种思考方式是实际上不支持转义。斜线字符串<code>/\t/</code>将不包含制表符，而是反斜杠，后跟字符“ t”。仅允许对斜杠字符进行转义，即<code>/\/folder/</code>将是一个斜线字符串，包含<code>'/folder'</code> 。斜杠转义的结果是，斜线字符串不能以反斜杠结尾。否则，它将逃脱斜线字符串终止符。您可以改用特殊技巧， <code>/ends with slash ${'\'}/</code> 。但最好不要在这种情况下使用斜线字符串。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dollar_slashy_string"><a class="anchor" href="#_dollar_slashy_string"></a>美元斜线字符串</h5>
<div class="paragraph">
<p>美元斜线字符串是多行GString，以空格分隔<code>$/</code>和结束<code>/$</code> 。转义字符是美元符号，它可以转义另一个美元或正斜杠。但是，美元和正斜杠都不需要转义，除了可以逃避以GString占位符序列开头的字符串子序列的美元，或者如果您需要逃避以结束美元斜杠字符串定界符开头的序列，则不需要。</p>
</div>
<div class="paragraph">
<p>这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def name = "Guillaume"
def date = "April, 1st"

def dollarSlashy = $/
    Hello $name,
    today we're ${date}.

    $ dollar sign
    $$ escaped dollar sign
    \ backslash
    / forward slash
    $/ escaped forward slash
    $$$/ escaped opening dollar slashy
    $/$$ escaped closing dollar slashy
/$

assert [
    'Guillaume',
    'April, 1st',
    '$ dollar sign',
    '$ escaped dollar sign',
    '\\ backslash',
    '/ forward slash',
    '/ escaped forward slash',
    '$/ escaped opening dollar slashy',
    '/$ escaped closing dollar slashy'
].every { dollarSlashy.contains(it) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>它的创建是为了克服斜线转义规则的某些限制。当它的转义规则适合您的字符串内容时（通常，如果它有一些斜杠您不想转义），请使用它。</p>
</div>
</div>
<div class="sect4">
<h5 id="_string_summary_table"><a class="anchor" href="#_string_summary_table"></a>字符串汇总表</h5>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字串名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串语法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">插补</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">多行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转义符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">单引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'…​'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check-empty"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check-empty"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">三重单引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'''…​'''</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check-empty"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"…​"</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check-empty"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">三重双引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"""…​"""</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">粗暴的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/…​/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">美元大跌</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$/…​/$</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_characters"><a class="anchor" href="#_characters"></a>性格</h5>
<div class="paragraph">
<p>与Java不同，Groovy没有明确的字符文字。但是，您可以通过三种不同的方式明确地将Groovy字符串作为实际字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">char c1 = 'A' <i class="conum" data-value="1"></i><b>(1)</b>
assert c1 instanceof Character

def c2 = 'B' as char <i class="conum" data-value="2"></i><b>(2)</b>
assert c2 instanceof Character

def c3 = (char)'C' <i class="conum" data-value="3"></i><b>(3)</b>
assert c3 instanceof Character</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>通过在声明变量时通过显式指定字符来显式<code>char</code>类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>通过使用类型强制<code>as</code>算子</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通过使用强制转换为char操作</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当字符保留在变量中时，第一个选项<em class="conum">1</em>很有趣，而当必须将char值作为方法调用的参数传递时，其他两个选项（ <em class="conum">2</em>和<em class="conum">3</em> ）更有趣。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_numbers"><a class="anchor" href="#_numbers"></a> 1.1.5。号码</h4>
<div class="paragraph">
<p>Groovy支持不同种类的整数文字和十进制文字，并得到通常的支持<code>Number</code> Java类型。</p>
</div>
<div class="sect4">
<h5 id="_integral_literals"><a class="anchor" href="#_integral_literals"></a>整体文字</h5>
<div class="paragraph">
<p>整数文字类型与Java中的相同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>byte</code></p>
</li>
<li>
<p><code>char</code></p>
</li>
<li>
<p><code>short</code></p>
</li>
<li>
<p><code>int</code></p>
</li>
<li>
<p><code>long</code></p>
</li>
<li>
<p><code>java.lang.BigInteger</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以使用以下声明创建这些类型的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// primitive types
byte  b = 1
char  c = 2
short s = 3
int   i = 4
long  l = 5

// infinite precision
BigInteger bi =  6</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用<code>def</code>关键字，整数的类型会有所不同：它将适应可以容纳该数字的类型的容量。</p>
</div>
<div class="paragraph">
<p>对于正数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def a = 1
assert a instanceof Integer

// Integer.MAX_VALUE
def b = 2147483647
assert b instanceof Integer

// Integer.MAX_VALUE + 1
def c = 2147483648
assert c instanceof Long

// Long.MAX_VALUE
def d = 9223372036854775807
assert d instanceof Long

// Long.MAX_VALUE + 1
def e = 9223372036854775808
assert e instanceof BigInteger</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及负数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def na = -1
assert na instanceof Integer

// Integer.MIN_VALUE
def nb = -2147483648
assert nb instanceof Integer

// Integer.MIN_VALUE - 1
def nc = -2147483649
assert nc instanceof Long

// Long.MIN_VALUE
def nd = -9223372036854775808
assert nd instanceof Long

// Long.MIN_VALUE - 1
def ne = -9223372036854775809
assert ne instanceof BigInteger</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_alternative_non_base_10_representations"><a class="anchor" href="#_alternative_non_base_10_representations"></a>非基数10的替代表示</h6>
<div class="paragraph">
<p>数字也可以用二进制，八进制，十六进制和十进制表示。</p>
</div>
<div class="sect6">
<h7 id="_binary_literal"><a class="anchor" href="#_binary_literal"></a>二进制文字</h7>
<div class="paragraph">
<p>二进制数字以a开头<code>0b</code>字首：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int xInt = 0b10101111
assert xInt == 175

short xShort = 0b11001001
assert xShort == 201 as short

byte xByte = 0b11
assert xByte == 3 as byte

long xLong = 0b101101101101
assert xLong == 2925l

BigInteger xBigInteger = 0b111100100001
assert xBigInteger == 3873g

int xNegativeInt = -0b10101111
assert xNegativeInt == -175</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="_octal_literal"><a class="anchor" href="#_octal_literal"></a>八进制文字</h7>
<div class="paragraph">
<p>八进制数字以以下格式表示： <code>0</code>后跟八进制数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int xInt = 077
assert xInt == 63

short xShort = 011
assert xShort == 9 as short

byte xByte = 032
assert xByte == 26 as byte

long xLong = 0246
assert xLong == 166l

BigInteger xBigInteger = 01111
assert xBigInteger == 585g

int xNegativeInt = -077
assert xNegativeInt == -63</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="_hexadecimal_literal"><a class="anchor" href="#_hexadecimal_literal"></a>十六进制文字</h7>
<div class="paragraph">
<p>十六进制数以以下格式表示： <code>0x</code>后跟十六进制数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int xInt = 0x77
assert xInt == 119

short xShort = 0xaa
assert xShort == 170 as short

byte xByte = 0x3a
assert xByte == 58 as byte

long xLong = 0xffff
assert xLong == 65535l

BigInteger xBigInteger = 0xaaaa
assert xBigInteger == 43690g

Double xDouble = new Double('0x1.0p0')
assert xDouble == 1.0d

int xNegativeInt = -0x77
assert xNegativeInt == -119</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_decimal_literals"><a class="anchor" href="#_decimal_literals"></a>小数文字</h5>
<div class="paragraph">
<p>十进制文字类型与Java中的相同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>float</code></p>
</li>
<li>
<p><code>double</code></p>
</li>
<li>
<p><code>java.lang.BigDecimal</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以使用以下声明创建这些类型的十进制数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// primitive types
float  f = 1.234
double d = 2.345

// infinite precision
BigDecimal bd =  3.456</code></pre>
</div>
</div>
<div class="paragraph">
<p>小数可以使用指数，而<code>e</code>要么<code>E</code>指数字母，后跟可选符号，以及代表指数的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 1e3  ==  1_000.0
assert 2E4  == 20_000.0
assert 3e+1 ==     30.0
assert 4E-2 ==      0.04
assert 5e-1 ==      0.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了进行精确的十进制数计算，Groovy选择了<code>java.lang.BigDecimal</code>作为其十进制数字类型。另外，两者<code>float</code>和<code>double</code>支持，但需要显式的类型声明，类型强制或后缀。即使<code>BigDecimal</code>是十进制数字的默认值，此类文字在方法或闭包中接受<code>float</code>要么<code>double</code>作为参数类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不能使用二进制，八进制或十六进制表示形式来表示小数。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_underscore_in_literals"><a class="anchor" href="#_underscore_in_literals"></a>在文字下划线</h5>
<div class="paragraph">
<p>在编写长文字数字时，很难确定一些数字是如何组合在一起的，例如，成千上万的单词，单词等的组合。通过允许在数字文字中加下划线，可以更容易地发现这些组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">long creditCardNumber = 1234_5678_9012_3456L
long socialSecurityNumbers = 999_99_9999L
double monetaryAmount = 12_345_132.12
long hexBytes = 0xFF_EC_DE_5E
long hexWords = 0xFFEC_DE5E
long maxLong = 0x7fff_ffff_ffff_ffffL
long alsoMaxLong = 9_223_372_036_854_775_807L
long bytes = 0b11010010_01101001_10010100_10010010</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_number_type_suffixes"><a class="anchor" href="#_number_type_suffixes"></a>数字类型后缀</h5>
<div class="paragraph">
<p>我们可以给数字（包括二进制，八进制和十六进制）加一个后缀（见下表），以强制其具有特定类型。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">后缀</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>G</code>要么<code>g</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>L</code>要么<code>l</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>I</code>要么<code>i</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>G</code>要么<code>g</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>D</code>要么<code>d</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>F</code>要么<code>f</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 42I == new Integer('42')
assert 42i == new Integer('42') // lowercase i more readable
assert 123L == new Long("123") // uppercase L more readable
assert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integer
assert 456G == new BigInteger('456')
assert 456g == new BigInteger('456')
assert 123.45 == new BigDecimal('123.45') // default BigDecimal type used
assert 1.200065D == new Double('1.200065')
assert 1.234F == new Float('1.234')
assert 1.23E23D == new Double('1.23E23')
assert 0b1111L.class == Long // binary
assert 0xFFi.class == Integer // hexadecimal
assert 034G.class == BigInteger // octal</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_math_operations"><a class="anchor" href="#_math_operations"></a>数学运算</h5>
<div class="paragraph">
<p>尽管稍后将讨论<a href="#_operators">运算符</a> ，但重要的是讨论数学运算的行为及其结果类型是什么。</p>
</div>
<div class="paragraph">
<p>除了除法和功率二进制运算（见下文），</p>
</div>
<div class="ulist">
<ul>
<li>
<p>之间的二进制运算<code>byte</code> ， <code>char</code> ， <code>short</code>和<code>int</code>导致<code>int</code></p>
</li>
<li>
<p>涉及二元运算<code>long</code>与<code>byte</code> ， <code>char</code> ， <code>short</code>和<code>int</code>导致<code>long</code></p>
</li>
<li>
<p>涉及二元运算<code>BigInteger</code>和任何其他整数类型导致<code>BigInteger</code></p>
</li>
<li>
<p>涉及二元运算<code>BigDecimal</code>与<code>byte</code> ， <code>char</code> ， <code>short</code> ， <code>int</code>和<code>BigInteger</code>导致<code>BigDecimal</code></p>
</li>
<li>
<p>之间的二进制运算<code>float</code> ， <code>double</code>和<code>BigDecimal</code>导致<code>double</code></p>
</li>
<li>
<p>两个之间的二进制运算<code>BigDecimal</code>导致<code>BigDecimal</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下表总结了这些规则：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
<col style="width:10%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">字节</th>
<th class="tableblock halign-left valign-top">烧焦</th>
<th class="tableblock halign-left valign-top">短</th>
<th class="tableblock halign-left valign-top">整型</th>
<th class="tableblock halign-left valign-top">长</th>
<th class="tableblock halign-left valign-top">大整数</th>
<th class="tableblock halign-left valign-top">浮动</th>
<th class="tableblock halign-left valign-top">双</th>
<th class="tableblock halign-left valign-top">大十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>字节</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>烧焦</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>短</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>整型</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>长</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>大整数</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>浮动</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>双</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>大十进制</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大十进制</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于Groovy的运算符重载，通常的算术运算符也可以与<code>BigInteger</code>和<code>BigDecimal</code> ，这与Java中必须使用显式方法对这些数字进行运算的方式不同。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="integer_division"><a class="anchor" href="#integer_division"></a>除法运算符的情况</h6>
<div class="paragraph">
<p>除法运算符<code>/</code> （和<code>/=</code>进行划分和分配） <code>double</code>如果任何一个操作数为a的结果<code>float</code>要么<code>double</code>和<code>BigDecimal</code>否则返回结果（当两个操作数均为整数类型的任何组合时） <code>short</code> ， <code>char</code> ， <code>byte</code> ， <code>int</code> ， <code>long</code> ， <code>BigInteger</code>要么<code>BigDecimal</code> ）。</p>
</div>
<div class="paragraph">
<p><code>BigDecimal</code>除法与<code>divide()</code>如果除法是精确的（即产生可以在相同精度和小数范围内表示的结果）的方法，或者使用<code>MathContext</code> <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#precision()">精度</a>为两个操作数<a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#precision()">精度</a>的最大值加上一个额外的精度10，最大<a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#scale()">标度</a>为10和最大操作数标度。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于Java中的整数除法，您应该使用<code>intdiv()</code> Groovy没有提供专用的整数除法运算符。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="power_operator"><a class="anchor" href="#power_operator"></a>电力经营者的情况</h6>
<div class="paragraph">
<p>电源操作由<code>**</code>运算符，带有两个参数：底数和指数。幂运算的结果取决于其操作数以及运算的结果（尤其是如果结果可以表示为整数值时）。</p>
</div>
<div class="paragraph">
<p>Groovy的幂运算使用以下规则来确定结果类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果指数是十进制值</p>
<div class="ulist">
<ul>
<li>
<p>如果结果可以表示为<code>Integer</code> ，然后返回<code>Integer</code></p>
</li>
<li>
<p>否则结果可以表示为<code>Long</code> ，然后返回<code>Long</code></p>
</li>
<li>
<p>否则返回一个<code>Double</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>如果指数是整数值</p>
<div class="ulist">
<ul>
<li>
<p>如果指数严格为负，则返回<code>Integer</code> ， <code>Long</code>要么<code>Double</code>如果结果值适合该类型</p>
</li>
<li>
<p>如果指数为正或零</p>
<div class="ulist">
<ul>
<li>
<p>如果基数是<code>BigDecimal</code> ，然后返回<code>BigDecimal</code>结果值</p>
</li>
<li>
<p>如果基数是<code>BigInteger</code> ，然后返回<code>BigInteger</code>结果值</p>
</li>
<li>
<p>如果基数是<code>Integer</code> ，然后返回<code>Integer</code>如果结果值适合其中，否则为<code>BigInteger</code></p>
</li>
<li>
<p>如果基数是<code>Long</code> ，然后返回<code>Long</code>如果结果值适合其中，否则为<code>BigInteger</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们可以通过一些示例来说明这些规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// base and exponent are ints and the result can be represented by an Integer
assert    2    **   3    instanceof Integer    //  8
assert   10    **   9    instanceof Integer    //  1_000_000_000

// the base is a long, so fit the result in a Long
// (although it could have fit in an Integer)
assert    5L   **   2    instanceof Long       //  25

// the result can't be represented as an Integer or Long, so return a BigInteger
assert  100    **  10    instanceof BigInteger //  10e20
assert 1234    ** 123    instanceof BigInteger //  170515806212727042875...

// the base is a BigDecimal and the exponent a negative int
// but the result can be represented as an Integer
assert    0.5  **  -2    instanceof Integer    //  4

// the base is an int, and the exponent a negative float
// but again, the result can be represented as an Integer
assert    1    **  -0.3f instanceof Integer    //  1

// the base is an int, and the exponent a negative int
// but the result will be calculated as a Double
// (both base and exponent are actually converted to doubles)
assert   10    **  -1    instanceof Double     //  0.1

// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal
assert    1.2  **  10    instanceof BigDecimal //  6.1917364224

// the base is a float or double, and the exponent is an int
// but the result can only be represented as a Double value
assert    3.4f **   5    instanceof Double     //  454.35430372146965
assert    5.6d **   2    instanceof Double     //  31.359999999999996

// the exponent is a decimal value
// and the result can only be represented as a Double value
assert    7.8  **   1.9  instanceof Double     //  49.542708423868476
assert    2    **   0.1f instanceof Double     //  1.0717734636432956</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_booleans"><a class="anchor" href="#_booleans"></a> 1.1.6。布尔值</h4>
<div class="paragraph">
<p>布尔值是一种特殊的数据类型，用于表示真值： <code>true</code>和<code>false</code> 。将此数据类型用于跟踪真/假<a href="#_conditional_operators">条件的</a>简单标志。</p>
</div>
<div class="paragraph">
<p>布尔值可以存储在变量中，并分配给字段，就像其他任何数据类型一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def myBooleanVariable = true
boolean untypedBooleanVar = false
booleanField = true</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>true</code>和<code>false</code>是仅有的两个原始布尔值。但是，可以使用<a href="#_bitwise_and_logical_operators">逻辑运算符</a>表示更复杂的布尔表达式。</p>
</div>
<div class="paragraph">
<p>另外，Groovy具有<a href="#Groovy-Truth">特殊的规则</a> （通常称为<em>Groovy Truth</em> ），用于将非布尔对象强制为布尔值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_lists"><a class="anchor" href="#_lists"></a> 1.1.7。清单</h4>
<div class="paragraph">
<p>Groovy使用逗号分隔的值列表（用方括号括起来）表示列表。Groovy列表是普通的JDK <code>java.util.List</code> ，因为Groovy没有定义自己的集合类。定义列表文字时使用的具体列表实现为<code>java.util.ArrayList</code>默认情况下，除非您决定另行指定，否则我们将在后面介绍。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def numbers = [1, 2, 3]         <i class="conum" data-value="1"></i><b>(1)</b>

assert numbers instanceof List  <i class="conum" data-value="2"></i><b>(2)</b>
assert numbers.size() == 3      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们定义一个列表号，以逗号分隔并用方括号括起来，然后将该列表分配给变量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该列表是Java的一个实例<code>java.util.List</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>列表的大小可以用<code>size()</code>方法，并显示我们的列表包含3个元素</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在上面的示例中，我们使用了同类列表，但是您也可以创建包含异构类型值的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def heterogeneous = [1, "a", true]  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这里的列表包含一个数字，一个字符串和一个布尔值</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们提到默认情况下，列表文字实际上是<code>java.util.ArrayList</code> ，但是由于可以在列表中使用类型强制，因此可以为列表使用其他后备类型<code>as</code>运算符，或使用变量的显式类型声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def arrayList = [1, 2, 3]
assert arrayList instanceof java.util.ArrayList

def linkedList = [2, 3, 4] as LinkedList    <i class="conum" data-value="1"></i><b>(1)</b>
assert linkedList instanceof java.util.LinkedList

LinkedList otherLinked = [3, 4, 5]          <i class="conum" data-value="2"></i><b>(2)</b>
assert otherLinked instanceof java.util.LinkedList</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们将强制与<code>as</code>运算子明确要求<code>java.util.LinkedList</code>实作</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以说保存列表文字的变量是类型<code>java.util.LinkedList</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<code>[]</code>下标运算符（用于读取和设置值），带有正索引或负索引来访问列表末尾的元素以及范围，并使用<code><<</code> leftShift运算符可将元素追加到列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def letters = ['a', 'b', 'c', 'd']

assert letters[0] == 'a'     <i class="conum" data-value="1"></i><b>(1)</b>
assert letters[1] == 'b'

assert letters[-1] == 'd'    <i class="conum" data-value="2"></i><b>(2)</b>
assert letters[-2] == 'c'

letters[2] = 'C'             <i class="conum" data-value="3"></i><b>(3)</b>
assert letters[2] == 'C'

letters << 'e'               <i class="conum" data-value="4"></i><b>(4)</b>
assert letters[ 4] == 'e'
assert letters[-1] == 'e'

assert letters[1, 3] == ['b', 'd']         <i class="conum" data-value="5"></i><b>(5)</b>
assert letters[2..4] == ['C', 'd', 'e']    <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>访问列表的第一个元素（从零开始的计数）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用负索引访问列表的最后一个元素：-1是列表末尾的第一个元素</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用分配为列表的第三个元素设置新值</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>使用<code><<</code> leftShift运算符，将元素添加到列表的末尾</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>一次访问两个元素，返回包含这两个元素的新列表</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>使用范围来访问列表中从开始到结束元素位置的值的范围</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>由于列表本质上可以是异构的，因此列表还可以包含其他列表以创建多维列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def multi = [[0, 1], [2, 3]]     <i class="conum" data-value="1"></i><b>(1)</b>
assert multi[1][0] == 2          <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义数字列表</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>访问最顶部列表的第二个元素和内部列表的第一个元素</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_arrays"><a class="anchor" href="#_arrays"></a> 1.1.8。数组</h4>
<div class="paragraph">
<p>Groovy将数组的列表符号重复使用，但是要制作此类文字数组，您需要通过强制或类型声明显式定义数组的类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String[] arrStr = ['Ananas', 'Banana', 'Kiwi']  <i class="conum" data-value="1"></i><b>(1)</b>

assert arrStr instanceof String[]    <i class="conum" data-value="2"></i><b>(2)</b>
assert !(arrStr instanceof List)

def numArr = [1, 2, 3] as int[]      <i class="conum" data-value="3"></i><b>(3)</b>

assert numArr instanceof int[]       <i class="conum" data-value="4"></i><b>(4)</b>
assert numArr.size() == 3</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用显式变量类型声明定义字符串数组</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>断言我们创建了一个字符串数组</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用以下命令创建一个整数数组<code>as</code>算子</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>断言我们创建了一个原始整数数组</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以创建多维数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def matrix3 = new Integer[3][3]         <i class="conum" data-value="1"></i><b>(1)</b>
assert matrix3.size() == 3

Integer[][] matrix2                     <i class="conum" data-value="2"></i><b>(2)</b>
matrix2 = [[1, 2], [3, 4]]
assert matrix2 instanceof Integer[][]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>您可以定义新数组的边界</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>或者声明一个数组而不指定其边界</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>访问数组元素的方式与列表相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']
assert names[0] == 'Cédric'     <i class="conum" data-value="1"></i><b>(1)</b>

names[2] = 'Blackdrag'          <i class="conum" data-value="2"></i><b>(2)</b>
assert names[2] == 'Blackdrag'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>检索数组的第一个元素</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将数组的第三个元素的值设置为新值</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy不支持Java的数组初始化器符号，因为用Groovy闭包符号可能会误解大括号。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_maps"><a class="anchor" href="#_maps"></a> 1.1.9。地图</h4>
<div class="paragraph">
<p>Groovy有时有时在其他语言中称为字典或关联数组，具有地图功能。映射将键与值相关联，将键和值之间用冒号分隔，将每个键/值对之间用逗号分隔，并将整个键和值括在方括号中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF']   <i class="conum" data-value="1"></i><b>(1)</b>

assert colors['red'] == '#FF0000'    <i class="conum" data-value="2"></i><b>(2)</b>
assert colors.green  == '#00FF00'    <i class="conum" data-value="3"></i><b>(3)</b>

colors['pink'] = '#FF00FF'           <i class="conum" data-value="4"></i><b>(4)</b>
colors.yellow  = '#FFFF00'           <i class="conum" data-value="5"></i><b>(5)</b>

assert colors.pink == '#FF00FF'
assert colors['yellow'] == '#FFFF00'

assert colors instanceof java.util.LinkedHashMap</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们定义了一个字符串颜色名称的映射，并与它们的十六进制编码的html颜色相关联</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们使用下标符号来检查与<code>red</code>键</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们还可以使用属性符号来声明绿色的十六进制表示形式</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>同样，我们可以使用下标符号来添加新的键/值对</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>或属性符号，添加<code>yellow</code>颜色</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当使用名称作为键时，我们实际上在映射中定义了字符串键。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy创建的地图实际上是<code>java.util.LinkedHashMap</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您尝试访问地图中不存在的钥匙：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert colors.unknown == null</code></pre>
</div>
</div>
<div class="paragraph">
<p>您将检索一个<code>null</code>结果。</p>
</div>
<div class="paragraph">
<p>在上面的示例中，我们使用了字符串键，但是您也可以将其他类型的值用作键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def numbers = [1: 'one', 2: 'two']

assert numbers[1] == 'one'</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用数字作为键，因为数字可以明确地识别为数字，因此Groovy不会像前面的示例那样创建字符串键。但是请考虑您要传递一个变量来代替键的情况，以使该变量的值成为键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def key = 'name'
def person = [key: 'Guillaume']      <i class="conum" data-value="1"></i><b>(1)</b>

assert !person.containsKey('name')   <i class="conum" data-value="2"></i><b>(2)</b>
assert person.containsKey('key')     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>key</code>与<code>'Guillaume'</code>名称实际上是<code>"key"</code>字符串，而不是与<code>key</code>变量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该地图不包含<code>'name'</code>键</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>相反，地图包含一个<code>'key'</code>键</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以传递带引号的字符串以及键：[“ name”：“ Guillaume”]。如果您的密钥字符串不是有效的标识符，则这是强制性的，例如，如果您想创建一个包含如下哈希值的字符串密钥，例如：[“ street-name”：“ Main street”]。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当需要在地图定义中将变量值作为键传递时，必须用括号将变量或表达式括起来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">person = [(key): 'Guillaume']        <i class="conum" data-value="1"></i><b>(1)</b>

assert person.containsKey('name')    <i class="conum" data-value="2"></i><b>(2)</b>
assert !person.containsKey('key')    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这次，我们围绕<code>key</code>带括号的变量，以指示解析器我们传递变量而不是定义字符串键</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该地图确实包含<code>name</code>键</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>但是地图不包含<code>key</code>和以前一样</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="groovy-operators"><a class="anchor" href="#groovy-operators"></a> 1.2。经营者</h3>
<div class="paragraph">
<p>本章介绍了Groovy编程语言的运算符。</p>
</div>
<div class="sect3">
<h4 id="_arithmetic_operators"><a class="anchor" href="#_arithmetic_operators"></a> 1.2.1。算术运算符</h4>
<div class="paragraph">
<p>Groovy支持您在数学和其他编程语言（例如Java）中发现的常见的算术运算符。支持所有Java算术运算符。让我们在以下示例中进行研究。</p>
</div>
<div class="sect4">
<h5 id="_normal_arithmetic_operators"><a class="anchor" href="#_normal_arithmetic_operators"></a>普通算术运算符</h5>
<div class="paragraph">
<p>Groovy提供了以下二进制算术运算符：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作员</th>
<th class="tableblock halign-left valign-top">目的</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加成</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减法</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">乘法</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">师</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用<code>intdiv()</code>有关整数除法的信息，请参见有关<a href="#integer_division">整数除法</a>的部分，以获取有关<a href="#integer_division">除法</a>返回类型的更多信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">余</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功率</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有关<a href="#power_operator">操作</a>的返回类型的更多信息，请参见关于<a href="#power_operator">幂运算</a>的部分。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下是一些使用这些运算符的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert  1  + 2 == 3
assert  4  - 3 == 1
assert  3  * 5 == 15
assert  3  / 2 == 1.5
assert 10  % 3 == 1
assert  2 ** 3 == 8</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_unary_operators"><a class="anchor" href="#_unary_operators"></a>一元运算符</h5>
<div class="paragraph">
<p>的<code>+</code>和<code>-</code>一元运算符也可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert +3 == 3
assert -4 == 0 - 4

assert -(-1) == 1  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>请注意使用括号将表达式括起来，以将一元减号应用于该包围的表达式。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于一元算术运算符， <code>++</code> （增量）和<code>--</code> （减量）运算符可用，包括前缀和后缀表示法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def a = 2
def b = a++ * 3             <i class="conum" data-value="1"></i><b>(1)</b>

assert a == 3 && b == 6

def c = 3
def d = c-- * 2             <i class="conum" data-value="2"></i><b>(2)</b>

assert c == 2 && d == 6

def e = 1
def f = ++e + 3             <i class="conum" data-value="3"></i><b>(3)</b>

assert e == 2 && f == 5

def g = 4
def h = --g + 1             <i class="conum" data-value="4"></i><b>(4)</b>

assert g == 3 && h == 4</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>后缀增量将递增<code>a</code>在对表达式求值并分配给之后<code>b</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>后缀递减将递减<code>c</code>在对表达式求值并分配给之后<code>d</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>前缀增量将递增<code>e</code>在对表达式求值并将其分配给之前<code>f</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>前缀减量将减量<code>g</code>在对表达式求值并将其分配给之前<code>h</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_assignment_arithmetic_operators"><a class="anchor" href="#_assignment_arithmetic_operators"></a>分配算术运算符</h5>
<div class="paragraph">
<p>我们上面已经看到的二进制算术运算符也可以以赋值形式使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>+=</code></p>
</li>
<li>
<p><code>-=</code></p>
</li>
<li>
<p><code>*=</code></p>
</li>
<li>
<p><code>/=</code></p>
</li>
<li>
<p><code>%=</code></p>
</li>
<li>
<p><code>**=</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们看看它们的作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def a = 4
a += 3

assert a == 7

def b = 5
b -= 3

assert b == 2

def c = 5
c *= 3

assert c == 15

def d = 10
d /= 2

assert d == 5

def e = 10
e %= 3

assert e == 1

def f = 3
f **= 2

assert f == 9</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_relational_operators"><a class="anchor" href="#_relational_operators"></a> 1.2.2。关系运算符</h4>
<div class="paragraph">
<p>关系运算符允许对象之间进行比较，以了解两个对象是否相同或不同，或者一个对象大于，小于或等于另一个。</p>
</div>
<div class="paragraph">
<p>可以使用以下运算符：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作员</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>==</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">少于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小于或等于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">比...更棒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>>=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大于或等于</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下是使用这些运算符进行简单数字比较的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 1 + 2 == 3
assert 3 != 4

assert -2 < 3
assert 2 <= 2
assert 3 <= 4

assert 5 > 1
assert 5 >= -2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_logical_operators"><a class="anchor" href="#_logical_operators"></a> 1.2.3。逻辑运算符</h4>
<div class="paragraph">
<p>Groovy为布尔表达式提供了三种逻辑运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&&</code> ：逻辑“和”</p>
</li>
<li>
<p><code>||</code> ：逻辑“或”</p>
</li>
<li>
<p><code>!</code> ：逻辑“不”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们用以下示例对其进行说明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert !false           <i class="conum" data-value="1"></i><b>(1)</b>
assert true && true     <i class="conum" data-value="2"></i><b>(2)</b>
assert true || false    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>“不”假为真</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>真“和”真是真的</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>真“或”假为真</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_precedence"><a class="anchor" href="#_precedence"></a>优先顺序</h5>
<div class="paragraph">
<p>逻辑“非”比逻辑“与”具有更高的优先级。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert (!false && false) == false   <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这里的断言是正确的（因为括号中的表达式是假的），因为“ not”的优先级高于“ and”，因此它仅适用于第一个“ false”项。否则，它将应用于“和”的结果，将其变为true，并且断言将失败</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>逻辑“和”的优先级高于逻辑“或”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert true || true && false        <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在这里，断言是正确的，因为“和”的优先级高于“或”，因此“或”最后执行并返回true，具有一个true参数；否则，“ and”将最后执行并返回false，具有一个false参数，并且断言将失败</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_short_circuiting"><a class="anchor" href="#_short_circuiting"></a>短路</h5>
<div class="paragraph">
<p>逻辑上<code>||</code>运算符支持短路：如果左操作数为true，则它知道结果在任何情况下都为true，因此不会评估右操作数。仅当左侧操作数为false时，才对右侧操作数进行求值。</p>
</div>
<div class="paragraph">
<p>同样对于逻辑<code>&&</code>运算符：如果左操作数为false，则它知道在任何情况下结果都为false，因此不会评估右操作数。仅当左操作数为true时，才对右操作数求值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">boolean checkIfCalled() {   <i class="conum" data-value="1"></i><b>(1)</b>
    called = true
}

called = false
true || checkIfCalled()
assert !called              <i class="conum" data-value="2"></i><b>(2)</b>

called = false
false || checkIfCalled()
assert called               <i class="conum" data-value="3"></i><b>(3)</b>

called = false
false && checkIfCalled()
assert !called              <i class="conum" data-value="4"></i><b>(4)</b>

called = false
true && checkIfCalled()
assert called               <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们创建一个函数来设置<code>called</code>每当调用时将其标记为true</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在第一种情况下，重置被叫标志后，我们确认如果左操作数为<code>||</code>为true，则不调用该函数，因为<code>||</code>短路正确操作数的评估</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在第二种情况下，左操作数为false，因此调用了函数，正如我们的标志现在为true所表明的那样</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>同样的<code>&&</code> ，我们确认函数未使用错误的左操作数调用</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但是用真正的左操作数调用函数</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bitwise_operators"><a class="anchor" href="#_bitwise_operators"></a> 1.2.4。按位运算符</h4>
<div class="paragraph">
<p>Groovy提供了4个按位运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&</code> ：按位“和”</p>
</li>
<li>
<p><code>|</code> ：按位“或”</p>
</li>
<li>
<p><code>^</code> ：按位“ xor”（不包括“ or”）</p>
</li>
<li>
<p><code>~</code> ：按位求反</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以将按位运算符应用于<code>byte</code>或<code>int</code>然后返回<code>int</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int a = 0b00101010
assert a == 42
int b = 0b00001000
assert b == 8
assert (a & a) == a                     <i class="conum" data-value="1"></i><b>(1)</b>
assert (a & b) == b                     <i class="conum" data-value="2"></i><b>(2)</b>
assert (a | a) == a                     <i class="conum" data-value="3"></i><b>(3)</b>
assert (a | b) == a                     <i class="conum" data-value="4"></i><b>(4)</b>

int mask = 0b11111111                   <i class="conum" data-value="5"></i><b>(5)</b>
assert ((a ^ a) & mask) == 0b00000000   <i class="conum" data-value="6"></i><b>(6)</b>
assert ((a ^ b) & mask) == 0b00100010   <i class="conum" data-value="7"></i><b>(7)</b>
assert ((~a) & mask)    == 0b11010101   <i class="conum" data-value="8"></i><b>(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>按位和</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>按位并返回通用位</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>按位或</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>按位或返回所有“ 1”位</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>设置掩码以仅检查最后8位</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>按位互斥或自返回0</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>按位异或</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>按位取反</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得注意的是，原始类型的内部表示遵循<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html">Java语言规范</a> 。特别是，原始类型是带符号的，这意味着对于按位取反，最好使用掩码来仅检索必要的位。</p>
</div>
<div class="paragraph">
<p>在Groovy中，按位运算符具有可<a href="#Operator-Overloading">重载</a>的特殊性，这意味着您可以为任何类型的对象定义这些运算符的行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="_conditional_operators"><a class="anchor" href="#_conditional_operators"></a> 1.2.5。条件运算符</h4>
<div class="sect4">
<h5 id="_not_operator"><a class="anchor" href="#_not_operator"></a>不是操作员</h5>
<div class="paragraph">
<p>“ not”运算符用感叹号（ <code>!</code> ）并反转基础布尔表达式的结果。特别是，可以将<code>not</code>具有<a href="#Groovy-Truth">Groovy事实的</a>运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert (!true)    == false                      <i class="conum" data-value="1"></i><b>(1)</b>
assert (!'foo')   == false                      <i class="conum" data-value="2"></i><b>(2)</b>
assert (!'')      == true                       <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的否定<code>true</code>是<code>false</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>'foo'是一个非空字符串，计算结果为<code>true</code> ，因此否定返回<code>false</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>''是一个空字符串，计算结果为<code>false</code> ，因此否定返回<code>true</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_ternary_operator"><a class="anchor" href="#_ternary_operator"></a>三元运算符</h5>
<div class="paragraph">
<p>三元运算符是一种快捷方式表达式，等效于为变量分配某些值的if / else分支。</p>
</div>
<div class="paragraph">
<p>代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (string!=null && string.length()>0) {
    result = 'Found'
} else {
    result = 'Not found'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">result = (string!=null && string.length()>0) ? 'Found' : 'Not found'</code></pre>
</div>
</div>
<div class="paragraph">
<p>三元运算符也与<a href="#Groovy-Truth">Groovy真相</a>兼容，因此您可以使其更简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">result = string ? 'Found' : 'Not found'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_elvis_operator"><a class="anchor" href="#_elvis_operator"></a>猫王算子</h5>
<div class="paragraph">
<p>“猫王运算符”是三元运算符的缩写。一个方便的例子是，如果表达式解析为“返回默认值” <code>false</code> -ish（如<a href="#Groovy-Truth">Groovy事实</a> ）。一个简单的示例可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">displayName = user.name ? user.name : 'Anonymous'   <i class="conum" data-value="1"></i><b>(1)</b>
displayName = user.name ?: 'Anonymous'              <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用三元运算符，您必须重复要分配的值</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果不是Elvis运算符，则使用经过测试的值<code>false</code> -ish</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用Elvis运算符可以消除代码的冗长性，并减少重构时出错的风险，因为无需复制在条件和正返回值中都经过测试的表达式。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_object_operators"><a class="anchor" href="#_object_operators"></a> 1.2.6。对象运算符</h4>
<div class="sect4">
<h5 id="_safe_navigation_operator"><a class="anchor" href="#_safe_navigation_operator"></a>安全导航员</h5>
<div class="paragraph">
<p>安全导航运算符用于避免<code>NullPointerException</code> 。通常，当您引用某个对象时，可能需要验证该对象不是<code>null</code>在访问对象的方法或属性之前。为了避免这种情况，安全的导航操作员只需返回<code>null</code>而不是抛出异常，就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def person = Person.find { it.id == 123 }    <i class="conum" data-value="1"></i><b>(1)</b>
def name = person?.name                      <i class="conum" data-value="2"></i><b>(2)</b>
assert name == null                          <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>find</code>将返回一个<code>null</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用null安全运算符可防止<code>NullPointerException</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>结果是<code>null</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_direct_field_access_operator"><a class="anchor" href="#_direct_field_access_operator"></a>直接现场操作员</h5>
<div class="paragraph">
<p>通常在Groovy中，当您编写如下代码时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class User {
    public final String name                 <i class="conum" data-value="1"></i><b>(1)</b>
    User(String name) { this.name = name}
    String getName() { "Name: $name" }       <i class="conum" data-value="2"></i><b>(2)</b>
}
def user = new User('Bob')
assert user.name == 'Name: Bob'              <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>公共领域<code>name</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>吸气剂<code>name</code>返回自定义字符串</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>叫吸气剂</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>user.name</code>调用会触发对同名属性的调用，也就是说，在此调用<code>name</code> 。如果要检索字段而不是调用getter，则可以使用直接字段访问运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert user.@name == 'Bob'                   <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用于<code>.@</code>强制使用字段而不是使用getter</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="method-pointer-operator"><a class="anchor" href="#method-pointer-operator"></a>方法指针运算符</h5>
<div class="paragraph">
<p>方法指针运算符（ <code>.&</code> ）call用于将对方法的引用存储在变量中，以便以后调用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def str = 'example of method reference'            <i class="conum" data-value="1"></i><b>(1)</b>
def fun = str.&toUpperCase                         <i class="conum" data-value="2"></i><b>(2)</b>
def upper = fun()                                  <i class="conum" data-value="3"></i><b>(3)</b>
assert upper == str.toUpperCase()                  <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>str</code>变量包含一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们存储了对<code>toUpperCase</code>上的方法<code>str</code>名为变量的实例<code>fun</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>fun</code>可以像常规方法一样调用</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>我们可以检查结果是否与直接调用时相同<code>str</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用方法指针有多个优点。首先，这种方法指针的类型是<code>groovy.lang.Closure</code> ，因此可以在将使用闭包的任何地方使用它。特别适合根据策略模式的需要转换现有方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def transform(List elements, Closure action) {                    <i class="conum" data-value="1"></i><b>(1)</b>
    def result = []
    elements.each {
        result << action(it)
    }
    result
}
String describe(Person p) {                                       <i class="conum" data-value="2"></i><b>(2)</b>
    "$p.name is $p.age"
}
def action = this.&describe                                       <i class="conum" data-value="3"></i><b>(3)</b>
def list = [
    new Person(name: 'Bob',   age: 42),
    new Person(name: 'Julia', age: 35)]                           <i class="conum" data-value="4"></i><b>(4)</b>
assert transform(list, action) == ['Bob is 42', 'Julia is 35']    <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>transform</code>方法获取列表中的每个元素并调用<code>action</code>关闭它们，返回新列表</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们定义一个函数<code>Person</code>并返回一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们在该函数上创建一个方法指针</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>我们创建要收集描述符的元素列表</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>方法指针可用于<code>Closure</code>被期望</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>方法指针由接收方和方法名称绑定。参数在运行时解析，这意味着，如果您有多个具有相同名称的方法，则语法没有不同，只有在运行时才对要调用的适当方法进行解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def doSomething(String str) { str.toUpperCase() }    <i class="conum" data-value="1"></i><b>(1)</b>
def doSomething(Integer x) { 2*x }                   <i class="conum" data-value="2"></i><b>(2)</b>
def reference = this.&doSomething                    <i class="conum" data-value="3"></i><b>(3)</b>
assert reference('foo') == 'FOO'                     <i class="conum" data-value="4"></i><b>(4)</b>
assert reference(123)   == 246                       <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义重载<code>doSomething</code>接受方法<code>String</code>作为争论</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>定义重载<code>doSomething</code>接受方法<code>Integer</code>作为争论</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在上创建单个方法指针<code>doSomething</code> ，而不指定参数类型</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>将方法指针与<code>String</code>称<code>String</code>版本<code>doSomething</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>将方法指针与<code>Integer</code>称<code>Integer</code>版本<code>doSomething</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_regular_expression_operators"><a class="anchor" href="#_regular_expression_operators"></a> 1.2.7。正则表达式运算符</h4>
<div class="sect4">
<h5 id="_pattern_operator"><a class="anchor" href="#_pattern_operator"></a>模式运算符</h5>
<div class="paragraph">
<p>模式运算符（ <code>~</code> ）提供了一种简单的方法来创建<code>java.util.regex.Pattern</code>实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = ~/foo/
assert p instanceof Pattern</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，您会发现模式运算符的斜线字符串中带有表达式，它可以与任何类型的<code>String</code>在Groovy中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p = ~'foo'                                                        <i class="conum" data-value="1"></i><b>(1)</b>
p = ~"foo"                                                        <i class="conum" data-value="2"></i><b>(2)</b>
p = ~$/dollar/slashy $ string/$                                   <i class="conum" data-value="3"></i><b>(3)</b>
p = ~"${pattern}"                                                 <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用单引号字符串</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用双引号字符串</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用美元斜线字符串可以使用斜杠和美元符号，而不必将其转义</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>您还可以使用GString！</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_find_operator"><a class="anchor" href="#_find_operator"></a>查找运算符</h5>
<div class="paragraph">
<p>除了构建模式之外，您还可以直接使用find运算符<code>=~</code>建立一个<code>java.util.regex.Matcher</code>实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def text = "some text to match"
def m = text =~ /match/                                           <i class="conum" data-value="1"></i><b>(1)</b>
assert m instanceof Matcher                                       <i class="conum" data-value="2"></i><b>(2)</b>
if (!m) {                                                         <i class="conum" data-value="3"></i><b>(3)</b>
    throw new RuntimeException("Oops, text not found!")
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>=~</code>创建一个匹配器<code>text</code>变量，使用右侧的模式</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的返回类型<code>=~</code>是一个<code>Matcher</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>相当于打电话<code>if (!m.find())</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>由于一个<code>Matcher</code>强迫<code>boolean</code>通过调用它<code>find</code>方法， <code>=~</code>运算符与Perl的简单用法一致<code>=~</code>运算符，当它作为谓词出现时（在<code>if</code> ， <code>while</code>等）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_match_operator"><a class="anchor" href="#_match_operator"></a>匹配运算符</h5>
<div class="paragraph">
<p>匹配运算符（ <code>==~</code> ）是find运算符的细微变化，不会返回a <code>Matcher</code>但为布尔值，并且要求输入字符串严格匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">m = text ==~ /match/                                              <i class="conum" data-value="1"></i><b>(1)</b>
assert m instanceof Boolean                                       <i class="conum" data-value="2"></i><b>(2)</b>
if (m) {                                                          <i class="conum" data-value="3"></i><b>(3)</b>
    throw new RuntimeException("Should not reach that point!")
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>==~</code>使用正则表达式匹配主题，但匹配必须严格</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的返回类型<code>==~</code>因此是<code>boolean</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>相当于打电话<code>if (text ==~ /match/)</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_other_operators"><a class="anchor" href="#_other_operators"></a> 1.2.8。其他运营商</h4>
<div class="sect4">
<h5 id="_spread_operator"><a class="anchor" href="#_spread_operator"></a>点差运算符</h5>
<div class="paragraph">
<p>扩展点运算符（ <code>*.</code> ）（通常缩写为Spread运算符）用于对聚合对象的所有项目调用操作。这等效于对每个项目调用操作并将结果收集到列表中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Car {
    String make
    String model
}
def cars = [
       new Car(make: 'Peugeot', model: '508'),
       new Car(make: 'Renault', model: 'Clio')]       <i class="conum" data-value="1"></i><b>(1)</b>
def makes = cars*.make                                <i class="conum" data-value="2"></i><b>(2)</b>
assert makes == ['Peugeot', 'Renault']                <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>建立一个清单<code>Car</code>项目。该列表是对象的集合。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>调用列表中的价差运算符，访问<code>make</code>每个项目的属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>返回对应于的集合的字符串列表<code>make</code>项目</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>表达方式<code>cars*.make</code>相当于<code>cars.collect{ it.make }</code> 。当引用的属性不是包含列表的属性时，Groovy的GPath表示法允许使用快捷方式，在这种情况下，它会自动传播。在前面提到的情况下，表达式<code>cars.make</code>可以使用，尽管通常建议保留显式的扩展点运算符。</p>
</div>
<div class="paragraph">
<p>Spread运算符是null安全的，这意味着如果collection中的元素为null，则它将返回null而不是抛出<code>NullPointerException</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">cars = [
   new Car(make: 'Peugeot', model: '508'),
   null,                                              <i class="conum" data-value="1"></i><b>(1)</b>
   new Car(make: 'Renault', model: 'Clio')]
assert cars*.make == ['Peugeot', null, 'Renault']     <i class="conum" data-value="2"></i><b>(2)</b>
assert null*.make == null                             <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>建立哪个元素的清单<code>null</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用价差运算符<strong>不会</strong>抛出<code>NullPointerException</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>接收者也可能为null，在这种情况下，返回值为<code>null</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>传播运算符可用于实现<code>Iterable</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Component {
    Long id
    String name
}
class CompositeObject implements Iterable<Component> {
    def components = [
        new Component(id: 1, name: 'Foo'),
        new Component(id: 2, name: 'Bar')]

    @Override
    Iterator<Component> iterator() {
        components.iterator()
    }
}
def composite = new CompositeObject()
assert composite*.id == [1,2]
assert composite*.name == ['Foo','Bar']</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用散点运算符的多次调用（此处<code>cars*.models*.name</code> ）使用本身包含聚合的数据结构的聚合时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Make {
    String name
    List<Model> models
}

@Canonical
class Model {
    String name
}

def cars = [
    new Make(name: 'Peugeot',
             models: [new Model('408'), new Model('508')]),
    new Make(name: 'Renault',
             models: [new Model('Clio'), new Model('Captur')])
]

def makes = cars*.name
assert makes == ['Peugeot', 'Renault']

def models = cars*.models*.name
assert models == [['408', '508'], ['Clio', 'Captur']]
assert models.sum() == ['408', '508', 'Clio', 'Captur'] // flatten one level
assert models.flatten() == ['408', '508', 'Clio', 'Captur'] // flatten all levels (one in this case)</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑使用<code>collectNested</code> DGM方法而不是散点图运算符用于集合的集合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Car {
    String make
    String model
}
def cars = [
   [
       new Car(make: 'Peugeot', model: '408'),
       new Car(make: 'Peugeot', model: '508')
   ], [
       new Car(make: 'Renault', model: 'Clio'),
       new Car(make: 'Renault', model: 'Captur')
   ]
]
def models = cars.collectNested{ it.model }
assert models == [['408', '508'], ['Clio', 'Captur']]</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_spreading_method_arguments"><a class="anchor" href="#_spreading_method_arguments"></a>传播方法参数</h6>
<div class="paragraph">
<p>在某些情况下，可能需要在列表中找到方法调用的参数以适应方法参数。在这种情况下，可以使用传播运算符来调用该方法。例如，假设您具有以下方法签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int function(int x, int y, int z) {
    x*y+z
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，如果您有以下列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def args = [4,5,6]</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以调用该方法而不必定义中间变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert function(*args) == 26</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至可以将普通参数与扩展参数混合使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">args = [4]
assert function(*args,5,6) == 26</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_spread_list_elements"><a class="anchor" href="#_spread_list_elements"></a>传播列表元素</h6>
<div class="paragraph">
<p>当在列表文字中使用时，spread运算符的行为就像将spread元素的内容内联到列表中一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def items = [4,5]                      <i class="conum" data-value="1"></i><b>(1)</b>
def list = [1,2,3,*items,6]            <i class="conum" data-value="2"></i><b>(2)</b>
assert list == [1,2,3,4,5,6]           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>items</code>是一个清单</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们要插入的内容<code>items</code>直接列出<code>list</code>无需致电<code>addAll</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>内容<code>items</code>已内联到<code>list</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_spread_map_elements"><a class="anchor" href="#_spread_map_elements"></a>传播地图元素</h6>
<div class="paragraph">
<p>扩展地图运算符的工作方式与扩展列表运算符相似，但适用于地图。它使您可以将地图的内容内联到另一个地图文字中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def m1 = [c:3, d:4]                   <i class="conum" data-value="1"></i><b>(1)</b>
def map = [a:1, b:2, *:m1]            <i class="conum" data-value="2"></i><b>(2)</b>
assert map == [a:1, b:2, c:3, d:4]    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>m1</code>是我们要内联的地图</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们使用<code>*:m1</code>表示法传播内容<code>m1</code>进入<code>map</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>map</code>包含的所有元素<code>m1</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>扩展图运算符的位置是相关的，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def m1 = [c:3, d:4]                   <i class="conum" data-value="1"></i><b>(1)</b>
def map = [a:1, b:2, *:m1, d: 8]      <i class="conum" data-value="2"></i><b>(2)</b>
assert map == [a:1, b:2, c:3, d:8]    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>m1</code>是我们要内联的地图</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们使用<code>*:m1</code>表示法传播内容<code>m1</code>进入<code>map</code> ，但重新定义密钥<code>d</code>传播<strong>后</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>map</code>包含所有预期的密钥，但是<code>d</code>重新定义</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_range_operator"><a class="anchor" href="#_range_operator"></a>范围运算符</h5>
<div class="paragraph">
<p>Groovy支持范围的概念并提供了一种表示法（ <code>..</code> ）创建对象范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def range = 0..5                                    <i class="conum" data-value="1"></i><b>(1)</b>
assert (0..5).collect() == [0, 1, 2, 3, 4, 5]       <i class="conum" data-value="2"></i><b>(2)</b>
assert (0..<5).collect() == [0, 1, 2, 3, 4]         <i class="conum" data-value="3"></i><b>(3)</b>
assert (0..5) instanceof List                       <i class="conum" data-value="4"></i><b>(4)</b>
assert (0..5).size() == 6                           <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>简单的整数范围，存储在局部变量中</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一个<code>IntRange</code> ，具有包容性范围</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>一个<code>IntRange</code> ，具有唯一上限</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>一种<code>groovy.lang.Range</code>实现<code>List</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>表示您可以致电<code>size</code>方法就可以了</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ranges实现是轻量级的，这意味着仅存储上下限。您可以从任何范围创建范围<code>Comparable</code>具有<code>next()</code>和<code>previous()</code>确定范围内下一个/上一个项目的方法。例如，您可以通过以下方式创建一系列字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ('a'..'d').collect() == ['a','b','c','d']</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spaceship_operator"><a class="anchor" href="#_spaceship_operator"></a>飞船操作员</h5>
<div class="paragraph">
<p>宇宙飞船操作员（ <code><=></code> ）的代表<code>compareTo</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert (1 <=> 1) == 0
assert (1 <=> 2) == -1
assert (2 <=> 1) == 1
assert ('a' <=> 'z') == -1</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="subscript-operator"><a class="anchor" href="#subscript-operator"></a>下标运算符</h5>
<div class="paragraph">
<p>下标运算符是的简写形式<code>getAt</code>要么<code>putAt</code> ，具体取决于您是在作业的左侧还是右侧找到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = [0,1,2,3,4]
assert list[2] == 2                         <i class="conum" data-value="1"></i><b>(1)</b>
list[2] = 4                                 <i class="conum" data-value="2"></i><b>(2)</b>
assert list[0..2] == [0,1,4]                <i class="conum" data-value="3"></i><b>(3)</b>
list[0..2] = [6,6,6]                        <i class="conum" data-value="4"></i><b>(4)</b>
assert list == [6,6,6,3,4]                  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>[2]</code>可以代替<code>getAt(2)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果在作业的左侧，将呼叫<code>putAt</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>getAt</code>也支持范围</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>也是<code>putAt</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>列表已变异</td>
</tr>
</tbody></table>
</div>
<div id="custom-subscript-operator" class="paragraph">
<p>下标运算符，结合自定义实现<code>getAt</code> / <code>putAt</code>是销毁对象的便捷方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class User {
    Long id
    String name
    def getAt(int i) {                                             <i class="conum" data-value="1"></i><b>(1)</b>
        switch (i) {
            case 0: return id
            case 1: return name
        }
        throw new IllegalArgumentException("No such element $i")
    }
    void putAt(int i, def value) {                                 <i class="conum" data-value="2"></i><b>(2)</b>
        switch (i) {
            case 0: id = value; return
            case 1: name = value; return
        }
        throw new IllegalArgumentException("No such element $i")
    }
}
def user = new User(id: 1, name: 'Alex')                           <i class="conum" data-value="3"></i><b>(3)</b>
assert user[0] == 1                                                <i class="conum" data-value="4"></i><b>(4)</b>
assert user[1] == 'Alex'                                           <i class="conum" data-value="5"></i><b>(5)</b>
user[1] = 'Bob'                                                    <i class="conum" data-value="6"></i><b>(6)</b>
assert user.name == 'Bob'                                          <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>User</code>类定义一个自定义<code>getAt</code>实作</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>User</code>类定义一个自定义<code>putAt</code>实作</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个样本用户</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>将下标运算符与索引0一起使用允许检索用户ID</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>使用带有下标1的下标运算符可以检索用户名</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>我们可以使用下标运算符写入属性，这要归功于<code>putAt</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>并检查它是否确实是财产<code>name</code>改变了</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_membership_operator"><a class="anchor" href="#_membership_operator"></a>会员运营商</h5>
<div class="paragraph">
<p>成员运算符（ <code>in</code> ）等同于调用<code>isCase</code>方法。在一个上下文中<code>List</code> ，相当于调用<code>contains</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = ['Grace','Rob','Emmy']
assert ('Emmy' in list)                     <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>相当于打电话<code>list.contains('Emmy')</code>要么<code>list.isCase('Emmy')</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_identity_operator"><a class="anchor" href="#_identity_operator"></a>身份运算符</h5>
<div class="paragraph">
<p>在Groovy中，使用<code>==</code>测试相等性不同于在Java中使用相同的运算符。在Groovy中，它正在调用<code>equals</code> 。如果要比较引用相等，则应使用<code>is</code>如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list1 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        <i class="conum" data-value="1"></i><b>(1)</b>
def list2 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        <i class="conum" data-value="2"></i><b>(2)</b>
assert list1 == list2                                       <i class="conum" data-value="3"></i><b>(3)</b>
assert !list1.is(list2)                                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个字符串列表</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建另一个包含相同元素的字符串列表</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用<code>==</code> ，我们测试对象是否相等</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>但是使用<code>is</code> ，我们可以检查引用是否不同</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_coercion_operator"><a class="anchor" href="#_coercion_operator"></a>强制运算符</h5>
<div class="paragraph">
<p>强制运算符（ <code>as</code> ）是铸造的变体。Coercion将对象从一种类型转换为另一种类型， <strong>而</strong>这些对象<strong>不</strong>兼容分配。让我们举个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Integer x = 123
String s = (String) x                                   <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>Integer</code>不可分配给<code>String</code> ，因此会产生一个<code>ClassCastException</code>在运行时</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用<em>强制</em>来解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Integer x = 123
String s = x as String                                  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>Integer</code>不可分配给<code>String</code> ，但使用<code>as</code>会<em>强迫</em>它<code>String</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当一个对象被强制转换为另一个对象时，除非目标类型与源类型相同，否则强制将返回一个<strong>新</strong>对象。强制规则因源和目标类型而异，如果未找到转换规则，强制可能会失败。自定义转换规则可以通过以下方式实现<code>asType</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Identifiable {
    String name
}
class User {
    Long id
    String name
    def asType(Class target) {                                              <i class="conum" data-value="1"></i><b>(1)</b>
        if (target == Identifiable) {
            return new Identifiable(name: name)
        }
        throw new ClassCastException("User cannot be coerced into $target")
    }
}
def u = new User(name: 'Xavier')                                            <i class="conum" data-value="2"></i><b>(2)</b>
def p = u as Identifiable                                                   <i class="conum" data-value="3"></i><b>(3)</b>
assert p instanceof Identifiable                                            <i class="conum" data-value="4"></i><b>(4)</b>
assert !(p instanceof User)                                                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>User</code>类从中定义自定义转换规则<code>User</code>至<code>Identifiable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们创建一个实例<code>User</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们强迫<code>User</code>实例化为<code>Identifiable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>目标是<code>Identifiable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>目标不是的实例<code>User</code>不再</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_diamond_operator"><a class="anchor" href="#_diamond_operator"></a>钻石算子</h5>
<div class="paragraph">
<p>钻石操作员（ <code><></code> ）是仅添加语法糖的运算符，以支持与Java 7中同名运算符的兼容性。它用于指示应从声明中推断出泛型类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">List<String> strings = new LinkedList<>()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在动态Groovy中，这是完全未使用的。在静态类型检查的Groovy中，它也是可选的，因为Groovy类型检查器会执行类型推断，而不管此操作符是否存在。</p>
</div>
</div>
<div class="sect4">
<h5 id="_call_operator"><a class="anchor" href="#_call_operator"></a>呼叫接线员</h5>
<div class="paragraph">
<p>呼叫接线员<code>()</code>用于调用名为<code>call</code>隐含地。对于任何定义一个<code>call</code>方法，您可以省略<code>.call</code>并使用调用运算符代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyCallable {
    int call(int x) {           <i class="conum" data-value="1"></i><b>(1)</b>
        2*x
    }
}

def mc = new MyCallable()
assert mc.call(2) == 4          <i class="conum" data-value="2"></i><b>(2)</b>
assert mc(2) == 4               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>MyCallable</code>定义一个名为<code>call</code> 。请注意，它不需要实现<code>java.util.concurrent.Callable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以使用经典方法调用语法来调用方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>或者我们可以省略<code>.call</code>多亏了电话接线员</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_operator_precedence"><a class="anchor" href="#_operator_precedence"></a> 1.2.9。运算符优先级</h4>
<div class="paragraph">
<p>下表按优先顺序列出了所有常规操作符。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">水平</th>
<th class="tableblock halign-left valign-top">运营商</th>
<th class="tableblock halign-left valign-top">姓名</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>new</code>   <code>()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对象创建，显式括号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>()</code>   <code>{}</code>   <code>[]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法调用，闭包，文字列表/映射</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.</code>   <code>.&</code>   <code>.@</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">成员访问，方法关闭，字段/属性访问</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>?.</code>   <code>*</code>   <code>*.</code>   <code>*:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">安全取消引用，扩展，扩展点，扩展图</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>~</code>   <code>!</code>   <code>(type)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">按位取反/模式，不是，类型转换</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[]</code>   <code>++</code>   <code>--</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">列表/地图/数组索引，后增加/减少</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功率</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>++</code>   <code>--</code>   <code>+</code>   <code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">前增加/减少，一元加，一元减</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code>   <code>/</code>   <code>%</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">乘法，div，余数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code>   <code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加，减</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><<</code>   <code>>></code>   <code>>>></code>   <code>..</code>   <code>..<</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">左/右（无符号）移位，包含/排除范围</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><</code>   <code><=</code>   <code>></code>   <code>>=</code>   <code>in</code>   <code>instanceof</code>   <code>as</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在强制类型中小于/大于/等于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>==</code>   <code>!=</code>   <code><=></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等于，不等于，比较</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=~</code>   <code>==~</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正则表达式查找，正则表达式匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制/按位和</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制/按位异或</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>|</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制/按位或</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&&</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">逻辑与</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>||</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">逻辑或</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>? :</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">三元条件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>?:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">猫王算子</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=</code>   <code>**=</code>   <code>*=</code>   <code>/=</code>   <code>%=</code>   <code>+=</code>   <code>-=</code>  <br>
<code><<=</code>   <code>>>=</code>   <code>>>>=</code>   <code>&=</code>   <code>^=</code>   <code>|=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">各种作业</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="Operator-Overloading"><a class="anchor" href="#Operator-Overloading"></a> 1.2.10。运算符重载</h4>
<div class="paragraph">
<p>Groovy允许您重载各种运算符，以便它们可以与您自己的类一起使用。考虑这个简单的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bucket {
    int size

    Bucket(int size) { this.size = size }

    Bucket plus(Bucket other) {                     <i class="conum" data-value="1"></i><b>(1)</b>
        return new Bucket(this.size + other.size)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>Bucket</code>实现一个称为<code>plus()</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>只需实施<code>plus()</code>方法， <code>Bucket</code>类现在可以与<code>+</code>运算符如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def b1 = new Bucket(4)
def b2 = new Bucket(11)
assert (b1 + b2).size == 15                         <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>他们俩<code>Bucket</code>可以将对象与<code>+</code>算子</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>所有（非比较器）Groovy运算符都有一个对应的方法，可以在自己的类中实现。唯一的要求是您的方法是公共的，具有正确的名称以及正确的参数数量。参数类型取决于要在运算符右侧支持的类型。例如，您可以支持以下语句</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert (b1 + 11).size == 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过实施<code>plus()</code>具有此签名的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Bucket plus(int capacity) {
    return new Bucket(this.size + capacity)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是运算符及其对应方法的完整列表：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作员</th>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">操作员</th>
<th class="tableblock halign-left valign-top">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.getAt（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a。减（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b] = c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.putAt（b，c）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a。乘（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a in b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">b.isCase（a）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.div（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><<</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.leftShift（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.mod（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>>></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.rightShift（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功率（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>>>></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.rightShiftUnsigned（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>|</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a。或（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>++</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.next（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.previous（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.xor（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.positive（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>as</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.asType（b）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.negative（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个电话（）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>~a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.bitwiseNegate（）</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_program_structure"><a class="anchor" href="#_program_structure"></a> 1.3。程序结构</h3>
<div class="paragraph">
<p>本章介绍了Groovy编程语言的程序结构。</p>
</div>
<div class="sect3">
<h4 id="_package_names"><a class="anchor" href="#_package_names"></a> 1.3.1。包装名称</h4>
<div class="paragraph">
<p>包名称的作用与Java中完全相同。它们使我们能够分离代码库，而不会发生任何冲突。Groovy类必须在类定义之前指定其包，否则采用默认包。</p>
</div>
<div class="paragraph">
<p>定义软件包与Java非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// defining a package named com.yoursite
package com.yoursite</code></pre>
</div>
</div>
<div class="paragraph">
<p>上课<code>Foo</code>在里面<code>com.yoursite.com</code>包，您将需要使用完全限定名称<code>com.yoursite.com.Foo</code> ，否则您可以使用<code>import</code>声明，如下所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_imports"><a class="anchor" href="#_imports"></a> 1.3.2。进口货</h4>
<div class="paragraph">
<p>为了引用任何类，您需要对其包进行合格的引用。Groovy遵循Java的允许<code>import</code>解决类引用的语句。</p>
</div>
<div class="paragraph">
<p>例如，Groovy提供了几个构建器类，例如<code>MarkupBuilder</code> 。 <code>MarkupBuilder</code>在包装内<code>groovy.xml</code>因此，要使用此类，您需要<code>import</code>如图所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_default_imports"><a class="anchor" href="#_default_imports"></a>默认导入</h5>
<div class="paragraph">
<p>默认导入是Groovy语言默认提供的导入。例如，看下面的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new Date()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java中的相同代码需要导入语句才能<code>Date</code>像这样的类：import java.util。日期。Groovy默认情况下会为您导入这些类。</p>
</div>
<div class="paragraph">
<p>groovy为您添加了以下导入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.lang.*
import java.util.*
import java.io.*
import java.net.*
import groovy.lang.*
import groovy.util.*
import java.math.BigInteger
import java.math.BigDecimal</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做是因为这些包中的类是最常用的。通过导入，这些样板代码减少了。</p>
</div>
</div>
<div class="sect4">
<h5 id="_simple_import"><a class="anchor" href="#_simple_import"></a>简单导入</h5>
<div class="paragraph">
<p>简单的import是import语句，您可以在其中完全定义类名和包。例如，导入语句import groovy.xml。下面代码中的MarkupBuilder是一个简单的导入，直接引用包中的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_star_import"><a class="anchor" href="#_star_import"></a>星级导入</h5>
<div class="paragraph">
<p>与Java一样，Groovy提供了一种特殊的方式，可以使用以下方式从包中导入所有类<code>*</code> ，即所谓的星号导入。 <code>MarkupBuilder</code>是包装中的一类<code>groovy.xml</code>以及另一个称为<code>StreamingMarkupBuilder</code> 。如果需要同时使用两个类，则可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.xml.MarkupBuilder
import groovy.xml.StreamingMarkupBuilder

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null</code></pre>
</div>
</div>
<div class="paragraph">
<p>那是完全有效的代码。但是用<code>*</code>导入，我们只需一行就可以达到相同的效果。星号导入包中的所有类<code>groovy.xml</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.xml.*

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个问题<code>*</code>导入是因为它们可能会使您的本地名称空间混乱。但是使用Groovy提供的各种别名，可以轻松解决。</p>
</div>
</div>
<div class="sect4">
<h5 id="_static_import"><a class="anchor" href="#_static_import"></a>静态导入</h5>
<div class="paragraph">
<p>Groovy的静态导入功能使您可以引用导入的类，就像它们是您自己的类中的静态方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static Boolean.FALSE

assert !FALSE //use directly, without Boolean prefix!</code></pre>
</div>
</div>
<div class="paragraph">
<p>这类似于Java的静态导入功能，但比Java更动态，因为它允许您定义与导入方法同名的方法，只要您具有不同的类型即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static java.lang.String.format <i class="conum" data-value="1"></i><b>(1)</b>

class SomeClass {

    String format(Integer i) { <i class="conum" data-value="2"></i><b>(2)</b>
        i.toString()
    }

    static void main(String[] args) {
        assert format('String') == 'String' <i class="conum" data-value="3"></i><b>(3)</b>
        assert new SomeClass().format(Integer.valueOf(1)) == '1'
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>静态导入方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>与上面静态导入的方法同名的方法声明，但参数类型不同</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>Java中的编译错误，但是是有效的常规代码</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果具有相同的类型，则导入的类优先。</p>
</div>
</div>
<div class="sect4">
<h5 id="_static_import_aliasing"><a class="anchor" href="#_static_import_aliasing"></a>静态导入别名</h5>
<div class="paragraph">
<p>静态导入<code>as</code>关键字为命名空间问题提供了一种优雅的解决方案。假设您想获得一个<code>Calendar</code>实例，使用其<code>getInstance()</code>方法。这是一个静态方法，因此我们可以使用静态导入。但是不要打电话<code>getInstance()</code>每次将其与类名分开时可能会产生误导，我们可以使用别名导入它，以提高代码的可读性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static Calendar.getInstance as now

assert now().class == Calendar.getInstance().class</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，这很干净！</p>
</div>
</div>
<div class="sect4">
<h5 id="_static_star_import"><a class="anchor" href="#_static_star_import"></a>静态星导入</h5>
<div class="paragraph">
<p>静态星号导入与常规星号导入非常相似。它将导入给定类中的所有静态方法。</p>
</div>
<div class="paragraph">
<p>例如，假设我们需要为我们的应用计算正弦和余弦。班级<code>java.lang.Math</code>有名为的静态方法<code>sin</code>和<code>cos</code>符合我们的需求。借助静态星形导入，我们可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static java.lang.Math.*

assert sin(0) == 0.0
assert cos(0) == 1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，我们能够访问这些方法<code>sin</code>和<code>cos</code>直接，没有<code>Math.</code>字首。</p>
</div>
</div>
<div class="sect4">
<h5 id="_import_aliasing"><a class="anchor" href="#_import_aliasing"></a>导入别名</h5>
<div class="paragraph">
<p>使用类型别名，我们可以使用我们选择的名称来引用完全限定的类名称。这可以通过<code>as</code>关键字，和以前一样。</p>
</div>
<div class="paragraph">
<p>例如我们可以导入<code>java.sql.Date</code>如<code>SQLDate</code>并在与该文件相同的文件中使用<code>java.util.Date</code>不必使用任何一个类的完全限定名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.util.Date
import java.sql.Date as SQLDate

Date utilDate = new Date(1000L)
SQLDate sqlDate = new SQLDate(1000L)

assert utilDate instanceof java.util.Date
assert sqlDate instanceof java.sql.Date</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_scripts_versus_classes"><a class="anchor" href="#_scripts_versus_classes"></a> 1.3.3。脚本与类</h4>
<div class="sect4">
<h5 id="_public_static_void_main_vs_script"><a class="anchor" href="#_public_static_void_main_vs_script"></a>公共静态无效主vs脚本</h5>
<div class="paragraph">
<p>Groovy支持脚本和类。以以下代码为例：</p>
</div>
<div class="listingblock">
<div class="title">主槽</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Main {                                    <i class="conum" data-value="1"></i><b>(1)</b>
    static void main(String... args) {          <i class="conum" data-value="2"></i><b>(2)</b>
        println 'Groovy world!'                 <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个<code>Main</code>类，名字是任意的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>public static void main(String[])</code>方法可用作类的主要方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>方法的主体</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是典型的代码，你会发现从Java，其中的代码<strong>必须</strong>被嵌入到一类是可执行的到来。Groovy使它变得更容易，以下代码等效：</p>
</div>
<div class="listingblock">
<div class="title">主槽</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println 'Groovy world!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将脚本视为一个类，而无需对其进行声明，但有所不同。</p>
</div>
</div>
<div class="sect4">
<h5 id="_script_class"><a class="anchor" href="#_script_class"></a>脚本类</h5>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/Script.html">脚本</a>总是被编译成一个类。Groovy编译器将为您编译该类，并将脚本主体复制到<code>run</code>方法。因此，将前面的示例编译为如下所示：</p>
</div>
<div class="listingblock">
<div class="title">主槽</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {                     <i class="conum" data-value="1"></i><b>(1)</b>
    def run() {                                 <i class="conum" data-value="2"></i><b>(2)</b>
        println 'Groovy world!'                 <i class="conum" data-value="3"></i><b>(3)</b>
    }
    static void main(String[] args) {           <i class="conum" data-value="4"></i><b>(4)</b>
        InvokerHelper.runScript(Main, args)     <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Main</code>类扩展了<code>groovy.lang.Script</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>groovy.lang.Script</code>需要一个<code>run</code>返回值的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>脚本主体进入<code>run</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>main</code>方法是自动生成的</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>并将脚本的执行委托给<code>run</code>方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果脚本在文件中，则文件的基本名称用于确定生成的脚本类的名称。在此示例中，如果文件名是<code>Main.groovy</code> ，那么脚本类将是<code>Main</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_methods"><a class="anchor" href="#_methods"></a>方法</h5>
<div class="paragraph">
<p>可以在脚本中定义方法，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int fib(int n) {
    n < 2 ? 1 : fib(n-1) + fib(n-2)
}
assert fib(10)==89</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以混合使用方法和代码。生成的脚本类会将所有方法携带到脚本类中，并将所有脚本主体组合到<code>run</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println 'Hello'                                 <i class="conum" data-value="1"></i><b>(1)</b>

int power(int n) { 2**n }                       <i class="conum" data-value="2"></i><b>(2)</b>

println "2^6==${power(6)}"                      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>脚本开始</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在脚本主体中定义了一个方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并且脚本继续</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此代码在内部转换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {
    int power(int n) { 2** n}                   <i class="conum" data-value="1"></i><b>(1)</b>
    def run() {
        println 'Hello'                         <i class="conum" data-value="2"></i><b>(2)</b>
        println "2^6==${power(6)}"              <i class="conum" data-value="3"></i><b>(3)</b>
    }
    static void main(String[] args) {
        InvokerHelper.runScript(Main, args)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>power</code>方法被原样复制到生成的脚本类中</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>第一条语句复制到<code>run</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>第二条语句复制到<code>run</code>方法</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">即使Groovy从您的脚本创建了一个类，它对用户也是完全透明的。特别是，脚本被编译为字节码，并且保留行号。这意味着，如果在脚本中引发异常，则堆栈跟踪将显示与原始脚本相对应的行号，而不是我们已显示的生成的代码。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_variables"><a class="anchor" href="#_variables"></a>变数</h5>
<div class="paragraph">
<p>脚本中的变量不需要类型定义。这意味着该脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int x = 1
int y = 2
assert x+y == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>与以下行为相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">x = 1
y = 2
assert x+y == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，两者之间在语义上有所不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果在第一个示例中声明了该变量，则它是一个<em>局部变量</em> 。它将在<code>run</code>编译器将生成的方法，并且在脚本主体之外<strong>不</strong>可见。特别是，该变量在脚本的其他方法中将<strong>不</strong>可见</p>
</li>
<li>
<p>如果未声明变量，它将进入<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/Script.html#getBinding()">脚本绑定</a> 。绑定从方法中可见，如果使用脚本与应用程序交互并且需要在脚本和应用程序之间共享数据，则该绑定尤其重要。读者可以参考<a href="#_integrating_groovy_in_a_java_application">集成指南</a>以获取更多信息。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您想让变量成为类的字段而无需进入<code>Binding</code> ，您可以使用<a href="#xform-Field">@Field批注</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_orientation"><a class="anchor" href="#_object_orientation"></a> 1.4。面向对象</h3>
<div class="paragraph">
<p>本章介绍了Groovy编程语言的面向对象。</p>
</div>
<div class="sect3">
<h4 id="_types"><a class="anchor" href="#_types"></a> 1.4.1。种类</h4>
<div class="sect4">
<h5 id="_primitive_types"><a class="anchor" href="#_primitive_types"></a>原始类型</h5>
<div class="paragraph">
<p>Groovy支持与<a href="http://docs.oracle.com/javase/specs/jls/se8/html/">Java语言规范</a>定义的原始类型相同的原始类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>整数类型： <code>byte</code> （8位）， <code>short</code> （16位）， <code>int</code> （32位）和<code>long</code> （64位）</p>
</li>
<li>
<p>浮点类型： <code>float</code> （32位）和<code>double</code> （64位）</p>
</li>
<li>
<p><code>boolean</code>类型（恰好<code>true</code>要么<code>false</code> ）</p>
</li>
<li>
<p><code>char</code>类型（16位，可用作数字类型，表示UTF-16代码）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy将原始字段和变量声明并存储为原始数据时，由于它对所有内容都使用对象，因此会自动包装对原始数据的引用。就像Java一样，它使用的包装是</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表2.基本包装器</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">原始类型</th>
<th class="tableblock halign-left valign-top">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">烧焦</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这是一个使用示例<code>int</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
  static int i
}

assert Foo.class.getDeclaredField('i').type == int.class
assert Foo.i.class != int.class && Foo.i.class == Integer.class</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在您可能会担心，这意味着每次您对原始图元使用数学运算符时，都会产生将原始图元拆箱和重新装箱的费用。但是事实并非如此，因为Groovy会将您的运算符编译为<a href="core-operators.html#_operator-overloading">等效</a>的<a href="core-operators.html#_operator-overloading">方法，</a>并改用<a href="core-operators.html#_operator-overloading">等效</a>的<a href="core-operators.html#_operator-overloading">方法</a> 。此外，当调用采用基本参数的Java方法并自动将基本方法的返回值从Java装箱时，Groovy将自动取消对基本的装箱。但是，请注意，与Java的方法解析有所<a href="core-differences-java.html#_primitives_and_wrappers">不同</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_class"><a class="anchor" href="#_class"></a>类</h5>
<div class="paragraph">
<p>Groovy类与Java类非常相似，并且在JVM级别与Java类兼容。它们可能具有方法，字段和属性（以JavaBean属性为例，但样板较少）。类和类成员可以具有与Java中相同的修饰符（公共的，受保护的，私有的，静态的等），但在源代码级别上有一些细微的差异，稍后将对此进行说明。</p>
</div>
<div class="paragraph">
<p>Groovy类及其对应的Java类之间的主要区别是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有可见性修饰符的类或方法会自动公开（可以使用特殊注释来实现程序包私有可见性）。</p>
</li>
<li>
<p>由于不需要显式的getter和setter方法，没有可见性修饰符的字段会自动变成属性，从而减少了冗长的代码。关于这方面的更多内容将在“ <a href="#fields">字段和属性”部分中介绍</a> 。</p>
</li>
<li>
<p>类不需要与它们的源文件定义具有相同的基本名称，但是在大多数情况下，强烈建议使用它们（请参见有关脚本的下一点）。</p>
</li>
<li>
<p>一个源文件可能包含一个或多个类（但是，如果文件包含不在类中的任何代码，则将其视为脚本）。脚本只是具有某些特殊约定的类，并且将具有与其源文件相同的名称（因此，请勿在脚本中包含与脚本源文件同名的类定义）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下代码提供了一个示例类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {                       <i class="conum" data-value="1"></i><b>(1)</b>

    String name                      <i class="conum" data-value="2"></i><b>(2)</b>
    Integer age

    def increaseAge(Integer years) { <i class="conum" data-value="3"></i><b>(3)</b>
        this.age += years
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>以名字开头的类<code>Person</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>字符串字段和命名的属性<code>name</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>方法定义</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_normal_class"><a class="anchor" href="#_normal_class"></a>普通班</h6>
<div class="paragraph">
<p>普通类是指顶级和具体的类。这意味着可以实例化它们，而不受任何其他类或脚本的限制。这样，它们只能是公开的（即使<code>public</code>关键字可能会被删除）。通过使用类调用其构造函数来实例化类<code>new</code>关键字，如以下代码段所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = new Person()</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_inner_class"><a class="anchor" href="#_inner_class"></a>内部阶层</h6>
<div class="paragraph">
<p>内部类在另一个类中定义。封闭类可以照常使用内部类。另一方面，内部类可以访问其封闭类的成员，即使它们是私有的也是如此。除封闭类之外的其他类均不允许访问内部类。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Outer {
    private String privateStr

    def callInnerMethod() {
        new Inner().methodA()       <i class="conum" data-value="1"></i><b>(1)</b>
    }

    class Inner {                   <i class="conum" data-value="2"></i><b>(2)</b>
        def methodA() {
            println "${privateStr}." <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>内部类被实例化，其方法被调用</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>内部类定义，在其封闭类内部</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>即使是私有的，内部类也可以访问封闭类的字段</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用内部类有一些原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它们通过将内部类对其他类隐藏而增加了封装，而其他类则无需了解。这也导致包装和工作空间更整洁。</p>
</li>
<li>
<p>通过对仅一个类使用的类进行分组，它们提供了良好的组织。</p>
</li>
<li>
<p>它们导致更易于维护的代码，因为内部类靠近使用它们的类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在某些情况下，内部类是接口的实现，这些接口的方法是外部类所需要的。下面的代码通过非常常见的线程用法说明了这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Outer2 {
    private String privateStr = 'some string'

    def startThread() {
       new Thread(new Inner2()).start()
    }

    class Inner2 implements Runnable {
        void run() {
            println "${privateStr}."
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意该类<code>Inner2</code>仅定义为提供方法的实现<code>run</code>上课<code>Outer2</code> 。在这种情况下，匿名内部类有助于消除冗长性。</p>
</div>
<div class="sect6">
<h7 id="_anonymous_inner_class"><a class="anchor" href="#_anonymous_inner_class"></a>匿名内部阶级</h7>
<div class="paragraph">
<p>内部类的最后一个示例可以使用匿名内部类简化。使用以下代码可以实现相同的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Outer3 {
    private String privateStr = 'some string'

    def startThread() {
        new Thread(new Runnable() {      <i class="conum" data-value="1"></i><b>(1)</b>
            void run() {
                println "${privateStr}."
            }
        }).start()                       <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>与上一节的最后一个示例相比， <code>new Inner2()</code>被替换为<code>new Runnable()</code>及其所有实施</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>方法<code>start</code>正常调用</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，不需要定义一个新类仅使用一次。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_abstract_class"><a class="anchor" href="#_abstract_class"></a>抽象类</h6>
<div class="paragraph">
<p>抽象类代表通用概念，因此，它们无法实例化，无法创建为子类。其成员包括字段/属性以及抽象或具体方法。抽象方法没有实现，必须由具体的子类实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Abstract {         <i class="conum" data-value="1"></i><b>(1)</b>
    String name

    abstract def abstractMethod() <i class="conum" data-value="2"></i><b>(2)</b>

    def concreteMethod() {
        println 'concrete'
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>抽象类必须用<code>abstract</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>抽象方法也必须声明为<code>abstract</code>关键词</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常将抽象类与接口进行比较。但是选择一个或另一个至少有两个重要的区别。首先，虽然抽象类可能包含字段/属性和具体方法，但接口可能仅包含抽象方法（方法签名）。而且，一个类可以实现多个接口，而它只能扩展一个类（无论是否抽象）。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_interface"><a class="anchor" href="#_interface"></a>接口</h5>
<div class="paragraph">
<p>接口定义了类需要遵循的协定。接口仅定义需要实现的方法列表，而没有定义方法的实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter {                                         <i class="conum" data-value="1"></i><b>(1)</b>
    void greet(String name)                                 <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>接口需要使用<code>interface</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>接口仅定义方法签名</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接口的方法始终是<strong>公共的</strong> 。使用是错误的<code>protected</code>要么<code>private</code>接口中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter {
    protected void greet(String name)           <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>protected</code>是编译时错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果类在其类中定义了接口，则它将<em>实现</em>一个接口<code>implements</code>列表或其任何超类是否：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SystemGreeter implements Greeter {                    <i class="conum" data-value="1"></i><b>(1)</b>
    void greet(String name) {                               <i class="conum" data-value="2"></i><b>(2)</b>
        println "Hello $name"
    }
}

def greeter = new SystemGreeter()
assert greeter instanceof Greeter                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>SystemGreeter</code>宣布<code>Greeter</code>界面使用<code>implements</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后实施所需<code>greet</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的任何实例<code>SystemGreeter</code>也是<code>Greeter</code>接口</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一个接口可以扩展另一个接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface ExtendedGreeter extends Greeter {                 <i class="conum" data-value="1"></i><b>(1)</b>
    void sayBye(String name)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>ExtendedGreeter</code>接口扩展了<code>Greeter</code>界面使用<code>extends</code>关键词</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得注意的是，要使一个类成为接口的实例，必须明确。例如，以下类定义了<code>greet</code>在中声明的方法<code>Greeter</code>接口，但不声明<code>Greeter</code>在其界面中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class DefaultGreeter {
    void greet(String name) { println "Hello" }
}

greeter = new DefaultGreeter()
assert !(greeter instanceof Greeter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，Groovy没有定义结构类型。但是，可以使用运行时对象的实例在运行时实现接口。 <code>as</code>强制运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">greeter = new DefaultGreeter()                              <i class="conum" data-value="1"></i><b>(1)</b>
coerced = greeter as Greeter                                <i class="conum" data-value="2"></i><b>(2)</b>
assert coerced instanceof Greeter                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个实例<code>DefaultGreeter</code>没有实现接口</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将实例强制<code>Greeter</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>强制实例实现<code>Greeter</code>接口</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您会看到有两个不同的对象：一个是源对象，一个是<code>DefaultGreeter</code>实例，它没有实现该接口。另一个是<code>Greeter</code>委托给强制对象。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Groovy接口不支持Java 8接口之类的默认实现。如果您正在寻找类似（但不相等）的东西， <a href="#_traits">特征就很</a>接近接口，但是允许默认实现以及本手册中描述的其他重要功能。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_constructors"><a class="anchor" href="#_constructors"></a>建设者</h5>
<div class="paragraph">
<p>构造函数是用于初始化具有特定状态的对象的特殊方法。与普通方法一样，一个类可以声明多个构造函数，只要每个构造函数具有唯一的类型签名即可。如果对象在构造过程中不需要任何参数，则可以使用<em>no-arg</em>构造函数。如果没有提供构造函数，那么Groovy编译器将提供一个空的无参数构造函数。</p>
</div>
<div class="paragraph">
<p>Groovy支持两种调用样式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>使用位置参数的</em>方式类似于使用Java构造函数的方式</p>
</li>
<li>
<p><em>命名参数</em>允许您在调用构造函数时指定参数名称。</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_positional_parameters"><a class="anchor" href="#_positional_parameters"></a>位置参数</h6>
<div class="paragraph">
<p>要使用位置参数创建对象，相应的类需要声明一个或多个构造函数。对于多个构造函数，每个构造函数必须具有唯一的类型签名。构造函数也可以使用<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/transform/TupleConstructor.html">groovy.transform添加到类中</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/transform/TupleConstructor.html">。TupleConstructor</a>批注。</p>
</div>
<div class="paragraph">
<p>通常，一旦声明了至少一个构造函数，则只能通过调用其构造函数之一来实例化该类。值得注意的是，在这种情况下，您通常无法使用命名参数创建类。Groovy确实支持命名参数，只要该类包含一个无参数的构造函数或提供一个采用<code>Map</code>参数作为第一个（也是唯一可能的）参数-有关详细信息，请参见下一部分。</p>
</div>
<div class="paragraph">
<p>使用声明的构造函数有三种形式。第一种是普通的Java方式， <code>new</code>关键词。其他依赖于将列表强制转换成所需的类型。在这种情况下，可以强制<code>as</code>关键字并通过静态键入变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class PersonConstructor {
    String name
    Integer age

    PersonConstructor(name, age) {          <i class="conum" data-value="1"></i><b>(1)</b>
        this.name = name
        this.age = age
    }
}

def person1 = new PersonConstructor('Marie', 1)  <i class="conum" data-value="2"></i><b>(2)</b>
def person2 = ['Marie', 2] as PersonConstructor  <i class="conum" data-value="3"></i><b>(3)</b>
PersonConstructor person3 = ['Marie', 3]         <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>构造函数声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>构造函数调用，经典的Java方式</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>构造函数用法，与<code>as</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>构造函数用法，在分配中使用强制</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_named_parameters"><a class="anchor" href="#_named_parameters"></a>命名参数</h6>
<div class="paragraph">
<p>如果未声明（或无参数）构造函数，则可以通过以映射形式（属性/值对）传递参数来创建对象。如果要允许多个参数组合，这可能会派上用场。否则，通过使用传统的位置参数，必须声明所有可能的构造函数。有一个构造函数，其中第一个（也许也是唯一一个）参数是<code>Map</code>参数也受支持-也可以使用<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/transform/MapConstructor.html">groovy.transform添加此类构造</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/transform/MapConstructor.html">函数。MapConstructor</a>批注。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class PersonWOConstructor {                                  <i class="conum" data-value="1"></i><b>(1)</b>
    String name
    Integer age
}

def person4 = new PersonWOConstructor()                      <i class="conum" data-value="2"></i><b>(2)</b>
def person5 = new PersonWOConstructor(name: 'Marie')         <i class="conum" data-value="3"></i><b>(3)</b>
def person6 = new PersonWOConstructor(age: 1)                <i class="conum" data-value="4"></i><b>(4)</b>
def person7 = new PersonWOConstructor(name: 'Marie', age: 2) <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>没有声明构造函数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>实例中未提供任何参数</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>name</code>实例化中给出的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>age</code>实例化中给出的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>name</code>和<code>age</code>实例中给出的参数</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，重要的是要强调一点，这种方法为构造函数调用者提供了更多功能，同时对调用者增加了使名称和值类型正确的责任。因此，如果需要更大的控制权，则最好使用位置参数声明构造函数。</p>
</div>
<div class="paragraph">
<p>笔记：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>尽管上面的示例没有提供构造函数，但是您也可以提供no-arg构造函数或第一个参数为<code>Map</code> ，最通常是唯一的论点。</p>
</li>
<li>
<p>当没有（或无参数）构造函数被声明时，对于每个提供的命名属性，Groovy会先通过调用no-arg构造函数，再调用setter来替换命名的构造函数调用。</p>
</li>
<li>
<p>当第一个参数是Map时，Groovy将所有命名参数组合到Map中（不考虑顺序），并将地图作为第一个参数。如果您的属性声明为<code>final</code> （因为它们将在构造函数中设置，而不是在使用setter的事实之后设置）。</p>
</li>
<li>
<p>通过提供位置构造函数以及无参数或Map构造函数，可以支持命名构造和位置构造。</p>
</li>
<li>
<p>您可以通过具有第一个参数是Map的构造函数来支持混合构造，但是还需要其他位置参数。请谨慎使用此样式。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_methods_2"><a class="anchor" href="#_methods_2"></a>方法</h5>
<div class="paragraph">
<p>Groovy方法与其他语言非常相似。下一部分将显示一些特性。</p>
</div>
<div class="sect5">
<h6 id="_method_definition"><a class="anchor" href="#_method_definition"></a>方法定义</h6>
<div class="paragraph">
<p>用返回类型或方法定义方法<code>def</code>关键字，以使返回类型为无类型。方法也可以接收任意数量的参数，这些参数可能没有明确声明其类型。Java修饰符可以正常使用，并且如果未提供可见性修饰符，则该方法是公共的。</p>
</div>
<div class="paragraph">
<p>Groovy中的方法总是返回一些值。如果不<code>return</code>提供语句，将返回在最后执行的行中评估的值。例如，请注意，以下方法均不使用<code>return</code>关键词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def someMethod() { 'method called' }                           <i class="conum" data-value="1"></i><b>(1)</b>
String anotherMethod() { 'another method called' }             <i class="conum" data-value="2"></i><b>(2)</b>
def thirdMethod(param1) { "$param1 passed" }                   <i class="conum" data-value="3"></i><b>(3)</b>
static String fourthMethod(String param1) { "$param1 passed" } <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>没有声明返回类型且没有参数的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>具有显式返回类型且无参数的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>具有未定义类型的参数的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>带有String参数的静态方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_named_parameters_2"><a class="anchor" href="#_named_parameters_2"></a>命名参数</h6>
<div class="paragraph">
<p>像构造函数一样，普通方法也可以使用命名参数来调用。为了支持这种表示法，使用了约定，其中方法的第一个参数是<code>Map</code> 。在方法主体中，可以像在普通映射中一样访问参数值（ <code>map.key</code> ）。如果该方法只有一个Map参数，则必须命名所有提供的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Map args) { "${args.name}: ${args.age}" }
foo(name: 'Marie', age: 1)</code></pre>
</div>
</div>
<div class="sect6">
<h7 id="_mixing_named_and_positional_parameters"><a class="anchor" href="#_mixing_named_and_positional_parameters"></a>混合命名和位置参数</h7>
<div class="paragraph">
<p>命名参数可以与位置参数混合。在这种情况下，除了<code>Map</code>参数作为第一个参数，所讨论的方法将根据需要具有其他位置参数。调用方法时提供的位置参数必须正确。命名参数可以在任何位置。它们被分组到地图中，并自动作为第一个参数提供。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Map args, Integer number) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(name: 'Marie', age: 1, 23)  <i class="conum" data-value="1"></i><b>(1)</b>
foo(23, name: 'Marie', age: 1)  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>附加方法调用<code>number</code>的论点<code>Integer</code>类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>具有参数顺序更改的方法调用</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们没有Map作为第一个参数，则必须为该参数提供Map而不是命名参数。否则将导致<code>groovy.lang.MissingMethodException</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(name: 'Marie', age: 1, 23)  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>方法调用抛出<code>groovy.lang.MissingMethodException: No signature of method: foo() is applicable for argument types: (LinkedHashMap, Integer) values: [[name:Marie, age:1], 23]</code> ，因为命名参数<code>Map</code>参数未定义为第一个参数</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们用显式替换命名参数，可以避免上述异常<code>Map</code>参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(23, [name: 'Marie', age: 1])  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确的<code>Map</code>参数代替命名参数使调用有效</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">尽管Groovy允许您混合使用命名参数和位置参数，但这可能导致不必要的混乱。请谨慎混合命名和位置参数。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_default_arguments"><a class="anchor" href="#_default_arguments"></a>默认参数</h6>
<div class="paragraph">
<p>默认参数使参数可选。如果未提供参数，则该方法采用默认值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(String par1, Integer par2 = 1) { [name: par1, age: par2] }
assert foo('Marie').age == 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在存在默认参数之后，无法定义任何强制性参数，只能定义其他默认参数。</p>
</div>
</div>
<div class="sect5">
<h6 id="_varargs"><a class="anchor" href="#_varargs"></a>瓦拉格斯</h6>
<div class="paragraph">
<p>Groovy支持参数数量可变的方法。它们的定义如下： <code>def foo(p1, …​, pn, T…​ args)</code> 。这里<code>foo</code>支持<code>n</code>默认情况下的参数，但未指定数量的其他参数超出<code>n</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { args.length }
assert foo() == 0
assert foo(1) == 1
assert foo(1, 2) == 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子定义了一个方法<code>foo</code> ，它可以接受任意数量的参数，包括完全没有参数。
<code>args.length</code>将返回给定的参数数量。Groovy允许<code>T[]</code>作为替代符号<code>T…​</code> 。这意味着Groovy将任何以数组作为最后一个参数的方法视为可以接受可变数量参数的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object[] args) { args.length }
assert foo() == 0
assert foo(1) == 1
assert foo(1, 2) == 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用varargs的方法被调用<code>null</code>作为vararg参数，则参数将为<code>null</code>而不是长度为<code>null</code>作为唯一元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { args }
assert foo(null) == null</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用数组作为参数调用varargs方法，则参数将是该数组，而不是包含给定数组作为唯一元素的长度为1的数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { args }
Integer[] ints = [1, 2]
assert foo(ints) == [1, 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个要点是varargs与方法重载相结合。如果方法过载，Groovy将选择最具体的方法。例如，如果一个方法<code>foo</code>接受类型为varargs的参数<code>T</code>和另一种方法<code>foo</code>也接受一个类型的参数<code>T</code> ，第二种方法是首选。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(Object... args) { 1 }
def foo(Object x) { 2 }
assert foo() == 1
assert foo(1) == 2
assert foo(1, 2) == 1</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_method_selection_algorithm"><a class="anchor" href="#_method_selection_algorithm"></a>方法选择算法</h6>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
<div class="sect5">
<h6 id="_exception_declaration"><a class="anchor" href="#_exception_declaration"></a>异常声明</h6>
<div class="paragraph">
<p>Groovy自动允许您将已检查的异常视为未检查的异常。这意味着您不需要声明方法可能抛出的任何检查的异常，如下面的示例所示，该示例可以抛出一个<code>FileNotFoundException</code>如果找不到文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def badRead() {
    new File('doesNotExist.txt').text
}

shouldFail(FileNotFoundException) {
    badRead()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也不需要围绕电话<code>badRead</code>上一个示例中的try / catch块中的方法-尽管您可以随意这样做。</p>
</div>
<div class="paragraph">
<p>如果您希望声明代码可能抛出（检查或以其他方式抛出）的任何异常，则可以这样做。添加异常不会改变其他Groovy代码中代码的使用方式，但是可以看作是代码的人工阅读者的文档。异常将成为字节码中方法声明的一部分，因此，如果您的代码可能是从Java调用的，则将它们包括在内可能会很有用。以下示例说明了如何使用显式检查异常声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def badRead() throws FileNotFoundException {
    new File('doesNotExist.txt').text
}

shouldFail(FileNotFoundException) {
    badRead()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fields_and_properties"><a class="anchor" href="#_fields_and_properties"></a>字段和属性</h5>
<div class="sect5">
<h6 id="fields"><a class="anchor" href="#fields"></a>领域</h6>
<div class="paragraph">
<p>字段是具有以下内容的类或特征的成员：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>强制<em>访问修饰符</em> （ <code>public</code> ， <code>protected</code> ， 要么<code>private</code> ）</p>
</li>
<li>
<p>一个或多个可选<em>修饰符</em> （ <code>static</code> ， <code>final</code> ， <code>synchronized</code> ）</p>
</li>
<li>
<p>可选<em>类型</em></p>
</li>
<li>
<p>强制性<em>名称</em></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Data {
    private int id                                  <i class="conum" data-value="1"></i><b>(1)</b>
    protected String description                    <i class="conum" data-value="2"></i><b>(2)</b>
    public static final boolean DEBUG = false       <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一种<code>private</code>字段命名<code>id</code> ，类型<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一种<code>protected</code>字段命名<code>description</code> ，类型<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>一种<code>public static final</code>类型为<em>DEBUG</em>的字段<code>boolean</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>字段可以在声明时直接初始化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Data {
    private String id = IDGenerator.next() <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>私人领域<code>id</code>初始化为<code>IDGenerator.next()</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以省略字段的类型声明。但是，这被认为是不好的做法，总的来说，对字段使用强类型是一个好主意：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BadPractice {
    private mapping                         <i class="conum" data-value="1"></i><b>(1)</b>
}
class GoodPractice {
    private Map<String,String> mapping      <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>场<code>mapping</code>没有声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>场<code>mapping</code>有很强的类型</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果以后要使用可选的类型检查，则两者之间的区别很重要。这对于文档编制也很重要。但是，在某些情况下（例如脚本编写）或如果您想依赖鸭子输入，则可能会忽略该类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="properties"><a class="anchor" href="#properties"></a>性质</h6>
<div class="paragraph">
<p>属性是类的外部可见功能。Java中的典型约定不仅是使用公共字段来表示此类功能（它提供了更有限的抽象，而且会限制重构的可能性），而是遵循JavaBean约定，即使用私有支持字段和getter的组合来表示属性。 /设置者。Groovy遵循这些相同的约定，但是提供了一种更简单的方法来定义属性。您可以使用以下方法定义属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>缺少</strong>访问修饰符（否<code>public</code> ， <code>protected</code>要么<code>private</code> ）</p>
</li>
<li>
<p>一个或多个可选<em>修饰符</em> （ <code>static</code> ， <code>final</code> ， <code>synchronized</code> ）</p>
</li>
<li>
<p>可选<em>类型</em></p>
</li>
<li>
<p>强制性<em>名称</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy随后将适当地生成吸气剂/吸气剂。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name                             <i class="conum" data-value="1"></i><b>(1)</b>
    int age                                 <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建后盾<code>private String name</code>场<code>getName</code>和一个<code>setName</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建后盾<code>private int age</code>场<code>getAge</code>和一个<code>setAge</code>方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果声明了属性<code>final</code> ，不会生成设置器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    final String name                   <i class="conum" data-value="1"></i><b>(1)</b>
    final int age                       <i class="conum" data-value="2"></i><b>(2)</b>
    Person(String name, int age) {
        this.name = name                <i class="conum" data-value="3"></i><b>(3)</b>
        this.age = age                  <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义类型的只读属性<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>定义类型的只读属性<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>分配<code>name</code>的参数<code>name</code>领域</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>分配<code>age</code>的参数<code>age</code>领域</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>属性是通过名称访问的，并且将透明地调用getter或setter，除非代码在定义属性的类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    void name(String name) {
        this.name = "Wonder$name"       <i class="conum" data-value="1"></i><b>(1)</b>
    }
    String wonder() {
        this.name                       <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
def p = new Person()
p.name = 'Marge'                        <i class="conum" data-value="3"></i><b>(3)</b>
assert p.name == 'Marge'                <i class="conum" data-value="4"></i><b>(4)</b>
p.name('Marge')                         <i class="conum" data-value="5"></i><b>(5)</b>
assert p.wonder() == 'WonderMarge'      <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>this.name</code>将直接访问该字段，因为该属性是从定义它的类中访问的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类似地，直接在<code>name</code>领域</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>对属性的写访问权限是在<code>Person</code>类，因此它将隐式调用<code>setName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>对属性的读取访问是在<code>Person</code>类，因此它将隐式调用<code>getName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>这将称为<code>name</code>方法开启<code>Person</code>直接执行该字段</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>这将称为<code>wonder</code>方法开启<code>Person</code>对字段执行直接读取访问</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得注意的是，这样做是为了防止在定义属性的类中使用属性访问语法时发生堆栈溢出，从而防止堆栈溢出。</p>
</div>
<div class="paragraph">
<p>通过meta可以列出类的属性<code>properties</code>实例的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
}
def p = new Person()
assert p.properties.keySet().containsAll(['name','age'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>按照约定，即使没有支持字段，只要有遵循Java Beans规范的getter或setter，Groovy都将识别属性。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class PseudoProperties {
    // a pseudo property "name"
    void setName(String name) {}
    String getName() {}

    // a pseudo read-only property "age"
    int getAge() { 42 }

    // a pseudo write-only property "groovy"
    void setGroovy(boolean groovy) {  }
}
def p = new PseudoProperties()
p.name = 'Foo'                      <i class="conum" data-value="1"></i><b>(1)</b>
assert p.age == 42                  <i class="conum" data-value="2"></i><b>(2)</b>
p.groovy = true                     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>写作<code>p.name</code>因为存在伪属性而被允许<code>name</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>阅读<code>p.age</code>允许，因为有一个伪只读属性<code>age</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>写作<code>p.groovy</code>允许，因为有一个伪只写属性<code>groovy</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这种语法糖是用Groovy编写的许多DSL的核心。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_annotation"><a class="anchor" href="#_annotation"></a>注解</h5>
<div class="sect5">
<h6 id="ann-definition"><a class="anchor" href="#ann-definition"></a>注释定义</h6>
<div class="paragraph">
<p>注释是一种专用于对代码元素进行注释的特殊接口。注释是一种类型，其中超级接口是<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Annotation.html">注释</a>接口。使用接口以与接口非常相似的方式声明注释。 <code>@interface</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface SomeAnnotation {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>批注可以以没有主体和可选默认值的方法的形式定义成员。可能的成员类型限于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基本类型</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/String.html">弦乐</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Class.html">班级</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Enum.html">枚举</a></p>
</li>
<li>
<p>另一种<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Annotation.html">注释类型</a></p>
</li>
<li>
<p>或以上任何数组</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface SomeAnnotation {
    String value()                          <i class="conum" data-value="1"></i><b>(1)</b>
}
@interface SomeAnnotation {
    String value() default 'something'      <i class="conum" data-value="2"></i><b>(2)</b>
}
@interface SomeAnnotation {
    int step()                              <i class="conum" data-value="3"></i><b>(3)</b>
}
@interface SomeAnnotation {
    Class appliesTo()                       <i class="conum" data-value="4"></i><b>(4)</b>
}
@interface SomeAnnotation {}
@interface SomeAnnotations {
    SomeAnnotation[] value()                <i class="conum" data-value="5"></i><b>(5)</b>
}
enum DayOfWeek { mon, tue, wed, thu, fri, sat, sun }
@interface Scheduled {
    DayOfWeek dayOfWeek()                   <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义<code>value</code>类型成员<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>定义<code>value</code>类型成员<code>String</code>默认值为<code>something</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>定义<code>step</code>类型的成员原始类型<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>定义<code>appliesTo</code>类型成员<code>Class</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>定义<code>value</code>成员，该类型是另一个注释类型的数组</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>定义<code>dayOfWeek</code>成员是枚举类型<code>DayOfWeek</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与Java语言不同，在Groovy中，可以使用注释来更改语言的语义。AST转换尤其如此，它将基于注释生成代码。</p>
</div>
</div>
<div class="sect5">
<h6 id="ann-placement"><a class="anchor" href="#ann-placement"></a>注解位置</h6>
<div class="paragraph">
<p>注释可以应用于代码的各个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@SomeAnnotation                 <i class="conum" data-value="1"></i><b>(1)</b>
void someMethod() {
    // ...
}

@SomeAnnotation                 <i class="conum" data-value="2"></i><b>(2)</b>
class SomeClass {}

@SomeAnnotation String var      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>@SomeAnnotation</code>适用于<code>someMethod</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>@SomeAnnotation</code>适用于<code>SomeClass</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>@SomeAnnotation</code>适用于<code>var</code>变量</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了限制可以应用注释的范围，必须使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Target.html">Target</a>注释在注释定义上声明它。例如，这是您声明可以将注释应用于类或方法的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.lang.annotation.ElementType
import java.lang.annotation.Target

@Target([ElementType.METHOD, ElementType.TYPE])     <i class="conum" data-value="1"></i><b>(1)</b>
@interface SomeAnnotation {}                        <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Target</code>注解旨在用范围对注解进行注解。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>@SomeAnnotation</code>因此只会被允许<code>TYPE</code>要么<code>METHOD</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可能的目标列表在<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html">ElementType枚举中</a>可用。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">Groovy不支持Java 8中引入的<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html#TYPE_PARAMETER">TYPE_PARAMETER</a>和<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html#TYPE_PARAMETER">TYPE_USE</a>元素类型。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_annotation_member_values"><a class="anchor" href="#_annotation_member_values"></a>注释成员值</h6>
<div class="paragraph">
<p>使用注释时，需要至少设置所有没有默认值的成员。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface Page {
    int statusCode()
}

@Page(statusCode=404)
void notFound() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是可以省略<code>value=</code>在注释的值的声明中，如果成员<code>value</code>是唯一设置的一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@interface Page {
    String value()
    int statusCode() default 200
}

@Page(value='/home')                    <i class="conum" data-value="1"></i><b>(1)</b>
void home() {
    // ...
}

@Page('/users')                         <i class="conum" data-value="2"></i><b>(2)</b>
void userList() {
    // ...
}

@Page(value='error',statusCode=404)     <i class="conum" data-value="3"></i><b>(3)</b>
void notFound() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们可以省略<code>statusCode</code>因为它具有默认值，但是<code>value</code>需要设置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>以来<code>value</code>是唯一没有默认值的强制成员，我们可以省略<code>value=</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果两者<code>value</code>和<code>statusCode</code>需要设置，需要使用<code>value=</code>为默认<code>value</code>会员</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_retention_policy"><a class="anchor" href="#_retention_policy"></a>保留政策</h6>
<div class="paragraph">
<p>注释的可见性取决于其保留策略。注释的保留策略是使用<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Retention.html">Retention</a>注释设置的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy

@Retention(RetentionPolicy.SOURCE)                   <i class="conum" data-value="1"></i><b>(1)</b>
@interface SomeAnnotation {}                         <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Retention</code>批注为<code>@SomeAnnotation</code>注解</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>所以<code>@SomeAnnotation</code>将有一个<code>SOURCE</code>保留</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/RetentionPolicy.html">RetentionPolicy</a>枚举中提供了可能的保留目标和说明列表。选择通常取决于您是要在编译时还是运行时看到注释。</p>
</div>
</div>
<div class="sect5">
<h6 id="_closure_annotation_parameters"><a class="anchor" href="#_closure_annotation_parameters"></a>闭包注释参数</h6>
<div class="paragraph">
<p>Groovy中注释的一个有趣的功能是可以将闭包用作注释值。因此，注释可用于多种表达式，并且仍具有IDE支持。例如，设想一个框架，您希望根据环境约束（例如JDK版本或OS）执行某些方法。可以编写以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Tasks {
    Set result = []
    void alwaysExecuted() {
        result << 1
    }
    @OnlyIf({ jdk>=6 })
    void supportedOnlyInJDK6() {
        result << 'JDK 6'
    }
    @OnlyIf({ jdk>=7 && windows })
    void requiresJDK7AndWindows() {
        result << 'JDK 7 Windows'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了<code>@OnlyIf</code>注释接受<code>Closure</code>作为参数，您只需要声明<code>value</code>作为一个<code>Class</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@interface OnlyIf {
    Class value()                    <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了完成该示例，让我们编写一个使用该信息的样本运行器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Runner {
    static <T> T run(Class<T> taskClass) {
        def tasks = taskClass.newInstance()                                         <i class="conum" data-value="1"></i><b>(1)</b>
        def params = [jdk:6, windows: false]                                        <i class="conum" data-value="2"></i><b>(2)</b>
        tasks.class.declaredMethods.each { m ->                                     <i class="conum" data-value="3"></i><b>(3)</b>
            if (Modifier.isPublic(m.modifiers) && m.parameterTypes.length == 0) {   <i class="conum" data-value="4"></i><b>(4)</b>
                def onlyIf = m.getAnnotation(OnlyIf)                                <i class="conum" data-value="5"></i><b>(5)</b>
                if (onlyIf) {
                    Closure cl = onlyIf.value().newInstance(tasks,tasks)            <i class="conum" data-value="6"></i><b>(6)</b>
                    cl.delegate = params                                            <i class="conum" data-value="7"></i><b>(7)</b>
                    if (cl()) {                                                     <i class="conum" data-value="8"></i><b>(8)</b>
                        m.invoke(tasks)                                             <i class="conum" data-value="9"></i><b>(9)</b>
                    }
                } else {
                    m.invoke(tasks)                                                 <i class="conum" data-value="10"></i><b>(10)</b>
                }
            }
        }
        tasks                                                                       <i class="conum" data-value="11"></i><b>(11)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建作为参数传递的类的新实例（任务类）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>模拟一个不是Windows的JDK 6环境</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>迭代任务类的所有已声明方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>如果该方法是公开的并且不带参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>尝试找到<code>@OnlyIf</code>注解</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>如果找到了<code>value</code>并创建一个新的<code>Closure</code>从中</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>设置<code>delegate</code>对我们的环境变量的关闭</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>称为闭包，即注解闭包。它将返回一个<code>boolean</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>如果是<code>true</code> ，调用方法</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>如果该方法未使用注释<code>@OnlyIf</code> ，仍然执行方法</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i> <b>11</b></td>
<td>之后，返回任务对象</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后可以通过以下方式使用跑步者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def tasks = Runner.run(Tasks)
assert tasks.result == [1, 'JDK 6'] as Set</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_meta_annotations"><a class="anchor" href="#_meta_annotations"></a>元注释</h6>
<div class="sect6">
<h7 id="_declaring_meta_annotations"><a class="anchor" href="#_declaring_meta_annotations"></a>声明元注释</h7>
<div class="paragraph">
<p>元注释（也称为注释别名）是在编译时由其他注释替换的注释（一个元注释是一个或多个注释的别名）。元注释可用于减少涉及多个注释的代码的大小。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始。想象你有<code>@Service</code>和<code>@Transactional</code>批注，并且您想同时使用这两种方式来注释类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Service
@Transactional
class MyTransactionalService {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定您可以添加到同一类的批注的倍数，元批注可以通过使用语义完全相同的单个批注减少两个批注来提供帮助。例如，我们可能想写成这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TransactionalService                           <i class="conum" data-value="1"></i><b>(1)</b>
class MyTransactionalService {}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>@TransactionalService</code>是一个元注释</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>元注释被声明为常规注释，但带有<code>@AnnotationCollector</code>以及它正在收集的注释列表。就我们而言， <code>@TransactionalService</code>注释可以写成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AnnotationCollector

@Service                                        <i class="conum" data-value="1"></i><b>(1)</b>
@Transactional                                  <i class="conum" data-value="2"></i><b>(2)</b>
@AnnotationCollector                            <i class="conum" data-value="3"></i><b>(3)</b>
@interface TransactionalService {
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用以下命令注释元注释<code>@Service</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>用以下命令注释元注释<code>@Transactional</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>用以下命令注释元注释<code>@AnnotationCollector</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect6">
<h7 id="meta-ann-behavior"><a class="anchor" href="#meta-ann-behavior"></a>元注释的行为</h7>
<div class="paragraph">
<p>Groovy支持<em>预编译</em>和<em>源形式的</em>元注释。这意味着您的元注释<em>可以</em>预先编译，也可以与当前正在编译的源树放在同一源代码树中。</p>
</div>
<div class="paragraph">
<p>信息：元注释是仅Groovy的功能。您没有机会用元注释来注释Java类，并希望它能与Groovy一样。同样，您不能用Java编写元注释：元注释定义<strong>和</strong>用法都必须是Groovy代码。但是，您可以在元注释中愉快地收集Java注释和Groovy注释。</p>
</div>
<div class="paragraph">
<p>当Groovy编译器遇到带有元注释的类时，它将<strong>替换</strong>为收集的注释。因此，在我们之前的示例中，它将替换<code>@TransactionalService</code>与<code>@Transactional</code>和<code>@Service</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def annotations = MyTransactionalService.annotations*.annotationType()
assert (Service in annotations)
assert (Transactional in annotations)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<em>语义分析</em>编译阶段执行从元注释到收集的注释的转换。</p>
</div>
<div class="paragraph">
<p>除了使用收集的注释替换别名之外，元注释还能够处理它们，包括参数。</p>
</div>
</div>
<div class="sect6">
<h7 id="meta-ann-members"><a class="anchor" href="#meta-ann-members"></a>元注释参数</h7>
<div class="paragraph">
<p>元注释可以收集具有参数的注释。为了说明这一点，我们将想象两个注释，每个注释接受一个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Timeout(after=3600)
@Dangerous(type='explosive')</code></pre>
</div>
</div>
<div class="paragraph">
<p>并假设您要创建一个名为<code>@Explosive</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Timeout(after=3600)
@Dangerous(type='explosive')
@AnnotationCollector
public @interface Explosive {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，替换注释时，它们将获得<strong>在alias中定义</strong>的注释参数值。更有趣的是，元注释支持覆盖特定值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Explosive(after=0)                 <i class="conum" data-value="1"></i><b>(1)</b>
class Bomb {}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>after</code>作为参数提供的值<code>@Explosive</code>覆盖在<code>@Timeout</code>注解</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果两个注释定义了相同的参数名称，则默认处理器会将注释值复制到接受此参数的所有注释中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
   String value()                                   <i class="conum" data-value="1"></i><b>(1)</b>
}
@Retention(RetentionPolicy.RUNTIME)
public @interface Bar {
    String value()                                  <i class="conum" data-value="2"></i><b>(2)</b>
}

@Foo
@Bar
@AnnotationCollector
public @interface FooBar {}                         <i class="conum" data-value="3"></i><b>(3)</b>

@Foo('a')
@Bar('b')
class Bob {}                                        <i class="conum" data-value="4"></i><b>(4)</b>

assert Bob.getAnnotation(Foo).value() == 'a'        <i class="conum" data-value="5"></i><b>(5)</b>
println Bob.getAnnotation(Bar).value() == 'b'       <i class="conum" data-value="6"></i><b>(6)</b>

@FooBar('a')
class Joe {}                                        <i class="conum" data-value="7"></i><b>(7)</b>
assert Joe.getAnnotation(Foo).value() == 'a'        <i class="conum" data-value="8"></i><b>(8)</b>
println Joe.getAnnotation(Bar).value() == 'a'       <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Foo</code>注释定义了<code>value</code>类型成员<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>@Bar</code>注释还定义了<code>value</code>类型成员<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>@FooBar</code>元注释聚合<code>@Foo</code>和<code>@Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>类<code>Bob</code>带有注释<code>@Foo</code>和<code>@Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的价值<code>@Foo</code>上的注释<code>Bob</code>是<code>a</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>而价值<code>@Bar</code>上的注释<code>Bob</code>是<code>b</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>类<code>Joe</code>带有注释<code>@FooBar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后的价值<code>@Foo</code>上的注释<code>Joe</code>是<code>a</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>和的价值<code>@Bar</code>上的注释<code>Joe</code>也是<code>a</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在第二种情况下，将元注释值复制到两个<code>@Foo</code>和<code>@Bar</code>注释。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果收集的批注定义了具有不兼容类型的相同成员，则会产生编译时错误。例如，如果在前面的示例中<code>@Foo</code>定义类型的值<code>String</code>但<code>@Bar</code>定义类型的值<code>int</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，可以自定义元注释的行为并描述如何扩展收集的注释。我们将很快讨论如何做，但首先要介绍一个高级处理选项。</p>
</div>
</div>
<div class="sect6">
<h7 id="handling_duplicate_annotations"><a class="anchor" href="#handling_duplicate_annotations"></a>处理重复的注释</h7>
<div class="paragraph">
<p>的<code>@AnnotationCollector</code>注释支持<code>mode</code>该参数可用于在存在重复注释的情况下更改默认处理器如何处理注释替换。</p>
</div>
<div class="paragraph">
<p>INFO：定制处理器（下面讨论）可能支持也可能不支持此参数。</p>
</div>
<div class="paragraph">
<p>举例来说，假设您创建了一个包含<code>@ToString</code>注释，然后将您的元注释放在已经有显式的类上<code>@ToString</code>注解。这应该是一个错误吗？是否应同时使用两个注释？一个优先于另一个吗？没有正确的答案。在某些情况下，使这些答案中的任何一个正确都是很合适的。因此，与尝试抢占一种解决重复标注问题的正确方法不同，Groovy让您编写自己的自定义元注释处理器（接下来介绍），并让您编写自己喜欢的AST转换中的任何检查逻辑-这是常见的目标进行汇总。话虽如此，只需设置<code>mode</code> ，您可以在任何额外的编码内自动为您处理许多普遍预期的情况。的行为<code>mode</code>参数由<code>AnnotationCollectorMode</code>选择的枚举值，并在下表中进行了汇总。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">模式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">重复</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释集合中的注释将始终被插入。运行完所有转换后，如果存在多个注释（不包括具有SOURCE保留的注释），将是一个错误。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_COLLECTOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自收集器的注释将被添加，所有具有相同名称的现有注释将被删除。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_COLLECTOR_MERGED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自收集器的注释将被添加，任何具有相同名称的现有注释将被删除，但是在现有注释中找到的任何新参数将被合并到添加的注释中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_EXPLICIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果找到任何现有的具有相同名称的注释，则将忽略来自收集器的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PREFER_EXPLICIT_MERGED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果找到任何具有相同名称的现有注释，但是收集器注释上的任何新参数都将添加到现有注释中，则将忽略来自收集器的注释。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect6">
<h7 id="meta-ann-processor"><a class="anchor" href="#meta-ann-processor"></a>自定义注释处理器</h7>
<div class="paragraph">
<p>自定义注释处理器将让您选择如何将元注释扩展为收集的注释。在这种情况下，元注释的行为完全取决于您。为此，您必须：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个元注释处理器，扩展<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/AnnotationCollectorTransform.html">AnnotationCollectorTransform</a></p>
</li>
<li>
<p>声明要在元注释声明中使用的处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了说明这一点，我们将探索元注释<code>@CompileDynamic</code>被实施。</p>
</div>
<div class="paragraph">
<p><code>@CompileDynamic</code>是一个扩展为<code>@CompileStatic(TypeCheckingMode.SKIP)</code> 。问题是默认的元注释处理器不支持枚举和注释值<code>TypeCheckingMode.SKIP</code>是一个。</p>
</div>
<div class="paragraph">
<p>天真的实现在这里行不通：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic(TypeCheckingMode.SKIP)
@AnnotationCollector
public @interface CompileDynamic {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，我们将如下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AnnotationCollector(processor = "org.codehaus.groovy.transform.CompileDynamicProcessor")
public @interface CompileDynamic {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会注意到的第一件事是我们的界面不再带有注释<code>@CompileStatic</code> 。原因是我们依靠<code>processor</code>参数，而是引用一个将<strong>生成</strong>注释的类。</p>
</div>
<div class="paragraph">
<p>这是定制处理器的实现方式：</p>
</div>
<div class="listingblock">
<div class="title">CompileDynamicProcessor.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
class CompileDynamicProcessor extends AnnotationCollectorTransform {            <i class="conum" data-value="2"></i><b>(2)</b>
    private static final ClassNode CS_NODE = ClassHelper.make(CompileStatic)    <i class="conum" data-value="3"></i><b>(3)</b>
    private static final ClassNode TC_NODE = ClassHelper.make(TypeCheckingMode) <i class="conum" data-value="4"></i><b>(4)</b>

    List<AnnotationNode> visit(AnnotationNode collector,                        <i class="conum" data-value="5"></i><b>(5)</b>
                               AnnotationNode aliasAnnotationUsage,             <i class="conum" data-value="6"></i><b>(6)</b>
                               AnnotatedNode aliasAnnotated,                    <i class="conum" data-value="7"></i><b>(7)</b>
                               SourceUnit source) {                             <i class="conum" data-value="8"></i><b>(8)</b>
        def node = new AnnotationNode(CS_NODE)                                  <i class="conum" data-value="9"></i><b>(9)</b>
        def enumRef = new PropertyExpression(
            new ClassExpression(TC_NODE), "SKIP")                               <i class="conum" data-value="10"></i><b>(10)</b>
        node.addMember("value", enumRef)                                        <i class="conum" data-value="11"></i><b>(11)</b>
        Collections.singletonList(node)                                         <i class="conum" data-value="12"></i><b>(12)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们的定制处理器是用Groovy编写的，为了获得更好的编译性能，我们使用静态编译</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>自定义处理器必须扩展<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/AnnotationCollectorTransform.html">AnnotationCollectorTransform</a></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个代表<code>@CompileStatic</code>注释类型</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>创建一个代表<code>TypeCheckingMode</code>枚举类型</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>collector</code>是个<code>@AnnotationCollector</code>在元注释中找到的节点。通常不使用。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>aliasAnnotationUsage</code>是扩展的元注释，在这里<code>@CompileDynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td><code>aliasAnnotated</code>是使用元注释进行注释的节点</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td><code>sourceUnit</code>是个<code>SourceUnit</code>正在编译</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>我们为创建一个新的注释节点<code>@CompileStatic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>我们创建一个等价于<code>TypeCheckingMode.SKIP</code></td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i> <b>11</b></td>
<td>我们将该表达式添加到注释节点，现在<code>@CompileStatic(TypeCheckingMode.SKIP)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i> <b>12</b></td>
<td>返回生成的注释</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在示例中， <code>visit</code>方法是唯一必须重写的方法。它的目的是返回注释节点列表，该列表将添加到使用元注释进行注释的节点上。在此示例中，我们返回一个对应于<code>@CompileStatic(TypeCheckingMode.SKIP)</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_inheritance"><a class="anchor" href="#_inheritance"></a>遗产</h5>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
<div class="sect4">
<h5 id="generics"><a class="anchor" href="#generics"></a>泛型</h5>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_traits"><a class="anchor" href="#_traits"></a> 1.4.2。特质</h4>
<div class="paragraph">
<p>特质是该语言的结构结构，它可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>行为组成</p>
</li>
<li>
<p>接口的运行时实现</p>
</li>
<li>
<p>行为重载</p>
</li>
<li>
<p>与静态类型检查/编译的兼容性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以将它们视为既包含<strong>默认实现</strong>又包含<strong>state的</strong> <strong>接口</strong> 。使用<code>trait</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特质声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征内方法的声明</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后就可以像普通界面一样使用<code>implements</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bird implements FlyingAbility {}          <i class="conum" data-value="1"></i><b>(1)</b>
def b = new Bird()                              <i class="conum" data-value="2"></i><b>(2)</b>
assert b.fly() == "I'm flying!"                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加特质<code>FlyingAbility</code>到<code>Bird</code>班级能力</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>实例化一个新的<code>Bird</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>Bird</code>类自动获取<code>FlyingAbility</code>特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从本构图到测试，这些特性具有广泛的功能，本节对此进行了详细介绍。</p>
</div>
<div class="sect4">
<h5 id="_methods_3"><a class="anchor" href="#_methods_3"></a>方法</h5>
<div class="sect5">
<h6 id="_public_methods"><a class="anchor" href="#_public_methods"></a>公开方法</h6>
<div class="paragraph">
<p>可以使用trait中的任何常规方法来声明特征中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特质声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征内方法的声明</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_abstract_methods"><a class="anchor" href="#_abstract_methods"></a>抽象方法</h6>
<div class="paragraph">
<p>另外，特征也可以声明<em>抽象</em>方法，因此需要在实现特征的类中实现<em>抽象</em>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greetable {
    abstract String name()                              <i class="conum" data-value="1"></i><b>(1)</b>
    String greeting() { "Hello, ${name()}!" }           <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>实现类将必须声明<code>name</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以与具体方法混合</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后可以使用如下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person implements Greetable {                     <i class="conum" data-value="1"></i><b>(1)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>实施特质<code>Greetable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>以来<code>name</code>是抽象的，需要实现它</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后<code>greeting</code>可以叫</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_private_methods"><a class="anchor" href="#_private_methods"></a>私人方法</h6>
<div class="paragraph">
<p>特性还可以定义私有方法。这些方法将不会出现在特征合同界面中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    private String greetingMessage() {                      <i class="conum" data-value="1"></i><b>(1)</b>
        'Hello from a private method!'
    }
    String greet() {
        def m = greetingMessage()                           <i class="conum" data-value="2"></i><b>(2)</b>
        println m
        m
    }
}
class GreetingMachine implements Greeter {}                 <i class="conum" data-value="3"></i><b>(3)</b>
def g = new GreetingMachine()
assert g.greet() == "Hello from a private method!"          <i class="conum" data-value="4"></i><b>(4)</b>
try {
    assert g.greetingMessage()                              <i class="conum" data-value="5"></i><b>(5)</b>
} catch (MissingMethodException e) {
    println "greetingMessage is private in trait"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个私有方法<code>greetingMessage</code>特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>公众<code>greet</code>留言电话<code>greetingMessage</code>默认</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个实现特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>greet</code>可以叫</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但不是<code>greetingMessage</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">仅支持性状<code>public</code>和<code>private</code>方法。都没有<code>protected</code>也不<code>package private</code>支持范围。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_final_methods"><a class="anchor" href="#_final_methods"></a>最终方法</h6>
<div class="paragraph">
<p>如果我们有一个实现特征的类，则从概念上讲，特征方法的实现将“继承”到该类中。但是，实际上，没有包含此类实现的基类。而是将它们直接编织到班级中。方法上的最终修饰符仅表示织造方法的修饰符。尽管用相同的签名但混合了最终变量和非最终变量来继承和重写或乘以继承方法可能被认为是不好的样式，但是Groovy并不禁止这种情况。将应用常规方法选择，并且所使用的修饰符将从结果方法中确定。如果您想要无法覆盖的特征实现方法，则可以考虑创建一个实现所需特征的基类。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_the_meaning_of_this"><a class="anchor" href="#_the_meaning_of_this"></a>这个的意思</h5>
<div class="paragraph">
<p><code>this</code>表示实现实例。将特征视为超类。这意味着当您编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Introspector {
    def whoAmI() { this }
}
class Foo implements Introspector {}
def foo = new Foo()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后致电：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">foo.whoAmI()</code></pre>
</div>
</div>
<div class="paragraph">
<p>将返回相同的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert foo.whoAmI().is(foo)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_interfaces"><a class="anchor" href="#_interfaces"></a>介面</h5>
<div class="paragraph">
<p>特性可以实现接口，在这种情况下，可以使用<code>implements</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Named {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    String name()
}
trait Greetable implements Named {                      <i class="conum" data-value="2"></i><b>(2)</b>
    String greeting() { "Hello, ${name()}!" }
}
class Person implements Greetable {                     <i class="conum" data-value="3"></i><b>(3)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="4"></i><b>(4)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="5"></i><b>(5)</b>
assert p instanceof Named                               <i class="conum" data-value="6"></i><b>(6)</b>
assert p instanceof Greetable                           <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>普通接口的声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>加<code>Named</code>到已实现接口的列表</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明一个实现<code>Greetable</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>实现失踪<code>name</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的<code>greeting</code>实现来自特质</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>确保<code>Person</code>实现<code>Named</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>确保<code>Person</code>实现<code>Greetable</code>特征</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_properties"><a class="anchor" href="#_properties"></a>性质</h5>
<div class="paragraph">
<p>特征可以定义属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                             <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person(name: 'Bob')             <i class="conum" data-value="3"></i><b>(3)</b>
assert p.name == 'Bob'                      <i class="conum" data-value="4"></i><b>(4)</b>
assert p.getName() == 'Bob'                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>申报财产<code>name</code>内在特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明一个实现特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>该属性自动显示</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>可以使用常规属性访问器进行访问</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>或使用常规的getter语法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_fields"><a class="anchor" href="#_fields"></a>领域</h5>
<div class="sect5">
<h6 id="_private_fields"><a class="anchor" href="#_private_fields"></a>私人领域</h6>
<div class="paragraph">
<p>由于特征允许使用私有方法，因此使用私有字段存储状态也可能很有趣。特性将使您做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counter {
    private int count = 0                   <i class="conum" data-value="1"></i><b>(1)</b>
    int count() { count += 1; count }       <i class="conum" data-value="2"></i><b>(2)</b>
}
class Foo implements Counter {}             <i class="conum" data-value="3"></i><b>(3)</b>
def f = new Foo()
assert f.count() == 1                       <i class="conum" data-value="4"></i><b>(4)</b>
assert f.count() == 2</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一个私有领域<code>count</code>内在特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明一个公共方法<code>count</code>递增计数器并返回它</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明一个实现<code>Counter</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>count</code>方法可以使用私有字段来保持状态</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这是与<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Java 8虚拟扩展方法</a>的主要区别。尽管虚拟扩展方法不携带状态，但特征可以携带。而且，从Java 6开始就支持Groovy中的特征，因为它们的实现不依赖于虚拟扩展方法。这意味着，即使可以从Java类中将特征视为常规接口，该接口也将<strong>没有</strong>默认方法，而只有抽象方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_public_fields"><a class="anchor" href="#_public_fields"></a>公共领域</h6>
<div class="paragraph">
<p>公共字段的工作方式与私有字段相同，但是为了避免<a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">菱形问题</a> ，在实现类中将字段名称重新映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    public String name                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person()                        <i class="conum" data-value="3"></i><b>(3)</b>
p.Named__name = 'Bob'                       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在特征内声明一个公共<strong>领域</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明实现该特征的类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建该类的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>公共字段可用，但已重命名</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>字段的名称取决于特征的完全限定名称。所有点（ <code>.</code>包中的）替换为下划线（ <code>_</code> ），并且最终名称包含双下划线。因此，如果字段的类型是<code>String</code> ，包装名称为<code>my.package</code> ，特征的名称是<code>Foo</code>并且该字段的名称是<code>bar</code> ，在实施类中，公共字段将显示为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String my_package_Foo__bar</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">虽然特质支持公共领域，但不建议使用它们，这被认为是不好的做法。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_composition_of_behaviors"><a class="anchor" href="#_composition_of_behaviors"></a>行为组成</h5>
<div class="paragraph">
<p>特性可以用于以受控方式实现多重继承。例如，我们可以具有以下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}
trait SpeakingAbility {
    String speak() { "I'm speaking!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个实现了这两个特征的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {} <i class="conum" data-value="1"></i><b>(1)</b>

def d = new Duck()                                      <i class="conum" data-value="2"></i><b>(2)</b>
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.speak() == "I'm speaking!"                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Duck</code>该类同时实现<code>FlyingAbility</code>和<code>SpeakingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个新的实例<code>Duck</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以调用该方法<code>fly</code>从<code>FlyingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>还有方法<code>speak</code>从<code>SpeakingAbility</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>特性鼓励在对象之间重用功能，并通过现有行为的组合来创建新的类。</p>
</div>
</div>
<div class="sect4">
<h5 id="_overriding_default_methods"><a class="anchor" href="#_overriding_default_methods"></a>覆盖默认方法</h5>
<div class="paragraph">
<p>特性提供方法的默认实现，但可以在实现类中覆盖它们。例如，我们可以稍微改变一下上面的例子，通过鸭子来嘎嘎叫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {
    String quack() { "Quack!" }                         <i class="conum" data-value="1"></i><b>(1)</b>
    String speak() { quack() }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def d = new Duck()
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.quack() == "Quack!"                            <i class="conum" data-value="4"></i><b>(4)</b>
assert d.speak() == "Quack!"                            <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义特定于<code>Duck</code> ，命名<code>quack</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>覆盖默认的实现<code>speak</code>这样我们使用<code>quack</code>代替</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>鸭子仍在飞行，从默认实现</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>quack</code>来自<code>Duck</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>speak</code>不再使用来自的默认实现<code>SpeakingAbility</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_extending_traits"><a class="anchor" href="#_extending_traits"></a>扩展特征</h5>
<div class="sect5">
<h6 id="_simple_inheritance"><a class="anchor" href="#_simple_inheritance"></a>简单继承</h6>
<div class="paragraph">
<p>性状可能会扩展另一个特征，在这种情况下，您必须使用<code>extends</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                                     <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Polite extends Named {                        <i class="conum" data-value="2"></i><b>(2)</b>
    String introduce() { "Hello, I am $name" }      <i class="conum" data-value="3"></i><b>(3)</b>
}
class Person implements Polite {}
def p = new Person(name: 'Alice')                   <i class="conum" data-value="4"></i><b>(4)</b>
assert p.introduce() == 'Hello, I am Alice'         <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Named</code>特质定义一个<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Polite</code>特质<strong>扩展</strong>了<code>Named</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Polite</code>添加了可以访问<code>name</code>超特性的性质</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>name</code>该属性从<code>Person</code>课堂实施<code>Polite</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>就像<code>introduce</code>方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_multiple_inheritance"><a class="anchor" href="#_multiple_inheritance"></a>多重继承</h6>
<div class="paragraph">
<p>或者，一个特征可以扩展多个特征。在这种情况下，必须在<code>implements</code>条款：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait WithId {                                      <i class="conum" data-value="1"></i><b>(1)</b>
    Long id
}
trait WithName {                                    <i class="conum" data-value="2"></i><b>(2)</b>
    String name
}
trait Identified implements WithId, WithName {}     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>WithId</code>特质定义了<code>id</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>WithName</code>特质定义了<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Identified</code>是一个既继承了<code>WithId</code>和<code>WithName</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_duck_typing_and_traits"><a class="anchor" href="#_duck_typing_and_traits"></a>鸭的打字和特征</h5>
<div class="sect5">
<h6 id="_dynamic_code"><a class="anchor" href="#_dynamic_code"></a>动态代码</h6>
<div class="paragraph">
<p>特性可以调用任何动态代码，例如普通的Groovy类。这意味着您可以在方法的主体中调用应该在实现类中存在的方法，而不必在接口中显式声明它们。这意味着特质与鸭子类型完全兼容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SpeakingDuck {
    String speak() { quack() }                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Duck implements SpeakingDuck {
    String methodMissing(String name, args) {
        "${name.capitalize()}!"                     <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
def d = new Duck()
assert d.speak() == 'Quack!'                        <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>SpeakingDuck</code>期望<code>quack</code>要定义的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Duck</code>类确实使用<em>methodMissing</em>实现方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>称呼<code>speak</code>方法触发对<code>quack</code>由处理<code>methodMissing</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_dynamic_methods_in_a_trait"><a class="anchor" href="#_dynamic_methods_in_a_trait"></a>特征中的动态方法</h6>
<div class="paragraph">
<p>特征也可以实现MOP方法，例如<code>methodMissing</code>要么<code>propertyMissing</code> ，在这种情况下，实现类将从trait继承行为，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DynamicObject {                               <i class="conum" data-value="1"></i><b>(1)</b>
    private Map props = [:]
    def methodMissing(String name, args) {
        name.toUpperCase()
    }
    def propertyMissing(String prop) {
        props[prop]
    }
    void setProperty(String prop, Object value) {
        props[prop] = value
    }
}

class Dynamic implements DynamicObject {
    String existingProperty = 'ok'                  <i class="conum" data-value="2"></i><b>(2)</b>
    String existingMethod() { 'ok' }                <i class="conum" data-value="3"></i><b>(3)</b>
}
def d = new Dynamic()
assert d.existingProperty == 'ok'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert d.foo == null                                <i class="conum" data-value="5"></i><b>(5)</b>
d.foo = 'bar'                                       <i class="conum" data-value="6"></i><b>(6)</b>
assert d.foo == 'bar'                               <i class="conum" data-value="7"></i><b>(7)</b>
assert d.existingMethod() == 'ok'                   <i class="conum" data-value="8"></i><b>(8)</b>
assert d.someMethod() == 'SOMEMETHOD'               <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建实现几种MOP方法的特征</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Dynamic</code>类定义一个属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>Dynamic</code>类定义方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>调用现有属性将从中调用方法<code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>调用不存在的属性会从特征中调用方法</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>将会通知<code>setProperty</code>在特质上定义</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>将会通知<code>getProperty</code>在特质上定义</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>调用现有方法<code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>但由于特质而调用了不存在的方法<code>methodMissing</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_multiple_inheritance_conflicts"><a class="anchor" href="#_multiple_inheritance_conflicts"></a>多重继承冲突</h5>
<div class="sect5">
<h6 id="_default_conflict_resolution"><a class="anchor" href="#_default_conflict_resolution"></a>默认冲突解决</h6>
<div class="paragraph">
<p>一个类可以实现多个特征。如果某个特征定义的方法与另一个特征中的方法具有相同的签名，则我们将发生冲突：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A {
    String exec() { 'A' }               <i class="conum" data-value="1"></i><b>(1)</b>
}
trait B {
    String exec() { 'B' }               <i class="conum" data-value="2"></i><b>(2)</b>
}
class C implements A,B {}               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特征<code>A</code>定义一个名为<code>exec</code>返回一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征<code>B</code>定义完全相同的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类<code>C</code>实现两个特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下，默认行为是： <strong>最后一个声明的特征</strong>中的方法<code>implements</code>条款胜出。这里， <code>B</code>在之后声明<code>A</code>所以从<code>B</code>将被收取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def c = new C()
assert c.exec() == 'B'</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_user_conflict_resolution"><a class="anchor" href="#_user_conflict_resolution"></a>解决用户冲突</h6>
<div class="paragraph">
<p>如果此行为不是您想要的行为，则可以使用<code>Trait.super.foo</code>句法。在上面的示例中，我们可以通过编写以下代码来确保调用特征A中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class C implements A,B {
    String exec() { A.super.exec() }    <i class="conum" data-value="1"></i><b>(1)</b>
}
def c = new C()
assert c.exec() == 'A'                  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确要求<code>exec</code>从特质<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>从调用版本<code>A</code>而不是使用默认分辨率，这将是<code>B</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_implementation_of_traits"><a class="anchor" href="#_runtime_implementation_of_traits"></a>特征的运行时实现</h5>
<div class="sect5">
<h6 id="_implementing_a_trait_at_runtime"><a class="anchor" href="#_implementing_a_trait_at_runtime"></a>在运行时实现特征</h6>
<div class="paragraph">
<p>Groovy还支持在运行时动态地实现特征。它允许您使用特征“装饰”现有对象。作为示例，让我们从此特征和以下类开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Extra {
    String extra() { "I'm an extra method" }            <i class="conum" data-value="1"></i><b>(1)</b>
}
class Something {                                       <i class="conum" data-value="2"></i><b>(2)</b>
    String doSomething() { 'Something' }                <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Extra</code>特质定义了<code>extra</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Something</code>类<strong>未</strong>实现<code>Extra</code>特征</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>Something</code>只定义一个方法<code>doSomething</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，如果这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something()
s.extra()</code></pre>
</div>
</div>
<div class="paragraph">
<p>额外通话将失败，因为<code>Something</code>没有实施<code>Extra</code> 。可以使用以下语法在运行时执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something() as Extra                        <i class="conum" data-value="1"></i><b>(1)</b>
s.extra()                                               <i class="conum" data-value="2"></i><b>(2)</b>
s.doSomething()                                         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><strong>在运行时</strong>使用<strong>as</strong>关键字将对象强制为特征</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后<code>extra</code>可以在对象上调用</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>和<code>doSomething</code>仍然可以通话</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">将对象强制为特征时，操作的结果不是同一实例。可以保证强制对象将同时实现原始对象实现的特征<strong>和</strong>接口，但结果将<strong>不是</strong>原始类的实例。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_implementing_multiple_traits_at_once"><a class="anchor" href="#_implementing_multiple_traits_at_once"></a>一次实现多个特征</h6>
<div class="paragraph">
<p>如果您需要一次实现多个特征，则可以使用<code>withTraits</code>方法而不是<code>as</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A { void methodFromA() {} }
trait B { void methodFromB() {} }

class C {}

def c = new C()
c.methodFromA()                     <i class="conum" data-value="1"></i><b>(1)</b>
c.methodFromB()                     <i class="conum" data-value="2"></i><b>(2)</b>
def d = c.withTraits A, B           <i class="conum" data-value="3"></i><b>(3)</b>
d.methodFromA()                     <i class="conum" data-value="4"></i><b>(4)</b>
d.methodFromB()                     <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>拨电至<code>methodFromA</code>将会失败，因为<code>C</code>没有实现<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>拨电至<code>methodFromB</code>将会失败，因为<code>C</code>没有实现<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>withTrait</code>将包裹<code>c</code>变成可以实现的东西<code>A</code>和<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>methodFromA</code>现在将通过，因为<code>d</code>贯彻<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>methodFromB</code>现在将通过，因为<code>d</code>也实现<code>B</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">将一个对象强制为多个特征时，操作的结果不是同一实例。可以保证强制对象将同时实现原始对象所实现的特征<strong>和</strong>接口，但是结果将<strong>不是</strong>原始类的实例。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_chaining_behavior"><a class="anchor" href="#_chaining_behavior"></a>链接行为</h5>
<div class="paragraph">
<p>Groovy支持<em>可堆叠特征</em>的概念。如果当前特征无法处理消息，则想法是将一个特征委托给另一个特征。为了说明这一点，让我们想象一个消息处理程序接口，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface MessageHandler {
    void on(String message, Map payload)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以通过应用小的行为来组成消息处理程序。例如，让我们以特征形式定义默认处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DefaultHandler implements MessageHandler {
    void on(String message, Map payload) {
        println "Received $message with payload $payload"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，任何类都可以通过实现trait来继承默认处理程序的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandler implements DefaultHandler {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果要记录除默认处理程序之外的所有消息，该怎么办？一种选择是编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandlerWithLogging implements DefaultHandler {
    void on(String message, Map payload) {                                  <i class="conum" data-value="1"></i><b>(1)</b>
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        DefaultHandler.super.on(message, payload)                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>明确实施<code>on</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>执行记录</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通过委派给<code>DefaultHandler</code>特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这可行，但是这种方法有缺点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>日志记录逻辑绑定到“具体”处理程序</p>
</li>
<li>
<p>我们有一个明确的参考<code>DefaultHandler</code>在里面<code>on</code>方法，这意味着如果我们碰巧更改了类实现的特征，则代码将被破坏</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>作为替代，我们可以编写另一个特征，即仅限于日志记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait LoggingHandler implements MessageHandler {                            <i class="conum" data-value="1"></i><b>(1)</b>
    void on(String message, Map payload) {
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        super.on(message, payload)                                          <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>日志处理程序本身就是一个处理程序</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打印收到的消息</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后<code>super</code>使其将调用委托给链中的下一个特征</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后我们的班级可以这样重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class HandlerWithLogger implements DefaultHandler, LoggingHandler {}
def loggingHandler = new HandlerWithLogger()
loggingHandler.on('test logging', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing test logging with payload [:]
Received test logging with payload [:]</pre>
</div>
</div>
<div class="paragraph">
<p>正如优先规则所暗示的那样<code>LoggerHandler</code>获胜，因为它被声明为最后一个，然后调用<code>on</code>将使用来自<code>LoggingHandler</code> 。但后者呼吁<code>super</code> ，这意味着链中的下一个特征。在这里，下一个特征是<code>DefaultHandler</code>所以<strong>两者都</strong>将被称为：</p>
</div>
<div class="paragraph">
<p>如果我们添加第三个处理程序，该处理程序负责处理以<code>say</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SayHandler implements MessageHandler {
    void on(String message, Map payload) {
        if (message.startsWith("say")) {                                    <i class="conum" data-value="1"></i><b>(1)</b>
            println "I say ${message - 'say'}!"
        } else {
            super.on(message, payload)                                      <i class="conum" data-value="2"></i><b>(2)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>处理程序特定的前提</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果不满足前提条件，则将消息传递给链中的下一个处理程序</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后我们的最终处理程序如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Handler implements DefaultHandler, SayHandler, LoggingHandler {}
def h = new Handler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>意思是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消息将首先通过日志记录处理程序</p>
</li>
<li>
<p>日志处理程序调用<code>super</code>它将委派给下一个处理程序，即<code>SayHandler</code></p>
</li>
<li>
<p>如果消息以<code>say</code> ，然后处理程序将使用消息</p>
</li>
<li>
<p>如果没有， <code>say</code>处理程序委托给链中的下一个处理程序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种方法非常强大，因为它允许您编写彼此不认识的处理程序，但仍可以按所需顺序将它们组合在一起。例如，如果我们执行代码，它将打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
Seeing sayHello with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果我们将日志记录处理程序移动到链中的第二个处理程序，则输出将不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AlternateHandler implements DefaultHandler, LoggingHandler, SayHandler {}
h = new AlternateHandler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>印刷品：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>原因是现在，因为<code>SayHandler</code>无需呼叫即可使用消息<code>super</code> ，不再调用日志记录处理程序。</p>
</div>
<div class="sect5">
<h6 id="_semantics_of_super_inside_a_trait"><a class="anchor" href="#_semantics_of_super_inside_a_trait"></a>特征特质的超语义</h6>
<div class="paragraph">
<p>如果一个类实现了多个特征并调用了不合格<code>super</code>找到，然后：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果该类实现了另一个特征，则调用将委托给链中的下一个特征</p>
</li>
<li>
<p>如果连锁店没有任何特征， <code>super</code>指实现类的超类（ <em>this</em> ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如，由于以下行为，可以修饰最终类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Filtering {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    StringBuilder append(String str) {                  <i class="conum" data-value="2"></i><b>(2)</b>
        def subst = str.replace('o','')                 <i class="conum" data-value="3"></i><b>(3)</b>
        super.append(subst)                             <i class="conum" data-value="4"></i><b>(4)</b>
    }
    String toString() { super.toString() }              <i class="conum" data-value="5"></i><b>(5)</b>
}
def sb = new StringBuilder().withTraits Filtering       <i class="conum" data-value="6"></i><b>(6)</b>
sb.append('Groovy')
assert sb.toString() == 'Grvy'                          <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个名为<code>Filtering</code> ，应该应用于<code>StringBuilder</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>重新定义<code>append</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>从字符串中删除所有“ o”</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后委托给<code>super</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>如果<code>toString</code>被称为，委托给<code>super.toString</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>的运行时实现<code>Filtering</code>特质<code>StringBuilder</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>附加的字符串不再包含字母<code>o</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这个例子中，当<code>super.append</code>遇到时，目标对象没有实现其他任何特征，因此被称为原始方法<code>append</code>方法，也就是说从<code>StringBuilder</code> 。相同的技巧用于<code>toString</code> ，以便所生成的代理对象的字符串表示形式委托给<code>toString</code>的<code>StringBuilder</code>实例。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_advanced_features"><a class="anchor" href="#_advanced_features"></a>高级功能</h5>
<div class="sect5">
<h6 id="_sam_type_coercion"><a class="anchor" href="#_sam_type_coercion"></a> SAM型强制</h6>
<div class="paragraph">
<p>如果一个特征定义了一个抽象方法，则它是SAM（单一抽象方法）类型强制的候选者。例如，想象一下以下特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    String greet() { "Hello $name" }        <i class="conum" data-value="1"></i><b>(1)</b>
    abstract String getName()               <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>greet</code>方法不是抽象的，而是调用抽象方法<code>getName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>getName</code>是一种抽象方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以来<code>getName</code>是在所述<em>单个抽象方法</em> <code>Greeter</code>特质，你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Greeter greeter = { 'Alice' }               <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>关闭“成为”实施<code>getName</code>单一抽象方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>甚至：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void greet(Greeter g) { println g.greet() } <i class="conum" data-value="1"></i><b>(1)</b>
greet { 'Alice' }                           <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>greet方法接受SAM类型Greeter作为参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以直接用闭包调用它</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_differences_with_java_8_default_methods"><a class="anchor" href="#_differences_with_java_8_default_methods"></a> Java 8默认方法的差异</h6>
<div class="paragraph">
<p>在Java 8中，接口可以具有方法的默认实现。如果一个类实现一个接口并且不提供默认方法的实现，则从该接口中选择实现。特性的行为相同，但有一个主要区别：如果类在其接口列表中声明了该特性， <strong>并且</strong> <strong>即使</strong>超类也没有提供实现，则<strong>始终</strong>使用trait的实现。</p>
</div>
<div class="paragraph">
<p>如果您想覆盖已经实现的方法的行为，可以使用此功能以非常精确的方式来构成行为。</p>
</div>
<div class="paragraph">
<p>为了说明这个概念，让我们从一个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.CompileStatic
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

class SomeTest extends GroovyTestCase {
    def config
    def shell

    void setup() {
        config = new CompilerConfiguration()
        shell = new GroovyShell(config)
    }
    void testSomething() {
        assert shell.evaluate('1+1') == 2
    }
    void otherTest() { /* ... */ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们创建一个简单的测试用例，该用例使用两个属性（ <em>config</em>和<em>shell</em> ），并在多种测试方法中使用它们。现在，假设您要进行相同的测试，但是要使用另一种不同的编译器配置。一种选择是创建一个子类<code>SomeTest</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以工作，但是如果您实际上有多个测试类，并且想要为所有这些测试类测试新配置怎么办？然后，您将必须为每个测试类创建一个不同的子类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class YetAnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您会看到<code>setup</code>两种测试的方法是相同的。然后，该想法是创建一个特征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait MyTestSupport {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( new ASTTransformationCustomizer(CompileStatic) )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在子类中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest implements MyTestSupport {}
class YetAnotherTest extends SomeTest2 implements MyTestSupport {}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使我们能够大大减少样板代码，并减少在我们决定更改设置代码时忘记更改设置代码的风险。即使<code>setup</code>已在超级类中实现，因为测试类在其接口列表中声明了特征，所以该行为将从特征实现中借用！</p>
</div>
<div class="paragraph">
<p>当您无法访问超类源代码时，此功能特别有用。它可用于模拟方法或在子类中强制方法的特定实现。它使您可以重构代码，以将重写的逻辑保留为单个特征，并仅通过实现它即可继承新行为。当然，另一种选择是在将要使用新代码的<strong>每个</strong>位置覆盖该方法。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">值得注意的是，如果您使用运行时特征，则特征中的方法<strong>始终</strong>比被代理对象更优选：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name                                         <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Bob {
    String getName() { 'Bob' }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person(name: 'Alice')
assert p.name == 'Alice'                                <i class="conum" data-value="3"></i><b>(3)</b>
def p2 = p as Bob                                       <i class="conum" data-value="4"></i><b>(4)</b>
assert p2.name == 'Bob'                                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Person</code>类定义一个<code>name</code>属性导致<code>getName</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>Bob</code>是定义<code>getName</code>作为返回<code>Bob</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>默认对象将返回<em>Alice</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>p2</code>胁迫<code>p</code>进入<code>Bob</code>在运行时</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><code>getName</code>返回<em>鲍勃，</em>因为<code>getName</code>取自<strong>特质</strong></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">同样，不要忘记动态特质强制返回一个唯一的对象，该对象仅实现原始接口以及特质。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_differences_with_mixins"><a class="anchor" href="#_differences_with_mixins"></a> mixins的差异</h5>
<div class="paragraph">
<p>Mixin在概念上存在一些差异，因为Groovy中提供了它们。请注意，我们在谈论的是运行时混入，而不是@Mixin注释，后者已不赞成使用traits。</p>
</div>
<div class="paragraph">
<p>首先，特征中定义的方法在字节码中可见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在内部，特征表示为一个接口（没有默认或静态方法）和几个帮助程序类</p>
</li>
<li>
<p>这意味着实现特征的对象可以有效地实现<em>接口</em></p>
</li>
<li>
<p>这些方法从Java可见</p>
</li>
<li>
<p>它们与类型检查和静态编译兼容</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>相反，通过mixin添加的方法仅在运行时可见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A { String methodFromA() { 'A' } }        <i class="conum" data-value="1"></i><b>(1)</b>
class B { String methodFromB() { 'B' } }        <i class="conum" data-value="2"></i><b>(2)</b>
A.metaClass.mixin B                             <i class="conum" data-value="3"></i><b>(3)</b>
def o = new A()
assert o.methodFromA() == 'A'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert o.methodFromB() == 'B'                   <i class="conum" data-value="5"></i><b>(5)</b>
assert o instanceof A                           <i class="conum" data-value="6"></i><b>(6)</b>
assert !(o instanceof B)                        <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>A</code>定义<code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类<code>B</code>定义<code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>混合B到A</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>我们可以打电话<code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>我们也可以打电话<code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>该对象是的实例<code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>但这<strong>不是</strong>实例<code>B</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后一点实际上是非常重要的，它说明了混合环境优于特征的地方： <strong>不</strong>修改实例，因此，如果将某个类别混入另一个类别，则不会生成第三类，并且方法会响应A即使混入，也会继续响应A。</p>
</div>
</div>
<div class="sect4">
<h5 id="_static_methods_properties_and_fields"><a class="anchor" href="#_static_methods_properties_and_fields"></a>静态方法，属性和字段</h5>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">以下说明请注意。静态成员支持正在进行中，仍处于试验阶段。以下信息仅对2.5.8有效。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在特征中定义静态方法，但这有很多限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有静态方法的特性不能静态编译或进行类型检查。动态地访问所有静态方法，属性和字段（这是JVM的限制）。</p>
</li>
<li>
<p>静态方法不会出现在每个特征的生成接口中。</p>
</li>
<li>
<p>特质被解释为实现类的<em>模板</em> ，这意味着每个实现类将获得自己的静态方法，属性和字段。因此，在特征上声明的静态成员不属于<code>Trait</code> ，但要实现类。</p>
</li>
<li>
<p>通常，您不应混合使用具有相同签名的静态方法和实例方法。适用特征的常规规则适用（包括多重继承冲突解决）。如果选择的方法是静态的，但是某些实现的特征具有实例变量，则将发生编译错误。如果选择的方法是实例变量，则将忽略静态变量（在这种情况下，其行为类似于Java接口中的静态方法）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait TestHelper {
    public static boolean CALLED = false        <i class="conum" data-value="1"></i><b>(1)</b>
    static void init() {                        <i class="conum" data-value="2"></i><b>(2)</b>
        CALLED = true                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}
class Foo implements TestHelper {}
Foo.init()                                      <i class="conum" data-value="4"></i><b>(4)</b>
assert Foo.TestHelper__CALLED                   <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>静态字段在特征中声明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>特征中也声明了一个静态方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>静态字段<em>在</em>特征中更新</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>静态方法<em>初始化</em>可供实现类使用</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td><em>重新映射</em>了静电场以避免钻石问题</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与往常一样，不建议使用公共字段。无论如何，如果您要这样做，必须了解以下代码将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Foo.CALLED = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为在特征本身上<em>没有</em>定义静态字段<em>CALLED</em> 。同样，如果您有两个不同的实现类，则每个类都有一个不同的静态字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bar implements TestHelper {}              <i class="conum" data-value="1"></i><b>(1)</b>
class Baz implements TestHelper {}              <i class="conum" data-value="2"></i><b>(2)</b>
Bar.init()                                      <i class="conum" data-value="3"></i><b>(3)</b>
assert Bar.TestHelper__CALLED                   <i class="conum" data-value="4"></i><b>(4)</b>
assert !Baz.TestHelper__CALLED                  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>Bar</code>实现特质</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>类<code>Baz</code>也实现了特质</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>init</code>仅被调用<code>Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>静态场<code>CALLED</code>上<code>Bar</code>已更新</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但是静态场<code>CALLED</code>上<code>Baz</code>不是，因为它<strong>与众不同</strong></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_inheritance_of_state_gotchas"><a class="anchor" href="#_inheritance_of_state_gotchas"></a>状态陷阱的继承</h5>
<div class="paragraph">
<p>我们已经看到，特质是有状态的。特征可以定义字段或属性，但是当类实现特征时，它将基于每个特征获取这些字段/属性。因此，请考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特质定义两个属性， <code>x</code>和<code>y</code> ， 以及ASA <code>sum</code>方法。现在让我们创建一个实现特征的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BaseElem implements IntCouple {
    int f() { sum() }
}
def base = new BaseElem()
assert base.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>通话结果<code>f</code>是<code>3</code> ，因为<code>f</code>代表参加<code>sum</code>在特质中，具有状态。但是，如果我们改写这个怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Elem implements IntCouple {
    int x = 3                                       <i class="conum" data-value="1"></i><b>(1)</b>
    int y = 4                                       <i class="conum" data-value="2"></i><b>(2)</b>
    int f() { sum() }                               <i class="conum" data-value="3"></i><b>(3)</b>
}
def elem = new Elem()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>覆盖属性<code>x</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>覆盖属性<code>y</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>呼叫<code>sum</code>从特质</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果你打电话<code>elem.f()</code> ， 什么是预期的输出？实际上是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert elem.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>原因是<code>sum</code>方法访问特征的<em>字段</em> 。所以它正在使用<code>x</code>和<code>y</code>特征中定义的值。如果要使用实现类中的值，则需要使用getter和setter取消引用字段，如最后一个示例中所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { getX()+getY() }
}

class Elem implements IntCouple {
    int x = 3
    int y = 4
    int f() { sum() }
}
def elem = new Elem()
assert elem.f() == 7</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_self_types"><a class="anchor" href="#_self_types"></a>自我类型</h5>
<div class="sect5">
<h6 id="_type_constraints_on_traits"><a class="anchor" href="#_type_constraints_on_traits"></a>特征的类型约束</h6>
<div class="paragraph">
<p>有时您会想编写只能应用于某种类型的特征。例如，您可能想要在扩展了您无法控制的另一个类的类上应用特征，并且仍然能够调用这些方法。为了说明这一点，让我们从以下示例开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CommunicationService {
    static void sendMessage(String from, String to, String message) {       <i class="conum" data-value="1"></i><b>(1)</b>
        println "$from sent [$message] to $to"
    }
}

class Device { String id }                                                  <i class="conum" data-value="2"></i><b>(2)</b>

trait Communicating {
    void sendMessage(Device to, String message) {
        CommunicationService.sendMessage(id, to.id, message)                <i class="conum" data-value="3"></i><b>(3)</b>
    }
}

class MyDevice extends Device implements Communicating {}                   <i class="conum" data-value="4"></i><b>(4)</b>

def bob = new MyDevice(id:'Bob')
def alice = new MyDevice(id:'Alice')
bob.sendMessage(alice,'secret')                                             <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一种<code>Service</code>类，超出您的控制范围（在库中，…）定义了一个<code>sendMessage</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一种<code>Device</code>类，超出您的控制范围（在图书馆中，...）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>为可以调用服务的设备定义通信特征</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>定义<code>MyDevice</code>作为通讯设备</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>从特征中调用方法，然后<code>id</code>解决了</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>很明显，在这里<code>Communicating</code>特质只能适用于<code>Device</code> 。但是，由于特质无法扩展类，因此没有明确的约定来表明这一点。但是，代码可以编译并运行得很好，因为<code>id</code>在trait方法中将动态解决。问题是没有什么可以阻止将特征应用于任何<strong>非</strong> <code>Device</code> 。任何具有<code>id</code>会工作，而任何没有<code>id</code>属性将导致运行时错误。</p>
</div>
<div class="paragraph">
<p>如果要启用类型检查或应用，则问题甚至更加复杂<code>@CompileStatic</code>关于特质：因为特质对自己是一个人一无所知<code>Device</code> ，类型检查器会抱怨说找不到<code>id</code>属性。</p>
</div>
<div class="paragraph">
<p>一种可能性是显式添加一个<code>getId</code>特征中的方法，但不能解决所有问题。如果方法需要怎么办<code>this</code>作为参数，实际上要求它是一个<code>Device</code> ？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SecurityService {
    static void check(Device d) { if (d.id==null) throw new SecurityException() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想打电话<code>this</code>在特征中，那么您将需要明确地投射<code>this</code>变成一个<code>Device</code> 。显式强制转换为<code>this</code>到处。</p>
</div>
</div>
<div class="sect5">
<h6 id="traits-selftype"><a class="anchor" href="#traits-selftype"></a> @SelfType批注</h6>
<div class="paragraph">
<p>为了使该合同明确，并使类型检查器知道其<em>自身</em>的<em>类型</em> ，Groovy提供了一个<code>@SelfType</code>注释将：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>让您声明实现此特征的类必须继承或实现的类型</p>
</li>
<li>
<p>如果不满足这些类型约束，则抛出编译时错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，在前面的示例中，我们可以使用<code>@groovy.transform.SelfType</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@SelfType(Device)
@CompileStatic
trait Communicating {
    void sendMessage(Device to, String message) {
        SecurityService.check(this)
        CommunicationService.sendMessage(id, to.id, message)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果您尝试在<strong>不是</strong>设备的类上实现此特征，则将发生编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyDevice implements Communicating {} // forgot to extend Device</code></pre>
</div>
</div>
<div class="paragraph">
<p>错误将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class 'MyDevice' implements trait 'Communicating' but does not extend self type class 'Device'</pre>
</div>
</div>
<div class="paragraph">
<p>总之，自我类型是一种声明对特征的约束的有效方法，而不必直接在特征中声明契约或不必在所有地方使用强制转换，从而将关注点分离保持应有的严格程度。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_limitations"><a class="anchor" href="#_limitations"></a>局限性</h5>
<div class="sect5">
<h6 id="_compatibility_with_ast_transformations"><a class="anchor" href="#_compatibility_with_ast_transformations"></a>与AST转换的兼容性</h6>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">性状与AST转换未正式兼容。其中一些，例如<code>@CompileStatic</code>将应用于特性本身（而不是实现类），而其他特性将同时应用于实现类和特性。绝对不能保证AST转换会像在常规类上一样在特征上运行，因此使用该风险自担！
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_prefix_and_postfix_operations"><a class="anchor" href="#_prefix_and_postfix_operations"></a>前缀和后缀操作</h6>
<div class="paragraph">
<p>在特征中，如果前缀和后缀操作更新了特征的字段，则不允许它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counting {
    int x
    void inc() {
        x++                             <i class="conum" data-value="1"></i><b>(1)</b>
    }
    void dec() {
        --x                             <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
class Counter implements Counting {}
def c = new Counter()
c.inc()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>x</code>在特征中定义，不允许后缀增量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>x</code>在特征中定义，不允许前缀减少</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>解决方法是使用<code>+=</code>运算符。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_closures"><a class="anchor" href="#_closures"></a> 1.5。关闭</h3>
<div class="paragraph">
<p>本章介绍Groovy闭包。Groovy中的闭包是开放的匿名代码块，可以接受参数，返回值并分配给变量。闭包可以引用在其周围范围内声明的变量。与正式的封闭定义相反， <code>Closure</code>在Groovy语言中，“语言”也可以包含在其周围范围之外定义的自由变量。在打破封闭的正式概念的同时，它提供了本章中介绍的各种优点。</p>
</div>
<div class="sect3">
<h4 id="_syntax_2"><a class="anchor" href="#_syntax_2"></a> 1.5.1。句法</h4>
<div class="sect4">
<h5 id="_defining_a_closure"><a class="anchor" href="#_defining_a_closure"></a>定义闭包</h5>
<div class="paragraph">
<p>闭包定义遵循以下语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">{ [closureParameters -> ] statements }</code></pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>[closureParameters->]</code>是一个可选的用逗号分隔的参数列表，并且语句为0或多个Groovy语句。这些参数看起来类似于方法参数列表，并且这些参数可以是键入的也可以是未键入的。</p>
</div>
<div class="paragraph">
<p>指定参数列表后， <code>-></code>字符是必需的，用于将参数与闭包主体分开。<em>语句</em>部分由0、1或许多Groovy语句组成。</p>
</div>
<div class="paragraph">
<p>有效的闭包定义的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">{ item++ }                                          <i class="conum" data-value="1"></i><b>(1)</b>

{ -> item++ }                                       <i class="conum" data-value="2"></i><b>(2)</b>

{ println it }                                      <i class="conum" data-value="3"></i><b>(3)</b>

{ it -> println it }                                <i class="conum" data-value="4"></i><b>(4)</b>

{ name -> println name }                            <i class="conum" data-value="5"></i><b>(5)</b>

{ String x, int y ->                                <i class="conum" data-value="6"></i><b>(6)</b>
    println "hey ${x} the value is ${y}"
}

{ reader ->                                         <i class="conum" data-value="7"></i><b>(7)</b>
    def line = reader.readLine()
    line.trim()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个闭包引用一个名为<code>item</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以通过添加箭头来将闭包参数与代码明确分开（ <code>-></code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用隐式参数的闭包（ <code>it</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>替代版本，其中<code>it</code>是一个明确的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>在这种情况下，通常最好为参数使用显式名称</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>一个接受两个类型化参数的闭包</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>一个闭包可以包含多个语句</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="closure-as-object"><a class="anchor" href="#closure-as-object"></a>封闭对象</h5>
<div class="paragraph">
<p>闭包是<code>groovy.lang.Closure</code>类，即使是代码块，也可以将其分配给变量或字段，就像其他任何变量一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def listener = { e -> println "Clicked on $e.source" }      <i class="conum" data-value="1"></i><b>(1)</b>
assert listener instanceof Closure
Closure callback = { println 'Done!' }                      <i class="conum" data-value="2"></i><b>(2)</b>
Closure<Boolean> isTextFile = {
    File it -> it.name.endsWith('.txt')                     <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>您可以将闭包分配给变量，并且它是的实例<code>groovy.lang.Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果不使用<code>def</code> ，您可以将闭包分配给类型为的变量<code>groovy.lang.Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>（可选）您可以使用的通用类型指定闭包的返回类型<code>groovy.lang.Closure</code></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_calling_a_closure"><a class="anchor" href="#_calling_a_closure"></a>调用关闭</h5>
<div class="paragraph">
<p>闭包作为一个匿名代码块，可以像其他任何方法一样调用。如果您定义一个不带参数的闭包，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def code = { 123 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，仅在<em>调用</em>闭包时才执行闭包内的代码，这可以通过使用变量来完成，就像使用常规方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert code() == 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，您也可以明确使用<code>call</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert code.call() == 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果闭包接受参数，则原理相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def isOdd = { int i -> i%2 != 0 }                           <i class="conum" data-value="1"></i><b>(1)</b>
assert isOdd(3) == true                                     <i class="conum" data-value="2"></i><b>(2)</b>
assert isOdd.call(2) == false                               <i class="conum" data-value="3"></i><b>(3)</b>

def isEven = { it%2 == 0 }                                  <i class="conum" data-value="4"></i><b>(4)</b>
assert isEven(3) == false                                   <i class="conum" data-value="5"></i><b>(5)</b>
assert isEven.call(2) == true                               <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个接受一个闭包<code>int</code>作为参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以直接调用</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>或使用<code>call</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>对于带有隐式参数的闭包也是如此（ <code>it</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>可以使用直接调用<code>(arg)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>或使用<code>call</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与方法不同，闭包在被调用时<strong>总是</strong>返回一个值。下一节讨论如何声明闭包参数，何时使用它们以及<a href="#implicit-it">隐式“ it”参数</a>是什么。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parameters"><a class="anchor" href="#_parameters"></a> 1.5.2。参量</h4>
<div class="sect4">
<h5 id="_normal_parameters"><a class="anchor" href="#_normal_parameters"></a>普通参数</h5>
<div class="paragraph">
<p>闭包的参数遵循与常规方法的参数相同的原则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可选类型</p>
</li>
<li>
<p>一个名字</p>
</li>
<li>
<p>可选的默认值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>参数之间用逗号分隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def closureWithOneArg = { str -> str.toUpperCase() }
assert closureWithOneArg('groovy') == 'GROOVY'

def closureWithOneArgAndExplicitType = { String str -> str.toUpperCase() }
assert closureWithOneArgAndExplicitType('groovy') == 'GROOVY'

def closureWithTwoArgs = { a,b -> a+b }
assert closureWithTwoArgs(1,2) == 3

def closureWithTwoArgsAndExplicitTypes = { int a, int b -> a+b }
assert closureWithTwoArgsAndExplicitTypes(1,2) == 3

def closureWithTwoArgsAndOptionalTypes = { a, int b -> a+b }
assert closureWithTwoArgsAndOptionalTypes(1,2) == 3

def closureWithTwoArgAndDefaultValue = { int a, int b=2 -> a+b }
assert closureWithTwoArgAndDefaultValue(1) == 3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="implicit-it"><a class="anchor" href="#implicit-it"></a>隐式参数</h5>
<div class="paragraph">
<p>当闭包没有显式定义参数列表时（使用<code>-></code> ），闭包<strong>始终</strong>定义一个隐式参数，名为<code>it</code> 。这意味着该代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def greeting = { "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>完全等同于这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def greeting = { it -> "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要声明一个不接受任何参数且必须限制为不带参数的调用的闭包，则<strong>必须</strong>使用一个明确的空参数列表对其进行声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def magicNumber = { -> 42 }

// this call will fail because the closure doesn't accept any argument
magicNumber(11)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_varargs_2"><a class="anchor" href="#_varargs_2"></a>瓦拉格斯</h5>
<div class="paragraph">
<p>闭包可以像其他任何方法一样声明变量参数。<em>Vargs</em>方法是一种方法，如果最后一个参数的长度可变（或数组），则可以接受可变数量的参数，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def concat1 = { String... args -> args.join('') }           <i class="conum" data-value="1"></i><b>(1)</b>
assert concat1('abc','def') == 'abcdef'                     <i class="conum" data-value="2"></i><b>(2)</b>
def concat2 = { String[] args -> args.join('') }            <i class="conum" data-value="3"></i><b>(3)</b>
assert concat2('abc', 'def') == 'abcdef'

def multiConcat = { int n, String... args ->                <i class="conum" data-value="4"></i><b>(4)</b>
    args.join('')*n
}
assert multiConcat(2, 'abc','def') == 'abcdefabcdef'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个闭包接受可变数量的字符串作为第一个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>可以使用任意数量的参数来调用它， <strong>而</strong>不必显式地将它们包装到数组中</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果将<em>args</em>参数声明为数组，则可以直接使用相同的行为</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>只要<strong>最后一个</strong>参数是数组或显式vargs类型</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_delegation_strategy"><a class="anchor" href="#_delegation_strategy"></a> 1.5.3。授权策略</h4>
<div class="sect4">
<h5 id="_groovy_closures_vs_lambda_expressions"><a class="anchor" href="#_groovy_closures_vs_lambda_expressions"></a> Groovy闭包与Lambda表达式</h5>
<div class="paragraph">
<p>Groovy将闭包定义为<a href="#closure-as-object">Closure类的实例</a> 。它<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">与Java 8中的lambda表达式</a>有很大不同。委派是Groovy闭包中的一个关键概念，在lambda中没有等效的概念。<em>更改委托</em>或<em>更改</em>闭包<em>的委托策略</em>的能力使在Groovy中设计漂亮的域特定语言（DSL）成为可能。</p>
</div>
</div>
<div class="sect4">
<h5 id="closure-owner"><a class="anchor" href="#closure-owner"></a>所有者，委托人和这个</h5>
<div class="paragraph">
<p>要理解委托的概念，我们首先必须解释<code>this</code>在一个封闭内。闭包实际上定义了3个不同的东西：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>this</code>对应于定义闭包的<em>封闭类</em></p>
</li>
<li>
<p><code>owner</code>对应于定义闭包的<em>封闭对象</em> ，它可以是类或闭包</p>
</li>
<li>
<p><code>delegate</code>对应于第三方对象，无论何时未定义消息的接收者，方法调用或属性都将被解析</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="closure-this"><a class="anchor" href="#closure-this"></a>这个的意思</h6>
<div class="paragraph">
<p>最后，打电话<code>getThisObject</code>将返回定义闭包的封闭类。等效于使用显式<code>this</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Enclosing {
    void run() {
        def whatIsThisObject = { getThisObject() }          <i class="conum" data-value="1"></i><b>(1)</b>
        assert whatIsThisObject() == this                   <i class="conum" data-value="2"></i><b>(2)</b>
        def whatIsThis = { this }                           <i class="conum" data-value="3"></i><b>(3)</b>
        assert whatIsThis() == this                         <i class="conum" data-value="4"></i><b>(4)</b>
    }
}
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { this }                               <i class="conum" data-value="5"></i><b>(5)</b>
    }
    void run() {
        def inner = new Inner()
        assert inner.cl() == inner                          <i class="conum" data-value="6"></i><b>(6)</b>
    }
}
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { this }                               <i class="conum" data-value="7"></i><b>(7)</b>
            cl()
        }
        assert nestedClosures() == this                     <i class="conum" data-value="8"></i><b>(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在内部定义了一个闭包<code>Enclosing</code>类，并返回<code>getThisObject</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>调用闭包将返回的实例<code>Enclosing</code>定义闭包的位置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通常，您只想使用快捷方式<code>this</code>符号</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>它返回<strong>完全相同</strong>的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>如果闭包在内部类中定义</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>this</code>在闭包<strong>中将</strong>返回内部类，而不是顶级类</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>如果是嵌套的闭包，例如这里<code>cl</code>在以下范围内定义<code>nestedClosures</code></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后<code>this</code>对应于最接近的外部类，而不是封闭的闭包！</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当然，可以通过以下方式从封闭类中调用方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
    String toString() { "$name is $age years old" }

    String dump() {
        def cl = {
            String msg = this.toString()               <i class="conum" data-value="1"></i><b>(1)</b>
            println msg
            msg
        }
        cl()
    }
}
def p = new Person(name:'Janice', age:74)
assert p.dump() == 'Janice is 74 years old'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>关闭电话<code>toString</code>上<code>this</code> ，实际上会称为<code>toString</code>封闭对象的方法，也就是说<code>Person</code>实例</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_owner_of_a_closure"><a class="anchor" href="#_owner_of_a_closure"></a>封闭的所有者</h6>
<div class="paragraph">
<p>闭包的所有者与闭包的定义非常相似<a href="#closure-this">，只是</a>有一个微妙的区别：闭包的所有者将返回直接封装的对象，无论是闭包还是类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Enclosing {
    void run() {
        def whatIsOwnerMethod = { getOwner() }               <i class="conum" data-value="1"></i><b>(1)</b>
        assert whatIsOwnerMethod() == this                   <i class="conum" data-value="2"></i><b>(2)</b>
        def whatIsOwner = { owner }                          <i class="conum" data-value="3"></i><b>(3)</b>
        assert whatIsOwner() == this                         <i class="conum" data-value="4"></i><b>(4)</b>
    }
}
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { owner }                               <i class="conum" data-value="5"></i><b>(5)</b>
    }
    void run() {
        def inner = new Inner()
        assert inner.cl() == inner                           <i class="conum" data-value="6"></i><b>(6)</b>
    }
}
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { owner }                               <i class="conum" data-value="7"></i><b>(7)</b>
            cl()
        }
        assert nestedClosures() == nestedClosures            <i class="conum" data-value="8"></i><b>(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在内部定义了一个闭包<code>Enclosing</code>类，并返回<code>getOwner</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>调用闭包将返回的实例<code>Enclosing</code>定义闭包的位置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>通常，您只想使用快捷方式<code>owner</code>符号</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>它返回<strong>完全相同</strong>的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>如果闭包在内部类中定义</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>owner</code>在闭包<strong>中将</strong>返回内部类，而不是顶级类</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>但是在嵌套闭包的情况下，例如这里<code>cl</code>在以下范围内定义<code>nestedClosures</code></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后<code>owner</code>对应于封闭的封闭物，因此与<code>this</code> ！</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_delegate_of_a_closure"><a class="anchor" href="#_delegate_of_a_closure"></a>委托结束</h6>
<div class="paragraph">
<p>闭包的委托可以通过使用<code>delegate</code>财产或致电<code>getDelegate</code>方法。这是在Groovy中构建领域特定语言的强大概念。虽然<a href="#this">closure-this</a>和<a href="#owner">closure-owner</a>引用了closure的词法范围，但委托是closure将使用的用户定义对象。默认情况下，委托设置为<code>owner</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Enclosing {
    void run() {
        def cl = { getDelegate() }                          <i class="conum" data-value="1"></i><b>(1)</b>
        def cl2 = { delegate }                              <i class="conum" data-value="2"></i><b>(2)</b>
        assert cl() == cl2()                                <i class="conum" data-value="3"></i><b>(3)</b>
        assert cl() == this                                 <i class="conum" data-value="4"></i><b>(4)</b>
        def enclosed = {
            { -> delegate }.call()                          <i class="conum" data-value="5"></i><b>(5)</b>
        }
        assert enclosed() == enclosed                       <i class="conum" data-value="6"></i><b>(6)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>您可以获取闭包的委托，调用<code>getDelegate</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>或使用<code>delegate</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>都返回相同的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>这是封闭类或闭包</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>特别是在嵌套闭包的情况下</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td><code>delegate</code>将对应于<code>owner</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>闭包的委托可以更改为<strong>任何对象</strong> 。让我们通过创建两个彼此都不是子类但都定义了一个名为<code>name</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}
class Thing {
    String name
}

def p = new Person(name: 'Norman')
def t = new Thing(name: 'Teapot')</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后让我们定义一个闭包来获取<code>name</code>委托上的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def upperCasedName = { delegate.name.toUpperCase() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后通过更改闭包的委托，您可以看到目标对象将更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">upperCasedName.delegate = p
assert upperCasedName() == 'NORMAN'
upperCasedName.delegate = t
assert upperCasedName() == 'TEAPOT'</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上，行为与拥有<code>target</code>在闭包的词法范围内定义的变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def target = p
def upperCasedNameUsingVar = { target.name.toUpperCase() }
assert upperCasedNameUsingVar() == 'NORMAN'</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，存在主要差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在最后一个示例中， <em>target</em>是从闭包内部引用的局部变量</p>
</li>
<li>
<p>该委托可以透明地使用，也就是说，无需在方法调用前添加前缀<code>delegate.</code>如下一段所述。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_delegation_strategy_2"><a class="anchor" href="#_delegation_strategy_2"></a>授权策略</h6>
<div class="paragraph">
<p>每当在闭包中访问属性而不显式设置接收者对象时，就会涉及委托策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}
def p = new Person(name:'Igor')
def cl = { name.toUpperCase() }                 <i class="conum" data-value="1"></i><b>(1)</b>
cl.delegate = p                                 <i class="conum" data-value="2"></i><b>(2)</b>
assert cl() == 'IGOR'                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>name</code>在闭包的词法范围内未引用变量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以将闭包的委托更改为的实例<code>Person</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并且方法调用将成功</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该代码起作用的原因是<code>name</code>属性将在<code>delegate</code>宾语！这是解决闭包内部属性或方法调用的一种非常有效的方法。无需设置明确的<code>delegate.</code>接收方：将进行调用，因为关闭的默认委派策略使之如此。闭包实际上定义了多种解决方案策略，您可以选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Closure.OWNER_FIRST</code>是<strong>默认策略</strong> 。如果<strong>所有者</strong>上存在属性/方法，则将在<strong>所有者</strong>上调用它。如果不是，则使用<strong>委托</strong> 。</p>
</li>
<li>
<p><code>Closure.DELEGATE_FIRST</code>颠倒逻辑：首先使用<strong>委托</strong> ，然后使用<strong>所有者</strong></p>
</li>
<li>
<p><code>Closure.OWNER_ONLY</code>只会在所有者上解析属性/方法查找：委托将被忽略。</p>
</li>
<li>
<p><code>Closure.DELEGATE_ONLY</code>只会解决委托上的属性/方法查找：所有者将被忽略。</p>
</li>
<li>
<p><code>Closure.TO_SELF</code>可供需要高级元编程技术并希望实现自定义解析策略的开发人员使用：解析不会在所有者或委托上进行，而只会在闭包类本身上进行。如果您实现自己的子类，则仅使用此方法有意义<code>Closure</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们用下面的代码说明默认的“所有者优先”策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    def pretty = { "My name is $name" }             <i class="conum" data-value="1"></i><b>(1)</b>
    String toString() {
        pretty()
    }
}
class Thing {
    String name                                     <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person(name: 'Sarah')
def t = new Thing(name: 'Teapot')

assert p.toString() == 'My name is Sarah'           <i class="conum" data-value="3"></i><b>(3)</b>
p.pretty.delegate = t                               <i class="conum" data-value="4"></i><b>(4)</b>
assert p.toString() == 'My name is Sarah'           <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>为了说明，我们定义一个引用“名称”的闭包成员</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>这俩<code>Person</code>和<code>Thing</code>类定义一个<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用默认策略， <code>name</code>财产首先由所有者解决</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>所以如果我们改变<code>delegate</code>至<code>t</code>这是<code>Thing</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>结果没有变化： <code>name</code>首先解决<code>owner</code>封闭的</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>但是，可以更改关闭的解决策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p.pretty.resolveStrategy = Closure.DELEGATE_FIRST
assert p.toString() == 'My name is Teapot'</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过更改<code>resolveStrategy</code> ，我们正在修改Groovy解决“隐含此”引用的方式：在这种情况下， <code>name</code>首先将在委托中查找，然后在所有者上查找（如果找不到）。以来<code>name</code>是在委托中定义的<code>Thing</code> ，则使用此值。</p>
</div>
<div class="paragraph">
<p>（RESP所有者）“委派第一”和“仅授权”或“所有者第一”和“仅所有者”可以示之间的差值，如果该委托的一个<strong>不</strong>具有这样的方法或属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
    def fetchAge = { age }
}
class Thing {
    String name
}

def p = new Person(name:'Jessica', age:42)
def t = new Thing(name:'Printer')
def cl = p.fetchAge
cl.delegate = p
assert cl() == 42
cl.delegate = t
assert cl() == 42
cl.resolveStrategy = Closure.DELEGATE_ONLY
cl.delegate = p
assert cl() == 42
cl.delegate = t
try {
    cl()
    assert false
} catch (MissingPropertyException ex) {
    // "age" is not defined on the delegate
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们定义了两个类，每个类都有一个<code>name</code>财产，但只有<code>Person</code>类声明一个<code>age</code> 。的<code>Person</code>类还声明了一个引用的闭包<code>age</code> 。我们可以将默认解决方案策略从“所有者优先”更改为“仅委托”。由于关闭的所有者是<code>Person</code>类，那么我们可以检查委托是否是的实例<code>Person</code> ，则成功调用了闭包，但是如果我们使用一个委托作为它的实例来调用它<code>Thing</code> ，它失败并显示<code>groovy.lang.MissingPropertyException</code> 。尽管在内部定义了闭包<code>Person</code>类，不使用所有者。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><a href="core-domain-specific-languages.html">在手册</a>的<a href="core-domain-specific-languages.html">专用部分中，</a>可以找到有关如何使用此功能开发DSL的全面说明。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_closures_in_gstrings"><a class="anchor" href="#_closures_in_gstrings"></a> 1.5.4。GString中的闭包</h4>
<div class="paragraph">
<p>采取以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1
def gs = "x = ${x}"
assert gs == 'x = 1'</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码的行为符合您的预期，但是如果添加以下内容，将会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">x = 2
assert gs == 'x = 2'</code></pre>
</div>
</div>
<div class="paragraph">
<p>您将看到断言失败！有两个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GString只懒惰地求值<code>toString</code>值的表示</p>
</li>
<li>
<p>语法<code>${x}</code>在一个的GString <strong>不代表</strong>一个闭合但<strong>表达式</strong>来<code>$x</code> ，在创建GString时进行评估。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我们的示例中， <code>GString</code>用表达式引用创建<code>x</code> 。当。。。的时候<code>GString</code>被创建，的<strong>值</strong> <code>x</code>是1，所以<code>GString</code>创建的值为1。当触发断言时， <code>GString</code>评估并将1转换为<code>String</code>使用<code>toString</code> 。当我们改变<code>x</code>到2，我们确实更改了<code>x</code> ，但这是一个不同的对象， <code>GString</code>仍然引用旧的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">一种<code>GString</code>只会改变它的<code>toString</code>如果它引用的值是变异的，则表示。如果引用发生更改，则不会发生任何事情。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要在GString中进行真正的关闭，例如强制对变量进行延迟计算，则需要使用备用语法<code>${→ x}</code>如固定示例中所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1
def gs = "x = ${-> x}"
assert gs == 'x = 1'

x = 2
assert gs == 'x = 2'</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们用以下代码说明它与突变的区别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    String toString() { name }          <i class="conum" data-value="1"></i><b>(1)</b>
}
def sam = new Person(name:'Sam')        <i class="conum" data-value="2"></i><b>(2)</b>
def lucy = new Person(name:'Lucy')      <i class="conum" data-value="3"></i><b>(3)</b>
def p = sam                             <i class="conum" data-value="4"></i><b>(4)</b>
def gs = "Name: ${p}"                   <i class="conum" data-value="5"></i><b>(5)</b>
assert gs == 'Name: Sam'                <i class="conum" data-value="6"></i><b>(6)</b>
p = lucy                                <i class="conum" data-value="7"></i><b>(7)</b>
assert gs == 'Name: Sam'                <i class="conum" data-value="8"></i><b>(8)</b>
sam.name = 'Lucy'                       <i class="conum" data-value="9"></i><b>(9)</b>
assert gs == 'Name: Lucy'               <i class="conum" data-value="10"></i><b>(10)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Person</code>班上有一个<code>toString</code>方法返回<code>name</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们创建第一个<code>Person</code>叫<em>山姆</em></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们创建另一个<code>Person</code>叫<em>露西</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>p</code>变量设置为<code>Sam</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>并创建一个引用的值的闭包<code>p</code> ，也就是说<em>山姆</em></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>因此，当我们评估字符串时，它将返回<em>Sam</em></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>如果我们改变<code>p</code> <em>露西</em></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>该字符串仍为<em>Sam</em>求<strong>值</strong> ，因为它是<code>p</code>当。。。的时候<code>GString</code>被创建</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>所以如果我们变异<em>山姆</em>将他的名字改成<em>露西</em></td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>这次<code>GString</code>已正确突变</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，如果您不想依赖于更改对象或包装对象，则<strong>必须</strong>在<code>GString</code>通过显式声明一个空的参数列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    String toString() { name }
}
def sam = new Person(name:'Sam')
def lucy = new Person(name:'Lucy')
def p = sam
// Create a GString with lazy evaluation of "p"
def gs = "Name: ${-> p}"
assert gs == 'Name: Sam'
p = lucy
assert gs == 'Name: Lucy'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_closure_coercion"><a class="anchor" href="#_closure_coercion"></a> 1.5.5。强制关闭</h4>
<div class="paragraph">
<p>闭包可以转换为接口或单一抽象方法类型。请参考<a href="core-semantics.html#closure-coercion">本手册</a>的完整说明。</p>
</div>
</div>
<div class="sect3">
<h4 id="_functional_programming"><a class="anchor" href="#_functional_programming"></a> 1.5.6。功能编程</h4>
<div class="paragraph">
<p>像<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Java 8</a>中的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambda表达式</a>一样，闭包是Groovy中功能编程范例的核心。对功能的某些功能编程操作可直接在<code>Closure</code>类，如本节所示。</p>
</div>
<div class="sect4">
<h5 id="_currying"><a class="anchor" href="#_currying"></a>咖喱</h5>
<div class="paragraph">
<p>在Groovy中，“ currying”是指部分应用程序的概念。它<strong>不</strong>符合，因为那Groovy的适用于封闭的不同范围的规则在函数式编程讨好的真正概念。用Groovy进行Currying可以让您设置闭包的一个参数的值，并且它将返回一个接受较少参数的新闭包。</p>
</div>
<div class="sect5">
<h6 id="_left_currying"><a class="anchor" href="#_left_currying"></a>左弯曲</h6>
<div class="paragraph">
<p>左递归是设置闭包的最左边参数的事实，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nCopies = { int n, String str -> str*n }    <i class="conum" data-value="1"></i><b>(1)</b>
def twice = nCopies.curry(2)                    <i class="conum" data-value="2"></i><b>(2)</b>
assert twice('bla') == 'blabla'                 <i class="conum" data-value="3"></i><b>(3)</b>
assert twice('bla') == nCopies(2, 'bla')        <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>nCopies</code>闭包定义两个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>curry</code>将第一个参数设置为<code>2</code> ，创建一个接受单个闭包的新闭包（函数）<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>因此，仅用一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>这相当于打电话<code>nCopies</code>有两个参数</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_right_currying"><a class="anchor" href="#_right_currying"></a>右弯曲</h6>
<div class="paragraph">
<p>与左递归相似，可以设置闭包的最右边参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nCopies = { int n, String str -> str*n }    <i class="conum" data-value="1"></i><b>(1)</b>
def blah = nCopies.rcurry('bla')                <i class="conum" data-value="2"></i><b>(2)</b>
assert blah(2) == 'blabla'                      <i class="conum" data-value="3"></i><b>(3)</b>
assert blah(2) == nCopies(2, 'bla')             <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>nCopies</code>闭包定义两个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>rcurry</code>将最后一个参数设置为<code>bla</code> ，创建一个接受单个闭包的新闭包（函数）<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>因此，仅使用一个<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>这相当于打电话<code>nCopies</code>有两个参数</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_index_based_currying"><a class="anchor" href="#_index_based_currying"></a>基于索引的货币</h6>
<div class="paragraph">
<p>如果闭包接受两个以上的参数，则可以使用<code>ncurry</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def volume = { double l, double w, double h -> l*w*h }      <i class="conum" data-value="1"></i><b>(1)</b>
def fixedWidthVolume = volume.ncurry(1, 2d)                 <i class="conum" data-value="2"></i><b>(2)</b>
assert volume(3d, 2d, 4d) == fixedWidthVolume(3d, 4d)       <i class="conum" data-value="3"></i><b>(3)</b>
def fixedWidthAndHeight = volume.ncurry(1, 2d, 4d)          <i class="conum" data-value="4"></i><b>(4)</b>
assert volume(3d, 2d, 4d) == fixedWidthAndHeight(3d)        <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>volume</code>函数定义3个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>ncurry</code>将第二个参数（索引= 1）设置为<code>2d</code> ，创建一个接受长度和高度的新音量功能</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>该功能等同于调用<code>volume</code>省略宽度</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>也可以从指定的索引开始设置多个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>结果函数接受的参数数量与初始参数数量之和减去以下参数设置的数量一样<code>ncurry</code></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_memoization"><a class="anchor" href="#_memoization"></a>记忆化</h5>
<div class="paragraph">
<p>记忆允许对闭包调用的结果进行缓存。如果一个函数（关闭）执行的计算速度很慢，这很有趣，但是您知道该函数将经常使用相同的参数来调用。一个典型的例子是斐波那契套件。天真的实现可能看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def fib
fib = { long n -> n<2?n:fib(n-1)+fib(n-2) }
assert fib(15) == 610 // slow!</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个幼稚的实现，因为通常以相同的参数递归调用“ fib”，从而产生指数算法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计算<code>fib(15)</code>需要的结果<code>fib(14)</code>和<code>fib(13)</code></p>
</li>
<li>
<p>计算<code>fib(14)</code>需要的结果<code>fib(13)</code>和<code>fib(12)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于调用是递归的，因此您已经可以看到我们将一次又一次地计算相同的值，尽管它们可以被缓存。可以通过使用以下方法缓存调用结果来“修复”这种简单的实现<code>memoize</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">fib = { long n -> n<2?n:fib(n-1)+fib(n-2) }.memoize()
assert fib(25) == 75025 // fast!</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">缓存<strong>使用参数的实际值工作</strong> 。这意味着，如果将备注与原始类型或装箱原始类型一起使用时，则应格外小心。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用其他方法来调整缓存的行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>memoizeAtMost</code>将生成一个新的闭包， <strong>最多</strong>缓存<em>n个</em>值</p>
</li>
<li>
<p><code>memoizeAtLeast</code>将生成一个新的闭包，该闭包<strong>至少</strong>缓存<em>n个</em>值</p>
</li>
<li>
<p><code>memoizeBetween</code>将生成一个新的闭包，该闭包<strong>至少</strong>缓存<em>n个</em>值<strong>，最多</strong>缓存<em>n</em> <em>个</em>值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有备忘变体中使用的缓存是LRU缓存。</p>
</div>
</div>
<div class="sect4">
<h5 id="_composition"><a class="anchor" href="#_composition"></a>组成</h5>
<div class="paragraph">
<p>闭包组成与函数组成的概念相对应，也就是说，通过组成两个或更多函数（链接调用）来创建新函数，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def plus2  = { it + 2 }
def times3 = { it * 3 }

def times3plus2 = plus2 << times3
assert times3plus2(3) == 11
assert times3plus2(4) == plus2(times3(4))

def plus2times3 = times3 << plus2
assert plus2times3(3) == 15
assert plus2times3(5) == times3(plus2(5))

// reverse composition
assert times3plus2(3) == (times3 >> plus2)(3)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trampoline"><a class="anchor" href="#_trampoline"></a>蹦床</h5>
<div class="paragraph">
<p>递归算法通常受到物理限制：最大堆栈高度。例如，如果您调用的方法递归调用自身的深度过深，则最终将收到一个<code>StackOverflowException</code> 。</p>
</div>
<div class="paragraph">
<p>在这些情况下有帮助的方法是使用<code>Closure</code>及其蹦床的能力。</p>
</div>
<div class="paragraph">
<p>封闭包装在<code>TrampolineClosure</code> 。接到电话后， <code>Closure</code>会叫原件<code>Closure</code>等待结果。如果通话的结果是<code>TrampolineClosure</code> ，可能是由于调用<code>trampoline()</code>方法， <code>Closure</code>将再次被调用。重复执行的返回的Trapolited Closures实例将继续进行，直到获得非Trapolited Closures值为止。 <code>Closure</code>返回。该值将成为蹦床的最终结果。这样，调用是串行进行的，而不是填充堆栈。</p>
</div>
<div class="paragraph">
<p>这是使用<code>trampoline()</code>实现阶乘函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def factorial
factorial = { int n, def accu = 1G ->
    if (n < 2) return accu
    factorial.trampoline(n - 1, n * accu)
}
factorial = factorial.trampoline()

assert factorial(1)    == 1
assert factorial(3)    == 1 * 2 * 3
assert factorial(1000) // == 402387260.. plus another 2560 digits</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_method_pointers"><a class="anchor" href="#_method_pointers"></a>方法指针</h5>
<div class="paragraph">
<p>能够使用常规方法作为闭包通常是很实际的。例如，您可能想使用闭包的currying功能，但是普通方法无法使用这些功能。在Groovy中，您可以使用<a href="core-operators.html#method-pointer-operator">方法指针运算符</a>从任何方法获取闭包。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_semantics"><a class="anchor" href="#_semantics"></a> 1.6。语义学</h3>
<div class="paragraph">
<p>本章介绍了Groovy编程语言的语义。</p>
</div>
<div class="sect3">
<h4 id="_statements"><a class="anchor" href="#_statements"></a> 1.6.1。陈述</h4>
<div class="sect4">
<h5 id="_variable_definition"><a class="anchor" href="#_variable_definition"></a>变量定义</h5>
<div class="paragraph">
<p>变量可以使用它们的任一类型（例如<code>String</code> ）或使用关键字<code>def</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String x
def o</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>def</code>是类型名称的替代。在变量定义中，它用来表示您不关心类型。在变量定义中，必须明确提供类型名称或在替换中使用“ def”。为了使Groovy解析器可检测到变量定义，这是必需的。</p>
</div>
<div class="paragraph">
<p>你可以想到<code>def</code>作为...的别名<code>Object</code>您将立即了解它。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">可以使用泛型来完善变量定义类型，例如<code>List<String> names</code> 。要了解有关泛型支持的更多信息，请阅读<a href="#generics">泛型部分</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_variable_assignment"><a class="anchor" href="#_variable_assignment"></a>变量分配</h5>
<div class="paragraph">
<p>您可以将值分配给变量以供以后使用。请尝试以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">x = 1
println x

x = new java.util.Date()
println x

x = -3.1499392
println x

x = false
println x

x = "Hi"
println x</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_multiple_assignment"><a class="anchor" href="#_multiple_assignment"></a>多重分配</h6>
<div class="paragraph">
<p>Groovy支持多重分配，即可以一次分配多个变量，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (a, b, c) = [10, 20, 'foo']
assert a == 10 && b == 20 && c == 'foo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果愿意，可以在声明中提供类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (int i, String j) = [10, 'foo']
assert i == 10 && j == 'foo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>与声明变量时使用的方法一样，它也适用于现有变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nums = [1, 3, 5]
def a, b, c
(a, b, c) = nums
assert a == 1 && b == 3 && c == 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语法适用于数组，列表以及返回以下任意一个的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (_, month, year) = "18th June 2009".split()
assert "In $month of $year" == 'In June of 2009'</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_overflow_and_underflow"><a class="anchor" href="#_overflow_and_underflow"></a>上溢和下溢</h6>
<div class="paragraph">
<p>如果左侧的变量太多，则多余的变量将用null填充：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (a, b, c) = [1, 2]
assert a == 1 && b == 2 && c == null</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果右侧有太多变量，则多余的变量将被忽略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (a, b) = [1, 2, 3]
assert a == 1 && b == 2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_object_destructuring_with_multiple_assignment"><a class="anchor" href="#_object_destructuring_with_multiple_assignment"></a>具有多个分配的对象分解</h6>
<div class="paragraph">
<p>在描述各种<a href="#groovy-operators">Groovy运算符</a>的部分中，讨论了下<a href="#subscript-operator">标运算符</a>的大小写，解释了如何覆盖<code>getAt()</code> / <code>putAt()</code>方法。</p>
</div>
<div class="paragraph">
<p>使用这种技术，我们可以将多个赋值和下标运算符方法结合起来以实现<em>对象分解</em> 。</p>
</div>
<div class="paragraph">
<p>考虑以下不可变<code>Coordinates</code>类，其中包含一对经度和纬度对，并注意我们对<code>getAt()</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Immutable
class Coordinates {
    double latitude
    double longitude

    double getAt(int idx) {
        if (idx == 0) latitude
        else if (idx == 1) longitude
        else throw new Exception("Wrong coordinate index, use 0 or 1")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们实例化该类并破坏其经度和纬度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def coordinates = new Coordinates(latitude: 43.23, longitude: 3.67) <i class="conum" data-value="1"></i><b>(1)</b>

def (la, lo) = coordinates                                          <i class="conum" data-value="2"></i><b>(2)</b>

assert la == 43.23                                                  <i class="conum" data-value="3"></i><b>(3)</b>
assert lo == 3.67</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们创建了一个实例<code>Coordinates</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后，我们使用多重分配来获取各个经度和纬度值</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们最终可以维护其价值观。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_control_structures"><a class="anchor" href="#_control_structures"></a>控制结构</h5>
<div class="sect5">
<h6 id="_conditional_structures"><a class="anchor" href="#_conditional_structures"></a>条件结构</h6>
<div class="sect6">
<h7 id="_if_else"><a class="anchor" href="#_if_else"></a>如果别的</h7>
<div class="paragraph">
<p>Groovy支持通常的if-else Java语法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = false
def y = false

if ( !x ) {
    x = true
}

assert x == true

if ( x ) {
    x = false
} else {
    y = true
}

assert x == y</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果语法如下，那么Groovy还支持普通的Java“嵌套”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if ( ... ) {
    ...
} else if (...) {
    ...
} else {
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="_switch_case"><a class="anchor" href="#_switch_case"></a>开关/箱</h7>
<div class="paragraph">
<p>Groovy中的switch语句向后兼容Java代码。因此您可以轻松解决多个匹配项共享相同代码的问题。</p>
</div>
<div class="paragraph">
<p>但是，一个区别是Groovy switch语句可以处理任何种类的switch值，并且可以执行不同种类的匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1.23
def result = ""

switch ( x ) {
    case "foo":
        result = "found foo"
        // lets fall through

    case "bar":
        result += "bar"

    case [4, 5, 6, 'inList']:
        result = "list"
        break

    case 12..30:
        result = "range"
        break

    case Integer:
        result = "integer"
        break

    case Number:
        result = "number"
        break

    case ~/fo*/: // toString() representation of x matches the pattern?
        result = "foo regex"
        break

    case { it < 0 }: // or { x < 0 }
        result = "negative"
        break

    default:
        result = "default"
}

assert result == "number"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Switch支持以下几种比较：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果switch值是该类的实例，则类大小写值匹配</p>
</li>
<li>
<p>如果正则表达式大小写值匹配<code>toString()</code>开关值的表示形式与正则表达式匹配</p>
</li>
<li>
<p>如果开关值包含在集合中，则集合用例值匹配。这也包括范围（因为它们是列表）</p>
</li>
<li>
<p>如果根据<a href="#Groovy-Truth">Groovy事实</a> ，调用闭包返回的结果为true，则闭包大小值匹配</p>
</li>
<li>
<p>如果未使用上述任何一项，则如果案例值等于开关值，则案例值匹配</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用闭包大小写值时，默认<code>it</code>参数实际上是开关值（在我们的示例中为变量<code>x</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_looping_structures"><a class="anchor" href="#_looping_structures"></a>循环结构</h6>
<div class="sect6">
<h7 id="_classic_for_loop"><a class="anchor" href="#_classic_for_loop"></a>经典循环</h7>
<div class="paragraph">
<p>Groovy支持标准Java / C for循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String message = ''
for (int i = 0; i < 5; i++) {
    message += 'Hi '
}
assert message == 'Hi Hi Hi Hi Hi '</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="_for_in_loop"><a class="anchor" href="#_for_in_loop"></a>循环中</h7>
<div class="paragraph">
<p>Groovy中的for循环要简单得多，并且可以与任何类型的数组，集合，Map等一起使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// iterate over a range
def x = 0
for ( i in 0..9 ) {
    x += i
}
assert x == 45

// iterate over a list
x = 0
for ( i in [0, 1, 2, 3, 4] ) {
    x += i
}
assert x == 10

// iterate over an array
def array = (0..4).toArray()
x = 0
for ( i in array ) {
    x += i
}
assert x == 10

// iterate over a map
def map = ['abc':1, 'def':2, 'xyz':3]
x = 0
for ( e in map ) {
    x += e.value
}
assert x == 6

// iterate over values in a map
x = 0
for ( v in map.values() ) {
    x += v
}
assert x == 6

// iterate over the characters in a string
def text = "abc"
def list = []
for (c in text) {
    list.add(c)
}
assert list == ["a", "b", "c"]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy还支持带有冒号的Java冒号变体： <code>for (char c : text) {}</code> ，其中变量的类型是必需的。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect6">
<h7 id="_while_loop"><a class="anchor" href="#_while_loop"></a> while循环</h7>
<div class="paragraph">
<p>Groovy支持像Java这样的常规{@}循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 0
def y = 5

while ( y-- > 0 ) {
    x++
}

assert x == 5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_exception_handling"><a class="anchor" href="#_exception_handling"></a>异常处理</h6>
<div class="paragraph">
<p>异常处理与Java相同。</p>
</div>
</div>
<div class="sect5">
<h6 id="_try_catch_finally"><a class="anchor" href="#_try_catch_finally"></a>尝试/抓住/最后</h6>
<div class="paragraph">
<p>您可以指定一个完整的<code>try-catch-finally</code> ， 一种<code>try-catch</code>或<code>try-finally</code>组块。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">每个块体周围都需要支撑。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">try {
    'moo'.toLong()   // this will generate an exception
    assert false     // asserting that this point should never be reached
} catch ( e ) {
    assert e in NumberFormatException
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以将代码放在匹配的“ try”子句之后的“ finally”子句中，以便无论“ try”子句中的代码是否引发异常，finally子句中的代码将始终执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def z
try {
    def i = 7, j = 0
    try {
        def k = i / j
        assert false        //never reached due to Exception in previous line
    } finally {
        z = 'reached here'  //always executed even if Exception thrown
    }
} catch ( e ) {
    assert e in ArithmeticException
    assert z == 'reached here'
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_multi_catch"><a class="anchor" href="#_multi_catch"></a>多渔获</h6>
<div class="paragraph">
<p>使用multi catch块（自Groovy 2.0起），我们能够定义要捕获并由同一catch块处理的多个异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">try {
    /* ... */
} catch ( IOException | NullPointerException e ) {
    /* one block to handle 2 exceptions */
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_power_assertion"><a class="anchor" href="#_power_assertion"></a>权力主张</h5>
<div class="paragraph">
<p>与Groovy共享Java的Java不同<code>assert</code>关键字，Groovy中的后者的行为则大不相同。首先，总是执行Groovy中的断言，而与<code>-ea</code> JVM的标志。这使其成为单元测试的一流选择。“权力断言”的概念与Groovy的方式直接相关。 <code>assert</code>表现良好。</p>
</div>
<div class="paragraph">
<p>功率断言可分解为三个部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>assert [left expression] == [right expression] : (optional message)</pre>
</div>
</div>
<div class="paragraph">
<p>断言的结果与您在Java中获得的结果完全不同。如果断言为真，则什么都不会发生。如果断言为假，则它提供要断言的表达式的每个子表达式的值的可视表示。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 1+1 == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>将产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Caught: Assertion failed:

assert 1+1 == 3
        |  |
        2  false</pre>
</div>
</div>
<div class="paragraph">
<p>当表达式更复杂时，幂断言变得非常有趣，例如下面的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 2
def y = 7
def z = 5
def calc = { a,b -> a*b+1 }
assert calc(x,y) == [x,z].sum()</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将为每个子表达式打印值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert calc(x,y) == [x,z].sum()
       |    | |  |   | |  |
       15   2 7  |   2 5  7
                 false</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不想像上面那样打印出漂亮的错误消息，则可以通过更改断言的可选消息部分来回退到自定义错误消息，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 2
def y = 7
def z = 5
def calc = { a,b -> a*b+1 }
assert calc(x,y) == z*z : 'Incorrect computation result'</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将显示以下错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Incorrect computation result. Expression: (calc.call(x, y) == (z * z)). Values: z = 5, z = 5</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_labeled_statements"><a class="anchor" href="#_labeled_statements"></a>带标签的声明</h5>
<div class="paragraph">
<p>任何语句都可以与标签关联。标签不会影响代码的语义，可用于使代码更易于阅读，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">given:
    def x = 1
    def y = 2
when:
    def z = x+y
then:
    assert z == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管不更改标记语句的语义，但仍可以在<code>break</code>指令作为跳转目标，如以下示例所示。但是，即使允许这样做，这种编码样式也通常被认为是不好的做法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">for (int i=0;i<10;i++) {
    for (int j=0;j<i;j++) {
        println "j=$j"
        if (j == 5) {
            break exit
        }
    }
    exit: println "i=$i"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是要了解，默认情况下标签不会影响代码的语义，但是它们属于抽象语法树（AST），因此AST转换可以使用该信息对代码执行转换，因此导致不同的语义。<a href="http://spockframework.github.io/spock/docs/current/index.html">Spock框架</a>尤其这样做是为了使测试更容易。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_expressions"><a class="anchor" href="#_expressions"></a> 1.6.2。表达方式</h4>
<div class="paragraph">
<p>（待定）</p>
</div>
<div class="sect4">
<h5 id="gpath_expressions"><a class="anchor" href="#gpath_expressions"></a> GPath表达式</h5>
<div class="paragraph">
<p><code>GPath</code>是集成到Groovy中的一种路径表达语言，它允许识别嵌套的结构化数据的一部分。从这个意义上讲，它具有与XPath用于XML相似的目标和范围。GPath通常用于处理XML的上下文中，但实际上它适用于任何对象图。XPath使用类似于文件系统的路径表示法，即树状层次结构，其中部分之间用斜杠分隔<code>/</code> ，GPath <strong>使用点对象符号</strong>来执行对象导航。</p>
</div>
<div class="paragraph">
<p>例如，您可以指定目标对象或元素的路径：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a.b.c</code> →对于XML，产生所有<code>c</code>里面的元素<code>b</code>内<code>a</code></p>
</li>
<li>
<p><code>a.b.c</code> →对于POJO，产生<code>c</code>所有的属性<code>b</code>的性质<code>a</code> （有点像<code>a.getB().getC()</code>在JavaBeans中）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这两种情况下，都可以将GPath表达式视为对对象图的查询。对于POJO，对象图通常是由通过对象实例化和组合编写的程序构建的。对于XML处理，对象图是<code>parsing</code> XML文本，通常使用XmlParser或XmlSlurper之类的类。有关在Groovy中使用XML的更多详细信息，请参见<a href="../../../subprojects/groovy-xml/src/spec/doc/xml-userguide.html#Processing XML">处理XML</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>查询从XmlParser或XmlSlurper生成的对象图时，GPath表达式可以使用<code>@</code>符号：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a["@href"]</code> →类似地图的符号：所有a元素的href属性</p>
</li>
<li>
<p><code>a.'@href'</code> →属性符号：表达此内容的另一种方法</p>
</li>
<li>
<p><code>a.@href</code> →直接表示法：这是另一种表达方式</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_object_navigation"><a class="anchor" href="#_object_navigation"></a>对象导航</h6>
<div class="paragraph">
<p>让我们看一个简单的<em>对象图</em>上的GPath表达式的示例，该<em>图</em>是使用java反射获得的。假设您处于类的非静态方法中，该方法具有另一个名为<code>aMethodFoo</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void aMethodFoo() { println "This is aMethodFoo." } <i class="conum" data-value="0"></i><b>(0)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下GPath表达式将获取该方法的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['aMethodFoo'] == this.class.methods.name.grep(~/.*Foo/)</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>更精确地讲</em> ，上面的GPath表达式会生成一个String列表，每个列表都是现有方法的名称。 <code>this</code>该名称以<code>Foo</code> 。</p>
</div>
<div class="paragraph">
<p>现在，在该类中还定义了以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void aMethodBar() { println "This is aMethodBar." } <i class="conum" data-value="1"></i><b>(1)</b>
void anotherFooMethod() { println "This is anotherFooMethod." } <i class="conum" data-value="2"></i><b>(2)</b>
void aSecondMethodBar() { println "This is aSecondMethodBar." } <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>那么以下GPath表达式将获得<strong>（1）</strong>和<strong>（3）的名称</strong> ，而不是<strong>（2）</strong>或<strong>（0）的名称</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['aMethodBar', 'aSecondMethodBar'] as Set == this.class.methods.name.grep(~/.*Bar/) as Set</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_expression_deconstruction"><a class="anchor" href="#_expression_deconstruction"></a>表达解构</h6>
<div class="paragraph">
<p>我们可以分解表达式<code>this.class.methods.name.grep(~/.*Bar/)</code>了解如何评估GPath：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>this.class</code></dt>
<dd>
<p>属性访问器，等效于<code>this.getClass()</code>在Java中，产生一个<code>Class</code>宾语。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods</code></dt>
<dd>
<p>属性访问器，等效于<code>this.getClass().getMethods()</code> ，产生一个数组<code>Method</code>对象。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods.name</code></dt>
<dd>
<p>在数组的每个元素上应用属性访问器，并生成结果列表。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods.name.grep(…​)</code></dt>
<dd>
<p>调用方法<code>grep</code>在列表产生的每个元素上<code>this.class.methods.name</code>并生成结果列表。</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">像<code>this.class.methods</code>产生一个数组，因为这就是调用<code>this.getClass().getMethods()</code>用Java会产生。 <code>GPath</code>表达式没有约定<code>s</code>表示列表或类似内容。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>GPath表达式的一项强大功能是将对集合的<em>属性访问</em>转换为<em>对集合的每个元素的属性访问</em> ，并将结果收集到集合中。因此，表达<code>this.class.methods.name</code>可以用Java表示如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List<String> methodNames = new ArrayList<String>();
for (Method method : this.getClass().getMethods()) {
   methodNames.add(method.getName());
}
return methodNames;</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组访问符号也可以在存在集合的GPath表达式中使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 'aSecondMethodBar' == this.class.methods.name.grep(~/.*Bar/).sort()[1]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">数组访问在GPath表达式中从零开始</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_gpath_for_xml_navigation"><a class="anchor" href="#_gpath_for_xml_navigation"></a>用于XML导航的GPath</h6>
<div class="paragraph">
<p>这是一个XML文档和各种形式的GPath表达式的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlText = """
              | <root>
              |   <level>
              |      <sublevel id='1'>
              |        <keyVal>
              |          <key>mykey</key>
              |          <value>value 123</value>
              |        </keyVal>
              |      </sublevel>
              |      <sublevel id='2'>
              |        <keyVal>
              |          <key>anotherKey</key>
              |          <value>42</value>
              |        </keyVal>
              |        <keyVal>
              |          <key>mykey</key>
              |          <value>fizzbuzz</value>
              |        </keyVal>
              |      </sublevel>
              |   </level>
              | </root>
              """
def root = new XmlSlurper().parseText(xmlText.stripMargin())
assert root.level.size() == 1 <i class="conum" data-value="1"></i><b>(1)</b>
assert root.level.sublevel.size() == 2 <i class="conum" data-value="2"></i><b>(2)</b>
assert root.level.sublevel.findAll { it.@id == 1 }.size() == 1 <i class="conum" data-value="3"></i><b>(3)</b>
assert root.level.sublevel[1].keyVal[0].key.text() == 'anotherKey' <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>有一个<code>level</code>下的节点<code>root</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>那里有两个<code>sublevel</code>下的节点<code>root/level</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>有一个要素<code>sublevel</code>具有属性<code>id</code>有价值<code>1</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的文字值<code>key</code>第一要素<code>keyVal</code>第二要素<code>sublevel</code>下的元素<code>root/level</code>是“ anotherKey”</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promotion_and_coercion"><a class="anchor" href="#_promotion_and_coercion"></a> 1.6.3。促进和强迫</h4>
<div class="sect4">
<h5 id="_number_promotion"><a class="anchor" href="#_number_promotion"></a>号码促销</h5>
<div class="paragraph">
<p>数升法则在<a href="#_math_operations">数学运算</a>部分中指定。</p>
</div>
</div>
<div class="sect4">
<h5 id="closure-coercion"><a class="anchor" href="#closure-coercion"></a>强制关闭</h5>
<div class="sect5">
<h6 id="_assigning_a_closure_to_a_sam_type"><a class="anchor" href="#_assigning_a_closure_to_a_sam_type"></a>为SAM类型分配闭包</h6>
<div class="paragraph">
<p>SAM类型是定义单个抽象方法的类型。这包括：</p>
</div>
<div class="listingblock">
<div class="title">功能接口</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Predicate<T> {
    boolean accept(T obj)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">单一抽象方法的抽象类</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Greeter {
    abstract String getName()
    void greet() {
        println "Hello, $name"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用以下命令将任何闭包转换为SAM类型<code>as</code>操作员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Predicate filter = { it.contains 'G' } as Predicate
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' } as Greeter
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而<code>as Type</code>自Groovy 2.2.0起，表达式是可选的。您可以忽略它，只需编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Predicate filter = { it.contains 'G' }
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' }
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着您也可以使用方法指针，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">boolean doFilter(String s) { s.contains('G') }

Predicate filter = this.&doFilter
assert filter.accept('Groovy') == true

Greeter greeter = GroovySystem.&getVersion
greeter.greet()</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_calling_a_method_accepting_a_sam_type_with_a_closure"><a class="anchor" href="#_calling_a_method_accepting_a_sam_type_with_a_closure"></a>用闭包调用接受SAM类型的方法</h6>
<div class="paragraph">
<p>关闭SAM类型强制的第二个，可能是更重要的用例是调用一个接受SAM类型的方法。想象一下以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public <T> List<T> filter(List<T> source, Predicate<T> predicate) {
    source.findAll { predicate.accept(it) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用闭包调用它，而无需创建接口的显式实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert filter(['Java','Groovy'], { it.contains 'G'} as Predicate) == ['Groovy']</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是从Groovy 2.2.0开始，您还可以省略显式强制并像使用闭包一样调用该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert filter(['Java','Groovy']) { it.contains 'G'} == ['Groovy']</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，这具有使您可以将闭包语法用于方法调用的优势，也就是说，将闭包置于括号之外，从而提高了代码的可读性。</p>
</div>
</div>
<div class="sect5">
<h6 id="_closure_to_arbitrary_type_coercion"><a class="anchor" href="#_closure_to_arbitrary_type_coercion"></a>对任意类型强制的关闭</h6>
<div class="paragraph">
<p>除SAM类型外，闭包还可以强制为任何类型，尤其是接口。让我们定义以下接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface FooBar {
    int foo()
    void bar()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>as</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def impl = { println 'ok'; 123 } as FooBar</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将产生一个使用闭包实现所有方法的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert impl.foo() == 123
impl.bar()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是也有可能强迫任何一个类关闭。例如，我们可以替换<code>interface</code>我们定义的<code>class</code>无需更改断言：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class FooBar {
    int foo() { 1 }
    void bar() { println 'bar' }
}

def impl = { println 'ok'; 123 } as FooBar

assert impl.foo() == 123
impl.bar()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_map_to_type_coercion"><a class="anchor" href="#_map_to_type_coercion"></a>映射为强制类型</h5>
<div class="paragraph">
<p>通常，使用单个闭包来实现具有多个方法的接口或类不是可行的方法。或者，Groovy允许您将地图强制为接口或类。在这种情况下，映射的键将解释为方法名称，而值则是方法实现。以下示例说明了将地图强制转换为<code>Iterator</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map
map = [
  i: 10,
  hasNext: { map.i > 0 },
  next: { map.i-- },
]
def iter = map as Iterator</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，这是一个相当人为的示例，但说明了这一概念。您只需要实现实际调用的那些方法，但是如果调用的方法在地图中不存在，则<code>MissingMethodException</code>或<code>UnsupportedOperationException</code>取决于传递给调用的参数，将抛出该异常，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface X {
    void f()
    void g(int n)
    void h(String s, int n)
}

x = [ f: {println "f called"} ] as X
x.f() // method exists
x.g() // MissingMethodException here
x.g(5) // UnsupportedOperationException here</code></pre>
</div>
</div>
<div class="paragraph">
<p>异常的类型取决于调用本身：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MissingMethodException</code>如果调用的参数与接口/类的参数不匹配</p>
</li>
<li>
<p><code>UnsupportedOperationException</code>如果调用的参数与接口/类的重载方法之一匹配</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_string_to_enum_coercion"><a class="anchor" href="#_string_to_enum_coercion"></a>强制枚举的字符串</h5>
<div class="paragraph">
<p>Groovy允许透明<code>String</code> （要么<code>GString</code> ）枚举值强制。假设您定义了以下枚举：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">enum State {
    up,
    down
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么您可以为枚举分配一个字符串，而不必使用显式<code>as</code>强迫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">State st = 'up'
assert st == State.up</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用<code>GString</code>作为值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def val = "up"
State st = "${val}"
assert st == State.up</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这会引发运行时错误（ <code>IllegalArgumentException</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">State st = 'not an enum value'</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，还可以在switch语句中使用隐式强制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">State switchState(State st) {
    switch (st) {
        case 'up':
            return State.down // explicit constant
        case 'down':
            return 'up' // implicit coercion for return types
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特别要看<code>case</code>使用字符串常量。但是，如果您调用的方法将枚举与<code>String</code>参数，您仍然必须使用显式<code>as</code>强迫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert switchState('up' as State) == State.down
assert switchState(State.down) == State.up</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom_type_coercion"><a class="anchor" href="#_custom_type_coercion"></a>自定义类型强制</h5>
<div class="paragraph">
<p>一个班级可以通过实施<code>asType</code>方法。使用以下命令调用自定义强制<code>as</code>运算符，并且从不隐式。例如，假设您定义了两个类， <code>Polar</code>和<code>Cartesian</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Polar {
    double r
    double phi
}
class Cartesian {
   double x
   double y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且您要从极坐标转换为笛卡尔坐标。一种方法是定义<code>asType</code>中的方法<code>Polar</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def asType(Class target) {
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许您使用<code>as</code>强制运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sigma = 1E-16
def polar = new Polar(r:1.0,phi:PI/2)
def cartesian = polar as Cartesian
assert abs(cartesian.x-sigma) < sigma</code></pre>
</div>
</div>
<div class="paragraph">
<p>放在一起， <code>Polar</code>类看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Polar {
    double r
    double phi
    def asType(Class target) {
        if (Cartesian==target) {
            return new Cartesian(x: r*cos(phi), y: r*sin(phi))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但也可以定义<code>asType</code>外面的<code>Polar</code>类，如果您想为“封闭”类或您不拥有源代码的类定义自定义强制策略，例如使用元类，则可以使用该类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Polar.metaClass.asType = { Class target ->
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_class_literals_vs_variables_and_the_as_operator"><a class="anchor" href="#_class_literals_vs_variables_and_the_as_operator"></a>类文字，变量和as运算符</h5>
<div class="paragraph">
<p>使用<code>as</code>仅当您具有对类的静态引用时，才可以使用关键字，例如以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter {
    void greet()
}
def greeter = { println 'Hello, Groovy!' } as Greeter // Greeter is known statically
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果您通过反思（例如通过调用）获得课程，该怎么办<code>Class.forName</code> ？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Class clazz = Class.forName('Greeter')</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试使用对类的引用<code>as</code>关键字将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">greeter = { println 'Hello, Groovy!' } as clazz
// throws:
// unable to resolve class clazz
// @ line 9, column 40.
//   greeter = { println 'Hello, Groovy!' } as clazz</code></pre>
</div>
</div>
<div class="paragraph">
<p>之所以失败，是因为<code>as</code>关键字仅适用于类文字。相反，您需要致电<code>asType</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">greeter = { println 'Hello, Groovy!' }.asType(clazz)
greeter.greet()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optionality"><a class="anchor" href="#_optionality"></a> 1.6.4。可选性</h4>
<div class="sect4">
<h5 id="_optional_parentheses"><a class="anchor" href="#_optional_parentheses"></a>可选括号</h5>
<div class="paragraph">
<p>如果至少有一个参数并且没有歧义，则方法调用可以省略括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println 'Hello World'
def maximum = Math.max 5, 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于没有参数或模棱两可的方法调用，必须使用括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println()
println(Math.max(5, 10))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_optional_semicolons"><a class="anchor" href="#_optional_semicolons"></a>可选分号</h5>
<div class="paragraph">
<p>在Groovy中，如果行仅包含一个语句，则可以省略行末的分号。</p>
</div>
<div class="paragraph">
<p>这意味着：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert true;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以更习惯地写为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert true</code></pre>
</div>
</div>
<div class="paragraph">
<p>一行中的多个语句需要用分号将它们分开：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">boolean a = true; assert a</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_optional_return_keyword"><a class="anchor" href="#_optional_return_keyword"></a>可选的return关键字</h5>
<div class="paragraph">
<p>在Groovy中，返回在方法或闭包中评估的最后一个表达式。这意味着<code>return</code>关键字是可选的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int add(int a, int b) {
    return a+b
}
assert add(1, 2) == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以缩短为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int add(int a, int b) {
    a+b
}
assert add(1, 2) == 3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_optional_public_keyword"><a class="anchor" href="#_optional_public_keyword"></a>可选的公共关键字</h5>
<div class="paragraph">
<p>默认情况下，Groovy类和方法是<code>public</code> 。因此本课：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class Server {
    public String toString() { "a server" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与此类相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Server {
    String toString() { "a server" }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Groovy-Truth"><a class="anchor" href="#Groovy-Truth"></a> 1.6.5。时髦的真相</h4>
<div class="paragraph">
<p>Groovy通过应用下面给出的规则来确定一个表达式是真还是假。</p>
</div>
<div class="sect4">
<h5 id="_boolean_expressions"><a class="anchor" href="#_boolean_expressions"></a>布尔表达式</h5>
<div class="paragraph">
<p>如果相应的布尔值为<code>true</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert true
assert !false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_collections_and_arrays"><a class="anchor" href="#_collections_and_arrays"></a>集合和数组</h5>
<div class="paragraph">
<p>非空集合和数组为真。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [1, 2, 3]
assert ![]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_matchers"><a class="anchor" href="#_matchers"></a>匹配器</h5>
<div class="paragraph">
<p>如果Matcher至少有一场比赛，则为True。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ('a' =~ /a/)
assert !('a' =~ /b/)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_iterators_and_enumerations"><a class="anchor" href="#_iterators_and_enumerations"></a>迭代器和枚举</h5>
<div class="paragraph">
<p>具有其他元素的迭代器和枚举被强制为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [0].iterator()
assert ![].iterator()
Vector v = [0] as Vector
Enumeration enumeration = v.elements()
assert enumeration
enumeration.nextElement()
assert !enumeration</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_maps_2"><a class="anchor" href="#_maps_2"></a>地图</h5>
<div class="paragraph">
<p>非空Maps评估为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['one' : 1]
assert ![:]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_strings"><a class="anchor" href="#_strings"></a>弦乐</h5>
<div class="paragraph">
<p>非空字符串，GString和CharSequences被强制为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 'a'
assert !''
def nonEmpty = 'a'
assert "$nonEmpty"
def empty = ''
assert !"$empty"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_numbers_2"><a class="anchor" href="#_numbers_2"></a>号码</h5>
<div class="paragraph">
<p>非零数字为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 1
assert 3.5
assert !0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_object_references"><a class="anchor" href="#_object_references"></a>对象引用</h5>
<div class="paragraph">
<p>非空对象引用被强制为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new Object()
assert !null</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_customizing_the_truth_with_asboolean_methods"><a class="anchor" href="#_customizing_the_truth_with_asboolean_methods"></a>使用asBoolean（）方法自定义真相</h5>
<div class="paragraph">
<p>为了自定义groovy是否将您的对象评估为<code>true</code>要么<code>false</code>实施<code>asBoolean()</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Color {
    String name

    boolean asBoolean(){
        name == 'green' ? true : false
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy将调用此方法将您的对象强制为布尔值，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new Color(name: 'green')
assert !new Color(name: 'red')</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_typing"><a class="anchor" href="#_typing"></a> 1.6.6。打字</h4>
<div class="sect4">
<h5 id="_optional_typing"><a class="anchor" href="#_optional_typing"></a>可选输入</h5>
<div class="paragraph">
<p>可选类型是一种想法，即使您没有将显式类型放在变量上，程序也可以运行。作为一种动态语言，Groovy自然地实现了该功能，例如，在声明变量时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String aString = 'foo'                      <i class="conum" data-value="1"></i><b>(1)</b>
assert aString.toUpperCase()                <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>foo</code>是使用显式类型声明的<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以打电话给<code>toUpperCase</code>上的方法<code>String</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Groovy将让您编写以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def aString = 'foo'                         <i class="conum" data-value="1"></i><b>(1)</b>
assert aString.toUpperCase()                <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>foo</code>使用声明<code>def</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们仍然可以致电<code>toUpperCase</code>方法，因为类型<code>aString</code>在运行时解决</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，在这里使用显式类型都没关系。当您将此功能与<a href="#static-type-checking">静态类型检查</a>结合使用时，这特别有趣，因为类型检查器会执行类型推断。</p>
</div>
<div class="paragraph">
<p>同样，Groovy也不强制在方法中声明参数的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String concat(String a, String b) {
    a+b
}
assert concat('foo','bar') == 'foobar'</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用重写<code>def</code>作为返回类型和参数类型，以便利用鸭子类型，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def concat(def a, def b) {                              <i class="conum" data-value="1"></i><b>(1)</b>
    a+b
}
assert concat('foo','bar') == 'foobar'                  <i class="conum" data-value="2"></i><b>(2)</b>
assert concat(1,2) == 3                                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>返回类型和参数类型都使用<code>def</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>它使得可以将方法与<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>而且还有<code>int</code>自从<code>plus</code>方法已定义</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用<code>def</code>建议使用此处的关键字来描述应该适用于任何类型的方法的意图，但是从技术上讲，我们可以使用<code>Object</code>相反，结果将是相同的： <code>def</code>在Groovy中，严格等于使用<code>Object</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最终，可以同时从返回类型和描述符中删除该类型。但是，如果要将其从返回类型中删除，则需要为该方法添加一个显式修饰符，以便编译器可以在方法声明和方法调用之间有所不同，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">private concat(a,b) {                                   <i class="conum" data-value="1"></i><b>(1)</b>
    a+b
}
assert concat('foo','bar') == 'foobar'                  <i class="conum" data-value="2"></i><b>(2)</b>
assert concat(1,2) == 3                                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果我们想省略返回类型，则必须设置一个显式修饰符。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>仍然可以与<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>还有<code>int</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">通常，在公共API的方法参数或方法返回类型中，忽略类型是不好的做法。使用时<code>def</code>在局部变量中并不是一个真正的问题，因为在方法参数上进行设置时，变量的可见性仅限于方法本身， <code>def</code>将被转换为<code>Object</code>在方法签名中，使用户很难知道哪种参数是预期的类型。这意味着您应该将其限制在显式依赖鸭子类型的情况下。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="static-type-checking"><a class="anchor" href="#static-type-checking"></a>静态类型检查</h5>
<div class="paragraph">
<p>默认情况下，Groovy在编译时执行最少的类型检查。由于它主要是一种动态语言，因此大多数静态编译器通常不会在编译时进行检查。通过运行时元编程添加的方法可能会更改类或对象的运行时行为。在下面的示例中，说明原因：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {                                                          <i class="conum" data-value="1"></i><b>(1)</b>
    String firstName
    String lastName
}
def p = new Person(firstName: 'Raymond', lastName: 'Devos')             <i class="conum" data-value="2"></i><b>(2)</b>
assert p.formattedName == 'Raymond Devos'                               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Person</code>类仅定义两个属性， <code>firstName</code>和<code>lastName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以创建一个Person的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并调用一个名为<code>formattedName</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在动态语言中，例如上面的示例这样的代码不抛出任何错误是很常见的。怎么会这样？在Java中，这通常会在编译时失败。但是，在Groovy中，它不会在编译时失败，并且如果编码正确，也不会在运行时失败。实际上，要使其在运行时工作， <strong>一种</strong>可能性是依靠运行时元编程。因此，只需在声明之后添加此行<code>Person</code>上课就足够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person.metaClass.getFormattedName = { "$delegate.firstName $delegate.lastName" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着通常，在Groovy中，您不能对对象的类型进行超出其声明类型的任何假设，即使您知道它，也无法在编译时确定将调用哪种方法，或确定哪种方法。属性将被检索。从编写DSL到测试，都有很多兴趣，这将在本手册的其他部分中进行讨论。</p>
</div>
<div class="paragraph">
<p>但是，如果您的程序不依赖动态功能，并且您来自静态世界（尤其是Java思维方式），那么在编译时不捕获此类“错误”可能会令人惊讶。正如我们在前面的示例中看到的那样，编译器无法确定这是一个错误。要使其知道，必须显式指示编译器要切换到类型检查模式。这可以通过用以下方法注释类或方法来完成： <code>@groovy.lang.TypeChecked</code> 。</p>
</div>
<div class="paragraph">
<p>激活类型检查后，编译器将执行更多工作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型推断已激活，这意味着即使您使用<code>def</code>例如，在局部变量上，类型检查器将能够从分配中推断出变量的类型</p>
</li>
<li>
<p>方法调用在编译时解决，这意味着如果未在类上声明方法，则编译器将引发错误</p>
</li>
<li>
<p>通常，您会使用静态语言找到的所有编译时错误都会出现：找不到方法，找不到属性，方法调用的类型不兼容，数字精度错误等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在本节中，我们将描述各种情况下类型检查器的行为，并说明使用限制<code>@TypeChecked</code>在您的代码上。</p>
</div>
<div class="sect5">
<h6 id="_the_code_typechecked_code_annotation"><a class="anchor" href="#_the_code_typechecked_code_annotation"></a>的<code>@TypeChecked</code>注解</h6>
<div class="sect6">
<h7 id="_activating_type_checking_at_compile_time"><a class="anchor" href="#_activating_type_checking_at_compile_time"></a>在编译时激活类型检查</h7>
<div class="paragraph">
<p>的<code>groovy.lang.TypeChecked</code>启用注释的类型检查。可以放在一个类上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
class Calculator {
    int sum(int x, int y) { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在方法上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calculator {
    @groovy.transform.TypeChecked
    int sum(int x, int y) { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，将对带注释的类的所有方法，属性，字段，内部类...进行类型检查，而在第二种情况下，将仅对方法和其可能包含的闭包或匿名内部类进行类型检查。</p>
</div>
</div>
<div class="sect6">
<h7 id="_skipping_sections"><a class="anchor" href="#_skipping_sections"></a>跳过部分</h7>
<div class="paragraph">
<p>类型检查的范围可以受到限制。例如，如果对一个类进行了类型检查，则可以指示类型检查器跳过方法，方法是使用注释<code>@TypeChecked(TypeCheckingMode.SKIP)</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TypeChecked
import groovy.transform.TypeCheckingMode

@TypeChecked                                        <i class="conum" data-value="1"></i><b>(1)</b>
class GreetingService {
    String greeting() {                             <i class="conum" data-value="2"></i><b>(2)</b>
        doGreet()
    }

    @TypeChecked(TypeCheckingMode.SKIP)             <i class="conum" data-value="3"></i><b>(3)</b>
    private String doGreet() {
        def b = new SentenceBuilder()
        b.Hello.my.name.is.John                     <i class="conum" data-value="4"></i><b>(4)</b>
        b
    }
}
def s = new GreetingService()
assert s.greeting() == 'Hello my name is John'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>GreetingService</code>类标记为已检查类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>所以<code>greeting</code>方法自动类型检查</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>但<code>doGreet</code>标有<code>SKIP</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>类型检查器不会抱怨这里缺少属性</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在上一个示例中， <code>SentenceBuilder</code>依靠动态代码。没有真正的<code>Hello</code>方法或属性，因此类型检查器通常会抱怨并且编译会失败。由于使用构建器的方法标记为<code>TypeCheckingMode.SKIP</code> ，此方法将<em>跳过</em>类型检查，因此即使类的其余部分都经过类型检查，代码也将编译。</p>
</div>
<div class="paragraph">
<p>以下各节描述了Groovy中类型检查的语义。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_type_checking_assignments"><a class="anchor" href="#_type_checking_assignments"></a>类型检查分配</h6>
<div class="paragraph">
<p>一个东西<code>o</code>类型的<code>A</code>可以分配给类型的变量<code>T</code>当且仅当：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code>等于<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Date now = new Date()</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是其中之一<code>String</code> ， <code>boolean</code> ， <code>Boolean</code>要么<code>Class</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String s = new Date() // implicit call to toString
Boolean boxed = 'some string'       // Groovy truth
boolean prim = 'some string'        // Groovy truth
Class clazz = 'java.lang.String'    // class coercion</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>o</code>为null并且<code>T</code>不是原始类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String s = null         // passes
int i = null            // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个数组， <code>A</code>是一个数组，组件类型为<code>A</code>可分配给的组件类型<code>T</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int[] i = new int[4]        // passes
int[] i = new String[4]     // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个数组， <code>A</code>是列表和组件类型<code>A</code>可分配给的组件类型<code>T</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int[] i = [1,2,3]               // passes
int[] i = [1,2, new Date()]     // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是...的超类<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">AbstractList list = new ArrayList()     // passes
LinkedList list = new ArrayList()       // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是由实现的接口<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">List list = new ArrayList()             // passes
RandomAccess list = new LinkedList()    // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>要么<code>A</code>是原始类型，它们的装箱类型是可分配的</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int i = 0
Integer bi = 1
int x = new Integer(123)
double d = new Float(5f)</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>延伸<code>groovy.lang.Closure</code>和<code>A</code>是SAM类型（单个抽象方法类型）</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Runnable r = { println 'Hello' }
interface SAMType {
    int doSomething()
}
SAMType sam = { 123 }
assert sam.doSomething() == 123
abstract class AbstractSAM {
    int calc() { 2* value() }
    abstract int value()
}
AbstractSAM c = { 123 }
assert c.calc() == 246</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>和<code>A</code>从获得<code>java.lang.Number</code>并符合下表</p>
</li>
</ul>
</div>
<table id="number-assignment" class="tableblock frame-all grid-all spread">
<caption class="title">表3。数字类型（java.lang。XXX）</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Ť</th>
<th class="tableblock halign-left valign-top">一种</th>
<th class="tableblock halign-left valign-top">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal或BigInteger外的任何值</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Double d1 = 4d
Double d2 = 4f
Double d3 = 4l
Double d4 = 4i
Double d5 = (short) 4
Double d6 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger或Double外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Float f1 = 4f
Float f2 = 4l
Float f3 = 4i
Float f4 = (short) 4
Float f5 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger，Double或Float外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Long l1 = 4l
Long l2 = 4i
Long l3 = (short) 4
Long l4 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger，Double，Float或Long外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Integer i1 = 4i
Integer i2 = (short) 4
Integer i3 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger，Double，Float，Long或Integer外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Short s1 = (short) 4
Short s2 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Byte b1 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="_list_and_map_constructors"><a class="anchor" href="#_list_and_map_constructors"></a>列表和地图构造函数</h6>
<div class="paragraph">
<p>除上述分配规则外，如果认为分配无效，则在类型检查模式下使用<em>列表</em>文字或<em>地图</em>文字<code>A</code>可以分配给类型的变量<code>T</code>如果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>赋值是一个变量声明， <code>A</code>是列表文字，并且<code>T</code>有一个构造函数，其参数与列表文字中元素的类型匹配</p>
</li>
<li>
<p>赋值是一个变量声明， <code>A</code>是地图文字， <code>T</code>具有无参数构造函数和每个映射键的属性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，代替编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person classic = new Person('Ada','Lovelace')</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用“列表构造函数”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person list = ['Ada','Lovelace']</code></pre>
</div>
</div>
<div class="paragraph">
<p>或“地图构造函数”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person map = [firstName:'Ada', lastName:'Lovelace']</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用地图构造函数，则会对地图的键进行其他检查，以检查是否定义了相同名称的属性。例如，以下将在编译时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person map = [firstName:'Ada', lastName:'Lovelace', age: 24]     <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类型检查器将引发错误<code>No such property: age for class: Person</code>在编译时</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_method_resolution"><a class="anchor" href="#_method_resolution"></a>方法解析</h6>
<div class="paragraph">
<p>在类型检查模式下，方法在编译时解析。解析按名称和参数进行。返回类型与方法选择无关。参数类型与遵循这些规则的参数类型匹配：</p>
</div>
<div class="paragraph">
<p>争论<code>o</code>类型的<code>A</code>可以用于类型的参数<code>T</code>当且仅当：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code>等于<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int sum(int x, int y) {
    x+y
}
assert sum(3,4) == 7</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个<code>String</code>和<code>A</code>是一个<code>GString</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(String str) {
    "Result: $str"
}
assert format("${3+4}") == "Result: 7"</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>o</code>为null并且<code>T</code>不是原始类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(int value) {
    "Result: $value"
}
assert format(7) == "Result: 7"
format(null)           // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个数组， <code>A</code>是一个数组，组件类型为<code>A</code>可分配给的组件类型<code>T</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(String[] values) {
    "Result: ${values.join(' ')}"
}
assert format(['a','b'] as String[]) == "Result: a b"
format([1,2] as int[])              // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是...的超类<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(AbstractList list) {
    list.join(',')
}
format(new ArrayList())              // passes
String format(LinkedList list) {
    list.join(',')
}
format(new ArrayList())              // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是由实现的接口<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(List list) {
    list.join(',')
}
format(new ArrayList())                  // passes
String format(RandomAccess list) {
    'foo'
}
format(new LinkedList())                 // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>要么<code>A</code>是原始类型，它们的装箱类型是可分配的</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int sum(int x, Integer y) {
    x+y
}
assert sum(3, new Integer(4)) == 7
assert sum(new Integer(3), 4) == 7
assert sum(new Integer(3), new Integer(4)) == 7
assert sum(new Integer(3), 4) == 7</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>延伸<code>groovy.lang.Closure</code>和<code>A</code>是SAM类型（单个抽象方法类型）</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface SAMType {
    int doSomething()
}
int twice(SAMType sam) { 2*sam.doSomething() }
assert twice { 123 } == 246
abstract class AbstractSAM {
    int calc() { 2* value() }
    abstract int value()
}
int eightTimes(AbstractSAM sam) { 4*sam.calc() }
assert eightTimes { 123 } == 984</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>和<code>A</code>从获得<code>java.lang.Number</code>并遵守与<a href="#number-assignment">数字分配</a>相同的规则</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在编译时找不到具有适当名称和参数的方法，则会引发错误。以下示例说明了与“常规” Groovy的区别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyService {
    void doSomething() {
        printLine 'Do something'            <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>printLine</code>是一个错误，但是由于我们处于动态模式，因此在编译时不会捕获该错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>上面的示例显示了Groovy将能够编译的类。但是，如果您尝试创建一个实例<code>MyService</code>并致电<code>doSomething</code>方法，那么它将<strong>在运行时</strong>失败，因为<code>printLine</code>不存在。当然，我们已经展示了Groovy如何使它成为一个完全有效的调用，例如通过捕获<code>MethodMissingException</code>或实现自定义元类，但是如果您知道自己不在这种情况下， <code>@TypeChecked</code>派上用场了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
class MyService {
    void doSomething() {
        printLine 'Do something'            <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>printLine</code>这是编译时错误吗</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>只是添加<code>@TypeChecked</code>将触发编译时方法解析。类型检查器将尝试查找方法<code>printLine</code>接受<code>String</code>在<code>MyService</code>类，但找不到一个。它将失败，并显示以下消息：</p>
</div>
<div class="paragraph">
<p><code>Cannot find matching method MyService#printLine(java.lang.String)</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">了解类型检查器背后的逻辑很重要：它是编译时检查，因此根据定义，类型检查器不知道您执行的任何类型的<strong>运行时</strong>元编程。这意味着没有<code>@TypeChecked</code>如果激活类型检查，将<strong>不再</strong>编译。如果您想到鸭子输入，尤其如此：<br>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck {
    void quack() {              <i class="conum" data-value="1"></i><b>(1)</b>
        println 'Quack!'
    }
}
class QuackingBird {
    void quack() {              <i class="conum" data-value="2"></i><b>(2)</b>
        println 'Quack!'
    }
}
@groovy.transform.TypeChecked
void accept(quacker) {
    quacker.quack()             <i class="conum" data-value="3"></i><b>(3)</b>
}
accept(new Duck())              <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们定义一个<code>Duck</code>定义一个<code>quack</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们定义另一个<code>QuackingBird</code>类还定义了一个<code>quack</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>quacker</code>是松散类型的，因此由于该方法是<code>@TypeChecked</code> ，我们将获得一个编译时错误</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>即使在非类型检查的Groovy中，这也会通过</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有一些可能的解决方法，例如引入接口，但是基本上，通过激活类型检查，您可以获得类型安全性，但是却失去了该语言的某些功能。希望Groovy引入一些功能，例如流类型，以减少类型检查和非类型检查的Groovy之间的差距。</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="type-inference"><a class="anchor" href="#type-inference"></a>类型推断</h6>
<div class="sect6">
<h7 id="_principles"><a class="anchor" href="#_principles"></a>原则</h7>
<div class="paragraph">
<p>当代码带有注释时<code>@TypeChecked</code> ，编译器执行类型推断。它不仅仅依赖于静态类型，而且还使用各种技术来推断变量的类型，返回类型，文字等等。这样即使激活类型检查器，代码也可以保持尽可能的简洁。</p>
</div>
<div class="paragraph">
<p>最简单的示例是推断变量的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def message = 'Welcome to Groovy!'              <i class="conum" data-value="1"></i><b>(1)</b>
println message.toUpperCase()                   <i class="conum" data-value="2"></i><b>(2)</b>
println message.upper() // compile time error   <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>def</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>呼唤<code>toUpperCase</code>由类型检查器允许</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>呼唤<code>upper</code>将在编译时失败</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>之所以打电话给<code>toUpperCase</code>作品是因为<code>message</code>被<em>推断</em>为<code>String</code> 。</p>
</div>
</div>
<div class="sect6">
<h7 id="_variables_vs_fields_in_type_inference"><a class="anchor" href="#_variables_vs_fields_in_type_inference"></a>类型推断中的变量与字段</h7>
<div class="paragraph">
<p>值得注意的是，尽管编译器对局部变量执行类型推断，但它<strong>不对</strong>字段执行任何类型的推断，始终回退到<strong>声明</strong>的字段<strong>类型</strong> 。为了说明这一点，让我们看一下这个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeClass {
    def someUntypedField                                                                <i class="conum" data-value="1"></i><b>(1)</b>
    String someTypedField                                                               <i class="conum" data-value="2"></i><b>(2)</b>

    void someMethod() {
        someUntypedField = '123'                                                        <i class="conum" data-value="3"></i><b>(3)</b>
        someUntypedField = someUntypedField.toUpperCase()  // compile-time error        <i class="conum" data-value="4"></i><b>(4)</b>
    }

    void someSafeMethod() {
        someTypedField = '123'                                                          <i class="conum" data-value="5"></i><b>(5)</b>
        someTypedField = someTypedField.toUpperCase()                                   <i class="conum" data-value="6"></i><b>(6)</b>
    }

    void someMethodUsingLocalVariable() {
        def localVariable = '123'                                                       <i class="conum" data-value="7"></i><b>(7)</b>
        someUntypedField = localVariable.toUpperCase()                                  <i class="conum" data-value="8"></i><b>(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>someUntypedField</code>用途<code>def</code>作为声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>someTypedField</code>用途<code>String</code>作为声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以分配<strong>任何东西</strong>给<code>someUntypedField</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>尚未致电<code>toUpperCase</code>在编译时失败，因为该字段未正确键入</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>我们可以分配一个<code>String</code>到类型的字段<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>而这次<code>toUpperCase</code>被允许</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>如果我们分配一个<code>String</code>到局部变量</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后打电话<code>toUpperCase</code>允许在局部变量上</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为什么会有这样的差异？原因是<em>线程安全</em> 。在编译的时候，我们不能让有关字段的类型<strong>的任何</strong>保证。任何线程都可以随时访问任何字段，并且在方法中为某个字段分配某种类型的变量并在第二行使用该时间之间，另一个线程可能已更改了该字段的内容。局部变量不是这种情况：我们知道它们是否“转义”，因此我们可以确保变量的类型在一段时间内是恒定的（或不是恒定的）。请注意，即使字段为final，JVM也无法对此作出保证，因此，如果字段为final，则类型检查器的行为也不会有所不同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这是我们建议使用<strong>类型</strong>字段的原因之一。使用时<code>def</code>由于类型推断，对于局部变量来说是完全可以的，对于字段来说，情况并非如此，字段也属于类的公共API，因此类型很重要。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect6">
<h7 id="_collection_literal_type_inference"><a class="anchor" href="#_collection_literal_type_inference"></a>集合文字类型推断</h7>
<div class="paragraph">
<p>Groovy提供了各种类型文字的语法。Groovy中有三种本机集合文字：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>列表，使用<code>[]</code>文字</p>
</li>
<li>
<p>地图，使用<code>[:]</code>文字</p>
</li>
<li>
<p>范围，使用<code>from..to</code> （包括）和<code>from..<to</code> （独家）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>文字的推断类型取决于文字的元素，如下表所示：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:40%">
<col style="width:60%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">文字</th>
<th class="tableblock halign-left valign-top">推断类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = []</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.List</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = ['foo','bar']</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.List<String></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = ["${foo}","${bar}"]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.List<GString></code>小心一点<code>GString</code> <strong>不是</strong> <code>String</code> ！</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [:]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.LinkedHashMap</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map1 = [someKey: 'someValue']
def map2 = ['someKey': 'someValue']</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.LinkedHashMap<String,String></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = ["${someKey}": 'someValue']</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.LinkedHashMap<GString,String></code>注意，关键是<code>GString</code> ！</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def intRange = (0..10)</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>groovy.lang.IntRange</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def charRange = ('a'..'z')</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>groovy.lang.Range<String></code> ：使用边界的类型推断范围的组件类型</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如您所见，除了<code>IntRange</code> ，则推断类型利用泛型类型来描述集合的内容。如果集合包含不同类型的元素，则类型检查器仍会执行组件的类型推断，但使用<a href="#section-lub">最小上限</a>的概念。</p>
</div>
</div>
<div class="sect6">
<h7 id="section-lub"><a class="anchor" href="#section-lub"></a>最小上限</h7>
<div class="paragraph">
<p>在Groovy中，两种类型的<em>最小上限</em> <code>A</code>和<code>B</code>被定义为以下类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>超类对应于的通用超类<code>A</code>和<code>B</code></p>
</li>
<li>
<p>接口对应于两者实现的接口<code>A</code>和<code>B</code></p>
</li>
<li>
<p>如果<code>A</code>要么<code>B</code>是原始类型，并且<code>A</code>不等于<code>B</code> ，最小上限<code>A</code>和<code>B</code>是其包装器类型的最小上限</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果<code>A</code>和<code>B</code>只有一个（1）通用接口，并且它们的通用超类是<code>Object</code> ，那么两者的LUB就是通用接口。</p>
</div>
<div class="paragraph">
<p>最小上限代表两者的最小类型<code>A</code>和<code>B</code>可以分配。例如，如果<code>A</code>和<code>B</code>都是<code>String</code> ，则两者的LUB（最小上限）也为<code>String</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Top {}
class Bottom1 extends Top {}
class Bottom2 extends Top {}

assert leastUpperBound(String, String) == String                    <i class="conum" data-value="1"></i><b>(1)</b>
assert leastUpperBound(ArrayList, LinkedList) == AbstractList       <i class="conum" data-value="2"></i><b>(2)</b>
assert leastUpperBound(ArrayList, List) == List                     <i class="conum" data-value="3"></i><b>(3)</b>
assert leastUpperBound(List, List) == List                          <i class="conum" data-value="4"></i><b>(4)</b>
assert leastUpperBound(Bottom1, Bottom2) == Top                     <i class="conum" data-value="5"></i><b>(5)</b>
assert leastUpperBound(List, Serializable) == Object                <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的LUB <code>String</code>和<code>String</code>是<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的LUB <code>ArrayList</code>和<code>LinkedList</code>是他们常见的超级类型<code>AbstractList</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的LUB <code>ArrayList</code>和<code>List</code>是他们唯一的通用界面，<code>List</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>两个相同接口的LUB是接口本身</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的LUB <code>Bottom1</code>和<code>Bottom2</code>是他们的超类<code>Top</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>两种没有共同点的LUB是<code>Object</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这些示例中，LUB始终可以表示为受JVM支持的普通类型。但是Groovy在内部将LUB表示为可能更复杂的类型，例如，您将无法使用它来定义变量。为了说明这一点，让我们继续下面的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Foo {}
class Top {}
class Bottom extends Top implements Serializable, Foo {}
class SerializableFooImpl implements Serializable, Foo {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的最小上限是多少<code>Bottom</code>和<code>SerializableFooImpl</code> ？他们没有共同的超级阶级（除了<code>Object</code> ），但它们确实共享2个接口（ <code>Serializable</code>和<code>Foo</code> ），因此它们的最小上限是代表两个接口（ <code>Serializable</code>和<code>Foo</code> ）。无法在源代码中定义此类型，但是Groovy知道它。</p>
</div>
<div class="paragraph">
<p>在集合类型推断（通常是泛型类型推断）的上下文中，这变得很方便，因为将组件的类型推断为最小上限。在下面的示例中，我们可以说明为什么这很重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter { void greet() }                  <i class="conum" data-value="1"></i><b>(1)</b>
interface Salute { void salute() }                  <i class="conum" data-value="2"></i><b>(2)</b>

class A implements Greeter, Salute {                <i class="conum" data-value="3"></i><b>(3)</b>
    void greet() { println "Hello, I'm A!" }
    void salute() { println "Bye from A!" }
}
class B implements Greeter, Salute {                <i class="conum" data-value="4"></i><b>(4)</b>
    void greet() { println "Hello, I'm B!" }
    void salute() { println "Bye from B!" }
    void exit() { println 'No way!' }               <i class="conum" data-value="5"></i><b>(5)</b>
}
def list = [new A(), new B()]                       <i class="conum" data-value="6"></i><b>(6)</b>
list.each {
    it.greet()                                      <i class="conum" data-value="7"></i><b>(7)</b>
    it.salute()                                     <i class="conum" data-value="8"></i><b>(8)</b>
    it.exit()                                       <i class="conum" data-value="9"></i><b>(9)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Greeter</code>接口定义单个方法，<code>greet</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Salute</code>接口定义单个方法，<code>salute</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类<code>A</code>同时实现<code>Greeter</code>和<code>Salute</code>但没有显式接口可以扩展两者</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>一样<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但<code>B</code>定义一个额外的<code>exit</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>的类型<code>list</code>被推断为“ <code>A</code>和“ B””</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>所以可以打电话<code>greet</code>两者都定义了<code>A</code>和<code>B</code>通过<code>Greeter</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>可以打电话<code>salute</code>两者都定义了<code>A</code>和<code>B</code>通过<code>Salute</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>尚未致电<code>exit</code>是编译时错误，因为它不属于的LUB <code>A</code>和<code>B</code> （仅在<code>B</code> ）</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>错误消息如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - Cannot find matching method Greeter or Salute#exit()</pre>
</div>
</div>
<div class="paragraph">
<p>这表明<code>exit</code>方法都没有定义<code>Greeter</code>也不<code>Salute</code> ，这是在的最小上限中定义的两个接口<code>A</code>和<code>B</code> 。</p>
</div>
</div>
<div class="sect6">
<h7 id="_instanceof_inference"><a class="anchor" href="#_instanceof_inference"></a>推理实例</h7>
<div class="paragraph">
<p>在常规的非类型检查的Groovy中，您可以编写如下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Greeter {
    String greeting() { 'Hello' }
}

void doSomething(def o) {
    if (o instanceof Greeter) {     <i class="conum" data-value="1"></i><b>(1)</b>
        println o.greeting()        <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

doSomething(new Greeter())</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个来保护方法调用<code>instanceof</code>校验</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打电话</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该方法调用之所以有效是因为动态调度（在运行时选择了该方法）。Java中的等效代码将需要强制转换<code>o</code>到一个<code>Greeter</code>在致电之前<code>greeting</code>方法，因为方法是在编译时选择的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (o instanceof Greeter) {
    System.out.println(((Greeter)o).greeting());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，在Groovy中，即使您添加<code>@TypeChecked</code> （并因此激活类型检查） <code>doSomething</code>方法， <strong>不需要</strong>强制转换。编译器会嵌入<em>instanceof</em>推断，从而使强制类型转换成为可选内容。</p>
</div>
</div>
<div class="sect6">
<h7 id="section-flow-typing"><a class="anchor" href="#section-flow-typing"></a>流式</h7>
<div class="paragraph">
<p>流类型是类型检查模式下Groovy的重要概念，也是类型推断的扩展。这个想法是，编译器能够推断代码流中的变量类型，而不仅仅是在初始化时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTyping() {
    def o = 'foo'                       <i class="conum" data-value="1"></i><b>(1)</b>
    o = o.toUpperCase()                 <i class="conum" data-value="2"></i><b>(2)</b>
    o = 9d                              <i class="conum" data-value="3"></i><b>(3)</b>
    o = Math.sqrt(o)                    <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>第一， <code>o</code>使用声明<code>def</code>并分配了一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>编译器推断出<code>o</code>是一个<code>String</code> ，所以打电话<code>toUpperCase</code>被允许</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>o</code>被重新分配了<code>double</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>呼唤<code>Math.sqrt</code>通过编译，因为编译器知道这一点， <code>o</code>是一个<code>double</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，类型检查器<em>意识到</em>以下事实：变量的具体类型随时间而变化。特别是，如果您将最后一个分配替换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">o = 9d
o = o.toUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，类型检查器将在编译时失败，因为它知道<code>o</code>是一个<code>double</code>什么时候<code>toUpperCase</code>被调用，所以是类型错误。</p>
</div>
<div class="paragraph">
<p>重要的是要了解，使用<code>def</code>触发类型推断。流类型适用于任何类型的<strong>任何</strong>变量。声明具有显式类型的变量只会限制您可以分配给变量的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           <i class="conum" data-value="1"></i><b>(1)</b>
    list = list*.toUpperCase()          <i class="conum" data-value="2"></i><b>(2)</b>
    list = 'foo'                        <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>list</code>被声明为未选中<code>List</code>并分配了一个String的列表文字</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该行由于流类型而通过编译：类型检查器知道<code>list</code>在这一点上是<code>List<String></code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>但您不能分配一个<code>String</code>到一个<code>List</code>所以这是一个类型检查错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以注意到，即使声明的变量<strong>没有</strong>泛型信息，类型检查器也知道什么是组件类型。因此，这样的代码将使编译失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           <i class="conum" data-value="1"></i><b>(1)</b>
    list.add(1)                         <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>list</code>推断为<code>List<String></code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>所以添加一个<code>int</code>到一个<code>List<String></code>是编译时错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要解决此问题，需要在声明中添加一个显式的泛型类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List<? extends Serializable> list = []                      <i class="conum" data-value="1"></i><b>(1)</b>
    list.addAll(['a','b','c'])                                  <i class="conum" data-value="2"></i><b>(2)</b>
    list.add(1)                                                 <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>list</code>声明为<code>List<? extends Serializable></code>并初始化为空列表</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加到列表中的元素符合列表的声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>所以添加一个<code>int</code>到一个<code>List<? extends Serializable></code>被允许</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>引入了流类型以减少经典和静态Groovy之间的语义差异。特别是，请考虑以下代码在Java中的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public Integer compute(String str) {
    return str.length();
}
public String compute(Object o) {
    return "Nope";
}
// ...
Object string = "Some string";          <i class="conum" data-value="1"></i><b>(1)</b>
Object result = compute(string);        <i class="conum" data-value="2"></i><b>(2)</b>
System.out.println(result);             <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>o</code>被声明为<code>Object</code>并分配了一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们称<code>compute</code>方法<code>o</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并打印结果</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在Java中，此代码将输出<code>Nope</code> ，因为方法选择是在编译时基于<strong>声明的</strong>类型完成的。所以即使<code>o</code>是一个<code>String</code>在运行时，它仍然是<code>Object</code>被称为的版本，因为<code>o</code>被宣布为<code>Object</code> 。简而言之，在Java中，声明的类型最为重要，无论是变量类型，参数类型还是返回类型。</p>
</div>
<div class="paragraph">
<p>在Groovy中，我们可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int compute(String string) { string.length() }
String compute(Object o) { "Nope" }
Object o = 'string'
def result = compute(o)
println result</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是这次，它将返回<code>6</code> ，因为选择的方法是<strong>在运行时</strong>根据<em>实际</em>参数类型选择的。所以在运行时， <code>o</code>是一个<code>String</code>所以<code>String</code>使用变体。请注意，此行为与类型检查无关，它是Groovy通常的工作方式：动态调度。</p>
</div>
<div class="paragraph">
<p>在类型检查的Groovy中，我们要确保类型检查器<strong>在编译</strong>时选择运行时将选择的相同方法。由于语言的语义，通常这是不可能的，但是我们可以使用流类型来使事情变得更好。使用流输入<code>o</code> <em>推断</em>为<code>String</code>当。。。的时候<code>compute</code>方法会被调用，因此需要一个<code>String</code>并返回一个<code>int</code>被选中。这意味着我们可以推断该方法的返回类型为<code>int</code> ，而不是<code>String</code> 。这对于后续调用和类型安全很重要。</p>
</div>
<div class="paragraph">
<p>因此，在类型检查Groovy中，流类型是一个非常重要的概念，这也意味着<code>@TypeChecked</code>应用后，将根据<em>推断</em>的参数<em>类型</em>而不是声明的类型选择方法。这不能确保100％的类型安全，因为类型检查器<em>可能</em>选择了错误的方法，但是它确保了与动态Groovy最接近的语义。</p>
</div>
</div>
<div class="sect6">
<h7 id="_advanced_type_inference"><a class="anchor" href="#_advanced_type_inference"></a>高级类型推断</h7>
<div class="paragraph">
<p><a href="#section-flow-typing">流类型</a>和<a href="#section-lub">最小上限推断</a>的组合用于执行高级类型推断，并在多种情况下确保类型安全。特别地，程序控制结构可能会更改变量的推断类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o
if (someCondition) {
    o = new Top()                               <i class="conum" data-value="1"></i><b>(1)</b>
} else {
    o = new Bottom()                            <i class="conum" data-value="2"></i><b>(2)</b>
}
o.methodFromTop()                               <i class="conum" data-value="3"></i><b>(3)</b>
o.methodFromBottom()  // compilation error      <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果<code>someCondition</code>是真的， <code>o</code>被分配了一个<code>Top</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果<code>someCondition</code>是假的<code>o</code>被分配了一个<code>Bottom</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>呼唤<code>methodFromTop</code>是安全的</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>但是打电话<code>methodFromBottom</code>不是，所以是编译时错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当类型检查器访问<code>if/else</code>控制结构，它检查所有在<code>if/else</code>分支并计算所有分配的<a href="#section-lub">最小上限</a> 。此类型是在<code>if/else</code>块，所以在此示例中， <code>o</code>被分配了一个<code>Top</code>在里面<code>if</code>分支和一个<code>Bottom</code>在里面<code>else</code>科。这些的<a href="#section-lub">LUB</a>是<code>Top</code> ，因此在条件分支之后，编译器会推断<code>o</code>作为一个<code>Top</code> 。呼唤<code>methodFromTop</code>因此将被允许，但不允许<code>methodFromBottom</code> 。</p>
</div>
<div class="paragraph">
<p>对于闭包，尤其是闭包共享变量，存在相同的推理。闭包共享变量是在闭包外部定义但在闭包内部使用的变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def text = 'Hello, world!'                          <i class="conum" data-value="1"></i><b>(1)</b>
def closure = {
    println text                                    <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个名为<code>text</code>被宣布</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>text</code>从封闭内部使用。这是一个<em>闭包共享变量</em> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Groovy允许开发人员使用这些变量而不要求它们是最终变量。这意味着可以在闭包内部重新分配闭包共享变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String result
doSomething { String it ->
    result = "Result: $it"
}
result = result?.toUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>的问题是，一个封闭的是，可以在<strong>任意</strong>时刻执行（或不）代码的独立块。特别是， <code>doSomething</code>例如，可以是异步的。这意味着闭包的主体不属于主控制流。因此，类型检查器还会为每个闭包共享变量计算该变量所有赋值的<a href="#section-lub">LUB</a> ，并将使用该变量<code>LUB</code>作为闭包范围之外的推断类型，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o = new Top()                               <i class="conum" data-value="1"></i><b>(1)</b>
Thread.start {
    o = new Bottom()                            <i class="conum" data-value="2"></i><b>(2)</b>
}
o.methodFromTop()                               <i class="conum" data-value="3"></i><b>(3)</b>
o.methodFromBottom()  // compilation error      <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>首先为闭包共享变量分配一个<code>Top</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在封闭内，它被分配了一个<code>Bottom</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>methodFromTop</code>被允许</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>methodFromBottom</code>是编译错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这里，很明显<code>methodFromBottom</code>在编译时或运行时，不能保证调用的类型<code>o</code>将<em>有效</em>地成为<code>Bottom</code> 。可能会有，但是我们不能确定，因为它是异步的。因此，类型检查器将仅允许在<a href="#section-lub">最小上限处</a>调用，这是一个<code>Top</code> 。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_closures_and_type_inference"><a class="anchor" href="#_closures_and_type_inference"></a>闭包和类型推断</h6>
<div class="paragraph">
<p>类型检查器对闭包执行特殊的推断，从而在一侧进行附加检查并在另一侧提高了流畅性。</p>
</div>
<div class="sect6">
<h7 id="_return_type_inference"><a class="anchor" href="#_return_type_inference"></a>返回类型推断</h7>
<div class="paragraph">
<p>类型检查器能够做的第一件事是推断闭包的<em>返回类型</em> 。在下面的示例中对此进行了简单说明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
int testClosureReturnTypeInference(String arg) {
    def cl = { "Arg: $arg" }                                <i class="conum" data-value="1"></i><b>(1)</b>
    def val = cl()                                          <i class="conum" data-value="2"></i><b>(2)</b>

    val.length()                                            <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义了一个闭包，它返回一个字符串（更确切地说， <code>GString</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们调用闭包并将结果分配给变量</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类型检查器推断闭包将返回一个字符串，因此调用<code>length()</code>被允许</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如您所见，与显式声明其返回类型的方法不同，无需声明闭包的返回类型：它的类型是从闭包的主体中推断出来的。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">闭包与方法</div>
<div class="paragraph">
<p>值得注意的是，返回类型推断仅适用于闭包。尽管类型检查器可以对方法执行相同操作，但实际上并不可取： <em>通常</em> ，方法可以被覆盖，并且在静态上不可能确保所调用的方法不是覆盖的版本。因此，流类型实际上会认为方法会返回某些内容，而实际上，它可能会返回其他内容，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TypeChecked
class A {
    def compute() { 'some string' }             <i class="conum" data-value="1"></i><b>(1)</b>
    def computeFully() {
        compute().toUpperCase()                 <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
@TypeChecked
class B extends A {
    def compute() { 123 }                       <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>A</code>定义方法<code>compute</code>有效地返回一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>这将导致编译失败，因为返回类型为<code>compute</code>是<code>def</code> （又名<code>Object</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类<code>B</code>延伸<code>A</code>和重新定义<code>compute</code> ，此类型返回一个<code>int</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如您所见，如果类型检查器依赖于方法的推断返回类型（使用<a href="#section-flow-typing">流类型）</a> ，则类型检查器可以确定可以调用<code>toUpperCase</code> 。实际上这是一个<strong>错误</strong> ，因为子类可以覆盖<code>compute</code>并返回另一个对象。这里， <code>B#compute</code>返回一个<code>int</code> ，所以有人打电话<code>computeFully</code>在...的实例上<code>B</code>会看到运行时错误。编译器通过使用方法的声明的返回类型而不是推断的返回类型来防止这种情况的发生。</p>
</div>
<div class="paragraph">
<p>为了保持一致， <strong>每种</strong>方法的行为都是相同的，即使它们是静态的或最终的也是如此。</p>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="_parameter_type_inference"><a class="anchor" href="#_parameter_type_inference"></a>参数类型推断</h7>
<div class="paragraph">
<p>除了返回类型外，闭包还可以从上下文中推断出其参数类型。编译器可以通过两种方式推断参数类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过<em>隐式SAM类型强制</em></p>
</li>
<li>
<p>通过API元数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了说明这一点，让我们从一个由于类型检查器无法推断参数类型而使编译失败的示例开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
}

void inviteIf(Person p, Closure<Boolean> predicate) {           <i class="conum" data-value="1"></i><b>(1)</b>
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void failCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)
    inviteIf(p) {                                               <i class="conum" data-value="2"></i><b>(2)</b>
        it.age >= 18 // No such property: age                   <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>inviteIf</code>方法接受<code>Person</code>和一个<code>Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们称它为<code>Person</code>和一个<code>Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然而<code>it</code>不是静态地称为<code>Person</code>编译失败</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在此示例中，封闭体包含<code>it.age</code> 。使用动态的而不是类型检查的代码，这将起作用，因为<code>it</code>将是一个<code>Person</code>在运行时。不幸的是，在编译时，无法知道什么类型的<code>it</code> ，只需阅读<code>inviteIf</code> 。</p>
</div>
<div class="sect7">
<h8 id="_explicit_closure_parameters"><a class="anchor" href="#_explicit_closure_parameters"></a>显式关闭参数</h8>
<div class="paragraph">
<p>简而言之，类型检查器没有足够的上下文信息<code>inviteIf</code>静态确定类型的方法<code>it</code> 。这意味着方法调用需要这样重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">inviteIf(p) { Person it ->                                  <i class="conum" data-value="1"></i><b>(1)</b>
    it.age >= 18
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的类型<code>it</code>需要明确声明</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过明确声明<code>it</code>变量，则可以解决该问题并使此代码静态检查。</p>
</div>
</div>
<div class="sect7">
<h8 id="_parameters_inferred_from_single_abstract_method_types"><a class="anchor" href="#_parameters_inferred_from_single_abstract_method_types"></a>从单抽象方法类型推断出的参数</h8>
<div class="paragraph">
<p>对于API或框架设计人员而言，有两种方法可以使用户感到更加优雅，从而使他们不必为闭包参数声明显式类型。第一个也是最简单的方法是用SAM类型替换闭包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Predicate<On> { boolean apply(On e) }                 <i class="conum" data-value="1"></i><b>(1)</b>

void inviteIf(Person p, Predicate<Person> predicate) {          <i class="conum" data-value="2"></i><b>(2)</b>
    if (predicate.apply(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void passesCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)

    inviteIf(p) {                                               <i class="conum" data-value="3"></i><b>(3)</b>
        it.age >= 18                                            <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一个<code>SAM</code>与<code>apply</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>inviteIf</code>现在使用<code>Predicate<Person></code>代替<code>Closure<Boolean></code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>无需声明其类型<code>it</code>变了</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>it.age</code>编译正确，类型<code>it</code>从<code>Predicate#apply</code>方法签名</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">通过使用此技术，我们利用了对Groovy的<em>SAM类型</em>功能<em>自动关闭的强制</em> 。是否应使用<em>SAM类型</em>还是<em>闭包的问题</em>实际上取决于您需要执行的操作。在许多情况下，使用SAM接口就足够了，尤其是考虑到Java 8中的功能接口时。但是，闭包提供了功能接口无法访问的功能。特别是，闭包可以具有委托和所有者，并且可以在被调用之前作为对象（例如克隆，序列化，咖喱等）进行操作。它们还可以支持多个签名（多态性）。因此，如果您需要这种操作，最好切换到最高级的类型推断注释，如下所述。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>关于闭包参数类型推断（即<em>无需</em>确定地声明它们<em>而</em>静态地确定闭包的参数类型）时，需要解决的原始问题是Groovy类型系统继承了Java类型。系统，不足以描述参数的类型。</p>
</div>
</div>
<div class="sect7">
<h8 id="_the_code_closureparams_code_annotation"><a class="anchor" href="#_the_code_closureparams_code_annotation"></a>的<code>@ClosureParams</code>注解</h8>
<div class="paragraph">
<p>Groovy提供了一个注释， <code>@ClosureParams</code>旨在完成类型信息。此注释主要针对希望通过提供类型推断元数据来扩展类型检查器功能的框架和API开发人员。如果您的库使用了闭包，并且您也想要最大程度的工具支持，那么这一点很重要。</p>
</div>
<div class="paragraph">
<p>让我们通过固定原始示例来说明这一点，并介绍<code>@ClosureParams</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.ClosureParams
import groovy.transform.stc.FirstParam
void inviteIf(Person p, @ClosureParams(FirstParam) Closure<Boolean> predicate) {        <i class="conum" data-value="1"></i><b>(1)</b>
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}
inviteIf(p) {                                                                       <i class="conum" data-value="2"></i><b>(2)</b>
    it.age >= 18
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>闭包参数用<code>@ClosureParams</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>不必使用显式类型<code>it</code> ，据推测</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>@ClosureParams</code>注记最少接受一个参数，该参数称为<em>类型hint</em> 。类型提示是一个类，它负责在编译时为闭包完成类型信息。在此示例中，使用的类型提示是<code>groovy.transform.stc.FirstParam</code>它向类型检查器指示闭包将接受一个参数，该参数的类型是方法的第一个参数的类型。在这种情况下，方法的第一个参数是<code>Person</code> ，因此它向类型检查器指示闭包的第一个参数实际上是a <code>Person</code> 。</p>
</div>
<div class="paragraph">
<p>第二个可选参数名为<em>options</em> 。它的语义取决于<em>类型提示</em>类。Groovy带有各种捆绑的类型提示，如下表所示：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表4。预定义类型提示</caption>
<colgroup>
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:66.6668%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型提示</th>
<th class="tableblock halign-left valign-top">多态的？</th>
<th class="tableblock halign-left valign-top">说明和示例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FirstParam</code><br>
<code>SecondParam</code><br>
<code>ThirdParam</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法的第一个（分别为第二个，第三个）参数类型<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FirstParam
void doSomething(String str, @ClosureParams(FirstParam) Closure c) {
    c(str)
}
doSomething('foo') { println it.toUpperCase() }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.SecondParam
void withHash(String str, int seed, @ClosureParams(SecondParam) Closure c) {
    c(31*str.hashCode()+seed)
}
withHash('foo', (int)System.currentTimeMillis()) {
    int mod = it%2
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.ThirdParam
String format(String prefix, String postfix, String o, @ClosureParams(ThirdParam) Closure c) {
    "$prefix${c(o)}$postfix"
}
assert format('foo', 'bar', 'baz') {
    it.toUpperCase()
} == 'fooBAZbar'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FirstParam.FirstGenericType</code><br>
<code>SecondParam.FirstGenericType</code><br>
<code>ThirdParam.FirstGenericType</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法的第一个（分别是第二个，第三个）参数的第一个通用类型<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FirstParam
public <T> void doSomething(List<T> strings, @ClosureParams(FirstParam.FirstGenericType) Closure c) {
    strings.each {
        c(it)
    }
}
doSomething(['foo','bar']) { println it.toUpperCase() }
doSomething([1,2,3]) { println(2*it) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>的变体<code>SecondGenericType</code>和<code>ThirdGenericType</code>为所有人而存在<code>FirstParam</code> ， <code>SecondParam</code>和<code>ThirdParam</code>输入提示。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>SimpleType</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型提示，其关闭参数的类型来自options字符串。<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.SimpleType
public void doSomething(@ClosureParams(value=SimpleType,options=['java.lang.String','int']) Closure c) {
    c('foo',3)
}
doSomething { str, len ->
    assert str.length() == len
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此类型提示支持<strong>单个</strong>签名，并且使用完全限定的类型名称或原始类型将每个参数指定为<em>options</em>数组的值。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>MapEntryOrKeyValue</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>闭包的专用类型提示<code>Map.Entry</code>单个参数，或与键和值相对应的两个参数。<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.MapEntryOrKeyValue
public <K,V> void doSomething(Map<K,V> map, @ClosureParams(MapEntryOrKeyValue) Closure c) {
    // ...
}
doSomething([a: 'A']) { k,v ->
    assert k.toUpperCase() == v.toUpperCase()
}
doSomething([abc: 3]) { e ->
    assert e.key.length() == e.value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此类型提示<strong>要求</strong>第一个参数是<code>Map</code>类型，并根据地图实际键/值类型推断闭包参数类型。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FromAbstractTypeMethods</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>从某种类型的抽象方法推断闭包参数类型。为<strong>每个</strong>抽象方法推断出一个签名。<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromAbstractTypeMethods
abstract class Foo {
    abstract void firstSignature(int x, int y)
    abstract void secondSignature(String str)
}
void doSomething(@ClosureParams(value=FromAbstractTypeMethods, options=["Foo"]) Closure cl) {
    // ...
}
doSomething { a, b -> a+b }
doSomething { s -> s.toUpperCase() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果像上面的示例中那样有多个签名，则类型检查器将<strong>仅</strong>在每种方法的不同性时才能推断参数的类型。在上面的示例中， <code>firstSignature</code>接受两个参数， <code>secondSignature</code>接受1个参数，因此类型检查器可以根据参数数量来推断参数类型。但是请参阅下面讨论的可选的resolver class属性。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FromString</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>从<code>options</code>论点。的<code>options</code>参数由逗号分隔的非基本类型数组组成。数组的每个元素对应一个签名，元素中的每个逗号分隔签名的参数。简而言之，这是最通用的类型提示， <code>options</code>映射被<strong>解析</strong>为好像它是签名文字。尽管类型提示非常强大，但是如果可以的话，必须避免使用该类型提示，因为由于必须解析类型签名，它会增加编译时间。</p>
</div>
<div class="paragraph">
<p>闭包接受单个签名<code>String</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromString
void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {
    // ...
}
doSomething { s -> s.toUpperCase() }
doSomething { s,i -> s.toUpperCase()*i }</code></pre>
</div>
</div>
<div class="paragraph">
<p>多态闭包，接受一个<code>String</code>或一个<code>String, Integer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromString
void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {
    // ...
}
doSomething { s -> s.toUpperCase() }
doSomething { s,i -> s.toUpperCase()*i }</code></pre>
</div>
</div>
<div class="paragraph">
<p>多态闭包，接受一个<code>T</code>或一对<code>T,T</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromString
public <T> void doSomething(T e, @ClosureParams(value=FromString, options=["T","T,T"]) Closure cl) {
    // ...
}
doSomething('foo') { s -> s.toUpperCase() }
doSomething('foo') { s1,s2 -> assert s1.toUpperCase() == s2.toUpperCase() }</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">即使您使用<code>FirstParam</code> ， <code>SecondParam</code>要么<code>ThirdParam</code>作为一种类型的提示，它并不严格意味着其将被传递到闭合的参数<strong>将</strong>是第一个（相应的第二，第三）的方法调用的参数。这仅意味着闭包的参数<strong>类型</strong>将与方法调用的第一个（分别是第二个，第三个）参数的类型<strong>相同</strong> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>简而言之，缺乏<code>@ClosureParams</code>接受方法的注释<code>Closure</code> <strong>不会</strong>失败的编译。如果存在（类型可以同时存在于Java源代码和Groovy源代码中），那么类型检查器将具有<strong>更多</strong>信息并可以执行其他类型推断。这使得此功能对于框架开发人员特别有趣。</p>
</div>
<div class="paragraph">
<p>第三个可选参数名为<em>冲突解决方案策略</em> 。它可以引用一个类（从<code>ClosureSignatureConflictResolver</code> ），如果在初始推断计算完成后发现多个参数类型，则可以执行其他类型的参数解析。Groovy带有一个默认的类型解析器，该解析器不执行任何操作，而另一个则在找到多个签名时选择第一个签名。仅当找到多个签名且解析器设计为后处理器时，才调用解析器。任何需要注入类型信息的语句都必须传递通过类型提示确定的参数签名之一。然后，解析器从返回的候选签名中进行选择。</p>
</div>
</div>
</div>
<div class="sect6">
<h7 id="_code_delegatesto_code"><a class="anchor" href="#_code_delegatesto_code"></a><code>@DelegatesTo</code></h7>
<div class="paragraph">
<p>的<code>@DelegatesTo</code>类型检查器使用批注来推断委托的类型。它允许API设计人员指示编译器什么是委托类型和委托策略。的<code>@DelegatesTo</code>注释将在<a href="core-domain-specific-languages.html#section-delegatesto">特定的章节中</a>讨论。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_static_compilation"><a class="anchor" href="#_static_compilation"></a>静态编译</h5>
<div class="sect5">
<h6 id="_dynamic_vs_static"><a class="anchor" href="#_dynamic_vs_static"></a>动态与静态</h6>
<div class="paragraph">
<p>在<a href="#static-type-checking">类型检查部分</a> ，我们已经看到Groovy提供了可选的类型检查，这要归功于<code>@TypeChecked</code>注解。类型检查器在编译时运行，并对动态代码执行静态分析。无论是否启用类型检查，程序的行为都将完全相同。这意味着<code>@TypeChecked</code>对于程序的语义，注释是中性的。尽管可能有必要在源中添加类型信息，以使程序被认为是类型安全的，但最后，程序的语义是相同的。</p>
</div>
<div class="paragraph">
<p>尽管这听起来不错，但实际上存在一个问题：在编译时进行的动态代码的类型检查在定义上仅在没有运行时特定行为发生时才是正确的。例如，以下程序通过类型检查：</p>
</div>
<div id="typechecked-defeated" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.TypeChecked
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那里有两个<code>compute</code>方法。一个接受<code>String</code>并返回一个<code>int</code> ，另一个接受<code>int</code>并返回一个<code>String</code> 。如果您对此进行编译，则认为它是类型安全的： <code>compute('foobar')</code>通话会传回<code>int</code> ，并致电<code>compute</code>在这个<code>int</code>反过来会返回一个<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>现在，在致电之前<code>test()</code> ，请考虑添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Computer.metaClass.compute = { String str -> new Date() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用运行时元编程，我们实际上是在修改<code>compute(String)</code>方法，这样就不会返回提供的参数的长度，而是会返回一个<code>Date</code> 。如果执行该程序，它将在运行时失败。由于可以从任何地方的任何线程中添加此行，因此类型检查器绝对无法静态地确保不会发生这种情况。简而言之，类型检查器容易受到猴子补丁的攻击。这只是一个示例，但这说明了这样一个概念，即对动态程序进行静态分析本质上是错误的。</p>
</div>
<div class="paragraph">
<p>Groovy语言为<code>@TypeChecked</code>这实际上将确保推断为被调用的方法<strong>将</strong>在运行时有效地被调用。此注释将Groovy编译器转换为<strong>静态编译器</strong> ，在该<strong>静态编译器中</strong> ，所有方法调用都在编译时解析， <strong>并且</strong>生成的字节码确保了这种情况的发生：注释为<code>@groovy.transform.CompileStatic</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="compilestatic-annotation"><a class="anchor" href="#compilestatic-annotation"></a>的<code>@CompileStatic</code>注解</h6>
<div class="paragraph">
<p>的<code>@CompileStatic</code>注释可以添加到<code>@TypeChecked</code>可以使用注解，即在类或方法上。不必同时添加两者<code>@TypeChecked</code>和<code>@CompileStatic</code> ，作为<code>@CompileStatic</code>执行一切<code>@TypeChecked</code>可以，但是还会触发静态编译。</p>
</div>
<div class="paragraph">
<p>让我们以<a href="#typechecked-defeated">失败</a>的<a href="#typechecked-defeated">示例为例</a> ，但是这次我们替换<code>@TypeChecked</code>带有注释<code>@CompileStatic</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.CompileStatic
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}
Computer.metaClass.compute = { String str -> new Date() }
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是<strong>唯一的</strong>区别。如果我们执行此程序，这次将没有运行时错误。的<code>test</code>该方法不受猴子修补的影响，因为<code>compute</code>在其主体中调用的方法在编译时链接，因此即使<code>Computer</code>更改后，程序仍会<strong>按照类型检查器的预期运行</strong> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="_key_benefits"><a class="anchor" href="#_key_benefits"></a>主要好处</h6>
<div class="paragraph">
<p>使用有几个好处<code>@CompileStatic</code>在您的代码上：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型安全</p>
</li>
<li>
<p>对<a href="#compilestatic-annotation">猴子修补</a>免疫</p>
</li>
<li>
<p>性能提升</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>性能的提高取决于您正在执行的程序的类型。如果它受I / O约束，则静态编译代码和动态代码之间的区别几乎不会引起注意。在占用大量CPU的代码上，由于生成的字节码与Java为等效程序生成的字节码非常接近（如果不相等），因此性能得到了极大的提高。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用Groovy的<em>invokedynamic</em>版本（使用JDK 7及更高版本的人员可以访问），动态代码的性能应该与静态编译代码的性能非常接近。有时，它甚至可以更快！只有一种方法可以确定应该选择哪个版本：测量。原因是，根据您的程序<strong>和</strong>所使用的JVM，性能可能会显着不同。尤其是Groovy的<em>invokedynamic</em>版本对使用中的JVM版本非常敏感。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_type_checking_extensions"><a class="anchor" href="#_type_checking_extensions"></a> 1.6.7。类型检查扩展</h4>
<div class="sect4">
<h5 id="_writing_a_type_checking_extension"><a class="anchor" href="#_writing_a_type_checking_extension"></a>编写类型检查扩展</h5>
<div class="sect5">
<h6 id="_towards_a_smarter_type_checker"><a class="anchor" href="#_towards_a_smarter_type_checker"></a>迈向更智能的类型检查器</h6>
<div class="paragraph">
<p>尽管是动态语言，但是Groovy可以在编译时与静态类型检查器一起使用， <a href="#static-type-checking">并</a>使用<a href="#static-type-checking">@TypeChecked</a>批注启用。在这种模式下，编译器变得更加冗长，并为例如错别字，不存在的方法等引发错误，但是……这有一些局限性，其中大多数来自Groovy本质上仍然是动态语言的事实。例如，您将无法对使用标记生成器的代码使用类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def builder = new MarkupBuilder(out)
builder.html {
    head {
        // ...
    }
    body {
        p 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上一个示例中， <code>html</code> ， <code>head</code> ， <code>body</code>要么<code>p</code>方法存在。但是，如果执行代码，则它会起作用，因为Groovy使用动态调度并在运行时转换这些方法调用。在此构建器中，您可以使用的标记数量或属性没有限制，这意味着类型检查器没有机会在编译时了解所有可能的方法（标记），除非您创建了构建器例如专用于HTML。</p>
</div>
<div class="paragraph">
<p>Groovy是实现内部DSL的首选平台。灵活的语法以及运行时和编译时元编程功能使Groovy成为一个有趣的选择，因为它使程序员可以专注于DSL而不是工具或实现。由于Groovy DSL是Groovy代码，因此无需编写专用插件即可轻松获得IDE支持。</p>
</div>
<div class="paragraph">
<p>在很多情况下，DSL引擎是用Groovy（或Java）编写的，然后用户代码作为脚本执行，这意味着您在用户逻辑之上拥有某种包装器。包装器可以包括例如<code>GroovyShell</code>要么<code>GroovyScriptEngine</code>在运行脚本之前透明地执行一些任务（添加导入，应用AST转换，扩展基本脚本等）。通常，用户编写的脚本无需测试即可投入生产，因为DSL逻辑可能会<strong>导致任何</strong>用户都可以使用DSL语法编写代码。最后，用户可能只是忽略了他所写的实际上是<strong>代码</strong> 。这给DSL实现者带来了一些挑战，例如确保用户代码的执行安全，或者在这种情况下，早期报告错误。</p>
</div>
<div class="paragraph">
<p>例如，假设有一个DSL，其目标是远程驱动火星上的流动站。向流动站发送消息大约需要15分钟。如果流动站执行脚本并失败并显示错误（例如错字），则您有两个问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，仅在30分钟（流动站获取脚本所需的时间和接收错误所需的时间）之后才提供反馈</p>
</li>
<li>
<p>其次，脚本的某些部分已执行，您可能必须对固定脚本进行重大更改（这意味着您需要了解流动站的当前状态…）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类型检查扩展是一种机制，它允许DSL引擎的开发人员通过对常规groovy类应用静态类型检查所允许的相同类型的检查，从而使这些脚本更安全。</p>
</div>
<div class="paragraph">
<p>这里的原则是尽早失败，也就是说尽快使脚本编译失败，并在可能的情况下向用户提供反馈（包括良好的错误消息）。</p>
</div>
<div class="paragraph">
<p>简而言之，类型检查扩展背后的想法是使编译器了解DSL使用的所有运行时元编程技巧，以便脚本可以像冗长的静态编译代码一样受益于相同的编译时检查级别。我们将看到，您可以通过执行普通类型检查器不会执行的检查来进一步发展，为用户提供强大的编译时检查。</p>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Howdoesitwork"><a class="anchor" href="#Typecheckingextensions-Howdoesitwork"></a>扩展属性</h6>
<div class="paragraph">
<p>的<code>@TypeChecked</code>注释支持名为的属性<code>extensions</code> 。此参数采用与<em>类型检查扩展脚本</em>列表相对应的字符串数组。这些脚本是在<strong>编译时</strong>在classpath上找到的。例如，您将编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TypeChecked(extensions='/path/to/myextension.groovy')
void foo() { ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，将使用正常类型检查器的规则对<em>foo</em>方法进行类型检查，这些规则由<em>myextension.groovy</em>脚本中找到的规则完成。请注意，虽然内部类型检查器支持多种机制来实现类型检查扩展（包括普通的旧Java代码），但建议的方法是使用那些类型检查扩展脚本。</p>
</div>
</div>
<div class="sect5">
<h6 id="_a_dsl_for_type_checking"><a class="anchor" href="#_a_dsl_for_type_checking"></a> DSL用于类型检查</h6>
<div class="paragraph">
<p>类型检查扩展背后的想法是使用DSL扩展类型检查器功能。通过此DSL，您可以使用“事件驱动” API进入编译过程，尤其是类型检查阶段。例如，当类型检查器进入方法主体时，它将引发<em>beforeVisitMethod</em>事件，扩展可<em>对此</em>作出反应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitMethod { methodNode ->
 println "Entering ${methodNode.name}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>想象一下，您手边有流动站DSL。用户会写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">robot.move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您具有这样定义的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Robot {
    Robot move(int qt) { this }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在执行以下脚本之前，可以对脚本进行类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(TypeChecked)            <i class="conum" data-value="1"></i><b>(1)</b>
)
def shell = new GroovyShell(config)                         <i class="conum" data-value="2"></i><b>(2)</b>
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)                                      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>编译器配置会添加<code>@TypeChecked</code>所有类的注释</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在<code>GroovyShell</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>这样，使用shell编译的脚本将使用<code>@TypeChecked</code>用户无需显式添加它</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用上面的编译器配置，我们可以透明地将<em>@TypeChecked</em>应用于脚本。在这种情况下，它将在编译时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - The variable [robot] is undeclared.</pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们将略微更新配置以包括``扩展''参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['robotextension.groovy'])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将以下内容添加到您的类路径中：</p>
</div>
<div class="listingblock">
<div class="title">机器人扩展</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedVariable { var ->
    if ('robot'==var.name) {
        storeType(var, classNodeFor(Robot))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们告诉编译器，如果找到了一个<em>未解决的变量</em> ，并且该变量的名称是<em>robot</em> ，那么我们可以确保该变量的类型为<code>Robot</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-TheAPI"><a class="anchor" href="#Typecheckingextensions-TheAPI"></a>类型检查扩展API</h6>
<div class="sect6">
<h7 id="Typecheckingextensions-AST"><a class="anchor" href="#Typecheckingextensions-AST"></a> AST</h7>
<div class="paragraph">
<p>类型检查API是处理抽象语法树的低级API。即使使用DSL不仅比处理纯Java或Groovy的AST代码要容易得多，您还必须非常了解AST才能开发扩展。</p>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-Events"><a class="anchor" href="#Typecheckingextensions-Events"></a>大事记</h7>
<div class="paragraph">
<p>类型检查器发送以下事件，扩展脚本可以对此事件做出反应：</p>
</div>
<table id="event-setup" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>设定</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成初始化后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>没有</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">setup {
    // this is called before anything else
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可用于执行扩展程序的设置</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-finish" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>完</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成类型检查后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>没有</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">finish {
    // this is after completion
    // of all type checking
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型检查器完成工作后，可用于执行其他检查。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedVariable" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>未解决的变量</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器发现一个未解决的变量时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>VariableExpression var</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedVariable { var ->
    if ('people' == var.name) {
        storeType(var, classNodeFor(List))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员通过用户注入的变量帮助类型检查器。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedProperty" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>未解决的属性</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器在接收方上找不到属性时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>PropertyExpression pexp</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedProperty { pexp ->
    if ('longueur'==pexp.propertyAsString &&
        getType(pexp.objectExpression)==classNodeFor(String)) {
        storeType(pexp,classNodeFor(int))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员处理“动态”属性</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedAttribute" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>unresolvedAttribute</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法在接收方上找到属性时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>AttributeExpression AEX</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedAttribute { aex ->
    if (getType(aex.objectExpression)==classNodeFor(String)) {
        storeType(aex,classNodeFor(String))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员处理缺失的属性</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeMethodCall" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在类型检查器开始类型检查方法调用之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeMethodCall { call ->
    if (isMethodCallExpression(call)
            && call.methodAsString=='toUpperCase') {
        addStaticTypeError('Not allowed',call)
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许您在类型检查器执行自己的检查之前拦截方法调用。如果要用有限范围的自定义检查替换默认类型检查，这很有用。在这种情况下，必须将handled标志设置为true，以便类型检查器跳过自己的检查。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterMethodCall" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成类型检查方法调用后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterMethodCall { call ->
    if (getTargetMethod(call).name=='toUpperCase') {
        addStaticTypeError('Not allowed',call)
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器完成自己的检查之后，允许您执行其他检查。如果您要执行标准的类型检查测试，但又要确保附加的类型安全性（例如，相互检查参数），则这特别有用。注意<code>afterMethodCall</code>即使您做了<code>beforeMethodCall</code>并将handled标志设置为true。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-onMethodSelection" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>onMethodSelection</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器找到适合方法调用的方法时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>表达式expr，MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">onMethodSelection { expr, node ->
    if (node.declaringClass.name == 'java.lang.String') {
        // calling a method on 'String'
        // let’s perform additional checks!
        if (++count>2) {
            addStaticTypeError("You can use only 2 calls on String in your source code",expr)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型检查器通过推断方法调用的参数类型来工作，然后选择目标方法。如果找到一个对应的，则触发此事件。例如，如果您想对特定的方法调用做出反应，例如输入一个以闭包作为参数的方法的作用域（如在构建器中），这很有趣。请注意，可能会为各种类型的表达式引发此事件，而不仅仅是方法调用（例如，二进制表达式）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-methodNotFound" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>methodNotFound</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法为方法调用找到合适的方法时，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode接收者，字符串名称，ArgumentListExpression argList，ClassNode [] argTypes，MethodCall调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call ->
    // receiver is the inferred type of the receiver
    // name is the name of the called method
    // argList is the list of arguments the method was called with
    // argTypes is the array of inferred types for each argument
    // call is the method call for which we couldn’t find a target method
    if (receiver==classNodeFor(String)
            && name=='longueur'
            && argList.size()==0) {
        handled = true
        return newMethod('longueur', classNodeFor(String))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不像<code>onMethodSelection</code> ，当类型检查器找不到方法调用的目标方法（实例或静态）时，将发送此事件。它使您有机会在将错误发送给用户之前拦截该错误，还可以设置目标方法。为此，您需要返回一个列表<code>MethodNode</code> 。在大多数情况下，您都将返回：一个空列表，这意味着您找不到相应的方法；一个列表中只有一个元素，这表示目标方法毫无疑问。如果返回多个MethodNode，则编译器会向用户抛出错误，指出方法调用不明确，并列出了可能的方法。为了方便起见，如果只想返回一个方法，则可以直接返回它，而不必将其包装到列表中。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitMethod" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器在对方法主体进行类型检查之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitMethod { methodNode ->
    // tell the type checker we will handle the body by ourselves
    handled = methodNode.name.startsWith('skip')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在开始对方法主体进行类型检查之前，类型检查器将调用此方法。例如，如果您要自己执行类型检查而不是让类型检查器执行类型检查，则必须将handled标志设置为true。此事件还可用于帮助定义扩展的范围（例如，仅当您在方法foo中时才应用它）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitMethod" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在对方法主体进行类型检查之后，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterVisitMethod { methodNode ->
    scopeExit {
        if (methods>2) {
            addStaticTypeError("Method ${methodNode.name} contains more than 2 method calls", methodNode)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器访问方法主体之后，使您有机会执行其他检查。例如，如果您收集信息，并希望在收集所有信息后执行其他检查，这将很有用。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitClass" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器在对类进行类型检查之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitClass { ClassNode classNode ->
    def name = classNode.nameWithoutPackage
    if (!(name[0] in 'A'..'Z')) {
        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果对某个班级进行了类型检查，则在访问该班级之前，将发送此事件。在用注释的类中定义的内部类也是如此<code>@TypeChecked</code> 。它可以帮助您定义扩展的范围，甚至可以用自定义类型检查实现完全替代类型检查器的访问。为此，您必须设置<code>handled</code>标记为<code>true</code> 。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitClass" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在完成类型检查类的访问之后，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterVisitClass { ClassNode classNode ->
    def name = classNode.nameWithoutPackage
    if (!(name[0] in 'A'..'Z')) {
        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器完成工作之后，为每个要进行类型检查的类调用。这包括带注释的类<code>@TypeChecked</code>并且不会跳过与相同的类中定义的任何内部/匿名类。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-incompatibleAssignment" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>不兼容分配</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器认为分配不正确时调用，这意味着分配的右侧与左侧不兼容</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode lhsType，ClassNode rhsType，表达式分配</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">incompatibleAssignment { lhsType, rhsType, expr ->
    if (isBinaryExpression(expr) && isAssignment(expr.operation.type)) {
        if (lhsType==classNodeFor(int) && rhsType==classNodeFor(Closure)) {
            handled = true
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使开发人员能够处理错误的任务。例如，这在类重写时很有用<code>setProperty</code> ，因为在这种情况下，有可能通过该运行时机制处理将一种类型的变量分配给另一种类型的属性。在这种情况下，您可以通过告诉类型分配有效（可以使用<code>handled</code>调成<code>true</code> ）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-ambiguousMethods" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>模棱两可的方法</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法在几种候选方法之间进行选择时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>列表<methodnode>方法，表达式来源</methodnode></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">ambiguousMethods { methods, origin ->
    // choose the method which has an Integer as parameter type
    methods.find { it.parameters.any { it.type == classNodeFor(Integer) } }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使开发人员能够处理错误的任务。例如，这在类重写时很有用<code>setProperty</code> ，因为在这种情况下，有可能通过该运行时机制处理将一种类型的变量分配给另一种类型的属性。在这种情况下，您可以通过告诉类型分配有效（可以使用<code>handled</code>调成<code>true</code> ）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当然，扩展脚本可能包含多个块，并且您可以具有多个块来响应同一事件。这使DSL看起来更好，更易于编写。但是，对事件做出反应远远不够。如果您知道您可以对事件做出反应，那么您还需要处理错误，这意味着可以使用多种<em>帮助</em>程序来简化事情。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="Typecheckingextensions-Workingwithextensions"><a class="anchor" href="#Typecheckingextensions-Workingwithextensions"></a>使用扩展</h6>
<div class="sect6">
<h7 id="Typecheckingextensions-Supportclasses"><a class="anchor" href="#Typecheckingextensions-Supportclasses"></a>支援课程</h7>
<div class="paragraph">
<p>DSL依赖于称为<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc的支持类</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">。GroovyTypeCheckingExtensionSupport</a> 。此类本身扩展了<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html">org.codehaus.groovy.transform.stc。TypeCheckingExtension</a> 。这两个类定义了许多<em>帮助程序</em>方法，这些方法将使AST的使用更加容易，尤其是在类型检查方面。要知道的一件有趣的事是您<strong>可以访问类型检查器</strong> 。这意味着您可以以编程方式调用类型检查器的方法，包括那些允许<strong>引发编译错误的方法</strong> 。</p>
</div>
<div class="paragraph">
<p>扩展脚本委托给<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport</a>类，意味着您可以直接访问以下变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>context</em> ：类型检查器上下文，类型为<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingContext.html">org.codehaus.groovy.transform.stc。TypeCheckingContext</a></p>
</li>
<li>
<p><em>typeCheckingVisitor</em> ：类型检查器本身，一个<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.html">org.codehaus.groovy.transform.stc。StaticTypeCheckingVisitor</a>实例</p>
</li>
<li>
<p><em>generateMethods</em> ：“生成的方法”列表，实际上是可以使用类型检查扩展名在内部创建的“虚拟”方法列表。 <code>newMethod</code>来电</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类型检查上下文包含许多在类型检查器的上下文中有用的信息。例如，当前的封装方法调用，二进制表达式，闭包等堆栈……如果必须知道发生错误并要处理错误的<em>位置</em> ，则此信息特别重要。</p>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-Classnodes"><a class="anchor" href="#Typecheckingextensions-Classnodes"></a>类节点</h7>
<div class="paragraph">
<p>使用类型检查扩展时，处理类节点需要特别注意。编译使用抽象语法树（AST），并且在对类进行类型检查时该树可能不完整。这也意味着，当您引用类型时，不得使用诸如<code>String</code>要么<code>HashSet</code> ，但将代表这些类型的节点分类。这需要一定程度的抽象，并了解Groovy如何处理类节点。为了使事情变得容易，Groovy提供了几种帮助程序方法来处理类节点。例如，如果您想说“字符串的类型”，则可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert classNodeFor(String) instanceof ClassNode</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还会注意到，有一个<em>classNodeFor</em>的变体，它需要一个<code>String</code>作为参数，而不是<code>Class</code> 。在一般情况下，你<strong>不</strong>应该使用那一个，因为它的名字就是它会创建一个类节点<code>String</code> ，但没有任何方法，也没有在其上定义任何属性。第一个版本将返回一类节点是<em>解决了</em> ，但第二个返回一个<em>不是</em> 。因此，后者应保留给非常特殊的情况。</p>
</div>
<div class="paragraph">
<p>您可能遇到的第二个问题是引用尚未编译的类型。这可能比您想像的更多。例如，当您一起编译一组文件时。在这种情况下，如果您想说“那个变量是Foo类型”，但是<code>Foo</code>尚未编译，您仍然可以参考<code>Foo</code>类节点使用<code>lookupClassNodeFor</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert lookupClassNodeFor('Foo') instanceof ClassNode</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-Helpingthetypechecker"><a class="anchor" href="#Typecheckingextensions-Helpingthetypechecker"></a>帮助类型检查器</h7>
<div class="paragraph">
<p>假设您知道该变量<code>foo</code>是类型<code>Foo</code>并且您想告诉类型检查器。然后您可以使用<code>storeType</code>方法，它有两个参数：第一个是要存储其类型的节点，第二个是节点的类型。如果你看执行<code>storeType</code> ，您会看到它委托给类型检查器等效方法，该方法本身在存储节点元数据方面做了很多工作。您还将看到，存储类型不仅限于变量：您可以设置任何表达式的类型。</p>
</div>
<div class="paragraph">
<p>同样，获取AST节点的类型只是调用<code>getType</code>在那个节点上。通常，这就是您想要的，但是您必须了解一些内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getType</code>返回表达式的<strong>推断类型</strong> 。这意味着对于声明为type的变量，它不会返回<code>Object</code>的类节点<code>Object</code> ，但在<strong>代码的这一点上</strong>推断出此变量的类型（流类型）</p>
</li>
<li>
<p>如果要访问变量（或字段/参数）的原始类型，则必须在AST节点上调用适当的方法</p>
</li>
</ul>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-Throwinganerror"><a class="anchor" href="#Typecheckingextensions-Throwinganerror"></a>引发错误</h7>
<div class="paragraph">
<p>要引发类型检查错误，您只需调用<code>addStaticTypeError</code>具有两个参数的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一条<em>消息</em> ，它是将显示给最终用户的字符串</p>
</li>
<li>
<p>负责该错误的<em>AST节点</em> 。最好提供最合适的AST节点，因为它将用于检索行号和列号</p>
</li>
</ul>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-isXXXExpression"><a class="anchor" href="#Typecheckingextensions-isXXXExpression"></a> isXXXExpression</h7>
<div class="paragraph">
<p>通常需要知道AST节点的类型。为了提高可读性，DSL提供了一种特殊的isXXXExpression方法，该方法将委托给<code>x instance of XXXExpression</code> 。例如，代替编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (node instanceof BinaryExpression) {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要您导入<code>BinaryExpression</code>上课，你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (isBinaryExpression(node)) {
   ...
}</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-Virtualmethods"><a class="anchor" href="#Typecheckingextensions-Virtualmethods"></a>虚方法</h7>
<div class="paragraph">
<p>当您执行动态代码的类型检查时，您可能经常会遇到这样的情况：知道方法调用有效，但背后没有“真正的”方法。例如，以Grails动态查找器为例。您可以进行一个名为<em>findByName（…）</em>的方法调用。由于在bean中没有定义<em>findByName</em>方法，因此类型检查器会抱怨。但是，您会知道此方法在运行时不会失败，甚至可以说出此方法的返回类型是什么。对于这种情况，DSL支持两种特殊的结构，它们由<em>幻影方法</em>组成。这意味着您将返回一个实际上不存在但在类型检查的上下文中定义的方法节点。存在三种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newMethod(String name, Class returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, ClassNode returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, Callable<ClassNode> return Type)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这三个变体都执行相同的操作：它们创建一个新方法节点，该名称为提供的名称，并定义此方法的返回类型。此外，类型检查器会将这些方法添加到<code>generatedMethods</code>清单（请参阅<code>isGenerated</code>下面）。我们仅设置名称和返回类型的原因是，在90％的情况下，仅它就是您所需要的。例如，在<code>findByName</code>示例鞋帮，您唯一需要知道的是<code>findByName</code>在运行时不会失败，并且它返回一个域类。的<code>Callable</code>返回类型的版本很有趣，因为当类型检查器实际需要返回类型时，它会延迟返回类型的计算。这很有趣，因为在某些情况下，当类型检查器需要它时，您可能不知道实际的返回类型，因此您可以使用每次都会调用的闭包。 <code>getReturnType</code>由此方法节点上的类型检查器调用。如果将此与延迟检查结合使用，则可以实现相当复杂的类型检查，包括对前向引用的处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">newMethod(name) {
    // each time getReturnType on this method node will be called, this closure will be called!
    println 'Type checker called me!'
    lookupClassNodeFor(Foo) // return type
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要的不仅是名称和返回类型，还可以随时创建一个新的<code>MethodNode</code>由你自己。</p>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-Scoping"><a class="anchor" href="#Typecheckingextensions-Scoping"></a>范围界定</h7>
<div class="paragraph">
<p>范围界定在DSL类型检查中非常重要，也是我们无法使用基于<em>切入点</em>的方法进行DSL类型检查的原因之一。基本上，您必须能够非常精确地定义您的扩展何时适用以及何时不适用。此外，您必须能够处理常规类型检查器无法处理的情况，例如前向引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">point a(1,1)
line a,b // b is referenced afterwards!
point b(5,2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>举例来说，您要处理一个构建器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">builder.foo {
   bar
   baz(bar)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，您的扩展程序只有在您输入<code>foo</code>方法，并且在此范围之外处于非活动状态。但是您可能会遇到复杂的情况，例如同一文件中的多个构建器或嵌入式构建器（构建器中的构建器）。尽管您不应该尝试从一开始就解决所有问题（必须接受类型检查的限制），但类型检查器确实提供了一种很好的机制来处理此问题：使用<code>newScope</code>和<code>scopeExit</code>方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newScope</code>创建一个新的作用域并将其放在栈顶</p>
</li>
<li>
<p><code>scopeExits</code>从堆栈弹出作用域</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>范围包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>父范围</p>
</li>
<li>
<p>定制数据图</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您想看一下实现，那只是一个<code>LinkedHashMap</code> （ <a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport/TypeCheckingScope.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport。TypeCheckingScope</a> ），但功能非常强大。例如，您可以使用这种范围存储退出范围时要执行的闭包列表。这是您处理前向引用的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def scope = newScope()
scope.secondPassChecks = []
//...
scope.secondPassChecks << { println 'executed later' }
// ...
scopeExit {
    secondPassChecks*.run() // execute deferred checks
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是说，如果在某个时候您无法确定表达式的类型，或者在这一点上您无法检查赋值是否有效，您仍然可以稍后进行检查……是一项非常强大的功能。现在， <code>newScope</code>和<code>scopeExit</code>提供一些有趣的语法糖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">newScope {
    secondPassChecks = []
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在DSL中的任何时间，您都可以使用<code>getCurrentScope()</code>或更简单<code>currentScope</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">//...
currentScope.secondPassChecks << { println 'executed later' }
// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>通用模式将是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确定<em>切入点</em> ，在该<em>切入点</em>上将新作用域推入堆栈并在该作用域内初始化自定义变量</p>
</li>
<li>
<p>使用各种事件，您可以使用存储在自定义范围中的信息来执行检查，推迟检查等等。</p>
</li>
<li>
<p>确定退出范围的<em>切入点</em> ，调用<code>scopeExit</code>并最终执行其他检查</p>
</li>
</ul>
</div>
</div>
<div class="sect6">
<h7 id="Typecheckingextensions-Otherusefulmethods"><a class="anchor" href="#Typecheckingextensions-Otherusefulmethods"></a>其他有用的方法</h7>
<div class="paragraph">
<p>有关帮助程序方法的完整列表，请参考<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport</a>和<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html">org.codehaus.groovy.transform.stc。TypeCheckingExtension</a>类。但是，请特别注意以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>isDynamic</code> ：使用VariableExpression作为参数，如果变量是DynamicExpression，则返回true，这意味着在脚本中未使用类型或<code>def</code> 。</p>
</li>
<li>
<p><code>isGenerated</code> ：以MethodNode作为参数，并使用该方法判断类型是否由类型检查器扩展生成。 <code>newMethod</code>方法</p>
</li>
<li>
<p><code>isAnnotatedBy</code> ：接受一个AST节点和一个Class（或ClassNode），并告诉该节点是否用此类注释。例如：<code>isAnnotatedBy(node, NotNull)</code></p>
</li>
<li>
<p><code>getTargetMethod</code> ：将方法调用作为参数并返回<code>MethodNode</code>类型检查器已为此确定的</p>
</li>
<li>
<p><code>delegatesTo</code> ：模拟的行为<code>@DelegatesTo</code>注解。它允许您告诉参数将委托给特定类型（您也可以指定委托策略）</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_advanced_type_checking_extensions"><a class="anchor" href="#_advanced_type_checking_extensions"></a>高级类型检查扩展</h5>
<div class="sect5">
<h6 id="_precompiled_type_checking_extensions"><a class="anchor" href="#_precompiled_type_checking_extensions"></a>预编译类型检查扩展</h6>
<div class="paragraph">
<p>上面的所有示例都使用类型检查脚本。它们以类路径的源代码形式存在，这意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对应于类型检查扩展名的Groovy源文件在编译类路径上可用</p>
</li>
<li>
<p>该文件由Groovy编译器针对要编译的每个源单元进行编译（通常，一个源单元对应于一个文件）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是开发类型检查扩展名的一种非常方便的方法，但是由于要为每个要编译的文件扩展名本身的编译，因此它意味着编译阶段较慢。由于这些原因，依靠预编译的扩展可能是实际的。您可以通过以下两种方法执行此操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用Groovy编写扩展，进行编译，然后使用对扩展类的引用而不是源代码</p>
</li>
<li>
<p>用Java编写扩展，进行编译，然后使用对扩展类的引用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用Groovy编写类型检查扩展是最简单的方法。基本上，这种想法是类型检查扩展脚本成为类型检查扩展类的main方法的主体，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport

class PrecompiledExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {     <i class="conum" data-value="1"></i><b>(1)</b>
    @Override
    Object run() {                                                                          <i class="conum" data-value="2"></i><b>(2)</b>
        unresolvedVariable { var ->
            if ('robot'==var.name) {
                storeType(var, classNodeFor(Robot))                                         <i class="conum" data-value="3"></i><b>(3)</b>
                handled = true
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扩展<code>TypeCheckingDSL</code>上课是最简单的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>那么扩展代码需要放入<code>run</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>您可以使用与以源代码形式编写的扩展程序相同的事件</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>设置扩展与使用源表单扩展非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['typing.PrecompiledExtension'])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>区别在于，您无需指定classpath中的路径，而只需指定预编译扩展名的完全限定的类名即可。</p>
</div>
<div class="paragraph">
<p>如果您真的想用Java编写扩展，那么您将不会从类型检查扩展DSL中受益。可以使用以下方式用Java重写上面的扩展名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import org.codehaus.groovy.ast.ClassHelper;
import org.codehaus.groovy.ast.expr.VariableExpression;
import org.codehaus.groovy.transform.stc.AbstractTypeCheckingExtension;


import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;

public class PrecompiledJavaExtension extends AbstractTypeCheckingExtension {                   <i class="conum" data-value="1"></i><b>(1)</b>

    public PrecompiledJavaExtension(final StaticTypeCheckingVisitor typeCheckingVisitor) {
        super(typeCheckingVisitor);
    }

    @Override
    public boolean handleUnresolvedVariableExpression(final VariableExpression vexp) {          <i class="conum" data-value="2"></i><b>(2)</b>
        if ("robot".equals(vexp.getName())) {
            storeType(vexp, ClassHelper.make(Robot.class));
            setHandled(true);
            return true;
        }
        return false;
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扩展<code>AbstractTypeCheckingExtension</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后覆盖<code>handleXXX</code>所需方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_using_grab_in_a_type_checking_extension"><a class="anchor" href="#_using_grab_in_a_type_checking_extension"></a>在类型检查扩展中使用@Grab</h6>
<div class="paragraph">
<p>完全有可能使用<code>@Grab</code>类型检查扩展中的注释。这意味着您可以包括仅在编译时可用的库。在这种情况下，您必须了解，将大大增加编译时间（至少在第一次获取依赖项时）。</p>
</div>
</div>
<div class="sect5">
<h6 id="_sharing_or_packaging_type_checking_extensions"><a class="anchor" href="#_sharing_or_packaging_type_checking_extensions"></a>共享或打包类型检查扩展</h6>
<div class="paragraph">
<p>类型检查扩展仅仅是需要放在类路径中的脚本。这样，您可以按原样共享它，或将其捆绑在一个将添加到类路径的jar文件中。</p>
</div>
</div>
<div class="sect5">
<h6 id="_global_type_checking_extensions"><a class="anchor" href="#_global_type_checking_extensions"></a>全局类型检查扩展</h6>
<div class="paragraph">
<p>虽然您可以配置编译器以透明地将类型检查扩展添加到脚本中，但是当前无法仅通过将扩展放在类路径上来透明地应用扩展。</p>
</div>
</div>
<div class="sect5">
<h6 id="_type_checking_extensions_and_compilestatic"><a class="anchor" href="#_type_checking_extensions_and_compilestatic"></a>类型检查扩展名和@CompileStatic</h6>
<div class="paragraph">
<p>类型检查扩展与<code>@TypeChecked</code>但也可以与<code>@CompileStatic</code> 。但是，您必须意识到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用于的类型检查扩展<code>@CompileStatic</code>通常不足以让编译器知道如何从“不安全”代码生成静态可编译代码</p>
</li>
<li>
<p>可以使用带有<code>@CompileStatic</code>只是为了增强类型检查，也就是说引入了<strong>更多的</strong>编译错误，而没有实际处理动态代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们解释一下第一点，即即使使用扩展，编译器也不会知道如何静态地编译代码：从技术上讲，即使您告诉类型检查器动态变量的类型是什么，例如不知道如何编译它。是吗<code>getBinding('foo')</code> ， <code>getProperty('foo')</code> ， <code>delegate.getFoo()</code> ，...？即使使用类型检查扩展，也绝对没有直接的方法来告诉静态编译器如何编译此类代码（同样，它只会给出有关类型的提示）。</p>
</div>
<div class="paragraph">
<p>对于此特定示例，一种可能的解决方案是指示编译器使用<a href="#mixed-mode">混合模式编译</a> 。一种更高级的方法是<a href="#ast-xform-as-extension">在类型检查期间</a>使用<a href="#ast-xform-as-extension">AST转换，</a>但这要复杂得多。</p>
</div>
<div class="paragraph">
<p>类型检查扩展允许您在失败的地方帮助类型检查器，但也可以在没有失败的地方帮助失败。在这种情况下，支持扩展<code>@CompileStatic</code>太。想象一下一个能够对SQL查询进行类型检查的扩展。在那种情况下，扩展名在动态和静态上下文中都是有效的，因为没有扩展名，代码仍然可以通过。</p>
</div>
</div>
<div class="sect5">
<h6 id="mixed-mode"><a class="anchor" href="#mixed-mode"></a>混合模式编译</h6>
<div class="paragraph">
<p>在上一节中，我们强调了您可以使用以下命令激活类型检查扩展的事实： <code>@CompileStatic</code> 。在这种情况下，类型检查器将不再抱怨某些未解析的变量或未知的方法调用，但仍然不知道如何静态地编译它们。</p>
</div>
<div class="paragraph">
<p>混合模式编译提供了第三种方法，即指示编译器，只要找到未解析的变量或方法调用，则应退回到动态模式。这要归功于类型检查扩展和特殊的<code>makeDynamic</code>呼叫。</p>
</div>
<div class="paragraph">
<p>为了说明这一点，让我们回到<code>Robot</code>例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">robot.move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们尝试使用激活我们的类型检查扩展程序<code>@CompileStatic</code>代替<code>@TypeChecked</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      <i class="conum" data-value="1"></i><b>(1)</b>
        extensions:['robotextension.groovy'])               <i class="conum" data-value="2"></i><b>(2)</b>
)
def shell = new GroovyShell(config)
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>应用<code>@CompileStatic</code>透明地</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>激活类型检查扩展</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该脚本可以正常运行，因为静态编译器会被告知有关类型的信息。 <code>robot</code>变量，因此它可以直接调用<code>move</code> 。但在此之前，编译器如何知道如何获取<code>robot</code>变量？实际上，默认情况下，在类型检查扩展中，设置<code>handled=true</code>在未解析的变量上将自动触发动态分辨率，因此在这种情况下，您没有什么特别的条件可以使编译器使用混合模式。但是，让我们从机器人脚本开始稍微更新一下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里您可以注意到没有参考<code>robot</code>不再。那么我们的扩展将无济于事，因为我们将无法指示编译器<code>move</code>完成于<code>Robot</code>实例。借助于<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/DelegatingScript.html">groovy.util ，可以完全动态地执行此代码示例</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/DelegatingScript.html">。DelegatingScript</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.scriptBaseClass = 'groovy.util.DelegatingScript'     <i class="conum" data-value="1"></i><b>(1)</b>
def shell = new GroovyShell(config)
def runner = shell.parse(script)                            <i class="conum" data-value="2"></i><b>(2)</b>
runner.setDelegate(new Robot())                             <i class="conum" data-value="3"></i><b>(3)</b>
runner.run()                                                <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们将编译器配置为使用<code>DelegatingScript</code>作为基类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>脚本源需要解析，并将返回的实例<code>DelegatingScript</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后我们可以打电话<code>setDelegate</code>使用<code>Robot</code>作为脚本的委托</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后执行脚本。 <code>move</code>将直接在委托上执行</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们希望通过<code>@CompileStatic</code> ，我们必须使用类型检查扩展名，因此让我们更新配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      <i class="conum" data-value="1"></i><b>(1)</b>
        extensions:['robotextension2.groovy'])              <i class="conum" data-value="2"></i><b>(2)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>应用<code>@CompileStatic</code>透明地</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用备用的类型检查扩展名来识别对<code>move</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后在上一节中，我们学习了如何处理无法识别的方法调用，因此我们可以编写此扩展名：</p>
</div>
<div class="listingblock">
<div class="title">robotextension2.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call ->
    if (isMethodCallExpression(call)                        <i class="conum" data-value="1"></i><b>(1)</b>
        && call.implicitThis                                <i class="conum" data-value="2"></i><b>(2)</b>
        && 'move'==name                                     <i class="conum" data-value="3"></i><b>(3)</b>
        && argTypes.length==1                               <i class="conum" data-value="4"></i><b>(4)</b>
        && argTypes[0] == classNodeFor(int)                 <i class="conum" data-value="5"></i><b>(5)</b>
    ) {
        handled = true                                      <i class="conum" data-value="6"></i><b>(6)</b>
        newMethod('move', classNodeFor(Robot))              <i class="conum" data-value="7"></i><b>(7)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果调用是方法调用（不是静态方法调用）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该调用是基于“隐式这样做”（没有明确的<code>this.</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>被调用的方法是<code>move</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>并且该调用是通过单个参数完成的</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>而该参数是类型<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>然后告诉类型检查器该调用是有效的</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>并且该呼叫的返回类型为<code>Robot</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您尝试执行此代码，那么您可能会惊讶于它实际上在运行时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.NoSuchMethodError: java.lang.Object.move()Ltyping/Robot;</pre>
</div>
</div>
<div class="paragraph">
<p>原因很简单：尽管类型检查扩展足以满足<code>@TypeChecked</code> ，它不涉及静态编译，对于<code>@CompileStatic</code>这需要其他信息。在这种情况下，您告诉编译器该方法已经存在，但是您没有向它解释它实际上是<strong>什么</strong>方法，以及消息的接收者（委托）是什么。</p>
</div>
<div class="paragraph">
<p>解决此问题非常容易，仅意味着更换<code>newMethod</code>打电话给别的东西：</p>
</div>
<div class="listingblock">
<div class="title">robotextension3.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call ->
    if (isMethodCallExpression(call)
        && call.implicitThis
        && 'move'==name
        && argTypes.length==1
        && argTypes[0] == classNodeFor(int)
    ) {
        makeDynamic(call, classNodeFor(Robot))              <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>告诉编译器调用应该动态化</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>makeDynamic</code>呼叫执行3件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它返回一个虚拟方法，就像<code>newMethod</code></p>
</li>
<li>
<p>自动设置<code>handled</code>标记为<code>true</code>为了你</p>
</li>
<li>
<p>但也标志着<code>call</code>动态地完成</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，当编译器必须生成用于调用的字节码时<code>move</code> ，由于现在已将其标记为动态调用，因此它将回退到动态编译器并让其处理该调用。由于扩展名告诉我们动态调用的返回类型是<code>Robot</code> ，后续调用将静态完成！</p>
</div>
<div class="paragraph">
<p>有人会奇怪为什么静态编译器默认情况下没有扩展就不会这样做。这是一个设计决策：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果代码是静态编译的，我们通常需要类型安全和最佳性能</p>
</li>
<li>
<p>因此，如果使无法识别的变量/方法调用动态化，则会失去类型安全性，而且在编译时还完全支持错别字！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>简而言之，如果您要进行混合模式编译，则<strong>必须</strong>通过类型检查扩展将其明确显示，以便编译器和DSL设计人员完全了解自己在做什么。</p>
</div>
<div class="paragraph">
<p><code>makeDynamic</code>可以在3种AST节点上使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法节点（ <code>MethodNode</code> ）</p>
</li>
<li>
<p>一个变量 （ <code>VariableExpression</code> ）</p>
</li>
<li>
<p>属性表达式（ <code>PropertyExpression</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这还不够，那就意味着不能直接进行静态编译，而您必须依靠AST转换。</p>
</div>
</div>
<div class="sect5">
<h6 id="ast-xform-as-extension"><a class="anchor" href="#ast-xform-as-extension"></a>在扩展中转换AST</h6>
<div class="paragraph">
<p>从AST转换设计的角度来看，类型检查扩展看起来非常有吸引力：扩展可以访问诸如推断类型之类的上下文，这通常很不错。扩展可以直接访问抽象语法树。由于您可以访问AST，因此从理论上讲，没有什么可以阻止您修改AST。但是，我们不建议您这样做，除非您是高级AST转换设计器并且非常了解编译器内部：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，您将明确打破类型检查的约定，即仅对AST进行注释。类型检查<strong>不</strong>应该修改AST树，因为你不就能够保证了，如果没有<em>@TypeChecked</em>注释代码的行为，而不标注相同。</p>
</li>
<li>
<p>如果您的扩展名旨在与<em>@CompileStatic</em>配合<em>使用</em> ，则<strong>可以</strong>修改AST，因为这确实是<em>@CompileStatic</em>最终将执行的操作。静态编译并不能保证在动态的Groovy相同的语义，从而有效地存在与<em>@CompileStatic</em>与<em>@TypeChecked</em>编译代码编译的代码之间的差异。由您决定要更新AST的策略，但是可能使用在类型检查变得更容易之前运行的AST转换。</p>
</li>
<li>
<p>如果您不能依靠类型检查器之前启动的转换，则必须<strong>非常</strong>小心</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">类型检查阶段是生成字节码之前在编译器中运行的最后一个阶段。所有其他AST转换都在此之前运行，并且编译器在“修复”类型检查阶段之前生成的错误AST方面做得非常出色。在类型检查期间（例如直接在类型检查扩展中）执行转换后，您必须自己完成所有工作，以生成100％兼容编译器的抽象语法树，这很容易变得复杂。因此，如果您从类型检查扩展和AST转换开始，我们不建议您这样做。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_examples"><a class="anchor" href="#_examples"></a>例子</h6>
<div class="paragraph">
<p>现实生活中类型检查扩展的示例很容易找到。您可以下载Groovy的源代码，并查看链接到<a href="https://github.com/apache/groovy/tree/master/src/test-resources/groovy/transform/stc">各种扩展脚本</a>的<a href="https://github.com/apache/groovy/blob/master/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy">TypeCheckingExtensionsTest</a>类。</p>
</div>
<div class="paragraph">
<p>可以在<a href="markup-template-engine.html">标记模板引擎</a>源代码中找到复杂类型检查扩展的示例：该模板引擎依靠类型检查扩展和AST转换将模板转换为完全静态编译的代码。可以在<a href="https://github.com/apache/groovy/tree/master/subprojects/groovy-templates/src/main/groovy/groovy/text/markup">这里</a>找到其来源。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tools"><a class="anchor" href="#_tools"></a> 2。工具类</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_running_groovy_from_the_commandline"><a class="anchor" href="#_running_groovy_from_the_commandline"></a> 2.1。从命令行运行Groovy</h3>
<div class="sect3">
<h4 id="section-groovy-commandline"><a class="anchor" href="#section-groovy-commandline"></a> 2.1.1。 groovy，Groovy命令</h4>
<div class="paragraph">
<p><code>groovy</code>调用Groovy命令行处理器。它允许您在Groovy文件中运行内联Groovy表达式以及脚本，测试或应用程序。它起着类似的作用<code>java</code>在Java世界中，但是处理内联脚本而不是调用类文件，通常使用脚本来调用它，并且会在需要时自动调用Groovy编译器。</p>
</div>
<div class="paragraph">
<p>运行Groovy脚本，测试或应用程序的最简单方法是在shell提示符下运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>> groovy MyScript.groovy</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>.groovy</code>部分是可选的。的<code>groovy</code>该命令支持许多命令行开关：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">简洁版本</th>
<th class="tableblock halign-left valign-top">长版</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-公关</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-启用预览</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用预览Java功能（JEP 12）（仅jdk12 +）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">groovy-启用预览Person.groovy</p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-一种</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-自动分割<splitpattern></splitpattern></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用splitPattern（默认'\ s'）使用隐式'split'变量分割线</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--basescript<class></class></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">脚本的基类名称（必须从脚本派生）</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-编码<charset></charset></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定文件的编码</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-cp<path></path></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-classpath<path><br>--classpath<path></path></path></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定编译类路径。必须是第一个参数。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">groovy -cp lib / dep.jar MyScript</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--configscript<path></path></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">高级编译器配置脚本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">groovy --configscript config / config.groovy src / Person.groovy</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">- 限定<name=value></name=value></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义系统属性</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-调试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">调试模式将打印出完整的堆栈跟踪</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--disableopt<optlist></optlist></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁用一个或所有优化元素。<br>optlist可以是包含元素的逗号分隔列表：<br>全部（禁用所有优化），<br>int（禁用任何基于int的优化）</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-e<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</p></td></tr></tbody></table></div></div></div></div></div></body></html>