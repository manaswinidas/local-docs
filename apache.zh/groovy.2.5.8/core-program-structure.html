<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>程序结构</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=1">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>程序结构</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_package_names">1。包装名称</a></li>
<li><a href="#_imports">2。进口货</a>
<ul class="sectlevel2">
<li><a href="#_default_imports">2.1。默认导入</a></li>
<li><a href="#_simple_import">2.2。简单导入</a></li>
<li><a href="#_star_import">2.3。星级导入</a></li>
<li><a href="#_static_import">2.4。静态导入</a></li>
<li><a href="#_static_import_aliasing">2.5。静态导入别名</a></li>
<li><a href="#_static_star_import">2.6。静态星导入</a></li>
<li><a href="#_import_aliasing">2.7。导入别名</a></li>
</ul>
</li>
<li><a href="#_scripts_versus_classes">3。脚本与类</a>
<ul class="sectlevel2">
<li><a href="#_public_static_void_main_vs_script">3.1。公共静态无效主vs脚本</a></li>
<li><a href="#_script_class">3.2。脚本类</a></li>
<li><a href="#_methods">3.3。方法</a></li>
<li><a href="#_variables">3.4。变数</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了Groovy编程语言的程序结构。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_package_names"><a class="anchor" href="#_package_names"></a> 1。包装名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>包名称的作用与Java中完全相同。它们使我们能够分离代码库，而不会发生任何冲突。Groovy类必须在类定义之前指定其包，否则采用默认包。</p>
</div>
<div class="paragraph">
<p>定义软件包与Java非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// defining a package named com.yoursite
package com.yoursite</code></pre>
</div>
</div>
<div class="paragraph">
<p>上课<code>Foo</code>在里面<code>com.yoursite.com</code>包，您将需要使用完全限定名称<code>com.yoursite.com.Foo</code> ，否则您可以使用<code>import</code>声明，如下所示。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_imports"><a class="anchor" href="#_imports"></a> 2。进口货</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了引用任何类，您需要对其包进行合格的引用。Groovy遵循Java的允许<code>import</code>解决类引用的语句。</p>
</div>
<div class="paragraph">
<p>例如，Groovy提供了几个构建器类，例如<code>MarkupBuilder</code> 。 <code>MarkupBuilder</code>在包装内<code>groovy.xml</code>因此，要使用此类，您需要<code>import</code>如图所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_default_imports"><a class="anchor" href="#_default_imports"></a> 2.1。默认导入</h3>
<div class="paragraph">
<p>默认导入是Groovy语言默认提供的导入。例如，看下面的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new Date()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java中的相同代码需要导入语句才能<code>Date</code>像这样的类：import java.util。日期。Groovy默认情况下会为您导入这些类。</p>
</div>
<div class="paragraph">
<p>groovy为您添加了以下导入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.lang.*
import java.util.*
import java.io.*
import java.net.*
import groovy.lang.*
import groovy.util.*
import java.math.BigInteger
import java.math.BigDecimal</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做是因为这些包中的类是最常用的。通过导入，这些样板代码减少了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_import"><a class="anchor" href="#_simple_import"></a> 2.2。简单导入</h3>
<div class="paragraph">
<p>简单的import是import语句，您可以在其中完全定义类名和包。例如，导入语句import groovy.xml。下面代码中的MarkupBuilder是一个简单的导入，直接引用包中的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_import"><a class="anchor" href="#_star_import"></a> 2.3。星级导入</h3>
<div class="paragraph">
<p>与Java一样，Groovy提供了一种特殊的方式，可以使用以下方式从包中导入所有类<code>*</code> ，即所谓的星号导入。 <code>MarkupBuilder</code>是包装中的一类<code>groovy.xml</code>以及另一个称为<code>StreamingMarkupBuilder</code> 。如果需要同时使用两个类，则可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.xml.MarkupBuilder
import groovy.xml.StreamingMarkupBuilder

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null</code></pre>
</div>
</div>
<div class="paragraph">
<p>那是完全有效的代码。但是用<code>*</code>导入，我们只需一行就可以达到相同的效果。星号导入包中的所有类<code>groovy.xml</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.xml.*

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个问题<code>*</code>导入是因为它们可能会使您的本地名称空间混乱。但是使用Groovy提供的各种别名，可以轻松解决。</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_import"><a class="anchor" href="#_static_import"></a> 2.4。静态导入</h3>
<div class="paragraph">
<p>Groovy的静态导入功能使您可以引用导入的类，就像它们是您自己的类中的静态方法一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static Boolean.FALSE

assert !FALSE //use directly, without Boolean prefix!</code></pre>
</div>
</div>
<div class="paragraph">
<p>这类似于Java的静态导入功能，但比Java更动态，因为它允许您定义与导入方法同名的方法，只要您具有不同的类型即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static java.lang.String.format <i class="conum" data-value="1"></i><b>(1)</b>

class SomeClass {

    String format(Integer i) { <i class="conum" data-value="2"></i><b>(2)</b>
        i.toString()
    }

    static void main(String[] args) {
        assert format('String') == 'String' <i class="conum" data-value="3"></i><b>(3)</b>
        assert new SomeClass().format(Integer.valueOf(1)) == '1'
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>静态导入方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>与上面静态导入的方法同名的方法声明，但参数类型不同</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>Java中的编译错误，但是是有效的常规代码</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果具有相同的类型，则导入的类优先。</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_import_aliasing"><a class="anchor" href="#_static_import_aliasing"></a> 2.5。静态导入别名</h3>
<div class="paragraph">
<p>静态导入<code>as</code>关键字为命名空间问题提供了一种优雅的解决方案。假设您想获得一个<code>Calendar</code>实例，使用其<code>getInstance()</code>方法。这是一个静态方法，因此我们可以使用静态导入。但是不要打电话<code>getInstance()</code>每次将其与类名分开时可能会产生误导，我们可以使用别名导入它，以提高代码的可读性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static Calendar.getInstance as now

assert now().class == Calendar.getInstance().class</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，这很干净！</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_star_import"><a class="anchor" href="#_static_star_import"></a> 2.6。静态星导入</h3>
<div class="paragraph">
<p>静态星号导入与常规星号导入非常相似。它将导入给定类中的所有静态方法。</p>
</div>
<div class="paragraph">
<p>例如，假设我们需要为我们的应用计算正弦和余弦。班级<code>java.lang.Math</code>有名为的静态方法<code>sin</code>和<code>cos</code>符合我们的需求。借助静态星形导入，我们可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static java.lang.Math.*

assert sin(0) == 0.0
assert cos(0) == 1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，我们能够访问这些方法<code>sin</code>和<code>cos</code>直接，没有<code>Math.</code>字首。</p>
</div>
</div>
<div class="sect2">
<h3 id="_import_aliasing"><a class="anchor" href="#_import_aliasing"></a> 2.7。导入别名</h3>
<div class="paragraph">
<p>使用类型别名，我们可以使用我们选择的名称来引用完全限定的类名称。这可以通过<code>as</code>关键字，和以前一样。</p>
</div>
<div class="paragraph">
<p>例如我们可以导入<code>java.sql.Date</code>如<code>SQLDate</code>并在与该文件相同的文件中使用<code>java.util.Date</code>不必使用任何一个类的完全限定名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.util.Date
import java.sql.Date as SQLDate

Date utilDate = new Date(1000L)
SQLDate sqlDate = new SQLDate(1000L)

assert utilDate instanceof java.util.Date
assert sqlDate instanceof java.sql.Date</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_scripts_versus_classes"><a class="anchor" href="#_scripts_versus_classes"></a> 3。脚本与类</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_public_static_void_main_vs_script"><a class="anchor" href="#_public_static_void_main_vs_script"></a> 3.1。公共静态无效主vs脚本</h3>
<div class="paragraph">
<p>Groovy支持脚本和类。以以下代码为例：</p>
</div>
<div class="listingblock">
<div class="title">主槽</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Main {                                    <i class="conum" data-value="1"></i><b>(1)</b>
    static void main(String... args) {          <i class="conum" data-value="2"></i><b>(2)</b>
        println 'Groovy world!'                 <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个<code>Main</code>类，名字是任意的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>public static void main(String[])</code>方法可用作类的主要方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>方法的主体</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是典型的代码，你会发现从Java，其中的代码<strong>必须</strong>被嵌入到一类是可执行的到来。Groovy使它变得更容易，以下代码等效：</p>
</div>
<div class="listingblock">
<div class="title">主槽</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println 'Groovy world!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将脚本视为一个类，而无需对其进行声明，但有所不同。</p>
</div>
</div>
<div class="sect2">
<h3 id="_script_class"><a class="anchor" href="#_script_class"></a> 3.2。脚本类</h3>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/Script.html">脚本</a>总是被编译成一个类。Groovy编译器将为您编译该类，并将脚本主体复制到<code>run</code>方法。因此，将前面的示例编译为如下所示：</p>
</div>
<div class="listingblock">
<div class="title">主槽</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {                     <i class="conum" data-value="1"></i><b>(1)</b>
    def run() {                                 <i class="conum" data-value="2"></i><b>(2)</b>
        println 'Groovy world!'                 <i class="conum" data-value="3"></i><b>(3)</b>
    }
    static void main(String[] args) {           <i class="conum" data-value="4"></i><b>(4)</b>
        InvokerHelper.runScript(Main, args)     <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Main</code>类扩展了<code>groovy.lang.Script</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>groovy.lang.Script</code>需要一个<code>run</code>返回值的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>脚本主体进入<code>run</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的<code>main</code>方法是自动生成的</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>并将脚本的执行委托给<code>run</code>方法</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果脚本在文件中，则文件的基本名称用于确定生成的脚本类的名称。在此示例中，如果文件名是<code>Main.groovy</code> ，那么脚本类将是<code>Main</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_methods"><a class="anchor" href="#_methods"></a> 3.3。方法</h3>
<div class="paragraph">
<p>可以在脚本中定义方法，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int fib(int n) {
    n &lt; 2 ? 1 : fib(n-1) + fib(n-2)
}
assert fib(10)==89</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以混合使用方法和代码。生成的脚本类会将所有方法携带到脚本类中，并将所有脚本主体组合到<code>run</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println 'Hello'                                 <i class="conum" data-value="1"></i><b>(1)</b>

int power(int n) { 2**n }                       <i class="conum" data-value="2"></i><b>(2)</b>

println "2^6==${power(6)}"                      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>脚本开始</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在脚本主体中定义了一个方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并且脚本继续</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此代码在内部转换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {
    int power(int n) { 2** n}                   <i class="conum" data-value="1"></i><b>(1)</b>
    def run() {
        println 'Hello'                         <i class="conum" data-value="2"></i><b>(2)</b>
        println "2^6==${power(6)}"              <i class="conum" data-value="3"></i><b>(3)</b>
    }
    static void main(String[] args) {
        InvokerHelper.runScript(Main, args)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>power</code>方法被原样复制到生成的脚本类中</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>第一条语句复制到<code>run</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>第二条语句复制到<code>run</code>方法</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">即使Groovy从您的脚本创建了一个类，它对用户也是完全透明的。特别是，脚本被编译为字节码，并且保留行号。这意味着，如果在脚本中引发异常，则堆栈跟踪将显示与原始脚本相对应的行号，而不是我们已显示的生成的代码。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_variables"><a class="anchor" href="#_variables"></a> 3.4。变数</h3>
<div class="paragraph">
<p>脚本中的变量不需要类型定义。这意味着该脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int x = 1
int y = 2
assert x+y == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>与以下行为相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">x = 1
y = 2
assert x+y == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，两者之间在语义上有所不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果在第一个示例中声明了该变量，则它是一个<em>局部变量</em> 。它将在<code>run</code>编译器将生成的方法，并且在脚本主体之外<strong>不</strong>可见。特别是，该变量在脚本的其他方法中将<strong>不</strong>可见</p>
</li>
<li>
<p>如果未声明变量，它将进入<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/Script.html#getBinding()">脚本绑定</a> 。绑定从方法中可见，如果使用脚本与应用程序交互并且需要在脚本和应用程序之间共享数据，则该绑定尤其重要。读者可以参考<a href="guide-integrating.html#_integrating_groovy_in_a_java_application">集成指南</a>以获取更多信息。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您想让变量成为类的字段而无需进入<code>Binding</code> ，您可以使用<a href="core-metaprogramming.html#xform-Field">@Field批注</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=2">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>