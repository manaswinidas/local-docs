<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>装饰图案</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=3">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>装饰图案</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_traditional_example">1。传统例子</a></li>
<li><a href="#_a_touch_of_dynamic_behaviour">2。一点动感的行为</a></li>
<li><a href="#_runtime_behaviour_embellishment">3。运行时行为修饰</a></li>
<li><a href="#_more_dynamic_decorating">4。更动感的装饰</a></li>
<li><a href="#_decorating_with_an_interceptor">5，用拦截器装饰</a></li>
<li><a href="#_decorating_with_java_lang_reflect_proxy">6。用java.lang.reflect装饰。代理</a></li>
<li><a href="#_decorating_with_spring">7。用春天装饰</a></li>
<li><a href="#_asynchronous_decorators_using_gpars">8。使用GPar的异步装饰器</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Decorator_pattern">装饰器模式</a>提供了一种在不更改对象基本界面的情况下修饰其行为的机制。装饰对象应该能够在期望原始（未装饰）对象的任何地方进行替换。装饰通常不涉及修改原始对象的源代码，并且装饰者应该能够以灵活的方式组合在一起，以产生具有多个装饰的对象。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traditional_example"><a class="anchor" href="#_traditional_example"></a> 1。传统例子</h2>
<div class="sectionbody">
<div class="paragraph">
<p>假设我们有以下内容<code>Logger</code>类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Logger {
    def log(String message) {
        println message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时，对日志消息进行时间戳记很有用，或者有时我们可能希望更改消息的大小写。我们可以尝试将所有这些功能构建到我们的<code>Logger</code>类。如果我们这样做， <code>Logger</code>课开始会很复杂。而且，即使他们可能不想要功能的一小部分，每个人都将获得所有功能。最后，特征交互将变得非常难以控制。</p>
</div>
<div class="paragraph">
<p>为了克服这些缺点，我们改为定义两个装饰器类。的用途<code>Logger</code>类可以随意按零或更多装饰器类的顺序装饰基础记录器。这些类如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TimeStampingLogger extends Logger {
    private Logger logger
    TimeStampingLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        def now = Calendar.instance
        logger.log("$now.time: $message")
    }
}

class UpperLogger extends Logger {
    private Logger logger
    UpperLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        logger.log(message.toUpperCase())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以像这样使用装饰器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def logger = new UpperLogger(new TimeStampingLogger(new Logger()))
logger.log("G'day Mate")
// =&gt; Tue May 22 07:13:50 EST 2007: G'DAY MATE</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到我们用两个装饰器修饰了记录器的行为。由于我们选择了应用装饰器的顺序，因此我们的日志消息大写，并且时间戳是正常情况下的。如果我们交换订单，让我们看看会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">logger = new TimeStampingLogger(new UpperLogger(new Logger()))
logger.log('Hi There')
// =&gt; TUE MAY 22 07:13:50 EST 2007: HI THERE</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，时间戳本身也已更改为大写。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_touch_of_dynamic_behaviour"><a class="anchor" href="#_a_touch_of_dynamic_behaviour"></a> 2。一点动感的行为</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们以前的装饰师专门针对<code>Logger</code>对象。我们可以使用Groovy的元对象编程功能来创建装饰器，该装饰器实际上是通用的。考虑此类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GenericLowerDecorator {
    private delegate
    GenericLowerDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        def newargs = args.collect { arg -&gt;
            if (arg instanceof String) {
                return arg.toLowerCase()
            } else {
                return arg
            }
        }
        delegate.invokeMethod(name, newargs)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它需要任何类并进行装饰，以便任何<code>String</code>方法参数将自动更改为小写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">logger = new GenericLowerDecorator(new TimeStampingLogger(new Logger()))
logger.log('IMPORTANT Message')
// =&gt; Tue May 22 07:27:18 EST 2007: important message</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意在这里订购。原始装饰者仅限于装饰<code>Logger</code>对象。该装饰器可与任何对象类型一起使用，因此我们无法交换顺序，即这将不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// Can't mix and match Interface-Oriented and Generic decorators
// logger = new TimeStampingLogger(new GenericLowerDecorator(new Logger()))</pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过在运行时生成适当的Proxy类型来克服此限制，但在此不会使示例复杂化。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_runtime_behaviour_embellishment"><a class="anchor" href="#_runtime_behaviour_embellishment"></a> 3。运行时行为修饰</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您也可以考虑使用<code>ExpandoMetaClass</code>从Groovy 1.1开始，以动态修饰类的行为。这不是装饰器模式的正常使用样式（它肯定不那么灵活），但是在某些情况下可以帮助您获得类似的结果而无需创建新类。</p>
</div>
<div class="paragraph">
<p>代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// current mechanism to enable ExpandoMetaClass
GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()

def logger = new Logger()
logger.metaClass.log = { String m -&gt; println 'message: ' + m.toUpperCase() }
logger.log('x')
// =&gt; message: X</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以达到与应用单个装饰器相似的结果，但是我们无法轻松地即时应用和删除装饰。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_dynamic_decorating"><a class="anchor" href="#_more_dynamic_decorating"></a> 4。更动感的装饰</h2>
<div class="sectionbody">
<div class="paragraph">
<p>假设我们有一个计算器类（实际上任何类都可以）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calc {
    def add(a, b) { a + b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可能会对观察类的使用情况感兴趣。如果将其深埋在我们的代码库中，则可能很难确定何时调用它以及使用什么参数。另外，可能很难知道它是否运行良好。我们可以轻松地创建一个通用的跟踪装饰器，该装饰器会在每当<code>Calc</code>类将被调用，并提供有关执行所需时间的时间信息。这是跟踪装饰器的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TracingDecorator {
    private delegate
    TracingDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        println "Calling $name$args"
        def before = System.currentTimeMillis()
        def result = delegate.invokeMethod(name, args)
        println "Got $result in ${System.currentTimeMillis()-before} ms"
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是在脚本中使用类的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def tracedCalc = new TracingDecorator(new Calc())
assert 15 == tracedCalc.add(3, 12)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是运行此脚本后将看到的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Calling add{3, 12}
Got 15 in 31 ms</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_decorating_with_an_interceptor"><a class="anchor" href="#_decorating_with_an_interceptor"></a> 5，用拦截器装饰</h2>
<div class="sectionbody">
<div class="paragraph">
<p>上面的时序示例与Groovy对象的生命周期挂钩（通过<code>invokeMethod</code> ）。这是执行元编程的重要样式，因此Groovy对使用<em>拦截器</em>进行的这种装饰样式有特殊的支持。</p>
</div>
<div class="paragraph">
<p>Groovy甚至内置了<code>TracingInterceptor</code> 。我们可以像这样扩展内置类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TimingInterceptor extends TracingInterceptor {
    private beforeTime
    def beforeInvoke(object, String methodName, Object[] arguments) {
        super.beforeInvoke(object, methodName, arguments)
        beforeTime = System.currentTimeMillis()
    }
    Object afterInvoke(Object object, String methodName, Object[] arguments, Object result) {
        super.afterInvoke(object, methodName, arguments, result)
        def duration = System.currentTimeMillis() - beforeTime
        writer.write("Duration: $duration ms\\n")
        writer.flush()
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是使用此新类的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def proxy = ProxyMetaClass.getInstance(Calc)
proxy.interceptor = new TimingInterceptor()
proxy.use {
    assert 7 == new Calc().add(1, 6)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>before Calc.ctor()
after  Calc.ctor()
Duration: 0 ms
before Calc.add(java.lang.Integer, java.lang.Integer)
after  Calc.add(java.lang.Integer, java.lang.Integer)
Duration: 2 ms</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_decorating_with_java_lang_reflect_proxy"><a class="anchor" href="#_decorating_with_java_lang_reflect_proxy"></a> 6。用java.lang.reflect装饰。代理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您尝试装饰一个对象（即，只是类的特定实例，而不是通常的类），则可以使用Java的<code>java.lang.reflect.Proxy</code> 。Groovy使使用此工具比仅使用Java更容易。以下是从grails项目中提取的代码示例，该项目包装了<code>java.sql.Connection</code>所以它的关闭方法是不操作的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">protected Sql getGroovySql() {
    final Connection con = session.connection()
    def invoker = { object, method, args -&gt;
        if (method.name == "close") {
            log.debug("ignoring call to Connection.close() for use by groovy.sql.Sql")
        } else {
            log.trace("delegating $method")
            return con.invokeMethod(method.name, args)
        }
    } as InvocationHandler;
    def proxy = Proxy.newProxyInstance( getClass().getClassLoader(), [Connection] as Class[], invoker )
    return new Sql(proxy)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有许多方法可以拦截，则可以修改此方法以通过方法名称在映射中查找闭包并调用它。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_decorating_with_spring"><a class="anchor" href="#_decorating_with_spring"></a> 7。用春天装饰</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://www.springframework.org">Spring Framework</a>允许将装饰器与<em>拦截</em>器一起使用（您可能已经听说过<em>advice</em>或<em>Aspect</em>术语）。您也可以从Groovy利用这种机制。</p>
</div>
<div class="paragraph">
<p>首先定义一个您要装饰的类（我们还将像正常的Spring惯例一样使用一个接口）：</p>
</div>
<div class="paragraph">
<p>这是界面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Calc {
    def add(a, b)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是课程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CalcImpl implements Calc {
    def add(a, b) { a + b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们在一个名为<code>beans.xml</code>如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;bean id="performanceInterceptor" autowire="no"
          class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"&gt;
        &lt;property name="loggerName" value="performance"/&gt;
    &lt;/bean&gt;
    &lt;bean id="calc" class="util.CalcImpl"/&gt;
    &lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
        &lt;property name="beanNames" value="calc"/&gt;
        &lt;property name="interceptorNames" value="performanceInterceptor"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们的脚本如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('org.springframework:spring-context:3.2.2.RELEASE')
import org.springframework.context.support.ClassPathXmlApplicationContext

def ctx = new ClassPathXmlApplicationContext('beans.xml')
def calc = ctx.getBean('calc')
println calc.add(3, 25)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们运行它时，我们看到的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>21/05/2007 23:02:35 org.springframework.aop.interceptor.PerformanceMonitorInterceptor invokeUnderTrace
FINEST: StopWatch 'util.Calc.add': running time (millis) = 16</pre>
</div>
</div>
<div class="paragraph">
<p>您可能需要调整您的<code>logging.properties</code>日志级别的消息文件<code>FINEST</code>显示。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_asynchronous_decorators_using_gpars"><a class="anchor" href="#_asynchronous_decorators_using_gpars"></a> 8。使用GPar的异步装饰器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用<a href="http://www.cs.iastate.edu/~design/projects/panini/docs/starting.shtml">Panini中</a>的示例代码获取灵感。这是一个Groovy版本，避免使用<code>@AddedBehavior</code>注释以不具有通常选择装饰方法的算法为代价。这不是对所选择的特定方法的限制，仅是出于说明目的的简化（但不要假设以下内容完全相同）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('org.codehaus.gpars:gpars:0.10')
import static groovyx.gpars.GParsPool.withPool

interface Document {
    void print()
    String getText()
}

class DocumentImpl implements Document {
    def document
    void print() { println document }
    String getText() { document }
}

def words(String text) {
    text.replaceAll('[^a-zA-Z]', ' ').trim().split("\\\\s+")*.toLowerCase()
}

def avgWordLength = {
    def words = words(it.text)
    sprintf "Avg Word Length: %4.2f", words*.size().sum() / words.size()
}
def modeWord = {
    def wordGroups = words(it.text).groupBy {it}.collectEntries { k, v -&gt; [k, v.size()] }
    def maxSize = wordGroups*.value.max()
    def maxWords = wordGroups.findAll { it.value == maxSize }
    "Mode Word(s): ${maxWords*.key.join(', ')} ($maxSize occurrences)"
}
def wordCount = { d -&gt; "Word Count: " + words(d.text).size() }

def asyncDecorator(Document d, Closure c) {
    ProxyGenerator.INSTANCE.instantiateDelegate([print: {
        withPool {
            def result = c.callAsync(d)
            d.print()
            println result.get()
        }
    }], [Document], d)
}

Document d = asyncDecorator(asyncDecorator(asyncDecorator(
        new DocumentImpl(document:"This is the file with the words in it\\n\\t\\nDo you see the words?\\n"),
//        new DocumentImpl(document: new File('AsyncDecorator.groovy').text),
        wordCount), modeWord), avgWordLength)
d.print()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:31 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=4">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>