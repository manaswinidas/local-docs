<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>类型检查扩展</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>类型检查扩展</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_writing_a_type_checking_extension">1。编写类型检查扩展</a>
<ul class="sectlevel2">
<li><a href="#_towards_a_smarter_type_checker">1.1。迈向更智能的类型检查器</a></li>
<li><a href="#Typecheckingextensions-Howdoesitwork">1.2。扩展属性</a></li>
<li><a href="#_a_dsl_for_type_checking">1.3。DSL用于类型检查</a></li>
<li><a href="#Typecheckingextensions-TheAPI">1.4。类型检查扩展API</a>
<ul class="sectlevel3">
<li><a href="#Typecheckingextensions-AST">1.4.1。AST</a></li>
<li><a href="#Typecheckingextensions-Events">1.4.2。大事记</a></li>
</ul>
</li>
<li><a href="#Typecheckingextensions-Workingwithextensions">1.5。使用扩展</a>
<ul class="sectlevel3">
<li><a href="#Typecheckingextensions-Supportclasses">1.5.1。支援课程</a></li>
<li><a href="#Typecheckingextensions-Classnodes">1.5.2。类节点</a></li>
<li><a href="#Typecheckingextensions-Helpingthetypechecker">1.5.3。帮助类型检查器</a></li>
<li><a href="#Typecheckingextensions-Throwinganerror">1.5.4。引发错误</a></li>
<li><a href="#Typecheckingextensions-isXXXExpression">1.5.5。 isXXXExpression</a></li>
<li><a href="#Typecheckingextensions-Virtualmethods">1.5.6。虚方法</a></li>
<li><a href="#Typecheckingextensions-Scoping">1.5.7。范围界定</a></li>
<li><a href="#Typecheckingextensions-Otherusefulmethods">1.5.8。其他有用的方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_advanced_type_checking_extensions">2。高级类型检查扩展</a>
<ul class="sectlevel2">
<li><a href="#_precompiled_type_checking_extensions">2.1。预编译类型检查扩展</a></li>
<li><a href="#_using_grab_in_a_type_checking_extension">2.2。在类型检查扩展中使用@Grab</a></li>
<li><a href="#_sharing_or_packaging_type_checking_extensions">2.3。共享或打包类型检查扩展</a></li>
<li><a href="#_global_type_checking_extensions">2.4。全局类型检查扩展</a></li>
<li><a href="#_type_checking_extensions_and_compilestatic">2.5。类型检查扩展名和@CompileStatic</a></li>
<li><a href="#mixed-mode">2.6。混合模式编译</a></li>
<li><a href="#ast-xform-as-extension">2.7。在扩展中转换AST</a></li>
<li><a href="#_examples">2.8。例子</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_writing_a_type_checking_extension"><a class="anchor" href="#_writing_a_type_checking_extension"></a> 1。编写类型检查扩展</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_towards_a_smarter_type_checker"><a class="anchor" href="#_towards_a_smarter_type_checker"></a> 1.1。迈向更智能的类型检查器</h3>
<div class="paragraph">
<p>尽管是动态语言，但是Groovy可以在编译时与静态类型检查器一起使用， <a href="#static-type-checking">并</a>使用<a href="#static-type-checking">@TypeChecked</a>批注启用。在这种模式下，编译器变得更加冗长，并为例如错别字，不存在的方法等引发错误，但是……这有一些局限性，其中大多数来自Groovy本质上仍然是动态语言的事实。例如，您将无法对使用标记生成器的代码使用类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def builder = new MarkupBuilder(out)
builder.html {
    head {
        // ...
    }
    body {
        p 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上一个示例中， <code>html</code> ， <code>head</code> ， <code>body</code>要么<code>p</code>方法存在。但是，如果执行代码，则它会起作用，因为Groovy使用动态调度并在运行时转换这些方法调用。在此构建器中，您可以使用的标记数量或属性没有限制，这意味着类型检查器没有机会在编译时了解所有可能的方法（标记），除非您创建了构建器例如专用于HTML。</p>
</div>
<div class="paragraph">
<p>Groovy是实现内部DSL的首选平台。灵活的语法以及运行时和编译时元编程功能使Groovy成为一个有趣的选择，因为它使程序员可以专注于DSL而不是工具或实现。由于Groovy DSL是Groovy代码，因此无需编写专用插件即可轻松获得IDE支持。</p>
</div>
<div class="paragraph">
<p>在很多情况下，DSL引擎是用Groovy（或Java）编写的，然后用户代码作为脚本执行，这意味着您在用户逻辑之上拥有某种包装器。包装器可以包括例如<code>GroovyShell</code>要么<code>GroovyScriptEngine</code>在运行脚本之前透明地执行一些任务（添加导入，应用AST转换，扩展基本脚本等）。通常，用户编写的脚本无需测试即可投入生产，因为DSL逻辑可能会<strong>导致任何</strong>用户都可以使用DSL语法编写代码。最后，用户可能只是忽略了他所写的实际上是<strong>代码</strong> 。这给DSL实现者带来了一些挑战，例如确保用户代码的执行安全，或者在这种情况下，早期报告错误。</p>
</div>
<div class="paragraph">
<p>例如，假设有一个DSL，其目标是远程驱动火星上的流动站。向流动站发送消息大约需要15分钟。如果流动站执行脚本并失败并显示错误（例如错字），则您有两个问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，仅在30分钟（流动站获取脚本所需的时间和接收错误所需的时间）之后才提供反馈</p>
</li>
<li>
<p>其次，脚本的某些部分已执行，您可能必须对固定脚本进行重大更改（这意味着您需要了解流动站的当前状态…）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类型检查扩展是一种机制，它允许DSL引擎的开发人员通过对常规groovy类应用静态类型检查所允许的相同类型的检查，从而使这些脚本更安全。</p>
</div>
<div class="paragraph">
<p>这里的原则是尽早失败，也就是说尽快使脚本编译失败，并在可能的情况下向用户提供反馈（包括良好的错误消息）。</p>
</div>
<div class="paragraph">
<p>简而言之，类型检查扩展背后的想法是使编译器了解DSL使用的所有运行时元编程技巧，以便脚本可以像冗长的静态编译代码一样受益于相同的编译时检查级别。我们将看到，您可以通过执行普通类型检查器不会执行的检查来进一步发展，为用户提供强大的编译时检查。</p>
</div>
</div>
<div class="sect2">
<h3 id="Typecheckingextensions-Howdoesitwork"><a class="anchor" href="#Typecheckingextensions-Howdoesitwork"></a> 1.2。扩展属性</h3>
<div class="paragraph">
<p>的<code>@TypeChecked</code>注释支持名为的属性<code>extensions</code> 。此参数采用与<em>类型检查扩展脚本</em>列表相对应的字符串数组。这些脚本是在<strong>编译时</strong>在classpath上找到的。例如，您将编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TypeChecked(extensions='/path/to/myextension.groovy')
void foo() { ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，将使用正常类型检查器的规则对<em>foo</em>方法进行类型检查，这些规则由<em>myextension.groovy</em>脚本中找到的规则完成。请注意，虽然内部类型检查器支持多种机制来实现类型检查扩展（包括普通的旧Java代码），但建议的方法是使用那些类型检查扩展脚本。</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_dsl_for_type_checking"><a class="anchor" href="#_a_dsl_for_type_checking"></a> 1.3。DSL用于类型检查</h3>
<div class="paragraph">
<p>类型检查扩展背后的想法是使用DSL扩展类型检查器功能。通过此DSL，您可以使用“事件驱动” API进入编译过程，尤其是类型检查阶段。例如，当类型检查器进入方法主体时，它将引发<em>beforeVisitMethod</em>事件，扩展可<em>对此</em>作出反应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitMethod { methodNode -&gt;
 println "Entering ${methodNode.name}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>想象一下，您手边有流动站DSL。用户会写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">robot.move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您具有这样定义的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Robot {
    Robot move(int qt) { this }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在执行以下脚本之前，可以对脚本进行类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(TypeChecked)            <i class="conum" data-value="1"></i><b>(1)</b>
)
def shell = new GroovyShell(config)                         <i class="conum" data-value="2"></i><b>(2)</b>
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)                                      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>编译器配置会添加<code>@TypeChecked</code>所有类的注释</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在<code>GroovyShell</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>这样，使用shell编译的脚本将使用<code>@TypeChecked</code>用户无需显式添加它</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用上面的编译器配置，我们可以透明地将<em>@TypeChecked</em>应用于脚本。在这种情况下，它将在编译时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - The variable [robot] is undeclared.</pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们将略微更新配置以包括``扩展''参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['robotextension.groovy'])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将以下内容添加到您的类路径中：</p>
</div>
<div class="listingblock">
<div class="title">机器人扩展</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedVariable { var -&gt;
    if ('robot'==var.name) {
        storeType(var, classNodeFor(Robot))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们告诉编译器，如果找到了一个<em>未解决的变量</em> ，并且该变量的名称是<em>robot</em> ，那么我们可以确保该变量的类型为<code>Robot</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="Typecheckingextensions-TheAPI"><a class="anchor" href="#Typecheckingextensions-TheAPI"></a> 1.4。类型检查扩展API</h3>
<div class="sect3">
<h4 id="Typecheckingextensions-AST"><a class="anchor" href="#Typecheckingextensions-AST"></a> 1.4.1。AST</h4>
<div class="paragraph">
<p>类型检查API是处理抽象语法树的低级API。即使使用DSL不仅比处理纯Java或Groovy的AST代码要容易得多，您还必须非常了解AST才能开发扩展。</p>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Events"><a class="anchor" href="#Typecheckingextensions-Events"></a> 1.4.2。大事记</h4>
<div class="paragraph">
<p>类型检查器发送以下事件，扩展脚本可以对此事件做出反应：</p>
</div>
<table id="event-setup" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>设定</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成初始化后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>没有</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">setup {
    // this is called before anything else
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可用于执行扩展程序的设置</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-finish" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>完</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成类型检查后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>没有</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">finish {
    // this is after completion
    // of all type checking
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型检查器完成工作后，可用于执行其他检查。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedVariable" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>未解决的变量</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器发现一个未解决的变量时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>VariableExpression var</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedVariable { var -&gt;
    if ('people' == var.name) {
        storeType(var, classNodeFor(List))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员通过用户注入的变量帮助类型检查器。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedProperty" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>未解决的属性</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器在接收方上找不到属性时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>PropertyExpression pexp</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedProperty { pexp -&gt;
    if ('longueur'==pexp.propertyAsString &amp;&amp;
        getType(pexp.objectExpression)==classNodeFor(String)) {
        storeType(pexp,classNodeFor(int))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员处理“动态”属性</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedAttribute" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>unresolvedAttribute</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法在接收方上找到属性时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>AttributeExpression AEX</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedAttribute { aex -&gt;
    if (getType(aex.objectExpression)==classNodeFor(String)) {
        storeType(aex,classNodeFor(String))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员处理缺失的属性</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeMethodCall" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在类型检查器开始类型检查方法调用之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeMethodCall { call -&gt;
    if (isMethodCallExpression(call)
            &amp;&amp; call.methodAsString=='toUpperCase') {
        addStaticTypeError('Not allowed',call)
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许您在类型检查器执行自己的检查之前拦截方法调用。如果要用有限范围的自定义检查替换默认类型检查，这很有用。在这种情况下，必须将handled标志设置为true，以便类型检查器跳过自己的检查。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterMethodCall" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成类型检查方法调用后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterMethodCall { call -&gt;
    if (getTargetMethod(call).name=='toUpperCase') {
        addStaticTypeError('Not allowed',call)
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器完成自己的检查之后，允许您执行其他检查。如果您要执行标准的类型检查测试，但又要确保附加的类型安全性（例如，相互检查参数），则这特别有用。注意<code>afterMethodCall</code>即使您做了<code>beforeMethodCall</code>并将handled标志设置为true。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-onMethodSelection" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>onMethodSelection</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器找到适合方法调用的方法时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>表达式expr，MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">onMethodSelection { expr, node -&gt;
    if (node.declaringClass.name == 'java.lang.String') {
        // calling a method on 'String'
        // let’s perform additional checks!
        if (++count&gt;2) {
            addStaticTypeError("You can use only 2 calls on String in your source code",expr)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型检查器通过推断方法调用的参数类型来工作，然后选择目标方法。如果找到一个对应的，则触发此事件。例如，如果您想对特定的方法调用做出反应，例如输入一个以闭包作为参数的方法的作用域（如在构建器中），这很有趣。请注意，可能会为各种类型的表达式引发此事件，而不仅仅是方法调用（例如，二进制表达式）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-methodNotFound" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>methodNotFound</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法为方法调用找到合适的方法时，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode接收者，字符串名称，ArgumentListExpression argList，ClassNode [] argTypes，MethodCall调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    // receiver is the inferred type of the receiver
    // name is the name of the called method
    // argList is the list of arguments the method was called with
    // argTypes is the array of inferred types for each argument
    // call is the method call for which we couldn’t find a target method
    if (receiver==classNodeFor(String)
            &amp;&amp; name=='longueur'
            &amp;&amp; argList.size()==0) {
        handled = true
        return newMethod('longueur', classNodeFor(String))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不像<code>onMethodSelection</code> ，当类型检查器找不到方法调用的目标方法（实例或静态）时，将发送此事件。它使您有机会在将错误发送给用户之前拦截该错误，还可以设置目标方法。为此，您需要返回一个列表<code>MethodNode</code> 。在大多数情况下，您都将返回：一个空列表，这意味着您找不到相应的方法；一个列表中只有一个元素，这表示目标方法毫无疑问。如果返回多个MethodNode，则编译器会向用户抛出错误，指出方法调用不明确，并列出了可能的方法。为了方便起见，如果只想返回一个方法，则可以直接返回它，而不必将其包装到列表中。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitMethod" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器在对方法主体进行类型检查之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitMethod { methodNode -&gt;
    // tell the type checker we will handle the body by ourselves
    handled = methodNode.name.startsWith('skip')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在开始对方法主体进行类型检查之前，类型检查器将调用此方法。例如，如果您要自己执行类型检查而不是让类型检查器执行类型检查，则必须将handled标志设置为true。此事件还可用于帮助定义扩展的范围（例如，仅当您在方法foo中时才应用它）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitMethod" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在对方法主体进行类型检查之后，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterVisitMethod { methodNode -&gt;
    scopeExit {
        if (methods&gt;2) {
            addStaticTypeError("Method ${methodNode.name} contains more than 2 method calls", methodNode)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器访问方法主体之后，使您有机会执行其他检查。例如，如果您收集信息，并希望在收集所有信息后执行其他检查，这将很有用。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitClass" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器在对类进行类型检查之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitClass { ClassNode classNode -&gt;
    def name = classNode.nameWithoutPackage
    if (!(name[0] in 'A'..'Z')) {
        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果对某个班级进行了类型检查，则在访问该班级之前，将发送此事件。在用注释的类中定义的内部类也是如此<code>@TypeChecked</code> 。它可以帮助您定义扩展的范围，甚至可以用自定义类型检查实现完全替代类型检查器的访问。为此，您必须设置<code>handled</code>标记为<code>true</code> 。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitClass" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在完成类型检查类的访问之后，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterVisitClass { ClassNode classNode -&gt;
    def name = classNode.nameWithoutPackage
    if (!(name[0] in 'A'..'Z')) {
        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器完成工作之后，为每个要进行类型检查的类调用。这包括带注释的类<code>@TypeChecked</code>并且不会跳过与相同的类中定义的任何内部/匿名类。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-incompatibleAssignment" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>不兼容分配</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器认为分配不正确时调用，这意味着分配的右侧与左侧不兼容</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode lhsType，ClassNode rhsType，表达式分配</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">incompatibleAssignment { lhsType, rhsType, expr -&gt;
    if (isBinaryExpression(expr) &amp;&amp; isAssignment(expr.operation.type)) {
        if (lhsType==classNodeFor(int) &amp;&amp; rhsType==classNodeFor(Closure)) {
            handled = true
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使开发人员能够处理错误的任务。例如，这在类重写时很有用<code>setProperty</code> ，因为在这种情况下，有可能通过该运行时机制处理将一种类型的变量分配给另一种类型的属性。在这种情况下，您可以通过告诉类型分配有效（可以使用<code>handled</code>调成<code>true</code> ）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-ambiguousMethods" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>模棱两可的方法</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法在几种候选方法之间进行选择时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>列表<methodnode>方法，表达式来源</methodnode></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">ambiguousMethods { methods, origin -&gt;
    // choose the method which has an Integer as parameter type
    methods.find { it.parameters.any { it.type == classNodeFor(Integer) } }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使开发人员能够处理错误的任务。例如，这在类重写时很有用<code>setProperty</code> ，因为在这种情况下，有可能通过该运行时机制处理将一种类型的变量分配给另一种类型的属性。在这种情况下，您可以通过告诉类型分配有效（可以使用<code>handled</code>调成<code>true</code> ）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当然，扩展脚本可能包含多个块，并且您可以具有多个块来响应同一事件。这使DSL看起来更好，更易于编写。但是，对事件做出反应远远不够。如果您知道您可以对事件做出反应，那么您还需要处理错误，这意味着可以使用多种<em>帮助</em>程序来简化事情。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Typecheckingextensions-Workingwithextensions"><a class="anchor" href="#Typecheckingextensions-Workingwithextensions"></a> 1.5。使用扩展</h3>
<div class="sect3">
<h4 id="Typecheckingextensions-Supportclasses"><a class="anchor" href="#Typecheckingextensions-Supportclasses"></a> 1.5.1。支援课程</h4>
<div class="paragraph">
<p>DSL依赖于称为<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc的支持类</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">。GroovyTypeCheckingExtensionSupport</a> 。此类本身扩展了<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html">org.codehaus.groovy.transform.stc。TypeCheckingExtension</a> 。这两个类定义了许多<em>帮助程序</em>方法，这些方法将使AST的使用更加容易，尤其是在类型检查方面。要知道的一件有趣的事是您<strong>可以访问类型检查器</strong> 。这意味着您可以以编程方式调用类型检查器的方法，包括那些允许<strong>引发编译错误的方法</strong> 。</p>
</div>
<div class="paragraph">
<p>扩展脚本委托给<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport</a>类，意味着您可以直接访问以下变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>context</em> ：类型检查器上下文，类型为<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingContext.html">org.codehaus.groovy.transform.stc。TypeCheckingContext</a></p>
</li>
<li>
<p><em>typeCheckingVisitor</em> ：类型检查器本身，一个<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.html">org.codehaus.groovy.transform.stc。StaticTypeCheckingVisitor</a>实例</p>
</li>
<li>
<p><em>generateMethods</em> ：“生成的方法”列表，实际上是可以使用类型检查扩展名在内部创建的“虚拟”方法列表。 <code>newMethod</code>来电</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类型检查上下文包含许多在类型检查器的上下文中有用的信息。例如，当前的封装方法调用，二进制表达式，闭包等堆栈……如果必须知道发生错误并要处理错误的<em>位置</em> ，则此信息特别重要。</p>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Classnodes"><a class="anchor" href="#Typecheckingextensions-Classnodes"></a> 1.5.2。类节点</h4>
<div class="paragraph">
<p>使用类型检查扩展时，处理类节点需要特别注意。编译使用抽象语法树（AST），并且在对类进行类型检查时该树可能不完整。这也意味着，当您引用类型时，不得使用诸如<code>String</code>要么<code>HashSet</code> ，但将代表这些类型的节点分类。这需要一定程度的抽象，并了解Groovy如何处理类节点。为了使事情变得容易，Groovy提供了几种帮助程序方法来处理类节点。例如，如果您想说“字符串的类型”，则可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert classNodeFor(String) instanceof ClassNode</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还会注意到，有一个<em>classNodeFor</em>的变体，它需要一个<code>String</code>作为参数，而不是<code>Class</code> 。在一般情况下，你<strong>不</strong>应该使用那一个，因为它的名字就是它会创建一个类节点<code>String</code> ，但没有任何方法，也没有在其上定义任何属性。第一个版本将返回一类节点是<em>解决了</em> ，但第二个返回一个<em>不是</em> 。因此，后者应保留给非常特殊的情况。</p>
</div>
<div class="paragraph">
<p>您可能遇到的第二个问题是引用尚未编译的类型。这可能比您想像的更多。例如，当您一起编译一组文件时。在这种情况下，如果您想说“那个变量是Foo类型”，但是<code>Foo</code>尚未编译，您仍然可以参考<code>Foo</code>类节点使用<code>lookupClassNodeFor</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert lookupClassNodeFor('Foo') instanceof ClassNode</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Helpingthetypechecker"><a class="anchor" href="#Typecheckingextensions-Helpingthetypechecker"></a> 1.5.3。帮助类型检查器</h4>
<div class="paragraph">
<p>假设您知道该变量<code>foo</code>是类型<code>Foo</code>并且您想告诉类型检查器。然后您可以使用<code>storeType</code>方法，它有两个参数：第一个是要存储其类型的节点，第二个是节点的类型。如果你看执行<code>storeType</code> ，您会看到它委托给类型检查器等效方法，该方法本身在存储节点元数据方面做了很多工作。您还将看到，存储类型不仅限于变量：您可以设置任何表达式的类型。</p>
</div>
<div class="paragraph">
<p>同样，获取AST节点的类型只是调用<code>getType</code>在那个节点上。通常，这就是您想要的，但是您必须了解一些内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getType</code>返回表达式的<strong>推断类型</strong> 。这意味着对于声明为type的变量，它不会返回<code>Object</code>的类节点<code>Object</code> ，但在<strong>代码的这一点上</strong>推断出此变量的类型（流类型）</p>
</li>
<li>
<p>如果要访问变量（或字段/参数）的原始类型，则必须在AST节点上调用适当的方法</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Throwinganerror"><a class="anchor" href="#Typecheckingextensions-Throwinganerror"></a> 1.5.4。引发错误</h4>
<div class="paragraph">
<p>要引发类型检查错误，您只需调用<code>addStaticTypeError</code>具有两个参数的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一条<em>消息</em> ，它是将显示给最终用户的字符串</p>
</li>
<li>
<p>负责该错误的<em>AST节点</em> 。最好提供最合适的AST节点，因为它将用于检索行号和列号</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-isXXXExpression"><a class="anchor" href="#Typecheckingextensions-isXXXExpression"></a> 1.5.5。 isXXXExpression</h4>
<div class="paragraph">
<p>通常需要知道AST节点的类型。为了提高可读性，DSL提供了一种特殊的isXXXExpression方法，该方法将委托给<code>x instance of XXXExpression</code> 。例如，代替编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (node instanceof BinaryExpression) {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要您导入<code>BinaryExpression</code>上课，你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (isBinaryExpression(node)) {
   ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Virtualmethods"><a class="anchor" href="#Typecheckingextensions-Virtualmethods"></a> 1.5.6。虚方法</h4>
<div class="paragraph">
<p>当您执行动态代码的类型检查时，您可能经常会遇到这样的情况：知道方法调用有效，但背后没有“真正的”方法。例如，以Grails动态查找器为例。您可以进行一个名为<em>findByName（…）</em>的方法调用。由于在bean中没有定义<em>findByName</em>方法，因此类型检查器会抱怨。但是，您会知道此方法在运行时不会失败，甚至可以说出此方法的返回类型是什么。对于这种情况，DSL支持两种特殊的结构，它们由<em>幻影方法</em>组成。这意味着您将返回一个实际上不存在但在类型检查的上下文中定义的方法节点。存在三种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newMethod(String name, Class returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, ClassNode returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, Callable<ClassNode> return Type)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这三个变体都执行相同的操作：它们创建一个新方法节点，该名称为提供的名称，并定义此方法的返回类型。此外，类型检查器会将这些方法添加到<code>generatedMethods</code>清单（请参阅<code>isGenerated</code>下面）。我们仅设置名称和返回类型的原因是，在90％的情况下，仅它就是您所需要的。例如，在<code>findByName</code>示例鞋帮，您唯一需要知道的是<code>findByName</code>在运行时不会失败，并且它返回一个域类。的<code>Callable</code>返回类型的版本很有趣，因为当类型检查器实际需要返回类型时，它会延迟返回类型的计算。这很有趣，因为在某些情况下，当类型检查器需要它时，您可能不知道实际的返回类型，因此您可以使用每次都会调用的闭包。 <code>getReturnType</code>由此方法节点上的类型检查器调用。如果将此与延迟检查结合使用，则可以实现相当复杂的类型检查，包括对前向引用的处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">newMethod(name) {
    // each time getReturnType on this method node will be called, this closure will be called!
    println 'Type checker called me!'
    lookupClassNodeFor(Foo) // return type
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要的不仅是名称和返回类型，还可以随时创建一个新的<code>MethodNode</code>由你自己。</p>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Scoping"><a class="anchor" href="#Typecheckingextensions-Scoping"></a> 1.5.7。范围界定</h4>
<div class="paragraph">
<p>范围界定在DSL类型检查中非常重要，也是我们无法使用基于<em>切入点</em>的方法进行DSL类型检查的原因之一。基本上，您必须能够非常精确地定义您的扩展何时适用以及何时不适用。此外，您必须能够处理常规类型检查器无法处理的情况，例如前向引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">point a(1,1)
line a,b // b is referenced afterwards!
point b(5,2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>举例来说，您要处理一个构建器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">builder.foo {
   bar
   baz(bar)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，您的扩展程序只有在您输入<code>foo</code>方法，并且在此范围之外处于非活动状态。但是您可能会遇到复杂的情况，例如同一文件中的多个构建器或嵌入式构建器（构建器中的构建器）。尽管您不应该尝试从一开始就解决所有问题（必须接受类型检查的限制），但类型检查器确实提供了一种很好的机制来处理此问题：使用<code>newScope</code>和<code>scopeExit</code>方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newScope</code>创建一个新的作用域并将其放在栈顶</p>
</li>
<li>
<p><code>scopeExits</code>从堆栈弹出作用域</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>范围包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>父范围</p>
</li>
<li>
<p>定制数据图</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您想看一下实现，那只是一个<code>LinkedHashMap</code> （ <a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport/TypeCheckingScope.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport。TypeCheckingScope</a> ），但功能非常强大。例如，您可以使用这种范围存储退出范围时要执行的闭包列表。这是您处理前向引用的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def scope = newScope()
scope.secondPassChecks = []
//...
scope.secondPassChecks &lt;&lt; { println 'executed later' }
// ...
scopeExit {
    secondPassChecks*.run() // execute deferred checks
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是说，如果在某个时候您无法确定表达式的类型，或者在这一点上您无法检查赋值是否有效，您仍然可以稍后进行检查……是一项非常强大的功能。现在， <code>newScope</code>和<code>scopeExit</code>提供一些有趣的语法糖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">newScope {
    secondPassChecks = []
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在DSL中的任何时间，您都可以使用<code>getCurrentScope()</code>或更简单<code>currentScope</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">//...
currentScope.secondPassChecks &lt;&lt; { println 'executed later' }
// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>通用模式将是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确定<em>切入点</em> ，在该<em>切入点</em>上将新作用域推入堆栈并在该作用域内初始化自定义变量</p>
</li>
<li>
<p>使用各种事件，您可以使用存储在自定义范围中的信息来执行检查，推迟检查等等。</p>
</li>
<li>
<p>确定退出范围的<em>切入点</em> ，调用<code>scopeExit</code>并最终执行其他检查</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Otherusefulmethods"><a class="anchor" href="#Typecheckingextensions-Otherusefulmethods"></a> 1.5.8。其他有用的方法</h4>
<div class="paragraph">
<p>有关帮助程序方法的完整列表，请参考<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport</a>和<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html">org.codehaus.groovy.transform.stc。TypeCheckingExtension</a>类。但是，请特别注意以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>isDynamic</code> ：使用VariableExpression作为参数，如果变量是DynamicExpression，则返回true，这意味着在脚本中未使用类型或<code>def</code> 。</p>
</li>
<li>
<p><code>isGenerated</code> ：以MethodNode作为参数，并使用该方法判断类型是否由类型检查器扩展生成。 <code>newMethod</code>方法</p>
</li>
<li>
<p><code>isAnnotatedBy</code> ：接受一个AST节点和一个Class（或ClassNode），并告诉该节点是否用此类注释。例如：<code>isAnnotatedBy(node, NotNull)</code></p>
</li>
<li>
<p><code>getTargetMethod</code> ：将方法调用作为参数并返回<code>MethodNode</code>类型检查器已为此确定的</p>
</li>
<li>
<p><code>delegatesTo</code> ：模拟的行为<code>@DelegatesTo</code>注解。它允许您告诉参数将委托给特定类型（您也可以指定委托策略）</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_type_checking_extensions"><a class="anchor" href="#_advanced_type_checking_extensions"></a> 2。高级类型检查扩展</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_precompiled_type_checking_extensions"><a class="anchor" href="#_precompiled_type_checking_extensions"></a> 2.1。预编译类型检查扩展</h3>
<div class="paragraph">
<p>上面的所有示例都使用类型检查脚本。它们以类路径的源代码形式存在，这意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对应于类型检查扩展名的Groovy源文件在编译类路径上可用</p>
</li>
<li>
<p>该文件由Groovy编译器针对要编译的每个源单元进行编译（通常，一个源单元对应于一个文件）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是开发类型检查扩展名的一种非常方便的方法，但是由于要为每个要编译的文件扩展名本身的编译，因此它意味着编译阶段较慢。由于这些原因，依靠预编译的扩展可能是实际的。您可以通过以下两种方法执行此操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用Groovy编写扩展，进行编译，然后使用对扩展类的引用而不是源代码</p>
</li>
<li>
<p>用Java编写扩展，进行编译，然后使用对扩展类的引用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用Groovy编写类型检查扩展是最简单的方法。基本上，这种想法是类型检查扩展脚本成为类型检查扩展类的main方法的主体，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport

class PrecompiledExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {     <i class="conum" data-value="1"></i><b>(1)</b>
    @Override
    Object run() {                                                                          <i class="conum" data-value="2"></i><b>(2)</b>
        unresolvedVariable { var -&gt;
            if ('robot'==var.name) {
                storeType(var, classNodeFor(Robot))                                         <i class="conum" data-value="3"></i><b>(3)</b>
                handled = true
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扩展<code>TypeCheckingDSL</code>上课是最简单的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>那么扩展代码需要放入<code>run</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>您可以使用与以源代码形式编写的扩展程序相同的事件</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>设置扩展与使用源表单扩展非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['typing.PrecompiledExtension'])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>区别在于，您无需指定classpath中的路径，而只需指定预编译扩展名的完全限定的类名即可。</p>
</div>
<div class="paragraph">
<p>如果您真的想用Java编写扩展，那么您将不会从类型检查扩展DSL中受益。可以使用以下方式用Java重写上面的扩展名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import org.codehaus.groovy.ast.ClassHelper;
import org.codehaus.groovy.ast.expr.VariableExpression;
import org.codehaus.groovy.transform.stc.AbstractTypeCheckingExtension;


import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;

public class PrecompiledJavaExtension extends AbstractTypeCheckingExtension {                   <i class="conum" data-value="1"></i><b>(1)</b>

    public PrecompiledJavaExtension(final StaticTypeCheckingVisitor typeCheckingVisitor) {
        super(typeCheckingVisitor);
    }

    @Override
    public boolean handleUnresolvedVariableExpression(final VariableExpression vexp) {          <i class="conum" data-value="2"></i><b>(2)</b>
        if ("robot".equals(vexp.getName())) {
            storeType(vexp, ClassHelper.make(Robot.class));
            setHandled(true);
            return true;
        }
        return false;
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扩展<code>AbstractTypeCheckingExtension</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后覆盖<code>handleXXX</code>所需方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_using_grab_in_a_type_checking_extension"><a class="anchor" href="#_using_grab_in_a_type_checking_extension"></a> 2.2。在类型检查扩展中使用@Grab</h3>
<div class="paragraph">
<p>完全有可能使用<code>@Grab</code>类型检查扩展中的注释。这意味着您可以包括仅在编译时可用的库。在这种情况下，您必须了解，将大大增加编译时间（至少在第一次获取依赖项时）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_sharing_or_packaging_type_checking_extensions"><a class="anchor" href="#_sharing_or_packaging_type_checking_extensions"></a> 2.3。共享或打包类型检查扩展</h3>
<div class="paragraph">
<p>类型检查扩展仅仅是需要放在类路径中的脚本。这样，您可以按原样共享它，或将其捆绑在一个将添加到类路径的jar文件中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_global_type_checking_extensions"><a class="anchor" href="#_global_type_checking_extensions"></a> 2.4。全局类型检查扩展</h3>
<div class="paragraph">
<p>虽然您可以配置编译器以透明地将类型检查扩展添加到脚本中，但是当前无法仅通过将扩展放在类路径上来透明地应用扩展。</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_checking_extensions_and_compilestatic"><a class="anchor" href="#_type_checking_extensions_and_compilestatic"></a> 2.5。类型检查扩展名和@CompileStatic</h3>
<div class="paragraph">
<p>类型检查扩展与<code>@TypeChecked</code>但也可以与<code>@CompileStatic</code> 。但是，您必须意识到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用于的类型检查扩展<code>@CompileStatic</code>通常不足以让编译器知道如何从“不安全”代码生成静态可编译代码</p>
</li>
<li>
<p>可以使用带有<code>@CompileStatic</code>只是为了增强类型检查，也就是说引入了<strong>更多的</strong>编译错误，而没有实际处理动态代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们解释一下第一点，即即使使用扩展，编译器也不会知道如何静态地编译代码：从技术上讲，即使您告诉类型检查器动态变量的类型是什么，例如不知道如何编译它。是吗<code>getBinding('foo')</code> ， <code>getProperty('foo')</code> ， <code>delegate.getFoo()</code> ，...？即使使用类型检查扩展，也绝对没有直接的方法来告诉静态编译器如何编译此类代码（同样，它只会给出有关类型的提示）。</p>
</div>
<div class="paragraph">
<p>对于此特定示例，一种可能的解决方案是指示编译器使用<a href="#mixed-mode">混合模式编译</a> 。一种更高级的方法是<a href="#ast-xform-as-extension">在类型检查期间</a>使用<a href="#ast-xform-as-extension">AST转换，</a>但这要复杂得多。</p>
</div>
<div class="paragraph">
<p>类型检查扩展允许您在失败的地方帮助类型检查器，但也可以在没有失败的地方帮助失败。在这种情况下，支持扩展<code>@CompileStatic</code>太。想象一下一个能够对SQL查询进行类型检查的扩展。在那种情况下，扩展名在动态和静态上下文中都是有效的，因为没有扩展名，代码仍然可以通过。</p>
</div>
</div>
<div class="sect2">
<h3 id="mixed-mode"><a class="anchor" href="#mixed-mode"></a> 2.6。混合模式编译</h3>
<div class="paragraph">
<p>在上一节中，我们强调了您可以使用以下命令激活类型检查扩展的事实： <code>@CompileStatic</code> 。在这种情况下，类型检查器将不再抱怨某些未解析的变量或未知的方法调用，但仍然不知道如何静态地编译它们。</p>
</div>
<div class="paragraph">
<p>混合模式编译提供了第三种方法，即指示编译器，只要找到未解析的变量或方法调用，则应退回到动态模式。这要归功于类型检查扩展和特殊的<code>makeDynamic</code>呼叫。</p>
</div>
<div class="paragraph">
<p>为了说明这一点，让我们回到<code>Robot</code>例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">robot.move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们尝试使用激活我们的类型检查扩展程序<code>@CompileStatic</code>代替<code>@TypeChecked</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      <i class="conum" data-value="1"></i><b>(1)</b>
        extensions:['robotextension.groovy'])               <i class="conum" data-value="2"></i><b>(2)</b>
)
def shell = new GroovyShell(config)
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>应用<code>@CompileStatic</code>透明地</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>激活类型检查扩展</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该脚本可以正常运行，因为静态编译器会被告知有关类型的信息。 <code>robot</code>变量，因此它可以直接调用<code>move</code> 。但在此之前，编译器如何知道如何获取<code>robot</code>变量？实际上，默认情况下，在类型检查扩展中，设置<code>handled=true</code>在未解析的变量上将自动触发动态分辨率，因此在这种情况下，您没有什么特别的条件可以使编译器使用混合模式。但是，让我们从机器人脚本开始稍微更新一下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里您可以注意到没有参考<code>robot</code>不再。那么我们的扩展将无济于事，因为我们将无法指示编译器<code>move</code>完成于<code>Robot</code>实例。借助于<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/DelegatingScript.html">groovy.util ，可以完全动态地执行此代码示例</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/DelegatingScript.html">。DelegatingScript</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.scriptBaseClass = 'groovy.util.DelegatingScript'     <i class="conum" data-value="1"></i><b>(1)</b>
def shell = new GroovyShell(config)
def runner = shell.parse(script)                            <i class="conum" data-value="2"></i><b>(2)</b>
runner.setDelegate(new Robot())                             <i class="conum" data-value="3"></i><b>(3)</b>
runner.run()                                                <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们将编译器配置为使用<code>DelegatingScript</code>作为基类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>脚本源需要解析，并将返回的实例<code>DelegatingScript</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后我们可以打电话<code>setDelegate</code>使用<code>Robot</code>作为脚本的委托</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后执行脚本。 <code>move</code>将直接在委托上执行</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们希望通过<code>@CompileStatic</code> ，我们必须使用类型检查扩展名，因此让我们更新配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      <i class="conum" data-value="1"></i><b>(1)</b>
        extensions:['robotextension2.groovy'])              <i class="conum" data-value="2"></i><b>(2)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>应用<code>@CompileStatic</code>透明地</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用备用的类型检查扩展名来识别对<code>move</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后在上一节中，我们学习了如何处理无法识别的方法调用，因此我们可以编写此扩展名：</p>
</div>
<div class="listingblock">
<div class="title">robotextension2.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    if (isMethodCallExpression(call)                        <i class="conum" data-value="1"></i><b>(1)</b>
        &amp;&amp; call.implicitThis                                <i class="conum" data-value="2"></i><b>(2)</b>
        &amp;&amp; 'move'==name                                     <i class="conum" data-value="3"></i><b>(3)</b>
        &amp;&amp; argTypes.length==1                               <i class="conum" data-value="4"></i><b>(4)</b>
        &amp;&amp; argTypes[0] == classNodeFor(int)                 <i class="conum" data-value="5"></i><b>(5)</b>
    ) {
        handled = true                                      <i class="conum" data-value="6"></i><b>(6)</b>
        newMethod('move', classNodeFor(Robot))              <i class="conum" data-value="7"></i><b>(7)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果调用是方法调用（不是静态方法调用）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该调用是基于“隐式这样做”（没有明确的<code>this.</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>被调用的方法是<code>move</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>并且该调用是通过单个参数完成的</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>而该参数是类型<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>然后告诉类型检查器该调用是有效的</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>并且该呼叫的返回类型为<code>Robot</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您尝试执行此代码，那么您可能会惊讶于它实际上在运行时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.NoSuchMethodError: java.lang.Object.move()Ltyping/Robot;</pre>
</div>
</div>
<div class="paragraph">
<p>原因很简单：尽管类型检查扩展足以满足<code>@TypeChecked</code> ，它不涉及静态编译，对于<code>@CompileStatic</code>这需要其他信息。在这种情况下，您告诉编译器该方法已经存在，但是您没有向它解释它实际上是<strong>什么</strong>方法，以及消息的接收者（委托）是什么。</p>
</div>
<div class="paragraph">
<p>解决此问题非常容易，仅意味着更换<code>newMethod</code>打电话给别的东西：</p>
</div>
<div class="listingblock">
<div class="title">robotextension3.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    if (isMethodCallExpression(call)
        &amp;&amp; call.implicitThis
        &amp;&amp; 'move'==name
        &amp;&amp; argTypes.length==1
        &amp;&amp; argTypes[0] == classNodeFor(int)
    ) {
        makeDynamic(call, classNodeFor(Robot))              <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>告诉编译器调用应该动态化</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>makeDynamic</code>呼叫执行3件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它返回一个虚拟方法，就像<code>newMethod</code></p>
</li>
<li>
<p>自动设置<code>handled</code>标记为<code>true</code>为了你</p>
</li>
<li>
<p>但也标志着<code>call</code>动态地完成</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，当编译器必须生成用于调用的字节码时<code>move</code> ，由于现在已将其标记为动态调用，因此它将回退到动态编译器并让其处理该调用。由于扩展名告诉我们动态调用的返回类型是<code>Robot</code> ，后续调用将静态完成！</p>
</div>
<div class="paragraph">
<p>有人会奇怪为什么静态编译器默认情况下没有扩展就不会这样做。这是一个设计决策：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果代码是静态编译的，我们通常需要类型安全和最佳性能</p>
</li>
<li>
<p>因此，如果使无法识别的变量/方法调用动态化，则会失去类型安全性，而且在编译时还完全支持错别字！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>简而言之，如果您要进行混合模式编译，则<strong>必须</strong>通过类型检查扩展将其明确显示，以便编译器和DSL设计人员完全了解自己在做什么。</p>
</div>
<div class="paragraph">
<p><code>makeDynamic</code>可以在3种AST节点上使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法节点（ <code>MethodNode</code> ）</p>
</li>
<li>
<p>一个变量 （ <code>VariableExpression</code> ）</p>
</li>
<li>
<p>属性表达式（ <code>PropertyExpression</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这还不够，那就意味着不能直接进行静态编译，而您必须依靠AST转换。</p>
</div>
</div>
<div class="sect2">
<h3 id="ast-xform-as-extension"><a class="anchor" href="#ast-xform-as-extension"></a> 2.7。在扩展中转换AST</h3>
<div class="paragraph">
<p>从AST转换设计的角度来看，类型检查扩展看起来非常有吸引力：扩展可以访问诸如推断类型之类的上下文，这通常很不错。扩展可以直接访问抽象语法树。由于您可以访问AST，因此从理论上讲，没有什么可以阻止您修改AST。但是，我们不建议您这样做，除非您是高级AST转换设计器并且非常了解编译器内部：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，您将明确打破类型检查的约定，即仅对AST进行注释。类型检查<strong>不</strong>应该修改AST树，因为你不就能够保证了，如果没有<em>@TypeChecked</em>注释代码的行为，而不标注相同。</p>
</li>
<li>
<p>如果您的扩展名旨在与<em>@CompileStatic</em>配合<em>使用</em> ，则<strong>可以</strong>修改AST，因为这确实是<em>@CompileStatic</em>最终将执行的操作。静态编译并不能保证在动态的Groovy相同的语义，从而有效地存在与<em>@CompileStatic</em>与<em>@TypeChecked</em>编译代码编译的代码之间的差异。由您决定要更新AST的策略，但是可能使用在类型检查变得更容易之前运行的AST转换。</p>
</li>
<li>
<p>如果您不能依靠类型检查器之前启动的转换，则必须<strong>非常</strong>小心</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">类型检查阶段是生成字节码之前在编译器中运行的最后一个阶段。所有其他AST转换都在此之前运行，并且编译器在“修复”类型检查阶段之前生成的错误AST方面做得非常出色。在类型检查期间（例如直接在类型检查扩展中）执行转换后，您必须自己完成所有工作，以生成100％兼容编译器的抽象语法树，这很容易变得复杂。因此，如果您从类型检查扩展和AST转换开始，我们不建议您这样做。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_examples"><a class="anchor" href="#_examples"></a> 2.8。例子</h3>
<div class="paragraph">
<p>现实生活中类型检查扩展的示例很容易找到。您可以下载Groovy的源代码，并查看链接到<a href="https://github.com/apache/groovy/tree/master/src/test-resources/groovy/transform/stc">各种扩展脚本</a>的<a href="https://github.com/apache/groovy/blob/master/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy">TypeCheckingExtensionsTest</a>类。</p>
</div>
<div class="paragraph">
<p>可以在<a href="markup-template-engine.html">标记模板引擎</a>源代码中找到复杂类型检查扩展的示例：该模板引擎依靠类型检查扩展和AST转换将模板转换为完全静态编译的代码。可以在<a href="https://github.com/apache/groovy/tree/master/subprojects/groovy-templates/src/main/groovy/groovy/text/markup">这里</a>找到其来源。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>