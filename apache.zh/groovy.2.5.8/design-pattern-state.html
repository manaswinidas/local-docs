<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>状态模式</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=0">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>状态模式</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_example">1。例</a></li>
<li><a href="#_variation_1_leveraging_interface_oriented_design">2。变体1：利用面向接口的设计</a></li>
<li><a href="#_variation_2_extract_state_pattern_logic">3。方案2：提取状态模式逻辑</a></li>
<li><a href="#_variation_3_bring_on_the_dsl">4。变体3：启用DSL</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/State_pattern">状态模式</a>提供了一种在复杂系统中划分行为的结构化方法。系统的整体行为分为良好定义的状态。通常，每个状态由一个类实现。首先可以通过了解系统的<em>当前状态</em>来确定整个系统的行为；其次，通过了解在该状态下可能的行为（体现在与该状态相对应的类的方法中）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example"><a class="anchor" href="#_example"></a> 1。例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Client {
    def context = new Context()
    def connect() {
        context.state.connect()
    }
    def disconnect() {
        context.state.disconnect()
    }
    def send_message(message) {
        context.state.send_message(message)
    }
    def receive_message() {
        context.state.receive_message()
    }
}

class Context {
    def state = new Offline(this)
}

class ClientState {
    def context
    ClientState(context) {
        this.context = context
        inform()
    }
}

class Offline extends ClientState {
    Offline(context) {
        super(context)
    }
    def inform() {
        println "offline"
    }
    def connect() {
        context.state = new Online(context)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends ClientState {
    Online(context) {
        super(context)
    }
    def inform() {
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        context.state = new Offline(context)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>offline
error: not connected
connected
"Hello" sent
error: already connected
message received
offline</pre>
</div>
</div>
<div class="paragraph">
<p>但是，对于像Groovy这样的动态语言来说，很棒的事情之一就是我们可以举这个例子，并根据我们的特殊需求以多种不同的方式来表达它。该示例的一些潜在变化如下所示。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_variation_1_leveraging_interface_oriented_design"><a class="anchor" href="#_variation_1_leveraging_interface_oriented_design"></a> 2。变体1：利用面向接口的设计</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们可以采用的一种方法是利用<a href="http://www.pragmaticprogrammer.com/titles/kpiod/index.html">面向接口的设计</a> 。为此，我们可以引入以下接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface State {
    def connect()
    def disconnect()
    def send_message(message)
    def receive_message()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们的<code>Client</code> ， <code>Online</code>和“离线”类可以进行修改以实现该接口，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Client implements State {
  // ... as before ...
}

class Online implements State {
  // ... as before ...
}

class Offline implements State {
  // ... as before ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会问：我们是否刚刚引入了其他样板代码？我们不能依靠鸭子打字吗？答案是“是”和“否”。我们可以避免使用鸭式输入法，但是状态模式的主要目的之一是划分复杂度。如果我们知道<em>客户</em>类和每个<em>状态</em>类都满足一个接口，那么我们就在复杂性上设置了一些关键界限。我们可以孤立地查看任何状态类，并且知道该状态可能的行为范围。</p>
</div>
<div class="paragraph">
<p>我们不必为此使用接口，但是它有助于表达这种特定分区样式的意图，并且有助于减小单元测试的大小（我们将不得不使用其他测试来以这种语言表达这种意图。对面向接口设计的支持较少）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_variation_2_extract_state_pattern_logic"><a class="anchor" href="#_variation_2_extract_state_pattern_logic"></a> 3。方案2：提取状态模式逻辑</h2>
<div class="sectionbody">
<div class="paragraph">
<p>或者，或者与其他变体结合，我们可能决定将某些状态模式逻辑提取到帮助程序类中。例如，我们可以在状态模式package / jar / script中定义以下类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class InstanceProvider {
    static def registry = GroovySystem.metaClassRegistry
    static def create(objectClass, param) {
        registry.getMetaClass(objectClass).invokeConstructor([param] as Object[])
    }
}

abstract class Context {
    private context
    protected setContext(context) {
        this.context = context
    }
    def invokeMethod(String name, Object arg) {
        context.invokeMethod(name, arg)
    }
    def startFrom(initialState) {
        setContext(InstanceProvider.create(initialState, this))
    }
}

abstract class State {
    private client

    State(client) { this.client = client }

    def transitionTo(nextState) {
        client.setContext(InstanceProvider.create(nextState, client))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这都是非常通用的，可以在我们要引入状态模式的任何地方使用。这是我们的代码现在的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Client extends Context {
    Client() {
        startFrom(Offline)
    }
}

class Offline extends State {
    Offline(client) {
        super(client)
        println "offline"
    }
    def connect() {
        transitionTo(Online)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends State {
    Online(client) {
        super(client)
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        transitionTo(Offline)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在这里看到<code>startFrom</code>和<code>transitionTo</code>方法开始使我们的示例代码具有DSL的感觉。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_variation_3_bring_on_the_dsl"><a class="anchor" href="#_variation_3_bring_on_the_dsl"></a> 4。变体3：启用DSL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>替代地，或与其他变体结合，我们可能决定完全采用针对该示例的领域特定语言（DSL）方法。</p>
</div>
<div class="paragraph">
<p>我们可以定义以下通用辅助函数（在<a href="http://www.bytemycode.com/snippets/snippet/640/">此</a>首先讨论）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Grammar {
    def fsm

    def event
    def fromState
    def toState

    Grammar(a_fsm) {
        fsm = a_fsm
    }

    def on(a_event) {
        event = a_event
        this
    }

    def on(a_event, a_transitioner) {
        on(a_event)
        a_transitioner.delegate = this
        a_transitioner.call()
        this
    }

    def from(a_fromState) {
        fromState = a_fromState
        this
    }

    def to(a_toState) {
        assert a_toState, "Invalid toState: $a_toState"
        toState = a_toState
        fsm.registerTransition(this)
        this
    }

    def isValid() {
        event &amp;&amp; fromState &amp;&amp; toState
    }

    public String toString() {
        "$event: $fromState=&gt;$toState"
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class FiniteStateMachine {
    def transitions = [:]

    def initialState
    def currentState

    FiniteStateMachine(a_initialState) {
        assert a_initialState, "You need to provide an initial state"
        initialState = a_initialState
        currentState = a_initialState
    }

    def record() {
        Grammar.newInstance(this)
    }

    def reset() {
        currentState = initialState
    }

    def isState(a_state) {
        currentState == a_state
    }

    def registerTransition(a_grammar) {
        assert a_grammar.isValid(), "Invalid transition ($a_grammar)"
        def transition
        def event = a_grammar.event
        def fromState = a_grammar.fromState
        def toState = a_grammar.toState

        if (!transitions[event]) {
            transitions[event] = [:]
        }

        transition = transitions[event]
        assert !transition[fromState], "Duplicate fromState $fromState for transition $a_grammar"
        transition[fromState] = toState
    }

    def fire(a_event) {
        assert currentState, "Invalid current state '$currentState': passed into constructor"
        assert transitions.containsKey(a_event), "Invalid event '$a_event', should be one of ${transitions.keySet()}"
        def transition = transitions[a_event]
        def nextState = transition[currentState]
        assert nextState, "There is no transition from '$currentState' to any other state"
        currentState = nextState
        currentState
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以像这样定义和测试状态机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class StatePatternDslTest extends GroovyTestCase {
    private fsm

    protected void setUp() {
        fsm = FiniteStateMachine.newInstance('offline')
        def recorder = fsm.record()
        recorder.on('connect').from('offline').to('online')
        recorder.on('disconnect').from('online').to('offline')
        recorder.on('send_message').from('online').to('online')
        recorder.on('receive_message').from('online').to('online')
    }

    void testInitialState() {
        assert fsm.isState('offline')
    }

    void testOfflineState() {
        shouldFail{
            fsm.fire('send_message')
        }
        shouldFail{
            fsm.fire('receive_message')
        }
        shouldFail{
            fsm.fire('disconnect')
        }
        assert 'online' == fsm.fire('connect')
    }

    void testOnlineState() {
        fsm.fire('connect')
        fsm.fire('send_message')
        fsm.fire('receive_message')
        shouldFail{
            fsm.fire('connect')
        }
        assert 'offline' == fsm.fire('disconnect')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例与其他示例不完全相同。它不使用预定义<code>Online</code>和<code>Offline</code>类。而是根据需要动态定义整个状态机。有关此样式的更多详细示例，请参见<a href="http://www.bytemycode.com/snippets/snippet/640/">前面的参考</a> 。</p>
</div>
<div class="paragraph">
<p>另请参阅： <a href="#_model_based_testing_using_modeljunit">使用ModelJUnit进行基于模型的测试</a></p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=1">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>