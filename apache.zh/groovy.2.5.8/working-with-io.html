<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>使用IO</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=6">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>使用IO</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_reading_files">1。读取文件</a></li>
<li><a href="#_writing_files">2。写文件</a></li>
<li><a href="#_traversing_file_trees">3。遍历文件树</a></li>
<li><a href="#_data_and_objects">4。数据与对象</a></li>
<li><a href="#process-management">5，执行外部流程</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Groovy提供了许多用于I / O的<a href="gdk.html">辅助方法</a> 。尽管您可以在Groovy中使用标准Java代码来处理这些代码，但Groovy提供了更便捷的方式来处理文件，流，读取器，...</p>
</div>
<div class="paragraph">
<p>特别是，您应该查看添加到以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>java.io.File</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></p>
</li>
<li>
<p>的<code>java.io.InputStream</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></p>
</li>
<li>
<p>的<code>java.io.OutputStream</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></p>
</li>
<li>
<p>的<code>java.io.Reader</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html</a></p>
</li>
<li>
<p>的<code>java.io.Writer</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html</a></p>
</li>
<li>
<p>的<code>java.nio.file.Path</code>类别： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" class="bare">http</a> ： <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" class="bare">//docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下部分重点介绍使用上述可用辅助方法的示例惯用构造，但这并不意味着对所有可用方法都有完整的描述。为此，请阅读<a href="gdk.html">GDK API</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reading_files"><a class="anchor" href="#_reading_files"></a> 1。读取文件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>作为第一个示例，让我们看看如何在Groovy中打印文本文件的所有行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir, 'haiku.txt').eachLine { line -&gt;
    println line
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>eachLine</code>方法是添加到<code>File</code> Groovy自动创建class并具有许多变体，例如，如果您需要知道行号，则可以使用以下变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir, 'haiku.txt').eachLine { line, nb -&gt;
    println "Line $nb: $line"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果出于某种原因在抛出异常<code>eachLine</code>主体，该方法可确保资源已正确关闭。对于Groovy添加的所有I / O资源方法，都是如此。</p>
</div>
<div class="paragraph">
<p>例如，在某些情况下，您将更喜欢使用<code>Reader</code> ，但是仍然可以从Groovy的自动资源管理中受益。在下一个示例中，即使发生异常，阅读器<strong>也会</strong>关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def count = 0, MAXSIZE = 3
new File(baseDir,"haiku.txt").withReader { reader -&gt;
    while (reader.readLine()) {
        if (++count &gt; MAXSIZE) {
            throw new RuntimeException('Haiku should only have 3 verses')
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要将文本文件的行收集到列表中，则可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = new File(baseDir, 'haiku.txt').collect {it}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您甚至可以利用<code>as</code>运算符，将文件的内容放入行数组中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def array = new File(baseDir, 'haiku.txt') as String[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>您必须将文件内容放入文件中多少次了<code>byte[]</code>它需要多少代码？Groovy实际上非常容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">byte[] contents = file.bytes</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用I / O不仅限于处理文件。实际上，很多操作都依赖于输入/输出流，因此，正如您在<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html">文档中</a>可以看到的那样，为什么Groovy为此添加了很多支持方法。</p>
</div>
<div class="paragraph">
<p>例如，您可以获得<code>InputStream</code>从一个<code>File</code>非常简单地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def is = new File(baseDir,'haiku.txt').newInputStream()
// do something ...
is.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，您可以看到它需要您关闭输入流。在Groovy中，通常最好使用<code>withInputStream</code>可以为您解决的成语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'haiku.txt').withInputStream { stream -&gt;
    // do something ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_files"><a class="anchor" href="#_writing_files"></a> 2。写文件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当然，在某些情况下，您将不希望读取而是写入文件。一种选择是使用<code>Writer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'haiku.txt').withWriter('utf-8') { writer -&gt;
    writer.writeLine 'Into the ancient pond'
    writer.writeLine 'A frog jumps'
    writer.writeLine 'Water’s sound!'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但对于这样一个简单的示例，使用<code><<</code>运算符就足够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'haiku.txt') &lt;&lt; '''Into the ancient pond
A frog jumps
Water’s sound!'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，我们并不总是处理文本内容，因此您可以使用<code>Writer</code>或直接写入字节，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">file.bytes = [66,22,11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，您也可以直接处理输出流。例如，以下是创建输出流以写入文件的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def os = new File(baseDir,'data.bin').newOutputStream()
// do something ...
os.close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，您会看到它需要您关闭输出流。再次强调，使用<code>withOutputStream</code>在任何情况下都会处理异常并关闭流的惯用语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new File(baseDir,'data.bin').withOutputStream { stream -&gt;
    // do something ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traversing_file_trees"><a class="anchor" href="#_traversing_file_trees"></a> 3。遍历文件树</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在脚本编写上下文中，遍历文件树以查找某些特定文件并对其进行处理是一项常见的任务。Groovy提供了多种方法来执行此操作。例如，您可以对目录的所有文件执行某些操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dir.eachFile { file -&gt;                      <i class="conum" data-value="1"></i><b>(1)</b>
    println file.name
}
dir.eachFileMatch(~/.*\.txt/) { file -&gt;     <i class="conum" data-value="2"></i><b>(2)</b>
    println file.name
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>对目录中找到的每个文件执行关闭代码</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对目录中与指定模式匹配的文件执行关闭代码</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，您将不得不处理更深层次的文件层次结构，在这种情况下，您可以使用<code>eachFileRecurse</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dir.eachFileRecurse { file -&gt;                      <i class="conum" data-value="1"></i><b>(1)</b>
    println file.name
}

dir.eachFileRecurse(FileType.FILES) { file -&gt;      <i class="conum" data-value="2"></i><b>(2)</b>
    println file.name
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>递归地对目录中找到的每个文件或目录执行关闭代码</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>仅对文件执行关闭代码，但递归执行</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于更复杂的遍历技术，您可以使用<code>traverse</code>方法，要求您设置一个特殊标志来指示如何处理遍历：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dir.traverse { file -&gt;
    if (file.directory &amp;&amp; file.name=='bin') {
        FileVisitResult.TERMINATE                   <i class="conum" data-value="1"></i><b>(1)</b>
    } else {
        println file.name
        FileVisitResult.CONTINUE                    <i class="conum" data-value="2"></i><b>(2)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果当前文件是目录，并且名称是<code>bin</code> ，停止遍历</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>否则，打印文件名并继续</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_and_objects"><a class="anchor" href="#_data_and_objects"></a> 4。数据与对象</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Java中，通常使用来对数据进行序列化和反序列化<code>java.io.DataOutputStream</code>和<code>java.io.DataInputStream</code>类。Groovy将使处理它们变得更加容易。例如，您可以使用以下代码将数据序列化为文件并反序列化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">boolean b = true
String message = 'Hello from Groovy'
// Serialize data into a file
file.withDataOutputStream { out -&gt;
    out.writeBoolean(b)
    out.writeUTF(message)
}
// ...
// Then read it back
file.withDataInputStream { input -&gt;
    assert input.readBoolean() == b
    assert input.readUTF() == message
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，如果您要序列化的数据实现了<code>Serializable</code>界面，您可以继续执行对象输出流，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person p = new Person(name:'Bob', age:76)
// Serialize data into a file
file.withObjectOutputStream { out -&gt;
    out.writeObject(p)
}
// ...
// Then read it back
file.withObjectInputStream { input -&gt;
    def p2 = input.readObject()
    assert p2.name == p.name
    assert p2.age == p.age
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="process-management"><a class="anchor" href="#process-management"></a> 5，执行外部流程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>上一节描述了在Groovy中处理文件，读取器或流有多么容易。但是，在诸如系统管理或开发人员之类的领域中，通常需要与外部流程进行通信。</p>
</div>
<div class="paragraph">
<p>Groovy提供了一种执行命令行过程的简单方法。只需将命令行写为字符串并调用<code>execute()</code>方法。例如，在* nix机器（或装有适当* nix命令的Windows机器）上，您可以执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "ls -l".execute()             <i class="conum" data-value="1"></i><b>(1)</b>
println "Found text ${process.text}"        <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>执行<code>ls</code>外部过程中的命令</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用命令的输出并检索文本</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>execute()</code>方法返回一个<code>java.lang.Process</code>实例，随后将允许处理输入/输出/错误流，并检查进程的退出值等。</p>
</div>
<div class="paragraph">
<p>例如，这里是与上面相同的命令，但是我们现在一次处理一行结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "ls -l".execute()             <i class="conum" data-value="1"></i><b>(1)</b>
process.in.eachLine { line -&gt;               <i class="conum" data-value="2"></i><b>(2)</b>
    println line                            <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>执行<code>ls</code>外部过程中的命令</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对于流程的输入流的每一行</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>打印线</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得一提的是<code>in</code>对应于命令标准输出的输入流。 <code>out</code>将指向一个流，您可以在其中将数据发送到流程（其标准输入）。</p>
</div>
<div class="paragraph">
<p>请记住，许多命令是Shell内置的，需要特殊处理。因此，如果要在Windows计算机上的目录中列出文件列表，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "dir".execute()
println "${process.text}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>您会收到一个<code>IOException</code>说<em>无法运行程序“目录”：CreateProcess错误= 2，系统找不到指定的文件。</em></p>
</div>
<div class="paragraph">
<p>这是因为<code>dir</code>内置于Windows Shell（ <code>cmd.exe</code> ），并且不能作为简单的可执行文件运行。相反，您将需要编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def process = "cmd /c dir".execute()
println "${process.text}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，因为此功能当前使用<code>java.lang.Process</code>卧底，必须考虑该类的不足。特别是，此类的javadoc说：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>由于某些本机平台仅为标准输入和输出流提供了有限的缓冲区大小，因此未能及时写入子进程的输入流或读取子进程的输出流可能导致子进程阻塞，甚至死锁</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>因此，Groovy提供了一些附加的辅助方法，这些方法使处理流程的流变得更加容易。</p>
</div>
<div class="paragraph">
<p>这是如何吞噬过程中的所有输出（包括错误流输出）的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = "rm -f foo.tmp".execute([], tmpDir)
p.consumeProcessOutput()
p.waitFor()</code></pre>
</div>
</div>
<div class="paragraph">
<p>也有变化<code>consumeProcessOutput</code>利用<code>StringBuffer</code> ， <code>InputStream</code> ， <code>OutputStream</code>等等...有关完整列表，请阅读<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Process.html">java.lang的</a><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Process.html">GDK API。处理</a></p>
</div>
<div class="paragraph">
<p>另外，这些是<code>pipeTo</code>命令（映射到<code>|</code>以允许重载），这允许将一个进程的输出流馈送到另一个进程的输入流。</p>
</div>
<div class="paragraph">
<p>以下是一些使用示例：</p>
</div>
<div class="listingblock">
<div class="title">管道在行动</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">proc1 = 'ls'.execute()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc1 | proc2 | proc3 | proc4
proc4.waitFor()
if (proc4.exitValue()) {
    println proc4.err.text
} else {
    println proc4.text
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">消费错误</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sout = new StringBuilder()
def serr = new StringBuilder()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc4.consumeProcessOutput(sout, serr)
proc2 | proc3 | proc4
[proc2, proc3].each { it.consumeProcessErrorStream(serr) }
proc2.withWriter { writer -&gt;
    writer &lt;&lt; 'testfile.groovy'
}
proc4.waitForOrKill(1000)
println "Standard output: $sout"
println "Standard error: $serr"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=7">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>