<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>MarkupTemplateEngine</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=1">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>MarkupTemplateEngine</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_the_template_format">1。模板格式</a>
<ul class="sectlevel2">
<li><a href="#_basics">1.1。基本</a></li>
<li><a href="#_support_methods">1.2。支持方式</a></li>
<li><a href="#_includes">1.3。包括</a></li>
<li><a href="#_fragments">1.4。碎片</a></li>
<li><a href="#_layouts">1.5。版面</a></li>
</ul>
</li>
<li><a href="#_rendering_contents">2。渲染内容</a>
<ul class="sectlevel2">
<li><a href="#_creation_of_a_template_engine">2.1。创建模板引擎</a></li>
<li><a href="#markuptemplate-config">2.2。配置选项</a></li>
<li><a href="#markuptemplate-autoformat">2.3。自动格式化</a></li>
<li><a href="#markuptemplate-autoescape">2.4。自动转义</a></li>
<li><a href="#markuptemplate-gotchas">2.5。常见陷阱</a>
<ul class="sectlevel3">
<li><a href="#_strings_containing_markup">2.5.1。包含标记的字符串</a></li>
</ul>
</li>
<li><a href="#markuptemplate-i18n">2.6。国际化</a></li>
<li><a href="#markuptemplate-basetemplate">2.7。自定义模板类</a></li>
</ul>
</li>
<li><a href="#_type_checked_templates">3。类型检查的模板</a>
<ul class="sectlevel2">
<li><a href="#_optional_type_checking">3.1。可选的类型检查</a></li>
<li><a href="#_alternative_declaration_of_types">3.2。类型的替代声明</a></li>
<li><a href="#_performance_of_type_checked_templates">3.3。类型检查模板的性能</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>此模板引擎是一个模板引擎，主要旨在生成类似XML的标记（XML，XHTML，HTML5等），但可用于生成任何基于文本的内容。与传统的模板引擎不同，该引擎依赖于使用生成器语法的DSL。这是一个示例模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">xmlDeclaration()
cars {
   cars.each {
       car(make: it.make, model: it.model)
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用以下模型供稿：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">model = [cars: [new Car(make: 'Peugeot', model: '508'), new Car(make: 'Toyota', model: 'Prius')]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将呈现为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version='1.0'?&gt;
&lt;cars&gt;&lt;car make='Peugeot' model='508'/&gt;&lt;car make='Toyota' model='Prius'/&gt;&lt;/cars&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该模板引擎的主要功能是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>像</em>语法<em>这样</em>的<em>标记生成器</em></p>
</li>
<li>
<p>模板被编译成字节码</p>
</li>
<li>
<p>快速渲染</p>
</li>
<li>
<p>模型的可选类型检查</p>
</li>
<li>
<p>包括</p>
</li>
<li>
<p>国际化支持</p>
</li>
<li>
<p>片段/布局</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_template_format"><a class="anchor" href="#_the_template_format"></a> 1。模板格式</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_basics"><a class="anchor" href="#_basics"></a> 1.1。基本</h3>
<div class="paragraph">
<p>模板由Groovy代码组成。让我们更深入地研究第一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">xmlDeclaration()                                <i class="conum" data-value="1"></i><b>(1)</b>
cars {                                          <i class="conum" data-value="2"></i><b>(2)</b>
   cars.each {                                  <i class="conum" data-value="3"></i><b>(3)</b>
       car(make: it.make, model: it.model)      <i class="conum" data-value="4"></i><b>(4)</b>
   }                                            <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>呈现XML声明字符串。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打开一个<code>cars</code>标签</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>cars</code>是在<em>模板模型中</em>找到的变量，它是<code>Car</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>对于每个项目，我们创建一个<code>car</code>标签中包含来自<code>Car</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>关闭<code>cars</code>标签</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如您所见，可以在模板中使用常规Groovy代码。在这里，我们正在打电话<code>each</code>在列表中（从模型中检索），允许我们渲染一个<code>car</code>每个条目的标签。</p>
</div>
<div class="paragraph">
<p>以类似的方式，呈现HTML代码是如此简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">yieldUnescaped '&lt;!DOCTYPE html&gt;'                                                    <i class="conum" data-value="1"></i><b>(1)</b>
html(lang:'en') {                                                                   <i class="conum" data-value="2"></i><b>(2)</b>
    head {                                                                          <i class="conum" data-value="3"></i><b>(3)</b>
        meta('http-equiv':'"Content-Type" content="text/html; charset=utf-8"')      <i class="conum" data-value="4"></i><b>(4)</b>
        title('My page')                                                            <i class="conum" data-value="5"></i><b>(5)</b>
    }                                                                               <i class="conum" data-value="6"></i><b>(6)</b>
    body {                                                                          <i class="conum" data-value="7"></i><b>(7)</b>
        p('This is an example of HTML contents')                                    <i class="conum" data-value="8"></i><b>(8)</b>
    }                                                                               <i class="conum" data-value="9"></i><b>(9)</b>
}                                                                                   <i class="conum" data-value="10"></i><b>(10)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>呈现HTML doctype特殊标签</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打开<code>html</code>带有属性的标签</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>打开<code>head</code>标签</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>呈现一个<code>meta</code>用一个标记<code>http-equiv</code>属性</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>呈现<code>title</code>标签</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>关闭<code>head</code>标签</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>打开<code>body</code>标签</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>呈现一个<code>p</code>标签</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>关闭<code>body</code>标签</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i> <b>10</b></td>
<td>关闭<code>html</code>标签</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>输出很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;head&gt;&lt;meta http-equiv='"Content-Type" content="text/html; charset=utf-8"'/&gt;&lt;title&gt;My page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is an example of HTML contents&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过一些<a href="#markuptemplate-config">配置</a> ，您可以漂亮地打印输出，并自动添加换行符和缩进。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_support_methods"><a class="anchor" href="#_support_methods"></a> 1.2。支持方式</h3>
<div class="paragraph">
<p>在上一个示例中，doctype声明是使用<code>yieldUnescaped</code>方法。我们也看到了<code>xmlDeclaration</code>方法。模板引擎提供了几种支持方法，可以帮助您正确呈现内容：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:16.6666%">
<col style="width:33.3333%">
<col style="width:50.0001%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">让</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">渲染内容，但在渲染之前将其转义</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">yield 'Some text with &lt;angle brackets&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">Some text with &amp;lt;angle brackets&amp;gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">yieldUnescaped</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现原始内容。该参数按原样呈现，没有转义。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">yieldUnescaped 'Some text with &lt;angle brackets&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">Some text with &lt;angle brackets&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">xmlDeclaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现XML声明字符串。如果在配置中指定了编码，则将其写入声明中。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">xmlDeclaration()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;?xml version='1.0'?&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>TemplateConfiguration#getDeclarationEncoding</code>不为空：</p>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">评论</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在XML注释中呈现原始内容</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">comment 'This is &lt;a href="foo.html"&gt;commented out&lt;/a&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!--This is &lt;a href="foo.html"&gt;commented out&lt;/a&gt;--&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新队</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现新行。也可以看看<code>TemplateConfiguration#setAutoNewLine</code>和<code>TemplateConfiguration#setNewLineString</code> 。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p('text')
newLine()
p('text on new line')</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;p&gt;text&lt;/p&gt;
&lt;p&gt;text on new line&lt;/p&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现XML处理指令。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">pi("xml-stylesheet":[href:"mystyle.css", type:"text/css"])</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml-stylesheet href='mystyle.css' type='text/css'?&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tryEscape</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回一个对象的转义字符串，如果它是一个<code>String</code> （或从<code>CharSequence</code> ）。否则返回对象本身。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">yieldUnescaped tryEscape('Some text with &lt;angle brackets&gt;')</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">Some text with &amp;lt;angle brackets&amp;gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_includes"><a class="anchor" href="#_includes"></a> 1.3。包括</h3>
<div class="paragraph">
<p>的<code>MarkupTemplateEngine</code>支持包含其他文件的内容。包含的内容可能是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>另一个模板</p>
</li>
<li>
<p>原始内容</p>
</li>
<li>
<p>要逃避的内容</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以使用以下方法来包含另一个模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">include template: 'other_template.tpl'</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将文件包含为原始内容而不进行转义，可以这样进行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">include unescaped: 'raw.txt'</code></pre>
</div>
</div>
<div class="paragraph">
<p>最终，可以使用以下方法完成在渲染之前应转义的文本的包含：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">include escaped: 'to_be_escaped.txt'</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以改用以下帮助方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>includeGroovy(<name>)</code>包括另一个模板</p>
</li>
<li>
<p><code>includeEscaped(<name>)</code>包含另一个带有转义符的文件</p>
</li>
<li>
<p><code>includeUnescaped(<name>)</code>包含另一个文件而没有转义</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>调用这些方法而不是<code>include xxx:</code>如果要包含的文件名是动态的（例如，存储在变量中），则语法可能很有用。在<strong>classpath</strong>上可以找到要包含的文件（与它们的类型，模板或文本无关）。这是为什么<code>MarkupTemplateEngine</code>需要一个可选的<code>ClassLoader</code>作为构造函数参数（另一个原因是您可以在模板中包含引用其他类的代码）。</p>
</div>
<div class="paragraph">
<p>如果您不希望模板位于类路径中，则<code>MarkupTemplateEngine</code>接受一个方便的构造函数，该构造函数使您可以定义要在其中找到模板的目录。</p>
</div>
</div>
<div class="sect2">
<h3 id="_fragments"><a class="anchor" href="#_fragments"></a> 1.4。碎片</h3>
<div class="paragraph">
<p>片段是嵌套的模板。它们可用于在单个模板中提供改进的组成。片段由一个字符串，内部模板和一个模型组成，用于呈现此模板。考虑以下模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">ul {
    pages.each {
        fragment "li(line)", line:it
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>fragment</code>元素创建一个嵌套模板，并使用该模板特有的模型进行渲染。在这里，我们有<code>li(line)</code>碎片，在哪里<code>line</code>一定会<code>it</code> 。以来<code>it</code>对应于<code>pages</code> ，我们将生成一个<code>li</code>模型中每个页面的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;ul&gt;&lt;li&gt;Page 1&lt;/li&gt;&lt;li&gt;Page 2&lt;/li&gt;&lt;/ul&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>片段很有趣，可以分解模板元素。它们是以每个模板片段的编译为代价的，因此无法外部化。</p>
</div>
</div>
<div class="sect2">
<h3 id="_layouts"><a class="anchor" href="#_layouts"></a> 1.5。版面</h3>
<div class="paragraph">
<p>与片段不同，布局引用其他模板。它们可用于组成模板和共享通用结构。例如，如果您有一个通用的HTML页面设置，并且只想替换正文，这通常很有趣。使用<em>布局</em>可以轻松完成此操作。首先，您需要创建一个布局模板：</p>
</div>
<div class="listingblock">
<div class="title">layout-main.tpl</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">html {
    head {
        title(title)                <i class="conum" data-value="1"></i><b>(1)</b>
    }
    body {
        bodyContents()              <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>title</code>变量（在标题标签内）是布局变量</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>bodyContents</code>通话将渲染身体</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，您需要的是一个包含布局的模板：</p>
</div>
<div id="example-layout-simple" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">layout 'layout-main.tpl',                                   <i class="conum" data-value="1"></i><b>(1)</b>
    title: 'Layout example',                                <i class="conum" data-value="2"></i><b>(2)</b>
    bodyContents: contents { p('This is the body') }        <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>main-layout.tpl</code>布局文件</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>设置<code>title</code>变量</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>设置<code>bodyContents</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如你看到的， <code>bodyContents</code>多亏了<code>bodyContents()</code>调用布局文件。结果，该模板将呈现为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;Layout example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the body&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>呼吁<code>contents</code>方法用于告诉模板引擎，代码块实际上是模板的规范，而不是直接呈现的辅助函数。如果您不添加<code>contents</code>在指定之前，将呈现内容，但您还将看到生成的随机字符串，与该块的结果值相对应。</p>
</div>
<div class="paragraph">
<p>布局是一种在多个模板之间共享公共元素的强大方法，而无需重写所有内容或使用包含。</p>
</div>
<div class="paragraph">
<p>默认情况下，布局使用的模型与使用页面的模型无关。但是，可以使它们从父模型继承。想象一下，模型是这样定义的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">model = new HashMap&lt;String,Object&gt;();
model.put('title','Title from main model');</code></pre>
</div>
</div>
<div class="paragraph">
<p>和以下模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">layout 'layout-main.tpl', true,                             <i class="conum" data-value="1"></i><b>(1)</b>
    bodyContents: contents { p('This is the body') }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注意使用<code>true</code>启用模型继承</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>那么就没有必要通过<code>title</code>与<a href="#example-layout-simple">上一个示例中</a>的布局相同。结果将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;Title from main model&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the body&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是也可以从父模型中覆盖一个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">layout 'layout-main.tpl', true,                             <i class="conum" data-value="1"></i><b>(1)</b>
    title: 'overridden title',                               <i class="conum" data-value="2"></i><b>(2)</b>
    bodyContents: contents { p('This is the body') }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>true</code>表示从父模型继承</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>但<code>title</code>被覆盖</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>那么输出将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;overridden title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the body&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rendering_contents"><a class="anchor" href="#_rendering_contents"></a> 2。渲染内容</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_creation_of_a_template_engine"><a class="anchor" href="#_creation_of_a_template_engine"></a> 2.1。创建模板引擎</h3>
<div class="paragraph">
<p>在服务器端，渲染模板需要一个实例<code>groovy.text.markup.MarkupTemplateEngine</code>和一个<code>groovy.text.markup.TemplateConfiguration</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">TemplateConfiguration config = new TemplateConfiguration();         <i class="conum" data-value="1"></i><b>(1)</b>
MarkupTemplateEngine engine = new MarkupTemplateEngine(config);     <i class="conum" data-value="2"></i><b>(2)</b>
Template template = engine.createTemplate("p('test template')");    <i class="conum" data-value="3"></i><b>(3)</b>
Map&lt;String, Object&gt; model = new HashMap&lt;&gt;();                        <i class="conum" data-value="4"></i><b>(4)</b>
Writable output = template.make(model);                             <i class="conum" data-value="5"></i><b>(5)</b>
output.writeTo(writer);                                             <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建模板配置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用此配置创建模板引擎</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>从创建一个模板实例<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>创建要在模板中使用的模型</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>将模型绑定到模板实例</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>渲染输出</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有几种可能的选项来解析模板：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从一个<code>String</code> ，使用<code>createTemplate(String)</code></p>
</li>
<li>
<p>从一个<code>Reader</code> ，使用<code>createTemplate(Reader)</code></p>
</li>
<li>
<p>从一个<code>URL</code> ，使用<code>createTemplate(URL)</code></p>
</li>
<li>
<p>给定模板名称，使用<code>createTemplateByPath(String)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常应首选最新版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Template template = engine.createTemplateByPath("main.tpl");
Writable output = template.make(model);
output.writeTo(writer);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="markuptemplate-config"><a class="anchor" href="#markuptemplate-config"></a> 2.2。配置选项</h3>
<div class="paragraph">
<p>可以通过以下几种配置选项来调整引擎的行为： <code>TemplateConfiguration</code>类：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:28.5714%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明编码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">确定在以下情况下要写入的编码值<code>xmlDeclaration</code>叫做。它<strong>不</strong>影响您使用作为输出的作家。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">xmlDeclaration()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;?xml version='1.0'?&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>TemplateConfiguration#getDeclarationEncoding</code>不为空：</p>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">expandEmptyElements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则以扩展格式呈现空标签。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;p/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>expandEmptyElements</code>是真的：</p>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;p&gt;&lt;/p&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useDoubleQuotes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，请对属性使用双引号而不是简单引号</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">tag(attr:'value')</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;tag attr='value'/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>useDoubleQuotes</code>是真的：</p>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;tag attr="value"/&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">newLineString</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统默认值（系统属性<code>line.separator</code> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许选择渲染新行时使用的字符串</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><strong>范本</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p('foo')
newLine()
p('baz')</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>newLineString='BAR'</code> ：</p>
</div>
<div class="paragraph">
<p><strong>输出</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;p&gt;foo&lt;/p&gt;BAR&lt;p&gt;baz&lt;/p&gt;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动逃生</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则会在渲染之前自动转义来自模型的变量。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>参见<a href="#markuptemplate-autoescape">自动逃生部分</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动缩进</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则在新行之后执行自动缩进</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>请参阅<a href="#markuptemplate-autoformat">自动格式化部分</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">autoIndentString</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">四（4）个空格</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用作缩进的字符串。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>请参阅<a href="#markuptemplate-autoformat">自动格式化部分</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">autoNewLine</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则自动插入新行</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>请参阅<a href="#markuptemplate-autoformat">自动格式化部分</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">baseTemplateClass</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>groovy.text.markup.BaseTemplate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置已编译模板的超类。这可用于提供特定于应用程序的模板。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>请参阅<a href="#markuptemplate-basetemplate">自定义模板部分</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">地区</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认语言环境</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置模板的默认语言环境。</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>请参阅<a href="#markuptemplate-i18n">国际化部分</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">创建模板引擎后，更改配置是<strong>不安全</strong>的。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="markuptemplate-autoformat"><a class="anchor" href="#markuptemplate-autoformat"></a> 2.3。自动格式化</h3>
<div class="paragraph">
<p>默认情况下，模板引擎将渲染输出而没有任何特定的格式。一些<a href="#markuptemplate-config">配置选项</a>可以改善这种情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>autoIndent</code>插入新行后负责自动缩进</p>
</li>
<li>
<p><code>autoNewLine</code>负责根据模板源的原始格式自动插入新行</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，建议同时设置<code>autoIndent</code>和<code>autoNewLine</code>如果您希望人类可读的漂亮打印输出，则为true：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">config.setAutoNewLine(true);
config.setAutoIndent(true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用以下模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">html {
    head {
        title('Title')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在的输出将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以稍微更改模板，以便<code>title</code>指令与<code>head</code>一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">html {
    head { title('Title')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出将反映出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;
    &lt;head&gt;&lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>仅</strong>在找到标签的花括号的位置插入新行，并且插入对应于找到嵌套内容的位置。这意味着，除非它们本身使用花括号，否则另一个标签正文中的标签将<strong>不会</strong>触发新行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">html {
    head {
        meta(attr:'value')          <i class="conum" data-value="1"></i><b>(1)</b>
        title('Title')              <i class="conum" data-value="2"></i><b>(2)</b>
        newLine()                   <i class="conum" data-value="3"></i><b>(3)</b>
        meta(attr:'value2')         <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>插入新行是因为<code>meta</code>与不在同一行<code>head</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>没有插入新行，因为我们和上一个标签的深度相同</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以通过显式调用来强制渲染新行<code>newLine</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>并且此标记将在单独的行上呈现</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这次，输出将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;
    &lt;head&gt;
        &lt;meta attr='value'/&gt;&lt;title&gt;Title&lt;/title&gt;
        &lt;meta attr='value2'/&gt;
    &lt;/head&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，渲染器使用四（4）个空格作为缩进，但是您可以通过设置<code>TemplateConfiguration#autoIndentString</code>属性。</p>
</div>
</div>
<div class="sect2">
<h3 id="markuptemplate-autoescape"><a class="anchor" href="#markuptemplate-autoescape"></a> 2.4。自动转义</h3>
<div class="paragraph">
<p>默认情况下，将从模型读取的内容按<strong>原样</strong>呈现。如果此内容来自用户输入，则可能是明智的，并且您可能希望默认情况下对其进行转义，例如，以避免XSS注入。为此，模板配置提供了一个选项，该选项将自动从模型中转义对象，只要它们从<code>CharSequence</code> （通常是`String`s）。</p>
</div>
<div class="paragraph">
<p>让我们想象一下以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.setAutoEscape(false);
model = new HashMap&lt;String,Object&gt;();
model.put("unsafeContents", "I am an &lt;html&gt; hacker.");</code></pre>
</div>
</div>
<div class="paragraph">
<p>和以下模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">html {
    body {
        div(unsafeContents)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您将不需要HTML <code>unsafeContents</code>由于存在潜在的安全问题，因此按原样呈现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;&lt;body&gt;&lt;div&gt;I am an &lt;html&gt; hacker.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>自动转义将解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.setAutoEscape(true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在输出已正确转义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;html&gt;&lt;body&gt;&lt;div&gt;I am an &amp;lt;html&amp;gt; hacker.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，使用自动转义并不会阻止您包括模型中未转义的内容。为此，您的模板随后应明确提及不应通过给模型变量加上前缀来转义模型变量<code>unescaped.</code> ，如本例所示：</p>
</div>
<div class="listingblock">
<div class="title">显式绕过自动转义</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">html {
    body {
        div(unescaped.unsafeContents)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="markuptemplate-gotchas"><a class="anchor" href="#markuptemplate-gotchas"></a> 2.5。常见陷阱</h3>
<div class="sect3">
<h4 id="_strings_containing_markup"><a class="anchor" href="#_strings_containing_markup"></a> 2.5.1。包含标记的字符串</h4>
<div class="paragraph">
<p>假设您要生成一个<code><p></code>标签，其中包含包含标记的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p {
    yield "This is a "
    a(href:'target.html', "link")
    yield " to another page"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并生成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;p&gt;This is a &lt;a href='target.html'&gt;link&lt;/a&gt; to another page&lt;/p&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不能写得短些吗？一个天真的选择是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p {
    yield "This is a ${a(href:'target.html', "link")} to another page"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但结果看起来不会像预期的那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">&lt;p&gt;&lt;a href='target.html'&gt;link&lt;/a&gt;This is a  to another page&lt;/p&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>原因是标记模板引擎是<em>流</em>引擎。在原始版本中，第一个<code>yield</code>调用生成一个字符串，该字符串将流式传输到输出，然后<code>a</code>链接生成并流式传输，然后是最后一个<code>yield</code>调用流式传输，从而<strong>按顺序</strong>执行。但是使用上面的字符串版本，执行顺序是不同的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>yield</code>调用需要一个参数，一个<em>字符串</em></p>
</li>
<li>
<p>在<em>产生yield</em>调用<em>之前</em>需要评估参数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，评估字符串会导致执行<code>a(href:…​)</code> <strong>提前</strong>致电<code>yield</code>本身称为。这不是您想要的。相反，您想生成一个包含标记的<em>字符串</em> ，然后将其传递给<code>yield</code>呼叫。这可以通过以下方式完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p("This is a ${stringOf {a(href:'target.html', "link")}} to another page")</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>stringOf</code>调用，该调用基本上告诉标记模板引擎需要标记基础标记并以字符串形式导出。请注意，对于简单表达式， <code>stringOf</code>可以由以<em>美元</em>符号开头的替代标记表示法代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">p("This is a ${$a(href:'target.html', "link")} to another page")</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">值得注意的是<code>stringOf</code>或特殊<code>$tag</code>符号触发创建一个独特的字符串编写器，该字符串编写器随后用于呈现标记。它比将版本用于调用要慢<code>yield</code>而是直接执行标记的流式传输。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="markuptemplate-i18n"><a class="anchor" href="#markuptemplate-i18n"></a> 2.6。国际化</h3>
<div class="paragraph">
<p>模板引擎具有对国际化的本地支持。为此，当您创建<code>TemplateConfiguration</code> ，您可以提供<code>Locale</code>这是用于模板的默认语言环境。每个模板可以具有不同的版本，每个区域设置一个。模板的名称有所不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>file.tpl</code> ：默认模板文件</p>
</li>
<li>
<p><code>file_fr_FR.tpl</code> ：模板的法语版本</p>
</li>
<li>
<p><code>file_en_US.tpl</code> ：模板的美国英语版本</p>
</li>
<li>
<p>......</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>呈现或包含模板后，则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果模板名称或包含名称<strong>明确</strong>设置了语言环境，则包含<strong>特定</strong>版本，如果找不到，则使用默认版本</p>
</li>
<li>
<p>如果模板名称不包含语言环境，则<code>TemplateConfiguration</code>使用语言环境，如果找不到，则使用默认版本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，假设默认语言环境设置为<code>Locale.ENGLISH</code>并且主模板包括：</p>
</div>
<div class="listingblock">
<div class="title">在包含中使用显式语言环境</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">include template: 'locale_include_fr_FR.tpl'</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后使用特定模板呈现模板：</p>
</div>
<div class="listingblock">
<div class="title">绕过模板配置</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">Texte en français</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用include而不指定语言环境将使模板引擎查找具有配置的语言环境的模板，如果没有，则回退到默认语言，例如：</p>
</div>
<div class="listingblock">
<div class="title">不要在include中使用语言环境</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">include template: 'locale_include.tpl'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">退回到默认模板</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">Default text</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，将模板引擎的默认语言环境更改为<code>Locale.FRANCE</code>将更改输出，因为模板引擎现在将使用<code>fr_FR</code>地区：</p>
</div>
<div class="listingblock">
<div class="title">不要回退到默认模板，因为找到了特定于语言环境的模板</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">Texte en français</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过此策略，您可以依靠默认模板（文件名中未设置语言环境）来一次翻译模板。</p>
</div>
</div>
<div class="sect2">
<h3 id="markuptemplate-basetemplate"><a class="anchor" href="#markuptemplate-basetemplate"></a> 2.7。自定义模板类</h3>
<div class="paragraph">
<p>默认情况下，创建的模板会继承<code>groovy.text.markup.BaseTemplate</code>类。应用程序提供不同的模板类，例如提供了解应用程序的其他辅助方法或自定义的呈现原语（例如，对于HTML）可能会很有趣。</p>
</div>
<div class="paragraph">
<p>模板引擎通过设置替代项来提供此功能<code>baseTemplateClass</code>在里面<code>TemplateConfiguration</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">config.setBaseTemplateClass(MyTemplate.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义基类必须扩展<code>BaseClass</code>像这个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public abstract class MyTemplate extends BaseTemplate {
    private List&lt;Module&gt; modules
    public MyTemplate(
            final MarkupTemplateEngine templateEngine,
            final Map model,
            final Map&lt;String, String&gt; modelTypes,
            final TemplateConfiguration configuration) {
        super(templateEngine, model, modelTypes, configuration)
    }

    List&lt;Module&gt; getModules() {
        return modules
    }

    void setModules(final List&lt;Module&gt; modules) {
        this.modules = modules
    }

    boolean hasModule(String name) {
        modules?.any { it.name == name }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例显示了一个类，该类提供了一个名为<code>hasModule</code> ，然后可以直接在模板中使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (hasModule('foo')) {
    p 'Found module [foo]'
} else {
    p 'Module [foo] not found'
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_checked_templates"><a class="anchor" href="#_type_checked_templates"></a> 3。类型检查的模板</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_optional_type_checking"><a class="anchor" href="#_optional_type_checking"></a> 3.1。可选的类型检查</h3>
<div class="paragraph">
<p>即使未对类型进行模板检查，它们也会被静态编译。这意味着一旦模板被编译，性能将非常好。对于某些应用程序，最好在实际渲染模板之前先确保模板有效。这意味着模板编译失败，例如，如果模型变量上的方法不存在。</p>
</div>
<div class="paragraph">
<p>的<code>MarkupTemplateEngine</code>提供了这样的设施。可以选择对模板进行类型检查。为此，开发人员必须在模板创建时提供其他信息，这是在模型中找到的变量的类型。想象一下一个模型，该模型公开了一个页面列表，其中页面定义为：</p>
</div>
<div class="listingblock">
<div class="title">Page.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class Page {

    Long id
    String title
    String body
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以在模型中显示页面列表，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Page p = new Page();
p.setTitle("Sample page");
p.setBody("Page body");
List&lt;Page&gt; pages = new LinkedList&lt;&gt;();
pages.add(p);
model = new HashMap&lt;String,Object&gt;();
model.put("pages", pages);</code></pre>
</div>
</div>
<div class="paragraph">
<p>模板可以轻松使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">pages.each { page -&gt;                    <i class="conum" data-value="1"></i><b>(1)</b>
    p("Page title: $page.title")        <i class="conum" data-value="2"></i><b>(2)</b>
    p(page.text)                        <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>迭代模型中的页面</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>page.title</code>已验证</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>page.text</code> <strong>不是</strong> （应该是<code>page.body</code> ）</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果没有类型检查，模板的编译将成功，因为模板引擎直到实际渲染页面才知道模型。这意味着，仅在呈现页面后，问题才会在运行时出现：</p>
</div>
<div class="listingblock">
<div class="title">运行时错误</div>
<div class="content">
<pre>No such property: text</pre>
</div>
</div>
<div class="paragraph">
<p>在某些情况下，清理甚至注意到可能会很复杂。通过声明<code>pages</code>到模板引擎，我们现在能够在编译时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">modelTypes = new HashMap&lt;String,String&gt;();                                          <i class="conum" data-value="1"></i><b>(1)</b>
modelTypes.put("pages", "List&lt;Page&gt;");                                              <i class="conum" data-value="2"></i><b>(2)</b>
Template template = engine.createTypeCheckedModelTemplate("main.tpl", modelTypes)   <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个包含模型类型的地图</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>声明类型<code>pages</code>变量（注意类型使用字符串）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用<code>createTypeCheckedModelTemplate</code>代替<code>createTemplate</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这次，在最后一行编译模板时，发生错误：</p>
</div>
<div class="listingblock">
<div class="title">模板编译时间错误</div>
<div class="content">
<pre>[Static type checking] - No such property: text for class: Page</pre>
</div>
</div>
<div class="paragraph">
<p>这意味着您无需等待页面呈现就可以看到错误。指某东西的用途<code>createTypeCheckedModelTemplate</code>是强制性的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_alternative_declaration_of_types"><a class="anchor" href="#_alternative_declaration_of_types"></a> 3.2。类型的替代声明</h3>
<div class="paragraph">
<p>或者，如果开发人员也是编写模板的开发人员，则可以直接在模板中声明期望变量的类型。在这种情况下，即使您致电<code>createTemplate</code> ，将对其进行类型检查：</p>
</div>
<div class="listingblock">
<div class="title">内联类型声明</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">modelTypes = {                          <i class="conum" data-value="1"></i><b>(1)</b>
    List&lt;Page&gt; pages                    <i class="conum" data-value="2"></i><b>(2)</b>
}

pages.each { page -&gt;
    p("Page title: $page.title")
    p(page.text)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类型需要在<code>modelTypes</code>标头</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在模型中为每个对象声明一个变量</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_performance_of_type_checked_templates"><a class="anchor" href="#_performance_of_type_checked_templates"></a> 3.3。类型检查模板的性能</h3>
<div class="paragraph">
<p>使用类型检查的模型的另一个好处是性能应该提高。通过告诉类型检查器什么是期望的类型，您还可以让编译器为此生成优化的代码，因此，如果您要寻找最佳性能，请考虑使用类型检查的模板。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=2">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>