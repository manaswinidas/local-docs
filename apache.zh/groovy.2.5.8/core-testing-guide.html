<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>测试指南</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=0">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>测试指南</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1。介绍</a></li>
<li><a href="#_language_features">2。语言功能</a>
<ul class="sectlevel2">
<li><a href="#_power_assertions">2.1。功率断言</a></li>
<li><a href="#_mocking_and_stubbing">2.2。模拟和存根</a>
<ul class="sectlevel3">
<li><a href="#_map_coercion">2.2.1。地图强制</a></li>
<li><a href="#_closure_coercion">2.2.2。封闭强制</a></li>
<li><a href="#_mockfor_and_stubfor">2.2.3。MockFor和StubFor</a></li>
<li><a href="#testing_guide_emc">2.2.4。Expando元类（EMC）</a></li>
</ul>
</li>
<li><a href="#_gdk_methods">2.3。GDK方法</a>
<ul class="sectlevel3">
<li><a href="#_iterable_combinations">2.3.1。可迭代的组合</a></li>
<li><a href="#_iterable_eachcombination">2.3.2。Iterable＃eachCombination</a></li>
</ul>
</li>
<li><a href="#_tool_support">2.4。工具支援</a>
<ul class="sectlevel3">
<li><a href="#_test_code_coverage">2.4.1。测试代码覆盖率</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_testing_with_junit">3。使用JUnit进行测试</a>
<ul class="sectlevel2">
<li><a href="#_junit_3">3.1。JUnit 3</a>
<ul class="sectlevel3">
<li><a href="#_assertion_methods">3.1.1。断言方法</a></li>
<li><a href="#_shouldfail_methods">3.1.2。应该失败的方法</a></li>
<li><a href="#_notyetimplemented_method">3.1.3。 notYetImplemented方法</a></li>
</ul>
</li>
<li><a href="#_junit_4">3.2。JUnit 4</a></li>
<li><a href="#_junit_5">3.3。JUnit 5</a></li>
</ul>
</li>
<li><a href="#_testing_with_spock">4。用Spock测试</a>
<ul class="sectlevel2">
<li><a href="#_specifications">4.1。技术指标</a></li>
<li><a href="#_more_spock">4.2。更多Spock</a></li>
</ul>
</li>
<li><a href="#_functional_tests_with_geb">5，用Geb进行功能测试</a>
<ul class="sectlevel2">
<li><a href="#_a_geb_script">5.1。Geb脚本</a></li>
<li><a href="#_more_geb">5.2。更多吉布</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a> 1。介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy编程语言为编写测试提供了强大的支持。除了语言功能以及与最新测试库和框架的测试集成之外，Groovy生态系统还诞生了丰富的测试库和框架集。</p>
</div>
<div class="paragraph">
<p>本章将从特定于语言的测试功能开始，并继续仔细研究JUnit集成，针对规范的Spock和针对功能测试的Geb。最后，我们将概述其他已知与Groovy一起使用的测试库。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_language_features"><a class="anchor" href="#_language_features"></a> 2。语言功能</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了对JUnit的集成支持之外，Groovy编程语言还具有已被证明对于测试驱动的开发非常有价值的功能。本节将对它们进行深入分析。</p>
</div>
<div class="sect2">
<h3 id="_power_assertions"><a class="anchor" href="#_power_assertions"></a> 2.1。功率断言</h3>
<div class="paragraph">
<p>编写测试意味着通过使用断言来制定假设。在Java中，可以使用<code>assert</code> J2SE 1.4中已添加的关键字。在Java中， <code>assert</code>可以通过JVM参数启用语句<code>-ea</code> （要么<code>-enableassertions</code> ）和<code>-da</code> （要么<code>-disableassertions</code> ）。默认情况下，禁用Java中的断言语句。</p>
</div>
<div class="paragraph">
<p>Groovy带有一个相当<em>强大</em>的<code>assert</code>也称为<em>权力断言</em> 。Groovy的力量<code>assert</code>给定布尔表达式验证为与Java版本的输出不同<code>false</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1
assert x == 2

// Output:             <i class="conum" data-value="1"></i><b>(1)</b>
//
// Assertion failed:
// assert x == 2
//        | |
//        1 false</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>本节显示了std-err输出</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>java.lang.AssertionError</code>当无法成功验证断言时抛出的，包含原始异常消息的扩展版本。功率断言输出显示从外部表达式到内部表达式的评估结果。</p>
</div>
<div class="paragraph">
<p>幂断言语句在复杂的布尔语句或具有集合或其他语句的语句中释放真正的幂<code>toString</code>启用的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = [1,2,3,4,5]
assert (x &lt;&lt; 6) == [6,7,8,9,10]

// Output:
//
// Assertion failed:
// assert (x &lt;&lt; 6) == [6,7,8,9,10]
//         | |     |
//         | |     false
//         | [1, 2, 3, 4, 5, 6]
//         [1, 2, 3, 4, 5, 6]</code></pre>
</div>
</div>
<div class="paragraph">
<p>与Java的另一个重要区别是Groovy中的断言<em>默认</em>为<em>启用</em> 。语言设计的决定是消除取消激活断言的可能性。或者，正如Bertrand Meyer所说， <code>it makes no sense to take off your swim ring if you put your feet into real water</code> 。</p>
</div>
<div class="paragraph">
<p>要注意的一件事是在电源断言语句中的布尔表达式内部具有副作用的方法。由于内部错误消息构造机制仅存储对目标下实例的引用，因此，如果涉及副作用方法，则会发生错误消息文本在渲染时无效的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [[1,2,3,3,3,3,4]].first().unique() == [1,2,3]

// Output:
//
// Assertion failed:
// assert [[1,2,3,3,3,3,4]].first().unique() == [1,2,3]
//                          |       |        |
//                          |       |        false
//                          |       [1, 2, 3, 4]
//                          [1, 2, 3, 4]           <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>错误消息显示集合的实际状态，而不是集合之前的状态。 <code>unique</code>方法被应用</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果选择提供自定义断言错误消息，则可以使用Java语法来完成<code>assert expression1 : expression2</code>哪里<code>expression1</code>是布尔表达式，并且<code>expression2</code>是自定义错误消息。但是请注意，这将禁用电源断言，并将完全回退到断言错误时的自定义错误消息。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_mocking_and_stubbing"><a class="anchor" href="#_mocking_and_stubbing"></a> 2.2。模拟和存根</h3>
<div class="paragraph">
<p>Groovy具有出色的内置支持，可支持各种模拟和存根选项。使用Java时，动态模拟框架非常流行。造成这种情况的一个关键原因是，使用Java创建定制的手工模拟模型非常困难。如果您愿意，可以在Groovy中轻松使用这样的框架，但是在Groovy中创建自定义模拟会容易得多。您通常可以通过简单的映射或闭包来构建自定义模拟。</p>
</div>
<div class="paragraph">
<p>以下各节说明仅使用Groovy语言功能创建模拟和存根的方法。</p>
</div>
<div class="sect3">
<h4 id="_map_coercion"><a class="anchor" href="#_map_coercion"></a> 2.2.1。地图强制</h4>
<div class="paragraph">
<p>通过使用map或expandos，我们可以很容易地合并协作者的期望行为，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TranslationService {
    String convert(String key) {
        return "test"
    }
}

def service = [convert: { String key -&gt; 'some text' }] as TranslationService
assert 'some text' == service.convert('key.text')</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>as</code>运算符可用于将地图强制转换为特定类。给定的映射键被解释为方法名称和值，即<code>groovy.lang.Closure</code>块，被解释为方法代码块。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，如果您处理自定义，则地图强制可能会妨碍您的操作<code>java.util.Map</code>后代类与<code>as</code>操作员。地图强制机制直接针对某些集合类，它没有考虑自定义类。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_closure_coercion"><a class="anchor" href="#_closure_coercion"></a> 2.2.2。封闭强制</h4>
<div class="paragraph">
<p>'as'运算符可以以一种简洁的方式与闭包一起使用，这非常适合在简单场景下进行开发人员测试。我们还没有发现这种技术如此强大，以至于我们不想消除动态模拟，但是在简单情况下它仍然非常有用。</p>
</div>
<div class="paragraph">
<p>包含单个方法的类或接口（包括SAM（单个抽象方法）类）可用于强制将闭包作为给定类型的对象。请注意，为此，Groovy在内部创建了给定类降序的代理对象。因此，该对象将不是给定类的直接实例。这一点很重要，例如，如果生成的代理对象的元类随后进行了更改。</p>
</div>
<div class="paragraph">
<p>让我们举一个将闭包强制为特定类型的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def service = { String key -&gt; 'some text' } as TranslationService
assert 'some text' == service.convert('key.text')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy支持一种称为隐式SAM强制的功能。这意味着<code>as</code>在运行时可以推断目标SAM类型的情况下，不需要运算符。在模拟整个SAM类的测试中，这种强制类型可能有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class BaseService {
    abstract void doSomething()
}

BaseService service = { -&gt; println 'doing something' }
service.doSomething()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mockfor_and_stubfor"><a class="anchor" href="#_mockfor_and_stubfor"></a> 2.2.3。MockFor和StubFor</h4>
<div class="paragraph">
<p>Groovy模拟和存根类可以在<code>groovy.mock.interceptor</code>包。</p>
</div>
<div class="paragraph">
<p>的<code>MockFor</code>类通过允许定义对协作者行为的<em>严格排序的</em>期望，来支持（通常是单元）类的隔离测试。一个典型的测试场景涉及一个被测类和一个或多个合作者。在这种情况下，通常需要仅测试被测类的业务逻辑。这样做的一种策略是用简化的模拟对象替换协作者实例，以帮助隔离测试目标中的逻辑。MockFor允许使用元编程创建此类模拟。协作者的期望行为定义为行为规范。该行为将被强制执行并自动检查。</p>
</div>
<div class="paragraph">
<p>假设目标类如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String first, last
}

class Family {
    Person father, mother
    def nameOfMother() { "$mother.first $mother.last" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用<code>MockFor</code> ，模拟期望始终取决于序列，并且其使用会自动以调用结束<code>verify</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def mock = new MockFor(Person)      <i class="conum" data-value="1"></i><b>(1)</b>
mock.demand.getFirst{ 'dummy' }
mock.demand.getLast{ 'name' }
mock.use {                          <i class="conum" data-value="2"></i><b>(2)</b>
    def mary = new Person(first:'Mary', last:'Smith')
    def f = new Family(mother:mary)
    assert f.nameOfMother() == 'dummy name'
}
mock.expect.verify()                <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>新的模拟是由的新实例创建的<code>MockFor</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一种<code>Closure</code>被传递给<code>use</code>启用模拟功能</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>致电<code>verify</code>检查方法调用的顺序和数量是否符合预期</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>StubFor</code> class通过允许定义对协作者行为的<em>松散</em>期望来支持（通常是单元）类的孤立测试。一个典型的测试场景涉及一个被测类和一个或多个合作者。在这种情况下，通常需要仅测试CUT的业务逻辑。这样做的一种策略是将协作者实例替换为简化的存根对象，以帮助隔离目标类中的逻辑。 <code>StubFor</code>允许使用元编程创建此类存根。协作者的期望行为定义为行为规范。</p>
</div>
<div class="paragraph">
<p>与之相反<code>MockFor</code>存根期望与<code>verify</code>与序列无关，其使用是可选的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def stub = new StubFor(Person)      <i class="conum" data-value="1"></i><b>(1)</b>
stub.demand.with {                  <i class="conum" data-value="2"></i><b>(2)</b>
    getLast{ 'name' }
    getFirst{ 'dummy' }
}
stub.use {                          <i class="conum" data-value="3"></i><b>(3)</b>
    def john = new Person(first:'John', last:'Smith')
    def f = new Family(father:john)
    assert f.father.first == 'dummy'
    assert f.father.last == 'name'
}
stub.expect.verify()                <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>新的存根由的新实例创建<code>StubFor</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>with</code>方法用于将闭包内部的所有调用委派给<code>StubFor</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>一种<code>Closure</code>被传递给<code>use</code>启用存根功能</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>致电<code>verify</code> （可选）检查方法调用的数量是否符合预期</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>MockFor</code>和<code>StubFor</code>不能用于测试静态编译的类，例如使用Java类或Groovy类的静态编译类<code>@CompileStatic</code> 。要存根和/或模拟这些类，可以使用Spock或Java模拟库之一。</p>
</div>
</div>
<div class="sect3">
<h4 id="testing_guide_emc"><a class="anchor" href="#testing_guide_emc"></a> 2.2.4。Expando元类（EMC）</h4>
<div class="paragraph">
<p>Groovy包括一个特殊的<code>MetaClass</code>所谓的<code>ExpandoMetaClass</code> （EMC）。它允许使用简洁的闭包语法动态添加方法，构造函数，属性和静态方法。</p>
</div>
<div class="paragraph">
<p>每一个<code>java.lang.Class</code>提供了一个特殊的<code>metaClass</code>引用<code>ExpandoMetaClass</code>实例。expando元类不限于自定义类，它可用于JDK类，例如<code>java.lang.String</code>以及：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String.metaClass.swapCase = {-&gt;
    def sb = new StringBuffer()
    delegate.each {
        sb &lt;&lt; (Character.isUpperCase(it as char) ? Character.toLowerCase(it as char) :
            Character.toUpperCase(it as char))
    }
    sb.toString()
}

def s = "heLLo, worLD!"
assert s.swapCase() == 'HEllO, WORld!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>ExpandoMetaClass</code>是模拟功能的很好候选者，因为它允许模拟静态方法等更高级的内容</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
    String title
}

Book.metaClass.static.create &lt;&lt; { String title -&gt; new Book(title:title) }

def b = Book.create("The Stand")
assert b.title == 'The Stand'</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至是构造函数</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Book.metaClass.constructor &lt;&lt; { String title -&gt; new Book(title:title) }

def b = new Book("The Stand")
assert b.title == 'The Stand'</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">模拟构造函数似乎是一种hack，最好甚至不要考虑，甚至可能存在有效的用例。在Grails中可以找到一个示例，该示例在运行时借助以下命令添加了域类构造函数<code>ExpandoMetaClass</code> 。这使域对象可以在Spring应用程序上下文中注册自己，并允许注入服务或由依赖项注入容器控制的其他bean。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要更改<code>metaClass</code>在每个测试方法级别的“属性”属性中，您需要删除对元类所做的更改，否则这些更改将在测试方法调用之间保持不变。通过替换<code>GroovyMetaClassRegistry</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">GroovySystem.metaClassRegistry.setMetaClass(java.lang.String, null)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种选择是注册一个<code>MetaClassRegistryChangeEventListener</code> ，跟踪更改的类并删除所选测试运行时的清除方法中的更改。<a href="https://github.com/grails/grails-core/blob/master/grails-bootstrap/src/main/groovy/grails/build/support/MetaClassRegistryCleaner.java">在Grails Web开发框架中</a>可以找到一个很好的例子。</p>
</div>
<div class="paragraph">
<p>除了使用<code>ExpandoMetaClass</code>在类级别，还支持在每个对象级别使用元类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def b = new Book(title: "The Stand")
b.metaClass.getTitle {-&gt; 'My Title' }

assert b.title == 'My Title'</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，元类更改仅与实例有关。根据测试情况，这可能比全局元类更改更合适。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gdk_methods"><a class="anchor" href="#_gdk_methods"></a> 2.3。GDK方法</h3>
<div class="paragraph">
<p>下一节简要概述了可在测试用例场景（例如，测试数据生成）中使用的GDK方法。</p>
</div>
<div class="sect3">
<h4 id="_iterable_combinations"><a class="anchor" href="#_iterable_combinations"></a> 2.3.1。可迭代的组合</h4>
<div class="paragraph">
<p>的<code>combinations</code>添加的方法<code>java.lang.Iterable</code>兼容类可用于从包含两个或多个子列表的列表中获取组合列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testCombinations() {
    def combinations = [[2, 3],[4, 5, 6]].combinations()
    assert combinations == [[2, 4], [3, 4], [2, 5], [3, 5], [2, 6], [3, 6]]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该方法可用于测试用例场景，以生成特定方法调用的所有可能的参数组合。</p>
</div>
</div>
<div class="sect3">
<h4 id="_iterable_eachcombination"><a class="anchor" href="#_iterable_eachcombination"></a> 2.3.2。Iterable＃eachCombination</h4>
<div class="paragraph">
<p>的<code>eachCombination</code>添加的方法<code>java.lang.Iterable</code>可用于应用功能（在这种情况下， <code>groovy.lang.Closure</code> ），以将每个<code>combinations</code>方法：</p>
</div>
<div class="paragraph">
<p><code>eachCombination</code>是GDK方法，已添加到所有符合<code>java.lang.Iterable</code>接口。它对输入列表的每个组合应用一个函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testEachCombination() {
    [[2, 3],[4, 5, 6]].eachCombination { println it[0] + it[1] }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该方法可以在测试上下文中用于以每个生成的组合调用方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tool_support"><a class="anchor" href="#_tool_support"></a> 2.4。工具支援</h3>
<div class="sect3">
<h4 id="_test_code_coverage"><a class="anchor" href="#_test_code_coverage"></a> 2.4.1。测试代码覆盖率</h4>
<div class="paragraph">
<p>代码覆盖率是衡量（单元）测试有效性的有用措施。与没有覆盖率或覆盖率较低的程序相比，具有较高代码覆盖率的程序保留严重错误的机会较低。为了获得代码覆盖率指标，通常需要在执行测试之前检测生成的字节码。Groovy支持此任务的工具之一是<a href="http://cobertura.github.io/cobertura/">Cobertura</a> 。</p>
</div>
<div class="paragraph">
<p>Cobertura集成附带了各种框架和构建工具。对于Grails，有一个基于Cobertura的<a href="http://grails.org/plugin/code-coverage">代码覆盖插件</a> ，对于Gradle，有<a href="https://github.com/eriwen/gradle-cobertura-plugin">gradle-cobertura插件</a> ，仅举了两个。</p>
</div>
<div class="paragraph">
<p>以下代码清单显示了有关如何在Groovy项目的Gradle构建脚本中启用Cobertura测试覆盖率报告的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def pluginVersion = '&lt;plugin version&gt;'
def groovyVersion = '&lt;groovy version&gt;'
def junitVersion = '&lt;junit version&gt;'

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.eriwen:gradle-cobertura-plugin:${pluginVersion}'
    }
}

apply plugin: 'groovy'
apply plugin: 'cobertura'

repositories {
    mavenCentral()
}

dependencies {
    compile "org.codehaus.groovy:groovy-all:${groovyVersion}"
    testCompile "junit:junit:${junitVersion}"
}

cobertura {
    format = 'html'
    includes = ['**/*.java', '**/*.groovy']
    excludes = ['com/thirdparty/**/*.*']
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以为Cobertura覆盖率报告选择几种输出格式，并且可以将测试代码覆盖率报告添加到连续集成构建任务中。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_with_junit"><a class="anchor" href="#_testing_with_junit"></a> 3。使用JUnit进行测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy通过以下方式简化了JUnit测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您使用与使用Java测试时相同的总体做法，但是可以在测试中采用Groovy的许多简洁语法，使其简洁。如果您愿意的话，甚至可以使用编写测试特定领域语言（DSL）的功能。</p>
</li>
<li>
<p>有许多帮助程序类可以简化许多测试活动。在某些情况下，详细信息会有所不同，具体取决于所使用的JUnit版本。我们将尽快介绍这些细节。</p>
</li>
<li>
<p>Groovy的PowerAssert机制非常适合在您的测试中使用</p>
</li>
<li>
<p>Groovy认为测试是如此重要，因此您应该能够像脚本或类一样轻松地运行它们。这就是为什么Groovy在使用<code>groovy</code>命令或GroovyConsole。除了运行测试之外，这还为您提供了其他一些选择</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在以下各节中，我们将仔细研究JUnit 3、4和5 Groovy集成。</p>
</div>
<div class="sect2">
<h3 id="_junit_3"><a class="anchor" href="#_junit_3"></a> 3.1。JUnit 3</h3>
<div class="paragraph">
<p>支持JUnit 3测试的最杰出的Groovy类之一可能是<code>GroovyTestCase</code>类。来自<code>junit.framework.TestCase</code>它提供了许多其他方法，使在Groovy中进行测试变得轻而易举。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">虽然<code>GroovyTestCase</code>继承自<code>TestCase</code>并不意味着您不能在项目中使用JUnit 4功能。实际上，最新的Groovy版本附带捆绑的JUnit 4，并且向后兼容<code>TestCase</code>实施。Groovy邮件列表上已经讨论过是否使用<code>GroovyTestCase</code>或JUnit 4，其结果主要取决于品味，但是<code>GroovyTestCase</code>您可以免费获得许多方法，这些方法使某些类型的测试更易于编写。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在本节中，我们将介绍由<code>GroovyTestCase</code> 。这些的完整列表可以在<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/GroovyTestCase.html">groovy.util的JavaDoc文档中找到</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/GroovyTestCase.html">。GroovyTestCase</a> ，不要忘记它是继承自<code>junit.framework.TestCase</code>继承了所有<code>assert*</code>方法。</p>
</div>
<div class="sect3">
<h4 id="_assertion_methods"><a class="anchor" href="#_assertion_methods"></a> 3.1.1。断言方法</h4>
<div class="paragraph">
<p><code>GroovyTestCase</code>继承自<code>junit.framework.TestCase</code>因此，它继承了可在每种测试方法中调用的大量断言方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyTestCase extends GroovyTestCase {

    void testAssertions() {
        assertTrue(1 == 1)
        assertEquals("test", "test")

        def x = "42"
        assertNotNull "x must not be null", x
        assertNull null

        assertSame x, x
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面可以看出，与Java相比，在大多数情况下可以省略括号，这会导致JUnit断言方法调用表达式的可读性更高。</p>
</div>
<div class="paragraph">
<p>一个有趣的断言方法，由<code>GroovyTestCase</code>是<code>assertScript</code> 。它确保给定的Groovy代码字符串成功无任何异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testScriptAssertions() {
    assertScript '''
        def x = 1
        def y = 2

        assert x + y == 3
    '''
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shouldfail_methods"><a class="anchor" href="#_shouldfail_methods"></a> 3.1.2。应该失败的方法</h4>
<div class="paragraph">
<p><code>shouldFail</code>可用于检查给定的代码块是否失败。如果失败，则断言确实成立，否则断言失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testInvalidIndexAccess1() {
    def numbers = [1,2,3,4]
    shouldFail {
        numbers.get(4)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例使用基本<code>shouldFail</code>方法接口<code>groovy.lang.Closure</code>作为一个参数。的<code>Closure</code>实例保存应该在运行时中断的代码。</p>
</div>
<div class="paragraph">
<p>如果我们想断言<code>shouldFail</code>在特定的<code>java.lang.Exception</code>类型，我们可以使用<code>shouldFail</code>实施需要<code>Exception</code>类作为第一个参数， <code>Closure</code>作为第二个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testInvalidIndexAccess2() {
    def numbers = [1,2,3,4]
    shouldFail IndexOutOfBoundsException, {
        numbers.get(4)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不是<code>IndexOutOfBoundsException</code> （或它的后代类）被抛出，测试用例将失败。</p>
</div>
<div class="paragraph">
<p>的一个相当不错的功能<code>shouldFail</code>到目前为止尚不可见：它返回异常消息。如果要断言异常错误消息，这真的很有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testInvalidIndexAccess3() {
    def numbers = [1,2,3,4]
    def msg = shouldFail IndexOutOfBoundsException, {
        numbers.get(4)
    }
    assert msg.contains('Index: 4, Size: 4') ||
        msg.contains('Index 4 out-of-bounds for length 4') ||
        msg.contains('Index 4 out of bounds for length 4')
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_notyetimplemented_method"><a class="anchor" href="#_notyetimplemented_method"></a> 3.1.3。 notYetImplemented方法</h4>
<div class="paragraph">
<p>的<code>notYetImplemented</code> HtmlUnit对方法的影响很大。它允许编写测试方法，但将其标记为尚未实现。只要测试方法失败并标有<code>notYetImplemented</code>测试变为绿色：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testNotYetImplemented1() {
    if (notYetImplemented()) return   <i class="conum" data-value="1"></i><b>(1)</b>

    assert 1 == 2                     <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>致电<code>notYetImplemented</code>是必要的<code>GroovyTestCase</code>获取当前的方法堆栈。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>只要测试评估为<code>false</code>测试执行将成功。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>替代<code>notYetImplemented</code>方法是<code>@NotYetImplemented</code>注解。它允许对尚未实现的方法进行注释，其行为与<code>GroovyTestCase#notYetImplemented</code>但不需要<code>notYetImplemented</code>方法调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@NotYetImplemented
void testNotYetImplemented2() {
    assert 1 == 2
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_junit_4"><a class="anchor" href="#_junit_4"></a> 3.2。JUnit 4</h3>
<div class="paragraph">
<p>Groovy可以无限制地用于编写JUnit 4测试用例。的<code>groovy.test.GroovyAssert</code>拥有各种静态方法，可以替代<code>GroovyTestCase</code> JUnit 4测试中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.junit.Test

import static groovy.test.GroovyAssert.shouldFail

class JUnit4ExampleTests {

    @Test
    void indexOutOfBoundsAccess() {
        def numbers = [1,2,3,4]
        shouldFail {
            numbers.get(4)
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面的示例可以看出，在<code>GroovyAssert</code>在类定义的开头被导入<code>shouldFail</code>可以与在<code>GroovyTestCase</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>groovy.test.GroovyAssert</code>从<code>org.junit.Assert</code>这意味着它将继承所有JUnit断言方法。但是，随着power断言语句的引入，事实证明， <em>依靠断言语句</em>而不是使用JUnit断言方法是一种<em>好习惯，</em>而改进的消息是主要原因。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得一提的是<code>GroovyAssert.shouldFail</code>不完全相同<code>GroovyTestCase.shouldFail</code> 。而<code>GroovyTestCase.shouldFail</code>返回异常消息， <code>GroovyAssert.shouldFail</code>返回异常本身。需要更多的击键操作才能获取消息，但是作为回报，您可以访问异常的其他属性和方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Test
void shouldFailReturn() {
    def e = shouldFail {
        throw new RuntimeException('foo',
                                   new RuntimeException('bar'))
    }
    assert e instanceof RuntimeException
    assert e.message == 'foo'
    assert e.cause.message == 'bar'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_junit_5"><a class="anchor" href="#_junit_5"></a> 3.3。JUnit 5</h3>
<div class="paragraph">
<p>在使用JUnit5时，JUnit4下描述的许多方法和辅助类都适用，但是JUnit5在编写测试时使用一些略有不同的类注释。有关更多详细信息，请参见<a href="http://junit.org">JUnit5</a>文档。</p>
</div>
<div class="paragraph">
<p>按照正常的JUnit5准则创建测试类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyTest {
  @Test
  void streamSum() {
    assert Stream.of(1, 2, 3).mapToInt{ i -&gt; i }.sum() &gt; 5
  }

  @RepeatedTest(value=2, name = "{displayName} {currentRepetition}/{totalRepetitions}")
  void streamSumRepeated() {
    assert Stream.of(1, 2, 3).mapToInt{i -&gt; i}.sum() == 6
  }

  private boolean isPalindrome(s) { s == s.reverse()  }

  @ParameterizedTest                                                              <i class="conum" data-value="1"></i><b>(1)</b>
  @ValueSource(strings = [ "racecar", "radar", "able was I ere I saw elba" ])
  void palindromes(String candidate) {
    assert isPalindrome(candidate)
  }

  @TestFactory
  def dynamicTestCollection() {[
    dynamicTest("Add test") { -&gt; assert 1 + 1 == 2 },
    dynamicTest("Multiply Test") { -&gt; assert 2 * 3 == 6 }
  ]}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>此测试需要额外的<code>org.junit.jupiter:junit-jupiter-params</code>依赖项（如果尚未在您的项目中）。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以在IDE或构建工具中运行测试（如果它支持JUnit5并已为其配置）。如果您在GroovyConsole或通过<code>groovy</code>命令，您将看到运行测试结果的简短文本摘要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>JUnit5 launcher: passed=8, failed=0, skipped=0, time=246ms</pre>
</div>
</div>
<div class="paragraph">
<p>有关详细信息，请访问<code>FINE</code>日志记录级别。您可以配置日志记录以显示此类信息，或通过编程方式执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@BeforeAll
static void init() {
  def logger = Logger.getLogger(LoggingListener.name)
  logger.level = Level.FINE
  logger.addHandler(new ConsoleHandler(level: Level.FINE))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_with_spock"><a class="anchor" href="#_testing_with_spock"></a> 4。用Spock测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spock是针对Java和Groovy应用程序的测试和规范框架。使它在人群中脱颖而出的是其美丽而富有表现力的规范DSL。实际上，Spock规范被编写为Groovy类。尽管它们是用Groovy编写的，但是它们可以用于测试Java类。Spock可以用于单元测试，集成测试或BDD（行为驱动开发）测试，它不会将自己放入特定类型的测试框架或库中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">除了这些令人敬畏的功能外，Spock还是一个很好的示例，说明了如何利用第三方库中的高级Groovy编程语言功能，例如，通过使用Groovy AST转换。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本部分不应作为有关如何使用Spock的详细指南，而应给人留下深刻印象，即Spock的含义以及如何将其用于单元，集成，功能或任何其他类型的测试。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下一节我们将首先了解Spock规范的剖析。它应该让Spock感觉很好。</p>
</div>
<div class="sect2">
<h3 id="_specifications"><a class="anchor" href="#_specifications"></a> 4.1。技术指标</h3>
<div class="paragraph">
<p>Spock使您可以编写描述感兴趣的系统所展示的功能（属性，方面）的规范。 “系统”可以是单个类和整个应用程序之间的任何内容，更高级的术语是<em>“规范下的系统”</em> 。<em>功能说明</em>从系统及其协作者的特定快照开始，此快照称为<em>功能的“夹具”</em> 。</p>
</div>
<div class="paragraph">
<p>Spock规范类派生自<code>spock.lang.Specification</code> 。具体的规范类可能包含字段，固定方法，特征方法和辅助方法。</p>
</div>
<div class="paragraph">
<p>让我们看一个简单的规范，它具有一个虚构的单特征方法<code>Stack</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class StackSpec extends Specification {

    def "adding an element leads to size increase"() {  <i class="conum" data-value="1"></i><b>(1)</b>
        setup: "a new stack instance is created"        <i class="conum" data-value="2"></i><b>(2)</b>
            def stack = new Stack()

        when:                                           <i class="conum" data-value="3"></i><b>(3)</b>
            stack.push 42

        then:                                           <i class="conum" data-value="4"></i><b>(4)</b>
            stack.size() == 1
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>Feature方法是按照约定用String文字命名的。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>设置块，此处需要完成此功能的所有设置工作。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>当块描述一种刺激时，此功能说明会在目标下执行某些操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后，阻塞可用于验证when块触发的代码结果的所有表达式。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spock功能规范定义为内部的方法<code>spock.lang.Specification</code>类。它们通过使用字符串文字而不是方法名称来描述功能。</p>
</div>
<div class="paragraph">
<p>特征方法包含多个块，在我们的示例中，我们使用<code>setup</code> ， <code>when</code>和<code>then</code> 。的<code>setup</code>块的特殊之处在于它是可选的，并允许配置在feature方法内部可见的局部变量。的<code>when</code>块定义了刺激并且是刺激的伴侣<code>then</code>描述对刺激的反应的方框。</p>
</div>
<div class="paragraph">
<p>请注意<code>setup</code>中的方法<code>StackSpec</code>上面还有一个描述字符串。说明字符串是可选的，可以在块标签之后添加（例如<code>setup</code> ， <code>when</code> ， <code>then</code> ）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_more_spock"><a class="anchor" href="#_more_spock"></a> 4.2。更多Spock</h3>
<div class="paragraph">
<p>Spock提供了更多功能，例如数据表或高级模拟功能。随时查阅<a href="https://github.com/spockframework/spock">Spock GitHub页面</a>以获取更多文档和下载信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functional_tests_with_geb"><a class="anchor" href="#_functional_tests_with_geb"></a> 5，用Geb进行功能测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Geb是一个功能性的Web测试和刮板库，与JUnit和Spock集成。它基于Selenium Web驱动程序，并且像Spock一样，提供了Groovy DSL来编写针对Web应用程序的功能测试。</p>
</div>
<div class="paragraph">
<p>Geb具有出色的功能，使其非常适合功能测试库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过类似JQuery的DOM访问<code>$</code>功能</p>
</li>
<li>
<p>实现<em>页面模式</em></p>
</li>
<li>
<p>支持使用模块对某些Web组件（例如，菜单栏等）进行<em>模块化</em></p>
</li>
<li>
<p>通过JS变量与JavaScript集成</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本部分不应作为有关如何使用Geb的详细指南，而应给人以印象，即Geb的含义以及如何利用它进行功能测试。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下一节将给出一个示例，说明如何使用Geb编写具有单个搜索字段的简单网页的功能测试。</p>
</div>
<div class="sect2">
<h3 id="_a_geb_script"><a class="anchor" href="#_a_geb_script"></a> 5.1。Geb脚本</h3>
<div class="paragraph">
<p>尽管Geb可以在Groovy脚本中独立使用，但是在许多情况下，它可以与其他测试框架结合使用。Geb带有各种可在JUnit 3、4，TestNG或Spock测试中使用的基类。基类是需要作为依赖项添加的其他Geb模块的一部分。</p>
</div>
<div class="paragraph">
<p>例如，以下<code>@Grab</code>依赖关系可用于在JUnit4测试中通过Selenium Firefox驱动程序运行Geb。JUnit 3/4支持所需的模块是<code>geb-junit4</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('org.gebish:geb-core:0.9.2')
@Grab('org.gebish:geb-junit4:0.9.2')
@Grab('org.seleniumhq.selenium:selenium-firefox-driver:2.26.0')
@Grab('org.seleniumhq.selenium:selenium-support:2.26.0')</code></pre>
</div>
</div>
<div class="paragraph">
<p>盖布的核心阶级是<code>geb.Browser</code>类。顾名思义，它用于浏览页面和访问DOM元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import geb.Browser
import org.openqa.selenium.firefox.FirefoxDriver

def browser = new Browser(driver: new FirefoxDriver(), baseUrl: 'http://myhost:8080/myapp')  <i class="conum" data-value="1"></i><b>(1)</b>
browser.drive {
    go "/login"                        <i class="conum" data-value="2"></i><b>(2)</b>

    $("#username").text = 'John'       <i class="conum" data-value="3"></i><b>(3)</b>
    $("#password").text = 'Doe'

    $("#loginButton").click()

    assert title == "My Application - Dashboard"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个新的<code>Browser</code>实例已创建。在这种情况下，它使用硒<code>FirefoxDriver</code>并设置<code>baseUrl</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>go</code>用于导航到URL或相对URI</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>$</code>与CSS选择器一起用于访问<code>username</code>和<code>password</code> DOM字段。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>Browser</code>班上有一个<code>drive</code>将所有方法/属性调用委托给当前方法的方法<code>browser</code>实例。的<code>Browser</code>不得内联完成配置，也可以将其外部化<code>GebConfig.groovy</code>例如配置文件。实际上， <code>Browser</code>该类大部分被Geb测试基类隐藏。他们将所有缺少的属性和方法调用委托给当前对象<code>browser</code>后台存在的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SearchTests extends geb.junit4.GebTest {

    @Test
    void executeSeach() {
        go 'http://somehost/mayapp/search'              <i class="conum" data-value="1"></i><b>(1)</b>
        $('#searchField').text = 'John Doe'             <i class="conum" data-value="2"></i><b>(2)</b>
        $('#searchButton').click()                      <i class="conum" data-value="3"></i><b>(3)</b>

        assert $('.searchResult a').first().text() == 'Mr. John Doe' <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>Browser#go</code>采取相对或绝对链接并调用页面。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>Browser#$</code>用于访问DOM内容。允许底层Selenium驱动程序支持的任何CSS选择器</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>click</code>用于单击按钮。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>$</code>用于获取第一个链接<code>searchResult</code>块</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>上面的示例显示了一个简单的带有JUnit 4基类的Geb Web测试<code>geb.junit4.GebTest</code> 。请注意，在这种情况下<code>Browser</code>配置已外部化。 <code>GebTest</code>委托类似的方法<code>go</code>和<code>$</code>到底层<code>browser</code>实例。</p>
</div>
</div>
<div class="sect2">
<h3 id="_more_geb"><a class="anchor" href="#_more_geb"></a> 5.2。更多吉布</h3>
<div class="paragraph">
<p>在上一节中，我们仅介绍了可用的Geb功能。有关Geb的更多信息可以在<a href="http://gebish.org">项目主页上</a>找到。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=1">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>