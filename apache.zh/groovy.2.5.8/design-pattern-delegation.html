<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>委托模式</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>委托模式</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_implement_delegation_pattern_using_expandometaclass">1。使用ExpandoMetaClass实现委托模式</a></li>
<li><a href="#_implement_delegation_pattern_using_delegate_annotation">2。使用@Delegate注释实现委派模式</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Delegation_pattern">委托模式</a>是一种通过将责任委托给一个或多个关联对象来实现对象行为（公共方法）的技术。</p>
</div>
<div class="paragraph">
<p>Groovy允许应用委托模式的传统样式，例如，参见<a href="#_replace_inheritance_with_delegation">使用</a>代理<a href="#_replace_inheritance_with_delegation">替换继承</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implement_delegation_pattern_using_expandometaclass"><a class="anchor" href="#_implement_delegation_pattern_using_expandometaclass"></a> 1。使用ExpandoMetaClass实现委托模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/ExpandoMetaClass.html">groovy.lang。ExpandoMetaClass</a>允许将此模式的使用封装在库中。这使Groovy可以仿真可用于Ruby语言的类似库。</p>
</div>
<div class="paragraph">
<p>考虑以下库类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Delegator {
    private targetClass
    private delegate
    Delegator(targetClass, delegate) {
        this.targetClass = targetClass
        this.delegate = delegate
    }
    def delegate(String methodName) {
        delegate(methodName, methodName)
    }
    def delegate(String methodName, String asMethodName) {
        targetClass.metaClass."$asMethodName" = delegate.&amp;"$methodName"
    }
    def delegateAll(String[] names) {
        names.each { delegate(it) }
    }
    def delegateAll(Map names) {
        names.each { k, v -&gt; delegate(k, v) }
    }
    def delegateAll() {
        delegate.class.methods*.name.each { delegate(it) }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在类路径中使用它，您现在可以动态应用委托模式，如以下示例所示。首先，考虑一下我们有以下几类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy \\$thing"
    }
}

def lender = new MortgageLender()

def delegator = new Delegator(Person, lender)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以使用<em>委托</em>者从<em>借出</em>对象自动借用方法来扩展<em>Person</em>类。我们可以按原样借用方法，也可以重命名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegate 'borrowFor'
delegator.delegate 'borrowAmount', 'getMoney'

def p = new Person()

println p.borrowFor('present')   // =&gt; buy present
println p.getMoney(50)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的第一行通过委派给<em>贷方</em>对象，将<em>peerFor</em>方法添加到<em>Person</em>类。第二行通过委派给<em>贷方</em>对象的<em>borowAmount</em>方法，将<em>getMoney</em>方法添加到<em>Person</em>类。</p>
</div>
<div class="paragraph">
<p>另外，我们可以借用这样的多种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegateAll 'borrowFor', 'borrowAmount'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将这两个方法添加到<em>Person</em>类。</p>
</div>
<div class="paragraph">
<p>或者，如果我们需要所有方法，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegateAll()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使<em>Person</em>类中的委托对象中的所有方法可用。</p>
</div>
<div class="paragraph">
<p>另外，我们可以使用地图符号重命名多个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">delegator.delegateAll borrowAmount:'getMoney', borrowFor:'getThing'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implement_delegation_pattern_using_delegate_annotation"><a class="anchor" href="#_implement_delegation_pattern_using_delegate_annotation"></a> 2。使用@Delegate注释实现委派模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>从1.6版开始，您可以使用基于AST转换的内置委派机制。</p>
</div>
<div class="paragraph">
<p>这使委派更加容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    def name
    @Delegate MortgageLender mortgageLender = new MortgageLender()
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy $thing"
    }
}

def p = new Person()

assert "buy present" == p.borrowFor('present')
assert "borrow \\$50" == p.borrowAmount(50)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>