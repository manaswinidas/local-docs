<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>语义学</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>语义学</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_statements">1。陈述</a>
<ul class="sectlevel2">
<li><a href="#_variable_definition">1.1。变量定义</a></li>
<li><a href="#_variable_assignment">1.2。变量分配</a>
<ul class="sectlevel3">
<li><a href="#_multiple_assignment">1.2.1。多重分配</a></li>
<li><a href="#_overflow_and_underflow">1.2.2。上溢和下溢</a></li>
<li><a href="#_object_destructuring_with_multiple_assignment">1.2.3。具有多个分配的对象分解</a></li>
</ul>
</li>
<li><a href="#_control_structures">1.3。控制结构</a>
<ul class="sectlevel3">
<li><a href="#_conditional_structures">1.3.1。条件结构</a>
<ul class="sectlevel4">
<li><a href="#_if_else">如果别的</a></li>
<li><a href="#_switch_case">开关/箱</a></li>
</ul>
</li>
<li><a href="#_looping_structures">1.3.2。循环结构</a>
<ul class="sectlevel4">
<li><a href="#_classic_for_loop">经典循环</a></li>
<li><a href="#_for_in_loop">循环中</a></li>
<li><a href="#_while_loop">while循环</a></li>
</ul>
</li>
<li><a href="#_exception_handling">1.3.3。异常处理</a></li>
<li><a href="#_try_catch_finally">1.3.4。尝试/抓住/最后</a></li>
<li><a href="#_multi_catch">1.3.5。多渔获</a></li>
</ul>
</li>
<li><a href="#_power_assertion">1.4。权力主张</a></li>
<li><a href="#_labeled_statements">1.5。带标签的声明</a></li>
</ul>
</li>
<li><a href="#_expressions">2。表达方式</a>
<ul class="sectlevel2">
<li><a href="#gpath_expressions">2.1。GPath表达式</a>
<ul class="sectlevel3">
<li><a href="#_object_navigation">2.1.1。对象导航</a></li>
<li><a href="#_expression_deconstruction">2.1.2。表达解构</a></li>
<li><a href="#_gpath_for_xml_navigation">2.1.3。用于XML导航的GPath</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_promotion_and_coercion">3。促进和强迫</a>
<ul class="sectlevel2">
<li><a href="#_number_promotion">3.1。号码促销</a></li>
<li><a href="#closure-coercion">3.2。强制关闭</a>
<ul class="sectlevel3">
<li><a href="#_assigning_a_closure_to_a_sam_type">3.2.1。为SAM类型分配闭包</a></li>
<li><a href="#_calling_a_method_accepting_a_sam_type_with_a_closure">3.2.2。用闭包调用接受SAM类型的方法</a></li>
<li><a href="#_closure_to_arbitrary_type_coercion">3.2.3。对任意类型强制的关闭</a></li>
</ul>
</li>
<li><a href="#_map_to_type_coercion">3.3。映射为强制类型</a></li>
<li><a href="#_string_to_enum_coercion">3.4。强制枚举的字符串</a></li>
<li><a href="#_custom_type_coercion">3.5。自定义类型强制</a></li>
<li><a href="#_class_literals_vs_variables_and_the_as_operator">3.6。类文字，变量和as运算符</a></li>
</ul>
</li>
<li><a href="#_optionality">4。可选性</a>
<ul class="sectlevel2">
<li><a href="#_optional_parentheses">4.1。可选括号</a></li>
<li><a href="#_optional_semicolons">4.2。可选分号</a></li>
<li><a href="#_optional_return_keyword">4.3。可选的return关键字</a></li>
<li><a href="#_optional_public_keyword">4.4。可选的公共关键字</a></li>
</ul>
</li>
<li><a href="#Groovy-Truth">5，时髦的真相</a>
<ul class="sectlevel2">
<li><a href="#_boolean_expressions">5.1。布尔表达式</a></li>
<li><a href="#_collections_and_arrays">5.2。集合和数组</a></li>
<li><a href="#_matchers">5.3。匹配器</a></li>
<li><a href="#_iterators_and_enumerations">5.4。迭代器和枚举</a></li>
<li><a href="#_maps">5.5。地图</a></li>
<li><a href="#_strings">5.6。弦乐</a></li>
<li><a href="#_numbers">5.7。号码</a></li>
<li><a href="#_object_references">5.8。对象引用</a></li>
<li><a href="#_customizing_the_truth_with_asboolean_methods">5.9。使用asBoolean（）方法自定义真相</a></li>
</ul>
</li>
<li><a href="#_typing">6。打字</a>
<ul class="sectlevel2">
<li><a href="#_optional_typing">6.1。可选输入</a></li>
<li><a href="#static-type-checking">6.2。静态类型检查</a>
<ul class="sectlevel3">
<li><a href="#_the_code_typechecked_code_annotation">6.2.1。的<code>@TypeChecked</code>注解</a>
<ul class="sectlevel4">
<li><a href="#_activating_type_checking_at_compile_time">在编译时激活类型检查</a></li>
<li><a href="#_skipping_sections">跳过部分</a></li>
</ul>
</li>
<li><a href="#_type_checking_assignments">6.2.2。类型检查分配</a></li>
<li><a href="#_list_and_map_constructors">6.2.3。列表和地图构造函数</a></li>
<li><a href="#_method_resolution">6.2.4。方法解析</a></li>
<li><a href="#type-inference">6.2.5。类型推断</a>
<ul class="sectlevel4">
<li><a href="#_principles">原则</a></li>
<li><a href="#_variables_vs_fields_in_type_inference">类型推断中的变量与字段</a></li>
<li><a href="#_collection_literal_type_inference">集合文字类型推断</a></li>
<li><a href="#section-lub">最小上限</a></li>
<li><a href="#_instanceof_inference">推理实例</a></li>
<li><a href="#section-flow-typing">流式</a></li>
<li><a href="#_advanced_type_inference">高级类型推断</a></li>
</ul>
</li>
<li><a href="#_closures_and_type_inference">6.2.6。闭包和类型推断</a>
<ul class="sectlevel4">
<li><a href="#_return_type_inference">返回类型推断</a></li>
<li><a href="#_parameter_type_inference">参数类型推断</a>
<ul class="sectlevel5">
<li><a href="#_explicit_closure_parameters">显式关闭参数</a></li>
<li><a href="#_parameters_inferred_from_single_abstract_method_types">从单抽象方法类型推断出的参数</a></li>
<li><a href="#_the_code_closureparams_code_annotation">的<code>@ClosureParams</code>注解</a></li>
</ul>
</li>
<li><a href="#_code_delegatesto_code"><code>@DelegatesTo</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_static_compilation">6.3。静态编译</a>
<ul class="sectlevel3">
<li><a href="#_dynamic_vs_static">6.3.1。动态与静态</a></li>
<li><a href="#compilestatic-annotation">6.3.2。的<code>@CompileStatic</code>注解</a></li>
<li><a href="#_key_benefits">6.3.3。主要好处</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_type_checking_extensions">7。类型检查扩展</a>
<ul class="sectlevel2">
<li><a href="#_writing_a_type_checking_extension">7.1。编写类型检查扩展</a>
<ul class="sectlevel3">
<li><a href="#_towards_a_smarter_type_checker">7.1.1。迈向更智能的类型检查器</a></li>
<li><a href="#Typecheckingextensions-Howdoesitwork">7.1.2。扩展属性</a></li>
<li><a href="#_a_dsl_for_type_checking">7.1.3。DSL用于类型检查</a></li>
<li><a href="#Typecheckingextensions-TheAPI">7.1.4。类型检查扩展API</a>
<ul class="sectlevel4">
<li><a href="#Typecheckingextensions-AST">AST</a></li>
<li><a href="#Typecheckingextensions-Events">大事记</a></li>
</ul>
</li>
<li><a href="#Typecheckingextensions-Workingwithextensions">7.1.5。使用扩展</a>
<ul class="sectlevel4">
<li><a href="#Typecheckingextensions-Supportclasses">支援课程</a></li>
<li><a href="#Typecheckingextensions-Classnodes">类节点</a></li>
<li><a href="#Typecheckingextensions-Helpingthetypechecker">帮助类型检查器</a></li>
<li><a href="#Typecheckingextensions-Throwinganerror">引发错误</a></li>
<li><a href="#Typecheckingextensions-isXXXExpression">isXXXExpression</a></li>
<li><a href="#Typecheckingextensions-Virtualmethods">虚方法</a></li>
<li><a href="#Typecheckingextensions-Scoping">范围界定</a></li>
<li><a href="#Typecheckingextensions-Otherusefulmethods">其他有用的方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_advanced_type_checking_extensions">7.2。高级类型检查扩展</a>
<ul class="sectlevel3">
<li><a href="#_precompiled_type_checking_extensions">7.2.1。预编译类型检查扩展</a></li>
<li><a href="#_using_grab_in_a_type_checking_extension">7.2.2。在类型检查扩展中使用@Grab</a></li>
<li><a href="#_sharing_or_packaging_type_checking_extensions">7.2.3。共享或打包类型检查扩展</a></li>
<li><a href="#_global_type_checking_extensions">7.2.4。全局类型检查扩展</a></li>
<li><a href="#_type_checking_extensions_and_compilestatic">7.2.5。类型检查扩展名和@CompileStatic</a></li>
<li><a href="#mixed-mode">7.2.6。混合模式编译</a></li>
<li><a href="#ast-xform-as-extension">7.2.7。在扩展中转换AST</a></li>
<li><a href="#_examples">7.2.8。例子</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了Groovy编程语言的语义。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_statements"><a class="anchor" href="#_statements"></a> 1。陈述</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_variable_definition"><a class="anchor" href="#_variable_definition"></a> 1.1。变量定义</h3>
<div class="paragraph">
<p>变量可以使用它们的任一类型（例如<code>String</code> ）或使用关键字<code>def</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String x
def o</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>def</code>是类型名称的替代。在变量定义中，它用来表示您不关心类型。在变量定义中，必须明确提供类型名称或在替换中使用“ def”。为了使Groovy解析器可检测到变量定义，这是必需的。</p>
</div>
<div class="paragraph">
<p>你可以想到<code>def</code>作为...的别名<code>Object</code>您将立即了解它。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">可以使用泛型来完善变量定义类型，例如<code>List<String> names</code> 。要了解有关泛型支持的更多信息，请阅读<a href="#generics">泛型部分</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_variable_assignment"><a class="anchor" href="#_variable_assignment"></a> 1.2。变量分配</h3>
<div class="paragraph">
<p>您可以将值分配给变量以供以后使用。请尝试以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">x = 1
println x

x = new java.util.Date()
println x

x = -3.1499392
println x

x = false
println x

x = "Hi"
println x</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_assignment"><a class="anchor" href="#_multiple_assignment"></a> 1.2.1。多重分配</h4>
<div class="paragraph">
<p>Groovy支持多重分配，即可以一次分配多个变量，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (a, b, c) = [10, 20, 'foo']
assert a == 10 &amp;&amp; b == 20 &amp;&amp; c == 'foo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果愿意，可以在声明中提供类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (int i, String j) = [10, 'foo']
assert i == 10 &amp;&amp; j == 'foo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>与声明变量时使用的方法一样，它也适用于现有变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nums = [1, 3, 5]
def a, b, c
(a, b, c) = nums
assert a == 1 &amp;&amp; b == 3 &amp;&amp; c == 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语法适用于数组，列表以及返回以下任意一个的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (_, month, year) = "18th June 2009".split()
assert "In $month of $year" == 'In June of 2009'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_overflow_and_underflow"><a class="anchor" href="#_overflow_and_underflow"></a> 1.2.2。上溢和下溢</h4>
<div class="paragraph">
<p>如果左侧的变量太多，则多余的变量将用null填充：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (a, b, c) = [1, 2]
assert a == 1 &amp;&amp; b == 2 &amp;&amp; c == null</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果右侧有太多变量，则多余的变量将被忽略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def (a, b) = [1, 2, 3]
assert a == 1 &amp;&amp; b == 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_object_destructuring_with_multiple_assignment"><a class="anchor" href="#_object_destructuring_with_multiple_assignment"></a> 1.2.3。具有多个分配的对象分解</h4>
<div class="paragraph">
<p>在描述各种<a href="#groovy-operators">Groovy运算符</a>的部分中，讨论了下<a href="#subscript-operator">标运算符</a>的大小写，解释了如何覆盖<code>getAt()</code> / <code>putAt()</code>方法。</p>
</div>
<div class="paragraph">
<p>使用这种技术，我们可以将多个赋值和下标运算符方法结合起来以实现<em>对象分解</em> 。</p>
</div>
<div class="paragraph">
<p>考虑以下不可变<code>Coordinates</code>类，其中包含一对经度和纬度对，并注意我们对<code>getAt()</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Immutable
class Coordinates {
    double latitude
    double longitude

    double getAt(int idx) {
        if (idx == 0) latitude
        else if (idx == 1) longitude
        else throw new Exception("Wrong coordinate index, use 0 or 1")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们实例化该类并破坏其经度和纬度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def coordinates = new Coordinates(latitude: 43.23, longitude: 3.67) <i class="conum" data-value="1"></i><b>(1)</b>

def (la, lo) = coordinates                                          <i class="conum" data-value="2"></i><b>(2)</b>

assert la == 43.23                                                  <i class="conum" data-value="3"></i><b>(3)</b>
assert lo == 3.67</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们创建了一个实例<code>Coordinates</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后，我们使用多重分配来获取各个经度和纬度值</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们最终可以维护其价值观。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_control_structures"><a class="anchor" href="#_control_structures"></a> 1.3。控制结构</h3>
<div class="sect3">
<h4 id="_conditional_structures"><a class="anchor" href="#_conditional_structures"></a> 1.3.1。条件结构</h4>
<div class="sect4">
<h5 id="_if_else"><a class="anchor" href="#_if_else"></a>如果别的</h5>
<div class="paragraph">
<p>Groovy支持通常的if-else Java语法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = false
def y = false

if ( !x ) {
    x = true
}

assert x == true

if ( x ) {
    x = false
} else {
    y = true
}

assert x == y</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果语法如下，那么Groovy还支持普通的Java“嵌套”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if ( ... ) {
    ...
} else if (...) {
    ...
} else {
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_switch_case"><a class="anchor" href="#_switch_case"></a>开关/箱</h5>
<div class="paragraph">
<p>Groovy中的switch语句向后兼容Java代码。因此您可以轻松解决多个匹配项共享相同代码的问题。</p>
</div>
<div class="paragraph">
<p>但是，一个区别是Groovy switch语句可以处理任何种类的switch值，并且可以执行不同种类的匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1.23
def result = ""

switch ( x ) {
    case "foo":
        result = "found foo"
        // lets fall through

    case "bar":
        result += "bar"

    case [4, 5, 6, 'inList']:
        result = "list"
        break

    case 12..30:
        result = "range"
        break

    case Integer:
        result = "integer"
        break

    case Number:
        result = "number"
        break

    case ~/fo*/: // toString() representation of x matches the pattern?
        result = "foo regex"
        break

    case { it &lt; 0 }: // or { x &lt; 0 }
        result = "negative"
        break

    default:
        result = "default"
}

assert result == "number"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Switch支持以下几种比较：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果switch值是该类的实例，则类大小写值匹配</p>
</li>
<li>
<p>如果正则表达式大小写值匹配<code>toString()</code>开关值的表示形式与正则表达式匹配</p>
</li>
<li>
<p>如果开关值包含在集合中，则集合用例值匹配。这也包括范围（因为它们是列表）</p>
</li>
<li>
<p>如果根据<a href="#Groovy-Truth">Groovy事实</a> ，调用闭包返回的结果为true，则闭包大小值匹配</p>
</li>
<li>
<p>如果未使用上述任何一项，则如果案例值等于开关值，则案例值匹配</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用闭包大小写值时，默认<code>it</code>参数实际上是开关值（在我们的示例中为变量<code>x</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_looping_structures"><a class="anchor" href="#_looping_structures"></a> 1.3.2。循环结构</h4>
<div class="sect4">
<h5 id="_classic_for_loop"><a class="anchor" href="#_classic_for_loop"></a>经典循环</h5>
<div class="paragraph">
<p>Groovy支持标准Java / C for循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String message = ''
for (int i = 0; i &lt; 5; i++) {
    message += 'Hi '
}
assert message == 'Hi Hi Hi Hi Hi '</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_for_in_loop"><a class="anchor" href="#_for_in_loop"></a>循环中</h5>
<div class="paragraph">
<p>Groovy中的for循环要简单得多，并且可以与任何类型的数组，集合，Map等一起使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// iterate over a range
def x = 0
for ( i in 0..9 ) {
    x += i
}
assert x == 45

// iterate over a list
x = 0
for ( i in [0, 1, 2, 3, 4] ) {
    x += i
}
assert x == 10

// iterate over an array
def array = (0..4).toArray()
x = 0
for ( i in array ) {
    x += i
}
assert x == 10

// iterate over a map
def map = ['abc':1, 'def':2, 'xyz':3]
x = 0
for ( e in map ) {
    x += e.value
}
assert x == 6

// iterate over values in a map
x = 0
for ( v in map.values() ) {
    x += v
}
assert x == 6

// iterate over the characters in a string
def text = "abc"
def list = []
for (c in text) {
    list.add(c)
}
assert list == ["a", "b", "c"]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy还支持带有冒号的Java冒号变体： <code>for (char c : text) {}</code> ，其中变量的类型是必需的。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_while_loop"><a class="anchor" href="#_while_loop"></a> while循环</h5>
<div class="paragraph">
<p>Groovy支持像Java这样的常规{@}循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 0
def y = 5

while ( y-- &gt; 0 ) {
    x++
}

assert x == 5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exception_handling"><a class="anchor" href="#_exception_handling"></a> 1.3.3。异常处理</h4>
<div class="paragraph">
<p>异常处理与Java相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_try_catch_finally"><a class="anchor" href="#_try_catch_finally"></a> 1.3.4。尝试/抓住/最后</h4>
<div class="paragraph">
<p>您可以指定一个完整的<code>try-catch-finally</code> ， 一种<code>try-catch</code>或<code>try-finally</code>组块。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">每个块体周围都需要支撑。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">try {
    'moo'.toLong()   // this will generate an exception
    assert false     // asserting that this point should never be reached
} catch ( e ) {
    assert e in NumberFormatException
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以将代码放在匹配的“ try”子句之后的“ finally”子句中，以便无论“ try”子句中的代码是否引发异常，finally子句中的代码将始终执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def z
try {
    def i = 7, j = 0
    try {
        def k = i / j
        assert false        //never reached due to Exception in previous line
    } finally {
        z = 'reached here'  //always executed even if Exception thrown
    }
} catch ( e ) {
    assert e in ArithmeticException
    assert z == 'reached here'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multi_catch"><a class="anchor" href="#_multi_catch"></a> 1.3.5。多渔获</h4>
<div class="paragraph">
<p>使用multi catch块（自Groovy 2.0起），我们能够定义要捕获并由同一catch块处理的多个异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">try {
    /* ... */
} catch ( IOException | NullPointerException e ) {
    /* one block to handle 2 exceptions */
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_power_assertion"><a class="anchor" href="#_power_assertion"></a> 1.4。权力主张</h3>
<div class="paragraph">
<p>与Groovy共享Java的Java不同<code>assert</code>关键字，Groovy中的后者的行为则大不相同。首先，总是执行Groovy中的断言，而与<code>-ea</code> JVM的标志。这使其成为单元测试的一流选择。“权力断言”的概念与Groovy的方式直接相关。 <code>assert</code>表现良好。</p>
</div>
<div class="paragraph">
<p>功率断言可分解为三个部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>assert [left expression] == [right expression] : (optional message)</pre>
</div>
</div>
<div class="paragraph">
<p>断言的结果与您在Java中获得的结果完全不同。如果断言为真，则什么都不会发生。如果断言为假，则它提供要断言的表达式的每个子表达式的值的可视表示。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 1+1 == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>将产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Caught: Assertion failed:

assert 1+1 == 3
        |  |
        2  false</pre>
</div>
</div>
<div class="paragraph">
<p>当表达式更复杂时，幂断言变得非常有趣，例如下面的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 2
def y = 7
def z = 5
def calc = { a,b -&gt; a*b+1 }
assert calc(x,y) == [x,z].sum()</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将为每个子表达式打印值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert calc(x,y) == [x,z].sum()
       |    | |  |   | |  |
       15   2 7  |   2 5  7
                 false</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不想像上面那样打印出漂亮的错误消息，则可以通过更改断言的可选消息部分来回退到自定义错误消息，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 2
def y = 7
def z = 5
def calc = { a,b -&gt; a*b+1 }
assert calc(x,y) == z*z : 'Incorrect computation result'</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将显示以下错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Incorrect computation result. Expression: (calc.call(x, y) == (z * z)). Values: z = 5, z = 5</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_labeled_statements"><a class="anchor" href="#_labeled_statements"></a> 1.5。带标签的声明</h3>
<div class="paragraph">
<p>任何语句都可以与标签关联。标签不会影响代码的语义，可用于使代码更易于阅读，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">given:
    def x = 1
    def y = 2
when:
    def z = x+y
then:
    assert z == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管不更改标记语句的语义，但仍可以在<code>break</code>指令作为跳转目标，如以下示例所示。但是，即使允许这样做，这种编码样式也通常被认为是不好的做法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">for (int i=0;i&lt;10;i++) {
    for (int j=0;j&lt;i;j++) {
        println "j=$j"
        if (j == 5) {
            break exit
        }
    }
    exit: println "i=$i"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是要了解，默认情况下标签不会影响代码的语义，但是它们属于抽象语法树（AST），因此AST转换可以使用该信息对代码执行转换，因此导致不同的语义。<a href="http://spockframework.github.io/spock/docs/current/index.html">Spock框架</a>尤其这样做是为了使测试更容易。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_expressions"><a class="anchor" href="#_expressions"></a> 2。表达方式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>（待定）</p>
</div>
<div class="sect2">
<h3 id="gpath_expressions"><a class="anchor" href="#gpath_expressions"></a> 2.1。GPath表达式</h3>
<div class="paragraph">
<p><code>GPath</code>是集成到Groovy中的一种路径表达语言，它允许识别嵌套的结构化数据的一部分。从这个意义上讲，它具有与XPath用于XML相似的目标和范围。GPath通常用于处理XML的上下文中，但实际上它适用于任何对象图。XPath使用类似于文件系统的路径表示法，即树状层次结构，其中部分之间用斜杠分隔<code>/</code> ，GPath <strong>使用点对象符号</strong>来执行对象导航。</p>
</div>
<div class="paragraph">
<p>例如，您可以指定目标对象或元素的路径：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a.b.c</code> →对于XML，产生所有<code>c</code>里面的元素<code>b</code>内<code>a</code></p>
</li>
<li>
<p><code>a.b.c</code> →对于POJO，产生<code>c</code>所有的属性<code>b</code>的性质<code>a</code> （有点像<code>a.getB().getC()</code>在JavaBeans中）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这两种情况下，都可以将GPath表达式视为对对象图的查询。对于POJO，对象图通常是由通过对象实例化和组合编写的程序构建的。对于XML处理，对象图是<code>parsing</code> XML文本，通常使用XmlParser或XmlSlurper之类的类。有关在Groovy中使用XML的更多详细信息，请参见<a href="../../../subprojects/groovy-xml/src/spec/doc/xml-userguide.html#Processing XML">处理XML</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>查询从XmlParser或XmlSlurper生成的对象图时，GPath表达式可以使用<code>@</code>符号：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a["@href"]</code> →类似地图的符号：所有a元素的href属性</p>
</li>
<li>
<p><code>a.'@href'</code> →属性符号：表达此内容的另一种方法</p>
</li>
<li>
<p><code>a.@href</code> →直接表示法：这是另一种表达方式</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_object_navigation"><a class="anchor" href="#_object_navigation"></a> 2.1.1。对象导航</h4>
<div class="paragraph">
<p>让我们看一个简单的<em>对象图</em>上的GPath表达式的示例，该<em>图</em>是使用java反射获得的。假设您处于类的非静态方法中，该方法具有另一个名为<code>aMethodFoo</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void aMethodFoo() { println "This is aMethodFoo." } <i class="conum" data-value="0"></i><b>(0)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下GPath表达式将获取该方法的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['aMethodFoo'] == this.class.methods.name.grep(~/.*Foo/)</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>更精确地讲</em> ，上面的GPath表达式会生成一个String列表，每个列表都是现有方法的名称。 <code>this</code>该名称以<code>Foo</code> 。</p>
</div>
<div class="paragraph">
<p>现在，在该类中还定义了以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void aMethodBar() { println "This is aMethodBar." } <i class="conum" data-value="1"></i><b>(1)</b>
void anotherFooMethod() { println "This is anotherFooMethod." } <i class="conum" data-value="2"></i><b>(2)</b>
void aSecondMethodBar() { println "This is aSecondMethodBar." } <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>那么以下GPath表达式将获得<strong>（1）</strong>和<strong>（3）的名称</strong> ，而不是<strong>（2）</strong>或<strong>（0）的名称</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['aMethodBar', 'aSecondMethodBar'] as Set == this.class.methods.name.grep(~/.*Bar/) as Set</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_expression_deconstruction"><a class="anchor" href="#_expression_deconstruction"></a> 2.1.2。表达解构</h4>
<div class="paragraph">
<p>我们可以分解表达式<code>this.class.methods.name.grep(~/.*Bar/)</code>了解如何评估GPath：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>this.class</code></dt>
<dd>
<p>属性访问器，等效于<code>this.getClass()</code>在Java中，产生一个<code>Class</code>宾语。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods</code></dt>
<dd>
<p>属性访问器，等效于<code>this.getClass().getMethods()</code> ，产生一个数组<code>Method</code>对象。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods.name</code></dt>
<dd>
<p>在数组的每个元素上应用属性访问器，并生成结果列表。</p>
</dd>
<dt class="hdlist1"><code>this.class.methods.name.grep(…​)</code></dt>
<dd>
<p>调用方法<code>grep</code>在列表产生的每个元素上<code>this.class.methods.name</code>并生成结果列表。</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">像<code>this.class.methods</code>产生一个数组，因为这就是调用<code>this.getClass().getMethods()</code>用Java会产生。 <code>GPath</code>表达式没有约定<code>s</code>表示列表或类似内容。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>GPath表达式的一项强大功能是将对集合的<em>属性访问</em>转换为<em>对集合的每个元素的属性访问</em> ，并将结果收集到集合中。因此，表达<code>this.class.methods.name</code>可以用Java表示如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;String&gt; methodNames = new ArrayList&lt;String&gt;();
for (Method method : this.getClass().getMethods()) {
   methodNames.add(method.getName());
}
return methodNames;</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组访问符号也可以在存在集合的GPath表达式中使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 'aSecondMethodBar' == this.class.methods.name.grep(~/.*Bar/).sort()[1]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">数组访问在GPath表达式中从零开始</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_gpath_for_xml_navigation"><a class="anchor" href="#_gpath_for_xml_navigation"></a> 2.1.3。用于XML导航的GPath</h4>
<div class="paragraph">
<p>这是一个XML文档和各种形式的GPath表达式的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def xmlText = """
              | &lt;root&gt;
              |   &lt;level&gt;
              |      &lt;sublevel id='1'&gt;
              |        &lt;keyVal&gt;
              |          &lt;key&gt;mykey&lt;/key&gt;
              |          &lt;value&gt;value 123&lt;/value&gt;
              |        &lt;/keyVal&gt;
              |      &lt;/sublevel&gt;
              |      &lt;sublevel id='2'&gt;
              |        &lt;keyVal&gt;
              |          &lt;key&gt;anotherKey&lt;/key&gt;
              |          &lt;value&gt;42&lt;/value&gt;
              |        &lt;/keyVal&gt;
              |        &lt;keyVal&gt;
              |          &lt;key&gt;mykey&lt;/key&gt;
              |          &lt;value&gt;fizzbuzz&lt;/value&gt;
              |        &lt;/keyVal&gt;
              |      &lt;/sublevel&gt;
              |   &lt;/level&gt;
              | &lt;/root&gt;
              """
def root = new XmlSlurper().parseText(xmlText.stripMargin())
assert root.level.size() == 1 <i class="conum" data-value="1"></i><b>(1)</b>
assert root.level.sublevel.size() == 2 <i class="conum" data-value="2"></i><b>(2)</b>
assert root.level.sublevel.findAll { it.@id == 1 }.size() == 1 <i class="conum" data-value="3"></i><b>(3)</b>
assert root.level.sublevel[1].keyVal[0].key.text() == 'anotherKey' <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>有一个<code>level</code>下的节点<code>root</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>那里有两个<code>sublevel</code>下的节点<code>root/level</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>有一个要素<code>sublevel</code>具有属性<code>id</code>有价值<code>1</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>的文字值<code>key</code>第一要素<code>keyVal</code>第二要素<code>sublevel</code>下的元素<code>root/level</code>是“ anotherKey”</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_promotion_and_coercion"><a class="anchor" href="#_promotion_and_coercion"></a> 3。促进和强迫</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_number_promotion"><a class="anchor" href="#_number_promotion"></a> 3.1。号码促销</h3>
<div class="paragraph">
<p>数升法则在<a href="#_math_operations">数学运算</a>部分中指定。</p>
</div>
</div>
<div class="sect2">
<h3 id="closure-coercion"><a class="anchor" href="#closure-coercion"></a> 3.2。强制关闭</h3>
<div class="sect3">
<h4 id="_assigning_a_closure_to_a_sam_type"><a class="anchor" href="#_assigning_a_closure_to_a_sam_type"></a> 3.2.1。为SAM类型分配闭包</h4>
<div class="paragraph">
<p>SAM类型是定义单个抽象方法的类型。这包括：</p>
</div>
<div class="listingblock">
<div class="title">功能接口</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Predicate&lt;T&gt; {
    boolean accept(T obj)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">单一抽象方法的抽象类</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Greeter {
    abstract String getName()
    void greet() {
        println "Hello, $name"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用以下命令将任何闭包转换为SAM类型<code>as</code>操作员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Predicate filter = { it.contains 'G' } as Predicate
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' } as Greeter
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而<code>as Type</code>自Groovy 2.2.0起，表达式是可选的。您可以忽略它，只需编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Predicate filter = { it.contains 'G' }
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' }
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着您也可以使用方法指针，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">boolean doFilter(String s) { s.contains('G') }

Predicate filter = this.&amp;doFilter
assert filter.accept('Groovy') == true

Greeter greeter = GroovySystem.&amp;getVersion
greeter.greet()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_calling_a_method_accepting_a_sam_type_with_a_closure"><a class="anchor" href="#_calling_a_method_accepting_a_sam_type_with_a_closure"></a> 3.2.2。用闭包调用接受SAM类型的方法</h4>
<div class="paragraph">
<p>关闭SAM类型强制的第二个，可能是更重要的用例是调用一个接受SAM类型的方法。想象一下以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; source, Predicate&lt;T&gt; predicate) {
    source.findAll { predicate.accept(it) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用闭包调用它，而无需创建接口的显式实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert filter(['Java','Groovy'], { it.contains 'G'} as Predicate) == ['Groovy']</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是从Groovy 2.2.0开始，您还可以省略显式强制并像使用闭包一样调用该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert filter(['Java','Groovy']) { it.contains 'G'} == ['Groovy']</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，这具有使您可以将闭包语法用于方法调用的优势，也就是说，将闭包置于括号之外，从而提高了代码的可读性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_closure_to_arbitrary_type_coercion"><a class="anchor" href="#_closure_to_arbitrary_type_coercion"></a> 3.2.3。对任意类型强制的关闭</h4>
<div class="paragraph">
<p>除SAM类型外，闭包还可以强制为任何类型，尤其是接口。让我们定义以下接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface FooBar {
    int foo()
    void bar()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>as</code>关键词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def impl = { println 'ok'; 123 } as FooBar</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将产生一个使用闭包实现所有方法的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert impl.foo() == 123
impl.bar()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是也有可能强迫任何一个类关闭。例如，我们可以替换<code>interface</code>我们定义的<code>class</code>无需更改断言：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class FooBar {
    int foo() { 1 }
    void bar() { println 'bar' }
}

def impl = { println 'ok'; 123 } as FooBar

assert impl.foo() == 123
impl.bar()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_map_to_type_coercion"><a class="anchor" href="#_map_to_type_coercion"></a> 3.3。映射为强制类型</h3>
<div class="paragraph">
<p>通常，使用单个闭包来实现具有多个方法的接口或类不是可行的方法。或者，Groovy允许您将地图强制为接口或类。在这种情况下，映射的键将解释为方法名称，而值则是方法实现。以下示例说明了将地图强制转换为<code>Iterator</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map
map = [
  i: 10,
  hasNext: { map.i &gt; 0 },
  next: { map.i-- },
]
def iter = map as Iterator</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，这是一个相当人为的示例，但说明了这一概念。您只需要实现实际调用的那些方法，但是如果调用的方法在地图中不存在，则<code>MissingMethodException</code>或<code>UnsupportedOperationException</code>取决于传递给调用的参数，将抛出该异常，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface X {
    void f()
    void g(int n)
    void h(String s, int n)
}

x = [ f: {println "f called"} ] as X
x.f() // method exists
x.g() // MissingMethodException here
x.g(5) // UnsupportedOperationException here</code></pre>
</div>
</div>
<div class="paragraph">
<p>异常的类型取决于调用本身：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MissingMethodException</code>如果调用的参数与接口/类的参数不匹配</p>
</li>
<li>
<p><code>UnsupportedOperationException</code>如果调用的参数与接口/类的重载方法之一匹配</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_string_to_enum_coercion"><a class="anchor" href="#_string_to_enum_coercion"></a> 3.4。强制枚举的字符串</h3>
<div class="paragraph">
<p>Groovy允许透明<code>String</code> （要么<code>GString</code> ）枚举值强制。假设您定义了以下枚举：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">enum State {
    up,
    down
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么您可以为枚举分配一个字符串，而不必使用显式<code>as</code>强迫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">State st = 'up'
assert st == State.up</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用<code>GString</code>作为值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def val = "up"
State st = "${val}"
assert st == State.up</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这会引发运行时错误（ <code>IllegalArgumentException</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">State st = 'not an enum value'</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，还可以在switch语句中使用隐式强制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">State switchState(State st) {
    switch (st) {
        case 'up':
            return State.down // explicit constant
        case 'down':
            return 'up' // implicit coercion for return types
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特别要看<code>case</code>使用字符串常量。但是，如果您调用的方法将枚举与<code>String</code>参数，您仍然必须使用显式<code>as</code>强迫：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert switchState('up' as State) == State.down
assert switchState(State.down) == State.up</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_type_coercion"><a class="anchor" href="#_custom_type_coercion"></a> 3.5。自定义类型强制</h3>
<div class="paragraph">
<p>一个班级可以通过实施<code>asType</code>方法。使用以下命令调用自定义强制<code>as</code>运算符，并且从不隐式。例如，假设您定义了两个类， <code>Polar</code>和<code>Cartesian</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Polar {
    double r
    double phi
}
class Cartesian {
   double x
   double y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且您要从极坐标转换为笛卡尔坐标。一种方法是定义<code>asType</code>中的方法<code>Polar</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def asType(Class target) {
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许您使用<code>as</code>强制运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def sigma = 1E-16
def polar = new Polar(r:1.0,phi:PI/2)
def cartesian = polar as Cartesian
assert abs(cartesian.x-sigma) &lt; sigma</code></pre>
</div>
</div>
<div class="paragraph">
<p>放在一起， <code>Polar</code>类看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Polar {
    double r
    double phi
    def asType(Class target) {
        if (Cartesian==target) {
            return new Cartesian(x: r*cos(phi), y: r*sin(phi))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但也可以定义<code>asType</code>外面的<code>Polar</code>类，如果您想为“封闭”类或您不拥有源代码的类定义自定义强制策略，例如使用元类，则可以使用该类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Polar.metaClass.asType = { Class target -&gt;
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_class_literals_vs_variables_and_the_as_operator"><a class="anchor" href="#_class_literals_vs_variables_and_the_as_operator"></a> 3.6。类文字，变量和as运算符</h3>
<div class="paragraph">
<p>使用<code>as</code>仅当您具有对类的静态引用时，才可以使用关键字，例如以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter {
    void greet()
}
def greeter = { println 'Hello, Groovy!' } as Greeter // Greeter is known statically
greeter.greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果您通过反思（例如通过调用）获得课程，该怎么办<code>Class.forName</code> ？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Class clazz = Class.forName('Greeter')</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试使用对类的引用<code>as</code>关键字将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">greeter = { println 'Hello, Groovy!' } as clazz
// throws:
// unable to resolve class clazz
// @ line 9, column 40.
//   greeter = { println 'Hello, Groovy!' } as clazz</code></pre>
</div>
</div>
<div class="paragraph">
<p>之所以失败，是因为<code>as</code>关键字仅适用于类文字。相反，您需要致电<code>asType</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">greeter = { println 'Hello, Groovy!' }.asType(clazz)
greeter.greet()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_optionality"><a class="anchor" href="#_optionality"></a> 4。可选性</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_optional_parentheses"><a class="anchor" href="#_optional_parentheses"></a> 4.1。可选括号</h3>
<div class="paragraph">
<p>如果至少有一个参数并且没有歧义，则方法调用可以省略括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println 'Hello World'
def maximum = Math.max 5, 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于没有参数或模棱两可的方法调用，必须使用括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println()
println(Math.max(5, 10))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optional_semicolons"><a class="anchor" href="#_optional_semicolons"></a> 4.2。可选分号</h3>
<div class="paragraph">
<p>在Groovy中，如果行仅包含一个语句，则可以省略行末的分号。</p>
</div>
<div class="paragraph">
<p>这意味着：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert true;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以更习惯地写为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert true</code></pre>
</div>
</div>
<div class="paragraph">
<p>一行中的多个语句需要用分号将它们分开：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">boolean a = true; assert a</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optional_return_keyword"><a class="anchor" href="#_optional_return_keyword"></a> 4.3。可选的return关键字</h3>
<div class="paragraph">
<p>在Groovy中，返回在方法或闭包中评估的最后一个表达式。这意味着<code>return</code>关键字是可选的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int add(int a, int b) {
    return a+b
}
assert add(1, 2) == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以缩短为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int add(int a, int b) {
    a+b
}
assert add(1, 2) == 3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optional_public_keyword"><a class="anchor" href="#_optional_public_keyword"></a> 4.4。可选的公共关键字</h3>
<div class="paragraph">
<p>默认情况下，Groovy类和方法是<code>public</code> 。因此本课：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class Server {
    public String toString() { "a server" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与此类相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Server {
    String toString() { "a server" }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Groovy-Truth"><a class="anchor" href="#Groovy-Truth"></a> 5，时髦的真相</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy通过应用下面给出的规则来确定一个表达式是真还是假。</p>
</div>
<div class="sect2">
<h3 id="_boolean_expressions"><a class="anchor" href="#_boolean_expressions"></a> 5.1。布尔表达式</h3>
<div class="paragraph">
<p>如果相应的布尔值为<code>true</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert true
assert !false</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_collections_and_arrays"><a class="anchor" href="#_collections_and_arrays"></a> 5.2。集合和数组</h3>
<div class="paragraph">
<p>非空集合和数组为真。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [1, 2, 3]
assert ![]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matchers"><a class="anchor" href="#_matchers"></a> 5.3。匹配器</h3>
<div class="paragraph">
<p>如果Matcher至少有一场比赛，则为True。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ('a' =~ /a/)
assert !('a' =~ /b/)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_iterators_and_enumerations"><a class="anchor" href="#_iterators_and_enumerations"></a> 5.4。迭代器和枚举</h3>
<div class="paragraph">
<p>具有其他元素的迭代器和枚举被强制为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert [0].iterator()
assert ![].iterator()
Vector v = [0] as Vector
Enumeration enumeration = v.elements()
assert enumeration
enumeration.nextElement()
assert !enumeration</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_maps"><a class="anchor" href="#_maps"></a> 5.5。地图</h3>
<div class="paragraph">
<p>非空Maps评估为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert ['one' : 1]
assert ![:]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_strings"><a class="anchor" href="#_strings"></a> 5.6。弦乐</h3>
<div class="paragraph">
<p>非空字符串，GString和CharSequences被强制为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 'a'
assert !''
def nonEmpty = 'a'
assert "$nonEmpty"
def empty = ''
assert !"$empty"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_numbers"><a class="anchor" href="#_numbers"></a> 5.7。号码</h3>
<div class="paragraph">
<p>非零数字为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert 1
assert 3.5
assert !0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_references"><a class="anchor" href="#_object_references"></a> 5.8。对象引用</h3>
<div class="paragraph">
<p>非空对象引用被强制为true。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new Object()
assert !null</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_the_truth_with_asboolean_methods"><a class="anchor" href="#_customizing_the_truth_with_asboolean_methods"></a> 5.9。使用asBoolean（）方法自定义真相</h3>
<div class="paragraph">
<p>为了自定义groovy是否将您的对象评估为<code>true</code>要么<code>false</code>实施<code>asBoolean()</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Color {
    String name

    boolean asBoolean(){
        name == 'green' ? true : false
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy将调用此方法将您的对象强制为布尔值，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new Color(name: 'green')
assert !new Color(name: 'red')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_typing"><a class="anchor" href="#_typing"></a> 6。打字</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_optional_typing"><a class="anchor" href="#_optional_typing"></a> 6.1。可选输入</h3>
<div class="paragraph">
<p>可选类型是一种想法，即使您没有将显式类型放在变量上，程序也可以运行。作为一种动态语言，Groovy自然地实现了该功能，例如，在声明变量时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String aString = 'foo'                      <i class="conum" data-value="1"></i><b>(1)</b>
assert aString.toUpperCase()                <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>foo</code>是使用显式类型声明的<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以打电话给<code>toUpperCase</code>上的方法<code>String</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Groovy将让您编写以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def aString = 'foo'                         <i class="conum" data-value="1"></i><b>(1)</b>
assert aString.toUpperCase()                <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>foo</code>使用声明<code>def</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们仍然可以致电<code>toUpperCase</code>方法，因为类型<code>aString</code>在运行时解决</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，在这里使用显式类型都没关系。当您将此功能与<a href="#static-type-checking">静态类型检查</a>结合使用时，这特别有趣，因为类型检查器会执行类型推断。</p>
</div>
<div class="paragraph">
<p>同样，Groovy也不强制在方法中声明参数的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String concat(String a, String b) {
    a+b
}
assert concat('foo','bar') == 'foobar'</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用重写<code>def</code>作为返回类型和参数类型，以便利用鸭子类型，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def concat(def a, def b) {                              <i class="conum" data-value="1"></i><b>(1)</b>
    a+b
}
assert concat('foo','bar') == 'foobar'                  <i class="conum" data-value="2"></i><b>(2)</b>
assert concat(1,2) == 3                                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>返回类型和参数类型都使用<code>def</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>它使得可以将方法与<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>而且还有<code>int</code>自从<code>plus</code>方法已定义</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用<code>def</code>建议使用此处的关键字来描述应该适用于任何类型的方法的意图，但是从技术上讲，我们可以使用<code>Object</code>相反，结果将是相同的： <code>def</code>在Groovy中，严格等于使用<code>Object</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最终，可以同时从返回类型和描述符中删除该类型。但是，如果要将其从返回类型中删除，则需要为该方法添加一个显式修饰符，以便编译器可以在方法声明和方法调用之间有所不同，如本示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">private concat(a,b) {                                   <i class="conum" data-value="1"></i><b>(1)</b>
    a+b
}
assert concat('foo','bar') == 'foobar'                  <i class="conum" data-value="2"></i><b>(2)</b>
assert concat(1,2) == 3                                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果我们想省略返回类型，则必须设置一个显式修饰符。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>仍然可以与<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>还有<code>int</code></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">通常，在公共API的方法参数或方法返回类型中，忽略类型是不好的做法。使用时<code>def</code>在局部变量中并不是一个真正的问题，因为在方法参数上进行设置时，变量的可见性仅限于方法本身， <code>def</code>将被转换为<code>Object</code>在方法签名中，使用户很难知道哪种参数是预期的类型。这意味着您应该将其限制在显式依赖鸭子类型的情况下。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="static-type-checking"><a class="anchor" href="#static-type-checking"></a> 6.2。静态类型检查</h3>
<div class="paragraph">
<p>默认情况下，Groovy在编译时执行最少的类型检查。由于它主要是一种动态语言，因此大多数静态编译器通常不会在编译时进行检查。通过运行时元编程添加的方法可能会更改类或对象的运行时行为。在下面的示例中，说明原因：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {                                                          <i class="conum" data-value="1"></i><b>(1)</b>
    String firstName
    String lastName
}
def p = new Person(firstName: 'Raymond', lastName: 'Devos')             <i class="conum" data-value="2"></i><b>(2)</b>
assert p.formattedName == 'Raymond Devos'                               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Person</code>类仅定义两个属性， <code>firstName</code>和<code>lastName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们可以创建一个Person的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并调用一个名为<code>formattedName</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在动态语言中，例如上面的示例这样的代码不抛出任何错误是很常见的。怎么会这样？在Java中，这通常会在编译时失败。但是，在Groovy中，它不会在编译时失败，并且如果编码正确，也不会在运行时失败。实际上，要使其在运行时工作， <strong>一种</strong>可能性是依靠运行时元编程。因此，只需在声明之后添加此行<code>Person</code>上课就足够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person.metaClass.getFormattedName = { "$delegate.firstName $delegate.lastName" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着通常，在Groovy中，您不能对对象的类型进行超出其声明类型的任何假设，即使您知道它，也无法在编译时确定将调用哪种方法，或确定哪种方法。属性将被检索。从编写DSL到测试，都有很多兴趣，这将在本手册的其他部分中进行讨论。</p>
</div>
<div class="paragraph">
<p>但是，如果您的程序不依赖动态功能，并且您来自静态世界（尤其是Java思维方式），那么在编译时不捕获此类“错误”可能会令人惊讶。正如我们在前面的示例中看到的那样，编译器无法确定这是一个错误。要使其知道，必须显式指示编译器要切换到类型检查模式。这可以通过用以下方法注释类或方法来完成： <code>@groovy.lang.TypeChecked</code> 。</p>
</div>
<div class="paragraph">
<p>激活类型检查后，编译器将执行更多工作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型推断已激活，这意味着即使您使用<code>def</code>例如，在局部变量上，类型检查器将能够从分配中推断出变量的类型</p>
</li>
<li>
<p>方法调用在编译时解决，这意味着如果未在类上声明方法，则编译器将引发错误</p>
</li>
<li>
<p>通常，您会使用静态语言找到的所有编译时错误都会出现：找不到方法，找不到属性，方法调用的类型不兼容，数字精度错误等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在本节中，我们将描述各种情况下类型检查器的行为，并说明使用限制<code>@TypeChecked</code>在您的代码上。</p>
</div>
<div class="sect3">
<h4 id="_the_code_typechecked_code_annotation"><a class="anchor" href="#_the_code_typechecked_code_annotation"></a> 6.2.1。的<code>@TypeChecked</code>注解</h4>
<div class="sect4">
<h5 id="_activating_type_checking_at_compile_time"><a class="anchor" href="#_activating_type_checking_at_compile_time"></a>在编译时激活类型检查</h5>
<div class="paragraph">
<p>的<code>groovy.lang.TypeChecked</code>启用注释的类型检查。可以放在一个类上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
class Calculator {
    int sum(int x, int y) { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在方法上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calculator {
    @groovy.transform.TypeChecked
    int sum(int x, int y) { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，将对带注释的类的所有方法，属性，字段，内部类...进行类型检查，而在第二种情况下，将仅对方法和其可能包含的闭包或匿名内部类进行类型检查。</p>
</div>
</div>
<div class="sect4">
<h5 id="_skipping_sections"><a class="anchor" href="#_skipping_sections"></a>跳过部分</h5>
<div class="paragraph">
<p>类型检查的范围可以受到限制。例如，如果对一个类进行了类型检查，则可以指示类型检查器跳过方法，方法是使用注释<code>@TypeChecked(TypeCheckingMode.SKIP)</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TypeChecked
import groovy.transform.TypeCheckingMode

@TypeChecked                                        <i class="conum" data-value="1"></i><b>(1)</b>
class GreetingService {
    String greeting() {                             <i class="conum" data-value="2"></i><b>(2)</b>
        doGreet()
    }

    @TypeChecked(TypeCheckingMode.SKIP)             <i class="conum" data-value="3"></i><b>(3)</b>
    private String doGreet() {
        def b = new SentenceBuilder()
        b.Hello.my.name.is.John                     <i class="conum" data-value="4"></i><b>(4)</b>
        b
    }
}
def s = new GreetingService()
assert s.greeting() == 'Hello my name is John'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>GreetingService</code>类标记为已检查类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>所以<code>greeting</code>方法自动类型检查</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>但<code>doGreet</code>标有<code>SKIP</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>类型检查器不会抱怨这里缺少属性</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在上一个示例中， <code>SentenceBuilder</code>依靠动态代码。没有真正的<code>Hello</code>方法或属性，因此类型检查器通常会抱怨并且编译会失败。由于使用构建器的方法标记为<code>TypeCheckingMode.SKIP</code> ，此方法将<em>跳过</em>类型检查，因此即使类的其余部分都经过类型检查，代码也将编译。</p>
</div>
<div class="paragraph">
<p>以下各节描述了Groovy中类型检查的语义。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_type_checking_assignments"><a class="anchor" href="#_type_checking_assignments"></a> 6.2.2。类型检查分配</h4>
<div class="paragraph">
<p>一个东西<code>o</code>类型的<code>A</code>可以分配给类型的变量<code>T</code>当且仅当：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code>等于<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Date now = new Date()</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是其中之一<code>String</code> ， <code>boolean</code> ， <code>Boolean</code>要么<code>Class</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String s = new Date() // implicit call to toString
Boolean boxed = 'some string'       // Groovy truth
boolean prim = 'some string'        // Groovy truth
Class clazz = 'java.lang.String'    // class coercion</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>o</code>为null并且<code>T</code>不是原始类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String s = null         // passes
int i = null            // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个数组， <code>A</code>是一个数组，组件类型为<code>A</code>可分配给的组件类型<code>T</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int[] i = new int[4]        // passes
int[] i = new String[4]     // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个数组， <code>A</code>是列表和组件类型<code>A</code>可分配给的组件类型<code>T</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int[] i = [1,2,3]               // passes
int[] i = [1,2, new Date()]     // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是...的超类<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">AbstractList list = new ArrayList()     // passes
LinkedList list = new ArrayList()       // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是由实现的接口<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">List list = new ArrayList()             // passes
RandomAccess list = new LinkedList()    // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>要么<code>A</code>是原始类型，它们的装箱类型是可分配的</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int i = 0
Integer bi = 1
int x = new Integer(123)
double d = new Float(5f)</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>延伸<code>groovy.lang.Closure</code>和<code>A</code>是SAM类型（单个抽象方法类型）</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Runnable r = { println 'Hello' }
interface SAMType {
    int doSomething()
}
SAMType sam = { 123 }
assert sam.doSomething() == 123
abstract class AbstractSAM {
    int calc() { 2* value() }
    abstract int value()
}
AbstractSAM c = { 123 }
assert c.calc() == 246</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>和<code>A</code>从获得<code>java.lang.Number</code>并符合下表</p>
</li>
</ul>
</div>
<table id="number-assignment" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。数字类型（java.lang。XXX）</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Ť</th>
<th class="tableblock halign-left valign-top">一种</th>
<th class="tableblock halign-left valign-top">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal或BigInteger外的任何值</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Double d1 = 4d
Double d2 = 4f
Double d3 = 4l
Double d4 = 4i
Double d5 = (short) 4
Double d6 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮动</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger或Double外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Float f1 = 4f
Float f2 = 4l
Float f3 = 4i
Float f4 = (short) 4
Float f5 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger，Double或Float外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Long l1 = 4l
Long l2 = 4i
Long l3 = (short) 4
Long l4 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger，Double，Float或Long外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Integer i1 = 4i
Integer i2 = (short) 4
Integer i3 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除BigDecimal，BigInteger，Double，Float，Long或Integer外的任何类型</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Short s1 = (short) 4
Short s2 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Byte b1 = (byte) 4</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_list_and_map_constructors"><a class="anchor" href="#_list_and_map_constructors"></a> 6.2.3。列表和地图构造函数</h4>
<div class="paragraph">
<p>除上述分配规则外，如果认为分配无效，则在类型检查模式下使用<em>列表</em>文字或<em>地图</em>文字<code>A</code>可以分配给类型的变量<code>T</code>如果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>赋值是一个变量声明， <code>A</code>是列表文字，并且<code>T</code>有一个构造函数，其参数与列表文字中元素的类型匹配</p>
</li>
<li>
<p>赋值是一个变量声明， <code>A</code>是地图文字， <code>T</code>具有无参数构造函数和每个映射键的属性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，代替编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person classic = new Person('Ada','Lovelace')</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用“列表构造函数”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person list = ['Ada','Lovelace']</code></pre>
</div>
</div>
<div class="paragraph">
<p>或“地图构造函数”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Person map = [firstName:'Ada', lastName:'Lovelace']</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用地图构造函数，则会对地图的键进行其他检查，以检查是否定义了相同名称的属性。例如，以下将在编译时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person map = [firstName:'Ada', lastName:'Lovelace', age: 24]     <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类型检查器将引发错误<code>No such property: age for class: Person</code>在编译时</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_method_resolution"><a class="anchor" href="#_method_resolution"></a> 6.2.4。方法解析</h4>
<div class="paragraph">
<p>在类型检查模式下，方法在编译时解析。解析按名称和参数进行。返回类型与方法选择无关。参数类型与遵循这些规则的参数类型匹配：</p>
</div>
<div class="paragraph">
<p>争论<code>o</code>类型的<code>A</code>可以用于类型的参数<code>T</code>当且仅当：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code>等于<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int sum(int x, int y) {
    x+y
}
assert sum(3,4) == 7</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个<code>String</code>和<code>A</code>是一个<code>GString</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(String str) {
    "Result: $str"
}
assert format("${3+4}") == "Result: 7"</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>o</code>为null并且<code>T</code>不是原始类型</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(int value) {
    "Result: $value"
}
assert format(7) == "Result: 7"
format(null)           // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是一个数组， <code>A</code>是一个数组，组件类型为<code>A</code>可分配给的组件类型<code>T</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(String[] values) {
    "Result: ${values.join(' ')}"
}
assert format(['a','b'] as String[]) == "Result: a b"
format([1,2] as int[])              // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是...的超类<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(AbstractList list) {
    list.join(',')
}
format(new ArrayList())              // passes
String format(LinkedList list) {
    list.join(',')
}
format(new ArrayList())              // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>是由实现的接口<code>A</code></p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String format(List list) {
    list.join(',')
}
format(new ArrayList())                  // passes
String format(RandomAccess list) {
    'foo'
}
format(new LinkedList())                 // fails</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>要么<code>A</code>是原始类型，它们的装箱类型是可分配的</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int sum(int x, Integer y) {
    x+y
}
assert sum(3, new Integer(4)) == 7
assert sum(new Integer(3), 4) == 7
assert sum(new Integer(3), new Integer(4)) == 7
assert sum(new Integer(3), 4) == 7</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>延伸<code>groovy.lang.Closure</code>和<code>A</code>是SAM类型（单个抽象方法类型）</p>
<div class="exampleblock result">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface SAMType {
    int doSomething()
}
int twice(SAMType sam) { 2*sam.doSomething() }
assert twice { 123 } == 246
abstract class AbstractSAM {
    int calc() { 2* value() }
    abstract int value()
}
int eightTimes(AbstractSAM sam) { 4*sam.calc() }
assert eightTimes { 123 } == 984</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><em>要么</em> <code>T</code>和<code>A</code>从获得<code>java.lang.Number</code>并遵守与<a href="#number-assignment">数字分配</a>相同的规则</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在编译时找不到具有适当名称和参数的方法，则会引发错误。以下示例说明了与“常规” Groovy的区别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyService {
    void doSomething() {
        printLine 'Do something'            <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>printLine</code>是一个错误，但是由于我们处于动态模式，因此在编译时不会捕获该错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>上面的示例显示了Groovy将能够编译的类。但是，如果您尝试创建一个实例<code>MyService</code>并致电<code>doSomething</code>方法，那么它将<strong>在运行时</strong>失败，因为<code>printLine</code>不存在。当然，我们已经展示了Groovy如何使它成为一个完全有效的调用，例如通过捕获<code>MethodMissingException</code>或实现自定义元类，但是如果您知道自己不在这种情况下， <code>@TypeChecked</code>派上用场了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
class MyService {
    void doSomething() {
        printLine 'Do something'            <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>printLine</code>这是编译时错误吗</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>只是添加<code>@TypeChecked</code>将触发编译时方法解析。类型检查器将尝试查找方法<code>printLine</code>接受<code>String</code>在<code>MyService</code>类，但找不到一个。它将失败，并显示以下消息：</p>
</div>
<div class="paragraph">
<p><code>Cannot find matching method MyService#printLine(java.lang.String)</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">了解类型检查器背后的逻辑很重要：它是编译时检查，因此根据定义，类型检查器不知道您执行的任何类型的<strong>运行时</strong>元编程。这意味着没有<code>@TypeChecked</code>如果激活类型检查，将<strong>不再</strong>编译。如果您想到鸭子输入，尤其如此：<br>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck {
    void quack() {              <i class="conum" data-value="1"></i><b>(1)</b>
        println 'Quack!'
    }
}
class QuackingBird {
    void quack() {              <i class="conum" data-value="2"></i><b>(2)</b>
        println 'Quack!'
    }
}
@groovy.transform.TypeChecked
void accept(quacker) {
    quacker.quack()             <i class="conum" data-value="3"></i><b>(3)</b>
}
accept(new Duck())              <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们定义一个<code>Duck</code>定义一个<code>quack</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们定义另一个<code>QuackingBird</code>类还定义了一个<code>quack</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>quacker</code>是松散类型的，因此由于该方法是<code>@TypeChecked</code> ，我们将获得一个编译时错误</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>即使在非类型检查的Groovy中，这也会通过</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有一些可能的解决方法，例如引入接口，但是基本上，通过激活类型检查，您可以获得类型安全性，但是却失去了该语言的某些功能。希望Groovy引入一些功能，例如流类型，以减少类型检查和非类型检查的Groovy之间的差距。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="type-inference"><a class="anchor" href="#type-inference"></a> 6.2.5。类型推断</h4>
<div class="sect4">
<h5 id="_principles"><a class="anchor" href="#_principles"></a>原则</h5>
<div class="paragraph">
<p>当代码带有注释时<code>@TypeChecked</code> ，编译器执行类型推断。它不仅仅依赖于静态类型，而且还使用各种技术来推断变量的类型，返回类型，文字等等。这样即使激活类型检查器，代码也可以保持尽可能的简洁。</p>
</div>
<div class="paragraph">
<p>最简单的示例是推断变量的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def message = 'Welcome to Groovy!'              <i class="conum" data-value="1"></i><b>(1)</b>
println message.toUpperCase()                   <i class="conum" data-value="2"></i><b>(2)</b>
println message.upper() // compile time error   <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>def</code>关键词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>呼唤<code>toUpperCase</code>由类型检查器允许</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>呼唤<code>upper</code>将在编译时失败</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>之所以打电话给<code>toUpperCase</code>作品是因为<code>message</code>被<em>推断</em>为<code>String</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_variables_vs_fields_in_type_inference"><a class="anchor" href="#_variables_vs_fields_in_type_inference"></a>类型推断中的变量与字段</h5>
<div class="paragraph">
<p>值得注意的是，尽管编译器对局部变量执行类型推断，但它<strong>不对</strong>字段执行任何类型的推断，始终回退到<strong>声明</strong>的字段<strong>类型</strong> 。为了说明这一点，让我们看一下这个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeClass {
    def someUntypedField                                                                <i class="conum" data-value="1"></i><b>(1)</b>
    String someTypedField                                                               <i class="conum" data-value="2"></i><b>(2)</b>

    void someMethod() {
        someUntypedField = '123'                                                        <i class="conum" data-value="3"></i><b>(3)</b>
        someUntypedField = someUntypedField.toUpperCase()  // compile-time error        <i class="conum" data-value="4"></i><b>(4)</b>
    }

    void someSafeMethod() {
        someTypedField = '123'                                                          <i class="conum" data-value="5"></i><b>(5)</b>
        someTypedField = someTypedField.toUpperCase()                                   <i class="conum" data-value="6"></i><b>(6)</b>
    }

    void someMethodUsingLocalVariable() {
        def localVariable = '123'                                                       <i class="conum" data-value="7"></i><b>(7)</b>
        someUntypedField = localVariable.toUpperCase()                                  <i class="conum" data-value="8"></i><b>(8)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>someUntypedField</code>用途<code>def</code>作为声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>someTypedField</code>用途<code>String</code>作为声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以分配<strong>任何东西</strong>给<code>someUntypedField</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>尚未致电<code>toUpperCase</code>在编译时失败，因为该字段未正确键入</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>我们可以分配一个<code>String</code>到类型的字段<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>而这次<code>toUpperCase</code>被允许</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>如果我们分配一个<code>String</code>到局部变量</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>然后打电话<code>toUpperCase</code>允许在局部变量上</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为什么会有这样的差异？原因是<em>线程安全</em> 。在编译的时候，我们不能让有关字段的类型<strong>的任何</strong>保证。任何线程都可以随时访问任何字段，并且在方法中为某个字段分配某种类型的变量并在第二行使用该时间之间，另一个线程可能已更改了该字段的内容。局部变量不是这种情况：我们知道它们是否“转义”，因此我们可以确保变量的类型在一段时间内是恒定的（或不是恒定的）。请注意，即使字段为final，JVM也无法对此作出保证，因此，如果字段为final，则类型检查器的行为也不会有所不同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这是我们建议使用<strong>类型</strong>字段的原因之一。使用时<code>def</code>由于类型推断，对于局部变量来说是完全可以的，对于字段来说，情况并非如此，字段也属于类的公共API，因此类型很重要。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_collection_literal_type_inference"><a class="anchor" href="#_collection_literal_type_inference"></a>集合文字类型推断</h5>
<div class="paragraph">
<p>Groovy提供了各种类型文字的语法。Groovy中有三种本机集合文字：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>列表，使用<code>[]</code>文字</p>
</li>
<li>
<p>地图，使用<code>[:]</code>文字</p>
</li>
<li>
<p>范围，使用<code>from..to</code> （包括）和<code>from..<to</code> （独家）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>文字的推断类型取决于文字的元素，如下表所示：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:40%">
<col style="width:60%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">文字</th>
<th class="tableblock halign-left valign-top">推断类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = []</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.List</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = ['foo','bar']</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.List<String></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = ["${foo}","${bar}"]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.List<GString></code>小心一点<code>GString</code> <strong>不是</strong> <code>String</code> ！</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = [:]</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.LinkedHashMap</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map1 = [someKey: 'someValue']
def map2 = ['someKey': 'someValue']</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.LinkedHashMap<String,String></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def map = ["${someKey}": 'someValue']</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>java.util.LinkedHashMap<GString,String></code>注意，关键是<code>GString</code> ！</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def intRange = (0..10)</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>groovy.lang.IntRange</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def charRange = ('a'..'z')</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>groovy.lang.Range<String></code> ：使用边界的类型推断范围的组件类型</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如您所见，除了<code>IntRange</code> ，则推断类型利用泛型类型来描述集合的内容。如果集合包含不同类型的元素，则类型检查器仍会执行组件的类型推断，但使用<a href="#section-lub">最小上限</a>的概念。</p>
</div>
</div>
<div class="sect4">
<h5 id="section-lub"><a class="anchor" href="#section-lub"></a>最小上限</h5>
<div class="paragraph">
<p>在Groovy中，两种类型的<em>最小上限</em> <code>A</code>和<code>B</code>被定义为以下类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>超类对应于的通用超类<code>A</code>和<code>B</code></p>
</li>
<li>
<p>接口对应于两者实现的接口<code>A</code>和<code>B</code></p>
</li>
<li>
<p>如果<code>A</code>要么<code>B</code>是原始类型，并且<code>A</code>不等于<code>B</code> ，最小上限<code>A</code>和<code>B</code>是其包装器类型的最小上限</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果<code>A</code>和<code>B</code>只有一个（1）通用接口，并且它们的通用超类是<code>Object</code> ，那么两者的LUB就是通用接口。</p>
</div>
<div class="paragraph">
<p>最小上限代表两者的最小类型<code>A</code>和<code>B</code>可以分配。例如，如果<code>A</code>和<code>B</code>都是<code>String</code> ，则两者的LUB（最小上限）也为<code>String</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Top {}
class Bottom1 extends Top {}
class Bottom2 extends Top {}

assert leastUpperBound(String, String) == String                    <i class="conum" data-value="1"></i><b>(1)</b>
assert leastUpperBound(ArrayList, LinkedList) == AbstractList       <i class="conum" data-value="2"></i><b>(2)</b>
assert leastUpperBound(ArrayList, List) == List                     <i class="conum" data-value="3"></i><b>(3)</b>
assert leastUpperBound(List, List) == List                          <i class="conum" data-value="4"></i><b>(4)</b>
assert leastUpperBound(Bottom1, Bottom2) == Top                     <i class="conum" data-value="5"></i><b>(5)</b>
assert leastUpperBound(List, Serializable) == Object                <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的LUB <code>String</code>和<code>String</code>是<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的LUB <code>ArrayList</code>和<code>LinkedList</code>是他们常见的超级类型<code>AbstractList</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的LUB <code>ArrayList</code>和<code>List</code>是他们唯一的通用界面，<code>List</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>两个相同接口的LUB是接口本身</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>的LUB <code>Bottom1</code>和<code>Bottom2</code>是他们的超类<code>Top</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>两种没有共同点的LUB是<code>Object</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这些示例中，LUB始终可以表示为受JVM支持的普通类型。但是Groovy在内部将LUB表示为可能更复杂的类型，例如，您将无法使用它来定义变量。为了说明这一点，让我们继续下面的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Foo {}
class Top {}
class Bottom extends Top implements Serializable, Foo {}
class SerializableFooImpl implements Serializable, Foo {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的最小上限是多少<code>Bottom</code>和<code>SerializableFooImpl</code> ？他们没有共同的超级阶级（除了<code>Object</code> ），但它们确实共享2个接口（ <code>Serializable</code>和<code>Foo</code> ），因此它们的最小上限是代表两个接口（ <code>Serializable</code>和<code>Foo</code> ）。无法在源代码中定义此类型，但是Groovy知道它。</p>
</div>
<div class="paragraph">
<p>在集合类型推断（通常是泛型类型推断）的上下文中，这变得很方便，因为将组件的类型推断为最小上限。在下面的示例中，我们可以说明为什么这很重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter { void greet() }                  <i class="conum" data-value="1"></i><b>(1)</b>
interface Salute { void salute() }                  <i class="conum" data-value="2"></i><b>(2)</b>

class A implements Greeter, Salute {                <i class="conum" data-value="3"></i><b>(3)</b>
    void greet() { println "Hello, I'm A!" }
    void salute() { println "Bye from A!" }
}
class B implements Greeter, Salute {                <i class="conum" data-value="4"></i><b>(4)</b>
    void greet() { println "Hello, I'm B!" }
    void salute() { println "Bye from B!" }
    void exit() { println 'No way!' }               <i class="conum" data-value="5"></i><b>(5)</b>
}
def list = [new A(), new B()]                       <i class="conum" data-value="6"></i><b>(6)</b>
list.each {
    it.greet()                                      <i class="conum" data-value="7"></i><b>(7)</b>
    it.salute()                                     <i class="conum" data-value="8"></i><b>(8)</b>
    it.exit()                                       <i class="conum" data-value="9"></i><b>(9)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Greeter</code>接口定义单个方法，<code>greet</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>Salute</code>接口定义单个方法，<code>salute</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类<code>A</code>同时实现<code>Greeter</code>和<code>Salute</code>但没有显式接口可以扩展两者</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>一样<code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>但<code>B</code>定义一个额外的<code>exit</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>的类型<code>list</code>被推断为“ <code>A</code>和“ B””</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>所以可以打电话<code>greet</code>两者都定义了<code>A</code>和<code>B</code>通过<code>Greeter</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i> <b>8</b></td>
<td>可以打电话<code>salute</code>两者都定义了<code>A</code>和<code>B</code>通过<code>Salute</code>接口</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i> <b>9</b></td>
<td>尚未致电<code>exit</code>是编译时错误，因为它不属于的LUB <code>A</code>和<code>B</code> （仅在<code>B</code> ）</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>错误消息如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - Cannot find matching method Greeter or Salute#exit()</pre>
</div>
</div>
<div class="paragraph">
<p>这表明<code>exit</code>方法都没有定义<code>Greeter</code>也不<code>Salute</code> ，这是在的最小上限中定义的两个接口<code>A</code>和<code>B</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_instanceof_inference"><a class="anchor" href="#_instanceof_inference"></a>推理实例</h5>
<div class="paragraph">
<p>在常规的非类型检查的Groovy中，您可以编写如下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Greeter {
    String greeting() { 'Hello' }
}

void doSomething(def o) {
    if (o instanceof Greeter) {     <i class="conum" data-value="1"></i><b>(1)</b>
        println o.greeting()        <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

doSomething(new Greeter())</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个来保护方法调用<code>instanceof</code>校验</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打电话</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该方法调用之所以有效是因为动态调度（在运行时选择了该方法）。Java中的等效代码将需要强制转换<code>o</code>到一个<code>Greeter</code>在致电之前<code>greeting</code>方法，因为方法是在编译时选择的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (o instanceof Greeter) {
    System.out.println(((Greeter)o).greeting());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，在Groovy中，即使您添加<code>@TypeChecked</code> （并因此激活类型检查） <code>doSomething</code>方法， <strong>不需要</strong>强制转换。编译器会嵌入<em>instanceof</em>推断，从而使强制类型转换成为可选内容。</p>
</div>
</div>
<div class="sect4">
<h5 id="section-flow-typing"><a class="anchor" href="#section-flow-typing"></a>流式</h5>
<div class="paragraph">
<p>流类型是类型检查模式下Groovy的重要概念，也是类型推断的扩展。这个想法是，编译器能够推断代码流中的变量类型，而不仅仅是在初始化时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTyping() {
    def o = 'foo'                       <i class="conum" data-value="1"></i><b>(1)</b>
    o = o.toUpperCase()                 <i class="conum" data-value="2"></i><b>(2)</b>
    o = 9d                              <i class="conum" data-value="3"></i><b>(3)</b>
    o = Math.sqrt(o)                    <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>第一， <code>o</code>使用声明<code>def</code>并分配了一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>编译器推断出<code>o</code>是一个<code>String</code> ，所以打电话<code>toUpperCase</code>被允许</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>o</code>被重新分配了<code>double</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>呼唤<code>Math.sqrt</code>通过编译，因为编译器知道这一点， <code>o</code>是一个<code>double</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，类型检查器<em>意识到</em>以下事实：变量的具体类型随时间而变化。特别是，如果您将最后一个分配替换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">o = 9d
o = o.toUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，类型检查器将在编译时失败，因为它知道<code>o</code>是一个<code>double</code>什么时候<code>toUpperCase</code>被调用，所以是类型错误。</p>
</div>
<div class="paragraph">
<p>重要的是要了解，使用<code>def</code>触发类型推断。流类型适用于任何类型的<strong>任何</strong>变量。声明具有显式类型的变量只会限制您可以分配给变量的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           <i class="conum" data-value="1"></i><b>(1)</b>
    list = list*.toUpperCase()          <i class="conum" data-value="2"></i><b>(2)</b>
    list = 'foo'                        <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>list</code>被声明为未选中<code>List</code>并分配了一个String的列表文字</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该行由于流类型而通过编译：类型检查器知道<code>list</code>在这一点上是<code>List<String></code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>但您不能分配一个<code>String</code>到一个<code>List</code>所以这是一个类型检查错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以注意到，即使声明的变量<strong>没有</strong>泛型信息，类型检查器也知道什么是组件类型。因此，这样的代码将使编译失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           <i class="conum" data-value="1"></i><b>(1)</b>
    list.add(1)                         <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>list</code>推断为<code>List<String></code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>所以添加一个<code>int</code>到一个<code>List<String></code>是编译时错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要解决此问题，需要在声明中添加一个显式的泛型类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List&lt;? extends Serializable&gt; list = []                      <i class="conum" data-value="1"></i><b>(1)</b>
    list.addAll(['a','b','c'])                                  <i class="conum" data-value="2"></i><b>(2)</b>
    list.add(1)                                                 <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>list</code>声明为<code>List<? extends Serializable></code>并初始化为空列表</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加到列表中的元素符合列表的声明类型</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>所以添加一个<code>int</code>到一个<code>List<? extends Serializable></code>被允许</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>引入了流类型以减少经典和静态Groovy之间的语义差异。特别是，请考虑以下代码在Java中的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public Integer compute(String str) {
    return str.length();
}
public String compute(Object o) {
    return "Nope";
}
// ...
Object string = "Some string";          <i class="conum" data-value="1"></i><b>(1)</b>
Object result = compute(string);        <i class="conum" data-value="2"></i><b>(2)</b>
System.out.println(result);             <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>o</code>被声明为<code>Object</code>并分配了一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们称<code>compute</code>方法<code>o</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>并打印结果</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在Java中，此代码将输出<code>Nope</code> ，因为方法选择是在编译时基于<strong>声明的</strong>类型完成的。所以即使<code>o</code>是一个<code>String</code>在运行时，它仍然是<code>Object</code>被称为的版本，因为<code>o</code>被宣布为<code>Object</code> 。简而言之，在Java中，声明的类型最为重要，无论是变量类型，参数类型还是返回类型。</p>
</div>
<div class="paragraph">
<p>在Groovy中，我们可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int compute(String string) { string.length() }
String compute(Object o) { "Nope" }
Object o = 'string'
def result = compute(o)
println result</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是这次，它将返回<code>6</code> ，因为选择的方法是<strong>在运行时</strong>根据<em>实际</em>参数类型选择的。所以在运行时， <code>o</code>是一个<code>String</code>所以<code>String</code>使用变体。请注意，此行为与类型检查无关，它是Groovy通常的工作方式：动态调度。</p>
</div>
<div class="paragraph">
<p>在类型检查的Groovy中，我们要确保类型检查器<strong>在编译</strong>时选择运行时将选择的相同方法。由于语言的语义，通常这是不可能的，但是我们可以使用流类型来使事情变得更好。使用流输入<code>o</code> <em>推断</em>为<code>String</code>当。。。的时候<code>compute</code>方法会被调用，因此需要一个<code>String</code>并返回一个<code>int</code>被选中。这意味着我们可以推断该方法的返回类型为<code>int</code> ，而不是<code>String</code> 。这对于后续调用和类型安全很重要。</p>
</div>
<div class="paragraph">
<p>因此，在类型检查Groovy中，流类型是一个非常重要的概念，这也意味着<code>@TypeChecked</code>应用后，将根据<em>推断</em>的参数<em>类型</em>而不是声明的类型选择方法。这不能确保100％的类型安全，因为类型检查器<em>可能</em>选择了错误的方法，但是它确保了与动态Groovy最接近的语义。</p>
</div>
</div>
<div class="sect4">
<h5 id="_advanced_type_inference"><a class="anchor" href="#_advanced_type_inference"></a>高级类型推断</h5>
<div class="paragraph">
<p><a href="#section-flow-typing">流类型</a>和<a href="#section-lub">最小上限推断</a>的组合用于执行高级类型推断，并在多种情况下确保类型安全。特别地，程序控制结构可能会更改变量的推断类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o
if (someCondition) {
    o = new Top()                               <i class="conum" data-value="1"></i><b>(1)</b>
} else {
    o = new Bottom()                            <i class="conum" data-value="2"></i><b>(2)</b>
}
o.methodFromTop()                               <i class="conum" data-value="3"></i><b>(3)</b>
o.methodFromBottom()  // compilation error      <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果<code>someCondition</code>是真的， <code>o</code>被分配了一个<code>Top</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>如果<code>someCondition</code>是假的<code>o</code>被分配了一个<code>Bottom</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>呼唤<code>methodFromTop</code>是安全的</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>但是打电话<code>methodFromBottom</code>不是，所以是编译时错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当类型检查器访问<code>if/else</code>控制结构，它检查所有在<code>if/else</code>分支并计算所有分配的<a href="#section-lub">最小上限</a> 。此类型是在<code>if/else</code>块，所以在此示例中， <code>o</code>被分配了一个<code>Top</code>在里面<code>if</code>分支和一个<code>Bottom</code>在里面<code>else</code>科。这些的<a href="#section-lub">LUB</a>是<code>Top</code> ，因此在条件分支之后，编译器会推断<code>o</code>作为一个<code>Top</code> 。呼唤<code>methodFromTop</code>因此将被允许，但不允许<code>methodFromBottom</code> 。</p>
</div>
<div class="paragraph">
<p>对于闭包，尤其是闭包共享变量，存在相同的推理。闭包共享变量是在闭包外部定义但在闭包内部使用的变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def text = 'Hello, world!'                          <i class="conum" data-value="1"></i><b>(1)</b>
def closure = {
    println text                                    <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个名为<code>text</code>被宣布</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>text</code>从封闭内部使用。这是一个<em>闭包共享变量</em> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Groovy允许开发人员使用这些变量而不要求它们是最终变量。这意味着可以在闭包内部重新分配闭包共享变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String result
doSomething { String it -&gt;
    result = "Result: $it"
}
result = result?.toUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>的问题是，一个封闭的是，可以在<strong>任意</strong>时刻执行（或不）代码的独立块。特别是， <code>doSomething</code>例如，可以是异步的。这意味着闭包的主体不属于主控制流。因此，类型检查器还会为每个闭包共享变量计算该变量所有赋值的<a href="#section-lub">LUB</a> ，并将使用该变量<code>LUB</code>作为闭包范围之外的推断类型，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o = new Top()                               <i class="conum" data-value="1"></i><b>(1)</b>
Thread.start {
    o = new Bottom()                            <i class="conum" data-value="2"></i><b>(2)</b>
}
o.methodFromTop()                               <i class="conum" data-value="3"></i><b>(3)</b>
o.methodFromBottom()  // compilation error      <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>首先为闭包共享变量分配一个<code>Top</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在封闭内，它被分配了一个<code>Bottom</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>methodFromTop</code>被允许</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>methodFromBottom</code>是编译错误</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这里，很明显<code>methodFromBottom</code>在编译时或运行时，不能保证调用的类型<code>o</code>将<em>有效</em>地成为<code>Bottom</code> 。可能会有，但是我们不能确定，因为它是异步的。因此，类型检查器将仅允许在<a href="#section-lub">最小上限处</a>调用，这是一个<code>Top</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_closures_and_type_inference"><a class="anchor" href="#_closures_and_type_inference"></a> 6.2.6。闭包和类型推断</h4>
<div class="paragraph">
<p>类型检查器对闭包执行特殊的推断，从而在一侧进行附加检查并在另一侧提高了流畅性。</p>
</div>
<div class="sect4">
<h5 id="_return_type_inference"><a class="anchor" href="#_return_type_inference"></a>返回类型推断</h5>
<div class="paragraph">
<p>类型检查器能够做的第一件事是推断闭包的<em>返回类型</em> 。在下面的示例中对此进行了简单说明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
int testClosureReturnTypeInference(String arg) {
    def cl = { "Arg: $arg" }                                <i class="conum" data-value="1"></i><b>(1)</b>
    def val = cl()                                          <i class="conum" data-value="2"></i><b>(2)</b>

    val.length()                                            <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义了一个闭包，它返回一个字符串（更确切地说， <code>GString</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们调用闭包并将结果分配给变量</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类型检查器推断闭包将返回一个字符串，因此调用<code>length()</code>被允许</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如您所见，与显式声明其返回类型的方法不同，无需声明闭包的返回类型：它的类型是从闭包的主体中推断出来的。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">闭包与方法</div>
<div class="paragraph">
<p>值得注意的是，返回类型推断仅适用于闭包。尽管类型检查器可以对方法执行相同操作，但实际上并不可取： <em>通常</em> ，方法可以被覆盖，并且在静态上不可能确保所调用的方法不是覆盖的版本。因此，流类型实际上会认为方法会返回某些内容，而实际上，它可能会返回其他内容，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TypeChecked
class A {
    def compute() { 'some string' }             <i class="conum" data-value="1"></i><b>(1)</b>
    def computeFully() {
        compute().toUpperCase()                 <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
@TypeChecked
class B extends A {
    def compute() { 123 }                       <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类<code>A</code>定义方法<code>compute</code>有效地返回一个<code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>这将导致编译失败，因为返回类型为<code>compute</code>是<code>def</code> （又名<code>Object</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>类<code>B</code>延伸<code>A</code>和重新定义<code>compute</code> ，此类型返回一个<code>int</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如您所见，如果类型检查器依赖于方法的推断返回类型（使用<a href="#section-flow-typing">流类型）</a> ，则类型检查器可以确定可以调用<code>toUpperCase</code> 。实际上这是一个<strong>错误</strong> ，因为子类可以覆盖<code>compute</code>并返回另一个对象。这里， <code>B#compute</code>返回一个<code>int</code> ，所以有人打电话<code>computeFully</code>在...的实例上<code>B</code>会看到运行时错误。编译器通过使用方法的声明的返回类型而不是推断的返回类型来防止这种情况的发生。</p>
</div>
<div class="paragraph">
<p>为了保持一致， <strong>每种</strong>方法的行为都是相同的，即使它们是静态的或最终的也是如此。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_parameter_type_inference"><a class="anchor" href="#_parameter_type_inference"></a>参数类型推断</h5>
<div class="paragraph">
<p>除了返回类型外，闭包还可以从上下文中推断出其参数类型。编译器可以通过两种方式推断参数类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过<em>隐式SAM类型强制</em></p>
</li>
<li>
<p>通过API元数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了说明这一点，让我们从一个由于类型检查器无法推断参数类型而使编译失败的示例开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
    int age
}

void inviteIf(Person p, Closure&lt;Boolean&gt; predicate) {           <i class="conum" data-value="1"></i><b>(1)</b>
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void failCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)
    inviteIf(p) {                                               <i class="conum" data-value="2"></i><b>(2)</b>
        it.age &gt;= 18 // No such property: age                   <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>inviteIf</code>方法接受<code>Person</code>和一个<code>Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们称它为<code>Person</code>和一个<code>Closure</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然而<code>it</code>不是静态地称为<code>Person</code>编译失败</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在此示例中，封闭体包含<code>it.age</code> 。使用动态的而不是类型检查的代码，这将起作用，因为<code>it</code>将是一个<code>Person</code>在运行时。不幸的是，在编译时，无法知道什么类型的<code>it</code> ，只需阅读<code>inviteIf</code> 。</p>
</div>
<div class="sect5">
<h6 id="_explicit_closure_parameters"><a class="anchor" href="#_explicit_closure_parameters"></a>显式关闭参数</h6>
<div class="paragraph">
<p>简而言之，类型检查器没有足够的上下文信息<code>inviteIf</code>静态确定类型的方法<code>it</code> 。这意味着方法调用需要这样重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">inviteIf(p) { Person it -&gt;                                  <i class="conum" data-value="1"></i><b>(1)</b>
    it.age &gt;= 18
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的类型<code>it</code>需要明确声明</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过明确声明<code>it</code>变量，则可以解决该问题并使此代码静态检查。</p>
</div>
</div>
<div class="sect5">
<h6 id="_parameters_inferred_from_single_abstract_method_types"><a class="anchor" href="#_parameters_inferred_from_single_abstract_method_types"></a>从单抽象方法类型推断出的参数</h6>
<div class="paragraph">
<p>对于API或框架设计人员而言，有两种方法可以使用户感到更加优雅，从而使他们不必为闭包参数声明显式类型。第一个也是最简单的方法是用SAM类型替换闭包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Predicate&lt;On&gt; { boolean apply(On e) }                 <i class="conum" data-value="1"></i><b>(1)</b>

void inviteIf(Person p, Predicate&lt;Person&gt; predicate) {          <i class="conum" data-value="2"></i><b>(2)</b>
    if (predicate.apply(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void passesCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)

    inviteIf(p) {                                               <i class="conum" data-value="3"></i><b>(3)</b>
        it.age &gt;= 18                                            <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一个<code>SAM</code>与<code>apply</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>inviteIf</code>现在使用<code>Predicate<Person></code>代替<code>Closure<Boolean></code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>无需声明其类型<code>it</code>变了</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>it.age</code>编译正确，类型<code>it</code>从<code>Predicate#apply</code>方法签名</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">通过使用此技术，我们利用了对Groovy的<em>SAM类型</em>功能<em>自动关闭的强制</em> 。是否应使用<em>SAM类型</em>还是<em>闭包的问题</em>实际上取决于您需要执行的操作。在许多情况下，使用SAM接口就足够了，尤其是考虑到Java 8中的功能接口时。但是，闭包提供了功能接口无法访问的功能。特别是，闭包可以具有委托和所有者，并且可以在被调用之前作为对象（例如克隆，序列化，咖喱等）进行操作。它们还可以支持多个签名（多态性）。因此，如果您需要这种操作，最好切换到最高级的类型推断注释，如下所述。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>关于闭包参数类型推断（即<em>无需</em>确定地声明它们<em>而</em>静态地确定闭包的参数类型）时，需要解决的原始问题是Groovy类型系统继承了Java类型。系统，不足以描述参数的类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="_the_code_closureparams_code_annotation"><a class="anchor" href="#_the_code_closureparams_code_annotation"></a>的<code>@ClosureParams</code>注解</h6>
<div class="paragraph">
<p>Groovy提供了一个注释， <code>@ClosureParams</code>旨在完成类型信息。此注释主要针对希望通过提供类型推断元数据来扩展类型检查器功能的框架和API开发人员。如果您的库使用了闭包，并且您也想要最大程度的工具支持，那么这一点很重要。</p>
</div>
<div class="paragraph">
<p>让我们通过固定原始示例来说明这一点，并介绍<code>@ClosureParams</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.ClosureParams
import groovy.transform.stc.FirstParam
void inviteIf(Person p, @ClosureParams(FirstParam) Closure&lt;Boolean&gt; predicate) {        <i class="conum" data-value="1"></i><b>(1)</b>
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}
inviteIf(p) {                                                                       <i class="conum" data-value="2"></i><b>(2)</b>
    it.age &gt;= 18
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>闭包参数用<code>@ClosureParams</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>不必使用显式类型<code>it</code> ，据推测</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>@ClosureParams</code>注记最少接受一个参数，该参数称为<em>类型hint</em> 。类型提示是一个类，它负责在编译时为闭包完成类型信息。在此示例中，使用的类型提示是<code>groovy.transform.stc.FirstParam</code>它向类型检查器指示闭包将接受一个参数，该参数的类型是方法的第一个参数的类型。在这种情况下，方法的第一个参数是<code>Person</code> ，因此它向类型检查器指示闭包的第一个参数实际上是a <code>Person</code> 。</p>
</div>
<div class="paragraph">
<p>第二个可选参数名为<em>options</em> 。它的语义取决于<em>类型提示</em>类。Groovy带有各种捆绑的类型提示，如下表所示：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表2。预定义类型提示</caption>
<colgroup>
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:66.6668%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型提示</th>
<th class="tableblock halign-left valign-top">多态的？</th>
<th class="tableblock halign-left valign-top">说明和示例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FirstParam</code><br>
<code>SecondParam</code><br>
<code>ThirdParam</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法的第一个（分别为第二个，第三个）参数类型<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FirstParam
void doSomething(String str, @ClosureParams(FirstParam) Closure c) {
    c(str)
}
doSomething('foo') { println it.toUpperCase() }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.SecondParam
void withHash(String str, int seed, @ClosureParams(SecondParam) Closure c) {
    c(31*str.hashCode()+seed)
}
withHash('foo', (int)System.currentTimeMillis()) {
    int mod = it%2
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.ThirdParam
String format(String prefix, String postfix, String o, @ClosureParams(ThirdParam) Closure c) {
    "$prefix${c(o)}$postfix"
}
assert format('foo', 'bar', 'baz') {
    it.toUpperCase()
} == 'fooBAZbar'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FirstParam.FirstGenericType</code><br>
<code>SecondParam.FirstGenericType</code><br>
<code>ThirdParam.FirstGenericType</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法的第一个（分别是第二个，第三个）参数的第一个通用类型<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FirstParam
public &lt;T&gt; void doSomething(List&lt;T&gt; strings, @ClosureParams(FirstParam.FirstGenericType) Closure c) {
    strings.each {
        c(it)
    }
}
doSomething(['foo','bar']) { println it.toUpperCase() }
doSomething([1,2,3]) { println(2*it) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>的变体<code>SecondGenericType</code>和<code>ThirdGenericType</code>为所有人而存在<code>FirstParam</code> ， <code>SecondParam</code>和<code>ThirdParam</code>输入提示。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>SimpleType</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型提示，其关闭参数的类型来自options字符串。<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.SimpleType
public void doSomething(@ClosureParams(value=SimpleType,options=['java.lang.String','int']) Closure c) {
    c('foo',3)
}
doSomething { str, len -&gt;
    assert str.length() == len
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此类型提示支持<strong>单个</strong>签名，并且使用完全限定的类型名称或原始类型将每个参数指定为<em>options</em>数组的值。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>MapEntryOrKeyValue</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>闭包的专用类型提示<code>Map.Entry</code>单个参数，或与键和值相对应的两个参数。<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.MapEntryOrKeyValue
public &lt;K,V&gt; void doSomething(Map&lt;K,V&gt; map, @ClosureParams(MapEntryOrKeyValue) Closure c) {
    // ...
}
doSomething([a: 'A']) { k,v -&gt;
    assert k.toUpperCase() == v.toUpperCase()
}
doSomething([abc: 3]) { e -&gt;
    assert e.key.length() == e.value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此类型提示<strong>要求</strong>第一个参数是<code>Map</code>类型，并根据地图实际键/值类型推断闭包参数类型。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FromAbstractTypeMethods</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>从某种类型的抽象方法推断闭包参数类型。为<strong>每个</strong>抽象方法推断出一个签名。<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromAbstractTypeMethods
abstract class Foo {
    abstract void firstSignature(int x, int y)
    abstract void secondSignature(String str)
}
void doSomething(@ClosureParams(value=FromAbstractTypeMethods, options=["Foo"]) Closure cl) {
    // ...
}
doSomething { a, b -&gt; a+b }
doSomething { s -&gt; s.toUpperCase() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果像上面的示例中那样有多个签名，则类型检查器将<strong>仅</strong>在每种方法的不同性时才能推断参数的类型。在上面的示例中， <code>firstSignature</code>接受两个参数， <code>secondSignature</code>接受1个参数，因此类型检查器可以根据参数数量来推断参数类型。但是请参阅下面讨论的可选的resolver class属性。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>FromString</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>从<code>options</code>论点。的<code>options</code>参数由逗号分隔的非基本类型数组组成。数组的每个元素对应一个签名，元素中的每个逗号分隔签名的参数。简而言之，这是最通用的类型提示， <code>options</code>映射被<strong>解析</strong>为好像它是签名文字。尽管类型提示非常强大，但是如果可以的话，必须避免使用该类型提示，因为由于必须解析类型签名，它会增加编译时间。</p>
</div>
<div class="paragraph">
<p>闭包接受单个签名<code>String</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromString
void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {
    // ...
}
doSomething { s -&gt; s.toUpperCase() }
doSomething { s,i -&gt; s.toUpperCase()*i }</code></pre>
</div>
</div>
<div class="paragraph">
<p>多态闭包，接受一个<code>String</code>或一个<code>String, Integer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromString
void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {
    // ...
}
doSomething { s -&gt; s.toUpperCase() }
doSomething { s,i -&gt; s.toUpperCase()*i }</code></pre>
</div>
</div>
<div class="paragraph">
<p>多态闭包，接受一个<code>T</code>或一对<code>T,T</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.stc.FromString
public &lt;T&gt; void doSomething(T e, @ClosureParams(value=FromString, options=["T","T,T"]) Closure cl) {
    // ...
}
doSomething('foo') { s -&gt; s.toUpperCase() }
doSomething('foo') { s1,s2 -&gt; assert s1.toUpperCase() == s2.toUpperCase() }</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">即使您使用<code>FirstParam</code> ， <code>SecondParam</code>要么<code>ThirdParam</code>作为一种类型的提示，它并不严格意味着其将被传递到闭合的参数<strong>将</strong>是第一个（相应的第二，第三）的方法调用的参数。这仅意味着闭包的参数<strong>类型</strong>将与方法调用的第一个（分别是第二个，第三个）参数的类型<strong>相同</strong> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>简而言之，缺乏<code>@ClosureParams</code>接受方法的注释<code>Closure</code> <strong>不会</strong>失败的编译。如果存在（类型可以同时存在于Java源代码和Groovy源代码中），那么类型检查器将具有<strong>更多</strong>信息并可以执行其他类型推断。这使得此功能对于框架开发人员特别有趣。</p>
</div>
<div class="paragraph">
<p>第三个可选参数名为<em>冲突解决方案策略</em> 。它可以引用一个类（从<code>ClosureSignatureConflictResolver</code> ），如果在初始推断计算完成后发现多个参数类型，则可以执行其他类型的参数解析。Groovy带有一个默认的类型解析器，该解析器不执行任何操作，而另一个则在找到多个签名时选择第一个签名。仅当找到多个签名且解析器设计为后处理器时，才调用解析器。任何需要注入类型信息的语句都必须传递通过类型提示确定的参数签名之一。然后，解析器从返回的候选签名中进行选择。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_code_delegatesto_code"><a class="anchor" href="#_code_delegatesto_code"></a><code>@DelegatesTo</code></h5>
<div class="paragraph">
<p>的<code>@DelegatesTo</code>类型检查器使用批注来推断委托的类型。它允许API设计人员指示编译器什么是委托类型和委托策略。的<code>@DelegatesTo</code>注释将在<a href="core-domain-specific-languages.html#section-delegatesto">特定的章节中</a>讨论。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_static_compilation"><a class="anchor" href="#_static_compilation"></a> 6.3。静态编译</h3>
<div class="sect3">
<h4 id="_dynamic_vs_static"><a class="anchor" href="#_dynamic_vs_static"></a> 6.3.1。动态与静态</h4>
<div class="paragraph">
<p>在<a href="#static-type-checking">类型检查部分</a> ，我们已经看到Groovy提供了可选的类型检查，这要归功于<code>@TypeChecked</code>注解。类型检查器在编译时运行，并对动态代码执行静态分析。无论是否启用类型检查，程序的行为都将完全相同。这意味着<code>@TypeChecked</code>对于程序的语义，注释是中性的。尽管可能有必要在源中添加类型信息，以使程序被认为是类型安全的，但最后，程序的语义是相同的。</p>
</div>
<div class="paragraph">
<p>尽管这听起来不错，但实际上存在一个问题：在编译时进行的动态代码的类型检查在定义上仅在没有运行时特定行为发生时才是正确的。例如，以下程序通过类型检查：</p>
</div>
<div id="typechecked-defeated" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.TypeChecked
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那里有两个<code>compute</code>方法。一个接受<code>String</code>并返回一个<code>int</code> ，另一个接受<code>int</code>并返回一个<code>String</code> 。如果您对此进行编译，则认为它是类型安全的： <code>compute('foobar')</code>通话会传回<code>int</code> ，并致电<code>compute</code>在这个<code>int</code>反过来会返回一个<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>现在，在致电之前<code>test()</code> ，请考虑添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Computer.metaClass.compute = { String str -&gt; new Date() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用运行时元编程，我们实际上是在修改<code>compute(String)</code>方法，这样就不会返回提供的参数的长度，而是会返回一个<code>Date</code> 。如果执行该程序，它将在运行时失败。由于可以从任何地方的任何线程中添加此行，因此类型检查器绝对无法静态地确保不会发生这种情况。简而言之，类型检查器容易受到猴子补丁的攻击。这只是一个示例，但这说明了这样一个概念，即对动态程序进行静态分析本质上是错误的。</p>
</div>
<div class="paragraph">
<p>Groovy语言为<code>@TypeChecked</code>这实际上将确保推断为被调用的方法<strong>将</strong>在运行时有效地被调用。此注释将Groovy编译器转换为<strong>静态编译器</strong> ，在该<strong>静态编译器中</strong> ，所有方法调用都在编译时解析， <strong>并且</strong>生成的字节码确保了这种情况的发生：注释为<code>@groovy.transform.CompileStatic</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="compilestatic-annotation"><a class="anchor" href="#compilestatic-annotation"></a> 6.3.2。的<code>@CompileStatic</code>注解</h4>
<div class="paragraph">
<p>的<code>@CompileStatic</code>注释可以添加到<code>@TypeChecked</code>可以使用注解，即在类或方法上。不必同时添加两者<code>@TypeChecked</code>和<code>@CompileStatic</code> ，作为<code>@CompileStatic</code>执行一切<code>@TypeChecked</code>可以，但是还会触发静态编译。</p>
</div>
<div class="paragraph">
<p>让我们以<a href="#typechecked-defeated">失败</a>的<a href="#typechecked-defeated">示例为例</a> ，但是这次我们替换<code>@TypeChecked</code>带有注释<code>@CompileStatic</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.CompileStatic
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}
Computer.metaClass.compute = { String str -&gt; new Date() }
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是<strong>唯一的</strong>区别。如果我们执行此程序，这次将没有运行时错误。的<code>test</code>该方法不受猴子修补的影响，因为<code>compute</code>在其主体中调用的方法在编译时链接，因此即使<code>Computer</code>更改后，程序仍会<strong>按照类型检查器的预期运行</strong> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_key_benefits"><a class="anchor" href="#_key_benefits"></a> 6.3.3。主要好处</h4>
<div class="paragraph">
<p>使用有几个好处<code>@CompileStatic</code>在您的代码上：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型安全</p>
</li>
<li>
<p>对<a href="#compilestatic-annotation">猴子修补</a>免疫</p>
</li>
<li>
<p>性能提升</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>性能的提高取决于您正在执行的程序的类型。如果它受I / O约束，则静态编译代码和动态代码之间的区别几乎不会引起注意。在占用大量CPU的代码上，由于生成的字节码与Java为等效程序生成的字节码非常接近（如果不相等），因此性能得到了极大的提高。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用Groovy的<em>invokedynamic</em>版本（使用JDK 7及更高版本的人员可以访问），动态代码的性能应该与静态编译代码的性能非常接近。有时，它甚至可以更快！只有一种方法可以确定应该选择哪个版本：测量。原因是，根据您的程序<strong>和</strong>所使用的JVM，性能可能会显着不同。尤其是Groovy的<em>invokedynamic</em>版本对使用中的JVM版本非常敏感。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_checking_extensions"><a class="anchor" href="#_type_checking_extensions"></a> 7。类型检查扩展</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_writing_a_type_checking_extension"><a class="anchor" href="#_writing_a_type_checking_extension"></a> 7.1。编写类型检查扩展</h3>
<div class="sect3">
<h4 id="_towards_a_smarter_type_checker"><a class="anchor" href="#_towards_a_smarter_type_checker"></a> 7.1.1。迈向更智能的类型检查器</h4>
<div class="paragraph">
<p>尽管是动态语言，但是Groovy可以在编译时与静态类型检查器一起使用， <a href="#static-type-checking">并</a>使用<a href="#static-type-checking">@TypeChecked</a>批注启用。在这种模式下，编译器变得更加冗长，并为例如错别字，不存在的方法等引发错误，但是……这有一些局限性，其中大多数来自Groovy本质上仍然是动态语言的事实。例如，您将无法对使用标记生成器的代码使用类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def builder = new MarkupBuilder(out)
builder.html {
    head {
        // ...
    }
    body {
        p 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上一个示例中， <code>html</code> ， <code>head</code> ， <code>body</code>要么<code>p</code>方法存在。但是，如果执行代码，则它会起作用，因为Groovy使用动态调度并在运行时转换这些方法调用。在此构建器中，您可以使用的标记数量或属性没有限制，这意味着类型检查器没有机会在编译时了解所有可能的方法（标记），除非您创建了构建器例如专用于HTML。</p>
</div>
<div class="paragraph">
<p>Groovy是实现内部DSL的首选平台。灵活的语法以及运行时和编译时元编程功能使Groovy成为一个有趣的选择，因为它使程序员可以专注于DSL而不是工具或实现。由于Groovy DSL是Groovy代码，因此无需编写专用插件即可轻松获得IDE支持。</p>
</div>
<div class="paragraph">
<p>在很多情况下，DSL引擎是用Groovy（或Java）编写的，然后用户代码作为脚本执行，这意味着您在用户逻辑之上拥有某种包装器。包装器可以包括例如<code>GroovyShell</code>要么<code>GroovyScriptEngine</code>在运行脚本之前透明地执行一些任务（添加导入，应用AST转换，扩展基本脚本等）。通常，用户编写的脚本无需测试即可投入生产，因为DSL逻辑可能会<strong>导致任何</strong>用户都可以使用DSL语法编写代码。最后，用户可能只是忽略了他所写的实际上是<strong>代码</strong> 。这给DSL实现者带来了一些挑战，例如确保用户代码的执行安全，或者在这种情况下，早期报告错误。</p>
</div>
<div class="paragraph">
<p>例如，假设有一个DSL，其目标是远程驱动火星上的流动站。向流动站发送消息大约需要15分钟。如果流动站执行脚本并失败并显示错误（例如错字），则您有两个问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，仅在30分钟（流动站获取脚本所需的时间和接收错误所需的时间）之后才提供反馈</p>
</li>
<li>
<p>其次，脚本的某些部分已执行，您可能必须对固定脚本进行重大更改（这意味着您需要了解流动站的当前状态…）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类型检查扩展是一种机制，它允许DSL引擎的开发人员通过对常规groovy类应用静态类型检查所允许的相同类型的检查，从而使这些脚本更安全。</p>
</div>
<div class="paragraph">
<p>这里的原则是尽早失败，也就是说尽快使脚本编译失败，并在可能的情况下向用户提供反馈（包括良好的错误消息）。</p>
</div>
<div class="paragraph">
<p>简而言之，类型检查扩展背后的想法是使编译器了解DSL使用的所有运行时元编程技巧，以便脚本可以像冗长的静态编译代码一样受益于相同的编译时检查级别。我们将看到，您可以通过执行普通类型检查器不会执行的检查来进一步发展，为用户提供强大的编译时检查。</p>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Howdoesitwork"><a class="anchor" href="#Typecheckingextensions-Howdoesitwork"></a> 7.1.2。扩展属性</h4>
<div class="paragraph">
<p>的<code>@TypeChecked</code>注释支持名为的属性<code>extensions</code> 。此参数采用与<em>类型检查扩展脚本</em>列表相对应的字符串数组。这些脚本是在<strong>编译时</strong>在classpath上找到的。例如，您将编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TypeChecked(extensions='/path/to/myextension.groovy')
void foo() { ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，将使用正常类型检查器的规则对<em>foo</em>方法进行类型检查，这些规则由<em>myextension.groovy</em>脚本中找到的规则完成。请注意，虽然内部类型检查器支持多种机制来实现类型检查扩展（包括普通的旧Java代码），但建议的方法是使用那些类型检查扩展脚本。</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_dsl_for_type_checking"><a class="anchor" href="#_a_dsl_for_type_checking"></a> 7.1.3。DSL用于类型检查</h4>
<div class="paragraph">
<p>类型检查扩展背后的想法是使用DSL扩展类型检查器功能。通过此DSL，您可以使用“事件驱动” API进入编译过程，尤其是类型检查阶段。例如，当类型检查器进入方法主体时，它将引发<em>beforeVisitMethod</em>事件，扩展可<em>对此</em>作出反应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitMethod { methodNode -&gt;
 println "Entering ${methodNode.name}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>想象一下，您手边有流动站DSL。用户会写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">robot.move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您具有这样定义的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Robot {
    Robot move(int qt) { this }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在执行以下脚本之前，可以对脚本进行类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(TypeChecked)            <i class="conum" data-value="1"></i><b>(1)</b>
)
def shell = new GroovyShell(config)                         <i class="conum" data-value="2"></i><b>(2)</b>
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)                                      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>编译器配置会添加<code>@TypeChecked</code>所有类的注释</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在<code>GroovyShell</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>这样，使用shell编译的脚本将使用<code>@TypeChecked</code>用户无需显式添加它</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用上面的编译器配置，我们可以透明地将<em>@TypeChecked</em>应用于脚本。在这种情况下，它将在编译时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - The variable [robot] is undeclared.</pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们将略微更新配置以包括``扩展''参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['robotextension.groovy'])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将以下内容添加到您的类路径中：</p>
</div>
<div class="listingblock">
<div class="title">机器人扩展</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedVariable { var -&gt;
    if ('robot'==var.name) {
        storeType(var, classNodeFor(Robot))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们告诉编译器，如果找到了一个<em>未解决的变量</em> ，并且该变量的名称是<em>robot</em> ，那么我们可以确保该变量的类型为<code>Robot</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-TheAPI"><a class="anchor" href="#Typecheckingextensions-TheAPI"></a> 7.1.4。类型检查扩展API</h4>
<div class="sect4">
<h5 id="Typecheckingextensions-AST"><a class="anchor" href="#Typecheckingextensions-AST"></a> AST</h5>
<div class="paragraph">
<p>类型检查API是处理抽象语法树的低级API。即使使用DSL不仅比处理纯Java或Groovy的AST代码要容易得多，您还必须非常了解AST才能开发扩展。</p>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Events"><a class="anchor" href="#Typecheckingextensions-Events"></a>大事记</h5>
<div class="paragraph">
<p>类型检查器发送以下事件，扩展脚本可以对此事件做出反应：</p>
</div>
<table id="event-setup" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>设定</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成初始化后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>没有</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">setup {
    // this is called before anything else
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可用于执行扩展程序的设置</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-finish" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>完</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成类型检查后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>没有</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">finish {
    // this is after completion
    // of all type checking
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型检查器完成工作后，可用于执行其他检查。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedVariable" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>未解决的变量</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器发现一个未解决的变量时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>VariableExpression var</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedVariable { var -&gt;
    if ('people' == var.name) {
        storeType(var, classNodeFor(List))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员通过用户注入的变量帮助类型检查器。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedProperty" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>未解决的属性</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器在接收方上找不到属性时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>PropertyExpression pexp</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedProperty { pexp -&gt;
    if ('longueur'==pexp.propertyAsString &amp;&amp;
        getType(pexp.objectExpression)==classNodeFor(String)) {
        storeType(pexp,classNodeFor(int))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员处理“动态”属性</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-unresolvedAttribute" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>unresolvedAttribute</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法在接收方上找到属性时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>AttributeExpression AEX</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">unresolvedAttribute { aex -&gt;
    if (getType(aex.objectExpression)==classNodeFor(String)) {
        storeType(aex,classNodeFor(String))
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许开发人员处理缺失的属性</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeMethodCall" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在类型检查器开始类型检查方法调用之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeMethodCall { call -&gt;
    if (isMethodCallExpression(call)
            &amp;&amp; call.methodAsString=='toUpperCase') {
        addStaticTypeError('Not allowed',call)
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许您在类型检查器执行自己的检查之前拦截方法调用。如果要用有限范围的自定义检查替换默认类型检查，这很有用。在这种情况下，必须将handled标志设置为true，以便类型检查器跳过自己的检查。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterMethodCall" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterMethodCall</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器完成类型检查方法调用后调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>方法调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterMethodCall { call -&gt;
    if (getTargetMethod(call).name=='toUpperCase') {
        addStaticTypeError('Not allowed',call)
        handled = true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器完成自己的检查之后，允许您执行其他检查。如果您要执行标准的类型检查测试，但又要确保附加的类型安全性（例如，相互检查参数），则这特别有用。注意<code>afterMethodCall</code>即使您做了<code>beforeMethodCall</code>并将handled标志设置为true。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-onMethodSelection" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>onMethodSelection</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器找到适合方法调用的方法时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>表达式expr，MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">onMethodSelection { expr, node -&gt;
    if (node.declaringClass.name == 'java.lang.String') {
        // calling a method on 'String'
        // let’s perform additional checks!
        if (++count&gt;2) {
            addStaticTypeError("You can use only 2 calls on String in your source code",expr)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型检查器通过推断方法调用的参数类型来工作，然后选择目标方法。如果找到一个对应的，则触发此事件。例如，如果您想对特定的方法调用做出反应，例如输入一个以闭包作为参数的方法的作用域（如在构建器中），这很有趣。请注意，可能会为各种类型的表达式引发此事件，而不仅仅是方法调用（例如，二进制表达式）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-methodNotFound" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>methodNotFound</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法为方法调用找到合适的方法时，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode接收者，字符串名称，ArgumentListExpression argList，ClassNode [] argTypes，MethodCall调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    // receiver is the inferred type of the receiver
    // name is the name of the called method
    // argList is the list of arguments the method was called with
    // argTypes is the array of inferred types for each argument
    // call is the method call for which we couldn’t find a target method
    if (receiver==classNodeFor(String)
            &amp;&amp; name=='longueur'
            &amp;&amp; argList.size()==0) {
        handled = true
        return newMethod('longueur', classNodeFor(String))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不像<code>onMethodSelection</code> ，当类型检查器找不到方法调用的目标方法（实例或静态）时，将发送此事件。它使您有机会在将错误发送给用户之前拦截该错误，还可以设置目标方法。为此，您需要返回一个列表<code>MethodNode</code> 。在大多数情况下，您都将返回：一个空列表，这意味着您找不到相应的方法；一个列表中只有一个元素，这表示目标方法毫无疑问。如果返回多个MethodNode，则编译器会向用户抛出错误，指出方法调用不明确，并列出了可能的方法。为了方便起见，如果只想返回一个方法，则可以直接返回它，而不必将其包装到列表中。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitMethod" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器在对方法主体进行类型检查之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitMethod { methodNode -&gt;
    // tell the type checker we will handle the body by ourselves
    handled = methodNode.name.startsWith('skip')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在开始对方法主体进行类型检查之前，类型检查器将调用此方法。例如，如果您要自己执行类型检查而不是让类型检查器执行类型检查，则必须将handled标志设置为true。此事件还可用于帮助定义扩展的范围（例如，仅当您在方法foo中时才应用它）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitMethod" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterVisitMethod</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在对方法主体进行类型检查之后，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>MethodNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterVisitMethod { methodNode -&gt;
    scopeExit {
        if (methods&gt;2) {
            addStaticTypeError("Method ${methodNode.name} contains more than 2 method calls", methodNode)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器访问方法主体之后，使您有机会执行其他检查。例如，如果您收集信息，并希望在收集所有信息后执行其他检查，这将很有用。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-beforeVisitClass" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>beforeVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>类型检查器在对类进行类型检查之前调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">beforeVisitClass { ClassNode classNode -&gt;
    def name = classNode.nameWithoutPackage
    if (!(name[0] in 'A'..'Z')) {
        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果对某个班级进行了类型检查，则在访问该班级之前，将发送此事件。在用注释的类中定义的内部类也是如此<code>@TypeChecked</code> 。它可以帮助您定义扩展的范围，甚至可以用自定义类型检查实现完全替代类型检查器的访问。为此，您必须设置<code>handled</code>标记为<code>true</code> 。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-afterVisitClass" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>afterVisitClass</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>在完成类型检查类的访问之后，由类型检查器调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode节点</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">afterVisitClass { ClassNode classNode -&gt;
    def name = classNode.nameWithoutPackage
    if (!(name[0] in 'A'..'Z')) {
        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型检查器完成工作之后，为每个要进行类型检查的类调用。这包括带注释的类<code>@TypeChecked</code>并且不会跳过与相同的类中定义的任何内部/匿名类。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-incompatibleAssignment" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>不兼容分配</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器认为分配不正确时调用，这意味着分配的右侧与左侧不兼容</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>ClassNode lhsType，ClassNode rhsType，表达式分配</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">incompatibleAssignment { lhsType, rhsType, expr -&gt;
    if (isBinaryExpression(expr) &amp;&amp; isAssignment(expr.operation.type)) {
        if (lhsType==classNodeFor(int) &amp;&amp; rhsType==classNodeFor(Closure)) {
            handled = true
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使开发人员能够处理错误的任务。例如，这在类重写时很有用<code>setProperty</code> ，因为在这种情况下，有可能通过该运行时机制处理将一种类型的变量分配给另一种类型的属性。在这种情况下，您可以通过告诉类型分配有效（可以使用<code>handled</code>调成<code>true</code> ）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<table id="event-ambiguousMethods" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>活动名称</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>模棱两可的方法</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>叫什么时候</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>当类型检查器无法在几种候选方法之间进行选择时调用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>争论</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>列表<methodnode>方法，表达式来源</methodnode></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用法</strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">ambiguousMethods { methods, origin -&gt;
    // choose the method which has an Integer as parameter type
    methods.find { it.parameters.any { it.type == classNodeFor(Integer) } }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使开发人员能够处理错误的任务。例如，这在类重写时很有用<code>setProperty</code> ，因为在这种情况下，有可能通过该运行时机制处理将一种类型的变量分配给另一种类型的属性。在这种情况下，您可以通过告诉类型分配有效（可以使用<code>handled</code>调成<code>true</code> ）。</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当然，扩展脚本可能包含多个块，并且您可以具有多个块来响应同一事件。这使DSL看起来更好，更易于编写。但是，对事件做出反应远远不够。如果您知道您可以对事件做出反应，那么您还需要处理错误，这意味着可以使用多种<em>帮助</em>程序来简化事情。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Typecheckingextensions-Workingwithextensions"><a class="anchor" href="#Typecheckingextensions-Workingwithextensions"></a> 7.1.5。使用扩展</h4>
<div class="sect4">
<h5 id="Typecheckingextensions-Supportclasses"><a class="anchor" href="#Typecheckingextensions-Supportclasses"></a>支援课程</h5>
<div class="paragraph">
<p>DSL依赖于称为<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc的支持类</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">。GroovyTypeCheckingExtensionSupport</a> 。此类本身扩展了<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html">org.codehaus.groovy.transform.stc。TypeCheckingExtension</a> 。这两个类定义了许多<em>帮助程序</em>方法，这些方法将使AST的使用更加容易，尤其是在类型检查方面。要知道的一件有趣的事是您<strong>可以访问类型检查器</strong> 。这意味着您可以以编程方式调用类型检查器的方法，包括那些允许<strong>引发编译错误的方法</strong> 。</p>
</div>
<div class="paragraph">
<p>扩展脚本委托给<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport</a>类，意味着您可以直接访问以下变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>context</em> ：类型检查器上下文，类型为<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingContext.html">org.codehaus.groovy.transform.stc。TypeCheckingContext</a></p>
</li>
<li>
<p><em>typeCheckingVisitor</em> ：类型检查器本身，一个<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.html">org.codehaus.groovy.transform.stc。StaticTypeCheckingVisitor</a>实例</p>
</li>
<li>
<p><em>generateMethods</em> ：“生成的方法”列表，实际上是可以使用类型检查扩展名在内部创建的“虚拟”方法列表。 <code>newMethod</code>来电</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类型检查上下文包含许多在类型检查器的上下文中有用的信息。例如，当前的封装方法调用，二进制表达式，闭包等堆栈……如果必须知道发生错误并要处理错误的<em>位置</em> ，则此信息特别重要。</p>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Classnodes"><a class="anchor" href="#Typecheckingextensions-Classnodes"></a>类节点</h5>
<div class="paragraph">
<p>使用类型检查扩展时，处理类节点需要特别注意。编译使用抽象语法树（AST），并且在对类进行类型检查时该树可能不完整。这也意味着，当您引用类型时，不得使用诸如<code>String</code>要么<code>HashSet</code> ，但将代表这些类型的节点分类。这需要一定程度的抽象，并了解Groovy如何处理类节点。为了使事情变得容易，Groovy提供了几种帮助程序方法来处理类节点。例如，如果您想说“字符串的类型”，则可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert classNodeFor(String) instanceof ClassNode</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还会注意到，有一个<em>classNodeFor</em>的变体，它需要一个<code>String</code>作为参数，而不是<code>Class</code> 。在一般情况下，你<strong>不</strong>应该使用那一个，因为它的名字就是它会创建一个类节点<code>String</code> ，但没有任何方法，也没有在其上定义任何属性。第一个版本将返回一类节点是<em>解决了</em> ，但第二个返回一个<em>不是</em> 。因此，后者应保留给非常特殊的情况。</p>
</div>
<div class="paragraph">
<p>您可能遇到的第二个问题是引用尚未编译的类型。这可能比您想像的更多。例如，当您一起编译一组文件时。在这种情况下，如果您想说“那个变量是Foo类型”，但是<code>Foo</code>尚未编译，您仍然可以参考<code>Foo</code>类节点使用<code>lookupClassNodeFor</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert lookupClassNodeFor('Foo') instanceof ClassNode</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Helpingthetypechecker"><a class="anchor" href="#Typecheckingextensions-Helpingthetypechecker"></a>帮助类型检查器</h5>
<div class="paragraph">
<p>假设您知道该变量<code>foo</code>是类型<code>Foo</code>并且您想告诉类型检查器。然后您可以使用<code>storeType</code>方法，它有两个参数：第一个是要存储其类型的节点，第二个是节点的类型。如果你看执行<code>storeType</code> ，您会看到它委托给类型检查器等效方法，该方法本身在存储节点元数据方面做了很多工作。您还将看到，存储类型不仅限于变量：您可以设置任何表达式的类型。</p>
</div>
<div class="paragraph">
<p>同样，获取AST节点的类型只是调用<code>getType</code>在那个节点上。通常，这就是您想要的，但是您必须了解一些内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getType</code>返回表达式的<strong>推断类型</strong> 。这意味着对于声明为type的变量，它不会返回<code>Object</code>的类节点<code>Object</code> ，但在<strong>代码的这一点上</strong>推断出此变量的类型（流类型）</p>
</li>
<li>
<p>如果要访问变量（或字段/参数）的原始类型，则必须在AST节点上调用适当的方法</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Throwinganerror"><a class="anchor" href="#Typecheckingextensions-Throwinganerror"></a>引发错误</h5>
<div class="paragraph">
<p>要引发类型检查错误，您只需调用<code>addStaticTypeError</code>具有两个参数的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一条<em>消息</em> ，它是将显示给最终用户的字符串</p>
</li>
<li>
<p>负责该错误的<em>AST节点</em> 。最好提供最合适的AST节点，因为它将用于检索行号和列号</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-isXXXExpression"><a class="anchor" href="#Typecheckingextensions-isXXXExpression"></a> isXXXExpression</h5>
<div class="paragraph">
<p>通常需要知道AST节点的类型。为了提高可读性，DSL提供了一种特殊的isXXXExpression方法，该方法将委托给<code>x instance of XXXExpression</code> 。例如，代替编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (node instanceof BinaryExpression) {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要您导入<code>BinaryExpression</code>上课，你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (isBinaryExpression(node)) {
   ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Virtualmethods"><a class="anchor" href="#Typecheckingextensions-Virtualmethods"></a>虚方法</h5>
<div class="paragraph">
<p>当您执行动态代码的类型检查时，您可能经常会遇到这样的情况：知道方法调用有效，但背后没有“真正的”方法。例如，以Grails动态查找器为例。您可以进行一个名为<em>findByName（…）</em>的方法调用。由于在bean中没有定义<em>findByName</em>方法，因此类型检查器会抱怨。但是，您会知道此方法在运行时不会失败，甚至可以说出此方法的返回类型是什么。对于这种情况，DSL支持两种特殊的结构，它们由<em>幻影方法</em>组成。这意味着您将返回一个实际上不存在但在类型检查的上下文中定义的方法节点。存在三种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newMethod(String name, Class returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, ClassNode returnType)</code></p>
</li>
<li>
<p><code>newMethod(String name, Callable<ClassNode> return Type)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这三个变体都执行相同的操作：它们创建一个新方法节点，该名称为提供的名称，并定义此方法的返回类型。此外，类型检查器会将这些方法添加到<code>generatedMethods</code>清单（请参阅<code>isGenerated</code>下面）。我们仅设置名称和返回类型的原因是，在90％的情况下，仅它就是您所需要的。例如，在<code>findByName</code>示例鞋帮，您唯一需要知道的是<code>findByName</code>在运行时不会失败，并且它返回一个域类。的<code>Callable</code>返回类型的版本很有趣，因为当类型检查器实际需要返回类型时，它会延迟返回类型的计算。这很有趣，因为在某些情况下，当类型检查器需要它时，您可能不知道实际的返回类型，因此您可以使用每次都会调用的闭包。 <code>getReturnType</code>由此方法节点上的类型检查器调用。如果将此与延迟检查结合使用，则可以实现相当复杂的类型检查，包括对前向引用的处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">newMethod(name) {
    // each time getReturnType on this method node will be called, this closure will be called!
    println 'Type checker called me!'
    lookupClassNodeFor(Foo) // return type
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要的不仅是名称和返回类型，还可以随时创建一个新的<code>MethodNode</code>由你自己。</p>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Scoping"><a class="anchor" href="#Typecheckingextensions-Scoping"></a>范围界定</h5>
<div class="paragraph">
<p>范围界定在DSL类型检查中非常重要，也是我们无法使用基于<em>切入点</em>的方法进行DSL类型检查的原因之一。基本上，您必须能够非常精确地定义您的扩展何时适用以及何时不适用。此外，您必须能够处理常规类型检查器无法处理的情况，例如前向引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">point a(1,1)
line a,b // b is referenced afterwards!
point b(5,2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>举例来说，您要处理一个构建器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">builder.foo {
   bar
   baz(bar)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，您的扩展程序只有在您输入<code>foo</code>方法，并且在此范围之外处于非活动状态。但是您可能会遇到复杂的情况，例如同一文件中的多个构建器或嵌入式构建器（构建器中的构建器）。尽管您不应该尝试从一开始就解决所有问题（必须接受类型检查的限制），但类型检查器确实提供了一种很好的机制来处理此问题：使用<code>newScope</code>和<code>scopeExit</code>方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newScope</code>创建一个新的作用域并将其放在栈顶</p>
</li>
<li>
<p><code>scopeExits</code>从堆栈弹出作用域</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>范围包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>父范围</p>
</li>
<li>
<p>定制数据图</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您想看一下实现，那只是一个<code>LinkedHashMap</code> （ <a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport/TypeCheckingScope.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport。TypeCheckingScope</a> ），但功能非常强大。例如，您可以使用这种范围存储退出范围时要执行的闭包列表。这是您处理前向引用的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def scope = newScope()
scope.secondPassChecks = []
//...
scope.secondPassChecks &lt;&lt; { println 'executed later' }
// ...
scopeExit {
    secondPassChecks*.run() // execute deferred checks
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是说，如果在某个时候您无法确定表达式的类型，或者在这一点上您无法检查赋值是否有效，您仍然可以稍后进行检查……是一项非常强大的功能。现在， <code>newScope</code>和<code>scopeExit</code>提供一些有趣的语法糖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">newScope {
    secondPassChecks = []
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在DSL中的任何时间，您都可以使用<code>getCurrentScope()</code>或更简单<code>currentScope</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">//...
currentScope.secondPassChecks &lt;&lt; { println 'executed later' }
// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>通用模式将是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确定<em>切入点</em> ，在该<em>切入点</em>上将新作用域推入堆栈并在该作用域内初始化自定义变量</p>
</li>
<li>
<p>使用各种事件，您可以使用存储在自定义范围中的信息来执行检查，推迟检查等等。</p>
</li>
<li>
<p>确定退出范围的<em>切入点</em> ，调用<code>scopeExit</code>并最终执行其他检查</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="Typecheckingextensions-Otherusefulmethods"><a class="anchor" href="#Typecheckingextensions-Otherusefulmethods"></a>其他有用的方法</h5>
<div class="paragraph">
<p>有关帮助程序方法的完整列表，请参考<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html">org.codehaus.groovy.transform.stc。GroovyTypeCheckingExtensionSupport</a>和<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html">org.codehaus.groovy.transform.stc。TypeCheckingExtension</a>类。但是，请特别注意以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>isDynamic</code> ：使用VariableExpression作为参数，如果变量是DynamicExpression，则返回true，这意味着在脚本中未使用类型或<code>def</code> 。</p>
</li>
<li>
<p><code>isGenerated</code> ：以MethodNode作为参数，并使用该方法判断类型是否由类型检查器扩展生成。 <code>newMethod</code>方法</p>
</li>
<li>
<p><code>isAnnotatedBy</code> ：接受一个AST节点和一个Class（或ClassNode），并告诉该节点是否用此类注释。例如：<code>isAnnotatedBy(node, NotNull)</code></p>
</li>
<li>
<p><code>getTargetMethod</code> ：将方法调用作为参数并返回<code>MethodNode</code>类型检查器已为此确定的</p>
</li>
<li>
<p><code>delegatesTo</code> ：模拟的行为<code>@DelegatesTo</code>注解。它允许您告诉参数将委托给特定类型（您也可以指定委托策略）</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_type_checking_extensions"><a class="anchor" href="#_advanced_type_checking_extensions"></a> 7.2。高级类型检查扩展</h3>
<div class="sect3">
<h4 id="_precompiled_type_checking_extensions"><a class="anchor" href="#_precompiled_type_checking_extensions"></a> 7.2.1。预编译类型检查扩展</h4>
<div class="paragraph">
<p>上面的所有示例都使用类型检查脚本。它们以类路径的源代码形式存在，这意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对应于类型检查扩展名的Groovy源文件在编译类路径上可用</p>
</li>
<li>
<p>该文件由Groovy编译器针对要编译的每个源单元进行编译（通常，一个源单元对应于一个文件）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是开发类型检查扩展名的一种非常方便的方法，但是由于要为每个要编译的文件扩展名本身的编译，因此它意味着编译阶段较慢。由于这些原因，依靠预编译的扩展可能是实际的。您可以通过以下两种方法执行此操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用Groovy编写扩展，进行编译，然后使用对扩展类的引用而不是源代码</p>
</li>
<li>
<p>用Java编写扩展，进行编译，然后使用对扩展类的引用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用Groovy编写类型检查扩展是最简单的方法。基本上，这种想法是类型检查扩展脚本成为类型检查扩展类的main方法的主体，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport

class PrecompiledExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {     <i class="conum" data-value="1"></i><b>(1)</b>
    @Override
    Object run() {                                                                          <i class="conum" data-value="2"></i><b>(2)</b>
        unresolvedVariable { var -&gt;
            if ('robot'==var.name) {
                storeType(var, classNodeFor(Robot))                                         <i class="conum" data-value="3"></i><b>(3)</b>
                handled = true
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扩展<code>TypeCheckingDSL</code>上课是最简单的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>那么扩展代码需要放入<code>run</code>方法</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>您可以使用与以源代码形式编写的扩展程序相同的事件</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>设置扩展与使用源表单扩展非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['typing.PrecompiledExtension'])
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>区别在于，您无需指定classpath中的路径，而只需指定预编译扩展名的完全限定的类名即可。</p>
</div>
<div class="paragraph">
<p>如果您真的想用Java编写扩展，那么您将不会从类型检查扩展DSL中受益。可以使用以下方式用Java重写上面的扩展名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import org.codehaus.groovy.ast.ClassHelper;
import org.codehaus.groovy.ast.expr.VariableExpression;
import org.codehaus.groovy.transform.stc.AbstractTypeCheckingExtension;


import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;

public class PrecompiledJavaExtension extends AbstractTypeCheckingExtension {                   <i class="conum" data-value="1"></i><b>(1)</b>

    public PrecompiledJavaExtension(final StaticTypeCheckingVisitor typeCheckingVisitor) {
        super(typeCheckingVisitor);
    }

    @Override
    public boolean handleUnresolvedVariableExpression(final VariableExpression vexp) {          <i class="conum" data-value="2"></i><b>(2)</b>
        if ("robot".equals(vexp.getName())) {
            storeType(vexp, ClassHelper.make(Robot.class));
            setHandled(true);
            return true;
        }
        return false;
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扩展<code>AbstractTypeCheckingExtension</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>然后覆盖<code>handleXXX</code>所需方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_using_grab_in_a_type_checking_extension"><a class="anchor" href="#_using_grab_in_a_type_checking_extension"></a> 7.2.2。在类型检查扩展中使用@Grab</h4>
<div class="paragraph">
<p>完全有可能使用<code>@Grab</code>类型检查扩展中的注释。这意味着您可以包括仅在编译时可用的库。在这种情况下，您必须了解，将大大增加编译时间（至少在第一次获取依赖项时）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_sharing_or_packaging_type_checking_extensions"><a class="anchor" href="#_sharing_or_packaging_type_checking_extensions"></a> 7.2.3。共享或打包类型检查扩展</h4>
<div class="paragraph">
<p>类型检查扩展仅仅是需要放在类路径中的脚本。这样，您可以按原样共享它，或将其捆绑在一个将添加到类路径的jar文件中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_global_type_checking_extensions"><a class="anchor" href="#_global_type_checking_extensions"></a> 7.2.4。全局类型检查扩展</h4>
<div class="paragraph">
<p>虽然您可以配置编译器以透明地将类型检查扩展添加到脚本中，但是当前无法仅通过将扩展放在类路径上来透明地应用扩展。</p>
</div>
</div>
<div class="sect3">
<h4 id="_type_checking_extensions_and_compilestatic"><a class="anchor" href="#_type_checking_extensions_and_compilestatic"></a> 7.2.5。类型检查扩展名和@CompileStatic</h4>
<div class="paragraph">
<p>类型检查扩展与<code>@TypeChecked</code>但也可以与<code>@CompileStatic</code> 。但是，您必须意识到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用于的类型检查扩展<code>@CompileStatic</code>通常不足以让编译器知道如何从“不安全”代码生成静态可编译代码</p>
</li>
<li>
<p>可以使用带有<code>@CompileStatic</code>只是为了增强类型检查，也就是说引入了<strong>更多的</strong>编译错误，而没有实际处理动态代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们解释一下第一点，即即使使用扩展，编译器也不会知道如何静态地编译代码：从技术上讲，即使您告诉类型检查器动态变量的类型是什么，例如不知道如何编译它。是吗<code>getBinding('foo')</code> ， <code>getProperty('foo')</code> ， <code>delegate.getFoo()</code> ，...？即使使用类型检查扩展，也绝对没有直接的方法来告诉静态编译器如何编译此类代码（同样，它只会给出有关类型的提示）。</p>
</div>
<div class="paragraph">
<p>对于此特定示例，一种可能的解决方案是指示编译器使用<a href="#mixed-mode">混合模式编译</a> 。一种更高级的方法是<a href="#ast-xform-as-extension">在类型检查期间</a>使用<a href="#ast-xform-as-extension">AST转换，</a>但这要复杂得多。</p>
</div>
<div class="paragraph">
<p>类型检查扩展允许您在失败的地方帮助类型检查器，但也可以在没有失败的地方帮助失败。在这种情况下，支持扩展<code>@CompileStatic</code>太。想象一下一个能够对SQL查询进行类型检查的扩展。在那种情况下，扩展名在动态和静态上下文中都是有效的，因为没有扩展名，代码仍然可以通过。</p>
</div>
</div>
<div class="sect3">
<h4 id="mixed-mode"><a class="anchor" href="#mixed-mode"></a> 7.2.6。混合模式编译</h4>
<div class="paragraph">
<p>在上一节中，我们强调了您可以使用以下命令激活类型检查扩展的事实： <code>@CompileStatic</code> 。在这种情况下，类型检查器将不再抱怨某些未解析的变量或未知的方法调用，但仍然不知道如何静态地编译它们。</p>
</div>
<div class="paragraph">
<p>混合模式编译提供了第三种方法，即指示编译器，只要找到未解析的变量或方法调用，则应退回到动态模式。这要归功于类型检查扩展和特殊的<code>makeDynamic</code>呼叫。</p>
</div>
<div class="paragraph">
<p>为了说明这一点，让我们回到<code>Robot</code>例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">robot.move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们尝试使用激活我们的类型检查扩展程序<code>@CompileStatic</code>代替<code>@TypeChecked</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      <i class="conum" data-value="1"></i><b>(1)</b>
        extensions:['robotextension.groovy'])               <i class="conum" data-value="2"></i><b>(2)</b>
)
def shell = new GroovyShell(config)
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>应用<code>@CompileStatic</code>透明地</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>激活类型检查扩展</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该脚本可以正常运行，因为静态编译器会被告知有关类型的信息。 <code>robot</code>变量，因此它可以直接调用<code>move</code> 。但在此之前，编译器如何知道如何获取<code>robot</code>变量？实际上，默认情况下，在类型检查扩展中，设置<code>handled=true</code>在未解析的变量上将自动触发动态分辨率，因此在这种情况下，您没有什么特别的条件可以使编译器使用混合模式。但是，让我们从机器人脚本开始稍微更新一下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">move 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里您可以注意到没有参考<code>robot</code>不再。那么我们的扩展将无济于事，因为我们将无法指示编译器<code>move</code>完成于<code>Robot</code>实例。借助于<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/DelegatingScript.html">groovy.util ，可以完全动态地执行此代码示例</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/DelegatingScript.html">。DelegatingScript</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.scriptBaseClass = 'groovy.util.DelegatingScript'     <i class="conum" data-value="1"></i><b>(1)</b>
def shell = new GroovyShell(config)
def runner = shell.parse(script)                            <i class="conum" data-value="2"></i><b>(2)</b>
runner.setDelegate(new Robot())                             <i class="conum" data-value="3"></i><b>(3)</b>
runner.run()                                                <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们将编译器配置为使用<code>DelegatingScript</code>作为基类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>脚本源需要解析，并将返回的实例<code>DelegatingScript</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后我们可以打电话<code>setDelegate</code>使用<code>Robot</code>作为脚本的委托</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后执行脚本。 <code>move</code>将直接在委托上执行</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果我们希望通过<code>@CompileStatic</code> ，我们必须使用类型检查扩展名，因此让我们更新配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      <i class="conum" data-value="1"></i><b>(1)</b>
        extensions:['robotextension2.groovy'])              <i class="conum" data-value="2"></i><b>(2)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>应用<code>@CompileStatic</code>透明地</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用备用的类型检查扩展名来识别对<code>move</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后在上一节中，我们学习了如何处理无法识别的方法调用，因此我们可以编写此扩展名：</p>
</div>
<div class="listingblock">
<div class="title">robotextension2.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    if (isMethodCallExpression(call)                        <i class="conum" data-value="1"></i><b>(1)</b>
        &amp;&amp; call.implicitThis                                <i class="conum" data-value="2"></i><b>(2)</b>
        &amp;&amp; 'move'==name                                     <i class="conum" data-value="3"></i><b>(3)</b>
        &amp;&amp; argTypes.length==1                               <i class="conum" data-value="4"></i><b>(4)</b>
        &amp;&amp; argTypes[0] == classNodeFor(int)                 <i class="conum" data-value="5"></i><b>(5)</b>
    ) {
        handled = true                                      <i class="conum" data-value="6"></i><b>(6)</b>
        newMethod('move', classNodeFor(Robot))              <i class="conum" data-value="7"></i><b>(7)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>如果调用是方法调用（不是静态方法调用）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>该调用是基于“隐式这样做”（没有明确的<code>this.</code> ）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>被调用的方法是<code>move</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>并且该调用是通过单个参数完成的</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>而该参数是类型<code>int</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>然后告诉类型检查器该调用是有效的</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>并且该呼叫的返回类型为<code>Robot</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您尝试执行此代码，那么您可能会惊讶于它实际上在运行时失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.NoSuchMethodError: java.lang.Object.move()Ltyping/Robot;</pre>
</div>
</div>
<div class="paragraph">
<p>原因很简单：尽管类型检查扩展足以满足<code>@TypeChecked</code> ，它不涉及静态编译，对于<code>@CompileStatic</code>这需要其他信息。在这种情况下，您告诉编译器该方法已经存在，但是您没有向它解释它实际上是<strong>什么</strong>方法，以及消息的接收者（委托）是什么。</p>
</div>
<div class="paragraph">
<p>解决此问题非常容易，仅意味着更换<code>newMethod</code>打电话给别的东西：</p>
</div>
<div class="listingblock">
<div class="title">robotextension3.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">methodNotFound { receiver, name, argList, argTypes, call -&gt;
    if (isMethodCallExpression(call)
        &amp;&amp; call.implicitThis
        &amp;&amp; 'move'==name
        &amp;&amp; argTypes.length==1
        &amp;&amp; argTypes[0] == classNodeFor(int)
    ) {
        makeDynamic(call, classNodeFor(Robot))              <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>告诉编译器调用应该动态化</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>makeDynamic</code>呼叫执行3件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它返回一个虚拟方法，就像<code>newMethod</code></p>
</li>
<li>
<p>自动设置<code>handled</code>标记为<code>true</code>为了你</p>
</li>
<li>
<p>但也标志着<code>call</code>动态地完成</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，当编译器必须生成用于调用的字节码时<code>move</code> ，由于现在已将其标记为动态调用，因此它将回退到动态编译器并让其处理该调用。由于扩展名告诉我们动态调用的返回类型是<code>Robot</code> ，后续调用将静态完成！</p>
</div>
<div class="paragraph">
<p>有人会奇怪为什么静态编译器默认情况下没有扩展就不会这样做。这是一个设计决策：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果代码是静态编译的，我们通常需要类型安全和最佳性能</p>
</li>
<li>
<p>因此，如果使无法识别的变量/方法调用动态化，则会失去类型安全性，而且在编译时还完全支持错别字！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>简而言之，如果您要进行混合模式编译，则<strong>必须</strong>通过类型检查扩展将其明确显示，以便编译器和DSL设计人员完全了解自己在做什么。</p>
</div>
<div class="paragraph">
<p><code>makeDynamic</code>可以在3种AST节点上使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法节点（ <code>MethodNode</code> ）</p>
</li>
<li>
<p>一个变量 （ <code>VariableExpression</code> ）</p>
</li>
<li>
<p>属性表达式（ <code>PropertyExpression</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这还不够，那就意味着不能直接进行静态编译，而您必须依靠AST转换。</p>
</div>
</div>
<div class="sect3">
<h4 id="ast-xform-as-extension"><a class="anchor" href="#ast-xform-as-extension"></a> 7.2.7。在扩展中转换AST</h4>
<div class="paragraph">
<p>从AST转换设计的角度来看，类型检查扩展看起来非常有吸引力：扩展可以访问诸如推断类型之类的上下文，这通常很不错。扩展可以直接访问抽象语法树。由于您可以访问AST，因此从理论上讲，没有什么可以阻止您修改AST。但是，我们不建议您这样做，除非您是高级AST转换设计器并且非常了解编译器内部：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，您将明确打破类型检查的约定，即仅对AST进行注释。类型检查<strong>不</strong>应该修改AST树，因为你不就能够保证了，如果没有<em>@TypeChecked</em>注释代码的行为，而不标注相同。</p>
</li>
<li>
<p>如果您的扩展名旨在与<em>@CompileStatic</em>配合<em>使用</em> ，则<strong>可以</strong>修改AST，因为这确实是<em>@CompileStatic</em>最终将执行的操作。静态编译并不能保证在动态的Groovy相同的语义，从而有效地存在与<em>@CompileStatic</em>与<em>@TypeChecked</em>编译代码编译的代码之间的差异。由您决定要更新AST的策略，但是可能使用在类型检查变得更容易之前运行的AST转换。</p>
</li>
<li>
<p>如果您不能依靠类型检查器之前启动的转换，则必须<strong>非常</strong>小心</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">类型检查阶段是生成字节码之前在编译器中运行的最后一个阶段。所有其他AST转换都在此之前运行，并且编译器在“修复”类型检查阶段之前生成的错误AST方面做得非常出色。在类型检查期间（例如直接在类型检查扩展中）执行转换后，您必须自己完成所有工作，以生成100％兼容编译器的抽象语法树，这很容易变得复杂。因此，如果您从类型检查扩展和AST转换开始，我们不建议您这样做。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_examples"><a class="anchor" href="#_examples"></a> 7.2.8。例子</h4>
<div class="paragraph">
<p>现实生活中类型检查扩展的示例很容易找到。您可以下载Groovy的源代码，并查看链接到<a href="https://github.com/apache/groovy/tree/master/src/test-resources/groovy/transform/stc">各种扩展脚本</a>的<a href="https://github.com/apache/groovy/blob/master/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy">TypeCheckingExtensionsTest</a>类。</p>
</div>
<div class="paragraph">
<p>可以在<a href="markup-template-engine.html">标记模板引擎</a>源代码中找到复杂类型检查扩展的示例：该模板引擎依靠类型检查扩展和AST转换将模板转换为完全静态编译的代码。可以在<a href="https://github.com/apache/groovy/tree/master/subprojects/groovy-templates/src/main/groovy/groovy/text/markup">这里</a>找到其来源。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:30 UTC</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>