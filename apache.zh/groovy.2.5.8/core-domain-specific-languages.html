<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>领域特定语言</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">


<div id="header">
<h1>领域特定语言</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_command_chains">1。指挥链</a></li>
<li><a href="#_operator_overloading">2。运算符重载</a></li>
<li><a href="#_script_base_classes">3。脚本基类</a>
<ul class="sectlevel2">
<li><a href="#_the_script_class">3.1。脚本类</a></li>
<li><a href="#dsl-basescript">3.2。@BaseScript批注</a></li>
<li><a href="#_alternate_abstract_method">3.3。替代抽象方法</a></li>
</ul>
</li>
<li><a href="#_adding_properties_to_numbers">4。向数字添加属性</a></li>
<li><a href="#section-delegatesto">5，@DelegatesTo</a>
<ul class="sectlevel2">
<li><a href="#TheDelegatesToannotation-DSLsmadeeasy">5.1。在编译时解释授权策略</a></li>
<li><a href="#TheDelegatesToannotation-DelegatesTo">5.2。@DelegatesTo</a></li>
<li><a href="#TheDelegatesToannotation-DelegatesTomodes">5.3。代表到模式</a>
<ul class="sectlevel3">
<li><a href="#TheDelegatesToannotation-Simpledelegation">5.3.1。简单委托</a></li>
<li><a href="#TheDelegatesToannotation-Delegationstrategy">5.3.2。授权策略</a></li>
<li><a href="#TheDelegatesToannotation-Delegatetoparameter">5.3.3。委托给参数</a></li>
<li><a href="#TheDelegatesToannotation-Multipleclosures">5.3.4。多重关闭</a></li>
<li><a href="#_delegating_to_a_generic_type">5.3.5。委托给泛型类型</a></li>
<li><a href="#_delegating_to_an_arbitrary_type">5.3.6。委派给任意类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#compilation-customizers">6。编译定制器</a>
<ul class="sectlevel2">
<li><a href="#_introduction">6.1。介绍</a></li>
<li><a href="#_import_customizer">6.2。导入定制器</a></li>
<li><a href="#_ast_transformation_customizer">6.3。AST转换定制器</a></li>
<li><a href="#_secure_ast_customizer">6.4。安全的AST定制器</a></li>
<li><a href="#_source_aware_customizer">6.5。知道源代码的定制器</a></li>
<li><a href="#_customizer_builder">6.6。定制器构建器</a>
<ul class="sectlevel3">
<li><a href="#_import_customizer_2">6.6.1。导入定制器</a></li>
<li><a href="#_ast_transformation_customizer_2">6.6.2。AST转换定制器</a></li>
<li><a href="#_secure_ast_customizer_2">6.6.3。安全的AST定制器</a></li>
<li><a href="#_source_aware_customizer_2">6.6.4。知道源代码的定制器</a></li>
<li><a href="#_inlining_a_customizer">6.6.5。内联定制器</a></li>
<li><a href="#_multiple_customizers">6.6.6。多个定制器</a></li>
</ul>
</li>
<li><a href="#_config_script_flag">6.7。配置脚本标志</a>
<ul class="sectlevel3">
<li><a href="#_static_compilation_by_default">6.7.1。默认情况下静态编译</a></li>
</ul>
</li>
<li><a href="#_ast_transformations">6.8。AST转换</a></li>
</ul>
</li>
<li><a href="#_custom_type_checking_extensions">7。自定义类型检查扩展</a></li>
<li><a href="#_builders">8。建筑商</a>
<ul class="sectlevel2">
<li><a href="#_creating_a_builder">8.1。创建一个生成器</a>
<ul class="sectlevel3">
<li><a href="#_buildersupport">8.1.1。Builder支持</a></li>
<li><a href="#_factorybuildersupport">8.1.2。FactoryBuilder支持</a></li>
</ul>
</li>
<li><a href="#_existing_builders">8.2。现有的建设者</a>
<ul class="sectlevel3">
<li><a href="#_markupbuilder">8.2.1。标记生成器</a></li>
<li><a href="#_streamingmarkupbuilder">8.2.2。StreamingMarkupBuilder</a></li>
<li><a href="#_saxbuilder">8.2.3。SaxBuilder</a></li>
<li><a href="#_staxbuilder">8.2.4。StaxBuilder</a></li>
<li><a href="#_dombuilder">8.2.5。DOMBuilder</a></li>
<li><a href="#_nodebuilder">8.2.6。节点构建器</a></li>
<li><a href="#_jsonbuilder">8.2.7。JsonBuilder</a></li>
<li><a href="#_streamingjsonbuilder">8.2.8。流JsonBuilder</a></li>
<li><a href="#swingbuilder">8.2.9。SwingBuilder</a></li>
<li><a href="#_antbuilder">8.2.10。蚂蚁建筑</a></li>
<li><a href="#_clibuilder">8.2.11。CliBuilder</a>
<ul class="sectlevel4">
<li><a href="#_using_annotations_and_an_interface">使用注释和界面</a></li>
<li><a href="#_using_annotations_and_an_instance">使用注释和实例</a></li>
<li><a href="#_using_annotations_and_a_script">使用注释和脚本</a></li>
<li><a href="#_options_with_arguments">带参数的选项</a></li>
<li><a href="#_specifying_a_type">指定类型</a></li>
<li><a href="#_custom_parsing_of_the_argument_string">自定义解析参数String</a></li>
<li><a href="#_options_with_multiple_arguments">具有多个参数的选项</a></li>
<li><a href="#_types_and_multiple_arguments">类型和多个参数</a></li>
<li><a href="#_setting_a_default_value">设定默认值</a></li>
<li><a href="#_use_with_code_typechecked_code">用于<code>TypeChecked</code></a></li>
<li><a href="#_advanced_cli_usage">高级CLI使用</a>
<ul class="sectlevel5">
<li><a href="#_apache_commons_cli">Apache Commons CLI</a></li>
<li><a href="#_picocli">皮科克里</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_objectgraphbuilder">8.2.12。ObjectGraphBuilder</a></li>
<li><a href="#_jmxbuilder">8.2.13。JmxBuilder</a></li>
<li><a href="#_filetreebuilder">8.2.14。FileTreeBuilder</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_command_chains"><a class="anchor" href="#_command_chains"></a> 1。指挥链</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy允许您省略顶级语句的方法调用参数周围的括号。 “命令链”功能通过允许我们链接这种无括号的方法调用而扩展了此范围，该方法调用既不需要参数周围的括号，也不需要链接的调用之间的点。一般的想法是，像<code>a b c d</code>实际上将等同于<code>a(b).c(d)</code> 。这也适用于多个参数，闭包参数甚至命名参数。此外，这样的命令链也可以出现在分配的右侧。让我们看一下新语法支持的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// equivalent to: turn(left).then(right)
turn left then right

// equivalent to: take(2.pills).of(chloroquinine).after(6.hours)
take 2.pills of chloroquinine after 6.hours

// equivalent to: paint(wall).with(red, green).and(yellow)
paint wall with red, green and yellow

// with named parameters too
// equivalent to: check(that: margarita).tastes(good)
check that: margarita tastes good

// with closures as parameters
// equivalent to: given({}).when({}).then({})
given { } when { } then { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以在链中使用不带参数的方法，但在这种情况下，需要括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// equivalent to: select(all).unique().from(names)
select all unique() from names</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您的命令链包含奇数个元素，则该链将由方法/参数组成，并以最终的属性访问结束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// equivalent to: take(3).cookies
// and also this: take(3).getCookies()
take 3 cookies</code></pre>
</div>
</div>
<div class="paragraph">
<p>就现在可以用Groovy编写的DSL而言，这种命令链方法开辟了有趣的可能性。</p>
</div>
<div class="paragraph">
<p>上面的示例说明了使用基于命令链的DSL，但没有说明如何创建一个。您可以使用多种策略，但是为了说明如何创建这种DSL，我们将展示几个示例-首先使用map和Closures：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">show = { println it }
square_root = { Math.sqrt(it) }

def please(action) {
  [the: { what -&gt;
    [of: { n -&gt; action(what(n)) }]
  }]
}

// equivalent to: please(show).the(square_root).of(100)
please show the square_root of 100
// ==&gt; 10.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为第二个示例，请考虑如何编写DSL来简化现有API之一。也许您需要将此代码展示给可能不是核心Java开发人员的客户，业务分析师或测试人员。我们将使用<code>Splitter</code>来自Google <a href="https://github.com/google/guava">Guava库</a>项目，因为它已经有了一个不错的Fluent API。这是我们可能开箱即用的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Java开发人员而言，它读起来相当不错，但是如果这不是您的目标读者，或者您有很多这样的语句要编写，则可能会有些冗长。同样，编写DSL有很多选择。我们将通过Maps和Closures使其保持简单。我们将首先编写一个辅助方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def split(string) {
  [on: { sep -&gt;
    [trimming: { trimChar -&gt;
      Splitter.on(sep).trimResults(CharMatcher.is(trimChar as char)).split(string).iterator().toList()
    }]
  }]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，而不是原始示例中的这一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def result = split "_a ,_b_ ,c__" on ',' trimming '_\'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operator_overloading"><a class="anchor" href="#_operator_overloading"></a> 2。运算符重载</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy中的各种运算符都映射到对象的常规方法调用上。</p>
</div>
<div class="paragraph">
<p>这使您可以提供自己的Java或Groovy对象，这些对象可以利用运算符重载。下表描述了Groovy支持的运算符及其映射的方法。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作员</th>
<th class="tableblock halign-left valign-top">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a + b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a - b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a。减（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a * b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a。乘（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a ** b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功率（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a / b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.div（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a % b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.mod（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a | b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a。或（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a & b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a ^ b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.xor（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a++</code>要么<code>++a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.next（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a--</code>要么<code>--a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.previous（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.getAt（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b] = c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.putAt（b，c）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a << b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.leftShift（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a >> b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.rightShift（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a >>> b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.rightShiftUnsigned（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>switch(a) { case(b) : }</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">b.isCase（a）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>if(a)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.asBoolean（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>~a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.bitwiseNegate（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.negative（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.positive（）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a as b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.asType（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a == b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a。等于（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a != b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">！a。等于（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a <=> b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.compareTo（b）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a > b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.compareTo（b）> 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a >= b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.compareTo（b）> = 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a < b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.compareTo（b）<0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a <= b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.compareTo（b）<= 0</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_script_base_classes"><a class="anchor" href="#_script_base_classes"></a> 3。脚本基类</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_script_class"><a class="anchor" href="#_the_script_class"></a> 3.1。脚本类</h3>
<div class="paragraph">
<p>Groovy脚本总是编译为类。例如，脚本如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println 'Hello from Groovy'</code></pre>
</div>
</div>
<div class="paragraph">
<p>被编译为扩展抽象<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/Script.html">groovy.lang的类</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/Script.html">。脚本</a>类。此类包含一个称为<em>run的</em>抽象方法。编译脚本时，其主体将成为<em>run</em>方法，而脚本中找到的其他方法可以在实现类中找到。的<code>Script</code>该类提供了基本支持，可通过<code>Binding</code>对象，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def binding = new Binding()             <i class="conum" data-value="1"></i><b>(1)</b>
def shell = new GroovyShell(binding)    <i class="conum" data-value="2"></i><b>(2)</b>
binding.setVariable('x',1)              <i class="conum" data-value="3"></i><b>(3)</b>
binding.setVariable('y',3)
shell.evaluate 'z=2*x+y'                <i class="conum" data-value="4"></i><b>(4)</b>
assert binding.getVariable('z') == 5    <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>绑定用于在脚本和调用类之间共享数据</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>一种<code>GroovyShell</code>可以与此绑定一起使用</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>输入变量是从绑定内的调用类设置的</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后评估脚本</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>和<code>z</code>变量已“导出”到绑定中</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是在调用者和脚本之间共享数据的非常实用的方法，但是在某些情况下可能不够用或不实用。为此，Groovy允许您设置自己的基本脚本类。基本脚本类必须扩展<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/lang/Script.html">groovy.lang。脚本</a>并且是单个抽象方法类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class MyBaseClass extends Script {
    String name
    public void greet() { println "Hello, $name!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以在编译器配置中声明自定义脚本基类，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()                                <i class="conum" data-value="1"></i><b>(1)</b>
config.scriptBaseClass = 'MyBaseClass'                                  <i class="conum" data-value="2"></i><b>(2)</b>
def shell = new GroovyShell(this.class.classLoader, config)             <i class="conum" data-value="3"></i><b>(3)</b>
shell.evaluate """
    setName 'Judith'                                                    <i class="conum" data-value="4"></i><b>(4)</b>
    greet()
"""</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个定制的编译器配置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将基本脚本类设置为我们的自定义基本脚本类</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>然后创建一个<code>GroovyShell</code>使用该配置</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>然后，脚本将扩展基本脚本类，从而直接访问<code>name</code>财产和<code>greet</code>方法</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="dsl-basescript"><a class="anchor" href="#dsl-basescript"></a> 3.2。@BaseScript批注</h3>
<div class="paragraph">
<p>或者，也可以使用<code>@BaseScript</code>直接将注释添加到脚本中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.BaseScript

@BaseScript MyBaseClass baseScript
setName 'Judith'
greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>@BaseScript</code>应该注释一个类型为基本脚本类的变量。或者，您可以将基本脚本类设置为<code>@BaseScript</code>注释本身：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@BaseScript(MyBaseClass)
import groovy.transform.BaseScript

setName 'Judith'
greet()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternate_abstract_method"><a class="anchor" href="#_alternate_abstract_method"></a> 3.3。替代抽象方法</h3>
<div class="paragraph">
<p>我们已经看到，基本脚本类是一种单一的抽象方法类型，需要实现<code>run</code>方法。的<code>run</code>方法由脚本引擎自动执行。在某些情况下，拥有一个实现<code>run</code>方法，但提供了可供脚本主体使用的替代抽象方法。例如，基本脚本<code>run</code>方法可能会在之前执行一些初始化<code>run</code>方法被执行。这样做是可行的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class MyBaseClass extends Script {
    int count
    abstract void scriptBody()                              <i class="conum" data-value="1"></i><b>(1)</b>
    def run() {
        count++                                             <i class="conum" data-value="2"></i><b>(2)</b>
        scriptBody()                                        <i class="conum" data-value="3"></i><b>(3)</b>
        count                                               <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>基本脚本类应该定义一个（并且只有一个）抽象方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>run</code>在执行脚本主体之前，可以重写方法并执行任务</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>run</code>称抽象<code>scriptBody</code>将委托给用户脚本的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>那么它可以返回脚本中的值以外的其他值</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果执行此代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def result = shell.evaluate """
    println 'Ok'
"""
assert result == 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您将看到脚本已执行，但评估结果为<code>1</code>如由<code>run</code>基类的方法。如果使用更清楚<code>parse</code>代替<code>evaluate</code> ，因为它将允许您执行<code>run</code>在同一脚本实例上多次调用该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def script = shell.parse("println 'Ok'")
assert script.run() == 1
assert script.run() == 2</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adding_properties_to_numbers"><a class="anchor" href="#_adding_properties_to_numbers"></a> 4。向数字添加属性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Groovy中，数字类型被认为等于任何其他类型。这样，可以通过向数字添加属性或方法来增强数字。例如，在处理可测量数量时，这可能非常方便。有关如何在Groovy中增强现有类的详细信息，请参见<a href="core-metaprogramming.html#_extension_modules">扩展模块</a>部分或<a href="core-metaprogramming.html#categories">类别</a>部分。</p>
</div>
<div class="paragraph">
<p>在Groovy中，可以使用<code>TimeCategory</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">use(TimeCategory)  {
    println 1.minute.from.now       <i class="conum" data-value="1"></i><b>(1)</b>
    println 10.hours.ago

    def someDate = new Date()       <i class="conum" data-value="2"></i><b>(2)</b>
    println someDate - 3.months
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>TimeCategory</code> ，一个属性<code>minute</code>被添加到<code>Integer</code>类</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>同样， <code>months</code>方法返回一个<code>groovy.time.DatumDependentDuration</code>可用于微积分</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>类别在词法上受约束，使其非常适合内部DSL。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section-delegatesto"><a class="anchor" href="#section-delegatesto"></a> 5，@DelegatesTo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="TheDelegatesToannotation-DSLsmadeeasy"><a class="anchor" href="#TheDelegatesToannotation-DSLsmadeeasy"></a> 5.1。在编译时解释授权策略</h3>
<div class="paragraph">
<p><code>@groovy.lang.DelegatesTo</code>是文档和编译时注释，旨在：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>记录使用闭包作为参数的API</p>
</li>
<li>
<p>为静态类型检查器和编译器提供类型信息</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy语言是构建DSL的首选平台。使用闭包，创建自定义控件结构非常容易，并且创建构建器也很简单。假设您有以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">email {
    from 'dsl-guru@mycompany.com'
    to 'john.doe@waitaminute.com'
    subject 'The pope has resigned!'
    body {
        p 'Really, the pope has resigned!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一种实现方法是使用构建器策略，这意味着一种名为<code>email</code>接受闭包作为参数。该方法可以将后续调用委派给实现该方法的对象。 <code>from</code> ， <code>to</code> ， <code>subject</code>和<code>body</code>方法。再次， <code>body</code>是一种接受闭包作为参数并使用构建器策略的方法。</p>
</div>
<div class="paragraph">
<p>通常通过以下方式实现这种构建器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def email(Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>EmailSpec</code>类实现<code>from</code> ， <code>to</code> ， … 方法。通过致电<code>rehydrate</code> ，我们正在为其创建闭包的副本<code>delegate</code> ， <code>owner</code>和<code>thisObject</code>价值观。设置所有者和<code>this</code>对象在这里不是很重要，因为我们将使用<code>DELEGATE_ONLY</code>该策略表示仅针对闭包的委托才能解决方法调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class EmailSpec {
    void from(String from) { println "From: $from"}
    void to(String... to) { println "To: $to"}
    void subject(String subject) { println "Subject: $subject"}
    void body(Closure body) {
        def bodySpec = new BodySpec()
        def code = body.rehydrate(bodySpec, this, this)
        code.resolveStrategy = Closure.DELEGATE_ONLY
        code()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>EmailSpec</code>班级本身有一个<code>body</code>接受克隆并执行的闭包的方法。这就是我们在Groovy中所谓的构建器模式。</p>
</div>
<div class="paragraph">
<p>我们显示的代码的问题之一是<code>email</code> method没有关于他可以在闭包内调用的方法的任何信息。唯一可能的信息来自方法文档。这样做有两个问题：首先，文档并非总是编写的，如果有的话，它也不总是可用的（例如，未下载Javadoc）。其次，它对IDE没有帮助。在这里，真正有趣的是，IDE可以通过建议开发者一旦将它们放在闭包主体中，就可以帮助开发人员。 <code>email</code>类。</p>
</div>
<div class="paragraph">
<p>此外，如果用户在闭包中调用了方法未定义的方法， <code>EmailSpec</code>类，IDE应该至少发出警告（因为很有可能在运行时中断）。</p>
</div>
<div class="paragraph">
<p>上面的代码的另一个问题是它与静态类型检查不兼容。类型检查将使用户知道在编译时（而不是在运行时）是否授权方法调用，但是如果您尝试对此代码执行类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">email {
    from 'dsl-guru@mycompany.com'
    to 'john.doe@waitaminute.com'
    subject 'The pope has resigned!'
    body {
        p 'Really, the pope has resigned!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，类型检查器会知道<code>email</code>接受方法<code>Closure</code> ，但它会针对闭包<strong>内部</strong>的每个方法调用抱怨，因为<code>from</code>例如，，不是在类中定义的方法。实际上，它是在<code>EmailSpec</code>类，并且绝对没有提示可帮助它知道关闭委托在运行时将是类型<code>EmailSpec</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.TypeChecked
void sendEmail() {
    email {
        from 'dsl-guru@mycompany.com'
        to 'john.doe@waitaminute.com'
        subject 'The pope has resigned!'
        body {
            p 'Really, the pope has resigned!'
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译失败，并显示如下错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - Cannot find matching method MyScript#from(java.lang.String). Please check if the declared type is right and if the method exists.
 @ line 31, column 21.
                       from 'dsl-guru@mycompany.com'</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="TheDelegatesToannotation-DelegatesTo"><a class="anchor" href="#TheDelegatesToannotation-DelegatesTo"></a> 5.2。@DelegatesTo</h3>
<div class="paragraph">
<p>由于这些原因，Groovy 2.1引入了一个名为<code>@DelegatesTo</code> 。此批注的目的是解决文档问题，这将使您的IDE知道闭包主体中的预期方法，并且还可以通过向编译器提示潜在的接收者来解决类型检查问题。闭包主体中的方法调用。</p>
</div>
<div class="paragraph">
<p>这个想法是要注释<code>Closure</code>的参数<code>email</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def email(@DelegatesTo(EmailSpec) Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在这里所做的是告诉编译器（或IDE），当使用闭包调用该方法时，此闭包的委托将设置为一个类型的对象<code>email</code> 。但是仍然存在一个问题：默认委托策略不是我们的方法中使用的策略。因此，我们将提供更多信息，并告诉编译器（或IDE）委派策略也已更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def email(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=EmailSpec) Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，IDE和类型检查器（如果您正在使用<code>@TypeChecked</code> ）将了解委托和委托策略。这非常好，因为它既可以使IDE提供智能完成功能，又可以消除仅在运行时才知道程序行为的编译时存在的错误！</p>
</div>
<div class="paragraph">
<p>现在，以下代码将通过编译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TypeChecked
void doEmail() {
    email {
        from 'dsl-guru@mycompany.com'
        to 'john.doe@waitaminute.com'
        subject 'The pope has resigned!'
        body {
            p 'Really, the pope has resigned!'
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="TheDelegatesToannotation-DelegatesTomodes"><a class="anchor" href="#TheDelegatesToannotation-DelegatesTomodes"></a> 5.3。代表到模式</h3>
<div class="paragraph">
<p><code>@DelegatesTo</code>支持多种模式，我们将在本节中通过示例进行描述。</p>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Simpledelegation"><a class="anchor" href="#TheDelegatesToannotation-Simpledelegation"></a> 5.3.1。简单委托</h4>
<div class="paragraph">
<p>在这种模式下，唯一的强制性参数是表明我们委托调用哪个类的<em>值</em> 。而已。我们告诉编译器委托的类型将<strong>始终</strong>为<code>@DelegatesTo</code> （请注意，它可以是子类，但是如果是，则由子类定义的方法对类型检查器将不可见）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void body(@DelegatesTo(BodySpec) Closure cl) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Delegationstrategy"><a class="anchor" href="#TheDelegatesToannotation-Delegationstrategy"></a> 5.3.2。授权策略</h4>
<div class="paragraph">
<p>在这种模式下，您必须同时指定委托类<strong>和</strong>委托策略。如果不会使用默认的委派策略调用闭包，则必须使用此方法<code>Closure.OWNER_FIRST</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void body(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=BodySpec) Closure cl) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Delegatetoparameter"><a class="anchor" href="#TheDelegatesToannotation-Delegatetoparameter"></a> 5.3.3。委托给参数</h4>
<div class="paragraph">
<p>在这个变体中，我们将告诉编译器我们将委托给该方法的另一个参数。采取以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def exec(Object target, Closure code) {
   def clone = code.rehydrate(target, this, this)
   clone()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此，将<strong>不会</strong>在内部创建要使用的委托<code>exec</code>方法。实际上，我们接受了该方法的参数并委托给它。用法可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def email = new Email()
exec(email) {
   from '...'
   to '...'
   send()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个方法调用都委托给<code>email</code>参数。这是一种广泛使用的模式，也受到以下方面的支持<code>@DelegatesTo</code>使用伴随注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def exec(@DelegatesTo.Target Object target, @DelegatesTo Closure code) {
   def clone = code.rehydrate(target, this, this)
   clone()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>闭包带有注释<code>@DelegatesTo</code> ，但这一次，未指定任何类。相反，我们用<code>@DelegatesTo.Target</code> 。然后在编译时确定委托的类型。可以认为我们使用的是参数类型，在这种情况下<code>Object</code>但是这是错误的。采取以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Greeter {
   void sayHello() { println 'Hello' }
}
def greeter = new Greeter()
exec(greeter) {
   sayHello()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，这是开箱即用的， <strong>无需</strong>注释<code>@DelegatesTo</code> 。但是，要使IDE知道委托类型或<strong>类型检查器</strong> ，我们需要添加<code>@DelegatesTo</code> 。在这种情况下，它将知道<code>Greeter</code>变量是类型<code>Greeter</code> ，因此<strong>即使exec方法未明确定义Greeter类型的目标</strong> ，它也不会报告<em>sayHello</em>方法的错误。这是一项非常强大的功能，因为它阻止您编写同一版本的多个版本<code>exec</code>不同接收器类型的方法！</p>
</div>
<div class="paragraph">
<p>在此模式下， <code>@DelegatesTo</code>注释还支持<code>strategy</code>我们已经在上面描述的参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Multipleclosures"><a class="anchor" href="#TheDelegatesToannotation-Multipleclosures"></a> 5.3.4。多重关闭</h4>
<div class="paragraph">
<p>在上一个示例中， <code>exec</code>方法仅接受一个闭包，但是您可能具有采用多个闭包的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void fooBarBaz(Closure foo, Closure bar, Closure baz) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，没有什么可以阻止您使用<code>@DelegatesTo</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo { void foo(String msg) { println "Foo ${msg}!" } }
class Bar { void bar(int x) { println "Bar ${x}!" } }
class Baz { void baz(Date d) { println "Baz ${d}!" } }

void fooBarBaz(@DelegatesTo(Foo) Closure foo, @DelegatesTo(Bar) Closure bar, @DelegatesTo(Baz) Closure baz) {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但更重要的是，如果您有多个闭包<strong>和</strong>多个参数，则可以使用多个目标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void fooBarBaz(
    @DelegatesTo.Target('foo') foo,
    @DelegatesTo.Target('bar') bar,
    @DelegatesTo.Target('baz') baz,

    @DelegatesTo(target='foo') Closure cl1,
    @DelegatesTo(target='bar') Closure cl2,
    @DelegatesTo(target='baz') Closure cl3) {
    cl1.rehydrate(foo, this, this).call()
    cl2.rehydrate(bar, this, this).call()
    cl3.rehydrate(baz, this, this).call()
}

def a = new Foo()
def b = new Bar()
def c = new Baz()
fooBarBaz(
    a, b, c,
    { foo('Hello') },
    { bar(123) },
    { baz(new Date()) }
)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此时，您可能想知道为什么我们不使用参数名称作为引用。原因是信息（参数名称）并非总是可用（这是仅调试信息），因此这是JVM的局限性。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_delegating_to_a_generic_type"><a class="anchor" href="#_delegating_to_a_generic_type"></a> 5.3.5。委托给泛型类型</h4>
<div class="paragraph">
<p>在某些情况下，指示IDE或编译器委托类型将不是参数而是泛型是很有意思的。想象一下一个运行在元素列表上的配置器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public &lt;T&gt; void configure(List&lt;T&gt; elements, Closure configuration) {
   elements.each { e-&gt;
      def clone = configuration.rehydrate(e, this, this)
      clone.resolveStrategy = Closure.DELEGATE_FIRST
      clone.call()
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以使用以下任何列表调用此方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.transform.ToString
class Realm {
   String name
}
List&lt;Realm&gt; list = []
3.times { list &lt;&lt; new Realm() }
configure(list) {
   name = 'My Realm'
}
assert list.every { it.name == 'My Realm' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>让类型检查器和IDE知道<code>configure</code>方法调用列表中每个元素的闭包，您需要使用<code>@DelegatesTo</code>不同地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public &lt;T&gt; void configure(
    @DelegatesTo.Target List&lt;T&gt; elements,
    @DelegatesTo(strategy=Closure.DELEGATE_FIRST, genericTypeIndex=0) Closure configuration) {
   def clone = configuration.rehydrate(e, this, this)
   clone.resolveStrategy = Closure.DELEGATE_FIRST
   clone.call()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@DelegatesTo</code>需要一个可选的<code>genericTypeIndex</code>告诉将用作委托类型的泛型类型的索引的参数。这<strong>必须</strong>与<code>@DelegatesTo.Target</code>索引从0开始。在上面的示例中，这意味着将根据<code>List<T></code> ，并且由于索引0处的通用类型为<code>T</code>并推断为<code>Realm</code> ，类型检查器推断委托类型将是类型<code>Realm</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们正在使用<code>genericTypeIndex</code>而不是占位符（ <code>T</code> ），因为JVM的限制。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_delegating_to_an_arbitrary_type"><a class="anchor" href="#_delegating_to_an_arbitrary_type"></a> 5.3.6。委派给任意类型</h4>
<div class="paragraph">
<p>上面的选项都可能无法代表您要委派的类型。例如，让我们定义一个映射器类，该类用一个对象进行参数化，并定义一个映射方法，该方法返回另一种类型的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Mapper&lt;T,U&gt; {                             <i class="conum" data-value="1"></i><b>(1)</b>
    final T value                               <i class="conum" data-value="2"></i><b>(2)</b>
    Mapper(T value) { this.value = value }
    U map(Closure&lt;U&gt; producer) {                <i class="conum" data-value="3"></i><b>(3)</b>
        producer.delegate = value
        producer()
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>映射器类接受两个通用类型参数：源类型和目标类型</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>源对象存储在最终字段中</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>的<code>map</code>方法要求将源对象转换为目标对象</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如您所见，方法签名来自<code>map</code>没有提供有关闭包将操纵哪个对象的任何信息。阅读方法主体，我们知道它将是<code>value</code>这是哪种类型<code>T</code> ，但是<code>T</code>在方法签名中找不到，因此我们面临的情况是： <code>@DelegatesTo</code>适合。例如，如果我们尝试静态编译此代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def mapper = new Mapper&lt;String,Integer&gt;('Hello')
assert mapper.map { length() } == 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，编译器将失败并显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Static type checking] - Cannot find matching method TestScript0#length()</pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，您可以使用<code>type</code>的成员<code>@DelegatesTo</code>注释以供参考<code>T</code>作为类型标记：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Mapper&lt;T,U&gt; {
    final T value
    Mapper(T value) { this.value = value }
    U map(@DelegatesTo(type="T") Closure&lt;U&gt; producer) {  <i class="conum" data-value="1"></i><b>(1)</b>
        producer.delegate = value
        producer()
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@DelegatesTo</code>批注引用方法签名中找不到的通用类型</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，您不仅限于通用类型标记。的<code>type</code>成员可用于表示复杂类型，例如<code>List<T></code>要么<code>Map<T,List<U>></code> 。不得已时应使用该类型的原因是，仅当类型检查器发现使用以下类型时才检查类型<code>@DelegatesTo</code> ，而不是在注释方法本身被编译时。这意味着只能在呼叫现场确保类型安全。此外，编译速度会较慢（尽管在大多数情况下可能并不明显）。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="compilation-customizers"><a class="anchor" href="#compilation-customizers"></a> 6。编译定制器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction"><a class="anchor" href="#_introduction"></a> 6.1。介绍</h3>
<div class="paragraph">
<p>是否使用<code>groovyc</code>编译类或<code>GroovyShell</code>例如，为了执行脚本，在后台使用了<em>编译器配置</em> 。此配置保存诸如源编码或类路径之类的信息，但它还可用于执行更多操作，例如默认情况下添加导入，透明地应用AST转换或禁用全局AST转换。</p>
</div>
<div class="paragraph">
<p>编译定制器的目标是使这些常见任务易于实现。为此， <code>CompilerConfiguration</code>类是切入点。通用模式将始终基于以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.control.CompilerConfiguration
// create a configuration
def config = new CompilerConfiguration()
// tweak the configuration
config.addCompilationCustomizers(...)
// run your script
def shell = new GroovyShell(config)
shell.evaluate(script)</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译定制器必须扩展<em>org.codehaus.groovy.control.customizers。CompilationCustomizer</em>类。定制程序可以工作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在特定的编译阶段</p>
</li>
<li>
<p>在<em>每个</em>要编译的类节点上</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以实现自己的编译定制器，但是Groovy包含一些最常见的操作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_import_customizer"><a class="anchor" href="#_import_customizer"></a> 6.2。导入定制器</h3>
<div class="paragraph">
<p>使用此编译定制器，您的代码将透明地添加导入。这对于实现DSL的脚本特别有用，在脚本中您希望避免用户不得不编写导入文件。导入定制器将允许您添加Groovy语言允许的所有导入变体，即：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类导入，可以选择别名</p>
</li>
<li>
<p>明星进口</p>
</li>
<li>
<p>静态导入，可以选择别名</p>
</li>
<li>
<p>静态星进口</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.control.customizers.ImportCustomizer

def icz = new ImportCustomizer()
// "normal" import
icz.addImports('java.util.concurrent.atomic.AtomicInteger', 'java.util.concurrent.ConcurrentHashMap')
// "aliases" import
icz.addImport('CHM', 'java.util.concurrent.ConcurrentHashMap')
// "static" import
icz.addStaticImport('java.lang.Math', 'PI') // import static java.lang.Math.PI
// "aliased static" import
icz.addStaticImport('pi', 'java.lang.Math', 'PI') // import static java.lang.Math.PI as pi
// "star" import
icz.addStarImports 'java.util.concurrent' // import java.util.concurrent.*
// "static star" import
icz.addStaticStars 'java.lang.Math' // import static java.lang.Math.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/control/customizers/ImportCustomizer.html">org.codehaus.groovy.control.customizers中找到所有快捷方式的详细说明</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/control/customizers/ImportCustomizer.html">。ImportCustomizer</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_ast_transformation_customizer"><a class="anchor" href="#_ast_transformation_customizer"></a> 6.3。AST转换定制器</h3>
<div class="paragraph">
<p>AST转换定制器旨在透明地应用AST转换。全局AST转换不像只要在classpath上找到的转换就适用于编译的每个类上的蜜蜂（它具有诸如由于不应该进行转换而增加编译时间或副作用之类的缺点）的功能，定制程序将允许您有选择地应用仅针对特定脚本或类的转换。</p>
</div>
<div class="paragraph">
<p>例如，假设您希望能够使用<code>@Log</code>在脚本中。问题是<code>@Log</code>通常用于类节点，根据定义，脚本不需要一个。但是从实现的角度来看，脚本是类，只是无法用以下方式注释此隐式类节点<code>@Log</code> 。使用AST定制器，您可以采用一种解决方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import groovy.util.logging.Log

def acz = new ASTTransformationCustomizer(Log)
config.addCompilationCustomizers(acz)</code></pre>
</div>
</div>
<div class="paragraph">
<p>就这样！在内部， <code>@Log</code> AST转换应用于编译单元中的每个类节点。这意味着它将应用于脚本，但也将应用于脚本中定义的类。</p>
</div>
<div class="paragraph">
<p>如果正在使用的AST转换接受参数，则也可以在构造函数中使用参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def acz = new ASTTransformationCustomizer(Log, value: 'LOGGER')
// use name 'LOGGER' instead of the default 'log'
config.addCompilationCustomizers(acz)</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于AST转换定制器使用对象而不是AST节点，因此并非所有值都可以转换为AST转换参数。例如，原始类型被转换为<code>ConstantExpression</code> （那是<code>LOGGER</code>转换为<code>new ConstantExpression('LOGGER')</code> ，但是如果您的AST转换将闭包作为参数，则必须给它一个<code>ClosureExpression</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def configuration = new CompilerConfiguration()
def expression = new AstBuilder().buildFromCode(CompilePhase.CONVERSION) { -&gt; true }.expression[0]
def customizer = new ASTTransformationCustomizer(ConditionalInterrupt, value: expression, thrown: SecurityException)
configuration.addCompilationCustomizers(customizer)
def shell = new GroovyShell(configuration)
shouldFail(SecurityException) {
    shell.evaluate("""
        // equivalent to adding @ConditionalInterrupt(value={true}, thrown: SecurityException)
        class MyClass {
            void doIt() { }
        }
        new MyClass().doIt()
    """)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关选项的完整列表，请参考<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/control/customizers/ASTTransformationCustomizer.html">org.codehaus.groovy.control.customizers。ASTTransformationCustomizer</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_secure_ast_customizer"><a class="anchor" href="#_secure_ast_customizer"></a> 6.4。安全的AST定制器</h3>
<div class="paragraph">
<p>例如，此定制程序将允许DSL的开发人员限制语言的<strong>语法</strong> ，以防止用户使用某些构造。它仅在这种意义上是``安全的''，了解它<strong>不能</strong>代替安全管理器非常重要。它存在的唯一原因是限制语言的表现力。此定制器仅在AST（抽象语法树）级别上起作用，而在运行时不起作用！乍一看可能很奇怪，但是如果您将Groovy视为构建DSL的平台，那将更加有意义。您可能不希望用户手头有完整的语言。在下面的示例中，我们将使用仅允许算术运算的语言示例进行演示，但是此定制程序允许您执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>允许/禁止创建闭包</p>
</li>
<li>
<p>允许/禁止导入</p>
</li>
<li>
<p>允许/禁止包定义</p>
</li>
<li>
<p>允许/禁止方法定义</p>
</li>
<li>
<p>限制方法调用的接收者</p>
</li>
<li>
<p>限制用户可以使用的AST表达式的种类</p>
</li>
<li>
<p>限制用户可以使用的令牌（语法上）</p>
</li>
<li>
<p>限制可以在代码中使用的常量的类型</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于所有这些功能，安全的AST定制器都可以使用白名单（允许的元素列表） <strong>或</strong>黑名单（不允许的元素列表）工作。对于每种类型的功能（导入，令牌等），您可以选择使用白名单或黑名单，但是您可以将白名单和黑名单混合用于不同的功能。通常，您将选择白名单（全部禁止，允许选中）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.control.customizers.SecureASTCustomizer
import static org.codehaus.groovy.syntax.Types.* <i class="conum" data-value="1"></i><b>(1)</b>

def scz = new SecureASTCustomizer()
scz.with {
    closuresAllowed = false // user will not be able to write closures
    methodDefinitionAllowed = false // user will not be able to define methods
    importsWhitelist = [] // empty whitelist means imports are disallowed
    staticImportsWhitelist = [] // same for static imports
    staticStarImportsWhitelist = ['java.lang.Math'] // only java.lang.Math is allowed
    // the list of tokens the user can find
    // constants are defined in org.codehaus.groovy.syntax.Types
    tokensWhitelist = [ <i class="conum" data-value="1"></i><b>(1)</b>
            PLUS,
            MINUS,
            MULTIPLY,
            DIVIDE,
            MOD,
            POWER,
            PLUS_PLUS,
            MINUS_MINUS,
            COMPARE_EQUAL,
            COMPARE_NOT_EQUAL,
            COMPARE_LESS_THAN,
            COMPARE_LESS_THAN_EQUAL,
            COMPARE_GREATER_THAN,
            COMPARE_GREATER_THAN_EQUAL,
    ].asImmutable()
    // limit the types of constants that a user can define to number types only
    constantTypesClassesWhiteList = [ <i class="conum" data-value="2"></i><b>(2)</b>
            Integer,
            Float,
            Long,
            Double,
            BigDecimal,
            Integer.TYPE,
            Long.TYPE,
            Float.TYPE,
            Double.TYPE
    ].asImmutable()
    // method calls are only allowed if the receiver is of one of those types
    // be careful, it's not a runtime type!
    receiversClassesWhiteList = [ <i class="conum" data-value="2"></i><b>(2)</b>
            Math,
            Integer,
            Float,
            Double,
            Long,
            BigDecimal
    ].asImmutable()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用于<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/syntax/Types.html">org.codehaus.groovy.syntax中的令牌类型</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/syntax/Types.html">。种类</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>你可以在这里使用类文字</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果安全的AST定制器提供的功能不足以满足您的需求，那么在创建自己的编译定制器之前，您可能会对AST定制器支持的表达式和语句检查器感兴趣。基本上，它允许您在AST树，表达式（表达式检查器）或语句（语句检查器）上添加自定义检查。为此，您必须实施<code>org.codehaus.groovy.control.customizers.SecureASTCustomizer.StatementChecker</code>要么<code>org.codehaus.groovy.control.customizers.SecureASTCustomizer.ExpressionChecker</code> 。</p>
</div>
<div class="paragraph">
<p>这些接口定义了一个称为<code>isAuthorized</code> ，返回一个布尔值，然后取一个<code>Statement</code> （要么<code>Expression</code> ）作为参数。它使您可以对表达式或语句执行复杂的逻辑，以判断是否允许用户执行该操作。</p>
</div>
<div class="paragraph">
<p>例如，定制器中没有预定义的配置标志，这将使您阻止人们使用属性表达式。使用自定义检查器，这很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def scz = new SecureASTCustomizer()
def checker = { expr -&gt;
    !(expr instanceof AttributeExpression)
} as SecureASTCustomizer.ExpressionChecker
scz.addExpressionCheckers(checker)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以通过评估一个简单的脚本来确保此方法有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">new GroovyShell(config).evaluate '''
    class A {
        int val
    }

    def a = new A(val: 123)
    a.@val <i class="conum" data-value="1"></i><b>(1)</b>
'''</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>编译失败</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/StatementChecker.html">org.codehaus.groovy.control.customizers检查</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/StatementChecker.html">语句。SecureASTCustomizer。可以使用</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/ExpressionChecker.html">org.codehaus.groovy.control.customizers检查StatementChecker</a>表达式<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/ExpressionChecker.html">。SecureASTCustomizer。ExpressionChecker</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_source_aware_customizer"><a class="anchor" href="#_source_aware_customizer"></a> 6.5。知道源代码的定制器</h3>
<div class="paragraph">
<p>该定制器可以用作其他定制器上的过滤器。在这种情况下，过滤器是<code>org.codehaus.groovy.control.SourceUnit</code> 。为此，源感知型定制器将另一个定制器作为委托，并且仅当源单元上的谓词匹配时，才会应用该委托的定制。</p>
</div>
<div class="paragraph">
<p><code>SourceUnit</code>使您可以访问多种内容，尤其是正在编译的文件（当然，如果是从文件进行编译）。例如，它使您有可能根据文件名执行操作。这是创建源感知型定制器的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.control.customizers.SourceAwareCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

def delegate = new ImportCustomizer()
def sac = new SourceAwareCustomizer(delegate)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以在可识别源代码的定制器上使用谓词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// the customizer will only be applied to classes contained in a file name ending with 'Bean'
sac.baseNameValidator = { baseName -&gt;
    baseName.endsWith 'Bean'
}

// the customizer will only be applied to files which extension is '.spec'
sac.extensionValidator = { ext -&gt; ext == 'spec' }

// source unit validation
// allow compilation only if the file contains at most 1 class
sac.sourceUnitValidator = { SourceUnit sourceUnit -&gt; sourceUnit.AST.classes.size() == 1 }

// class validation
// the customizer will only be applied to classes ending with 'Bean'
sac.classValidator = { ClassNode cn -&gt; cn.endsWith('Bean') }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customizer_builder"><a class="anchor" href="#_customizer_builder"></a> 6.6。定制器构建器</h3>
<div class="paragraph">
<p>如果您正在Groovy代码中使用编译定制器（如上述示例），则可以使用其他语法来定制编译。建设者（ <code>org.codehaus.groovy.control.customizers.builder.CompilerCustomizationBuilder</code> ）简化了使用分层DSL创建定制器的过程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.control.CompilerConfiguration
import static org.codehaus.groovy.control.customizers.builder.CompilerCustomizationBuilder.withConfig <i class="conum" data-value="1"></i><b>(1)</b>

def conf = new CompilerConfiguration()
withConfig(conf) {
    // ... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>静态导入builder方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>配置在这里</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>上面的代码示例显示了如何使用构建器。静态方法<em>withConfig</em> ，采用与构建器代码相对应的闭包，并自动将编译定制器注册到该配置。分发中可用的每个编译定制器都可以通过以下方式配置：</p>
</div>
<div class="sect3">
<h4 id="_import_customizer_2"><a class="anchor" href="#_import_customizer_2"></a> 6.6.1。导入定制器</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withConfig(configuration) {
   imports { // imports customizer
      normal 'my.package.MyClass' // a normal import
      alias 'AI', 'java.util.concurrent.atomic.AtomicInteger' // an aliased import
      star 'java.util.concurrent' // star imports
      staticMember 'java.lang.Math', 'PI' // static import
      staticMember 'pi', 'java.lang.Math', 'PI' // aliased static import
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ast_transformation_customizer_2"><a class="anchor" href="#_ast_transformation_customizer_2"></a> 6.6.2。AST转换定制器</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withConfig(conf) {
   ast(Log) <i class="conum" data-value="1"></i><b>(1)</b>
}

withConfig(conf) {
   ast(Log, value: 'LOGGER') <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>透明地应用@Log</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>为记录器应用@Log用不同的名称</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_secure_ast_customizer_2"><a class="anchor" href="#_secure_ast_customizer_2"></a> 6.6.3。安全的AST定制器</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withConfig(conf) {
   secureAst {
       closuresAllowed = false
       methodDefinitionAllowed = false
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_source_aware_customizer_2"><a class="anchor" href="#_source_aware_customizer_2"></a> 6.6.4。知道源代码的定制器</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withConfig(configuration){
    source(extension: 'sgroovy') {
        ast(CompileStatic) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

withConfig(configuration){
    source(extensions: ['sgroovy','sg']) {
        ast(CompileStatic) <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

withConfig(configuration) {
    source(extensionValidator: { it.name in ['sgroovy','sg']}) {
        ast(CompileStatic) <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

withConfig(configuration) {
    source(basename: 'foo') {
        ast(CompileStatic) <i class="conum" data-value="3"></i><b>(3)</b>
    }
}

withConfig(configuration) {
    source(basenames: ['foo', 'bar']) {
        ast(CompileStatic) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}

withConfig(configuration) {
    source(basenameValidator: { it in ['foo', 'bar'] }) {
        ast(CompileStatic) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}

withConfig(configuration) {
    source(unitValidator: { unit -&gt; !unit.AST.classes.any { it.name == 'Baz' } }) {
        ast(CompileStatic) <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在.sgroovy文件上应用CompileStatic AST批注</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在.sgroovy或.sg文件上应用CompileStatic AST批注</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在名称为“ foo”的文件上应用CompileStatic AST批注</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>在名称为“ foo”或“ bar”的文件上应用CompileStatic AST批注</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>在不包含名为“ Baz”的类的文件上应用CompileStatic AST批注</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_inlining_a_customizer"><a class="anchor" href="#_inlining_a_customizer"></a> 6.6.5。内联定制器</h4>
<div class="paragraph">
<p>内联定制器允许您直接编写编译定制器，而无需为其创建类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withConfig(configuration) {
    inline(phase:'CONVERSION') { source, context, classNode -&gt;  <i class="conum" data-value="1"></i><b>(1)</b>
        println "visiting $classNode"                           <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个内联的定制器，它将在CONVERSION阶段执行</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>打印正在编译的类节点的名称</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_customizers"><a class="anchor" href="#_multiple_customizers"></a> 6.6.6。多个定制器</h4>
<div class="paragraph">
<p>当然，构建器允许您一次定义多个定制器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withConfig(configuration) {
   ast(ToString)
   ast(EqualsAndHashCode)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_config_script_flag"><a class="anchor" href="#_config_script_flag"></a> 6.7。配置脚本标志</h3>
<div class="paragraph">
<p>到目前为止，我们已经描述了如何使用<code>CompilationConfiguration</code>类，但是只有在您嵌入Groovy并创建自己的实例时才有可能<code>CompilerConfiguration</code> （然后使用它来创建一个<code>GroovyShell</code> ， <code>GroovyScriptEngine</code> ，…）。</p>
</div>
<div class="paragraph">
<p>如果您希望将其应用于通过常规Groovy编译器编译的类（也就是说，使用<code>groovyc</code> ， <code>ant</code>要么<code>gradle</code> （例如），可以使用名为<code>configscript</code>它采用Groovy配置脚本作为参数。</p>
</div>
<div class="paragraph">
<p>该脚本可让您访问<code>CompilerConfiguration</code>编译文件<strong>之前</strong>的实例（作为名为的变量暴露在配置脚本中） <code>configuration</code> ），以便您可以对其进行调整。</p>
</div>
<div class="paragraph">
<p>它还透明地集成了上面的编译器配置构建器。作为示例，让我们看看如何默认情况下在所有类上激活静态编译。</p>
</div>
<div class="sect3">
<h4 id="_static_compilation_by_default"><a class="anchor" href="#_static_compilation_by_default"></a> 6.7.1。默认情况下静态编译</h4>
<div class="paragraph">
<p>通常，Groovy中的类是使用动态运行时进行编译的。您可以通过放置一个名为的注释来激活静态编译<code>@CompileStatic</code>在任何班上。有些人希望默认启用此模式，也就是说不必注释类。使用<code>configscript</code> ， 这个有可能。首先，您需要创建一个名为<code>config.groovy</code>进入<code>src/conf</code>具有以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">withConfig(configuration) { <i class="conum" data-value="1"></i><b>(1)</b>
   ast(groovy.transform.CompileStatic)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><em>配置</em>引用一个<code>CompilerConfiguration</code>实例</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这实际上就是您所需要的。您不必导入构建器，它会自动在脚本中公开。然后，使用以下命令行编译文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>groovyc -configscript src/conf/config.groovy src/main/groovy/MyClass.groovy</pre>
</div>
</div>
<div class="paragraph">
<p>我们强烈建议您将配置文件与类分开，因此为什么我们建议使用<code>src/main</code>和<code>src/conf</code>上面的目录。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ast_transformations"><a class="anchor" href="#_ast_transformations"></a> 6.8。AST转换</h3>
<div class="paragraph">
<p>如果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>运行时元编程不允许您做您想做的事</p>
</li>
<li>
<p>您需要提高DSL执行的性能</p>
</li>
<li>
<p>您想利用与Groovy相同的语法，但具有不同的语义</p>
</li>
<li>
<p>您想改善对DSL中类型检查的支持</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，AST转换是必经之路。与迄今为止使用的技术不同，AST转换用于在编译为字节码之前更改或生成代码。AST转换能够在编译时添加新方法，或者根据您的需要完全更改方法的主体。它们是一个非常强大的工具，但代价是不容易编写。有关AST转换的更多信息，请参见本手册的<a href="http://docs.groovy-lang.org/latest/html/documentation/index.html#_compile_time_metaprogramming">编译时元编程</a>部分。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_custom_type_checking_extensions"><a class="anchor" href="#_custom_type_checking_extensions"></a> 7。自定义类型检查扩展</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在某些情况下，尽快向用户提供有关错误代码的反馈（即在编译DSL脚本时），而不必等待脚本的执行，可能会很有趣。但是，使用动态代码通常不可行。Groovy实际上提供了一种称为<a href="type-checking-extensions.html">类型检查扩展</a>的实用答案。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_builders"><a class="anchor" href="#_builders"></a> 8。建筑商</h2>
<div class="sectionbody">
<div class="paragraph">
<p>（待定）</p>
</div>
<div class="sect2">
<h3 id="_creating_a_builder"><a class="anchor" href="#_creating_a_builder"></a> 8.1。创建一个生成器</h3>
<div class="paragraph">
<p>（待定）</p>
</div>
<div class="sect3">
<h4 id="_buildersupport"><a class="anchor" href="#_buildersupport"></a> 8.1.1。Builder支持</h4>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
<div class="sect3">
<h4 id="_factorybuildersupport"><a class="anchor" href="#_factorybuildersupport"></a> 8.1.2。FactoryBuilder支持</h4>
<div class="paragraph">
<p>（待定）</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_existing_builders"><a class="anchor" href="#_existing_builders"></a> 8.2。现有的建设者</h3>
<div class="paragraph">
<p>（待定）</p>
</div>
<div class="sect3">
<h4 id="_markupbuilder"><a class="anchor" href="#_markupbuilder"></a> 8.2.1。标记生成器</h4>
<div class="paragraph">
<p>请参阅<a href="#_markupbuilder">创建Xml-MarkupBuilder</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_streamingmarkupbuilder"><a class="anchor" href="#_streamingmarkupbuilder"></a> 8.2.2。StreamingMarkupBuilder</h4>
<div class="paragraph">
<p>请参阅<a href="#_streamingmarkupbuilder">创建Xml-StreamingMarkupBuilder</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_saxbuilder"><a class="anchor" href="#_saxbuilder"></a> 8.2.3。SaxBuilder</h4>
<div class="paragraph">
<p>用于生成<a href="https://en.wikipedia.org/wiki/Simple_API_for_XML">XML的简单API（SAX）</a>事件的生成器。</p>
</div>
<div class="paragraph">
<p>如果您具有以下SAX处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class LogHandler extends org.xml.sax.helpers.DefaultHandler {

    String log = ''

    void startElement(String uri, String localName, String qName, org.xml.sax.Attributes attributes) {
        log += "Start Element: $localName, "
    }

    void endElement(String uri, String localName, String qName) {
        log += "End Element: $localName, "
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>SaxBuilder</code>为处理程序生成SAX事件，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def handler = new LogHandler()
def builder = new groovy.xml.SAXBuilder(handler)

builder.root() {
    helloWorld()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后检查一切是否按预期工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert handler.log == 'Start Element: root, Start Element: helloWorld, End Element: helloWorld, End Element: root, '</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_staxbuilder"><a class="anchor" href="#_staxbuilder"></a> 8.2.4。StaxBuilder</h4>
<div class="paragraph">
<p>与<a href="http://en.wikipedia.org/wiki/StAX">XML的Streaming API（StAX）</a>处理器一起使用的Groovy构建器。</p>
</div>
<div class="paragraph">
<p>这是一个使用Java的StAX实现生成XML的简单示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def factory = javax.xml.stream.XMLOutputFactory.newInstance()
def writer = new StringWriter()
def builder = new groovy.xml.StaxBuilder(factory.createXMLStreamWriter(writer))

builder.root(attribute:1) {
    elem1('hello')
    elem2('world')
}

assert writer.toString() == '&lt;?xml version="1.0" ?&gt;&lt;root attribute="1"&gt;&lt;elem1&gt;hello&lt;/elem1&gt;&lt;elem2&gt;world&lt;/elem2&gt;&lt;/root&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用<a href="https://github.com/jettison-json/jettison">Jettison之</a>类的外部库，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Grab('org.codehaus.jettison:jettison:1.3.3')
@GrabExclude('stax:stax-api') // part of Java 6 and later
import org.codehaus.jettison.mapped.*

def writer = new StringWriter()
def mappedWriter = new MappedXMLStreamWriter(new MappedNamespaceConvention(), writer)
def builder = new groovy.xml.StaxBuilder(mappedWriter)

builder.root(attribute:1) {
     elem1('hello')
     elem2('world')
}

assert writer.toString() == '{"root":{"@attribute":"1","elem1":"hello","elem2":"world"}}'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dombuilder"><a class="anchor" href="#_dombuilder"></a> 8.2.5。DOMBuilder</h4>
<div class="paragraph">
<p>用于将HTML，XHTML和XML解析为<a href="https://en.wikipedia.org/wiki/Document_Object_Model">W3C DOM</a>树的构建器。</p>
</div>
<div class="paragraph">
<p>例如这个XML <code>String</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String recordsXML = '''
    &lt;records&gt;
      &lt;car name='HSV Maloo' make='Holden' year='2006'&gt;
        &lt;country&gt;Australia&lt;/country&gt;
        &lt;record type='speed'&gt;Production Pickup Truck with speed of 271kph&lt;/record&gt;
      &lt;/car&gt;
      &lt;car name='P50' make='Peel' year='1962'&gt;
        &lt;country&gt;Isle of Man&lt;/country&gt;
        &lt;record type='size'&gt;Smallest Street-Legal Car at 99cm wide and 59 kg in weight&lt;/record&gt;
      &lt;/car&gt;
      &lt;car name='Royale' make='Bugatti' year='1931'&gt;
        &lt;country&gt;France&lt;/country&gt;
        &lt;record type='price'&gt;Most Valuable Car at $15 million&lt;/record&gt;
      &lt;/car&gt;
    &lt;/records&gt;'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用<code>DOMBuilder</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def reader = new StringReader(recordsXML)
def doc = groovy.xml.DOMBuilder.parse(reader)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后进一步处理，例如通过使用<a href="#_domcategory">DOMCategory</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def records = doc.documentElement
use(groovy.xml.dom.DOMCategory) {
    assert records.car.size() == 3
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_nodebuilder"><a class="anchor" href="#_nodebuilder"></a> 8.2.6。节点构建器</h4>
<div class="paragraph">
<p><code>NodeBuilder</code>用于创建<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/Node.html">Node</a>对象的嵌套树以处理任意数据。要创建简单的用户列表，请使用<code>NodeBuilder</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nodeBuilder = new NodeBuilder()
def userlist = nodeBuilder.userlist {
    user(id: '1', firstname: 'John', lastname: 'Smith') {
        address(type: 'home', street: '1 Main St.', city: 'Springfield', state: 'MA', zip: '12345')
        address(type: 'work', street: '2 South St.', city: 'Boston', state: 'MA', zip: '98765')
    }
    user(id: '2', firstname: 'Alice', lastname: 'Doe')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您可以进一步处理数据，例如通过使用<a href="#gpath_expressions">GPath表达式</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert userlist.user.@firstname.join(', ') == 'John, Alice'
assert userlist.user.find { it.@lastname == 'Smith' }.address.size() == 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jsonbuilder"><a class="anchor" href="#_jsonbuilder"></a> 8.2.7。JsonBuilder</h4>
<div class="paragraph">
<p>Groovy的<code>JsonBuilder</code>使创建Json变得容易。例如，创建以下Json字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String carRecords = '''
    {
        "records": {
        "car": {
            "name": "HSV Maloo",
            "make": "Holden",
            "year": 2006,
            "country": "Australia",
            "record": {
              "type": "speed",
              "description": "production pickup truck with speed of 271kph"
            }
          }
      }
    }
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用<code>JsonBuilder</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">JsonBuilder builder = new JsonBuilder()
builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}
String json = JsonOutput.prettyPrint(builder.toString())</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用<a href="https://github.com/lukas-krecan/JsonUnit">JsonUnit</a>来检查生成器是否产生了预期的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">JsonAssert.assertJsonEquals(json, carRecords)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要自定义生成的输出，则可以传递一个<code>JsonGenerator</code>创建一个实例<code>JsonBuilder</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.json.*

def generator = new JsonGenerator.Options()
        .excludeNulls()
        .excludeFieldsByName('make', 'country', 'record')
        .excludeFieldsByType(Number)
        .addConverter(URL) { url -&gt; "http://groovy-lang.org" }
        .build()

JsonBuilder builder = new JsonBuilder(generator)
builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        homepage new URL('http://example.org')
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}

assert builder.toString() == '{"records":{"car":{"name":"HSV Maloo","homepage":"http://groovy-lang.org"}}}'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_streamingjsonbuilder"><a class="anchor" href="#_streamingjsonbuilder"></a> 8.2.8。流JsonBuilder</h4>
<div class="paragraph">
<p>不像<code>JsonBuilder</code>它会在内存中创建一个数据结构，这在需要在输出之前以编程方式更改结构的情况下非常方便， <code>StreamingJsonBuilder</code>无需任何中间存储器数据结构即可直接流式传输到写入器。如果您不需要修改结构并希望使用内存效率更高的方法，请使用<code>StreamingJsonBuilder</code> 。</p>
</div>
<div class="paragraph">
<p>的用法<code>StreamingJsonBuilder</code>类似于<code>JsonBuilder</code> 。为了创建此Json字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String carRecords = '''
    {
        "records": {
        "car": {
            "name": "HSV Maloo",
            "make": "Holden",
            "year": 2006,
            "country": "Australia",
            "record": {
              "type": "speed",
              "description": "production pickup truck with speed of 271kph"
            }
          }
      }
    }
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>你用一个<code>StreamingJsonBuilder</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">StringWriter writer = new StringWriter()
StreamingJsonBuilder builder = new StreamingJsonBuilder(writer)
builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}
String json = JsonOutput.prettyPrint(writer.toString())</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用<a href="https://github.com/lukas-krecan/JsonUnit">JsonUnit</a>检查预期结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">JsonAssert.assertJsonEquals(json, carRecords)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要自定义生成的输出，则可以传递一个<code>JsonGenerator</code>创建一个实例<code>StreamingJsonBuilder</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def generator = new JsonGenerator.Options()
        .excludeNulls()
        .excludeFieldsByName('make', 'country', 'record')
        .excludeFieldsByType(Number)
        .addConverter(URL) { url -&gt; "http://groovy-lang.org" }
        .build()

StringWriter writer = new StringWriter()
StreamingJsonBuilder builder = new StreamingJsonBuilder(writer, generator)

builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        homepage new URL('http://example.org')
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}

assert writer.toString() == '{"records":{"car":{"name":"HSV Maloo","homepage":"http://groovy-lang.org"}}}'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="swingbuilder"><a class="anchor" href="#swingbuilder"></a> 8.2.9。SwingBuilder</h4>
<div class="paragraph">
<p><code>SwingBuilder</code>允许您以声明性和简洁的方式创建完整的Swing GUI。它通过在Groovy中使用常见的习惯用法来实现这一目标。生成器会为您创建复杂对象的工作，例如实例化子代，调用Swing方法以及将这些子代附加到其父代。因此，您的代码更具可读性和可维护性，同时仍然允许您访问所有Swing组件。</p>
</div>
<div class="paragraph">
<p>这是使用的简单示例<code>SwingBuilder</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.swing.SwingBuilder
import java.awt.BorderLayout as BL

count = 0
new SwingBuilder().edt {
  frame(title: 'Frame', size: [300, 300], show: true) {
    borderLayout()
    textlabel = label(text: 'Click the button!', constraints: BL.NORTH)
    button(text:'Click Me',
         actionPerformed: {count++; textlabel.text = "Clicked ${count} time(s)."; println "clicked"}, constraints:BL.SOUTH)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是它的样子：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/SwingBuilder001.gif" alt="SwingBuilder001">
</div>
</div>
<div class="paragraph">
<p>通常，通过一系列重复的实例化，设置器来创建组件的这种层次结构，最后将该子级附加到其各自的父级。使用<code>SwingBuilder</code>但是，允许您以其本机形式定义此层次结构，这使接口设计只需阅读代码即可理解。</p>
</div>
<div class="paragraph">
<p>通过利用Groovy内置的许多编程功能（例如闭包，隐式构造函数调用，导入别名和字符串插值），可以实现此处显示的灵活性。当然，使用它们并不一定要完全理解它们<code>SwingBuilder</code> ;从上面的代码中可以看到，它们的用法很直观。</p>
</div>
<div class="paragraph">
<p>这是一个稍微复杂的示例，其中包括<code>SwingBuilder</code>通过闭包重新使用代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.swing.SwingBuilder
import javax.swing.*
import java.awt.*

def swing = new SwingBuilder()

def sharedPanel = {
     swing.panel() {
        label("Shared Panel")
    }
}

count = 0
swing.edt {
    frame(title: 'Frame', defaultCloseOperation: JFrame.EXIT_ON_CLOSE, pack: true, show: true) {
        vbox {
            textlabel = label('Click the button!')
            button(
                text: 'Click Me',
                actionPerformed: {
                    count++
                    textlabel.text = "Clicked ${count} time(s)."
                    println "Clicked!"
                }
            )
            widget(sharedPanel())
            widget(sharedPanel())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是依赖于可观察到的bean和绑定的另一个变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.swing.SwingBuilder
import groovy.beans.Bindable

class MyModel {
   @Bindable int count = 0
}

def model = new MyModel()
new SwingBuilder().edt {
  frame(title: 'Java Frame', size: [100, 100], locationRelativeTo: null, show: true) {
    gridLayout(cols: 1, rows: 2)
    label(text: bind(source: model, sourceProperty: 'count', converter: { v -&gt;  v? "Clicked $v times": ''}))
    button('Click me!', actionPerformed: { model.count++ })
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="core-metaprogramming.html#xform-Bindable">@Bindable</a>是AST转换的核心之一。它生成所有必需的样板代码，以将简单的bean变成可观察的代码。的<code>bind()</code>节点创建适当的<code>PropertyChangeListeners</code>只要有<code>PropertyChangeEvent</code>被解雇了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_antbuilder"><a class="anchor" href="#_antbuilder"></a> 8.2.10。蚂蚁建筑</h4>
<div class="paragraph">
<p>尽管<a href="http://ant.apache.org/">Apache Ant</a>主要是一个构建工具，但它却是一个非常实用的工具，用于处理文件，包括zip文件，副本，资源处理等。但是，如果您曾经使用过<code>build.xml</code>文件或某些<em>Jelly脚本</em> ，发现自己受到所有尖括号的限制，或者使用XML作为脚本语言发现它有点怪异，并且想要更简洁，更直接的方法，那么也许使用Groovy编写Ant脚本可能就是你所需要的之后。</p>
</div>
<div class="paragraph">
<p>Groovy有一个名为的帮助器类<code>AntBuilder</code>这使得Ant任务的脚本编写非常容易；允许将真正的脚本语言用于编程构造（变量，方法，循环，逻辑分支，类等）。看起来仍然像Ant的XML的简洁版本，没有那些尖括号。尽管您可以在脚本中混合并匹配此标记。Ant本身是jar文件的集合。通过将它们添加到您的类路径中，您可以轻松地在Groovy中直接使用它们。我们相信使用<code>AntBuilder</code>导致更简洁和易于理解的语法。</p>
</div>
<div class="paragraph">
<p><code>AntBuilder</code>使用我们在Groovy中习惯的便捷构建器符号直接公开Ant任务。这是最基本的示例，它在标准输出上打印一条消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ant = new AntBuilder()          <i class="conum" data-value="1"></i><b>(1)</b>
ant.echo('hello from Ant!')         <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个实例<code>AntBuilder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>执行<code>echo</code>参数中包含消息的任务</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>假设您需要创建一个ZIP文件。它可以很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ant = new AntBuilder()
ant.zip(destfile: 'sources.zip', basedir: 'src')</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一个示例中，我们演示了<code>AntBuilder</code>直接在Groovy中使用经典Ant模式复制文件列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// let's just call one task
ant.echo("hello")

// here is an example of a block of Ant inside GroovyMarkup
ant.sequential {
    echo("inside sequential")
    def myDir = "target/AntTest/"
    mkdir(dir: myDir)
    copy(todir: myDir) {
        fileset(dir: "src/test") {
            include(name: "**/*.groovy")
        }
    }
    echo("done")
}

// now let's do some normal Groovy again
def file = new File(ant.project.baseDir,"target/AntTest/some/pkg/MyTest.groovy")
assert file.exists()</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个示例是遍历匹配特定模式的文件列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// let's create a scanner of filesets
def scanner = ant.fileScanner {
    fileset(dir:"src/test") {
        include(name:"**/My*.groovy")
    }
}

// now let's iterate over
def found = false
for (f in scanner) {
    println("Found file $f")
    found = true
    assert f instanceof File
    assert f.name.endsWith(".groovy")
}
assert found</code></pre>
</div>
</div>
<div class="paragraph">
<p>或执行JUnit测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">ant.junit {
    classpath { pathelement(path: '.') }
    test(name:'some.pkg.MyTest')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们甚至可以通过直接从Groovy编译并执行Java文件来进一步操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">ant.echo(file:'Temp.java', '''
    class Temp {
        public static void main(String[] args) {
            System.out.println("Hello");
        }
    }
''')
ant.javac(srcdir:'.', includes:'Temp.java', fork:'true')
ant.java(classpath:'.', classname:'Temp', fork:'true')
ant.echo('Done')</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得一提的是<code>AntBuilder</code>包含在<a href="http://gradle.org/">Gradle中</a> ，因此您可以像在Groovy中一样在Gradle中使用它。其他文档可以在<a href="http://gradle.org/docs/current/userguide/ant.html">Gradle手册中</a>找到。</p>
</div>
</div>
<div class="sect3">
<h4 id="_clibuilder"><a class="anchor" href="#_clibuilder"></a> 8.2.11。CliBuilder</h4>
<div class="paragraph">
<p><code>CliBuilder</code>提供了一种紧凑的方法来指定命令行应用程序的可用选项，然后根据该规范自动解析应用程序的命令行参数。按照惯例，在<em>选项</em>命令行参数和作为参数传递给应用程序的所有其余参数之间有区别。通常，可能支持几种类型的选项，例如<code>-V</code>要么<code>--tabsize=4</code> 。 <code>CliBuilder</code>消除了为命令行处理开发大量代码的负担。相反，它支持一种声明性的方法来声明您的选项，然后提供一个调用以使用简单的机制来查询选项来解析命令行参数（您可以将其视为选项的简单模型）。</p>
</div>
<div class="paragraph">
<p>即使您创建的每个命令行的细节可能大不相同，但每次都遵循相同的主要步骤。首先， <code>CliBuilder</code>实例已创建。然后，定义允许的命令行选项。可以使用<em>动态api</em>样式或<em>注释</em>样式来完成。然后根据选项规范来解析命令行参数，从而生成一组选项，然后对其进行查询。</p>
</div>
<div class="paragraph">
<p>这是一个简单的例子<code>Greeter.groovy</code>说明用法的脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// import of CliBuilder not shown                          <i class="conum" data-value="1"></i><b>(1)</b>
// specify parameters
def cli = new CliBuilder(usage: 'groovy Greeter [option]') <i class="conum" data-value="2"></i><b>(2)</b>
cli.a(longOpt: 'audience', args: 1, 'greeting audience')   <i class="conum" data-value="3"></i><b>(3)</b>
cli.h(longOpt: 'help', 'display usage')                    <i class="conum" data-value="4"></i><b>(4)</b>

// parse and process parameters
def options = cli.parse(args)                              <i class="conum" data-value="5"></i><b>(5)</b>
if (options.h) cli.usage()                                 <i class="conum" data-value="6"></i><b>(6)</b>
else println "Hello ${options.a ? options.a : 'World'}"    <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>Groovy的早期版本在groovy.util软件包中有一个CliBuilder，并且不需要导入。尽管仍受支持，但现在不赞成使用此方法，而应选择groovy.cli.picocli或groovy.cli.commons版本。groovy.util版本指向commons-cli版本以实现向后兼容，但是将在Groovy的将来版本中将其删除。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>定义一个新的<code>CliBuilder</code>指定可选用法字符串的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>指定一个<code>-a</code>选择带可选长变体的单个参数的选项<code>--audience</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>指定一个<code>-h</code>选项不带参数，带有可选的long变量<code>--help</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>解析提供给脚本的命令行参数</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>如果<code>h</code>找到选项显示用法消息</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>显示标准问候语，或者<code>a</code>找到选项，自定义问候语</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在没有命令行参数的情况下运行此脚本，即：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-shell" data-lang="shell">&gt; groovy Greeter</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello World</pre>
</div>
</div>
<div class="paragraph">
<p>使用以下命令运行此脚本<code>-h</code>作为单个命令行参数，即：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-shell" data-lang="shell">&gt; groovy Greeter -h</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>usage: groovy Greeter [option]
 -a,--audience &lt;arg&gt;   greeting audience
 -h,--help             display usage</pre>
</div>
</div>
<div class="paragraph">
<p>使用以下命令运行此脚本<code>--audience Groovologist</code>作为命令行参数，即：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-shell" data-lang="shell">&gt; groovy Greeter --audience Groovologist</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello Groovologist</pre>
</div>
</div>
<div class="paragraph">
<p>创建时<code>CliBuilder</code>上例中的实例，我们设置了可选<code>usage</code>构造函数调用中的属性。这遵循Groovy在构造期间设置实例的其他属性的正常能力。可以设置许多其他属性，例如<code>header</code>和<code>footer</code> 。有关可用属性的完整集，请参见<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/CliBuilder.html">CliBuilder</a>类的可用属性。</p>
</div>
<div class="paragraph">
<p>定义允许的命令行选项时，请同时输入一个简短的名称（例如，“ h” <code>help</code>前面显示的选项）和简短说明（例如，“ <code>help</code>选项）。在上面的示例中，我们还设置了一些其他属性，例如<code>longOpt</code>和<code>args</code> 。指定允许的命令行选项时，支持以下其他属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">argName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">输出中使用的此选项的参数名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">longOpt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选项的长表示形式或长名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">args</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数值的数量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code>要么<code>String</code> <1></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">optionalArg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数值是否可选</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">需要</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该选项是否是强制性的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此选项的类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Class</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">valueSeparator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为值分隔符的字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code> <2></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">兑换</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将传入的String转换为所需的类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Closure</code> <1></p></td>
</tr>
</tbody>
</table>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>稍后更多细节</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在Groovy中的特殊情况下，单字符字符串被强制转换为char</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您只有一个选项<code>longOpt</code>变体，您可以使用特殊的简称_来指定选项，例如： <code>cli._(longOpt: 'verbose', 'enable verbose logging')</code> 。剩下的一些命名参数应该是不言自明的，而其他一些则需要更多解释。但是在进一步解释之前，让我们先看看使用方法<code>CliBuilder</code>带有注释。</p>
</div>
<div class="sect4">
<h5 id="_using_annotations_and_an_interface"><a class="anchor" href="#_using_annotations_and_an_interface"></a>使用注释和界面</h5>
<div class="paragraph">
<p>您无需提供一系列方法调用（尽管以声明性的mini-DSL形式）来指定允许的选项，而是可以提供允许选项的接口规范，其中使用批注来指示和提供这些选项以及如何使用这些选项的详细信息处理未处理的参数。使用了两个注释： <a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/cli/Option.html">groovy.cli。Option</a>和<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/cli/Unparsed.html">groovy.cli。未分析</a> 。</p>
</div>
<div class="paragraph">
<p>定义此规范的方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface GreeterI {
    @Option(shortName='h', description='display usage') Boolean help()        <i class="conum" data-value="1"></i><b>(1)</b>
    @Option(shortName='a', description='greeting audience') String audience() <i class="conum" data-value="2"></i><b>(2)</b>
    @Unparsed(description = "positional parameters") List remaining()         <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用以下命令指定布尔选项集<code>-h</code>要么<code>--help</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用以下命令指定一个字符串选项集<code>-a</code>要么<code>--audience</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>指定剩余参数的存储位置</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>注意如何从接口方法名称中自动确定长名称。您可以使用<code>longName</code>注解属性可覆盖该行为，并在需要时指定自定义的长名称，或者使用longName'_'表示不提供任何长名称。在这种情况下，您将需要指定shortName。</p>
</div>
<div class="paragraph">
<p>这是使用接口规范的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// import CliBuilder not shown
def cli = new CliBuilder(usage: 'groovy Greeter')  <i class="conum" data-value="1"></i><b>(1)</b>
def argz = '--audience Groovologist'.split()
def options = cli.parseFromSpec(GreeterI, argz)             <i class="conum" data-value="2"></i><b>(2)</b>
assert options.audience() == 'Groovologist'                 <i class="conum" data-value="3"></i><b>(3)</b>

argz = '-h Some Other Args'.split()
options = cli.parseFromSpec(GreeterI, argz)                 <i class="conum" data-value="4"></i><b>(4)</b>
assert options.help()
assert options.remaining() == ['Some', 'Other', 'Args']     <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个<code>CliBuilder</code>像以前一样具有可选属性的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用接口规范解析参数</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用界面中的方法询问选项</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>解析一组不同的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>询问其余参数</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>什么时候<code>parseFromSpec</code>叫做， <code>CliBuilder</code>自动创建一个实现该接口的实例并填充它。您只需调用接口方法来查询选项值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_annotations_and_an_instance"><a class="anchor" href="#_using_annotations_and_an_instance"></a>使用注释和实例</h5>
<div class="paragraph">
<p>或者，也许您已经有一个包含选项信息的域类。您可以简单地注释该类的属性或设置器以启用<code>CliBuilder</code>以适当地填充您的域对象。每个注释都通过注释属性描述了该选项的属性，并指示设置者<code>CliBuilder</code>将用于在您的域对象中填充该选项。</p>
</div>
<div class="paragraph">
<p>定义此规范的方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GreeterC {
    @Option(shortName='h', description='display usage')
    Boolean help                        <i class="conum" data-value="1"></i><b>(1)</b>

    private String audience
    @Option(shortName='a', description='greeting audience')
    void setAudience(String audience) { <i class="conum" data-value="2"></i><b>(2)</b>
        this.audience = audience
    }
    String getAudience() { audience }

    @Unparsed(description = "positional parameters")
    List remaining                      <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>表示布尔属性是一个选项</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>表示一个String属性（带有显式setter）是一个选项</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>指定剩余的args的存储位置</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是您如何使用规范的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// import CliBuilder not shown
def cli = new CliBuilder(usage: 'groovy Greeter [option]') <i class="conum" data-value="1"></i><b>(1)</b>
def options = new GreeterC()                               <i class="conum" data-value="2"></i><b>(2)</b>
def argz = '--audience Groovologist foo'.split()
cli.parseFromInstance(options, argz)                       <i class="conum" data-value="3"></i><b>(3)</b>
assert options.audience == 'Groovologist'                  <i class="conum" data-value="4"></i><b>(4)</b>
assert options.remaining == ['foo']                        <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个<code>CliBuilder</code>像以前一样带有可选参数的实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建一个实例<code>CliBuilder</code>填充</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>解析填充提供的实例的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>询问String选项属性</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>询问剩余的参数属性</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>什么时候<code>parseFromInstance</code>叫做， <code>CliBuilder</code>自动填充您的实例。您只需查询实例属性（或域对象中提供的任何访问器方法）即可访问选项值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_annotations_and_a_script"><a class="anchor" href="#_using_annotations_and_a_script"></a>使用注释和脚本</h5>
<div class="paragraph">
<p>最后，还有两个专门用于脚本的便捷注释别名。它们只是将前面提到的注释和<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/transform/Field.html">groovy.transform结合在一起</a><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/transform/Field.html">。场</a> 。这些注释的groovydoc揭示了细节： <a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/cli/OptionField.html">groovy.cli。OptionField</a>和<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/cli/UnparsedField.html">groovy.cli。UnparsedField</a> 。</p>
</div>
<div class="paragraph">
<p>这是一个在自包含脚本中使用这些注释的示例，该脚本将使用与前面实例示例所示相同的参数进行调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// import CliBuilder not shown
import groovy.cli.OptionField
import groovy.cli.UnparsedField

@OptionField String audience
@OptionField Boolean help
@UnparsedField List remaining
new CliBuilder().parseFromInstance(this, args)
assert audience == 'Groovologist'
assert remaining == ['foo']</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_options_with_arguments"><a class="anchor" href="#_options_with_arguments"></a>带参数的选项</h5>
<div class="paragraph">
<p>我们在最初的示例中看到，某些选项的行为类似于标志，例如<code>Greeter -h</code>但是其他人争吵，例如<code>Greeter --audience Groovologist</code> 。最简单的情况涉及选项，其作用类似于标志或具有单个（可能是可选的）参数。这是涉及这些情况的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// import CliBuilder not shown
def cli = new CliBuilder()
cli.a(args: 0, 'a arg') <i class="conum" data-value="1"></i><b>(1)</b>
cli.b(args: 1, 'b arg') <i class="conum" data-value="2"></i><b>(2)</b>
cli.c(args: 1, optionalArg: true, 'c arg') <i class="conum" data-value="3"></i><b>(3)</b>
def options = cli.parse('-a -b foo -c bar baz'.split()) <i class="conum" data-value="4"></i><b>(4)</b>

assert options.a == true
assert options.b == 'foo'
assert options.c == 'bar'
assert options.arguments() == ['baz']

options = cli.parse('-a -c -b foo bar baz'.split()) <i class="conum" data-value="5"></i><b>(5)</b>

assert options.a == true
assert options.c == true
assert options.b == 'foo'
assert options.arguments() == ['bar', 'baz']</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>一个简单的标志选项-默认值；允许将args设置为0，但这不是必需的。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>仅带有一个参数的选项</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>一个带有可选参数的选项；如果忽略该选项，它的作用就像一个标志</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>使用此规范的示例，其中将参数提供给'c'选项</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>使用此规范的示例，其中不向'c'选项提供任何参数；这只是一个标志</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>注意：遇到带有可选参数的选项时，它将（某种程度上）贪婪地消耗所提供的命令行参数中的下一个参数。但是，如果下一个参数与已知的多头或空头选项（带前导单连字符或双连字符）匹配，则将优先使用，例如<code>-b</code>在上面的示例中。</p>
</div>
<div class="paragraph">
<p>选项参数也可以使用注释样式指定。这是说明这样定义的接口选项规范：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface WithArgsI {
    @Option boolean a()
    @Option String b()
    @Option(optionalArg=true) String[] c()
    @Unparsed List remaining()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是它的用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def cli = new CliBuilder()
def options = cli.parseFromSpec(WithArgsI, '-a -b foo -c bar baz'.split())
assert options.a()
assert options.b() == 'foo'
assert options.c() == ['bar']
assert options.remaining() == ['baz']

options = cli.parseFromSpec(WithArgsI, '-a -c -b foo bar baz'.split())
assert options.a()
assert options.c() == []
assert options.b() == 'foo'
assert options.remaining() == ['bar', 'baz']</code></pre>
</div>
</div>
<div class="paragraph">
<p>本示例使用数组类型的选项规范。在讨论多个论点时，我们将在短期内更详细地介绍这一点。</p>
</div>
</div>
<div class="sect4">
<h5 id="_specifying_a_type"><a class="anchor" href="#_specifying_a_type"></a>指定类型</h5>
<div class="paragraph">
<p>命令行上的参数本质上是字符串（或者可以说是标志的布尔值），但是可以通过提供其他类型的信息自动转换为更丰富的类型。对于基于注释的参数定义样式，这些类型是使用注释属性的字段类型或带注释的方法的返回类型（或setter方法的setter参数类型）提供的。对于参数定义的动态方法样式，支持特殊的“ type”属性，该属性允许您指定类名称。</p>
</div>
<div class="paragraph">
<p>定义显式类型时， <code>args</code>假定named-parameter为1（布尔型选项除外，默认情况下为0）。一个明确的<code>args</code>如果需要，仍可以提供该参数。这是使用具有动态api参数定义样式的类型的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def argz = '''-a John -b -d 21 -e 1980 -f 3.5 -g 3.14159
    -h cv.txt -i DOWN and some more'''.split()
def cli = new CliBuilder()
cli.a(type: String, 'a-arg')
cli.b(type: boolean, 'b-arg')
cli.c(type: Boolean, 'c-arg')
cli.d(type: int, 'd-arg')
cli.e(type: Long, 'e-arg')
cli.f(type: Float, 'f-arg')
cli.g(type: BigDecimal, 'g-arg')
cli.h(type: File, 'h-arg')
cli.i(type: RoundingMode, 'i-arg')
def options = cli.parse(argz)
assert options.a == 'John'
assert options.b
assert !options.c
assert options.d == 21
assert options.e == 1980L
assert options.f == 3.5f
assert options.g == 3.14159
assert options.h == new File('cv.txt')
assert options.i == RoundingMode.DOWN
assert options.arguments() == ['and', 'some', 'more']</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持基元，数字类型，文件，枚举及其数组（使用<a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?org/codehaus/groovy/runtime/StringGroovyMethods.html#asType">StringGroovyMethods＃asType（String，Class）</a>进行转换）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_custom_parsing_of_the_argument_string"><a class="anchor" href="#_custom_parsing_of_the_argument_string"></a>自定义解析参数String</h5>
<div class="paragraph">
<p>如果支持的类型不够，则可以提供一个闭包来为您处理从String到Rich类型的转换。这是使用动态api样式的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
def cli = new CliBuilder()
def lower = { it.toLowerCase() }
cli.a(convert: lower, 'a-arg')
cli.b(convert: { it.toUpperCase() }, 'b-arg')
cli.d(convert: { Date.parse('yyyy-MM-dd', it) }, 'd-arg')
def options = cli.parse(argz)
assert options.a == 'john'
assert options.b == 'MARY'
assert options.d.format('dd-MMM-yyyy') == '01-Jan-2016'
assert options.arguments() == ['and', 'some', 'more']</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，您可以通过提供转换闭包作为注释参数来使用注释样式。这是一个示例规范：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface WithConvertI {
    @Option(convert={ it.toLowerCase() }) String a()
    @Option(convert={ it.toUpperCase() }) String b()
    @Option(convert={ Date.parse("yyyy-MM-dd", it) }) Date d()
    @Unparsed List remaining()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及使用该规范的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Date newYears = Date.parse("yyyy-MM-dd", "2016-01-01")
def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
def cli = new CliBuilder()
def options = cli.parseFromSpec(WithConvertI, argz)
assert options.a() == 'john'
assert options.b() == 'MARY'
assert options.d() == newYears
assert options.remaining() == ['and', 'some', 'more']</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_options_with_multiple_arguments"><a class="anchor" href="#_options_with_multiple_arguments"></a>具有多个参数的选项</h5>
<div class="paragraph">
<p>还可以使用来支持多个参数<code>args</code>值大于1。有一个特殊的命名参数， <code>valueSeparator</code> ，也可以在处理多个参数时选择使用。在命令行上提供这样的参数列表时，它在支持的语法上提供了更多的灵活性。例如，提供值分隔符'，允许以逗号分隔的值列表在命令行上传递。</p>
</div>
<div class="paragraph">
<p>的<code>args</code>值通常是整数。可以选择将其作为字符串提供。有两个特殊的字符串符号： <code>+</code>和<code>*</code> 。的<code>*</code>值表示0或更大。的<code>+</code>值表示1或更大。的<code>*</code>值与使用相同<code>+</code>并设置<code>optionalArg</code>价值为真。</p>
</div>
<div class="paragraph">
<p>访问多个参数遵循特殊约定。只需在用于访问参数选项的普通属性中添加一个“ s”，您将检索所有提供的参数作为列表。因此，对于名为“ a”的简短选项，您可以使用以下命令访问第一个“ a”参数<code>options.a</code>和所有参数的列表使用<code>options.as</code> 。只要您也没有不带's'的单数变体，就可以使用以's'结尾的短名或长名。因此，如果<code>name</code>是具有多个参数的选项之一，并且<code>guess</code>是带有单个参数的另一个，使用不会造成混淆<code>options.names</code>和<code>options.guess</code> 。</p>
</div>
<div class="paragraph">
<p>以下摘录重点介绍了多个参数的使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// import CliBuilder not shown
def cli = new CliBuilder()
cli.a(args: 2, 'a-arg')
cli.b(args: '2', valueSeparator: ',', 'b-arg') <i class="conum" data-value="1"></i><b>(1)</b>
cli.c(args: '+', valueSeparator: ',', 'c-arg') <i class="conum" data-value="2"></i><b>(2)</b>

def options = cli.parse('-a 1 2 3 4'.split()) <i class="conum" data-value="3"></i><b>(3)</b>
assert options.a == '1' <i class="conum" data-value="4"></i><b>(4)</b>
assert options.as == ['1', '2'] <i class="conum" data-value="5"></i><b>(5)</b>
assert options.arguments() == ['3', '4']

options = cli.parse('-a1 -a2 3'.split()) <i class="conum" data-value="6"></i><b>(6)</b>
assert options.as == ['1', '2']
assert options.arguments() == ['3']

options = cli.parse(['-b1,2']) <i class="conum" data-value="7"></i><b>(7)</b>
assert options.bs == ['1', '2']

options = cli.parse(['-c', '1'])
assert options.cs == ['1']

options = cli.parse(['-c1'])
assert options.cs == ['1']

options = cli.parse(['-c1,2,3'])
assert options.cs == ['1', '2', '3']</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>作为字符串和逗号值分隔符提供的Args值</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>允许一个或多个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>两个命令行参数将作为'b'选项的参数列表提供</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>访问“ a”选项的第一个参数</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>访问“ a”选项的参数列表</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>为'a'选项指定两个参数的另一种语法</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>'b'选项的参数以逗号分隔值形式提供</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>作为使用<em>复数名称</em>方法访问多个参数的替代方法，可以为选项使用基于数组的类型。在这种情况下，所有选项将始终通过通过普通单数名称访问的数组返回。接下来，我们将在讨论类型时看到一个示例。</p>
</div>
<div class="paragraph">
<p>通过为带注释的类成员（方法或属性）使用数组类型，还可以使用选项定义的注释样式来支持多个参数，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface ValSepI {
    @Option(numberOfArguments=2) String[] a()
    @Option(numberOfArgumentsString='2', valueSeparator=',') String[] b()
    @Option(numberOfArgumentsString='+', valueSeparator=',') String[] c()
    @Unparsed remaining()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并使用如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def cli = new CliBuilder()

def options = cli.parseFromSpec(ValSepI, '-a 1 2 3 4'.split())
assert options.a() == ['1', '2']
assert options.remaining() == ['3', '4']

options = cli.parseFromSpec(ValSepI, '-a1 -a2 3'.split())
assert options.a() == ['1', '2']
assert options.remaining() == ['3']

options = cli.parseFromSpec(ValSepI, ['-b1,2'] as String[])
assert options.b() == ['1', '2']

options = cli.parseFromSpec(ValSepI, ['-c', '1'] as String[])
assert options.c() == ['1']

options = cli.parseFromSpec(ValSepI, ['-c1'] as String[])
assert options.c() == ['1']

options = cli.parseFromSpec(ValSepI, ['-c1,2,3'] as String[])
assert options.c() == ['1', '2', '3']</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_types_and_multiple_arguments"><a class="anchor" href="#_types_and_multiple_arguments"></a>类型和多个参数</h5>
<div class="paragraph">
<p>这是一个使用类型和具有动态api参数定义样式的多个参数的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def argz = '''-j 3 4 5 -k1.5,2.5,3.5 and some more'''.split()
def cli = new CliBuilder()
cli.j(args: 3, type: int[], 'j-arg')
cli.k(args: '+', valueSeparator: ',', type: BigDecimal[], 'k-arg')
def options = cli.parse(argz)
assert options.js == [3, 4, 5] <i class="conum" data-value="1"></i><b>(1)</b>
assert options.j == [3, 4, 5]  <i class="conum" data-value="1"></i><b>(1)</b>
assert options.k == [1.5, 2.5, 3.5]
assert options.arguments() == ['and', 'some', 'more']</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>对于数组类型，可以使用结尾的“ s”，但不需要</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_setting_a_default_value"><a class="anchor" href="#_setting_a_default_value"></a>设定默认值</h5>
<div class="paragraph">
<p>Groovy使使用Elvis运算符很容易在使用某些变量时提供默认值，例如<code>String x = someVariable ?: 'some default'</code> 。但是有时您希望将这样的默认设置作为选项规范的一部分，以最大程度地减少询问器在以后阶段的工作。 <code>CliBuilder</code>支持<code>defaultValue</code>属性以适应这种情况。</p>
</div>
<div class="paragraph">
<p>使用动态api样式的方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def cli = new CliBuilder()
cli.f longOpt: 'from', type: String, args: 1, defaultValue: 'one', 'f option'
cli.t longOpt: 'to', type: int, defaultValue: '35', 't option'

def options = cli.parse('-f two'.split())
assert options.hasOption('f')
assert options.f == 'two'
assert !options.hasOption('t')
assert options.t == 35

options = cli.parse('-t 45'.split())
assert !options.hasOption('from')
assert options.from == 'one'
assert options.hasOption('to')
assert options.to == 45</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可能需要使用注释样式的规范。这是使用接口规范的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface WithDefaultValueI {
    @Option(shortName='f', defaultValue='one') String from()
    @Option(shortName='t', defaultValue='35') int to()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def cli = new CliBuilder()

def options = cli.parseFromSpec(WithDefaultValueI, '-f two'.split())
assert options.from() == 'two'
assert options.to() == 35

options = cli.parseFromSpec(WithDefaultValueI, '-t 45'.split())
assert options.from() == 'one'
assert options.to() == 45</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>defaultValue</code>将注释与实例一起使用时的注释属性，尽管为属性（或支持字段）提供初始值可能也很容易。</p>
</div>
</div>
<div class="sect4">
<h5 id="_use_with_code_typechecked_code"><a class="anchor" href="#_use_with_code_typechecked_code"></a>用于<code>TypeChecked</code></h5>
<div class="paragraph">
<p>动态api风格的使用<code>CliBuilder</code>本质上是动态的，但是如果您想使用Groovy的静态类型检查功能，则可以选择几种方法。首先，考虑使用注释样式，例如，这是一个接口选项规范：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface TypeCheckedI{
    @Option String name()
    @Option int age()
    @Unparsed List remaining()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且可以与<code>@TypeChecked</code>如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TypeChecked
void testTypeCheckedInterface() {
    def argz = "--name John --age 21 and some more".split()
    def cli = new CliBuilder()
    def options = cli.parseFromSpec(TypeCheckedI, argz)
    String n = options.name()
    int a = options.age()
    assert n == 'John' &amp;&amp; a == 21
    assert options.remaining() == ['and', 'some', 'more']
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其次，动态api样式的一个功能提供了一些支持。定义语句本质上是动态的，但实际上返回的值在前面的示例中已被我们忽略。返回值实际上是<code>TypedOption<Type></code>又特别<code>getAt</code>支持允许使用类型化的选项来查询选项，例如<code>options[savedTypeOption]</code> 。因此，如果在代码的非类型检查部分中有与这些语句相似的语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def cli = new CliBuilder()
TypedOption&lt;Integer&gt; age = cli.a(longOpt: 'age', type: Integer, 'some age option')</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，以下语句可以在代码的单独部分中进行类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def args = '--age 21'.split()
def options = cli.parse(args)
int a = options[age]
assert a == 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，还有一种由<code>CliBuilder</code>甚至允许对定义部分进行类型检查。这是一个较为冗长的方法调用。而不是在方法调用中使用短名称（ <em>opt</em>名称），而是使用固定名称<code>option</code>并提供<code>opt</code>价值作为财产。您还必须直接指定类型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.cli.TypedOption
import groovy.transform.TypeChecked

@TypeChecked
void testTypeChecked() {
    def cli = new CliBuilder()
    TypedOption&lt;String&gt; name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
    TypedOption&lt;Integer&gt; age = cli.option(Integer, longOpt: 'age', 'age option')
    def argz = "--name John --age 21 and some more".split()
    def options = cli.parse(argz)
    String n = options[name]
    int a = options[age]
    assert n == 'John' &amp;&amp; a == 21
    assert options.arguments() == ['and', 'some', 'more']
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_advanced_cli_usage"><a class="anchor" href="#_advanced_cli_usage"></a>高级CLI使用</h5>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>注意</strong>高级CLI功能</p>
</div>
<div class="paragraph">
<p><code>CliBuilder</code>可以被认为是<a href="https://github.com/remkop/picocli">picocli</a>或<a href="https://commons.apache.org/proper/commons-cli/">Apache Commons CLI</a>之上的Groovy友好包装器。如果有某项功能未提供<code>CliBuilder</code>您知道底层库中支持的<code>CliBuilder</code>实现（以及各种Groovy语言功能）使您可以轻松地直接调用基础库方法。这样做是一种实用的方法，可以利用由以下人员提供的Groovy友好语法<code>CliBuilder</code>并且仍然可以访问某些基础库的高级功能。但是要小心一点；的未来版本<code>CliBuilder</code>可能使用另一个底层库，并且在这种情况下，您的Groovy类和/或脚本可能需要进行一些移植工作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_apache_commons_cli"><a class="anchor" href="#_apache_commons_cli"></a> Apache Commons CLI</h6>
<div class="paragraph">
<p>例如，以下是一些使用Apache Commons CLI的分组机制的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.apache.commons.cli.*

def cli = new CliBuilder()
cli.f longOpt: 'from', 'f option'
cli.u longOpt: 'until', 'u option'
def optionGroup = new OptionGroup()
optionGroup.with {
  addOption cli.option('o', [longOpt: 'output'], 'o option')
  addOption cli.option('d', [longOpt: 'directory'], 'd option')
}
cli.options.addOptionGroup optionGroup
assert !cli.parse('-d -o'.split()) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>由于一次只能使用一个组中的一个选项，因此解析将失败。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_picocli"><a class="anchor" href="#_picocli"></a>皮科克里</h6>
<div class="paragraph">
<p>以下是picocli版本的的一些可用功能<code>CliBuilder</code> 。</p>
</div>
<div class="paragraph">
<p><strong>新属性：errorWriter</strong></p>
</div>
<div class="paragraph">
<p>当应用程序的用户提供无效的命令行参数时，CliBuilder将错误消息和使用帮助消息写到<code>stderr</code>输出流。它不使用<code>stdout</code>流，以防止在程序的输出用作另一个进程的输入时分析错误消息。您可以通过设置<code>errorWriter</code>设置为其他值</p>
</div>
<div class="paragraph">
<p>另一方面， <code>CliBuilder.usage()</code>将使用帮助信息打印到<code>stdout</code>流。这样，当用户请求帮助时（例如， <code>--help</code>参数），他们可以将输出通过管道传递给类似<code>less</code>要么<code>grep</code> 。</p>
</div>
<div class="paragraph">
<p>您可以指定不同的编写器进行测试。
<em>请注意，为了向后兼容，请设置<code>writer</code>属性不同的值可以<strong>同时</strong>设置<code>writer</code>和<code>errorWriter</code>给指定的作者。</em></p>
</div>
<div class="paragraph">
<p><strong>ANSI颜色</strong></p>
</div>
<div class="paragraph">
<p>picocli版本的CliBuilder在支持的平台上自动以ANSI颜色呈现使用帮助消息。如果需要，您可以对此进行<a href="http://picocli.info/#_usage_help_with_styles_and_colors">自定义</a> 。（下面是一个示例。）</p>
</div>
<div class="paragraph">
<p><strong>新属性：名称</strong></p>
</div>
<div class="paragraph">
<p>和以前一样，您可以将使用帮助消息的摘要与<code>usage</code>属性。您可能会对一个小的改进感兴趣：如果仅设置命令<code>name</code> ，系统会自动生成一个简介，重复元素后跟<code>…​</code>和可选元素包围<code>[</code>和<code>]</code> 。（下面是一个示例。）</p>
</div>
<div class="paragraph">
<p><strong>新属性：usageMessage</strong></p>
</div>
<div class="paragraph">
<p>此属性公开<code>UsageMessageSpec</code>来自底层picocli库的对象，该库可对使用帮助消息的各个部分进行精细控制。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def cli = new CliBuilder()
cli.name = "myapp"
cli.usageMessage.with {
    headerHeading("@|bold,underline Header heading:|@%n")
    header("Header 1", "Header 2")                     // before the synopsis
    synopsisHeading("%n@|bold,underline Usage:|@ ")
    descriptionHeading("%n@|bold,underline Description heading:|@%n")
    description("Description 1", "Description 2")      // after the synopsis
    optionListHeading("%n@|bold,underline Options heading:|@%n")
    footerHeading("%n@|bold,underline Footer heading:|@%n")
    footer("Footer 1", "Footer 2")
}
cli.a('option a description')
cli.b('option b description')
cli.c(args: '*', 'option c description')
cli.usage()</code></pre>
</div>
</div>
<div class="paragraph">
<p>给出以下输出：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/usageMessageSpec.png" alt="usageMessageSpec">
</div>
</div>
<div class="paragraph">
<p><strong>新属性：解析器</strong></p>
</div>
<div class="paragraph">
<p>的<code>parser</code>物业可访问picocli <code>ParserSpec</code>可用于自定义解析器行为的对象。有关详细信息，请参见<a href="http://picocli.info/apidocs/picocli/CommandLine.Model.ParserSpec.html">文档</a> 。</p>
</div>
<div class="paragraph">
<p><strong>地图选项</strong></p>
</div>
<div class="paragraph">
<p>最后，如果您的应用程序具有键值对选项，那么您可能会对picocli对地图的支持感兴趣。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.util.concurrent.TimeUnit
import static java.util.concurrent.TimeUnit.DAYS
import static java.util.concurrent.TimeUnit.HOURS

def cli = new CliBuilder()
cli.D(args: 2,   valueSeparator: '=', 'the old way')                          <i class="conum" data-value="1"></i><b>(1)</b>
cli.X(type: Map, 'the new way')                                               <i class="conum" data-value="2"></i><b>(2)</b>
cli.Z(type: Map, auxiliaryTypes: [TimeUnit, Integer].toArray(), 'typed map')  <i class="conum" data-value="3"></i><b>(3)</b>

def options = cli.parse('-Da=b -Dc=d -Xx=y -Xi=j -ZDAYS=2 -ZHOURS=23'.split())<i class="conum" data-value="4"></i><b>(4)</b>
assert options.Ds == ['a', 'b', 'c', 'd']                                     <i class="conum" data-value="5"></i><b>(5)</b>
assert options.Xs == [ 'x':'y', 'i':'j' ]                                     <i class="conum" data-value="6"></i><b>(6)</b>
assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>先前， <code>key=value</code>对被分成几部分并添加到列表中</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>Picocli地图支持：只需指定<code>Map</code>作为选项的类型</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>您甚至可以指定地图元素的类型</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>为了进行比较，让我们为每个选项指定两个键值对</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>以前，所有键值对都在一个列表中，并且由应用程序使用此列表</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>Picocli将键值对返回为<code>Map</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>地图的键和值都可以强类型输入</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_objectgraphbuilder"><a class="anchor" href="#_objectgraphbuilder"></a> 8.2.12。ObjectGraphBuilder</h4>
<div class="paragraph">
<p><code>ObjectGraphBuilder</code>是遵循JavaBean约定的任意豆图的生成器。这对于创建测试数据特别有用。</p>
</div>
<div class="paragraph">
<p>让我们从属于您的域的类列表开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">package com.acme

class Company {
    String name
    Address address
    List employees = []
}

class Address {
    String line1
    String line2
    int zip
    String state
}

class Employee {
    String name
    int employeeId
    Address address
    Company company
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后使用<code>ObjectGraphBuilder</code>建立一个<code>Company</code>三名员工一样简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def builder = new ObjectGraphBuilder()                          <i class="conum" data-value="1"></i><b>(1)</b>
builder.classLoader = this.class.classLoader                    <i class="conum" data-value="2"></i><b>(2)</b>
builder.classNameResolver = "com.acme"                          <i class="conum" data-value="3"></i><b>(3)</b>

def acme = builder.company(name: 'ACME') {                      <i class="conum" data-value="4"></i><b>(4)</b>
    3.times {
        employee(id: it.toString(), name: "Drone $it") {        <i class="conum" data-value="5"></i><b>(5)</b>
            address(line1:"Post street")                        <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}

assert acme != null
assert acme instanceof Company
assert acme.name == 'ACME'
assert acme.employees.size() == 3
def employee = acme.employees[0]
assert employee instanceof Employee
assert employee.name == 'Drone 0'
assert employee.address instanceof Address</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建一个新的对象图生成器</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>设置将解析类的类加载器</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>设置要解析的类的基本包名称</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>创建一个<code>Company</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>与3 <code>Employee</code>实例</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>他们每个人都有一个独特的<code>Address</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在后台，对象图生成器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将尝试将节点名称匹配到<code>Class</code> ，使用默认值<code>ClassNameResolver</code>需要包名称的策略</p>
</li>
<li>
<p>然后将使用默认值创建适当类的实例<code>NewInstanceResolver</code>调用无参数构造函数的策略</p>
</li>
<li>
<p>解决嵌套节点的父/子关系，涉及其他两种策略：</p>
<div class="ulist">
<ul>
<li>
<p><code>RelationNameResolver</code>将在父级中生成子级属性的名称，并在子级中生成父级属性的名称（在这种情况下， <code>Employee</code>具有适当命名的父级属性<code>company</code> ）</p>
</li>
<li>
<p><code>ChildPropertySetter</code>会考虑到孩子是否属于<code>Collection</code>是否（在这种情况下<code>employees</code>应该是<code>Employee</code>实例<code>Company</code> ）。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果代码遵循编写JavaBean的常用约定，则所有4种策略都有一个默认实现，可以按预期工作。如果您的任何bean或对象都不遵循约定，则可以插入自己的每种策略的实现。例如，假设您需要构建一个不可变的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Immutable
class Person {
    String name
    int age
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，如果您尝试创建一个<code>Person</code>与建造者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def person = builder.person(name:'Jon', age:17)</code></pre>
</div>
</div>
<div class="paragraph">
<p>它在运行时将失败，并显示以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Cannot set readonly property: name for class: com.acme.Person</pre>
</div>
</div>
<div class="paragraph">
<p>可以通过更改新的实例策略来解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">builder.newInstanceResolver = { Class klazz, Map attributes -&gt;
    if (klazz.getConstructor(Map)) {
        def o = klazz.newInstance(attributes)
        attributes.clear()
        return o
    }
    klazz.newInstance()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ObjectGraphBuilder</code>支持每个节点的ID，这意味着您可以在构建器中存储对节点的引用。当多个对象引用同一个实例时，这很有用。因为一个名为<code>id</code>在某些领域模型中可能具有业务意义<code>ObjectGraphBuilder</code>有一个名为<code>IdentifierResolver</code>您可以配置更改默认名称值。用于引用先前保存的实例的属性可能会发生同样的情况，即名为<code>ReferenceResolver</code>将产生适当的值（默认为“ refId”）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def company = builder.company(name: 'ACME') {
    address(id: 'a1', line1: '123 Groovy Rd', zip: 12345, state: 'JV')          <i class="conum" data-value="1"></i><b>(1)</b>
    employee(name: 'Duke', employeeId: 1, address: a1)                          <i class="conum" data-value="2"></i><b>(2)</b>
    employee(name: 'John', employeeId: 2 ){
      address( refId: 'a1' )                                                    <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>可以使用<code>id</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>员工可以直接使用其ID引用地址</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>或使用<code>refId</code>对应于<code>id</code>对应地址的</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>值得一提的是，您不能修改引用的bean的属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_jmxbuilder"><a class="anchor" href="#_jmxbuilder"></a> 8.2.13。JmxBuilder</h4>
<div class="paragraph">
<p>有关详细信息，请参见<a href="#jmx_jmxbuilder">使用JMX-JmxBuilder</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_filetreebuilder"><a class="anchor" href="#_filetreebuilder"></a> 8.2.14。FileTreeBuilder</h4>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/2.5.8/html/gapi/index.html?groovy/util/FileTreeBuilder.html">FileTreeBuilder</a>是用于根据规范生成文件目录结构的构建器。例如，创建以下树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre> src/
  |--- main
  |     |--- groovy
  |            |--- Foo.groovy
  |--- test
        |--- groovy
               |--- FooTest.groovy</pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>FileTreeBuilder</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">tmpDir = File.createTempDir()
def fileTreeBuilder = new FileTreeBuilder(tmpDir)
fileTreeBuilder.dir('src') {
    dir('main') {
       dir('groovy') {
          file('Foo.groovy', 'println "Hello"')
       }
    }
    dir('test') {
       dir('groovy') {
          file('FooTest.groovy', 'class FooTest extends GroovyTestCase {}')
       }
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了检查一切是否按预期工作，我们使用以下`assert`s：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new File(tmpDir, '/src/main/groovy/Foo.groovy').text == 'println "Hello"'
assert new File(tmpDir, '/src/test/groovy/FooTest.groovy').text == 'class FooTest extends GroovyTestCase {}'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>FileTreeBuilder</code>还支持简写语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">tmpDir = File.createTempDir()
def fileTreeBuilder = new FileTreeBuilder(tmpDir)
fileTreeBuilder.src {
    main {
       groovy {
          'Foo.groovy'('println "Hello"')
       }
    }
    test {
       groovy {
          'FooTest.groovy'('class FooTest extends GroovyTestCase {}')
       }
    }
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将产生与上述相同的目录结构，如以下`assert`所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new File(tmpDir, '/src/main/groovy/Foo.groovy').text == 'println "Hello"'
assert new File(tmpDir, '/src/test/groovy/FooTest.groovy').text == 'class FooTest extends GroovyTestCase {}'</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>上次更新时间2019-08-02 18:30:29 UTC</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>