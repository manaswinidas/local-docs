<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>使用JMX</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=0">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>使用JMX</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1。介绍</a></li>
<li><a href="#_monitoring_the_jvm">2。监控JVM</a></li>
<li><a href="#_monitoring_tomcat">3。监视Tomcat</a></li>
<li><a href="#_oc4j_example">4。OC4J示例</a></li>
<li><a href="#_weblogic_example">5，WebLogic示例</a></li>
<li><a href="#_spring_example">6。春天的例子</a></li>
<li><a href="#_troubleshooting">7。故障排除</a>
<ul class="sectlevel2">
<li><a href="#_java_lang_securityexception">7.1。 java.lang。SecurityException</a></li>
</ul>
</li>
<li><a href="#jmx_jmxbuilder">8。JmxBuilder</a>
<ul class="sectlevel2">
<li><a href="#_instantiating_jmxbuilder">8.1。实例化JmxBuilder</a></li>
<li><a href="#_jmx_connectors">8.2。JMX连接器</a>
<ul class="sectlevel3">
<li><a href="#_connector_server">8.2.1。连接器服务器</a></li>
<li><a href="#_connector_client">8.2.2。连接器客户端</a></li>
</ul>
</li>
<li><a href="#_jmxbuilder_mbean_export">8.3。JmxBuilder MBean导出</a>
<ul class="sectlevel3">
<li><a href="#_implicit_vs_explicit_descriptors">8.3.1。隐式与显式描述符</a></li>
<li><a href="#_the_jmxbuilder_export_node">8.3.2。JmxBuilder.export（）节点</a></li>
<li><a href="#_jmxbuilder_export_syntax">8.3.3。JmxBuilder.export（）语法</a></li>
<li><a href="#_integration_with_groovymbean_class">8.3.4。与GroovyMBean类集成</a></li>
<li><a href="#_mbean_registration_with_jmxbuilder_bean">8.3.5。使用JmxBuilder.bean（）进行MBean注册</a>
<ul class="sectlevel4">
<li><a href="#_implicit_export">隐式导出</a>
<ul class="sectlevel5">
<li><a href="#_jconsole_view_of_exported_bean">导出Bean的JConsole视图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_jmxbuilder_bean_syntax">8.3.6。JmxBuilder.bean（）语法</a></li>
<li><a href="#_bean_node_specifying_mbean_objectname">8.3.7。Bean（）节点-指定MBean ObjectName</a></li>
</ul>
</li>
<li><a href="#_bean_node_attribute_export">8.4。Bean（）节点-属性导出</a>
<ul class="sectlevel3">
<li><a href="#_export_all_attributes_with_wildcard">8.4.1。导出所有带有通配符“ *”的属性</a></li>
<li><a href="#_export_attribute_list">8.4.2。导出属性列表</a></li>
<li><a href="#_export_attribute_with_explicit_descriptors">8.4.3。带有明确描述符的导出属性</a></li>
</ul>
</li>
<li><a href="#_bean_node_constructor_export">8.5。Bean（）节点-构造函数导出</a>
<ul class="sectlevel3">
<li><a href="#_export_all_constructors_with">8.5.1。用“ *”导出所有构造函数</a></li>
<li><a href="#_export_constructors_using_parameter_descriptor">8.5.2。使用参数描述符导出构造函数</a></li>
<li><a href="#_export_constructor_with_explicit_descriptors">8.5.3。具有显式描述符的导出构造函数</a></li>
</ul>
</li>
<li><a href="#_bean_node_operation_export">8.6。Bean（）节点-操作导出</a>
<ul class="sectlevel3">
<li><a href="#_export_all_operations_with">8.6.1。用“ *”导出所有操作</a></li>
<li><a href="#_export_operation_list">8.6.2。出口业务清单</a></li>
<li><a href="#_export_operations_by_signature">8.6.3。签名导出操作</a></li>
<li><a href="#_export_operations_with_explicit_descriptors">8.6.4。带有明确描述符的导出操作</a></li>
</ul>
</li>
<li><a href="#_embedding_descriptor">8.7。嵌入描述符</a></li>
<li><a href="#_timer_export">8.8。计时器导出</a>
<ul class="sectlevel3">
<li><a href="#_timer_node_syntax">8.8.1。计时器节点语法</a></li>
<li><a href="#_exporting_a_timer">8.8.2。导出计时器</a></li>
<li><a href="#_timer_period">8.8.3。计时器周期</a></li>
</ul>
</li>
<li><a href="#_jmxbuilder_and_events">8.9。JmxBuilder和事件</a>
<ul class="sectlevel3">
<li><a href="#_event_handling_closures">8.9.1。事件处理关闭</a>
<ul class="sectlevel4">
<li><a href="#_parameterless">无参数</a></li>
<li><a href="#_with_event_parameter">带事件参数</a></li>
</ul>
</li>
<li><a href="#_handling_attribute_onchange_event">8.9.2。处理属性onChange事件</a></li>
<li><a href="#_attribute_onchange_event_object">8.9.3。属性onChange事件对象</a></li>
<li><a href="#_handling_operation_oncall_event">8.9.4。处理onCall事件</a></li>
<li><a href="#_operation_oncall_event_object">8.9.5。操作onCall事件对象</a></li>
</ul>
</li>
<li><a href="#_listener_mbean">8.10。侦听器MBean</a>
<ul class="sectlevel3">
<li><a href="#_listening_to_jmx_events">8.10.1。收听JMX事件</a></li>
<li><a href="#_listener_node_syntax">8.10.2。侦听器节点语法</a></li>
</ul>
</li>
<li><a href="#_emitting_jmx_events">8.11。发出JMX事件</a>
<ul class="sectlevel3">
<li><a href="#_emitter_syntax">8.11.1。发射器语法</a></li>
<li><a href="#_declare_the_emitter">8.11.2。声明发射器</a></li>
<li><a href="#_broadcast_event">8.11.3。广播事件</a></li>
<li><a href="#_sending_event_objects">8.11.4。发送事件对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_further_jmx_information">9。更多JMX信息</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a> 1。介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>鉴于Groovy直接位于Java之上，Groovy可以利用<a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX</a>与Java一起完成的大量工作。此外，Groovy还提供了一个<code>GroovyMBean</code>使MBean看起来像普通Groovy对象的类。这简化了与<em>MBean</em>交互的Groovy代码。例如，以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println server.getAttribute(beanName, 'Age')
server.setAttribute(beanName, new Attribute('Name', 'New name'))
Object[] params = [5, 20]
String[] signature = [Integer.TYPE, Integer.TYPE]
println server.invoke(beanName, 'add', params, signature)</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以简化为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def mbean = new GroovyMBean(server, beanName)
println mbean.Age
mbean.Name = 'New name'
println mbean.add(5, 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此页面的其余部分显示如何：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用MXBean监视JVM</p>
</li>
<li>
<p>监视Apache Tomcat并显示统计信息</p>
</li>
<li>
<p>监视Oracle OC4J并显示信息</p>
</li>
<li>
<p>监视BEA WebLogic并显示信息</p>
</li>
<li>
<p>利用Spring的MBean注释支持将Groovy Bean导出为MBean</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_monitoring_the_jvm"><a class="anchor" href="#_monitoring_the_jvm"></a> 2。监控JVM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>应用程序不直接访问MBean，而是由称为<em>MBean服务器</em>的存储库管理<em>MBean</em> 。Java包括一个特殊的MBean服务器，称为<em>平台MBean服务器</em> ，它内置在JVM中。平台MBean使用唯一名称在此服务器中注册。</p>
</div>
<div class="paragraph">
<p>您可以使用以下代码通过其平台MBean监视JVM：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.lang.management.*

def os = ManagementFactory.operatingSystemMXBean
println """OPERATING SYSTEM:
\tarchitecture = $os.arch
\tname = $os.name
\tversion = $os.version
\tprocessors = $os.availableProcessors
"""

def rt = ManagementFactory.runtimeMXBean
println """RUNTIME:
\tname = $rt.name
\tspec name = $rt.specName
\tvendor = $rt.specVendor
\tspec version = $rt.specVersion
\tmanagement spec version = $rt.managementSpecVersion
"""

def cl = ManagementFactory.classLoadingMXBean
println """CLASS LOADING SYSTEM:
\tisVerbose = ${cl.isVerbose()}
\tloadedClassCount = $cl.loadedClassCount
\ttotalLoadedClassCount = $cl.totalLoadedClassCount
\tunloadedClassCount = $cl.unloadedClassCount
"""

def comp = ManagementFactory.compilationMXBean
println """COMPILATION:
\ttotalCompilationTime = $comp.totalCompilationTime
"""

def mem = ManagementFactory.memoryMXBean
def heapUsage = mem.heapMemoryUsage
def nonHeapUsage = mem.nonHeapMemoryUsage
println """MEMORY:
HEAP STORAGE:
\tcommitted = $heapUsage.committed
\tinit = $heapUsage.init
\tmax = $heapUsage.max
\tused = $heapUsage.used
NON-HEAP STORAGE:
\tcommitted = $nonHeapUsage.committed
\tinit = $nonHeapUsage.init
\tmax = $nonHeapUsage.max
\tused = $nonHeapUsage.used
"""

ManagementFactory.memoryPoolMXBeans.each { mp -&gt;
    println "\tname: " + mp.name
    String[] mmnames = mp.memoryManagerNames
    mmnames.each{ mmname -&gt;
        println "\t\tManager Name: $mmname"
    }
    println "\t\tmtype = $mp.type"
    println "\t\tUsage threshold supported = " + mp.isUsageThresholdSupported()
}
println()

def td = ManagementFactory.threadMXBean
println "THREADS:"
td.allThreadIds.each { tid -&gt;
    println "\tThread name = ${td.getThreadInfo(tid).threadName}"
}
println()

println "GARBAGE COLLECTION:"
ManagementFactory.garbageCollectorMXBeans.each { gc -&gt;
    println "\tname = $gc.name"
    println "\t\tcollection count = $gc.collectionCount"
    println "\t\tcollection time = $gc.collectionTime"
    String[] mpoolNames = gc.memoryPoolNames
    mpoolNames.each { mpoolName -&gt;
        println "\t\tmpool name = $mpoolName"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行时，您将看到以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OPERATING SYSTEM:
	architecture = x86
	name = Windows XP
	version = 5.1
	processors = 2

RUNTIME:
	name = 620@LYREBIRD
	spec name = Java Virtual Machine Specification
	vendor = Sun Microsystems Inc.
	spec version = 1.0
	management spec version = 1.0

CLASS LOADING SYSTEM:
	isVerbose = false
	loadedClassCount = 919
	totalLoadedClassCount = 919
	unloadedClassCount = 0

COMPILATION:
	totalCompilationTime = 91

MEMORY:
HEAP STORAGE:
	committed = 3108864
	init = 0
	max = 66650112
	used = 1994728
NON-HEAP STORAGE:
	committed = 9240576
	init = 8585216
	max = 100663296
	used = 5897880

	name: Code Cache
		Manager Name: CodeCacheManager
		mtype = Non-heap memory
		Usage threshold supported = true
	name: Eden Space
		Manager Name: MarkSweepCompact
		Manager Name: Copy
		mtype = Heap memory
		Usage threshold supported = false
	name: Survivor Space
		Manager Name: MarkSweepCompact
		Manager Name: Copy
		mtype = Heap memory
		Usage threshold supported = false
	name: Tenured Gen
		Manager Name: MarkSweepCompact
		mtype = Heap memory
		Usage threshold supported = true
	name: Perm Gen
		Manager Name: MarkSweepCompact
		mtype = Non-heap memory
		Usage threshold supported = true

THREADS:
	Thread name = Monitor Ctrl-Break
	Thread name = Signal Dispatcher
	Thread name = Finalizer
	Thread name = Reference Handler
	Thread name = main

GARBAGE COLLECTION:
	name = Copy
		collection count = 60
		collection time = 141
		mpool name = Eden Space
		mpool name = Survivor Space
	name = MarkSweepCompact
		collection count = 0
		collection time = 0
		mpool name = Eden Space
		mpool name = Survivor Space
		mpool name = Tenured Gen
		mpool name = Perm Gen</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_monitoring_tomcat"><a class="anchor" href="#_monitoring_tomcat"></a> 3。监视Tomcat</h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先通过设置以下内容来启动启用了JMX监视的<a href="http://tomcat.apache.org">Tomcat</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-shell" data-lang="shell">set JAVA_OPTS=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9004\
 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在启动脚本中执行此操作，并且可以选择任何可用的端口（我们使用9004）。</p>
</div>
<div class="paragraph">
<p>以下代码使用JMX在运行的Tomcat中发现可用的MBean，确定哪些是Web模块，提取每个Web模块的处理时间，并使用JFreeChart在图形中显示结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.swing.SwingBuilder

import javax.management.ObjectName
import javax.management.remote.JMXConnectorFactory as JmxFactory
import javax.management.remote.JMXServiceURL as JmxUrl
import javax.swing.WindowConstants as WC

import org.jfree.chart.ChartFactory
import org.jfree.data.category.DefaultCategoryDataset as Dataset
import org.jfree.chart.plot.PlotOrientation as Orientation

def serverUrl = 'service:jmx:rmi:///jndi/rmi://localhost:9004/jmxrmi'
def server = JmxFactory.connect(new JmxUrl(serverUrl)).MBeanServerConnection
def serverInfo = new GroovyMBean(server, 'Catalina:type=Server').serverInfo
println "Connected to: $serverInfo"

def query = new ObjectName('Catalina:*')
String[] allNames = server.queryNames(query, null)
def modules = allNames.findAll { name -&gt;
    name.contains('j2eeType=WebModule')
}.collect{ new GroovyMBean(server, it) }

println "Found ${modules.size()} web modules. Processing ..."
def dataset = new Dataset()

modules.each { m -&gt;
    println m.name()
    dataset.addValue m.processingTime, 0, m.path
}

def labels = ['Time per Module', 'Module', 'Time']
def options = [false, true, true]
def chart = ChartFactory.createBarChart(*labels, dataset,
                Orientation.VERTICAL, *options)
def swing = new SwingBuilder()
def frame = swing.frame(title:'Catalina Module Processing Time', defaultCloseOperation:WC.EXIT_ON_CLOSE) {
    panel(id:'canvas') { rigidArea(width:600, height:250) }
}
frame.pack()
frame.show()
chart.draw(swing.canvas.graphics, swing.canvas.bounds)</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行时，我们将看到进展的轨迹：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Connected to: Apache Tomcat/6.0.13
Found 5 web modules. Processing ...
Catalina:j2eeType=WebModule,name=//localhost/,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/host-manager,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/docs,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/examples,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/manager,J2EEApplication=none,J2EEServer=none</pre>
</div>
</div>
<div class="paragraph">
<p>输出将如下所示：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="assets/img/catalina.gif" alt="卡塔利娜岛"></span></p>
</div>
<div class="paragraph">
<p>注意：如果在运行此脚本时遇到错误，请参阅下面的“ <strong>故障排除”</strong>部分。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oc4j_example"><a class="anchor" href="#_oc4j_example"></a> 4。OC4J示例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>以下是一个脚本，用于访问OC4J并打印出有关服务器，其运行时以及（例如）配置的JMS目标的一些信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import javax.management.remote.*
import oracle.oc4j.admin.jmx.remote.api.JMXConnectorConstant

def serverUrl = new JMXServiceURL('service:jmx:rmi://localhost:23791')
def serverPath = 'oc4j:j2eeType=J2EEServer,name=standalone'
def jvmPath = 'oc4j:j2eeType=JVM,name=single,J2EEServer=standalone'
def provider = 'oracle.oc4j.admin.jmx.remote'
def credentials = [
    (JMXConnectorConstant.CREDENTIALS_LOGIN_KEY): 'oc4jadmin',
    (JMXConnectorConstant.CREDENTIALS_PASSWORD_KEY): 'admin'
]
def env = [
    (JMXConnectorFactory.PROTOCOL_PROVIDER_PACKAGES): provider,
    (JMXConnector.CREDENTIALS): credentials
]
def server = JmxFactory.connect(serverUrl, env).MBeanServerConnection
def serverInfo = new GroovyMBean(server, serverPath)
def jvmInfo = new GroovyMBean(server, jvmPath)
println """Connected to $serverInfo.node. \
Server started ${new Date(serverInfo.startTime)}.
OC4J version:  $serverInfo.serverVersion from $serverInfo.serverVendor
JVM version:   $jvmInfo.javaVersion from $jvmInfo.javaVendor
Memory usage:  $jvmInfo.freeMemory bytes free, \
$jvmInfo.totalMemory bytes total
"""

def query = new javax.management.ObjectName('oc4j:*')
String[] allNames = server.queryNames(query, null)
def dests = allNames.findAll { name -&gt;
    name.contains('j2eeType=JMSDestinationResource')
}.collect { new GroovyMBean(server, it) }

println "Found ${dests.size()} JMS destinations. Listing ..."
dests.each { d -&gt; println "$d.name: $d.location" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是运行此脚本的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Connected to LYREBIRD. Server started Thu May 31 21:04:54 EST 2007.
OC4J version:  11.1.1.0.0 from Oracle Corp.
JVM version:   1.6.0_01 from Sun Microsystems Inc.
Memory usage:  8709976 bytes free, 25153536 bytes total

Found 5 JMS destinations. Listing ...
Demo Queue: jms/demoQueue
Demo Topic: jms/demoTopic
jms/Oc4jJmsExceptionQueue: jms/Oc4jJmsExceptionQueue
jms/RAExceptionQueue: jms/RAExceptionQueue
OracleASRouter_store: OracleASRouter_store</pre>
</div>
</div>
<div class="paragraph">
<p>作为一个稍微的变化，此脚本使用JFreeChart显示内存使用情况的饼图：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.jfree.chart.ChartFactory
import javax.swing.WindowConstants as WC
import javax.management.remote.*
import oracle.oc4j.admin.jmx.remote.api.JMXConnectorConstant

def url = 'service:jmx:rmi://localhost:23791'
def credentials = [:]
credentials[JMXConnectorConstant.CREDENTIALS_LOGIN_KEY] = "oc4jadmin"
credentials[JMXConnectorConstant.CREDENTIALS_PASSWORD_KEY] = "password"
def env = [:]
env[JMXConnectorFactory.PROTOCOL_PROVIDER_PACKAGES] = "oracle.oc4j.admin.jmx.remote"
env[JMXConnector.CREDENTIALS] = credentials
def server = JMXConnectorFactory.connect(new JMXServiceURL(url), env).MBeanServerConnection
def jvmInfo = new GroovyMBean(server, 'oc4j:j2eeType=JVM,name=single,J2EEServer=standalone')

def piedata = new org.jfree.data.general.DefaultPieDataset()
piedata.setValue "Free", jvmInfo.freeMemory
piedata.setValue "Used", jvmInfo.totalMemory - jvmInfo.freeMemory

def options = [true, true, true]
def chart = ChartFactory.createPieChart('OC4J Memory Usage', piedata, *options)
chart.backgroundPaint = java.awt.Color.white
def swing = new groovy.swing.SwingBuilder()
def frame = swing.frame(title:'OC4J Memory Usage', defaultCloseOperation:WC.EXIT_ON_CLOSE) {
    panel(id:'canvas') { rigidArea(width:350, height:250) }
}
frame.pack()
frame.show()
chart.draw(swing.canvas.graphics, swing.canvas.bounds)</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来像：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="assets/img/oc4jpie.gif" alt="oc4jpie"></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_weblogic_example"><a class="anchor" href="#_weblogic_example"></a> 5，WebLogic示例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>该脚本打印出有关服务器的信息，然后打印有关JMS目标的信息（作为示例）。许多其他的MBean是<a href="http://docs.oracle.com/cd/E13222_01/wls/docs90/wlsmbeanref/core/index.html">可用的</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import javax.management.remote.*
import javax.management.*
import javax.naming.Context

def urlRuntime = '/jndi/weblogic.management.mbeanservers.runtime'
def urlBase = 'service:jmx:t3://localhost:7001'

def serviceURL = new JMXServiceURL(urlBase + urlRuntime)
def h = new Hashtable()
h.put(Context.SECURITY_PRINCIPAL, 'weblogic')
h.put(Context.SECURITY_CREDENTIALS, 'weblogic')
h.put(JMXConnectorFactory.PROTOCOL_PROVIDER_PACKAGES, 'weblogic.management.remote')
def server = JMXConnectorFactory.connect(serviceURL, h).MBeanServerConnection
def domainName = new ObjectName('com.bea:Name=RuntimeService,Type=weblogic.management.mbeanservers.runtime.RuntimeServiceMBean')
def rtName = server.getAttribute(domainName, 'ServerRuntime')
def rt = new GroovyMBean(server, rtName)
println "Server: name=$rt.Name, state=$rt.State, version=$rt.WeblogicVersion"
def destFilter = Query.match(Query.attr('Type'), Query.value('JMSDestinationRuntime'))
server.queryNames(new ObjectName('com.bea:*'), destFilter).each { name -&gt;
    def jms = new GroovyMBean(server, name)
    println "JMS Destination: name=$jms.Name, type=$jms.DestinationType, messages=$jms.MessagesReceivedCount"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Server: name=examplesServer, state=RUNNING, version=WebLogic Server 10.0  Wed May 9 18:10:27 EDT 2007 933139
JMS Destination: name=examples-jms!exampleTopic, type=Topic, messages=0
JMS Destination: name=examples-jms!exampleQueue, type=Queue, messages=0
JMS Destination: name=examples-jms!jms/MULTIDATASOURCE_MDB_QUEUE, type=Queue, messages=0
JMS Destination: name=examplesJMSServer!examplesJMSServer.TemporaryQueue0, type=Queue, messages=68
JMS Destination: name=examples-jms!quotes, type=Topic, messages=0
JMS Destination: name=examples-jms!weblogic.wsee.wseeExamplesDestinationQueue, type=Queue, messages=0
JMS Destination: name=examples-jms!weblogic.examples.ejb30.ExampleQueue, type=Queue, messages=0</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_example"><a class="anchor" href="#_spring_example"></a> 6。春天的例子</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您还可以使用Spring自动将bean注册为JMX感知。</p>
</div>
<div class="paragraph">
<p>这是一个示例类（Calculator.groovy）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.springframework.jmx.export.annotation.*

@ManagedResource(objectName="bean:name=calcMBean", description="Calculator MBean")
public class Calculator {

    private int invocations

    @ManagedAttribute(description="The Invocation Attribute")
    public int getInvocations() {
        return invocations
    }

    private int base = 10

    @ManagedAttribute(description="The Base to use when adding strings")
    public int getBase() {
        return base
    }

    @ManagedAttribute(description="The Base to use when adding strings")
    public void setBase(int base) {
        this.base = base
    }

    @ManagedOperation(description="Add two numbers")
    @ManagedOperationParameters([
        @ManagedOperationParameter(name="x", description="The first number"),
        @ManagedOperationParameter(name="y", description="The second number")])
    public int add(int x, int y) {
        invocations++
        return x + y
    }

    @ManagedOperation(description="Add two strings representing numbers of a particular base")
    @ManagedOperationParameters([
        @ManagedOperationParameter(name="x", description="The first number"),
        @ManagedOperationParameter(name="y", description="The second number")])
    public String addStrings(String x, String y) {
        invocations++
        def result = Integer.valueOf(x, base) + Integer.valueOf(y, base)
        return Integer.toString(result, base)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是Spring配置文件（beans.xml）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    &lt;bean id="mbeanServer"
          class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
        &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
    &lt;/bean&gt;

    &lt;bean id="exporter"
          class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="assembler" ref="assembler"/&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=defaultCalcName" value-ref="calcBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="server" ref="mbeanServer"/&gt;
        &lt;property name="autodetect" value="true"/&gt;
    &lt;/bean&gt;

    &lt;bean id="jmxAttributeSource"
          class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

    &lt;!-- will create management interface using annotation metadata --&gt;
    &lt;bean id="assembler"
          class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- will pick up the ObjectName from the annotation --&gt;
    &lt;bean id="namingStrategy"
          class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="calcBean"
          class="Calculator"&gt;
        &lt;property name="base" value="10"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个使用此bean和配置的脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.springframework.context.support.ClassPathXmlApplicationContext
import java.lang.management.ManagementFactory
import javax.management.ObjectName
import javax.management.Attribute

// get normal bean
def ctx = new ClassPathXmlApplicationContext("beans.xml")
def calc = ctx.getBean("calcBean")

Thread.start {
    // access bean via JMX, use a separate thread just to
    // show that we could access remotely if we wanted
    def server = ManagementFactory.platformMBeanServer
    def mbean = new GroovyMBean(server, 'bean:name=calcMBean')
    sleep 1000
    assert 8 == mbean.add(7, 1)
    mbean.Base = 8
    assert '10' == mbean.addStrings('7', '1')
    mbean.Base = 16
    sleep 2000
    println "Number of invocations: $mbean.Invocations"
    println mbean
}

assert 15 == calc.add(9, 6)
assert '11' == calc.addStrings('10', '1')
sleep 2000
assert '20' == calc.addStrings('1f', '1')</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是结果输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Number of invocations: 5
MBean Name:
  bean:name=calcMBean

Attributes:
  (rw) int Base
  (r) int Invocations
Operations:
  int add(int x, int y)
  java.lang.String addStrings(java.lang.String x, java.lang.String y)
  int getInvocations()
  int getBase()
  void setBase(int p1)</pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以在使用<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">jconsole</a>运行该进程时将其附加到该进程。它看起来像：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="assets/img/jconsole.gif" alt="控制台"></span></p>
</div>
<div class="paragraph">
<p>我们使用以下命令启动了Groovy应用程序： <code>-Dcom.sun.management.jmxremote</code> JVM参数。</p>
</div>
<div class="paragraph">
<p>也可以看看：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_dynamic-language-beans-in-spring">Spring中的动态语言bean</a></p>
</li>
<li>
<p><a href="#_using-spring-factories-with-groovy">通过Groovy使用Spring工厂</a></p>
</li>
<li>
<p><a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/jmx.html">Spring JMX文档</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_troubleshooting"><a class="anchor" href="#_troubleshooting"></a> 7。故障排除</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_java_lang_securityexception"><a class="anchor" href="#_java_lang_securityexception"></a> 7.1。 java.lang。SecurityException</h3>
<div class="paragraph">
<p>如果出现以下错误，则说明容器的JMX访问受密码保护：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.SecurityException: Authentication failed! Credentials required</pre>
</div>
</div>
<div class="paragraph">
<p>要解决此问题，请在连接时添加带有凭据的环境，如下所示（必须在此之前设置密码）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def jmxEnv = null
if (password != null) {
    jmxEnv = [(JMXConnector.CREDENTIALS): (String[])["monitor", password]]
}
def connector = JMXConnectorFactory.connect(new JMXServiceURL(serverUrl), jmxEnv)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您尝试监视/管理的软件的详细信息可能会略有不同。如果适用，请使用上述凭据查看其他示例（例如OC4J和WebLogic）。如果仍然有问题，则必须查阅您尝试监视/管理的软件的文档，以获取有关如何提供凭据的详细信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jmx_jmxbuilder"><a class="anchor" href="#jmx_jmxbuilder"></a> 8。JmxBuilder</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>JmxBuilder是Java管理扩展（JMX）API的基于Groovy的领域特定语言</strong> 。它使用构建器模式（FactoryBuilder）创建内部DSL，该DSL有助于通过MBean服务器将POJO和Groovy bean作为管理组件公开。JmxBuilder隐藏了通过JMX API创建和导出管理bean的复杂性，并提供了一组自然的Groovy构造来与JMX基础结构进行交互。</p>
</div>
<div class="sect2">
<h3 id="_instantiating_jmxbuilder"><a class="anchor" href="#_instantiating_jmxbuilder"></a> 8.1。实例化JmxBuilder</h3>
<div class="paragraph">
<p>要开始使用JmxBuilder，只需确保jar文件在类路径中即可。然后，您可以在代码中执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def jmx = new JmxBuilder()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>而已！</strong> 现在您可以使用JmxBuilder。</p>
</div>
<div class="paragraph">
<p><strong>注意</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>您可以将<strong>自己的MBeanServer</strong>的实例传递给构建器（ <strong>JmxBuilder（MBeanServer）</strong> ）</p>
</li>
<li>
<p>如果未指定MBeanServer，则构建器实例将默认为基础平台MBeanServer。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一旦有了JmxBuilder实例，就可以调用其任何构建器节点了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jmx_connectors"><a class="anchor" href="#_jmx_connectors"></a> 8.2。JMX连接器</h3>
<div class="paragraph">
<p>远程连接是JMX体系结构的关键部分。JmxBuilder以最少的编码量简化了连接器服务器和连接器客户端的创建。</p>
</div>
<div class="sect3">
<h4 id="_connector_server"><a class="anchor" href="#_connector_server"></a> 8.2.1。连接器服务器</h4>
<div class="paragraph">
<p>JmxBuilder.connectorServer（）支持完整的Connector api语法，并允许您指定属性，覆盖URL，指定自己的主机等。</p>
</div>
<div class="paragraph">
<p><strong>句法</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>jmx.connectorServer(
    protocol:"rmi",
    host:"...",
    port:1099,
    url:"...",
    properties:[
        "authenticate":true|false,
        "passwordFile":"...",
        "accessFile":"...",
        "sslEnabled" : true | false
        // any valid connector property
    ]
)</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，serverConnector节点将接受四个ServerConnector属性别名（authenticate，passwordFile，accessFile和sslEnabled）。您可以使用这些别名或提供任何RMI支持的属性。</p>
</div>
<div class="paragraph">
<p><strong>示例-连接器服务器（请参阅下面的更正）</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">jmx.connectorServer(port: 9000).start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码片段返回一个RMI连接器，该连接器将开始侦听端口9000。默认情况下，构建器将在内部生成URL <strong>“ service：jmx：rmi：/// jndi / rmi：// localhost：9000 / jmxrmi”</strong> 。</p>
</div>
<div class="paragraph">
<p><em>注意：可悲的是，当您尝试运行先前的代码片段时，您很可能会收到类似以下的内容（示例不完整，请参见下文）：</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre>Caught: java.io.IOException: Cannot bind to URL [rmi://localhost:9000/jmxrmi]: javax.naming.ServiceUnavailableException [Root exception is java.rmi.ConnectException: Connection refused to host: localhost; nested exception is:
?????? java.net.ConnectException: Connection refused]
??</pre>
</div>
</div>
<div class="paragraph">
<p><em>在安装了Groovy 1.6的Mac和Linux（CentOS 5）上会发生这种情况。也许对/ etc / hosts文件的配置有一些假设？</em></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<em>正确的示例如下所示。</em>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>连接器示例（已更正）-连接器服务器</strong></p>
</div>
<div class="paragraph">
<p>上面的示例未创建RMI注册表。因此，要导出，您必须先导出RMI对象注册表（确保导入<code>java.rmi.registry.LocateRegistry</code> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.rmi.registry.LocateRegistry
//...

LocateRegistry.createRegistry(9000)
jmx.connectorServer(port: 9000).start()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_connector_client"><a class="anchor" href="#_connector_client"></a> 8.2.2。连接器客户端</h4>
<div class="paragraph">
<p>通过JmxBuilder.connectorClient（）节点，您可以创建JMX连接器客户端对象以连接到JMX MBean服务器。</p>
</div>
<div class="paragraph">
<p><strong>句法</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>jmx.connectorClient (
    protocol:"rmi",
    host:"...",
    port:1099,
    url:"...",
)</pre>
</div>
</div>
<div class="paragraph">
<p><strong>示例-客户端连接器</strong></p>
</div>
<div class="paragraph">
<p>创建连接器客户端可以轻松完成。使用一行代码，您可以创建JMX连接器客户端的实例，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def client = jmx.connectorClient(port: 9000)
client.connect()</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用以下方法访问与连接器关联的MBeanServerConnection：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">client.getMBeanServerConnection()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jmxbuilder_mbean_export"><a class="anchor" href="#_jmxbuilder_mbean_export"></a> 8.3。JmxBuilder MBean导出</h3>
<div class="paragraph">
<p>您可以使用最少的代码<strong>导出Java对象或Groovy对象</strong> 。JmxBuilder甚至可以找到并<strong>导出</strong>在运行时注入的<strong>动态Groovy方法</strong> 。</p>
</div>
<div class="sect3">
<h4 id="_implicit_vs_explicit_descriptors"><a class="anchor" href="#_implicit_vs_explicit_descriptors"></a> 8.3.1。隐式与显式描述符</h4>
<div class="paragraph">
<p>使用构建器时，可以<strong>让JmxBuilder隐式生成</strong>所有MBean描述符信息。当您要编写最少的代码以快速导出bean时，这很有用。您还可以显式声明该bean的所有描述符信息。这使您可以完全控制如何描述要为基础bean导出的每条信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_jmxbuilder_export_node"><a class="anchor" href="#_the_jmxbuilder_export_node"></a> 8.3.2。JmxBuilder.export（）节点</h4>
<div class="paragraph">
<p><strong>JmxBuilder.export（）节点提供了一个容器</strong> ，所有要导出到MBeanServer的管理实体都放置在<strong>该容器</strong>中。您可以放置一个或多个bean（）或timer（）节点作为export（）节点的子节点。JmxBuilder将<strong>自动</strong>将节点<strong>描述的实体批量导出</strong>到MBean服务器进行管理（请参见下面的示例）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def beans = jmx.export {
    bean(new Foo())
    bean(new Bar())
    bean(new SomeBar())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码片段中， <strong>JmxBuilder.export（）将三个管理Bean导出</strong>到MBean服务器。</p>
</div>
</div>
<div class="sect3">
<h4 id="_jmxbuilder_export_syntax"><a class="anchor" href="#_jmxbuilder_export_syntax"></a> 8.3.3。JmxBuilder.export（）语法</h4>
<div class="paragraph">
<p>JmxBuilder.export（）节点支持<strong>registrationPolicy</strong>参数，以指定JmxBuilder在MBean注册期间如何解决bean名称冲突：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>jmx.export(policy:"replace|ignore|error")
or
jmx.export(regPolicy:"replace|ignore|error")</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>替换</strong> -JmxBuilder.export（）将替换在导出过程中已向MBean注册的所有bean。</p>
</li>
<li>
<p><strong>ignore-</strong>如果已经注册了相同的bean，则将忽略正在导出的bean。</p>
</li>
<li>
<p><strong>错误</strong> -JmxBuilder.export（）在注册期间发生bean名称冲突时引发错误。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_integration_with_groovymbean_class"><a class="anchor" href="#_integration_with_groovymbean_class"></a> 8.3.4。与GroovyMBean类集成</h4>
<div class="paragraph">
<p>当您将MBean导出到MBeanServer时， <strong>JmxBuilder将返回一个GroovyMBean实例，该实例</strong>代表构建器已导出的管理Bean。诸如<strong>bean（）</strong>和<strong>timer（）</strong>之类的节点在被调用时将返回GroovyMBean的实例。<strong>export（）</strong>节点返回<strong>所有GroovyMBean []</strong>的<strong>数组，这些数组</strong>代表所有导出到MBean服务器的托管对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_mbean_registration_with_jmxbuilder_bean"><a class="anchor" href="#_mbean_registration_with_jmxbuilder_bean"></a> 8.3.5。使用JmxBuilder.bean（）进行MBean注册</h4>
<div class="paragraph">
<p>本参考资料的这一部分使用类<strong>RequestController</strong>来说明如何使用JmxBuilder导出运行时管理bean。该类用于说明目的，可以是POJO或Groovy bean。</p>
</div>
<div class="paragraph">
<p><strong>RequestController</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class RequestController {
    // constructors
    RequestController() { super() }
    RequestController(Map resource) { }

    // attributes
    boolean isStarted() { true }
    int getRequestCount() { 0 }
    int getResourceCount() { 0 }
    void setRequestLimit(int limit) { }
    int getRequestLimit() { 0 }

    // operations
    void start() { }
    void stop() { }
    void putResource(String name, Object resource) { }
    void makeRequest(String res) { }
    void makeRequest() { }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_implicit_export"><a class="anchor" href="#_implicit_export"></a>隐式导出</h5>
<div class="paragraph">
<p>如前所述，您可以使用JmxBuilder的灵活语法来导出没有描述符的任何POJO / POGO。构建器可以使用隐式默认值自动描述管理Bean的所有方面。这些默认值很容易被覆盖，正如我们将在下一节中看到的那样。</p>
</div>
<div class="paragraph">
<p>下面列出了导出POJO或POGO的最简单方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">jmx.export {
    bean(new RequestController(resource: "Hello World"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>这是做什么的：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先， <strong>JmxBuilder.export（）节点会将</strong> MBean <strong>导出</strong>到表示<strong>已声明的POJO</strong>实例的MBeanServer。</p>
</li>
<li>
<p>构建器将为MBean和所有其他MBean描述符信息<strong>生成一个默认的ObjectName</strong> 。</p>
</li>
<li>
<p><strong>JmxBuilder将自动导出</strong>实例上的所有声明的<strong>属性</strong> （MBean getter / setters）， <strong>构造函数</strong>和<strong>操作</strong> 。</p>
</li>
<li>
<p>导出的<strong>属性</strong>将具有<strong>只读</strong>可见性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>记住， <strong>JmxBuilder.export（）</strong>为所有导出的实例<strong>返回一个GroovyMBean []对象的数组</strong> 。因此，一旦调用JmxBuilder.export（）， <strong>就可以立即访问基础MBean代理</strong> （通过GroovyMBean）。</p>
</div>
<div class="sect5">
<h6 id="_jconsole_view_of_exported_bean"><a class="anchor" href="#_jconsole_view_of_exported_bean"></a>导出Bean的JConsole视图</h6>
<div class="paragraph">
<p><span class="image"><img src="assets/img/jconsole-implicit-export.png" alt="jconsole隐式导出"></span></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jmxbuilder_bean_syntax"><a class="anchor" href="#_jmxbuilder_bean_syntax"></a> 8.3.6。JmxBuilder.bean（）语法</h4>
<div class="paragraph">
<p>JmxBuilder.bean（）节点支持广泛的描述符集，以描述要管理的bean。JMX MBeanServer使用这些描述符公开有关为管理而公开的bean的元数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>jmx.export {
    bean(
        target:bean instance,
        name:ObjectName,
        desc:"...",
        attributes:"*",
        attributes:[]
        attributes:[ "AttrubuteName1","AttributeName2",...,"AttributeName_n" ]
        attributes:[
            "AttributeName":"*",
            "AttributeName":[
                desc:"...",
                defaultValue:value,
                writable:true|false,
                editable:true|false,
                onChange:{event-&gt; // event handler}
            ]
        ],

        constructors:"*",
        constructors:[
            "Constructor Name":[],
            "Constructor Name":[ "ParamType1","ParamType2,...,ParamType_n" ],
            "Constructor Name":[
                desc:"...",
                params:[
                    "ParamType1":"*",
                    "ParamType2":[desc:"...", name:"..."],...,
                    "ParamType_n":[desc:"...", name:"..."]
                ]
            ]
        ],

        operations:"*",
        operations:[ "OperationName1", "OperationName2",...,"OperationNameN" ],
        operations:[
            "OperationName1":"*",
            "OperationName2":[ "type1","type2,"type3" ]
            "OperationName3":[
                desc:"...",
                params:[
                    "ParamType1":"*"
                    "ParamType2":[desc:"...", name:"..."],...,
                    "ParamType_n":[desc:"...", name:"..."]
                ],
                onInvoked:{event-&gt; JmxBuilder.send(event:"", to:"")}
            ]
        ],

        listeners:[
            "ListenerName1":[event: "...", from:ObjectName, call:{event-&gt;}],
            "ListenerName2":[event: "...", from:ObjectName, call:&amp;methodPointer]
        ]

    )
}</pre>
</div>
</div>
<div class="paragraph">
<p>以下部分不介绍整个节点，而是分别探讨每个属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_bean_node_specifying_mbean_objectname"><a class="anchor" href="#_bean_node_specifying_mbean_objectname"></a> 8.3.7。Bean（）节点-指定MBean ObjectName</h4>
<div class="paragraph">
<p>使用bean（）节点描述符，可以指定自己的MBean ObjectName。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ctrl = new RequestController(resource:"Hello World")
def beans = jmx.export {
    bean(target: ctrl, name: "jmx.tutorial:type=Object")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将ObjectName指定为String或ObjectName的实例。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bean_node_attribute_export"><a class="anchor" href="#_bean_node_attribute_export"></a> 8.4。Bean（）节点-属性导出</h3>
<div class="paragraph">
<p>JMX属性是基础bean上的设置器和获取器。JmxBuilder.bean（）节点提供了几种灵活描述和导出MBean属性的方法。您可以将它们组合在一起，但是要获得任何级别的属性可见性。让我们来看看。</p>
</div>
<div class="sect3">
<h4 id="_export_all_attributes_with_wildcard"><a class="anchor" href="#_export_all_attributes_with_wildcard"></a> 8.4.1。导出所有带有通配符“ *”的属性</h4>
<div class="paragraph">
<p>以下代码片段<strong>将描述并导出</strong> bean上的<strong>所有属性</strong>为只读。<strong>JmxBuilder将使用默认值</strong>来描述为管理导出的属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(target: new RequestController(),
    name: objName,
    attributes: "*")
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_export_attribute_list"><a class="anchor" href="#_export_attribute_list"></a> 8.4.2。导出属性列表</h4>
<div class="paragraph">
<p>JmxBuilder将允许您指定要导出的属性列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        attributes: ["Resource", "RequestCount"]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码段中， <strong>只会导出“ Resource”和“ RequestCount”属性</strong> 。同样，由于没有提供描述符，因此<strong>JmxBuilder将使用合理的默认值</strong>来描述导出的属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_export_attribute_with_explicit_descriptors"><a class="anchor" href="#_export_attribute_with_explicit_descriptors"></a> 8.4.3。带有明确描述符的导出属性</h4>
<div class="paragraph">
<p>JmxBuilder的优势之一是它在描述MBean方面的灵活性。使用构建器，您可以描述要导出到MBeanServer的MBeans属性的所有方面（请参见上面的语法）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        attributes: [
            "Resource": [desc: "The resource to request.", readable: true, writable: true, defaultValue: "Hello"],
            "RequestCount": "*"
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码片段中，使用JMX属性的所有受支持的描述符（即desc，可读，可写，defaultValue） <strong>完整描述了</strong>属性<strong>“ Resource”</strong> 。但是，我们使用通配符描述属性<strong>RequestCount</strong> ，它将使用默认值导出和描述。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bean_node_constructor_export"><a class="anchor" href="#_bean_node_constructor_export"></a> 8.5。Bean（）节点-构造函数导出</h3>
<div class="paragraph">
<p>JmxBuilder <strong>支持</strong>在底层bean中定义<strong>的构造函数的显式描述和导出</strong> 。导出构造函数时，有几个选项可用。您可以将它们组合在一起，但是要达到所需的可管理性水平。</p>
</div>
<div class="sect3">
<h4 id="_export_all_constructors_with"><a class="anchor" href="#_export_all_constructors_with"></a> 8.5.1。用“ *”导出所有构造函数</h4>
<div class="paragraph">
<p>您可以使用构建器的特殊“ *” <strong>符号导出</strong>在基础bean上声明的<strong>所有构造器</strong> 。构建器将使用默认值来描述MBean构造器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        constructors: "*"
    )
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_export_constructors_using_parameter_descriptor"><a class="anchor" href="#_export_constructors_using_parameter_descriptor"></a> 8.5.2。使用参数描述符导出构造函数</h4>
<div class="paragraph">
<p>JmxBuilder允许您<strong>通过描述参数签名</strong>来指定要导出<strong>的</strong> <strong>特定构造函数</strong> 。当您具有多个具有不同参数签名的构造函数并且要导出特定的构造函数时，此功能很有用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        constructors: [
            "RequestController": ["Object"]
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，JmxBuilder将<strong>导出一个采用类型为“ Object”的参数的构造函数</strong> 。同样，JmxBuilder将使用默认值填写构造函数和参数的描述。</p>
</div>
</div>
<div class="sect3">
<h4 id="_export_constructor_with_explicit_descriptors"><a class="anchor" href="#_export_constructor_with_explicit_descriptors"></a> 8.5.3。具有显式描述符的导出构造函数</h4>
<div class="paragraph">
<p>JmxBuilder允许您<strong>完整描述</strong>要导出的目标构造函数（请参见上面的语法）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(target: new RequestController(), name: objName,
        constructors: [
            "RequestController": [
                desc: "Constructor takes param",
                params: ["Object" : [name: "Resource", desc: "Resource for controller"]]
            ]
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码中，JmxBuilder将针对采用一个参数导出到MBeanServer的构造函数。注意，如何使用所有可选的描述符键（包括参数描述符）对构造函数进行完整描述。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bean_node_operation_export"><a class="anchor" href="#_bean_node_operation_export"></a> 8.6。Bean（）节点-操作导出</h3>
<div class="paragraph">
<p>与构造函数类似，JmxBuilder支持使用灵活的表示法来描述和导出MBean操作（有关语法，请参见上文）。您可以组合这些符号，但是要达到所需的操作可管理性水平。</p>
</div>
<div class="sect3">
<h4 id="_export_all_operations_with"><a class="anchor" href="#_export_all_operations_with"></a> 8.6.1。用“ *”导出所有操作</h4>
<div class="paragraph">
<p>您可以使用构建器的特殊“ *” <strong>符号导出</strong>在bean上定义的<strong>所有</strong>要公开进行管理的操作。构建器将对导出的操作使用默认描述符值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        operations: "*"
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此代码段中，JmxBuilder将<strong>导出所有bean操作</strong> ，并将使用默认值在MBeanServer中对其进行描述。</p>
</div>
</div>
<div class="sect3">
<h4 id="_export_operation_list"><a class="anchor" href="#_export_operation_list"></a> 8.6.2。出口业务清单</h4>
<div class="paragraph">
<p>JmxBuilder具有一种简写的表示法，通过提供一系列导出方法，您可以快速定位要导出的操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        operations: ["start", "stop"]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码段中， <strong>构建器将仅导出方法start（）和stop（）</strong> 。所有其他方法将被忽略。JmxBuilder将使用默认描述符值来描述正在导出的操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_export_operations_by_signature"><a class="anchor" href="#_export_operations_by_signature"></a> 8.6.3。签名导出操作</h4>
<div class="paragraph">
<p>使用JmxBuilder，您可以使用方法的参数签名将方法定位为导出以进行管理。当您想要区分要导出的同名方法（即stop（）而不是stop（boolean））时，这很有用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        operations: [
            "makeRequest": ["String"]
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码段中，JmxBuilder将<strong>选择</strong>要导出的<strong>方法</strong> makeRequest <strong>（String）</strong>而不是不带参数的其他版本makeRequest（）。在此速记上下文中，签名被指定为类型列表（即“字符串”）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_export_operations_with_explicit_descriptors"><a class="anchor" href="#_export_operations_with_explicit_descriptors"></a> 8.6.4。带有明确描述符的导出操作</h4>
<div class="paragraph">
<p>JmxBuilder支持bean操作的详细描述符。您可以提供有关bean上任何操作的深层描述符信息，包括名称，描述，方法参数，参数类型和参数描述。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(target: new RequestController(), name: objName,
        operations: [
            "start": [desc: "Starts request controller"],
            "stop": [desc: "Stops the request controller"],
            "setResource": [params: ["Object"]],
            "makeRequest": [
                desc: "Executes the request.",
                params: [
                    "String": [name: "Resource", desc: "The resource to request"]
                ]
            ]
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码片段显示了JmxBuilder允许您描述针对管理的操作的所有方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>操作<strong>start（）和stop（）</strong>由“ desc”键描述（这已经足够，因为没有参数）。</p>
</li>
<li>
<p>在操作<strong>setResource（）中，</strong>使用<strong>params</strong>的简写形式：描述方法的参数。</p>
</li>
<li>
<p><strong>makeRequest（）</strong>使用扩展的描述符语法来描述操作的所有方面。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_embedding_descriptor"><a class="anchor" href="#_embedding_descriptor"></a> 8.7。嵌入描述符</h3>
<div class="paragraph">
<p>JmxBuilder支持<strong>将描述符直接嵌入Groovy类的功能</strong> 。因此，您可以将JMX描述符直接嵌入类中，而不必将描述围绕声明的对象（如此处所示）进行包装。</p>
</div>
<div class="paragraph">
<p><strong>RequestControllerGroovy</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class RequestControllerGroovy {
    // attributes
    boolean started
    int requestCount
    int resourceCount
    int requestLimit
    Map resources

    // operations
    void start() { }
    void stop(){ }
    void putResource(String name, Object resource) { }
    void makeRequest(String res) { }
    void makeRequest() { }

    static descriptor = [
        name: "jmx.builder:type=EmbeddedObject",
        operations: ["start", "stop", "putResource"],
        attributes: "*"
    ]
}

// export
jmx.export(
    bean(new RequestControllerGroovy())
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码中有两件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义了Groovy类RequestControllerGroovy，它包括一个<strong>静态描述符</strong>成员。该成员用于声明JmxBuilder描述符，以描述针对JMX导出的类的成员。</p>
</li>
<li>
<p>代码的第二部分显示了如何使用JmxBuilder导出该类进行管理。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_timer_export"><a class="anchor" href="#_timer_export"></a> 8.8。计时器导出</h3>
<div class="paragraph">
<p>JMX标准要求API的实现必须提供计时器服务。由于JMX是基于组件的体系结构，因此计时器提供了一种出色的信令机制来与MBeanServer中已注册的侦听器组件进行通信。JmxBuilder支持使用到目前为止所见的相同简单语法创建和导出计时器。</p>
</div>
<div class="sect3">
<h4 id="_timer_node_syntax"><a class="anchor" href="#_timer_node_syntax"></a> 8.8.1。计时器节点语法</h4>
<div class="listingblock">
<div class="content">
<pre>timer(
    name:ObjectName,
    event:"...",
    message:"...",
    data:dataValue
    startDate:"now"|dateValue
    period:"99d"|"99h"|"99m"|"99s"|99
    occurrences:long
)</pre>
</div>
</div>
<div class="paragraph">
<p>timer（）节点支持几种属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>name</strong> ：-必需计时器的合格JMX ObjectName实例（或String）。</p>
</li>
<li>
<p><strong>event</strong> ：-将与每个定时信号一起广播的JMX事件类型字符串（默认为<strong>“ jmx.builder.event”</strong> ）。</p>
</li>
<li>
<p><strong>message</strong> ：-可以发送给侦听器的可选字符串值。</p>
</li>
<li>
<p><strong>data</strong> ：-一个可选对象，可以发送给定时信号的侦听器。</p>
</li>
<li>
<p><strong>startDate</strong> ：-何时启动计时器。一组有效值[“ now”，日期对象]。默认为“现在”</p>
</li>
<li>
<p><strong>period</strong> ：-计时器的时间段，以毫秒或时间单位（天，小时，分钟，秒）表示。请参阅下面的说明。</p>
</li>
<li>
<p><strong>出现次数</strong> ：-一个数字，指示重复计时器的时间。默认是永远的。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_exporting_a_timer"><a class="anchor" href="#_exporting_a_timer"></a> 8.8.2。导出计时器</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def timer = jmx.timer(name: "jmx.builder:type=Timer", event: "heartbeat", period: "1s")
timer.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码段<strong>描述，创建和导出了标准的JMX Timer</strong>组件。在这里， <strong>timer（）</strong>节点<strong>返回一个GroovyMBean</strong> ，它表示MBeanServer中已注册的计时器MBean。</p>
</div>
<div class="paragraph">
<p><strong>导出计时器</strong>的<strong>另一种方法</strong>是在JmxBuilder.export（）节点内。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def beans = jmx.export {
    timer(name: "jmx.builder:type=Timer1", event: "event.signal", period: "1s")
    timer(name: "jmx.builder:type=Timer2", event: "event.log", period: "1s")
}
beans[0].start()
beans[1].start()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_timer_period"><a class="anchor" href="#_timer_period"></a> 8.8.3。计时器周期</h4>
<div class="paragraph">
<p><strong>timer（）节点支持</strong>用于指定<strong>计时器周期值</strong> <strong>的灵活表示法</strong> 。您可以以秒，分钟，小时和天为单位指定时间。默认值是毫秒。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计时器（ <strong>周期：100</strong> ）= 100毫秒</p>
</li>
<li>
<p>timer（ <strong>period：“ 1s”</strong> ）= 1秒</p>
</li>
<li>
<p>计时器（ <strong>周期：“ 1m”</strong> ）= 1分钟</p>
</li>
<li>
<p>timer（ <strong>period：“ 1h”</strong> ）= 1小时</p>
</li>
<li>
<p>timer（ <strong>period：“ 1d”</strong> ）= 1天</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>节点将自动翻译。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jmxbuilder_and_events"><a class="anchor" href="#_jmxbuilder_and_events"></a> 8.9。JmxBuilder和事件</h3>
<div class="paragraph">
<p><strong>事件模型</strong>是<strong>JMX</strong>不可或缺的一部分。已注册的管理Bean可以<strong>通过</strong>在MBeanServer的事件总线上<strong>广播事件</strong>来<strong>相互通信</strong> 。<strong>JmxBuilder提供了几种方法来轻松侦听</strong> MBeanServer事件总线上广播的事件<strong>并对事件做出反应</strong> 。开发人员可以<strong>捕获总线上的任何事件，</strong>也可以<strong>自己抛出事件</strong>以供MBeanServer上注册的其他组件使用。</p>
</div>
<div class="sect3">
<h4 id="_event_handling_closures"><a class="anchor" href="#_event_handling_closures"></a> 8.9.1。事件处理关闭</h4>
<div class="paragraph">
<p>JmxBuilder利用Groovy对闭包的使用来提供对JMX事件做出反应的简单而优雅的方法。JmxBuilder支持两个闭包签名：</p>
</div>
<div class="sect4">
<h5 id="_parameterless"><a class="anchor" href="#_parameterless"></a>无参数</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">callback = { -&gt;
    // event handling code here.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JmxBuilder执行关闭操作，不传递有关在总线上捕获的事件的信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="_with_event_parameter"><a class="anchor" href="#_with_event_parameter"></a>带事件参数</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">callback = { event -&gt;
    // event handling code
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JmxBuilder将使用此格式将<strong>“事件”对象传递给闭包</strong> 。事件对象包含有关事件被拦截的信息，以便处理程序可以处理它。根据捕获的事件，参数将包含不同的信息集。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_attribute_onchange_event"><a class="anchor" href="#_handling_attribute_onchange_event"></a> 8.9.2。处理属性onChange事件</h4>
<div class="paragraph">
<p>描述属性时（请参见上面的bean（）节点部分），可以<strong>提供一个闭包（或方法指针），以便</strong>在导出的MBean上<strong>更新属性值时执行回调</strong> 。这为开发人员提供了听取并响应MBean状态更改的机会。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">jmx.export {
    bean(
        target: new RequestController(), name: "jmx.tutorial:type=Object",
        attributes: [
            "Resource": [
                readable: true, writable: true,
                onChange: { e -&gt;
                    println e.oldValue
                    println e.newValue
                }
            ]
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例代码片段说明了在描述MBean属性时如何<strong>指定“ onChange”回调闭包</strong> 。在此示例代码中，只要通过导出的MBean更新属性“ Resource”， <strong>就会执行onChange事件</strong> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_attribute_onchange_event_object"><a class="anchor" href="#_attribute_onchange_event_object"></a> 8.9.3。属性onChange事件对象</h4>
<div class="paragraph">
<p>处理属性onChange事件时，处理程序关闭将接收带有以下信息的事件对象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>事件。 <strong>oldValue-</strong>更改事件之前的上一个属性值。</p>
</li>
<li>
<p>事件。 <strong>newValue-</strong>更改后属性的新值。</p>
</li>
<li>
<p>事件。 <strong>attribute-</strong>发生事件的属性的名称。</p>
</li>
<li>
<p>事件。 <strong>attributeType-</strong>导致事件的属性的数据类型。</p>
</li>
<li>
<p>事件。 <strong>sequenceNumber-</strong>一个数字值，表示事件的序列号。</p>
</li>
<li>
<p>事件。 <strong>timeStamp-</strong>事件发生的时间戳。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_handling_operation_oncall_event"><a class="anchor" href="#_handling_operation_oncall_event"></a> 8.9.4。处理onCall事件</h4>
<div class="paragraph">
<p>与mbean属性类似，JmxBuilder使开发人员<strong>能够侦听</strong>在MBeaServer中注册的MBean上的<strong>操作调用</strong> 。JmxBuilder接受<strong>将在MBean方法调用后执行</strong>的<strong>回调关闭</strong> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class EventHandler {
    void handleStart(e){
        println e
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def handler = new EventHandler()

def beans = jmx.export {
    bean(target: new RequestController(), name: "jmx.tutorial:type=Object",
        operations: [
            "start": [
                desc:"Starts request controller",
                onCall:handler.&amp;handleStart
            ]
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码片段<strong>显示了如何</strong>在MBean上调用操作“ start（）”时<strong>声明“ onCall”闭包以用作侦听器</strong> 。本示例<strong>使用方法指针语法</strong>来说明JmxBuilder的多功能性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_operation_oncall_event_object"><a class="anchor" href="#_operation_oncall_event_object"></a> 8.9.5。操作onCall事件对象</h4>
<div class="paragraph">
<p>在处理操作onCall事件时，回调关闭将接收带有以下信息的事件对象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>事件。 <strong>event-</strong>广播的事件类型字符串。</p>
</li>
<li>
<p>事件。 <strong>源</strong> -在其上调用的方法的对象。</p>
</li>
<li>
<p>事件。 <strong>数据</strong> -使所述事件属性的数据类型。</p>
</li>
<li>
<p>事件。 <strong>sequenceNumber-</strong>一个数字值，表示事件的序列号。</p>
</li>
<li>
<p>事件。 <strong>timeStamp-</strong>事件发生的时间戳。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listener_mbean"><a class="anchor" href="#_listener_mbean"></a> 8.10。侦听器MBean</h3>
<div class="paragraph">
<p>当使用bean（）节点导出MBean时，可以定义MBean可以侦听和响应的事件。bean（）节点提供了“ listeners：”属性，该属性使您可以定义bean可以响应的事件侦听器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def beans = jmx.export {
    timer(name: "jmx.builder:type=Timer", event: "heartbeat", period: "1s").start()
    bean(target: new RequestController(), name: "jmx.tutorial:type=Object",
        operations: "*",
        listeners: [
            heartbeat: [
                from: "jmx.builder:type=Timer",
                call: { e -&gt;
                    println e
                }
            ]
        ]
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，我们看到了<strong>将侦听器添加到导出的MBean</strong>的<strong>语法</strong> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>拳头， <strong>计时器被导出</strong>并启动。</p>
</li>
<li>
<p>然后<strong>声明</strong>一个<strong>MBean，它将侦听计时器</strong>事件并执行有意义的操作。</p>
</li>
<li>
<p><strong>“ heartbeat：”</strong>名称是任意的，并且与上面声明的计时器没有任何关联。</p>
</li>
<li>
<p><strong>使用“ from：”属性指定</strong>事件的<strong>来源</strong> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以指定您有兴趣从广播公司接收的<strong>事件类型</strong> （因为广播公司可以发出多个事件）。</p>
</div>
<div class="sect3">
<h4 id="_listening_to_jmx_events"><a class="anchor" href="#_listening_to_jmx_events"></a> 8.10.1。收听JMX事件</h4>
<div class="paragraph">
<p>在某些情况下，您将需要创建独立的事件侦听器（不附加到导出的MBean）。JmxBuilder提供了Listener（）节点，使您可以创建可以侦听MBeanServer事件的JMX侦听器。当创建JMX客户端应用程序以监视/管理远程JMX MBeanServer上的JMX代理时，这很有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_listener_node_syntax"><a class="anchor" href="#_listener_node_syntax"></a> 8.10.2。侦听器节点语法</h4>
<div class="listingblock">
<div class="content">
<pre>jmx.listener(
    event: "...",
    from: "object name" | ObjectName,
    call: { event-&gt; }
)</pre>
</div>
</div>
<div class="paragraph">
<p>这是<strong>listener（）</strong>节点属性的描述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>event：可选字符串，用于标识要侦听的JMX事件类型。</p>
</li>
<li>
<p>from（必填）：要侦听的组件的JMX ObjectName。可以指定为字符串或ObjectName的实例</p>
</li>
<li>
<p>call：捕获事件时要执行的闭包。也可以将其指定为Groovy方法指针。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是JmxBuilder的侦听器节点的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">jmx.timer(name: "jmx.builder:type=Timer", period: "1s").start()

jmx.listener(
    from: "jmx.builder:type=Timer",
    call: { e -&gt;
        println "beep..."
    }
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例说明如何使用独立的侦听器（在MBean导出之外）。在这里，我们<strong>导出一个</strong>分辨率<strong>为1秒的计时器</strong> 。然后，我们为该计时器指定一个侦听器，该侦听器将每秒打印一次“哔”声。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_emitting_jmx_events"><a class="anchor" href="#_emitting_jmx_events"></a> 8.11。发出JMX事件</h3>
<div class="paragraph">
<p>JmxBuilder提供了在MBeanServer的事件总线上<strong>广播自己的事件所需</strong>的<strong>工具</strong> 。您可以广播的事件类型没有限制。您只需<strong>声明您的发射器</strong>和您要发送的事件类型，然后随时<strong>广播您的事件</strong> 。MBeanServer中任何已注册的组件都可以注册自己以侦听您的事件。</p>
</div>
<div class="sect3">
<h4 id="_emitter_syntax"><a class="anchor" href="#_emitter_syntax"></a> 8.11.1。发射器语法</h4>
<div class="listingblock">
<div class="content">
<pre>jmx.emitter(name:"Object:Name", event:"type")</pre>
</div>
</div>
<div class="paragraph">
<p>节点Emitter（）的属性可以总结如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>名称：可选的JMX ObjectName，用于在MBeanServer中注册您的发射器。默认值为jmx.builder：type = Emitter，name = Emitter @ OBJECT_HASH_VALUE</p>
</li>
<li>
<p>event：描述JMX事件类型的选项字符串值。默认值为<strong>“ jmx.builder.event.emitter”</strong> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_declare_the_emitter"><a class="anchor" href="#_declare_the_emitter"></a> 8.11.2。声明发射器</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def emitter = jmx.emitter()</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码段<strong>使用隐式描述符语法声明了发射器</strong> 。JmxBuilder将执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建并注册带有默认ObjectName的发射器MBean。</p>
</li>
<li>
<p>设置值为<strong>“ jmx.builder.event.emitter”</strong>的<strong>默认事件类型</strong> 。</p>
</li>
<li>
<p>返回表示发射器的GroovyMBean。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与构建器中的其他节点一样， <strong>您可以覆盖generator（）节点中的所有键</strong> 。您可以指定<strong>ObjectName</strong>和<strong>事件类型</strong> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_broadcast_event"><a class="anchor" href="#_broadcast_event"></a> 8.11.3。广播事件</h4>
<div class="paragraph">
<p>声明发射器后，就可以广播事件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">emitter.send()</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例显示了<strong>发射器</strong>在声明<strong>事件</strong>后<strong>发送事件</strong> 。在MBeanServer中注册的任何JMX组件都可以注册以接收来自此发射器的消息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_sending_event_objects"><a class="anchor" href="#_sending_event_objects"></a> 8.11.4。发送事件对象</h4>
<div class="paragraph">
<p>发送消息时，可以选择将数据传递给接收者。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">emitter.send("Hello!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用<strong>接受参数</strong>的<strong>事件监听器闭包（请参见上文），则</strong>可以访问该值。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_jmx_information"><a class="anchor" href="#_further_jmx_information"></a> 9。更多JMX信息</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="http://www.ddj.com/dept/java/184406481?pgno=1">监控Java虚拟机</a></p>
</li>
<li>
<p><a href="http://buttso.blogspot.com/2006/05/using-groovy-for-system-management.html">使用Groovy进行系统管理</a></p>
</li>
<li>
<p><a href="https://blogs.oracle.com/sundararajan/entry/groovier_jconsole">Groovier jconsole！</a></p>
</li>
<li>
<p><a href="http://jmesnil.net/weblog/2007/05/23/jmx-scripts-with-eclipse-monkey">带有Eclipse Monkey的JMX脚本</a></p>
</li>
<li>
<p><a href="http://activemq.apache.org/jmx.html">使用JMX监视Apache ActiveMQ</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>最近更新时间2019-08-02 18:30:31 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=1">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>