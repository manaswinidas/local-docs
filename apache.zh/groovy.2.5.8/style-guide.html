<html lang="zh-Hans" ><head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Java开发人员的Groovy样式和语言功能准则</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="asset?aid=1">
</head>
<body class="book toc2 toc-left" >
<div id="header">
<h1>Java开发人员的Groovy样式和语言功能准则</h1>
<div class="details">
<span id="revnumber">版本2.5.8</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_no_semicolons">1。没有分号</a></li>
<li><a href="#_return_keyword_optional">2。返回关键字可选</a></li>
<li><a href="#_def_and_type">3。定义和类型</a></li>
<li><a href="#_public_by_default">4。默认为公开</a></li>
<li><a href="#_omitting_parentheses">5，省略括号</a></li>
<li><a href="#_classes_as_first_class_citizens">6。一流公民</a></li>
<li><a href="#_getters_and_setters">7。吸气剂和二传手</a></li>
<li><a href="#_initializing_beans_with_named_parameters_and_the_default_constructor">8。使用命名参数和默认构造函数初始化bean</a></li>
<li><a href="#_using_code_with_code_and_code_tap_code_for_repeated_operations_on_the_same_bean">9。使用<code>with()</code>和<code>tap()</code>在同一bean上重复操作</a></li>
<li><a href="#_equals_and_code_code">10。等于和<code>==</code></a></li>
<li><a href="#_gstrings_interpolation_multiline">11。GString（插值，多行）</a></li>
<li><a href="#_native_syntax_for_data_structures">12数据结构的本机语法</a></li>
<li><a href="#_the_groovy_development_kit">13Groovy开发套件</a></li>
<li><a href="#_the_power_of_switch">14。开关电源</a></li>
<li><a href="#_import_aliasing">15导入别名</a></li>
<li><a href="#_groovy_truth">16。时髦真相</a></li>
<li><a href="#_safe_graph_navigation">17。安全的图形导航</a></li>
<li><a href="#_assert">18岁断言</a></li>
<li><a href="#_elvis_operator_for_default_values">19Elvis运算符的默认值</a></li>
<li><a href="#_catch_any_exception">20捕获任何异常</a></li>
<li><a href="#_optional_typing_advice">21可选的打字建议</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>从事Groovy冒险的Java开发人员将始终牢记Java，并且将逐步学习Groovy（一次提供一项功能），变得更加高效并编写更多惯用的Groovy代码。本文档的目的是指导开发人员，并教授一些常用的Groovy语法样式，新的运算符以及诸如闭包之类的新功能。本指南并不完整，仅作为快速入门，是进一步的指南部分的基础。您是否想为文档做出贡献并加以完善。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_no_semicolons"><a class="anchor" href="#_no_semicolons"></a> 1。没有分号</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当来自C / C ++ / C＃/ Java背景时，我们已经习惯了分号，因此我们将它们放在各处。更糟的是，Groovy支持99％的Java语法，有时，将一些Java代码粘贴到您的Groovy程序中是如此容易，结果到处都是无数分号。但是... Groovy中的分号是可选的，您可以省略它们，并且删除它们更惯用了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_return_keyword_optional"><a class="anchor" href="#_return_keyword_optional"></a> 2。返回关键字可选</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Groovy中，可以返回在方法主体中求值的最后一个表达式，而不必使用<code>return</code>关键词。特别是对于短方法和闭包，为简洁起见最好省略它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String toString() { return "a server" }
String toString() { "a server" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是有时候，当您使用变量并在两行上两次直观地看到它时，这看起来不太好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def props() {
    def m1 = [a: 1, b: 2]
    m2 = m1.findAll { k, v -&gt; v % 2 == 0 }
    m2.c = 3
    m2
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，请在最后一个表达式之前放置换行符，或显式使用<code>return</code>可能会产生更好的可读性。</p>
</div>
<div class="paragraph">
<p>我（对我自己）有时会使用<code>return</code>关键字，有时不是，这通常是一个品味问题。但是，例如，在封闭内部，我们经常会经常省略它。因此，即使关键字是可选的，如果您认为它妨碍了代码的可读性，则绝不强制不使用它。</p>
</div>
<div class="paragraph">
<p>但是请注意。当使用定义的方法时<code>def</code>关键字而不是特定的具体类型，有时您会惊讶地看到最后一个表达式被返回。因此通常更喜欢使用特定的返回类型，例如void或type。在上面的示例中，假设我们忘记将m2作为要返回的最后一条语句，那么最后一个表达式将是<code>m2.c = 3</code>它将返回... <code>3</code> ，而不是您期望的地图。</p>
</div>
<div class="paragraph">
<p>像这样的陈述<code>if</code> / <code>else</code> ， <code>try</code> / <code>catch</code>因此也可以返回一个值，因为这些语句中有一个“最后一个表达式”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(n) {
    if(n == 1) {
        "Roshan"
    } else {
        "Dawrani"
    }
}

assert foo(1) == "Roshan"
assert foo(2) == "Dawrani"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_def_and_type"><a class="anchor" href="#_def_and_type"></a> 3。定义和类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当我们在谈论<code>def</code>和类型，我经常看到开发人员同时使用<code>def</code>和一种。但<code>def</code>这里是多余的。因此，选择使用<code>def</code>或类型。</p>
</div>
<div class="paragraph">
<p>所以不要写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def String name = "Guillaume"</code></pre>
</div>
</div>
<div class="paragraph">
<p>但：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String name = "Guillaume"</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用时<code>def</code>在Groovy中，实际的类型持有人是<code>Object</code> （因此您可以将任何对象分配给使用定义的变量<code>def</code> ，如果声明方法返回，则返回任何类型的对象<code>def</code> ）。</p>
</div>
<div class="paragraph">
<p>使用无类型参数定义方法时，可以使用<code>def</code>但这不是必需的，因此我们倾向于忽略它们。所以代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void doSomething(def param1, def param2) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>首选：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void doSomething(param1, param2) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，正如我们在文档的最后一部分中提到的那样，通常最好键入方法参数，以帮助记录代码，并帮助IDE进行代码完成或利用静态类型检查或静态编译功能Groovy。</p>
</div>
<div class="paragraph">
<p>另一个地方<code>def</code>是多余的，应在定义构造函数时避免使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyClass {
    def MyClass() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，只需删除<code>def</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyClass {
    MyClass() {}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_public_by_default"><a class="anchor" href="#_public_by_default"></a> 4。默认为公开</h2>
<div class="sectionbody">
<div class="paragraph">
<p>默认情况下，Groovy考虑类和方法<code>public</code> 。因此，您不必使用<code>public</code>修饰符随处可见。仅当它不公开时，才应放置可见性修改器。</p>
</div>
<div class="paragraph">
<p>所以代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class Server {
    public String toString() { return "a server" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更简洁一些：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Server {
    String toString() { "a server" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会想知道“包范围”的可见性，而Groovy允许省略“ public”这一事实意味着默认情况下不支持此范围，但是实际上有一个特殊的Groovy批注，允许您使用该可见性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Server {
    @PackageScope Cluster cluster
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_omitting_parentheses"><a class="anchor" href="#_omitting_parentheses"></a> 5，省略括号</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy允许您省略顶级表达式的括号，例如<code>println</code>命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println "Hello"
method a, b</code></pre>
</div>
</div>
<div class="paragraph">
<p>vs：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println("Hello")
method(a, b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当闭包是方法调用的最后一个参数时，例如使用Groovy的<code>each{}</code>迭代机制，您可以将闭包放在右括号之外，甚至可以忽略括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">list.each( { println it } )
list.each(){ println it }
list.each  { println it }</code></pre>
</div>
</div>
<div class="paragraph">
<p>总是喜欢第三种形式，这是更自然的，因为一对空括号只是无用的语法噪音！</p>
</div>
<div class="paragraph">
<p>在某些情况下，需要使用括号，例如在进行嵌套方法调用时或在调用不带参数的方法时。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def foo(n) { n }
def bar() { 1 }

println foo 1 // won't work
def m = bar   // won't work</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_classes_as_first_class_citizens"><a class="anchor" href="#_classes_as_first_class_citizens"></a> 6。一流公民</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>.class</code>在Groovy中不需要后缀，有点像Java的<code>instanceof</code> 。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">connection.doPost(BASE_URI + "/modify.hqu", params, ResourcesResponse.class)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在下面使用GStrings进行介绍，并使用头等公民：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">connection.doPost("${BASE_URI}/modify.hqu", params, ResourcesResponse)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getters_and_setters"><a class="anchor" href="#_getters_and_setters"></a> 7。吸气剂和二传手</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Groovy中，getter和setter形成了我们所谓的“属性”，并提供了访问和设置此类属性的快捷方式。因此，可以使用类似于字段的访问符号来代替Java调用getter / setter的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">resourceGroup.getResourcePrototype().getName() == SERVER_TYPE_NAME
resourceGroup.resourcePrototype.name == SERVER_TYPE_NAME

resourcePrototype.setName("something")
resourcePrototype.name = "something"</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用Groovy（通常称为POGO）（普通的旧Groovy对象）编写bean时，您不必自己创建字段并进行getter / setter设置，而是让Groovy编译器为您完成。</p>
</div>
<div class="paragraph">
<p>所以代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    private String name
    String getName() { return name }
    void setName(String name) { this.name = name }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以简单地写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，没有修饰符可见性的独立的“字段”实际上使Groovy编译器可以为您生成私有字段以及getter和setter。</p>
</div>
<div class="paragraph">
<p>当使用Java中的此类POGO时，getter和setter确实存在，并且可以照常使用。</p>
</div>
<div class="paragraph">
<p>尽管编译器会创建通常的getter / setter逻辑，但如果您希望对这些getter / setter进行其他操作或其他操作，您仍然可以自由地提供它们，并且编译器将使用您的逻辑，而不是默认生成的逻辑。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_initializing_beans_with_named_parameters_and_the_default_constructor"><a class="anchor" href="#_initializing_beans_with_named_parameters_and_the_default_constructor"></a> 8。使用命名参数和默认构造函数初始化bean</h2>
<div class="sectionbody">
<div class="paragraph">
<p>用像这样的豆子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Server {
    String name
    Cluster cluster
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是按以下方式在后续语句中设置每个设置器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = new Server()
server.name = "Obelix"
server.cluster = aCluster</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以将命名参数与默认构造函数一起使用（首先调用构造函数，然后按在地图中指定设置器的顺序调用设置器）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def server = new Server(name: "Obelix", cluster: aCluster)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_code_with_code_and_code_tap_code_for_repeated_operations_on_the_same_bean"><a class="anchor" href="#_using_code_with_code_and_code_tap_code_for_repeated_operations_on_the_same_bean"></a> 9。使用<code>with()</code>和<code>tap()</code>在同一bean上重复操作</h2>
<div class="sectionbody">
<div class="paragraph">
<p>创建新实例时，使用默认构造函数的命名参数很有趣，但是如果要更新提供给您的实例，又需要一次又一次地重复“ server”前缀，该怎么办？不，多亏了<code>with()</code>和<code>tap()</code> Groovy在任何类型的所有对象上添加的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.name = application.name
server.status = status
server.sessionCount = 3
server.start()
server.stop()</code></pre>
</div>
</div>
<div class="paragraph">
<p>vs：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">server.with {
    name = application.name
    status = status
    sessionCount = 3
    start()
    stop()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与Groovy中的任何闭包一样，最后一条语句被视为返回值。在上面的示例中，这是<code>stop()</code> 。要将其用作构建器，它仅返回传入的对象，还存在<code>tap()</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def person = new Person().with {
    name = "Ada Lovelace"
    it // Note the explicit mention of it as the return value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>vs：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def person = new Person().tap {
    name = "Ada Lovelace"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：您也可以使用<code>with(true)</code>代替<code>tap()</code>和<code>with(false)</code>代替<code>with()</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_equals_and_code_code"><a class="anchor" href="#_equals_and_code_code"></a> 10。等于和<code>==</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java的<code>==</code>实际上是Groovy的<code>is()</code>方法和Groovy的<code>==</code>是一个聪明的人<code>equals()</code> ！</p>
</div>
<div class="paragraph">
<p>比较对象的引用，而不是<code>==</code> ，您应该使用<code>a.is(b)</code> 。</p>
</div>
<div class="paragraph">
<p>但是要照常做<code>equals()</code>比较，您应该更喜欢Groovy的<code>==</code> ，因为它还避免<code>NullPointerException</code> ，而不管左边还是右边<code>null</code>或不。</p>
</div>
<div class="paragraph">
<p>代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">status != null &amp;&amp; status.equals(ControlConstants.STATUS_COMPLETED)</code></pre>
</div>
</div>
<div class="paragraph">
<p>做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">status == ControlConstants.STATUS_COMPLETED</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gstrings_interpolation_multiline"><a class="anchor" href="#_gstrings_interpolation_multiline"></a> 11。GString（插值，多行）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们经常在Java中使用字符串和变量串联，其中许多<code>/</code>双引号，加号的结尾，以及<code>\n</code>换行符。使用内插的字符串（称为GStrings），这样的字符串看起来更好，而且键入起来也不会太麻烦：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">throw new Exception("Unable to convert resource: " + resource)</code></pre>
</div>
</div>
<div class="paragraph">
<p>vs：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">throw new Exception("Unable to convert resource: ${resource}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>在花括号内，您可以放置任何类型的表达式，而不仅仅是变量。对于简单变量，或<code>variable.property</code> ，甚至可以放下花括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">throw new Exception("Unable to convert resource: $resource")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以使用闭包标记来懒惰地求值那些表达式<code>${-> resource }</code> 。当GString强制转换为String时，它将评估闭包并获取<code>toString()</code>返回值的表示形式。</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int i = 3

def s1 = "i's value is: ${i}"
def s2 = "i's value is: ${-&gt; i}"

i++

assert s1 == "i's value is: 3" // eagerly evaluated, takes the value on creation
assert s2 == "i's value is: 4" // lazily evaluated, takes the new value into account</code></pre>
</div>
</div>
<div class="paragraph">
<p>当字符串及其连接的表达式在Java中很长时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">throw new PluginException("Failed to execute command list-applications:" +
    " The group with name " +
    parameterMap.groupname[0] +
    " is not compatible group of type " +
    SERVER_TYPE_NAME)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>\</code>连续字符（这不是多行字符串）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">throw new PluginException("Failed to execute command list-applications: \
The group with name ${parameterMap.groupname[0]} \
is not compatible group of type ${SERVER_TYPE_NAME}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用带三引号的多行字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">throw new PluginException("""Failed to execute command list-applications:
    The group with name ${parameterMap.groupname[0]}
    is not compatible group of type ${SERVER_TYPE_NAME)}""")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过调用以下命令去除出现在多行字符串左侧的缩进<code>.stripIndent()</code>在那个字符串上。</p>
</div>
<div class="paragraph">
<p>还要注意Groovy中单引号和双引号之间的区别：单引号始终创建Java字符串，而不对变量进行插值，而双引号在存在插值变量时要么创建Java字符串，要么创建GString。</p>
</div>
<div class="paragraph">
<p>对于多行字符串，您可以将引号三倍：即，对于GStrings，三重双引号，对于仅Strings，三重单引号。</p>
</div>
<div class="paragraph">
<p>如果需要编写正则表达式模式，则应使用“ slashy”字符串表示法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert "foooo/baaaaar" ==~ /fo+\/ba+r/</code></pre>
</div>
</div>
<div class="paragraph">
<p>“ slashy”表示法的优点是您不需要双转义反斜杠，从而使使用regex更加简单。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的一点是，当您需要字符串常量时，更喜欢使用单引号字符串，而当您明确依赖于字符串插值时，请使用双引号字符串。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_native_syntax_for_data_structures"><a class="anchor" href="#_native_syntax_for_data_structures"></a> 12数据结构的本机语法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy为数据结构（如列表，映射，正则表达式或值范围）提供了本机语法构造。确保在您的Groovy程序中利用它们。</p>
</div>
<div class="paragraph">
<p>以下是这些本机构造的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = [1, 4, 6, 9]

// by default, keys are Strings, no need to quote them
// you can wrap keys with () like [(variableStateAcronym): stateName] to insert a variable or object as a key.
def map = [CA: 'California', MI: 'Michigan']

// ranges can be inclusive and exclusive
def range = 10..20 // inclusive
assert range.size() == 11
// use brackets if you need to call a method on a range definition
assert (10..&lt;20).size() == 10 // exclusive

def pattern = ~/fo*/

// equivalent to add()
list &lt;&lt; 5

// call contains()
assert 4 in list
assert 5 in list
assert 15 in range

// subscript notation
assert list[1] == 4

// add a new key value pair
map &lt;&lt; [WA: 'Washington']
// subscript notation
assert map['CA'] == 'California'
// property notation
assert map.WA == 'Washington'

// matches() strings against patterns
assert 'foo' ==~ pattern</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_groovy_development_kit"><a class="anchor" href="#_the_groovy_development_kit"></a> 13Groovy开发套件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>继续数据结构，当您需要遍历集合时，Groovy提供了各种其他方法来装饰Java的核心数据结构，例如<code>each{}</code> ， <code>find{}</code> ， <code>findAll{}</code> ， <code>every{}</code> ， <code>collect{}</code> ， <code>inject{}</code> 。这些方法为编程语言增添了功能风味，并有助于更轻松地处理复杂的算法。由于语言的动态特性，通过装饰将许多新方法应用于各种类型。您可以在String，Files，Streams，Collections等上找到很多非常有用的方法：</p>
</div>
<div class="paragraph">
<p><a href="http://groovy-lang.org/gdk.html" class="bare">http://groovy-lang.org/gdk.html</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_power_of_switch"><a class="anchor" href="#_the_power_of_switch"></a> 14。开关电源</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy的<code>switch</code>比C-ish语言强大得多，后者通常只接受基元并被同化。Groovy的<code>switch</code>接受几乎任何类型的类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = 1.23
def result = ""
switch (x) {
    case "foo": result = "found foo"
    // lets fall through
    case "bar": result += "bar"
    case [4, 5, 6, 'inList']:
        result = "list"
        break
    case 12..30:
        result = "range"
        break
    case Integer:
        result = "integer"
        break
    case Number:
        result = "number"
        break
    case { it &gt; 3 }:
        result = "number &gt; 3"
        break
    default: result = "default"
}
assert result == "number"</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，带有<code>isCase()</code>方法还可以确定值是否与大小写相对应</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_import_aliasing"><a class="anchor" href="#_import_aliasing"></a> 15导入别名</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Java中，当使用两个具有相同名称但来自不同包的类时，例如<code>java.util.List</code>和<code>java.awt.List</code> ，您可以导入一个类，但为另一个类使用完全限定的名称。</p>
</div>
<div class="paragraph">
<p>同样有时候，在您的代码中，多次使用长类名会增加冗长性并降低代码的清晰度。</p>
</div>
<div class="paragraph">
<p>为了改善这种情况，Groovy功能引入了别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.util.List as UtilList
import java.awt.List as AwtList
import javax.swing.WindowConstants as WC

UtilList list1 = [WC.EXIT_ON_CLOSE]
assert list1.size() instanceof Integer
def list2 = new AwtList()
assert list2.size() instanceof java.awt.Dimension</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以在静态导入方法时使用别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static java.lang.Math.abs as mabs
assert mabs(-4) == 4</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_groovy_truth"><a class="anchor" href="#_groovy_truth"></a> 16。时髦真相</h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以将所有对象“强制”为布尔值： <code>null</code> ， <code>void</code> ，等于零或为空，则得出<code>false</code> ，如果不是，则求值为<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>所以不用写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (name != null &amp;&amp; name.length &gt; 0) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (name) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>集合等也一样</p>
</div>
<div class="paragraph">
<p>因此，您可以在诸如<code>while()</code> ， <code>if()</code> ，三元运算符，猫王运算符（请参见下文）等。</p>
</div>
<div class="paragraph">
<p>甚至可以通过添加布尔值来自定义Groovy真相<code>asBoolean()</code>上课的方法！</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_safe_graph_navigation"><a class="anchor" href="#_safe_graph_navigation"></a> 17。安全的图形导航</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy支持<code>.</code>操作员安全地导航对象图。</p>
</div>
<div class="paragraph">
<p>在Java中，当您对图深处的节点感兴趣时，需要检查<code>null</code> ，您通常会写复杂的文章<code>if</code>或嵌套<code>if</code>像这样的语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">if (order != null) {
    if (order.getCustomer() != null) {
        if (order.getCustomer().getAddress() != null) {
            System.out.println(order.getCustomer().getAddress());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用<code>?.</code>安全的解除引用运算符，您可以使用以下代码简化此类代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">println order?.customer?.address</code></pre>
</div>
</div>
<div class="paragraph">
<p>在整个调用链中检查空值，否<code>NullPointerException</code>如果有任何元素将被抛出<code>null</code> ，如果某物是<code>null</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_assert"><a class="anchor" href="#_assert"></a> 18岁断言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要检查参数，返回值等，您可以使用<code>assert</code>声明。</p>
</div>
<div class="paragraph">
<p>与Java的相反<code>assert</code> ，不需要激活Assert即可正常工作，因此始终会检查Assert。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def check(String name) {
    // name non-null and non-empty according to Groovy Truth
    assert name
    // safe navigation + Groovy Truth to check
    assert name?.size() &gt; 3
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还将注意到Groovy的“ Power Assert”语句提供的出色输出，其中包含断言的每个子表达式的各个值的图形视图。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_elvis_operator_for_default_values"><a class="anchor" href="#_elvis_operator_for_default_values"></a> 19Elvis运算符的默认值</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Elvis运算符是特殊的三元运算符快捷方式，可用于默认值。</p>
</div>
<div class="paragraph">
<p>我们经常不得不编写如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def result = name != null ? name : "Unknown"</code></pre>
</div>
</div>
<div class="paragraph">
<p>多亏了Groovy Truth， <code>null</code>支票可以简化为“姓名”。</p>
</div>
<div class="paragraph">
<p>更进一步，因为无论如何您都返回“名称”，而不是在此三元表达式中重复两次名称，所以我们可以使用Elvis运算符以某种方式删除问号和冒号之间的内容，从而使以上内容变为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def result = name ?: "Unknown"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_catch_any_exception"><a class="anchor" href="#_catch_any_exception"></a> 20捕获任何异常</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您不太在意您内部抛出的异常类型<code>try</code>块，您可以简单地捕获其中的任何一个，而只需忽略捕获的异常的类型。因此，与其捕获异常，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">try {
    // ...
} catch (Exception t) {
    // something bad happens
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后捕获任何东西（“任何”或“全部”，或使您认为是任何东西的任何东西）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">try {
    // ...
} catch (any) {
    // something bad happens
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">注意，它捕获的是所有异常，而不是`Throwable`。如果您需要真正抓住“一切”，则必须明确表示要抓住`Throwable`。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_optional_typing_advice"><a class="anchor" href="#_optional_typing_advice"></a> 21可选的打字建议</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我将在何时以及如何使用可选类型上讲几句话。Groovy使您可以决定是使用显式强类型，还是何时使用<code>def</code> 。</p>
</div>
<div class="paragraph">
<p>我有一个简单的经验法则：每当您要编写的代码将被其他人用作公共API时，您始终应该支持使用强类型化，这有助于使契约更牢固，避免可能的通过arguments键入错误，可以提供更好的文档，还可以帮助IDE完成代码。只要代码只供您使用（例如私有方法），或者当IDE可以轻松推断类型时，您就可以自由决定何时键入或不键入。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本2.5.8<br>上次更新时间2019-08-02 18:30:29 UTC</div>
</div>
<link rel="stylesheet" href="asset?aid=2">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>