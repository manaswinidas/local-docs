<html ><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>第十四章Java管理扩展（JMX）</title><link rel="stylesheet" type="text/css" href="css/docbook.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="jetty, servlet, servlet-api, cometd, http, websocket, eclipse, maven, java, server, software"><link rel="home" href="index.html" title="Jetty"><link rel="up" href="jetty-admin-guide.html" title="Part III. Jetty Administration Guide"><link rel="prev" href="using-annotations-embedded.html" title="Using Annotations with Jetty Embedded"><link rel="next" href="jetty-jmx-annotations.html" title="Jetty JMX Annotations"><link rel="shortcut icon" href="images/favicon.ico" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><link rel="stylesheet" href="css/highlighter/foundation.css"><script src="js/highlight.pack.js"></script><script>
      hljs.initHighlightingOnLoad();
    </script><link type="text/css" rel="stylesheet" href="css/font-awesome/font-awesome.min.css"></head><body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><tbody><tr><td style="width:25%"><a href="http://www.eclipse.org/jetty"><img src="images/jetty-header-logo.png" alt="Jetty标志"></a><br><span style="font-size:small">版本：9.4.24.v20191120</span></td><td style="width:50%"></td></tr></tbody></table><div class="navheader" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><table width="100%" summary="Navigation header"><tbody><tr><th colspan="3" align="center">第十四章Java管理扩展（JMX）</th></tr><tr><td width="20%" align="left"><a href="using-annotations-embedded.html" accesskey="p"><i class="fa fa-chevron-left" aria-hidden="true"></i>以前</a> </td><th width="60%" align="center">第三部分Jetty管理指南<br><a href="index.html" accesskey="p"><i class="fa fa-home" aria-hidden="true"></i>家</a></th><td width="20%" align="right"> <a href="jetty-jmx-annotations.html" accesskey="n">下一个<i class="fa fa-chevron-right" aria-hidden="true"></i></a></td></tr></tbody></table><hr></div><div class="jetty-callout" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><h5 class="callout"><a href="http://www.webtide.com/">通过<span class="website">www.webtide.com</span>与Jetty核心开发人员联系。</a></h5><p>内部/客户项目的私人支持...自定义扩展和发行版...无限期支持的版本快照...您的应用程序和Ajax / Comet项目的可伸缩性指南...赞助功能开发的开发服务</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="jmx-chapter"></a>第十四章Java管理扩展（JMX）</h2></div></div></div><div class="toc"><p><b>目录</b></p><dl class="toc"><dt><span class="section"><a href="jmx-chapter.html#using-jmx">在Jetty中使用JMX</a></span></dt><dt><span class="section"><a href="jetty-jmx-annotations.html">Jetty JMX注释</a></span></dt><dt><span class="section"><a href="jetty-jconsole.html">使用JConsole和JMC管理Jetty</a></span></dt></dl></div><p><a class="link" href="http://java.sun.com/products/JavaManagement/" target="_top">Java管理扩展（JMX）API</a>是用于管理和监视资源（例如应用程序，设备，服务和Java虚拟机<a class="link" href="http://java.sun.com/products/JavaManagement/" target="_top">）</a>的标准API。</p><p>JMX技术的典型用途包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">咨询和更改应用程序配置</li><li class="listitem">累积并提供有关应用程序行为的统计信息</li><li class="listitem">通知状态变化和错误状况</li></ul></div><p>JMX API包括远程访问，因此，出于这些目的，远程管理程序可以与正在运行的应用程序进行交互。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="using-jmx"></a>在Jetty中使用JMX</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="jmx-chapter.html#configuring-jmx">配置JMX</a></span></dt><dt><span class="section"><a href="jmx-chapter.html#accessing-jetty-mbeans">使用JConsole或Java Mission Control访问Jetty MBean</a></span></dt><dt><span class="section"><a href="jmx-chapter.html#jmx-remote-access">启用JMX远程访问</a></span></dt></dl></div><p>Jetty的体系结构基于POJO组件（请参阅<a class="xref" href="architecture.html#basic-architecture" title="Jetty建筑">Jetty Architecture</a> ）。这些组件以树的形式组织，每个组件的生命周期都可以跨越<code class="literal">Server</code>生命周期或Web应用程序生命周期，甚至更短的生命周期（例如TCP连接）。</p><p>每次在组件树中添加或删除组件时，都会发出一个事件，并且<a class="link" href="http://www.eclipse.org/jetty/javadoc/9.4.24.v20191120/org/eclipse/jetty/util/component/Container.html" target="_top"><code class="literal">Container.Listener</code></a>实现可以侦听这些事件并执行其他操作。</p><p>一个这样的<code class="literal">Container.Listener</code>是<code class="literal">MBeanContainer</code>使用<code class="literal">ObjectMBean</code>从任意POJO创建MBean，并向平台注册MBean或从平台注销MBean <code class="literal">MBeanServer</code> 。</p><p>Jetty组件带有<a class="xref" href="jetty-jmx-annotations.html" title="Jetty JMX注释">Jetty JMX注释，</a>并提供特定的JMX详细信息，以便<code class="literal">ObjectMBean</code>可以构建与组件POJO关联的JMX元数据的更精确表示。</p><p>因此，将组件添加到组件树时， <code class="literal">MBeanContainer</code>收到通知后，它将根据组件POJO创建MBean并将其注册到<code class="literal">MBeanServer</code> 。同样，当从树中删除组件时， <code class="literal">MBeanContainer</code>通知，并从<code class="literal">MBeanServer</code> 。</p><p>可以通过任何JMX控制台（如Java Mission Control（JMC），VisualVM，JConsole或其他）访问Jetty MBean。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="configuring-jmx"></a>配置JMX</h3></div></div></div><p>本指南描述了初始化和配置Jetty JMX集成的各种方法。配置Jetty JMX集成仅将Jetty MBean注册到平台中<code class="literal">MBeanServer</code> ，因此只能在本地（从同一台机器）访问MBean，而不能从远程机器访问。</p><p>这意味着此配置足以进行开发，您可以在其中轻松访问（通过图形用户界面）运行Jetty的计算机，但是当运行远程机器的Jetty或只能通过SSH或其他方式访问时，此配置通常是不够的没有图形用户界面支持。在这些情况下，您必须启用<a class="link" href="jmx-chapter.html#jmx-remote-access" title="启用JMX远程访问">JMX远程访问</a> 。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jmx-standalone-jetty"></a>独立Jetty服务器</h4></div></div></div><p>默认情况下，Jetty发行版中未启用JMX。要在Jetty发行版中启用JMX，请运行以下命令，其中<code class="literal">{$jetty.home}</code>是您安装Jetty发行版的目录，并且<code class="literal">${jetty.base}</code>是您进行Jetty配置的目录（请参阅<a class="link" href="startup-base-and-home.html" title="管理Jetty基地和Jetty主页">有关Jetty基本示例和家庭示例的文档</a> ）：</p><div class="screenexample"><pre class="screen">$ cd ${jetty.base}
$ java -jar {$jetty.home}/start.jar --add-to-start=jmx</pre></div><p>运行上面的命令将添加可用的可配置元素<code class="literal">jmx</code>模块到<code class="literal">{$jetty.base}/start.ini</code>文件，或创建<code class="literal">${jetty.base}/start.d/jmx.ini</code>文件。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jmx-embedded-jetty"></a>嵌入式Jetty服务器</h4></div></div></div><p>当运行嵌入到应用程序中的Jetty时，创建并配置一个<code class="literal">MBeanContainer</code>实例如下：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>Server server = new Server();

// Setup JMX.
MBeanContainer mbeanContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());
server.addBean(mbeanContainer);

// Export the loggers as MBeans.
server.addBean(Log.getLog());</code></pre><p>因为日志记录是在初始化之前进行的<code class="literal">MBeanContainer</code> （甚至在<code class="literal">Server</code>本身），则有必要通过手动注册记录器<code class="literal">server.addBean()</code>以便记录器可以在JMX树中显示为MBean。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jmx-jetty-maven-plugin"></a>将Jetty Maven插件与JMX一起使用</h4></div></div></div><p>如果您使用的是<a class="link" href="jetty-maven-plugin.html" title="配置Jetty Maven插件">Jetty Maven插件</a> ，则应复制<code class="literal">${jetty.home}/etc/jetty-jmx.xml</code>档案到您的webapp专案中，例如<code class="literal">src/main/config/etc/</code> ，然后添加一个<code class="literal"><jettyXml></code>元素<code class="literal"><configuration></code> Jetty Maven插件的元素：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>&lt;plugin&gt;
  &lt;groupid&gt;org.eclipse.jetty&lt;/groupid&gt;
  &lt;artifactid&gt;jetty-maven-plugin&lt;/artifactid&gt;
  &lt;version&gt;9.4.24.v20191120&lt;/version&gt;
  &lt;configuration&gt;
    &lt;scanintervalseconds&gt;10&lt;/scanintervalseconds&gt;
    &lt;jettyXml&gt;src/main/config/etc/jetty-jmx.xml&lt;/jettyXml&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="accessing-jetty-mbeans"></a>使用JConsole或Java Mission Control访问Jetty MBean</h3></div></div></div><p>访问Jetty发布的MBean的最简单方法是使用<a class="link" href="jetty-jconsole.html" title="使用JConsole和JMC管理Jetty">Java Mission Control（JMC）或JConsole。</a></p><p>这两个工具都可以连接到本地或远程JVM，以显示MBean。</p><p>对于本地访问，您只需要启动JConsole或JMC，然后从其用户界面中选择要连接的本地JVM。</p><p>对于远程访问，您首先需要在Jetty中启用JMX远程访问。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-remote-access"></a>启用JMX远程访问</h3></div></div></div><p>有两种方法可以启用远程连接，以便JConsole或JMC可以连接到远程JVM以可视化MBean。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">使用<code class="literal">com.sun.management.jmxremote</code>命令行上的系统属性。不幸的是，该解决方案不能很好地与防火墙配合使用，并且不灵活。</li><li class="listitem">使用Jetty的<code class="literal">jmx-remote</code>模块或-等效地- <code class="literal">ConnectorServer</code>类。</li></ul></div><p><code class="literal">ConnectorServer</code>默认情况下将使用RMI允许来自远程客户端的连接，并且它是标准JDK类的包装器<code class="literal">JMXConnectorServer</code> ，该类提供对JMX客户端的远程访问。</p><p>连接到远程JVM分为两个步骤：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">首先，客户端将连接到RMI <span class="emphasis"><em>注册表</em></span>以下载RMI存根。 <code class="literal">JMXConnectorServer</code> ;该RMI存根包含用于连接到RMI服务器（即远程）的IP地址和端口。 <code class="literal">JMXConnectorServer</code> 。</li><li class="listitem">其次，客户端使用RMI存根连接到RMI <span class="emphasis"><em>服务器</em></span> （即远程<code class="literal">JMXConnectorServer</code> ）通常位于可能与RMI注册表地址和端口不同的地址和端口上。</li></ul></div><p>RMI注册表和RMI服务器的配置由<code class="literal">JMXServiceURL</code> 。RMI的字符串格式<code class="literal">JMXServiceURL</code>是：</p><div class="screenexample"><pre class="screen">service:jmx:rmi://&lt;rmi_server_host&gt;:&lt;rmi_server_port&gt;/jndi/rmi://&lt;rmi_registry_host&gt;:&lt;rmi_registry_port&gt;/jmxrmi</pre></div><p>默认值为：</p><div class="screenexample"><pre class="screen">rmi_server_host = localhost
rmi_server_port = 1099
rmi_registry_host = localhost
rmi_registry_port = 1099</pre></div><p>使用默认配置，只有服务器计算机本地的客户端才能连接到RMI注册表和RMI服务器-出于安全原因这样做。使用此配置，仍然可以使用<a class="link" href="jmx-chapter.html#jmx-remote-access-ssh-tunnel" title="JMX Remote Access with Port Forwarding via SSH Tunnel">SSH隧道</a>从远程访问MBean <a class="link" href="jmx-chapter.html#jmx-remote-access-ssh-tunnel" title="通过SSH隧道进行端口转发的JMX远程访问">。</a></p><p>通过指定适当的<code class="literal">JMXServiceURL</code> ，您可以微调RMI注册表和RMI服务器绑定到的网络接口，以及RMI注册表和RMI服务器侦听的端口。RMI服务器和RMI注册表主机和端口可以相同（与默认配置中相同），因为RMI能够将到达端口的流量多路复用到多个RMI对象。</p><p>如果需要允许通过防火墙的JMX远程访问，则必须同时打开RMI注册表和RMI服务器端口。</p><p>例子：</p><div class="screenexample"><pre class="screen">service:jmx:rmi:///jndi/rmi:///jmxrmi
  rmi_server_host = local host address
  rmi_server_port = randomly chosen
  rmi_registry_host = local host address
  rmi_registry_port = 1099

service:jmx:rmi://0.0.0.0:1099/jndi/rmi://0.0.0.0:1099/jmxrmi
  rmi_server_host = any address
  rmi_server_port = 1099
  rmi_registry_host = any address
  rmi_registry_port = 1099

service:jmx:rmi://localhost:1100/jndi/rmi://localhost:1099/jmxrmi
  rmi_server_host = loopback address
  rmi_server_port = 1100
  rmi_registry_host = loopback address
  rmi_registry_port = 1099</pre></div><div class="note" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times" style="margin-left:0.5in;margin-right:0.5in"><h3 class="title"><i class="fa fa-asterisk" aria-hidden="true"></i>注意</h3><p>什么时候<code class="literal">ConnectorServer</code>启动后，其RMI存根将导出到RMI注册表。RMI存根包含用于连接到RMI对象的IP地址和端口，但是IP地址通常是计算机主机名，而不是主机名中指定的主机。 <code class="literal">JMXServiceURL</code> 。</p><p>要控制存储在RMI存根中的IP地址，您需要设置系统属性<code class="literal">java.rmi.server.hostname</code>具有所需的值。出于安全原因，将RMI服务器主机绑定到环回地址时，这一点尤其重要。另请参阅“ <a class="link" href="jmx-chapter.html#jmx-remote-access-ssh-tunnel" title="通过SSH隧道进行端口转发的JMX远程访问">通过SSH隧道进行JMX远程访问”。</a></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_enabling_jmx_remote_access_in_standalone_jetty_server"></a>在独立Jetty服务器中启用JMX远程访问</h4></div></div></div><p>与<a class="link" href="jmx-chapter.html#jmx-standalone-jetty" title="独立Jetty服务器">在独立的Jetty服务器中启用JMX</a>相似，您可以启用<code class="literal">jmx-remote</code>模块：</p><div class="screenexample"><pre class="screen">$ cd ${jetty.base}
$ java -jar {$jetty.home}/start.jar --add-to-start=jmx-remote</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_enabling_jmx_remote_access_in_embedded_jetty"></a>在嵌入式Jetty中启用JMX远程访问</h4></div></div></div><p>运行嵌入到应用程序中的Jetty时，创建并配置一个<code class="literal">ConnectorServer</code> ：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>Server server = new Server();

// Setup JMX
MBeanContainer mbeanContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());
server.addBean(mbeanContainer);

// Setup ConnectorServer
JMXServiceURL jmxURL = new JMXServiceURL("rmi", null, 1999, "/jndi/rmi:///jmxrmi");
ConnectorServer jmxServer = new ConnectorServer(jmxURL, "org.eclipse.jetty.jmx:name=rmiconnectorserver");
server.addBean(jmxServer);</code></pre><p>的<code class="literal">JMXServiceURL</code>上面指定RMI服务器绑定到端口1999上的通配符地址，而RMI注册表绑定到端口1099（默认RMI注册表端口）上的通配符地址。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jmx-remote-access-authorization"></a> JMX远程访问授权</h4></div></div></div><p>标准<code class="literal">JMXConnectorServer</code>提供了几种授权访问的选项。有关在JMX中控制身份验证和授权的完整指南，请参阅<a class="link" href="https://blogs.oracle.com/lmalventosa/entry/jmx_authentication_authorization" target="_top">JMX RMI连接器中的身份验证和授权</a> 。</p><p>授权访问<code class="literal">JMXConnectorServer</code>您可以使用此配置，其中<code class="literal">jmx.password</code>和<code class="literal">jmx.access</code>文件具有上面博客条目中指定的格式：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>&lt;New id="ConnectorServer" class="org.eclipse.jetty.jmx.ConnectorServer"&gt;
  &lt;Arg&gt;
    &lt;New class="javax.management.remote.JMXServiceURL"&gt;
      &lt;Arg type="java.lang.String"&gt;rmi&lt;/Arg&gt;
      &lt;Arg type="java.lang.String" /&gt;
      &lt;Arg type="java.lang.Integer"&gt;1099&lt;/Arg&gt;
      &lt;Arg type="java.lang.String"&gt;/jndi/rmi:///jmxrmi&lt;/Arg&gt;
    &lt;/New&gt;
  &lt;/Arg&gt;
  &lt;Arg&gt;
    &lt;Map&gt;
      &lt;Entry&gt;
        &lt;Item&gt;jmx.remote.x.access.file&lt;/Item&gt;
        &lt;Item&gt;
          &lt;New class="java.lang.String"&gt;&lt;Arg&gt;&lt;Property name="jetty.base" default="." /&gt;/resources/jmx.access&lt;/Arg&gt;&lt;/New&gt;
        &lt;/Item&gt;
      &lt;/Entry&gt;
      &lt;Entry&gt;
        &lt;Item&gt;jmx.remote.x.password.file&lt;/Item&gt;
        &lt;Item&gt;
          &lt;New class="java.lang.String"&gt;&lt;Arg&gt;&lt;Property name="jetty.base" default="." /&gt;/resources/jmx.password&lt;/Arg&gt;&lt;/New&gt;
        &lt;/Item&gt;
      &lt;/Entry&gt;
    &lt;/Map&gt;
  &lt;/Arg&gt;
  &lt;Arg&gt;org.eclipse.jetty.jmx:name=rmiconnectorserver&lt;/Arg&gt;
  &lt;Call name="start" /&gt;
&lt;/New&gt;</code></pre><p>同样，在代码中：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>JMXServiceURL jmxURL = new JMXServiceURL("rmi", null, 1099, "/jndi/rmi:///jmxrmi");
Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();
env.put("jmx.remote.x.access.file", "resources/jmx.access");
env.put("jmx.remote.x.password.file", "resources/jmx.password");
ConnectorServer jmxServer = new ConnectorServer(jmxURL, env, "org.eclipse.jetty.jmx:name=rmiconnectorserver");
jmxServer.start();</code></pre><p>呼唤<code class="literal">ConnectorServer.start()</code>可以像上面的示例中那样明确，也可以在添加<code class="literal">ConnectorServer</code>作为豆子<code class="literal">Server</code> ，以便启动<code class="literal">Server</code>也将开始<code class="literal">ConnectorServer</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_securing_jmx_remote_access_with_tls"></a>使用TLS保护JMX远程访问</h4></div></div></div><p>默认情况下，通过RMI进行的JMX通信以明文形式进行。</p><p>可以配置<code class="literal">ConnectorServer</code>与一个<code class="literal">SslContextFactory</code>这样就可以加密通过RMI进行的JMX通信：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>&lt;New id="ConnectorServer" class="org.eclipse.jetty.jmx.ConnectorServer"&gt;
  &lt;Arg&gt;
    &lt;New class="javax.management.remote.JMXServiceURL"&gt;
      &lt;Arg type="java.lang.String"&gt;rmi&lt;/Arg&gt;
      &lt;Arg type="java.lang.String" /&gt;
      &lt;Arg type="java.lang.Integer"&gt;1099&lt;/Arg&gt;
      &lt;Arg type="java.lang.String"&gt;/jndi/rmi:///jmxrmi&lt;/Arg&gt;
    &lt;/New&gt;
  &lt;/Arg&gt;
  &lt;Arg /&gt;
  &lt;Arg&gt;org.eclipse.jetty.jmx:name=rmiconnectorserver&lt;/Arg&gt;
  &lt;Arg&gt;&lt;Ref refid="sslContextFactory" /&gt;&lt;/Arg&gt;
&lt;/New&gt;</code></pre><p>同样，在代码中：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

JMXServiceURL jmxURL = new JMXServiceURL("rmi", null, 1099, "/jndi/rmi:///jmxrmi");
ConnectorServer jmxServer = new ConnectorServer(jmxURL, null, "org.eclipse.jetty.jmx:name=rmiconnectorserver", sslContextFactory);</code></pre><p>可以使用相同的<code class="literal">SslContextFactory</code>用于配置Jetty<code class="literal">ServerConnector</code>支持TLS的HTTP协议。这在上面的XML示例中使用： <code class="literal">SslContextFactory</code>为TLS配置<code class="literal">ServerConnector</code>注册的ID为<code class="literal">sslContextFactory</code> XML通过以下方式引用<code class="literal">Ref</code>元件。</p><p>密钥库必须包含由证书颁发机构签署的有效证书。</p><p>RMI机制很常见：RMI客户端（通常是监视控制台）将首先连接到RMI注册表（使用TLS），下载包含要连接的RMI服务器的地址和端口的RMI服务器存根。到RMI服务器（使用TLS）。</p><p>这也意味着，如果RMI注册表和RMI服务器位于不同的主机上，则RMI客户端必须具有可用的加密材料来验证两个主机。</p><p>由证书颁发机构签名的证书大大简化了使TLS上的JMX通信正常工作所需的配置。</p><p>如果不是这种情况（例如，证书是自签名的），那么您需要指定所需的系统属性，以允许RMI（尤其是充当RMI客户端时）检索建立TLS连接所需的加密材料。</p><p>例如，尝试使用JDK标准进行连接<code class="literal">JMXConnector</code>使用RMI服务器和RMI注册表来<code class="literal">domain.com</code> ：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>// System properties necessary for an RMI client to trust a self-signed certificate.
System.setProperty("javax.net.ssl.trustStore", "/path/to/trustStore");
System.setProperty("javax.net.ssl.trustStorePassword", "secret");

JMXServiceURL jmxURL = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://domain.com:1100/jmxrmi")
Map&lt;String, Object&gt; clientEnv = new HashMap&lt;&gt;();
// Required to connect to the RMI registry via TLS.
clientEnv.put(ConnectorServer.RMI_REGISTRY_CLIENT_SOCKET_FACTORY_ATTRIBUTE, new SslRMIClientSocketFactory());
try (JMXConnector client = JMXConnectorFactory.connect(jmxURL, clientEnv))
{
    Set&lt;ObjectName&gt; names = client.getMBeanServerConnection().queryNames(null, null);
}</code></pre><p>同样，要启动JMC：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>$ jmc -vmargs -Djavax.net.ssl.trustStore=/path/to/trustStore -Djavax.net.ssl.trustStorePassword=secret</code></pre><p>请注意，启动<code class="literal">ConnectorServer</code>在服务器上也是如此，因为相对于RMI注册表，它充当RMI客户端。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jmx-remote-access-ssh-tunnel"></a>通过SSH隧道进行端口转发的JMX远程访问</h4></div></div></div><p>当RMI端口未打开时（例如由于防火墙策略），您可以在远程机器上访问JMX MBean，但是您可以通过SSH隧道使用本地端口转发对机器进行SSH访问。</p><p>在这种情况下，您要配置<code class="literal">ConnectorServer</code>与一个<code class="literal">JMXServiceURL</code>仅将RMI服务器和RMI注册表绑定到回送接口： <code class="literal">service:jmx:rmi://localhost:1099/jndi/rmi://localhost:1099/jmxrmi</code> 。</p><p>然后使用SSH隧道设置本地端口转发：</p><div class="screenexample"><pre class="screen">$ ssh -L 1099:localhost:1099 &lt;user&gt;@&lt;machine_host&gt;</pre></div><p>现在，您可以使用JConsole或JMC连接到<code class="literal">localhost:1099</code>在本地计算机上。流量将转发至<code class="literal">machine_host</code>在那里，SSH会将流量转发到<code class="literal">localhost:1099</code> ，这正是<code class="literal">ConnectorServer</code>听。</p><p>配置时<code class="literal">ConnectorServer</code>这样，您必须设置系统属性<code class="literal">-Djava.rmi.server.hostname=localhost</code> ，在服务器上。</p><p>这是必需的，因为导出RMI服务器时，其地址和端口存储在RMI存根中。您希望RMI存根中的地址为<code class="literal">localhost</code>因此，当RMI存根下载到远程客户端时，RMI通信将通过SSH隧道进行。</p></div></div></div></div><script type="text/javascript">
      SyntaxHighlighter.all()
    </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tbody><tr><td width="40%" align="left"><a href="using-annotations-embedded.html" accesskey="p"><i class="fa fa-chevron-left" aria-hidden="true"></i>以前</a> </td><td width="20%" align="center"><a href="jetty-admin-guide.html" accesskey="u"><i class="fa fa-chevron-up" aria-hidden="true"></i>最佳</a></td><td width="40%" align="right"> <a href="jetty-jmx-annotations.html" accesskey="n">下一个<i class="fa fa-chevron-right" aria-hidden="true"></i></a></td></tr><tr><td width="40%" align="left" valign="top">在Jetty Embedded中使用注释</td><td width="20%" align="center"><a href="index.html" accesskey="h"><i class="fa fa-home" aria-hidden="true"></i>家</a></td><td width="40%" align="right" valign="top">Jetty JMX注释</td></tr></tbody></table></div><p xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"></p><div class="jetty-callout">看到错误或缺少的东西？
            <span class="callout"><a href="http://github.com/eclipse/jetty.project">在以下位置对此文档做出贡献<span class="website"><i class="fa fa-github" aria-hidden="true"></i> Github！</span></a></span> <span style="float:right"><i>（产生：2019-11-20）</i></span></div><p></p></body></html>