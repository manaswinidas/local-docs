<html ><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>第30章建筑</title><link rel="stylesheet" type="text/css" href="css/docbook.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="jetty, servlet, servlet-api, cometd, http, websocket, eclipse, maven, java, server, software"><link rel="home" href="index.html" title="Jetty"><link rel="up" href="jetty-ref-guide.html" title="Part V. Jetty Reference Guide"><link rel="prev" href="jetty-ref-guide.html" title="Part V. Jetty Reference Guide"><link rel="next" href="jetty-classloading.html" title="Jetty Classloading"><link rel="shortcut icon" href="images/favicon.ico" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><link rel="stylesheet" href="css/highlighter/foundation.css"><script src="js/highlight.pack.js"></script><script>
      hljs.initHighlightingOnLoad();
    </script><link type="text/css" rel="stylesheet" href="css/font-awesome/font-awesome.min.css"></head><body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><tbody><tr><td style="width:25%"><a href="http://www.eclipse.org/jetty"><img src="images/jetty-header-logo.png" alt="Jetty标志"></a><br><span style="font-size:small">版本：9.4.24.v20191120</span></td><td style="width:50%"></td></tr></tbody></table><div class="navheader" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><table width="100%" summary="Navigation header"><tbody><tr><th colspan="3" align="center">第30章建筑</th></tr><tr><td width="20%" align="left"><a href="jetty-ref-guide.html" accesskey="p"><i class="fa fa-chevron-left" aria-hidden="true"></i>以前</a> </td><th width="60%" align="center">第五部分Jetty参考指南<br><a href="index.html" accesskey="p"><i class="fa fa-home" aria-hidden="true"></i>家</a></th><td width="20%" align="right"> <a href="jetty-classloading.html" accesskey="n">下一个<i class="fa fa-chevron-right" aria-hidden="true"></i></a></td></tr></tbody></table><hr></div><div class="jetty-callout" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><h5 class="callout"><a href="http://www.webtide.com/">通过<span class="website">www.webtide.com</span>与Jetty核心开发人员联系。</a></h5><p>内部/客户项目的私人支持...自定义扩展和发行版...无限期支持的版本快照...您的应用程序和Ajax / Comet项目的可伸缩性指南...赞助功能开发的开发服务</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>第30章建筑</h2></div></div></div><div class="toc"><p><b>目录</b></p><dl class="toc"><dt><span class="section"><a href="architecture.html#basic-architecture">Jetty建筑</a></span></dt><dt><span class="section"><a href="jetty-classloading.html">Jetty类装载</a></span></dt><dt><span class="section"><a href="jetty-1xx-responses.html">管理1xx响应</a></span></dt><dt><span class="section"><a href="creating-custom-protocol.html">创建自定义协议</a></span></dt></dl></div><p>与Jetty建筑及其如何处理某些设计决策有关的常规项目。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="basic-architecture"></a>Jetty建筑</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="architecture.html#_view_from_20_000_feet">20,000英尺高的视野</a></span></dt><dt><span class="section"><a href="architecture.html#_patterns">模式</a></span></dt><dt><span class="section"><a href="architecture.html#_connectors">连接器</a></span></dt><dt><span class="section"><a href="architecture.html#_handlers">处理程序</a></span></dt><dt><span class="section"><a href="architecture.html#what-is-a-context">语境</a></span></dt><dt><span class="section"><a href="architecture.html#_web_application">Web应用程序</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_view_from_20_000_feet"></a> 20,000英尺高的视野</h3></div></div></div><p>Jetty<a class="link" href="http://www.eclipse.org/jetty/javadoc/9.4.24.v20191120/org/eclipse/jetty/server/Server.html" target="_top">服务器</a>是接受连接的“连接器”集合与处理来自连接的请求并产生响应的“处理程序”集合之间的管道，而线程池中的线程则在工作。</p><p><span class="inlinemediaobject"><img src="images/jetty-high-level-architecture.png" width="576" alt="图片"></span></p><p>虽然Jetty请求/响应是从Servlet API派生的，但是只有配置了适当的处理程序后，才能使用Servlet API的全部功能。例如，请求上的会话API处于无效状态，除非请求已传递给<code class="literal">SessionHandler</code> 。Servlet本身的概念是由<code class="literal">ServletHandler</code> 。如果不需要Servlet，则使用Servlet请求/响应API的开销很小。因此，您可以仅使用连接器和处理程序来构建Jetty服务器，而无需使用Servlet。</p><p>配置Jetty的工作是构建连接器和处理程序的树并提供其单独的配置。由于Jetty组件只是普通的Java对象（POJO），因此您可以通过多种技术来完成组件的组装和配置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">在代码中，请参阅Jetty Source XRef中的示例。</li><li class="listitem">使用Jetty XML，XML格式的依赖项注入样式。</li><li class="listitem">使用您选择的依赖项注入框架，Spring或XBean。</li><li class="listitem">使用Jetty WebApp和上下文部署程序。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_patterns"></a>模式</h3></div></div></div><p>Jetty的实施遵循一些相当标准的模式。最抽象的概念，例如<code class="literal">Connector`s and `Handler`s are captured by interfaces. Generic handling for those interfaces is then provided in an abstract implementation such as `AbstractConnector</code>和<code class="literal">AbstractHandler</code> 。</p><p><span class="inlinemediaobject"><img src="images/basic-architecture-patterns.png" width="576" alt="图片"></span></p><p>JSR77启发了大多数Jetty组件的生命周期，由<code class="literal">LifeCycle</code>界面和<code class="literal">AbstractLifeCycle</code>实现被用作许多Jetty组件的基础。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_connectors"></a>连接器</h3></div></div></div><p>一种<code class="literal">Connector</code>是接受TCP连接的组件。对于每个接受的TCP连接， <code class="literal">Connector</code>问一个<code class="literal">ConnectionFactory</code>创建一个<code class="literal">Connection</code>处理该TCP连接上的网络流量的对象，为特定协议解析并生成字节。</p><p>一种<code class="literal">ServerConnector</code>因此可以配置一个或多个<code class="literal">ConnectionFactory</code> 。</p><p>最简单的情况是一个<code class="literal">ConnectionFactory</code>如<code class="literal">HttpConnectionFactory</code> ，即会<code class="literal">HttpConnection</code>解析并为HTTP / 1.1协议生成字节的对象。</p><p>更复杂的情况可以是<code class="literal">ServerConnector</code>配置了三个工厂： <code class="literal">ProxyConnectionFactory</code> ， <code class="literal">SslConnectionFactory</code>和<code class="literal">HttpConnectionFactory</code> 。这样的连接器将能够处理来自负载均衡器（例如HAProxy）的PROXY协议字节（通过<code class="literal">ProxyConnectionFactory</code> ），然后处理TLS字节（ <code class="literal">SslConnectionFactory</code> ），然后解密/加密来自/到远程客户端的字节，最后处理HTTP / 1.1字节（使用<code class="literal">HttpConnectionFactory</code> ）。每<code class="literal">ConnectionFactory</code>被要求创建一个<code class="literal">Connection</code>每个TCP连接的对象；的<code class="literal">Connection</code>对象将被链接在一起以处理字节，每个字节都有自己的协议。因此<code class="literal">ProxyConnection</code>将处理PROXY协议字节， <code class="literal">SslConnection</code>将处理字节的加密/解密，并且<code class="literal">HttpConnection</code>将处理HTTP / 1.1字节，从而产生将由应用程序处理的请求和响应对象。</p><p>Jetty的高级用法将允许用户编写自己的<code class="literal">ConnectionFactory</code>处理Jetty项目未直接实现的自定义协议，因此将Jetty用作通用网络服务器。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_handlers"></a>处理程序</h3></div></div></div><p>一种<code class="literal">Handler</code>是处理HTTP请求和响应的组件。处理程序的核心API是handle方法：</p><p><span class="inlinemediaobject"><img src="images/basic-architecture-handlers.png" width="576" alt="图片"></span></p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException</code></pre><p>参数：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">target</code> –请求的目标，可以是URI或名称。</li><li class="listitem"><code class="literal">baseRequest</code> –原始的未包装请求对象。</li><li class="listitem"><code class="literal">request</code> –请求对象，作为<code class="literal">baseRequest</code>对象或包装<code class="literal">baseRequest</code> 。如果需要，可以使用HttpConnection.getCurrentConnection（）方法访问Request对象。</li><li class="listitem">response –响应对象，可以解包为<code class="literal">Response</code>或该响应的包装。您可以使用HttpConnection.getCurrentConnection（）方法来访问<code class="literal">Response</code>对象（如果需要）。</li></ul></div><p>此方法的实现可以处理请求，将请求传递到另一个处理程序（或servlet），或者可以修改和/或包装请求，然后将其传递。这提供了Handler的三种样式：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">协调处理程序–将请求路由到其他处理程序的处理程序（ <code class="literal">HandlerCollection</code> ， <code class="literal">ContextHandlerCollection</code> ）</li><li class="listitem">过滤处理程序–扩充请求并将其传递给其他处理程序的处理程序（ <code class="literal">HandlerWrapper</code> ， <code class="literal">ContextHandler</code> ， <code class="literal">SessionHandler</code> ）</li><li class="listitem">生成处理程序–产生内容的处理程序（ <code class="literal">ResourceHandler</code>和<code class="literal">ServletHandler</code> ）</li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_nested_handlers_and_handlers_called_sequentially"></a>嵌套处理程序和顺序调用的处理程序</h4></div></div></div><p>您可以通过嵌套处理程序，依次调用它们或组合两个模型来组合处理程序以处理请求的不同方面。</p><p><span class="inlinemediaobject"><img src="images/basic-architecture-nested-handlers.png" width="576" alt="图片"></span></p><p>依次调用的处理程序执行的操作不依赖于下一个调用，也不依赖于处理程序的顺序。它们处理请求并生成响应，而无需与其他处理程序进行交互。该模型的主要类别是<code class="literal">HandlerCollection</code> 。</p><p>嵌套处理程序是根据before / invokeNext / after模式调用的。嵌套处理程序的主要类是<code class="literal">HandlerWrapper</code> 。嵌套处理程序比顺序调用的处理程序更为常见。</p><p>另请参见<a class="xref" href="jetty-handlers.html#writing-custom-handlers" title="编写自定义处理程序">编写自定义处理程序</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_servlet_handler"></a> Servlet处理程序</h4></div></div></div><p>的<code class="literal">ServletHandler</code>是一个<code class="literal">Handler</code>通过将请求传递到任何已配置的Servlet过滤器，然后传递到URI模式映射的Servlet来生成内容。</p><p><span class="inlinemediaobject"><img src="images/basic-architecture-servlet-handler.png" width="576" alt="图片"></span></p><p>一种<code class="literal">ServletHandler</code>通常部署在<code class="literal">ServletContext</code> ，这是一个<code class="literal">ContextHandler</code>提供了将URI映射到servlet的便捷方法。</p><p>过滤器和Servlet也可以使用<code class="literal">RequestDispatcher</code>将请求重新路由到当前上下文中的另一个上下文或另一个Servlet。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="what-is-a-context"></a>语境</h3></div></div></div><p>上下文是将其他处理程序分组在特定URI上下文路径或虚拟主机下的处理程序。通常，上下文可以具有：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">定义上下文处理哪些请求的上下文路径（例如， <code class="literal">/myapp</code> ）</li><li class="listitem">静态内容的资源库（文档根）</li><li class="listitem">一个类加载器，用于获取特定于上下文的类（通常从<code class="literal">/WEB-INF/classes</code>和<code class="literal">/WEB-INF/lib</code> ）</li><li class="listitem">虚拟主机名</li></ul></div><p>上下文实现包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">ContextHandler</code></li><li class="listitem"><code class="literal">ServletContextHandler</code></li><li class="listitem"><code class="literal">WebAppContext</code></li></ul></div><p>Web应用程序上下文将安全性，会话和Servlet的处理程序合并在一个单元中，您可以使用<code class="literal">web.xml</code>描述符。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_web_application"></a> Web应用程序</h3></div></div></div><p>一种<code class="literal">WebAppContext</code>是从<code class="literal">ServletContextHandler</code>通过以下方式支持Web应用程序的标准化布局以及会话，安全性，侦听器，过滤器，Servlet和JSP的配置<code class="literal">web.xml</code>通常在<code class="literal">/WEB-INF</code> Web应用程序的目录。</p><p><span class="inlinemediaobject"><img src="images/basic-architecture-web-application.png" width="576" alt="图片"></span></p><p>实质上<code class="literal">WebAppContext</code>是一个便利类，它帮助构建和配置其他处理程序以实现标准的Web应用程序配置。配置实际上是通过Configuration类的可插入实现来完成的，其中主要是<code class="literal">WebXmlConfiguration.</code></p></div></div></div><script type="text/javascript">
      SyntaxHighlighter.all()
    </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tbody><tr><td width="40%" align="left"><a href="jetty-ref-guide.html" accesskey="p"><i class="fa fa-chevron-left" aria-hidden="true"></i>以前</a> </td><td width="20%" align="center"><a href="jetty-ref-guide.html" accesskey="u"><i class="fa fa-chevron-up" aria-hidden="true"></i>最佳</a></td><td width="40%" align="right"> <a href="jetty-classloading.html" accesskey="n">下一个<i class="fa fa-chevron-right" aria-hidden="true"></i></a></td></tr><tr><td width="40%" align="left" valign="top">第五部分Jetty参考指南</td><td width="20%" align="center"><a href="index.html" accesskey="h"><i class="fa fa-home" aria-hidden="true"></i>家</a></td><td width="40%" align="right" valign="top">Jetty类装载</td></tr></tbody></table></div><p xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"></p><div class="jetty-callout">看到错误或缺少的东西？
            <span class="callout"><a href="http://github.com/eclipse/jetty.project">在以下位置对此文档做出贡献<span class="website"><i class="fa fa-github" aria-hidden="true"></i> Github！</span></a></span> <span style="float:right"><i>（产生：2019-11-20）</i></span></div><p></p></body></html>