<html ><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>API用法</title><link rel="stylesheet" type="text/css" href="css/docbook.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="jetty, servlet, servlet-api, cometd, http, websocket, eclipse, maven, java, server, software"><link rel="home" href="index.html" title="Jetty"><link rel="up" href="http-client.html" title="Chapter 22. HTTP Client"><link rel="prev" href="http-client.html" title="Chapter 22. HTTP Client"><link rel="next" href="http-client-cookie.html" title="Cookies Support"><link rel="shortcut icon" href="images/favicon.ico" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><link rel="stylesheet" href="css/highlighter/foundation.css"><script src="js/highlight.pack.js"></script><script>
      hljs.initHighlightingOnLoad();
    </script><link type="text/css" rel="stylesheet" href="css/font-awesome/font-awesome.min.css"></head><body bgcolor="white"  text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><tbody><tr><td style="width:25%"><a href="http://www.eclipse.org/jetty"><img src="images/jetty-header-logo.png" alt="Jetty标志"></a><br><span style="font-size:small">版本：9.4.24.v20191120</span></td><td style="width:50%"></td></tr></tbody></table><div class="navheader" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><table width="100%" summary="Navigation header"><tbody><tr><th colspan="3" align="center">API用法</th></tr><tr><td width="20%" align="left"><a href="http-client.html" accesskey="p"><i class="fa fa-chevron-left" aria-hidden="true"></i>以前</a> </td><th width="60%" align="center">第22章HTTP客户端<br><a href="index.html" accesskey="p"><i class="fa fa-home" aria-hidden="true"></i>家</a></th><td width="20%" align="right"> <a href="http-client-cookie.html" accesskey="n">下一个<i class="fa fa-chevron-right" aria-hidden="true"></i></a></td></tr></tbody></table><hr></div><div class="jetty-callout" xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><h5 class="callout"><a href="http://www.webtide.com/">通过<span class="website">www.webtide.com</span>与Jetty核心开发人员联系。</a></h5><p>内部/客户项目的私人支持...自定义扩展和发行版...无限期支持的版本快照...您的应用程序和Ajax / Comet项目的可伸缩性指南...赞助功能开发的开发服务</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="http-client-api"></a> API用法</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="http-client-api.html#http-client-blocking">阻止API</a></span></dt><dt><span class="section"><a href="http-client-api.html#http-client-async">非阻塞API</a></span></dt><dt><span class="section"><a href="http-client-api.html#http-client-content">内容处理</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="http-client-blocking"></a>阻止API</h3></div></div></div><p>执行HTTP请求的简单方法如下：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.GET("http://domain.com/path?query");</code></pre><p>方法<code class="literal">HttpClient.GET(...)</code>执行HTTP <code class="literal">GET</code>请求给定的URI并返回一个<code class="literal">ContentResponse</code>当请求/响应对话成功完成时。</p><p>的<code class="literal">ContentResponse</code>对象包含HTTP响应信息：状态代码，标头以及可能的内容。默认情况下，内容长度限制为2 MiB。有关更大的内容，请参见<a class="xref" href="http-client-api.html#http-client-response-content" title="响应内容处理">响应内容处理</a> 。</p><p>如果您想自定义请求，例如通过发出<code class="literal">HEAD</code>请求而不是<code class="literal">GET</code> ，并模拟浏览器用户代理，您可以通过以下方式进行操作：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.newRequest("http://domain.com/path?query")
        .method(HttpMethod.HEAD)
        .agent("Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0")
        .send();</code></pre><p>这是以下内容的简写：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>Request request = httpClient.newRequest("http://domain.com/path?query");
request.method(HttpMethod.HEAD);
request.agent("Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0");
ContentResponse response = request.send();</code></pre><p>您首先使用创建一个请求对象<code class="literal">httpClient.newRequest(...)</code> ，然后使用流畅的API样式（即，请求对象上的方法的链式调用）对其进行自定义。自定义请求对象后，您调用<code class="literal">request.send()</code>产生<code class="literal">ContentResponse</code>请求/响应对话完成时。</p><p>简单<code class="literal">POST</code>请求也有一个快捷方法：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.POST("http://domain.com/entity/1")
        .param("p", "value")
        .send();</code></pre><p>的<code class="literal">POST</code>通过添加的参数值<code class="literal">param()</code>方法会自动进行URL编码。</p><p>Jetty的HTTP客户端自动跟随重定向，因此它处理典型的Web模式<a class="link" href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_top">POST / Redirect / GET</a> ，并且响应对象包含响应的内容。 <code class="literal">GET</code>请求。重定向后的功能是可以基于每个请求或全局启用/禁用的功能。</p><p>文件上传也需要一行，并使用JDK 7 <code class="literal">java.nio.file</code>类：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.newRequest("http://domain.com/upload")
        .method(HttpMethod.POST)
        .file(Paths.get("file_to_upload.txt"), "text/plain")
        .send();</code></pre><p>可以使用来强加请求/响应对话的总超时时间<code class="literal">Request.timeout(...)</code>方法如下：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.newRequest("http://domain.com/path?query")
        .timeout(5, TimeUnit.SECONDS)
        .send();</code></pre><p>在上面的示例中，当5秒到期时，请求被中止，并且<code class="literal">java.util.concurrent.TimeoutException</code>被抛出。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="http-client-async"></a>非阻塞API</h3></div></div></div><p>到目前为止，我们已经展示了如何以阻塞方式使用Jetty HTTP客户端-也就是说，发出请求的线程会阻塞，直到请求/响应对话完成为止。</p><p>本节将研究Jetty的HTTP客户端非阻塞异步API，这些API非常适合大型内容下载，请求/响应的并行处理以及在性能和有效线程与资源利用率是关键因素的情况下。</p><p>异步API严重依赖在请求和响应处理的各个阶段调用的侦听器。这些侦听器由应用程序实现，并且可以执行任何类型的逻辑。该实现在用于处理请求或响应的同一线程中调用这些侦听器。因此，如果这些侦听器中的应用程序代码需要很长时间才能执行，则请求或响应处理将延迟到侦听器返回之前。</p><p>如果您需要在侦听器中执行花费很长时间的应用程序代码，则必须生成自己的线程，并记住要深复制您的代码中将需要的侦听器提供的所有数据，因为当侦听器返回它提供的数据时，回收/清除/销毁。</p><p>请求和响应处理由两个不同的线程执行，因此可能同时发生。这种并发处理的典型示例是回显服务器，其中较大的上传可能与较大的下载回显并发。另外，请记住，可以<span class="emphasis"><em>在</em></span>请求<span class="emphasis"><em>之前</em></span>处理和完成响应。一个典型的示例是大型上载触发服务器快速响应（例如，错误）：响应可能到达并在请求内容仍在上载时完成。</p><p>调用的应用程序线程<code class="literal">Request.send(Response.CompleteListener)</code>执行请求的处理，直到请求被完全处理或将在I / O上阻塞为止，然后它返回（因此从不阻塞）。如果它将阻止I / O，则线程会要求I / O系统在I / O准备好继续进行操作时发出事件，然后返回。当此类事件被触发时，从<code class="literal">HttpClient</code>线程池将继续处理请求。</p><p>响应是从I / O线程处理的，该I / O线程触发了准备读取字节的事件。响应处理将继续进行，直到完全处理了响应或将其阻塞为I / O。如果它将阻止I / O，则线程会要求I / O系统在I / O准备好继续的时候发出事件，然后返回。当此类事件被触发时，从<code class="literal">HttpClient</code>线程池将恢复响应的处理。</p><p>当请求和响应都被完全处理时，完成最后一次处理的线程（通常是处理响应的线程，但也可能是处理请求的线程-如果请求所花的时间比要处理的响应多的时间）用于使下一个针对相同目的地的请求出队并进行处理。</p><p>一个简单的异步<code class="literal">GET</code>可以使用以下方式编写丢弃响应内容的请求：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>httpClient.newRequest("http://domain.com/path")
        .send(new Response.CompleteListener()
        {
            @Override
            public void onComplete(Result result)
            {
                // Your logic here
            }
        });</code></pre><p>方法<code class="literal">Request.send(Response.CompleteListener)</code>退货<code class="literal">void</code>并且不阻塞；的<code class="literal">Response.CompleteListener</code>当请求/响应对话完成时，通知作为参数提供的信息，并且<code class="literal">Result</code>参数允许您访问响应对象。</p><p>您可以使用JDK 8的lambda表达式编写相同的代码：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>httpClient.newRequest("http://domain.com/path")
        .send(result -&gt; { /* Your logic here */ });</code></pre><p>您可以采用同步API所用的相同方式，为请求/响应会话设置总超时时间：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>httpClient.newRequest("http://domain.com/path")
        .timeout(3, TimeUnit.SECONDS)
        .send(result -&gt; { /* Your logic here */ });</code></pre><p>上面的示例将在请求/响应对话中施加3秒钟的总超时时间。</p><p>HTTP客户端API广泛使用侦听器来为所有可能的请求和响应事件提供钩子，并且使用JDK 8的lambda表达式，它们使用起来更加有趣：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>httpClient.newRequest("http://domain.com/path")
        // Add request hooks
        .onRequestQueued(request -&gt; { ... })
        .onRequestBegin(request -&gt; { ... })
        ... // More request hooks available

        // Add response hooks
        .onResponseBegin(response -&gt; { ... })
        .onResponseHeaders(response -&gt; { ... })
        .onResponseContent((response, buffer) -&gt; { ... })
        ... // More response hooks available

        .send(result -&gt; { ... });</code></pre><p>这使得Jetty HTTP客户端适用于HTTP负载测试，因为例如，您可以准确地对请求/响应对话的每个步骤进行计时（从而知道请求/响应时间的真正花费时间）。</p><p>看看<a class="link" href="http://www.eclipse.org/jetty/javadoc/9.4.24.v20191120/org/eclipse/jetty/client/api/Request.Listener.html" target="_top"><code class="literal">Request.Listener</code></a>类以了解请求事件，并<a class="link" href="http://www.eclipse.org/jetty/javadoc/9.4.24.v20191120/org/eclipse/jetty/client/api/Response.Listener.html" target="_top"><code class="literal">Response.Listener</code></a>知道响应事件的类。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="http-client-content"></a>内容处理</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="http-client-request-content"></a>请求内容处理</h4></div></div></div><p>Jetty的HTTP客户端提供了许多现成的实用程序类来处理请求内容。</p><p>您可以提供请求内容为<code class="literal">String</code> ， <code class="literal">byte[]</code> ， <code class="literal">ByteBuffer</code> ， <code class="literal">java.nio.file.Path</code> ， <code class="literal">InputStream</code> ，并提供您自己的实现<code class="literal">org.eclipse.jetty.client.api.ContentProvider</code> 。这是一个使用以下内容提供请求内容的示例<code class="literal">java.nio.file.Paths</code> ：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.newRequest("http://domain.com/upload")
        .method(HttpMethod.POST)
        .file(Paths.get("file_to_upload.txt"), "text/plain")
        .send();</code></pre><p>这等效于使用<code class="literal">PathContentProvider</code>实用程序类：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.newRequest("http://domain.com/upload")
        .method(HttpMethod.POST)
        .content(new PathContentProvider(Paths.get("file_to_upload.txt")), "text/plain")
        .send();</code></pre><p>或者，您可以使用<code class="literal">FileInputStream</code>通过<code class="literal">InputStreamContentProvider</code>实用程序类：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>ContentResponse response = httpClient.newRequest("http://domain.com/upload")
        .method(HttpMethod.POST)
        .content(new InputStreamContentProvider(new FileInputStream("file_to_upload.txt")), "text/plain")
        .send();</code></pre><p>以来<code class="literal">InputStream</code>被阻塞，即使输入流被阻塞，如果输入流阻塞，请求的发送也会被阻塞<code class="literal">HttpClient</code>蜜蜂。</p><p>如果您已经阅读了内存中的内容，则可以将其作为<code class="literal">byte[]</code>使用<code class="literal">BytesContentProvider</code>实用程序类：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>byte[] bytes = ...;
ContentResponse response = httpClient.newRequest("http://domain.com/upload")
        .method(HttpMethod.POST)
        .content(new BytesContentProvider(bytes), "text/plain")
        .send();</code></pre><p>如果请求内容不是立即可用，但是将通知您的应用程序要发送的内容，则可以使用<code class="literal">DeferredContentProvider</code>通过这种方式：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>DeferredContentProvider content = new DeferredContentProvider();
httpClient.newRequest("http://domain.com/upload")
        .method(HttpMethod.POST)
        .content(content)
        .send(new Response.CompleteListener()
        {
            @Override
            public void onComplete(Result result)
            {
                // Your logic here
            }
        });

// Content not available yet here

...

// An event happens, now content is available
byte[] bytes = ...;
content.offer(ByteBuffer.wrap(bytes));

...

// All content has arrived
content.close();</code></pre><p>在等待请求内容并因此由客户端应用程序上载请求时，服务器可能能够完全异步地响应（至少使用响应头）。在这种情况下， <code class="literal">Response.Listener</code>回调将在请求完全发送之前被调用。这允许对请求/响应对话进行细粒度的控制：例如，服务器可能拒绝太大的内容，将响应发送给客户端，这反过来又可能会阻止内容上载。</p><p>提供请求内容的另一种方法是使用<code class="literal">OutputStreamContentProvider</code> ，允许应用程序在请求内容可用时写入请求内容。 <code class="literal">OutputStream</code>由...提供<code class="literal">OutputStreamContentProvider</code> ：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>OutputStreamContentProvider content = new OutputStreamContentProvider();

// Use try-with-resources to close the OutputStream when all content is written
try (OutputStream output = content.getOutputStream())
{
    client.newRequest("localhost", 8080)
            .method(HttpMethod.POST)
            .content(content)
            .send(new Response.CompleteListener()
            {
                @Override
                public void onComplete(Result result)
                {
                    // Your logic here
                }
            });

    ...

    // Write content
    writeContent(output);
}
// End of try-with-resource, output.close() called automatically to signal end of content</code></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="http-client-response-content"></a>响应内容处理</h4></div></div></div><p>Jetty HTTP客户端允许应用程序以不同方式处理响应内容。</p><p>第一种方法是将响应内容缓存在内存中；这是在使用阻止API时完成的（请参见<a class="xref" href="http-client-api.html#http-client-blocking" title="阻止API">阻止API</a> ），并且将内容缓冲在<code class="literal">ContentResponse</code>最多2 MiB。</p><p>如果您想控制响应内容的长度（例如，限制为小于默认值2 MiB的值），则可以使用<code class="literal">org.eclipse.jetty.client.util.FutureResponseListener</code>通过这种方式：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>Request request = httpClient.newRequest("http://domain.com/path");

// Limit response content buffer to 512 KiB
FutureResponseListener listener = new FutureResponseListener(request, 512 * 1024);

request.send(listener);

ContentResponse response = listener.get(5, TimeUnit.SECONDS);</code></pre><p>如果超出了响应内容的长度，则响应将被中止，并且方法将引发异常<code class="literal">get()</code> 。</p><p>如果您使用的是异步API（请参见<a class="xref" href="http-client-api.html#http-client-async" title="非阻塞API">非阻塞API</a> ），则可以使用<code class="literal">BufferingResponseListener</code>实用程序类：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>httpClient.newRequest("http://domain.com/path")
        // Buffer response content up to 8 MiB
        .send(new BufferingResponseListener(8 * 1024 * 1024)
        {
            @Override
            public void onComplete(Result result)
            {
                if (!result.isFailed())
                {
                    byte[] responseContent = getContent();
                    // Your logic here
                }
            }
        });</code></pre><p>第二种方法是最有效的（因为它避免了内容复制），并允许您指定一个<code class="literal">Response.ContentListener</code>或子类，以便在内容到达时立即对其进行处理。在下面的示例中， <code class="literal">Response.Listener.Adapter</code>是一个实现了<code class="literal">Response.ContentListener</code>和<code class="literal">Response.CompleteListener</code>并可以传递给<code class="literal">Request.send()</code> 。Jetty的HTTP客户端将调用<code class="literal">onContent()</code>方法零次或多次（直到有内容），最后调用<code class="literal">onComplete()</code>方法。</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>httpClient .newRequest("http://domain.com/path")
        .send(new Response.Listener.Adapter()
        {
            @Override
            public void onContent(Response response, ByteBuffer buffer)
            {
                // Your logic here
            }
        });</code></pre><p>第三种方式允许您等待响应，然后使用<code class="literal">InputStreamResponseListener</code>实用程序类：</p><pre xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"><code>InputStreamResponseListener listener = new InputStreamResponseListener();
httpClient.newRequest("http://domain.com/path")
        .send(listener);

// Wait for the response headers to arrive
Response response = listener.get(5, TimeUnit.SECONDS);

// Look at the response
if (response.getStatus() == HttpStatus.OK_200)
{
    // Use try-with-resources to close input stream.
    try (InputStream responseContent = listener.getInputStream())
    {
        // Your logic here
    }
}</code></pre></div></div></div><script type="text/javascript">
      SyntaxHighlighter.all()
    </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tbody><tr><td width="40%" align="left"><a href="http-client.html" accesskey="p"><i class="fa fa-chevron-left" aria-hidden="true"></i>以前</a> </td><td width="20%" align="center"><a href="http-client.html" accesskey="u"><i class="fa fa-chevron-up" aria-hidden="true"></i>最佳</a></td><td width="40%" align="right"> <a href="http-client-cookie.html" accesskey="n">下一个<i class="fa fa-chevron-right" aria-hidden="true"></i></a></td></tr><tr><td width="40%" align="left" valign="top">第22章HTTP客户端</td><td width="20%" align="center"><a href="index.html" accesskey="h"><i class="fa fa-home" aria-hidden="true"></i>家</a></td><td width="40%" align="right" valign="top">Cookies支持</td></tr></tbody></table></div><p xmlns:jfetch="java:org.eclipse.jetty.xslt.tools.JavaSourceFetchExtension" xmlns:fetch="java:org.eclipse.jetty.xslt.tools.SourceFetchExtension" xmlns:d="http://docbook.org/ns/docbook" xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" xmlns:xslthl="http://xslthl.sf.net" xmlns:gcse="http://www.google.com" xmlns:date="http://exslt.org/dates-and-times"></p><div class="jetty-callout">看到错误或缺少的东西？
            <span class="callout"><a href="http://github.com/eclipse/jetty.project">在以下位置对此文档做出贡献<span class="website"><i class="fa fa-github" aria-hidden="true"></i> Github！</span></a></span> <span style="float:right"><i>（产生：2019-11-20）</i></span></div><p></p></body></html>