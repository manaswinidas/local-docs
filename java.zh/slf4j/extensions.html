<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>SLF4J扩展</title>
    
    <link rel="stylesheet" type="text/css" href="css/site.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/prettify.css">
  </head>
  <body  onload="prettyPrint()">
    <script type="text/javascript">prefix='';</script>
    <script type="text/javascript" src="js/prettify.js"></script>
    <script src="templates/header.js" type="text/javascript"></script>
    <div id="left">
      <script src="templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="templates/right.js" type="text/javascript"></script>
    </div>

    <div id="content">

    <h1>SLF4J扩展</h1>

    <p>SLF4J扩展打包在SLF4J <em>随附的slf4j-ext.jar</em>中。</p>

    
    <ul>
      <li><a href="#profiler">探查器</a></li>
      <li><a href="#extended_logger">扩展记录器</a></li>
      <li><a href="#event_logger">事件记录</a></li>
      <li><a href="#javaagent">与Java代理一起添加的日志记录（需要Java 5）</a></li>
    </ul>

		<h2><a name="profiler"></a>分析器</h2>

		<h3>什么是探查器？</h3>
    
    <p>根据维基百科， <a href="http://en.wikipedia.org/wiki/Profiler_%28computer_science%29">概要分析</a>是使用程序运行时收集的信息来调查程序的行为，即，它是动态程序分析的一种形式，与静态代码分析相对。性能分析的通常目标是确定要优化速度或内存使用率的程序的哪些部分。
    </p>

    <p>SLF4J探查器（又名穷人探查器）将帮助开发人员收集性能数据。本质上，探查器由一个或多个秒表组成。秒表由<em>源代码中的</em>语句驱动（启动/停止）。一个例子应该更清楚地说明这一点。
    </p>

    <h3>基本例子</h3>


    <em>示例：使用探查器： <a href="xref-test/org/slf4j/profiler/BasicProfilerDemo.html">BasicProfilerDemo</a></em>

    <pre class="prettyprint source">[omitted]
32  public class BasicProfilerDemo {
33  
34    public static void main(String[] args) {
35      // create a profiler called "BASIC"
36      <b>Profiler profiler = new Profiler("BASIC");</b>
37      <b>profiler.start("A");</b>
38      doA();
39  
40      <b>profiler.start("B");</b>
41      doB();
42      
43      <b>profiler.start("OTHER");</b>
44      doOther();
45      <b>profiler.stop().print();</b>
46    }
[omitted]</pre>


  <p>运行上面的示例将输出以下输出。</p>

    <p class="source">+ Profiler [BASIC] |-经过的时间[A] 220.487毫秒。|-经过的时间[B] 2499.866毫秒。|-经过的时间[OTHER] 3300.745毫秒。|-[BASIC]总计6022.568毫秒。</p>
  
   <p>实例化探查器将启动全局秒表。每次对start（）方法的调用都会启动一个新的名为秒表的秒表。除了启动已命名的秒表之外，start（）方法还导致先前的秒表停止。因此， <code>profiler.start("A")</code>启动名为“ A”的秒表。随后致电<code>profiler.start("B")</code>启动秒表“ B”，同时停止秒表“ A”。调用<code>stop()</code>在探查器上停止将停止最后一个秒表以及在实例化探查器时启动的全局秒表。
   </p>


   <h3>探查器嵌套</h3>
   
   <p>探查器也可以嵌套。通过嵌套探查器，可以测量本身具有需要定时和测量的子任务的任务。
   </p>

   <p>启动嵌套探查器将停止任何先前启动的与父探查器关联的秒表或嵌套探查器。
   </p>
   
   <p>通常，子任务是由与托管父探查器的类不同的类实现的。使用<code>ProfilerRegistry</code>是将嵌套的探查器传递到当前对象之外的对象的便捷方法。每个线程都有自己的探查器注册表，可以通过调用以下命令来检索<code>getThreadContextInstance()</code>方法。
   </p>

   <em>示例： <a href="xref-test/org/slf4j/profiler/NestedProfilerDemo.html">NestedProfilerDemo</a>
   </em>

   <pre class="prettyprint source">33  public class NestedProfilerDemo {
34    
35    public static void main(String[] args) {
36      // create a profiler called "DEMO"
37      Profiler profiler = new Profiler("DEMO");
38      
39      // register this profiler in the thread context's profiler registry
40      <b>ProfilerRegistry profilerRegistry = ProfilerRegistry.getThreadContextInstance();</b>
41      <b>profiler.registerWith(profilerRegistry);</b>
42      
43      // start a stopwatch called "RANDOM"
44      profiler.start("RANDOM");
45      RandomIntegerArrayGenerator riaGenerator = new RandomIntegerArrayGenerator();
46      int n = 1000*1000;
47      int[] randomArray = riaGenerator.generate(n);
48      
49      // create and start a nested profiler called "SORT_AND_PRUNE"
50      // By virtue of its parent-child relationship with the "DEMO"
51      // profiler, and the previous registration of the parent profiler, 
52      // this nested profiler will be automatically registered
53      // with the thread context's profiler registry
54      <b>profiler.startNested(SortAndPruneComposites.NESTED_PROFILER_NAME);</b>
55      
56      SortAndPruneComposites pruner = new SortAndPruneComposites(randomArray);
57      pruner.sortAndPruneComposites();
58      
59      // stop and print the "DEMO" printer
60      profiler.stop().print();
61    }
62  }</pre>

   <p>这是<a href="xref-test/org/slf4j/profiler/SortAndPruneComposites.html">SortAndPruneComposites</a>类的相关摘录。
   </p>

   <pre class="prettyprint source">[omitted]
6   public class SortAndPruneComposites {
7   
8     static String NESTED_PROFILER_NAME = "SORT_AND_PRUNE";
9     
10    final int[] originalArray;
11    final int originalArrayLength;
12    
13    public SortAndPruneComposites(int[] randomArray) {
14      this.originalArray = randomArray;
15      this.originalArrayLength = randomArray.length;
16     
17    }
18    
19    public int[] sortAndPruneComposites() {
20      // retrieve previously registered profiler named "SORT_AND_PRUNE"
21      ProfilerRegistry profilerRegistry = ProfilerRegistry.getThreadContextInstance();
22      <b>Profiler sortProfiler = profilerRegistry.get(NESTED_PROFILER_NAME);</b>
23  
24      // start a new stopwatch called SORT
25      sortProfiler.start("SORT");
26      int[] sortedArray = sort();
27      // start a new stopwatch called PRUNE_COMPOSITES
28      sortProfiler.start("PRUNE_COMPOSITES");
29      int result[] = pruneComposites(sortedArray);
30      
31      return result;
32    }
[omitted] </pre>
   

  <p>在主频为3.2 GHz的双核Intel CPU上，运行<code>ProfilerDemo</code>应用程序产生以下输出：</p>
  
  <p class="source">+ Profiler [DEMO] |-经过的时间[RANDOM] 70.524毫秒。| --- +探查器[SORT_AND_PRUNE] |-经过的时间[SORT] 665.281毫秒。|-经过的时间[PRUNE_COMPOSITES] 5695.515毫秒。|-小计[SORT_AND_PRUNE] 6360.866毫秒。|-经过的时间[SORT_AND_PRUNE] 6360.866毫秒。|-总[DEMO] 6433.922毫秒。</p>

  <p>从上面的内容中，我们了解到生成1'000'000个随机整数需要70毫秒，将它们排序为665毫秒，然后将复合（非素数）整数5695毫秒进行修剪，总共需要6433毫秒。考虑到修剪组合需要花费大部分CPU工作量，因此任何将来的优化工作都将直接针对修剪部分。
  </p>

  <p>仅需进行几次适当的探查器调用，我们就可以识别应用程序中的热点。还要注意，将探查器传递给目标类可以通过在探查器注册表中注册探查器，然后在目标类中进行检索来实现。
  </p>

  <h3>使用记录仪打印</h3>

  <p>调用中<code>profiler.print</code>将始终在控制台上打印输出。如果希望将探查器代码保留在生产中，则可能需要对输出目标进行更多控制。这可以通过将您选择的记录器与分析器相关联来实现。
  </p>
  
  <p>将记录器与事件探查器关联之后，您将调用<code>log()</code>方法代替<code>print()</code>如下面的示例所示。
  </p>

  <em>带记录器的探查器： <a href="xref-test/org/slf4j/profiler/NestedProfilerDemo2.html">NestedProfilerDemo2</a>
   </em>

   <pre class="prettyprint source">[omitted]
17  public class NestedProfilerDemo2 {
18  
19    static Logger logger = LoggerFactory.getLogger(NestedProfilerDemo2.class);
20    
21    public static void main(String[] args) {
22      Profiler profiler = new Profiler("DEMO");
23      // associate a logger with the profiler
24      <b>profiler.setLogger(logger);</b>
25      
26      ProfilerRegistry profilerRegistry = ProfilerRegistry.getThreadContextInstance();
27      profiler.registerWith(profilerRegistry);
28      
29      profiler.start("RANDOM");
30      RandomIntegerArrayGenerator riaGenerator = new RandomIntegerArrayGenerator();
31      int n = 10*1000;
32      int[] randomArray = riaGenerator.generate(n);
33      
34      profiler.startNested(SortAndPruneComposites.NESTED_PROFILER_NAME);
35      
36      SortAndPruneComposites pruner = new SortAndPruneComposites(randomArray);
37      pruner.sortAndPruneComposites();
38      
39      // stop and log
40      profiler.stop().<b>log()</b>;
41    }
42  } </pre>
  
  <p>此示例生成的输出将取决于日志记录环境，但应与前一个生成的输出非常相似<code>NestedProfilerDemo</code>例。
  </p>

  <p>log（）方法使用名为“ PROFILER”的标记在DEBUG级别记录日志。</p>

  <p>如果您的日志记录系统支持标记（例如，日志记录），则可以专门启用或禁用SLF4J分析器生成的输出。即使为探查级别启用了探查器使用的记录器，这里的logback配置文件也会禁用任何带有“ PROFILER”标记的记录事件的输出。
  </p>


  <em>logback配置禁用分析器（仅分析器）的日志记录</em>

  <pre class="prettyprint source">&lt;configuration>

  <b>&lt;turboFilter class="ch.qos.logback.classic.turbo.MarkerFilter">
    &lt;Marker>PROFILER&lt;/Marker>
    &lt;OnMatch>DENY&lt;/OnMatch>
  &lt;/turboFilter></b>
    
  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;Pattern>%-5level %logger{36} - %msg%n&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root>
    &lt;level value="DEBUG" />
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration>  </pre>


<!-- .............................................................. -->

   <h2><a name="mdcStrLookup"></a> MDCStrLookup</h2>

   <p>StrLookup是Apache Commons Lang中定义的类。它与StrSubstitutor类结合使用，以允许字符串在运行时动态替换字符串中的标记。在许多情况下，需要将SLF4J MDC中的键值合并为字符串。MDCStrLookup使这成为可能。
   </p>
   <p>Apache Commons Configuration提供了一个ConfigurationInterpolator类。此类允许注册新的StrLookups，然后可以使用这些值与Commons Configuration的配置及其管理的配置文件合并。
   </p>
   <p>StrLookup显然依赖Commons Lang。slf4j-ext的Maven pom.xml将此依赖项列为可选，因此不需要那些希望使用其他扩展名的人来打包公共lang jar。因此，在使用MDCStrLookup时，必须与slf4j-ext一起显式声明commons-lang的依赖关系。
   </p>

<!-- .............................................................. -->

   <h2><a name="extended_logger"></a>扩展记录仪</h2>

   <p>的<a href="apidocs/org/slf4j/ext/XLogger.html"><code>XLogger</code></a>类提供了一些额外的日志记录方法，这些方法对于遵循应用程序的执行路径非常有用。这些方法生成的日志事件可以与其他调试日志分开进行过滤。鼓励自由使用这些方法，因为已经发现输出可以</p>
   
   <ul> 
     <li>无需调试会话即可帮助开发中的问题诊断</li>

     <li>协助无法进行调试的生产中的问题诊断</li> 
     
     <li>帮助教育新开发者学习应用程序。</li>
   </ul>
   

   <p>两种最常用的方法是<code>entry()</code>和<code>exit()</code>方法。 <code>entry()</code>应该放在方法的开头，除了简单的getter和setter之外。 <code>entry()</code>可以称为从0到4的参数传递。通常，这些将是传递给方法的参数。的<code>entry()</code>方法记录的跟踪级别为TRACE，并使用<code>Marker</code>其名称为“ ENTER”，它也是“ FLOW”标记。
   </p>
   
   <p>的<code>exit()</code>方法应该放在任何return语句之前，或者作为没有返回的方法的最后一个语句。 <code>exit()</code>可以使用或不使用参数来调用。通常，返回void的方法将使用<code>exit()</code>而返回对象的方法将使用exit（Object obj）。的<code>entry()</code>方法记录的跟踪级别为TRACE，并使用名称为“ EXIT”的标记，该标记也是“ FLOW”标记。
   </p>
   
   <p>当应用程序抛出不太可能处理的异常（例如RuntimeException）时，可以使用throwing（）方法。这样可以确保在需要时可以进行适当的诊断。生成的日志记录事件将具有ERROR级别，并将具有名称为“ THROWING”的关联标记，该标记也是“ EXCEPTION”标记。
   </p>

   <p>当应用程序捕获到不打算重新抛出的异常（无论是显式的还是附加到另一个Exception）时，可以使用catching（）方法。生成的日志记录事件将具有ERROR级别，并将具有名称为“ CATCHING”的关联标记，该标记也是“ EXCEPTION”标记。
   </p>
   
   <p>通过使用这些扩展的方法，可以确保在SLF4J上实现标准化的应用程序能够以标准化的方式执行诊断日志记录。
   </p>

   <p>请注意，XLogger实例是通过<a href="apidocs/org/slf4j/ext/XLoggerFactory.html"><code>XLoggerFactory</code></a>实用程序类。</p>

   <p>以下示例显示了以相当典型的方式使用这些方法的简单应用程序。的<code>throwing()</code>该方法不存在，因为没有显式抛出异常且未处理任何异常。
   </p>

   <pre class="prettyprint source">package com.test;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import java.util.Random;

public class TestService {
  private XLogger logger = XLoggerFactory.getXLogger(TestService.class
      .getName());

  private String[] messages = new String[] { "Hello, World",
      "Goodbye Cruel World", "You had me at hello" };

  private Random rand = new Random(1);

  public String retrieveMessage() {
    logger.entry();

    String testMsg = getMessage(getKey());

    logger.exit(testMsg);
    return testMsg;
  }

  public void exampleException() {
    logger.entry();
    try {
      String msg = messages[messages.length];
      logger.error("An exception should have been thrown");
    } catch (Exception ex) {
      logger.catching(ex);
    }
    logger.exit();
  }

  public String getMessage(int key) {
    logger.entry(key);

    String value = messages[key];

    logger.exit(value);
    return value;
  }

  private int getKey() {
    logger.entry();
    int key = rand.nextInt(messages.length);
    logger.exit(key);
    return key;
  }
}</pre>

   <p>该测试应用程序使用前面的服务来生成日志事件。
   </p>

   <pre class="prettyprint source">package com.test;

public class App {
  public static void main( String[] args )    {
    TestService service = new TestService();
    service.retrieveMessage();
    service.retrieveMessage();
    service.exampleException();
  }
} </pre>
  
   <p>下面的配置将导致所有输出都路由到target / test.log。FileAppender的模式包括类名，行号和方法名。在模式中包括这些对于使日志有价值至关重要。
   </p>

   <pre class="prettyprint source">&lt;?xml version='1.0' encoding='UTF-8'?>
&lt;configuration&gt;
  &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt;
      &lt;level&gt;ERROR&lt;/level&gt;
      &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
      &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
    &lt;/filter&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;Pattern&gt;%d{HH:mm:ss.SSS} %-5level %class{36}:%L %M - %msg%n&lt;/Pattern&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;
  &lt;appender name="log" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;File&gt;target/test.log&lt;/File&gt;
    &lt;Append&gt;false&lt;/Append&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;Pattern&gt;%d{HH:mm:ss.SSS} %-5level %class{36}:%L %M - %msg%n&lt;/Pattern&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;root&gt;
    &lt;level value="trace" /&gt;
    &lt;appender-ref ref="log" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>
   <p>这是上述Java类和配置的输出。
   </p>
<p class="source">00：07：57.725 TRACE com.test.TestService：22 entry-条目00：07：57.738 TRACE com.test.TestService：57 getKey-条目00：07：57.739 TRACE com.test.TestService：59 getKey-以（退出0）00：07：57.741 TRACE com.test.TestService：47 getMessage-输入为（0）00：07：57.741 TRACE com.test.TestService：51 getMessage-以（Hello，World）输出为00：07：57.742 TRACE com.test.TestService：26 RetrieveMessage-退出（Hello，World）00：07：57.742 TRACE com.test.TestService：22triggerMessage-条目00：07：57.742 TRACE com.test.TestService：57 getKey-条目00： 07：57.743 TRACE com.test.TestService：59 getKey-以（1）退出00：07：57.745 TRACE com.test.TestService：47 getMessage-以（1）00：07：57.745 TRACE com.test.TestService进入： 51 getMessage-以（Goodbye Cruel World）00：07：57.746退出TRACE com.test.TestService：26 resolveMessage-以（Goodbye Cruel World）00：07：57.746退出TRACE com.test.TestService：32 exampleException-条目00： 07：57.750 com.test.TestService：40 exampleException错误-捕获java.lang。ArrayIndexOutOfBoundsException：在com.test.AppService.exampleException（TestService.java:35）在com.test.AppTest.testApp（AppTest.java:39）处为3。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）。java.lang.reflect上的DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）。位于junit.framework的Method.invoke（Method.java:585）。junit.framework的TestCase.runTest（TestCase.java:154）。junit.framework的TestCase.runBare（TestCase.java:127）。位于junit.framework的TestResult $ 1.protect（TestResult.java:106）。junit.framework的TestResult.runProtected（TestResult.java:124）。位于junit.framework的TestResult.run（TestResult.java:109）。junit.framework的TestCase.run（TestCase.java:118）。junit.framework的TestSuite.runTest（TestSuite.java:208）。位于sun.reflect的TestSuite.run（TestSuite.java:203）。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）。java.lang.reflect上的DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）。org.apache.maven.surefire.junit上的Method.invoke（Method.java:585）。org.apache.maven.surefire.suite上的JUnitTestSet.execute（JUnitTestSet.java:213）。org.apache.maven.surefire.suite的AbstractDirectoryTestSuite.executeTestSet（AbstractDirectoryTestSuite.java:140）。org.apache.maven.surefire的AbstractDirectoryTestSuite.execute（AbstractDirectoryTestSuite.java:127）。Surefire.run（Surefire.java:177）位于sun.reflect。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）。java.lang.reflect上的DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）。org.apache.maven.surefire.booter上的Method.invoke（Method.java:585）。org.apache.maven.surefire.booter上的SurefireBooter.runSuitesInProcess（SurefireBooter.java:338）。SurefireBooter.main（SurefireBooter.java:997）00：07：57.750 TRACE com.test.TestService：42 exampleException-退出</p>

   <p>在上面的示例中，仅将根记录程序级别更改为DEBUG即可大大减少输出。
   </p>
   <p class="source">00：28：06.004错误com.test.TestService：40 exampleException-正在捕获java.lang。ArrayIndexOutOfBoundsException：在com.test.AppService.exampleException（TestService.java:35）在com.test.AppTest.testApp（AppTest.java:39）处为3。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）。java.lang.reflect上的DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）。位于junit.framework的Method.invoke（Method.java:585）。junit.framework的TestCase.runTest（TestCase.java:154）。junit.framework的TestCase.runBare（TestCase.java:127）。位于junit.framework的TestResult $ 1.protect（TestResult.java:106）。junit.framework的TestResult.runProtected（TestResult.java:124）。位于junit.framework的TestResult.run（TestResult.java:109）。junit.framework的TestCase.run（TestCase.java:118）。junit.framework的TestSuite.runTest（TestSuite.java:208）。位于sun.reflect的TestSuite.run（TestSuite.java:203）。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）。java.lang.reflect上的DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）。org.apache.maven.surefire.junit上的Method.invoke（Method.java:585）。org.apache.maven.surefire.suite上的JUnitTestSet.execute（JUnitTestSet.java:213）。org.apache.maven.surefire.suite的AbstractDirectoryTestSuite.executeTestSet（AbstractDirectoryTestSuite.java:140）。org.apache.maven.surefire的AbstractDirectoryTestSuite.execute（AbstractDirectoryTestSuite.java:127）。Surefire.run（Surefire.java:177）位于sun.reflect。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）。java.lang.reflect上的DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）。org.apache.maven.surefire.booter上的Method.invoke（Method.java:585）。org.apache.maven.surefire.booter上的SurefireBooter.runSuitesInProcess（SurefireBooter.java:338）。SurefireBooter.main（SurefireBooter.java:997）</p>

  <!-- .............................................................. -->

  <h2><a name="event_logger"></a>事件记录</h2>

  <p>EventLogger类提供了一种用于记录应用程序中发生的事件的简单机制。尽管EventLogger可用作启动应由审核日志记录系统处理的事件的方式，但它并未实现审核日志记录系统所需的任何功能，例如保证交付。</p>

  <p>在典型的Web应用程序中使用EventLogger的推荐方法是用与请求的整个寿命相关的数据（例如用户的ID，用户的IP地址，产品名称等）填充SLF4J MDC。这可以轻松实现。可以在Servlet过滤器中完成，在该过滤器中，也可以在请求结束时清除MDC。当需要记录的事件发生时，应创建并填充EventData对象。然后调用EventLogger.logEvent（data），其中data是对EventData对象的引用。</p>

  <pre class="prettyprint source">import org.slf4j.MDC;
import org.apache.commons.lang.time.DateUtils;

import javax.servlet.Filter;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.FilterChain;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.TimeZone;

public class RequestFilter implements Filter
{
  private FilterConfig filterConfig;
  private static String TZ_NAME = "timezoneOffset";

  public void init(FilterConfig filterConfig) throws ServletException {
    this.filterConfig = filterConfig;
  }

  /**
   * Sample filter that populates the MDC on every request.
   */
  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,
                       FilterChain filterChain) throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest)servletRequest;
    HttpServletResponse response = (HttpServletResponse)servletResponse;
    MDC.put("ipAddress", request.getRemoteAddr());
    HttpSession session = request.getSession(false);
    TimeZone timeZone = null;
    if (session != null) {
      // Something should set this after authentication completes
      String loginId = (String)session.getAttribute("LoginId");
      if (loginId != null) {
        MDC.put("loginId", loginId);
      }
      // This assumes there is some javascript on the user's page to create the cookie.
      if (session.getAttribute(TZ_NAME) == null) {
        if (request.getCookies() != null) {
          for (Cookie cookie : request.getCookies()) {
            if (TZ_NAME.equals(cookie.getName())) {
              int tzOffsetMinutes = Integer.parseInt(cookie.getValue());
              timeZone = TimeZone.getTimeZone("GMT");
              timeZone.setRawOffset((int)(tzOffsetMinutes * DateUtils.MILLIS_PER_MINUTE));
              request.getSession().setAttribute(TZ_NAME, tzOffsetMinutes);
              cookie.setMaxAge(0);
              response.addCookie(cookie);
            }
          }
        }
      }
    }
    MDC.put("hostname", servletRequest.getServerName());
    MDC.put("productName", filterConfig.getInitParameter("ProductName"));
    MDC.put("locale", servletRequest.getLocale().getDisplayName());
    if (timeZone == null) {
      timeZone = TimeZone.getDefault();
    }
    MDC.put("timezone", timeZone.getDisplayName());
    filterChain.doFilter(servletRequest, servletResponse);
    MDC.clear();
  }

  public void destroy() {
  }
} </pre>
 
  <p>使用EventLogger的示例类。</p>
  <pre class="prettyprint source">import org.slf4j.ext.EventData;
import org.slf4j.ext.EventLogger;

import java.util.Date;
import java.util.UUID;

public class MyApp {

  public String doFundsTransfer(Account toAccount, Account fromAccount, long amount) {
    toAccount.deposit(amount);
    fromAccount.withdraw(amount);
    EventData data = new EventData();
    data.setEventDateTime(new Date());
    data.setEventType("transfer");
    String confirm = UUID.randomUUID().toString();
    data.setEventId(confirm);
    data.put("toAccount", toAccount);
    data.put("fromAccount", fromAccount);
    data.put("amount", amount);
    EventLogger.logEvent(data);
    return confirm;
  }
}  </pre>
 
  <p>EventLogger类使用名为“ EventLogger”的记录器。EventLogger使用INFO的日志记录级别。下面显示了使用Logback的配置。</p>
  <pre class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;Pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/Pattern&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;appender name="events" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;Pattern&gt;%d{HH:mm:ss.SSS} %X - %msg%n&lt;/Pattern&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;logger name="EventLogger" additivity="false"&gt;
    &lt;level value="INFO"/&gt;
    &lt;appender appender-ref="events"/&gt;
  &lt;/logger&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;

&lt;/configuration&gt;  </pre>

  <!-- .............................................................. -->

  <h2><a name="javaagent"></a>使用Java代理添加日志记录</h2>

  <p><b>注意：测试版发布，而不是生产质量</b>  </p>

  <p>不耐烦的快速入门：</p>

  <ol>
    <li>使用Java 5或更高版本。</li>
    <li>下载slf4j-ext-2.0.0-alpha0.jar和javassist.jar，并将它们放在同一目录中。</li>
    <li>确保使用slf4j-api-2.0.0-alpha0.jar和合适的后端正确配置了您的应用程序。</li>

    <li>代替“ java ...”，请使用“ java --javaagent：PATH / slf4j-ext-2.0.0-alpha0.jar = time，verbose，level = info ...”<br>（将PATH替换为jar的路径）</li>
    <li>而已！</li>
  </ol>

  <p>在某些应用程序中，日志记录用于跟踪应用程序的实际执行，而不是记录偶然事件。一种方法是使用<a href="#extended_logger">扩展的记录器</a>适当地添加语句，而另一种方法是使用修改编译后的字节码的工具来添加这些语句！存在许多种，并且slf4j-ext中包含的一种并不打算与之竞争，而只是提供一种从给定应用程序获取非常基本的跟踪信息的快速方法。
  </p>

  <p>Java 5添加了Java Instrumentation机制，该机制允许您提供“ Java代理”，该代理可以在加载类时检查和修改类的字节码。这允许原始类文件保持不变，并且对字节码进行的转换取决于启动时的需求。
  </p>

  <p>举一个著名的“ Hello World”示例：</p>

  <pre class="prettyprint source">public class HelloWorld {
  public static void main(String args[]) {
    System.out.println("Hello World");
  }
}</pre>

  <p>典型的转换类似于：（省略了导入）</p>

  <pre class="prettyprint source">public class LoggingHelloWorld {
  final static Logger _log = LoggerFactory.getLogger(LoggingHelloWorld.class.getName());

  public static void main(String args[]) {
    if (_log.isInfoEnabled()) {
      _log.info("> main(args=" + Arrays.asList(args) + ")");
    }
    System.out.println("Hello World");
    if (_log.isInfoEnabled()) {
      _log.info("&lt; main()");
    }
  }
}</pre>

  <p>当类似于“ java LoggingHelloWorld 1 2 3 4”运行时，它会产生以下结果：</p>

  <p class="source">1 [main] INFO LoggingHelloWorld-> main（args = [1、2、3、4]）Hello World 1 [main] INFO LoggingHelloWorld-<main（）</p>

  <p>使用此命令可能会产生相同的效果（javassist.jar和slf4j-ext-2.0.0-alpha0.jar的相对路径为../jars）：</p>

  <p class="source">java -javaagent：../ jars / slf4j-ext-2.0.0-alpha0.jar HelloWorld 1 2 3 4</p>

  <p></p>


  <h3>如何使用</h3>
  <p>javaagent可以采用一个或多个用逗号分隔的选项。当前支持以下选项：</p>

  <dl>
    <dt><b>等级</b> = X</dt>
    <dd>用于生成的日志语句的日志级别。X是“信息”，“调试”或“跟踪”之一。默认值为“ info”。</dd>
    
    <dt><b>时间</b></dt>
    <dd>在程序启动时，以及程序结束时，再打印出当前日期以及执行时间（以毫秒为单位）。</dd>
    
    <dt><b>冗长的</b></dt>
    <dd>在将类作为加载的一部分进行处理时打印出</dd>

    <dt><b>忽略</b> = X：Y：...</dt>
    <dd>（高级）提供不添加日志的类名的冒号分隔前缀的完整列表。默认列表是“ org / slf4j /：ch / qos / logback /：org / apache / log4j /”。这不能覆盖这样的事实：一个类必须能够访问slf4j-api类才能进行日志记录，因此，如果这些类对于给定类不可见，则不会进行检测。
    </dd>
  </dl>


    <p>某些类在使用“ object.toString（）”呈现时可能会出现异常，因此它们可能会在登录配置文件中被永久禁用。例如，Apache Jakarta commons lang包中的ToStringBuilder是最佳选择。对于logback，将此代码段添加到logback.xml：</p><pre>&lt;logger name="org.apache.commons.lang.builder" level="OFF" /&gt;</pre>
    <p></p>
    

  
  <p>注意：这些尚未最终确定，并且可能会更改。</p>

  <h3>jar文件的位置</h3>

  <p>javassist库用于实际的字节码操作，并且必须可用才能添加任何日志记录语句。 slf4j-ext-2.0.0-alpha0已配置为查找以下内容：</p>

  <ul>
    <li>“ javassist-3.4。GA.jar”相对于slf4j-ext-2.0.0-alpha0.jar，就像Maven已从存储库下载，而slf4j-ext-2.0.0-alpha0.jar都直接在Maven存储库中的“ -javaagent”-参数。</li>
    <li>“ javassist-3.4。GA.jar”与slf4j-ext位于同一目录中</li>
    <li>与slf4j-ext位于同一目录中的“ javassist.jar”</li>
  </ul>

  <p>如果代理未找到javassist库，则会显示一条警告消息，并且需要字节码转换的选项将不起作用。
  </p>


  <h3>杂项说明</h3>

  <ul>
    <li>在类加载器已经加载的任何类上，均不会调用Java代理。</li>
    <li>JVM可能会悄悄吞下通常会打印的Java代理中的异常。</li>
    <li>javaagent仅记录到System.err。</li>
    <li>logger变量的名称是固定的（固定为不太可能使用的值），因此，如果已经使用该名称，则会发生故障。应该更改它以确定未使用的名称，并改用它。</li>
    <li>未检测到空方法（对接口的不正确检查）。他们应该是</li>
    
  </ul>

  <p>（该代理是<a href="http://today.java.net/pub/a/today/2008/04/24/add-logging-at-class-load-time-with-instrumentation.html">http://today.java.net/pub/a/today/2008/04/24/add-logging-at-class-load-time-</a>中描述的java.util.logging版本的改编版<a href="http://today.java.net/pub/a/today/2008/04/24/add-logging-at-class-load-time-with-instrumentation.html">with-instrumentation.html</a> ）</p>

  <script  src="templates/footer.js" type="text/javascript"></script> 
</div>



</body></html>