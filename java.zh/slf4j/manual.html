<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>SLF4J手册</title>
    <link rel="stylesheet" type="text/css" href="css/site.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/prettify.css">
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='';</script>
    <script type="text/javascript" src="js/prettify.js"></script>
    <script type="text/javascript" src="js/jquery-min.js"></script>
    <script type="text/javascript" src="js/decorator.js"></script>
    <script type="text/javascript" src="templates/header.js"></script>
    <div id="left">
      <script type="text/javascript" src="templates/left.js"></script>
    </div>
    <div id="right">
      <script src="templates/right.js" type="text/javascript"></script>
    </div>

    <div id="content">


    <h2>SLF4J用户手册</h2>
    
    <p>Java的简单日志记录外观（SLF4J）可作为各种日志记录框架（如java.util.logging，logback和log4j）的简单外观或抽象。SLF4J允许最终用户在<em>部署</em>时插入所需的日志记录框架。请注意，启用SLF4J的库/应用程序意味着仅添加一个强制性依赖项，即<em>slf4j-api-2.0.0-alpha2-SNAPSHOT.jar</em> 。</p>

    <p><span class="label">从1.6.0开始，</span>如果在类路径上未找到绑定，则SLF4J将默认为无操作实现。
    </p>
      
    <p><span class="label">从1.7.0开始</span> <a href="apidocs/org/slf4j/Logger.html"><code>Logger</code></a>接口现在提供接受<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/varargs.html">varargs</a>而不是<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/varargs.html">varargs的</a>变体<code>Object[]</code> 。此更改意味着SLF4J需要JDK 1.5或更高版本。Java编译器在后台将方法中的varargs部分转换为<code>Object[]</code> 。因此，在1.7.x中，由编译器生成的Logger接口与1.6.x中的对应接口是无法区分的。因此，SLF4J版本1.7.x与SLF4J版本1.6.x完全100％兼容。
    </p>

    <p><span class="label">从1.7.5开始</span> ，记录器检索时间显着改善。考虑到改进的程度，强烈建议用户迁移到SLF4J 1.7.5或更高版本。
    </p>

    <p><span class="label">从1.7.9开始</span> <code>slf4j.detectLoggerNameMismatch</code>系统属性为true时，SLF4J可以自动<a href="codes.html#loggerNameMismatch">发现名称错误的记录器</a> 。
    </p>

    <p><span class="label">从2.0.0</span>版本<span class="label">开始，</span> SLF4J API版本2.0.0需要Java 8，并引入了向后兼容的流畅日志记录API。向后兼容意味着我们无需更改现有的日志记录框架即可使用户从<a href="#fluent">流畅的日志记录API中</a>受益。</p>

    <h3 class="doAnchor" name="hello_world">你好，世界</h3>

    <p>按照编程传统，这里有一个示例，说明使用SLF4J输出“ Hello world”的最简单方法。首先获取名称为“ HelloWorld”的记录器。该记录器又用于记录消息“ Hello World”。
    </p>

<pre class="prettyprint source">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info("Hello World");
  }
}</pre>

     <p>要运行此示例，您首先需要<a href="download.html">下载slf4j发行版</a> ，然后将其解压缩。完成后，将文件<em>slf4j-api-1.7.28.jar添加</em>到您的类路径中。</p>

     <p>编译并运行<em>HelloWorld</em>将导致在控制台上打印以下输出。</p>

<pre>SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</pre>

     <p>因为在您的类路径上找不到slf4j绑定，所以将打印此警告。</p>

     <p>将<a href="#swapping">绑定</a>添加到类路径后，警告将消失。假设您添加<em>slf4j-simple-1.7.28.jar，</em>以便您的类路径包含：</p>
     
     <ul>
       <li>slf4j-api-1.7.28.jar</li>
       <li>slf4j-simple-1.7.28.jar</li>
     </ul>

     <p>现在，编译并运行<em>HelloWorld</em>会在控制台上产生以下输出。</p>

     <pre class="output">0 [main] INFO HelloWorld - Hello World</pre>
      
     <h3 class="doAnchor" name="typical_usage">典型用法</h3>
 
     <p>下面的示例代码说明了SLF4J的典型使用模式。请注意在第15行上使用{}-占位符。看到问题<a href="faq.html#logging_performance">“最快的记录方式是什么？有关更多详细信息，请参见FAQ中的“”</a> 。
     </p>
     
     <p></p>

      <pre class="prettyprint source"> 1: <b>import org.slf4j.Logger;</b>
 2: <b>import org.slf4j.LoggerFactory;</b>
 3: 
 4: public class Wombat {
 5:  
 6:   <b>final Logger logger = LoggerFactory.getLogger(Wombat.class);</b>
 7:   Integer t;
 8:   Integer oldT;
 9:
10:   public void setTemperature(Integer temperature) {
11:    
12:     oldT = t;        
13:     t = temperature;
14:
15:     <b>logger.debug("Temperature set to {}. Old temperature was {}.", t, oldT);</b>
16:
17:     if(temperature.intValue() > 50) {
18:       <b>logger.info("Temperature has risen above 50 degrees.");</b>
19:     }
20:   }
21: } </pre>
      

      <h3 class="doAnchor" name="fluent">流利的日志API</h3>

      <p><span class="label">从2.0.0</span>版本<span class="label">开始，</span> SLF4J API版本2.0.0需要Java 8，并引入了向后兼容的流畅日志记录API。向后兼容意味着我们无需更改现有的日志记录框架即可使用户从<a href="#fluent">流畅的日志记录API中</a>受益。</p>

      <p>想法是使用<a href="apidocs/org/slf4j/spi/LoggingEventBuilder.html">LoggingEventBuilder逐段</a>构建日志事件，并在事件完全构建后进行日志记录。的<code>atTrace()</code> ， <code>atDebug()</code> ， <code>atInfo()</code> ， <code>atWarn()</code>和<code>atError()</code>方法，是所有<code>org.slf4j.Logger</code>接口，返回一个实例<a href="apidocs/org/slf4j/spi/LoggingEventBuilder.html"><code>LoggingEventBuilder</code></a> 。对于禁用的日志级别，返回<code>LoggingEventBuilder</code>实例不执行任何操作，因此保留了传统日志记录界面的纳秒级性能。</p>


      <p>以下是一些用法示例：</p>

      <p>该声明</p> 
      <pre class="prettyprint source">logger.atInfo().log("Hello world");</pre>

      <p>等效于：</p>

      <pre class="prettyprint source">logger.info("Hello world.");</pre>

      
      <p>以下日志语句在其输出中等效（对于默认实现）：</p>
     
      <pre class="prettyprint source">
        int newT = 15;
        int oldT = 16;

        // using traditional API
        logger.debug("Temperature set to {}. Old temperature was {}.", newT, oldT);

        // using fluent API, add arguments one by one and then log message
        logger.<b>atDebug()</b>.addArgument(newT).addArgument(oldT).log("Temperature set to {}. Old temperature was {}.");

        // using fluent API, log message with arguments
        logger.<b>atDebug()</b>.log("Temperature set to {}. Old temperature was {}.", newT, oldT);

        // using fluent API, add one argument and then log message providing one more argument
        logger.<b>atDebug()</b>.addArgument(newT).log("Temperature set to {}. Old temperature was {}.", oldT);

        // using fluent API, add one argument with a Supplier and then log message with one more argument.
        // Assume the method t16() returns 16.
        logger.<b>atDebug()</b>.addArgument(() -> t16()).log(msg, "Temperature set to {}. Old temperature was {}.", oldT);
      </pre>

      <p>流利的日志记录API允许将许多不同类型的数据规范为<code>org.slf4j.Logger</code>且方法中的方法组合没有爆炸式增长<code>Logger</code>接口。</p>

      <p>现在可以传递多个<a href="apidocs/org/slf4j/Marker.html">Marker</a> ，传递带有<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier的</a>参数或传递多个键值对。键值对与可以自动解释它们的日志数据分析器结合使用时特别有用。</p>

      <p>以下日志语句是等效的：</p>
      
      <pre class="prettyprint source">
        int newT = 15;
        int oldT = 16;

        // using classical API
        logger.debug("oldT={} newT={} Temperature changed.", newT, oldT);

        // using fluent API
        logger.atDebug().<b>addKeyValue("oldT", oldT)</b>.addKeyValue("newT", newT).log("Temperature changed.");          
      </pre>

      <p>API的键值对变体将键值对存储为单独的对象。默认实现为<code>org.slf4j.Logger</code>类将键值对添加到消息的<em>前缀</em> 。日志后端可以自由地根据需要自定义输出。</p>

      
      <h3 class="doAnchor" name="swapping">在部署时与日志框架绑定</h3>

      <p>如前所述，SLF4J支持各种日志记录框架。SLF4J发行版本附带了几个jar文件，这些文件称为“ SLF4J绑定”，每个绑定对应于一个受支持的框架。</p>

      <dl>

        <dt><em>slf4j-log4j12-1.7.28.jar</em>
        </dt>
        <dd>绑定<a href="http://logging.apache.org/log4j/1.2/index.html">log4j 1.2版</a> （一种广泛使用的日志记录框架）。您还需要将<em>log4j.jar</em>放在类路径上。<p></p></dd>

        <dt><em>slf4j-jdk14-1.7.28.jar</em> </dt>
        <dd>java.util.logging的绑定，也称为JDK 1.4日志记录<p></p></dd>

        <dt><em>slf4j-nop-1.7.28.jar</em></dt>
        <dd>绑定为<a href="http://www.slf4j.org/api/org/slf4j/helpers/NOPLogger.html">NOP</a> ，静默丢弃所有日志记录。<p></p></dd>
        
        <dt><em>slf4j-simple-1.7.28.jar</em></dt>
        <dd>绑定用于<a href="http://www.slf4j.org/apidocs/org/slf4j/impl/SimpleLogger.html">简单</a>实现，它将所有事件输出到System.err。仅打印INFO或更高级别的消息。在小型应用程序的上下文中，此绑定可能很有用。<p></p></dd>
        
        <dt><em>slf4j-jcl-1.7.28.jar</em></dt>
        
        <dd><a href="http://commons.apache.org/logging/">雅加达共同伐木的</a>绑定。该绑定会将所有SLF4J日志记录委派给JCL。<p></p>
        </dd>     
        
        <dt><em>logback-classic-1.2.3.jar（需要logback-core-1.2.3.jar）</em></dt>

        <dd><span class="label notice">本机实现</span> SLF4J项目外部还有SLF4J绑定，例如，以本机方式实现SLF4J的<a href="http://logback.qos.ch/">logback</a> 。Logback的<a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/Logger.html"><code>ch.qos.logback.classic.Logger</code></a>类是SLF4J的直接实现<a href="http://www.slf4j.org/apidocs/org/slf4j/Logger.html"><code>org.slf4j.Logger</code></a>接口。因此，结合使用SLF4J和logback会涉及严格的零内存和计算开销。

        </dd>
      </dl>

      <p>
      </p> 	 
	 

      <p>要切换日志记录框架，只需在类路径上替换slf4j绑定即可。例如，要从java.util.logging切换到log4j，只需将slf4j-jdk14-1.7.28.jar替换为slf4j-log4j12-1.7.28.jar。
      </p>

      <p>SLF4J不依赖任何特殊类的装载机。实际上，每个SLF4J绑定<em>在编译时都</em>进行了硬连线<em>，</em>以使用一个且仅一个特定的日志记录框架。例如，slf4j-log4j12-1.7.28.jar绑定在编译时绑定为使用log4j。在代码中，除了<em>slf4j-api-1.7.28.jar之外</em> ，您还只需将选择的<b>一个</b>绑定<b>和一个</b>绑定绑定到适当的类路径位置即可。在类路径上不要放置多个绑定。这是一般想法的图形化说明。
      </p>

      <p><a href="images/concrete-bindings.png">
      <img border="1" src="images/concrete-bindings.png" alt="点击放大" width="800">
      </a></p>

      <p>SLF4J接口及其各种适配器非常简单。大多数熟悉Java语言的开发人员应该能够在不到一小时的时间内阅读并完全理解代码。无需了解类加载器，因为SLF4J不会使用它，也不会直接访问任何类加载器。因此，使用Jakarta Commons Logging（JCL）观察到的SLF4J不会遇到类加载器问题或内存泄漏。
      </p>

      <p>鉴于SLF4J接口及其部署模型的简单性，新日志记录框架的开发人员应该发现编写SLF4J绑定非常容易。
      </p>
     
      <h3 class="doAnchor" name="libraries">图书馆</h3>

      <p>广泛分发的组件和库的作者可以针对SLF4J接口进行编码，以避免在其最终用户上强加日志记录框架。因此，最终用户可以在部署时通过在类路径上插入相应的slf4j绑定来选择所需的日志记录框架，稍后可以通过在类路径上将现有绑定替换为另一个绑定并重新启动应用程序来进行更改。事实证明，这种方法非常简单且非常可靠。
      </p>
        
      <p><b>从SLF4J版本1.6.0开始</b> ，如果在类路径上未找到绑定，则slf4j-api将默认为无操作实现，丢弃所有日志请求。因此，与其抛出一个<code>NoClassDefFoundError</code>因为<code>org.slf4j.impl.StaticLoggerBinder</code>缺少类，SLF4J 1.6.0版和更高版本将发出一条有关缺少绑定的警告消息，并继续丢弃所有日志请求，而不会进一步发出抗议。例如，让Wombat成为依赖于SLF4J进行日志记录的一些与生物学相关的框架。为了避免将日志记录框架强加于最终用户，Wombat的发行版包括<em>slf4j-api.jar</em>但没有绑定。即使在类路径上没有任何SLF4J绑定，Wombat的发行版仍然可以直接使用，而无需最终用户从SLF4J的网站下载绑定。仅当最终用户决定启用日志记录时，她才需要安装与她选择的日志记录框架相对应的SLF4J绑定。
      </p>

      <p><span class="label">基本规则</span> <b>诸如库或框架之类的嵌入式组件不应声明对任何SLF4J绑定的依赖关系，而只能依赖slf4j-api</b> 。当库声明对特定绑定的可传递依赖项时，该绑定将强加于最终用户，而否定了SLF4J的目的。请注意，声明对绑定的非传递性依赖关系（例如，用于测试）不会影响最终用户。</p>

      <p>FAQ中还讨论了嵌入式组件中SLF4J的用法，以及与<a href="faq.html#configure_logging">日志记录配置</a> ， <a href="faq.html#optional_dependency">依赖关系减少</a>和<a href="faq.html#optional_dependency">测试的关系</a> 。</p>

      <h3 class="doAnchor" name="projectDep">声明项目相关性以进行日志记录</h3>

      <p>给定Maven的传递依赖关系规则，对于“常规”项目（不是库或框架），声明日志记录依赖关系可以通过单个依赖关系声明来完成。
      </p>

      <p><span class="label notice">logback-classic</span>如果希望将logback-classic用作基础日志记录框架，则需要做的就是在<em>pom.xml</em>文件中声明“ ch.qos.logback：logback-classic”作为依赖项，如下所示。除了<em>logback-classic-1.2.3.jar之外</em> ，这还将把<em>slf4j-api-1.7.28.jar</em>以及<em>logback-core-1.2.3.jar</em>放入您的项目中。请注意，明确声明对<em>logback-core-1.2.3</em>或<em>slf4j-api-1.7.28.jar</em>的依赖关系并没有错，并且可能需要借助Maven的“最近定义”依赖关系中介规则来强加正确版本的工件。 。
      </p>

<pre class="prettyprint source">&lt;dependency> 
  &lt;groupId>ch.qos.logback&lt;/groupId>
  &lt;artifactId>logback-classic&lt;/artifactId>
  &lt;version>1.2.3&lt;/version>
&lt;/dependency></pre>

     <p></p>

      <p><span class="label notice">log4j</span>如果希望将log4j用作基础日志记录框架，则需要做的就是在<em>pom.xml</em>文件中将“ org.slf4j：slf4j-log4j12”声明为依赖项，如下所示。除了<em>slf4j-log4j12-1.7.28.jar之外</em> ，这还将把<em>slf4j-api-1.7.28.jar</em>以及<em>log4j-1.2.17.jar拉</em>入您的项目。请注意，显式声明对<em>log4j-1.2.17.jar</em>或<em>slf4j-api-1.7.28.jar</em>的依赖关系不是错误的，并且可能需要借助Maven的“最近定义”依赖关系中介规则来强加上述工件的正确版本。 。</p>

<pre class="prettyprint source">&lt;dependency> 
  &lt;groupId>org.slf4j&lt;/groupId>
  &lt;artifactId>slf4j-log4j12&lt;/artifactId>
  &lt;version>1.7.28&lt;/version>
&lt;/dependency></pre>

     <p></p>

      <p><span class="label notice">java.util.logging</span>如果希望将java.util.logging用作基础日志记录框架，则需要做的就是在<em>pom.xml</em>文件中将“ org.slf4j：slf4j-jdk14”声明为依赖项，如下所示。除了<em>slf4j-jdk14-1.7.28.jar之外</em> ，这还将把<em>slf4j-api-1.7.28.jar</em>拉入您的项目。请注意，显式声明对<em>slf4j-api-1.7.28.jar</em>的依赖关系是正确的，并且可能需要借助Maven的“最近定义”依赖关系中介规则来强加上述工件的正确版本。</p>

<pre class="prettyprint source">&lt;dependency> 
  &lt;groupId>org.slf4j&lt;/groupId>
  &lt;artifactId>slf4j-jdk14&lt;/artifactId>
  &lt;version>1.7.28&lt;/version>
&lt;/dependency></pre>


   
      <h3 class="doAnchor" name="compatibility">二进制兼容性</h3>

      <p>SLF4J绑定指定了诸如<em>slf4j-jdk14.jar</em>或<em>slf4j-log4j12.jar之类的工件，</em>用于<em>将</em> slf4j <em>绑定</em>至基础日志框架，例如java.util.logging和log4j。
      </p>

      <p class="highlight">从客户端的角度来看，slf4j-api的所有版本都是兼容的。对于任何N和M，使用slf4j-api-N.jar编译的客户端代码将与slf4j-api-M.jar一起完美运行。您只需要确保绑定的版本与slf4j-api.jar的版本匹配即可。您不必担心项目中给定依赖项使用的slf4j-api.jar版本。</p>
      

      <p>混合使用不同版本的<em>slf4j-api.jar</em>和SLF4J绑定可能会导致问题。例如，如果您使用的是slf4j-api-1.7.28.jar，则还应该使用slf4j-simple-1.7.28.jar，而不能使用slf4j-simple-1.5.5.jar。</p>

     
      <p>但是，从客户端的角度来看，slf4j-api的所有版本都是兼容的。用<em>SLF4J-API N.jar</em>编译将与<em>SLF4J-API M.jar</em>运行完全正常的任何N和M你的客户端代码只需要确保的是，SLF4J-api.jar中的您结合匹配的版本。您不必担心项目中给定依赖项使用的slf4j-api.jar版本。您始终可以使用任何版本的<em>slf4j-api.jar</em> ，并且只要<em>slf4j-api.jar</em>的版本及其绑定匹配，就可以了。
      </p>

      <p>在初始化时，如果SLF4J怀疑可能存在slf4j-api与绑定版本不匹配的问题，它将发出有关可疑不匹配的警告。
      </p>


      <h3 class="doAnchor" name="consolidate">通过SLF4J合并日志记录</h3>

      <p>通常，给定的项目将依赖于依赖于除SLF4J之外的日志记录API的各种组件。通常会根据JCL，java.util.logging，log4j和SLF4J的组合找到项目。然后，希望通过单个通道合并日志记录。SLF4J通过为JCL，java.util.logging和log4j提供桥接模块来满足这种常见用例。有关更多详细信息，请参阅“ <a href="legacy.html"><b>桥接旧版API</b></a> ”页面。</p>

      <h3 class="doAnchor" name="mdc">映射诊断上下文（MDC）支持</h3>

      <p>“映射的诊断上下文”实质上是由日志记录框架维护的映射，其中应用程序代码提供键值对，然后可以由日志记录框架将其插入日志消息中。MDC数据在筛选消息或触发某些操作方面也可能非常有帮助。</p>

      <p>SLF4J支持MDC或映射的诊断上下文。如果基础日志框架提供MDC功能，则SLF4J将委派给基础框架的MDC。请注意，此时，只有log4j和logback提供MDC功能。如果基础框架不提供MDC（例如java.util.logging），则SLF4J仍将存储MDC数据，但是其中的信息将需要由自定义用户代码检索。</p>

      <p>因此，作为SLF4J用户，您可以在存在log4j或logback的情况下利用MDC信息，但无需将这些日志框架强制依赖于用户。
      </p>

      <p>有关MDC的更多信息，请参阅Logback手册中<a href="http://logback.qos.ch/manual/mdc.html">有关MDC</a>的<a href="http://logback.qos.ch/manual/mdc.html">章节</a> 。
      </p>

    
      
      <h3 class="doAnchor" name="summary">执行摘要</h3>
      
      <table class="bodyTable striped" cellspacing="4" cellpadding="4">
        <tbody><tr>
          <th align="left">优点</th>
          <th align="left">描述</th>
        </tr>
        
        <tr>

          <td>在部署时选择您的日志记录框架</td>

          <td>通过在类路径上插入适当的jar文件（绑定），可以在部署时插入所需的日志记录框架。
          </td>
        </tr>


        <tr>
          <td>快速运行</td>

          <td>由于JVM加载类的方式，框架绑定将在很早的时候自动进行验证。如果SLF4J在类路径上找不到绑定，它将发出一条警告消息，并且默认为无操作实现。
          </td>
        </tr>

       
        <tr>
          <td>流行日志框架的绑定</td>
          
          <td>SLF4J支持流行的日志记录框架，即log4j，java.util.logging，简单日志记录和NOP。 <a href="http://logback.qos.ch">登录</a>项目本机支持SLF4J。</td>
          
        </tr>
        
        <tr>
          <td>桥接旧式日志记录API</td>
          
          <td>
            <p>在SLF4J上实施JCL，即<em>jcl-over-slf4j.jar</em> ，将使您的项目可以零碎地迁移到SLF4J，而不会破坏与使用JCL的现有软件的兼容性。类似地，log4j-over-slf4j.jar和jul-to-slf4j模块将允许您将log4j和java.util.logging调用分别重定向到SLF4J。有关更多详细信息，请参见<a href="legacy.html">桥接传统API</a>上的页面。
            </p>
          </td>
        </tr>
        
        <tr>
          <td>迁移您的源代码</td>
          <td><a href="migrator.html">slf4j-migrator</a>实用程序可以帮助您迁移源以使用SLF4J。</td>
        </tr>
        
        
        
        <tr>
          <td>支持参数化日志消息</td>
          
          <td>所有SLF4J绑定都支持参数化日志消息，从而显着<a href="faq.html#logging_performance">改善了性能</a>结果。</td>
        </tr>
        
         
  </tbody></table>

  <script src="templates/footer.js" type="text/javascript"></script>

</div>


</body></html>