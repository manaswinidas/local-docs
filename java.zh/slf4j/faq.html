<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>SLF4J常见问题</title>
    <link rel="stylesheet" type="text/css" href="css/site.css" media="screen">   
    <link rel="stylesheet" type="text/css" href="css/prettify.css">
  </head>
  <body  onload="prettyPrint(); decorate();">

  <script type="text/javascript" src="js/prettify.js"></script>
	<script type="text/javascript">prefix='';</script>

  <script type="text/javascript" src="templates/header.js"></script>
  <script type="text/javascript" src="js/jquery-min.js"></script>
  <script type="text/javascript" src="js/decorator.js"></script>

  <div id="left">
    <script src="templates/left.js" type="text/javascript"></script>
  </div>
  <div id="right">
     <script src="templates/right.js" type="text/javascript"></script>
  </div>

  <div id="content">

  <h2><a name="top">关于SLF4J的常见问题</a></h2>

  <p><b>共性</b></p>
  
  <ol type="1">
    <li><a href="#what_is">什么是SLF4J？</a></li>
    
    <li><a href="#when">什么时候应使用SLF4J？</a></li>
    
    <li><a href="#yet_another_facade">SLF4J还是另一个日志记录门面吗？</a></li>
    
    <li><a href="#why_new_project">如果SLF4J修复了JCL，那么为什么不使用JCL进行修复而不是创建新项目呢？
    </a>
    </li>
    
    <li><a href="#need_to_recompile">使用SLF4J时，是否必须重新编译我的应用程序才能切换到其他日志系统？
    </a>
    </li>
    
    <li><a href="#requirements">SLF4J的要求是什么？</a></li>

    <li><a href="#changesInVersion18">SLF4J 1.8.0版中有哪些更改？</a></li>
    
    <li><a href="#compatibility">SLF4J版本向后兼容吗？</a></li>

    <li><a href="#IllegalAccessError">我正进入（状态<code>IllegalAccessError</code>使用SLF4J时的异常。这是为什么？</a></li>


    <li>
      <a href="#license">为什么SLF4J在X11类型许可证下而不是在Apache软件许可证下获得许可？
      </a>
    </li>
    
    <li>
      <a href="#where_is_binding">在哪里可以获得特定的SLF4J绑定？
      </a>
    </li>
    
    <li>
      <a href="#configure_logging">我的图书馆应该尝试配置日志记录吗？
      </a>
    </li>
    
    <li>
      <a href="#optional_dependency">为了减少软件依赖项的数量，我们希望使SLF4J成为可选的依赖项。这是一个好主意吗？
      </a>
    </li>

    <li>
      <a href="#maven2">Maven传递依赖项如何？
      </a>
    </li>
    
    <li>
      <a href="#excludingJCL">如何排除Commons-logging作为Maven依赖项？
      </a>
    </li>
  </ol>
  
  
  <b>关于SLF4J API</b>
  
  <ol type="1">
    
    <li>
      <a href="#string_or_object">为什么Logger界面中的打印方法不接受Object类型的消息，而仅接受String类型的消息？
      </a>
    </li>
    
    <li>
      <a href="#exception_message">是否可以在没有伴随消息的情况下记录异常？
      </a>
    </li>
    
    
    <li>
      <a href="#logging_performance">（不）记录的最快方法是什么？
      </a>
    </li>
    
    <li>
      <a href="#string_contents">如何记录单个（可能是复杂的）对象的字符串内容？
      </a>
    </li>
    
    
    <li><a href="#fatal">为什么不<code>org.slf4j.Logger</code>界面是否具有致命级别的方法？</a></li>
    
    <li><a href="#trace">为什么仅在SLF4J 1.4.0版中引入了TRACE级别？</a></li>
    
    <li><a href="#i18n">SLF4J日志记录API是否支持I18N（国际化）？</a></li>


    <li><a href="#noLoggerFactory">是否可以检索记录器而无需通过静态方法<code>LoggerFactory</code> ？</a></li>

    <li><a href="#paramException">在存在异常/可抛出异常的情况下，是否可以参数化日志记录语句？</a></li>
    
  </ol>
  
  
  
  <b>实施SLF4J API</b>
  
  <ol type="1">
    
    <li><a href="#slf4j_compatible">如何使我的日志记录框架SLF4J兼容？</a></li>
    
    <li><a href="#marker_interface">我的日志记录系统如何增加对<code>Marker</code>接口？</a></li>
    
    <li><a href="#version_checks">SLF4J的版本检查机制如何工作？</a></li>
    
    
  </ol>
  
  
  <b>有关日志记录的一般问题</b>
  
  
  <ol type="1">
    
    <li><a href="#declared_static">是否应将类的Logger成员声明为静态成员？</a></li>
    
    
    <li><a href="#declaration_pattern">是否有推荐的成语在课堂上宣布记录员？</a></li>
    
  </ol>
  
  <h2>共性</h2>
  
  <dl>
    <dt class="doAnchor" name="what_is">什么是SLF4J？</dt>
    <dd>
      <p>SLF4J是用于日志记录系统的简单外观，允许最终用户在部署时插入所需的日志记录系统。
      </p>      
    </dd>
    
    <dt class="doAnchor" name="when">什么时候应使用SLF4J？</dt>
    
    <dd>
      <p>简而言之，库和其他嵌入式组件应考虑SLF4J的日志记录需求，因为库无法负担将其日志记录框架的选择强加于最终用户。另一方面，独立应用程序使用SLF4J不一定有意义。独立应用程序可以直接调用其选择的日志记录框架。对于logback，这个问题是没有意义的，因为logback通过SLF4J公开了它的logger API。</p>
      
      <p>SLF4J只是一个外观，意味着它没有提供完整的日志记录解决方案。无法使用SLF4J执行诸如配置附加程序或设置日志记录级别的操作。因此，在某个时间点，任何非平凡的应用程序都将需要直接调用基础日志系统。换句话说，对于独立应用程序，不可能完全独立于API基础日志系统。尽管如此，SLF4J将这种依赖性的影响降低到近乎无痛的水平。
      </p>
      
      <p>假设您的CRM应用程序使用log4j进行日志记录。但是，您的重要客户之一要求通过JDK 1.4日志记录执行日志记录。如果您的应用程序中有成千上万的直接log4j调用，那么迁移到JDK 1.4将会是一个相对冗长且容易出错的过程。更糟糕的是，您可能需要维护两个版本的CRM软件。如果您一直在调用SLF4J API而不是log4j，则可以通过用一个jar文件替换另一个jar文件在几分钟内完成迁移。
      </p> 
      
      <p>SLF4J允许组件开发人员将日志记录系统的选择推迟到最终用户手中，但最终需要做出选择。
      </p>
      
      
      
    </dd>
    
    <dt class="doAnchor" name="yet_another_facade">SLF4J还是另一个伐木门面吗？</dt>
    
    <dd>
      <p>SLF4J在概念上与Jakarta Commons Logging（JCL）非常相似。因此，可以将其视为另一个伐木外观。但是，SLF4J的设计要简单得多，并且可以说更坚固。简而言之，SLF4J避免了困扰JCL的类加载器问题。</p>
      
      
      
    </dd>
    <dt class="doAnchor" name="why_new_project">如果SLF4J修复了JCL，那么为什么不使用JCL进行修复而不是创建新项目呢？
    </dt>
    
    <dd>
      <p>这个问题问得好。首先，SLF4J静态绑定方法非常简单，甚至是可笑的。要说服开发人员这种方法的有效性并不容易。只有在SLF4J发布并开始被接受之后，它才能在相关社区中受到尊重。
      </p>
      
      <p>其次，SLF4J提供了两个增强功能，这些增强功能往往被低估了。参数化日志消息以务实的方式解决了与日志记录性能相关的重要问题。标记对象，这些对象受<code>org.slf4j.Logger</code>界面，为采用高级日志记录系统铺平了道路，并且仍然可以在需要时切换回更传统的日志记录系统。
      </p>
      
      
    </dd>
    
    <dt class="doAnchor" name="need_to_recompile">使用SLF4J时，是否必须重新编译我的应用程序才能切换到其他日志系统？
    </dt>
    
    <dd>
      <p>不，您不需要重新编译您的应用程序。通过删除以前的SLF4J绑定并将其替换为您选择的绑定，可以切换到其他日志系统。
      </p>
      
      <p>例如，如果您使用的是NOP实现，并且想要切换到log4j版本1.2，只需在类路径<em>上将slf4j-nop.jar</em>替换为<em>slf4j-log4j12.jar</em> ，但不要忘记添加log4j-1.2.x.jar也一样是否要切换到JDK 1.4日志记录？只需将<em>slf4j-log4j12.jar</em>替换为<em>slf4j-jdk14.jar</em> <em>即可</em> 。
      </p>
      
      
    </dd>

    <dt class="doAnchor" name="requirements">SLF4J的要求是什么？
    </dt>
    
    <dd>
      
      <p>从1.7.0版开始，SLF4J需要JDK 1.5或更高版本。较早的SLF4J版本，即SLF4J 1.4、1.5。和1.6，需要JDK 1.4。
      </p>
      
      <p> </p>
      
      <table class="bodyTable striped">
        <tbody><tr align="left">
          <th>捆绑</th>
          <th>要求</th>
        </tr>
        
        <tr>
          <td>slf4j-nop</td>
          <td>JDK 1.5</td>
        </tr>
        <tr>
          <td>slf4j-简单</td>
          <td>JDK 1.5</td>
        </tr>
        
        <tr>
          <td>slf4j-log4j12</td>
          <td align="left">JDK 1.5，以及使用中的log4j附加程序所需的任何其他库依赖项</td>
        </tr>
        <tr>
          <td>slf4j-jdk14</td>
          <td>JDK 1.5或更高版本</td>
        </tr>
        <tr>
          <td>经典的logback</td>
          <td>JDK 1.5或更高版本，以及使用中的logback附加程序所需的任何其他库依赖项</td>
        </tr>
        
      </tbody></table>
      
      
    </dd>

    <!-- ==================================================== -->
    <dt class="doAnchor" name="changesInVersion18">SLF4J 1.8.0版中有哪些更改？
    </dt>

    <dd>
      <p><span class="label notice">适用于2.x</span>请注意，2.0.x系列基于1.8.x系列，因此以下说明也适用于SLF4J2.x。</p>
      
      <p>1.8.x中没有面向客户端的API更改。对于大多数用户，只要还更新了日志记录提供程序，升级到版本1.8.x的操作应该是可替代的。
      </p>
      

      <p>在1.8.0版中，SLF4J已按照<a href="http://openjdk.java.net/projects/jigsaw/spec/">JPMS / Jigsaw</a>规范进行了模块化。而且，slf4j-api现在依靠<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>机制来找到其日志记录后端。早期版本依赖于静态绑定器机制，而slf4j-api版本1.8.x不支持Loger。更具体地说，在初始化<code>LoggerFactory</code>班级将不再搜索<code>StaticLoggerBinder</code>类在类路径上。</p>

  
      <p>现在不再是“绑定” <code>org.slf4j.LoggerFactory</code>搜索“提供者”。这些<em>附带</em>例如<em>slf4j-nop-1.8.x.jar</em> ， <em>slf4j-simple-1.8.x.jar</em>或<em>slf4j-jdk14-1.8.x.jar</em> 。
      </p>
      
      <p>下表描述了将各种slf4j-api和slf4j-simple版本放置在类路径上时的结果。请注意，下表类似地不仅适用于slf4j-simple，还适用于其他提供程序，例如slf4j-log4j12，logback-classic，slf4j-jul14等。
      </p>

   
      <table class="bodyTable" cellpadding="8">
        <tbody><tr class="striped">
          <th>slf4j-api版本</th>
          <th>slf4j-简单版本</th>
          <th>结果</th>
          <th>说明</th>
        </tr>
        <tr class="striped">
          
          <td>1.8.x</td>
          <td>1.8.x</td>
          <td>好</td>
          <td>slf4j-api和提供程序的版本相同</td>
        </tr>
        
        <tr class="striped">
          <td>1.7.x</td>
          <td>1.8.x</td>
          <td>找不到绑定警告消息</td>
          <td>1.8.x提供程序<b>不</b>充当1.7.x / 16.x可兼容的绑定</td>
        </tr>
        
        <tr class="striped">
          
          <td>1.8.x</td>
          <td>1.7.x</td>
          <td>找不到提供者警告消息</td>
          <td>slf4j-api 1.8.x将不再搜索<code>StaticLoggerBinding</code></td>
        </tr>
        
      </tbody></table>

      
    </dd>

    
    <!-- ==================================================== -->
    <!-- entry has order dependees -->

    <dt class="doAnchor" name="compatibility">SLF4J版本向后兼容吗？
    </dt>

    <dd>
      <p>从客户端的角度来看，SLF4J API向后兼容所有版本。这意味着您可以毫无问题地从SLF4J 1.0版升级到任何更高版本。对于任何版本N和任何版本<em>M</em> ，使用<em>slf4j-api-versionN.jar</em>编译的代码将与<em>slf4j-api-versionM.jar</em>一起使用。 <b>迄今为止，slf4j-api中的二进制兼容性从未被破坏。</b></p>

      <p>但是，尽管从客户端的角度来看SLF4J API非常稳定，但是SLF4J绑定（例如slf4j-simple.jar或slf4j-log4j12.jar）可能需要特定版本的slf4j-api。混合使用不同版本的slf4j构件可能会出现问题，强烈建议不要这样做。例如，如果您使用的是slf4j-api-1.5.6.jar，则还应该使用slf4j-simple-1.5.6.jar，而使用slf4j-simple-1.4.2.jar则无效。
      </p>        

      <p>在初始化时，如果SLF4J怀疑可能存在版本不匹配问题，则会发出有关所述不匹配的警告。
      </p>

      
    </dd>

    <!-- ==================================================== -->

    <dt class="doAnchor" name="IllegalAccessError">我正进入（状态<code>IllegalAccessError</code>使用SLF4J时的异常。这是为什么？
    </dt>

    <dd>

      <p>以下是例外情况详细信息。</p>

      <pre class="source">Exception in thread "main" java.lang.IllegalAccessError: tried to access field
org.slf4j.impl.StaticLoggerBinder.SINGLETON from class org.slf4j.LoggerFactory
   at org.slf4j.LoggerFactory.&lt;clinit>(LoggerFactory.java:60)</pre>

      <p>此错误是由的静态初始化程序引起的<code>LoggerFactory</code>试图直接访问的SINGLETON字段的类<code>org.slf4j.impl.StaticLoggerBinder</code> 。虽然在SLF4J 1.5.5和更早版本中允许这样做，但在1.5.6和更高版本中，SINGLETON字段已标记为私有访问。
      </p>


      <p>如果出现上面显示的异常，则说明您正在使用旧版本的slf4j-api（例如1.4.3）和新版本的slf4j绑定（例如1.5.6）。通常，当您的Maven <em>pom.ml</em>文件包含休眠3.3.0并声明对slf4j-api版本1.4.2的依赖时，就会发生这种情况。如果您的<em>pom.xml</em>声明了对slf4j绑定的依赖关系，例如slf4j-log4j12版本1.5.6，则将出现非法访问错误。
      </p>

      <p>要查看Maven引入了哪个版本的slf4j-api，请按以下方式使用maven依赖插件。</p>

      <p class="source">mvn依赖项：树</p>

      <p>如果使用的是Eclipse，请不要依赖<a href="http://m2eclipse.codehaus.org/">m2eclipse</a>所示的依赖关系树。</p>

      <p>在您的<em>pom.xml</em>文件中，显式声明对slf4j-api的依赖关系，使其与声明的绑定的版本匹配将使问题解决。
      </p>

      <p>请同时阅读有关<a href="#compatibility">向后兼容性</a>的FAQ条目，以获得更一般的解释。</p>

      
    </dd>
    

    <!-- ==================================================== -->

    <dt class="doAnchor" name="license">为什么SLF4J在X11类型许可证下而不是在Apache软件许可证下获得许可？
    </dt>
    
    <dd>
      <p>SLF4J是根据宽松的X11类型许可证而不是<a href="http://www.apache.org/licenses/">ASL</a>或<a href="http://www.gnu.org/copyleft/lesser.html">LGPL进行许可的，</a>因为X11许可证被Apache软件基金会和自由软件基金会都认为与其各自的许可证兼容。
      </p>
      
      
    </dd>

    <!-- ==================================================== -->
    <dt class="doAnchor" name="where_is_binding">在哪里可以获得特定的SLF4J绑定？
    </dt>
    
    <dd>
      
      <p><a href="api/org/slf4j/impl/SimpleLogger.html">SimpleLogger</a> ， <a href="api/org/slf4j/impl/NOPLogger.html">NOPLogger</a> ， <a href="api/org/slf4j/impl/Log4jLoggerAdapter.html">Log4jLoggerAdapter</a>和<a href="api/org/slf4j/impl/JDK14LoggerAdapter.html">JDK14LoggerAdapter的</a> SLF4J绑定包含在文件<em>slf4j-nop.jar</em> ， <em>slf4j-simple.jar</em> ， <em>slf4j-log4j12.jar</em>和<em>slf4j-jdk14.jar中</em> 。这些文件随<a href="download.html">SLF4J官方发行版一起提供</a> 。请注意，所有绑定都取决于<em>slf4j-api.jar</em> 。
      </p>
      
      <p>logback-classic的绑定附带<a href="http://logback.qos.ch/download.html">logback发行版</a> 。但是，与所有其他绑定一样，经典的logback绑定需要<em>slf4j-api.jar</em> 。
      </p>
      
      
    </dd>
    
    <dt class="doAnchor" name="configure_logging">我的图书馆应该尝试配置日志记录吗？
    </dt>
    
    <dd>
      <p><b>诸如库之类的嵌入式组件不仅不需要配置底层的日志记录框架，而且实际上也不需要这样做</b> 。他们应调用SLF4J进行日志记录，但应让最终用户配置日志记录环境。当嵌入式组件尝试自行配置日志记录时，它们通常会覆盖最终用户的意愿。归根结底，最终用户必须阅读日志并进行处理。她应该是决定如何配置日志记录的人。
      </p>      
      
      
    </dd>
    
    <!-- ======================================================= -->

    <dt class="doAnchor" name="optional_dependency">为了减少软件依赖项的数量，我们希望使SLF4J成为可选的依赖项。这是一个好主意吗？
    </dt>

    <dd>
      <p>每当软件项目达到需要设计日志记录策略的位置时，就会<a href="http://stackoverflow.com/questions/978670/is-it-worth-wrapping-a-logging-framework-in-an-additional-layer">弹出此问题</a> 。
      </p>

      <p>让Wombat成为具有很少依赖性的软件库。如果选择SLF4J作为Wombat的日志记录API，则将对<em>slf4j-api.jar</em>的新依赖<em>项</em>添加到Wombat的依赖项列表中。鉴于编写日志记录包装器似乎并不难，一些开发人员将试图包装SLF4J并仅在类路径中已经存在它时才与它链接，从而使SLF4J成为Wombat的可选依赖项。除了解决依赖关系问题外，包装程序还将Wombat与SLF4J的API隔离开来，以确保Wombat的登录是面向未来的。
      </p>

      <p>另一方面，根据定义，任何SLF4J包装器都取决于SLF4J。它必须具有相同的通用API。如果将来会出现新的，截然不同的日志记录API，那么使用包装器的代码将很难像直接使用SLF4J的代码一样迁移到新的API。因此，包装程序不太可能对代码进行过时的验证，而是通过在SLF4J之上添加一个附加的间接寻址来使其更加复杂，该间接寻址本身就是一种间接寻址。
      </p>

      <p><span class="label">脆弱性增加</span>实际上比这更糟。包装器将需要依赖于某些内部SLF4J接口，这些接口会不时发生变化，这与面向客户端的API永不改变。因此，包装程序通常取决于编译时使用的主要版本。针对SLF4J版本1.5.x编译的包装器不适用于SLF4J 1.6，而客户端代码使用<code>org.slf4j.Logger</code> ， <code>LoggerFactory</code> ， <code>MarkerFactory</code> ， <code>org.slf4j.Marker</code>和<code>MDC</code>适用于1.0版及更高版本的任何SLF4J版本。
      </p>

      <p>可以合理地假设，在大多数项目中，Wombat将是众多项目中的一种依赖项。如果每个库都有自己的日志记录包装器，则可能需要分别配置每个包装器。因此，不必处理一个日志记录框架，即SLF4J，Wombat的用户还必须详细说明Wombat的日志记录包装器。为了使SLF4J成为可选组件，每个带有自己的包装器的框架都会使问题更加复杂。（配置或处理五个不同的日志记录包装程序的复杂性并不令人兴奋，也不讨人喜欢。）
      </p>

      <p><a href="http://velocity.apache.org/engine/devel/developer-guide.html#Configuring_Logging">Velocity项目采用</a>的<a href="http://velocity.apache.org/engine/devel/developer-guide.html#Configuring_Logging">日志记录策略</a>是“自定义日志记录抽象”反模式的一个很好的例子。通过采用独立的日志记录抽象策略，Velocity开发人员使自己的生活更艰难，但更重要的是，他们使用户的生活更加艰难。
      </p>

      <p>一些项目尝试在类路径上检测到SLF4J的存在，如果存在，请切换到该路径。尽管此方法似乎足够透明，但会导致错误的位置信息。底层的日志记录框架将打印包装程序的位置（类名和行号），而不是实际的调用方。接下来是API覆盖率问题，因为SLF4J除了参数化日志记录之外还支持MDC和标记。虽然人们可以在数小时内提出看似可行的SLF4J包装器，但随着时间的推移，将会出现许多技术问题，Wombat开发人员将不得不处理这些问题。请注意，SLF4J已经发展了几年，并针对它提交了260个错误报告。</p>

      <p>由于上述原因，框架的开发人员应抵制编写自己的日志记录包装器的诱惑。这不仅浪费了开发人员的时间，而且实际上将使所述框架的用户的生活更加困难，并使日志代码反常地更容易受到更改的影响。
      </p>
    </dd>


   <!-- ======================================================= -->

    <dt class="doAnchor" name="maven2">Maven传递依赖项如何？
    </dt>
    
    <dd>
      <p>作为使用Maven构建的库的作者，您可能希望使用绑定（例如slf4j-log4j12或logback-classic）来测试您的应用程序，而不必强制将log4j或logback-classic依赖于用户。这相当容易实现。
      </p>

      <p>假设您的库代码取决于SLF4J API，则需要将slf4j-api声明为编译时（默认范围）依赖项。
      </p>
      <pre class="prettyprint source">&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
  &lt;version&gt;2.0.0-alpha2-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</pre>
      
      <p>可以通过将SLF4J绑定依赖项的范围声明为“测试”来限制测试中使用的SLF4J绑定的传递性。这是一个例子：</p>
      
      <pre class="prettyprint source">&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
  &lt;version&gt;2.0.0-alpha2-SNAPSHOT&lt;/version&gt;
  <b>&lt;scope&gt;test&lt;/scope&gt;</b>
&lt;/dependency&gt;</pre>
      
      <p>因此，就用户而言，您正在将slf4j-api导出为库的传递依赖项，而不导出任何SLF4J绑定或任何基础的日志记录系统。
      </p>
      
      <p>请注意，从SLF4J 1.6版开始，在没有SLF4J绑定的情况下，slf4j-api将默认为无操作实现。
      </p>

      
      
    </dd>
    
    <!-- ====================================================== -->
    <dt class="doAnchor" name="excludingJCL">如何排除Commons-logging作为Maven依赖项？
    </dt>
    
    <dd>
      <p><b>备选方案1）明确排除</b></p>

      <p>许多使用Maven的软件项目都将commons-logging声明为依赖项。因此，如果您希望迁移到SLF4J或使用jcl-over-slf4j，则需要在项目的所有依赖项（永久依赖于commons-logging）中排除commons-logging。Maven文档中描述了<a href="http://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html">依赖性排除</a> 。明确地排除针对分布在几个<em>pom.xml</em>文件上的多个依赖项的commons-logging可能是一个麻烦且相对容易出错的过程。
      </p>

      <p><b>备选方案2）提供的范围</b></p>

      <p>通过在项目的pom.xml文件中<em>提供的</em>作用域中声明公共日志，可以将其简单而方便地排除为依赖项。实际的公共日志记录类将由jcl-over-slf4j提供。这将转换为以下pom文件片段：</p>
      
         <pre class="prettyprint source">&lt;dependency>
  &lt;groupId>commons-logging&lt;/groupId>
  &lt;artifactId>commons-logging&lt;/artifactId>
  &lt;version>1.1.1&lt;/version>
  &lt;scope>provided&lt;/scope>
&lt;/dependency>

&lt;dependency>
  &lt;groupId>org.slf4j&lt;/groupId>
  &lt;artifactId>jcl-over-slf4j&lt;/artifactId>
  &lt;version>2.0.0-alpha2-SNAPSHOT&lt;/version>
&lt;/dependency></pre>

      <p>第一个依赖项声明实质上声明了公共日志将由您的环境“以某种方式”提供。第二个声明将jcl-over-slf4j包含到您的项目中。由于jcl-over-slf4j是commons-logging的完美二进制兼容替代品，因此第一个断言变为true。
      </p>

      <p>不幸的是，尽管在提供的作用域中声明commons-logging可以完成工作，但是您的IDE（例如Eclipse）仍然会将<em>commons-logging.jar</em>放在IDE所看到的项目的类路径中。您需要确保IDE可以在<em>commons-logging.jar</em>之前看到<em>jcl-over-slf4j.jar</em> 。</p>

      <p><b>备选方案3）空的文物</b></p>
      
      <p>另一种方法是依赖于<b>空的</b> <em>commons-logging.jar</em>工件。这种聪明的<a href="http://day-to-day-stuff.blogspot.com/2007/10/announcement-version-99-does-not-exist.html">方法最初是</a>由Erik van Oosten构想的，最初得到了支持。
      </p>

      <p>可从<a href="http://version99.qos.ch">http://version99.qos.ch（</a>具有高可用性的Maven存储库）中获得空工件，该存储库已复制到位于不同地理区域的几台主机上。</p>

      <p>以下声明将version99存储库添加到Maven搜索的远程存储库集合中。该存储库包含用于commons-logging和log4j的空工件。顺便说一句，如果您使用的是version99信息库，请在放一行<version99 at="" qos.ch="">。
      </version99></p>

      <pre class="prettyprint source">&lt;repositories>
  &lt;repository>
    &lt;id>version99&lt;/id>
    &lt;!-- highly available repository serving empty artifacts --&gt;
    &lt;url>http://version99.qos.ch/&lt;/url>
  &lt;/repository>
&lt;/repositories></pre>
      
    <p>在以下位置声明版本99的公共记录为空： <code><dependencyManagement></code>您的项目的“部分”将定向公共记录的所有传递依赖项导入版本为99的空白版本，从而很好地解决了公共记录排除问题。公共记录类将由jcl-over-slf4j提供。以下各行将commons-logging版本99-empty声明为空（在依赖项管理部分），并将jcl-over-slf4j声明为依赖项。
    </p>
    
<pre class="prettyprint source">&lt;dependencyManagement>
  &lt;dependencies>
    &lt;dependency>
      &lt;groupId>commons-logging&lt;/groupId>
      &lt;artifactId>commons-logging&lt;/artifactId>
      &lt;version><b>99-empty</b>&lt;/version>
    &lt;/dependency>
    ... other declarations...
  &lt;/dependencies>
&lt;/dependencyManagement>

&lt;!-- Do not forget to declare a dependency on jcl-over-slf4j in the        --&gt;
&lt;!-- dependencies section. Note that the dependency on commons-logging     --&gt;
&lt;!-- will be imported transitively. You don't have to declare it yourself. --&gt;
&lt;dependencies>
  &lt;dependency>
    &lt;groupId>org.slf4j&lt;/groupId>
    &lt;artifactId>jcl-over-slf4j&lt;/artifactId>
    &lt;version>2.0.0-alpha2-SNAPSHOT&lt;/version>
  &lt;/dependency>
  ... other dependency declarations
&lt;/dependencies>
</pre>


    </dd>
    
    
    
  </dl>
  
  
  <h2>关于SLF4J API</h2>
  
  <dl>
    
    <dt class="doAnchor" name="string_or_object">为什么Logger界面中的打印方法不接受Object类型的消息，而仅接受String类型的消息？
    </dt>
    
    <dd>
      
      <p>在SLF4J 1.0beta4中，修改了<a href="api/org/slf4j/Logger.html">Logger接口</a>中的诸如debug（），info（），warn（），error（）之类的打印方法，以便仅接受String类型的消息，而不接受Object。
      </p>
      
      <p>因此，DEBUG级别的打印方法集变为：</p>
      
      <pre class="prettyprint source">debug(String msg); 
debug(String format, Object arg); 
debug(String format, Object arg1, Object arg2);           
debug(String msg, Throwable t);</pre>
      
      <p>以前，上述方法中的第一个参数是类型<code>Object</code> 。</p>
      
      <p>此更改使日志记录系统是关于装饰和处理String类型的消息，而不是任何任意类型（Object）的消息。
      </p>
      
      <p>同样重要的是，新的方法签名集在重载的方法之间提供了更清晰的区分，而以前由于Java重载规则而对调用的方法的选择并不总是很容易遵循。</p>
      
      <p>犯错误也很容易。例如，以前写：</p>
      
      <pre class="prettyprint source">logger.debug(new Exception("some error"));</pre>
      
      <p>不幸的是，以上调用未打印异常的堆栈跟踪。因此，可能会丢失潜在的关键信息。当第一个参数限制为String类型时，则仅方法</p>
      
      <pre class="prettyprint source">debug(String msg, Throwable t);</pre>
      
      <p>可用于记录异常。请注意，此方法可确保每个记录的异常均附带描述性消息。</p>
      
      
    </dd>
    
    <!-- ====================================================== -->

    <dt class="doAnchor" name="exception_message">是否可以在没有伴随消息的情况下记录异常？
    </dt>

    <dd>
      <p>简而言之，没有。</p>
      
      <p>如果<code>e</code>是一个<code>Exception</code> ，并且您想在ERROR级别记录异常，则必须添加随附的消息。例如，</p>
      
      <pre class="prettyprint source">logger.error("some accompanying message", e);</pre>
      
      <p>您可能会合理地辩称，并非所有例外都伴随着有意义的信息。此外，一个好的例外应该已经包含了自我解释性的描述。因此，伴随的消息可以被认为是冗余的。
      </p>
      
      
      <p>尽管这些是有效的论点，但也有三个相反的论点也值得考虑。首先，尽管不是在所有情况下，但在很多情况下，伴随的消息都可以传达有用的信息，很好地补充了异常中包含的描述。通常，在记录异常的时间点，与引发异常的时间点相比，开发人员可以访问更多的上下文信息。其次，不难想像或多或少的通用消息，例如“异常捕获”，“跟随异常”，它们可以用作以下内容的第一个参数： <code>error(String msg, Throwable t)</code>调用。第三，大多数日志输出格式在一行中显示消息，然后在单独的行中显示异常。因此，如果没有消息，消息行将看起来不一致。
      </p>
      
      <p>简而言之，如果允许用户在没有附带消息的情况下记录异常，那么记录消息的工作就是记录系统的工作。这实际上是java.util.logging包中的<a href="http://tinyurl.com/cr9kg">throwing（String sourceClass，String sourceMethod，Throwable thrown）</a>方法的作用。（它自己决定附带的消息是字符串“ THROW”。）
      </p>
      
      <p>最初要求附带消息来记录异常可能看起来很奇怪。但是，这是<em>所有</em> log4j派生系统（例如java.util.logging，logkit等）中的常见做法，当然还有log4j本身。当前的共识似乎认为要求附带消息是一件好事（TM）。
      </p>
      
    </dd>     
    
    <!-- ====================================================== -->
    
    
    <dt class="doAnchor" name="logging_performance">（不）记录的最快方法是什么？
    </dt>

    <dd>    
      <p>SLF4J支持称为参数化日志记录的高级功能，该功能可以显着提高<em>禁用的</em>日志记录语句的日志记录性能。</p>
      
      <p>对于一些记录仪<code>logger</code> ， 写作，</p>
      <pre class="prettyprint source">logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));</pre>
      
      <p>产生了构造message参数的成本，即转换两个整数<code>i</code>和<code>entry[i]</code>到一个字符串，并连接中间字符串。这与是否记录消息无关。
      </p>        
      
      <p>避免参数构造成本的一种可能方法是，将log语句包含在测试中。这是一个例子。</p>
      
      <pre class="prettyprint source">if(logger.isDebugEnabled()) {
  logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));
}</pre>
      
      
      <p>这样，如果禁用了调试功能，则不会产生参数构造的成本<code>logger</code> 。另一方面，如果为记录器启用了DEBUG级别，则将产生两次评估该记录器是否已启用的成本：一次<code>debugEnabled</code>然后进入<code>debug</code> 。这是微不足道的开销，因为评估记录器所花费的时间不到实际记录一条语句的时间的1％。
      </p>
      
      <p><b>更好的是，使用参数化消息</b></p>
      
      <p>存在基于消息格式的非常方便的替代方法。假设<code>entry</code>是一个对象，可以这样写：</p>
      
      
      <pre class="prettyprint source">Object entry = new SomeObject();
logger.debug("The entry is {}.", entry);</pre>
      
      <p>在评估是否记录日志之后，并且只有在确定的情况下，记录器实现才会格式化消息，并将“ {}”对替换为字符串值<code>entry</code> 。换句话说，在禁用log语句的情况下，此格式不会产生参数构造的开销。
      </p>
      
      <p>以下两行将产生完全相同的输出。但是，在<em>禁用</em>日志记录语句的情况下，第二种形式的效果将比第一种形式好至少30倍。
      </p>
      
      <pre class="prettyprint source">logger.debug("The new entry is "+entry+".");
logger.debug("The new entry is {}.", entry);</pre>
      
      
      <p>也可以使用<a href="apidocs/org/slf4j/Logger.html#debug(java.lang.String, java.lang.Object%2C java.lang.Object)">两个参数的</a>变体。例如，您可以编写：</p>
      
      
      <pre class="prettyprint source">logger.debug("The new entry is {}. It replaces {}.", entry, oldEntry);</pre>
      
      <p>如果需要传递三个或更多参数，则可以使用<a href="apidocs/org/slf4j/Logger.html#debug(java.lang.String%2C java.lang.Object...)"><code>Object...</code></a>打印方法的<a href="apidocs/org/slf4j/Logger.html#debug(java.lang.String%2C java.lang.Object...)">变体</a> 。例如，您可以编写：</p>
      
      <pre class="prettyprint source">logger.debug("Value {} was inserted between {} and {}.", newVal, below, above);</pre>
      
      <p>这种形式会导致通常很小的Object []（对象数组）的构造隐性成本。一个参数变体和两个参数变体不会产生此隐藏成本，并且仅出于此原因（效率）存在。仅使用Object ...变体，slf4j-api会更小/更干净。</p>
     
      
      <p>还支持数组类型参数，包括多维数组。</p>
      
      <p>SLF4J使用其自己的消息格式实现，该实现与Java平台的不同。SLF4J的执行速度快大约10倍，但代价是非标准且灵活性较差，这证明了这一点。
      </p>
      
      <p><b>转义“ {}”对</b></p>
      
      <p>“ {}”对称为<em>格式化锚</em> 。它用于指定消息模式中需要替换参数的位置。
      </p>
      
      <p>SLF4J只关心<em>格式锚</em> ，即紧跟在“}”之后的“ {”字符。因此，如果您的邮件中包含'{'或'}'字符，则无需执行任何特殊操作，除非'}'字符紧跟在'}'之后。例如，</p>
      
      <pre class="prettyprint source">logger.debug("Set {1,2} differs from {}", "3");</pre>
      
      <p>它将打印为“设置{1,2}与3不同”。</p>
      
      <p>你甚至可以写，</p>
      <pre class="prettyprint source">logger.debug("Set {1,2} differs from {{}}", "3");</pre>
      <p>它将被打印为“设置{1,2}与{3}不同”。</p>
      
      <p>在极少数情况下，“ {}”对在您的文本中自然出现，并且您希望禁用格式锚的特殊含义，那么您需要使用“ \”转义“ {”字符，即反斜杠字符。只能对'{'字符进行转义。无需转义'}'字符。例如，</p>
      
      <pre class="prettyprint source">logger.debug("Set \\{} differs from {}", "3");</pre>
      
      <p>将打印为“设置{}与3不同”。请注意，在Java代码中，反斜杠字符必须写为'\\'。</p>
      
      <p>在极少数情况下，“ \ {}”自然出现在消息中，您可以对格式锚进行两次转义，使其保留其原始含义。例如，</p>
      
      
      <pre class="prettyprint source">logger.debug("File name is C:\\\\{}.", "file.zip");</pre>
      <p>将打印为“文件名为C：\ file.zip”。</p>
      
    </dd>
    
    <!-- ================================================= -->
    
    <dt class="doAnchor" name="string_contents">如何记录单个（可能是复杂的）对象的字符串内容？</dt>
    
    <dd>
      <p>在相对较少的情况下，要记录的消息是对象的字符串形式，则可以使用适当级别的参数化打印方法。假设<code>complexObject</code>是具有一定复杂性的对象，对于级别为DEBUG的日志语句，您可以编写：</p>
      
      <pre class="prettyprint source">logger.debug("{}", complexObject);</pre>
      
      
      <p>日志系统将调用<code>complexObject.toString()</code>仅在确定已启用log语句之后，才执行此方法。否则，费用<code>complexObject.toString()</code>将有利地避免转换。
      </p>
      
      
      
    </dd>
    
    <!-- ================================================= -->
    
    
    <dt class="doAnchor" name="fatal">为什么不<code>org.slf4j.Logger</code>界面是否具有致命级别的方法？
    </dt>
    
    <dd>      
      <p><a href="apidocs/org/slf4j/Marker.html">Marker</a>界面是<code>org.slf4j</code>包，使致命级别大大冗余。如果给定的错误除了需要为普通错误分配的关注之外，只需用专门指定的标记标记日志记录语句，该标记可以命名为“ FATAL”或您喜欢的任何其他名称。
      </p>

      <p>这是一个例子</p>
    
<pre class="prettyprint">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

class Bar {
  void foo() {
    <b>Marker fatal = MarkerFactory.getMarker("FATAL");</b>
    Logger logger = LoggerFactory.getLogger("aLogger");

    try {
      ... obtain a JDBC connection
    } catch (JDBException e) {
      logger.error(<b>fatal</b>, "Failed to obtain JDBC connection", e);
    }
  }
}</pre>


      <p>虽然标记是SLF4J API的一部分，但只有logback支持现成的标记。例如，如果您添加<code>%marker</code>转换单词到其模式，logback的<code>PatternLayout</code>将标记数据添加到其输出。标记数据可用于<a href="http://logback.qos.ch/manual/filters.html">过滤消息</a> ，甚至可以<a href="http://logback.qos.ch/recipes/emailPerTransaction.html">在单个事务结束时</a> <a href="http://logback.qos.ch/manual/appenders.html#OnMarkerEvaluator">触发</a>外发电子邮件。
      </p>

      <p>结合不支持标记的日志框架（例如log4j和java.util.logging），标记数据将被静默忽略。</p>

      <p>与级别允许的五个值（错误，警告，信息，调试和跟踪）相比，标记为处理日志语句添加了一个具有无限可能值的新维度。目前，仅logback支持标记数据。但是，没有什么可以阻止其他日志记录框架使用标记数据。
      </p>
      
    </dd>
    
    <!-- ======================================================= -->
    <dt class="doAnchor" name="trace">为什么仅在SLF4J 1.4.0版中引入了TRACE级别？</dt>
    
    <dd>
      
      <p>TRACE级别的添加一直是引起人们广泛争议的要求。通过研究各种项目，我们观察到TRACE级别用于禁用某些类的日志输出， <em>而无需</em>为这些类配置日志。确实，TRACE级别默认在log4j和logback以及大多数其他日志记录系统中被禁用。通过在配置文件中添加适当的指令，可以实现相同的结果。
      </p>
      
      <p>因此，在许多情况下，TRACE级别具有与DEBUG相同的语义。在这种情况下，TRACE级别仅保存一些配置指令。在其他更有趣的情况下，TRACE的含义不同于DEBUG的含义，可以使用<a href="api/org/slf4j/Marker.html">Marker</a>对象来传达所需的含义。但是，如果您不被标记困扰，并希望使用低于DEBUG的日志记录级别，则TRACE级别可以完成工作。
      </p>
      
      <p>请注意，虽然评估禁用的日志请求的成本大约为<code>nanoseconds</code> ，不建议在严格的循环中使用TRACE级别（或其他任何级别），在这种情况下，日志请求可能会被评估数百万次。如果启用了日志请求，那么它将以大量输出淹没目标目的地。如果请求被禁用，将浪费资源。
      </p>
      
      <p>简而言之，尽管我们仍然不鼓励使用TRACE级别，因为存在替代方案，或者因为在许多情况下，由于人们不断要求TRACE级别的日志请求是浪费的，所以我们决定屈从于大众需求。
      </p>
      
      
    </dd>

    <!-- ================================================= -->
    <dt class="doAnchor" name="i18n">SLF4J日志记录API是否支持I18N（国际化）？
    </dt>
    
    <dd>
      <p>是的，从1.5.9版开始，SLF4J附带了一个名为<code>org.slf4j.cal10n</code>它将<a href="localization.html">本地化/国际化日志记录</a>支持添加为基于<a href="http://cal10n.qos.ch">CAL10N API</a>的<a href="http://cal10n.qos.ch">薄层</a> 。</p>

      
    </dd>          

    <!-- ================================================= -->

    <dt class="doAnchor" name="noLoggerFactory">是否可以检索记录器而无需通过静态方法<code>LoggerFactory</code> ？
    </dt>

    <dd>

      <p>是。 <code>LoggerFactory</code>本质上是一个包装<a href="xref/org/slf4j/ILoggerFactory.html"><code>ILoggerFactory</code></a>实例。的<code>ILoggerFactory</code>使用中的实例是根据SLF4J框架的静态绑定约定确定的。请参阅中的<a href="xref/org/slf4j/LoggerFactory.html#217">getSingleton（）</a>方法。 <code>LoggerFactory</code>有关详细信息。
      </p>

      <p>但是，没有什么可以阻止您使用自己的<code>ILoggerFactory</code>实例。请注意，您还可以获得对<code>ILoggerFactory</code>那<code>LoggerFactory</code>该类通过调用<a href="apidocs/org/slf4j/LoggerFactory.html#getILoggerFactory()"><code>LoggerFactory.getILoggerFactory()</code></a>方法。
      </p>

      <p>因此，如果SLF4J绑定约定不符合您的需求，或者您需要其他灵活性，那么请考虑使用<code>ILoggerFactory</code>接口作为发明自己的日志记录API的替代方法。</p>
    </dd>
    
    <!-- ================================================= -->

    <dt class="doAnchor" name="paramException">在存在异常/可抛出异常的情况下，是否可以参数化日志记录语句？</dt>


    <dd>
      <p>是的，从SLF4J 1.6.0开始，但在以前的版本中没有。假设异常是最后一个参数，则SLF4J API在存在异常的情况下支持参数化。从而，</p>
    <pre class="prettyprint">String s = "Hello world";
try {
  Integer i = Integer.valueOf(s);
} catch (NumberFormatException e) {
  logger.error("Failed to format {}", s, e);
}</pre>

     <p>将打印<code>NumberFormatException</code>其堆栈跟踪符合预期。Java编译器将<a href="http://www.slf4j.org/apidocs/org/slf4j/Logger.html#error%28java.lang.String, java.lang.Object, java.lang.Object%29">使用String和两个Object参数</a>调用<a href="http://www.slf4j.org/apidocs/org/slf4j/Logger.html#error%28java.lang.String, java.lang.Object, java.lang.Object%29">error方法</a> 。SLF4J将按照程序员的最可能意图进行解释<code>NumberFormatException</code>实例作为可抛出而不是未使用的实例<code>Object</code>参数。在1.6.0之前的SLF4J版本中， <code>NumberFormatException</code>实例只是被忽略了。
     </p>

     <p>如果异常不是最后一个参数，则它将被视为普通对象，并且不会打印其堆栈跟踪。但是，这种情况在实践中不应发生。
     </p>
    
    </dd>
  </dl>


  
  <h2>实施SLF4J API</h2>
  
  <dl>

    <!-- ============================================================= -->

    <dt class="doAnchor" name="slf4j_compatible">如何使我的日志记录框架SLF4J兼容？
    </dt>
    
    
    <dd>
      
      <p>添加对SLF4J的支持非常容易。本质上，您应对现有的绑定并对其进行一些调整（如下所述）可以解决问题。
      </p>
      
      <p>假设您的日志记录系统具有记录器的概念，称为say <code>MyLogger</code> ，您需要提供一个适配器<code>MyLogger</code>至<code>org.slf4j.Logger</code>接口。有关适配器的示例，请参考slf4j-jcl，slf4j-jdk14和slf4j-log4j12模块。
      </p>
      
      <p>编写适当的适配器后，说<code>MyLoggerAdapter</code> ，您需要提供一个实现<code>org.slf4j.ILoggerFactory</code>接口。该工厂应返回实例<code>MyLoggerAdapter</code> 。让<code>MyLoggerFactory</code>是您的工厂班级的名称。
      </p>
      
      <p>一旦有了适配器，即<code>MyLoggerAdapter</code> ，还有一家工厂，即<code>MyLoggerFactory</code> ，最后剩下的步骤是修改<code>StaticLoggerBinder</code>类，以便它返回的新实例<code>MyLoggerFactory</code> 。您还需要修改<code>loggerFactoryClassStr</code>变量。
      </p>
      
      <p>对于Marker或MDC支持，您可以使用现有的NOP实现之一。
      </p>
      
      <p>总之，要为您的日志记录系统创建SLF4J绑定，请按照下列步骤操作：</p>
      
      <ol>
        <li>从现有模块的副本开始，</li>
        <li>在您的日志记录系统和<code>org.slf4j.Logger</code>接口</li>
        <li>为上一步中创建的适配器创建工厂，</li>
        <li>修改<code>StaticLoggerBinder</code>类以使用您在上一步中创建的工厂</li>
      </ol>
      
      
    </dd>

    <!-- ============================================================= -->

    <dt class="doAnchor" name="marker_interface">我的日志记录系统如何增加对<code>Marker</code>接口？
    </dt>
    <dd>
      
      <p>标记构成了一个革命性的概念，该概念受日志支持，但不受其他现有日志系统的支持。因此，允许符合SLF4J的日志记录系统忽略用户传递的标记数据。
      </p>
      
      <p>但是，即使可以忽略标记数据，仍然必须允许用户指定标记数据。否则，用户将无法在支持标记的日志系统和不支持标记的日志系统之间切换。
      </p>
      
      <p>的<code>MarkerIgnoringBase</code>类可以用作缺少标记支持的日志系统的适配器或本机实现的基础。在<code>MarkerIgnoringBase</code> ，使用标记数据的方法只需调用没有Marker参数的相应方法，就丢弃作为参数传递的所有Marker数据。您的SLF4J适配器可以扩展<code>MarkerIgnoringBase</code>快速实施以下方法<code>org.slf4j.Logger</code>这需要一个<code>Marker</code>作为第一个论点。
      </p>
      
      
    </dd>
    
    <!-- ============================================================= -->

    <dt class="doAnchor" name="version_checks">SLF4J的版本检查机制如何工作？
    </dt>
    
    <dd>
      <p>SLF4J API在初始化期间执行的版本检查是一个<em>可选</em>过程。符合SLF4J的实现可能选择<em>不</em>参与，在这种情况下，将不执行任何版本检查。
      </p>
      
      <p>但是，如果SLF4J实现决定参与，则需要在其副本中声明一个名为REQUESTED_API_VERSION的变量。 <code>StaticLoggerBinder</code>类。此变量的值应等于与其一起编译的slf4j-api.jar的版本。如果将实现升级到slf4j-api的较新版本，则还需要更新REQUESTED_API_VERSION的值。</p>
      
      <p>对于每个版本，SLF4J API维护一个兼容版本的列表。仅当在兼容性列表中找不到所需的版本时，SLF4J才会发出版本不匹配警告。因此，即使您的SLF4J绑定的发布时间表与SLF4J的发布时间表不同，假设您每6到12个月更新一次使用的SLF4J版本，您仍然可以参与版本检查而不会出现不匹配警告。例如，logback具有不同的发布时间表，但仍参与版本检查。</p>
      
      <p><b>从SLF4J 1.5.5开始</b> ，SLF4J发行版本中随附的所有绑定（例如slf4j-log4j12，slf4j-simple和slf4j-jdk14）都声明REQUESTED_API_VERSION字段，其值等于其SLF4J版本。因此，例如，如果slf4j-simple-1.5.8.jar与slf4j-api-1.6.0.jar混合使用，因为1.5.8不在SLF4J 1.6.x版的兼容性列表中，则版本不匹配将发出警告。
      </p>

      <p>请注意，SLF4J 1.5.5之前的版本没有版本检查机制。仅slf4j-api-1.5.5.jar和更高版本可以发出版本不匹配警告。
      </p>

      
    </dd>
    
  </dl>
  
  <h2>有关日志记录的一般问题</h2>
  
  

  <dl>

    <!-- ============================================================= -->
    <dt class="doAnchor" name="declared_static">是否应将类的Logger成员声明为静态成员？
    </dt>
    <dd>
      
      <p>我们<code>used</code>建议将记录器成员声明为实例变量而不是静态变量。经过进一步分析， <b>我们不再推荐一种方法。</b>
      </p>
      
      <p>这是每种方法的优缺点的摘要。
      </p>
      
      <table class="bodyTable">
        <tbody><tr valign="top">
          <th width="50%">将记录器声明为静态的优点</th>       
          <th width="50%">将记录器声明为静态的缺点</th>              
        </tr>
        <tr valign="top" class="alt">
          <td>
            <ol>
              <li>常见的习语</li>
              <li>更少的CPU开销：在托管类初始化时，记录器仅检索和分配一次</li>
              <li>更少的内存开销：记录器声明将每个类消耗一个引用</li>            
            </ol>
          </td>
          
          <td> <!-- static con -->
            <ol>
              <li>对于在应用程序之间共享的库，无法利用存储库选择器。应当注意，如果SLF4J绑定和基础API随每个应用程序一起提供（未在应用程序之间共享），则每个应用程序仍将具有其自己的日志记录环境。
              </li>
              <li>不适合国际奥委会</li>
            </ol>
          </td>
        </tr>
        
        <tr>
          <th width="50%">将记录器声明为实例变量的优点</th>       
          <th width="50%">将记录器声明为实例变量的缺点</th>
        </tr>
        
        <tr class="alt" valign="top">
          <td> <!-- instance pros -->
            <ol>
              <li>即使在应用程序之间共享的库中，也可以利用存储库选择器。但是，存储库选择器仅在基础日志系统为logback-classic时才起作用。存储库选择器不适用于SLF4J + log4j组合。
              </li>
              <li>国际奥委会友好</li>
            </ol>
          </td>
          
          <td> <!-- instance cons -->
            <ol>
              <li>不像将记录器声明为静态变量那样普遍</li>
              
              <li>更高的CPU开销：为主机类的每个实例检索并分配记录器</li>
              
              <li>更高的内存开销：记录器声明将为主机类的每个实例消耗一个引用</li>                   
            </ol>
          </td>
        </tr>        
      </tbody></table>
      
      
      <h3>说明</h3>
      
      <p>静态记录器成员为类的所有实例花费单个变量引用，而实例记录器成员将为类的每个实例花费变量引用。对于实例化数千次的简单类，可能会有明显的差异。
      </p>
      
      <p>但是，较新的日志记录系统（例如log4j或logback）为应用程序服务器中运行的每个应用程序支持不同的日志记录器上下文。因此，即使在服务器中部署了<em>log4j.jar</em>或<em>logback-classic.jar</em>的单个副本，日志记录系统也将能够区分应用程序，并为每个应用程序提供不同的日志记录环境。
      </p>
      
      <p>更具体地说，每次通过调用检索记录器<code>LoggerFactory.getLogger()</code>方法，基础日志系统将返回适合当前应用程序的实例。请注意，在<em>同一</em>应用程序中以给定名称检索记录器将始终返回相同的记录器。对于给定的名称，将仅针对不同的应用程序返回不同的记录器。
      </p>
      
      <p>如果记录器是静态的，则仅在将托管类加载到内存时才检索一次。如果仅在一个应用程序中使用托管类，则无需过多关注。但是，如果托管类在多个应用程序之间共享，则共享类的所有实例都将登录到应用程序的上下文中，而这恰巧是首先将共享类加载到内存中的-这几乎不是用户期望的行为。
      </p>
      
      <p>不幸的是，对于SLF4J API的非本地实现（即使用slf4j-log4j12），log4j的存储库选择器将无法正确执行其工作，因为非本地SLF4J绑定slf4j-log4j12会将记录器实例存储在地图中，短路上下文相关的记录器检索。对于本地SLF4J实现，例如经典的logback，存储库选择器将按预期工作。
      </p>          
      
      <p>Apache Commons Wiki包含内容<a href="http://wiki.apache.org/commons/Logging/StaticLog">丰富的文章，</a>涉及相同的问题。</p>
      
      <p><b>记录仪序列化</b></p>
      
      <p>与静态变量相反，实例变量默认情况下被序列化。从SLF4J 1.5.3版开始，记录器实例在序列化后仍然有效。因此，即使将记录器声明为实例变量，主机类的序列化也不再需要任何特殊操作。在以前的版本中，记录器实例需要声明为<code>transient</code>在主持人课上。</p>
      
      <p><b>摘要</b></p>
      
      <p>总之，将记录器成员声明为静态变量需要较少的CPU时间，并且占用的内存较小。另一方面，将记录器成员声明为实例变量需要更多的CPU时间，并且具有稍微更高的内存开销。但是，实例变量可以为每个应用程序创建一个独特的记录器环境，即使是在共享库中声明的记录器也是如此。也许比前面提到的注意事项更重要，实例变量是IOC友好的，而静态变量不是。
      </p>    
     
      <p>另请参见commons-logging Wiki中的<a href="http://wiki.apache.org/jakarta-commons/Logging/StaticLog">相关讨论</a> 。
      </p>
      
    </dd>       
  </dl>
  
  <!-- ============================================================= -->
  <dl>
    <dt class="doAnchor" name="declaration_pattern">在类中声明记录器是否有建议的习惯用法？
    </dt>
    
    <dd>
      <p>以下是推荐的记录器声明习惯用法。由于<a href="#declared_static">上述</a>原因，留给用户确定是否将记录器声明为静态变量。</p>
      
      <pre class="prettyprint source">package some.package;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
      
public class MyClass {
  <b>final (static) Logger logger = LoggerFactory.getLogger(MyClass.class);</b>
  ... etc
}</pre>
      
      <p>不幸的是，由于托管类的名称是logger声明的一部分，因此上述logger声明惯用语<em>不能</em>抵抗类之间的剪切和粘贴。
      </p>

      <p>或者，您可以使用<code>MethodHandles.lookup()</code>在JDK 7中引入以传递调用者类。</p>

      <pre class="prettyprint source">package some.package;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.lang.invoke.MethodHandles;
      
public class MyClass {
  <b>final <span class="big">static</span> Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</b>
  ... etc
}</pre>
      
     <p>可以跨类剪切和粘贴此模式。</p>

    </dd>
  </dl>
    
  <script src="templates/footer.js" type="text/javascript"></script>
</div>


</body></html>