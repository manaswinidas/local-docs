<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>SLF4J迁移器</title>
    <link rel="stylesheet" type="text/css" href="css/site.css" media="screen">
  </head>
  <body >
    <script type="text/javascript">prefix='';</script>
    
    <script src="templates/header.js" type="text/javascript"></script>
    <div id="left">
      <script src="templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="templates/right.js" type="text/javascript"></script>
    </div>

    <div id="content">


    <h1>SLF4J迁移器</h1>
    
    <p>SLF4J迁移器是一个小型Java工具，用于将Java源文件从Jakarta Commons Logging（JCL）API迁移到SLF4J。它还可以从log4j API迁移到SLF4J，或从<code>java.util.logging</code> SLF4J的API。</p>
    
    <p>SLF4J迁移器包含一个jar文件，可以将其作为独立的Java应用程序启动。这是命令：</p>
    
    <p class="source">java -jar slf4j-migrator-2.0.0-alpha0.jar</p>
    
    <br>
    
    <p>启动应用程序后，将出现类似于以下内容的窗口。
    </p>
    
    <p><img src="images/slf4j-migrator.gif" alt="slf4j-migrator.gif"></p>
    
    <p>应用程序的使用应该是不言自明的。请注意，此迁移工具可以就地替换Java文件，这意味着将不会有修改后文件的备份副本。<b>使用SLF4J Migrator之前，您有责任备份文件。</b>
    </p>
    
    
    <h2>局限性</h2>
    
    <p>SLF4J迁移器旨在作为一个简单的工具来帮助您使用JCL，log4j或JUL将项目源迁移到SLF4J。它只能执行基本转换步骤。本质上，它将替换适当的导入行和记录器声明。
    </p>
    
    <p>MyClass是使用JCL的示例类。在此之前：</p>
    
    <p class="source">包装some.package; <b>导入org.apache.commons.logging。日志;导入org.apache.commons.logging。LogFactory;</b>公共MyClass { <b>日志记录器= LogFactory.getLog（MyClass.class）;</b>公共无效someMethod（）{logger.info（“ Hello world”）; }}</p>

  <p>迁移后：</p>

  <p class="source">包装some.package; <b>导入org.slf4j。记录仪导入org.slf4j。LoggerFactory;</b>公共MyClass { <b>Logger logger = LoggerFactory.getLogger（MyClass.class）;</b>公共无效someMethod（）{logger.info（“ Hello world”）; }}</p>

  <br>

  <p>尽管其转换规则是基本的，但SLF4J迁移器仍可以减轻将Java项目从JCL迁移到SLF4J所涉及的繁琐工作。</p>

  <p>从log4j到SLF4J或从JUL到SLF4J的迁移规则是相似的。</p>

  <h3>一般限制</h3>

  <ul>

    <li>构建脚本未修改<p>您需要手动修改Ant / Maven / Ivy构建脚本，以使用SLF4J而不是JCL或log4j。</p>

    <p></p>
    </li>

    <li>仅支持字符串类型的消息<p>如果您的一个日志语句包含一个非字符串对象作为其唯一参数，则必须在该对象上手动添加toString（）方法调用。
    </p>

    <p>例如，</p>
    <p class="source">logger.debug（new Object（））;</p>
    <p>必须手动重写为</p>
    <p class="source">logger.debug（new Object（）。toString（））;</p>

    <p></p>
    </li>

    <li>不支持致命级别。
    
    <p>您必须手动转换它们。认为此限制不是很严重，因为通常很少有带有FATAL级别的日志语句。
    </p>

    <p>
    </p>
    </li>

    <li>如果一个方法在同一行上声明了多个记录器，则转换将不会完成。例：<p class="source">public void someMethod（Log l1，Log l2）{...}将被转换为public void someMethod（Log l1，Logger l2）{...}</p>
  </li>
  </ul>

  <h3>从log4j迁移时的限制</h3>

  <ul>
    <li>NDC语句保持原样<p>由于SLF4J不支持NDC，因此迁移器无法正确处理NDC语句。您必须手动将它们迁移到MDC。同样，这种限制并不严重，因为即使在大型项目中，通常也很少有NDC语句。
    </p>

    <p>请注意，与NDC相反，MDC语句可以正确迁移，因为SLF4J支持此类语句。</p>

    <p></p>
    </li>

    <li>致电<code>PropertyConfigurator</code>要么<code>DomConfigurator</code>由于没有SLF4J等效项，因此无法迁移。

    <p>
    </p>

    </li> 
  </ul>

  <h3>从JUL迁移时的限制</h3>

  
  <ul>
    <li>致电<code>finest()</code> ， <code>finer()</code>要么<code>finest()</code>方法<code>java.util.logging.Logger</code>保持原样。

    <p>鉴于<code>finest()</code> ， <code>finer()</code>要么<code>finest()</code>调用可以映射到SLF4J中的trace（）或debug（）调用，无法猜测用户希望如何映射这些调用。
    </p>

    <p>
    </p>

    </li>


    <li>匹配“ .severe（”的所有字符串都将替换为字符串“ .error（”，而不进行任何上下文分析。同样，所有与“ .warning（”匹配的字符串都将被“ .warn（”替换。

    <p>由于match / replace操作不是上下文相关的，因此，如果您的代码包含名为“ severe”或“ warning”的方法，则迁移结果将出现编译错误。幸运的是，此类错误应该很少且易于识别。
    </p>

    <p>
    </p>

    </li>

    <li>调用以下方法中定义的<code>java.util.logging.Logger</code>类需要手动迁移： <code>log</code> ， <code>logp</code> ， <code>logrb</code> ， <code>entering</code> ， <code>exiting</code> 。
      
    </li>
  </ul>

  <script  src="templates/footer.js" type="text/javascript"></script> 
 </div> 


</body></html>