<html  xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>SLF4J错误代码</title>
  <link rel="stylesheet" type="text/css" href="css/site.css" media="screen">
  <link rel="stylesheet" type="text/css" href="css/prettify.css">
  <style>
    h3.doAnchor {
      border-top: 2px solid #888;
      padding-top: 1ex;
    }
  </style>
</head>
<body  onload="prettyPrint(); decorate();">
    <script type="text/javascript" src="js/prettify.js"></script>
    <script type="text/javascript">prefix='';</script>
    <script type="text/javascript" src="templates/header.js"></script>
    <script type="text/javascript" src="js/jquery-min.js"></script>
    <script type="text/javascript" src="js/decorator.js"></script>

    <div id="left">
      <script src="templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="templates/right.js" type="text/javascript"></script>
    </div>


    <div id="content">

    <center>
      <h2>SLF4J警告或错误消息及其含义</h2>     
      
    </center>
    

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="noProviders">找不到SLF4J提供程序。
    </h3>

    <p>当在类路径上找不到SLF4J提供程序时，将报告此<b>警告</b> （即不是错误）消息。将<em>slf4j-nop.jar</em> <em>slf4j-simple.jar</em> ， <em>slf4j-log4j12.jar</em> ， <em>slf4j-jdk14.jar</em>或<em>logback-classic.jar</em>中的一个（仅一个）放置在类路径上应该可以解决此问题。请注意，这些提供程序必须针对slf4j-api 1.8或更高版本。
    </p>

    <p>在没有提供程序的情况下，SLF4J将默认为无操作（NOP）记录程序提供程序。
    </p>

    <p>请注意，slf4j-api版本1.8.x及更高版本使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>机制。<span class="red">早期版本依赖于slf4j-api不再支持的静态绑定器机制。</span>请阅读常见问题解答条目<a href="faq.html#changesInVersion18">SLF4J 1.8.0版中发生了什么变化？</a> 了解更多重要细节。
    </p>
    
    <p>如果您负责打包应用程序并且不关心日志记录，那么将<em>slf4j-nop.jar</em>放在应用程序的类路径中将摆脱此警告消息。请注意，诸如库或框架之类的嵌入式组件不应声明对任何SLF4J提供程序的依赖，而应仅依赖slf4j-api。当库声明对SLF4J提供程序的编译时依赖性时，它将该提供程序强加于最终用户，从而否定了SLF4J的目的。</p>
    
    <!-- ====================================================== -->    

    <h3 class="doAnchor" name="ignoredBindings">类路径包含针对1.8之前的slf4j-api版本的SLF4J绑定</h3>

    <p>slf4j-api版本1.8.x和Jigsaw（Java 9）的出现计划在以后使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>机制。<span class="red">SLF4J的早期版本依赖于静态绑定器机制，而slf4j-api不再支持该机制。</span></p>
    
    <p>如果SLF4J没有找到针对SLF4J 1.8的提供程序，而是找到了针对SLF4J 1.7或更早版本的绑定，它将列出找到的绑定，否则将<b>忽略</b>它们。
    </p>

    <p>另请参见常见问题解答条目<a href="faq.html#changesInVersion18">SLF4J 1.8.0版中有哪些更改？</a> 了解更多重要细节。
    </p>
    

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="unsuccessfulInit">IllegalStateException： <code>org.slf4j.LoggerFactory</code>处于失败状态。最初的异常被提早发出。</h3>

    <p>这个<code>IllegalStateException</code>在初始化后引发，并通知用户<code>LoggerFactory</code>失败了。</p>

    <p><span class="label notice">注意</span>必须意识到，导致故障的异常是在<b>较早的阶段</b>抛出的。此较早的异常应提供有关问题根本原因的更有价值的信息。
    </p>

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="release">方法<code>o.a.commons.logging.impl.SLF4FLogFactory#release</code>被调用。
    </h3>

    <p>给定commons-logging API的结构，尤其是由SLF4J实现的结构， <code>o.a.commons.logging.impl.SLF4FLogFactory#release()</code>方法永远不应该被调用。但是，根据servlet容器中<em>commons-logging.jar</em>文件的部署， <code>release()</code>方法的副本可能会意外调用<code>org.apache.commons.logging.LogFactory</code>使用<em>commons-logging.jar进行</em>类运输。
    </p>

    <p>在Tomcat的最新版本中，这是相对常见的情况，尤其是如果将<em>jcl-over-slf4j.jar</em>放在<em>Web</em>应用程序的<em>WEB-INF / lib</em>目录中，而不是<em>$ TOMCAT_HOME / common / lib中</em> ，其中$ TOMCAT_HOME代表Tomcat的安装目录。为了充分利用<em>jcl-over-slf4j.jar</em>提供的稳定性，我们建议您将<em>jcl-over-slf4j.jar</em>放在<em>$ TOMCAT_HOME / common / lib中，</em>而不要将副本放在Web应用程序中。
    </p>

    <p>另请参阅<a href="http://bugzilla.slf4j.org/show_bug.cgi?id=22">错误＃22</a> 。</p>
    
     <!-- ====================================================== -->

    <h3 class="doAnchor" name="unsupported_operation_in_jcl_over_slf4j">jcl-over-slf4j不支持操作[suchAndSuch]。
    </h3>

    <p>一个<code>UnsupportedOperationException</code>每当调用JCL 1.1中引入的一种受保护的方法时，都将抛出该异常。这些方法由<code>LogFactory</code>带有<em>commons-logging.jar的实现</em> 。然而<code>LogFactory</code>由<em>jcl-over-slf4j.jar</em> （即SLF4FLogFactory）实现的方法不会调用任何这些方法。
    </p>

    <p>如果观察到此问题，则很可能在类路径中有<em>commons-logging.jar</em>的副本，该副本将覆盖<em>jcl-over-slf4j.jar附带的类</em> 。请注意，此问题本质上与“ oacommons.logging.impl”时发出的警告非常相似。调用SLF4FLogFactory.release（）“方法，在上一项中进行了讨论。
    </p>

    <!-- ====================================================== -->
    <h3 class="doAnchor" name="loggerNameMismatch">检测到记录器名称不匹配</h3>

    <p>记录器名称不匹配警告仅在以下情况下显示<code>slf4j.detectLoggerNameMismatch</code>系统属性设置为true。默认情况下，未设置此属性，即使记录器名称不匹配，也不会打印警告。
    </p>

    <p><span class="label">从1.7.9开始</span> ，如果通过作为参数传递给类的类指定的记录器名称，将打印警告。 <code>LoggerFactory.getLogger(Class)</code>方法与SLF4J内部计算出的调用方名称不同。</p>

    <p>例如，下面的代码片段</p> 

<pre class="prettyprint source">package com.acme;
import com.foo.Kangaroo;

class <b>Fruit</b> {
  Logger logger = LoggerFactory.getLogger(<b>Kangaroo.class</b>);
}</pre>

    <p>将导致警告</p>

    <pre class="prettyprint source">SLF4J: Detected logger name mismatch. Given name: "com.foo.Kangaroo"; computed name: "com.acme.Fruit".</pre>
    
    <p>但只有在<code>slf4j.detectLoggerNameMismatch</code>系统属性设置为true。</p>
    
    <p>对于特殊情况，在定义记录器的类是作为参数传递的类参数的超类型的特殊情况下，不会发出警告。例如，</p>
    
    <pre class="prettyprint source">class A { 
    Logger logger = LoggerFactory.getLogger(getClass()); 
}
class B extends A { 
    // no mismatch warning will be issued when B is instantiated 
    // given that class A is a super-type of class B
}</pre>

    <p>如果遇到无法解释的不匹配警告，则可能是发现了一个白象，这是非常罕见的情况，其中SLF4J无法正确计算定义记录器的类的名称。我们非常有兴趣了解这种情况。如果并且当您发现无法解释的不匹配时，请向我们<a href="bug-reporting.html">提交错误报告</a> 。
    </p>

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="StaticLoggerBinder">无法加载课程<code>org.slf4j.impl.StaticLoggerBinder</code></h3>

    <p>当<code>org.slf4j.impl.StaticLoggerBinder</code>类无法加载到内存中。当在类路径上找不到合适的SLF4J绑定时，就会发生这种情况。将<em>slf4j-nop.jar</em> <em>slf4j-simple.jar</em> ， <em>slf4j-log4j12.jar</em> ， <em>slf4j-jdk14.jar</em>或<em>logback-classic.jar</em>中的一个（仅一个）放置在类路径上应该可以解决此问题。
    </p>

    <p>请注意，slf4j-api版本2.0.x和更高版本使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>机制。后端不支持logback 1.3和更高版本（例如slf4j-api 2.x） <code>org.slf4j.impl.StaticLoggerBinder</code> 。如果放置针对slf4j-api 2.0.x的日志记录后端，则需要在类路径上使用<em>slf4j-api-2.x.jar</em> 。另请参阅<a href="faq.html#changesInVersion18">相关的常见问题解答</a>条目。
    </p>


    <p><span class="label">从1.6.0开始，</span>从SLF4J 1.6版开始，在没有绑定的情况下，SLF4J将默认为无操作（NOP）记录器实现。
    </p>

    <p>如果您负责打包应用程序并且不关心日志记录，那么将<em>slf4j-nop.jar</em>放在应用程序的类路径中将摆脱此警告消息。请注意，诸如库或框架之类的嵌入式组件不应声明对任何SLF4J绑定的依赖关系，而只能依赖slf4j-api。当库声明对SLF4J绑定的编译时依赖性时，它会将绑定强加给最终用户，从而否定了SLF4J的目的。</p>

    
    <!-- ====================================================== -->
    <!-- duplicates /faq.html#IllegalAccessError -->

<!--
    <h3>
      <a name="illegalAccess" href="#illegalAccess">java.lang.IllegalAccessError: tried to access field
      org.slf4j.impl.StaticLoggerBinder.SINGLETON from class
      org.slf4j.LoggerFactory</a>
    </h3>

    <p>When this errors occurs, the exception looks as follows:</p>
    <p class="source">java.lang.IllegalAccessError: tried to access field org.slf4j.impl.StaticLoggerBinder.SINGLETON 
     from class org.slf4j.LoggerFactory
  at org.slf4j.LoggerFactory.<clinit>(LoggerFactory.java:60)
  ... </p>

    <p>The error is caused by the static initializer of the
    <code>LoggerFactory</code> class attempting to directly access the
    SINGLETON field of
    <code>org.slf4j.impl.StaticLoggerBinder</code>. While this was
    allowed in SLF4J 1.5.5 and earlier, in 1.5.6 and later the
    SINGLETON field has been marked as private access.
    </p>
    
    <p>From a broader perspective, this issue is a manifestation of
    problems encountered when mixing different versions of SLF4J
    artifacts.  Please also refer to the relevant <a
    href="faq.html#compatibility">FAQ entry</a>.
    </p>
-->

    <!-- ====================================================== -->
    <h3 class="doAnchor" name="multiple_bindings">在类路径上找到多个绑定</h3>


    <p>SLF4J API旨在一次绑定一个且仅一个基础日志框架。如果类路径上存在多个绑定，SLF4J将发出警告，列出这些绑定的位置。</p>

    <p>当类路径上有多个绑定时，请选择一个且仅选择一个您要使用的绑定，然后删除其他绑定。例如，如果您在类路径上同时具有<em>slf4j-simple-2.0.0-alpha0.jar</em>和<em>slf4j-nop-2.0.0-alpha0.jar</em> ，并且您希望使用nop（无操作）绑定，则将其删除类路径中的<em>slf4j-simple-2.0.0-alpha0.jar</em> 。
    </p>

    <p>SLF4J在此警告中提供的位置列表通常提供足够的信息，以标识依赖关系，该依赖关系可传递地将不需要的SLF4J绑定拉入项目。在声明不适当的依赖项时，请在项目的pom.xml文件中排除此SLF4J绑定。例如， <em>cassandra-all</em> 0.8.1版将<em>log4j</em>和<em>slf4j-log4j12</em>都声明为编译时依赖项。因此，当您在项目中包含<em>cassandra-all</em>作为依赖项时， <em>cassandra-all</em>声明将导致<em>slf4j-log4j12.jar</em>和<em>log4j.jar</em>都作为依赖项被拉入。如果您不想将log4j用作SLF4J后端，则可以指示Maven排除这两个工件，如下所示：</p>

    <pre class="prettyprint">&lt;dependencies>
  &lt;dependency>
    &lt;groupId> org.apache.cassandra&lt;/groupId>
    &lt;artifactId>cassandra-all&lt;/artifactId>
    &lt;version>0.8.1&lt;/version>

    &lt;exclusions>
      &lt;exclusion> 
        &lt;groupId>org.slf4j&lt;/groupId>
        &lt;artifactId>slf4j-log4j12&lt;/artifactId>
      &lt;/exclusion>
      &lt;exclusion> 
        &lt;groupId>log4j&lt;/groupId>
        &lt;artifactId>log4j&lt;/artifactId>
      &lt;/exclusion>
    &lt;/exclusions> 

  &lt;/dependency>
&lt;/dependencies></pre>

   <p><span class="label notice">注意</span> SLF4J发出的警告仅是警告。即使存在多个绑定，SLF4J也会选择一个日志记录框架/实现并与其绑定。SLF4J选择绑定的方式由JVM确定，出于所有实际目的，应将其视为随机的。从1.6.6版开始，SLF4J将命名其实际绑定到的框架/实现类。</p>

   <p>诸如库或框架之类的嵌入式组件不应声明对任何SLF4J绑定的依赖，而只能依赖slf4j-api。当库声明对SLF4J绑定的编译时依赖性时，它会将绑定强加给最终用户，从而否定了SLF4J的目的。当您遇到嵌入式组件声明对任何SLF4J绑定具有编译时依赖性时，请花点时间与该组件/库的作者联系，并请他们改正其方法。</p>
  
    <!-- ====================================================== -->

    <h3 class="doAnchor" name="version_mismatch">slf4j-api版本与绑定版本不匹配</h3>

    <p>SLF4J绑定指定了诸如<em>slf4j-jdk14.jar</em>或<em>slf4j-log4j12.jar之类的工件，</em>用于<em>将</em> slf4j <em>绑定</em>至基础日志框架，例如java.util.logging和log4j。
    </p>

    <p>混合使用不同版本的<em>slf4j-api.jar</em>和SLF4J绑定可能会导致问题。例如，如果您使用的是slf4j-api-2.0.0-alpha0.jar，则还应该使用slf4j-simple-2.0.0-alpha0.jar，而使用slf4j-simple-1.5.5.jar将不起作用。</p>

    <p><span class="label notice">注意</span>从客户端的角度来看，slf4j-api的所有版本都是兼容的。用<em>SLF4J-API N.jar</em>编译将与<em>SLF4J-API M.jar</em>运行完全正常的任何N和M你的客户端代码只需要确保的是，SLF4J-api.jar中的您结合匹配的版本。您不必担心项目中给定依赖项使用的slf4j-api.jar版本。您始终可以使用任何版本的<em>slf4j-api.jar</em> ，并且只要<em>slf4j-api.jar</em>的版本及其绑定匹配，就可以了。
    </p>

    <p>在初始化时，如果SLF4J怀疑可能存在api与绑定版本不匹配的问题，它将发出有关可疑不匹配的警告。
    </p>

    <!-- ====================================================== -->
    
    <h3 class="doAnchor" name="null_LF">记录工厂实现不能为空</h3>

    <p>当<code>LoggerFactory</code>类找不到适当的绑定。将<em>slf4j-nop.jar</em> ， <em>slf4j-simple.jar</em> ， <em>slf4j-log4j12.jar</em> ， <em>slf4j-jdk14.jar</em>或<em>logback-classic.jar</em>中的一个（只有一个）放置在类路径上应被证明是有效的补救措施。
    </p>

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="log4jDelegationLoop">在类路径上检测到log4j-over-slf4j.jar和slf4j-log4j12.jar，抢占<code>StackOverflowError</code> 。
    </h3>

    <p>slf4j-log4j12模块的目的是将对SLF4J记录器的调用委托或重定向到log4j。log4j-over-slf4j模块的目的是将对log4j记录器的调用重定向到SLF4J。如果SLF4J与<em>slf4j-log4j12.jar</em>绑定，并且在类路径上也存在<em>log4j-over-slf4j.jar，</em>则<code>StackOverflowError</code>不可避免地会在首次调用SLF4J或log4j记录器后立即发生。
    </p>

    <p>这是异常的样子：</p>

    <pre class="prettyprint source">Exception in thread "main" java.lang.StackOverflowError
  at java.util.Hashtable.containsKey(Hashtable.java:306)
  at org.apache.log4j.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:36)
  at org.apache.log4j.LogManager.getLogger(LogManager.java:39)
  at org.slf4j.impl.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:73)
  at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:249)
  at org.apache.log4j.Category.&lt;init>(Category.java:53)
  at org.apache.log4j.Logger..&lt;init>(Logger.java:35)
  at org.apache.log4j.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:39)
  at org.apache.log4j.LogManager.getLogger(LogManager.java:39)
  at org.slf4j.impl.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:73)
  at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:249)
  at org.apache.log4j.Category..&lt;init>(Category.java:53)
  at org.apache.log4j.Logger..&lt;init>(Logger.java:35)
  at org.apache.log4j.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:39)
  at org.apache.log4j.LogManager.getLogger(LogManager.java:39)
  subsequent lines omitted...</pre>

    <p><span class="label">从1.5.11版本开始，</span> SLF4J软件会引发异常并详细说明问题的实际原因，从而避免了不可避免的堆栈溢出错误。这被认为比让用户怀疑其原因要好。 <code>StackOverflowError</code> 。
    </p>

    <p>有关此主题的更多背景，请参阅<a href="legacy.html">桥接旧版API</a> 。</p>

    <!-- ====================================================== -->


    <h3 class="doAnchor" name="jclDelegationLoop">在类路径上检测到jcl-over-slf4j.jar和slf4j-jcl.jar，抢占<code>StackOverflowError</code> 。
    </h3>

    <p>slf4j-jcl模块的目的是将对SLF4J记录器的调用委托或重定向到雅加达公共记录（JCL）。jcl-over-slf4j模块的目的是将对JCL记录器的调用重定向到SLF4J。如果SLF4J与<em>slf4j-jcl.jar</em>绑定，并且<em>jcl-over-slf4j.jar</em>也存在于类路径中，则<code>StackOverflowError</code>不可避免地会在首次调用SLF4J或JCL记录器后立即发生。
    </p>

    <p>这是异常的样子：</p>

    <pre class="prettyprint source">Exception in thread "main" java.lang.StackOverflowError
  at java.lang.String.hashCode(String.java:1482)
  at java.util.HashMap.get(HashMap.java:300)
  at org.slf4j.impl.JCLLoggerFactory.getLogger(JCLLoggerFactory.java:67)
  at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:249)
  at org.apache.commons.logging.impl.SLF4JLogFactory.getInstance(SLF4JLogFactory.java:155)
  at org.apache.commons.logging.LogFactory.getLog(LogFactory.java:289)
  at org.slf4j.impl.JCLLoggerFactory.getLogger(JCLLoggerFactory.java:69)
  at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:249)
  at org.apache.commons.logging.impl.SLF4JLogFactory.getInstance(SLF4JLogFactory.java:155)
  subsequent lines omitted...</pre>


    <p><span class="label">从1.5.11版本开始，</span> SLF4J软件会引发异常并详细说明问题的实际原因，从而避免了不可避免的堆栈溢出错误。这被认为比让用户怀疑其原因要好。 <code>StackOverflowError</code> 。
    </p>

    <p>有关此主题的更多背景，请参阅<a href="legacy.html">桥接旧版API</a> 。</p>

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="no_static_mdc_binder">无法加载类“ org.slf4j.impl。StaticMDCBinder”</h3>
    
    <p>此错误表明在类路径上找不到适当的SLF4J绑定。将<em>slf4j-nop.jar</em> ， <em>slf4j-simple.jar</em> ， <em>slf4j-log4j12.jar</em> ， <em>slf4j-jdk14.jar</em>或<em>logback-classic.jar</em>中的一个（仅一个）放置在类路径上应该可以解决此问题。
    </p>

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="null_MDCA">MDCAdapter不能为null</h3>

    <p>在以下情况下报告此错误<code>org.slf4j.MDC</code>类尚未正确初始化。与前面列出的项目相同的原因和解决方法。
    </p>

  
    
   <!-- ====================================================== -->

    <h3 class="doAnchor" name="replay">在初始化阶段，已截获了（N）个日志调用，现在正在重播它们。这些受基础日志系统的过滤规则的约束。
    </h3>

    <p><span class="label">从1.7.15开始，在初始化</span>阶段进行记录调用，并在初始化后重放。请注意，重播的日志调用将受到基础日志系统的过滤。</p>

    <p>原则上，仅在第一次日志记录调用发生时对已经是多线程的应用程序进行重放。
    </p>

    <p>另请参见<a href="#substituteLogger">替代记录器</a> 。</p>
 
    <!-- ====================================================== -->

    <h3 class="doAnchor" name="substituteLogger">替代记录器是在基础记录系统的默认配置阶段创建的</h3>

    <p>高度可配置的日志记录系统（例如logback和log4j）可以创建在其自身初始化期间调用记录器的组件。有关典型情况，请参见问题<a href="http://jira.qos.ch/browse/LOGBACK-127">LOGBACK-127</a> 。但是，由于与SLF4J的绑定过程尚未完成（因为基础日志系统尚未完全加载到内存中），因此无法满足此类日志记录器创建请求。</p>

    <p>为了避免出现这种“鸡与蛋”的问题，SLF4J在此阶段（初始化）创建了替代记录器。在此阶段，对替代记录器的调用将被简单地丢弃。初始化完成后，替代记录器会将记录调用委派给适当的记录器实现，否则将用作由返回的任何其他记录器<code>LoggerFactory</code> 。
    </p>
  
    <p>如果必须创建任何替代记录器，SLF4J将发出此类记录器的清单。此列表旨在让您知道初始化期间对这些记录器进行的所有记录调用均已删除。
    </p>

    <p>另请参见<a href="#replay">截获和重播的日志记录调用</a> 。</p>
  
    <!-- ====================================================== -->

    <h3 class="doAnchor" name="log4j_version">SLF4J版本1.4.0及更高版本需要log4j 1.2.12或更高版本</h3>

    <p>跟踪级别已添加到2005年8月29日发布的1.2.12版本的log4j中。跟踪级别已于2007年5月16日添加到SLF4J API 1.4.0版中。因此，从SLF4J 1.4.0开始，SLF4J的log4j绑定需要log4j版本1.2.12或更高版本。
    </p>

    <p>但是，如<a href="http://jira.qos.ch/browse/SLF4J-59">第59期中所述</a> ，在某些环境中，可能难以升级log4j版本。为了适应这种情况，SLF4J的<code>Log4jLoggerAdapter</code>将TRACE级别映射为DEBUG。</p>

    <!-- ====================================================== -->

     <h3 class="doAnchor" name="log4j_version">java.lang。NoClassDefFoundError：org / slf4j / event / LoggingEvent</h3>

     <p>经典的Backback版本1.1.4和更高版本需要slf4j-api版本1.7.15或更高版本。
     </p>

     <p>在类路径中使用较早的slf4j-api.jar时，尝试自检由Logback版本1.1.4或更高版本返回的Logger实例将导致<code>NoClassDefFoundError</code>类似于以下所示。
     </p>
     
     <pre class="prettyprint source">Exception in thread "main" java.lang.NoClassDefFoundError: org/slf4j/event/LoggingEvent
        at java.lang.Class.getDeclaredMethods0(Native Method)
        at java.lang.Class.privateGetDeclaredMethods(Class.java:2451)
        at java.lang.Class.privateGetPublicMethods(Class.java:2571)
        at java.lang.Class.getMethods(Class.java:1429)
        at java.beans.Introspector.getPublicDeclaredMethods(Introspector.java:1261)
        at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1122)
        at java.beans.Introspector.getBeanInfo(Introspector.java:414)
        at java.beans.Introspector.getBeanInfo(Introspector.java:161)
    </pre>

    <p>将<em>slf4j-api.jar</em>版本1.7.15或更高版本放置在类路径中应该可以解决此问题。</p>
    
    <p>请注意，此问题仅在logback版本1.1.4和更高版本中发生，其他绑定（例如slf4j-log4j，slf4j-jdk14和slf4j-simple不受影响）。
    </p>
    

    <!-- ====================================================== -->


    <script src="templates/footer.js" type="text/javascript"></script>
  </div>
  


</body></html>