<html  xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>Log4j桥</title>
  <link rel="stylesheet" type="text/css" href="css/site.css" media="screen">
  <link rel="stylesheet" type="text/css" href="css/print.css" media="print">
</head>

<body  onload="decorate();">
  <script type="text/javascript">prefix='';</script>

  <script type="text/javascript" src="templates/header.js"></script>
  <script type="text/javascript" src="js/jquery-min.js"></script>
  <script type="text/javascript" src="js/decorator.js"></script>

  <div id="left">
    <script src="templates/left.js" type="text/javascript"></script>
  </div>
  <div id="content">
	

    <h2>桥接旧版API</h2>
    
    <p>通常，您依赖的某些组件依赖于SLF4J以外的日志API。您可能还假设这些组件在不久的将来不会切换到SLF4J。为了应对这种情况，SLF4J附带了几个桥接模块，这些模块会将对log4j，JCL和java.util.logging API的调用重定向为仿佛对SLF4J API进行的行为。下图说明了这个想法。
    </p>

    <p>请注意，对于您所控制的源代码，您确实应该使用<a href="migrator.html">slf4j-migrator</a> 。此页面中描述的基于二进制的解决方案适用于您无法控制的软件。
    </p>

    <p></p>
    <p></p>
    
    
    <p><a href="images/legacy.png">
    <img src="images/legacy.png" alt="点击放大" width="800">
    </a></p>
    
    <p>
    </p>
    
    <h2 class="doAnchor" name="jcl-over-slf4j">从Jakarta Commons Logging（JCL）逐步迁移到SLF4J</h2>
    
    <h4 class="doAnchor" name="jclOverSLF4J"><em>jcl-over-slf4j.jar</em></h4>
    
    <p>为了简化从JCL到SLF4J的迁移，SLF4J发行版包括jar文件<em>jcl-over-slf4j.jar</em> 。该jar文件旨在替代JCL 1.1.1版。它实现了JCL的公共API，但在下面使用了SLF4J，因此命名为“基于SLF4J的JCL”。</p>
    
    <p>我们的SCL4J之上的JCL实现将允许您逐步迁移到SLF4J，尤其是在您的软件所依赖的某些库在可预见的将来继续使用JCL的情况下。您可以立即享受SLF4J的可靠性，并同时保持向后兼容性。只需用<em>jcl-over-slf4j.jar</em>替换<em>commons-logging.jar</em> <em>即可</em> 。随后，将由SLF4J而不是JCL完成底层日志记录框架的选择， <a href="http://articles.qos.ch/classloader.html">但不会使JCL困扰类加载器</a> 。底层日志记录框架可以是SLF4J支持的任何框架。通常，用<em>jcl-over-slf4j.jar</em>替换<em>commons-logging.jar</em>将立即永久解决与Commons日志记录相关的类加载器问题。
    </p>
    
    <h3 class="doAnchor" name="slf4jJCL"><em>slf4j-jcl.jar</em></h3>
    
    <p>切换到SLF4J API后，我们的一些用户意识到在某些情况下必须使用JCL，因此他们使用SLF4J可能会成为问题。对于这种不常见但很重要的情况，SLF4J提供了一个JCL绑定，可以在文件<em>slf4j-jcl.jar中找到</em> 。JCL绑定会将通过SLF4J API进行的所有日志记录调用委托给JCL。因此，如果由于某种原因现有的应用程序<em>必须</em>使用JCL，则该应用程序的该部分仍可以以对大型应用程序环境透明的方式针对SLF4J API进行编码。您选择的SLF4J API对于继续使用JCL的其余应用程序是不可见的。</p>
    
    <h3 class="doAnchor" name="jclRecursion"><em>jcl-over-slf4j.jar</em>不应与<em>slf4j-jcl.jar</em>混淆</h3>
    
    
    <p>JCL-over-SLF4J（即<em>jcl-over-slf4j.jar</em> ）在出于向后兼容性原因而需要支持JCL的情况下非常有用。它可以用于解决与JCL相关的问题，而不必采用SLF4J API，该决定可以推迟到以后。
    </p>
    
    <p>另一方面， <strong>在</strong>为组件采用SLF4J API <strong>之后</strong> ， <em>slf4j-jcl.jar</em>很有用<strong>，</strong>该组件需要嵌入在JCL是正式要求的更大的应用程序环境中。您的软件组件仍然可以使用SLF4J API，而不会破坏大型应用程序。实际上， <em>slf4j-jcl.jar</em>会将所有日志记录决策委派给JCL，以便您的组件对SLF4J API的依赖关系对于更大的整体而言是透明的。
    </p>
    
    <p>请注意，不能同时部署<em>jcl-over-slf4j.jar</em>和<em>slf4j-jcl.jar</em> 。前一个jar文件将导致JCL将日志记录系统的选择委派给SLF4J，后一个jar文件将使SLF4J将日志记录系统的选择委派给JCL，从而导致<a href="codes.html#jclDelegationLoop">无限循环</a> 。
    </p>
    
    
    <h2 class="doAnchor" name="log4j-over-slf4j">log4j-over-slf4j</h2>
    
    <p>SLF4J附带了一个名为<em>log4j-over-slf4j</em>的模块。它允许log4j用户将现有应用程序迁移到SLF4J，而无需更改<em>任何代码，</em>而只需用<em>log4j-over-slf4j.jar</em>替换<em>log4j.jar</em>文件，如下所述。
    </p>
    
    <h4 class="doAnchor" name="losHow">它是如何工作的？</h4>
    
    <p>log4j-over-slf4j模块包含最广泛使用的log4j类的替换，即<code>org.apache.log4j.Category</code> ， <code>org.apache.log4j.Logger</code> ， <code>org.apache.log4j.Priority</code> ， <code>org.apache.log4j.Level</code> ， <code>org.apache.log4j.MDC</code>和<code>org.apache.log4j.BasicConfigurator</code> 。这些替换类将所有工作重定向到其相应的SLF4J类。
    </p>
    
    <p>要使用log4j的环比SLF4J在自己的应用程序，第一步是要找到，然后用<em>log4j的环比slf4j.jar</em>更换<em>log4j.jar。</em>请注意，您仍然需要SLF4J绑定及其依赖性，才能使log4j-over-slf4j正常工作。
    </p>
    
    <p>在大多数情况下，只需要替换jar文件即可从log4j迁移到SLF4J。</p>

    <p>请注意，作为此迁移的结果，将不再拾取log4j配置文件。如果您需要将log4j.properties文件迁移到logback，则<a href="http://logback.qos.ch/translator/">log4j转换器</a>可能会有所帮助。有关配置登录的信息，请参阅<a href="http://logback.qos.ch/manual/index.html">其手册</a> 。
    </p>
    
    <h4 class="doAnchor" name="losFail">什么时候不起作用？</h4>
    
    <p>当应用程序调用网桥中不存在的log4j组件时， <em>log4j-over-slf4j</em>模块将无法工作。例如，当应用程序代码直接引用log4j追加器，过滤器或PropertyConfigurator时，则log4j-over-slf4j不足以替代log4j。但是，通过配置文件配置log4j时，无论是<em>log4j.properties</em>还是<em>log4j.xml</em> ，log4j-over-slf4j模块都应该可以正常工作。
    </p>

    
    
    <h4 class="doAnchor" name="losOverhead">那开销呢？</h4>
    
    <p>使用log4j-over-slf4j代替直接使用log4j的开销相对较小。鉴于log4j-over-slf4j立即将所有工作委托给SLF4J，CPU开销应该可以忽略不计，约为几<em>纳秒</em> 。每个记录器都有一个与哈希映射中的条目相对应的内存开销，即使对于包含数千个记录器的超大型应用程序，这通常也应该是可以接受的。此外，如果您选择logback作为基础日志系统，并且考虑到logback比log4j快得多且内存效率更高，那么使用logback所获得的收益应该可以弥补使用log4j-over-slf4j而不是直接使用log4j的开销。
    </p>
    
    <h4 class="doAnchor" name="log4jRecursion">log4j-over-slf4j.jar和slf4j-log4j12.jar不能同时存在</h4>
    
    <p><em>slf4j-log4j12.jar</em>的存在（即SLF4J的log4j绑定）将强制将所有SLF4J调用委派给log4j。<em>log4j-over-slf4j.jar</em>的存在将把所有log4j API调用委派给它们的SLF4J等效项。如果两者同时存在，则slf4j调用将委派给log4j，而log4j调用将重定向到SLF4j，从而导致<a href="codes.html#log4jDelegationLoop">无限循环</a> 。
    </p>


    
    <h2 class="doAnchor" name="jul-to-slf4j">jul-to-slf4j桥</h2>
    
    <p><em>jul-to-slf4j.jar</em>工件包括一个java.util.logging（jul）处理程序，即<code>SLF4JBridgeHandler</code> ，它将所有传入的jul记录路由到SLF4j API。有关使用说明，请参见<a href="api/org/slf4j/bridge/SLF4JBridgeHandler.html">SLF4JBridgeHandler javadocs</a> 。
    </p>

    <p><span class="label notice">关于性能的说明</span>与其他桥接模块（分别重新实现JCL和log4j的jcl-over-slf4j和log4j-over-slf4j）相反，jul-to-slf4j模块不会重新实现java.util.logging，因为java下的软件包。*名称空间无法替换。相反，jul-to-slf4j会将<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/logging/LogRecord.html?is-external=true">LogRecord</a>对象转换为它们的SLF4J等效项。请注意，此翻译过程会产生构建<code>LogRecord</code>实例，无论是否为给定级别禁用了SLF4J记录器。<b>因此，从Jul到SLF4J的转换会严重增加禁用的日志记录语句的成本（60倍或6000％），并显着影响已启用的日志语句的性能（总体增加20％）。</b>随着版本的logback 0.9.25，它可以完全消除的帮助下禁用日志报表的60倍转换开销<a href="http://logback.qos.ch/manual/configuration.html#LevelChangePropagator">LevelChangePropagator</a> 。
    </p>

    <p>如果您担心应用程序的性能，请使用<code>SLF4JBridgeHandler</code>仅在以下两个条件之一为真时才适用：</p>
    <ol>
      <li>几乎没有日志记录语句</li>
      <li><code>LevelChangePropagator</code>已安装</li>
    </ol>
    
    
    <h4 class="doAnchor" name="julRecursion">jul-to-slf4j.jar和slf4j-jdk14.jar不能同时存在</h4>
    
    <p>slf4j-jdk14.jar的存在（即SLF4J的jul绑定）将强制将SLF4J调用委派给jul。另一方面，通过调用“ SLF4JBridgeHandler.install（）”，存在jul-to-slf4j.jar以及SLF4JBridgeHandler的安装会将jul记录路由到SLF4J。因此，如果两个jar同时存在（并且已安装SLF4JBridgeHandler），则slf4j调用将委派给jul，jul记录将路由到SLF4J，从而导致无限循环。
    </p> 
    

    <script  src="templates/footer.js" type="text/javascript"></script> 
  </div> 
 

</body></html>