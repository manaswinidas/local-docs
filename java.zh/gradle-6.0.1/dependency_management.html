<html lang="en-US" ><head></head><body class="book" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>学习基础</title>
<style>
/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Lato (normal, regular) */
@font-face {
    font-family: Lato;
    font-weight: 400;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-normal/lato-normal.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-normal/lato-normal.woff") format("woff");
}
/* Lato (normal, italic) */
@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: 400;
    font-style: italic;
    src: url("https://assets.gradle.com/lato/fonts/lato-normal-italic/lato-normal-italic.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-normal-italic/lato-normal-italic.woff") format("woff");
}
/* Lato (bold, regular) */
@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: 500;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff") format("woff");
}
/* Lato (bold, regular) */
@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: 800;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-heavy/lato-heavy.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-heavy/lato-heavy.woff") format("woff");
}


/* BEGIN asciidoc.css */

/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white; color: rgba(0, 0, 0, 0.8); padding: 0; margin: 0; font-family: "Noto Serif", "DejaVu Serif", serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: #7a2518; font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #2156a5; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Open Sans", "DejaVu Sans", sans-serif; font-weight: 300; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.0125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddddd8; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; font-weight: normal; color: rgba(0, 0, 0, 0.9); }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }

blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; }
    h1 { font-size: 2.75em; }
    h2 { font-size: 2.3125em; }
    h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
    h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #f7f8f7; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }

body { tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; word-spacing: -0.05em; }
h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong { font-weight: 400; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; background-color: #f7f7f8; -webkit-border-radius: 4px; border-radius: 4px; line-height: 1.45; text-rendering: optimizeSpeed; word-wrap: break-word; }
*:not(pre) > code.nobreak { word-wrap: normal; }
*:not(pre) > code.nowrap { white-space: nowrap; }

pre, pre > code { line-height: 1.45; color: rgba(0, 0, 0, 0.9); font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace; font-weight: normal; text-rendering: optimizeSpeed; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: rgba(0, 0, 0, 0.8); }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: rgba(0, 0, 0, 0.9); }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddddd8; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddddd8; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddddd8; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #ddddd8; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #efefed; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #7a2518; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
    body.toc2 { padding-left: 15em; padding-right: 0; }
    #toc.toc2 { margin-top: 0 !important; background-color: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #efefed; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
    #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
    #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
    #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
    #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
    body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
    body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #efefed; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
    #toc.toc2 { width: 20em; }
    #toc.toc2 #toctitle { font-size: 1.375em; }
    #toc.toc2 > ul { font-size: 0.95em; }
    #toc.toc2 ul ul { padding-left: 1.25em; }
    body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: rgba(0, 0, 0, 0.8); padding: 1.25em; }

#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #efefed; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1rem; font-style: italic; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: rgba(0, 0, 0, 0.85); }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: initial; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddddd8; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; text-align: center; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #f7f7f8; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 1em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #f7f7f8; background-color: rgba(0, 0, 0, 0.9); }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock pre.prettyprint { border-width: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.45; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddddd8; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #7a2518; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid rgba(0, 0, 0, 0.6); }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: rgba(0, 0, 0, 0.6); }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.6; background: #f7f8f7; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 1.25em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:first-of-type img { max-width: initial; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.05em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

dt, th.tableblock, td.content, div.footnote { text-rendering: optimizeLegibility; }

h1, h2, p, td.content, span.alt { letter-spacing: -0.01em; }

p strong, td.content strong, div.footnote strong { letter-spacing: -0.005em; }

p, blockquote, dt, td.content, span.alt { font-size: 1.0625rem; }

p { margin-bottom: 1.25rem; }

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }

.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }

.print-only { display: none !important; }

@media print { @page { margin: 1.25cm 0.75cm; }
    * { -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
    a { color: inherit !important; text-decoration: underline !important; }
    a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
    a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
    abbr[title]:after { content: " (" attr(title) ")"; }
    pre, blockquote, tr, img, object, svg { page-break-inside: avoid; }
    thead { display: table-header-group; }
    svg { max-width: 100%; }
    p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
    h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
    #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
    #toc { border-bottom: 1px solid #ddddd8 !important; padding-bottom: 0 !important; }
    .sect1 { padding-bottom: 0 !important; }
    .sect1 + .sect1 { border: 0 !important; }
    #header > h1:first-child { margin-top: 1.25rem; }
    body.book #header { text-align: center; }
    body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
    body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
    body.book #header .details span:first-child { margin-left: 0 !important; }
    body.book #header .details br { display: block; }
    body.book #header .details br + span:before { content: none !important; }
    body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
    body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
    .listingblock code[data-lang]:before { display: block; }
    #footer { background: none !important; padding: 0 0.9375em; }
    #footer-text { color: rgba(0, 0, 0, 0.6) !important; font-size: 0.9em; }
    .hide-on-print { display: none !important; }
    .print-only { display: block !important; }
    .hide-for-print { display: none !important; }
    .show-for-print { display: inherit !important; } }

/* END asciidoc.css */

html,
body {
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px;
    font-weight: 400;
    line-height: 1.5;
}

body {
    color: #02303A;
    background-color: #f7f7f8;
    font-family: "Lato", "Helvetica Neue", Arial, sans-serif;
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
}

/* Links */
a {
    color: #1DA2BD;
    text-decoration: none;
}

a:hover,
a:focus {
    text-decoration: underline;
}

#content a[href^='../dsl/'],
#content a[href^='../javadoc/'] {
    font-family: 'Inconsolata', monospace;
    font-style: normal;
    border-bottom: 1px dotted rgba(29, 162, 189, 0.5);
    padding: 0 1px;
}

#content a[href^='../dsl/']:hover,
#content a[href^='../dsl/']:focus,
#content a[href^='../javadoc/']:hover,
#content a[href^='../javadoc/']:focus {
    text-decoration: none;
}

/* Copy */

p {
    font-size: 1rem;
}

pre,
pre > code,
code {
    font-family: 'Inconsolata', monospace;
}

h1,
h2,
h3,
h4,
h5,
h6,
#toctitle,
.sidebarblock > .content > .title {
    font-family: inherit;
    font-weight: 500;
    color: inherit;
}

h1 {
    font-size: 2rem;
}

h2 {
    font-size: 1.5rem;
}

h3 {
    font-size: 1.125rem;
}

h4 {
    font-size: 1.0625rem;
}

h5, h6 {
    font-size: 1rem;
}

b, strong {
    font-weight: 500;
}

dl {
    margin: 0 0 1.25rem 1.5rem;
}

.dlist dt code {
    color: #02303A;
    font-size: 1em;
    font-weight: bold;
}

.dlist p {
    margin-bottom: 0.625rem;
}

.sr-only {
    border: 0;
    clip: rect(0, 0, 0, 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
}

/* Layout */
.main-content > .appendix,
.main-content > .book,
.main-content > .chapter,
.main-content > .footer {
    background-color: white;
    border-radius: 5px;
    max-width: 45rem;
    padding: 1.5rem;
}

@media screen and (max-width: 45em) {
    .footer {
        max-width: 100%;
    }

    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        margin-top: 0;
        margin-bottom: 0;
    }
}

/* Override asciidoc styles */
#header {
    position: static;
}

#header, #content {
    padding: 0;
}

#header .details {
    /* TODO: Pretty sure there's a way to avoid Asciidoc generating details */
    display: none;
}

p {
    color: #02303A;
}

h1,
h2,
p,
p strong,
td.content,
td.content strong,
div.footnote strong,
span.alt {
    letter-spacing: normal;
}

.subheader,
.admonitionblock td.content > .title,
.audioblock > .title,
.exampleblock > .title,
.imageblock > .title,
.listingblock > .title,
.literalblock > .title,
.stemblock > .title,
.openblock > .title,
.paragraph > .title,
.quoteblock > .title,
table.tableblock > .title,
.verseblock > .title,
.videoblock > .title,
.dlist > .title,
.olist > .title,
.ulist > .title,
.qlist > .title,
.hdlist > .title {
    color: inherit;
    font-family: inherit;
}

.listingblock .title,
.listingblock .title code {
    font-style: normal;
    font-weight: bold;
}

#content .admonitionblock .icon .title {
    color: transparent;
    font-size: 3.5em;
    text-shadow: 0 0 #00c489;
    opacity: 0.7;
}

.admonitionblock td.content > .title {
    font-family: inherit;
    font-style: normal;
    font-size: 1.25em;
    color: #555;
}

.admonitionblock table tr td {
    padding: 0;
}

.imageblock,
.videoblock {
    padding: 0.25em;
}

p.lead,
.paragraph.lead > p,
#preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: 1.0625rem;
}

.paragraph.lead > p,
#preamble > .sectionbody > .paragraph:first-of-type p {
    color: inherit;
}

.sect1 {
    padding-bottom: 0;
}

.sect1 + .sect1 {
    border: 0 none;
}

.admonitionblock .icon .title {
    font-size: 2.3em;
}

.admonitionblock > table td.icon .title {
    font-family: "Lato", Arial, sans-serif;
}

.admonitionblock .content,
.admonitionblock p {
    color: #666;
}

.verseblock pre {
    font-family: "Lato", Arial, sans-serif;
}

td.hdlist1 {
    padding-bottom: 0.625rem;
}

td.hdlist2 p {
    margin-bottom: 0.625rem;
}

body.book #header > h1 {
    border: 0;
}

#header > h1:first-child {
    margin-top: 0;
}

#content a.link {
    color: #02303A;
}

.highlight .com {
    color: #777;
}

.listingblock pre.highlightjs > code {
    overflow-x: auto;
}

.listingblock pre.highlight {
    overflow-x: auto;
}

.listingblock pre.highlight > code {
    white-space: pre;
}

.conum[data-value] {
    font-family: "Lato", Arial, sans-serif;
}

.colist > table tr > td:first-of-type {
    padding-top: 0.25em;
    padding-bottom: 0.25em;
    line-height: 1.4;
    vertical-align: baseline;
}

/*
 * Samples
 */
.exampleblock > .content {
    background-color: inherit;
    border: 0 none;
    box-shadow: none;
    padding: 0;
}

.exampleblock > .content .title {
    background-color: #f7f7f8;
    border-top: 1px solid #ccc;
    font-family: 'Inconsolata', monospace;
    margin: 0;
    padding: 1em 1em 0;
}

.exampleblock .listingblock {
    margin: 0;
}

/* Multi-language selection */
.multi-language-selector .language-option[data-lang='groovy'],
.exampleblock[data-lang=groovy] > .content .title {
    background-image: url('data:image/svg+xml;base64,PHN2Zw0KICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIg0KICAgd2lkdGg9IjYxNC4wNjA4NSINCiAgIGhlaWdodD0iMzAzLjU5ODYiDQogICB2ZXJzaW9uPSIxLjEiPg0KICA8Zw0KICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzUuMzk2NTk5LC0zMC41NTgxOTYpIj4NCiAgICA8cGF0aA0KICAgICAgIGQ9Im0gMTU0Ljk3Njg3LDMzMi42OTE2MiBjIDAsLTAuODA1ODcgMTAuODMxMjMsLTE4LjYyMTcyIDI0LjA2OTQsLTM5LjU5MDc2IDEzLjIzODE5LC0yMC45NjkwNSAyMi42NjA1NywtMzguNjIwNjYgMjAuOTM4NjcsLTM5LjIyNTc3IC0xLjcyMTkxLC0wLjYwNTEgLTcuNjc5OTIsMC40ODU2NyAtMTMuMjQwMDIsMi40MjM5MyAtMTYuNzQ1MjQsNS44Mzc0MyAtMjAuMTg2MDUsNC4yOTAxNiAtMzIuNjkzMDgsLTE0LjcwMTU1IC0xMy41MzI2NSwtMjAuNTQ5MDYgLTE0LjAxNzI0LC0yMi42Njk4MyAtNi45NjE1OCwtMzAuNDY2MjQgNC42MDg3NiwtNS4wOTI1NiA0LjMzMTU5LC02LjI3OTY3IC0zLjIzMTksLTEzLjg0MzE2IC00LjU1MDA5LC00LjU1MDEgLTguMjcyODksLTkuNjQzMDkgLTguMjcyODksLTExLjMxNzc2IDAsLTIuODE2NzkgLTMwLjk5MTQ1LC0xNS41ODkzMyAtNzkuOTg5NDk2LC0zMi45NjYxNSAtMTEuMTA5NjYsLTMuOTM5OTcgLTIwLjE5OTM3NSwtNy44MjkyOCAtMjAuMTk5Mzc1LC04LjY0MjkxIDAsLTAuODEzNjYgMjMuNDcwNzM4LC0xLjAwNDc2IDUyLjE1NzE5MSwtMC40MjQ2OSBsIDUyLjE1NzIxLDEuMDU0NjYgNS4wOTEyNywtOC4wMzAwMSBjIDIxLjUxNjQ0LC0zMy45MzU5MiA1NC4wMDk1MiwtNjQuNTg4MjEyIDY4LjQ2NzA1LC02NC41ODgyMTIgMy4wMTA2LDAgOS4xMjE0MSwyLjg2OTE4IDEzLjU3OTUzLDYuMzc1OTQ1IDcuMjU5NDYsNS43MTAyODMgOC4yNTY1LDkuMjQ4NjMyIDkuNTQ5OTQsMzMuODkxOTY3IDAuNzk0MywxNS4xMzM4MiAyLjQyNDIyLDI4LjQ5NjAxIDMuNjIxOTgsMjkuNjkzNzkgMS4xOTc3NSwxLjE5Nzc2IDQuOTk3NjksLTAuMzc0MjUgOC40NDQzMSwtMy40OTMzOSA0LjQwMTQsLTMuOTgzMjMgOS4wMzQ4NCwtNS4wNjMxMyAxNS41Njc2MSwtMy42MjgzIDYuNzY3NTYsMS40ODY0MSAxMC42MjcxLDAuNDY4OTUgMTQuMTY5MzgsLTMuNzM1NDMgNS4zMTM2LC02LjMwNjY2IDMxLjkwNTk2LC00OC45MzcyMDEgMzEuOTA1OTYsLTUxLjE0ODc0NCAwLC0wLjc1MTU4OCA1LjI2NTA5LC05Ljc1NzMwNiAxMS43MDAyMywtMjAuMDEyNzAzIDYuNDM1MDksLTEwLjI1NTM5NyAxMy44NDY2NCwtMjIuMDgwNjMxIDE2LjQ3MDA3LC0yNi4yNzgyODMgNC42NjU1OCwtNy40NjUyMDEgNS4zOTY2LC02LjU4MTczNSAzMy40MjY5Miw0MC4zOTg3MzYgMjguOTQxMjEsNDguNTA3MTY0IDQ0LjUxNzY3LDY2LjQwNjU1NCA1Mi4zMTU3LDYwLjExNzYzNCA1LjQ0MiwtNC4zODg4OSAzNC4wMDA1NSwtNC42Mzc5NCA0MS45ODI0NiwtMC4zNjYxNCA0LjUzNjY1LDIuNDI3OTMgNy40MTkxNiwyLjM5NjEgOS45MjQ4NCwtMC4xMDk2MiA1LjIwMDA3LC01LjIwMDA2IDE3LjY0OTgyLC00LjI5NDM3IDIwLjkwNDEyLDEuNTIwNzggMi41NjM5Myw0LjU4MTQ2IDMuMjE3ODQsNC41ODE0NiA3LjAyMDE0LDAgMi4zMDYwNiwtMi43Nzg2NyA5LjEzNjE5LC01LjA1MjA4IDE1LjE3ODAzLC01LjA1MjA4IDguNTM4ODQsMCAxMS43OTMzNiwxLjc3MzY3IDE0LjYxNDAzLDcuOTY0MzcgbCAzLjYyODgxLDcuOTY0MzYgNTYuMDkyMDMsLTEuOTg1OCBjIDMwLjg1MDYyLC0xLjA5MjIyIDU2LjA5MjA0LC0xLjI4Njg4IDU2LjA5MjA0LC0wLjQzMjU1IDAsMC44NTQyNyAtMjIuOTA2MDgsMTAuMDcxOTUgLTUwLjkwMjQxLDIwLjQ4MzcxIC0yNy45OTYzMiwxMC40MTE3MiAtNTEuMzY3LDE5LjI0MzA1IC01MS45MzQ4NCwxOS42MjUxMiAtMC41Njc4NSwwLjM4MjA3IDAuNjk4NDcsOS40OTI3MyAyLjgxNDA1LDIwLjI0NTg4IDUuNTA0NTcsMjcuOTc5MTcgMS45MTQ1OCw0Ni42MjU4OSAtMTEuOTI2MjksNjEuOTQ2MDQgLTYuMjA5LDYuODcyNjMgLTE2LjI4MzM4LDE0LjE0Mzk1IC0yMi4zODc1MywxNi4xNTg0OSAtNi4xMDQxNSwyLjAxNDU0IC0xMS4wOTg0NCw0LjM4NjE0IC0xMS4wOTg0NCw1LjI3MDE5IDAsMC44ODQwNiA2LjUxNTI1LDExLjY3ODkzIDE0LjQ3ODM1LDIzLjk4ODU5IDcuOTYzMDksMTIuMzA5NjkgMTMuMjgyOCwyMi4zODEyNSAxMS44MjE1MiwyMi4zODEyNSAtMi4zODUwNCwwIC02MC40Njk4NywtMjIuNDQyMzggLTE1MC43ODg5OCwtNTguMjYwNyAtMTcuODA5LC03LjA2MjU4IC0zNC4wMjY4MywtMTIuODQxMDkgLTM2LjAzOTYxLC0xMi44NDEwOSAtMy43NTM2MywwIC0zNi4xNjY5LDEyLjI4NjYyIC0xMzEuMjI0MjMsNDkuNzQyMDYgLTU1LjEyNTI1LDIxLjcyMTAzIC01Ny4yOTIxNywyMi40NzM0OCAtNTcuMjkyMTcsMTkuODk0NTEgeiBtIDExMy4xMTY0OCwtNTEuMjUyNjUgYyAyOS4zMjk0OSwtMTEuMzk1MDYgNTguNDE2NTcsLTIyLjUzMDggNjQuNjM3OTgsLTI0Ljc0NjA3IDEwLjcwMDY4LC0zLjgxMDE5IDE0LjI3OTE4LC0yLjg1NDkzIDY2LjI1Mzk0LDE3LjY4NjM0IDMwLjIxODI1LDExLjk0Mjc0IDYwLjAzMjUyLDIzLjU3NTg3IDY2LjI1MzkyLDI1Ljg1MTM0IDYuMjIxNDEsMi4yNzU1MiAxOS4wNDMxNyw3LjIyMDU5IDI4LjQ5Mjc1LDEwLjk4OTA4IDEwLjc3NTAzLDQuMjk3MDQgMTYuMjgyNTEsNS4zMzE2NiAxNC43NzEwOCwyLjc3NDg0IC0xNi44ODM3LC0yOC41NjExMyAtMTcuMzk5OCwtMjkuMDM3MTYgLTI5LjEwMDgzLC0yNi44NDIwNSAtMTQuMTEzNjEsMi42NDc3MiAtMjIuODc4OTcsLTAuMDY4NSAtMjcuMzgzNjksLTguNDg1NTQgLTIuOTIxMTIsLTUuNDU4MTYgLTIuMDI5NDQsLTguMTI3NTkgNS4yNTQ0MiwtMTUuNzMwMzEgMTAuODQ4ODcsLTExLjMyMzc3IDkuMTQ0NTcsLTIxLjc0MTQ0IC00Ljg0NDI5LC0yOS42MTA5OSAtNS4zNjc2NCwtMy4wMTk1OSAtMTIuMTQwNTksLTEwLjQ4MzcyIC0xNS4wNTEwMiwtMTYuNTg2OTcgbCAtNS4yOTE2OSwtMTEuMDk2ODIgLTExLjM0NTUxLDcuNjk5MjggYyAtMTMuOTQ0NTgsOS40NjMwNCAtMzAuOTUwNjIsOS45NTA2MyAtNDUuMTQ3NjQsMS4yOTQ0OCBsIC0xMC40NjQ4OCwtNi4zODA2NSAtMTIuMTU4NDEsOC4yNjI4NCBjIC0xMi4xNzQ2Miw4LjI3Mzg2IC0yNi4xOTEwOCw5LjM0MjggLTQwLjQzNzUyLDMuMDgzOTIgLTMuOTI0OTgsLTEuNzI0MzkgLTUuNjU1ODMsLTEuMDU0MTUgLTUuNjU1ODMsMi4xOTAwOCAwLDIuNTcxMTggLTMuNzA0MjksNi4zNjI2NSAtOC4yMzE4MSw4LjQyNTUzIC0xMy41NzQyLDYuMTg0NzkgLTI2LjgyMTA3LDQuNTQyNDcgLTM1LjgwMjI5LC00LjQzODc1IGwgLTguMTg5NDQsLTguMTg5NDQgLTYuNjA5ODIsOC40MDMwMyBjIC0zLjYzNTM5LDQuNjIxNjYgLTEyLjA0OTUyLDExLjgzNjk4IC0xOC42OTgwNSwxNi4wMzM5OCAtOC4yMjk2NSw1LjE5NTE4IC0xOC40MTc0MSwxNy44NzE4MiAtMzEuOTE2NCwzOS43MTM2MSAtMTAuOTA1NDksMTcuNjQ1NDYgLTE5LjgyODE2LDMyLjk4MDQyIC0xOS44MjgxNiwzNC4wNzc3NiAwLDEuMDk3MyA4LjM2MjU1LC0xLjUyNzM2IDE4LjU4MzQyLC01LjgzMjU5IDEwLjIyMDg5LC00LjMwNTIxIDQyLjU4MDI4LC0xNy4xNTA4NyA3MS45MDk3NywtMjguNTQ1OTMgeiBtIDI0OC43NjcyOSwtMTIuMjU4NDYgYyAyMi4yNTU1NywtMTIuNTA4MzMgMjcuNDE0MjQsLTM1LjY0ODA4IDE3LjU3Njg1LC03OC44NDMxOCAtOC4yMjE0LC0zNi4wOTk2MSAtMTIuMzI1NSwtNDcuOTEzMjcgLTE3LjE5NDk0LC00OS40OTU5NyAtMy4zNjkwMiwtMS4wOTUwMyAtMy44ODY3NCwwLjEwNjk5IC0xLjk4ODU4LDQuNjE2MzUgMTIuMzE1MTYsMjkuMjU3NzEgMTIuOTk5NjMsNDMuOTQ2NjIgMi4yNDAyMiw0OC4wNzU0MSAtNy4zOTE1MSwyLjgzNjQyIC0xNS4yMzIzOSwtNy43OTA3NSAtMjEuMzk5MDIsLTI5LjAwMzI2IC00Ljc3NTEyLC0xNi40MjU4NyAtOS43Njg2MSwtMjMuODI4MzcgLTEzLjUzMzg3LC0yMC4wNjMxMSAtMC45MDE1NywwLjkwMTYgMC42Nzg0OCw2LjEyMTE3IDMuNTExMjQsMTEuNTk5MTMgMi44MzI3Myw1LjQ3NzkgNi43MTcyMSwyMS45NzQ1NSA4LjYzMjE3LDM2LjY1OTIgMS45MTQ5NywxNC42ODQ2MiA1LjYxMzg1LDMwLjA2MDczIDguMjE5NzMsMzQuMTY5MTIgNi43NzE5OCwxMC42NzY2MSAxNy41NTEyOCw4LjEwMzYgMjQuNTIzODIsLTUuODUzODQgNi44OTM3MywtMTMuNzk5NzUgNy42NzI4NCwtNC42MDc4MSAwLjk2OTMsMTEuNDM2MDIgLTYuOTYwNzQsMTYuNjU5MzcgLTI3LjYzNDQyLDIxLjY1NDgxIC01MS41ODQxOCwxMi40NjQ0MiAtMy44MzMzLC0xLjQ3MDk2IC01LjEzMDM5LDAuMDUxNSAtNS4xMzAzOSw2LjAyMDk3IDAsNC4zOTQzMSAtMi45MzYxOCwxMS43MjI0NSAtNi41MjQ4OCwxNi4yODQ3IGwgLTYuNTI0ODgsOC4yOTUwNiA4Ljk0ODgxLDEuNTExMjMgYyAxNS40NDk0NSwyLjYwOTA5IDM2LjYzMzI4LC0wLjc3NjQyIDQ5LjI1ODYsLTcuODcyMjUgeiBtIC0zMjAuMzY2NSwtMjcuNTM3MzMgYyA0Ni40NTk2NSwtMTMuMzU0NSA1NC43NjE4OCwtMjguOTMwOTMgMzkuMzI4ODUsLTczLjc4NzgyIC0zLjU4MTg1LC0xMC40MTA3OSAtNi41MTI0MywtMjEuNjA5NzEgLTYuNTEyNDMsLTI0Ljg4NjU0IDAsLTExLjE1NzEyIC01LjYxMTUyLC02LjAwMTYxIC05LjgxNzEzLDkuMDE5NDMgLTUuNTYyMDMsMTkuODY1NjEgLTIyLjI5MTE1LDM2Ljc1MDUzIC0zNi4zNDUxNiwzNi42ODM2NCAtMTIuMjA1NDcsLTAuMDU4MiAtMTYuMTgyNTEsLTIuMjgwMDggLTIxLjIyMzc4LC0xMS44NTc2OCAtOS4wNDc0OCwtMTcuMTg4ODIgMC44MTQ2OSwtNDMuNTY3OTcgMjUuOTY5NTQsLTY5LjQ2MjcyIDE4LjQyNDMxLC0xOC45NjYzMDQgMjguNDg4OTMsLTIwLjY4Mzk2NSAyOC40ODg5MywtNC44NjIwNSAwLDI0LjY3MzIgLTE3LjAxMTM0LDYwLjk5NDcgLTI1Ljk3MzA5LDU1LjQ1NjA0IC00LjM4MjA1LC0yLjcwODI2IC0zLjY3MTM4LC0xNC42Njc1MiAxLjQxNzIyLC0yMy44NTAwOSA0LjMyNzM1LC03LjgwODgyIDMuNDQ4MTQsLTE5LjcwNzcxIC0xLjQ1NjIsLTE5LjcwNzcxIC01LjY4Njg5LDAgLTE2Ljk0NTQ3LDIwLjcxMTk2IC0xOC40MzMxOCwzMy45MTA3NCAtMS4zMTUxNSwxMS42NjgyNiAtMC40OTI4NiwxNC41MDU0NSA1LjA2NjUyLDE3LjQ4MDcyIDE5LjQ4MjQ0LDEwLjQyNjcgNDUuMDA1MzEsLTIxLjM5NTQ1IDQ2LjI5MDgzLC01Ny43MTU4NCAwLjY3NTA0LC0xOS4wNzMxODEgLTMuMDE2NzYsLTI0LjQ0MTEwNSAtMTQuNzc5MDYsLTIxLjQ4ODk1MSAtMTcuMTE4NzksNC4yOTY1NDMgLTYzLjIzNDgzLDYzLjc4NjY0MSAtNjMuMjM0ODMsODEuNTczNDYxIDAsMTMuOTEyOCA2Ljk4NzM3LDIzLjY5NzI4IDE5LjI4ODI3LDI3LjAwOTYgMjAuOTE0MTksNS42MzE2MiA0MS4xMzUzOSwtNC4zNzM4OSA1NS40NjMzLC0yNy40NDMzOCBsIDYuMDIxNzUsLTkuNjk1NzEgMC4wMTMyLDEzLjE3MjIzIGMgMC4wMTYyLDE5LjA3MzggLTEyLjQyNjE5LDI5LjEyNzQgLTUxLjY5ODE3LDQxLjc2NzkzIC05Ljc3NjQ5LDMuMTQ2OCAtMTguMTgzMzIsNi4wNTQ0MSAtMTguNjgxOCw2LjQ2MTM3IC0xLjgyMDU2LDEuNDg2MzIgMTYuNjg3MzksMjcuNDc1NzEgMTkuNTY2NDQsMjcuNDc1NzEgMS42MzI2MiwwIDExLjE5MTE1LC0yLjM2MzU5IDIxLjI0MTIzLC01LjI1MjM4IHogTSA0NzYuNDExLDIxNy45NjMwMSBjIDQuNjYzNDcsLTUuMTUzMSA1LjQ4NTUxLC0xMC43NTEwMyA0LjQ4NTc5LC0zMC41NDgyMyAtMS4wODczOSwtMjEuNTMzMzEgLTIuMjc3NDYsLTI1LjMzODUxIC0xMC42NjE0MywtMzQuMDg5NDkgLTE1LjE0ODgyLC0xNS44MTE5NCAtMzMuODYxMjMsLTExLjc3ODI4IC0yMi45MDgxOSw0LjkzODE0IDUuODIyNTYsOC44ODYzNyAxMi45MjU0LDcuMzY4NjQgMTAuNDE2NDEsLTIuMjI1ODEgLTEuOTk4NjQsLTcuNjQyNzYgMS43Mjk5OCwtNy44NDM1OCA4LjIyODM5LC0wLjQ0MzIyIDEyLjE5MzAxLDEzLjg4NTM3IDkuMTE1MzQsMzMuMTI2OTggLTUuMjk4NiwzMy4xMjY5OCAtOS44NjcxNiwwIC0xMi45NDE5NSwtNC4yMzE3NiAtMTkuMzczNTMsLTI2LjY2MzE4IC0yLjkzMDU5LC0xMC4yMjA4NyAtNi40OTk2NCwtMTguNTgzNDMgLTcuOTMxMjcsLTE4LjU4MzQzIC00Ljc2ODk5LDAgLTYuODkyODcsNC4yMDg3OCAtMy45MjcyMSw3Ljc4MjQgMS42MTA4OCwxLjk0MTEgNi4wNzIxOCwxNS44OTEyNyA5LjkxNDA0LDMxLjAwMDQxIDkuNjY5MDMsMzguMDI1OTYgMjMuMTc2NjYsNTEuMDQxNDUgMzcuMDU1NiwzNS43MDU0MyB6IG0gLTE4My43NzEyNSwwLjYwMzk1IGMgMS45ODk3OCwtMS4zMzUgMi44OTk3NSwtNy42NDg5MyAyLjA3ODY1LC0xNC40MjMgLTEuMzI0NDksLTEwLjkyNzAyIC0yLjA2NjYyLC0xMS43MjQxIC03Ljk3MjcsLTguNTYzMjcgLTguNDg3MzMsNC41NDIyNyAtMTcuNjA4MzksLTQuMDYzNTEgLTIwLjcwMjIyLC0xOS41MzI2IC0yLjM0NzA3LC0xMS43MzUzOCAtMy4wNjUyNiwtMTEuNTA0ODkgMTQuMDI1NzYsLTQuNTAxNDkgMi4xNDI4OCwwLjg3ODA4IDcuNTk2NzEsLTIuMTA0MDIgMTIuMTE5NjMsLTYuNjI2OTQgOC4yNzQwOCwtOC4yNzQwOCAxMC45OTgwMiwtMTguMjEyOTkgNC45OTE1NiwtMTguMjEyOTkgLTEuNzc3NTQsMCAtMy4yMzE5LDEuNDU0MzYgLTMuMjMxOSwzLjIzMTkgMCw0LjY0OTIzIC04Ljg0MjMxLDMuOTg5ODIgLTEwLjgzNDY1LC0wLjgwNzk3IC0xLjE2MjI0LC0yLjc5ODc5IC0zLjYzODA3LC0xLjgwNTkxIC04LjA1OTE1LDMuMjMxOSAtMy41MDk4NSwzLjk5OTQ4IC03Ljc5NjczLDcuMjcxNzggLTkuNTI2NDEsNy4yNzE3OCAtMS43Mjk2OSwwIC00LjA2NTYsLTMuMjcyMyAtNS4xOTA4OCwtNy4yNzE3OCAtMS45NzE5NSwtNy4wMDg1NiAtMi4yMTM2NiwtNy4wNTI3NyAtNi42NzczNywtMS4yMjE2OSAtMy45MTA2LDUuMTA4NTQgLTMuOTQ1NTcsNi43MzU4MyAtMC4yMjQ2MSwxMC40NTY2MSAzLjk0MDYyLDMuOTQwNjQgMTEuNDI2MTUsMzAuODcxMDIgMTEuNDI2MTUsNDEuMTA3NDQgMCwxMi43Mjg2NyAxNy41MjkzMywyMi43MzgzMiAyNy43NzgzLDE1Ljg2MjEgeiBtIDU4Ljk0MzA5LC0xNi44NzUzMSBjIDEyLjE0NTY3LC0xMi4xNDU2NyAxNS43NDQ1MiwtMzAuMzUxNDMgOS4xMjk0MywtNDYuMTgzNTcgLTUuMTcwMTYsLTEyLjM3Mzk3IC0xNC4xNDQ2NiwtMTcuMDA1MTYgLTI2Ljc5ODc4LC0xMy44MjkxOCAtOS40MDI2MywyLjM1OTkxIC0yMy43MjMxMSwyOS43NzY1OSAtMjMuNzczODcsNDUuNTE1MzYgLTAuMDc5MiwyNC41MjkwMiAyMy4yNTA1MywzMi42OTAwNSA0MS40NDMyMiwxNC40OTczOSB6IG0gLTIyLjA4MzQxLC0xOS40MzQwNyBjIC0zLjU1NTEsLTMuNTU1MSAtNi40MTc1NSwtMTAuNDYzMjggLTYuMzYxMDIsLTE1LjM1MTUzIDAuMDkzNCwtOC4wNzk2NSAwLjQ5MzE1LC04LjM3MzUgNC4zOTYxOSwtMy4yMzE5IDQuODI0NjQsNi4zNTU2OSAxMy4zOTc5Nyw3LjQ1NjY2IDE2LjY4MjQxLDIuMTQyMzIgMS4xOTQzMiwtMS45MzI0MSAwLjU1Mjk1LC01LjEzMjAyIC0xLjQyNTIsLTcuMTEwMTcgLTUuMDgxMzIsLTUuMDgxMzIgLTQuNDY1NjEsLTExLjk5OTYzIDEuMDY3OTIsLTExLjk5OTYzIDYuMTUxMzcsMCAxNC43MjY3OSwxMi41MTQ3NyAxNC43MjY3OSwyMS40OTE5MSAwLDYuNjA2NzQgLTEzLjQ0NDQsMjAuNTIyOCAtMTkuODI3MjQsMjAuNTIyOCAtMS41Mzc4NSwwIC01LjcwNDc2LC0yLjkwODcyIC05LjI1OTg1LC02LjQ2MzggeiBtIDg2LjM0ODk3LDE4LjU4MzQxIGMgMTMuNDEwNzQsLTE0LjYwMjYzIDEyLjEwMzc2LC0zNy4wOTggLTMuMDk4MjUsLTUzLjMyNjM0IC03Ljg1MDU3LC04LjM4MDYgLTI1LjI5Mjk4LC05LjgyNTUyIC0zMi40MzE4NSwtMi42ODY2NCAtNi41ODc2MSw2LjU4NzYxIC0xMy4xNjQ2NSwzMi40OTMwMyAtMTAuNzIxMjIsNDIuMjI4NDEgNS4yMTEyMiwyMC43NjMxOCAzMi40MDA0MSwyOC44NjY1MiA0Ni4yNTEzMiwxMy43ODQ1NyB6IG0gLTI3LjQ1NTY1LC0yMy42MTQ1MiBjIC01LjMwNjIzLC0zLjcxNjY0IC03LjEyOTQxLC04LjE0OTc0IC02Ljk3ODA2LC0xNi45Njc0NyAwLjE2OTM1LC05Ljg2MDMzIDAuNjg0MywtMTAuNzQ5ODEgMi45NjE0NSwtNS4xMTQxNSAzLjM0NTczLDguMjgwMzIgMTAuMzYyOTIsMTEuNDA3MzQgMTYuNTE4MTQsNy4zNjA5IDMuODE3NTMsLTIuNTA5NjMgMy42MzkyOSwtMy42OTU5NyAtMS4xMDEwNCwtNy4zMjkwNyAtNi4zMjE4OSwtNC44NDUyMyAtNy41NTUwOCwtMTEuNzAxOTEgLTIuMTA0NjUsLTExLjcwMTkxIDQuODczNjQsMCAyMi4zMDQwMiwxOS4wNjY2NiAyMi4zMDQwMiwyNC4zOTc3OCAwLDUuMjAzMTYgLTEyLjM3NzM5LDE0LjM4NTAzIC0xOS4zOTEzOSwxNC4zODUwMyAtMi43NjQwNSwwIC04LjI1NzksLTIuMjY0MDIgLTEyLjIwODQ3LC01LjAzMTExIHogbSAxODkuOTYyOTIsLTE0LjI4ODg3IDMzLjkzNDk1LC0xMi43MzY4MiAtMzYuMzU4ODgsLTAuMTMxMjUgYyAtMzIuNTM5MiwtMC4xMTczNiAtMzYuMzU0MjQsMC40NjMwNyAtMzYuMzE0NzUsNS41MjQ3NSAwLjA0MDEsNS4xMjc1NyAzLjMzMDczLDIwLjI4Mzk1IDQuMzcyNywyMC4xMzk2NyAwLjIzNzIyLC0wLjAzMjkgMTUuNzAxNzcsLTUuNzkxMjQgMzQuMzY1OTgsLTEyLjc5NjQ4IHogbSAtNDQzLjQ5MzQzLC0yLjI3OTMgMy40NjgyNSwtMTAuMjg3NjEgLTMwLjQ2Njg2LC0xLjAyNDA0IGMgLTE2Ljc1Njc0NCwtMC41NjMyMiAtMzAuNDYzNTg0LC0wLjEzMjEzIC0zMC40NTk1OCwwLjk1ODA0IDAuMDA1OCwxLjU5NTEzIDUyLjUwNjU3LDIyLjEwNzA3IDUzLjY2MTc0LDIwLjk2NTUyIDAuMTgwMzUsLTAuMTc4NCAxLjg4ODkyLC00Ljk1MzcyIDMuNzk2NDUsLTEwLjYxMTkxIHogbSAyMDguOTA5MiwtMzEuODg2OTUgYyA3LjE2NjY3LDEuMTQ2IDE1LjI0OTgxLDQuMDc5MjQgMTcuOTYyNTYsNi41MTgzNSA0LjIxMjc5LDMuNzg3ODMgNi4wNDUyOCwzLjUyOTY2IDEyLjU2MjA3LC0xLjc2OTg1IDQuMTk2NDMsLTMuNDEyNSA5LjY1MDI2LC02LjIwNDU3IDEyLjExOTYzLC02LjIwNDU3IDIuNDY5MzksMCA0LjQ4OTgyLC0wLjcxMzA4IDQuNDg5ODIsLTEuNTg0NjcgMCwtMy4wMDkxOCAtNDYuNTM5NTQsLTc5LjIxMjUyIC00OC4zMTQ0NywtNzkuMTA5NjEgLTIuMDg1LDAuMTIwODcyIC00OS43ODYwMyw4MC4wODc5OCAtNTEuMjU0NjQsODUuOTI0MzcgLTAuNjE2MzQsMi40NDk1MiAxLjMxODA0LDMuMzUzNzEgNS4wNzM2NCwyLjM3MTYgMy4zMzgzNiwtMC44NzMgNy45NTQxNiwwLjY4MzI2IDEwLjI1NzI3LDMuNDU4MzYgMy43MzU0LDQuNTAwODcgNS4yNjEwOCw0LjE0MjI5IDE0LjEzMDY4LC0zLjMyMDk3IDguNDI2NDcsLTcuMDkwNDEgMTEuOTMwOCwtOC4wNDg4IDIyLjk3MzQ0LC02LjI4MzAxIHoiDQogICAgICAgc3R5bGU9ImZpbGw6IzMzMzMzMztmaWxsLW9wYWNpdHk6MSIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOiM2Mzk4YWE7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmUiDQogICAgICAgZD0ibSAzMDkuNTQ1NzksMTQwLjg3OTIyIGMgLTAuNTAwNzUsLTAuMjMzMTEgLTEuMTE4MDQsLTAuNzY3OTkgLTIuNTI3OCwtMi4xOTAzNSAtMS45MTE4OCwtMS45Mjg5NyAtMi42NzE4OCwtMi40OTAxMyAtNC4yNjEwOCwtMy4xNDYyOCAtMi4wODc5MSwtMC44NjIwNCAtNC4zNTQ5LC0xLjA5NDIzIC02LjQ4MjMxLC0wLjY2MzkxIC0xLjg5ODA4LDAuMzgzOTMgLTIuNDI0MzUsMC40MjUyNyAtMy4yODI0MiwwLjI1NzggLTEuNDMyMjQsLTAuMjc5NTMgLTEuOTQxNTcsLTEuMTQ5MjkgLTEuNTM1ODMsLTIuNjIyNzIgMC41MDU3MywtMS44MzY1NyA0LjMzNjkzLC04Ljk0MjU1IDEyLjAwODk5LC0yMi4yNzM4NyAxNS41ODM3LC0yNy4wNzg5ODggMzYuNTM2MjQsLTYxLjIyMDk2OCAzOC44NTA1NiwtNjMuMzA2NjYyIDAuMjU2MzEsLTAuMjMwOTk0IDAuMjY1LC0wLjIzMDk5NCAwLjUyMjQ4LDAgMS4zNzc2OCwxLjIzNTk3NiA5LjQ3NjIsMTMuNzI1ODg5IDIwLjU0MDM2LDMxLjY3ODI5OCAxNC45NjY5NiwyNC4yODUwMDQgMjcuNDExMDIsNDUuNjQzNzE0IDI3LjQxMTAyLDQ3LjA0NzcwNCAwLDAuODU3MjkgLTEuMzE2MDgsMS4zNzIxNSAtNC4wODU5MSwxLjU5ODQ1IC0zLjQ0MjI2LDAuMjgxMjQgLTcuNDI0NzgsMi4zMDE4OCAtMTIuODY4ODcsNi41MjkzNiAtMi41ODcxMiwyLjAwODk4IC0zLjY5MTI2LDIuNzU5MzMgLTQuOTUwNjIsMy4zNjQzOCAtMS4wNDkyOCwwLjUwNDExIC0xLjEzNjkyLDAuNTI0MzcgLTIuMjY4NTQsMC41MjQzNyAtMS4xMTM2OCwwIC0xLjIyNjYxLC0wLjAyNDkgLTIuMDk2MjMsLTAuNDYxMjggLTAuNTEyMTMsLTAuMjU3MDIgLTEuNTA0NjksLTAuOTQ5MyAtMi4yNDE1NSwtMS41NjM0MiAtMi4xNzg0OCwtMS44MTU2MSAtNC43OTkxOCwtMy4xMzYxNCAtOS4wNzE5NywtNC41NzEyNCAtNS40Mjk5NywtMS44MjM3NiAtMTEuMjQ0NTQsLTIuOTE4NCAtMTYuMTk1NTEsLTMuMDQ4OTYgLTMuOTA5MzQsLTAuMTAzMDggLTUuNzEyMDEsMC4yNDc5OCAtOC42NzYwMiwxLjY4OTYzIC0yLjQxOTg4LDEuMTc2OTggLTMuNTg2MjEsMi4wMTMxMSAtOS4xMjQ3NSw2LjU0MTQ1IC01LjYzMzc2LDQuNjA2MTcgLTcuNjM0NDIsNS41NjIwNSAtOS42NjQsNC42MTcyNSB6IiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6IzYzOThhYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSINCiAgICAgICBkPSJtIDEyOC42Mzc4NiwxNzAuNzM5IGMgLTEwLjE1OSwtMi45NjA3IC00NS41MDMxNzEsLTE2LjkxOTYyIC01MC40NTA5MjQsLTE5LjkyNTIzIC0wLjY4MjkxNiwtMC40MTQ4NCAtMC43MzgwOTgsLTAuNDc3ODcgLTAuNTQzMjA3LC0wLjYyMDM4IDEuMTMxNTYzLC0wLjgyNzQxIDEyLjMzNzk4MywtMS4yMzkwMSAyNS4wMDQwMzEsLTAuOTE4MzYgNS4wNTEzMSwwLjEyNzg4IDM1LjUwMTMyLDEuMTMzMjMgMzUuNTUwOSwxLjE3Mzc3IDAuMDk5NywwLjA4MTUgLTYuNTIxNjQsMTkuMjg4OCAtNy4wMzA1MSwyMC4zOTQzMyAtMC4yMTI1MSwwLjQ2MTcgLTAuNjUwNjMsMC40NDM2NyAtMi41MzAyOSwtMC4xMDQxMyB6IiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6IzYzOThhYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSINCiAgICAgICBkPSJtIDU0My42OTQxMywxNzUuMzEwNTUgYyAtMS4zODYyLC0yLjcxMjg3IC0zLjg4NzY5LC0xNC45NzA2NyAtMy45NjA3OCwtMTkuNDA4NTggLTAuMDI4NCwtMS43MjQyNCAwLjE4NjY3LC0yLjQyNzQxIDAuOTYwNiwtMy4xNDA4IDEuNzczNzgsLTEuNjM1MDEgNS4zNzkzOCwtMi4yMjMyIDE1LjI5MDE3LC0yLjQ5NDM0IDUuMDAzNDcsLTAuMTM2ODkgMjguMTAxOSwtMC4xNTc5NiA0NC40MTEyNywtMC4wNDA1IGwgMTEuNDI4NTksMC4wODIzIC0yNy41MTc3LDEwLjMxNDI3IGMgLTI1LjA5MjkyLDkuNDA1NCAtMzkuNjg0NzMsMTQuODQxMjYgLTQwLjIyNDkxLDE0Ljk4NDkgLTAuMTM1MTcsMC4wMzYgLTAuMjY5ODEsLTAuMDY3NCAtMC4zODcyNCwtMC4yOTcyMyBsIDAsMCB6IiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6IzYzOThhYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSINCiAgICAgICBkPSJtIDE3OC4wODgzNSwzMTUuNTE0MzMgYyAwLC0wLjc3MDc4IDMuMjY4OSwtNi41MzMxIDExLjU1Mzk1LC0yMC4zNjY5OCAxOS44NTExOCwtMzMuMTQ2MzEgMjguOTI3MTUsLTQ1LjE2MDEyIDQwLjA3MjkyLC01My4wNDQyOSA5Ljk3MTI3LC03LjA1MzM3IDE1LjMwMjc5LC0xMS45Mjk0IDIxLjI0NTM5LC0xOS40MzAzMyBsIDMuNjY0MDksLTQuNjI0OTIgNC45Mzk5LDQuODU2NTIgYyA4LjY0Nzg0LDguNTAxODkgMTMuODYxMywxMC45NjY2OCAyMy4yOTcxNywxMS4wMTQzMiAxMS41NDA1OCwwLjA1ODMgMjQuMTc4NDksLTYuMzg4MSAyNC4xNzg0OSwtMTIuMzMyOTkgMCwtMS4zMzk4IDAuOTU0MDQsLTIuNzIyMzYgMS44Nzg1NywtMi43MjIzNiAwLjM5MTMyLDAgMi42MTY4NiwwLjY4MzY1IDQuOTQ1NjUsMS41MTkyMyA2LjA2OTkyLDIuMTc3OSA5LjYzMDI4LDIuOTY1NDggMTQuNjA5MTIsMy4yMzE2NSA0LjkzOTk4LDAuMjY0MDkgOC41NDg0OCwtMC4xNzA0IDEzLjM1ODE3LC0xLjYwODQxIDQuNzI1NjEsLTEuNDEyODggNy40NDcwOSwtMi44NTkwNSAxNS41OTgzMywtOC4yODg4MiA0LjEwNzYsLTIuNzM2MTggNy41OTk1NCwtNC45NzQ4NyA3Ljc1OTg4LC00Ljk3NDg3IDAuMTYwMzMsMCAzLjEyNTM0LDEuNzE4OTYgNi41ODg5LDMuODE5OTEgMy40NjM1NiwyLjEwMDk1IDcuNjI1NDIsNC4zODEzMyA5LjI0ODU5LDUuMDY3NTEgMTEuMDY4NjIsNC42NzkxOCAyMy4wMjQ0NSw0LjM3MzkgMzMuOTcxMjYsLTAuODY3NDEgMS45NTc5NSwtMC45Mzc0NyA2LjU2NzkzLC0zLjczMDc0IDEwLjI0NDQsLTYuMjA3MjcgMy42NzY0OCwtMi40NzY1MyA2LjczNjEzLC00LjQ0NTc2IDYuNzk5MjMsLTQuMzc2MDYgMC4wNjMxLDAuMDY5NyAxLjQ1NjA1LDIuOTIwOCAzLjA5NTQ0LDYuMzM1NzggMS42Mzk0LDMuNDE0OTggMy42OTg5NSw3LjI2NjcgNC41NzY3OSw4LjU1OTM3IDMuODAwMDEsNS41OTU3OCA4LjE3NTg4LDkuNzUxNDEgMTQuMDgzNDMsMTMuMzc0NjQgNi4wODEyMiwzLjcyOTc1IDkuODMyMDYsOC42ODY4IDEwLjIxODgyLDEzLjUwNTA3IDAuMzgzNjcsNC43Nzk2OCAtMS43MDMyOSw5LjAxOTM5IC03LjcyMTg5LDE1LjY4NzIxIC00LjY5NzQ3LDUuMjA0MTkgLTUuODczMyw3LjIzNTQgLTUuODYxMTMsMTAuMTI0OTEgMC4wMTIyLDIuODkyNjIgMS43MDEwMyw2LjIyODU0IDQuNjY5NjQsOS4yMjM3OSA0LjgwNTMzLDQuODQ4NDQgMTIuMzQ2MDUsNi4yODc3NyAyMy40MzUzNCw0LjQ3MzE5IDIuNDc0MDgsLTAuNDA0ODQgNS41OTQ3OSwtMC43Mzc1NyA2LjkzNDkxLC0wLjczOTM4IDQuMjg1NTEsLTAuMDA2IDYuOTAzMTksMi4wOTU5NSAxMS44OTI1MSw5LjU0ODU5IDMuNDQzNTEsNS4xNDM2NSAxMC45NzM5NiwxNy43NTUwOCAxMC45NzM5NiwxOC4zNzgzNiAwLDAuMzI0MDcgLTAuMzUxNDUsMC41NTIwOCAtMC44NTA5NywwLjU1MjA4IC0xLjA1MTA5LDAgLTUuNjIzMTQsLTEuMjQzOCAtOC45MzIxNCwtMi40Mjk5NCAtNC4zNDg1LC0xLjU1ODc1IC01Ny4yNzIzOCwtMjIuMDA1MjYgLTc0Ljc0Nzg2LC0yOC44Nzc5NSAtNDYuNjYzNSwtMTguMzUxNjIgLTYyLjAyODA1LC0yNC4yMTI0NiAtNjkuNTM2NTcsLTI2LjUyNDg5IC04LjExNDE3LC0yLjQ5ODk1IC0xMy42NDAyOSwtMy4wODUyMiAtMTguMTI2NjEsLTEuOTIzMDYgLTUuNTc5OTYsMS40NDU0NiAtODEuNzIwNjcsMzAuODY4ODggLTEyNi4xMzI0NSw0OC43NDE5NSAtMjEuOTMxMTksOC44MjYgLTI0LjY3NzQ5LDkuODc1NzcgLTI4Ljc4MTE2LDExLjAwMTU5IC0zLjI2MzAzLDAuODk1MjEgLTMuMTQ0MDcsMC44ODI5NCAtMy4xNDQwNywwLjMyNDI2IHoiIC8+DQogIDwvZz4NCjwvc3ZnPg==');
    background-position: 16px 80%;
    background-repeat: no-repeat;
    background-size: 20px 12px;
    padding-left: 2.5em;
}

.multi-language-selector .language-option[data-lang='kotlin'],
.exampleblock[data-lang=kotlin] > .content .title {
    background-image: url('data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA2MCA2MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjAgNjA7Ij4NCjxnPg0KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iWE1MSURfM18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTUuOTU5NCIgeTE9Ii0xMy4wMTQzIiB4Mj0iNDQuMzA2OCIgeTI9IjE1LjMzMzIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCA2MSkiPg0KCQk8c3RvcCAgb2Zmc2V0PSI5LjY3NzAwMGUtMDIiIHN0eWxlPSJzdG9wLWNvbG9yOiMwMDk1RDUiLz4NCgkJPHN0b3AgIG9mZnNldD0iMC4zMDA3IiBzdHlsZT0ic3RvcC1jb2xvcjojMjM4QUQ5Ii8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuNjIxMSIgc3R5bGU9InN0b3AtY29sb3I6IzU1N0JERSIvPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjg2NDMiIHN0eWxlPSJzdG9wLWNvbG9yOiM3NDcyRTIiLz4NCgkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzgwNkVFMyIvPg0KCTwvbGluZWFyR3JhZGllbnQ+DQoJPHBvbHlnb24gaWQ9IlhNTElEXzJfIiBzdHlsZT0iZmlsbDp1cmwoI1hNTElEXzNfKTsiIHBvaW50cz0iMCw2MCAzMC4xLDI5LjkgNjAsNjAgCSIvPg0KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNC4yMDkyIiB5MT0iNDguOTQwOSIgeDI9IjIwLjY3MzQiIHkyPSI2NS40MDUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCA2MSkiPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjExODMiIHN0eWxlPSJzdG9wLWNvbG9yOiMwMDk1RDUiLz4NCgkJPHN0b3AgIG9mZnNldD0iMC40MTc4IiBzdHlsZT0ic3RvcC1jb2xvcjojM0M4M0RDIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuNjk2MiIgc3R5bGU9InN0b3AtY29sb3I6IzZENzRFMSIvPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjgzMzMiIHN0eWxlPSJzdG9wLWNvbG9yOiM4MDZFRTMiLz4NCgk8L2xpbmVhckdyYWRpZW50Pg0KCTxwb2x5Z29uIHN0eWxlPSJmaWxsOnVybCgjU1ZHSURfMV8pOyIgcG9pbnRzPSIwLDAgMzAuMSwwIDAsMzIuNSAJIi8+DQogICAgPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8yXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMTAuMTAxNyIgeTE9IjUuODM2MiIgeDI9IjQ1LjczMTUiIHkyPSI2MS42Njk0IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgNjEpIj4NCgkJPHN0b3AgIG9mZnNldD0iMC4xMDc1IiBzdHlsZT0ic3RvcC1jb2xvcjojQzc1N0JDIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuMjEzOCIgc3R5bGU9InN0b3AtY29sb3I6I0QwNjA5QSIvPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjQyNTQiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMTcyNUMiLz4NCgkJPHN0b3AgIG9mZnNldD0iMC42MDQ4IiBzdHlsZT0ic3RvcC1jb2xvcjojRUU3RTJGIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuNzQzIiBzdHlsZT0ic3RvcC1jb2xvcjojRjU4NjEzIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuODIzMiIgc3R5bGU9InN0b3AtY29sb3I6I0Y4ODkwOSIvPg0KCTwvbGluZWFyR3JhZGllbnQ+DQoJPHBvbHlnb24gc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8yXyk7IiBwb2ludHM9IjMwLjEsMCAwLDMxLjcgMCw2MCAzMC4xLDI5LjkgNjAsMCAJIi8+DQo8L2c+DQo8L3N2Zz4=');
    background-position: 17px 80%;
    background-repeat: no-repeat;
    background-size: 11px 11px;
    padding-left: 2.3em;
}

.multi-language-selector {
    display: block;
}

.multi-language-selector .language-option[data-lang='groovy'] {
    background-position: 20px center;
    padding-left: 32px;
}

.multi-language-selector .language-option[data-lang='kotlin'] {
    background-position: 30px center;
    padding-left: 27px;
}

.multi-language-selector .language-option {
    background-color: white;
    border: 1px solid #f7f7f8;
    border-radius: 4px 4px 0 0;
    cursor: pointer;
    display: inline-block;
    font-weight: normal;
    font-family: 'Lato', Arial, sans-serif;
    margin: 0;
    padding: 4px 20px;
    min-width: 130px;
    max-width: 320px;
    text-align: center;
    filter: grayscale(1);
    -webkit-filter: grayscale(1);
    opacity: 0.7;
}

.multi-language-selector .language-option.selected {
    background-color: #f7f7f8;
    color: #02303a;
    filter: none;
    -webkit-filter: none;
    opacity: 1;
}

.multi-language-text.hidden,
.multi-language-selector ~ .multi-language-sample.hidden {
    display: none;
}

.multi-language-sample {
    border-radius: 0 0 4px 4px;
}

/*
 * Ensure that blocks of code do not wrap by applying the behavior of `[listing%nowrap]` by default.
 *
 * These styles are copied from a CSS ruleset in asciidoctor.css that has the same group of
 * selectors except that they end with `.nowrap`.
 */
.literalblock pre,
.literalblock pre[class],
.listingblock pre,
.listingblock pre[class] {
    overflow-x: auto;
    white-space: pre;
    word-wrap: normal;
}

/*
 * This CSS ruleset solves: https://github.com/gradle/guides/issues/113#issuecomment-314826749.
 */
.literalblock pre::after,
.literalblock pre[class]::after,
.listingblock pre::after,
.listingblock pre[class]::after {
    content: "";
}

.quoteblock blockquote,
.quoteblock blockquote p {
    text-align: left;
    text-align: start;
}

div.screenshot {
    box-shadow: 0 0 20px 1px rgba(0, 0, 0, 0.2);
    margin-left: auto;
    margin-right: auto;
    width: 90%;
}

.inset {
    box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.1);
    padding: 1em;
}

.image.inline-icon img {
    vertical-align: sub;
}

/* TOC */
#header > h1:first-child + #toc {
    background: none;
    border: 0 none;
    margin-top: 0;
}

#header #toctitle {
    margin-bottom: 0.425rem;
}

#toc,
#content #toc {
    border: 0 none;
}

#toc > ul {
    margin-left: 0;
    font-family: inherit;
}

#toc > ul > li {
    line-height: 1.25;
    margin-top: 0;
    padding-bottom: 0.5rem;
}

#toc > ul > li:last-of-type {
    padding-bottom: 0;
}

#toc a {
    font-style: normal;
}

#toc a:hover,
#toc a:focus,
#toc a:hover code,
#toc a:focus code {
    color: #1DA2BD;
}

#toc a:active {
    text-decoration: none;
}

@media screen and (min-width: 75rem) and (min-height: 48rem) {
    #header #toc {
        font-size: 1rem;
        background: #f7f7f8;
        border-radius: 0;
        margin-bottom: 0;
        padding: 15px 0 0;
    }

    #header #toctitle {
        font-size: 1rem;
        font-weight: 700;
        margin: 0.4rem 0 0.5rem 0;
    }

    #toc a {
        color: #02303A;
    }

    #toc a.active {
        color: #1BA8C4;
    }
}

/* Site header specific styles */
.hamburger {
    background-color: transparent;
    background-image: none;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-left: auto;
    padding: 11px 10px;
}

.hamburger:focus {
    outline: 0;
}

.hamburger__bar {
    display: block;
    width: 22px;
    height: 2px;
    background-color: black;
    border-radius: 1px;
}

.hamburger__bar + .hamburger__bar {
    margin-top: 4px;
}

.site-header {
    background-color: white;
}

/* Override javadoc styles */
.site-header div {
    font-family: 'Lato', Arial, sans-serif;
}

.site-header__navigation-header a {
    align-self: center;
    border-bottom: 0 none;
    height: 36px;
}

.site-header .site-header-version {
    align-self: flex-end;
    color: #1da2bd;
    font-size: 20px;
    padding-left: 1px;
}

.site-header__navigation {
    display: flex;
    flex-direction: column;
}

.site-header__navigation-header {
    display: flex;
    flex: 0 0 auto;
    margin-left: 12px;
}

.site-header__navigation-collapsible {
    flex: 1 1 auto;
    height: 210px;
    overflow: visible;
    transition: height 0.3s ease;
}

.site-header__navigation-items {
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    align-items: flex-start;
    max-height: 210px; /* This matches the collapsible height above */
    margin: 0 20px;
    padding-top: 12px;
    padding-left: 0;
    list-style-type: none;
}

.site-header__navigation-item {
    flex: 0 1 auto;
    font-size: 16px;
    width: 250px;
}

.site-header__navigation-item .site-header__navigation-link {
    position: relative;
    display: inline-block;
    cursor: pointer;
    width: 100%;
    padding: 5px;
    line-height: 20px;
    border: 0 none;
    color: #02303A;
    text-decoration: none;
    transition: none;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
}

.site-header__navigation-item .site-header__navigation-link:hover {
    color: #1DA2BD;
}

.site-header__navigation-item .site-header__navigation-link.active {
    font-weight: 500;
}

/* Navigation submenu styles */
.site-header__navigation-submenu-section {
    position: relative;
}

.site-header__navigation-submenu-section .site-header__down-arrow {
    width: 8px;
    height: 8px;
    margin-left: 2px;
    margin-top: 0;
}

.site-header__navigation-submenu-section .site-header__navigation-link:hover {
    color: #02303A;
}

.site-header__navigation-submenu-section .site-header__navigation-link:hover path {
    fill: none;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link:hover {
    color: #1DA2BD;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu {
    display: none;
    width: 170px;
    background-color: white;
    top: 40px;
    left: 21px; /* NOTE: This must match the padding of .site-header__navigation-link */
    padding: 3px 10px 6px 10px;
    z-index: 100;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link {
    width: 100%;
    color: #02303A;
    white-space: nowrap;
    display: inline-block;
    padding-top: 3px;
    border: 0 none;
    transition: none;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link .site-header__navigation-submenu-item-link-text {
    display: inline-block;
    font-size: 16px;
}

.site-header__navigation-submenu-section.open .site-header__navigation-submenu {
    display: block;
}

/* Top navigation mobile styles */
@media (max-width: 1023px) {
    .site-header__navigation-collapsible--collapse {
        height: 0;
        overflow-y: hidden;
    }

    .site-header__navigation-submenu-section .site-header__navigation-submenu {
        padding: 0 1rem 0.5rem 1.5rem;
        display: block;
        top: 30px !important;
        left: 0 !important;
    }

    .site-header__navigation-item,
    .site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link .site-header__navigation-submenu-item-link-text {
        font-size: 18px;
    }

    .site-header {
        padding: 5px 12px;
    }

    .site-header-version {
        display: none;
    }

    .site-footer__navigation {
        flex-direction: column;
    }

    .site-footer__links {
        flex-wrap: wrap;
    }

    .site-footer__link-group {
        margin-bottom: 1rem;
    }
}

/* Top navigation desktop styles */
@media (min-width: 1024px) {
    .site-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        -webkit-box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .15);
        -moz-box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .15);
        box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .15);
        z-index: 1;
    }

    /*
      Pushes the section headings to just below the top nav bar when a user
      navigates directly to section anchors.
     */
    #content h2[id], #content h3[id], #content h4[id], #content h5[id] {
        padding-top: 60px;
    }

    #content h2[id] {
        /* Little extra room above h2s */
        margin-top: -1em;
    }

    #content h3[id], #content h4[id], #content h5[id] {
        margin-top: -60px;
    }

    .site-header__navigation {
        flex-direction: row;
    }

    .site-header__navigation-button {
        display: none;
    }

    .site-header__navigation-items {
        flex-direction: row;
        align-items: center;
        float: right;
        width: auto;
        padding-top: 0;
    }

    .site-header__navigation-item {
        width: auto;
    }

    .site-header__navigation-item .site-header__navigation-link {
        padding: 15px 18px;
    }

    .site-header__navigation-item:last-of-type .site-header__navigation-link {
        padding-right: 0;
    }

    .site-header__navigation-link--button {
        padding: 6px 12px;
    }

    .site-header__navigation-collapsible {
        height: auto;
    }

    .site-header__navigation-submenu-section .site-header__navigation-submenu {
        position: absolute;
        border: 1px solid #9a9a9a;
        border-radius: 3px;
    }

    .site-header__navigation-submenu-section:hover .site-header__navigation-submenu {
        display: block;
    }

    /*
      Pushes the section headings to just below the top nav bar when a user
      navigates directly to section anchors. It doesn't work if you try
      to apply the padding and margin to the `h` elements directly.
     */
    .chapter a[name],
    .chapter .anchor {
        padding-top: 60px;
        margin-top: -60px;
        text-decoration: none;
        border: none;
        display: inline-block;
    }
}

/* Side Navigation styles */
/* Docs Navigation */
.docs-navigation {
    display: none;
    padding-left: 5px;
}

.docs-navigation .search-container {
    display: none;
    margin-bottom: 1rem;
}

.docs-navigation .search-input {
    height: 30px;
    line-height: 30px;
    box-sizing: border-box;
    padding: 0 20px 0 30px;
    border: 1px solid #e3e3e3;
    border-radius: 3px;
    color: #666;
    outline: none;
    margin-right: 10px;
    transition: border-color 0.2s ease;
    background: white url('data:image/svg+xml;utf8,<svg height="20px" version="1.1" viewBox="0 0 32 32" width="20px" xmlns="http://www.w3.org/2000/svg"><g fill="#cccccc" fill-rule="evenodd" stroke="none" stroke-width="1"><path d="M19.4271164,21.4271164 C18.0372495,22.4174803 16.3366522,23 14.5,23 C9.80557939,23 6,19.1944206 6,14.5 C6,9.80557939 9.80557939,6 14.5,6 C19.1944206,6 23,9.80557939 23,14.5 C23,16.3366522 22.4174803,18.0372495 21.4271164,19.4271164 L27.0119176,25.0119176 C27.5621186,25.5621186 27.5575313,26.4424687 27.0117185,26.9882815 L26.9882815,27.0117185 C26.4438648,27.5561352 25.5576204,27.5576204 25.0119176,27.0119176 L19.4271164,21.4271164 L19.4271164,21.4271164 Z M14.5,21 C18.0898511,21 21,18.0898511 21,14.5 C21,10.9101489 18.0898511,8 14.5,8 C10.9101489,8 8,10.9101489 8,14.5 C8,18.0898511 10.9101489,21 14.5,21 L14.5,21 Z"/></g></svg>') no-repeat 8px 5px;
    background-size: 20px;
    vertical-align: middle !important;
    max-width: 100%;
}

.docs-navigation .search-input:focus {
    border-color: #1BA8CB;
}

.docs-navigation .search-input::placeholder {
    color: #ccc;
}

/* Docsearch overrides */
.docs-navigation .algolia-autocomplete {
    display: block !important;
    flex: 1;
}

.docs-navigation .algolia-autocomplete .ds-dropdown-menu {
    width: 100%;
    min-width: 0 !important;
    max-width: none !important;
    padding: .75rem 0 !important;
    background-color: #fff !important;
    background-clip: padding-box;
    border: 1px solid #e3e3e3 !important;
    box-shadow: 0 .5rem 1rem rgba(0, 0, 0, .175) !important;
}

@media (min-width: 768px) {
    .docs-navigation .algolia-autocomplete .ds-dropdown-menu {
        width: 300%;
    }
}

.docs-navigation .algolia-autocomplete .ds-dropdown-menu [class^="ds-dataset-"] {
    padding: 0 !important;
    overflow: visible !important;
    background-color: transparent !important;
    border: 0 !important;
}

.docs-navigation .algolia-autocomplete .ds-dropdown-menu .ds-suggestions {
    margin-top: 0 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion {
    padding: 0 15px !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--category-header {
    font-weight: 800 !important;
    color: #1BA8CB !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--wrapper {}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column {}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--content {
    padding: 0 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--title {
    display: block !important;
    color: #02303A;
    padding: .25rem 1rem !important;
    margin-bottom: 0 !important;
    font-weight: 500 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--text {
    padding: 0 1rem .5rem !important;
    margin-top: -.25rem !important;
    font-size: 0.9em !important;
    font-weight: 400 !important;
    line-height: 1.25 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-footer {
    float: none !important;
    width: auto !important;
    height: auto !important;
    padding: .75rem 1rem 0;
    font-size: .875rem !important;
    line-height: 1 !important;
    color: #767676 !important;
    border-top: 1px solid #e3e3e3 !important;
    text-align: right;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-footer a {
    font-size: .875rem;
    text-decoration: underline;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-footer--logo {
    display: inline !important;
    overflow: visible !important;
    color: inherit !important;
    text-indent: 0 !important;
    background: none !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--highlight {
    background-color: rgba(143, 187, 237, .1) !important;
}

.docs-navigation .algolia-autocomplete .ds-suggestion .ds-cursor .algolia-docsearch-suggestion--content {
    background-color: rgba(208, 189, 236, .15) !important;
}

.docs-navigation a {
    color: #02303A;
    display: block;
    font-size: 1rem;
    line-height: 1.25;
}

.docs-navigation a code {
    color: #02303A;
    overflow-wrap: break-word;
    padding: 0;
    word-break: break-all;
}

.docs-navigation a.active {
    color: #1BA8C4;
}

.docs-navigation ul {
    list-style-type: none;
    margin: 0.5em 0;
    padding: 0;
}

.docs-navigation ul:last-of-type {
    margin-bottom: 0;
}

.docs-navigation li:first-of-type {
    margin-top: 0;
}

.docs-navigation li {
    margin-bottom: 0.5em;
}

.docs-navigation li:last-of-type {
    margin-bottom: 0;
}

.docs-navigation .nav-dropdown {
    background: transparent url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iNiIgdmlld0JveD0iMCAwIDE5IDExIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIHRyYW5zZm9ybT0icm90YXRlKC0xODAgOS4zNzQgNS40OTQpIiBkPSJNMTcuOTk5MSAxMC40MjI4MjVMOS4zNzQxIDAuNTY1NTc1IDAuNzQ5MSAxMC40MjI4MjUiIHN0cm9rZT0iIzAyMzAzQSIgb3BhY2l0eT0iMC43IiBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+') no-repeat center right;
}

.docs-navigation > ul ul,
.docs-navigation > ul ul ul {
    display: none;
    height: 0;
    margin-left: 1rem;
}

.docs-navigation > ul ul:target,
.docs-navigation > ul ul:target ul,
.docs-navigation > ul .nav-dropdown.expanded ~ ul {
    display: block;
    height: auto;
}

.docs-navigation h3 {
    font-size: 1rem;
    font-weight: 700;
    line-height: 1.5;
    margin: 1.5em 0 0;
}

.docs-navigation .docs-home-link {
    position: relative;
}

.docs-navigation .pdf-link-container {
    display: inline-block;
    position: absolute;
    top: -1.25em;
    right: 0;
}

.docs-navigation .pdf-link-container a {
    color: #999;
    font-size: 12px;
}

.docs-navigation .pdf-link-container svg {
    fill: #999;
    height: 12px;
    vertical-align: bottom;
}

@media screen and (min-width: 45rem) {
    .main-content {
        display: flex;
        justify-content: center;
    }
}

/* User guide navigation appears for desktops */
@media screen and (min-width: 64rem) {
    .main-content {
        padding-top: 75px;
    }

    .docs-navigation {
        display: block;
        flex: 0 0 auto;
        width: 13.75rem;
    }

    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        flex: 0 0 45rem;
        margin: 0 20px;
    }
}

/* Fixed intra-chapter navigation for desktops */
@media screen and (min-width: 75rem) and (min-height: 48rem) {
    .appendix #header #toc,
    .book #header #toc,
    .chapter #header #toc {
        position: fixed;
        left: calc(50% + 380px);
        top: 50px;
        width: 13.75rem;
        padding-top: 15px;
        font-size: 1rem;
        background-color: #F7F7F8;
    }

    .appendix #toc a,
    .book #toc a,
    .chapter #toc a {
        color: #02303A;
        display: inline-block;
    }

    .appendix #toc a.active,
    .book #toc a.active,
    .chapter #toc a.active {
        color: #1BA8C4;
    }

    .docs-navigation {
        flex-basis: 13.75rem;
    }

    /* Sneaky way to make room for TOC */
    .secondary-navigation {
        flex: 0 0 13.75rem;
    }
}

@media screen and (min-width: 84.375rem) and (min-height: 48rem) {
    .appendix #header #toc,
    .book #header #toc,
    .chapter #header #toc {
        left: calc(50% + 26.25rem);
    }
}

@media screen and (min-width: 93.75rem) and (min-height: 48rem) {
    .appendix #header #toc,
    .book #header #toc,
    .chapter #header #toc {
        left: calc(50% + 31.25rem);
    }
}

/* Userguide Meta */
.chapter-meta {
    float: right;
    text-align: right;
}

.chapter-meta .edit-link {
    color: #999;
    font-size: 0.9em;
    padding-right: 3px;
}

.chapter-meta .edit-link svg {
    margin-right: 1px;
}

/* Clever use of RTL to fill in all stars to left of hover position */
.rating {
    direction: rtl;
}

.rating > .star {
    cursor: pointer;
    display: table-cell;
    padding: 3px;
}

.rating > .star:hover > svg > g,
.rating > .star:hover ~ .star > svg > g,
.rating > .star.selected > svg > g,
.rating > .star.selected ~ .star > svg > g {
    fill: #999;
}

/* Footer styles */
.site-footer {
}

.site-footer__navigation {
    display: flex;
    max-width: 75rem;
    margin: 3rem auto 0 auto;
    padding: 0.5rem 0.75rem;
}

.site-footer__links {
    display: flex;
    flex: 1 1 auto;
}

.site-footer__links .site-footer__links-list {
    list-style-type: none;
    margin: 0;
}

.site-footer__links .site-footer__links-list a {
    color: #666;
}

.site-footer__link-group {
    flex: 1 1 auto;
    flex-basis: 175px;
}

.site-footer__link-group header {
    color: #555;
}

.site-footer__subscribe-newsletter {
    flex: 0 0 350px;
}

.site-footer__subscribe-newsletter .newsletter-form__header h5 {
    color: #555;
    margin-top: 0;
}

.site-footer__subscribe-newsletter p {
    font-size: 0.875rem;
    margin: 2px 0 0 2px;
    opacity: 0.7;
}

.site-footer__subscribe-newsletter .disclaimer {
    font-size: 0.75rem;
    opacity: 0.55;
}

.site-footer__subscribe-newsletter .newsletter-form {
    padding-top: 6px;
    display: flex;
    justify-content: flex-start;
}

.site-footer__subscribe-newsletter .email,
.site-footer__subscribe-newsletter .submit {
    height: 40px;
}

.site-footer__subscribe-newsletter .email {
    line-height: 40px;
    width: 250px;
    color: #1DA2BD;
    font-size: 16px;
    padding-left: 20px;
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
    border-style: none;
}

.site-footer__subscribe-newsletter .submit {
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    width: 100px;
    background-color: #1BA8CB;
    color: white;
    font-weight: 500;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    border-style: none;
    cursor: pointer;
    transition: all .3s ease;
}

/* Secondary footer (below) */
.site-footer-secondary {
    background-color: white;
}

.site-footer-secondary__contents {
    display: flex;
    align-items: center;
    justify-content: space-between;
    max-width: 75rem;
    margin-left: auto;
    margin-right: auto;
    font-size: 0.875rem;
    padding: 0.5rem 0.75rem;
}

/*
 * 1. Value is the largest computed width among 'site-footer__copy' and 'site-footer__links'.
 */
.site-footer__copy,
.site-footer__secondary-links {
    flex-grow: 0;
    flex-basis: 280px;
    /* 1. */
}

/*
 * 1. 'flex-shrink: 1' is applied to the element with the smallest computed width among
 *    'site-footer__copy' and 'site-footer__links'.
 */
.site-footer__copy {
    flex-shrink: 1;
    /* 1. */
}

.site-footer__logo {
    flex: 0 0 auto;
    margin-right: 10px;
    margin-left: 10px;
}

.site-footer__logo svg {
    width: 35px;
    height: 35px;
}

/*
 * 1. 'flex-shrink: 0' is applied to the element with the largest computed width among
 *    'site-footer__copy' and 'site-footer__links'.
 */
.site-footer__secondary-links {
    flex-shrink: 0;
    /* 1 */
    text-align: right;
    white-space: nowrap;
}

.site-footer-secondary a {
    color: #999;
}

.site-footer-secondary__links a:not(:last-child) {
    padding-right: 10px;
}

.site-footer-secondary__links a:not(:first-child) {
    padding-left: 10px;
}

@media all and (max-width: 29.99rem) {
    .site-footer__rights,
    .site-footer-secondary__links {
        display: none;
    }

    .site-footer__logo {
        order: 1;
        text-align: left;
    }

    .site-footer__copy {
        order: 2;
        text-align: right;
    }
}

/* Avoid the footer taking up much of the screen on short displays */
@media all and (max-height: 56.25rem) {
    .site-footer__navigation {
        margin: 1.5rem auto 0 auto;
        padding-top: 0;
        padding-bottom: 0;
    }
}

@media screen and (min-width: 84.375rem) {
    .ui-logos .ui-logo {
        box-shadow: 0 6px 15px 1px rgba(0, 0, 0, 0.56);
    }

    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        flex-basis: 50rem;
        max-width: 50rem;
    }
}

@media screen and (min-width: 93.75rem) {
    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        flex-basis: 60rem;
        max-width: 60rem;
    }
}

/* User Manual Home */
.technology-logos,
.ui-logos {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: space-around;
}

.technology-logo,
.ui-logo {
    flex: 0 1 auto;
}

.ui-logo {
    width: 224px;
    height: 135px;
    margin: 12px;
}

</style>
<meta name="adoc-src-path" content="/dep-man/dependency_management.adoc">

<link href="//assets.gradle.com" rel="preconnect" crossorigin="">
<link href="asset?aid=0" rel="stylesheet">



<header class="site-layout__header site-header" itemscope itemtype="https://schema.org/WPHeader">
    <nav class="site-header__navigation" itemscope itemtype="https://schema.org/SiteNavigationElement">
        <div class="site-header__navigation-header">
            <a class="logo" href="https://docs.gradle.org" title="Gradle Docs" target="_top">
                <svg width="139px" height="43px" viewbox="0 0 278 86" version="1.1" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <style>.cls-1 {
                            fill: #02303a;
                        }</style>
                    </defs>
                    <title>摇篮</title>
                    <path class="cls-1" d="M155,56.32V70.27a18.32,18.32,0,0,1-5.59,2.83,21.82,21.82,0,0,1-6.36.89,21.08,21.08,0,0,1-7.64-1.31A17.12,17.12,0,0,1,129.59,69a16.14,16.14,0,0,1-3.73-5.58,18.78,18.78,0,0,1-1.31-7.08,19.58,19.58,0,0,1,1.26-7.14A15.68,15.68,0,0,1,135,40a20.39,20.39,0,0,1,7.45-1.29,22,22,0,0,1,3.92.33,20.43,20.43,0,0,1,3.39.92,15.16,15.16,0,0,1,2.85,1.42A17.3,17.3,0,0,1,155,43.25l-1.84,2.91a1.72,1.72,0,0,1-1.12.84,2,2,0,0,1-1.5-.34L149,45.75a10.49,10.49,0,0,0-1.75-.79,14.33,14.33,0,0,0-2.17-.54,15.29,15.29,0,0,0-2.78-.22,11.91,11.91,0,0,0-4.61.86,9.66,9.66,0,0,0-3.52,2.46,10.9,10.9,0,0,0-2.24,3.84,14.88,14.88,0,0,0-.79,5,15.23,15.23,0,0,0,.85,5.28,11.06,11.06,0,0,0,2.38,3.94A10.15,10.15,0,0,0,138.05,68a14.28,14.28,0,0,0,8.25.44,17.1,17.1,0,0,0,2.94-1.09V61.14h-4.35a1.3,1.3,0,0,1-1-.35,1.15,1.15,0,0,1-.35-.85V56.32Zm10.47-2.93a10.53,10.53,0,0,1,2.72-3.45,5.77,5.77,0,0,1,3.72-1.25,4.5,4.5,0,0,1,2.72.74l-.38,4.41a1.18,1.18,0,0,1-.34.61,1,1,0,0,1-.61.18,6.76,6.76,0,0,1-1.06-.12,8.22,8.22,0,0,0-1.38-.12,5,5,0,0,0-1.74.28,4.37,4.37,0,0,0-1.37.83,5.55,5.55,0,0,0-1.07,1.3,12.26,12.26,0,0,0-.87,1.74V73.61H160V49.14h3.45a1.94,1.94,0,0,1,1.27.32,1.9,1.9,0,0,1,.48,1.16Zm11.36-.84A14.49,14.49,0,0,1,187,48.69a9.92,9.92,0,0,1,3.84.7,8.06,8.06,0,0,1,2.86,2,8.38,8.38,0,0,1,1.78,3,11.64,11.64,0,0,1,.61,3.82V73.61h-2.68a2.64,2.64,0,0,1-1.28-.25,1.72,1.72,0,0,1-.72-1l-.52-1.77a20.25,20.25,0,0,1-1.82,1.47,10.86,10.86,0,0,1-1.83,1.06,10.36,10.36,0,0,1-2,.66,12,12,0,0,1-2.4.22,9.64,9.64,0,0,1-2.86-.41,6.28,6.28,0,0,1-2.27-1.26,5.6,5.6,0,0,1-1.48-2.07,7.38,7.38,0,0,1-.52-2.89,5.7,5.7,0,0,1,.31-1.85,5.3,5.3,0,0,1,1-1.75,8.25,8.25,0,0,1,1.83-1.57,11.17,11.17,0,0,1,2.75-1.29,23.28,23.28,0,0,1,3.81-.9,36.77,36.77,0,0,1,5-.41V58.16a5.35,5.35,0,0,0-1.05-3.64,3.83,3.83,0,0,0-3-1.18,7.3,7.3,0,0,0-2.38.33,9.39,9.39,0,0,0-1.65.75l-1.3.75a2.52,2.52,0,0,1-1.3.34,1.7,1.7,0,0,1-1.05-.32,2.61,2.61,0,0,1-.69-.76Zm13.5,10.61a31.66,31.66,0,0,0-4.3.45,11,11,0,0,0-2.79.82,3.57,3.57,0,0,0-1.5,1.17,2.89,2.89,0,0,0,.47,3.67,3.93,3.93,0,0,0,2.39.67,7,7,0,0,0,3.14-.66,9.52,9.52,0,0,0,2.59-2Zm32.53-25V73.61h-3.6a1.39,1.39,0,0,1-1.48-1.07l-.5-2.36a12.4,12.4,0,0,1-3.4,2.74,9.17,9.17,0,0,1-4.47,1,7.95,7.95,0,0,1-6.55-3.26A11.61,11.61,0,0,1,201,66.79a19.71,19.71,0,0,1-.66-5.34,16.77,16.77,0,0,1,.74-5.06,12.21,12.21,0,0,1,2.13-4,9.88,9.88,0,0,1,3.31-2.69,9.64,9.64,0,0,1,4.34-1,8.63,8.63,0,0,1,3.51.64,9,9,0,0,1,2.6,1.74V38.17ZM217,55.39a5.94,5.94,0,0,0-2.18-1.72,6.54,6.54,0,0,0-2.54-.5,5.68,5.68,0,0,0-2.41.5A4.87,4.87,0,0,0,208,55.19a7.19,7.19,0,0,0-1.17,2.57,14.83,14.83,0,0,0-.4,3.69,16.34,16.34,0,0,0,.34,3.63,7.14,7.14,0,0,0,1,2.44,3.79,3.79,0,0,0,1.58,1.36,5,5,0,0,0,2.07.41,6,6,0,0,0,3.13-.76A9.19,9.19,0,0,0,217,66.36Zm17.67-17.22V73.61h-5.89V38.17ZM245.1,62.11a11.37,11.37,0,0,0,.67,3.26,6.54,6.54,0,0,0,1.38,2.27,5.39,5.39,0,0,0,2,1.33,7.26,7.26,0,0,0,2.61.44,8.21,8.21,0,0,0,2.47-.33,11.51,11.51,0,0,0,1.81-.74c.52-.27,1-.52,1.36-.74a2.31,2.31,0,0,1,1.13-.33,1.21,1.21,0,0,1,1.1.55L261.36,70a9.45,9.45,0,0,1-2.19,1.92,12.18,12.18,0,0,1-2.54,1.24,14,14,0,0,1-2.7.66,18.78,18.78,0,0,1-2.65.19,12.93,12.93,0,0,1-4.75-.85,10.65,10.65,0,0,1-3.82-2.5,11.8,11.8,0,0,1-2.55-4.1,15.9,15.9,0,0,1-.93-5.67,13.55,13.55,0,0,1,.81-4.71,11.34,11.34,0,0,1,2.33-3.84,11,11,0,0,1,3.69-2.59,12.31,12.31,0,0,1,4.93-1,11.86,11.86,0,0,1,4.27.74,9.25,9.25,0,0,1,3.36,2.16,9.84,9.84,0,0,1,2.21,3.48,13,13,0,0,1,.8,4.71,3.82,3.82,0,0,1-.29,1.8,1.19,1.19,0,0,1-1.1.46Zm11.23-3.55A7.28,7.28,0,0,0,256,56.4a5.16,5.16,0,0,0-1-1.77,4.44,4.44,0,0,0-1.63-1.21,5.68,5.68,0,0,0-2.3-.44,5.46,5.46,0,0,0-4,1.45,7.13,7.13,0,0,0-1.87,4.13ZM112.26,14a13.72,13.72,0,0,0-19.08-.32,1.27,1.27,0,0,0-.41.93,1.31,1.31,0,0,0,.38.95l1.73,1.73a1.31,1.31,0,0,0,1.71.12,7.78,7.78,0,0,1,4.71-1.57,7.87,7.87,0,0,1,5.57,13.43C96,40.2,81.41,9.66,48.4,25.37a4.48,4.48,0,0,0-2,6.29l5.66,9.79a4.49,4.49,0,0,0,6.07,1.67l.14-.08-.11.08,2.51-1.41a57.72,57.72,0,0,0,7.91-5.89,1.37,1.37,0,0,1,1.8-.06h0a1.29,1.29,0,0,1,0,2A59.79,59.79,0,0,1,62.11,44l-.09.05-2.51,1.4a7,7,0,0,1-3.47.91,7.19,7.19,0,0,1-6.23-3.57l-5.36-9.24C34.17,40.81,27.93,54.8,31.28,72.5a1.31,1.31,0,0,0,1.29,1.06h6.09A1.3,1.3,0,0,0,40,72.42a8.94,8.94,0,0,1,17.73,0A1.3,1.3,0,0,0,59,73.56h5.94a1.31,1.31,0,0,0,1.3-1.14,8.93,8.93,0,0,1,17.72,0,1.3,1.3,0,0,0,1.29,1.14h5.87a1.3,1.3,0,0,0,1.3-1.28c.14-8.28,2.37-17.79,8.74-22.55C123.15,33.25,117.36,19.12,112.26,14ZM89.79,38.92l-4.2-2.11h0a2.64,2.64,0,1,1,4.2,2.12Z"></path>
                </svg>
            </a>
            <div class="site-header__doc-type sr-only">用户手册</div>
            <div class="site-header-version"></div>
            <button type="button" aria-label="导航菜单" class="site-header__navigation-button hamburger"></button>
        </div>
        <div class="site-header__navigation-collapsible site-header__navigation-collapsible--collapse">
            <ul class="site-header__navigation-items">
                <li class="site-header__navigation-item site-header__navigation-submenu-section" tabindex="0">
                    <span class="site-header__navigation-link">社区<svg class="site-header__down-arrow site-header__icon-light" width="19" height="11" viewbox="0 0 19 11" xmlns="http://www.w3.org/2000/svg"><title>打开社区菜单</title><path transform="rotate(-180 9.374 5.494)" d="M17.9991 10.422825L9.3741 0.565575 0.7491 10.422825" stroke="#02303A" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                    </span>
                    <div class="site-header__navigation-submenu">
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://gradle.org/" target="_top" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">社区之家</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://discuss.gradle.org/" target="_top" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">社区论坛</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://plugins.gradle.org" target="_top" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">社区插件</span>
                            </a>
                        </div>
                    </div>
                </li>
                <li class="site-header__navigation-item" itemprop="name">
                    <a class="site-header__navigation-link" href="https://gradle.com/training/" target="_top" itemprop="url">训练</a>
                </li>
                <li class="site-header__navigation-item site-header__navigation-submenu-section" tabindex="0">
                    <span class="site-header__navigation-link">新闻<svg class="site-header__down-arrow site-header__icon-light" width="19" height="11" viewbox="0 0 19 11" xmlns="http://www.w3.org/2000/svg"><title>打开社区菜单</title><path transform="rotate(-180 9.374 5.494)" d="M17.9991 10.422825L9.3741 0.565575 0.7491 10.422825" stroke="#02303A" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                    </span>
                    <div class="site-header__navigation-submenu">
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://newsletter.gradle.com" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">通讯</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://blog.gradle.org" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">博客</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item">
                            <a class="site-header__navigation-submenu-item-link" href="https://twitter.com/gradle">
                                <span class="site-header__navigation-submenu-item-link-text">推特</span>
                            </a>
                        </div>
                    </div>
                </li>
                <li class="site-header__navigation-item" itemprop="name">
                    <a class="site-header__navigation-link" href="https://gradle.com" target="_top" itemprop="url">企业</a>
                </li>
                <li class="site-header__navigation-item">
                    <a class="site-header__navigation-link" title="GitHub上的Gradle" href="https://github.com/gradle/gradle"><svg width="20" height="20" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><title>的github</title><path d="M10 0C4.477 0 0 4.477 0 10c0 4.418 2.865 8.166 6.839 9.489.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.342-3.369-1.342-.454-1.155-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.831.092-.646.35-1.086.636-1.336-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.268 2.75 1.026A9.578 9.578 0 0 1 10 4.836c.85.004 1.705.114 2.504.337 1.909-1.294 2.747-1.026 2.747-1.026.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.579.688.481C17.137 18.163 20 14.418 20 10c0-5.523-4.478-10-10-10" fill="#02303A" fill-rule="evenodd"></path></svg></a>
                </li>
            </ul>
        </div>
    </nav>
</header>

<main class="main-content">
    <!-- Primary Navigation -->
    <nav class="docs-navigation">
        <div class="search-container">
            <input type="search" name="q" id="search-input" class="search-input" placeholder="搜索文档">
        </div>
        <ul>
            <li><a href="userguide.html">文件首页</a></li>
            <li><a href="https://guides.gradle.org">讲解</a></li>
            <li><a href="../release-notes.html">发行说明</a></li>
            <li><a class="nav-dropdown" href="#gradle-api" data-toggle="collapse" aria-expanded="false" aria-controls="gradle-api">Gradle API</a>
                <ul id="gradle-api">
                    <li><a href="../javadoc/index.html?overview-summary.html">Java文档</a></li>
                    <li><a href="../dsl/index.html">Groovy DSL参考</a></li>
                    <li><a href="groovy_build_script_primer.html">Groovy DSL入门</a></li>
                    <li><a href="https://gradle.github.io/kotlin-dsl-docs/api/" target="_blank">Kotlin DSL API</a></li>
                    <li><a href="kotlin_dsl.html">Kotlin DSL入门</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="user-manual">用户手册</h3>
        <div class="docs-home-link">
            <div class="pdf-link-container">
                <a href="userguide.pdf">
                    <svg width="10px" height="12px" viewbox="0 0 10 12" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M6.01302083,0.857142857 C6.2421875,0.857142857 6.4296875,1.05 6.4296875,1.28571429 L6.4296875,5.14285714 L8.875,5.14285714 C9.05989583,5.14285714 9.15364583,5.37321429 9.0234375,5.50714286 L5.29427083,9.35357143 C5.13020833,9.52232143 4.8671875,9.52232143 4.703125,9.35357143 L0.979166667,5.50714286 C0.848958333,5.37321429 0.940104167,5.14285714 1.12760417,5.14285714 L3.57291667,5.14285714 L3.57291667,1.28571429 C3.57291667,1.05 3.76041667,0.857142857 3.98958333,0.857142857 L6.01302083,0.857142857 Z M6.01302083,0 L3.98958333,0 C3.29947917,0 2.73958333,0.575892857 2.73958333,1.28571429 L2.73958333,4.28571429 L1.12760417,4.28571429 C0.203125,4.28571429 -0.265625,5.4375 0.390625,6.1125 L4.11458333,9.95892857 C4.60416667,10.4625 5.39583333,10.4625 5.88541667,9.95892857 L9.61197917,6.11517857 C10.265625,5.44285714 9.80208333,4.28839286 8.875,4.28839286 L7.26302083,4.28839286 L7.26302083,1.28571429 C7.26302083,0.575892857 6.70052083,0 6.01302083,0 Z M10,11.6785714 L10,11.4642857 C10,11.2875 9.859375,11.1428571 9.6875,11.1428571 L0.3125,11.1428571 C0.140625,11.1428571 0,11.2875 0,11.4642857 L0,11.6785714 C0,11.8553571 0.140625,12 0.3125,12 L9.6875,12 C9.859375,12 10,11.8553571 10,11.6785714 Z"></path></svg> PDF格式</a>
            </div>
        </div>
        <ul>
            <li><a href="getting_started.html">入门</a></li>
            <li><a href="installation.html">安装Gradle</a></li>
            <li><a class="nav-dropdown" href="#upgrading-gradle" data-toggle="collapse" aria-expanded="false" aria-controls="upgrading-gradle">升级Gradle ...</a>
                <ul id="upgrading-gradle">
                    <li><a href="upgrading_version_5.html">版本5。X至6.0</a></li>
                    <li><a href="upgrading_version_4.html">版本4。X至5.0</a></li>
                    <li><a href="feature_lifecycle.html">Gradle的功能生命周期</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#migrating-to-gradle" data-toggle="collapse" aria-expanded="false" aria-controls="migrating-to-gradle">迁移至Gradle ...</a>
                <ul id="migrating-to-gradle">
                    <li><a href="migrating_from_maven.html">从Maven</a></li>
                    <li><a href="migrating_from_ant.html">来自蚂蚁</a></li>
                </ul>
            </li>
            <li><a href="troubleshooting.html">对构建进行故障排除</a></li>
        </ul>

        <h3 id="running-gradle-builds">运行Gradle构建</h3>
        <ul>
            <li><a class="nav-dropdown" href="#customizing-execution" data-toggle="collapse" aria-expanded="false" aria-controls="customizing-execution">自定义执行</a>
                <ul id="customizing-execution">
                    <li><a href="build_environment.html">配置构建环境</a></li>
                    <li><a href="gradle_daemon.html">配置Gradle守护程序</a></li>
                    <li><a href="init_scripts.html">使用初始化脚本</a></li>
                </ul>
            </li>
            <li><a href="intro_multi_project_builds.html">执行多项目构建</a></li>
            <li><a href="https://guides.gradle.org/creating-build-scans/">检查Gradle构建</a></li>
            <li><a class="nav-dropdown" href="#optimizing-build-performance" data-toggle="collapse" aria-expanded="false" aria-controls="optimizing-build-performance">优化构建时间</a>
                <ul id="optimizing-build-performance">
                    <li><a href="https://guides.gradle.org/performance/">构建绩效指南</a></li>
                    <li><a href="build_cache.html">启用和配置构建缓存</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="authoring-gradle-builds">编写Gradle构建</h3>
        <ul>
            <li><a class="nav-dropdown" href="#learning-the-basics" data-toggle="collapse" aria-expanded="false" aria-controls="learning-the-basics">学习基础</a>
                <ul id="learning-the-basics">
                    <li><a href="tutorial_using_tasks.html">介绍构建脚本的基础</a></li>
                    <li><a href="more_about_tasks.html">处理任务</a></li>
                    <li><a href="writing_build_scripts.html">了解有关构建脚本的更多信息</a></li>
                    <li><a href="working_with_files.html">处理文件</a></li>
                    <li><a href="plugins.html">使用Gradle插件</a></li>
                    <li><a href="build_lifecycle.html">了解构建生命周期</a></li>
                    <li><a href="logging.html">使用记录</a></li>
                    <li><a href="multi_project_builds.html">配置多项目构建</a></li>
                    <li><a href="potential_traps.html">避免陷阱</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#authoring-sustainable-builds" data-toggle="collapse" aria-expanded="false" aria-controls="authoring-sustainable-builds">创作可持续建筑</a>
                <ul id="authoring-sustainable-builds">
                    <li><a href="organizing_gradle_projects.html">组织构建逻辑</a></li>
                    <li><a href="authoring_maintainable_build_scripts.html">遵循最佳实践</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#advanced-techniques" data-toggle="collapse" aria-expanded="false" aria-controls="advanced-techniques">先进技术</a>
            <ul id="advanced-techniques">
                <li><a href="https://guides.gradle.org/using-the-worker-api/">开发并行任务</a></li>
                <li><a href="test_kit.html">使用TestKit测试构建</a></li>
                <li><a href="ant.html">从Gradle使用Ant</a></li>
            </ul>
            </li><li><a class="nav-dropdown" href="#sample-gradle-builds" data-toggle="collapse" aria-expanded="false" aria-controls="sample-gradle-builds">Gradle项目示例</a>
                <ul id="sample-gradle-builds">
                    <li><a href="https://github.com/gradle/gradle/tree/master/subprojects/docs/src/samples">Groovy DSL样本</a></li>
                    <li><a href="https://github.com/gradle/kotlin-dsl/tree/master/samples">Kotlin DSL样本</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="authoring-gradle-builds-java">编写JVM构建</h3>
        <ul>
            <li><a href="building_java_projects.html">构建Java和JVM项目</a></li>
            <li><a href="java_testing.html">测试Java和JVM项目</a></li>
            <li><a href="dependency_management_for_java_projects.html">管理依赖关系</a></li>
            <li><a class="nav-dropdown" href="#jvm-plugins" data-toggle="collapse" aria-expanded="false" aria-controls="jvm-plugins">JVM插件</a>
                <ul id="jvm-plugins">
                    <li><a href="java_library_plugin.html">Java库插件</a></li>
                    <li><a href="application_plugin.html">Java应用程序插件</a></li>
                    <li><a href="java_platform_plugin.html">Java平台插件</a></li>
                    <li><a href="groovy_plugin.html">Groovy插件</a></li>
                    <li><a href="scala_plugin.html">Scala插件</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="authoring-gradle-builds-native">编写C ++ / Swift构建</h3>
        <ul>
            <li><a href="building_cpp_projects.html">构建C ++项目</a></li>
            <li><a href="cpp_testing.html">测试C ++项目</a></li>
            <li><a href="building_swift_projects.html">建立Swift项目</a></li>
            <li><a href="swift_testing.html">测试Swift项目</a></li>
        </ul>

        <h3 id="managing-dependencies">使用依赖项</h3>
        <ul>
            <li><a class="nav-dropdown" href="#learning-the-basics-dependency-management" data-toggle="collapse" aria-expanded="false" aria-controls="learning-the-basics-dependency-management">学习基础</a>
                <ul id="learning-the-basics-dependency-management">
                    <li><a href="core_dependency_management.html">什么是依赖管理？</a></li>
                    <li><a href="declaring_repositories.html">声明存储库</a></li>
                    <li><a href="declaring_dependencies.html">声明依赖项</a></li>
                    <li><a href="library_vs_application.html">了解库和应用程序的差异</a></li>
                    <li><a href="viewing_debugging_dependencies.html">查看和调试依赖项</a></li>
                    <li><a href="dependency_resolution.html">了解分辨率</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#declaring-dependency-versions" data-toggle="collapse" aria-expanded="false" aria-controls="declaring-dependency-versions">声明版本</a>
                <ul id="declaring-dependency-versions">
                    <li><a href="single_versions.html">声明版本和范围</a></li>
                    <li><a href="rich_versions.html">声明丰富版本</a></li>
                    <li><a href="dynamic_versions.html">处理变更版本</a></li>
                    <li><a href="dependency_locking.html">锁定版本</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#controlling-transitive-dependencies" data-toggle="collapse" aria-expanded="false" aria-controls="controlling-transitive-dependencies">控制翻译</a>
                <ul id="controlling-transitive-dependencies">
                    <li><a href="dependency_constraints.html">升级版本</a></li>
                    <li><a href="dependency_downgrade_and_exclude.html">降级和排除</a></li>
                    <li><a href="platforms.html">共享版本</a></li>
                    <li><a href="dependency_version_alignment.html">对齐依赖</a></li>
                    <li><a href="dependency_capability_conflict.html">处理互斥依赖性</a></li>
                    <li><a href="component_metadata_rules.html">修复元数据</a></li>
                    <li><a href="resolution_rules.html">自定义分辨率</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#modeling-features" data-toggle="collapse" aria-expanded="false" aria-controls="modeling-features">图书馆的生产和消费形式</a>
                <ul id="modeling-features">
                    <li><a href="component_capabilities.html">声明图书馆的能力</a></li>
                    <li><a href="feature_variants.html">建模功能变体和可选依赖项</a></li>
                    <li><a href="variant_model.html">了解变体选择</a></li>
                    <li><a href="variant_attributes.html">声明变体属性</a></li>
                    <li><a href="cross_project_publications.html">共享项目成果</a></li>
                    <li><a href="artifact_transforms.html">改造神器</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#multi-repo" data-toggle="collapse" aria-expanded="false" aria-controls="multi-repo">在多仓库环境中工作</a>
                <ul id="multi-repo">
                    <li><a href="composite_builds.html">组成建筑</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#publishing" data-toggle="collapse" aria-expanded="false" aria-controls="publishing">出版图书馆</a>
                <ul id="publishing">
                    <li><a href="publishing_setup.html">设置发布</a></li>
                    <li><a href="publishing_gradle_module_metadata.html">了解Gradle模块元数据</a></li>
                    <li><a href="publishing_signing.html">签署文物</a></li>
                    <li><a href="publishing_customization.html">定制出版</a></li>
                    <li><a href="publishing_maven.html">Maven发布插件</a></li>
                    <li><a href="publishing_ivy.html">常春藤发布插件</a></li>
                </ul>
            </li>
            <li><a href="dependency_management_terminology.html">术语</a></li>
        </ul>

        <h3 id="extending-gradle">扩展摇篮</h3>
        <ul>
            <li><a href="https://gradle.org/guides/?q=Plugin Development">插件开发教程</a></li>
            <li><a href="custom_tasks.html">编写Gradle任务类型</a></li>
            <li><a href="custom_plugins.html">编写Gradle插件</a></li>
            <li><a href="custom_gradle_types.html">编写自定义Gradle类型</a></li>
            <li><a href="lazy_configuration.html">延迟配置任务</a></li>
            <li><a href="task_configuration_avoidance.html">使用避免任务配置</a></li>
        </ul>

        <h3 id="reference">参考</h3>
        <ul>
            <li><a href="plugin_reference.html">核心插件</a></li>
            <li><a href="command_line_interface.html">命令行界面</a></li>
            <li id="third-party-integration"><a href="third_party_integration.html">Gradle和第三方工具</a></li>
            <li><a href="gradle_wrapper.html">摇篮包装</a></li>
            <li><a href="directory_layout.html">Gradle管理的目录</a></li>
        </ul>
    </nav>
    <!-- End Primary Navigation -->
    <div class="chapter">
        <aside class="chapter-meta js-chapter-meta">
            <div class="rating js-rating-widget">
                <!--NOTE: These are "backwards" because we use a right-to-left trick for hover state-->
                <i class="star js-analytics-event js-rating" title="优秀的文档" data-action="rating" data-label="5"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="好的文件" data-action="rating" data-label="4"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="确定文档" data-action="rating" data-label="3"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="文档不良" data-action="rating" data-label="2"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="无法使用的文件" data-action="rating" data-label="1"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
            </div>

            <div class="quick-edit">
                <a class="edit-link js-edit-link" href="https://github.com/gradle/gradle/edit/master/subprojects/docs/src/docs/userguide/">
                    <svg width="11px" height="12px" viewbox="0 0 11 12" version="1.1" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><g stroke="#999999" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 5.11724219 9 11.5 0.5 11.5 0.5 2.5 5 2.5"></polyline><polygon fill="#999999" points="9.59427002 0.565307617 4.31427002 5.84530762 4.31427002 6.56530762 5.03427002 6.56530762 10.31427 1.28530762"></polygon></g></svg>编辑这个页面</a>
            </div>
        </aside>
<div id="header">
<h1>学习基础</h1>
<div class="details">
<span id="revnumber">版本6.0.1</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">内容</div>
<ul class="sectlevel1">
<li><a href="#dependency_management_in_gradle">Gradle中的依赖管理</a></li>
<li><a href="#declaring-repositories">声明存储库</a></li>
<li><a href="#declaring-dependencies">声明依赖</a></li>
<li><a href="#sec:understanding-diff-libraries-and-apps">了解库和应用程序之间的区别</a></li>
<li><a href="#viewing-debugging-dependencies">查看和调试依赖项</a></li>
<li><a href="#understanding_dependency_resolution">了解依赖性解析</a></li>
<li><a href="#declaring_versions">声明版本</a>
<ul class="sectlevel1">
<li><a href="#single-version-declarations">声明版本和范围</a></li>
<li><a href="#rich-version-constraints">声明丰富版本</a></li>
<li><a href="#sec:dynamic_versions_and_changing_modules">处理随时间变化的版本</a></li>
<li><a href="#dependency-locking">锁定依赖版本</a></li>
</ul>
</li>
<li><a href="#controlling_transitive_dependencies">控制传递依存关系</a>
<ul class="sectlevel1">
<li><a href="#dependency-constraints">升级传递依赖的版本</a></li>
<li><a href="#downgrading_versions_and_excluding_dependencies">降级版本并排除依赖项</a></li>
<li><a href="#sec:using-platform-to-control-transitive-deps">在项目之间共享依赖版本</a></li>
<li><a href="#version_alignment">对齐依赖版本</a></li>
<li><a href="#sec:handling-mutually-exclusive-deps">处理互斥依赖性</a></li>
<li><a href="#sec:component_metadata_rules">使用组件元数据规则修复元数据</a></li>
<li><a href="#resolution_rules">直接自定义依赖项的解析</a></li>
</ul>
</li>
<li><a href="#producing_and_consuming_variants_of_libraries">图书馆的生产和消费形式</a>
<ul class="sectlevel1">
<li><a href="#declaring-component-capabilities">声明图书馆的能力</a></li>
<li><a href="#feature_variants">建模功能变体和可选依赖项</a></li>
<li><a href="#understanding-variant-selection">了解变体选择</a></li>
<li><a href="#variant_attributes">使用变体属性</a></li>
<li><a href="#cross_project_publications">在项目之间共享输出</a></li>
<li><a href="#sec:abm_artifact_transforms">转换解决方案上的依赖工件</a></li>
</ul>
</li>
<li><a href="#working_in_a_multi_repo_environment">在多仓库环境中工作</a>
<ul class="sectlevel1">
<li><a href="#composite_builds">组成作品</a></li>
</ul>
</li>
<li><a href="#publishing_libraries">出版图书馆</a>
<ul class="sectlevel1">
<li><a href="#publishing_components">将项目发布为模块</a></li>
<li><a href="#sec:understanding-gradle-module-md">了解Gradle模块元数据</a></li>
<li><a href="#publishing_maven:signing">签名文物</a></li>
<li><a href="#customizing_publishing">定制发布</a></li>
<li><a href="#dependency_management_terminology">依赖管理术语</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="dependency_management_in_gradle"><a class="anchor" href="#dependency_management_in_gradle"></a> <a class="link" href="#dependency_management_in_gradle">Gradle中的依赖管理</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what_is_dependency_management"><a class="anchor" href="#what_is_dependency_management"></a> <a class="link" href="#what_is_dependency_management">什么是依赖管理？</a></h3>
<div class="paragraph">
<p>软件项目很少单独工作。在大多数情况下，项目依赖于库形式的可重用功能，或者分解为单个组件以构成模块化系统。依赖性管理是一种用于以自动化方式声明，解决和使用项目所需依赖性的技术。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>有关整个用户指南中使用的术语的一般概述，请参阅“ <a href="#">依赖关系管理术语”</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sec:dependency-mgmt-in-gradle"><a class="anchor" href="#sec:dependency-mgmt-in-gradle"></a> <a class="link" href="#sec:dependency-mgmt-in-gradle">Gradle中的依赖管理</a></h3>
<div class="paragraph">
<p>Gradle内置了对依赖项管理的支持，并且可以完成现代软件项目中遇到的典型方案。我们将在示例项目的帮助下探索主要概念。下图将为您简要概述所有活动部件。</p>
</div>
<div class="imageblock inset">
<div class="content">
<img src="img/dependency-management-resolution.png" alt="依赖管理解决方案">
</div>
<div class="title">图1。依赖管理大图</div>
</div>
<div class="paragraph">
<p>该示例项目将构建Java源代码。一些Java源文件从<a href="https://github.com/google/guava">Google Guava</a> （一个提供大量实用程序功能的开源库）中导入类。除了Guava，该项目还需要<a href="http://junit.org/junit5/">JUnit</a>库来编译和执行测试代码。</p>
</div>
<div class="paragraph">
<p>Guava和JUnit表示此项目的<em>依赖</em>项。构建脚本开发人员可以<a href="#declaring-dependencies">声明</a>不同范围的<a href="#declaring-dependencies">依赖关系</a> ，例如仅用于源代码的编译或用于执行测试。在Gradle中， <a href="#sec:what-are-dependency-configurations">依赖项</a>的<a href="#sec:what-are-dependency-configurations">范围</a>称为<em>configuration</em> 。有关完整概述，请参见有关<a href="#sec:dependency-types">依赖项类型</a>的参考资料。</p>
</div>
<div class="paragraph">
<p>通常，依赖项以<a href="#sub:terminology_module">模块</a>的形式出现。您需要告诉Gradle在哪里可以找到那些模块，以便构建可以使用它们。用于存储模块的位置称为<em>存储库</em> 。通过为构建<a href="#declaring-repositories">声明存储库</a> ，Gradle将知道如何查找和检索模块。存储库可以采用不同的形式：作为本地目录或远程存储库。有关<a href="#sec:repository-types">存储库类型</a>的参考对此主题进行了广泛介绍。</p>
</div>
<div class="paragraph">
<p>在运行时，如果需要执行特定任务，Gradle将定位声明的依赖项。依赖项可能需要从远程存储库下载，从本地目录检索，或者需要在多项目设置中构建另一个项目。此过程称为<em>依赖关系解析</em> 。您可以在<a href="#sec:how-gradle-downloads-deps">Gradle如何下载依赖项中</a>找到详细的讨论。</p>
</div>
<div class="paragraph">
<p>解决后，解析机制<a href="#sec:dependency_cache">会将依赖项的基础文件存储在本地缓存</a> （也称为<em>依赖项缓存）中</em> 。将来的版本会重复使用存储在缓存中的文件，以避免不必要的网络调用。</p>
</div>
<div class="paragraph">
<p>模块可以提供其他元数据。元数据是更详细地描述模块的数据，例如用于在存储库中找到模块的坐标，有关项目或其作者的信息。作为元数据的一部分，一个模块可以定义需要其他模块才能使其正常工作。例如，JUnit 5平台模块还需要平台公共模块。Gradle会自动解析那些额外的模块，即所谓的<em>传递依赖</em> 。如果需要，您可以<a href="#">自定义行为，</a>以根据您的项目需求来<a href="#">处理传递依赖项</a> 。</p>
</div>
<div class="paragraph">
<p>具有数十个或数百个已声明依赖项的项目很容易遭受依赖地狱之苦。Gradle提供了足够的工具来借助<a href="https://scans.gradle.com/get-started">构建扫描</a>或内置任务来可视化，导航和分析项目的依赖关系图。在<a href="#viewing-debugging-dependencies">查看和调试依赖项中</a>了解更多信息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/gradle-core-test-build-scan-dependencies.png" alt="gradle核心测试构建扫描依赖项">
</div>
<div class="title">图2。构建扫描依赖项报告</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="declaring-repositories"><a class="anchor" href="#declaring-repositories"></a> <a class="link" href="#declaring-repositories">声明存储库</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle可以基于Maven，Ivy或平面目录格式解决来自一个或多个存储库的依赖关系。<a href="#sec:repository-types">有关所有信息</a> ，请查看<a href="#sec:repository-types">所有类型存储库</a>的<a href="#sec:repository-types">完整参考</a> 。</p>
</div>
<div class="sect2">
<h3 id="sec:declaring_public_repository"><a class="anchor" href="#sec:declaring_public_repository"></a> <a class="link" href="#sec:declaring_public_repository">声明一个公开可用的存储库</a></h3>
<div class="paragraph">
<p>构建软件的组织可能希望利用公共二进制存储库来下载和使用开源依赖项。流行的公共存储库包括<a href="#sub:maven_central">Maven Central</a> ， <a href="#sub:maven_jcenter">Bintray JCenter</a>和<a href="#sub:maven_google">Google Android</a>存储库。Gradle为这些广泛使用的存储库提供了内置的速记符号。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-shortcut-repositories.png" alt="依赖管理快捷方式存储库">
</div>
<div class="title">图3。在速记符号的帮助下声明存储库</div>
</div>
<div class="paragraph">
<p>在幕后，Gradle解析了由速记符号定义的公共存储库的相应URL中的依赖性。所有速记符号均可通过<a href="../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html">RepositoryHandler</a> API获得。或者，您可以<a href="#sec:declaring_custom_repository">拼出存储库的URL以</a>进行更细粒度的控制。</p>
</div>
<div class="sect3">
<h4 id="sub:maven_central"><a class="anchor" href="#sub:maven_central"></a> <a class="link" href="#sub:maven_central">Maven Central存储库</a></h4>
<div class="paragraph">
<p>Maven Central是一个流行的存储库，托管开放源代码库供Java项目使用。</p>
</div>
<div class="paragraph">
<p>要为您的构建声明<a href="https://repo.maven.apache.org/maven2/">Maven Central存储库</a> ，请将其添加到脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">范例1。添加中央Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:maven_jcenter"><a class="anchor" href="#sub:maven_jcenter"></a> <a class="link" href="#sub:maven_jcenter">JCenter Maven存储库</a></h4>
<div class="paragraph">
<p><a href="http://bintray.com">Bintray</a>的JCenter是所有流行的Maven OSS工件的最新集合，包括直接发布到Bintray的工件。</p>
</div>
<div class="paragraph">
<p>要声明<a href="https://jcenter.bintray.com">JCenter Maven存储库，</a>请将其添加到您的构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">示例2添加Bintray的JCenter Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:maven_google"><a class="anchor" href="#sub:maven_google"></a> <a class="link" href="#sub:maven_google">Google Maven存储库</a></h4>
<div class="paragraph">
<p>Google存储库托管Android特定的工件，包括Android SDK。有关使用示例，请参阅<a href="https://developer.android.com/studio/build/dependencies.html#google-maven">相关的Android文档</a> 。</p>
</div>
<div class="paragraph">
<p>要声明<a href="https://maven.google.com/">Google Maven存储库，</a>请将其添加到您的构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">范例3。添加Google Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    google()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    google()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:declaring_custom_repository"><a class="anchor" href="#sec:declaring_custom_repository"></a> <a class="link" href="#sec:declaring_custom_repository">通过URL声明自定义存储库</a></h3>
<div class="paragraph">
<p>大多数企业项目都建立了仅在Intranet中可用的二进制存储库。内部存储库使团队可以发布内部二进制文件，设置用户管理和安全措施并确保正常运行时间和可用性。如果要声明一个不太受欢迎但可公开使用的存储库，则指定自定义URL也很有用。</p>
</div>
<div class="paragraph">
<p>通过调用<a href="../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html">RepositoryHandler</a> API上可用的相应方法，可以将具有自定义URL的存储库指定为Maven或Ivy存储<a href="../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html">库</a> 。 Gradle还支持其他协议<code>http</code>要么<code>https</code>作为自定义网址的一部分，例如<code>file</code> ， <code>sftp</code>要么<code>s3</code> 。有关完整信息，请参见<a href="#sec:repository-types">有关支持的存储库类型</a>的<a href="#sec:repository-types">部分</a> 。</p>
</div>
<div class="paragraph">
<p>您还<a href="#sub:defining_custom_pattern_layout_for_an_ivy_repository">可以</a>使用以下方法<a href="#sub:defining_custom_pattern_layout_for_an_ivy_repository">定义自己的存储库布局</a> <code>ivy { }</code>存储库，因为它们在存储库中模块的组织方式方面非常灵活。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:declaring_multiple_repositories"><a class="anchor" href="#sec:declaring_multiple_repositories"></a> <a class="link" href="#sec:declaring_multiple_repositories">声明多个存储库</a></h3>
<div class="paragraph">
<p>您可以定义多个存储库来解决依赖关系。如果某些依赖项仅在一个存储库中可用而在另一个存储库中不可用，则声明多个存储库将很有帮助。您可以混合<a href="#sec:repository-types">参考部分中</a>描述的任何类型的存储库。</p>
</div>
<div class="paragraph">
<p>此示例演示如何为项目声明各种命名和自定义URL存储库：</p>
</div>
<div class="exampleblock">
<div class="title">示例4声明多个存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    jcenter()
    maven {
        url "https://maven.springframework.org/release"
    }
    maven {
        url "https://maven.restlet.com"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    jcenter()
    maven {
        url = uri("https://maven.springframework.org/release")
    }
    maven {
        url = uri("https://maven.restlet.com")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>声明的顺序决定了Gradle在运行时如何检查依赖关系。如果Gradle在特定存储库中找到模块描述符，它将尝试从<em>同一存储库</em>下载该模块的所有工件。您可以了解有关<a href="#sec:how-gradle-downloads-deps">依赖项下载</a>的内部工作的更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="strict_limitation_to_declared_repositories"><a class="anchor" href="#strict_limitation_to_declared_repositories"></a> <a class="link" href="#strict_limitation_to_declared_repositories">严格限制已声明的存储库</a></h4>
<div class="paragraph">
<p>Maven POM元数据可以引用其他存储库。这些将被Gradle <em>忽略</em> ，Gradle将仅使用构建本身中声明的存储库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>这是可重现的安全保护措施，也是安全保护措施。没有它，依赖项的更新版本可能会将工件从任何地方拉入构建。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:repository-types"><a class="anchor" href="#sec:repository-types"></a> <a class="link" href="#sec:repository-types">支持的存储库类型</a></h3>
<div class="paragraph">
<p>Gradle在格式和连接性方面都支持多种依赖项源。您可以通过以下方式解决依赖关系：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不同格式</p>
<div class="ulist">
<ul>
<li>
<p>一个与<a href="#sec:maven_repo">Maven兼容的</a>工件存储库（例如：Maven Central，JCenter等）</p>
</li>
<li>
<p><a href="#sec:ivy_repositories">常春藤兼容的</a>工件存储库（包括自定义布局）</p>
</li>
<li>
<p><a href="#sub:flat_dir_resolver">本地（平面）目录</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>具有不同的连接性</p>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:authentication_schemes">认证存储库</a></p>
</li>
<li>
<p>多种<a href="#sec:supported_transport_protocols">远程协议，</a>例如HTTPS，SFTP，AWS S3和Google Cloud Storage</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="sub:flat_dir_resolver"><a class="anchor" href="#sub:flat_dir_resolver"></a> <a class="link" href="#sub:flat_dir_resolver">平面目录存储库</a></h4>
<div class="paragraph">
<p>一些项目可能更喜欢将依赖项存储在共享驱动器上，或者作为项目源代码的一部分存储，而不是二进制存储库产品。如果要将（平面）文件系统目录用作存储库，只需键入：</p>
</div>
<div class="exampleblock">
<div class="title">示例5平面存储库解析器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    flatDir {
        dirs 'lib'
    }
    flatDir {
        dirs 'lib1', 'lib2'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    flatDir {
        dirs("lib")
    }
    flatDir {
        dirs("lib1", "lib2")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将添加存储库，这些存储库将查找一个或多个目录以查找依赖项。</p>
</div>
<div class="paragraph">
<p>这种类型的存储库不支持任何元数据格式，例如Ivy XML或Maven POM文件。取而代之的是，Gradle将根据工件的存在情况动态生成模块描述符（不包含任何依赖项信息）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>由于Gradle倾向于使用其描述符是从真实的元数据创建而不是生成的模块，因此无法使用平面目录存储库来覆盖构建中声明的其他存储库中带有真实元数据的工件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，如果Gradle仅找到<code>jmxri-1.2.1.jar</code>在平面目录存储库中，但是<code>jmxri-1.2.1.pom</code>在另一个支持元数据的存储库中，它将使用第二个存储库来提供模块。</p>
</div>
<div class="paragraph">
<p>对于用本地对象覆盖远程工件的用例，请考虑使用Ivy或Maven存储库，而不是其URL指向本地目录。</p>
</div>
<div class="paragraph">
<p>如果仅使用平面目录存储库，则无需设置依赖项的所有属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:local-repos"><a class="anchor" href="#sub:local-repos"></a> <a class="link" href="#sub:local-repos">本地存储库</a></h4>
<div class="paragraph">
<p>以下各节描述存储库格式（Maven或Ivy）。可以使用本地文件系统路径将它们声明为本地存储库。</p>
</div>
<div class="paragraph">
<p>平面目录存储库的不同之处在于它们确实遵循一种格式并包含元数据。</p>
</div>
<div class="paragraph">
<p>配置了这样的存储库后，Gradle将完全绕过其<a href="#sec:dependency_cache">依赖项缓存</a> ，因为无法保证内容在两次执行之间不会发生变化。由于该限制，它们可能会对性能产生影响。</p>
</div>
<div class="paragraph">
<p>它们还使构建的可复制性变得更难实现，应将其使用限制为修补或原型制作。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:maven_repo"><a class="anchor" href="#sec:maven_repo"></a> <a class="link" href="#sec:maven_repo">Maven仓库</a></h3>
<div class="paragraph">
<p>许多组织将依赖项托管在内部Maven存储库中，该存储库只能在公司的网络中访问。Gradle可以通过URL声明Maven存储库。</p>
</div>
<div class="paragraph">
<p>要添加自定义Maven存储库，您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">范例6。添加自定义Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "http://repo.mycompany.com/maven2"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("http://repo.mycompany.com/maven2")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:custom-maven-repo"><a class="anchor" href="#sub:custom-maven-repo"></a> <a class="link" href="#sub:custom-maven-repo">设置复合Maven存储库</a></h4>
<div class="paragraph">
<p>有时，存储库会将POM发布到一个位置，并将JAR和其他工件发布到另一位置。要定义这样的存储库，您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">范例7。为JAR文件添加其他Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        // Look for POMs and artifacts, such as JARs, here
        url "http://repo2.mycompany.com/maven2"
        // Look for artifacts here if not found at the above location
        artifactUrls "http://repo.mycompany.com/jars"
        artifactUrls "http://repo.mycompany.com/jars2"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        // Look for POMs and artifacts, such as JARs, here
        url = uri("http://repo2.mycompany.com/maven2")
        // Look for artifacts here if not found at the above location
        artifactUrls("http://repo.mycompany.com/jars")
        artifactUrls("http://repo.mycompany.com/jars2")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>摇篮将看基地<code>url</code> POM和JAR的位置。如果找不到JAR，则多余的<code>artifactUrls</code>用于查找JAR。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:accessing_secured_maven_repositories"><a class="anchor" href="#sub:accessing_secured_maven_repositories"></a> <a class="link" href="#sub:accessing_secured_maven_repositories">访问经过身份验证的Maven存储库</a></h4>
<div class="paragraph">
<p>您可以为通过不同身份验证类型保护的Maven存储库指定凭据。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#sec:supported_transport_protocols">支持的存储库传输协议</a>以获取认证选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:maven_local"><a class="anchor" href="#sub:maven_local"></a> <a class="link" href="#sub:maven_local">本地Maven存储库</a></h4>
<div class="paragraph">
<p>Gradle可以使用<a href="https://maven.apache.org/guides/introduction/introduction-to-repositories.html">本地Maven存储库中</a>可用的依赖项。声明此存储库对于使用一个项目发布到本地Maven存储库并在另一个项目中使用Gradle消耗工件的团队来说是有益的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>Gradle将已解决的依赖性存储在<a href="#sec:dependency_cache">其自己的缓存中</a> 。即使您从基于Maven的远程存储库中解决依赖关系，构建也无需声明本地Maven存储库。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>在将Maven local添加为存储库之前，您应<a href="#sec:case-for-maven-local">确保确实需要这样做</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要将本地Maven缓存声明为存储库，请将其添加到构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">范例8。将本地Maven缓存添加为存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    mavenLocal()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    mavenLocal()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle使用与Maven相同的逻辑来标识本地Maven缓存的位置。如果在<code>settings.xml</code> ，将使用此位置。的<code>settings.xml</code>在<code><em>USER_HOME</em>/.m2</code>优先于<code>settings.xml</code>在<code><em>M2_HOME</em>/conf</code> 。如果不<code>settings.xml</code>可用，Gradle使用默认位置<code><em>USER_HOME</em>/.m2/repository</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:case-for-maven-local"><a class="anchor" href="#sec:case-for-maven-local"></a> <a class="link" href="#sec:case-for-maven-local">mavenLocal（）的情况</a></h3>
<div class="paragraph">
<p>作为一般建议，您应避免添加<code>mavenLocal()</code>作为存储库。使用中存在不同的问题<code>mavenLocal()</code>您应该注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven将其用作缓存而不是存储库，这意味着它可以包含部分模块。</p>
<div class="ulist">
<ul>
<li>
<p>例如，如果Maven从不下载给定模块的源文件或javadoc文件，则Gradle将不会找到它们，因为一旦找到模块，它就会<a href="#sec:how-gradle-downloads-deps">在单个存储库中搜索文件</a> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>作为<a href="#sub:local-repos">本地存储库</a> ，Gradle不信任其内容，因为：</p>
<div class="ulist">
<ul>
<li>
<p>无法追踪工件的来源，这是正确性和安全性问题</p>
</li>
<li>
<p>工件很容易被覆盖，这是一个安全性，正确性和可再现性问题</p>
</li>
</ul>
</div>
</li>
<li>
<p>为了缓解元数据和/或工件可以更改的事实，Gradle不对<a href="#sub:local-repos">本地存储库</a>执行<a href="#sec:dependency_cache">任何缓存</a></p>
<div class="ulist">
<ul>
<li>
<p>因此，您的构建速度较慢</p>
</li>
<li>
<p>鉴于存储库的顺序很重要，因此添加<code>mavenLocal()</code> <em>首先</em>意味着您的所有构建都会变慢</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>在某些情况下，您可能需要使用<code>mavenLocal()</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为了与Maven互操作</p>
<div class="ulist">
<ul>
<li>
<p>例如，项目A是使用Maven构建的，项目B是使用Gradle构建的，并且您需要在开发过程中共享工件</p>
</li>
<li>
<p><em>总是</em>最好使用内部功能齐全的存储库来代替</p>
</li>
<li>
<p>如果无法做到这一点，则应将其限制为<em>仅本地构建</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>与Gradle本身的互操作性</p>
<div class="ulist">
<ul>
<li>
<p>在多存储库环境中，您要检查对项目A的更改是否与项目B一起使用</p>
</li>
<li>
<p>对于此用例，最好使用<a href="#composite_builds">复合构建</a></p>
</li>
<li>
<p>如果由于某种原因，既无法构建复合版本，也不具有功能齐全的存储库，则<code>mavenLocal()</code>是不得已的选择</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>在所有这些警告之后，如果最终使用<code>mavenLocal()</code> ，请考虑将其与<a href="#sec:repository-content-filtering">存储库过滤器</a>结合使用。这将确保它仅提供预期的内容，而不会提供其他任何内容。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:ivy_repositories"><a class="anchor" href="#sec:ivy_repositories"></a> <a class="link" href="#sec:ivy_repositories">常春藤仓库</a></h3>
<div class="paragraph">
<p>组织可能决定将依赖项托管在内部Ivy存储库中。Gradle可以通过URL声明Ivy存储库。</p>
</div>
<div class="sect3">
<h4 id="sub:defining_an_ivy_repository_with_a_standard_layout"><a class="anchor" href="#sub:defining_an_ivy_repository_with_a_standard_layout"></a> <a class="link" href="#sub:defining_an_ivy_repository_with_a_standard_layout">使用标准布局定义常春藤存储库</a></h4>
<div class="paragraph">
<p>要使用标准布局声明常春藤存储库，不需要其他自定义。您只需声明URL。</p>
</div>
<div class="exampleblock">
<div class="title">范例9。常春藤仓库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url "http://repo.mycompany.com/repo"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("http://repo.mycompany.com/repo")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:defining_a_named_layout_for_an_ivy_repository"><a class="anchor" href="#sub:defining_a_named_layout_for_an_ivy_repository"></a> <a class="link" href="#sub:defining_a_named_layout_for_an_ivy_repository">定义常春藤存储库的命名布局</a></h4>
<div class="paragraph">
<p>您可以使用命名布局来指定存储库符合Ivy或Maven默认布局。</p>
</div>
<div class="exampleblock">
<div class="title">示例10具有命名布局的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url "http://repo.mycompany.com/repo"
        layout "maven"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("http://repo.mycompany.com/repo")
        layout("maven")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有效的命名布局值为<code>'gradle'</code> （默认）， <code>'maven'</code>和<code>'ivy'</code> 。参见<a href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html#org.gradle.api.artifacts.repositories.IvyArtifactRepository:layout(java.lang.String)">IvyArtifactRepository.layout（java.lang。API文档中的字符串）</a>以获取这些命名布局的详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:defining_custom_pattern_layout_for_an_ivy_repository"><a class="anchor" href="#sub:defining_custom_pattern_layout_for_an_ivy_repository"></a> <a class="link" href="#sub:defining_custom_pattern_layout_for_an_ivy_repository">定义常春藤存储库的自定义模式布局</a></h4>
<div class="paragraph">
<p>要使用非标准布局定义常春藤存储库，可以为存储库定义<em>模式</em>布局：</p>
</div>
<div class="exampleblock">
<div class="title">示例11具有模式布局的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url "http://repo.mycompany.com/repo"
        patternLayout {
            artifact "[module]/[revision]/[type]/[artifact].[ext]"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("http://repo.mycompany.com/repo")
        patternLayout {
            artifact("[module]/[revision]/[type]/[artifact].[ext]")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要定义从不同位置获取Ivy文件和工件的Ivy存储库，可以定义单独的模式以用于定位Ivy文件和工件：</p>
</div>
<div class="paragraph">
<p>每<code>artifact</code>要么<code>ivy</code>为存储库指定的内容会添加<em>其他</em>模式以供使用。模式按照定义的顺序使用。</p>
</div>
<div class="exampleblock">
<div class="title">范例12。具有多个自定义模式的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url "http://repo.mycompany.com/repo"
        patternLayout {
            artifact "3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"
            artifact "company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"
            ivy "ivy-files/[organisation]/[module]/[revision]/ivy.xml"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("http://repo.mycompany.com/repo")
        patternLayout {
            artifact("3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]")
            artifact("company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]")
            ivy("ivy-files/[organisation]/[module]/[revision]/ivy.xml")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>（可选）具有模式布局的存储库可以具有其<code>'organisation'</code>零件以Maven样式布置，正斜杠代替点作为分隔符。例如，组织<code>my.company</code>然后将表示为<code>my/company</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">范例13。具有Maven兼容布局的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url "http://repo.mycompany.com/repo"
        patternLayout {
            artifact "[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"
            m2compatible = true
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("http://repo.mycompany.com/repo")
        patternLayout {
            artifact("[organisation]/[module]/[revision]/[artifact]-[revision].[ext]")
            setM2compatible(true)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:accessing_secured_ivy_repositories"><a class="anchor" href="#sub:accessing_secured_ivy_repositories"></a> <a class="link" href="#sub:accessing_secured_ivy_repositories">访问经过身份验证的常春藤存储库</a></h4>
<div class="paragraph">
<p>您可以为通过基本身份验证保护的Ivy存储库指定凭据。</p>
</div>
<div class="exampleblock">
<div class="title">范例14。具有身份验证的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url "http://repo.mycompany.com"
        credentials {
            username "user"
            password "password"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("http://repo.mycompany.com")
        credentials {
            username = "user"
            password = "password"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="#sec:supported_transport_protocols">支持的存储库传输协议</a>以获取认证选项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:repository-content-filtering"><a class="anchor" href="#sec:repository-content-filtering"></a> <a class="link" href="#sec:repository-content-filtering">储存库内容过滤</a></h3>
<div class="paragraph">
<p>Gradle公开了一个API，以声明存储库可能包含或不包含的内容。有不同的用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>性能，当您知道在特定存储库中永远找不到依赖项时</p>
</li>
<li>
<p>通过避免泄漏私有项目中使用的依赖项来确保安全性</p>
</li>
<li>
<p>可靠性，当某些存储库包含损坏的元数据或工件时</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑到存储库的声明顺序很重要，这一点甚至更为重要。</p>
</div>
<div class="sect3">
<h4 id="declaring_a_repository_filter"><a class="anchor" href="#declaring_a_repository_filter"></a> <a class="link" href="#declaring_a_repository_filter">声明存储库过滤器</a></h4>
<div class="exampleblock">
<div class="title">示例15声明存储库内容</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "https://repo.mycompany.com/maven2"
        content {
            // this repository *only* contains artifacts with group "my.company"
            includeGroup "my.company"
        }
    }
    jcenter {
        content {
            // this repository contains everything BUT artifacts with group starting with "my.company"
            excludeGroupByRegex "my\\.company.*"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("https://repo.mycompany.com/maven2")
        content {
            // this repository *only* contains artifacts with group "my.company"
            includeGroup("my.company")
        }
    }
    jcenter {
        content {
            // this repository contains everything BUT artifacts with group starting with "my.company"
            excludeGroupByRegex("my\\.company.*")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，存储库包含所有内容，不包含任何内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果声明包含，那么它排除了一切<em>，但</em>包含的内容。</p>
</li>
<li>
<p>如果声明一个排除项，则它包括<em>除</em>排除项以外的所有内容。</p>
</li>
<li>
<p>如果声明包含和排除，则它仅包括显式包括但不排除的内容。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过显式<em>group</em> ， <em>module</em>或<em>version</em>严格或使用正则表达式进行过滤。有关详细信息，请参见<a href="../javadoc/org/gradle/api/artifacts/repositories/RepositoryContentDescriptor.html">RepositoryContentDescriptor</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="maven_repository_filtering"><a class="anchor" href="#maven_repository_filtering"></a> <a class="link" href="#maven_repository_filtering">Maven存储库过滤</a></h4>
<div class="paragraph">
<p>对于<a href="#sec:maven_repo">Maven存储库</a> ，通常情况下，存储库将包含发行版或快照。Gradle允许您声明使用此DSL在存储库中找到哪种工件：</p>
</div>
<div class="exampleblock">
<div class="title">示例16。分割快照和发行版</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "https://repo.mycompany.com/releases"
        mavenContent {
            releasesOnly()
        }
    }
    maven {
        url "https://repo.mycompany.com/snapshots"
        mavenContent {
            snapshotsOnly()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("https://repo.mycompany.com/releases")
        mavenContent {
            releasesOnly()
        }
    }
    maven {
        url = uri("https://repo.mycompany.com/snapshots")
        mavenContent {
            snapshotsOnly()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:supported_metadata_sources"><a class="anchor" href="#sec:supported_metadata_sources"></a> <a class="link" href="#sec:supported_metadata_sources">支持的元数据源</a></h3>
<div class="paragraph">
<p>在存储库中搜索模块时，默认情况下，Gradle会检查该存储库中<a href="#sec:supported-metadata-formats">受支持的元数据文件格式</a> 。在Maven存储库中，Gradle查找一个<code>.pom</code>文件，在常春藤存储库中查找<code>ivy.xml</code>文件，并在平面目录存储库中直接查找<code>.jar</code>文件，因为它不需要任何元数据。从5.0开始，Gradle还会寻找<code>.module</code> （Gradle模块元数据）文件。</p>
</div>
<div class="paragraph">
<p>但是，如果定义自定义存储库，则可能需要配置此行为。例如，您可以定义一个Maven存储库，而无需<code>.pom</code>文件，但只有jar。为此，您可以为任何存储库配置<em>元数据源</em> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例17支持不带元数据的工件的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "http://repo.mycompany.com/repo"
        metadataSources {
            mavenPom()
            artifact()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("http://repo.mycompany.com/repo")
        metadataSources {
            mavenPom()
            artifact()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以指定多个源来告诉Gradle继续查找是否找不到文件。在这种情况下，检查源的顺序是预定义的。</p>
</div>
<div class="paragraph">
<p>支持以下元数据源：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表格1。储存库传输协议</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">元数据源</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">订购</th>
<th class="tableblock halign-left valign-top">马文</th>
<th class="tableblock halign-left valign-top">常春藤/平目录</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gradleMetadata()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">寻找摇篮<code>.module</code>档案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第一</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mavenPom()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">寻找Maven <code>.pom</code>档案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第二名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ivyDescriptor()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">寻找<code>ivy.xml</code>档案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第二名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>artifact()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">直接寻找伪像</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第三名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ivy和Maven存储库的默认值随Gradle 6.0更改。在6.0之前， <code>artifact()</code>已包含在默认值中。当模块完全丢失时导致效率低下。要恢复此行为，例如，对于Maven Central，可以使用<code>mavenCentral { metadataSources { mavenPom(); artifact() } }</code> 。以类似的方式，您可以使用以下方式选择旧版Gradle中的新行为<code>mavenCentral { metadataSources { mavenPom() } }</code></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从Gradle 5.3开始，在解析元数据文件（无论是Ivy还是Maven）时，Gradle将寻找一个标记，指示存在匹配的Gradle Module元数据文件。如果找到它，它将代替Ivy或Maven文件使用。</p>
</div>
<div class="paragraph">
<p>从Gradle 5.6开始，您可以通过添加来禁用此行为<code>ignoreGradleMetadataRedirection()</code>到metadataSources声明。</p>
</div>
<div class="exampleblock">
<div class="title">示例18不使用Gradle元数据重定向的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "http://repo.mycompany.com/repo"
        metadataSources {
            mavenPom()
            artifact()
            ignoreGradleMetadataRedirection()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("http://repo.mycompany.com/repo")
        metadataSources {
            mavenPom()
            artifact()
            ignoreGradleMetadataRedirection()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:plugin-vs-build-repos"><a class="anchor" href="#sec:plugin-vs-build-repos"></a> <a class="link" href="#sec:plugin-vs-build-repos">插件存储库与构建存储库</a></h3>
<div class="paragraph">
<p>在构建期间，Gradle将在两个不同的阶段使用存储库。</p>
</div>
<div class="paragraph">
<p>第一阶段是在<a href="build_lifecycle.html#sec:build_phases">配置构建</a>并加载其应用的插件时。为此，Gradle将使用一组特殊的存储库。</p>
</div>
<div class="paragraph">
<p>第二阶段是在依赖关系解析期间。此时，Gradle将使用项目中声明的存储库，如前几节所示。</p>
</div>
<div class="sect3">
<h4 id="sub:plugin-repos"><a class="anchor" href="#sub:plugin-repos"></a> <a class="link" href="#sub:plugin-repos">插件存储库</a></h4>
<div class="paragraph">
<p>默认情况下，Gradle将使用<a href="http://plugins.gradle.org">Gradle插件门户</a>来查找插件。</p>
</div>
<div class="paragraph">
<p>但是，由于不同的原因，在其他公共存储库或非公共存储库中都有可用的插件。当构建需要这些插件之一时，需要指定其他存储库，以便Gradle知道要在哪里搜索。</p>
</div>
<div class="paragraph">
<p>由于声明存储库的方式及其预期包含的内容取决于插件的应用方式，因此最好参考<a href="plugins.html#sec:custom_plugin_repositories">Custom Plugin Repositories</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:supported_transport_protocols"><a class="anchor" href="#sec:supported_transport_protocols"></a> <a class="link" href="#sec:supported_transport_protocols">支持的存储库传输协议</a></h3>
<div class="paragraph">
<p>Maven和Ivy存储库支持使用各种传输协议。目前支持以下协议：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表2。储存库传输协议</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">凭证类型</th>
<th class="tableblock halign-left valign-top">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>file</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户名密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:authentication_schemes">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>https</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户名密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:authentication_schemes">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sftp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户名密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:authentication_schemes">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s3</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问密钥/秘密密钥/会话令牌或环境变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:s3-repositories">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gcs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://developers.google.com/identity/protocols/application-default-credentials">默认应用程序凭据</a>来自众所周知的文件，环境变量等。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:gcs-repositories">文献资料</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>用户名和密码绝对不应作为构建文件的一部分以纯文本格式输入版本控制中。您可以将凭据存储在本地<code>gradle.properties</code>文件并使用开源Gradle插件之一来加密和使用凭证，例如<a href="https://plugins.gradle.org/plugin/nu.studer.credentials">凭证插件</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>传输协议是存储库URL定义的一部分。以下构建脚本演示了如何创建基于HTTP的Maven和Ivy存储库：</p>
</div>
<div class="exampleblock">
<div class="title">示例19声明一个Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "http://repo.mycompany.com/maven2"
    }

    ivy {
        url "http://repo.mycompany.com/repo"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("http://repo.mycompany.com/maven2")
    }

    ivy {
        url = uri("http://repo.mycompany.com/repo")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何声明SFTP存储库：</p>
</div>
<div class="exampleblock">
<div class="title">示例20对存储库使用SFTP协议</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "sftp://repo.mycompany.com:22/maven2"
        credentials {
            username "user"
            password "password"
        }
    }

    ivy {
        url "sftp://repo.mycompany.com:22/repo"
        credentials {
            username "user"
            password "password"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("sftp://repo.mycompany.com:22/maven2")
        credentials {
            username = "user"
            password = "password"
        }
    }

    ivy {
        url = uri("sftp://repo.mycompany.com:22/repo")
        credentials {
            username = "user"
            password = "password"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关HTTP相关身份验证的详细信息，请参阅“ <a href="#sec:authentication_schemes">HTTP（S）身份验证方案配置”部分</a> 。</p>
</div>
<div class="paragraph">
<p>使用支持AWS S3的存储库时，您需要使用<a href="../dsl/org.gradle.api.credentials.AwsCredentials.html">AwsCredentials</a>进行身份验证，并提供访问密钥和私钥。以下示例显示了如何声明S3支持的存储库并提供AWS凭证：</p>
</div>
<div class="exampleblock">
<div class="title">示例21声明一个S3支持的Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "s3://myCompanyBucket/maven2"
        credentials(AwsCredentials) {
            accessKey "someKey"
            secretKey "someSecret"
            // optional
            sessionToken "someSTSToken"
        }
    }

    ivy {
        url "s3://myCompanyBucket/ivyrepo"
        credentials(AwsCredentials) {
            accessKey "someKey"
            secretKey "someSecret"
            // optional
            sessionToken "someSTSToken"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("s3://myCompanyBucket/maven2")
        credentials(AwsCredentials::class) {
            accessKey = "someKey"
            secretKey = "someSecret"
            // optional
            sessionToken = "someSTSToken"
        }
    }

    ivy {
        url = uri("s3://myCompanyBucket/ivyrepo")
        credentials(AwsCredentials::class) {
            accessKey = "someKey"
            secretKey = "someSecret"
            // optional
            sessionToken = "someSTSToken"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用AwsImAuthentication将所有凭证委派给AWS sdk。以下示例显示了如何：</p>
</div>
<div class="exampleblock">
<div class="title">示例22使用IAM声明一个S3支持的Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "s3://myCompanyBucket/maven2"
        authentication {
           awsIm(AwsImAuthentication) // load from EC2 role or env var
        }
    }

    ivy {
        url "s3://myCompanyBucket/ivyrepo"
        authentication {
           awsIm(AwsImAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("s3://myCompanyBucket/maven2")
        authentication {
            create&lt;AwsImAuthentication&gt;("awsIm") // load from EC2 role or env var
        }
    }

    ivy {
        url = uri("s3://myCompanyBucket/ivyrepo")
        authentication {
            create&lt;AwsImAuthentication&gt;("awsIm")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关与AWS S3相关的身份验证的详细信息，请参阅“ <a href="#sec:s3-repositories">AWS S3存储库配置</a> ”部分。</p>
</div>
<div class="paragraph">
<p>使用Google Cloud Storage支持的存储库时，将使用默认的应用程序凭据，而无需进一步配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例23使用默认应用程序凭据声明由Google Cloud Storage支持的Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "gcs://myCompanyBucket/maven2"
    }

    ivy {
        url "gcs://myCompanyBucket/ivyrepo"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("gcs://myCompanyBucket/maven2")
    }

    ivy {
        url = uri("gcs://myCompanyBucket/ivyrepo")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关与Google GCS相关的身份验证的详细信息，请参阅“ <a href="#sec:gcs-repositories">Google Cloud Storage存储库配置”部分</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:authentication_schemes"><a class="anchor" href="#sec:authentication_schemes"></a> <a class="link" href="#sec:authentication_schemes">HTTP（S）身份验证方案配置</a></h3>
<div class="paragraph">
<p>使用HTTP或HTTPS传输协议配置存储库时，可以使用多种身份验证方案。默认情况下，Gradle会尝试使用Apache HttpClient库支持的所有方案（在<a href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/authentication.html#d5e625">此处记录）</a> 。在某些情况下，与远程服务器交换凭据时，最好明确指定应使用哪种身份验证方案。明确声明时，在对远程存储库进行身份验证时仅使用那些方案。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="../javadoc/org/gradle/api/credentials/PasswordCredentials.html">PasswordCredentials</a>为通过基本身份验证保护的Maven存储库指定凭据。</p>
</div>
<div class="exampleblock">
<div class="title">示例24访问受密码保护的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "http://repo.mycompany.com/maven2"
        credentials {
            username "user"
            password "password"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("http://repo.mycompany.com/maven2")
        credentials {
            username = "user"
            password = "password"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/artifacts/defineRepository</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示如何将存储库配置为仅使用<a href="../javadoc/org/gradle/authentication/http/DigestAuthentication.html">DigestAuthentication</a> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例25配置存储库以仅使用摘要身份验证</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url 'https://repo.mycompany.com/maven2'
        credentials {
            username "user"
            password "password"
        }
        authentication {
            digest(DigestAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("https://repo.mycompany.com/maven2")
        credentials {
            username = "user"
            password = "password"
        }
        authentication {
            create&lt;DigestAuthentication&gt;("digest")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当前支持的身份验证方案是：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="../javadoc/org/gradle/authentication/http/BasicAuthentication.html">基本认证</a></dt>
<dd>
<p>通过HTTP的基本访问身份验证。使用此方案时，将抢先发送凭据。</p>
</dd>
<dt class="hdlist1"><a href="../javadoc/org/gradle/authentication/http/DigestAuthentication.html">摘要认证</a></dt>
<dd>
<p>通过HTTP的摘要式访问身份验证。</p>
</dd>
<dt class="hdlist1"><a href="../javadoc/org/gradle/authentication/http/HttpHeaderAuthentication.html">HttpHeaderAuthentication</a></dt>
<dd>
<p>基于任何自定义HTTP标头的身份验证，例如私有令牌，OAuth令牌等。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="sub:preemptive_authentication"><a class="anchor" href="#sub:preemptive_authentication"></a> <a class="link" href="#sub:preemptive_authentication">使用抢占式身份验证</a></h4>
<div class="paragraph">
<p>Gradle的默认行为是仅在服务器以HTTP 401响应的形式通过身份验证质询响应时提交凭据。在某些情况下，服务器将以不同的代码响应（例如，对于托管在GitHub上的存储库，返回404），从而导致依赖性解析失败。若要解决此问题，凭据可能会抢先发送到服务器。要启用抢占式身份验证，只需将您的存储库配置为显式使用<a href="../javadoc/org/gradle/authentication/http/BasicAuthentication.html">BasicAuthentication</a>方案：</p>
</div>
<div class="exampleblock">
<div class="title">示例26。配置存储库以使用抢占式身份验证</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url 'https://repo.mycompany.com/maven2'
        credentials {
            username "user"
            password "password"
        }
        authentication {
            basic(BasicAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("https://repo.mycompany.com/maven2")
        credentials {
            username = "user"
            password = "password"
        }
        authentication {
            create&lt;BasicAuthentication&gt;("basic")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:http-header-auth"><a class="anchor" href="#sub:http-header-auth"></a> <a class="link" href="#sub:http-header-auth">使用HTTP标头身份验证</a></h4>
<div class="paragraph">
<p>您可以使用带有<a href="../javadoc/org/gradle/authentication/http/HttpHeaderAuthentication.html">HttpHeaderAuthentication的HttpHeaderCredentials</a>为需要令牌，OAuth2或其他基于HTTP头的身份验证的<a href="../javadoc/org/gradle/api/credentials/HttpHeaderCredentials.html">受</a>保护的Maven存储库指定任何HTTP头。</p>
</div>
<div class="exampleblock">
<div class="title">示例27访问标头保护的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven {
        url "http://repo.mycompany.com/maven2"
        credentials(HttpHeaderCredentials) {
            name = "Private-Token"
            value = "TOKEN"
        }
        authentication {
            header(HttpHeaderAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    maven {
        url = uri("http://repo.mycompany.com/maven2")
        credentials(HttpHeaderCredentials::class) {
            name = "Private-Token"
            value = "TOKEN"
        }
        authentication {
            create&lt;HttpHeaderAuthentication&gt;("header")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/artifacts/defineRepository</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:s3-repositories"><a class="anchor" href="#sec:s3-repositories"></a> <a class="link" href="#sec:s3-repositories">AWS S3存储库配置</a></h3>
<div class="sect3">
<h4 id="sub:s3_configuration_properties"><a class="anchor" href="#sub:s3_configuration_properties"></a> <a class="link" href="#sub:s3_configuration_properties">S3配置属性</a></h4>
<div class="paragraph">
<p>以下系统属性可用于配置与s3存储库的交互：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.gradle.s3.endpoint</code></dt>
<dd>
<p>使用不兼容AWS，S3 API的存储服务时，用于覆盖AWS S3终端节点。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.s3.maxErrorRetry</code></dt>
<dd>
<p>指定在S3服务器以HTTP 5xx状态代码响应的情况下重试请求的最大次数。如果未指定，则使用默认值3。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sub:s3_url_formats"><a class="anchor" href="#sub:s3_url_formats"></a> <a class="link" href="#sub:s3_url_formats">S3 URL格式</a></h4>
<div class="paragraph">
<p>S3 URL是“虚拟主机样式”，并且必须采用以下格式</p>
</div>
<div class="listingblock">
<div class="content">
<pre>s3://&lt;bucketName&gt;[.&lt;regionSpecificEndpoint&gt;]/&lt;s3Key&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>例如<code>s3://myBucket.s3.eu-central-1.amazonaws.com/maven/release</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>myBucket</code>是AWS S3存储桶名称。</p>
</li>
<li>
<p><code>s3.eu-central-1.amazonaws.com</code>是<a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">特定</a>于<a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">区域</a>的<em>可选</em> <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">端点</a> 。</p>
</li>
<li>
<p><code>/maven/release</code>是AWS S3密钥（存储桶中对象的唯一标识符）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sub:s3_proxy_settings"><a class="anchor" href="#sub:s3_proxy_settings"></a> <a class="link" href="#sub:s3_proxy_settings">S3代理设置</a></h4>
<div class="paragraph">
<p>可以使用以下系统属性来配置S3的代理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>https.proxyHost</code></p>
</li>
<li>
<p><code>https.proxyPort</code></p>
</li>
<li>
<p><code>https.proxyUser</code></p>
</li>
<li>
<p><code>https.proxyPassword</code></p>
</li>
<li>
<p><code>http.nonProxyHosts</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果<code>org.gradle.s3.endpoint</code>已使用HTTP（非HTTPS）URI指定属性，可以使用以下系统代理设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>http.proxyHost</code></p>
</li>
<li>
<p><code>http.proxyPort</code></p>
</li>
<li>
<p><code>http.proxyUser</code></p>
</li>
<li>
<p><code>http.proxyPassword</code></p>
</li>
<li>
<p><code>http.nonProxyHosts</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sub:s3_v4_signatures"><a class="anchor" href="#sub:s3_v4_signatures"></a> <a class="link" href="#sub:s3_v4_signatures">AWS S3 V4签名（AWS4-HMAC-SHA256）</a></h4>
<div class="paragraph">
<p>某些AWS S3地区（eu-central-1-Frankfurt）要求所有HTTP请求均根据AWS的<a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">签名版本4进行签名</a> 。当使用需要V4签名的存储桶时，建议指定包含区域特定终结点的S3 URL。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>s3://somebucket.s3.eu-central-1.amazonaws.com/maven/release</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果未为需要V4签名的存储桶指定特定于区域的终结点，则Gradle将使用默认的AWS区域（us-east-1），并且控制台上会出现以下警告：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>尝试将请求重新发送给....使用AWS V4身份验证为避免将来出现此警告，请使用特定于区域的终结点来访问需要V4签名的区域中的存储桶。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>无法为需要V4签名的存储桶指定特定于区域的端点意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每次上传和下载文件时，AWS往返3次，而不是一次。</p>
</li>
<li>
<p>根据位置-网络等待时间增加，构建速度变慢。</p>
</li>
<li>
<p>传输失败的可能性增加。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="sub:s3_cross_account"><a class="anchor" href="#sub:s3_cross_account"></a> <a class="link" href="#sub:s3_cross_account">AWS S3跨账户访问</a></h5>
<div class="paragraph">
<p>一些组织可能有多个AWS账户，例如每个团队一个。存储桶拥有者的AWS账户通常与工件发布者和消费者不同。存储桶拥有者必须能够授予消费者访问权限，否则工件只能由发布者的帐户使用。这是通过添加<code>bucket-owner-full-control</code> <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl">罐头ACL</a>到上载的对象。Gradle将在每次上传中执行此操作。确保发布者具有所需的IAM权限， <code>PutObjectAcl</code> （和<code>PutObjectVersionAcl</code> （如果启用了存储桶版本控制），则直接或通过假定的IAM角色（取决于您的情况）。您可以在<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html">AWS S3访问权限中</a>阅读更多内容。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:gcs-repositories"><a class="anchor" href="#sec:gcs-repositories"></a> <a class="link" href="#sec:gcs-repositories">Google Cloud Storage储存库配置</a></h3>
<div class="sect3">
<h4 id="sub:gcs_configuration_properties"><a class="anchor" href="#sub:gcs_configuration_properties"></a> <a class="link" href="#sub:gcs_configuration_properties">GCS配置属性</a></h4>
<div class="paragraph">
<p>以下系统属性可用于配置与<a href="https://cloud.google.com/storage/">Google Cloud Storage存储</a>库的交互：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.gradle.gcs.endpoint</code></dt>
<dd>
<p>当使用非Google Cloud Platform兼容的Google Cloud Storage API的存储服务时，用于覆盖Google Cloud Storage端点。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.gcs.servicePath</code></dt>
<dd>
<p>用于覆盖Google Cloud Storage客户端从其生成请求的Google Cloud Storage根服务路径，默认为<code>/</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sub:gcs_url_formats"><a class="anchor" href="#sub:gcs_url_formats"></a> <a class="link" href="#sub:gcs_url_formats">GCS URL格式</a></h4>
<div class="paragraph">
<p>Google Cloud Storage网址为“虚拟托管样式”，并且必须采用以下格式<code>gcs://<bucketName>/<objectKey></code></p>
</div>
<div class="paragraph">
<p>例如<code>gcs://myBucket/maven/release</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>myBucket</code>是Google Cloud Storage存储桶名称。</p>
</li>
<li>
<p><code>/maven/release</code>是Google Cloud Storage密钥（存储桶中对象的唯一标识符）</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="declaring-dependencies"><a class="anchor" href="#declaring-dependencies"></a> <a class="link" href="#declaring-dependencies">声明依赖</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在查看依赖项声明本身之前，需要定义<em>依赖项配置</em>的概念。</p>
</div>
<div class="sect2">
<h3 id="sec:what-are-dependency-configurations"><a class="anchor" href="#sec:what-are-dependency-configurations"></a> <a class="link" href="#sec:what-are-dependency-configurations">什么是依赖项配置</a></h3>
<div class="paragraph">
<p>为Gradle项目声明的每个依赖项都适用于特定范围。例如，某些依赖项应用于编译源代码，而其他依赖项仅需要在运行时可用。Gradle在<a href="../dsl/org.gradle.api.artifacts.Configuration.html">Configuration</a>的帮助下表示依赖项的范围。每个配置都可以通过唯一的名称来标识。</p>
</div>
<div class="paragraph">
<p>许多Gradle插件都会向您的项目添加预定义的配置。例如，Java插件添加了一些配置，以表示其用于源代码编译，执行测试等所需的各种类路径。有关示例，请参见<a href="java_plugin.html#sec:java_plugin_and_dependency_management">Java插件章节</a> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-configurations.png" alt="依赖管理配置">
</div>
<div class="title">图4。配置将声明的依赖项用于特定目的</div>
</div>
<div class="paragraph">
<p>有关使用配置导航，检查和后处理分配的依赖项的元数据和工件的更多示例，请查看<a href="#sec:programmatic_api">解析结果API</a> 。</p>
</div>
<div class="sect3">
<h4 id="sub:config-inheritance-composition"><a class="anchor" href="#sub:config-inheritance-composition"></a> <a class="link" href="#sub:config-inheritance-composition">配置继承和组合</a></h4>
<div class="paragraph">
<p>一个配置可以扩展其他配置以形成继承层次结构。子配置继承为其任何超配置声明的整个依赖项集。</p>
</div>
<div class="paragraph">
<p>Gradle核心插件（如<a href="java_plugin.html#sec:java_plugin_and_dependency_management">Java插件</a> ）大量使用配置继承。例如<code>testImplementation</code>配置扩展了<code>implementation</code>组态。配置层次结构有一个实际目的：编译测试需要在编写测试类所需的依赖之上加上被测试源代码的依赖。如果将其类导入生产源代码中，则使用JUnit编写和执行测试代码的Java项目也需要Guava。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-configuration-inheritance.png" alt="依赖管理配置继承">
</div>
<div class="title">图5。Java插件提供的配置继承</div>
</div>
<div class="paragraph">
<p>在幕后<code>testImplementation</code>和<code>implementation</code>配置通过调用<a href="../dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:extendsFrom(org.gradle.api.artifacts.Configuration[])">Configuration.extendsFrom（org.gradle.api.artifacts方法来形成继承层次结构</a><a href="../dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:extendsFrom(org.gradle.api.artifacts.Configuration[])">。配置[]）</a> 。配置可以扩展任何其他配置，无论其在构建脚本或插件中的定义如何。</p>
</div>
<div class="paragraph">
<p>假设您想编写一套烟雾测试。每个冒烟测试都会进行HTTP调用以验证Web服务端点。作为基础测试框架，该项目已使用JUnit。您可以定义一个名为<code>smokeTest</code>从<code>testImplementation</code>配置以重用现有的测试框架依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">示例28。从其他配置扩展配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    smokeTest.extendsFrom testImplementation
}

dependencies {
    testImplementation 'junit:junit:4.12'
    smokeTest 'org.apache.httpcomponents:httpclient:4.5.5'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val smokeTest by configurations.creating {
    extendsFrom(configurations.testImplementation.get())
}

dependencies {
    testImplementation("junit:junit:4.12")
    smokeTest("org.apache.httpcomponents:httpclient:4.5.5")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:resolvable-consumable-configs"><a class="anchor" href="#sec:resolvable-consumable-configs"></a> <a class="link" href="#sec:resolvable-consumable-configs">可解析和消耗性配置</a></h3>
<div class="paragraph">
<p>从历史上看，配置一直是Gradle中依赖关系解析的根本。最后，我们要有所作为的是<em>消费者</em>和<em>生产者之间</em> 。为此，配置至少用于三个不同方面：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>声明依赖</p>
</li>
<li>
<p>作为<em>使用者</em> ，解决文件的一系列依赖关系</p>
</li>
<li>
<p>作为<em>生产者</em> ，将工件及其依赖项公开以供其他项目使用（此类<em>消耗性</em>配置通常表示生产者向其消费者提供的<a href="#">变体</a> ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如，如果我想表达我的申请<code>app</code> <em>取决于</em>图书馆<code>lib</code> ，我们<em>至少</em>需要一种配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例29。配置用于声明依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    // declare a "configuration" named "someConfiguration"
    someConfiguration
}
dependencies {
    // add a project dependency to the "someConfiguration" configuration
    someConfiguration project(":lib")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">// declare a "configuration" named "someConfiguration"
val someConfiguration by configurations.creating

dependencies {
    // add a project dependency to the "someConfiguration" configuration
    someConfiguration(project(":lib"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>配置可以扩展其他配置，以继承其依赖性。但是，上面的代码没有告诉任何有关<em>使用者的信息</em> 。特别是，它没有告诉您配置的<em>用途</em> 。比方说<code>lib</code>是一个Java库：它可以公开不同的内容，例如其API，实现或测试装置。如果我们想解决依赖关系<code>app</code> ，我们需要知道我们正在执行哪种任务（针对的API进行编译<code>lib</code> ，执行应用程序，编译测试...）。为此，您通常会找到伴随的配置，这些配置旨在明确声明其用法：</p>
</div>
<div class="exampleblock">
<div class="title">示例30代表具体依赖图的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    // declare a configuration that is going to resolve the compile classpath of the application
    compileClasspath.extendsFrom(someConfiguration)

    // declare a configuration that is going to resolve the runtime classpath of the application
    runtimeClasspath.extendsFrom(someConfiguration)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    // declare a configuration that is going to resolve the compile classpath of the application
    compileClasspath.extendsFrom(someConfiguration)

    // declare a configuration that is going to resolve the runtime classpath of the application
    runtimeClasspath.extendsFrom(someConfiguration)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此阶段，我们有3种不同的配置，它们已经有不同的目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>someConfiguration</code>声明我的应用程序的依赖关系。这只是一个我们在其中声明依赖项列表的存储桶。</p>
</li>
<li>
<p><code>compileClasspath</code>和<code>runtimeClasspath</code>是<em>要解决的</em>配置：解决时，它们应分别包含应用程序的编译类路径和运行时类路径。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这实际上是在<code>Configuration</code>键入<code>canBeResolved</code>旗。<em>可以解析</em>的配置是我们可以为其计算依赖关系图的配置，因为它包含实现解析所需的所有必要信息。也就是说，我们将计算一个依赖图，解析图中的组件，并最终获得工件。具有以下配置<code>canBeResolved</code>调成<code>false</code>并不意味着要解决。这样的配置<em>仅用于声明依赖项</em> 。原因是根据用法（编译类路径，运行时类路径），它<em>可以</em>解析为不同的图。尝试解决具有以下问题的配置是错误的<code>canBeResolved</code>调成<code>false</code> 。在某种程度上，这类似于<em>抽象类</em> （ <code>canBeResolved</code> = false）（不应该实例化），以及扩展抽象类的具体类（ <code>canBeResolved</code> = true）。可解析的配置将扩展至少一个不可解析的配置（并且可能会扩展多个）。</p>
</div>
<div class="paragraph">
<p>另一方面，在图书馆项目方面（ <em>生产者</em> ），我们还使用配置来表示可以消耗的东西。例如，该库可能公开一个API或运行时，并且我们会将工件附加到一个或多个。通常，针对<code>lib</code> ，我们需要的API <code>lib</code> ，但我们不需要其运行时依赖项。所以<code>lib</code>项目将公开<code>apiElements</code>配置，面向寻求其API的消费者。这样的配置将是消耗性的，但并不意味着必须解决。通过a的<em>canBeConsumed</em>标志表示<code>Configuration</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例31。设置配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    // A configuration meant for consumers that need the API of this component
    exposedApi {
        // This configuration is an "outgoing" configuration, it's not meant to be resolved
        canBeResolved = false
        // As an outgoing configuration, explain that consumers may want to consume it
        canBeConsumed = true
    }
    // A configuration meant for consumers that need the implementation of this component
    exposedRuntime {
        canBeResolved = false
        canBeConsumed = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    // A configuration meant for consumers that need the API of this component
    create("exposedApi") {
        // This configuration is an "outgoing" configuration, it's not meant to be resolved
        isCanBeResolved = false
        // As an outgoing configuration, explain that consumers may want to consume it
        isCanBeConsumed = true
    }
    // A configuration meant for consumers that need the implementation of this component
    create("exposedRuntime") {
        isCanBeResolved = false
        isCanBeConsumed = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>简而言之，配置角色由<code>canBeResolved</code>和<code>canBeConsumed</code>标志组合：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表3。配置角色</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置角色</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以解决</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以食用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">依赖桶</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决某些用途</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">暴露给消费者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">旧版，请勿使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>为了向后兼容，这些标志同时具有<code>true</code>作为默认值，但作为插件作者，您应该始终为这些标志确定正确的值，否则可能会意外引入解析错误。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:choosing-configuration"><a class="anchor" href="#sec:choosing-configuration"></a> <a class="link" href="#sec:choosing-configuration">选择正确的依赖项配置</a></h3>
<div class="paragraph">
<p>声明依赖项的配置的选择很重要。但是，没有固定的规则必须将依赖项放入哪个配置中。它主要取决于配置的组织方式，这通常是所应用插件的属性。</p>
</div>
<div class="paragraph">
<p>例如，在<code>java</code>插件，创建的配置已<a href="java_plugin.html#tab:configurations">记录在案，</a>并应根据其在代码中的作用，作为确定在哪里声明依赖项的基础。</p>
</div>
<div class="paragraph">
<p>作为建议，插件应明确记录其配置链接在一起的方式，并应尽最大努力隔离其<a href="#sec:resolvable-consumable-configs">角色</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:defining-custom-configurations"><a class="anchor" href="#sec:defining-custom-configurations"></a> <a class="link" href="#sec:defining-custom-configurations">定义自定义配置</a></h3>
<div class="paragraph">
<p>您可以自己定义配置，即所谓的<em>自定义配置</em> 。定制配置对于分离专用目的所需的依赖项范围很有用。</p>
</div>
<div class="paragraph">
<p>比方说，你想声明的依赖<a href="https://tomcat.apache.org/tomcat-9.0-doc/jasper-howto.html">碧玉Ant任务</a>为<em>不</em>应该在classpath最终编译源代码预编译JSP文件的目的。通过引入自定义配置并在任务中使用它来实现该目标相当简单。</p>
</div>
<div class="exampleblock">
<div class="title">示例32声明和使用自定义配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    jasper
}

repositories {
    mavenCentral()
}

dependencies {
    jasper 'org.apache.tomcat.embed:tomcat-embed-jasper:9.0.2'
}

task preCompileJsps {
    doLast {
        ant.taskdef(classname: 'org.apache.jasper.JspC',
                    name: 'jasper',
                    classpath: configurations.jasper.asPath)
        ant.jasper(validateXml: false,
                   uriroot: file('src/main/webapp'),
                   outputDir: file("$buildDir/compiled-jsps"))
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val jasper by configurations.creating

repositories {
    mavenCentral()
}

dependencies {
    jasper("org.apache.tomcat.embed:tomcat-embed-jasper:9.0.2")
}

tasks.register("preCompileJsps") {
    doLast {
        ant.withGroovyBuilder {
            "taskdef"("classname" to "org.apache.jasper.JspC",
                      "name" to "jasper",
                      "classpath" to jasper.asPath)
            "jasper"("validateXml" to false,
                     "uriroot" to file("src/main/webapp"),
                     "outputDir" to file("$buildDir/compiled-jsps"))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>项目的配置由<code>configurations</code>宾语。配置具有名称，并且可以互相扩展。要了解有关此API的更多信息，请查看<a href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html">ConfigurationContainer</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:dependency-types"><a class="anchor" href="#sec:dependency-types"></a> <a class="link" href="#sec:dependency-types">不同种类的依赖</a></h3>
<div class="sect3">
<h4 id="sub:module_dependencies"><a class="anchor" href="#sub:module_dependencies"></a> <a class="link" href="#sub:module_dependencies">模块依赖</a></h4>
<div class="paragraph">
<p>模块依赖性是最常见的依赖性。它们引用存储库中的模块。</p>
</div>
<div class="exampleblock">
<div class="title">例子33。模块依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    runtimeOnly group: 'org.springframework', name: 'spring-core', version: '2.5'
    runtimeOnly 'org.springframework:spring-core:2.5',
            'org.springframework:spring-aop:2.5'
    runtimeOnly(
        [group: 'org.springframework', name: 'spring-core', version: '2.5'],
        [group: 'org.springframework', name: 'spring-aop', version: '2.5']
    )
    runtimeOnly('org.hibernate:hibernate:3.0.5') {
        transitive = true
    }
    runtimeOnly group: 'org.hibernate', name: 'hibernate', version: '3.0.5', transitive: true
    runtimeOnly(group: 'org.hibernate', name: 'hibernate', version: '3.0.5') {
        transitive = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    runtimeOnly(group = "org.springframework", name = "spring-core", version = "2.5")
    runtimeOnly("org.springframework:spring-aop:2.5")
    runtimeOnly("org.hibernate:hibernate:3.0.5") {
        isTransitive = true
    }
    runtimeOnly(group = "org.hibernate", name = "hibernate", version = "3.0.5") {
        isTransitive = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多示例和完整参考，请参阅API文档中的<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html">DependencyHandler</a>类。</p>
</div>
<div class="paragraph">
<p>Gradle为模块依赖性提供了不同的表示法。有一个字符串符号和一个映射符号。模块依赖性具有允许进一步配置的API。看一看<a href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html">ExternalModuleDependency，</a>以了解有关API的全部信息。该API提供了属性和配置方法。通过字符串符号，您可以定义属性的子集。使用地图符号，您可以定义所有属性。要使用映射或字符串表示法访问完整的API，可以将单个依赖项与闭包一起分配给配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果您声明模块依赖性，则Gradle会查找模块元数据文件（ <code>.module</code> ， <code>.pom</code>要么<code>ivy.xml</code> ）中。如果存在这样的模块元数据文件，则将对其进行解析以及该模块的工件（例如<code>hibernate-3.0.5.jar</code> ）及其依赖项（例如<code>cglib</code> ）下载。如果不存在这样的模块元数据文件，那么从Gradle 6.0开始，您需要配置<a href="#sec:supported_metadata_sources">元数据源定义</a>以查找名为<code>hibernate-3.0.5.jar</code>直。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>在Maven中，一个模块只能有一个工件。</p>
</div>
<div class="paragraph">
<p>在Gradle和Ivy中，一个模块可以具有多个工件。每个工件可以具有不同的依赖关系集。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sub:file_dependencies"><a class="anchor" href="#sub:file_dependencies"></a> <a class="link" href="#sub:file_dependencies">文件依赖</a></h4>
<div class="paragraph">
<p>项目有时不依赖于二进制存储库产品（例如JFrog Artifactory或Sonatype Nexus）来托管和解决外部依赖项。通常的做法是将这些依赖项托管在共享驱动器上，或者将其与项目源代码一起放入版本控制中。这些依赖关系称为<em>文件依赖关系</em> ，原因是它们表示文件没有附加任何<a href="#sub:terminology_module_metadata">元数据</a> （例如有关传递依赖关系，源或其作者的信息）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-file-dependencies.png" alt="依赖管理文件依赖">
</div>
<div class="title">图6。解决本地文件系统和共享驱动器中的文件依赖关系</div>
</div>
<div class="paragraph">
<p>以下示例从目录解析文件依赖关系<code>ant</code> ， <code>libs</code>和<code>tools</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例34声明多个文件依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    antContrib
    externalLibs
    deploymentTools
}

dependencies {
    antContrib files('ant/antcontrib.jar')
    externalLibs files('libs/commons-lang.jar', 'libs/log4j.jar')
    deploymentTools(fileTree('tools') { include '*.exe' })
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    create("antContrib")
    create("externalLibs")
    create("deploymentTools")
}

dependencies {
    "antContrib"(files("ant/antcontrib.jar"))
    "externalLibs"(files("libs/commons-lang.jar", "libs/log4j.jar"))
    "deploymentTools"(fileTree("tools") { include("*.exe") })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如代码示例所示，每个依赖项都必须定义其在文件系统中的确切位置。创建文件引用的最主要方法是<a href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（java.lang。对象...）</a> ， <a href="../javadoc/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object...-">ProjectLayout.files（java.lang。对象...）</a>和<a href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)">Project.fileTree（java.lang。对象），</a>或者，您也可以以<a href="#sub:flat_dir_resolver">平面目录存储库</a>的形式定义一个或多个文件依赖项的源目录。</p>
</div>
<div class="paragraph">
<p>文件依赖性使您可以直接将一组文件添加到配置中，而无需先将它们添加到存储库中。如果您无法或不想将某些文件放置在存储库中，这将很有用。或者，如果您根本不想使用任何存储库来存储依赖项。</p>
</div>
<div class="paragraph">
<p>要将某些文件添加为配置的依赖项，只需将<a href="working_with_files.html#sec:file_collections">文件集合</a>作为依赖项传递：</p>
</div>
<div class="exampleblock">
<div class="title">示例35文件依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    runtimeOnly files('libs/a.jar', 'libs/b.jar')
    runtimeOnly fileTree('libs') { include '*.jar' }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    runtimeOnly(files("libs/a.jar", "libs/b.jar"))
    runtimeOnly(fileTree("libs") { include("*.jar") })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>文件依赖项不包含在项目的已发布依赖项描述符中。但是，文件依赖关系包含在同一构建中的可传递项目依赖关系中。这意味着它们不能在当前版本之外使用，但可以在同一版本内使用。</p>
</div>
<div class="paragraph">
<p>您可以声明产生文件依赖性的任务。例如，当文件是由生成生成的时，您可能会这样做。</p>
</div>
<div class="exampleblock">
<div class="title">示例36。生成的文件依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation files("$buildDir/classes") {
        builtBy 'compile'
    }
}

task compile {
    doLast {
        println 'compiling classes'
    }
}

task list(dependsOn: configurations.compileClasspath) {
    doLast {
        println "classpath = ${configurations.compileClasspath.collect { File file -&gt; file.name }}"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation(files("$buildDir/classes") {
        builtBy("compile")
    })
}

tasks.register("compile") {
    doLast {
        println("compiling classes")
    }
}

tasks.register("list") {
    dependsOn(configurations["compileClasspath"])
    doLast {
        println("classpath = ${configurations["compileClasspath"].map { file: File -&gt; file.name }}")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle -q list
compiling classes
classpath = [classes]</pre>
</div>
</div>
<div class="sect4">
<h5 id="sec:versioning_file_dependencies"><a class="anchor" href="#sec:versioning_file_dependencies"></a> <a class="link" href="#sec:versioning_file_dependencies">文件依赖关系的版本控制</a></h5>
<div class="paragraph">
<p>建议明确表达其意图和文件依赖性的具体版本。Gradle的<a href="#sec:how-gradle-downloads-deps">版本冲突解决方案</a>不考虑文件依赖性。因此，为文件名分配一个版本以指示其附带的不同更改集是非常重要的。例如<code>commons-beanutils-1.3.jar</code>使您可以通过发行说明跟踪库的更改。</p>
</div>
<div class="paragraph">
<p>因此，项目的依存关系更易于维护和组织。通过分配的版本发现潜在的API不兼容要容易得多。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:project_dependencies"><a class="anchor" href="#sub:project_dependencies"></a> <a class="link" href="#sub:project_dependencies">项目依赖</a></h4>
<div class="paragraph">
<p>软件项目通常将软件组件分解为模块，以提高可维护性并防止强耦合。模块可以定义彼此之间的依赖关系，以在同一项目中重用代码。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-project-dependencies.png" alt="依赖管理项目依赖">
</div>
<div class="title">图7。项目之间的依赖</div>
</div>
<div class="paragraph">
<p>Gradle可以对模块之间的依赖关系进行建模。这些依赖项称为<em>项目依赖项，</em>因为每个模块均由Gradle项目表示。</p>
</div>
<div class="exampleblock">
<div class="title">示例37。项目依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation project(':shared')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation(project(":shared"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在运行时，该构建会自动确保以正确的顺序构建项目依赖项，并将其添加到类路径中以进行编译。“ <a href="multi_project_builds.html#multi_project_builds">创作多项目构建</a> ”一章讨论了如何设置和配置多项目构建。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html">ProjectDependency</a>的API文档。</p>
</div>
<div class="paragraph">
<p>以下示例声明了对<code>utils</code>和<code>api</code>来自的项目<code>web-service</code>项目。方法<a href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:project(java.lang.String)">Project.project（java.lang。字符串）</a>通过路径创建对特定子项目的引用。</p>
</div>
<div class="exampleblock">
<div class="title">示例38。声明项目依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">project(':web-service') {
    dependencies {
        implementation project(':utils')
        implementation project(':api')
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">project(":web-service") {
    dependencies {
        "implementation"(project(":utils"))
        "implementation"(project(":api"))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="local_forks_of_module_dependencies"><a class="anchor" href="#local_forks_of_module_dependencies"></a> <a class="link" href="#local_forks_of_module_dependencies">模块依赖项的本地分支</a></h4>
<div class="paragraph">
<p>如果模块本身是使用Gradle构建的，则模块依赖性可以由对该模块源的本地fork的依赖性替代。这可以通过使用<a href="#defining_composite_builds">复合构建</a>来完成。例如，这使您可以通过使用并构建本地修补版本而不是已发布的二进制版本来修复在应用程序中使用的库中的问题。有关此内容的详细信息，请参见<a href="#defining_composite_builds">组合构建</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:gradle_distribution_dependencies"><a class="anchor" href="#sub:gradle_distribution_dependencies"></a> <a class="link" href="#sub:gradle_distribution_dependencies">Gradle特定于发行版的依赖性</a></h4>
<div class="sect4">
<h5 id="sub:api_dependencies"><a class="anchor" href="#sub:api_dependencies"></a> <a class="link" href="#sub:api_dependencies">Gradle API依赖性</a></h5>
<div class="paragraph">
<p>您可以使用<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()">DependencyHandler.gradleApi（）</a>方法声明对当前版本的Gradle API的<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()">依赖关系</a> 。在开发自定义Gradle任务或插件时，这很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例39。Gradle API依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation gradleApi()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation(gradleApi())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub:testkit_dependencies"><a class="anchor" href="#sub:testkit_dependencies"></a> <a class="link" href="#sub:testkit_dependencies">Gradle TestKit依赖性</a></h5>
<div class="paragraph">
<p>您可以使用<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleTestKit()">DependencyHandler.gradleTestKit（）</a>方法声明对当前版本的Gradle的TestKit API的<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleTestKit()">依赖关系</a> 。这对于编写和执行Gradle插件和构建脚本的功能测试很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例40Gradle TestKit依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    testImplementation gradleTestKit()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    testImplementation(gradleTestKit())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="test_kit.html#test_kit">TestKit章节</a>通过示例说明了TestKit的用法。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:groovy_dependencies"><a class="anchor" href="#sub:groovy_dependencies"></a> <a class="link" href="#sub:groovy_dependencies">本地Groovy依赖</a></h5>
<div class="paragraph">
<p>您可以使用<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()">DependencyHandler.localGroovy（）</a>方法声明与Gradle一起分发的Groovy的<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()">依赖关系</a> 。在Groovy中开发自定义Gradle任务或插件时，这很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例41。Gradle的Groovy依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation localGroovy()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation(localGroovy())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:documenting-dependencies"><a class="anchor" href="#sec:documenting-dependencies"></a> <a class="link" href="#sec:documenting-dependencies">记录依赖性</a></h3>
<div class="paragraph">
<p>声明依赖项或<a href="#sec:adding-constraints-transitive-deps">依赖项约束时</a> ，可以提供声明的自定义原因。这使构建脚本中的依赖项声明和<a href="#sec:identifying_reason_dependency_selection">依赖项见解报告</a>更易于解释。</p>
</div>
<div class="exampleblock">
<div class="title">示例42。给出在依赖性声明中选择特定模块版本的原因</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java-library'
}

repositories {
    jcenter()
}

dependencies {
    implementation('org.ow2.asm:asm:7.1') {
        because 'we require a JDK 9 compatible bytecode generator'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    `java-library`
}

repositories {
    jcenter()
}

dependencies {
    implementation("org.ow2.asm:asm:7.1") {
        because("we require a JDK 9 compatible bytecode generator")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example_using_the_dependency_insight_report_with_custom_reasons"><a class="anchor" href="#example_using_the_dependency_insight_report_with_custom_reasons"></a> <a class="link" href="#example_using_the_dependency_insight_report_with_custom_reasons">示例：以自定义原因使用依赖关系洞察报告</a></h4>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q dependencyInsight --dependency asm</code></strong></div>
<div class="content">
<pre>&gt; gradle -q dependencyInsight --dependency asm
org.ow2.asm:asm:7.1
   variant "compile" [
      org.gradle.status              = release (not requested)
      org.gradle.usage               = java-api
      org.gradle.libraryelements     = jar (compatible with: classes)
      org.gradle.category            = library (not requested)

      Requested attributes not found in the selected variant:
         org.gradle.dependency.bundling = external
         org.gradle.jvm.version = 11
   ]
   Selection reasons:
      - Was requested : we require a JDK 9 compatible bytecode generator

org.ow2.asm:asm:7.1
\--- compileClasspath

A web-based, searchable dependency report is available by adding the --scan option.</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:resolve_specific_artifacts_from_dependency"><a class="anchor" href="#sec:resolve_specific_artifacts_from_dependency"></a> <a class="link" href="#sec:resolve_specific_artifacts_from_dependency">通过模块依赖性解决特定工件</a></h3>
<div class="paragraph">
<p>每当Gradle尝试从Maven或Ivy存储库解析模块时，它都会查找元数据文件和默认工件文件JAR。如果这些工件文件都无法解析，则构建将失败。在某些情况下，您可能需要调整Gradle解析依赖项工件的方式。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依赖项仅提供非标准工件，没有任何元数据（例如ZIP文件）。</p>
</li>
<li>
<p>模块元数据声明了多个工件，例如，作为常春藤依赖描述符的一部分。</p>
</li>
<li>
<p>您只想下载特定的工件，而无需在元数据中声明任何传递依赖项。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle是一个多语言构建工具，不仅限于解析Java库。假设您想使用JavaScript作为客户端技术来构建Web应用程序。大多数项目将外部JavaScript库检入版本控制。外部JavaScript库与可重用Java库没有什么不同，那么为什么不从存储库中下载它呢？</p>
</div>
<div class="paragraph">
<p><a href="https://developers.google.com/speed/libraries/">Google托管库</a>是流行的开源JavaScript库的发行平台。借助纯工件符号，您可以下载JavaScript库文件，例如JQuery。的<code>@</code>字符将依赖项的坐标与工件的文件扩展名分开。</p>
</div>
<div class="exampleblock">
<div class="title">例子43。为声明的依赖项解析JavaScript工件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url 'https://ajax.googleapis.com/ajax/libs'
        patternLayout {
            artifact '[organization]/[revision]/[module].[ext]'
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    js
}

dependencies {
    js 'jquery:jquery:3.2.1@js'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("https://ajax.googleapis.com/ajax/libs")
        patternLayout {
            artifact("[organization]/[revision]/[module].[ext]")
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    create("js")
}

dependencies {
    "js"("jquery:jquery:3.2.1@js")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>某些模块会运送同一工件的不同“风味”，或者它们会发布属于特定模块版本但目的不同的多个工件。Java库通常会发布带有已编译类文件的工件，另一个库中仅包含源代码，而第三个库中包含Javadocs。</p>
</div>
<div class="paragraph">
<p>在JavaScript中，库可能以未压缩或缩小的工件形式存在。在Gradle中，特定的工件标识符称为<em>分类器</em> ，该术语通常在Maven和Ivy依赖管理中使用。</p>
</div>
<div class="paragraph">
<p>假设我们要下载JQuery库的精简构件，而不是未压缩的文件。您可以提供分类器<code>min</code>作为依赖项声明的一部分。</p>
</div>
<div class="exampleblock">
<div class="title">例子44。使用分类器解析JavaScript工件以获得已声明的依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    ivy {
        url 'https://ajax.googleapis.com/ajax/libs'
        patternLayout {
            artifact '[organization]/[revision]/[module](.[classifier]).[ext]'
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    js
}

dependencies {
    js 'jquery:jquery:3.2.1:min@js'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    ivy {
        url = uri("https://ajax.googleapis.com/ajax/libs")
        patternLayout {
            artifact("[organization]/[revision]/[module](.[classifier]).[ext]")
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    create("js")
}

dependencies {
    "js"("jquery:jquery:3.2.1:min@js")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:supported-metadata-formats"><a class="anchor" href="#sec:supported-metadata-formats"></a> <a class="link" href="#sec:supported-metadata-formats">支持的元数据格式</a></h3>
<div class="paragraph">
<p>外部模块依赖项需要模块元数据（因此，Gradle通常可以找出模块的传递依赖项）。为此，Gradle支持不同的元数据格式。</p>
</div>
<div class="paragraph">
<p>您还可以调整将在<a href="#sec:supported_metadata_sources">存储库定义中</a>查找哪种格式。</p>
</div>
<div class="sect3">
<h4 id="sub:supported-md-gradle"><a class="anchor" href="#sub:supported-md-gradle"></a> <a class="link" href="#sub:supported-md-gradle">Gradle模块元数据文件</a></h4>
<div class="paragraph">
<p>Gradle模块元数据经过专门设计，可支持Gradle依赖性管理模型的所有功能，因此是首选格式。您可以<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">在此处</a>找到其<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">规格</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:supported-md-pom"><a class="anchor" href="#sub:supported-md-pom"></a> <a class="link" href="#sub:supported-md-pom">POM文件</a></h4>
<div class="paragraph">
<p>Gradle本机支持<a href="https://maven.apache.org/pom.html">Maven POM文件</a> 。值得注意的是，默认情况下，Gradle将首先查找POM文件，但是如果该文件包含特殊标记，则Gradle将改为使用<a href="#sub:supported-md-gradle">Gradle模块元数据</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:supported-md-ivy"><a class="anchor" href="#sub:supported-md-ivy"></a> <a class="link" href="#sub:supported-md-ivy">常春藤文件</a></h4>
<div class="paragraph">
<p>同样，Gradle支持<a href="http://ant.apache.org/ivy/">Apache Ivy元数据文件</a> 。同样，Gradle会首先寻找<code>ivy.xml</code>文件，但如果此文件包含特殊标记，则Gradle将改为使用<a href="#sub:supported-md-gradle">Gradle模块元数据</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:understanding-diff-libraries-and-apps"><a class="anchor" href="#sec:understanding-diff-libraries-and-apps"></a> <a class="link" href="#sec:understanding-diff-libraries-and-apps">了解库和应用程序之间的区别</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sub:producers-vs-consumers"><a class="anchor" href="#sub:producers-vs-consumers"></a> <a class="link" href="#sub:producers-vs-consumers">生产者与消费者</a></h3>
<div class="paragraph">
<p>Gradle依赖管理中的一个关键概念是在消费者和生产者之间产生差异。</p>
</div>
<div class="paragraph">
<p>当你<em>建立</em>一个库，有效地都在<em>制片</em>方：你是生产这些要由别人， <em>消费者</em> <em>消费</em> <em>的文物</em> 。</p>
</div>
<div class="paragraph">
<p>传统构建系统存在许多问题，即它们无法在生产者和消费者之间发挥作用。</p>
</div>
<div class="paragraph">
<p>需要从广义上理解<em>消费者</em> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个依赖于另一个项目的项目是一个<em>消费者</em></p>
</li>
<li>
<p>依赖人工制品的<em>任务</em>是更细粒度的消费者</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在依赖管理中，我们做出的许多决定取决于我们正在构建的项目的类型，即我们是<a href="#sub:being-respectful-consumers">什么样的<em>消费者</em></a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:producer-variants"><a class="anchor" href="#sub:producer-variants"></a> <a class="link" href="#sub:producer-variants">生产者变体</a></h3>
<div class="paragraph">
<p>生产者可能想为不同种类的消费者生成不同的工件：对于相同的源代码，会产生不同的<em>二进制文件</em> 。或者，一个项目可能会产生供其他项目（相同存储库）使用但不能供外部使用的工件。</p>
</div>
<div class="paragraph">
<p>Java世界中的一个典型示例是Guava库，它以不同的版本发布：一个用于Java项目，一个用于Android项目。</p>
</div>
<div class="paragraph">
<p>但是，消费者的责任是告知要使用的版本，并且依赖关系管理引擎的责任是确保<em>图的一致性</em> （例如，确保在类路径中没有使用Java和Android版本的Guava两种语言） 。这就是Gradle <a href="#">变体模型</a>发挥作用的地方。</p>
</div>
<div class="paragraph">
<p>在Gradle中， <em>生产者变体</em>通过<a href="#sec:resolvable-consumable-configs">耗材配置</a>公开。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:strong-encapsulation"><a class="anchor" href="#sub:strong-encapsulation"></a> <a class="link" href="#sub:strong-encapsulation">强大的封装</a></h3>
<div class="paragraph">
<p>为了使生产者可以编译库，它需要所有<em>实现依赖</em>于编译类路径。存在仅<em>作为</em>库<em>的实现细节</em>所需的依赖关系，并且某些库实际上是API的一部分。</p>
</div>
<div class="paragraph">
<p>但是， <em>依赖</em>于此生成的库的库仅需要“查看”库的公共API，因此也可以“查看”该API的依赖项。它是生产方的编译类路径的子集：这是对依赖性的强封装。</p>
</div>
<div class="paragraph">
<p>结果是分配给<code>implementation</code>库的配置<em>不会最终在使用者的编译类路径上</em> 。另一方面，分配给<code>api</code>库的配置<em>最终将在使用者的编译类路径上</em> 。但是，在<em>运行时</em> ，需要所有依赖项。即使在单个项目中，Gradle也会在不同类型的使用者之间产生差异：例如，Java编译任务与Java exec任务是不同的使用者。</p>
</div>
<div class="paragraph">
<p>在Java世界<a href="java_library_plugin.html">中可以找到</a>有关API和运行时依赖项分离的更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:being-respectful-consumers"><a class="anchor" href="#sub:being-respectful-consumers"></a> <a class="link" href="#sub:being-respectful-consumers">尊重消费者</a></h3>
<div class="paragraph">
<p>无论何时，作为开发人员，您决定包括依赖项时，您都必须了解<em>对消费者有影响</em> 。例如，如果将依赖项添加到项目中，则它将成为使用者的<em>传递性依赖</em>项，因此，如果使用者需要其他版本，则可能会参与冲突解决。</p>
</div>
<div class="paragraph">
<p>Gradle处理的许多问题都与解决消费者和生产者的期望之间的不匹配有关。</p>
</div>
<div class="paragraph">
<p>但是，有些项目比其他项目容易：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果您处于消费链的末端，也就是说您正在构建<em>应用程序</em> ，那么实际上<em>没有</em>项目的<em>使用者</em> （除了最终客户）：添加<a href="#sec:excluding-transitive-deps">排除项</a>只会解决您的问题。</p>
</li>
<li>
<p>但是，如果您是图书馆，则添加<a href="#sec:excluding-transitive-deps">排除项</a>可能会阻止使用者正常工作，因为他们会使用您不喜欢的代码路径</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>始终牢记，您选择解决问题的解决方案可能会“泄漏”给您的消费者。本文档旨在指导您找到正确问题的正确解决方案，更重要的是，制定有助于决策引擎在发生冲突时做出正确决策的决策。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="viewing-debugging-dependencies"><a class="anchor" href="#viewing-debugging-dependencies"></a> <a class="link" href="#viewing-debugging-dependencies">查看和调试依赖项</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle提供了足够的工具来导航较大的依赖图并缓解可能导致<a href="https://en.wikipedia.org/wiki/Dependency_hell">依赖地狱的情况</a> 。用户可以选择呈现完整的依赖关系图，也可以确定选择原因和依赖关系的来源。依赖关系的来源可以是构建脚本中已声明的依赖关系，也可以是图形中的传递性依赖关系及其相应的配置。Gradle通过构建扫描的可视化表示和命令行工具提供了两种功能。</p>
</div>
<div class="sect2">
<h3 id="sec:debugging-build-scans"><a class="anchor" href="#sec:debugging-build-scans"></a> <a class="link" href="#sec:debugging-build-scans">构建扫描</a></h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果您不知道什么是<a href="https://scans.gradle.com/">构建扫描</a> ，请确保将其签出！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>构建扫描可以将依赖项可视化为可导航的可搜索树。通过单击图形中的特定依赖项，可以呈现其他上下文信息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-dependencies-report-build-scan.png" alt="依赖性管理依赖性报告构建扫描">
</div>
<div class="title">图8。构建扫描中的依赖树</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:listing_dependencies"><a class="anchor" href="#sec:listing_dependencies"></a> <a class="link" href="#sec:listing_dependencies">列出项目中的依赖项</a></h3>
<div class="paragraph">
<p>Gradle可以可视化项目中每个可用<a href="#sec:what-are-dependency-configurations">配置</a>的整个依赖树。</p>
</div>
<div class="paragraph">
<p>如果您想确定在运行时已解决了哪些依赖关系，则渲染依赖关系树特别有用。它还为您提供有关该过程中发生的任何依赖项冲突解决方案的信息，并清楚地指示所选版本。依赖性报告始终包含已声明和可传递的依赖性。</p>
</div>
<div class="paragraph">
<p>假设您要为使用<a href="https://www.eclipse.org/jgit/">JGit库</a>执行SCM操作（例如，为发布过程建模）的项目创建任务。您可以在<a href="#sec:what-are-dependency-configurations">自定义配置</a>的帮助下声明任何外部工具的依赖关系，这样它就不会污染其他上下文，例如生产源代码的编译类路径。</p>
</div>
<div class="paragraph">
<p>每个Gradle项目都提供任务<code>dependencies</code>从命令行渲染所谓的<em>依赖报告</em> 。默认情况下，相关性报告呈现所有配置的相关性。要专注于有关一种配置的信息，请提供可选参数<code>--configuration</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例45使用自定义配置声明JGit依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    jcenter()
}

configurations {
    scm
}

dependencies {
    scm 'org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    jcenter()
}

configurations {
    create("scm")
}

dependencies {
    "scm"("org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example_rendering_the_dependency_report_for_a_custom_configuration"><a class="anchor" href="#example_rendering_the_dependency_report_for_a_custom_configuration"></a> <a class="link" href="#example_rendering_the_dependency_report_for_a_custom_configuration">示例：呈现自定义配置的依赖性报告</a></h4>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q dependencies --configuration scm</code></strong></div>
<div class="content">
<pre>&gt; gradle -q dependencies --configuration scm

------------------------------------------------------------
Root project
------------------------------------------------------------

scm
\--- org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r
     +--- com.jcraft:jsch:0.1.54
     +--- com.googlecode.javaewah:JavaEWAH:1.1.6
     +--- org.apache.httpcomponents:httpclient:4.3.6
     |    +--- org.apache.httpcomponents:httpcore:4.3.3
     |    +--- commons-logging:commons-logging:1.1.3
     |    \--- commons-codec:commons-codec:1.6
     \--- org.slf4j:slf4j-api:1.7.2

A web-based, searchable dependency report is available by adding the --scan option.</pre>
</div>
</div>
<div class="paragraph">
<p>依赖性报告提供了有关图中可用依赖性的详细信息。任何无法解决的依赖项都标有<code>FAILED</code>红色。图表中可能多次出现的具有相同坐标的依赖项被省略，并用星号表示。必须进行冲突解决的依赖项会以右箭头字符分隔请求的版本和选定的版本。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:identifying_reason_dependency_selection"><a class="anchor" href="#sec:identifying_reason_dependency_selection"></a> <a class="link" href="#sec:identifying_reason_dependency_selection">识别选择哪个依赖版本以及为什么</a></h3>
<div class="paragraph">
<p>大型软件项目不可避免地会通过直接或传递依赖关系来处理越来越多的依赖关系。<a href="#sec:listing_dependencies">依存关系报告</a>为您提供了依存关系的原始列表，但没有解释<em>为什么</em>选择了依存关系，或者<em>由哪个</em>依存关系将其拉入图形。</p>
</div>
<div class="paragraph">
<p>让我们看一个具体的例子。一个项目可以请求相同依赖项的两个不同版本，无论是直接依赖项还是传递依赖项。Gradle应用<a href="#sec:version-conflict">版本冲突解决方案</a>来确保依赖关系图中仅存在一个版本的依赖关系。在此示例中，冲突的依赖关系表示为<code>commons-codec:commons-codec</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例46。声明JGit依赖项和冲突的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">repositories {
    jcenter()
}

configurations {
    scm
}

dependencies {
    scm 'org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r'
    scm 'commons-codec:commons-codec:1.7'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">repositories {
    jcenter()
}

configurations {
    create("scm")
}

dependencies {
    "scm"("org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r")
    "scm"("commons-codec:commons-codec:1.7")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果单击依赖项并选择“ Required By”选项卡，则<a href="https://scans.gradle.com/">构建扫描中</a>的依赖项树将显示选择原因（冲突解决）以及依赖项的来源。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-dependency-insight-report-build-scan.png" alt="依赖项管理依赖项见解报告构建扫描">
</div>
<div class="title">图9。构建扫描中的依赖关系洞察功能</div>
</div>
<div class="paragraph">
<p>每个Gradle项目都提供任务<code>dependencyInsight</code>从命令行呈现所谓的<em>依赖关系洞察报告</em> 。给定依赖关系图中的依赖关系，您可以识别选择原因并跟踪依赖关系选择的来源。您可以将依赖关系洞察报告视为给定依赖关系的依赖关系报告的逆表示。执行任务时，您必须提供必需的参数<code>--dependency</code>指定受检查依赖项的坐标。参数<code>--configuration</code>和<code>--singlepath</code>是可选的，但有助于过滤输出。</p>
</div>
<div class="sect3">
<h4 id="example_using_the_dependency_insight_report_for_a_given_dependency"><a class="anchor" href="#example_using_the_dependency_insight_report_for_a_given_dependency"></a> <a class="link" href="#example_using_the_dependency_insight_report_for_a_given_dependency">示例：对给定依赖项使用依赖关系洞察报告</a></h4>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q dependencyInsight --dependency commons-codec --configuration scm</code></strong></div>
<div class="content">
<pre>&gt; gradle -q dependencyInsight --dependency commons-codec --configuration scm
commons-codec:commons-codec:1.7
   variant "default" [
      org.gradle.status = release (not requested)
   ]
   Selection reasons:
      - By conflict resolution : between versions 1.7 and 1.6

commons-codec:commons-codec:1.7
\--- scm

commons-codec:commons-codec:1.6 -&gt; 1.7
\--- org.apache.httpcomponents:httpclient:4.3.6
     \--- org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r
          \--- scm

A web-based, searchable dependency report is available by adding the --scan option.</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:resolving-version-conflict"><a class="anchor" href="#sec:resolving-version-conflict"></a> <a class="link" href="#sec:resolving-version-conflict">解决版本冲突</a></h3>
<div class="paragraph">
<p>如果所选版本与您的期望不符，则Gradle提供了一系列工具来帮助您<a href="#">控制传递依赖</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:resolving-variant-aware-errors"><a class="anchor" href="#sec:resolving-variant-aware-errors"></a> <a class="link" href="#sec:resolving-variant-aware-errors">解决变量选择错误</a></h3>
<div class="paragraph">
<p>有时会在<a href="#">变体选择级别上</a>发生选择错误。请查看<a href="#sec:variant-select-errors">专用部分</a>以了解这些错误以及如何解决它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:resolving-unsafe-configuration-resolution-errors"><a class="anchor" href="#sub:resolving-unsafe-configuration-resolution-errors"></a> <a class="link" href="#sub:resolving-unsafe-configuration-resolution-errors">解决不安全的配置解析错误</a></h3>
<div class="paragraph">
<p>跨项目边界时，必须安全地解决配置问题，因为解决配置问题会对Gradle的项目模型产生副作用。Gradle可以管理此安全访问，但是需要以使Gradle能够进行访问的方式来访问配置。有多种方法可以不安全地解决配置，并且Gradle会针对每个不安全的访问产生弃用警告。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个项目中的任务直接解决另一个项目中的配置。</p>
</li>
<li>
<p>任务将另一个项目中的配置指定为输入文件集合。</p>
</li>
<li>
<p>一个项目的构建脚本在评估期间解析另一个项目中的配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您的构建具有不安全的访问弃用警告，则需要对其进行修复。这是这些不良做法的征兆，可能会导致奇怪且不确定的错误。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，可以通过在另一个项目上创建跨项目的依赖关系来解决此问题。有关更多信息，请参见用于<a href="#cross_project_publications">在项目之间共享输出</a>的文档。如果您发现无法使用这些技术解决的用例，请通过提交遵循我们的发行准则的<a href="https://github.com/gradle/gradle/issues">GitHub Issue</a>来通知我们。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="understanding_dependency_resolution"><a class="anchor" href="#understanding_dependency_resolution"></a> <a class="link" href="#understanding_dependency_resolution">了解依赖性解析</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了Gradle <em>内部</em>依赖项解析的工作方式。在介绍了如何声明<a href="#">存储库</a>和<a href="#">依赖项之后</a> ，有必要解释在依赖项解析期间这些声明如何组合在一起。</p>
</div>
<div class="paragraph">
<p>依赖关系解析是一个由两个阶段组成的过程，这些阶段重复进行直到依赖图完成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将新的依赖项添加到图中后，请执行冲突解决方案以确定应将哪个版本添加到图中。</p>
</li>
<li>
<p>当特定的依赖关系（即具有版本的模块）被标识为图的一部分时，请检索其元数据，以便可以依次添加其依赖关系。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下部分将描述Gradle识别为冲突的内容以及如何自动解决冲突。之后，将介绍元数据的检索，解释Gradle如何<a href="#sec:how-gradle-downloads-deps">遵循依赖关系链接</a> 。</p>
</div>
<div class="sect2">
<h3 id="sec:conflict-resolution"><a class="anchor" href="#sec:conflict-resolution"></a> <a class="link" href="#sec:conflict-resolution">Gradle如何处理冲突？</a></h3>
<div class="paragraph">
<p>执行依赖关系解析时，Gradle处理两种类型的冲突：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">版本冲突</dt>
<dd>
<p>那是当两个或多个依赖项需要给定的依赖项但版本不同时。</p>
</dd>
<dt class="hdlist1">实施冲突</dt>
<dd>
<p>那就是当依赖图包含在Gradle术语中提供相同实现或功能的模块时。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下各节将详细说明Gradle如何尝试解决这些冲突。</p>
</div>
<div class="paragraph">
<p>依赖性解析过程可以高度自定义以满足企业需求。有关更多信息，请参见<a href="#">控制传递依赖关系</a>一章。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:version-conflict"><a class="anchor" href="#sec:version-conflict"></a> <a class="link" href="#sec:version-conflict">解决版本冲突</a></h3>
<div class="paragraph">
<p>当两个组件发生版本冲突：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>假设同一个模块<code>com.google.guava:guava</code></p>
</li>
<li>
<p>但是在不同的版本上<code>20.0</code>和<code>25.1-android</code></p>
<div class="ulist">
<ul>
<li>
<p>我们的项目本身取决于<code>com.google.guava:guava:20.0</code></p>
</li>
<li>
<p>我们的项目还取决于<code>com.google.inject:guice:4.2.2</code>这本身取决于<code>com.google.guava:guava:25.1-android</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="sub:resolution-strategy"><a class="anchor" href="#sub:resolution-strategy"></a> <a class="link" href="#sub:resolution-strategy">解决策略</a></h4>
<div class="paragraph">
<p>鉴于上述冲突，可以通过选择版本或通过失败的解决方案来解决它。处理依赖性管理的不同工具具有处理此类冲突的不同方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://maven.apache.org/">Apache Maven</a>使用最接近的优先策略。</p>
</div>
<div class="paragraph">
<p>Maven将采用<em>最短</em>路径获取依赖项并使用该版本。如果有多个相同长度的路径，则第一个获胜。</p>
</div>
<div class="paragraph">
<p>这意味着在上面的示例中， <code>guava</code>将会<code>20.0</code>因为直接依赖比<em>更接近</em> <code>guice</code>依赖性。</p>
</div>
<div class="paragraph">
<p>该方法的主要缺点是依赖于顺序。在很大的图中保持顺序可能是一个挑战。例如，如果新版本的依赖项最终以不同于先前版本的顺序拥有其自己的依赖项声明，该怎么办？</p>
</div>
<div class="paragraph">
<p>使用Maven，这可能会对已解决的版本产生不良影响。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://ant.apache.org/ivy/">Apache Ivy</a>是一种非常灵活的依赖项管理工具。它提供了自定义依赖关系解决方案（包括冲突解决方案）的可能性。</p>
</div>
<div class="paragraph">
<p>这种灵活性伴随着难以推理的代价。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle将考虑<em>所有</em>请求的版本，无论它们出现在依赖关系图中的何处。在这些版本中，它将选择<em>最高的</em>版本。</p>
</div>
<div class="paragraph">
<p>如您所见，Gradle支持<a href="#">丰富版本声明</a>的概念，因此最高版本取决于版本声明的方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果不涉及范围，则将选择不被拒绝的最高版本。</p>
<div class="ulist">
<ul>
<li>
<p>如果严格低于该版本，则选择将失败。</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果涉及范围：</p>
<div class="ulist">
<ul>
<li>
<p>如果某个非范围版本落入指定范围内或高于其上限，则将选择该版本。</p>
</li>
<li>
<p>如果只有范围，则将选择具有最高上限的范围的<em>现有</em>最高版本。</p>
</li>
<li>
<p>如果严格低于该版本，则选择将失败。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，在范围起作用的情况下，Gradle需要元数据来确定对于所考虑范围确实存在哪些版本。这将导致对元数据的中间查找，如<a href="#sec:how-gradle-downloads-deps">Gradle如何检索依赖元数据？</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:implementation-conflict"><a class="anchor" href="#sec:implementation-conflict"></a> <a class="link" href="#sec:implementation-conflict">解决实施冲突</a></h3>
<div class="paragraph">
<p>Gradle使用变体和功能来识别模块<em>提供的功能</em> 。</p>
</div>
<div class="paragraph">
<p>这是一个独特的功能，值得<a href="#">一章</a>以了解其含义和功能。</p>
</div>
<div class="paragraph">
<p>两个模块之一发生冲突时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>尝试选择不兼容的变体，</p>
</li>
<li>
<p>声明相同的功能</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在<a href="#sub:selecting-between-candidates">选择候选人之间</a>了解有关处理此类冲突的更多信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:how-gradle-downloads-deps"><a class="anchor" href="#sec:how-gradle-downloads-deps"></a> <a class="link" href="#sec:how-gradle-downloads-deps">Gradle如何检索依赖元数据？</a></h3>
<div class="paragraph">
<p>Gradle需要有关依赖关系图中包含的模块的元数据。该信息是两点所必需的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当声明的版本是动态的时，确定模块的现有版本。</p>
</li>
<li>
<p>确定给定版本的模块依赖性。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="discovering_versions"><a class="anchor" href="#discovering_versions"></a> <a class="link" href="#discovering_versions">发现版本</a></h4>
<div class="paragraph">
<p>面对动态版本，Gradle需要确定具体的匹配版本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>检查每个存储库，Gradle不会在第一个返回某些元数据的站点上停止。定义多个时<em>，将按照添加顺序</em>对其进行检查。</p>
</li>
<li>
<p>对于Maven存储库，Gradle将使用<code>maven-metadata.xml</code>提供有关可用版本的信息。</p>
</li>
<li>
<p>对于常春藤存储库，Gradle将诉诸目录列表。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此过程将生成候选版本列表，这些候选版本然后与表示的动态版本匹配。此时，将恢复<a href="#sub:resolution-strategy">版本冲突解决</a> 。</p>
</div>
<div class="paragraph">
<p>请注意，Gradle会缓存版本信息，有关更多信息，请参见<a href="#sec:controlling-dynamic-version-caching">控制动态版本缓存</a>一节。</p>
</div>
</div>
<div class="sect3">
<h4 id="obtaining_module_metadata"><a class="anchor" href="#obtaining_module_metadata"></a> <a class="link" href="#obtaining_module_metadata">获取模块元数据</a></h4>
<div class="paragraph">
<p>给定所需的依赖关系（带有版本），Gradle尝试通过搜索依赖关系指向的模块来解决依赖关系。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依次检查每个存储库。</p>
<div class="ulist">
<ul>
<li>
<p>根据存储库的类型，Gradle会查找描述模块的元数据文件（ <code>.module</code> ， <code>.pom</code>要么<code>ivy.xml</code>文件）或直接用于工件文件。</p>
</li>
<li>
<p>具有模块元数据文件的模块（ <code>.module</code> ， <code>.pom</code>要么<code>ivy.xml</code>文件）优于仅具有工件文件的模块。</p>
</li>
<li>
<p>一旦存储库返回<em>元数据</em>结果，以下存储库将被忽略。</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果找到依赖项的元数据，则将对其进行检索和解析</p>
<div class="ulist">
<ul>
<li>
<p>如果模块元数据是声明了父POM的POM文件，则Gradle将递归地尝试为POM解析每个父模块。</p>
</li>
</ul>
</div>
</li>
<li>
<p>然后，从上述过程中选择的<em>同一存储库</em>中请求模块的所有工件。</p>
</li>
<li>
<p>然后，所有这些数据（包括存储库源和潜在的丢失）都存储在<a href="#sec:dependency_cache">Dependency Cache中</a> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>上面的最后一点是使与<a href="#sec:case-for-maven-local">Maven Local</a>集成的问题。由于它是Maven的缓存，因此有时会错过给定模块的某些工件。如果Gradle从Maven Local采购了这样的模块，它将认为丢失的工件完全丢失。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="repository_blacklisting"><a class="anchor" href="#repository_blacklisting"></a> <a class="link" href="#repository_blacklisting">仓库黑名单</a></h4>
<div class="paragraph">
<p>当Gradle无法从存储库检索信息时，它将在构建期间将其列入黑名单，并且所有依赖项解析都将失败。</p>
</div>
<div class="paragraph">
<p>最后一点对于可重复性很重要。如果允许继续构建而忽略有问题的存储库，则一旦存储库重新联机，后续的构建可能会有不同的结果。</p>
</div>
<div class="sect4">
<h5 id="sub:http-retries"><a class="anchor" href="#sub:http-retries"></a> <a class="link" href="#sub:http-retries">HTTP重试</a></h5>
<div class="paragraph">
<p>在将其列入黑名单之前，Gradle将尝试几次连接到给定的存储库。如果连接失败，Gradle将重试某些可能会被瞬态发生的错误，从而增加每次重试之间的等待时间。</p>
</div>
<div class="paragraph">
<p>当由于永久错误或达到最大重试次数而无法联系存储库时，就会将其列入黑名单。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:dependency_cache"><a class="anchor" href="#sec:dependency_cache"></a> <a class="link" href="#sec:dependency_cache">依赖缓存</a></h3>
<div class="paragraph">
<p>Gradle包含一个高度复杂的依赖项缓存机制，该机制旨在最大程度地减少在依赖项解析中发出的远程请求的数量，同时努力确保依赖项解析的结果正确且可重现。</p>
</div>
<div class="paragraph">
<p>Gradle依赖项缓存由位于以下位置的两种存储类型组成<code>GRADLE_USER_HOME/caches</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基于文件的下载工件的存储，包括二进制文件（如jars）以及原始下载的元数据（如POM文件和Ivy文件）。下载的工件的存储路径包括SHA1校验和，这意味着可以轻松地缓存2个名称相同但内容不同的工件。</p>
</li>
<li>
<p>解析的模块元数据的二进制存储，包括解析动态版本，模块描述符和工件的结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle缓存不允许本地缓存隐藏问题并创建其他神秘且难以调试的行为。Gradle专注于带宽和存储效率，可实现可靠且可复制的企业构建。</p>
</div>
<div class="sect3">
<h4 id="sub:cache_metadata"><a class="anchor" href="#sub:cache_metadata"></a> <a class="link" href="#sub:cache_metadata">独立的元数据缓存</a></h4>
<div class="paragraph">
<p>Gradle在元数据缓存中以二进制格式记录了依赖性解析的各个方面。存储在元数据缓存中的信息包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>解析动态版本的结果（例如， <code>1.+</code> ）到具体版本（例如<code>1.2</code> ）。</p>
</li>
<li>
<p>特定模块的已解析模块元数据，包括模块工件和模块依赖性。</p>
</li>
<li>
<p>特定工件的已解析工件元数据，包括指向下载的工件文件的指针。</p>
</li>
<li>
<p>由于<em>没有</em>在一个特定的存储库中的特定模块或工件，省去重复尝试访问不存在的资源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>元数据缓存中的每个条目都包括提供信息的存储库记录以及可用于缓存过期的时间戳。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:cache_repository_independence"><a class="anchor" href="#sub:cache_repository_independence"></a> <a class="link" href="#sub:cache_repository_independence">存储库缓存是独立的</a></h4>
<div class="paragraph">
<p>如上所述，对于每个存储库，都有一个单独的元数据缓存。存储库由其URL，类型和布局标识。如果以前没有从此<em>存储库</em>解析模块或工件，则Gradle将尝试根据存储库解析模块。这将始终涉及对存储库的远程查找，但是在许多情况下， <a href="#sub:cache_artifact_reuse">不需要下载</a> 。</p>
</div>
<div class="paragraph">
<p>如果所需的构件在构建指定的任何存储库中都不可用，则依赖关系解析将失败，即使本地缓存具有从其他存储库检索到的该构件的副本，也是如此。存储库独立性允许构建以以前没有构建工具完成的高级方式彼此隔离。这是创建可在任何环境下可靠且可复制的内部版本的关键功能。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:cache_artifact_reuse"><a class="anchor" href="#sub:cache_artifact_reuse"></a> <a class="link" href="#sub:cache_artifact_reuse">工件重用</a></h4>
<div class="paragraph">
<p>在下载工件之前，Gradle会尝试通过下载与该工件关联的sha文件来确定所需工件的校验和。如果可以检索校验和，那么如果已经存在具有相同ID和校验和的工件，则不会下载工件。如果无法从远程服务器检索校验和，则将下载工件（如果它与现有工件匹配，则将被忽略）。</p>
</div>
<div class="paragraph">
<p>除了考虑从其他存储库下载的工件外，Gradle还将尝试重用在本地Maven存储库中找到的工件。如果Maven已下载了候选工件，则Gradle将使用此工件，前提是可以对其进行验证以匹配远程服务器声明的校验和。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:cache_checksum_storage"><a class="anchor" href="#sub:cache_checksum_storage"></a> <a class="link" href="#sub:cache_checksum_storage">基于校验和的存储</a></h4>
<div class="paragraph">
<p>响应相同的工件标识符，不同的存储库可能会提供不同的二进制工件。Maven SNAPSHOT工件通常是这种情况，但对于在不更改其标识符的情况下重新发布的任何工件也是如此。通过根据工件的SHA1校验和缓存工件，Gradle能够维护同一工件的多个版本。这意味着在针对一个存储库进行解析时，Gradle绝不会覆盖来自其他存储库的缓存工件文件。无需在每个存储库中单独存放工件文件即可完成此操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:cache_locking"><a class="anchor" href="#sub:cache_locking"></a> <a class="link" href="#sub:cache_locking">缓存锁定</a></h4>
<div class="paragraph">
<p>Gradle依赖项缓存使用基于文件的锁定来确保多个Gradle进程可以安全地同时使用它。每当读取或写入二进制元数据存储时，都会保留该锁，但是会为缓慢的操作（例如下载远程工件）而释放该锁。</p>
</div>
<div class="paragraph">
<p>仅当不同的Gradle进程可以一起通信时，才支持此并发访问。对于容器化版本，通常<em>不是这种情况</em> 。</p>
</div>
<div class="sect4">
<h5 id="sub:cache_cleanup"><a class="anchor" href="#sub:cache_cleanup"></a> <a class="link" href="#sub:cache_cleanup">缓存清理</a></h5>
<div class="paragraph">
<p>Gradle跟踪访问依赖项缓存中的哪些工件。使用此信息，定期（最多每24小时）扫描缓存，以查找未使用超过30天的工件。然后删除过时的工件，以确保高速缓存不会无限期增长。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:programmatic_api"><a class="anchor" href="#sec:programmatic_api"></a> <a class="link" href="#sec:programmatic_api">以编程方式访问分辨率结果</a></h3>
<div class="paragraph">
<p>尽管大多数用户只需要访问文件的“固定列表”，但是在某些情况下，在<em>图</em>上进行推理并获得有关分辨率结果的更多信息可能会很有趣：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用于工具集成，其中需要依赖图的模型</p>
</li>
<li>
<p>用于生成视觉表示（图像， <code>.dot</code>文件，……）</p>
</li>
<li>
<p>用于提供诊断的任务（类似于<code>dependencyInsight</code>任务）</p>
</li>
<li>
<p>适用于需要在执行时执行依赖关系解析的任务（例如，按需下载文件）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于这些用例，Gradle提供了惰性的，线程安全的API，可通过调用<a href="../javadoc/org/gradle/api/artifacts/Configuration.html#getIncoming--">Configuration.getIncoming（）</a>方法进行访问：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult--">ResolutionResult API</a>允许访问已解析的依赖关系图，无论解析是否成功。</p>
</li>
<li>
<p><a href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getArtifacts--">工件API</a>提供了对未转换但未转换的工件的简单访问，但是具有工件的延迟下载（它们只能按需下载）。</p>
</li>
<li>
<p><a href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#artifactView-org.gradle.api.Action-">工件视图API</a>提供了可能经过<a href="#sec:abm_artifact_transforms">转换</a>的工件的高级筛选视图。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="declaring_versions" class="sect0"><a class="anchor" href="#declaring_versions"></a> <a class="link" href="#declaring_versions">声明版本</a></h1>
<div class="sect1">
<h2 id="single-version-declarations"><a class="anchor" href="#single-version-declarations"></a> <a class="link" href="#single-version-declarations">声明版本和范围</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>最简单的版本声明是表示要使用的版本的<em>简单字符串</em> 。Gradle支持不同的方式来声明版本字符串：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确切的版本：例如<code>1.3</code> ， <code>1.3.0-beta3</code> ，<code>1.0-20150201.131010-1</code></p>
</li>
<li>
<p>Maven样式的版本范围：例如<code>[1.0,)</code> ， <code>[1.1, 2.0)</code> ，<code>(1.2, 1.5]</code></p>
<div class="ulist">
<ul>
<li>
<p>的<code>[</code>和<code>]</code>符号表示包含范围； <code>(</code>和<code>)</code>表示排他界限。</p>
</li>
<li>
<p>如果缺少上限或下限，则范围没有上限或下限。</p>
</li>
<li>
<p>符号<code>]</code>可以代替<code>(</code>排他的下限<code>[</code>代替<code>)</code>独家上限。例如<code>]1.0, 2.0[</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><em>前缀</em>版本范围：例如<code>1.+</code> ，<code>1.3.+</code></p>
<div class="ulist">
<ul>
<li>
<p>仅版本完全匹配<code>+</code>被包含在内。</p>
</li>
<li>
<p>范围<code>+</code>它本身将包含任何版本。</p>
</li>
</ul>
</div>
</li>
<li>
<p>一种<code>latest-status</code>版本：例如<code>latest.integration</code> ，<code>latest.release</code></p>
<div class="ulist">
<ul>
<li>
<p>将使版本最高的模块与指定状态匹配。请参阅<a href="../javadoc/org/gradle/api/artifacts/ComponentMetadata.html#getStatus--">ComponentMetadata.getStatus（）</a> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>一个行家<code>SNAPSHOT</code>版本标识符：例如<code>1.0-SNAPSHOT</code> ，<code>1.4.9-beta1-SNAPSHOT</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="version_ordering"><a class="anchor" href="#version_ordering"></a> <a class="link" href="#version_ordering">版本订购</a></h3>
<div class="paragraph">
<p>版本具有隐式排序。版本排序用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确定特定版本是否包含在范围内。</p>
</li>
<li>
<p>解决冲突时，确定哪个版本是“最新的”。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>版本根据以下规则排序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个版本均分为其组成的“部分”：</p>
<div class="ulist">
<ul>
<li>
<p>那些角色<code>[. - _ +]</code>用于分隔版本的不同“部分”。</p>
</li>
<li>
<p>同时包含数字和字母的任何部分都将分为以下各个部分：<code>1a1 == 1.a.1</code></p>
</li>
<li>
<p>仅比较版本的各个部分。实际的分隔符并不重要：<code>1.a.1 == 1-a+1 == 1.a-1 == 1a1</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>使用以下规则比较2个版本的等效部分：</p>
<div class="ulist">
<ul>
<li>
<p>如果两个部分都是数字，则最高数值<strong>较高</strong> ： <code>1.1</code> <<code>1.2</code></p>
</li>
<li>
<p>如果一个部分是数字，它被认为比非数字部分<strong>高</strong> ： <code>1.a</code> <<code>1.1</code></p>
</li>
<li>
<p>如果两者都不是数字，则按<strong>字母顺序</strong>比较各部分<strong>，区分大小写</strong> ： <code>1.A</code> < <code>1.B</code> < <code>1.a</code> <<code>1.b</code></p>
</li>
<li>
<p>具有额外数字部分的版本被认为<strong>高于</strong>没有以下内容的版本： <code>1.1</code> <<code>1.1.0</code></p>
</li>
<li>
<p>具有额外的非数字部分的版本被认为<strong>低于</strong>没有以下内容的版本： <code>1.1.a</code> <<code>1.1</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>某些字符串值出于排序目的具有特殊含义：</p>
<div class="ulist">
<ul>
<li>
<p>字符串<code>dev</code>被认为<strong>低于</strong>任何其他字符串部分： <code>1.0-dev</code> < <code>1.0-alpha</code> < <code>1.0-rc</code> 。</p>
</li>
<li>
<p>琴弦<code>rc</code> ， <code>release</code>和<code>final</code>被认为<strong>高于</strong>其他任何字符串部分（按此顺序排序）： <code>1.0-zeta</code> < <code>1.0-rc</code> < <code>1.0-release</code> < <code>1.0-final</code> < <code>1.0</code> 。</p>
</li>
<li>
<p>字符串<code>SNAPSHOT</code> <strong>没有特殊含义</strong> ，并且像其他字符串部分一样按字母顺序排序： <code>1.0-alpha</code> < <code>1.0-SNAPSHOT</code> < <code>1.0-zeta</code> < <code>1.0-rc</code> < <code>1.0</code> 。</p>
</li>
<li>
<p>数字快照版本<strong>没有特殊含义</strong> ，其排序方式与其他任何数字部分一样： <code>1.0</code> < <code>1.0-20150201.121010-123</code> < <code>1.1</code> 。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="simple_version_declaration_semantics"><a class="anchor" href="#simple_version_declaration_semantics"></a> <a class="link" href="#simple_version_declaration_semantics">简单的版本声明语义</a></h3>
<div class="paragraph">
<p>使用缩写符号声明版本时，例如：</p>
</div>
<div class="exampleblock">
<div class="title">示例47一个简单的声明</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation('org.slf4j:slf4j-api:1.7.15')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.slf4j:slf4j-api:1.7.15")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随后的版本被认为是<a href="#sec:required-version">需要的版本</a> ，这意味着它应该是<em>最低限度</em> <code>1.7.15</code>但可以通过引擎进行升级（乐观升级）。</p>
</div>
<div class="paragraph">
<p>但是，对于<a href="#sec:strict-version">严格版本</a> ，有一种简写<a href="#sec:strict-version">形式</a> <code>!!</code>符号：</p>
</div>
<div class="exampleblock">
<div class="title">示例48严格依赖的简写</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // short-hand notation with !!
    implementation('org.slf4j:slf4j-api:1.7.15!!')
    // is equivalent to
    implementation("org.slf4j:slf4j-api") {
        version {
           strictly '1.7.15'
        }
    }

    // or...
    implementation('org.slf4j:slf4j-api:[1.7, 1.8[!!1.7.25')
    // is equivalent to
    implementation('org.slf4j:slf4j-api') {
        version {
           strictly '[1.7, 1.8['
           prefer '1.7.25'
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // short-hand notation with !!
    implementation("org.slf4j:slf4j-api:1.7.15!!")
    // is equivalent to
    implementation("org.slf4j:slf4j-api") {
        version {
           strictly("1.7.15")
        }
    }

    // or...
    implementation("org.slf4j:slf4j-api:[1.7, 1.8[!!1.7.25")
    // is equivalent to
    implementation("org.slf4j:slf4j-api") {
        version {
           strictly([1.7, 1.8[")
           prefer("1.7.25")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>严格版本<em>无法升级，</em>并且会覆盖此依赖关系提供的所有传递依赖关系。建议对严格版本使用范围。</p>
</div>
<div class="paragraph">
<p>记法<code>[1.7, 1.8[!!1.7.25</code>以上等同于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>严格地<code>[1.7, 1.8[</code></p>
</li>
<li>
<p>偏爱<code>1.7.25</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着引擎<strong>必须</strong>在1.7（包括）和1.8（排除）之间选择一个版本，并且如果图中没有其他组件需要其他版本，则它应该<em>优先使用</em> <code>1.7.25</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:declaring_without_version"><a class="anchor" href="#sec:declaring_without_version"></a> <a class="link" href="#sec:declaring_without_version">声明不带版本的依赖</a></h3>
<div class="paragraph">
<p>对于较大的项目，建议的做法是声明没有版本的依赖项，并将<a href="#sec:adding-constraints-transitive-deps">依赖项约束</a>用于版本声明。优点是，依赖关系约束使您可以在一处管理所有依赖关系的版本，包括可传递的依赖关系。</p>
</div>
<div class="exampleblock">
<div class="title">示例49。声明不带版本的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'org.springframework:spring-web'
}

dependencies {
    constraints {
        implementation 'org.springframework:spring-web:5.0.2.RELEASE'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.springframework:spring-web")
}

dependencies {
    constraints {
        implementation("org.springframework:spring-web:5.0.2.RELEASE")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rich-version-constraints"><a class="anchor" href="#rich-version-constraints"></a> <a class="link" href="#rich-version-constraints">声明丰富版本</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle支持用于声明版本的丰富模型，该模型允许组合不同级别的版本信息。术语及其含义如下（从最强到最弱）：</p>
</div>
<div id="sec:strict-version" class="dlist">
<dl>
<dt class="hdlist1"><code>strictly</code></dt>
<dd>
<p>与该版本符号不匹配的任何版本将被排除。这是最强的版本声明。在声明的依赖项上， <code>strictly</code>可以降级版本。在传递依赖项上，如果无法选择此子句可接受的版本，则将导致依赖项解析失败。有关详细信息，请参见<a href="#sec:enforcing_dependency_version">覆盖依赖项版本</a> 。该术语支持动态版本。</p>
<div class="paragraph">
<p>定义时，覆盖上一个<code>require</code>声明并清除先前的<code>reject</code> 。</p>
</div>
</dd>
</dl>
</div>
<div id="sec:required-version" class="dlist">
<dl>
<dt class="hdlist1"><code>require</code></dt>
<dd>
<p>表示所选版本不能低于<code>require</code>接受，但通过冲突解决可以更高，即使更高具有排他性上限。这就是依赖项上的直接版本所转换的内容。该术语支持动态版本。</p>
<div class="paragraph">
<p>定义时，覆盖上一个<code>strictly</code>声明并清除先前的<code>reject</code> 。</p>
</div>
</dd>
</dl>
</div>
<div id="sec:preferred-version" class="dlist">
<dl>
<dt class="hdlist1"><code>prefer</code></dt>
<dd>
<p>这是一个非常软的版本声明。仅当对该模块的版本没有更强的非动态观点时，才适用。该术语不支持动态版本。</p>
<div class="paragraph">
<p>定义可以补充<code>strictly</code>要么<code>require</code> 。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在级别层次结构之外还有一个附加术语：</p>
</div>
<div id="sec:rejected-version" class="dlist">
<dl>
<dt class="hdlist1"><code>reject</code></dt>
<dd>
<p>声明模块不接受特定版本。如果唯一的可选版本也被拒绝，这将导致依赖项解析失败。该术语支持动态版本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>下表说明了许多用例以及如何组合不同的术语以进行丰富版本声明：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表4。丰富版本的用例</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">可以使用哪个版本的依存关系？</th>
<th class="tableblock halign-left valign-top"><code>strictly</code></th>
<th class="tableblock halign-left valign-top"><code>require</code></th>
<th class="tableblock halign-left valign-top"><code>prefer</code></th>
<th class="tableblock halign-left valign-top"><code>rejects</code></th>
<th class="tableblock halign-left valign-top">选择结果</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">经过版本测试<code>1.5</code> ，请相信所有将来的版本都可以使用。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从以下版本开始<code>1.5</code> ，相当于<code>org:foo:1.5</code> 。升级到<code>2.4</code>被接受。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">经过测试<code>1.5</code> ，软约束会根据语义版本进行升级。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.0，2.0 [</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之间的任何版本<code>1.0</code>和<code>2.0</code> ， <code>1.5</code>如果没有人在乎。升级到<code>2.4</code>被接受。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">经过测试<code>1.5</code> ，但遵循语义版本控制。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.0，2.0 [</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之间的任何版本<code>1.0</code>和<code>2.0</code>排除在外， <code>1.5</code>如果没有人在乎。<br>从传递依赖项覆盖版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">与上述相同， <code>1.4</code>已知坏了。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.0，2.0 [</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之间的任何版本<code>1.0</code>和<code>2.0</code>排除在外<code>1.4</code> ， <code>1.5</code>如果没有人在乎。<br>从传递依赖项覆盖版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没意见，与<code>1.5</code> 。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code>如果没有其他意见，则其他任何意见。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没意见，喜欢最新版本。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>latest.release</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生成时的最新版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在边缘，最新版本，没有降级。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>latest.release</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生成时的最新版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有其他版本，只有1.5。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5，否则失败<code>strict</code>或更高<code>require</code>约束不同意。<br>从传递依赖项覆盖版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code>或专门的补丁版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.5,1.6 [</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最新<code>1.5.x</code>补丁发布，否则失败<code>strict</code>或更高<code>require</code>约束不同意。<br>从传递依赖项覆盖版本。<br>🔒</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>带锁（🔒）的行表示在这种情况下，利用<a href="#">依赖项锁</a>是有意义的。与丰富版本声明相关的另一个概念是能够发布已<a href="publishing_maven.html#publishing_maven:resolved_dependencies">解析版本</a>而不是已声明版本。</p>
</div>
<div class="paragraph">
<p>使用<code>strictly</code> ，尤其对于图书馆而言，必须是一个经过深思熟虑的过程，因为它会对下游消费者产生影响。同时，如果使用得当，它将有助于消费者了解哪些库组合在其上下文中无法协同工作。有关更多信息，请参见<a href="#sec:enforcing_dependency_version">覆盖依赖项版本</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>丰富的版本信息将以Gradle Module元数据格式保存。但是，转换为Ivy或Maven元数据格式将是有损的。最高级别将被发布，即<code>strictly</code>要么<code>require</code>过度<code>prefer</code> 。此外，任何<code>reject</code>将被忽略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>富版本声明可通过<code>version</code>依赖项或约束声明的DSL方法，可以访问<a href="../javadoc/org/gradle/api/artifacts/MutableVersionConstraint.html">MutableVersionConstraint</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例50丰富的版本声明</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation('org.slf4j:slf4j-api') {
        version {
            strictly '[1.7, 1.8['
            prefer '1.7.25'
        }
    }

    constraints {
        implementation('org.springframework:spring-core') {
            version {
                require '4.2.9.RELEASE'
                reject '4.3.16.RELEASE'
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.slf4j:slf4j-api") {
        version {
            strictly("[1.7, 1.8[")
            prefer("1.7.25")
        }
    }

    constraints {
        add("implementation", "org.springframework:spring-core") {
            version {
                require("4.2.9.RELEASE")
                reject("4.3.16.RELEASE")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:dynamic_versions_and_changing_modules"><a class="anchor" href="#sec:dynamic_versions_and_changing_modules"></a> <a class="link" href="#sec:dynamic_versions_and_changing_modules">处理随时间变化的版本</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在许多情况下，您想使用特定模块依赖项的最新版本或一系列版本中的最新版本。这可能是开发过程中的要求，或者您可能正在开发旨在与一系列依赖版本一起使用的库。您可以使用<em>动态版本</em>轻松地依赖这些不断变化的依赖关系。<a href="#sub:declaring_dependency_with_dynamic_version">动态版本</a>可以是版本范围（例如<code>2.+</code> ），也可以是可用的最新版本的占位符，例如<code>latest.integration</code> 。</p>
</div>
<div class="paragraph">
<p>另外，您请求的模块甚至可以针对同一版本（即所谓的“ <a href="#sub:declaring_dependency_with_changing_version">更改版本”）</a>随时间<a href="#sub:declaring_dependency_with_changing_version">变化</a> 。这种类型的<em>更改模块</em>的示例是Maven <code>SNAPSHOT</code>模块，始终指向最新发布的工件。换句话说，标准的Maven快照是一个不断发展的模块，它是一个“不断变化的模块”。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>使用动态版本和更改模块可能导致无法复制的构建。随着特定模块的新版本发布，其API可能与您的源代码不兼容。请谨慎使用此功能！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="sub:declaring_dependency_with_dynamic_version"><a class="anchor" href="#sub:declaring_dependency_with_dynamic_version"></a> <a class="link" href="#sub:declaring_dependency_with_dynamic_version">声明动态版本</a></h3>
<div class="paragraph">
<p>项目可能会采用更激进的方法来消耗对模块的依赖。例如，您可能希望始终集成最新版本的依赖项，以便在任何给定时间使用最先进的功能。<em>动态版本</em>允许解析给定模块的最新版本或版本范围的最新版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>在构建中使用动态版本会承担潜在破坏它的风险。包含不兼容的API更改的依赖关系的新版本发布后，您的源代码可能会停止编译。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">例子51。声明具有动态版本的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java-library'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework:spring-web:5.+'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    `java-library`
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.springframework:spring-web:5.+")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://scans.gradle.com/">构建扫描</a>可以有效地可视化动态依赖项版本及其各自的选定版本。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-dynamic-dependency-build-scan.png" alt="依赖管理动态依赖构建扫描">
</div>
<div class="title">图10。构建扫描中的动态依赖项</div>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将动态版本的依赖项缓存24小时。在此时间范围内，Gradle不会尝试从声明的存储库中解析较新的版本。<a href="#sec:controlling-dynamic-version-caching">可以</a>根据需要<a href="#sec:controlling-dynamic-version-caching">配置阈值</a> ，例如，如果您想更早地解析新版本。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:declaring_dependency_with_changing_version"><a class="anchor" href="#sub:declaring_dependency_with_changing_version"></a> <a class="link" href="#sub:declaring_dependency_with_changing_version">声明版本变更</a></h3>
<div class="paragraph">
<p>在发布应用程序或库的新版本之前，团队可能会决定实施一系列功能。允许消费者尽早且经常集成其未完成版本的一种通用策略是发布具有所谓<em>更改版本</em>的模块。版本更改表示该功能集仍在积极开发中，尚未发布稳定的版本以实现普遍可用性。</p>
</div>
<div class="paragraph">
<p>在Maven存储库中，更改的版本通常称为<a href="https://maven.apache.org/guides/getting-started/index.html#What_is_a_SNAPSHOT_version">快照版本</a> 。快照版本包含后缀<code>-SNAPSHOT</code> 。以下示例演示了如何在Spring依赖项上声明快照版本。</p>
</div>
<div class="exampleblock">
<div class="title">示例52。声明版本更改的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java-library'
}

repositories {
    mavenCentral()
    maven {
        url 'https://repo.spring.io/snapshot/'
    }
}

dependencies {
    implementation 'org.springframework:spring-web:5.0.3.BUILD-SNAPSHOT'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    `java-library`
}

repositories {
    mavenCentral()
    maven {
        url = uri("https://repo.spring.io/snapshot/")
    }
}

dependencies {
    implementation("org.springframework:spring-web:5.0.3.BUILD-SNAPSHOT")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将更改的依赖项版本缓存24小时。在此时间范围内，Gradle不会尝试从声明的存储库中解析较新的版本。<a href="#sec:controlling-dynamic-version-caching">可以</a>根据需要<a href="#sec:controlling-dynamic-version-caching">配置阈值</a> ，例如，如果您想更早地解析新的快照版本。</p>
</div>
<div class="paragraph">
<p>Gradle足够灵活，可以将任何版本视为更改版本，例如，如果您想为Ivy模块的快照行为建模。您需要做的就是将属性<a href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html#setChanging-boolean-">ExternalModuleDependency.setChanging（boolean）设置</a>为<code>true</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:controlling-dynamic-version-caching"><a class="anchor" href="#sec:controlling-dynamic-version-caching"></a> <a class="link" href="#sec:controlling-dynamic-version-caching">控制动态版本缓存</a></h3>
<div class="paragraph">
<p>默认情况下，Gradle会在24小时内缓存动态版本和更改模块。在这段时间内，Gradle不会与任何已声明的远程存储库联系以获取新版本。如果您想让Gradle更频繁地检查远程存储库或在每次执行构建时检查远程存储库，则需要更改生存时间（TTL）阈值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>由于HTTP（s）调用数量增加，因此对于动态版本或更改版本使用较短的TTL阈值可能会导致构建时间更长。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<a href="#sec:controlling_dependency_caching_command_line">命令行选项</a>覆盖默认的缓存模式。您还可以使用解析策略以<a href="#sec:controlling_dependency_caching_programmatically">编程方式更改构建中的缓存过期时间</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:controlling_dependency_caching_programmatically"><a class="anchor" href="#sec:controlling_dependency_caching_programmatically"></a> <a class="link" href="#sec:controlling_dependency_caching_programmatically">以编程方式控制依赖项缓存</a></h3>
<div class="paragraph">
<p>您可以使用<a href="../javadoc/org/gradle/api/artifacts/ResolutionStrategy.html">ResolutionStrategy</a>对配置进行编程来微调缓存的某些方面。如果您想永久更改设置，则编程方式非常有用。</p>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将动态版本缓存24小时。要更改Gradle将解析后的版本缓存为动态版本的时间，请使用：</p>
</div>
<div class="exampleblock">
<div class="title">示例53。动态版本缓存控制</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor 10, 'minutes'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor(10, "minutes")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将更改的模块缓存24小时。要更改Gradle将为更改的模块缓存元数据和工件的时间，请使用：</p>
</div>
<div class="exampleblock">
<div class="title">示例54更改模块缓存控制</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.cacheChangingModulesFor 4, 'hours'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.cacheChangingModulesFor(4, "hours")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:controlling_dependency_caching_command_line"><a class="anchor" href="#sec:controlling_dependency_caching_command_line"></a> <a class="link" href="#sec:controlling_dependency_caching_command_line">从命令行控制依赖项缓存</a></h3>
<div class="sect3">
<h4 id="sec:offline-mode"><a class="anchor" href="#sec:offline-mode"></a> <a class="link" href="#sec:offline-mode">离线模式下避免网络访问</a></h4>
<div class="paragraph">
<p>的<code>--offline</code>命令行开关告诉Gradle始终使用缓存中的依赖项模块，而不管是否要再次检查它们。当离线运行时，Gradle将永远不会尝试访问网络来执行依赖关系解析。如果依赖项缓存中不存在所需的模块，则生成执行将失败。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:refreshing-dependencies"><a class="anchor" href="#sec:refreshing-dependencies"></a> <a class="link" href="#sec:refreshing-dependencies">刷新依赖</a></h4>
<div class="paragraph">
<p>您可以控制依赖项缓存的行为，以从命令行进行不同的构建调用。命令行选项有助于对构建的一次执行做出选择性的临时选择。</p>
</div>
<div class="paragraph">
<p>有时，Gradle Dependency Cache可能与已配置存储库的实际状态不同步。最初可能是错误配置了存储库，或者错误地发布了“不变”模块。要刷新依赖项缓存中的所有依赖项，请使用<code>--refresh-dependencies</code>命令行上的选项。</p>
</div>
<div class="paragraph">
<p>的<code>--refresh-dependencies</code>选项告诉Gradle忽略所有缓存的已解析模块和工件的条目。将对所有已配置的存储库执行全新的解析，并重新计算动态版本，刷新模块并下载工件。但是，在可能的情况下，Gradle将在再次下载之前检查先前下载的工件是否有效。通过将存储库中已发布的SHA1值与现有下载的工件的SHA1值进行比较来完成此操作。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>动态依赖的新版本</p>
</li>
<li>
<p>更改模块的新版本（使用相同版本字符串但可以具有不同内容的模块）</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>刷新依赖关系将导致Gradle使其列表缓存无效。然而：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它将对元数据文件执行HTTP HEAD请求，但如果它们相同<em>则不会重新下载它们</em></p>
</li>
<li>
<p>它将对工件文件执行HTTP HEAD请求，但如果它们相同<em>则不会重新下载它们</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>换句话说，刷新依赖关系<em>仅</em>在您实际使用动态依赖关系<em>或</em>您具有未知的变化依赖关系<em>时才</em>有影响（在这种情况下，您有责任将其正确声明为Gradle作为变化依赖关系）。</p>
</div>
<div class="paragraph">
<p>认为使用<code>--refresh-dependencies</code>将强制下载依赖项。事实<strong>并非</strong>如此：Gradle将仅执行刷新动态依赖项严格要求的操作。这<em>可能</em>涉及下载新的清单或元数据文件，甚至是工件，但是如果没有任何更改，则影响最小。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:component_selection_rules"><a class="anchor" href="#sec:component_selection_rules"></a> <a class="link" href="#sec:component_selection_rules">使用组件选择规则</a></h3>
<div class="paragraph">
<p>当有多个与版本选择器匹配的版本可用时，组件选择规则可能会影响应该选择哪个组件实例。规则适用于每个可用版本，并允许该规则明确拒绝该版本。这允许Gradle忽略不满足规则设置的条件的任何组件实例。示例包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于像这样的动态版本<code>1.+</code>某些版本可能会明确拒绝选择。</p>
</li>
<li>
<p>对于像这样的静态版本<code>1.4</code>可以基于额外的组件元数据（例如Ivy分支属性）拒绝实例，从而允许使用后续存储库中的实例。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过<a href="../dsl/org.gradle.api.artifacts.ComponentSelectionRules.html">ComponentSelectionRules</a>对象配置规则。将使用<a href="../dsl/org.gradle.api.artifacts.ComponentSelection.html">ComponentSelection</a>对象作为参数调用配置的每个规则，该对象包含有关所考虑的候选版本的信息。调用<a href="../dsl/org.gradle.api.artifacts.ComponentSelection.html#org.gradle.api.artifacts.ComponentSelection:reject(java.lang.String)">ComponentSelection.reject（java.lang。字符串）</a>会导致明确拒绝给定的候选版本，在这种情况下，选择器将不考虑候选版本。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个规则，该规则禁止模块的特定版本，但允许动态版本选择下一个最佳候选者。</p>
</div>
<div class="exampleblock">
<div class="title">例子55。组件选择规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    rejectConfig {
        resolutionStrategy {
            componentSelection {
                // Accept the highest version matching the requested version that isn't '1.5'
                all { ComponentSelection selection -&gt;
                    if (selection.candidate.group == 'org.sample' &amp;&amp; selection.candidate.module == 'api' &amp;&amp; selection.candidate.version == '1.5') {
                        selection.reject("version 1.5 is broken for 'org.sample:api'")
                    }
                }
            }
        }
    }
}

dependencies {
    rejectConfig "org.sample:api:1.+"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    create("rejectConfig") {
        resolutionStrategy {
            componentSelection {
                // Accept the highest version matching the requested version that isn't '1.5'
                all {
                    if (candidate.group == "org.sample" &amp;&amp; candidate.module == "api" &amp;&amp; candidate.version == "1.5") {
                        reject("version 1.5 is broken for 'org.sample:api'")
                    }
                }
            }
        }
    }
}

dependencies {
    "rejectConfig"("org.sample:api:1.+")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，首先从最高版本开始应用版本选择。选择的版本将是所有组件选择规则都接受的第一个版本。如果没有任何规则明确拒绝该版本，则该版本被视为接受。</p>
</div>
<div class="paragraph">
<p>同样，规则可以针对特定模块。必须以以下形式指定模块<code>group:module</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子56。具有模块目标的组件选择规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    targetConfig {
        resolutionStrategy {
            componentSelection {
                withModule("org.sample:api") { ComponentSelection selection -&gt;
                    if (selection.candidate.version == "1.5") {
                        selection.reject("version 1.5 is broken for 'org.sample:api'")
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    create("targetConfig") {
        resolutionStrategy {
            componentSelection {
                withModule("org.sample:api") {
                    if (candidate.version == "1.5") {
                        reject("version 1.5 is broken for 'org.sample:api'")
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>组件选择规则在选择版本时也可以考虑组件元数据。可以考虑的其他可能的元数据是<a href="../javadoc/org/gradle/api/artifacts/ComponentMetadata.html">ComponentMetadata</a>和<a href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html">IvyModuleDescriptor</a> 。请注意，此额外信息可能并不总是可用，因此应检查<code>null</code>价值观。</p>
</div>
<div class="exampleblock">
<div class="title">例子57。带有元数据的组件选择规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    metadataRulesConfig {
        resolutionStrategy {
            componentSelection {
                // Reject any versions with a status of 'experimental'
                all { ComponentSelection selection -&gt;
                    if (selection.candidate.group == 'org.sample' &amp;&amp; selection.metadata?.status == 'experimental') {
                        selection.reject("don't use experimental candidates from 'org.sample'")
                    }
                }
                // Accept the highest version with either a "release" branch or a status of 'milestone'
                withModule('org.sample:api') { ComponentSelection selection -&gt;
                    if (selection.getDescriptor(IvyModuleDescriptor)?.branch != "release" &amp;&amp; selection.metadata?.status != 'milestone') {
                        selection.reject("'org.sample:api' must have testing branch or milestone status")
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    create("metadataRulesConfig") {
        resolutionStrategy {
            componentSelection {
                // Reject any versions with a status of 'experimental'
                all {
                    if (candidate.group == "org.sample" &amp;&amp; metadata?.status == "experimental") {
                        reject("don't use experimental candidates from 'org.sample'")
                    }
                }
                // Accept the highest version with either a "release" branch or a status of 'milestone'
                withModule("org.sample:api") {
                    if (getDescriptor(IvyModuleDescriptor::class)?.branch != "release" &amp;&amp; metadata?.status != "milestone") {
                        reject("'org.sample:api' must have testing branch or milestone status")
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，在声明组件选择规则时， <em>始终</em>需要<a href="../dsl/org.gradle.api.artifacts.ComponentSelection.html">ComponentSelection</a>参数作为参数。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dependency-locking"><a class="anchor" href="#dependency-locking"></a> <a class="link" href="#dependency-locking">锁定依赖版本</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用动态依赖版本（例如<code>1.+</code>要么<code>[1.0,2.0)</code> ）使构建不确定。这会导致构建崩溃而没有任何明显的变化，更糟糕的是，可能是由于构建作者无法控制的传递依赖关系所致。</p>
</div>
<div class="paragraph">
<p>为了实现可<a href="https://reproducible-builds.org/">复制的构建</a> ，必须<em>锁定</em>依赖项和传递性依赖项的版本，以便具有相同输入的构建将始终解析相同的模块版本。这称为<em>依赖锁定</em> 。</p>
</div>
<div class="paragraph">
<p>除其他外，它启用以下方案：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理多个存储库的公司不再需要依赖<code>-SNAPSHOT</code>或更改依赖关系，当依赖关系引入错误或不兼容性时，有时会导致级联失败。现在，可以针对主要或次要版本范围声明依赖项，从而可以在CI上测试最新版本，同时利用锁定来稳定开发人员构建。</p>
</li>
<li>
<p>希望始终使用最新依赖关系的团队可以使用动态版本，仅针对发行版锁定其依赖关系。release标签将包含锁定状态，从而在需要开发错误修复程序时可以完全重现该版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与<a href="publishing_maven.html#publishing_maven:resolved_dependencies">发布解析版本</a>结合使用，您还可以在发布时替换声明的动态版本部件。消费者将看到您的发行版已解决的版本。</p>
</div>
<div class="paragraph">
<p>每个<a href="#sec:what-are-dependency-configurations">依赖项配置</a>均启用锁定。启用后，您必须创建一个初始锁定状态。这将使Gradle验证分辨率结果没有改变，即使生成了新版本，也会导致选择的依赖项相同。对您的构建的修改可能会影响已解决的依赖关系集，将导致其失败。这样可以确保发布的依赖项或构建定义中的更改不会在不调整锁定状态的情况下更改分辨率。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>依赖关系锁定仅对于<a href="#sub:declaring_dependency_with_dynamic_version">动态版本</a>才有意义。不会影响<a href="#sub:declaring_dependency_with_changing_version">版本的更改</a> （例如<code>-SNAPSHOT</code> ），尽管其内容可能会更改，但其坐标保持不变。当持久锁状态和解析结果中存在变化的依赖性时，Gradle甚至会发出警告。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="enabling_locking_on_configurations"><a class="anchor" href="#enabling_locking_on_configurations"></a> <a class="link" href="#enabling_locking_on_configurations">启用配置锁定</a></h3>
<div class="paragraph">
<p>锁定配置是通过<a href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html">ResolutionStrategy进行的</a> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例58。锁定特定配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    compileClasspath {
        resolutionStrategy.activateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.compileClasspath {
    resolutionStrategy.activateDependencyLocking()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或以下方法，作为锁定所有配置的一种方法：</p>
</div>
<div class="exampleblock">
<div class="title">范例59。锁定所有配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencyLocking {
    lockAllConfigurations()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencyLocking {
    lockAllConfigurations()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>仅可解析的配置将具有锁定状态。在不可解析的配置上应用锁定只是一个禁忌。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>上面的代码将锁定所有<em>项目</em>配置，但不会锁定<em>buildscript</em>的配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以禁用对特定配置的锁定。如果某个插件配置为锁定所有配置，但是您碰巧添加了一个不应锁定的插件，则此功能很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例60解锁特定配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    compileClasspath {
        resolutionStrategy.deactivateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.compileClasspath {
    resolutionStrategy.deactivateDependencyLocking()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking_buildscript_classpath_configuration"><a class="anchor" href="#locking_buildscript_classpath_configuration"></a> <a class="link" href="#locking_buildscript_classpath_configuration">锁定buildscript类路径配置</a></h3>
<div class="paragraph">
<p>如果您将插件应用于构建，则可能还希望利用那里的依赖项锁定。为了锁定<a href="plugins.html#sec:applying_plugins_buildscript"><code>classpath</code></a>用于脚本插件的<a href="plugins.html#sec:applying_plugins_buildscript">配置</a> ，请执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">例子61。锁定buildscript类路径配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">buildscript {
    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generating_and_updating_dependency_locks"><a class="anchor" href="#generating_and_updating_dependency_locks"></a> <a class="link" href="#generating_and_updating_dependency_locks">生成和更新依赖关系锁</a></h3>
<div class="paragraph">
<p>为了生成或更新锁定状态，您可以指定<code>--write-locks</code>命令行参数以及将触发要解析的配置的常规任务。这将导致在该构建执行中为每个已解析的配置创建锁定状态。请注意，如果先前存在锁定状态，则将其覆盖。</p>
</div>
<div class="sect3">
<h4 id="lock_all_configurations_in_one_build_execution"><a class="anchor" href="#lock_all_configurations_in_one_build_execution"></a> <a class="link" href="#lock_all_configurations_in_one_build_execution">将所有配置锁定在一个构建执行中</a></h4>
<div class="paragraph">
<p>锁定多个配置时，您可能希望在一次构建执行中一次锁定所有配置。</p>
</div>
<div class="paragraph">
<p>为此，您有两个选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跑<code>gradle dependencies --write-locks</code> 。这将有效地锁定所有启用了锁定的可解析配置。请注意，在多项目设置中， <code>dependencies</code>仅在<em>一个</em>项目上执行，在这种情况下是根项目。</p>
</li>
<li>
<p>声明将解决所有配置的自定义任务</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">例子62。解决所有配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">task resolveAndLockAll {
    doFirst {
        assert gradle.startParameter.writeDependencyLocks
    }
    doLast {
        configurations.findAll {
            // Add any custom filtering on the configurations to be resolved
            it.canBeResolved
        }.each { it.resolve() }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">tasks.register("resolveAndLockAll") {
    doFirst {
        require(gradle.startParameter.isWriteDependencyLocks)
    }
    doLast {
        configurations.filter {
            // Add any custom filtering on the configurations to be resolved
            it.isCanBeResolved
        }.forEach { it.resolve() }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第二种选择是，通过正确选择配置，可以成为本机环境中的唯一选择，在这种情况下，并非所有配置都可以在单个平台上解决。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lock_state_location_and_format"><a class="anchor" href="#lock_state_location_and_format"></a> <a class="link" href="#lock_state_location_and_format">锁定状态的位置和格式</a></h3>
<div class="paragraph">
<p>锁定状态将保留在该文件夹中的文件中<code>gradle/dependency-locks</code>在项目或子项目目录中。每个文件均由其锁定的配置命名，并具有<code>lockfile</code>延期。该规则的一个例外是构建<a href="plugins.html#sec:applying_plugins_buildscript">脚本本身的</a>配置。在这种情况下，配置名称将带有前缀<code>buildscript-</code> 。</p>
</div>
<div class="paragraph">
<p>文件的内容是每行的模块表示法，标题提供了一些上下文。模块符号按字母顺序排序，以简化差异。</p>
</div>
<div class="listingblock">
<div class="title">gradle / dependency-locks / compileClasspath.lockfile</div>
<div class="content">
<pre># This is a Gradle generated file for dependency locking.
# Manual edits can break the build and are not advised.
# This file is expected to be part of source control.
org.springframework:spring-beans:5.0.5.RELEASE
org.springframework:spring-core:5.0.5.RELEASE
org.springframework:spring-jcl:5.0.5.RELEASE</pre>
</div>
</div>
<div class="paragraph">
<p>匹配以下依赖项声明：</p>
</div>
<div class="exampleblock">
<div class="title">示例63。动态依赖声明</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'org.springframework:spring-beans:[5.0,6.0)'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.springframework:spring-beans:[5.0,6.0)")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running_a_build_with_lock_state_present"><a class="anchor" href="#running_a_build_with_lock_state_present"></a> <a class="link" href="#running_a_build_with_lock_state_present">在存在锁定状态的情况下运行构建</a></h3>
<div class="paragraph">
<p>当构建需要解析启用了锁定的配置并找到匹配的锁定状态时，它将使用它来验证给定的配置仍解析相同的版本。</p>
</div>
<div class="paragraph">
<p>成功的构建表示使用了与锁定状态中存储的依赖项相同的依赖项，无论是否已生成与动态选择器匹配的新版本。</p>
</div>
<div class="paragraph">
<p>完整的验证如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处于锁定状态的现有条目必须在构建中匹配</p>
<div class="ulist">
<ul>
<li>
<p>版本不匹配或缺少已解决的模块会导致构建失败</p>
</li>
</ul>
</div>
</li>
<li>
<p>与锁定状态相比，解析结果不得包含其他依赖项</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="selectively_updating_lock_state_entries"><a class="anchor" href="#selectively_updating_lock_state_entries"></a> <a class="link" href="#selectively_updating_lock_state_entries">有选择地更新锁定状态条目</a></h3>
<div class="paragraph">
<p>为了仅更新配置的特定模块，您可以使用<code>--update-locks</code>命令行标志。需要逗号（ <code>,</code> ）分隔的模块符号列表。在这种模式下，现有的锁定状态仍用作解决方案的输入，从而过滤出更新目标模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ gradle classes --update-locks org.apache.commons:commons-lang3,org.slf4j:slf4j-api</pre>
</div>
</div>
<div class="paragraph">
<p>通配符，用表示<code>*</code> ，可以在组或模块名称中使用。它们可以是唯一字符，也可以分别出现在组或模块的末尾。以下通配符表示法示例有效：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.apache.commons:*</code> ：将让所有模块属于组<code>org.apache.commons</code>更新</p>
</li>
<li>
<p><code>*:guava</code> ：将所有模块命名<code>guava</code> ，无论他们的团队是什么，</p>
</li>
<li>
<p><code>org.springframework.spring*:spring*</code> ：将让所有模块所属的组以<code>org.springframework.spring</code>和名称以<code>spring</code>更新</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>分辨率可能会导致其他模块版本更新，这取决于Gradle分辨率规则。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="disabling_dependency_locking"><a class="anchor" href="#disabling_dependency_locking"></a> <a class="link" href="#disabling_dependency_locking">禁用依赖项锁定</a></h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>确保不再需要锁定的配置未配置锁定。</p>
</li>
<li>
<p>删除与不再需要锁定的配置相匹配的文件。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果仅执行上面的第二步，则锁定将不再有效。但是，如果将来在持久保留锁定状态时解决该配置，它将再次被锁定。</p>
</div>
</div>
<div class="sect2">
<h3 id="locking_limitations"><a class="anchor" href="#locking_limitations"></a> <a class="link" href="#locking_limitations">锁定限制</a></h3>
<div class="ulist">
<ul>
<li>
<p>锁定尚不能应用于源依赖项。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="nebula_locking_plugin"><a class="anchor" href="#nebula_locking_plugin"></a> <a class="link" href="#nebula_locking_plugin">星云锁定插件</a></h3>
<div class="paragraph">
<p>此功能受<a href="https://github.com/nebula-plugins/gradle-dependency-lock-plugin">Nebula Gradle依赖项锁定插件的</a>启发。</p>
</div>
</div>
</div>
</div>
<h1 id="controlling_transitive_dependencies" class="sect0"><a class="anchor" href="#controlling_transitive_dependencies"></a> <a class="link" href="#controlling_transitive_dependencies">控制传递依存关系</a></h1>
<div class="sect1">
<h2 id="dependency-constraints"><a class="anchor" href="#dependency-constraints"></a> <a class="link" href="#dependency-constraints">升级传递依赖的版本</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sec:direct-vs-transitive-deps"><a class="anchor" href="#sec:direct-vs-transitive-deps"></a> <a class="link" href="#sec:direct-vs-transitive-deps">直接依赖与依赖约束</a></h3>
<div class="paragraph">
<p>组件可能具有两种不同的依赖关系：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>直接依赖关系是<em>组件直接需要的</em> 。直接依赖关系也称为<em>第一级依赖关系</em> 。例如，如果您的项目源代码需要Guava，则应将Guava声明为<em>直接依赖项</em> 。</p>
</li>
<li>
<p>传递依赖关系是组件所需的依赖关系，但这仅是因为另一个依赖关系需要它们。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>依赖管理的问题与<em>传递依赖</em>有关是很常见的。开发人员经常通过添加<em>直接依赖项来</em>错误地解决传递依赖项问题。为了避免这种情况，Gradle提供了<em>依赖约束</em>的概念。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:adding-constraints-transitive-deps"><a class="anchor" href="#sec:adding-constraints-transitive-deps"></a> <a class="link" href="#sec:adding-constraints-transitive-deps">在传递依赖项上添加约束</a></h3>
<div class="paragraph">
<p>依赖关系约束允许您定义在构建脚本中声明的依赖关系和传递性依赖关系的版本或版本范围。表达约束的首选方法是应将约束应用于配置的所有依赖项。当Gradle尝试将对模块版本的依赖项解析时，将考虑该版本的所有<a href="#">依赖项声明</a> ，所有可传递依赖项和所有依赖项约束。选择符合所有条件的最高版本。如果找不到这样的版本，Gradle将失败，并显示一条错误的声明。如果发生这种情况，您可以调整依赖项或依赖项约束声明，或者根据需要对传递性依赖项进行其他调整。与依赖项声明类似，依赖项约束声明<a href="#sec:what-are-dependency-configurations">受配置范围限制，</a>因此可以为构建的某些部分选择性地定义。如果依赖性约束影响了解析结果，则以后仍然可以应用任何类型的<a href="#sec:dependency_resolve_rules">依赖性解析规则</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例64。定义依赖关系约束</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'org.apache.httpcomponents:httpclient'
    constraints {
        implementation('org.apache.httpcomponents:httpclient:4.5.3') {
            because 'previous versions have a bug impacting this application'
        }
        implementation('commons-codec:commons-codec:1.11') {
            because 'version 1.9 pulled from httpclient has bugs affecting this application'
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.apache.httpcomponents:httpclient")
    constraints {
        implementation("org.apache.httpcomponents:httpclient:4.5.3") {
            because("previous versions have a bug impacting this application")
        }
        implementation("commons-codec:commons-codec:1.11") {
            because("version 1.9 pulled from httpclient has bugs affecting this application")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在该示例中，所有版本都从依赖声明中省略。而是在约束块中定义版本。的版本定义<code>commons-codec:1.11</code>仅在以下情况下考虑<code>commons-codec</code>被引入为传递依赖，因为<code>commons-codec</code>在项目中未定义为依赖项。否则，约束无效。依赖关系约束还可以定义<a href="#">丰富的版本约束，</a>并支持<a href="#sec:strict-version">严格的版本</a>以强制版本，即使它与传递依赖关系定义的版本相矛盾（例如，如果版本需要降级）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>依赖关系约束仅在使用<a href="#sec:understanding-gradle-module-md">Gradle Module元数据</a>时发布。这意味着当前仅在使用Gradle进行发布和使用时才完全支持它们（即，在使用Maven或Ivy使用模块时它们会“丢失”）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>依赖性约束本身也可以传递地添加。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="downgrading_versions_and_excluding_dependencies"><a class="anchor" href="#downgrading_versions_and_excluding_dependencies"></a> <a class="link" href="#downgrading_versions_and_excluding_dependencies">降级版本并排除依赖项</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sec:enforcing_dependency_version"><a class="anchor" href="#sec:enforcing_dependency_version"></a> <a class="link" href="#sec:enforcing_dependency_version">覆盖传递依赖项版本</a></h3>
<div class="paragraph">
<p>Gradle通过选择在依赖关系图中找到的最新版本来解决任何依赖关系版本冲突。某些项目可能需要偏离默认行为，并强制实施较早版本的依赖项，例如，如果项目的源代码依赖于某些外部库中较旧的依赖项API，则此项目是必需的。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>强制版本的依赖项需要有意识的决定。如果外部库没有它们而无法正常运行，则更改可传递依赖项的版本可能会导致运行时错误。考虑将源代码升级为使用库的较新版本作为替代方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，执行强制依赖关系可以降级依赖关系。降级可能会有不同的用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在最新版本中发现了一个错误</p>
</li>
<li>
<p>您的代码取决于与二进制不兼容的较低版本</p>
</li>
<li>
<p>您的代码不依赖于需要更高版本的依赖项的代码路径</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在所有情况下，最好的表述是您的代码<em>严格依赖于</em>可传递代码的版本。使用<a href="#sec:strict-version">严格版本</a> ，即使传递依赖项另有说明，您也将有效地依赖声明的版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>严格的依赖关系在某种程度上类似于Maven <em>最接近的优先</em>策略，但存在细微的差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>严格的依赖</em>关系不会遇到排序问题：它们可传递地应用于子图，并且声明顺序依赖关系也无关紧要。</p>
</li>
<li>
<p>严格的依赖项冲突将触发您必须解决的构建失败</p>
</li>
<li>
<p>严格的依赖项可以与丰富的版本一起使用，这意味着<a href="#sec:strict-version-consequences">最好在<em>严格范围内</em>结合单个<em>首选版本</em>来表达需求</a> 。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>假设一个项目使用<a href="https://hc.apache.org/httpcomponents-client-ga/">HttpClient库</a>执行HTTP调用。HttpClient从1.10版引入<a href="https://commons.apache.org/proper/commons-codec/">Commons Codec</a>作为传递依赖项。但是，该项目的生产源代码需要Commons Codec 1.9中的API，该API在1.10中不再可用。可以通过在构建脚本中将其声明为严格来强制实施依赖项版本：</p>
</div>
<div class="exampleblock">
<div class="title">示例65。设定严格的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'org.apache.httpcomponents:httpclient:4.5.4'
    implementation('commons-codec:commons-codec') {
        version {
            strictly '1.9'
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.apache.httpcomponents:httpclient:4.5.4")
    implementation("commons-codec:commons-codec") {
        version {
            strictly("1.9")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:strict-version-consequences"><a class="anchor" href="#sec:strict-version-consequences"></a> <a class="link" href="#sec:strict-version-consequences">使用严格版本的后果</a></h4>
<div class="paragraph">
<p>必须仔细考虑使用严格的版本，尤其是图书馆作者。作为<em>生产者</em> ，严格的版本实际上将表现得像一种<em>力量</em> ：版本声明优先于在传递依赖关系图中找到的任何内容。特别是， <em>严格版本</em>将覆盖可传递地找到的同一模块上的任何其他<em>严格版本</em> 。</p>
</div>
<div class="paragraph">
<p>但是，对于使用者，在图形解析期间仍会严格考虑严格版本，如果使用者不同意，则<em>可能会触发错误</em> 。</p>
</div>
<div class="paragraph">
<p>例如，假设您的项目<code>B</code> <em>严格</em>取决于<code>C:1.0</code> 。现在，一个消费者， <code>A</code> ，取决于两者<code>B</code>和<code>C:1.1</code> 。</p>
</div>
<div class="paragraph">
<p>然后，这将触发解决方案错误，因为<code>A</code>说需要<code>C:1.1</code>但<code>B</code> <em>在其子图</em>中严格要求<code>1.0</code> 。这意味着，如果您在严格的约束条件下选择<em>单个版本</em> ，则该版本将<em>无法再升级</em> ，除非使用者也对同一模块设置了严格的约束条件。</p>
</div>
<div class="paragraph">
<p>在上面的示例中， <code>A</code>不得不说它<em>严格取决于1.1</em> 。</p>
</div>
<div class="paragraph">
<p>因此，一个好的做法是，如果使用<em>严格的版本</em> ，则应使用范围和该范围内的首选版本来表达它们。例如， <code>B</code>可能会说，而不是<code>strictly 1.0</code> ，这<em>完全取决于</em> <code>[1.0, 2.0[</code>范围，但<em>更喜欢</em> <code>1.0</code> 。然后，如果使用者选择1.1（或该范围内的任何其他版本），则构建将<em>不再失败</em> （约束已解决）。</p>
</div>
</div>
<div class="sect3">
<h4 id="forced_dependencies_vs_strict_dependencies"><a class="anchor" href="#forced_dependencies_vs_strict_dependencies"></a> <a class="link" href="#forced_dependencies_vs_strict_dependencies">强制依赖与严格依赖</a></h4>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>不建议使用<a href="../javadoc/org/gradle/api/artifacts/ExternalDependency.html#setForce-boolean-">ExternalDependency.setForce（boolean）</a>强制依赖，并且不再建议使用：强制依赖存在一个排序问题，该问题可能很难诊断，并且无法与其他丰富版本约束一起很好地工作。您应该选择<a href="#sec:enforcing_dependency_version">严格的版本</a> 。如果要编写和发布<a href="#">库</a> ，还需要注意以下几点： <code>force</code> <strong>未</strong>发布。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果由于某种原因不能使用<a href="#sec:enforcing_dependency_version">严格版本</a> ，则可以强制依赖项执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">例子66。实施依赖版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation 'org.apache.httpcomponents:httpclient:4.5.4'
    implementation('commons-codec:commons-codec:1.9') {
        force = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.apache.httpcomponents:httpclient:4.5.4")
    implementation("commons-codec:commons-codec:1.9") {
        isForce = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果项目要求在配置级别上具有特定版本的依赖关系，则可以通过调用方法<a href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:force(java.lang.Object[])">ResolutionStrategy.force（java.lang。Object []）</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子67。在配置级别上强制依赖项版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    compileClasspath {
        resolutionStrategy.force 'commons-codec:commons-codec:1.9'
    }
}

dependencies {
    implementation 'org.apache.httpcomponents:httpclient:4.5.4'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    "compileClasspath" {
        resolutionStrategy.force("commons-codec:commons-codec:1.9")
    }
}

dependencies {
    implementation("org.apache.httpcomponents:httpclient:4.5.4")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:excluding-transitive-deps"><a class="anchor" href="#sec:excluding-transitive-deps"></a> <a class="link" href="#sec:excluding-transitive-deps">排除传递依赖</a></h3>
<div class="paragraph">
<p>虽然上一节显示了如何强制实施某个版本的可传递依赖项，但本节<em>将排除</em>作为完全删除可传递依赖项的一种方式。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>与强制依赖版本相似，完全排除依赖需要有意识的决定。如果外部库没有它们而无法正常运行，则排除传递依赖关系可能会导致运行时错误。如果您使用排除，请确保您没有通过足够的测试覆盖率来利用任何不需要排除依赖的代码路径。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在声明的依赖项级别上排除传递性依赖项。通过属性将排除作为键/值对阐明<code>group</code>和/或<code>module</code>如下例所示。有关更多信息，请参见<a href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html#exclude-java.util.Map-">ModuleDependency.exclude（java.util。地图）</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例68。排除特定依赖声明的传递依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation('commons-beanutils:commons-beanutils:1.9.4') {
        exclude group: 'commons-collections', module: 'commons-collections'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们向<code>commons-beanutils</code>但排除传递依赖<code>commons-collections</code> 。在下面显示的代码中，我们仅使用beanutils库中的一种方法， <code>PropertyUtils.setSimpleProperty()</code> 。对现有的设置员使用此方法不需要以下功能<code>commons-collections</code>我们通过测试覆盖率进行了验证。</p>
</div>
<div class="exampleblock">
<div class="title">示例69。使用beanutils库中的实用程序</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">src / main / java / Main.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import org.apache.commons.beanutils.PropertyUtils;

public class Main {
    public static void main(String[] args) throws Exception {
        Object person = new Person();
        PropertyUtils.setSimpleProperty(person, "name", "Bart Simpson");
        PropertyUtils.setSimpleProperty(person, "age", 38);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实际上，我们表示仅使用该库的一个<em>子集</em> ，而无需<code>commons-collection</code>图书馆。这可以看作是隐式定义了一个<a href="#">特征变体</a> ，该<a href="#">变体</a>尚未由<code>commons-beanutils</code>本身。但是，这样做会增加破坏未经测试的代码路径的风险。</p>
</div>
<div class="paragraph">
<p>例如，在这里我们使用<code>setSimpleProperty()</code>修改设置器中定义的属性的方法<code>Person</code>类，效果很好。如果我们将尝试设置属性不存在的类，我们<em>应该</em>得到这样的错误<code>Unknown property on class Person</code> 。但是，由于错误处理路径使用来自<code>commons-collections</code> ，我们现在得到的错误是<code>NoClassDefFoundError: org/apache/commons/collections/FastHashMap</code> 。因此，如果我们的代码更具动态性，而我们忘记了充分涵盖错误情况，则我们库的使用者可能会遇到意外错误。</p>
</div>
<div class="paragraph">
<p>这仅仅是说明潜在陷阱的一个示例。实际上，较大的库或框架会带来大量的依赖关系。如果这些库无法分别声明功能，并且只能以“全有或全无”的方式使用，则排除可能是将库缩减为实际所需功能集的有效方法。</p>
</div>
<div class="paragraph">
<p>从好的方面来说，与Maven相比，Gradle的排除处理考虑了整个依赖关系图。因此，如果库上有多个依赖项，则只有在所有依赖项都对它们都同意的情况下才执行排除。例如，如果我们添加<code>opencsv</code>作为我们上面项目的另一个依赖项，这也取决于<code>commons-beanutils</code> ， <code>commons-collection</code>不再排除为<code>opencsv</code>本身<strong>并不</strong>排除它。</p>
</div>
<div class="exampleblock">
<div class="title">示例70。仅当所有依赖项声明均同意排除项时，排除项才适用</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    dependencies {
        implementation('commons-beanutils:commons-beanutils:1.9.4') {
            exclude group: 'commons-collections', module: 'commons-collections'
        }
        implementation 'com.opencsv:opencsv:4.6' // depends on 'commons-beanutils' without exclude and brings back 'commons-collections'
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4") {
        exclude(group = "commons-collections", module = "commons-collections")
    }
    implementation("com.opencsv:opencsv:4.6") // depends on 'commons-beanutils' without exclude and brings back 'commons-collections'
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们仍然想拥有<code>commons-collections</code>排除在外，因为我们的综合使用<code>commons-beanutils</code>和<code>opencsv</code>不需要它，我们需要将其从<code>opencsv</code>也一样</p>
</div>
<div class="exampleblock">
<div class="title">例子71。为多个依赖项声明排除传递依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    dependencies {
        implementation('commons-beanutils:commons-beanutils:1.9.4') {
            exclude group: 'commons-collections', module: 'commons-collections'
        }
        implementation('com.opencsv:opencsv:4.6') {
            exclude group: 'commons-collections', module: 'commons-collections'
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">    dependencies {
        implementation("commons-beanutils:commons-beanutils:1.9.4") {
            exclude(group = "commons-collections", module = "commons-collections")
        }
        implementation("com.opencsv:opencsv:4.6") {
            exclude(group = "commons-collections", module = "commons-collections")
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从历史上看，排除项还用作解决某些依赖项管理系统不支持的其他问题的工具。但是，Gradle提供了可能更适合解决特定用例的各种功能。您可以考虑研究以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:enforcing_dependency_version">更新</a>或<a href="#sec:enforcing_dependency_version">降级</a>依赖性版本：如果依赖性版本冲突，通常最好通过依赖性约束来调整版本，而不是尝试用不需要的版本排除依赖性。</p>
</li>
<li>
<p><a href="#">组件元数据规则</a> ：如果库的元数据明显错误，例如，如果它包含一个编译时依赖项，而在编译时就不需要，则可能的解决方案是删除组件元数据规则中的依赖项。通过这种方式，你告诉摇篮，它永远不会需要两个模块之间的依赖关系-即元数据是错误的-因此<strong>不</strong>应该被考虑。如果要开发库，则必须注意该信息不会发布，因此有时<em>排除</em>是更好的选择。</p>
</li>
<li>
<p><a href="#">解决互斥的依赖冲突</a> ：您经常看到用exclude解决的另一种情况是，两个依赖不能一起使用，因为它们表示同一事物（相同<a href="#sub:capabilities">功能</a> ）的两个实现。一个流行的示例是冲突日志API的实现（例如<code>log4j</code>和<code>log4j-over-slf4j</code> ）或在不同版本中具有不同坐标的模块（例如<code>com.google.collections</code>和<code>guava</code> ）。在这种情况下，如果Gradle不知道此信息，则建议通过组件元数据规则添加缺失的能力信息，如<a href="#sub:declaring-component-capabilities">声明组件功能</a>部分中所述。即使您正在开发图书馆，而您的消费者也不得不再次解决冲突，将决定权交给图书馆的最终消费者通常是正确的解决方案。也就是说，作为图书馆作者，您最终不必决定消费者使用哪种日志记录实现。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:using-platform-to-control-transitive-deps"><a class="anchor" href="#sec:using-platform-to-control-transitive-deps"></a> <a class="link" href="#sec:using-platform-to-control-transitive-deps">在项目之间共享依赖版本</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sub:sharing-dep-versions-between-projects"><a class="anchor" href="#sub:sharing-dep-versions-between-projects"></a> <a class="link" href="#sub:sharing-dep-versions-between-projects">使用平台控制传递版本</a></h3>
<div class="paragraph">
<p><a href="#sub::terminology_platform">平台</a>是一种特殊的软件组件，可用于控制传递依赖项版本。在大多数情况下，它完全由<a href="#sec:adding-constraints-transitive-deps">依赖项约束</a>组成，这将<em>建议</em>依赖项版本或<em>强制执行</em>某些版本。因此，当您需要<em>在项目之间共享依赖版本</em>时，这是一个完美的工具。在这种情况下，通常以这种方式组织项目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>platform</code>该项目为在不同子项目中找到的各种依赖项定义了约束</p>
</li>
<li>
<p>多个子项目，这些子项目<em>依赖于</em>平台并声明<em>不带版本的</em>依赖项</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在Java生态系统中，Gradle为此提供了一个<a href="java_platform_plugin.html#java_platform_plugin">插件</a> 。</p>
</div>
<div class="paragraph">
<p>找到发布为<a href="#sub:bom_import">Gradle本地支持的</a> Maven BOM的平台也是很常见的。</p>
</div>
<div class="paragraph">
<p>使用<code>platform</code>关键词：</p>
</div>
<div class="exampleblock">
<div class="title">例子72。获取平台中声明的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // get recommended versions from the platform project
    api platform(project(':platform'))
    // no version required
    api 'commons-httpclient:commons-httpclient'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // get recommended versions from the platform project
    api(platform(project(":platform")))
    // no version required
    api("commons-httpclient:commons-httpclient")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>这个<code>platform</code>记号是一种简写的记号，实际上在幕后执行了一些操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它将<a href="../javadoc/org/gradle/api/attributes/Category.html">org.gradle.category属性设置</a>为<code>platform</code> ，这意味着Gradle将选择依赖项的<em>平台</em>组件。</p>
</li>
<li>
<p>它默认设置了<a href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html#endorseStrictVersions--">endorseStrictVersions</a>行为，这意味着如果平台声明了严格的依赖关系，则将强制执行它们。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着默认情况下，对平台的依赖关系会触发该平台中定义的所有<a href="#sec:strict-version">严格版本</a>的继承，这对于平台作者确保所有使用者在依赖关系的版本方面都遵循自己的决定很有用。可以通过显式调用<code>doNotEndorseStrictVersions</code>方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sub:bom_import"><a class="anchor" href="#sub:bom_import"></a> <a class="link" href="#sub:bom_import">导入Maven BOM</a></h3>
<div class="paragraph">
<p>Gradle为导入<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies">物料清单（BOM）文件</a>提供了支持，这些<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies">文件</a>有效<code>.pom</code>使用的文件<code><dependencyManagement></code>控制直接和传递依赖的依赖版本。Gradle中的BOM支持与使用类似<code><scope>import</scope></code>取决于Maven中的BOM。但是，在Gradle中，这是通过BOM上的常规依赖项声明完成的：</p>
</div>
<div class="exampleblock">
<div class="title">示例73。依靠BOM导入其依赖关系约束</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // import a BOM
    implementation platform('org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE')

    // define dependencies without versions
    implementation 'com.google.code.gson:gson'
    implementation 'dom4j:dom4j'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // import a BOM
    implementation(platform("org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE"))

    // define dependencies without versions
    implementation("com.google.code.gson:gson")
    implementation("dom4j:dom4j")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在示例中， <code>gson</code>和<code>dom4j</code>由Spring Boot BOM提供。这样，如果您正在开发像Spring Boot这样的平台，则不必自己声明任何版本，而可以依赖平台提供的版本。</p>
</div>
<div class="paragraph">
<p>Gradle会处理<code><dependencyManagement></code>类似于<a href="#sec:adding-constraints-transitive-deps">Gradle的依赖关系约束</a>的BOM表块。这意味着， <code><dependencyManagement></code>块可能会影响依赖性解析结果。为了符合BOM的要求， <code>.pom</code>文件需要有<code><packaging>pom</packaging></code>组。</p>
</div>
<div class="paragraph">
<p>但是，BOM常常不仅提供建议的版本，而且还提供一种方法来覆盖图中找到的任何其他版本。您可以使用<code>enforcedPlatform</code>关键字，而不是<code>platform</code> ，在导入BOM时：</p>
</div>
<div class="exampleblock">
<div class="title">示例74。导入物料清单，确保其定义的版本会覆盖找到的任何其他版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // import a BOM. The versions used in this file will override any other version found in the graph
    implementation enforcedPlatform('org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE')

    // define dependencies without versions
    implementation 'com.google.code.gson:gson'
    implementation 'dom4j:dom4j'

    // this version will be overridden by the one found in the BOM
    implementation 'org.codehaus.groovy:groovy:1.8.6'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // import a BOM. The versions used in this file will override any other version found in the graph
    implementation(enforcedPlatform("org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE"))

    // define dependencies without versions
    implementation("com.google.code.gson:gson")
    implementation("dom4j:dom4j")

    // this version will be overridden by the one found in the BOM
    implementation("org.codehaus.groovy:groovy:1.8.6")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="version_alignment"><a class="anchor" href="#version_alignment"></a> <a class="link" href="#version_alignment">对齐依赖版本</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>依赖关系版本对齐允许依赖于同一逻辑组（ <em>平台</em> ）的不同模块在依赖关系图中具有相同的版本。</p>
</div>
<div class="sect2">
<h3 id="handling_inconsistent_module_versions"><a class="anchor" href="#handling_inconsistent_module_versions"></a> <a class="link" href="#handling_inconsistent_module_versions">处理不一致的模块版本</a></h3>
<div class="paragraph">
<p>Gradle支持对齐属于同一“平台”的模块的版本。例如，通常最好是组件的API和实现模块使用相同的版本。但是，由于传递依赖解析的博弈，属于同一平台的不同模块最终可能使用不同的版本。例如，您的项目可能取决于<code>jackson-databind</code>和<code>vert.x</code>库，如下图所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子75。声明依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // a dependency on Jackson Databind
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.8.9'

    // and a dependency on vert.x
    implementation 'io.vertx:vertx-core:3.5.3'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // a dependency on Jackson Databind
    implementation("com.fasterxml.jackson.core:jackson-databind:2.8.9")

    // and a dependency on vert.x
    implementation("io.vertx:vertx-core:3.5.3")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为<code>vert.x</code>依赖于取决于<code>jackson-core</code> ，我们实际上将解决以下依赖项版本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jackson-core</code>版<code>2.9.5</code> （由<code>vertx-core</code> ）</p>
</li>
<li>
<p><code>jackson-databind</code>版<code>2.9.5</code> （通过冲突解决）</p>
</li>
<li>
<p><code>jackson-annotation</code>版<code>2.9.0</code> （依赖项<code>jackson-databind:2.9.5</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最终会出现一组不能很好地协同工作的版本，这很容易。为了解决这个问题，Gradle支持平台版本的概念支持的依赖版本对齐。平台代表了一组“一起工作”的模块。或者是因为它们实际上是作为一个整体发布的（当平台成员之一发布时，所有其他模块也都以相同的版本发布），或者是因为有人测试了模块并指出它们可以很好地协同工作（通常是Spring）平台）。</p>
</div>
</div>
<div class="sect2">
<h3 id="aligning_versions_natively_with_gradle"><a class="anchor" href="#aligning_versions_natively_with_gradle"></a> <a class="link" href="#aligning_versions_natively_with_gradle">将本机版本与Gradle对齐</a></h3>
<div class="paragraph">
<p>Gradle本机支持Gradle生产的模块的对齐。这是<a href="#sec:adding-constraints-transitive-deps">依赖关系约束</a>的可传递<a href="#sec:adding-constraints-transitive-deps">性</a>的直接结果。因此，如果您具有多项目构建，并且希望使用者获得所有模块的相同版本，那么Gradle提供了一种使用<a href="java_platform_plugin.html">Java Platform Plugin</a>进行此操作的简单方法。</p>
</div>
<div class="paragraph">
<p>例如，如果您的项目包含3个模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lib</code></p>
</li>
<li>
<p><code>utils</code></p>
</li>
<li>
<p><code>core</code> ， 取决于<code>lib</code>和<code>utils</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>并声明以下依赖项的使用者：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>core</code>版本1.0</p>
</li>
<li>
<p><code>lib</code>版本1.1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后默认情况下，分辨率会选择<code>core:1.0</code>和<code>lib:1.1</code> ，因为<code>lib</code>不依赖<code>core</code> 。我们可以通过在项目中添加一个新的模块<em>platform</em>来解决此问题，该模块将对项目的所有模块添加约束：</p>
</div>
<div class="exampleblock">
<div class="title">例子76。平台模块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java-platform'
}

dependencies {
    // The platform declares constraints on all components that
    // require alignment
    constraints {
        api(project(":core"))
        api(project(":lib"))
        api(project(":utils"))
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    `java-platform`
}

dependencies {
    // The platform declares constraints on all components that
    // require alignment
    constraints {
        api(project(":core"))
        api(project(":lib"))
        api(project(":utils"))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>完成此操作后，我们需要确保所有模块现在都<em>依赖于该平台</em> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子77。声明对平台的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // Each project has a dependency on the platform
    api(platform(project(":platform")))

    // And any additional dependency required
    implementation(project(":lib"))
    implementation(project(":utils"))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // Each project has a dependency on the platform
    api(platform(project(":platform")))

    // And any additional dependency required
    implementation(project(":lib"))
    implementation(project(":utils"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>平台对所有组件都包含约束很重要，而且每个组件都对平台具有依赖关系很重要。这样，每当摇篮将增加一个依赖关系图上的平台的模块，它<em>还将</em>包括对平台的其他模块的约束。这意味着，如果看到属于同一平台的另一个模块，我们将自动升级到相同版本。</p>
</div>
<div class="paragraph">
<p>在我们的示例中，这意味着我们首先看到<code>core:1.0</code> ，这带来了一个平台<code>1.0</code>受到限制<code>lib:1.0</code>和<code>lib:1.0</code> 。然后我们添加<code>lib:1.1</code>依赖于<code>platform:1.1</code> 。通过冲突解决，我们选择<code>1.1</code>平台，对<code>core:1.1</code> 。然后我们之间解决冲突<code>core:1.0</code>和<code>core:1.1</code> ， 意思就是<code>core</code>和<code>lib</code>现在已正确对齐。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">仅当您使用Gradle Module元数据时，才对发布的组件强制执行此行为。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sec:align-versions-virtual"><a class="anchor" href="#sec:align-versions-virtual"></a> <a class="link" href="#sec:align-versions-virtual">对齐未随Gradle发布的模块版本</a></h3>
<div class="paragraph">
<p>每当发布者不使用Gradle时（例如在我们的Jackson例子中），我们都可以向Gradle解释说，所有Jackson模块都“属于”同一平台，并从与本机对齐方式相同的行为中受益：</p>
</div>
<div class="exampleblock">
<div class="title">示例78。依赖版本对齐规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class JacksonAlignmentRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext ctx) {
        ctx.details.with {
            if (id.group.startsWith("com.fasterxml.jackson")) {
                // declare that Jackson modules all belong to the Jackson virtual platform
                belongsTo("com.fasterxml.jackson:jackson-platform:${id.version}")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class JacksonAlignmentRule: ComponentMetadataRule {
    override fun execute(ctx: ComponentMetadataContext) {
        ctx.details.run {
            if (id.group.startsWith("com.fasterxml.jackson")) {
                // declare that Jackson modules all belong to the Jackson virtual platform
                belongsTo("com.fasterxml.jackson:jackson-platform:${id.version}")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过使用<code>belongsTo</code>关键字，我们声明所有模块都属于同一个<em>虚拟平台</em> ，该引擎由引擎特别对待，特别是在对齐方面。我们可以通过注册使用刚刚创建的规则：</p>
</div>
<div class="exampleblock">
<div class="title">示例79。利用依赖版本对齐规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    components.all(JacksonAlignmentRule)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    components.all(JacksonAlignmentRule::class.java)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，上面示例中的所有版本将与<code>2.9.5</code> 。但是，Gradle将允许您通过在Jackson平台上指定依赖项来覆盖该选择：</p>
</div>
<div class="exampleblock">
<div class="title">示例80。平台强制降级</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // Forcefully downgrade the Jackson platform to 2.8.9
    implementation enforcedPlatform('com.fasterxml.jackson:jackson-platform:2.8.9')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // Forcefully downgrade the Jackson platform to 2.8.9
    implementation(enforcedPlatform("com.fasterxml.jackson:jackson-platform:2.8.9"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:virtual_platform"><a class="anchor" href="#sec:virtual_platform"></a> <a class="link" href="#sec:virtual_platform">虚拟平台与已发布平台</a></h3>
<div class="paragraph">
<p>由组件元数据规则定义的平台， <code>belongsTo</code>目标模块未在存储库上发布称为虚拟平台。引擎特别考虑了虚拟平台，它像已发布的模块一样参与依赖关系解析，但是会触发依赖关系版本对齐。另一方面，我们可以找到在公共资源库上发布的“真实”平台。典型示例包括BOM，例如Spring BOM。它们的不同之处在于，已发布的平台可能引用的模块实际上是不同的模块。例如，Spring BOM声明了对Spring以及Apache Groovy的依赖。显然，这些东西的版本不同，因此在这种情况下对齐是没有意义的。换句话说，如果<em>发布</em>了平台，则Gradle会信任其元数据，并且不会尝试对齐该平台的依赖版本。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:handling-mutually-exclusive-deps"><a class="anchor" href="#sec:handling-mutually-exclusive-deps"></a> <a class="link" href="#sec:handling-mutually-exclusive-deps">处理互斥依赖性</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sub:capabilities"><a class="anchor" href="#sub:capabilities"></a> <a class="link" href="#sub:capabilities">组件功能介绍</a></h3>
<div class="paragraph">
<p>依赖图通常会偶然包含同一API的多个实现。这在日志记录框架中尤其常见，在日志记录框架中有多个绑定可用，并且当另一个传递依赖项选择另一个时，一个库选择一个绑定。由于这些实现位于不同的GAV坐标下，因此构建工具通常无法找出这些库之间是否存在冲突。为了解决这个问题，Gradle提供了<em>功能</em>的概念。</p>
</div>
<div class="paragraph">
<p>在单个依赖关系图中找到两个提供相同<em>功能的</em>组件是非法的。直观地讲，这意味着如果Gradle在类路径上找到两个提供相同内容的组件，它将失败并显示一条错误消息，指出哪些模块发生冲突。在我们的示例中，这意味着日志记录框架的不同绑定提供了相同的功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="capability_coordinates"><a class="anchor" href="#capability_coordinates"></a> <a class="link" href="#capability_coordinates">能力座标</a></h3>
<div class="paragraph">
<p><em>能力</em>由<code>(group, module, version)</code>三胞胎。每个组件都定义一个与其GAV坐标（组，工件，版本）相对应的隐式功能。例如， <code>org.apache.commons:commons-lang3:3.8</code>模块具有组的隐式功能<code>org.apache.commons</code> ， 名称<code>commons-lang3</code>和版本<code>3.8</code> 。重要的是要认识到功能是<em>版本化的</em> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:declaring-component-capabilities"><a class="anchor" href="#sub:declaring-component-capabilities"></a> <a class="link" href="#sub:declaring-component-capabilities">声明组件功能</a></h3>
<div class="paragraph">
<p>默认情况下，如果依赖关系图中的两个组件提供相同的功能，则Gradle将失败。因为当前发布的大多数模块都没有Gradle模块元数据，所以Gradle并不总是自动发现功能。但是，使用<em>规则</em>声明组件功能以便在构建而不是运行时尽快发现冲突很有趣。</p>
</div>
<div class="paragraph">
<p>一个典型的例子是在新版本中，只要将组件重新放置在不同的坐标上。例如，ASM库位于<code>asm:asm</code>协调直到版本<code>3.3.1</code> ，然后更改为<code>org.ow2.asm:asm</code>以来<code>4.0</code> 。在类路径上同时具有ASM⇐3.3.1和4.0+是非法的，因为它们提供相同的功能，只是组件已被重定位。由于每个组件都具有与其GAV坐标相对应的隐式功能，因此我们可以通过制定一条规则来声明“ <code>asm:asm</code>模块提供<code>org.ow2.asm:asm</code>能力：</p>
</div>
<div class="exampleblock">
<div class="title">例子81。通过能力解决冲突</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
class AsmCapability implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        context.details.with {
            if (id.group == "asm" &amp;&amp; id.name == "asm") {
                allVariants {
                    it.withCapabilities {
                        // Declare that ASM provides the org.ow2.asm:asm capability, but with an older version
                        it.addCapability("org.ow2.asm", "asm", id.version)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">class AsmCapability : ComponentMetadataRule {
    override
    fun execute(context: ComponentMetadataContext) = context.details.run {
        if (id.group == "asm" &amp;&amp; id.name == "asm") {
            allVariants {
                withCapabilities {
                    // Declare that ASM provides the org.ow2.asm:asm capability, but with an older version
                    addCapability("org.ow2.asm", "asm", id.version)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，只要在同一依赖图中找到两个组件，构建就将<em>失败</em> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>在这个阶段，Gradle <em>只会</em>使更多构建失败。它<strong>不会</strong>自动为您解决问题，但是可以帮助您意识到自己有问题。建议在<em>插件中</em>编写此类规则，然后将其应用于您的构建。然后，用户<em>必须尽可能</em>表达自己的喜好，或者解决类路径上不兼容内容的问题，如下节所述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sub:selecting-between-candidates"><a class="anchor" href="#sub:selecting-between-candidates"></a> <a class="link" href="#sub:selecting-between-candidates">在候选人之间进行选择</a></h3>
<div class="paragraph">
<p>在某个时候，依赖图将包含<em>不兼容的模块</em>或<em>互斥的</em>模块。例如，您可能有不同的记录器实现，并且需要选择一种绑定。
<a href="#sub:capabilities">功能可以</a>帮助您<em>意识到</em>您有冲突，但是Gradle还提供了表达如何解决冲突的工具。</p>
</div>
<div class="sect3">
<h4 id="sub:selecting-preferred-capability-provider"><a class="anchor" href="#sub:selecting-preferred-capability-provider"></a> <a class="link" href="#sub:selecting-preferred-capability-provider">在不同能力的候选人之间进行选择</a></h4>
<div class="paragraph">
<p>在上面的重定位示例中，Gradle能够告诉您在类路径上有两个版本的同一API：一个“旧”模块和一个“重定位”模块。现在，我们可以通过自动选择功能最高的组件来解决冲突：</p>
</div>
<div class="exampleblock">
<div class="title">示例82。通过功能版本控制解决冲突</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.capabilitiesResolution.withCapability('org.ow2.asm:asm') {
        selectHighestVersion()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.capabilitiesResolution.withCapability("org.ow2.asm:asm") {
        selectHighestVersion()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，通过选择最高性能的版本冲突解决方法进行修复并不总是适合的。例如，对于日志记录框架，我们使用什么版本的日志记录框架都没有关系，我们应该始终选择Slf4j。</p>
</div>
<div class="paragraph">
<p>在这种情况下，我们可以通过明确选择slf4j作为赢家来解决此问题：</p>
</div>
<div class="exampleblock">
<div class="title">示例83。用slf4j替换log4j</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    configurations.all {
        resolutionStrategy.capabilitiesResolution.withCapability("log4j:log4j") {
            select(candidates.find { it.id instanceof ModuleComponentIdentifier &amp;&amp; it.id.module == 'log4j-over-slf4j' } )
            because 'use slf4j in place of log4j'
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">    configurations.all {
        resolutionStrategy.capabilitiesResolution.withCapability("log4j:log4j") {
            select(candidates.first { it.id.let { id -&gt; id is ModuleComponentIdentifier &amp;&amp; id.module == "log4j-over-slf4j" } } )
            because("use slf4j in place of log4j")
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，如果您在类路径上具有多个<em>Slf4j绑定</em> ，则此方法也很好用：绑定<em>本质</em>上是不同的记录器实现，并且只需要一个。但是，所选的实现可能取决于要解决的配置。例如，对于测试， <code>slf4j-simple</code>可能就够了，但对于生产来说， <code>slf4-over-log4j</code>可能更好。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请查看<a href="../javadoc/org/gradle/api/artifacts/ResolutionStrategy.html#capabilitiesResolution">功能解析API</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:component_metadata_rules"><a class="anchor" href="#sec:component_metadata_rules"></a> <a class="link" href="#sec:component_metadata_rules">使用组件元数据规则修复元数据</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>从存储库中拉出的每个模块都具有与其关联的元数据，例如其组，名称，版本以及它提供的带有工件和依赖项的不同变体。有时，此元数据不完整或不正确。为了从构建脚本中处理这种不完整的元数据，Gradle提供了一个API来编写<em>组件元数据规则</em> 。这些规则在下载模块的元数据之后但在依赖关系解析中使用之前生效。</p>
</div>
<div class="sect2">
<h3 id="basics_of_writing_a_component_metadata_rule"><a class="anchor" href="#basics_of_writing_a_component_metadata_rule"></a> <a class="link" href="#basics_of_writing_a_component_metadata_rule">编写组件元数据规则的基础</a></h3>
<div class="paragraph">
<p>组件元数据规则应用于构建脚本的依赖关系块（ <a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html">DependencyHandler</a> ）的组件（ <a href="../dsl/org.gradle.api.artifacts.dsl.ComponentMetadataHandler.html">ComponentMetadataHandler</a> ）部分中。可以用两种不同的方式定义规则：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>直接在<em>组件</em>部分中应用它们时作为操作</p>
</li>
<li>
<p>作为实现<a href="../dsl/org.gradle.api.artifacts.dsl.ComponentMetadataRule.html">ComponentMetadataRule</a>接口的隔离类</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>虽然将规则内联定义为动作可以方便实验，但通常建议将规则定义为单独的类。编写为隔离类的规则可以用注释<code>@CacheableRule</code>缓存其应用程序的结果，以便无需在每次解决依赖项时重新执行它们。</p>
</div>
<div class="exampleblock">
<div class="title">示例84。可配置组件元数据规则的示例</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TargetJvmVersionRule implements ComponentMetadataRule {
    final Integer jvmVersion
    @Inject TargetJvmVersionRule(Integer jvmVersion) {
        this.jvmVersion = jvmVersion
    }

    @Inject ObjectFactory getObjects() { }

    void execute(ComponentMetadataContext context) {
        context.details.withVariant("compile") {
            attributes {
                attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, jvmVersion)
                attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_API))
            }
        }
    }
}
dependencies {
    components {
        withModule("commons-io:commons-io", TargetJvmVersionRule) {
            params(7)
        }
        withModule("commons-collections:commons-collections", TargetJvmVersionRule) {
            params(8)
        }
    }
    implementation("commons-io:commons-io:2.6")
    implementation("commons-collections:commons-collections:3.2.2")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class TargetJvmVersionRule @Inject constructor(val jvmVersion: Int) : ComponentMetadataRule {
    @Inject open fun getObjects(): ObjectFactory = throw UnsupportedOperationException()

    override fun execute(context: ComponentMetadataContext) {
        context.details.withVariant("compile") {
            attributes {
                attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, jvmVersion)
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_API))
            }
        }
    }
}
dependencies {
    components {
        withModule&lt;TargetJvmVersionRule&gt;("commons-io:commons-io") {
            params(7)
        }
        withModule&lt;TargetJvmVersionRule&gt;("commons-collections:commons-collections") {
            params(8)
        }
    }
    implementation("commons-io:commons-io:2.6")
    implementation("commons-collections:commons-collections:3.2.2")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从上面的示例可以看出，组件元数据规则是通过实现<a href="../javadoc/org/gradle/api/artifacts/ComponentMetadataRule.html">ComponentMetadataRule</a>来定义的，该<a href="../javadoc/org/gradle/api/artifacts/ComponentMetadataRule.html">组件</a>具有单个<code>execute</code>接收<a href="../javadoc/org/gradle/api/artifacts/ComponentMetadataContext.html">ComponentMetadataContext</a>实例作为参数的方法。在此示例中，还通过<a href="../javadoc/org/gradle/api/ActionConfiguration.html">ActionConfiguration</a>进一步配置了规则。通过在您的实现中使用构造函数来支持<code>ComponentMetadataRule</code>接受已配置的参数和需要注入的服务。</p>
</div>
<div class="paragraph">
<p>Gradle强制隔离实例<code>ComponentMetadataRule</code> 。这意味着所有参数必须为<code>Serializable</code>或可以隔离的已知Gradle类型。</p>
</div>
<div class="paragraph">
<p>此外，可以将Gradle服务注入您的<code>ComponentMetadataRule</code> 。因此，一旦有了构造函数，就必须对其进行注释<code>@javax.inject.Inject</code> 。通常需要使用<a href="../javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a>服务来创建强类型值对象的实例，例如用于设置<a href="../javadoc/org/gradle/api/attributes/Attribute.html">Attribute</a>的值。<a href="../javadoc/org/gradle/api/artifacts/repositories/RepositoryResourceAccessor.html">RepositoryResourceAccessor</a>是一项有助于使用自定义元数据对组件元数据规则进行高级使用的服务。</p>
</div>
<div class="paragraph">
<p>组件元数据规则可以应用于所有模块- <code>all(rule)</code> -或所选模块- <code>withModule(groupAndName, rule)</code> 。通常，专门编写规则以丰富一个特定模块的元数据，因此<code>withModule</code> API应该是首选。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:component_metadata_rules_details"><a class="anchor" href="#sec:component_metadata_rules_details"></a> <a class="link" href="#sec:component_metadata_rules_details">元数据的哪些部分可以修改？</a></h3>
<div class="paragraph">
<p>组件元数据规则API面向<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle Module元数据</a>和构建脚本中的<em>依赖项</em> API支持的功能。编写规则与在构建脚本中定义依赖关系和工件之间的主要区别在于，组件元数据规则遵循Gradle Module元数据的结构，直接对<a href="#understanding-variant-selection">变体</a>进行操作。相反，在构建脚本中，您经常会同时影响多个变量的形状（例如，将<em>api</em>依赖项添加到Java库的<em>api</em>和<em>运行时</em>变量中，由<em>jar</em>任务生成的工件也添加到了这两个变量中） 。</p>
</div>
<div class="paragraph">
<p>变体可以通过以下方法进行修改：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>allVariants</code> ：修改组件的所有变体</p>
</li>
<li>
<p><code>withVariant(name)</code> ：修改由名称标识的单个变体</p>
</li>
<li>
<p><code>addVariant(name)</code>要么<code>addVariant(name, base)</code> ： <em>从头开始</em>或通过<em>复制</em>现有变体（基础）的详细信息向组件添加新变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以调整每个变体的以下详细信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标识变体的<a href="#sec:abm_configuration_attributes">属性</a> - <code>attributes {}</code>块</p>
</li>
<li>
<p>该变体提供的<a href="#declaring-component-capabilities">功能</a> - <code>withCapabilities { }</code>块</p>
</li>
<li>
<p>变体的<a href="#">依赖</a>项，包括<a href="#">丰富的版本</a> - <code>withDependencies {}</code>块</p>
</li>
<li>
<p>变体的<a href="#sec:adding-constraints-transitive-deps">依赖关系约束</a> ，包括<a href="#">丰富版本</a> - <code>withDependencyConstraints {}</code>块</p>
</li>
<li>
<p>构成变体实际内容的已发布文件的位置- <code>withFiles { }</code>块</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>整个组件的一些属性也可以更改：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>组件级属性</em> ，当前唯一有意义的属性是<code>org.gradle.status</code></p>
</li>
<li>
<p>影响<em>方案</em>解释的<em>地位方案</em> <code>org.gradle.status</code>选择版本时的属性</p>
</li>
<li>
<p><a href="#sec:declaring-capabilities-external-modules">通过虚拟平台</a>进行<a href="#sec:declaring-capabilities-external-modules">版本对齐</a>的<em>belongsTo</em>属性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据模块元数据的格式，它以不同的方式映射到元数据的以变量为中心的表示形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果模块具有Gradle Module Metadata，则规则所基于的数据结构与您在模块的<code>.module</code>文件。</p>
</li>
<li>
<p>如果该模块仅发布于<code>.pom</code>元数据，派生出许多固定的变体，如<a href="#sub:maven-mapping-to-variants">POM文件到变体</a>的<a href="#sub:maven-mapping-to-variants">映射</a>部分中所述。</p>
</li>
<li>
<p>如果该模块仅发布了<code>ivy.xml</code>在文件中，可以访问文件中定义的<em>Ivy配置</em> ，而不是变体。它们的依赖性，依赖性约束和文件可以修改。此外， <code>addVariant(name, baseVariantOrConfiguration) { }</code>如果需要，可以使用API从<em>Ivy配置</em>派生变体（例如，可以使用此定义<a href="#sub:ivy-mapping-to-variants">Java库插件的<em>编译</em>和<em>运行时</em>变体</a> ）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="when_to_use_component_metadata_rules"><a class="anchor" href="#when_to_use_component_metadata_rules"></a> <a class="link" href="#when_to_use_component_metadata_rules">何时使用组件元数据规则？</a></h3>
<div class="paragraph">
<p>通常，如果您考虑使用组件元数据规则来调整某个模块的元数据，则应首先检查该模块是否与Gradle Module Metadata（Gradle Module Metadata）（ <code>.module</code>文件）或仅传统元数据（ <code>.pom</code>要么<code>ivy.xml</code> ）。</p>
</div>
<div class="paragraph">
<p>如果使用Gradle Module Metadata发布了模块，则尽管有时仍然存在某些明显错误的情况，但元数据可能已完成。对于这些模块，只有在明确确定元数据本身存在问题的情况下，才应使用组件元数据规则。如果您对依赖项解决结果有疑问，则应首先检查是否可以通过声明<a href="#">带有丰富版本的依赖项约束</a>来解决问题。特别是，如果您正在开发要发布的库，则应记住，与组件元数据规则相比，依赖关系约束是作为您自己的库的元数据的一部分发布的。因此，在具有依赖关系约束的情况下，您可以自动与使用者共享依赖关系解决方案的解决方案，而组件元数据规则仅应用于自己的内部版本。</p>
</div>
<div class="paragraph">
<p>如果模块是使用传统元数据发布的（ <code>.pom</code>要么<code>ivy.xml</code>只有，没有<code>.module</code>文件），因为这些格式不支持变体或依赖项约束等功能，因此元数据很可能不完整。仍然，从概念上讲，这样的模块可以包含不同的变体，或者可能具有它们被忽略（或错误地定义为依赖项）的依赖项约束。在接下来的部分中，我们将探讨许多现有的oss模块，这些模块具有不完整的元数据以及添加缺失的元数据信息的规则。</p>
</div>
<div class="paragraph">
<p>根据经验，您应该考虑所编写的规则是否也适用于构建环境。也就是说，如果将规则应用到任何其他使用受其影响的模块的构建中，该规则是否仍会产生正确且有用的结果？</p>
</div>
</div>
<div class="sect2">
<h3 id="fixing_wrong_dependency_details"><a class="anchor" href="#fixing_wrong_dependency_details"></a> <a class="link" href="#fixing_wrong_dependency_details">修复错误的依赖项详细信息</a></h3>
<div class="paragraph">
<p>让我们以<a href="https://repo1.maven.org/maven2/jaxen/jaxen">Maven</a> Central上Jaxen XPath Engine的发布为例。版本1.1.3的pom在编译范围内声明了许多依赖关系，这些依赖关系实际上并不是编译所必需的。这些已在1.1.4 pom中删除。假设由于某种原因需要使用1.1.3，我们可以使用以下规则来修复元数据：</p>
</div>
<div class="exampleblock">
<div class="title">示例85。删除未使用的Jaxen元数据依赖性的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class JaxenDependenciesRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        context.details.allVariants {
            withDependencies {
                removeAll { it.group in ["dom4j", "jdom", "xerces",  "maven-plugins", "xml-apis", "xom"] }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class JaxenDependenciesRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        context.details.allVariants {
            withDependencies {
                removeAll { it.group in listOf("dom4j", "jdom", "xerces",  "maven-plugins", "xml-apis", "xom") }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>内<code>withDependencies</code>阻止，您可以访问依赖项的完整列表，并且可以使用Java集合界面上可用的所有方法来检查和修改该列表。此外，还有<code>add(notation, configureAction)</code>接受通常表示法的方法类似于在构建脚本中<a href="#">声明依赖项</a> 。依赖关系约束可以通过以下方式检查和修改<code>withDependencyConstraints</code>块。</p>
</div>
<div class="paragraph">
<p>如果仔细研究Jaxen 1.1.4 pom，我们会发现<em>dom4j</em> ， <em>jdom</em>和<em>xerces</em>依赖项仍然存在，但标记为<em>optional</em> 。podle中的可选依赖项不会由Gradle或Maven自动处理。原因是它们指示Jaxen库提供了一些<a href="#">可选的功能变体</a> ，这些<a href="#">变体</a>需要这些依赖项中的一个或多个，但是缺少这些功能是什么以及哪个依赖项属于哪个的信息。此类信息无法在pom文件中表示，而是通过变体和<a href="#declaring-component-capabilities">功能</a>在Gradle模块元数据中表示。因此，我们也可以在规则中添加此信息。</p>
</div>
<div class="exampleblock">
<div class="title">示例86。将可选功能添加到Jaxen元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class JaxenCapabilitiesRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        context.details.addVariant("runtime-dom4j", "runtime") {
            withCapabilities {
                removeCapability("jaxen", "jaxen")
                addCapability("jaxen", "jaxen-dom4j", context.details.id.version)
            }
            withDependencies {
                add("dom4j:dom4j:1.6.1")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class JaxenCapabilitiesRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        context.details.addVariant("runtime-dom4j", "runtime") {
            withCapabilities {
                removeCapability("jaxen", "jaxen")
                addCapability("jaxen", "jaxen-dom4j", context.details.id.version)
            }
            withDependencies {
                add("dom4j:dom4j:1.6.1")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，我们首先使用<code>addVariant(name, baseVariant)</code>创建附加变量的方法，通过定义新功能<em>jaxen-dom4j</em>来表示Jaxen的可选dom4j集成功能，我们将其识别为<em>特征变量</em> 。这类似于在构建脚本中<a href="#sec::declare_feature_variants">定义可选功能变体</a> 。然后，我们使用<code>add</code>添加依赖项以定义此可选功能需要哪些依赖项的方法。</p>
</div>
<div class="paragraph">
<p>然后，在构建脚本中，我们可以将<a href="#sec::consuming_feature_variants">依赖</a>项添加<a href="#sec::consuming_feature_variants">到可选功能中</a> ，Gradle将使用丰富的元数据来发现正确的传递性依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">例子87。为Jaxen元数据应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    components {
        withModule("jaxen:jaxen", JaxenDependenciesRule)
        withModule("jaxen:jaxen", JaxenCapabilitiesRule)
    }
    implementation("jaxen:jaxen:1.1.3")
    runtimeOnly("jaxen:jaxen:1.1.3") {
        capabilities { requireCapability("jaxen:jaxen-dom4j") }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    components {
        withModule&lt;JaxenDependenciesRule&gt;("jaxen:jaxen")
        withModule&lt;JaxenCapabilitiesRule&gt;("jaxen:jaxen")
    }
    implementation("jaxen:jaxen:1.1.3")
    runtimeOnly("jaxen:jaxen:1.1.3") {
        capabilities { requireCapability("jaxen:jaxen-dom4j") }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="making_variants_published_as_classified_jars_explicit"><a class="anchor" href="#making_variants_published_as_classified_jars_explicit"></a> <a class="link" href="#making_variants_published_as_classified_jars_explicit">使发布为分类罐子的变体明确</a></h3>
<div class="paragraph">
<p>在上一个示例中，所有变体（“主要变体”和可选功能）都打包在一个jar文件中，但通常会将某些变体发布为单独的文件。尤其是，当变体互斥时-即它们<strong>不是</strong>功能变体，而是提供替代选择的不同变体。<strong>所有</strong>基于pom的库都已经存在的一个示例是<em>运行时</em>和<em>编译</em>变体，其中Gradle只能根据手头的任务选择一个。在Java生态系统中经常发现的此类替代方法中的另一个是针对不同Java版本的jar。</p>
</div>
<div class="paragraph">
<p>例如，我们看一下在<a href="https://repo1.maven.org/maven2/co/paralleluniverse/quasar-core/0.7.9">Maven</a> Central上发布的异步编程库Quasar的0.7.9版本。如果我们检查目录列表，我们会发现<code>quasar-core-0.7.9-jdk8.jar</code>除了出版<code>quasar-core-0.7.9.jar</code> 。在Maven存储库中，使用<em>分类器</em> （此处为<em>jdk8</em> ）发布其他jar是很常见的做法。尽管Maven和Gradle都允许您通过分类器引用此类jar，但它们在元数据中根本没有提及。因此，不存在这些罐子存在的信息，以及此类罐子所代表的变体之间是否存在其他差异（如不同的依赖项）。</p>
</div>
<div class="paragraph">
<p>在Gradle模块元数据中，将显示此变体信息，对于已经发布的Quasar库，我们可以使用以下规则添加它：</p>
</div>
<div class="exampleblock">
<div class="title">例子88。将Jdk 8变体添加到Quasar元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class QuasarRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        ["compile", "runtime"].each { base -&gt;
            context.details.addVariant("jdk8${base.capitalize()}", base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
                }
                withFiles {
                    removeAllFiles()
                    addFile("${context.details.id.name}-${context.details.id.version}-jdk8.jar")
                }
            }
            context.details.withVariant(base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 7)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class QuasarRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        listOf("compile", "runtime").forEach { base -&gt;
            context.details.addVariant("jdk8${base.capitalize()}", base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
                }
                withFiles {
                    removeAllFiles()
                    addFile("${context.details.id.name}-${context.details.id.version}-jdk8.jar")
                }
            }
            context.details.withVariant(base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 7)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，很明显，分类器代表目标Java版本，这是<a href="#sec:variant-aware-matching">已知的Java生态系统属性</a> 。因为我们还需要Java 8的<em>编译</em>和<em>运行时</em> ，所以我们创建了两个新的变体，但将现有的<em>编译</em>和<em>运行时</em>变体用作<em>base</em> 。这样，所有其他Java生态系统属性已经正确设置，并且所有依赖项都被继承。然后我们设置<code>TARGET_JVM_VERSION_ATTRIBUTE</code>至<code>8</code>对于这两个变体，请使用以下命令从新变体中删除所有现有文件： <code>removeAllFiles()</code> ，然后使用添加jdk8 jar文件<code>addFile()</code> 。的<code>removeAllFiles()</code>是必需的，因为对主jar的引用<code>quasar-core-0.7.5.jar</code>从相应的基本变体复制。</p>
</div>
<div class="paragraph">
<p>我们还将针对Java 7的信息丰富了现有的<em>编译</em>和<em>运行时</em>变体- <code>attribute(TARGET_JVM_VERSION_ATTRIBUTE, 7)</code> 。</p>
</div>
<div class="paragraph">
<p>现在，我们可以为构建脚本中所有依赖于编译类路径的依赖项请求Java 8版本，并且Gradle会自动为每个库选择最合适的变体。对于Quasar，现在是<em>jdk8Compile</em>变体，它公开了<code>quasar-core-0.7.9-jdk8.jar</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例89。类星元数据的应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.compileClasspath.attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
}
dependencies {
    components {
        withModule("co.paralleluniverse:quasar-core", QuasarRule)
    }
    implementation("co.paralleluniverse:quasar-core:0.7.9")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations["compileClasspath"].attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
}
dependencies {
    components {
        withModule&lt;QuasarRule&gt;("co.paralleluniverse:quasar-core")
    }
    implementation("co.paralleluniverse:quasar-core:0.7.9")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="making_variants_encoded_in_versions_explicit"><a class="anchor" href="#making_variants_encoded_in_versions_explicit"></a> <a class="link" href="#making_variants_encoded_in_versions_explicit">明确显示版本中编码的变体</a></h3>
<div class="paragraph">
<p>为同一个库发布多个替代项的另一种解决方案是使用流行的Guava库完成的版本控制模式。在这里，通过将分类器（而不是jar工件）附加到版本，每个新版本都会发布两次。以Guava 28为例，我们可以在<a href="https://repo1.maven.org/maven2/com/google/guava/guava">Maven</a> <em>Central上</em>找到<em>28.0-jre</em> （Java 8）和<em>28.0-android</em> （Java 6）版本。仅在使用pom元数据时使用此模式的优势在于，可以通过版本发现这两种变体。缺点是没有任何信息表明不同版本的后缀在语义上意味着什么。因此，在发生冲突的情况下，Gradle在比较版本字符串时只会选择最高版本。</p>
</div>
<div class="paragraph">
<p>将其转换为适当的变体会比较棘手，因为Gradle首先选择模块的版本，然后选择最合适的变体。因此，不直接支持将变体编码为版本的概念。但是，由于两个变体始终一起发布，因此我们可以假设文件实际上位于同一存储库中。由于它们是按照Maven存储库约定发布的，因此如果知道模块名称和版本，我们就知道每个文件的位置。我们可以编写以下规则：</p>
</div>
<div class="exampleblock">
<div class="title">示例90。将Jdk 6和Jdk 8变体添加到Guava元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GuavaRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        def variantVersion = context.details.id.version
        def version = variantVersion.substring(0, variantVersion.indexOf("-"))
        ["compile", "runtime"].each { base -&gt;
            [6: "android", 8: "jre"].each { targetJvmVersion, jarName -&gt;
                context.details.addVariant("jdk$targetJvmVersion${base.capitalize()}", base) {
                    attributes {
                        attributes.attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, targetJvmVersion)
                    }
                    withFiles {
                        removeAllFiles()
                        addFile("guava-$version-${jarName}.jar", "../$version-$jarName/guava-$version-${jarName}.jar")
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class GuavaRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        val variantVersion = context.details.id.version
        val version = variantVersion.substring(0, variantVersion.indexOf("-"))
        listOf("compile", "runtime").forEach { base -&gt;
            mapOf(6 to "android", 8 to "jre").forEach { (targetJvmVersion, jarName) -&gt;
                context.details.addVariant("jdk$targetJvmVersion${base.capitalize()}", base) {
                    attributes {
                        attributes.attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, targetJvmVersion)
                    }
                    withFiles {
                        removeAllFiles()
                        addFile("guava-$version-$jarName.jar", "../$version-$jarName/guava-$version-$jarName.jar")
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与前面的示例类似，我们为两个Java版本都添加了运行时和编译变体。在里面<code>withFile</code>但是，我们现在还要为相应的jar文件指定一个相对路径，无论Gradle选择了<em>-jre</em>还是<em>-android</em>版本，它都允许Gradle查找该文件。路径始终相对于元数据的位置（在这种情况下， <code>pom</code> ）选择模块版本的文件。因此，使用此规则，番石榴28个“版本”都携带<em>jdk6</em>和<em>jdk8</em>变体。因此，Gradle解决哪个问题都没有关系。该变体以及正确的jar文件是根据请求确定的<code>TARGET_JVM_VERSION_ATTRIBUTE</code>值。</p>
</div>
<div class="exampleblock">
<div class="title">例子91。适用于番石榴元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.compileClasspath.attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 6)
}
dependencies {
    components {
        withModule("com.google.guava:guava", GuavaRule)
    }
    // '23.3-android' and '23.3-jre' are now the same as both offer both variants
    implementation("com.google.guava:guava:23.3+")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations["compileClasspath"].attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 6)
}
dependencies {
    components {
        withModule&lt;GuavaRule&gt;("com.google.guava:guava")
    }
    // '23.3-android' and '23.3-jre' are now the same as both offer both variants
    implementation("com.google.guava:guava:23.3+")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="adding_variants_for_native_jars"><a class="anchor" href="#adding_variants_for_native_jars"></a> <a class="link" href="#adding_variants_for_native_jars">为本地jar添加变体</a></h3>
<div class="paragraph">
<p>带有分类器的jar还用于将库中存在多个替代方案（例如本机代码）的部分与主要工件分离。例如，这是由轻量级Java游戏库（LWGJ）完成的，该库将一些特定于平台的jar发布到<a href="https://repo1.maven.org/maven2/org/lwjgl/lwjgl/3.2.3">Maven</a> Central，在运行时，除了主jar之外，总是需要其中一个。由于没有通过元数据关联多个工件的概念，因此无法在pom元数据中传达此信息。在Gradle模块元数据中，每个变体可以具有任意多个文件，我们可以通过编写以下规则来利用它：</p>
</div>
<div class="exampleblock">
<div class="title">示例92。将本地运行时变体添加到LWGJ元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class LwjglRule implements ComponentMetadataRule { //val os: String, val arch: String, val classifier: String)
    private def nativeVariants = [
        [os: OperatingSystemFamily.LINUX,   arch: "arm32",  classifier: "natives-linux-arm32"],
        [os: OperatingSystemFamily.LINUX,   arch: "arm64",  classifier: "natives-linux-arm64"],
        [os: OperatingSystemFamily.WINDOWS, arch: "x86",    classifier: "natives-windows-x86"],
        [os: OperatingSystemFamily.WINDOWS, arch: "x86-64", classifier: "natives-windows"],
        [os: OperatingSystemFamily.MACOS,   arch: "x86-64", classifier: "natives-macos"]
    ]

    @Inject ObjectFactory getObjects() { }

    void execute(ComponentMetadataContext context) {
        context.details.withVariant("runtime") {
            attributes {
                attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named(OperatingSystemFamily, "none"))
                attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, objects.named(MachineArchitecture, "none"))
            }
        }
        nativeVariants.each { variantDefinition -&gt;
            context.details.addVariant("${variantDefinition.classifier}-runtime", "runtime") {
                attributes {
                    attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named(OperatingSystemFamily, variantDefinition.os))
                    attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, objects.named(MachineArchitecture, variantDefinition.arch))
                }
                withFiles {
                    addFile("${context.details.id.name}-${context.details.id.version}-${variantDefinition.classifier}.jar")
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class LwjglRule: ComponentMetadataRule {
    data class NativeVariant(val os: String, val arch: String, val classifier: String)

    private val nativeVariants = listOf(
        NativeVariant(OperatingSystemFamily.LINUX,   "arm32",  "natives-linux-arm32"),
        NativeVariant(OperatingSystemFamily.LINUX,   "arm64",  "natives-linux-arm64"),
        NativeVariant(OperatingSystemFamily.WINDOWS, "x86",    "natives-windows-x86"),
        NativeVariant(OperatingSystemFamily.WINDOWS, "x86-64", "natives-windows"),
        NativeVariant(OperatingSystemFamily.MACOS,   "x86-64", "natives-macos")
    )

    @Inject open fun getObjects(): ObjectFactory = throw UnsupportedOperationException()

    override fun execute(context: ComponentMetadataContext) {
        context.details.withVariant("runtime") {
            attributes {
                attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, getObjects().named("none"))
                attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, getObjects().named("none"))
            }
        }
        nativeVariants.forEach { variantDefinition -&gt;
            context.details.addVariant("${variantDefinition.classifier}-runtime", "runtime") {
                attributes {
                    attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, getObjects().named(variantDefinition.os))
                    attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, getObjects().named(variantDefinition.arch))
                }
                withFiles {
                    addFile("${context.details.id.name}-${context.details.id.version}-${variantDefinition.classifier}.jar")
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此规则与上面的Quasar库示例非常相似。仅这次，我们添加了五个不同的运行时变体，而对于编译变体则无需更改。运行时变体全部基于现有的<em>运行时</em>变体，并且我们不更改任何现有信息。所有Java生态系统属性，依赖项和主jar文件都属于每个运行时变体的一部分。我们只设置其他属性<code>OPERATING_SYSTEM_ATTRIBUTE</code>和<code>ARCHITECTURE_ATTRIBUTE</code>定义为Gradle <a href="building_cpp_projects.html">本机支持的一部分</a> 。然后，我们添加相应的本机jar文件，以便每个运行时变体现在都包含两个文件：主jar和本机jar。</p>
</div>
<div class="paragraph">
<p>在构建脚本中，我们现在可以请求特定的变体，如果需要更多信息来做出决定，则Gradle将失败，并出现选择错误。</p>
</div>
<div class="exampleblock">
<div class="title">示例93。LWGJ元数据的应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations["runtimeClasspath"].attributes {
    attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named(OperatingSystemFamily, "windows"))
}
dependencies {
    components {
        withModule("org.lwjgl:lwjgl", LwjglRule)
    }
    implementation("org.lwjgl:lwjgl:3.2.3")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations["runtimeClasspath"].attributes {
    attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named("windows"))
}
dependencies {
    components {
        withModule&lt;LwjglRule&gt;("org.lwjgl:lwjgl")
    }
    implementation("org.lwjgl:lwjgl:3.2.3")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle无法选择变体，因为需要选择机器架构</div>
<div class="content">
<pre>&gt; Could not resolve all files for configuration ':runtimeClasspath'.
   &gt; Could not resolve org.lwjgl:lwjgl:3.2.3.
     Required by:
         project :
      &gt; Cannot choose between the following variants of org.lwjgl:lwjgl:3.2.3:
          - natives-windows-runtime
          - natives-windows-x86-runtime</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="making_different_flavors_of_a_library_available_through_capabilities"><a class="anchor" href="#making_different_flavors_of_a_library_available_through_capabilities"></a> <a class="link" href="#making_different_flavors_of_a_library_available_through_capabilities">通过功能提供不同风格的库</a></h3>
<div class="paragraph">
<p>由于很难将<a href="#">可选功能变量</a>建模为带有pom元数据的单独jar，因此库有时会组成具有不同功能集的不同jar。也就是说，不是从不同的功能变体中组合出库的风格，而是选择一种预先组合的变体（在一个jar中提供所有内容）。这样的库之一就是著名的依赖注入框架Guice，它在<a href="https://repo1.maven.org/maven2/com/google/inject/guice/4.2.2">Maven</a> Central上发布，提供了完整的风格（主jar）和简化的变体，而没有面向方面的编程支持（ <code>guice-4.2.2-no_aop.jar</code> ）。pom元数据中未提及带有分类器的第二个变体。使用以下规则，我们基于该文件创建编译和运行时变体，并通过名为<code>com.google.inject:guice-no_aop</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例94。将no_aop功能变体添加到Guice元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GuiceRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        ["compile", "runtime"].each { base -&gt;
            context.details.addVariant("noAop${base.capitalize()}", base) {
                withCapabilities {
                    addCapability("com.google.inject", "guice-no_aop", context.details.id.version)
                }
                withFiles {
                    removeAllFiles()
                    addFile("guice-${context.details.id.version}-no_aop.jar")
                }
                withDependencies {
                    removeAll { it.group == "aopalliance" }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class GuiceRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        listOf("compile", "runtime").forEach { base -&gt;
            context.details.addVariant("noAop${base.capitalize()}", base) {
                withCapabilities {
                    addCapability("com.google.inject", "guice-no_aop", context.details.id.version)
                }
                withFiles {
                    removeAllFiles()
                    addFile("guice-${context.details.id.version}-no_aop.jar")
                }
                withDependencies {
                    removeAll { it.group == "aopalliance" }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>新的变体还依赖于标准化的aop接口库<code>aopalliance:aopalliance</code>删除，因为这些变体显然不需要。同样，这是无法在pom元数据中表达的信息。我们现在可以选择一个<code>guice-no_aop</code>变体，将获得正确的jar文件<strong>和</strong>正确的依赖关系。</p>
</div>
<div class="exampleblock">
<div class="title">示例95。对Guice元数据应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    components {
        withModule("com.google.inject:guice", GuiceRule)
    }
    implementation("com.google.inject:guice:4.2.2") {
        capabilities { requireCapability("com.google.inject:guice-no_aop") }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    components {
        withModule&lt;GuiceRule&gt;("com.google.inject:guice")
    }
    implementation("com.google.inject:guice:4.2.2") {
        capabilities { requireCapability("com.google.inject:guice-no_aop") }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="adding_missing_capabilities_to_detect_conflicts"><a class="anchor" href="#adding_missing_capabilities_to_detect_conflicts"></a> <a class="link" href="#adding_missing_capabilities_to_detect_conflicts">添加缺少的功能来检测冲突</a></h3>
<div class="paragraph">
<p>功能的另一种用法是表示两个不同的模块，例如<code>log4j</code>和<code>log4j-over-slf4j</code> ，提供同一事物的替代实现。通过声明两者均提供相同的功能，Gradle在依赖图中仅接受其中之一。此示例以及如何用组件元数据规则解决该示例，在<a href="#sec:declaring-capabilities-external-modules">功能建模</a>部分中进行了详细说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="making_ivy_modules_variant_aware"><a class="anchor" href="#making_ivy_modules_variant_aware"></a> <a class="link" href="#making_ivy_modules_variant_aware">使常春藤模块能够感知变体</a></h3>
<div class="paragraph">
<p>具有常春藤元数据的模块默认情况下不具有变体。但是，可以将<em>常春藤配置</em>映射为变体，因为<code>addVariant(name, baseVariantOrConfiguration)</code>接受任何已发布为基础的Ivy配置。例如，这可用于定义运行时和编译变体。相应规则的示例可以在<a href="#sub:ivy-mapping-to-variants">此处</a>找到。常春藤配置的常春藤详细信息（例如，依赖关系和文件）也可以使用<code>withVariant(configurationName)</code> API。但是，修改Ivy配置上的属性或功能无效。</p>
</div>
<div class="paragraph">
<p>对于非常特定于Ivy的用例，组件元数据规则API还提供对仅在Ivy元数据中找到的其他详细信息的访问。这些可以通过<a href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html">IvyModuleDescriptor</a>接口获得，并且可以使用<code>getDescriptor(IvyModuleDescriptor)</code>在<a href="../javadoc/org/gradle/api/artifacts/ComponentMetadataContext.html">ComponentMetadataContext上</a> 。（请注意，对于其他类型的元数据，此方法返回null。）</p>
</div>
<div class="exampleblock">
<div class="title">例子96。常春藤组件元数据规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class IvyComponentRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        val descriptor = context.getDescriptor(IvyModuleDescriptor)
        if (descriptor != null &amp;&amp; descriptor.branch == "testing") {
            context.details.status = "rc"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class IvyComponentRule : ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        val descriptor = context.getDescriptor(IvyModuleDescriptor::class)
        if (descriptor != null &amp;&amp; descriptor.branch == "testing") {
            context.details.status = "rc"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modifying_metadata_on_the_component_level_for_alignment"><a class="anchor" href="#modifying_metadata_on_the_component_level_for_alignment"></a> <a class="link" href="#modifying_metadata_on_the_component_level_for_alignment">在组件级别修改元数据以进行对齐</a></h3>
<div class="paragraph">
<p>尽管以上所有示例都对组件的变体进行了修改，但也可以对组件本身的元数据进行有限的修改。此信息可能会影响相关性解析期间模块的<a href="#">版本选择</a>过程，该过程在<a href="#">选择</a>组件的一个或多个变体<em>之前</em>执行。</p>
</div>
<div class="paragraph">
<p>组件上可用的第一个API是<code>belongsTo()</code>创建虚拟平台以对齐没有Gradle Module Metadata的多个模块的版本。在<a href="#sec:align-versions-virtual">对齐未随Gradle发行的模块版本</a>的部分中对此进行了详细说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:custom_status_scheme"><a class="anchor" href="#sec:custom_status_scheme"></a> <a class="link" href="#sec:custom_status_scheme">在组件级别上修改元数据以根据状态选择版本</a></h3>
<div class="paragraph">
<p>Gradle和Gradle模块元数据还允许在整个组件上设置属性，而不是单个变量。这些属性中的每一个都具有特殊的语义，因为它们影响版本选择，而版本选择是<em>在</em>变量选择<em>之前</em>完成的。尽管变体选择可以处理<a href="#sec:declaring_attributes">任何自定义属性</a> ，但版本选择仅考虑实现了特定语义的属性。目前，这里唯一有意义的属性是<code>org.gradle.status</code> 。因此，建议仅在组件级别修改此属性（如果有）。专用API <code>setStatus(value)</code>可用于此。为组件的所有变体修改另一个属性<code>withAllVariants { attributes {} }</code>应该代替使用。</p>
</div>
<div class="paragraph">
<p>解析<a href="#"><em>最新</em>版本选择器</a>时，将考虑模块的状态。特别， <code>latest.someStatus</code>将解析为具有状态的最高模块版本<code>someStatus</code>或更成熟的地位例如， <code>latest.integration</code>不论其状态如何，都会选择最高的模块版本（因为<code>integration</code>是最不成熟的状态，如下所述），而<code>latest.release</code>将选择状态最高的模块版本<code>release</code> 。</p>
</div>
<div class="paragraph">
<p>通过以下方式更改模块的<em>状态方案，</em>可以影响状态的解释： <code>setStatusScheme(valueList)</code> API。这个概念模拟了模块在不同出版物中随着时间推移而转变的不同成熟度。默认状态方案（从最小状态到最大状态）为<code>integration</code> ， <code>milestone</code> ， <code>release</code> 。的<code>org.gradle.status</code>必须将属性设置为组件状态方案中的值之一。因此，每个组件始终具有从元数据确定的状态，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle模块元数据：为以下项目发布的值<code>org.gradle.status</code>组件上的属性</p>
</li>
<li>
<p>常春藤元数据： <code>status</code>在ivy.xml中定义，默认为<code>integration</code>如果丢失</p>
</li>
<li>
<p>Pom元数据： <code>integration</code>对于SNAPSHOT版本的模块， <code>release</code>对于其他所有人</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例演示<code>latest</code>基于在适用于所有模块的组件元数据规则中声明的自定义状态方案的选择器：</p>
</div>
<div class="exampleblock">
<div class="title">示例97。自定义状态方案</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CustomStatusRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        context.details.statusScheme = ["nightly", "milestone", "rc", "release"]
        if (context.details.status == "integration") {
            context.details.status = "nightly"
        }
    }
}

dependencies {
    components {
        all(CustomStatusRule)
    }
    implementation("org.apache.commons:commons-lang3:latest.rc")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class CustomStatusRule : ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        context.details.statusScheme = listOf("nightly", "milestone", "rc", "release")
        if (context.details.status == "integration") {
            context.details.status = "nightly"
        }
    }
}

dependencies {
    components {
        all&lt;CustomStatusRule&gt;()
    }
    implementation("org.apache.commons:commons-lang3:latest.rc")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与默认方案相比，该规则将插入新状态<code>rc</code>并替换<code>integration</code>与<code>nightly</code> 。现有模块的状态<code>integration</code>映射到<code>nightly</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resolution_rules"><a class="anchor" href="#resolution_rules"></a> <a class="link" href="#resolution_rules">直接自定义依赖项的解析</a></h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>本节介绍Gradle提供的直接影响依赖关系解析引擎行为的机制。与本章介绍的其他概念（例如<a href="#">依赖项约束</a>或<a href="#">组件元数据规则）不同</a> ，它们都是解析的<strong>输入</strong> ，以下机制使您可以编写直接注入解析引擎的规则。因此，它们可以看作是<em>蛮力</em>解决方案，可能会隐藏未来的问题（例如，如果添加了新的依赖项）。因此，一般建议仅在其他手段不足的情况下使用以下机制。如果要编写<a href="#">库</a> ，则应始终首选<a href="#">依赖项约束，</a>因为它们是为用户发布的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="sec:dependency_resolve_rules"><a class="anchor" href="#sec:dependency_resolve_rules"></a> <a class="link" href="#sec:dependency_resolve_rules">使用依赖关系解决规则</a></h3>
<div class="paragraph">
<p>为每个已解析的依赖项执行一个依赖项解析规则，并提供了一个强大的api，用于在解析依赖项之前处理请求的依赖项。该功能当前提供了更改请求的依赖项的组，名称和/或版本的功能，从而允许在解析过程中将依赖项替换为完全不同的模块。</p>
</div>
<div class="paragraph">
<p>依赖关系解析规则提供了一种非常强大的方法来控制依赖关系解析过程，并且可用于实现依赖关系管理中的各种高级模式。下面概述了其中一些模式。或更多信息和代码示例，请参阅API文档中的<a href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html">ResolutionStrategy</a>类。</p>
</div>
<div class="sect3">
<h4 id="sec:custom_versioning_scheme"><a class="anchor" href="#sec:custom_versioning_scheme"></a> <a class="link" href="#sec:custom_versioning_scheme">实施自定义版本控制方案</a></h4>
<div class="paragraph">
<p>在某些公司环境中，可以在Gradle构建中声明的模块版本列表由外部维护和审核。依赖关系解析规则提供了该模式的巧妙实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在构建脚本中，开发人员使用模块组和名称声明依赖关系，但使用占位符版本，例如： <code>default</code> 。</p>
</li>
<li>
<p>的<code>default</code>通过依赖关系解析规则将版本解析为特定版本，该规则在已批准模块的公司目录中查找该版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以将规则实施整齐地封装在公司插件中，并在组织内的所有内部版本之间共享。</p>
</div>
<div class="exampleblock">
<div class="title">例子98。使用自定义版本控制方案</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        if (details.requested.version == 'default') {
            def version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)
            details.useVersion version.version
            details.because version.because
        }
    }
}

def findDefaultVersionInCatalog(String group, String name) {
    //some custom logic that resolves the default version into a specific version
    [version: "1.0", because: 'tested by QA']
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.eachDependency {
        if (requested.version == "default") {
            val version = findDefaultVersionInCatalog(requested.group, requested.name)
            useVersion(version.version)
            because(version.because)
        }
    }
}

data class DefaultVersion(val version: String, val because: String)

fun findDefaultVersionInCatalog(group: String, name: String): DefaultVersion {
    //some custom logic that resolves the default version into a specific version
    return DefaultVersion(version = "1.0", because = "tested by QA")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:blacklisting_version"><a class="anchor" href="#sec:blacklisting_version"></a> <a class="link" href="#sec:blacklisting_version">将特定版本列入黑名单并进行替换</a></h4>
<div class="paragraph">
<p>依赖关系解析规则提供了一种机制，可以将特定版本的依赖关系列入黑名单并提供替换版本。如果某个依赖项版本已损坏并且不应使用，当依赖项解析规则导致该版本被已知的良好版本替换时，这将很有用。损坏的模块的一个示例是声明对某个库的依赖关系，该依赖关系在任何公共存储库中都找不到，但是还有许多其他原因导致特定模块版本是不需要的，而首选其他版本。</p>
</div>
<div class="paragraph">
<p>在下面的示例中，假设该版本<code>1.2.1</code>包含重要的修复程序，应始终优先使用<code>1.2</code> 。提供的规则将强制执行以下操作：任何时间版本<code>1.2</code>遇到它将被替换为<code>1.2.1</code> 。请注意，这与如上所述的强制版本不同，因为此模块的任何其他版本都不会受到影响。这意味着“最新”冲突解决策略仍会选择版本<code>1.3</code>如果此版本也被移交。</p>
</div>
<div class="exampleblock">
<div class="title">示例99。示例：将替换版本列入黑名单</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        if (details.requested.group == 'org.software' &amp;&amp; details.requested.name == 'some-library' &amp;&amp; details.requested.version == '1.2') {
            details.useVersion '1.2.1'
            details.because 'fixes critical bug in 1.2'
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.eachDependency {
        if (requested.group == "org.software" &amp;&amp; requested.name == "some-library" &amp;&amp; requested.version == "1.2") {
            useVersion("1.2.1")
            because("fixes critical bug in 1.2")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>使用具有<a href="#rich-version-constraints">丰富版本约束</a>的<em>拒绝</em>指令是有区别的：如果在图中找到拒绝的版本，丰富的版本将导致构建失败，或者在使用动态依赖项时选择非拒绝的版本。在这里，我们<em>处理请求的版本</em> ，以便在找到被拒绝的版本时选择其他版本。换句话说，这是针对拒绝版本的<em>解决方案</em> ，而丰富版本限制允许声明<em>意图</em> （您不应使用此版本）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:module_replacement"><a class="anchor" href="#sec:module_replacement"></a> <a class="link" href="#sec:module_replacement">使用模块更换规则</a></h3>
<div class="paragraph">
<p>就<a href="#sub:capabilities">功能冲突</a>而言，最好表达模块<a href="#sub:capabilities">冲突</a> 。但是，如果没有声明这样的规则，或者您正在使用不支持功能的Gradle版本，则Gradle提供了解决这些问题的工具。</p>
</div>
<div class="paragraph">
<p>模块替换规则允许构建声明旧库已被新库替换。新图书馆取代旧图书馆的一个很好的例子是<code>google-collections</code> -> <code>guava</code>移民。创建Google馆藏的团队决定将模块名称从<code>com.google.collections:google-collections</code>进入<code>com.google.guava:guava</code> 。这在业界是一种合法的情况：团队需要能够更改其维护的产品名称，包括模块坐标。重命名模块坐标会影响冲突解决。</p>
</div>
<div class="paragraph">
<p>为了说明对解决冲突的影响，让我们考虑<code>google-collections</code> -> <code>guava</code>场景。这两个库都可能被拉到同一个依赖图中。例如， <em>我们的项目</em>取决于<code>guava</code>但<em>我们的</em>某些<em>依赖项</em>引入了旧版本的<code>google-collections</code> 。这可能会导致运行时错误，例如在测试或应用程序执行期间。Gradle不会自动解决<code>google-collections</code> -> <code>guava</code>冲突，因为它不被视为<em>版本冲突</em> 。这是因为两个库的模块坐标完全不同，并且在解决冲突时激活了冲突解决方案<code>group</code>和<code>module</code>坐标是相同的，但是在依赖关系图中有不同的版本（有关更多信息，请参阅冲突解决部分）。解决此问题的传统方法是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>声明排除规则，以避免引入<code>google-collections</code>图。这可能是最流行的方法。</p>
</li>
<li>
<p>避免引入旧式库的依赖项。</p>
</li>
<li>
<p>如果新版本不再引入旧版库，请升级依赖版本。</p>
</li>
<li>
<p>降级至<code>google-collections</code> 。不建议这样做，只是出于完整性考虑。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>传统方法行之有效，但它们不够笼统。例如，一个组织想要解决<code>google-collections</code> -> <code>guava</code>所有项目中的冲突解决问题。可以声明某些模块已被其他模块替代。这使组织能够将有关模块更换的信息包括在公司插件套件中，并全面解决企业中所有由Gradle支持的项目的问题。</p>
</div>
<div class="exampleblock">
<div class="title">示例100声明更换模块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    modules {
        module("com.google.collections:google-collections") {
            replacedBy("com.google.guava:guava", "google-collections is now part of Guava")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    modules {
        module("com.google.collections:google-collections") {
            replacedBy("com.google.guava:guava", "google-collections is now part of Guava")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多示例和详细API，请参阅DSL参考<a href="../javadoc/org/gradle/api/artifacts/dsl/ComponentMetadataHandler.html">ComponentMetadataHandler</a> 。</p>
</div>
<div class="paragraph">
<p>当我们声明那会发生什么<code>google-collections</code>被替换为<code>guava</code> ？Gradle可以使用此信息来解决冲突。Gradle会考虑每个版本的<code>guava</code>比任何版本的更新/更好<code>google-collections</code> 。另外，Gradle将确保在类路径/已解析文件列表中仅存在guava jar。请注意，如果仅<code>google-collections</code>出现在依赖关系图中（例如，否<code>guava</code> ）Gradle不会急于将其替换为<code>guava</code> 。模块更换是Gradle用于解决冲突的信息。如果没有冲突（例如<code>google-collections</code>或仅<code>guava</code>在图中）不使用替换信息。</p>
</div>
<div class="paragraph">
<p>当前不可能声明给定的模块被一组模块替换。但是，可以声明多个模块被单个模块替换。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:dependency_substitution_rules"><a class="anchor" href="#sec:dependency_substitution_rules"></a> <a class="link" href="#sec:dependency_substitution_rules">使用依赖替换规则</a></h3>
<div class="paragraph">
<p>依赖关系替换规则的工作方式与依赖关系解决规则相似。实际上，可以使用依赖关系替换规则来实现依赖关系解析规则的许多功能。它们允许将项目和模块依赖项透明地替换为指定的替换项。与依赖关系解析规则不同，依赖关系替换规则允许项目和模块依赖关系可以互换替换。</p>
</div>
<div class="paragraph">
<p><em>在配置中添加依赖项替换规则会更改解析该配置的时间。</em>在构造任务图时，无需解析首次使用的配置，而是解析配置。如果在任务执行期间对配置进行了进一步修改，或者配置依赖于在执行另一任务期间发布的模块，则可能会产生意想不到的后果。</p>
</div>
<div class="paragraph">
<p>解释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>Configuration</code>可以声明为任何Task的输入，并且该配置在解决时可以包括项目依赖项。</p>
</li>
<li>
<p>如果项目依赖项是任务的输入（通过配置），则必须将用于构建项目工件的任务添加到任务依赖项中。</p>
</li>
<li>
<p>为了确定作为任务输入的项目依赖关系，Gradle需要解决<code>Configuration</code>输入。</p>
</li>
<li>
<p>由于Gradle任务图在任务执行开始后便是固定的，因此Gradle需要在执行任何任务之前执行此解决方案。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在没有依赖替换规则的情况下，Gradle知道外部模块依赖永远不会传递引用项目依赖。通过简单的图形遍历，可以轻松确定配置的项目依赖项的完整集合。使用此功能，Gradle不能再进行此假设，并且必须执行完全解析才能确定项目依赖项。</p>
</div>
<div class="sect3">
<h4 id="sub:module_to_project_substitution"><a class="anchor" href="#sub:module_to_project_substitution"></a> <a class="link" href="#sub:module_to_project_substitution">将外部模块依赖项替换为项目依赖项</a></h4>
<div class="paragraph">
<p>一种替代依赖的用例是使用模块的本地开发版本来代替从外部存储库下载的模块。这对于测试依赖项的本地修补版本可能很有用。</p>
</div>
<div class="paragraph">
<p>可以在指定版本或不指定版本的情况下声明要替换的模块。</p>
</div>
<div class="exampleblock">
<div class="title">示例101用项目替换模块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute module("org.utils:api") because "we work with the unreleased development version" with project(":api")
        substitute module("org.utils:util:2.5") with project(":util")
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute(module("org.utils:api")).apply {
            with(project(":api"))
            because("we work with the unreleased development version")
        }
        substitute(module("org.utils:util:2.5")).with(project(":util"))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，替代项目必须包含在多项目构建中（通过<code>settings.gradle</code> ）。依赖关系替换规则负责将模块依赖关系替换为项目依赖关系，并连接所有任务依赖关系，但不将项目隐式包含在构建中。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:project_to_module_substitution"><a class="anchor" href="#sub:project_to_module_substitution"></a> <a class="link" href="#sub:project_to_module_substitution">用模块替换代替项目依赖</a></h4>
<div class="paragraph">
<p>使用替换规则的另一种方法是用多项目构建中的模块替换项目依赖项。通过允许从存储库下载而不是构建项目依赖项的子集，这对于加快大型多项目构建的开发速度很有用。</p>
</div>
<div class="paragraph">
<p>必须使用指定的版本声明要用作替换模块的模块。</p>
</div>
<div class="exampleblock">
<div class="title">例子102。用模块替换项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute project(":api") because "we use a stable version of org.utils:api" with module("org.utils:api:1.3")
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute(project(":api")).apply {
            with(module("org.utils:api:1.3"))
            because("we use a stable version of org.utils:api")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当项目依赖关系已替换为模块依赖关系时，该项目仍将包含在整个多项目构建中。但是，为了解决依赖关系，将不会执行构建替换后的依赖关系的任务<code>Configuration</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:conditional_dependency_substitution"><a class="anchor" href="#sub:conditional_dependency_substitution"></a> <a class="link" href="#sub:conditional_dependency_substitution">有条件地替换依赖</a></h4>
<div class="paragraph">
<p>依赖替换的一个常见用例是允许在多项目构建中更灵活地组装子项目。这对于开发外部依赖的本地修补版本或在大型多项目构建中构建模块的子集很有用。</p>
</div>
<div class="paragraph">
<p>以下示例使用依赖关系替换规则将任何模块依赖关系替换为组<code>org.example</code> ，但前提是必须找到与依赖项名称匹配的本地项目。</p>
</div>
<div class="exampleblock">
<div class="title">示例103有条件地替换依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    configurations.all {
        resolutionStrategy.dependencySubstitution.all { DependencySubstitution dependency -&gt;
            if (dependency.requested instanceof ModuleComponentSelector &amp;&amp; dependency.requested.group == "org.example") {
                def targetProject = findProject(":${dependency.requested.module}")
                if (targetProject != null) {
                    dependency.useTarget targetProject
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">    configurations.all {
        resolutionStrategy.dependencySubstitution.all {
            requested.let {
                if (it is ModuleComponentSelector &amp;&amp; it.group == "org.example") {
                    val targetProject = findProject(":${it.module}")
                    if (targetProject != null) {
                        useTarget(targetProject)
                    }
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，替代项目必须包含在多项目构建中（通过<code>settings.gradle</code> ）。依赖关系替换规则负责将模块依赖关系替换为项目依赖关系，但不将项目隐式包含在构建中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:disabling_resolution_transitive_dependencies"><a class="anchor" href="#sec:disabling_resolution_transitive_dependencies"></a> <a class="link" href="#sec:disabling_resolution_transitive_dependencies">禁用传递解析</a></h3>
<div class="paragraph">
<p>默认情况下，Gradle解析依赖项元数据指定的所有传递依赖项。有时，例如，如果元数据不正确或定义了较大的传递依赖关系图，则此行为可能是不希望的。您可以通过将<a href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html#setTransitive-boolean-">ModuleDependency.setTransitive（boolean）</a>设置为来告诉Gradle为依赖项禁用传递依赖项管理<code>false</code> 。结果，只有主工件才可以解决声明的依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">例子104。为声明的依赖项禁用传递依赖项解析</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation('com.google.guava:guava:23.0') {
        transitive = false
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("com.google.guava:guava:23.0") {
        isTransitive = false
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>禁用传递依赖关系解析可能需要您在构建脚本中声明必要的运行时依赖关系，否则将自动解决。否则可能会导致运行时类路径问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>项目可以决定完全禁用传递依赖项解析。您或者不想依赖发布到使用的存储库的元数据，或者想要完全控制图形中的依赖项。有关更多信息，请参见<a href="../javadoc/org/gradle/api/artifacts/Configuration.html#setTransitive-boolean-">Configuration.setTransitive（boolean）</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子105。在配置级别禁用传递依赖项解析</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    transitive = false
}

dependencies {
    implementation 'com.google.guava:guava:23.0'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    isTransitive = false
}

dependencies {
    implementation("com.google.guava:guava:23.0")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="changing_configuration_dependencies_prior_to_resolution"><a class="anchor" href="#changing_configuration_dependencies_prior_to_resolution"></a> <a class="link" href="#changing_configuration_dependencies_prior_to_resolution">在解决之前更改配置依赖性</a></h3>
<div class="paragraph">
<p>有时，插件可能要在解析配置之前先修改其相关性。的<code>withDependencies</code>方法允许以编程方式添加，删除或修改依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">例子106。修改对配置的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    implementation {
        withDependencies { DependencySet dependencies -&gt;
            ExternalModuleDependency dep = dependencies.find { it.name == 'to-modify' } as ExternalModuleDependency
            dep.version {
                strictly "1.2"
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    create("implementation") {
        withDependencies {
            val dep = this.find { it.name == "to-modify" } as ExternalModuleDependency
            dep.version {
                strictly("1.2")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:configuration_defaults"><a class="anchor" href="#sec:configuration_defaults"></a> <a class="link" href="#sec:configuration_defaults">设置默认配置依赖项</a></h3>
<div class="paragraph">
<p>如果未为配置显式设置任何依赖项，则可以使用默认依赖项来配置配置。此功能的主要用例是开发使用用户可能会覆盖的版本控制工具的插件。通过指定默认依赖关系，只有在用户未指定要使用的特定版本时，插件才能使用该工具的默认版本。</p>
</div>
<div class="exampleblock">
<div class="title">例子107。指定配置的默认依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    pluginTool {
        defaultDependencies { dependencies -&gt;
            dependencies.add(project.dependencies.create("org.gradle:my-util:1.0"))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    create("pluginTool") {
        defaultDependencies {
            add(project.dependencies.create("org.gradle:my-util:1.0"))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="excluding_a_dependency_from_a_configuration_completely"><a class="anchor" href="#excluding_a_dependency_from_a_configuration_completely"></a> <a class="link" href="#excluding_a_dependency_from_a_configuration_completely">从配置中完全排除依赖项</a></h3>
<div class="paragraph">
<p>与<a href="#sec:excluding-transitive-deps">在依赖项声明</a>中排除<a href="#sec:excluding-transitive-deps">依赖项</a>类似，可以通过使用<a href="../dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:exclude(java.util.Map)">Configuration.exclude（java.util。来完全排除特定配置的传递性依赖项</a><a href="../dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:exclude(java.util.Map)">。地图）</a> 。对于配置上声明的所有依赖关系，这将自动排除传递依赖关系。</p>
</div>
<div class="exampleblock">
<div class="title">示例108。排除特定配置的传递依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    implementation {
        exclude group: 'commons-collections', module: 'commons-collections'
    }
}

dependencies {
    implementation 'commons-beanutils:commons-beanutils:1.9.4'
    implementation 'com.opencsv:opencsv:4.6'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    "implementation" {
        exclude(group = "commons-collections", module = "commons-collections")
    }
}

dependencies {
    implementation("commons-beanutils:commons-beanutils:1.9.4")
    implementation("com.opencsv:opencsv:4.6")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="matching_dependencies_to_repositories"><a class="anchor" href="#matching_dependencies_to_repositories"></a> <a class="link" href="#matching_dependencies_to_repositories">将依赖项与存储库进行匹配</a></h3>
<div class="paragraph">
<p>Gradle公开了一个API，以声明存储库可能包含或不包含的内容。此功能提供了对哪个存储库提供哪些工件的精细控制，这可以是控制依赖项来源的一种方法。</p>
</div>
<div class="paragraph">
<p>请转至<a href="#sec:repository-content-filtering">有关存储库内容过滤的部分，</a>以了解有关此功能的更多信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:ivy_dynamic_resolve_mode"><a class="anchor" href="#sec:ivy_dynamic_resolve_mode"></a> <a class="link" href="#sec:ivy_dynamic_resolve_mode">启用常春藤动态解析模式</a></h3>
<div class="paragraph">
<p>Gradle的Ivy存储库实现支持等同于Ivy的动态解析模式。通常，Gradle将使用<code>rev</code>包含在每个依赖项定义中的属性<code>ivy.xml</code>文件。在动态解析模式下，Gradle会更喜欢<code>revConstraint</code>的属性<code>rev</code>给定依赖项定义的属性。如果<code>revConstraint</code>属性不存在， <code>rev</code>改为使用属性。</p>
</div>
<div class="paragraph">
<p>要启用动态解析模式，您需要在存储库定义中设置适当的选项。下面显示了两个示例。请注意，动态解析模式仅适用于Gradle的Ivy存储库。它不适用于Maven存储库或自定义Ivy <code>DependencyResolver</code>实现。</p>
</div>
<div class="exampleblock">
<div class="title">示例109启用动态解析模式</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// Can enable dynamic resolve mode when you define the repository
repositories {
    ivy {
        url "http://repo.mycompany.com/repo"
        resolve.dynamicMode = true
    }
}

// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories
repositories.withType(IvyArtifactRepository) {
    resolve.dynamicMode = true
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">// Can enable dynamic resolve mode when you define the repository
repositories {
    ivy {
        url = uri("http://repo.mycompany.com/repo")
        resolve.isDynamicMode = true
    }
}

// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories
repositories.withType&lt;IvyArtifactRepository&gt; {
    resolve.isDynamicMode = true
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="producing_and_consuming_variants_of_libraries" class="sect0"><a class="anchor" href="#producing_and_consuming_variants_of_libraries"></a> <a class="link" href="#producing_and_consuming_variants_of_libraries">图书馆的生产和消费形式</a></h1>
<div class="sect1">
<h2 id="declaring-component-capabilities"><a class="anchor" href="#declaring-component-capabilities"></a> <a class="link" href="#declaring-component-capabilities">声明图书馆的能力</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="capabilities_as_first_level_concept"><a class="anchor" href="#capabilities_as_first_level_concept"></a> <a class="link" href="#capabilities_as_first_level_concept">能力是首要概念</a></h3>
<div class="paragraph">
<p>组件提供了许多功能，这些功能通常与用于提供这些功能的软件体系结构正交。例如，一个库可能在单个工件中包含多个功能。但是，这样的库将以单个GAV（组，工件和版本）坐标发布。这意味着，在单个坐标处，可能会共存组件的不同“特征”。</p>
</div>
<div class="paragraph">
<p>使用Gradle，显式声明组件提供的功能变得很有趣。为此，Gradle提供了<a href="#sec:adding-constraints-transitive-deps">功能</a>的概念。</p>
</div>
<div class="paragraph">
<p>通常通过组合不同的<em>功能</em>来构建<em>功能</em> 。</p>
</div>
<div class="paragraph">
<p>在理想情况下，组件不应声明对显式GAV的依赖，而应根据功能来表达其要求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“给我一个提供日志记录的组件”</p>
</li>
<li>
<p>“给我一个脚本引擎”</p>
</li>
<li>
<p>“给我一个支持Groovy的脚本引擎”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过对<em>功能进行</em>建模，依赖关系管理引擎可以更智能，并在依赖关系图中具有<em>不兼容功能</em>时告诉您，或者让您选择何时图中的不同模块提供相同<em>功能</em> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:declaring-capabilities-external-modules"><a class="anchor" href="#sec:declaring-capabilities-external-modules"></a> <a class="link" href="#sec:declaring-capabilities-external-modules">声明外部模块的功能</a></h3>
<div class="paragraph">
<p>值得注意的是，Gradle支持声明的功能可用于构建的组件，也可以声明外部组件的功能。</p>
</div>
<div class="paragraph">
<p>例如，如果您的构建文件包含以下依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">例子110。具有日志框架隐式冲突的构建文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // This dependency will bring log4:log4j transitively
    implementation 'org.apache.zookeeper:zookeeper:3.4.9'

    // We use log4j over slf4j
    implementation 'org.slf4j:log4j-over-slf4j:1.7.10'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // This dependency will bring log4:log4j transitively
    implementation("org.apache.zookeeper:zookeeper:3.4.9")

    // We use log4j over slf4j
    implementation("org.slf4j:log4j-over-slf4j:1.7.10")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>照原样，很难确定您最终会在类路径上获得两个日志记录框架。事实上， <code>zookeeper</code>会带来<code>log4j</code> ，我们要使用的是<code>log4j-over-slf4j</code> 。我们可以通过添加一条规则来抢先检测冲突，该规则将声明两个日志记录框架提供相同的功能：</p>
</div>
<div class="exampleblock">
<div class="title">例子111。具有日志框架隐式冲突的构建文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // Activate the "LoggingCapability" rule
    components.all(LoggingCapability)
}

@CompileStatic
class LoggingCapability implements ComponentMetadataRule {
    final static Set&lt;String&gt; LOGGING_MODULES = ["log4j", "log4j-over-slf4j"] as Set&lt;String&gt;

    void execute(ComponentMetadataContext context) {
        context.details.with {
            if (LOGGING_MODULES.contains(id.name)) {
                allVariants {
                    it.withCapabilities {
                        // Declare that both log4j and log4j-over-slf4j provide the same capability
                        it.addCapability("log4j", "log4j", id.version)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // Activate the "LoggingCapability" rule
    components.all(LoggingCapability::class.java)
}

class LoggingCapability : ComponentMetadataRule {
    val loggingModules = setOf("log4j", "log4j-over-slf4j")

    override
    fun execute(context: ComponentMetadataContext) = context.details.run {
        if (loggingModules.contains(id.name)) {
            allVariants {
                withCapabilities {
                    // Declare that both log4j and log4j-over-slf4j provide the same capability
                    addCapability("log4j", "log4j", id.version)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过添加此规则，我们将确保Gradle <em>将</em>检测到冲突并适当地失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; Could not resolve all files for configuration ':compileClasspath'.
   &gt; Could not resolve org.slf4j:log4j-over-slf4j:1.7.10.
     Required by:
         project :
      &gt; Module 'org.slf4j:log4j-over-slf4j' has been rejected:
           Cannot select module with conflict on capability 'log4j:log4j:1.7.10' also provided by [log4j:log4j:1.2.16(compile)]
   &gt; Could not resolve log4j:log4j:1.2.16.
     Required by:
         project : &gt; org.apache.zookeeper:zookeeper:3.4.9
      &gt; Module 'log4j:log4j' has been rejected:
           Cannot select module with conflict on capability 'log4j:log4j:1.2.16' also provided by [org.slf4j:log4j-over-slf4j:1.7.10(compile)]</pre>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="#sub:selecting-between-candidates">文档</a>的<a href="#sub:selecting-between-candidates">功能部分，</a>以了解如何解决功能冲突。</p>
</div>
</div>
<div class="sect2">
<h3 id="declaring_additional_capabilities_for_a_local_component"><a class="anchor" href="#declaring_additional_capabilities_for_a_local_component"></a> <a class="link" href="#declaring_additional_capabilities_for_a_local_component">声明本地组件的其他功能</a></h3>
<div class="paragraph">
<p>所有组件都具有与该组件相同的GAV坐标对应的<em>隐式功能</em> 。只要在不同GAV坐标处发布的库是同一API的<em>替代实现</em> ，这便很方便。但是，也可以为组件声明其他<em>显式功能</em> ：</p>
</div>
<div class="exampleblock">
<div class="title">例子112。声明组件的功能</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    apiElements {
        outgoing {
            capability("com.acme:my-library:1.0")
            capability("com.other:module:1.1")
        }
    }
    runtimeElements {
        outgoing {
            capability("com.acme:my-library:1.0")
            capability("com.other:module:1.1")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    apiElements {
        outgoing {
            capability("com.acme:my-library:1.0")
            capability("com.other:module:1.1")
        }
    }
    runtimeElements {
        outgoing {
            capability("com.acme:my-library:1.0")
            capability("com.other:module:1.1")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>功能必须附加到<em>传出配置</em> ， <em>传出配置</em>是组件的<a href="#sec:resolvable-consumable-configs">消耗性配置</a> 。</p>
</div>
<div class="paragraph">
<p>此示例显示我们声明了两个功能：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>com.acme:my-library:1.0</code> ，它对应于库的<em>隐式功能</em></p>
</li>
<li>
<p><code>com.other:module:1.1</code> ，它对应于此库的另一功能</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>值得注意的是，我们需要执行1.，因为一旦您开始声<em>明显式</em>功能，就需要声明<em>所有</em>功能，包括<em>隐式功能</em> 。</p>
</div>
<div class="paragraph">
<p>第二功能可以特定于此库，也可以对应于外部组件提供的功能。在这种情况下<code>com.other:module</code>如果出现在相同的依赖图中，构建将失败，使用者<a href="#sub:selecting-between-candidates">将必须选择要使用的模块</a> 。</p>
</div>
<div class="paragraph">
<p>功能已发布到Gradle模块元数据。但是，它们在POM或Ivy元数据文件中<em>没有等效项</em> 。因此，发布此类组件时，Gradle将警告您该功能仅适用于Gradle使用者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Maven publication 'maven' contains dependencies that cannot be represented in a published pom file.
  - Declares capability com.acme:my-library:1.0
  - Declares capability com.other:module:1.1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="feature_variants"><a class="anchor" href="#feature_variants"></a> <a class="link" href="#feature_variants">建模功能变体和可选依赖项</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle支持<em>功能变体</em>的概念：在构建库时，通常只有在存在某些依赖项或使用特殊工件时，某些功能才可用。</p>
</div>
<div class="paragraph">
<p>功能变体使消费者可以选择他们需要的库的哪些<em>功能</em> ：依赖性管理引擎将选择正确的工件和依赖性。</p>
</div>
<div class="paragraph">
<p>这考虑到了许多不同的情况（列表并不详尽）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>（更好）替代<a href="https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html">Maven可选依赖项</a></p>
</li>
<li>
<p>建立一个<em>主</em>库，以支持运行时功能的不同互斥实现； <a href="#sec::incompatible_variants">用户必须为每个这样的功能选择一个，并且只有一个实现</a></p>
</li>
<li>
<p>建立了一个<em>主</em>库，它支持可选的运行时功能，每个功能都需要一组不同的依赖项</p>
</li>
<li>
<p><em>主</em>库随附<em>测试夹具之</em>类的辅助变体</p>
</li>
<li>
<p><em>主</em>库附带一个主工件，而启用附加功能则需要附加工件</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="sec::feature_variant_selection"><a class="anchor" href="#sec::feature_variant_selection"></a> <a class="link" href="#sec::feature_variant_selection">选择功能变体和功能</a></h3>
<div class="paragraph">
<p>声明对组件的依赖性通常是通过提供一组坐标（组，工件，版本也称为GAV坐标）来完成的。这使引擎可以确定我们要寻找的<em>组件</em> ，但是这种组件可能提供不同的<em>变体</em> 。通常根据用途选择一个<em>变体</em> 。例如，我们可以选择其他变体来针对组件进行编译（在这种情况下，我们需要组件的API），或者在执行代码时（在这种情况下，我们需要组件的运行时）。组件的所有变体都提供许多<a href="#sub:capabilities">功能</a> ，这些<a href="#sub:capabilities">功能</a>使用GAV坐标类似地表示。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>功能由GAV坐标表示，但您必须将其视为特征描述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“我提供了SLF4J绑定”</p>
</li>
<li>
<p>“我为MySQL提供运行时支持”</p>
</li>
<li>
<p>“我提供一个Groovy运行时”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，在图中有两个提供<em>相同内容的</em>组件是一个问题（它们相互冲突）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是一个重要的概念，因为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>默认情况下，变体提供与其组件的GAV坐标相对应的功能</p>
</li>
<li>
<p>如果依赖关系图中提供相同的功能，则不允许它们具有不同的组件或组件的不同变体</p>
</li>
<li>
<p>只要它们提供<em>不同的功能</em> ，就可以选择同一组件的两个变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>典型的组件将<strong>仅</strong>提供具有默认功能的变体。例如，Java库公开了提供<em>相同功能的</em>两个变体（API和运行时）。结果，在依赖关系图中同时具有单个组件的<em>API</em>和<em>运行时</em>都是错误的。</p>
</div>
<div class="paragraph">
<p>但是，假设您需要组件的<em>运行时</em>和<em>测试夹具</em> 。然后，只要<em>库的运行时</em>和<em>测试夹具</em>变体声明了不同的功能，就可以允许它。</p>
</div>
<div class="paragraph">
<p>如果这样做，那么使用者将必须声明两个依赖项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个关于“主”变体的库</p>
</li>
<li>
<p>通过<em>要求其功能</em> ，在“测试装置”变体上安装一个</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>尽管引擎支持独立于生态系统的功能变体，但此功能当前仅可通过Java插件使用，并且正在开发中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sec::declare_feature_variants"><a class="anchor" href="#sec::declare_feature_variants"></a> <a class="link" href="#sec::declare_feature_variants">声明功能变体</a></h3>
<div class="paragraph">
<p>可以通过应用<code>java</code>要么<code>java-library</code>插件。以下代码说明了如何声明名为<code>mongodbSupport</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例113。声明功能变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">group = 'org.gradle.demo'
version = '1.0'

java {
    registerFeature('mongodbSupport') {
        usingSourceSet(sourceSets.main)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">group = "org.gradle.demo"
version = "1.0"

java {
    registerFeature("mongodbSupport") {
        usingSourceSet(sourceSets["main"])
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle将以与<a href="java_library_plugin.html#java_library_plugin">Java库插件</a>设置配置非常相似的方式为您自动设置许多东西：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>配置<code>mongodbSupportApi</code> ，用于<em>声明</em>此功能的<em>API依赖关系</em></p>
</li>
<li>
<p>配置<code>mongodbSupportImplementation</code> ，用于<em>声明</em>此功能的<em>实现依赖项</em></p>
</li>
<li>
<p>配置<code>mongodbSupportApiElements</code> ，供消费者用来获取此功能的工件和API依赖项</p>
</li>
<li>
<p>配置<code>mongodbSupportRuntimeElements</code> ，供消费者使用，以获取此功能的构件和运行时依赖项</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大多数用户只需要关心前两个配置，即可声明此功能的特定依赖性：</p>
</div>
<div class="exampleblock">
<div class="title">示例114。声明功能的依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    mongodbSupportImplementation 'org.mongodb:mongodb-driver-sync:3.9.1'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    "mongodbSupportImplementation"("org.mongodb:mongodb-driver-sync:3.9.1")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>按照约定，Gradle会将功能名称映射到功能，其功能组和版本分别与主要组件的组和版本相同，但功能名称是主要组件名称，后跟一个<code>-</code>然后是kebab式功能名称。</p>
</div>
<div class="paragraph">
<p>例如，如果组是<code>org.gradle.demo</code> ，该组件的名称为<code>provider</code> ，其版本为<code>1.0</code>并且该功能被命名为<code>mongodbSupport</code> ，功能变体为<code>org.gradle.demo:provider-mongodb-support:1.0</code> 。</p>
</div>
<div class="paragraph">
<p>如果您自己选择功能名称或向变体添加更多功能，建议遵循相同的约定。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="sec:feature_variant_source_set"><a class="anchor" href="#sec:feature_variant_source_set"></a> <a class="link" href="#sec:feature_variant_source_set">功能变体源集</a></h4>
<div class="paragraph">
<p>在前面的示例中，我们声明了一个使用<em>主源集</em>的功能变体。这是Java生态系统中的典型用例，无论出于何种原因，都无法将项目的源拆分为不同的子项目或不同的源集。因此，Gradle将声明所描述的配置，但还将设置<em>主要源集</em>的编译类路径和运行时类路径，以便其从功能配置中扩展。换句话说，这允许您在其自己的“存储桶”中声明特定于功能的依赖关系，但是所有内容仍被编译为单个源集。也将只有一个工件（组件Jar），包括对所有功能的支持。</p>
</div>
<div class="paragraph">
<p>但是，通常最好为功能<em>设置单独的源集</em> 。然后Gradle将执行类似的映射，但<em>不会</em>使主要组件的编译和运行时类路径从已注册功能的依赖项中扩展。按照惯例，它还将创建一个<code>Jar</code>任务，使用与功能的kebab-case名称相对应的分类器，捆绑从该功能源集构建的类：</p>
</div>
<div class="exampleblock">
<div class="title">示例115。使用单独的源集声明功能变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">sourceSets {
    mongodbSupport {
        java {
            srcDir 'src/mongodb/java'
        }
    }
}

java {
    registerFeature('mongodbSupport') {
        usingSourceSet(sourceSets.mongodbSupport)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">sourceSets {
    create("mongodbSupport") {
        java {
            srcDir("src/mongodb/java")
        }
    }
}

java {
    registerFeature("mongodbSupport") {
        usingSourceSet(sourceSets["mongodbSupport"])
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec::publishing_feature_variants"><a class="anchor" href="#sec::publishing_feature_variants"></a> <a class="link" href="#sec::publishing_feature_variants">发布功能变体</a></h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>根据元数据文件格式，发布功能变体可能是有损的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle Module Metadata</a> ，所有内容都会发布，消费者将获得功能变体的全部好处</p>
</li>
<li>
<p>使用POM元数据（Maven），特征变体作为<strong>可选的依赖项</strong>发布，并且特征变体的工件使用不同的<em>分类器</em>发布</p>
</li>
<li>
<p>使用常春藤元数据，功能变体将作为额外配置发布，但<em>不会被</em>扩展<code>default</code>组态</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用以下功能支持发布功能变体<code>maven-publish</code>和<code>ivy-publish</code>仅插件。Java插件（或Java库插件）将为您注册其他变体，因此不需要其他配置，只需常规出版物即可：</p>
</div>
<div class="exampleblock">
<div class="title">示例116。发布具有功能变体的组件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java-library'
    id 'maven-publish'
}
// ...
publishing {
    publications {
        myLibrary(MavenPublication) {
            from components.java
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    `java-library`
    `maven-publish`
}
// ...
publishing {
    publications {
        create("myLibrary", MavenPublication::class.java) {
            from(components["java"])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:javadoc_sources_features_variants"><a class="anchor" href="#sub:javadoc_sources_features_variants"></a> <a class="link" href="#sub:javadoc_sources_features_variants">添加Javadoc和源JAR</a></h4>
<div class="paragraph">
<p>与<a href="building_java_projects.html#sec:java_packaging">主要Javadoc和源JAR</a>相似，您可以配置添加的功能变量，以便它为Javadoc和源产生JAR。但是，这仅在使用非主要来源集时才有意义。</p>
</div>
<div class="exampleblock">
<div class="title">示例117生成Javadoc并为功能变体提供源JAR</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">java {
    registerFeature('mongodbSupport') {
        usingSourceSet(sourceSets.mongodbSupport)
        withJavadocJar()
        withSourcesJar()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">java {
    registerFeature("mongodbSupport") {
        usingSourceSet(sourceSets["mongodbSupport"])
        withJavadocJar()
        withSourcesJar()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec::consuming_feature_variants"><a class="anchor" href="#sec::consuming_feature_variants"></a> <a class="link" href="#sec::consuming_feature_variants">对功能变体的依赖</a></h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>如前所述，功能变体在发布时可能是有损的。因此，消费者仅在以下情况下才能依赖功能变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有项目依赖项（在多项目构建中）</p>
</li>
<li>
<p>在可用Gradle Module元数据的情况下，即发布者必须已发布它</p>
</li>
<li>
<p>在常春藤世界中，通过声明对与功能匹配的配置的依赖</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>消费者可以通过声明所需的功能来指定它需要生产者的特定功能。例如，如果生产者声明了这样的“ MySQL支持”功能：</p>
</div>
<div class="exampleblock">
<div class="title">例子118。声明支持MySQL功能的库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">java {
    registerFeature('mysqlSupport') {
        usingSourceSet(sourceSets.main)
    }
}

dependencies {
    mysqlSupportImplementation 'mysql:mysql-connector-java:8.0.14'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">java {
    registerFeature("mysqlSupport") {
        usingSourceSet(sourceSets["main"])
    }
}

dependencies {
    "mysqlSupportImplementation"("mysql:mysql-connector-java:8.0.14")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，使用者可以通过执行以下操作来声明对MySQL支持功能的依赖关系：</p>
</div>
<div class="exampleblock">
<div class="title">示例119。在多项目构建中使用特定功能</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // This project requires the main producer component
    implementation(project(":producer"))

    // But we also want to use its MySQL support
    runtimeOnly(project(":producer")) {
        capabilities {
            requireCapability("org.gradle.demo:producer-mysql-support")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // This project requires the main producer component
    implementation(project(":producer"))

    // But we also want to use its MySQL support
    runtimeOnly(project(":producer")) {
        capabilities {
            requireCapability("org.gradle.demo:producer-mysql-support")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将自动带来<code>mysql-connector-java</code>对运行时类路径的依赖。如果存在多个依赖关系，则将它们全部带入，这意味着可以使用功能将有助于功能的依赖项组合在一起。</p>
</div>
<div class="paragraph">
<p>同样，如果带有功能变体的外部库是随<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle Module Metadata发布的</a> ，则可能依赖于该库提供的功能：</p>
</div>
<div class="exampleblock">
<div class="title">例子120。使用外部存储库中的特定功能</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    // This project requires the main producer component
    implementation('org.gradle.demo:producer:1.0')

    // But we also want to use its MongoDB support
    runtimeOnly('org.gradle.demo:producer:1.0') {
        capabilities {
            requireCapability("org.gradle.demo:producer-mongodb-support")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // This project requires the main producer component
    implementation("org.gradle.demo:producer:1.0")

    // But we also want to use its MongoDB support
    runtimeOnly("org.gradle.demo:producer:1.0") {
        capabilities {
            requireCapability("org.gradle.demo:producer-mongodb-support")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec::incompatible_variants"><a class="anchor" href="#sec::incompatible_variants"></a> <a class="link" href="#sec::incompatible_variants">处理互斥的变体</a></h3>
<div class="paragraph">
<p>使用<em>功能</em>作为处理功能的主要优点是，您可以精确处理变量的兼容性。规则很简单：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>不允许有两个组件变体在单个依赖关系图中提供相同的功能。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们可以利用它来要求Gradle在用户错误配置依赖项时失败。例如，想象一下，您的库支持MySQL，Postgres和MongoDB，但是只能同时选择<em>其中之一</em> 。不允许将其直接转换为“提供相同的功能”，因此所有三个功能都必须提供一个功能：</p>
</div>
<div class="exampleblock">
<div class="title">示例121。相互排斥的多种功能的生产者</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">java {
    registerFeature('mysqlSupport') {
        usingSourceSet(sourceSets.main)
        capability('org.gradle.demo', 'producer-db-support', '1.0')
        capability('org.gradle.demo', 'producer-mysql-support', '1.0')
    }
    registerFeature('postgresSupport') {
        usingSourceSet(sourceSets.main)
        capability('org.gradle.demo', 'producer-db-support', '1.0')
        capability('org.gradle.demo', 'producer-postgres-support', '1.0')
    }
    registerFeature('mongoSupport') {
        usingSourceSet(sourceSets.main)
        capability('org.gradle.demo', 'producer-db-support', '1.0')
        capability('org.gradle.demo', 'producer-mongo-support', '1.0')
    }
}

dependencies {
    mysqlSupportImplementation 'mysql:mysql-connector-java:8.0.14'
    postgresSupportImplementation 'org.postgresql:postgresql:42.2.5'
    mongoSupportImplementation 'org.mongodb:mongodb-driver-sync:3.9.1'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">java {
    registerFeature("mysqlSupport") {
        usingSourceSet(sourceSets["main"])
        capability("org.gradle.demo", "producer-db-support", "1.0")
        capability("org.gradle.demo", "producer-mysql-support", "1.0")
    }
    registerFeature("postgresSupport") {
        usingSourceSet(sourceSets["main"])
        capability("org.gradle.demo", "producer-db-support", "1.0")
        capability("org.gradle.demo", "producer-postgres-support", "1.0")
    }
    registerFeature("mongoSupport") {
        usingSourceSet(sourceSets["main"])
        capability("org.gradle.demo", "producer-db-support", "1.0")
        capability("org.gradle.demo", "producer-mongo-support", "1.0")
    }
}

dependencies {
    "mysqlSupportImplementation"("mysql:mysql-connector-java:8.0.14")
    "postgresSupportImplementation"("org.postgresql:postgresql:42.2.5")
    "mongoSupportImplementation"("org.mongodb:mongodb-driver-sync:3.9.1")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生产者在这里声明3个变体，每个数据库运行时支持一个变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mysql-support</code>同时提供<code>db-support</code>和<code>mysql-support</code>能力</p>
</li>
<li>
<p><code>postgres-support</code>同时提供<code>db-support</code>和<code>postgres-support</code>能力</p>
</li>
<li>
<p><code>mongo-support</code>同时提供<code>db-support</code>和<code>mongo-support</code>能力</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，如果消费者试图同时获得<code>postgres-support</code>和<code>mysql-support</code>像这样（这也可以传递）：</p>
</div>
<div class="exampleblock">
<div class="title">例子122。消费者尝试同时使用2个不兼容的变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation(project(":producer"))

    // Let's try to ask for both MySQL and Postgres support
    runtimeOnly(project(":producer")) {
        capabilities {
            requireCapability("org.gradle.demo:producer-mysql-support")
        }
    }
    runtimeOnly(project(":producer")) {
        capabilities {
            requireCapability("org.gradle.demo:producer-postgres-support")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    // This project requires the main producer component
    implementation(project(":producer"))

    // Let's try to ask for both MySQL and Postgres support
    runtimeOnly(project(":producer")) {
        capabilities {
            requireCapability("org.gradle.demo:producer-mysql-support")
        }
    }
    runtimeOnly(project(":producer")) {
        capabilities {
            requireCapability("org.gradle.demo:producer-postgres-support")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>依赖关系解析将失败，并出现以下错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Cannot choose between
   org.gradle.demo:producer:1.0 variant mysqlSupportRuntimeElements and
   org.gradle.demo:producer:1.0 variant postgresSupportRuntimeElements
   because they provide the same capability: org.gradle.demo:producer-db-support:1.0</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="understanding-variant-selection"><a class="anchor" href="#understanding-variant-selection"></a> <a class="link" href="#understanding-variant-selection">了解变体选择</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle的依赖管理引擎称为<em>变体感知</em> 。在像Apache Maven™这样的传统依赖管理引擎中，依赖关系绑定到在GAV坐标处发布的组件。这意味着组件的传递依赖项集仅由该组件的GAV坐标确定。实际解决什么<em>工件</em>都没有关系，依赖关系的集合<em>始终是相同的</em> 。此外，为组件选择其他工件（例如，使用<code>jdk7</code>工件）繁琐，因为它需要使用<em>分类器</em> 。该模型的一个问题是它不能保证全局图的一致性，因为没有与<em>分类器</em>关联的通用语义。这意味着没有什么可以阻止<code>jdk7</code>和<code>jdk8</code>类路径上单个模块的版本，因为引擎不知道与分类器名称关联的语义。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/component-model-maven.png" alt="组件模型专家">
</div>
<div class="title">图11。Maven组件模型</div>
</div>
<div class="paragraph">
<p>除了在GAV坐标处发布的<em>模块</em>的概念外，Gradle还介绍了此模块的<em>变体</em>的概念。变体对应于在相同GAV坐标处发布的组件的不同“视图”。在Gradle模型中，工件被附加到<em>变量</em>而不是模块。实际上，这意味着不同的<em>工件</em>可以具有不同的依赖关系集：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/component-model-gradle.png" alt="组件模型gradle">
</div>
<div class="title">图12。Gradle组件模型</div>
</div>
<div class="paragraph">
<p>这个中间级别将工件和依赖项与变量关联，而不是直接与组件相关联，使Gradle可以正确地建模每个工件的用途。</p>
</div>
<div class="paragraph">
<p>但是，这引发了有关如何选择变体的问题：当存在多个变体时，Gradle如何知道要选择哪个变体？实际上，由于使用了<a href="#">属性</a> ，因此选择了变体，这些<a href="#">属性</a>为变体提供了语义，并有助于引擎获得<em>一致的解析结果</em> 。</p>
</div>
<div class="paragraph">
<p>由于历史原因，Gradle区分两种组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从源构建的本地组件，其<a href="#sec:abm_configuration_attributes">变体映射到传出配置</a></p>
</li>
<li>
<p>外部组件（在存储库上发布），在这种情况下，该模块要么通过Gradle Module Metadata发布，并且本机支持变体，要么该模块使用Ivy / Maven元数据，而<a href="#sec:mapping-maven-ivy-to-variants">变体则从元数据派生</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这两种情况下，Gradle都会执行<em>变体感知选择</em> 。</p>
</div>
<div class="sect2">
<h3 id="sec:abm_configuration_attributes"><a class="anchor" href="#sec:abm_configuration_attributes"></a> <a class="link" href="#sec:abm_configuration_attributes">配置和变量属性</a></h3>
<div class="paragraph">
<p>本地组件将变体作为<em>传出配置</em>公开，这是<a href="#sec:resolvable-consumable-configs">消耗性配置</a> 。发生依赖关系解析时，引擎将通过选择其_consumable配置之一来选择传出组件的一种变体。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>此规则有2个明显的例外：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每当生产者<em>不</em>公开任何消耗品配置</p>
</li>
<li>
<p>每当使用者<em>明确选择目标配置时</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这种情况下， <em>绕过变体感知分辨率</em> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在<em>可解析配置</em> （也称为<em>使用者</em> ）和<em>消耗性配置</em> （在<em>生产者</em> ）上都使用属性。将属性添加到其他类型的配置中根本没有效果，因为属性不会在配置之间继承。</p>
</div>
<div class="paragraph">
<p>依赖项解析引擎的作用是在给定<em>消费者</em>表示的约束的情况下，找到<em>生产者</em>的合适<em>变体</em> 。</p>
</div>
<div class="paragraph">
<p>这就是属性发挥作用的地方：它们的作用是执行组件的正确<em>变体</em>的选择。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="title">变体与配置</div>
<div class="paragraph">
<p>对于外部组件，术语是使用<em>变体</em>一词，而不是<em>配置</em> 。配置是变体的超集。</p>
</div>
<div class="paragraph">
<p>这意味着外部组件提供了<em>variant</em> ，它们也具有属性。但是，有时由于历史原因或由于您使用也具有这种<em>配置</em>概念的Ivy，术语<em>配置</em>可能会泄漏到DSL中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sec:variant-visual"><a class="anchor" href="#sec:variant-visual"></a> <a class="link" href="#sec:variant-visual">可视化变体信息</a></h3>
<div class="paragraph">
<p>Gradle提供了一个报告任务，称为<code>outgoingVariants</code>显示项目的变体及其功能，属性和工件。它在概念上类似于<code>dependencyInsight</code> <a href="#sec:identifying_reason_dependency_selection">报告任务</a> 。</p>
</div>
<div class="paragraph">
<p>默认， <code>outgoingVariants</code>打印有关所有变体的信息。它提供了可选参数<code>--variant <variantName></code>选择要显示的单个变体。它还接受<code>-all</code>标志以包含有关旧配置和不推荐使用的配置的信息。</p>
</div>
<div class="paragraph">
<p>这是输出<code>outgoingVariants</code>新生成的任务<code>java-library</code>项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; Task :outgoingVariants
--------------------------------------------------
Variant apiElements
--------------------------------------------------
Description = API elements for main.

Capabilities
    - [default capability]
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 8
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-api

Artifacts
    - build/libs/variant-report.jar (artifactType = jar)

Secondary variants (*)
    - Variant : classes
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = classes
          - org.gradle.usage               = java-api
       - Artifacts
          - build/classes/java/main (artifactType = java-classes-directory)

--------------------------------------------------
Variant runtimeElements
--------------------------------------------------
Description = Elements of runtime for main.

Capabilities
    - [default capability]
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 8
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-runtime

Artifacts
    - build/libs/variant-report.jar (artifactType = jar)

Secondary variants (*)
    - Variant : classes
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = classes
          - org.gradle.usage               = java-runtime
       - Artifacts
          - build/classes/java/main (artifactType = java-classes-directory)
    - Variant : resources
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = resources
          - org.gradle.usage               = java-runtime
       - Artifacts
          - build/resources/main (artifactType = java-resources-directory)


(*) Secondary variants are variants created via the Configuration#getOutgoing(): ConfigurationPublications API which also participate in selection, in addition to the configuration itself.</pre>
</div>
</div>
<div class="paragraph">
<p>从中您可以看到Java库公开的两个主要变体， <code>apiElements</code>和<code>runtimeElements</code> 。请注意，主要区别在于<code>org.gradle.usage</code>具有值的属性<code>java-api</code>和<code>java-runtime</code> 。正如他们所指出的，这就是消费者的<em>编译</em>类路径上需要的内容与<em>运行时</em>类路径上需要的内容之间的区别。</p>
</div>
<div class="paragraph">
<p>它还显示了<em>次级</em>变体，这些变体是Gradle项目专有的，未发布。例如，次级变体<code>classes</code>从<code>apiElements</code>是什么允许Gradle在针对.NET进行编译时跳过JAR创建<a href="java_library_plugin.html#sec:java_library_classes_usage"><code>java-library</code>项目</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:variant-aware-matching"><a class="anchor" href="#sec:variant-aware-matching"></a> <a class="link" href="#sec:variant-aware-matching">变体匹配</a></h3>
<div class="paragraph">
<p>让我们以一个<code>lib</code>该库公开了2个变体：其API（通过名为的变体<code>exposedApi</code> ）及其运行时（通过名为的变体<code>exposedRuntime</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="title">关于生产者变体</div>
<div class="paragraph">
<p>此处存在变体<em>名称</em> ，主要用于调试目的并在错误消息中获得更好的显示。特别是，名称不参与变体的<em>ID</em> ：只有其属性参与。也就是说，要搜索特定的变体， <em>必须</em>依靠其属性<em>而不是</em>其名称。</p>
</div>
<div class="paragraph">
<p>组件可以公开的变体数量没有限制。传统上，一个组件会公开一个API和一个实现，但是例如，我们可能也想公开一个组件的测试装置。也可以为不同的使用者公开<em>不同的API</em> （考虑一下不同的环境，例如Linux与Windows）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>消费者需要解释它需要<em>什么</em>变体，这是通过在<em>消费者</em>上设置<em>属性</em>来完成的。</p>
</div>
<div class="paragraph">
<p>属性由<em>名称</em>和<em>值</em>对组成。例如，Gradle带有一个名为<code>org.gradle.usage</code>专门用于根据使用者的使用情况（编译，运行时...）选择组件的正确变体的概念。但是可以定义任意数量的属性。作为生产者，我们可以通过附加附件来表示消耗性配置代表组件的API。 <code>(org.gradle.usage,JAVA_API)</code>属性的变体。作为使用者，我们可以通过附加以下内容来表达我们需要可解析配置依赖项的API： <code>(org.gradle.usage,JAVA_API)</code>属性。为此，Gradle可以通过查看配置属性来<em>自动选择适当的变体</em> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消费者想要<code>org.gradle.usage=JAVA_API</code></p>
</li>
<li>
<p>生产者， <code>lib</code>展示2种不同的变体。与之一<code>org.gradle.usage=JAVA_API</code> ，另一个<code>org.gradle.usage=JAVA_RUNTIME</code> 。</p>
</li>
<li>
<p>Gradle选择<code>org.gradle.usage=JAVA_API</code>生产者的变体，因为它<em>与消费者属性匹配</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>换句话说：属性用于基于属性的值执行选择。</p>
</div>
<div class="paragraph">
<p>一个更详尽的示例涉及多个属性。通常，Gradle中的Java库项目将涉及4个不同的属性，在生产者和消费者方面都可以找到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.usage</code> ，说明变体是组件的API还是其实现</p>
</li>
<li>
<p><code>org.gradle.dependency.bundling</code> ，它声明了如何捆绑组件的依赖项（例如，如果工件是一个胖子，那么捆绑是<code>EMBEDDED</code> ）</p>
</li>
<li>
<p><code>org.gradle.libraryelements</code> ，用于说明该变体包含库的哪些<em>部分</em> （类，资源或所有内容）</p>
</li>
<li>
<p><code>org.gradle.jvm.version</code> ，用于说明此变体针对的<em>最低</em> Java <em>版本</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，假设我们的库具有两种不同的风格：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个用于JDK 8</p>
</li>
<li>
<p>一个用于JDK 9+</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在Maven中，这通常是通过生成2种不同的工件（“主”工件和“分类”工件）来实现的。但是，在Maven中，使用者无法表达其需要基于运行时的<em>最合适</em>版本的库这一事实。</p>
</div>
<div class="paragraph">
<p>使用Gradle，可以通过让生产者声明两个变体来优雅地解决此问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与之一<code>org.gradle.jvm.version=8</code> ，对于<em>至少在JDK 8上运行的</em>消费者</p>
</li>
<li>
<p>与之一<code>org.gradle.jvm.version=9</code> ，适用于从JDK 9开始的消费者</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，这两个变体的工件会有所不同，但它们的依存关系<em>也可能</em>会有所不同。通常，JDK 8变体可能需要JDK 9+的“反向端口”库才能工作，只有在JDK 8上运行的使用者才能使用。</p>
</div>
<div class="paragraph">
<p>在使用者方面， <em>可解析配置</em>将设置上述所有四个属性，并根据运行时设置其<code>org.gradle.jvm.version</code>到8或更多。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="title">有关变体兼容性的说明</div>
<div class="paragraph">
<p>如果消费者设置<code>org.gradle.jvm.version</code>到7？</p>
</div>
<div class="paragraph">
<p>然后解析将<em>失败，</em>并显示一条错误消息，说明生产者没有匹配的变体。这是因为Gradle认识到消费者希望使用Java 7兼容库，但是生产者可用的Java的<em>最低</em>版本为8。另一方面，如果消费者需要<em>11</em> ，则Gradle知道<em>8</em>和<em>9</em>变体都可以使用，但是它将选择<em>9，</em>因为它是最高兼容的版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sec:variant-select-errors"><a class="anchor" href="#sec:variant-select-errors"></a> <a class="link" href="#sec:variant-select-errors">变异选择错误</a></h3>
<div class="paragraph">
<p>在标识组件的正确变体的过程中，两种情况将导致分辨率错误：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>生产者的多个变体与消费者属性相匹配，存在变体歧义</p>
</li>
<li>
<p>生产者的任何变体都不符合消费者属性</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="sub:variant-ambiguity"><a class="anchor" href="#sub:variant-ambiguity"></a> <a class="link" href="#sub:variant-ambiguity">处理模棱两可的变量选择错误</a></h4>
<div class="paragraph">
<p>模棱两可的变量选择看起来如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; Could not resolve all files for configuration ':compileClasspath'.
   &gt; Could not resolve project :lib.
     Required by:
         project :ui
      &gt; Cannot choose between the following variants of project :lib:
          - feature1ApiElements
          - feature2ApiElements
        All of them match the consumer attributes:
          - Variant 'feature1ApiElements' capability org.test:test-capability:1.0:
              - Unmatched attribute:
                  - Found org.gradle.category 'library' but wasn't required.
              - Compatible attributes:
                  - Required org.gradle.dependency.bundling 'external' and found compatible value 'external'.
                  - Required org.gradle.jvm.version '11' and found compatible value '11'.
                  - Required org.gradle.libraryelements 'classes' and found compatible value 'jar'.
                  - Required org.gradle.usage 'java-api' and found compatible value 'java-api'.
          - Variant 'feature2ApiElements' capability org.test:test-capability:1.0:
              - Unmatched attribute:
                  - Found org.gradle.category 'library' but wasn't required.
              - Compatible attributes:
                  - Required org.gradle.dependency.bundling 'external' and found compatible value 'external'.
                  - Required org.gradle.jvm.version '11' and found compatible value '11'.
                  - Required org.gradle.libraryelements 'classes' and found compatible value 'jar'.
                  - Required org.gradle.usage 'java-api' and found compatible value 'java-api'.</pre>
</div>
</div>
<div class="paragraph">
<p>可以看到，显示了所有<em>兼容的</em>候选变体及其属性。然后将它们分为两个部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先介绍不匹配的属性，因为它们可能是选择适当变体时缺少的部分。</p>
</li>
<li>
<p>其次显示兼容的属性，因为它们指示消费者想要什么以及这些变体如何匹配该请求。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>不能有任何不匹配的属性，因为那时变体将不是候选者。同样，显示的变体集也排除了已消除歧义的变体。</p>
</div>
<div class="paragraph">
<p>在上面的示例中，解决方法不在于属性匹配，而在于<a href="#sec:adding-constraints-transitive-deps">功能匹配</a> ，该功能显示在变量名称旁边。因为这两个变体有效地提供了相同的属性和功能，所以它们不会被歧义。因此，在这种情况下，此修复程序最有可能在生产者端提供不同的功能（ <code>project :lib</code> ），并在用户端表示能力选择（ <code>project :ui</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:variant-no-match"><a class="anchor" href="#sub:variant-no-match"></a> <a class="link" href="#sub:variant-no-match">处理无匹配的变体错误</a></h4>
<div class="paragraph">
<p>没有匹配的变体错误如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; No variants of project :lib match the consumer attributes:
  - Configuration ':lib:compile':
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other attribute:
          - Required usage 'api' and found compatible value 'api'.
  - Configuration ':lib:compile' variant debug:
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other attributes:
          - Found buildType 'debug' but wasn't required.
          - Required usage 'api' and found compatible value 'api'.
  - Configuration ':lib:compile' variant release:
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other attributes:
          - Found buildType 'release' but wasn't required.
          - Required usage 'api' and found compatible value 'api'.</pre>
</div>
</div>
<div class="paragraph">
<p>可以看出，显示了<em>所有</em>候选变体及其属性。然后将它们分为两个部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先介绍不兼容的属性，因为它们通常是理解为什么无法选择变体的关键。</p>
</li>
<li>
<p>其次显示其他属性，包括<em>必需的</em>和<em>兼容</em>的属性，以及消费者不要求的所有其他<em>生产者</em>属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与模棱两可的变量错误类似，目标是了解要选择哪个变量，并查看可以针对使用者调整哪些属性或功能以实现此目的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:mapping-maven-ivy-to-variants"><a class="anchor" href="#sec:mapping-maven-ivy-to-variants"></a> <a class="link" href="#sec:mapping-maven-ivy-to-variants">从Maven / Ivy映射到变体</a></h3>
<div class="paragraph">
<p>既不的Maven也不常春藤具有<em>变体</em> ，其仅由本机模块摇篮元数据支持的概念。但是，由于不同的策略，它不会阻止Gradle与他们合作。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="title">与Gradle模块元数据的关系</div>
<div class="paragraph">
<p>Gradle模块元数据是在Maven，Ivy或其他类型的存储库上发布的模块的元数据格式。它类似于<code>pom.xml</code>要么<code>ivy.xml</code>文件，但是这种格式可以<em>识别变体</em> 。这意味着，如果您的项目产生其他变体，则这些变体将作为模块元数据的一部分提供并发布，从而极大地改善用户体验。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle模块元数据规范</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="sub:maven-mapping-to-variants"><a class="anchor" href="#sub:maven-mapping-to-variants"></a> <a class="link" href="#sub:maven-mapping-to-variants">将POM文件映射到变体</a></h4>
<div class="paragraph">
<p>在Maven存储库中发布的模块将转换为可识别变体的模块。Maven模块的特殊之处在于，无法知道发布了哪种组件。特别是，无法在代表<em>平台</em>的BOM和用作超级POM的BOM之间进行区分。有时，POM文件甚至有可能同时充当平台<em>和</em>库。</p>
</div>
<div class="paragraph">
<p>因此，Maven模块分为6个不同的变体，使Gradle用户可以准确地解释它们所依赖的内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2个“库”变体（属性<code>org.gradle.category</code> = <code>library</code> ）</p>
<div class="ulist">
<ul>
<li>
<p>的<code>compile</code>变体映射<code><scope>compile</scope></code>依赖性。此变体等效于<code>apiElements</code> <a href="java_library_plugin.html">Java库插件的</a>变体。此范围的所有依赖项均被视为<em>API依赖项</em> 。</p>
</li>
<li>
<p>的<code>runtime</code>变体既映射<code><scope>compile</scope></code>和<code><scope>runtime</scope></code>依赖性。此变体等效于<code>runtimeElements</code> <a href="java_library_plugin.html">Java库插件的</a>变体。这些作用域的所有依赖关系都被视为<em>运行时依赖关系</em> 。</p>
<div class="ulist">
<ul>
<li>
<p>在这两种情况下， <code><dependencyManagement></code>依赖关系<em>不会转换为约束</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>4个“平台”变体源自<code><dependencyManagement></code>阻止（属性<code>org.gradle.category</code> = <code>platform</code> ）：</p>
<div class="ulist">
<ul>
<li>
<p>的<code>platform-compile</code>变体映射<code><scope>compile</scope></code>依赖管理作为<em>依赖约束的依赖</em> 。</p>
</li>
<li>
<p>的<code>platform-runtime</code>变体既映射<code><scope>compile</scope></code>和<code><scope>runtime</scope></code>依赖管理作为<em>依赖约束的依赖</em> 。</p>
</li>
<li>
<p>的<code>enforced-platform-compile</code>类似于<code>platform-compile</code>但是所有的约束都是<em>强制的</em></p>
</li>
<li>
<p>的<code>enforced-platform-runtime</code>类似于<code>platform-runtime</code>但是所有的约束都是<em>强制的</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过查看手册的“ <a href="#sub:bom_import">导入BOM表”</a>部分，您可以了解有关平台和强制平台变体用法的更多信息。默认情况下，每当您声明对Maven模块的依赖关系时，Gradle都会查找<code>library</code>变体。但是，使用<code>platform</code>要么<code>enforcedPlatform</code>关键字，Gradle现在正在寻找“平台”变体之一，它允许您从POM文件而不是从依赖项中导入约束。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:ivy-mapping-to-variants"><a class="anchor" href="#sub:ivy-mapping-to-variants"></a> <a class="link" href="#sub:ivy-mapping-to-variants">将常春藤文件映射到变体</a></h4>
<div class="paragraph">
<p>与<a href="#sub:maven-mapping-to-variants">Maven</a>相反，默认情况下没有为Ivy文件实现派生策略。这样做的原因是，与pom相反，Ivy是一种灵活的格式，允许您发布任意多个自定义<em>配置</em> 。因此，通常在Ivy中没有编译/运行时范围或编译/运行时变体的概念。仅当您使用<a href="publishing_ivy.html#publishing_ivy">Gravy发行版</a>的<a href="publishing_ivy.html#publishing_ivy">ivy-publish插件</a>发布ivy文件时，您才能获得与pom文件类似的结构。但是，由于不能保证构建所使用的<strong>所有</strong>常春藤元数据文件都遵循此模式，因此Gradle无法基于该模式实施派生策略。</p>
</div>
<div class="paragraph">
<p>但是，如果要为Ivy的<em>编译</em>和<em>运行时</em>变体实现派生策略，则可以使用<a href="#sec:component_metadata_rules">组件元数据rule来实现</a> 。组件元数据规则API允许您<a href="#sec:component_metadata_rules_details">访问ivy配置</a>并基于它们创建变体。如果您知道您使用的所有ivy模块都已在Gradle中发布，而无需进一步自定义<code>ivy.xml</code>文件，您可以在构建中添加以下规则：</p>
</div>
<div class="exampleblock">
<div class="title">示例123导出Ivy元数据的编译和运行时变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class IvyVariantDerivationRule implements ComponentMetadataRule {
    @Inject ObjectFactory getObjects() { }

    void execute(ComponentMetadataContext context) {
        context.details.addVariant("runtimeElements", "default") {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements, LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category, Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage, Usage.JAVA_RUNTIME))
            }
        }
        context.details.addVariant("apiElements", "compile") {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements, LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category, Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage, Usage.JAVA_API))
            }
        }
    }
}

dependencies {
    components { all(IvyVariantDerivationRule) }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class IvyVariantDerivationRule : ComponentMetadataRule {
    @Inject open fun getObjects(): ObjectFactory = throw UnsupportedOperationException()

    override fun execute(context: ComponentMetadataContext) {
        context.details.addVariant("runtimeElements", "default") {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_RUNTIME))
            }
        }
        context.details.addVariant("apiElements", "compile") {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_API))
            }
        }
    }
}

dependencies {
    components { all&lt;IvyVariantDerivationRule&gt;() }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该规则创建一个<code>apiElements</code>基于的变体<code>compile</code>配置和<code>runtimeElements</code>基于的变体<code>default</code>每个常春藤模块的配置。对于每个变体，它都设置了相应的<a href="#sec:variant-aware-matching">Java生态系统属性</a> 。变体的依赖关系和工件来自基础配置。如果不是所有消耗的常春藤模块都遵循此模式，则可以调整规则或仅将规则应用于选定的一组模块。</p>
</div>
<div class="paragraph">
<p>对于没有体都常春藤模块，摇篮回落到原有配置选择（即摇篮<em>不</em>执行这些模块的变体意识到分辨率）。这意味着要么<code>default</code>选择配置或在对相应模块的依赖性中显式定义的配置。（请注意，只有从构建脚本或常春藤元数据中才可以进行显式配置选择，而应避免使用变量选择。）</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="variant_attributes"><a class="anchor" href="#variant_attributes"></a> <a class="link" href="#variant_attributes">使用变体属性</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>如有关<a href="#sec:variant-aware-matching">变体感知匹配</a>的部分所述，属性为变体提供语义，并用于在变体之间进行选择。</p>
</div>
<div class="paragraph">
<p>作为Gradle的用户，属性通常被隐藏为实现细节。但是了解Gradle及其核心插件定义的<em>标准属性</em>可能会很有用。</p>
</div>
<div class="paragraph">
<p>作为插件作者，这些属性及其定义方式可以作为在生态系统插件中<a href="#sec:declaring_attributes">构建自己的一组属性</a>的基础。</p>
</div>
<div class="sect2">
<h3 id="sec:standard_attributes"><a class="anchor" href="#sec:standard_attributes"></a> <a class="link" href="#sec:standard_attributes">Gradle定义的标准属性</a></h3>
<div class="paragraph">
<p>Gradle定义了Gradle核心插件使用的标准属性列表。</p>
</div>
<div class="sect3">
<h4 id="ecosystem_independent_standard_attributes"><a class="anchor" href="#ecosystem_independent_standard_attributes"></a> <a class="link" href="#ecosystem_independent_standard_attributes">与生态系统无关的标准属性</a></h4>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表5。与生态系统无关的标准变体属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/api/attributes/Usage.html#USAGE_ATTRIBUTE"><code>org.gradle.usage</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示变体的主要目的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Usage</code>根据<a href="../javadoc/org/gradle/api/attributes/Usage.html">用法中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如<code>java-runtime</code>可以代替<code>java-api</code>但并非相反）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/api/attributes/Category.html#CATEGORY_ATTRIBUTE"><code>org.gradle.category</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示此软件组件的类别</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Category</code>从<a href="../javadoc/org/gradle/api/attributes/Category.html">类别中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如<code>library</code>是JVM上的默认值，否则不兼容）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/api/attributes/LibraryElements.html#LIBRARY_ELEMENTS_ATTRIBUTE"><code>org.gradle.libraryelements</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示内容<code>org.gradle.category=library</code>变体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LibraryElements</code>从<a href="../javadoc/org/gradle/api/attributes/LibraryElements.html">LibraryElements中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如，在JVM世界中， <code>jar</code>是默认设置，并且与<code>classes</code> ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/api/attributes/DocsType.html#DOCS_TYPE_ATTRIBUTE"><code>org.gradle.docstype</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示内容<code>org.gradle.category=documentation</code>变体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocsType</code>根据<a href="../javadoc/org/gradle/api/attributes/DocsType.html">DocsType中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有默认值，没有兼容性</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/api/attributes/Bundling.html#BUNDLING_ATTRIBUTE"><code>org.gradle.dependency.bundling</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示如何访问变体的依赖项。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Bundling</code>根据<a href="../javadoc/org/gradle/api/attributes/Bundling.html">捆绑中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如，在JVM世界中， <code>embedded</code>与...兼容<code>external</code> ）</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表6。与生态系统无关的标准组件属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.gradle.status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组件级别属性，派生</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">基于<a href="#sec:custom_status_scheme">状态方案</a> ，默认情况下基于源存储库。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根据使用的方案</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sub:jvm_default_attributes"><a class="anchor" href="#sub:jvm_default_attributes"></a> <a class="link" href="#sub:jvm_default_attributes">JVM生态系统特定属性</a></h4>
<div class="paragraph">
<p>除了上面定义的与生态系统无关的属性之外，JVM生态系统还添加了以下属性：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表7。JVM生态系统标准组件属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/api/attributes/java/TargetJvmVersion.html#TARGET_JVM_VERSION_ATTRIBUTE"><code>org.gradle.jvm.version</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示JVM版本兼容性。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数使用后的版本<code>1.</code>适用于Java 1.4及更低版本，是Java 5及更高版本的主要版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认为Gradle使用的JVM版本，低级与高级兼容，更倾向于最高兼容性。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>JVM生态系统还包含许多针对不同属性的兼容性和消歧规则。愿意了解更多信息的读者可以查看以下代码<code>org.gradle.api.internal.artifacts.JavaEcosystemSupport</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="native_ecosystem_specific_attributes"><a class="anchor" href="#native_ecosystem_specific_attributes"></a> <a class="link" href="#native_ecosystem_specific_attributes">原生生态系统特有的属性</a></h4>
<div class="paragraph">
<p>除了上面定义的与生态系统无关的属性之外，本机生态系统还添加了以下属性：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表8。原生生态系统标准组件属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/language/cpp/CppBinary.html#DEBUGGABLE_ATTRIBUTE"><code>org.gradle.native.debuggable</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件是否使用调试符号构建</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/language/cpp/CppBinary.html#OPTIMIZED_ATTRIBUTE"><code>org.gradle.native.optimized</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件是否使用优化标志构建</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/nativeplatform/MachineArchitecture.html#ARCHITECTURE_ATTRIBUTE"><code>org.gradle.native.architecture</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件的目标体系结构</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MachineArchitecture</code>根据<a href="../javadoc/org/gradle/nativeplatform/MachineArchitecture.html">MachineArchitecture中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="../javadoc/org/gradle/nativeplatform/OperatingSystemFamily.html#OPERATING_SYSTEM_ATTRIBUTE"><code>org.gradle.native.operatingSystem</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件的目标操作系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OperatingSystemFamily</code>从<a href="../javadoc/org/gradle/nativeplatform/OperatingSystemFamily.html">OperatingSystemFamily中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="sec:declaring_attributes"><a class="anchor" href="#sec:declaring_attributes"></a> <a class="link" href="#sec:declaring_attributes">声明自定义属性</a></h3>
<div class="paragraph">
<p>如果要扩展Gradle（例如，通过为另一个生态系统编写插件），则要自定义属性，可以在插件中支持变体感知的依赖管理功能。但是，如果您还尝试发布库，则应保持谨慎。新属性的语义通常是通过插件定义的，该插件可以带有<a href="#sec:abm_compatibility_rules">兼容性</a>和<a href="#sec:abm_disambiguation_rules">歧义消除</a>规则。因此，使用消耗为特定生态系统发布的库的构建，也需要应用相应的插件来正确解释属性。如果您的插件面向更广泛的受众，即如果它是公开可用的，并且库已发布到公共存储库，则定义新属性可以有效地扩展Gradle Module元数据的语义并承担责任。例如，对已经发布的属性的支持不应再次删除，或者应在插件的未来版本中以某种兼容性层处理。</p>
</div>
</div>
<div class="sect2">
<h3 id="creating_attributes_in_a_build_script_or_plugin"><a class="anchor" href="#creating_attributes_in_a_build_script_or_plugin"></a> <a class="link" href="#creating_attributes_in_a_build_script_or_plugin">在构建脚本或插件中创建属性</a></h3>
<div class="paragraph">
<p><em>键入</em>属性。可以通过<code>Attribute<T>.of</code>方法：</p>
</div>
<div class="exampleblock">
<div class="title">例子124。定义属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// An attribute of type `String`
def myAttribute = Attribute.of("my.attribute.name", String)
// An attribute of type `Usage`
def myUsage = Attribute.of("my.usage.attribute", Usage)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">// An attribute of type `String`
val myAttribute = Attribute.of("my.attribute.name", String::class.java)
// An attribute of type `Usage`
val myUsage = Attribute.of("my.usage.attribute", Usage::class.java)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>目前，只有<code>String</code>或其他扩展名<code>Named</code>支持。必须在位于以下位置的<em>属性架构中</em>声明<em>属性</em> <code>dependencies</code>处理程序：</p>
</div>
<div class="exampleblock">
<div class="title">示例125在属性架构上注册属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies.attributesSchema {
    // registers this attribute to the attributes schema
    attribute(myAttribute)
    attribute(myUsage)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies.attributesSchema {
    // registers this attribute to the attributes schema
    attribute(myAttribute)
    attribute(myUsage)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后可以配置配置以设置属性值：</p>
</div>
<div class="exampleblock">
<div class="title">示例126在配置上设置属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    myConfiguration {
        attributes {
            attribute(myAttribute, 'my-value')
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    create("myConfiguration") {
        attributes {
            attribute(myAttribute, "my-value")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于类型扩展的属性<code>Named</code> ，则<strong>必须</strong>通过<em>对象工厂</em>创建属性的值：</p>
</div>
<div class="exampleblock">
<div class="title">例子127。命名属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    myConfiguration {
        attributes {
            attribute(myUsage, project.objects.named(Usage, 'my-value'))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    "myConfiguration" {
        attributes {
            attribute(myUsage, project.objects.named(Usage::class.java, "my-value"))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:abm_compatibility_rules"><a class="anchor" href="#sec:abm_compatibility_rules"></a> <a class="link" href="#sec:abm_compatibility_rules">属性兼容性规则</a></h4>
<div class="paragraph">
<p>属性使引擎可以选择<em>兼容的变体</em> 。但是，在某些情况下，提供者可能不<em>完全</em>具有消费者想要的东西，但是仍然可以使用它。例如，如果使用者要求一个库的API，则生产者可能没有这样的变体，而只有<em>运行时</em>变体。这是在外部存储库上发布的库的典型特征。在这种情况下，我们知道即使没有完全匹配（API），我们仍然可以针对运行时变体进行编译（它包含的<em>内容</em>超出了我们需要编译的范围，但仍然可以使用）。为了解决这个问题，Gradle提供了<a href="../javadoc/org/gradle/api/attributes/AttributeCompatibilityRule.html">属性兼容性规则</a> 。兼容性规则的作用是解释哪些变体与消费者要求的变体<em>兼容</em> 。</p>
</div>
<div class="paragraph">
<p>必须通过可从<a href="../javadoc/org/gradle/api/attributes/AttributesSchema.html">属性架构中</a>获取的<a href="../javadoc/org/gradle/api/attributes/AttributeMatchingStrategy.html">属性匹配策略</a>来注册属性兼容性规则。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:abm_disambiguation_rules"><a class="anchor" href="#sec:abm_disambiguation_rules"></a> <a class="link" href="#sec:abm_disambiguation_rules">属性消歧规则</a></h4>
<div class="paragraph">
<p>因为一个属性的多个值可以与请求的属性<em>兼容</em> ，所以Gradle需要在候选者之间进行选择。这是通过实现<a href="../javadoc/org/gradle/api/attributes/AttributeDisambiguationRule.html">属性消歧规则</a>来完成的。</p>
</div>
<div class="paragraph">
<p>必须通过可从<a href="../javadoc/org/gradle/api/attributes/AttributesSchema.html">属性架构中</a>获取的<a href="../javadoc/org/gradle/api/attributes/AttributeMatchingStrategy.html">属性匹配策略</a>来注册属性消歧规则。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cross_project_publications"><a class="anchor" href="#cross_project_publications"></a> <a class="link" href="#cross_project_publications">在项目之间共享输出</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在多项目构建中，一个常见的模式是一个项目消耗另一个项目的工件。通常，Java生态系统中最简单的消耗形式是<code>A</code>依赖于取决于<code>B</code> ， 然后<code>A</code>取决于<code>jar</code>按项目生产<code>B</code> 。如本章先前所述，此模型由<code>A</code> <em>取决于</em>一个<em>变种</em> <code>B</code> ，其中根据以下需求选择变体<code>A</code> 。为了进行编译，我们需要<code>B</code> ，由<code>apiElements</code>变体。对于运行时，我们需要<code>B</code> ，由<code>runtimeElements</code>变体。</p>
</div>
<div class="paragraph">
<p>但是，如果您需要与主要工件<em>不同的</em>工件怎么办？例如，Gradle为依赖于另一个项目的<a href="java_testing.html#sec:java_test_fixtures">测试装置</a>提供了内置支持，但是有时候，您需要依赖的工件并没有被公开为变体。</p>
</div>
<div class="paragraph">
<p>为了在项目之间<em>安全共享</em>并允许最大性能（并行度），必须通过<em>传出配置</em>公开此类工件。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="title">不要直接引用其他项目任务</div>
<div class="paragraph">
<p>声明跨项目依赖关系的常见反模式是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
   // this is unsafe!
   implementation project(":other").tasks.someOtherJar
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此发布模型<em>不安全，</em>并且可能导致不可复制且难以并行化内部版本。本节说明如何通过使用<em>变体</em>在项目之间定义“交换”来<em>正确创建跨项目边界</em> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有两个互补的选项可以在项目之间共享工件。仅当您需要共享的是不依赖于使用者的简单工件时， <a href="#sec:simple-sharing-artifacts-between-projects">简化版本</a>才适用。简单的解决方案还限于未将此工件发布到存储库的情况。这也意味着使用者不会发布对此工件的依赖关系。如果使用者在不同的环境（例如，不同的目标平台）中解决不同的工件或需要该出版物，则需要使用<a href="#sec:variant-aware-sharing">高级版本</a> 。</p>
</div>
<div class="sect2">
<h3 id="sec:simple-sharing-artifacts-between-projects"><a class="anchor" href="#sec:simple-sharing-artifacts-between-projects"></a> <a class="link" href="#sec:simple-sharing-artifacts-between-projects">项目之间工件的简单共享</a></h3>
<div class="paragraph">
<p>首先，生产者需要声明将要<em>暴露</em>给消费者的配置。如<a href="#sec:resolvable-consumable-configs">配置章节</a>中所述，这对应于<em>消耗性配置</em> 。</p>
</div>
<div class="paragraph">
<p>让我们想象一下，消费者需要生产者提供的<em>检测类</em> ，但是该工件<em>不是</em>主要工件。生产者可以通过创建将“承载”此工件的配置来公开其检测的类：</p>
</div>
<div class="exampleblock">
<div class="title">示例128。声明即将发布的变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    instrumentedJars {
        canBeConsumed = true
        canBeResolved = false
        // If you want this configuration to share the same dependencies, otherwise omit this line
        extendsFrom implementation, runtimeOnly
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val instrumentedJars by configurations.creating {
    isCanBeConsumed = true
    isCanBeResolved = false
    // If you want this configuration to share the same dependencies, otherwise omit this line
    extendsFrom(configurations["implementation"], configurations["runtimeOnly"])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种配置是<em>可消耗的</em> ，这意味着它是供消费者使用的“交换产品”。现在，我们要向此配置添加工件，消费者在使用它时会得到：</p>
</div>
<div class="exampleblock">
<div class="title">示例129将工件附加到外发配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">artifacts {
    instrumentedJars(instrumentedJar)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">artifacts {
    add("instrumentedJars", instrumentedJar)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，我们要附加的“工件”实际上是一个生成Jar的<em>任务</em> 。这样做，Gradle可以自动跟踪此任务的依赖关系并根据需要构建它们。这是可能的，因为<code>Jar</code>任务扩展<code>AbstractArchiveTask</code> 。如果不是这种情况，则需要显式声明工件的生成方式。</p>
</div>
<div class="exampleblock">
<div class="title">例子130。明确工件的任务依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">artifacts {
    instrumentedJars(someTask.outputFile) {
        builtBy(someTask)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">artifacts {
    add("instrumentedJars", someTask.outputFile) {
        builtBy(someTask)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在， <em>消费者</em>需要依赖于此配置以获得正确的工件：</p>
</div>
<div class="exampleblock">
<div class="title">示例131明确的配置依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    instrumentedClasspath(project(path: ":producer", configuration: 'instrumentedJars'))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    instrumentedClasspath(project(mapOf(
        "path" to ":producer",
        "configuration" to "instrumentedJars")))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果计划发布具有此依赖关系的组件， <em>则不建议</em>声明对显式目标配置的依赖关系：这可能会导致元数据损坏。如果需要在远程存储库上发布组件，请遵循可识别<a href="#sec:variant-aware-sharing">变体的交叉发布文档中的说明</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下，我们将依赖项添加到<em>instrumentedClasspath</em>配置中，这是<em>消费者特定的配置</em> 。在Gradle术语中，这称为<a href="#sec:resolvable-consumable-configs">可解析配置</a> ，其定义方式如下：</p>
</div>
<div class="exampleblock">
<div class="title">示例132在使用者上声明可解析的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    instrumentedClasspath {
        canBeConsumed = false
        canBeResolved = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val instrumentedClasspath by configurations.creating {
    isCanBeConsumed = false
    isCanBeResolved = true
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:variant-aware-sharing"><a class="anchor" href="#sec:variant-aware-sharing"></a> <a class="link" href="#sec:variant-aware-sharing">项目之间工件的变体感知共享</a></h3>
<div class="paragraph">
<p>在<a href="#sec:simple-sharing-artifacts-between-projects">简单的共享解决方案中</a> ，我们在生产者端定义了一个配置，用作生产者和消费者之间的工件交换。但是，使用者必须明确指出它所依赖的配置，这是我们在<em>变体感知分辨率下</em>要避免的配置。实际上，我们还<a href="#understanding-variant-selection">解释了</a> ，消费者可以使用<em>属性</em>来表达需求，而生产者也应该使用<em>属性</em>来提供适当的输出变体。这样可以进行更明智的选择，因为使用单个依赖项声明，而无需任何明确的目标配置，使用者可以解决不同的问题。典型的示例是使用单个依赖项声明<code>project(":myLib")</code> ，我们要么选择<code>arm64</code>要么<code>i386</code>版本<code>myLib</code>取决于架构。</p>
</div>
<div class="paragraph">
<p>为此，我们将向消费者和生产者添加属性。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>重要的是要了解，一旦配置具有属性，它们便会参与<em>变体感知的解析</em> ，这意味着只要有<em>任何</em>类似的符号<code>project(":myLib")</code>用来。换句话说，在生产者上设置的属性<em>必须与在同一项目上生产的其他变体一致</em> 。他们尤其不能为现有选择引入歧义。</p>
</div>
<div class="paragraph">
<p>实际上，这意味着在您创建的配置上使用的属性集可能取决于所使用的<em>生态系统</em> （Java，C ++，...），因为这些生态系统的相关插件通常使用不同的属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>让我们增强前面的示例，它恰好是一个Java库项目。Java库向使用者提供了几种变体， <code>apiElements</code>和<code>runtimeElements</code> 。现在，我们要添加第三个<code>instrumentedJars</code> 。</p>
</div>
<div class="paragraph">
<p>因此，我们需要了解新变体的用途，以便在其上设置适当的属性。让我们看一下我们在<code>runtimeElements</code>组态：</p>
</div>
<div class="listingblock">
<div class="title">gradle OutboundVariants --variant runtimeElements</div>
<div class="content">
<pre class="prettyprint highlight"><code>Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 11
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-runtime</code></pre>
</div>
</div>
<div class="paragraph">
<p>它告诉我们的是Java库插件产生具有5个属性的变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.category</code>告诉我们，此变体代表一个<em>库</em></p>
</li>
<li>
<p><code>org.gradle.dependency.bundling</code>告诉我们，此变体的依赖项以jar形式找到（例如，它们没有在jar中重新包装）</p>
</li>
<li>
<p><code>org.gradle.jvm.version</code>告诉我们该库支持的最低Java版本是Java 11</p>
</li>
<li>
<p><code>org.gradle.libraryelements</code>告诉我们此变体包含在jar中找到的所有元素（类和资源）</p>
</li>
<li>
<p><code>org.gradle.usage</code>表示此变体是Java运行时，因此既适用于Java编译器，也适用于运行时</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，如果我们希望在执行测试时使用我们的工具化类代替此变量，则需要将类似的属性附加到变量中。实际上，我们关心的属性是<code>org.gradle.libraryelements</code>解释<em>了变体包含的内容</em> ，因此我们可以通过以下方式设置变体：</p>
</div>
<div class="exampleblock">
<div class="title">示例133声明变量属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    instrumentedJars {
        canBeConsumed = true
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, JavaVersion.current().majorVersion.toInteger())
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, 'instrumented-jar'))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val instrumentedJars by configurations.creating {
    isCanBeConsumed = true
    isCanBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, namedAttribute(Category.LIBRARY))
        attribute(Usage.USAGE_ATTRIBUTE, namedAttribute(Usage.JAVA_RUNTIME))
        attribute(Bundling.BUNDLING_ATTRIBUTE, namedAttribute(Bundling.EXTERNAL))
        attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, JavaVersion.current().majorVersion.toInt())
        attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, namedAttribute("instrumented-jar"))
    }
}

inline fun &lt;reified T: Named&gt; Project.namedAttribute(value: String) = objects.named(T::class.java, value)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>选择正确的属性进行设置是此过程中最困难的事情，因为它们具有变体的语义。因此，在添加<em>新属性</em>之前，您应该始终询问自己是否没有一个可以承载所需语义的属性。如果没有，则可以添加一个新属性。添加新属性时，还必须小心，因为在选择过程中可能会产生歧义。通常，添加属性意味着将其添加到<em>所有</em>现有变体中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们在这里所做的是，我们添加了一个<em>新的</em>变体，可以<em>在运行时</em>使用它，但它包含检测类而不是普通类。但是，现在这意味着对于运行时，使用者必须在两个变体之间进行选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>runtimeElements</code> ，是由<code>java-library</code>插入</p>
</li>
<li>
<p><code>instrumentedJars</code> ，我们创建的变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>特别要说的是，我们要在测试运行时类路径上插入检测后的类。现在，我们可以在使用者上将我们的依赖项声明为常规项目依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">实施例134。声明项目依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    testImplementation 'junit:junit:4.12'
    testImplementation project(':producer')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    testImplementation("junit:junit:4.12")
    testImplementation(project(":producer"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们在这里停止，Gradle仍会选择<code>runtimeElements</code>替代我们的变体<code>instrumentedJars</code>变体。这是因为<code>testRuntimeClasspath</code>配置要求配置<code>libraryelements</code>属性是<code>jar</code> ，以及我们的新产品<code>instrumented-jars</code>值<em>不兼容</em> 。</p>
</div>
<div class="paragraph">
<p>因此，我们需要更改请求的属性，以便现在查找已检测的罐子：</p>
</div>
<div class="exampleblock">
<div class="title">示例135更改消费者属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">configurations {
    testRuntimeClasspath {
        attributes {
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, 'instrumented-jar'))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">configurations {
    testRuntimeClasspath {
        attributes {
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements::class.java, "instrumented-jar"))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们告诉我们，每当要解析测试运行时类路径时，我们正在寻找的是<em>插补类</em> 。但是，有一个问题：在我们的依赖项列表中，我们有JUnit，很明显，它<em>没有进行</em>检测。因此，如果我们在这里停下来，Gradle将会失败，并说明没有提供已检测类的JUnit变体。这是因为我们没有解释说，如果没有可用的工具版本，则使用常规jar很好。为此，我们需要编写一个<em>兼容性规则</em> ：</p>
</div>
<div class="exampleblock">
<div class="title">实施例136。相容性规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class InstrumentedJarsRule implements AttributeCompatibilityRule&lt;LibraryElements&gt; {

    @Override
    void execute(CompatibilityCheckDetails&lt;LibraryElements&gt; details) {
        if (details.consumerValue.name == 'instrumented-jar' &amp;&amp; details.producerValue.name == 'jar') {
            details.compatible()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">open class InstrumentedJarsRule: AttributeCompatibilityRule&lt;LibraryElements&gt; {

    override fun execute(details: CompatibilityCheckDetails&lt;LibraryElements&gt;) = details.run {
        if (consumerValue?.name == "instrumented-jar" &amp;&amp; producerValue?.name == "jar") {
            compatible()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们需要在属性模式上声明：</p>
</div>
<div class="exampleblock">
<div class="title">实施例137。利用兼容性规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    attributesSchema {
        attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE) {
            compatibilityRules.add(InstrumentedJarsRule)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    attributesSchema {
        attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE) {
            compatibilityRules.add(InstrumentedJarsRule::class.java)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就是这样！现在我们有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加了一个提供仪器罐子的变体</p>
</li>
<li>
<p>解释说，此变体可以替代运行时</p>
</li>
<li>
<p>解释说，使用者<em>仅在测试运行时</em>需要此变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，Gradle提供了一种强大的机制，可以根据偏好和兼容性选择正确的变体。可以<a href="#">在文档的“了解变体的插件”部分中</a>找到更多详细信息。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>通过像我们一样向现有属性添加值，或通过定义新属性，我们可以扩展模型。这意味着<em>所有消费者</em>都必须了解此扩展模型。对于本地使用者，这通常不是问题，因为所有项目都理解并共享相同的模式，但是如果您必须将此新变体发布到外部存储库，则意味着外部使用者必须为其构建添加相同的规则他们通过。对于<em>生态系统插件</em> （例如Kotlin插件）而言，这通常不是问题，在任何情况下，如果不应用插件就无法消费，但是如果添加自定义值或属性，则是一个问题。</p>
</div>
<div class="paragraph">
<p>因此， <strong>避免发布</strong>仅用于内部使用的<strong>自定义变体</strong> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="targeting-different-platforms"><a class="anchor" href="#targeting-different-platforms"></a> <a class="link" href="#targeting-different-platforms">定位不同的平台</a></h3>
<div class="paragraph">
<p>库针对不同平台的情况很常见。在Java生态系统中，我们经常看到同一库的不同工件，以不同的<em>分类器进行</em>区分。一个典型的例子是番石榴，其发布方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>guava-jre</code>适用于JDK 8及更高版本</p>
</li>
<li>
<p><code>guava-android</code>对于JDK 7</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种方法的问题是没有与分类器相关的语义。特别是，依赖项解析引擎无法根据用户需求自动确定要使用哪个版本。例如，最好表示您对Guava有依赖性，然后让引擎在<code>jre</code>和<code>android</code>基于什么兼容。</p>
</div>
<div class="paragraph">
<p>Gradle为此提供了一种改进的模型，它没有分类器的弱点：属性。</p>
</div>
<div class="paragraph">
<p>特别是在Java生态系统中，Gradle提供了一个内置属性，库作者可以使用该属性来表达与Java生态系统的兼容性： <code>org.gradle.jvm.version</code> 。此属性表示<em>使用者必须具备</em>的<em>最低版本才能正常工作</em> 。</p>
</div>
<div class="paragraph">
<p>当您应用<code>java</code>要么<code>java-library</code>插件，Gradle会自动将此属性与即将发布的变体相关联。这意味着，所有使用Gradle发布的库都会自动告知它们使用的目标平台。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>org.gradle.jvm.version</code>设置为源集的<em>目标兼容性</em> 。</p>
</div>
<div class="paragraph">
<p>自动设置此属性后，默认情况下，Gradle <em>不会</em>允许您为不同的JVM构建项目。如果需要执行此操作，则需要<a href="#sec:variant-aware-sharing">按照有关变体感知匹配</a>的<a href="#sec:variant-aware-sharing">说明</a>创建其他变体。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">Gradle的未来版本将提供自动为不同Java平台构建的方法。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:abm_artifact_transforms"><a class="anchor" href="#sec:abm_artifact_transforms"></a> <a class="link" href="#sec:abm_artifact_transforms">转换解决方案上的依赖工件</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>如在<a href="#sec:resolvable-consumable-configs">不同类型的配置中所述</a> ，对于相同的依赖项可能有不同的变体。例如，外部Maven依赖项具有一个变体，在针对依赖项进行编译时应使用该变体（ <code>java-api</code> ），以及用于运行使用依赖项的应用程序的变体（ <code>java-runtime</code> ）。项目依赖项甚至有更多的变体，例如，用于编译的项目类可作为类目录使用（ <code>org.gradle.usage=java-api, org.gradle.libraryelements=classes</code> ）或JAR（ <code>org.gradle.usage=java-api, org.gradle.libraryelements=jar</code> ）。</p>
</div>
<div class="paragraph">
<p>依赖项的变体在其传递性依赖项或工件本身中可能有所不同。例如， <code>java-api</code>和<code>java-runtime</code> Maven依赖项的变体仅在传递性依赖项上有所不同，并且都使用相同的工件-JAR文件。对于项目依赖性， <code>java-api,classes</code>和<code>java-api,jars</code>变体具有相同的传递依赖关系和不同的工件-分别是class目录和JAR文件。</p>
</div>
<div class="paragraph">
<p>Gradle通过<a href="#sec:abm_configuration_attributes">属性</a>集唯一地识别依赖项的变体。的<code>java-api</code>依赖项的变体是由<code>org.gradle.usage</code>具有价值的属性<code>java-api</code> 。</p>
</div>
<div class="paragraph">
<p>当Gradle解析配置时，解析的配置上的<a href="#sec:abm_configuration_attributes">属性</a>将确定<em>请求的属性</em> 。对于配置中的所有依赖关系，在解析配置时都会选择具有请求属性的变量。例如，当配置请求<code>org.gradle.usage=java-api, org.gradle.libraryelements=classes</code>在项目依赖项上，然后选择classes目录作为工件。</p>
</div>
<div class="paragraph">
<p>如果依赖项没有具有所请求属性的变量，则解析配置失败。有时可以在不更改传递依赖项的情况下将依赖项的工件转换为请求的变体。例如，解压缩JAR会转换<code>java-api,jars</code>变入<code>java-api,classes</code>变体。这种转换称为“ <em>伪影转换”</em> 。Gradle允许注册工件转换，并且当依赖项没有所请求的变体时，Gradle将尝试查找一系列工件转换以创建变体。</p>
</div>
<div class="sect2">
<h3 id="artifact_transform_selection_and_execution"><a class="anchor" href="#artifact_transform_selection_and_execution"></a> <a class="link" href="#artifact_transform_selection_and_execution">工件转换选择和执行</a></h3>
<div class="paragraph">
<p>如上所述，当Gradle解析配置并且配置中的依存关系不具有带有所请求属性的变体时，Gradle会尝试查找一系列工件转换以创建变体。查找伪像变换的匹配链的过程称为<em>伪像变换选择</em> 。每个注册的转换都从一组属性转换为一组属性。例如，解压缩转换可以从<code>org.gradle.usage=java-api, org.gradle.libraryelements=jars</code>至<code>org.gradle.usage=java-api, org.gradle.libraryelements=classes</code> 。</p>
</div>
<div class="paragraph">
<p>为了找到一条链，Gradle从请求的属性开始，然后将所有修改某些请求的属性的转换视为通向那里的可能路径。倒退，Gradle尝试使用转换获取到某些现有变体的路径。</p>
</div>
<div class="paragraph">
<p>例如，考虑一个<code>minified</code>具有两个值的属性： <code>true</code>和<code>false</code> 。minified属性表示依赖项的变体，其中删除了不必要的类文件。已注册了工件转换，可以进行转换<code>minified</code>从<code>false</code>至<code>true</code> 。什么时候<code>minified=true</code>被要求提供依赖性，并且只有带有<code>minified=false</code> ，然后Gradle选择注册的缩小变换。minify转换能够转换依赖项的伪像<code>minified=false</code>与神器<code>minified=true</code> 。</p>
</div>
<div class="paragraph">
<p>在找到的所有变换链中，Gradle尝试选择最佳的变换链：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果只有一个转换链，则选择它。</p>
</li>
<li>
<p>如果有两个变换链，并且一个是另一个的后缀，则将其选中。</p>
</li>
<li>
<p>如果存在最短的变换链，则将其选中。</p>
</li>
<li>
<p>在所有其他情况下，选择将失败并报告错误。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>当已经存在与请求属性匹配的依赖项变体时，Gradle不会尝试选择工件转换。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>artifactType</code>属性是特殊的，因为它仅存在于解析的工件上，而不存在于依赖项上。结果，任何仅变异的变换<code>artifactType</code>仅使用<code>artifactType</code>根据要求的属性。仅在使用<a href="../javadoc/org/gradle/api/artifacts/ArtifactView.html">ArtifactView</a>时才考虑使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>选择所需的工件变换后，Gradle会解析链中初始变换所需的依赖项变体。通过下载外部依赖项或执行生成工件的任务，Gradle完成解决变体的工件后，Gradle便开始使用选定的工件转换链来转换变体的工件。Gradle在可能的情况下并行执行变换链。</p>
</div>
<div class="paragraph">
<p>拿起上面的minify示例，考虑具有两个依赖关系的配置，外部<code>guava</code>依赖和项目依赖<code>producer</code>项目。该配置具有属性<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true</code> 。外部<code>guava</code>依赖项有两个变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code>和</p>
</li>
<li>
<p><code>org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用minify变换，Gradle可以转换变体<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code>的<code>guava</code>至<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true</code> ，这是请求的属性。项目依赖项还具有变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code> ，</p>
</li>
<li>
<p><code>org.gradle.usage=java-runtime,org.gradle.libraryelements=classes,minified=false</code> ，</p>
</li>
<li>
<p><code>org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false</code> ，</p>
</li>
<li>
<p><code>org.gradle.usage=java-api,org.gradle.libraryelements=classes,minified=false</code></p>
</li>
<li>
<p>还有一些。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>同样，使用minify变换，Gradle可以转换变体<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code>项目的<code>producer</code>至<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true</code> ，这是请求的属性。</p>
</div>
<div class="paragraph">
<p>解决配置后，Gradle需要下载<code>guava</code> JAR并将其最小化。Gradle还需要执行<code>producer:jar</code>任务来生成项目的JAR工件，然后将其最小化。下载和缩小<code>guava.jar</code>与执行并行<code>producer:jar</code>任务和生成的JAR的缩小。</p>
</div>
<div class="paragraph">
<p>这是设置方法<code>minified</code>属性，以便上面的作品。您需要在模式中注册新属性，将其添加到所有JAR工件中，并在所有可解析配置中请求它。</p>
</div>
<div class="exampleblock">
<div class="title">实施例138。工件转换属性设置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def artifactType = Attribute.of('artifactType', String)
def minified = Attribute.of('minified', Boolean)
dependencies {
    attributesSchema {
        attribute(minified)                      // <b class="conum">(1)</b>
    }
    artifactTypes.getByName("jar") {
        attributes.attribute(minified, false)    // <b class="conum">(2)</b>
    }
}

configurations.all {
    afterEvaluate {
        if (canBeResolved) {
            attributes.attribute(minified, true) // <b class="conum">(3)</b>
        }
    }
}

dependencies {
    registerTransform(Minify) {
        from.attribute(minified, false).attribute(artifactType, "jar")
        to.attribute(minified, true).attribute(artifactType, "jar")
    }
}

dependencies {                                 // <b class="conum">(4)</b>
    implementation('com.google.guava:guava:27.1-jre')
    implementation(project(':producer'))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val artifactType = Attribute.of("artifactType", String::class.java)
val minified = Attribute.of("minified", Boolean::class.javaObjectType)
dependencies {
    attributesSchema {
        attribute(minified)                      // <b class="conum">(1)</b>
    }
    artifactTypes.getByName("jar") {
        attributes.attribute(minified, false)    // <b class="conum">(2)</b>
    }
}

configurations.all {
    afterEvaluate {
        if (isCanBeResolved) {
            attributes.attribute(minified, true) // <b class="conum">(3)</b>
        }
    }
}

dependencies {
    registerTransform(Minify::class) {
        from.attribute(minified, false).attribute(artifactType, "jar")
        to.attribute(minified, true).attribute(artifactType, "jar")
    }
}

dependencies {                                 // <b class="conum">(4)</b>
    implementation("com.google.guava:guava:27.1-jre")
    implementation(project(":producer"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>将属性添加到架构</p>
</li>
<li>
<p>未缩小所有JAR文件</p>
</li>
<li>
<p>请求<code>minified=true</code>在所有可解析的配置上</p>
</li>
<li>
<p>添加将要转换的依赖项</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在，您可以看到运行我们的<code>resolveRuntimeClasspath</code>解决的任务<code>runtimeClasspath</code>组态。观察到Gradle在转换项目依赖项之前<code>resolveRuntimeClasspath</code>任务开始。Gradle执行以下命令时会转换二进制依赖项<code>resolveRuntimeClasspath</code>任务。</p>
</div>
<div class="listingblock">
<div class="title">解决runtimeClasspath配置时的输出</div>
<div class="content">
<pre>&gt; gradle resolveRuntimeClasspath

&gt; Task :producer:compileJava
&gt; Task :producer:processResources NO-SOURCE
&gt; Task :producer:classes
&gt; Task :producer:jar

&gt; Transform artifact producer.jar (project :producer) with Minify
Nothing to minify - using producer.jar unchanged

&gt; Task :resolveRuntimeClasspath
Minifying guava-27.1-jre.jar
Nothing to minify - using listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar unchanged
Nothing to minify - using jsr305-3.0.2.jar unchanged
Nothing to minify - using checker-qual-2.5.2.jar unchanged
Nothing to minify - using error_prone_annotations-2.2.0.jar unchanged
Nothing to minify - using j2objc-annotations-1.1.jar unchanged
Nothing to minify - using animal-sniffer-annotations-1.17.jar unchanged
Nothing to minify - using failureaccess-1.0.1.jar unchanged

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:implementing-artifact-transforms"><a class="anchor" href="#sec:implementing-artifact-transforms"></a> <a class="link" href="#sec:implementing-artifact-transforms">实现工件转换</a></h3>
<div class="paragraph">
<p>与任务类型类似，工件转换由一个动作和一些参数组成。与自定义任务类型的主要区别在于，操作和参数被实现为两个单独的类。</p>
</div>
<div class="paragraph">
<p>工件转换动作的实现是实现<a href="../dsl/org.gradle.api.artifacts.transform.TransformAction.html">TransformAction</a>的类。您需要实施<code>transform()</code>动作上的方法，它将输入伪像转换为零，一个或多个输出伪像。大多数伪像转换将是一对一的，因此transform方法会将输入伪像转换为恰好一个输出伪像。</p>
</div>
<div class="paragraph">
<p>工件转换动作的实现需要通过调用<a href="../dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:dir(java.lang.Object)">TransformOutputs.dir（）</a>或<a href="../dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:file(java.lang.Object)">TransformOutputs.file（）</a>来注册每个输出工件。</p>
</div>
<div class="paragraph">
<p>您只能提供两种类型的路径<code>dir</code>要么<code>file</code>方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>输入工件或输入工件中（输入目录）的绝对路径。</p>
</li>
<li>
<p>相对路径。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle使用绝对路径作为输出工件的位置。例如，如果输入工件是爆炸的WAR，则变换动作可以调用<code>TransformOutputs.file()</code>对于中的所有jar文件<code>WEB-INF/lib</code>目录。转换的输出将是Web应用程序的库JAR。</p>
</div>
<div class="paragraph">
<p>对于相对路径， <code>dir()</code>要么<code>file()</code>方法将工作空间返回到变换操作。转换动作的实现需要在提供的工作空间的位置处创建转换后的工件。</p>
</div>
<div class="paragraph">
<p>输出工件按注册顺序替换了转换后的变体中的输入工件。例如，如果配置包含工件<code>lib1.jar</code> ， <code>lib2.jar</code> ， <code>lib3.jar</code> ，并且变换操作会注册一个缩小的输出工件<code><artifact-name>-min.jar</code>对于输入工件，则转换后的配置包含工件<code>lib1-min.jar</code> ， <code>lib2-min.jar</code>和<code>lib3-min.jar</code> 。</p>
</div>
<div class="paragraph">
<p>这是一个<code>Unzip</code> transform通过解压缩将JAR文件转换为类目录。的<code>Unzip</code>转换不需要任何参数。注意实现如何使用<code>@InputArtifact</code>注入工件以转化为动作。它使用来请求解压缩类的目录<code>TransformOutputs.dir()</code>然后将JAR文件解压缩到该目录中。</p>
</div>
<div class="exampleblock">
<div class="title">示例139没有参数的工件转换</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Unzip implements TransformAction&lt;TransformParameters.None&gt; { // <b class="conum">(1)</b>
    @InputArtifact                                                          // <b class="conum">(2)</b>
    abstract Provider&lt;FileSystemLocation&gt; getInputArtifact()

    @Override
    void transform(TransformOutputs outputs) {
        def input = inputArtifact.get().asFile
        def unzipDir = outputs.dir(input.name)                              // <b class="conum">(3)</b>
        unzipTo(input, unzipDir)                                            // <b class="conum">(4)</b>
    }

    private static void unzipTo(File zipFile, File unzipDir) {
        // implementation...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">abstract class Unzip : TransformAction&lt;TransformParameters.None&gt; {          // <b class="conum">(1)</b>
    @get:InputArtifact                                                      // <b class="conum">(2)</b>
    abstract val inputArtifact: Provider&lt;FileSystemLocation&gt;

    override
    fun transform(outputs: TransformOutputs) {
        val input = inputArtifact.get().asFile
        val unzipDir = outputs.dir(input.name)                              // <b class="conum">(3)</b>
        unzipTo(input, unzipDir)                                            // <b class="conum">(4)</b>
    }

    private fun unzipTo(zipFile: File, unzipDir: File) {
        // implementation...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用<code>TransformParameters.None</code>如果转换不使用参数</p>
</li>
<li>
<p>注入输入工件</p>
</li>
<li>
<p>请求解压缩文件的输出位置</p>
</li>
<li>
<p>做转换的实际工作</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>工件转换可能需要参数，例如<code>String</code>确定用于支持输入工件转换的某些过滤器或文件集合。为了将这些参数传递给转换动作，您需要使用所需参数定义一个新类型。该类型需要实现标记接口<a href="../javadoc/org/gradle/api/artifacts/transform/TransformParameters.html">TransformParameters</a> 。必须使用<a href="custom_gradle_types.html#managed_properties">托管属性</a>来表示参数，并且参数类型必须是<a href="custom_gradle_types.html#managed_types">托管类型</a> 。您可以使用接口或抽象类声明getter，然后Gradle将生成实现。所有吸气剂都需要具有正确的输入注释，请参阅“ <a href="more_about_tasks.html#table:incremental_build_annotations">增量构建</a> ”部分中的表。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="custom_gradle_types.html#custom_gradle_types">开发自定义Gradle类型中</a>找到有关实现工件转换参数的更多信息。</p>
</div>
<div class="paragraph">
<p>这是一个的实现<code>Minify</code>仅保留某些类，从而使JAR变小的转换。的<code>Minify</code> transform需要将类保留为参数。观察如何通过以下方式获取参数<code>TransformAction.getParameters()</code>在里面<code>transform()</code>方法。实施<code>transform()</code>方法通过使用来为缩小的JAR请求位置<code>TransformOutputs.file()</code>然后在此位置创建缩小的JAR。</p>
</div>
<div class="exampleblock">
<div class="title">例子140。缩小转换实施</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class Minify implements TransformAction&lt;Parameters&gt; { // <b class="conum">(1)</b>
    interface Parameters extends TransformParameters {         // <b class="conum">(2)</b>
        @Input
        Map&lt;String, Set&lt;String&gt;&gt; getKeepClassesByArtifact()
        void setKeepClassesByArtifact(Map&lt;String, Set&lt;String&gt;&gt; keepClasses)
    }

    @PathSensitive(PathSensitivity.NAME_ONLY)
    @InputArtifact
    abstract Provider&lt;FileSystemLocation&gt; getInputArtifact()

    @Override
    void transform(TransformOutputs outputs) {
        def fileName = inputArtifact.get().asFile.name
        for (entry in parameters.keepClassesByArtifact) {      // <b class="conum">(3)</b>
            if (fileName.startsWith(entry.key)) {
                def nameWithoutExtension = fileName.substring(0, fileName.length() - 4)
                minify(inputArtifact.get().asFile, entry.value, outputs.file("${nameWithoutExtension}-min.jar"))
                return
            }
        }
        println "Nothing to minify - using ${fileName} unchanged"
        outputs.file(inputArtifact)                            // <b class="conum">(4)</b>
    }

    private void minify(File artifact, Set&lt;String&gt; keepClasses, File jarFile) {
        println "Minifying ${artifact.name}"
        // Implementation ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">abstract class Minify : TransformAction&lt;Minify.Parameters&gt; {   // <b class="conum">(1)</b>
    interface Parameters : TransformParameters {               // <b class="conum">(2)</b>
        @get:Input
        var keepClassesByArtifact: Map&lt;String, Set&lt;String&gt;&gt;

    }

    @get:PathSensitive(PathSensitivity.NAME_ONLY)
    @get:InputArtifact
    abstract val inputArtifact: Provider&lt;FileSystemLocation&gt;

    override
    fun transform(outputs: TransformOutputs) {
        val fileName = inputArtifact.get().asFile.name
        for (entry in parameters.keepClassesByArtifact) {      // <b class="conum">(3)</b>
            if (fileName.startsWith(entry.key)) {
                val nameWithoutExtension = fileName.substring(0, fileName.length - 4)
                minify(inputArtifact.get().asFile, entry.value, outputs.file("${nameWithoutExtension}-min.jar"))
                return
            }
        }
        println("Nothing to minify - using ${fileName} unchanged")
        outputs.file(inputArtifact)                            // <b class="conum">(4)</b>
    }

    private fun minify(artifact: File, keepClasses: Set&lt;String&gt;, jarFile: File) {
        println("Minifying ${artifact.name}")
        // Implementation ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>声明参数类型</p>
</li>
<li>
<p>转换参数接口</p>
</li>
<li>
<p>使用参数</p>
</li>
<li>
<p>当不需要缩小时使用不变的输入工件</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请记住，输入工件是一个依赖项，它可能具有自己的依赖项。如果您的工件转换需要访问这些传递依赖项，则可以声明一个抽象getter返回一个<code>FileCollection</code>并使用<a href="../javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html">@InputArtifactDependencies</a>对其进行<a href="../javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html">注释</a> 。运行转换时，Gradle会将可传递依赖项注入<code>FileCollection</code>通过实现getter实现属性。请注意，在转换中使用输入工件依赖项会影响性能，只有在确实需要它们时才注入它们。</p>
</div>
<div class="paragraph">
<p>此外，工件转换可以将<a href="build_cache.html#build_cache">构建缓存</a>用于其输出。要为构件转换启用构建缓存，请添加<code>@<a href="../javadoc/org/gradle/api/artifacts/transform/CacheableTransform.html">CacheableTransform</a></code>动作类上的注释。对于可缓存的转换，必须使用规范化注释（例如<a href="../javadoc/org/gradle/api/tasks/PathSensitive.html">@PathSensitive）</a>注释其<a href="../javadoc/org/gradle/api/artifacts/transform/InputArtifact.html">@InputArtifact</a>属性-以及所有标记有<a href="../javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html">@InputArtifactDependencies的</a>属性。</p>
</div>
<div class="paragraph">
<p>下面的示例显示一个更复杂的转换。它将JAR的某些选定类移动到不同的包，并使用移动的类重写类和所有类的字节码（类重定位）。为了确定要重定位的类，它查看输入工件的包和输入工件的依赖项。它还不会在外部类路径中重新放置JAR文件中包含的包。</p>
</div>
<div class="exampleblock">
<div class="title">实施例141。用于类重定位的工件转换</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CacheableTransform                                                          // <b class="conum">(1)</b>
abstract class ClassRelocator implements TransformAction&lt;Parameters&gt; {
    interface Parameters extends TransformParameters {                       // <b class="conum">(2)</b>
        @CompileClasspath                                                    // <b class="conum">(3)</b>
        ConfigurableFileCollection getExternalClasspath()
        @Input
        Property&lt;String&gt; getExcludedPackage()
    }

    @Classpath                                                               // <b class="conum">(4)</b>
    @InputArtifact
    abstract Provider&lt;FileSystemLocation&gt; getPrimaryInput()

    @CompileClasspath
    @InputArtifactDependencies                                               // <b class="conum">(5)</b>
    abstract FileCollection getDependencies()

    @Override
    void transform(TransformOutputs outputs) {
        def primaryInputFile = primaryInput.get().asFile
        if (parameters.externalClasspath.contains(primaryInput)) {           // <b class="conum">(6)</b>
            outputs.file(primaryInput)
        } else {
            def baseName = primaryInputFile.name.substring(0, primaryInputFile.name.length - 4)
            relocateJar(outputs.file("$baseName-relocated.jar"))
        }
    }

    private relocateJar(File output) {
        // implementation...
        def relocatedPackages = (dependencies.collectMany { readPackages(it) } + readPackages(primaryInput.get().asFile)) as Set
        def nonRelocatedPackages = parameters.externalClasspath.collectMany { readPackages(it) }
        def relocations = (relocatedPackages - nonRelocatedPackages).collect { packageName -&gt;
            def toPackage = "relocated.$packageName"
            println("$packageName -&gt; $toPackage")
            new Relocation(packageName, toPackage)
        }
        new JarRelocator(primaryInput.get().asFile, output, relocations).run()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">@CacheableTransform                                                          // <b class="conum">(1)</b>
abstract class ClassRelocator : TransformAction&lt;ClassRelocator.Parameters&gt; {
    interface Parameters : TransformParameters {                             // <b class="conum">(2)</b>
        @get:CompileClasspath                                                // <b class="conum">(3)</b>
        val externalClasspath: ConfigurableFileCollection
        @get:Input
        val excludedPackage: Property&lt;String&gt;
    }

    @get:Classpath                                                           // <b class="conum">(4)</b>
    @get:InputArtifact
    abstract val primaryInput: Provider&lt;FileSystemLocation&gt;

    @get:CompileClasspath
    @get:InputArtifactDependencies                                           // <b class="conum">(5)</b>
    abstract val dependencies: FileCollection

    override
    fun transform(outputs: TransformOutputs) {
        val primaryInputFile = primaryInput.get().asFile
        if (parameters.externalClasspath.contains(primaryInputFile)) {       // <b class="conum">(6)</b>
            outputs.file(primaryInput)
        } else {
            val baseName = primaryInputFile.name.substring(0, primaryInputFile.name.length - 4)
            relocateJar(outputs.file("$baseName-relocated.jar"))
        }
    }

    private fun relocateJar(output: File) {
        // implementation...
        val relocatedPackages = (dependencies.flatMap { it.readPackages() } + primaryInput.get().asFile.readPackages()).toSet()
        val nonRelocatedPackages = parameters.externalClasspath.flatMap { it.readPackages() }
        val relocations = (relocatedPackages - nonRelocatedPackages).map { packageName -&gt;
            val toPackage = "relocated.$packageName"
            println("$packageName -&gt; $toPackage")
            Relocation(packageName, toPackage)
        }
        JarRelocator(primaryInput.get().asFile, output, relocations).run()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>声明可缓存的转换</p>
</li>
<li>
<p>转换参数接口</p>
</li>
<li>
<p>声明每个参数的输入类型</p>
</li>
<li>
<p>声明输入工件的规范化</p>
</li>
<li>
<p>注入输入工件依赖项</p>
</li>
<li>
<p>使用参数</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="registering_artifact_transforms"><a class="anchor" href="#registering_artifact_transforms"></a> <a class="link" href="#registering_artifact_transforms">注册工件转换</a></h3>
<div class="paragraph">
<p>您需要注册工件转换操作，并在必要时提供参数，以便在解析依赖项时可以选择它们。</p>
</div>
<div class="paragraph">
<p>为了注册工件转换，您必须在内部使用<a href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:registerTransform(java.lang.Class, org.gradle.api.Action)">registerTransform（）</a> <code>dependencies {}</code>块。</p>
</div>
<div class="paragraph">
<p>使用时有几点要考虑<code>registerTransform()</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>from</code>和<code>to</code>属性是必需的。</p>
</li>
<li>
<p>转换操作本身可以具有配置选项。您可以使用<code>parameters {}</code>块。</p>
</li>
<li>
<p>您必须在具有将要解决的配置的项目上注册转换。</p>
</li>
<li>
<p>您可以提供任何实现<a href="../dsl/org.gradle.api.artifacts.transform.TransformAction.html">TransformAction的</a>类型给<code>registerTransform()</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，假设您想解压缩一些依赖项并将解压缩的目录和文件放在类路径中。您可以通过注册一种类型的工件转换操作来实现<code>Unzip</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">实施例142。没有参数的伪像转换配准</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def artifactType = Attribute.of('artifactType', String)

dependencies {
    registerTransform(Unzip) {
        from.attribute(artifactType, 'jar')
        to.attribute(artifactType, 'java-classes-directory')
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val artifactType = Attribute.of("artifactType", String::class.java)

dependencies {
    registerTransform(Unzip::class) {
        from.attribute(artifactType, "jar")
        to.attribute(artifactType, "java-classes-directory")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另一个例子是，您只想保留一些JAR就可以使其最小化<code>class</code>他们的文件。注意使用<code>parameters {}</code>块提供类以保留最小的JAR到<code>Minify</code>转变。</p>
</div>
<div class="exampleblock">
<div class="title">示例143。带参数的伪像转换配准</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def artifactType = Attribute.of('artifactType', String)
def minified = Attribute.of('minified', Boolean)
def keepPatterns = [
    "guava": [
        "com.google.common.base.Optional",
        "com.google.common.base.AbstractIterator"
    ] as Set
]


dependencies {
    registerTransform(Minify) {
        from.attribute(minified, false).attribute(artifactType, "jar")
        to.attribute(minified, true).attribute(artifactType, "jar")

        parameters {
            keepClassesByArtifact = keepPatterns
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val artifactType = Attribute.of("artifactType", String::class.java)
val minified = Attribute.of("minified", Boolean::class.javaObjectType)
val keepPatterns = mapOf(
    "guava" to setOf(
        "com.google.common.base.Optional",
        "com.google.common.base.AbstractIterator"
    )
)


dependencies {
    registerTransform(Minify::class) {
        from.attribute(minified, false).attribute(artifactType, "jar")
        to.attribute(minified, true).attribute(artifactType, "jar")

        parameters {
            keepClassesByArtifact = keepPatterns
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="implementing_incremental_artifact_transforms"><a class="anchor" href="#implementing_incremental_artifact_transforms"></a> <a class="link" href="#implementing_incremental_artifact_transforms">实施增量工件转换</a></h3>
<div class="paragraph">
<p>与<a href="custom_tasks.html#incremental_tasks">增量任务</a>类似，工件转换可以通过仅处理上次执行后更改的文件来避免工作。这是通过使用<a href="../dsl/org.gradle.work.InputChanges.html">InputChanges</a>接口完成的。对于工件转换，只有输入工件是增量输入，因此转换只能查询那里的更改。为了在转换动作中使用<a href="../dsl/org.gradle.work.InputChanges.html">InputChanges</a> ，请将其注入到动作中。有关如何使用<a href="../dsl/org.gradle.work.InputChanges.html">InputChanges的</a>更多信息，请参见有关<a href="custom_tasks.html#incremental_tasks">增量任务</a>的相应文档。</p>
</div>
<div class="paragraph">
<p>这是一个增量转换的示例，它计算Java源文件中的代码行：</p>
</div>
<div class="exampleblock">
<div class="title">实施例144。用于代码行计数的工件转换</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">abstract class CountLoc implements TransformAction&lt;TransformParameters.None&gt; {

    @Inject
    abstract InputChanges getInputChanges()

    @PathSensitive(PathSensitivity.RELATIVE)
    @InputArtifact
    abstract Provider&lt;FileSystemLocation&gt; getInput()

    @Override
    void transform(TransformOutputs outputs) {                          // <b class="conum">(1)</b>
        def outputDir = outputs.dir("${input.get().asFile.name}.loc")
        println("Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.incremental}")
        inputChanges.getFileChanges(input).forEach { change -&gt;          // <b class="conum">(2)</b>
            def changedFile = change.file
            if (change.fileType != FileType.FILE) {
                return
            }
            def outputLocation = new File(outputDir, "${change.normalizedPath}.loc")
            switch (change.changeType) {
                case ADDED:
                case MODIFIED:
                    println("Processing file ${changedFile.name}")
                    outputLocation.parentFile.mkdirs()

                    outputLocation.text = changedFile.readLines().size()

                case REMOVED:
                    println("Removing leftover output file ${outputLocation.name}")
                    outputLocation.delete()

            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">abstract class CountLoc : TransformAction&lt;TransformParameters.None&gt; {

    @get:Inject
    abstract val inputChanges: InputChanges

    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:InputArtifact
    abstract val input: Provider&lt;FileSystemLocation&gt;

    override
    fun transform(outputs: TransformOutputs) {                          // <b class="conum">(1)</b>
        val outputDir = outputs.dir("${input.get().asFile.name}.loc")
        println("Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.isIncremental}")
        inputChanges.getFileChanges(input).forEach { change -&gt;          // <b class="conum">(2)</b>
            val changedFile = change.file
            if (change.fileType != FileType.FILE) {
                return@forEach
            }
            val outputLocation = outputDir.resolve("${change.normalizedPath}.loc")
            when (change.changeType) {
                ChangeType.ADDED, ChangeType.MODIFIED -&gt; {

                    println("Processing file ${changedFile.name}")
                    outputLocation.parentFile.mkdirs()

                    outputLocation.writeText(changedFile.readLines().size.toString())
                }
                ChangeType.REMOVED -&gt; {
                    println("Removing leftover output file ${outputLocation.name}")
                    outputLocation.delete()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>注入<code>InputChanges</code></p>
</li>
<li>
<p>查询输入工件中的更改</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<h1 id="working_in_a_multi_repo_environment" class="sect0"><a class="anchor" href="#working_in_a_multi_repo_environment"></a> <a class="link" href="#working_in_a_multi_repo_environment">在多仓库环境中工作</a></h1>
<div class="sect1">
<h2 id="composite_builds"><a class="anchor" href="#composite_builds"></a> <a class="link" href="#composite_builds">组成作品</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="composite_build_intro"><a class="anchor" href="#composite_build_intro"></a> <a class="link" href="#composite_build_intro">什么是复合构建？</a></h3>
<div class="paragraph">
<p>复合构建只是包含其他构建的构建。在许多方面，复合构建类似于Gradle多项目构建，不同之处在于，它不包含单个构建<code>projects</code> ，完成<code>builds</code>被包含在内。</p>
</div>
<div class="paragraph">
<p>复合版本使您能够：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>结合通常独立开发的构建，例如，在应用程序使用的库中尝试错误修复时</p>
</li>
<li>
<p>将大型的多项目构建分解为更小，更孤立的块，可以根据需要独立或一起工作</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>自然包含在复合构建中的构建被称为“包含构建”。包含的构建不与复合构建或其他包含的构建共享任何配置。每个包含的构建都是独立配置和执行的。</p>
</div>
<div class="paragraph">
<p>包含的内部版本通过<a href="#sec:dependency_substitution_rules"><em>依赖替换</em></a>与其他内部版本交互。如果组合中的任何内部版本都具有包含的内部版本可以满足的依赖关系，则该依赖关系将由对包含的内部版本的项目依赖关系代替。
<em>由于依赖于依赖替换，因此在构建任务执行图时，复合构建可能会强制配置早日解析。这可能会对整体构建性能产生负面影响，因为这些配置无法并行解决。</em></p>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将尝试确定可以由包含的内部版本替代的依赖项。但是，为了获得更大的灵活性，如果Gradle确定的默认替换不适用于组合，则可以显式声明这些替换。请参阅<a href="#included_build_declaring_substitutions">声明替代</a> 。</p>
</div>
<div class="paragraph">
<p>除了通过项目依赖项消耗输出外，复合构建还可以直接在包含的构建中声明任务依赖项。包含的构建是隔离的，并且不能声明复合构建或其他包含的构建上的任务依赖性。请参阅<a href="#included_build_task_dependencies">根据包含的构建中的任务</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="defining_composite_builds"><a class="anchor" href="#defining_composite_builds"></a> <a class="link" href="#defining_composite_builds">定义复合构建</a></h3>
<div class="paragraph">
<p>以下示例演示了通常可以单独开发的2个Gradle构建可以组合为复合构建的各种方式。对于这些示例， <code>my-utils</code>多项目构建产生2个不同的Java库（ <code>number-utils</code>和<code>string-utils</code> ），以及<code>my-app</code> build使用这些库中的函数生成可执行文件。</p>
</div>
<div class="paragraph">
<p>的<code>my-app</code>构建没有直接依赖<code>my-utils</code> 。相反，它声明由生成的库的二进制依赖性<code>my-utils</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例145我的应用程序的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">my-app / build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java'
    id 'application'
    id 'idea'
}

group "org.sample"
version "1.0"

application {
    mainClassName = "org.sample.myapp.Main"
}

dependencies {
    implementation "org.sample:number-utils:1.0"
    implementation "org.sample:string-utils:1.0"
}

repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">my-app / build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    java
    application
    idea
}

group = "org.sample"
version = "1.0"

application {
    mainClassName = "org.sample.myapp.Main"
}

dependencies {
    implementation("org.sample:number-utils:1.0")
    implementation("org.sample:string-utils:1.0")
}

repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/compositeBuilds/basic</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="command_line_composite"><a class="anchor" href="#command_line_composite"></a> <a class="link" href="#command_line_composite">通过以下方式定义复合构建<code>--include-build</code></a></h4>
<div class="paragraph">
<p>的<code>--include-build</code>命令行参数将执行的构建转换为组合，将包含的构建中的依赖项替换为执行的构建。</p>
</div>
</div>
<div class="sect3">
<h4 id="example_declaring_a_command_line_composite"><a class="anchor" href="#example_declaring_a_command_line_composite"></a> <a class="link" href="#example_declaring_a_command_line_composite">示例：声明命令行复合</a></h4>
<div class="listingblock">
<div class="title">输出<strong><code>gradle --include-build ../my-utils run</code></strong></div>
<div class="content">
<pre>&gt; gradle --include-build ../my-utils run
&gt; Task :processResources NO-SOURCE
&gt; Task :my-utils:string-utils:compileJava
&gt; Task :my-utils:string-utils:processResources NO-SOURCE
&gt; Task :my-utils:string-utils:classes
&gt; Task :my-utils:string-utils:jar
&gt; Task :my-utils:number-utils:compileJava
&gt; Task :my-utils:number-utils:processResources NO-SOURCE
&gt; Task :my-utils:number-utils:classes
&gt; Task :my-utils:number-utils:jar
&gt; Task :compileJava
&gt; Task :classes

&gt; Task :run
The answer is 42


BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="settings_defined_composite"><a class="anchor" href="#settings_defined_composite"></a> <a class="link" href="#settings_defined_composite">通过设置文件定义复合构建</a></h4>
<div class="paragraph">
<p>通过使用<a href="../dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:includeBuild(java.lang.Object)">Settings.includeBuild（java.lang。对象）</a>在其中声明包含的内部版本<code>settings.gradle</code> （要么<code>settings.gradle.kts</code>在Kotlin中）文件。设置文件可用于同时添加子项目和包含的内部版本。包含的内部版本按位置添加。有关更多详细信息，请参见下面的示例。</p>
</div>
</div>
<div class="sect3">
<h4 id="separate_composite"><a class="anchor" href="#separate_composite"></a> <a class="link" href="#separate_composite">定义一个单独的复合构建</a></h4>
<div class="paragraph">
<p>上述方法的一个缺点是，它需要您修改现有的内部版本，从而使其作为独立的内部版本不太有用。避免这种情况的一种方法是定义一个单独的复合构建，其唯一目的是合并否则的单独构建。</p>
</div>
<div class="exampleblock">
<div class="title">例子146。声明一个单独的组合</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / settings.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">rootProject.name = 'adhoc'

includeBuild '../my-app'
includeBuild '../my-utils'</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / settings.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">rootProject.name = "adhoc"

includeBuild("../my-app")
includeBuild("../my-utils")</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，执行的“主要”构建是组合，并且没有定义任何有用的任务来执行自身。为了在“ my-app”构建中执行“运行”任务，复合构建必须定义一个委托任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例147根据包含的构建中的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">复合/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">task run {
    dependsOn gradle.includedBuild('my-app').task(':run')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">tasks.register("run") {
    dependsOn(gradle.includedBuild("my-app").task(":run"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>更多详细信息任务取决于以下包含的构建任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="included_builds"><a class="anchor" href="#included_builds"></a> <a class="link" href="#included_builds">包含版本的限制</a></h4>
<div class="paragraph">
<p>大多数构建都可以包含在组合中，包括其他组合构建。但是，有一些限制。</p>
</div>
<div class="paragraph">
<p>每个包含的版本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不能有一个<code>rootProject.name</code>与另一个包含的版本相同。</p>
</li>
<li>
<p>不能有一个<code>rootProject.name</code>与复合构建的顶级项目相同。</p>
</li>
<li>
<p>不能有一个<code>rootProject.name</code>与组合版本相同<code>rootProject.name</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="interacting_with_composite_builds"><a class="anchor" href="#interacting_with_composite_builds"></a> <a class="link" href="#interacting_with_composite_builds">与复合构建交互</a></h3>
<div class="paragraph">
<p>通常，与组合构建进行交互与常规多项目构建非常相似。可以执行任务，可以运行测试，并且可以将构建导入到IDE中。</p>
</div>
<div class="sect3">
<h4 id="composite_build_executing_tasks"><a class="anchor" href="#composite_build_executing_tasks"></a> <a class="link" href="#composite_build_executing_tasks">执行任务</a></h4>
<div class="paragraph">
<p>可以从命令行或您的IDE执行复合构建中的任务。执行任务将导致直接任务依赖关系被执行，以及从包含的构建中构建依赖关系工件所需的那些任务。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>还没有任何方法可以通过命令行从包含的内部版本中直接执行任务。包含的构建任务会自动执行以生成所需的依赖工件，或者<a href="#included_build_task_dependencies">包含的构建可以声明包含的构建对任务的依赖</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="composite_build_ide_integration"><a class="anchor" href="#composite_build_ide_integration"></a> <a class="link" href="#composite_build_ide_integration">导入IDE</a></h4>
<div class="paragraph">
<p>集成构建最有用的功能之一就是IDE集成。通过将<a href="idea_plugin.html#idea_plugin">idea</a>或<a href="eclipse_plugin.html#eclipse_plugin">eclipse</a>插件应用于构建，可以生成一个IDEA或Eclipse项目，该项目允许组合中的所有构建一起开发。</p>
</div>
<div class="paragraph">
<p>除了这些Gradle插件之外， <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>和<a href="https://projects.eclipse.org/projects/tools.buildship">Eclipse Buildship的</a>最新版本<a href="https://projects.eclipse.org/projects/tools.buildship">还</a>支持直接导入复合构建。</p>
</div>
<div class="paragraph">
<p>导入复合构建可以使来自单独的Gradle构建的资源易于一起开发。对于每个包含的构建，每个子项目都作为IDEA模块或Eclipse项目包含在内。配置了源依赖关系，提供了跨版本的导航和重构。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="included_build_declaring_substitutions"><a class="anchor" href="#included_build_declaring_substitutions"></a> <a class="link" href="#included_build_declaring_substitutions">声明由包含的构建替换的依赖项</a></h3>
<div class="paragraph">
<p>默认情况下，Gradle将配置每个包含的内部版本，以确定其可以提供的依赖项。这样做的算法非常简单：Gradle将检查包含的构建中项目的组和名称，并将项目依赖项替换为任何外部依赖项匹配<code>${project.group}:${project.name}</code> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，Gradle确定的默认替换不足，或者对于特定组合而言，它们不正确。对于这些情况，可以显式声明所包含构建的替换。以一个单项目构建“ anonymous-library”为例，它生成一个Java实用程序库，但未声明group属性的值：</p>
</div>
<div class="exampleblock">
<div class="title">实施例148。不声明组属性的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    java
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当此构建包含在组合中时，它将尝试替换依赖项模块“ undefined：anonymous-library”（“ undefined”是<code>project.group</code> ，并且“ anonymous-library”是根项目名称）。显然，这在复合构建中不会很有用。要在复合构建中使用未修改的未发布库，组合构建可以显式声明其提供的替换：</p>
</div>
<div class="exampleblock">
<div class="title">示例149声明包含的构建的替代</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">rootProject.name = 'app'

includeBuild('../anonymous-library') {
    dependencySubstitution {
        substitute module('org.sample:number-utils') with project(':')
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">rootProject.name = "app"

includeBuild("../anonymous-library") {
    dependencySubstitution {
        substitute(module("org.sample:number-utils")).with(project(":"))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用此配置，“ my-app”复合构建将替换对<code>org.sample:number-utils</code>依赖于“匿名库”的根项目。</p>
</div>
<div class="sect3">
<h4 id="included_build_substitution_requirements"><a class="anchor" href="#included_build_substitution_requirements"></a> <a class="link" href="#included_build_substitution_requirements">必须声明包含的内部替代品的情况</a></h4>
<div class="paragraph">
<p>许多使用<code>uploadArchives</code>发布工件的任务将自动作为包含的内部版本运行，而无需声明替代。以下是一些需要声明替换的常见情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当。。。的时候<code>archivesBaseName</code>属性用于设置发布的工件的名称。</p>
</li>
<li>
<p>当配置不是<code>default</code>发表：这通常意味着除<code>uploadArchives</code>用来。</p>
</li>
<li>
<p>当。。。的时候<code>MavenPom.addFilter()</code>用于发布与项目名称不匹配的工件。</p>
</li>
<li>
<p>当。。。的时候<code>maven-publish</code>要么<code>ivy-publish</code>插件用于发布，发布坐标不匹配<code>${project.group}:${project.name}</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="included_build_substitution_limitations"><a class="anchor" href="#included_build_substitution_limitations"></a> <a class="link" href="#included_build_substitution_limitations">复合建筑替换无效的情况</a></h4>
<div class="paragraph">
<p>某些组合即使包含在显式声明的依赖项替换中，也无法正常运行。此限制是由于以下事实：被替换的项目依赖项将始终指向<code>default</code>目标项目的配置。每当为项目的默认配置指定的工件和依赖项与实际发布到存储库的内容不匹配时，组合构建就可能表现出不同的行为。</p>
</div>
<div class="paragraph">
<p>在某些情况下，发布模块元数据可能与项目默认配置不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当配置不是<code>default</code>已出版。</p>
</li>
<li>
<p>当。。。的时候<code>maven-publish</code>要么<code>ivy-publish</code>使用插件。</p>
</li>
<li>
<p>当。。。的时候<code>POM</code>要么<code>ivy.xml</code>文件已作为发布的一部分进行了调整。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当包含在复合版本中时，使用这些功能的版本将无法正常运行。我们计划在将来对此进行改进。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="included_build_task_dependencies"><a class="anchor" href="#included_build_task_dependencies"></a> <a class="link" href="#included_build_task_dependencies">根据所包含构建中的任务</a></h3>
<div class="paragraph">
<p>虽然包含的内部版本相互隔离并且不能声明直接依赖关系，但是复合内部版本可以对其包含的内部版本声明任务依赖关系。使用<a href="../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuilds">Gradle.getIncludedBuilds（）</a>或<a href="../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuild(java.lang.String)">Gradle.includedBuild（java.lang。String）</a> ，然后通过<a href="../dsl/org.gradle.api.initialization.IncludedBuild.html#org.gradle.api.initialization.IncludedBuild:task(java.lang.String)">IncludedBuild.task（java.lang。字符串）</a>方法。</p>
</div>
<div class="paragraph">
<p>使用这些API，可以声明对特定包含的构建中的任务或所有或某些包含的构建中具有特定路径的任务的依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">示例150取决于包含的内部版本中的单个任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">复合/ build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">task run {
    dependsOn gradle.includedBuild('my-app').task(':run')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">tasks.register("run") {
    dependsOn(gradle.includedBuild("my-app").task(":run"))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例151取决于所有包含的构建中带有路径的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">task publishDeps {
    dependsOn gradle.includedBuilds*.task(':publishIvyPublicationToIvyRepository')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">tasks.register("publishDeps") {
    dependsOn(gradle.includedBuilds.map { it.task(":publishIvyPublicationToIvyRepository") })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="current_limitations_and_future_work"><a class="anchor" href="#current_limitations_and_future_work"></a> <a class="link" href="#current_limitations_and_future_work">复合材料构建的当前限制和未来计划</a></h3>
<div class="paragraph">
<p>我们认为复合构建已经非常有用。但是，有些事情并没有按照我们希望的方式工作，还有一些我们认为可以使事情做得更好的改进。</p>
</div>
<div class="paragraph">
<p>当前实施的局限性包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不支持包含发布的不反映项目默认配置的内部版本。请参阅<a href="#included_build_substitution_limitations">复合建筑无法使用的案例</a> 。</p>
</li>
<li>
<p>不支持基于软件模型的本机版本。（本机版本尚不支持二进制依赖性）。</p>
</li>
<li>
<p>如果多个复合构建并行运行，则多个复合构建可能会发生冲突。Gradle不会在Gradle调用之间共享共享复合构建的项目锁，以防止并发执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们计划在即将发布的版本中进行的改进包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更好地检测依赖项替换，例如使用自定义坐标发布的生成，生成多个组件的生成等。这将减少需要为包含的生成显式声明依赖项替换的情况。</p>
</li>
<li>
<p>可以直接从命令行定位包含的内部版本中的一个或多个任务的功能。我们目前正在探索允许使用此功能的语法选项，这将消除许多在组合中需要委派任务的情况。</p>
</li>
<li>
<p>使隐式<code>buildSrc</code>计划一个包含的构建。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="publishing_libraries" class="sect0"><a class="anchor" href="#publishing_libraries"></a> <a class="link" href="#publishing_libraries">出版图书馆</a></h1>
<div class="sect1">
<h2 id="publishing_components"><a class="anchor" href="#publishing_components"></a> <a class="link" href="#publishing_components">将项目发布为模块</a></h2>
<div class="sectionbody">
<div id="publishing_overview" class="paragraph">
<p>绝大多数软件项目都旨在以某种方式使用某种东西。它可以是其他软件项目使用的库，也可以是最终用户的应用程序。
<em>发布</em>是将构建的东西提供给消费者的过程。</p>
</div>
<div class="paragraph">
<p>在Gradle中，该过程如下所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>定义<a href="#publishing_overview:what">什么</a>发布</p>
</li>
<li>
<p>定义<a href="#publishing_overview:where">将</a>其发布到的位置</p>
</li>
<li>
<p><a href="#publishing_overview:how">做</a>出版</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这些步骤中的每一个都取决于要将工件发布到的存储库的类型。两种最常见的类型是Maven兼容和Ivy兼容存储库，或者简称为Maven和Ivy存储库。</p>
</div>
<div class="paragraph">
<p>从Gradle 6.0开始， <a href="#sec:understanding-gradle-module-md">Gradle模块元数据</a>将始终与Ivy XML或Maven POM元数据文件一起发布。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>寻找有关上传任务和<code>archives</code>组态？请参阅“ <a href="artifact_management.html#artifact_management">旧版发布”</a>一章，该功能现已弃用，并计划将其删除。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle通过以<a href="publishing_maven.html#publishing_maven">Maven Publish插件</a>和<a href="publishing_ivy.html#publishing_ivy">Ivy Publish插件</a>的形式提供一些预打包的基础结构，使发布到这些类型的存储库变得容易。这些插件使您可以配置要发布的内容并以最小的努力执行发布。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/publishing-process.png" alt="发布过程">
</div>
<div class="title">图13。发布过程</div>
</div>
<div class="paragraph">
<p>让我们更详细地看看这些步骤：</p>
</div>
<div id="publishing_overview:what" class="dlist">
<dl>
<dt class="hdlist1">发表什么</dt>
<dd>
<p>Gradle需要知道要发布哪些文件和信息，以便消费者可以使用您的项目。这通常是Gradle称为<a href="#sub:terminology_publication">出版物</a>的<a href="#sub:terminology_artifact">工件</a>和元数据的组合。出版物所包含的内容取决于要发布到的存储库的类型。</p>
<div class="paragraph">
<p>例如，发往Maven存储库的出版物包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个或多个工件（通常由项目构建）</p>
</li>
<li>
<p>Gradle Module元数据文件，将描述已发布组件的变体，</p>
</li>
<li>
<p>Maven POM文件将标识主要工件及其依赖项。主要工件通常是项目的生产JAR，辅助工件可能由“ -sources”和“ -javadoc” JAR组成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，Gradle将发布上述所有内容的校验和，并配置为发布<a href="#">签名</a> 。从Gradle 6.0开始，这包括<code>SHA256</code>和<code>SHA512</code>校验和。</p>
</div>
</dd>
</dl>
</div>
<div id="publishing_overview:where" class="dlist">
<dl>
<dt class="hdlist1">在哪里发布</dt>
<dd>
<p>Gradle需要知道在哪里发布工件，以便消费者可以掌握它们。这是通过<a href="#sub:terminology_repository">存储库</a>完成的，该存储<a href="#sub:terminology_repository">库</a>存储并提供了各种工件。Gradle还需要与存储库进行交互，这就是为什么您必须提供存储库的类型及其位置的原因。</p>
</dd>
</dl>
</div>
<div id="publishing_overview:how" class="dlist">
<dl>
<dt class="hdlist1">发行方式</dt>
<dd>
<p>Gradle会自动为发布和存储库的所有可能组合生成发布任务，从而使您可以将任何工件发布到任何存储库。如果要发布到Maven存储库，则任务的类型为<a href="../dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html">PublishToMavenRepository</a> ，而对于Ivy存储库，任务的类型为<a href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html">PublishToIvyRepository</a> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>下面是一个实际的示例，演示了整个发布过程。</p>
</div>
<div class="sect2">
<h3 id="sec:basic_publishing"><a class="anchor" href="#sec:basic_publishing"></a> <a class="link" href="#sec:basic_publishing">设置基本发布</a></h3>
<div class="paragraph">
<p>无论您的项目类型如何，发布的第一步都是应用适当的发布插件。如简介中所述，Gradle通过以下插件支持Maven和Ivy存储库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="publishing_maven.html#publishing_maven">Maven发布插件</a></p>
</li>
<li>
<p><a href="publishing_ivy.html#publishing_ivy">常春藤发布插件</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它们提供了配置相应存储库类型的发布所需的特定发布和存储库类。由于Maven存储库是最常用的存储库，因此它们将成为本示例和本章其他示例的基础。不用担心，我们将解释如何为Ivy存储库调整单个样本。</p>
</div>
<div class="paragraph">
<p>假设我们正在使用一个简单的Java库项目，因此仅应用以下插件：</p>
</div>
<div class="exampleblock">
<div class="title">示例152应用必要的插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'java-library'
    id 'maven-publish'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    `java-library`
    `maven-publish`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦应用了适当的插件，就可以配置发布和存储库。在此示例中，我们要发布项目的生产JAR文件-由<code>jar</code>任务-到自定义的Maven存储库。我们通过以下方式做到这一点<code>publishing {}</code>块，由<a href="../dsl/org.gradle.api.publish.PublishingExtension.html">PublishingExtension</a>支持：</p>
</div>
<div class="exampleblock">
<div class="title">示例153。配置Java库以进行发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">group = 'org.example'
version = '1.0'

publishing {
    publications {
        myLibrary(MavenPublication) {
            from components.java
        }
    }

    repositories {
        maven {
            name = 'myRepo'
            url = "file://${buildDir}/repo"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">group = "org.example"
version = "1.0"

publishing {
    publications {
        create&lt;MavenPublication&gt;("myLibrary") {
            from(components["java"])
        }
    }

    repositories {
        maven {
            name = "myRepo"
            url = uri("file://${buildDir}/repo")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这定义了一个称为“ myLibrary”的发布，可以通过其类型将其发布到Maven存储库： <a href="../dsl/org.gradle.api.publish.maven.MavenPublication.html">MavenPublication</a> 。该出版物仅包含生产JAR工件及其元数据，两者结合起来由<code>java</code>项目的<a href="#sub:terminology_component">组成部分</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">组件是定义发布的标准方法。它们是由插件提供的，通常是各种语言或平台的插件。例如，Java插件定义了<code>components.java</code>战争插件定义了<a href="../javadoc/org/gradle/api/component/SoftwareComponent.html">SoftwareComponent</a> <code>components.web</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该示例还定义了一个名为“ myRepo”的基于文件的Maven存储库。这样的基于文件的存储库对于示例来说很方便，但是实际构建通常可以与基于HTTPS的存储库服务器（例如Maven Central或内部公司服务器）一起使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">您可以定义一个并且只有一个没有名称的存储库。对于Maven存储库，这将转换为隐式名称“ Maven”，对于Ivy存储库，将转换为隐式名称。必须为所有其他存储库定义指定一个明确的名称。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与项目的结合<code>group</code>和<code>version</code> ，发布和存储库定义提供了Gradle发布项目的生产JAR所需的一切。然后Gradle将创建一个专用的<code>publishMyLibraryPublicationToMyRepoRepository</code>就是那样的任务。其名称基于模板<code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code> 。请参阅相应的发布插件的文档，以获取有关此任务的性质以及您可能可用的任何其他任务的更多详细信息。</p>
</div>
<div class="paragraph">
<p>您可以直接执行单个发布任务，也可以执行<code>publish</code> ，它将运行所有可用的发布任务。在这个例子中<code>publish</code>会跑<code>publishMyLibraryPublicationToMavenRepository</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>基本发布到Ivy存储库非常相似：您只需使用Ivy Publish Plugin，替换<code>MavenPublication</code>与<a href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html">IvyPublication一起</a>使用<code>ivy</code>代替<code>maven</code>在存储库定义中。</p>
</div>
<div class="paragraph">
<p>两种类型的存储库之间存在差异，尤其是每种存储库都支持的额外元数据之间存在差异-例如，Maven存储库需要一个POM文件，而Ivy存储库则具有自己的元数据格式-因此，请参阅插件章节以获取有关如何配置这两种配置的全面信息。您正在使用的任何存储库类型的出版物和存储库。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这就是基本用例的全部内容。但是，许多项目需要对发布的内容进行更多控制，因此我们在以下各节中介绍几种常见方案。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:understanding-gradle-module-md"><a class="anchor" href="#sec:understanding-gradle-module-md"></a> <a class="link" href="#sec:understanding-gradle-module-md">了解Gradle模块元数据</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle模块元数据是用于序列化Gradle组件模型的格式。它类似于<a href="https://maven.apache.org/pom.html">Apache Maven™的POM文件</a>或<a href="http://ant.apache.org/ivy/">Apache Ivy™ivy.xml</a>文件。元数据文件的目标是向<em>消费者</em>提供存储库中发布内容的合理模型。</p>
</div>
<div class="paragraph">
<p>Gradle模块元数据是一种独特的格式，旨在通过使其具有多平台和变体感知功能来改善依赖关系解析。</p>
</div>
<div class="paragraph">
<p>特别是，Gradle模块元数据支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rich-version-constraints">丰富的版本约束</a></p>
</li>
<li>
<p><a href="#sec:adding-constraints-transitive-deps">依赖约束</a></p>
</li>
<li>
<p><a href="#declaring-component-capabilities">组件功能</a></p>
</li>
<li>
<p><a href="#understanding-variant-selection">变体感知分辨率</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>发布Gradle模块元数据将为您的使用者提供更好的依赖关系管理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过检测<a href="#declaring-component-capabilities">不兼容的模块</a>及早发现问题</p>
</li>
<li>
<p>一致选择<a href="#targeting-different-platforms">特定于平台的依赖项</a></p>
</li>
<li>
<p>本机<a href="#version_alignment">依赖版本对齐</a></p>
</li>
<li>
<p>自动获取<a href="#">库</a>特定<a href="#">功能的</a>依赖关系</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用<a href="publishing_maven.html">Maven Publish插件</a>或<a href="publishing_ivy.html">Ivy Publish插件</a>时，Gradle模块元数据会自动<a href="publishing_ivy.html">发布</a> 。旧版<em>不</em>支持此功能<code>maven</code>和<code>ivy</code>插件。</p>
</div>
<div class="paragraph">
<p>可在<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">此处</a>找到Gradle模块元数据规范的规范。</p>
</div>
<div class="sect2">
<h3 id="sub:mapping-with-other-formats"><a class="anchor" href="#sub:mapping-with-other-formats"></a> <a class="link" href="#sub:mapping-with-other-formats">与其他格式的映射</a></h3>
<div class="paragraph">
<p>Gradle模块元数据会自动发布在Maven或Ivy存储库中。但是，它不会替代<em>pom.xml</em>或<em>ivy.xml</em>文件：它与这些文件一起发布。这样做是为了最大程度地提高与第三方构建工具的兼容性。</p>
</div>
<div class="paragraph">
<p>Gradle尽其所能将Gradle特定的概念映射到Maven或Ivy。当构建文件使用只能在Gradle模块元数据中表示的功能时，Gradle会在发布时警告您。下表总结了如何将某些特定于Gradle的功能映射到Maven和Ivy：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表9。将Gradle特定概念映射到Maven和Ivy</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">摇篮</th>
<th class="tableblock halign-left valign-top">马文</th>
<th class="tableblock halign-left valign-top">常春藤</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:adding-constraints-transitive-deps">依赖约束</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><dependencyManagement></code>依存关系</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未发表</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gradle依赖项约束是可<em>传递的</em> ，而Maven的依赖项管理块<em>不是</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#rich-version-constraints">丰富的版本约束</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布<em>需求</em>版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布了<em>需求</em>版本</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#declaring-component-capabilities">组件功能</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未发表</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未发表</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组件功能是Gradle独有的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#">功能变体</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">上载各种工件，相关性发布为_optional依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">已上传变体工件，未发布依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能变体很好地替代了可选的依赖项</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:publishing-custom-components">自定义组件类型</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工件已上传，依赖项是映射所描述的依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工件已上传，相关性被忽略</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在任何情况下，自定义组件类型都可能无法从Maven或Ivy中使用。它们通常存在于自定义生态系统中。</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="disabling_metadata_compatibility_publication_warnings"><a class="anchor" href="#disabling_metadata_compatibility_publication_warnings"></a> <a class="link" href="#disabling_metadata_compatibility_publication_warnings">禁用元数据兼容性发布警告</a></h4>
<div class="paragraph">
<p>如果要禁止显示警告，则可以使用以下API来禁止显示警告：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Maven，请参见<code>suppress*</code> <a href="../dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication:suppressAllPomMetadataWarnings()">Maven出版中的</a>方法</p>
</li>
<li>
<p>对于常春藤，请参阅<code>suppress*</code> <a href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html#org.gradle.api.publish.ivy.IvyPublication:suppressAllIvyMetadataWarnings()">IvyPublication中的</a>方法</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">示例154禁用发布警告</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    publications {
        maven(MavenPublication) {
            from components.java
            suppressPomMetadataWarningsFor('runtimeElements')
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">    publications {
        register&lt;MavenPublication&gt;("maven") {
            from(components["java"])
            suppressPomMetadataWarningsFor("runtimeElements")
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sub:interactions-other-build-tools"><a class="anchor" href="#sub:interactions-other-build-tools"></a> <a class="link" href="#sub:interactions-other-build-tools">与其他构建工具的交互</a></h3>
<div class="paragraph">
<p>由于Gradle模块元数据并未广泛传播，并且其目的是<a href="#sub:mapping-with-other-formats">最大程度地提高与其他工具的兼容性</a> ，因此Gradle可以做两件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle模块元数据会与给定存储库（Maven或Ivy）的常规描述符一起系统发布</p>
</li>
<li>
<p>的<code>pom.xml</code>要么<code>ivy.xml</code>文件将包含一个<em>标记注释</em> ，该<em>标记</em>告诉Gradle该模块存在Gradle模块元数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>标记的目的<em>不是</em>其他工具来解析模块元数据：仅用于Gradle用户。它向Gradle解释说，存在<em>更好的</em>模块元数据文件，应该使用它。这并不意味着Maven或Ivy的消耗也将被打破，而不仅仅是它在<a href="#sub:mapping-with-other-formats">降级模式下工作</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>必须将其视为一项<em>性能优化</em> ：不必执行2个网络请求，而是先获取Gradle模块元数据，然后再获取一个POM / Ivy文件，而Gradle将首先查看该文件中最重要的文件。可能存在，则仅在模块与Gradle Module Metadata实际发布时才执行第二个请求。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您知道依赖的模块始终与Gradle Module Metadata一起发布，则可以优化网络调用，为存储库配置元数据源：</p>
</div>
<div class="exampleblock">
<div class="title">示例155仅解决Gradle模块元数据</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    repositories {
        maven {
            url "http://repo.mycompany.com/repo"
            metadataSources {
                gradleMetadata()
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">    repositories {
        maven {
            setUrl("http://repo.mycompany.com/repo")
            metadataSources {
                gradleMetadata()
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sub:gmm-validation"><a class="anchor" href="#sub:gmm-validation"></a> <a class="link" href="#sub:gmm-validation">Gradle模块元数据验证</a></h3>
<div class="paragraph">
<p>Gradle模块元数据在发布之前先经过验证。</p>
</div>
<div class="paragraph">
<p>强制执行以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>变体名称必须唯一，</p>
</li>
<li>
<p>每个变体必须至少具有<a href="#">一个属性</a> ，</p>
</li>
<li>
<p>两个变体不能具有<a href="#">完全相同的属性和功能</a> ，</p>
</li>
<li>
<p>如果存在依赖关系，则所有变体中的至少一个必须包含<a href="#">版本信息</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些规则可确保生成的元数据的质量，并有助于确认使用不会有问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:disabling-gmm-publication"><a class="anchor" href="#sub:disabling-gmm-publication"></a> <a class="link" href="#sub:disabling-gmm-publication">禁用Gradle模块元数据发布</a></h3>
<div class="paragraph">
<p>在某些情况下，您可能需要禁用Gradle模块元数据的发布：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您要上传到的存储库将拒绝元数据文件（未知格式）</p>
</li>
<li>
<p>您正在使用未正确映射到Gradle模块元数据的Maven或Ivy特定概念</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这种情况下，只需禁用生成元数据文件的任务即可禁用Gradle Module元数据的发布：</p>
</div>
<div class="exampleblock">
<div class="title">例子156。禁用发布Gradle模块元数据</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    tasks.withType(GenerateModuleMetadata) {
        enabled = false
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">    tasks.withType&lt;GenerateModuleMetadata&gt; {
        enabled = false
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="publishing_maven:signing"><a class="anchor" href="#publishing_maven:signing"></a> <a class="link" href="#publishing_maven:signing">签名文物</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="signing_plugin.html#signing_plugin">签名插件</a>可用于签名构成发布的所有工件和元数据文件，包括Maven POM文件和Ivy模块描述符。为了使用它：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>应用签名插件</p>
</li>
<li>
<p>配置<a href="signing_plugin.html#sec:signatory_credentials">签名者凭据</a> —单击链接查看如何</p>
</li>
<li>
<p>指定您要签名的出版物</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这是一个配置插件以对其进行签名的示例<code>mavenJava</code>出版物：</p>
</div>
<div class="exampleblock">
<div class="title">示例157签署出版物</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">signing {
    sign publishing.publications.mavenJava
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">signing {
    sign(publishing.publications["mavenJava"])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将创建一个<code>Sign</code>您指定的每个出版物的任务，并全部连线<code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code>依赖它的任务。因此，发布任何出版物将自动为其出版物和元数据创建和发布签名，如您从以下输出中可以看到的：</p>
</div>
<div class="sect2">
<h3 id="example_sign_and_publish_a_project"><a class="anchor" href="#example_sign_and_publish_a_project"></a> <a class="link" href="#example_sign_and_publish_a_project">示例：签名并发布项目</a></h3>
<div class="listingblock">
<div class="title">输出<code>gradle publish</code></div>
<div class="content">
<pre>&gt; gradle publish
&gt; Task :compileJava
&gt; Task :processResources
&gt; Task :classes
&gt; Task :jar
&gt; Task :javadoc
&gt; Task :javadocJar
&gt; Task :sourcesJar
&gt; Task :generateMetadataFileForMavenJavaPublication
&gt; Task :generatePomFileForMavenJavaPublication
&gt; Task :signMavenJavaPublication
&gt; Task :publishMavenJavaPublicationToMavenRepository
&gt; Task :publish

BUILD SUCCESSFUL in 0s
10 actionable tasks: 10 executed</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="customizing_publishing"><a class="anchor" href="#customizing_publishing"></a> <a class="link" href="#customizing_publishing">定制发布</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sec:adding-variants-to-existing-components"><a class="anchor" href="#sec:adding-variants-to-existing-components"></a> <a class="link" href="#sec:adding-variants-to-existing-components">修改现有变体并将其添加到现有组件以进行发布</a></h3>
<div class="paragraph">
<p>Gradle的发布模型基于<em>组件</em>的概念，该概念由插件定义。例如，Java库插件定义了一个<code>java</code>组件，它对应于一个库，但是Java Platform插件定义了另一种组件，名为<code>javaPlatform</code> ，实际上是另一种软件组件（ <em>平台</em> ）。</p>
</div>
<div class="paragraph">
<p>有时我们想向现有组件添加<em>更多变体</em>或修改现有组件的<em>现有变体</em> 。例如，如果您<a href="#targeting-different-platforms">为其他平台添加了Java库的变体</a> ，则可能只想在<code>java</code>组件本身。通常，声明其他变体通常是发布<em>其他工件</em>的最佳解决方案。</p>
</div>
<div class="paragraph">
<p>要执行此类添加或修改， <code>AdhocComponentWithVariants</code>接口声明了两个方法<code>addVariantsFromConfiguration</code>和<code>withVariantsFromConfiguration</code>接受两个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用作变体源的<a href="#sec:resolvable-consumable-configs">传出配置</a></p>
</li>
<li>
<p>定制操作，使您可以<em>过滤</em>将要发布的变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要使用这些方法，您必须确保<code>SoftwareComponent</code>与您合作本身就是<code>AdhocComponentWithVariants</code> ，由Java插件（Java，Java库，Java平台）创建的组件就是这种情况。添加变体非常简单：</p>
</div>
<div class="exampleblock">
<div class="title">例子158。向现有软件组件添加变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">        AdhocComponentWithVariants javaComponent = (AdhocComponentWithVariants) project.components.findByName("java")
        javaComponent.addVariantsFromConfiguration(outgoing) {
            // dependencies for this variant are considered runtime dependencies
            it.mapToMavenScope("runtime")
            // and also optional dependencies, because we don't want them to leak
            it.mapToOptional()
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.kt</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">        val javaComponent = components.findByName("java") as AdhocComponentWithVariants
        javaComponent.addVariantsFromConfiguration(outgoing) {
            // dependencies for this variant are considered runtime dependencies
            mapToMavenScope("runtime")
            // and also optional dependencies, because we don't want them to leak
            mapToOptional()
        }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在其他情况下，您可能想要修改已经由其中一个Java插件添加的变体。例如，如果您激活Javadoc和源代码的发布，则它们将成为Javadoc和源代码的其他变体。 <code>java</code>零件。如果您只想发布其中之一，例如只发布Javadoc而没有发布源，则可以修改<code>sources</code>未发布的变体：</p>
</div>
<div class="exampleblock">
<div class="title">例子159。使用Javadoc发布Java库但没有源代码</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">java {
    withJavadocJar()
    withSourcesJar()
}

components.java.withVariantsFromConfiguration(configurations.sourcesElements) {
    skip()
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">java {
    withJavadocJar()
    withSourcesJar()
}

val javaComponent = components["java"] as AdhocComponentWithVariants
javaComponent.withVariantsFromConfiguration(configurations["sourcesElements"]) {
    skip()
}

publishing {
    publications {
        create&lt;MavenPublication&gt;("mavenJava") {
            from(components["java"])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:publishing-custom-components"><a class="anchor" href="#sec:publishing-custom-components"></a> <a class="link" href="#sec:publishing-custom-components">创建和发布自定义组件</a></h3>
<div class="paragraph">
<p>在<a href="#sec:adding-variants-to-existing-components">前面的示例中</a> ，我们演示了如何扩展或修改现有组件，例如Java插件提供的组件。但是Gradle还允许您构建自定义组件（不是Java库，不是Java平台，不是Gradle本身支持的东西）。</p>
</div>
<div class="paragraph">
<p>要创建自定义组件，您首先需要创建一个空的<em>自组织</em>组件。目前，这只能通过插件实现，因为您需要在<a href="../javadocorg/gradle/api/component/SoftwareComponentFactory.html">SoftwareComponentFactory</a>上获取一个句柄：</p>
</div>
<div class="exampleblock">
<div class="title">例子160。注入软件组件工厂</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">    private final SoftwareComponentFactory softwareComponentFactory

    @Inject
    InstrumentedJarsPlugin(SoftwareComponentFactory softwareComponentFactory) {
        this.softwareComponentFactory = softwareComponentFactory
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.kt</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">class InstrumentedJarsPlugin @Inject constructor(
    private val softwareComponentFactory: SoftwareComponentFactory) : Plugin&lt;Project&gt; {</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>声明自定义组件发布<em>了哪些</em>仍然通过做<a href="../javadocorg/gradle/api/component/AdhocComponentWithVariants.html">AdhocComponentWithVariants</a> API。对于自定义组件，第一步是按照<a href="#sec:variant-aware-sharing">本章中</a>的说明创建自定义传出变型。在此阶段，您应该拥有可以在跨项目依赖项中使用的变体，但是我们现在将其发布到外部存储库。</p>
</div>
<div class="exampleblock">
<div class="title">示例161创建一个自定义的临时组件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">        // create an adhoc component
        def adhocComponent = softwareComponentFactory.adhoc("myAdhocComponent")
        // add it to the list of components that this project declares
        project.components.add(adhocComponent)
        // and register a variant for publication
        adhocComponent.addVariantsFromConfiguration(outgoing) {
            it.mapToMavenScope("runtime")
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.kt</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">        // create an adhoc component
        val adhocComponent = softwareComponentFactory.adhoc("myAdhocComponent")
        // add it to the list of components that this project declares
        components.add(adhocComponent)
        // and register a variant for publication
        adhocComponent.addVariantsFromConfiguration(outgoing) {
            mapToMavenScope("runtime")
        }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>首先，我们使用工厂创建一个新的临时组件。然后，我们通过<code>addVariantsFromConfiguration</code>方法，在上<a href="#sec:adding-variants-to-existing-components">一节</a>中有更详细的描述。</p>
</div>
<div class="paragraph">
<p>在简单的情况下，一个<code>Configuration</code>和变体，在这种情况下，您可以发布单个发布的所有变体<code>Configuration</code>因为它们实际上是同一件事。但是，在某些情况下<code>Configuration</code>与其他<a href="../javadocorg/gradle/api/artifacts/ConfigurationPublications.html">配置出版物</a> （我们也称为<em>次要变体）有关</em> 。这样的配置在<a href="#">跨项目发布</a>用例中有意义，但在外部发布时则没有意义。例如，在项目之间共享<em>文件目录</em>的情况就是这种情况，但是您无法直接在Maven存储库中发布<em>目录</em> （仅打包文件，如jar或zip）。查看<a href="../javadocorg/gradle/api/component/ConfigurationVariantDetails.html">ConfigurationVariantDetails</a>类，以获取有关如何跳过特定变体的发布的详细信息。如果<code>addVariantsFromConfiguration</code>已经被要求进行配置，可以使用<code>withVariantsFromConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>当发布像这样的临时组件时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle模块元数据将<em>完全</em>代表已发布的变体。特别是，所有传出的变体都将继承已发布配置的依赖项，工件和属性。</p>
</li>
<li>
<p>将生成Maven和Ivy元数据文件，但是您需要声明如何通过<a href="../javadocorg/gradle/api/component/ConfigurationVariantDetails.html">ConfigurationVariantDetails</a>类将依赖项映射到Maven范围。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>实际上，这意味着Gradle可以像使用“本地组件”一样使用这种方式创建的组件。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:publishing_custom_artifacts_to_maven"><a class="anchor" href="#sec:publishing_custom_artifacts_to_maven"></a> <a class="link" href="#sec:publishing_custom_artifacts_to_maven">将自定义工件添加到发布中</a></h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">⚠</div>
</td>
<td class="content">
<div class="paragraph">
<p>与其考虑工件，不如考虑Gradle的变体感知模型。预期单个模块可能需要多个工件。但是，如果其他工件代表了<a href="#">可选功能</a> ，那么这种情况就很少止于此了，它们可能还具有不同的依存关系，甚至更多。</p>
</div>
<div class="paragraph">
<p>Gradle通过<em>Gradle Module Metadata</em>支持<em>其他变体</em>的发布，这些<em>变体</em>使依赖解析引擎知道这些工件。请参阅文档的<a href="#sec:variant-aware-sharing">变体感知共享</a>部分，以了解如何声明此类变体并<a href="#sec:publishing-custom-components">查看如何发布自定义组件</a> 。</p>
</div>
<div class="paragraph">
<p>如果您将额外的工件直接附加到发布，它们将“脱离上下文”发布。这意味着，它们根本不在元数据中引用，因此只能通过依赖项上的分类器直接解决。与Gradle Module元数据相比，Maven pom元数据将不包含有关其他工件的信息，无论它们是通过变体添加还是直接添加，因为变体无法以pom格式表示。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下部分描述了在确定元数据（例如Gradle或POM元数据）与用例无关的情况下如何直接发布工件。例如，如果您的项目不需要被其他项目占用，并且发布的结果唯一需要的就是工件本身。</p>
</div>
<div class="paragraph">
<p>通常，有两种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅使用工件创建出版物</p>
</li>
<li>
<p>根据带有元数据的组件将工件添加到发布中（不建议使用，而是<a href="#sec:adding-variants-to-existing-components">调整组件</a>或使用<a href="#sec:publishing-custom-components">即席组件发布</a> ，这都会生成适合您工件的元数据）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要基于工件创建发布，请先定义一个自定义工件并将其附加到您选择的Gradle <a href="#sub:terminology_configuration">配置</a> 。以下示例定义了由<code>rpm</code>任务（未显示）并将该工件附加到<code>archives</code>组态：</p>
</div>
<div class="exampleblock">
<div class="title">实施例162。定义配置的自定义工件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def rpmFile = file("$buildDir/rpms/my-package.rpm")
def rpmArtifact = artifacts.add('archives', rpmFile) {
    type 'rpm'
    builtBy 'rpm'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">val rpmFile = file("$buildDir/rpms/my-package.rpm")
val rpmArtifact = artifacts.add("archives", rpmFile) {
    type = "rpm"
    builtBy("rpm")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>artifacts.add()</code>方法（来自<a href="../dsl/org.gradle.api.artifacts.dsl.ArtifactHandler.html">ArtifactHandler）</a> -返回类型为<a href="../javadoc/org/gradle/api/artifacts/PublishArtifact.html">PublishArtifact</a>的工件对象，然后可以将其用于定义发布，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例163。将自定义PublishArtifact附加到发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">publishing {
    publications {
        maven(MavenPublication) {
            artifact rpmArtifact
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;("maven") {
            artifact(rpmArtifact)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>artifact()</code>方法接受<em>发布工件</em>作为参数，例如<code>rpmArtifact</code>在示例中-以及<a href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。对象）</a> ，例如<code>File</code>实例，字符串文件路径或归档任务。</p>
</li>
<li>
<p>发布插件支持不同的工件配置属性，因此请始终查看插件文档以获取更多详细信息。的<code>classifier</code>和<code>extension</code> <a href="publishing_maven.html#publishing_maven">Maven发布插件</a>和<a href="publishing_ivy.html#publishing_ivy">Ivy发布插件</a>都支持这些属性。</p>
</li>
<li>
<p>自定义工件需要在出版物中有所不同，通常是通过以下方式的唯一组合<code>classifier</code>和<code>extension</code> 。有关确切要求，请参见所用插件的文档。</p>
</li>
<li>
<p>如果您使用<code>artifact()</code>在执行存档任务时，Gradle会自动使用<code>classifier</code>和<code>extension</code>该任务的属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，您可以发布RPM。</p>
</div>
<div class="paragraph">
<p>如果您确实想基于组件将工件添加到发布中，而不是<a href="#sec:adding-variants-to-existing-components">调整组件</a>本身，则可以结合使用<code>from components.someComponent</code>和<code>artifact someArtifact</code>记号。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:publishing_maven:conditional_publishing"><a class="anchor" href="#sec:publishing_maven:conditional_publishing"></a> <a class="link" href="#sec:publishing_maven:conditional_publishing">将出版物限制为特定的存储库</a></h3>
<div class="paragraph">
<p>当定义了多个发布或存储库时，通常需要控制将哪些发布发布到哪个存储库。例如，考虑以下示例，该示例定义了两个发布-一个仅由一个二进制文件组成，另一个包含二进制和相关联的资源-两个存储库-一个供内部使用，一个供外部使用者使用：</p>
</div>
<div class="exampleblock">
<div class="title">示例164。添加多个出版物和存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">publishing {
    publications {
        binary(MavenPublication) {
            from components.java
        }
        binaryAndSources(MavenPublication) {
            from components.java
            artifact sourcesJar
        }
    }
    repositories {
        // change URLs to point to your repos, e.g. http://my.org/repo
        maven {
            name = 'external'
            url = "$buildDir/repos/external"
        }
        maven {
            name = 'internal'
            url = "$buildDir/repos/internal"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;("binary") {
            from(components["java"])
        }
        create&lt;MavenPublication&gt;("binaryAndSources") {
            from(components["java"])
            artifact(tasks["sourcesJar"])
        }
    }
    repositories {
        // change URLs to point to your repos, e.g. http://my.org/repo
        maven {
            name = "external"
            url = uri("$buildDir/repos/external")
        }
        maven {
            name = "internal"
            url = uri("$buildDir/repos/internal")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>发布插件将创建任务，使您可以将两个发布中的任何一个发布到任何一个存储库。他们还将这些任务附加到<code>publish</code>聚合任务。但是，假设您要将仅限二进制的发布限制为外部存储库，将带有源的二进制发布限制为内部存储库。为此，您需要使发布成为<em>条件</em>发布。</p>
</div>
<div class="paragraph">
<p>Gradle允许您通过<a href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf(org.gradle.api.specs.Spec)">Task.onlyIf（org.gradle.api.specs）根据条件跳过所需的任何任务</a><a href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf(org.gradle.api.specs.Spec)">。Spec）</a>方法。下面的示例演示了如何实现我们刚刚提到的约束：</p>
</div>
<div class="exampleblock">
<div class="title">示例165配置应将哪些工件发布到哪些存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">tasks.withType(PublishToMavenRepository) {
    onlyIf {
        (repository == publishing.repositories.external &amp;&amp;
            publication == publishing.publications.binary) ||
        (repository == publishing.repositories.internal &amp;&amp;
            publication == publishing.publications.binaryAndSources)
    }
}
tasks.withType(PublishToMavenLocal) {
    onlyIf {
        publication == publishing.publications.binaryAndSources
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">tasks.withType&lt;PublishToMavenRepository&gt;().configureEach {
    onlyIf {
        (repository == publishing.repositories["external"] &amp;&amp;
            publication == publishing.publications["binary"]) ||
        (repository == publishing.repositories["internal"] &amp;&amp;
            publication == publishing.publications["binaryAndSources"])
    }
}
tasks.withType&lt;PublishToMavenLocal&gt;().configureEach {
    onlyIf {
        publication == publishing.publications["binaryAndSources"]
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle publish</code></div>
<div class="content">
<pre>&gt; gradle publish
&gt; Task :compileJava
&gt; Task :processResources
&gt; Task :classes
&gt; Task :jar
&gt; Task :generateMetadataFileForBinaryAndSourcesPublication
&gt; Task :generatePomFileForBinaryAndSourcesPublication
&gt; Task :sourcesJar
&gt; Task :publishBinaryAndSourcesPublicationToExternalRepository SKIPPED
&gt; Task :publishBinaryAndSourcesPublicationToInternalRepository
&gt; Task :generateMetadataFileForBinaryPublication
&gt; Task :generatePomFileForBinaryPublication
&gt; Task :publishBinaryPublicationToExternalRepository
&gt; Task :publishBinaryPublicationToInternalRepository SKIPPED
&gt; Task :publish

BUILD SUCCESSFUL in 0s
10 actionable tasks: 10 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您可能还需要定义自己的聚合任务以帮助您的工作流程。例如，假设您有多个发布应发布到外部存储库。一次发布所有这些而不发布内部的可能非常有用。</p>
</div>
<div class="paragraph">
<p>以下示例演示了如何通过定义聚合任务来做到这一点- <code>publishToExternalRepository</code> -取决于所有相关的发布任务：</p>
</div>
<div class="exampleblock">
<div class="title">例子166。定义自己的速记任务以进行发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">task publishToExternalRepository {
    group = 'publishing'
    description = 'Publishes all Maven publications to the external Maven repository.'
    dependsOn tasks.withType(PublishToMavenRepository).matching {
        it.repository == publishing.repositories.external
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">tasks.register("publishToExternalRepository") {
    group = "publishing"
    description = "Publishes all Maven publications to the external Maven repository."
    dependsOn(tasks.withType&lt;PublishToMavenRepository&gt;().matching {
        it.repository == publishing.repositories["external"]
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此特定示例通过使用<a href="../javadoc/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-">TaskCollection.withType（java.lang。类），</a>具有<a href="../dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html">PublishToMavenRepository</a>任务类型。如果要发布到兼容Ivy的存储库，则可以对<a href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html">PublishToIvyRepository</a>进行相同的<a href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html">操作</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:configuring_publishing_tasks"><a class="anchor" href="#sec:configuring_publishing_tasks"></a> <a class="link" href="#sec:configuring_publishing_tasks">配置发布任务</a></h3>
<div class="paragraph">
<p>在评估项目之后，发布插件会创建其非聚合任务，这意味着您无法直接从构建脚本中引用它们。如果要配置这些任务中的任何一个，则应使用延迟任务配置。这可以通过项目的方式以多种方式完成<code>tasks</code>采集。</p>
</div>
<div class="paragraph">
<p>例如，假设您想更改<code>generatePomFileFor<em>PubName</em>Publication</code>任务写入其POM文件。您可以使用<a href="../javadoc/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-">TaskCollection.withType（java.lang。类）</a>方法，如本示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子167。配置由发布插件创建的动态命名任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">tasks.withType(GenerateMavenPom).all {
    def matcher = name =~ /generatePomFileFor(\w+)Publication/
    def publicationName = matcher[0][1]
    destination = "$buildDir/poms/${publicationName}-pom.xml"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">tasks.withType&lt;GenerateMavenPom&gt;().configureEach {
    val matcher = Regex("""generatePomFileFor(\w+)Publication""").matchEntire(name)
    val publicationName = matcher?.let { it.groupValues[1] }
    destination = file("$buildDir/poms/$publicationName-pom.xml")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例使用正则表达式从任务名称中提取发布的名称。这样可以避免所有可能生成的POM文件的文件路径之间发生冲突。如果只有一个出版物，则不必担心此类冲突，因为只有一个POM文件。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dependency_management_terminology"><a class="anchor" href="#dependency_management_terminology"></a> <a class="link" href="#dependency_management_terminology">依赖管理术语</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>依赖性管理带有大量术语。在这里，您可以找到最常用的术语，包括对用户指南的引用，以了解其实际应用。</p>
</div>
<div class="sect2">
<h3 id="sub:terminology_artifact"><a class="anchor" href="#sub:terminology_artifact"></a> <a class="link" href="#sub:terminology_artifact">神器</a></h3>
<div class="paragraph">
<p>生成的文件或目录，例如JAR，ZIP发行版或本机可执行文件。</p>
</div>
<div class="paragraph">
<p>工件通常设计为由用户或其他项目使用或使用，或部署到托管系统。在这种情况下，工件是单个文件。目录在项目间相关性的情况下很常见，以避免产生可发布工件的成本。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_capability"><a class="anchor" href="#sub:terminology_capability"></a> <a class="link" href="#sub:terminology_capability">能力</a></h3>
<div class="paragraph">
<p>功能标识由一个或多个组件提供的功能。通过类似于用于<a href="#sub:terminology_module_version">模块版本</a>的坐标的坐标来标识能力。默认情况下，每个模块版本都提供与其坐标匹配的功能，例如<code>com.google:guava:18.0</code> 。功能可以用来表示一个组件提供了多个<a href="#sub:terminology_feature_variant">功能变体，</a>或者两个不同的组件实现了相同的功能（因此不能一起使用）。有关更多详细信息，请参见<a href="#">功能</a>部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_component"><a class="anchor" href="#sub:terminology_component"></a> <a class="link" href="#sub:terminology_component">零件</a></h3>
<div class="paragraph">
<p><a href="#sub:terminology_module">模块的</a>任何单一版本。</p>
</div>
<div class="paragraph">
<p>对于外部库，术语组件是指该库的一个发行版本。</p>
</div>
<div class="paragraph">
<p>在构建中，组件由插件（例如Java库插件）定义，并提供一种简单的方法来定义要发布的发布。它们包括<a href="#sub:terminology_artifact">工件</a>以及适当的<a href="#sub:terminology_artifact">元数据</a> ，这些<a href="#sub:terminology_artifact">元数据</a>详细描述了组件的<a href="#sub:terminology_variant">变体</a> 。例如， <code>java</code>组件在其默认设置中由JAR组成-由<code>jar</code>任务-以及Java <em>api</em>和<em>运行时</em>变体的依赖项信息。它还可以使用相应的工件定义其他变体，例如<em>源</em>和<em>Javadoc</em> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_configuration"><a class="anchor" href="#sub:terminology_configuration"></a> <a class="link" href="#sub:terminology_configuration">组态</a></h3>
<div class="paragraph">
<p>配置是为特定目标分组在一起的一组命名的<a href="#sub:terminology_dependency">依赖项</a> 。配置提供对基础的，已解析的<a href="#sub:terminology_module">模块</a>及其工件的访问。有关更多信息，请参见有关<a href="#sec:what-are-dependency-configurations">依赖项配置</a>以及<a href="#sec:resolvable-consumable-configs">可解析和易用配置的各节</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>单词“配置”是一个重载术语，在依赖项管理的上下文之外具有不同的含义。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_dependency"><a class="anchor" href="#sub:terminology_dependency"></a> <a class="link" href="#sub:terminology_dependency">相依性</a></h3>
<div class="paragraph">
<p>依赖关系是构建，测试或运行<a href="#sub:terminology_module">模块</a>所需的另一软件的指针。有关更多信息，请参见关于<a href="#">声明依赖项</a>的部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_dependency_constraint"><a class="anchor" href="#sub:terminology_dependency_constraint"></a> <a class="link" href="#sub:terminology_dependency_constraint">依赖约束</a></h3>
<div class="paragraph">
<p>依赖关系约束定义了模块要使其成为依赖关系的有效解决结果所需要满足的要求。例如，依赖性约束可以缩小支持的模块版本的范围。依赖性约束可用于表达对传递性依赖性的此类要求。有关更多信息，请参见有关<a href="#">升级</a>和<a href="#">降级</a>传递依赖项的部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_feature_variant"><a class="anchor" href="#sub:terminology_feature_variant"></a> <a class="link" href="#sub:terminology_feature_variant">功能变体</a></h3>
<div class="paragraph">
<p>特征变体是表示可以单独选择或不能单独选择的组件特征的变<a href="#sub:terminology_variant">体</a> 。功能变体由一个或多个<a href="#sub:terminology_capability">功能</a>标识。有关更多信息，请参见有关<a href="#">模型特征变体和可选依赖项的部分</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_module"><a class="anchor" href="#sub:terminology_module"></a> <a class="link" href="#sub:terminology_module">模组</a></h3>
<div class="paragraph">
<p>随时间推移而发展的软件，例如<a href="https://github.com/google/guava">Google Guava</a> 。每个模块都有一个名称。模块的每个发行版均以<a href="#sub:terminology_module_version">模块版本</a>为代表。为了方便使用，可以将模块托管在<a href="#sub:terminology_repository">资源库中</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_module_metadata"><a class="anchor" href="#sub:terminology_module_metadata"></a> <a class="link" href="#sub:terminology_module_metadata">模块元数据</a></h3>
<div class="paragraph">
<p><a href="#sub:terminology_module">模块的</a>发行版提供元数据。元数据是更详细地描述模块的数据，例如有关工件位置或所需<a href="#sub:terminology_transitive_dependency">传递依赖项的信息</a> 。Gradle提供了自己的元数据格式，称为<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle模块元数据</a> （ <code>.module</code>文件），但也支持Maven（ <code>.pom</code> ）和常春藤（ <code>ivy.xml</code> ）元数据。有关支持的元数据格式的更多信息，请参见<a href="#">了解Gradle模块元数据</a>的部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="component_metadata_rule"><a class="anchor" href="#component_metadata_rule"></a> <a class="link" href="#component_metadata_rule">组件元数据规则</a></h3>
<div class="paragraph">
<p>组件元数据规则是在从存储库中提取组件的元数据后对其进行修改的规则，例如，添加丢失的信息或纠正错误的信息。与<a href="#sub:terminology_resolution_rule">解析规则</a>相反， <strong>在</strong>解析开始<strong>之前</strong>会应用组件元数据规则。组件元数据规则定义为构建逻辑的一部分，可以通过插件共享。有关更多信息，请参见关于<a href="#">使用组件元数据规则修复元数据的部分</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_module_version"><a class="anchor" href="#sub:terminology_module_version"></a> <a class="link" href="#sub:terminology_module_version">模块版本</a></h3>
<div class="paragraph">
<p>模块版本表示已发布<a href="#sub:terminology_module">模块</a>的一组不同的更改。例如<code>18.0</code>用坐标表示模块的版本<code>com.google:guava:18.0</code> 。实际上，对模块版本的方案没有限制。时间戳，数字，特殊后缀，例如<code>-GA</code>是所有允许的标识符。最广泛使用的版本控制策略是<a href="https://semver.org/">语义版本控制</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub::terminology_platform"><a class="anchor" href="#sub::terminology_platform"></a> <a class="link" href="#sub::terminology_platform">平台</a></h3>
<div class="paragraph">
<p>平台是旨在一起使用的一组模块。平台有不同类别，对应于不同的用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模块集：通常是作为一个整体发布的一组模块。使用集合中的一个模块通常意味着我们要对集合中的所有模块使用相同的版本。例如，如果使用<code>groovy</code> 1.2，也使用<code>groovy-json</code> 1.2。</p>
</li>
<li>
<p>运行时环境：一组可以很好地协同工作的库。例如，Spring Platform，为Spring和与Spring一起使用的组件推荐了版本。</p>
</li>
<li>
<p>部署环境：Java运行时，应用服务器，...</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另外Gradle定义了<a href="#sec:virtual_platform">虚拟平台</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">✨</div>
</td>
<td class="content">
<div class="paragraph">
<p>Maven的BOM（物料清单）是<a href="#sub:bom_import">Gradle支持的</a>一种流行的平台。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_publication"><a class="anchor" href="#sub:terminology_publication"></a> <a class="link" href="#sub:terminology_publication">出版物</a></h3>
<div class="paragraph">
<p>对文件和元数据的描述，这些文件和元数据应作为单个实体发布给存储库以供使用者使用。</p>
</div>
<div class="paragraph">
<p>出版物具有名称，由一个或多个工件以及有关这些工件的信息（ <a href="#sub:terminology_module_metadata">元数据</a> ）组成。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_repository"><a class="anchor" href="#sub:terminology_repository"></a> <a class="link" href="#sub:terminology_repository">资料库</a></h3>
<div class="paragraph">
<p>存储库托管一组<a href="#sub:terminology_module">模块</a> ，每个<a href="#sub:terminology_module">模块</a>可以提供一个或多个由<a href="#sub:terminology_module_version">模块版本</a>指示的发行版（组件）。该存储库可以基于二进制存储库产品（例如Artifactory或Nexus）或文件系统中的目录结构。有关更多信息，请参见<a href="#">声明存储库</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_resolution_rule"><a class="anchor" href="#sub:terminology_resolution_rule"></a> <a class="link" href="#sub:terminology_resolution_rule">解析规则</a></h3>
<div class="paragraph">
<p>解决规则会影响如何直接解决<a href="#sub:terminology_dependency">依赖项</a>的行为。解析规则定义为构建逻辑的一部分。有关更多信息，请参见有关<a href="#">直接自定义依赖项解析</a>的部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_transitive_dependency"><a class="anchor" href="#sub:terminology_transitive_dependency"></a> <a class="link" href="#sub:terminology_transitive_dependency">传递依存关系</a></h3>
<div class="paragraph">
<p><a href="#sub:terminology_component">组件</a>的变体可以依赖于其他模块才能正常工作，即所谓的传递依赖。托管在<a href="#sub:terminology_repository">存储库</a>中的模块的发行版可以提供<a href="#sub:terminology_module_metadata">元数据</a>来声明这些可传递依赖项。默认情况下，Gradle自动解析传递依赖。声明<a href="#">依赖约束</a>可以影响可传递依赖的版本选择。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_variant"><a class="anchor" href="#sub:terminology_variant"></a> <a class="link" href="#sub:terminology_variant">（组件的）变体</a></h3>
<div class="paragraph">
<p>每个<a href="#sub:terminology_component">组件都</a>包含一个或多个变体。变体由一组工件组成，并定义了一组依赖项。它由一组<a href="#sub:terminology_attribute">属性</a>和<a href="#sub:terminology_capability">功能</a>标识。</p>
</div>
<div class="paragraph">
<p>Gradle的依赖项解决方案可识别变体，并在选择组件（即模块的一个版本）后为每个组件选择一个或多个变体。如果变体选择结果不明确，也可能会失败，这意味着Gradle没有足够的信息来选择多个互斥变体之一。在那种情况下，可以通过<a href="#sub:terminology_attribute">变量属性</a>提供更多信息。每个Java组件通常提供的变体示例是<em>api</em>和<em>运行时</em>变体。其他示例是JDK8和JDK11变体。有关更多信息，请参见<a href="#">变量选择</a>部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="sub:terminology_attribute"><a class="anchor" href="#sub:terminology_attribute"></a> <a class="link" href="#sub:terminology_attribute">变体属性</a></h3>
<div class="paragraph">
<p>属性用于识别和选择<a href="#sub:terminology_variant">变体</a> 。一个变体定义了一个或多个属性，例如<code>org.gradle.usage=java-api</code> ， <code>org.gradle.jvm.version=11</code> 。解决依赖关系后，将请求一组属性，并且Gradle会为依赖关系图中的每个组件找到最合适的变量。可以为属性实现兼容性和消歧规则，以表达值之间的兼容性（例如Java 8与Java 11兼容，但是如果请求的版本为11或更高版本，则应该首选Java 11）。此类规则通常由插件提供。有关更多信息，请参见有关<a href="#">变量选择</a>和<a href="#">声明属性的部分</a> 。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<!-- end div class="chapter" -->
<aside class="secondary-navigation"></aside>
</main>

<footer class="site-layout__footer site-footer" itemscope itemtype="https://schema.org/WPFooter">
    <nav class="site-footer__navigation" itemtype="https://schema.org/SiteNavigationElement">
        <section class="site-footer__links">
            <div class="site-footer__link-group">
                <header><strong>文件</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="/userguide/userguide.html" itemprop="url">用户手册</a></li>
                    <li itemprop="name"><a href="/dsl/" itemprop="url">DSL参考</a></li>
                    <li itemprop="name"><a href="/release-notes.html" itemprop="url">发行说明</a></li>
                    <li itemprop="name"><a href="/javadoc/" itemprop="url">Java文档</a></li>
                </ul>
            </div>
            <div class="site-footer__link-group">
                <header><strong>新闻</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="https://blog.gradle.org/" itemprop="url">博客</a></li>
                    <li itemprop="name"><a href="https://newsletter.gradle.com/" itemprop="url">通讯</a></li>
                    <li itemprop="name"><a href="https://twitter.com/gradle" itemprop="url">推特</a></li>
                </ul>
            </div>
            <div class="site-footer__link-group">
                <header><strong>产品展示</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="https://gradle.com/build-scans/" itemprop="url">构建扫描</a></li>
                    <li itemprop="name"><a href="https://gradle.com/build-cache/" itemprop="url">构建缓存</a></li>
                    <li itemprop="name"><a href="https://gradle.com/enterprise/resources/" itemprop="url">企业文件</a></li>
                </ul>
            </div>
            <div class="site-footer__link-group">
                <header><strong>得到帮助</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="https://discuss.gradle.org/c/help-discuss" itemprop="url">论坛</a></li>
                    <li itemprop="name"><a href="https://github.com/gradle/" itemprop="url">的GitHub</a></li>
                    <li itemprop="name"><a href="https://gradle.com/training/" itemprop="url">训练</a></li>
                    <li itemprop="name"><a href="https://gradle.org/services/" itemprop="url">服务</a></li>
                </ul>
            </div>
        </section>
        <section class="site-footer__subscribe-newsletter" id="newsletter-form-container">
            <header class="newsletter-form__header"><h5>留<code>UP-TO-DATE</code>关于新功能和新闻</h5></header>
            <p class="disclaimer">输入您的电子邮件，即表示您同意我们的<a href="https://gradle.com/legal/terms-of-service/">条款</a>和<a href="https://gradle.com/legal/privacy/">隐私政策</a> ，包括接收电子邮件。您可以随时取消订阅。</p>
            <div class="newsletter-form__container">
                <form id="newsletter-form" class="newsletter-form" action="https://go.gradle.com/l/68052/2018-09-07/bk6wml" method="post">
                    <input id="email" class="email" name="email" type="email" placeholder="name@email.com" pattern="[^@\s]+@[^@\s]+\.[^@\s]+" maxlength="255" required>
                    <button id="submit" class="submit" type="submit">订阅</button>
                </form>
            </div>
        </section>
    </nav>
    <div class="site-footer-secondary">
        <div class="site-footer-secondary__contents">
            <div class="site-footer__copy">© <a href="https://gradle.com">Gradle Inc.</a> <time> 2018年</time>版权所有。
            </div>
            <div class="site-footer__logo"><a href="/">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 90 66.06">
                    <defs>
                        <style>.cls-1 {
                            fill: #02303a;
                        }</style>
                    </defs>
                    <title>摇动</title>
                    <path class="cls-1" d="M85.11,4.18a14.27,14.27,0,0,0-19.83-.34,1.38,1.38,0,0,0,0,2L67,7.6a1.36,1.36,0,0,0,1.78.12A8.18,8.18,0,0,1,79.5,20.06C68.17,31.38,53.05-.36,18.73,16a4.65,4.65,0,0,0-2,6.54l5.89,10.17a4.64,4.64,0,0,0,6.3,1.73l.14-.08-.11.08L31.53,33a60.29,60.29,0,0,0,8.22-6.13,1.44,1.44,0,0,1,1.87-.06h0a1.34,1.34,0,0,1,.06,2A61.61,61.61,0,0,1,33,35.34l-.09,0-2.61,1.46a7.34,7.34,0,0,1-3.61.94,7.45,7.45,0,0,1-6.47-3.71l-5.57-9.61C4,32-2.54,46.56,1,65a1.36,1.36,0,0,0,1.33,1.11H8.61A1.36,1.36,0,0,0,10,64.87a9.29,9.29,0,0,1,18.42,0,1.35,1.35,0,0,0,1.34,1.19H35.9a1.36,1.36,0,0,0,1.34-1.19,9.29,9.29,0,0,1,18.42,0A1.36,1.36,0,0,0,57,66.06H63.1a1.36,1.36,0,0,0,1.36-1.34c.14-8.6,2.46-18.48,9.07-23.43C96.43,24.16,90.41,9.48,85.11,4.18ZM61.76,30.05l-4.37-2.19h0a2.74,2.74,0,1,1,4.37,2.2Z"></path>
                </svg>
            </a></div>
            <div class="site-footer-secondary__links">
                <a href="https://gradle.com/careers/">招贤纳士</a> | <a href="https://gradle.com/legal/privacy/">隐私</a> | <a href="https://gradle.com/legal/terms-of-service/">服务条款</a> | <a href="https://gradle.org/contact/">联系</a>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
    // Polyfill Element.matches()
    if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }
    // Polyfill Element.closest()
    if (!Element.prototype.closest) {
        Element.prototype.closest = function (s) {
            var el = this;
            if (!document.documentElement.contains(el)) return null;
            do {
                if (typeof el.matches === "function" && el.matches(s)) return el;
                el = el.parentElement || el.parentNode;
            } while (el !== null);
            return null;
        };
    }

    var currentChapterFileName = window.location.pathname.substr(window.location.pathname.lastIndexOf("/") + 1);
    [].forEach.call(document.querySelectorAll(".docs-navigation a[href$='" + currentChapterFileName + "']"), function (link) {
        // Add "active" to all links same as current URL
        link.classList.add("active");

        // Expand all parent navigation
        var parentListEl = link.closest("li");
        while (parentListEl !== null) {
            var dropDownEl = parentListEl.querySelector(".nav-dropdown");
            if (dropDownEl !== null) {
                dropDownEl.classList.add("expanded");
            }
            parentListEl = parentListEl.parentNode.closest("li");
        }
    });

    // Expand/contract multi-level side navigation
    [].forEach.call(document.querySelectorAll(".docs-navigation .nav-dropdown"), function registerSideNavActions(collapsibleElement) {
        collapsibleElement.addEventListener("click", function toggleExpandedSideNav(evt) {
            evt.preventDefault();
            evt.target.classList.toggle("expanded");
            evt.target.setAttribute("aria-expanded", evt.target.classList.contains("expanded").toString());
            return false;
        }, false);
    });

    function postProcessCodeBlocks() {
        // Assumptions:
        //  1) All siblings that are marked with class="multi-language-sample" should be grouped
        //  2) Only one language can be selected per domain (to allow selection to persist across all docs pages)
        //  3) There is exactly 1 small set of languages to choose from. This does not allow for multiple language preferences. For example, users cannot prefer both Kotlin and ZSH.
        //  4) Only 1 sample of each language can exist in the same collection.

        var GRADLE_DSLs = ["groovy", "kotlin"];
        var preferredBuildScriptLanguage = initPreferredBuildScriptLanguage();

        // Ensure preferred DSL is valid, defaulting to Groovy DSL
        function initPreferredBuildScriptLanguage() {
            var lang = window.localStorage.getItem("preferred-gradle-dsl");
            if (GRADLE_DSLs.indexOf(lang) === -1) {
                window.localStorage.setItem("preferred-gradle-dsl", "groovy");
                lang = "groovy";
            }
            return lang;
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function processSampleEl(sampleEl, prefLangId) {
            var codeEl = sampleEl.querySelector("code[data-lang]");
            if (codeEl != null) {
                sampleEl.setAttribute("data-lang", codeEl.getAttribute("data-lang"));
                if (codeEl.getAttribute("data-lang") !== prefLangId) {
                    sampleEl.classList.add("hidden");
                } else {
                    sampleEl.classList.remove("hidden");
                }
            }
        }

        function switchSampleLanguage(languageId) {
            var multiLanguageSampleElements = [].slice.call(document.querySelectorAll(".multi-language-sample"));

            // Array of Arrays, each top-level array representing a single collection of samples
            var multiLanguageSets = [];
            for (var i = 0; i < multiLanguageSampleElements.length; i++) {
                var currentCollection = [multiLanguageSampleElements[i]];
                var currentSampleElement = multiLanguageSampleElements[i];
                processSampleEl(currentSampleElement, languageId);
                while (currentSampleElement.nextElementSibling != null && currentSampleElement.nextElementSibling.classList.contains("multi-language-sample")) {
                    currentCollection.push(currentSampleElement.nextElementSibling);
                    currentSampleElement = currentSampleElement.nextElementSibling;
                    processSampleEl(currentSampleElement, languageId);
                    i++;
                }

                multiLanguageSets.push(currentCollection);
            }

            multiLanguageSets.forEach(function (sampleCollection) {
                // Create selector element if not existing
                if (sampleCollection.length > 1 &&
                    (sampleCollection[0].previousElementSibling == null ||
                        !sampleCollection[0].previousElementSibling.classList.contains("multi-language-selector"))) {
                    var languageSelectorFragment = document.createDocumentFragment();
                    var multiLanguageSelectorElement = document.createElement("div");
                    multiLanguageSelectorElement.classList.add("multi-language-selector");
                    languageSelectorFragment.appendChild(multiLanguageSelectorElement);


                    sampleCollection.forEach(function (sampleEl) {
                        var optionEl = document.createElement("code");
                        var sampleLanguage = sampleEl.getAttribute("data-lang");
                        optionEl.setAttribute("data-lang", sampleLanguage);
                        optionEl.setAttribute("role", "button");
                        optionEl.classList.add("language-option");

                        optionEl.innerText = capitalizeFirstLetter(sampleLanguage);

                        optionEl.addEventListener("click", function updatePreferredLanguage(evt) {
                            var preferredLanguageId = optionEl.getAttribute("data-lang");
                            window.localStorage.setItem("preferred-gradle-dsl", preferredLanguageId);

                            // Record how far down the page the clicked element is before switching all samples
                            var beforeOffset = evt.target.offsetTop;

                            switchSampleLanguage(preferredLanguageId);

                            // Scroll the window to account for content height differences between different sample languages
                            window.scrollBy(0, evt.target.offsetTop - beforeOffset);
                        });
                        multiLanguageSelectorElement.appendChild(optionEl);
                    });
                    sampleCollection[0].parentNode.insertBefore(languageSelectorFragment, sampleCollection[0]);
                }
            });

            [].slice.call(document.querySelectorAll(".multi-language-selector .language-option")).forEach(function (optionEl) {
                if (optionEl.getAttribute("data-lang") === languageId) {
                    optionEl.classList.add("selected");
                } else {
                    optionEl.classList.remove("selected");
                }
            });

            [].slice.call(document.querySelectorAll(".multi-language-text")).forEach(function (el) {
                if (!el.classList.contains("lang-" + languageId)) {
                    el.classList.add("hidden");
                } else {
                    el.classList.remove("hidden");
                }
            });
        }

        switchSampleLanguage(preferredBuildScriptLanguage);
    }

    document.addEventListener("DOMContentLoaded", postProcessCodeBlocks);
</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>

</body></html>