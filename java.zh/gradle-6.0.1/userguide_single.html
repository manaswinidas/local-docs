<html lang="en-US" ><head></head><body class="book" >﻿
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="description" content="Single-page Gradle User Manual for Gradle 6.0.1">
<title>Gradle用户手册：版本6.0.1</title>
<style>
/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Lato (normal, regular) */
@font-face {
    font-family: Lato;
    font-weight: 400;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-normal/lato-normal.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-normal/lato-normal.woff") format("woff");
}
/* Lato (normal, italic) */
@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: 400;
    font-style: italic;
    src: url("https://assets.gradle.com/lato/fonts/lato-normal-italic/lato-normal-italic.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-normal-italic/lato-normal-italic.woff") format("woff");
}
/* Lato (bold, regular) */
@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: 500;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff") format("woff");
}
/* Lato (bold, regular) */
@font-face {
    font-display: swap;
    font-family: Lato;
    font-weight: 800;
    font-style: normal;
    src: url("https://assets.gradle.com/lato/fonts/lato-heavy/lato-heavy.woff2") format("woff2"),
    url("https://assets.gradle.com/lato/fonts/lato-heavy/lato-heavy.woff") format("woff");
}


/* BEGIN asciidoc.css */

/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white; color: rgba(0, 0, 0, 0.8); padding: 0; margin: 0; font-family: "Noto Serif", "DejaVu Serif", serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: #7a2518; font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #2156a5; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: "Open Sans", "DejaVu Sans", sans-serif; font-weight: 300; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.0125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddddd8; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; font-weight: normal; color: rgba(0, 0, 0, 0.9); }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }

blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; }
    h1 { font-size: 2.75em; }
    h2 { font-size: 2.3125em; }
    h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
    h4 { font-size: 1.4375em; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #f7f8f7; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }

body { tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.2; word-spacing: -0.05em; }
h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong { font-weight: 400; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; background-color: #f7f7f8; -webkit-border-radius: 4px; border-radius: 4px; line-height: 1.45; text-rendering: optimizeSpeed; word-wrap: break-word; }
*:not(pre) > code.nobreak { word-wrap: normal; }
*:not(pre) > code.nowrap { white-space: nowrap; }

pre, pre > code { line-height: 1.45; color: rgba(0, 0, 0, 0.9); font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace; font-weight: normal; text-rendering: optimizeSpeed; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: rgba(51, 51, 51, 0.8); }

kbd { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: rgba(0, 0, 0, 0.8); }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: rgba(0, 0, 0, 0.9); }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddddd8; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddddd8; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddddd8; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #ddddd8; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 1px solid #efefed; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #7a2518; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
    body.toc2 { padding-left: 15em; padding-right: 0; }
    #toc.toc2 { margin-top: 0 !important; background-color: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #efefed; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
    #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
    #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
    #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
    #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
    body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
    body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #efefed; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
    #toc.toc2 { width: 20em; }
    #toc.toc2 #toctitle { font-size: 1.375em; }
    #toc.toc2 > ul { font-size: 0.95em; }
    #toc.toc2 ul ul { padding-left: 1.25em; }
    body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: rgba(0, 0, 0, 0.8); padding: 1.25em; }

#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 1px solid #efefed; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1rem; font-style: italic; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: rgba(0, 0, 0, 0.85); }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: initial; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddddd8; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; text-align: center; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #f7f7f8; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; padding: 1em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #f7f7f8; background-color: rgba(0, 0, 0, 0.9); }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }

.listingblock pre.prettyprint { border-width: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.45; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddddd8; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #7a2518; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid rgba(0, 0, 0, 0.6); }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: rgba(0, 0, 0, 0.6); }

.quoteblock.abstract { margin: 0 0 1.25em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.6; background: #f7f8f7; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 1.25em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:first-of-type img { max-width: initial; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.05em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

dt, th.tableblock, td.content, div.footnote { text-rendering: optimizeLegibility; }

h1, h2, p, td.content, span.alt { letter-spacing: -0.01em; }

p strong, td.content strong, div.footnote strong { letter-spacing: -0.005em; }

p, blockquote, dt, td.content, span.alt { font-size: 1.0625rem; }

p { margin-bottom: 1.25rem; }

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }

.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }

.print-only { display: none !important; }

@media print { @page { margin: 1.25cm 0.75cm; }
    * { -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
    a { color: inherit !important; text-decoration: underline !important; }
    a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
    a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
    abbr[title]:after { content: " (" attr(title) ")"; }
    pre, blockquote, tr, img, object, svg { page-break-inside: avoid; }
    thead { display: table-header-group; }
    svg { max-width: 100%; }
    p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
    h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
    #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
    #toc { border-bottom: 1px solid #ddddd8 !important; padding-bottom: 0 !important; }
    .sect1 { padding-bottom: 0 !important; }
    .sect1 + .sect1 { border: 0 !important; }
    #header > h1:first-child { margin-top: 1.25rem; }
    body.book #header { text-align: center; }
    body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
    body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
    body.book #header .details span:first-child { margin-left: 0 !important; }
    body.book #header .details br { display: block; }
    body.book #header .details br + span:before { content: none !important; }
    body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
    body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
    .listingblock code[data-lang]:before { display: block; }
    #footer { background: none !important; padding: 0 0.9375em; }
    #footer-text { color: rgba(0, 0, 0, 0.6) !important; font-size: 0.9em; }
    .hide-on-print { display: none !important; }
    .print-only { display: block !important; }
    .hide-for-print { display: none !important; }
    .show-for-print { display: inherit !important; } }

/* END asciidoc.css */

html,
body {
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px;
    font-weight: 400;
    line-height: 1.5;
}

body {
    color: #02303A;
    background-color: #f7f7f8;
    font-family: "Lato", "Helvetica Neue", Arial, sans-serif;
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
}

/* Links */
a {
    color: #1DA2BD;
    text-decoration: none;
}

a:hover,
a:focus {
    text-decoration: underline;
}

#content a[href^='../dsl/'],
#content a[href^='../javadoc/'] {
    font-family: 'Inconsolata', monospace;
    font-style: normal;
    border-bottom: 1px dotted rgba(29, 162, 189, 0.5);
    padding: 0 1px;
}

#content a[href^='../dsl/']:hover,
#content a[href^='../dsl/']:focus,
#content a[href^='../javadoc/']:hover,
#content a[href^='../javadoc/']:focus {
    text-decoration: none;
}

/* Copy */

p {
    font-size: 1rem;
}

pre,
pre > code,
code {
    font-family: 'Inconsolata', monospace;
}

h1,
h2,
h3,
h4,
h5,
h6,
#toctitle,
.sidebarblock > .content > .title {
    font-family: inherit;
    font-weight: 500;
    color: inherit;
}

h1 {
    font-size: 2rem;
}

h2 {
    font-size: 1.5rem;
}

h3 {
    font-size: 1.125rem;
}

h4 {
    font-size: 1.0625rem;
}

h5, h6 {
    font-size: 1rem;
}

b, strong {
    font-weight: 500;
}

dl {
    margin: 0 0 1.25rem 1.5rem;
}

.dlist dt code {
    color: #02303A;
    font-size: 1em;
    font-weight: bold;
}

.dlist p {
    margin-bottom: 0.625rem;
}

.sr-only {
    border: 0;
    clip: rect(0, 0, 0, 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
}

/* Layout */
.main-content > .appendix,
.main-content > .book,
.main-content > .chapter,
.main-content > .footer {
    background-color: white;
    border-radius: 5px;
    max-width: 45rem;
    padding: 1.5rem;
}

@media screen and (max-width: 45em) {
    .footer {
        max-width: 100%;
    }

    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        margin-top: 0;
        margin-bottom: 0;
    }
}

/* Override asciidoc styles */
#header {
    position: static;
}

#header, #content {
    padding: 0;
}

#header .details {
    /* TODO: Pretty sure there's a way to avoid Asciidoc generating details */
    display: none;
}

p {
    color: #02303A;
}

h1,
h2,
p,
p strong,
td.content,
td.content strong,
div.footnote strong,
span.alt {
    letter-spacing: normal;
}

.subheader,
.admonitionblock td.content > .title,
.audioblock > .title,
.exampleblock > .title,
.imageblock > .title,
.listingblock > .title,
.literalblock > .title,
.stemblock > .title,
.openblock > .title,
.paragraph > .title,
.quoteblock > .title,
table.tableblock > .title,
.verseblock > .title,
.videoblock > .title,
.dlist > .title,
.olist > .title,
.ulist > .title,
.qlist > .title,
.hdlist > .title {
    color: inherit;
    font-family: inherit;
}

.listingblock .title,
.listingblock .title code {
    font-style: normal;
    font-weight: bold;
}

#content .admonitionblock .icon .title {
    color: transparent;
    font-size: 3.5em;
    text-shadow: 0 0 #00c489;
    opacity: 0.7;
}

.admonitionblock td.content > .title {
    font-family: inherit;
    font-style: normal;
    font-size: 1.25em;
    color: #555;
}

.admonitionblock table tr td {
    padding: 0;
}

.imageblock,
.videoblock {
    padding: 0.25em;
}

p.lead,
.paragraph.lead > p,
#preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: 1.0625rem;
}

.paragraph.lead > p,
#preamble > .sectionbody > .paragraph:first-of-type p {
    color: inherit;
}

.sect1 {
    padding-bottom: 0;
}

.sect1 + .sect1 {
    border: 0 none;
}

.admonitionblock .icon .title {
    font-size: 2.3em;
}

.admonitionblock > table td.icon .title {
    font-family: "Lato", Arial, sans-serif;
}

.admonitionblock .content,
.admonitionblock p {
    color: #666;
}

.verseblock pre {
    font-family: "Lato", Arial, sans-serif;
}

td.hdlist1 {
    padding-bottom: 0.625rem;
}

td.hdlist2 p {
    margin-bottom: 0.625rem;
}

body.book #header > h1 {
    border: 0;
}

#header > h1:first-child {
    margin-top: 0;
}

#content a.link {
    color: #02303A;
}

.highlight .com {
    color: #777;
}

.listingblock pre.highlightjs > code {
    overflow-x: auto;
}

.listingblock pre.highlight {
    overflow-x: auto;
}

.listingblock pre.highlight > code {
    white-space: pre;
}

.conum[data-value] {
    font-family: "Lato", Arial, sans-serif;
}

.colist > table tr > td:first-of-type {
    padding-top: 0.25em;
    padding-bottom: 0.25em;
    line-height: 1.4;
    vertical-align: baseline;
}

/*
 * Samples
 */
.exampleblock > .content {
    background-color: inherit;
    border: 0 none;
    box-shadow: none;
    padding: 0;
}

.exampleblock > .content .title {
    background-color: #f7f7f8;
    border-top: 1px solid #ccc;
    font-family: 'Inconsolata', monospace;
    margin: 0;
    padding: 1em 1em 0;
}

.exampleblock .listingblock {
    margin: 0;
}

/* Multi-language selection */
.multi-language-selector .language-option[data-lang='groovy'],
.exampleblock[data-lang=groovy] > .content .title {
    background-image: url('data:image/svg+xml;base64,PHN2Zw0KICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIg0KICAgd2lkdGg9IjYxNC4wNjA4NSINCiAgIGhlaWdodD0iMzAzLjU5ODYiDQogICB2ZXJzaW9uPSIxLjEiPg0KICA8Zw0KICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzUuMzk2NTk5LC0zMC41NTgxOTYpIj4NCiAgICA8cGF0aA0KICAgICAgIGQ9Im0gMTU0Ljk3Njg3LDMzMi42OTE2MiBjIDAsLTAuODA1ODcgMTAuODMxMjMsLTE4LjYyMTcyIDI0LjA2OTQsLTM5LjU5MDc2IDEzLjIzODE5LC0yMC45NjkwNSAyMi42NjA1NywtMzguNjIwNjYgMjAuOTM4NjcsLTM5LjIyNTc3IC0xLjcyMTkxLC0wLjYwNTEgLTcuNjc5OTIsMC40ODU2NyAtMTMuMjQwMDIsMi40MjM5MyAtMTYuNzQ1MjQsNS44Mzc0MyAtMjAuMTg2MDUsNC4yOTAxNiAtMzIuNjkzMDgsLTE0LjcwMTU1IC0xMy41MzI2NSwtMjAuNTQ5MDYgLTE0LjAxNzI0LC0yMi42Njk4MyAtNi45NjE1OCwtMzAuNDY2MjQgNC42MDg3NiwtNS4wOTI1NiA0LjMzMTU5LC02LjI3OTY3IC0zLjIzMTksLTEzLjg0MzE2IC00LjU1MDA5LC00LjU1MDEgLTguMjcyODksLTkuNjQzMDkgLTguMjcyODksLTExLjMxNzc2IDAsLTIuODE2NzkgLTMwLjk5MTQ1LC0xNS41ODkzMyAtNzkuOTg5NDk2LC0zMi45NjYxNSAtMTEuMTA5NjYsLTMuOTM5OTcgLTIwLjE5OTM3NSwtNy44MjkyOCAtMjAuMTk5Mzc1LC04LjY0MjkxIDAsLTAuODEzNjYgMjMuNDcwNzM4LC0xLjAwNDc2IDUyLjE1NzE5MSwtMC40MjQ2OSBsIDUyLjE1NzIxLDEuMDU0NjYgNS4wOTEyNywtOC4wMzAwMSBjIDIxLjUxNjQ0LC0zMy45MzU5MiA1NC4wMDk1MiwtNjQuNTg4MjEyIDY4LjQ2NzA1LC02NC41ODgyMTIgMy4wMTA2LDAgOS4xMjE0MSwyLjg2OTE4IDEzLjU3OTUzLDYuMzc1OTQ1IDcuMjU5NDYsNS43MTAyODMgOC4yNTY1LDkuMjQ4NjMyIDkuNTQ5OTQsMzMuODkxOTY3IDAuNzk0MywxNS4xMzM4MiAyLjQyNDIyLDI4LjQ5NjAxIDMuNjIxOTgsMjkuNjkzNzkgMS4xOTc3NSwxLjE5Nzc2IDQuOTk3NjksLTAuMzc0MjUgOC40NDQzMSwtMy40OTMzOSA0LjQwMTQsLTMuOTgzMjMgOS4wMzQ4NCwtNS4wNjMxMyAxNS41Njc2MSwtMy42MjgzIDYuNzY3NTYsMS40ODY0MSAxMC42MjcxLDAuNDY4OTUgMTQuMTY5MzgsLTMuNzM1NDMgNS4zMTM2LC02LjMwNjY2IDMxLjkwNTk2LC00OC45MzcyMDEgMzEuOTA1OTYsLTUxLjE0ODc0NCAwLC0wLjc1MTU4OCA1LjI2NTA5LC05Ljc1NzMwNiAxMS43MDAyMywtMjAuMDEyNzAzIDYuNDM1MDksLTEwLjI1NTM5NyAxMy44NDY2NCwtMjIuMDgwNjMxIDE2LjQ3MDA3LC0yNi4yNzgyODMgNC42NjU1OCwtNy40NjUyMDEgNS4zOTY2LC02LjU4MTczNSAzMy40MjY5Miw0MC4zOTg3MzYgMjguOTQxMjEsNDguNTA3MTY0IDQ0LjUxNzY3LDY2LjQwNjU1NCA1Mi4zMTU3LDYwLjExNzYzNCA1LjQ0MiwtNC4zODg4OSAzNC4wMDA1NSwtNC42Mzc5NCA0MS45ODI0NiwtMC4zNjYxNCA0LjUzNjY1LDIuNDI3OTMgNy40MTkxNiwyLjM5NjEgOS45MjQ4NCwtMC4xMDk2MiA1LjIwMDA3LC01LjIwMDA2IDE3LjY0OTgyLC00LjI5NDM3IDIwLjkwNDEyLDEuNTIwNzggMi41NjM5Myw0LjU4MTQ2IDMuMjE3ODQsNC41ODE0NiA3LjAyMDE0LDAgMi4zMDYwNiwtMi43Nzg2NyA5LjEzNjE5LC01LjA1MjA4IDE1LjE3ODAzLC01LjA1MjA4IDguNTM4ODQsMCAxMS43OTMzNiwxLjc3MzY3IDE0LjYxNDAzLDcuOTY0MzcgbCAzLjYyODgxLDcuOTY0MzYgNTYuMDkyMDMsLTEuOTg1OCBjIDMwLjg1MDYyLC0xLjA5MjIyIDU2LjA5MjA0LC0xLjI4Njg4IDU2LjA5MjA0LC0wLjQzMjU1IDAsMC44NTQyNyAtMjIuOTA2MDgsMTAuMDcxOTUgLTUwLjkwMjQxLDIwLjQ4MzcxIC0yNy45OTYzMiwxMC40MTE3MiAtNTEuMzY3LDE5LjI0MzA1IC01MS45MzQ4NCwxOS42MjUxMiAtMC41Njc4NSwwLjM4MjA3IDAuNjk4NDcsOS40OTI3MyAyLjgxNDA1LDIwLjI0NTg4IDUuNTA0NTcsMjcuOTc5MTcgMS45MTQ1OCw0Ni42MjU4OSAtMTEuOTI2MjksNjEuOTQ2MDQgLTYuMjA5LDYuODcyNjMgLTE2LjI4MzM4LDE0LjE0Mzk1IC0yMi4zODc1MywxNi4xNTg0OSAtNi4xMDQxNSwyLjAxNDU0IC0xMS4wOTg0NCw0LjM4NjE0IC0xMS4wOTg0NCw1LjI3MDE5IDAsMC44ODQwNiA2LjUxNTI1LDExLjY3ODkzIDE0LjQ3ODM1LDIzLjk4ODU5IDcuOTYzMDksMTIuMzA5NjkgMTMuMjgyOCwyMi4zODEyNSAxMS44MjE1MiwyMi4zODEyNSAtMi4zODUwNCwwIC02MC40Njk4NywtMjIuNDQyMzggLTE1MC43ODg5OCwtNTguMjYwNyAtMTcuODA5LC03LjA2MjU4IC0zNC4wMjY4MywtMTIuODQxMDkgLTM2LjAzOTYxLC0xMi44NDEwOSAtMy43NTM2MywwIC0zNi4xNjY5LDEyLjI4NjYyIC0xMzEuMjI0MjMsNDkuNzQyMDYgLTU1LjEyNTI1LDIxLjcyMTAzIC01Ny4yOTIxNywyMi40NzM0OCAtNTcuMjkyMTcsMTkuODk0NTEgeiBtIDExMy4xMTY0OCwtNTEuMjUyNjUgYyAyOS4zMjk0OSwtMTEuMzk1MDYgNTguNDE2NTcsLTIyLjUzMDggNjQuNjM3OTgsLTI0Ljc0NjA3IDEwLjcwMDY4LC0zLjgxMDE5IDE0LjI3OTE4LC0yLjg1NDkzIDY2LjI1Mzk0LDE3LjY4NjM0IDMwLjIxODI1LDExLjk0Mjc0IDYwLjAzMjUyLDIzLjU3NTg3IDY2LjI1MzkyLDI1Ljg1MTM0IDYuMjIxNDEsMi4yNzU1MiAxOS4wNDMxNyw3LjIyMDU5IDI4LjQ5Mjc1LDEwLjk4OTA4IDEwLjc3NTAzLDQuMjk3MDQgMTYuMjgyNTEsNS4zMzE2NiAxNC43NzEwOCwyLjc3NDg0IC0xNi44ODM3LC0yOC41NjExMyAtMTcuMzk5OCwtMjkuMDM3MTYgLTI5LjEwMDgzLC0yNi44NDIwNSAtMTQuMTEzNjEsMi42NDc3MiAtMjIuODc4OTcsLTAuMDY4NSAtMjcuMzgzNjksLTguNDg1NTQgLTIuOTIxMTIsLTUuNDU4MTYgLTIuMDI5NDQsLTguMTI3NTkgNS4yNTQ0MiwtMTUuNzMwMzEgMTAuODQ4ODcsLTExLjMyMzc3IDkuMTQ0NTcsLTIxLjc0MTQ0IC00Ljg0NDI5LC0yOS42MTA5OSAtNS4zNjc2NCwtMy4wMTk1OSAtMTIuMTQwNTksLTEwLjQ4MzcyIC0xNS4wNTEwMiwtMTYuNTg2OTcgbCAtNS4yOTE2OSwtMTEuMDk2ODIgLTExLjM0NTUxLDcuNjk5MjggYyAtMTMuOTQ0NTgsOS40NjMwNCAtMzAuOTUwNjIsOS45NTA2MyAtNDUuMTQ3NjQsMS4yOTQ0OCBsIC0xMC40NjQ4OCwtNi4zODA2NSAtMTIuMTU4NDEsOC4yNjI4NCBjIC0xMi4xNzQ2Miw4LjI3Mzg2IC0yNi4xOTEwOCw5LjM0MjggLTQwLjQzNzUyLDMuMDgzOTIgLTMuOTI0OTgsLTEuNzI0MzkgLTUuNjU1ODMsLTEuMDU0MTUgLTUuNjU1ODMsMi4xOTAwOCAwLDIuNTcxMTggLTMuNzA0MjksNi4zNjI2NSAtOC4yMzE4MSw4LjQyNTUzIC0xMy41NzQyLDYuMTg0NzkgLTI2LjgyMTA3LDQuNTQyNDcgLTM1LjgwMjI5LC00LjQzODc1IGwgLTguMTg5NDQsLTguMTg5NDQgLTYuNjA5ODIsOC40MDMwMyBjIC0zLjYzNTM5LDQuNjIxNjYgLTEyLjA0OTUyLDExLjgzNjk4IC0xOC42OTgwNSwxNi4wMzM5OCAtOC4yMjk2NSw1LjE5NTE4IC0xOC40MTc0MSwxNy44NzE4MiAtMzEuOTE2NCwzOS43MTM2MSAtMTAuOTA1NDksMTcuNjQ1NDYgLTE5LjgyODE2LDMyLjk4MDQyIC0xOS44MjgxNiwzNC4wNzc3NiAwLDEuMDk3MyA4LjM2MjU1LC0xLjUyNzM2IDE4LjU4MzQyLC01LjgzMjU5IDEwLjIyMDg5LC00LjMwNTIxIDQyLjU4MDI4LC0xNy4xNTA4NyA3MS45MDk3NywtMjguNTQ1OTMgeiBtIDI0OC43NjcyOSwtMTIuMjU4NDYgYyAyMi4yNTU1NywtMTIuNTA4MzMgMjcuNDE0MjQsLTM1LjY0ODA4IDE3LjU3Njg1LC03OC44NDMxOCAtOC4yMjE0LC0zNi4wOTk2MSAtMTIuMzI1NSwtNDcuOTEzMjcgLTE3LjE5NDk0LC00OS40OTU5NyAtMy4zNjkwMiwtMS4wOTUwMyAtMy44ODY3NCwwLjEwNjk5IC0xLjk4ODU4LDQuNjE2MzUgMTIuMzE1MTYsMjkuMjU3NzEgMTIuOTk5NjMsNDMuOTQ2NjIgMi4yNDAyMiw0OC4wNzU0MSAtNy4zOTE1MSwyLjgzNjQyIC0xNS4yMzIzOSwtNy43OTA3NSAtMjEuMzk5MDIsLTI5LjAwMzI2IC00Ljc3NTEyLC0xNi40MjU4NyAtOS43Njg2MSwtMjMuODI4MzcgLTEzLjUzMzg3LC0yMC4wNjMxMSAtMC45MDE1NywwLjkwMTYgMC42Nzg0OCw2LjEyMTE3IDMuNTExMjQsMTEuNTk5MTMgMi44MzI3Myw1LjQ3NzkgNi43MTcyMSwyMS45NzQ1NSA4LjYzMjE3LDM2LjY1OTIgMS45MTQ5NywxNC42ODQ2MiA1LjYxMzg1LDMwLjA2MDczIDguMjE5NzMsMzQuMTY5MTIgNi43NzE5OCwxMC42NzY2MSAxNy41NTEyOCw4LjEwMzYgMjQuNTIzODIsLTUuODUzODQgNi44OTM3MywtMTMuNzk5NzUgNy42NzI4NCwtNC42MDc4MSAwLjk2OTMsMTEuNDM2MDIgLTYuOTYwNzQsMTYuNjU5MzcgLTI3LjYzNDQyLDIxLjY1NDgxIC01MS41ODQxOCwxMi40NjQ0MiAtMy44MzMzLC0xLjQ3MDk2IC01LjEzMDM5LDAuMDUxNSAtNS4xMzAzOSw2LjAyMDk3IDAsNC4zOTQzMSAtMi45MzYxOCwxMS43MjI0NSAtNi41MjQ4OCwxNi4yODQ3IGwgLTYuNTI0ODgsOC4yOTUwNiA4Ljk0ODgxLDEuNTExMjMgYyAxNS40NDk0NSwyLjYwOTA5IDM2LjYzMzI4LC0wLjc3NjQyIDQ5LjI1ODYsLTcuODcyMjUgeiBtIC0zMjAuMzY2NSwtMjcuNTM3MzMgYyA0Ni40NTk2NSwtMTMuMzU0NSA1NC43NjE4OCwtMjguOTMwOTMgMzkuMzI4ODUsLTczLjc4NzgyIC0zLjU4MTg1LC0xMC40MTA3OSAtNi41MTI0MywtMjEuNjA5NzEgLTYuNTEyNDMsLTI0Ljg4NjU0IDAsLTExLjE1NzEyIC01LjYxMTUyLC02LjAwMTYxIC05LjgxNzEzLDkuMDE5NDMgLTUuNTYyMDMsMTkuODY1NjEgLTIyLjI5MTE1LDM2Ljc1MDUzIC0zNi4zNDUxNiwzNi42ODM2NCAtMTIuMjA1NDcsLTAuMDU4MiAtMTYuMTgyNTEsLTIuMjgwMDggLTIxLjIyMzc4LC0xMS44NTc2OCAtOS4wNDc0OCwtMTcuMTg4ODIgMC44MTQ2OSwtNDMuNTY3OTcgMjUuOTY5NTQsLTY5LjQ2MjcyIDE4LjQyNDMxLC0xOC45NjYzMDQgMjguNDg4OTMsLTIwLjY4Mzk2NSAyOC40ODg5MywtNC44NjIwNSAwLDI0LjY3MzIgLTE3LjAxMTM0LDYwLjk5NDcgLTI1Ljk3MzA5LDU1LjQ1NjA0IC00LjM4MjA1LC0yLjcwODI2IC0zLjY3MTM4LC0xNC42Njc1MiAxLjQxNzIyLC0yMy44NTAwOSA0LjMyNzM1LC03LjgwODgyIDMuNDQ4MTQsLTE5LjcwNzcxIC0xLjQ1NjIsLTE5LjcwNzcxIC01LjY4Njg5LDAgLTE2Ljk0NTQ3LDIwLjcxMTk2IC0xOC40MzMxOCwzMy45MTA3NCAtMS4zMTUxNSwxMS42NjgyNiAtMC40OTI4NiwxNC41MDU0NSA1LjA2NjUyLDE3LjQ4MDcyIDE5LjQ4MjQ0LDEwLjQyNjcgNDUuMDA1MzEsLTIxLjM5NTQ1IDQ2LjI5MDgzLC01Ny43MTU4NCAwLjY3NTA0LC0xOS4wNzMxODEgLTMuMDE2NzYsLTI0LjQ0MTEwNSAtMTQuNzc5MDYsLTIxLjQ4ODk1MSAtMTcuMTE4NzksNC4yOTY1NDMgLTYzLjIzNDgzLDYzLjc4NjY0MSAtNjMuMjM0ODMsODEuNTczNDYxIDAsMTMuOTEyOCA2Ljk4NzM3LDIzLjY5NzI4IDE5LjI4ODI3LDI3LjAwOTYgMjAuOTE0MTksNS42MzE2MiA0MS4xMzUzOSwtNC4zNzM4OSA1NS40NjMzLC0yNy40NDMzOCBsIDYuMDIxNzUsLTkuNjk1NzEgMC4wMTMyLDEzLjE3MjIzIGMgMC4wMTYyLDE5LjA3MzggLTEyLjQyNjE5LDI5LjEyNzQgLTUxLjY5ODE3LDQxLjc2NzkzIC05Ljc3NjQ5LDMuMTQ2OCAtMTguMTgzMzIsNi4wNTQ0MSAtMTguNjgxOCw2LjQ2MTM3IC0xLjgyMDU2LDEuNDg2MzIgMTYuNjg3MzksMjcuNDc1NzEgMTkuNTY2NDQsMjcuNDc1NzEgMS42MzI2MiwwIDExLjE5MTE1LC0yLjM2MzU5IDIxLjI0MTIzLC01LjI1MjM4IHogTSA0NzYuNDExLDIxNy45NjMwMSBjIDQuNjYzNDcsLTUuMTUzMSA1LjQ4NTUxLC0xMC43NTEwMyA0LjQ4NTc5LC0zMC41NDgyMyAtMS4wODczOSwtMjEuNTMzMzEgLTIuMjc3NDYsLTI1LjMzODUxIC0xMC42NjE0MywtMzQuMDg5NDkgLTE1LjE0ODgyLC0xNS44MTE5NCAtMzMuODYxMjMsLTExLjc3ODI4IC0yMi45MDgxOSw0LjkzODE0IDUuODIyNTYsOC44ODYzNyAxMi45MjU0LDcuMzY4NjQgMTAuNDE2NDEsLTIuMjI1ODEgLTEuOTk4NjQsLTcuNjQyNzYgMS43Mjk5OCwtNy44NDM1OCA4LjIyODM5LC0wLjQ0MzIyIDEyLjE5MzAxLDEzLjg4NTM3IDkuMTE1MzQsMzMuMTI2OTggLTUuMjk4NiwzMy4xMjY5OCAtOS44NjcxNiwwIC0xMi45NDE5NSwtNC4yMzE3NiAtMTkuMzczNTMsLTI2LjY2MzE4IC0yLjkzMDU5LC0xMC4yMjA4NyAtNi40OTk2NCwtMTguNTgzNDMgLTcuOTMxMjcsLTE4LjU4MzQzIC00Ljc2ODk5LDAgLTYuODkyODcsNC4yMDg3OCAtMy45MjcyMSw3Ljc4MjQgMS42MTA4OCwxLjk0MTEgNi4wNzIxOCwxNS44OTEyNyA5LjkxNDA0LDMxLjAwMDQxIDkuNjY5MDMsMzguMDI1OTYgMjMuMTc2NjYsNTEuMDQxNDUgMzcuMDU1NiwzNS43MDU0MyB6IG0gLTE4My43NzEyNSwwLjYwMzk1IGMgMS45ODk3OCwtMS4zMzUgMi44OTk3NSwtNy42NDg5MyAyLjA3ODY1LC0xNC40MjMgLTEuMzI0NDksLTEwLjkyNzAyIC0yLjA2NjYyLC0xMS43MjQxIC03Ljk3MjcsLTguNTYzMjcgLTguNDg3MzMsNC41NDIyNyAtMTcuNjA4MzksLTQuMDYzNTEgLTIwLjcwMjIyLC0xOS41MzI2IC0yLjM0NzA3LC0xMS43MzUzOCAtMy4wNjUyNiwtMTEuNTA0ODkgMTQuMDI1NzYsLTQuNTAxNDkgMi4xNDI4OCwwLjg3ODA4IDcuNTk2NzEsLTIuMTA0MDIgMTIuMTE5NjMsLTYuNjI2OTQgOC4yNzQwOCwtOC4yNzQwOCAxMC45OTgwMiwtMTguMjEyOTkgNC45OTE1NiwtMTguMjEyOTkgLTEuNzc3NTQsMCAtMy4yMzE5LDEuNDU0MzYgLTMuMjMxOSwzLjIzMTkgMCw0LjY0OTIzIC04Ljg0MjMxLDMuOTg5ODIgLTEwLjgzNDY1LC0wLjgwNzk3IC0xLjE2MjI0LC0yLjc5ODc5IC0zLjYzODA3LC0xLjgwNTkxIC04LjA1OTE1LDMuMjMxOSAtMy41MDk4NSwzLjk5OTQ4IC03Ljc5NjczLDcuMjcxNzggLTkuNTI2NDEsNy4yNzE3OCAtMS43Mjk2OSwwIC00LjA2NTYsLTMuMjcyMyAtNS4xOTA4OCwtNy4yNzE3OCAtMS45NzE5NSwtNy4wMDg1NiAtMi4yMTM2NiwtNy4wNTI3NyAtNi42NzczNywtMS4yMjE2OSAtMy45MTA2LDUuMTA4NTQgLTMuOTQ1NTcsNi43MzU4MyAtMC4yMjQ2MSwxMC40NTY2MSAzLjk0MDYyLDMuOTQwNjQgMTEuNDI2MTUsMzAuODcxMDIgMTEuNDI2MTUsNDEuMTA3NDQgMCwxMi43Mjg2NyAxNy41MjkzMywyMi43MzgzMiAyNy43NzgzLDE1Ljg2MjEgeiBtIDU4Ljk0MzA5LC0xNi44NzUzMSBjIDEyLjE0NTY3LC0xMi4xNDU2NyAxNS43NDQ1MiwtMzAuMzUxNDMgOS4xMjk0MywtNDYuMTgzNTcgLTUuMTcwMTYsLTEyLjM3Mzk3IC0xNC4xNDQ2NiwtMTcuMDA1MTYgLTI2Ljc5ODc4LC0xMy44MjkxOCAtOS40MDI2MywyLjM1OTkxIC0yMy43MjMxMSwyOS43NzY1OSAtMjMuNzczODcsNDUuNTE1MzYgLTAuMDc5MiwyNC41MjkwMiAyMy4yNTA1MywzMi42OTAwNSA0MS40NDMyMiwxNC40OTczOSB6IG0gLTIyLjA4MzQxLC0xOS40MzQwNyBjIC0zLjU1NTEsLTMuNTU1MSAtNi40MTc1NSwtMTAuNDYzMjggLTYuMzYxMDIsLTE1LjM1MTUzIDAuMDkzNCwtOC4wNzk2NSAwLjQ5MzE1LC04LjM3MzUgNC4zOTYxOSwtMy4yMzE5IDQuODI0NjQsNi4zNTU2OSAxMy4zOTc5Nyw3LjQ1NjY2IDE2LjY4MjQxLDIuMTQyMzIgMS4xOTQzMiwtMS45MzI0MSAwLjU1Mjk1LC01LjEzMjAyIC0xLjQyNTIsLTcuMTEwMTcgLTUuMDgxMzIsLTUuMDgxMzIgLTQuNDY1NjEsLTExLjk5OTYzIDEuMDY3OTIsLTExLjk5OTYzIDYuMTUxMzcsMCAxNC43MjY3OSwxMi41MTQ3NyAxNC43MjY3OSwyMS40OTE5MSAwLDYuNjA2NzQgLTEzLjQ0NDQsMjAuNTIyOCAtMTkuODI3MjQsMjAuNTIyOCAtMS41Mzc4NSwwIC01LjcwNDc2LC0yLjkwODcyIC05LjI1OTg1LC02LjQ2MzggeiBtIDg2LjM0ODk3LDE4LjU4MzQxIGMgMTMuNDEwNzQsLTE0LjYwMjYzIDEyLjEwMzc2LC0zNy4wOTggLTMuMDk4MjUsLTUzLjMyNjM0IC03Ljg1MDU3LC04LjM4MDYgLTI1LjI5Mjk4LC05LjgyNTUyIC0zMi40MzE4NSwtMi42ODY2NCAtNi41ODc2MSw2LjU4NzYxIC0xMy4xNjQ2NSwzMi40OTMwMyAtMTAuNzIxMjIsNDIuMjI4NDEgNS4yMTEyMiwyMC43NjMxOCAzMi40MDA0MSwyOC44NjY1MiA0Ni4yNTEzMiwxMy43ODQ1NyB6IG0gLTI3LjQ1NTY1LC0yMy42MTQ1MiBjIC01LjMwNjIzLC0zLjcxNjY0IC03LjEyOTQxLC04LjE0OTc0IC02Ljk3ODA2LC0xNi45Njc0NyAwLjE2OTM1LC05Ljg2MDMzIDAuNjg0MywtMTAuNzQ5ODEgMi45NjE0NSwtNS4xMTQxNSAzLjM0NTczLDguMjgwMzIgMTAuMzYyOTIsMTEuNDA3MzQgMTYuNTE4MTQsNy4zNjA5IDMuODE3NTMsLTIuNTA5NjMgMy42MzkyOSwtMy42OTU5NyAtMS4xMDEwNCwtNy4zMjkwNyAtNi4zMjE4OSwtNC44NDUyMyAtNy41NTUwOCwtMTEuNzAxOTEgLTIuMTA0NjUsLTExLjcwMTkxIDQuODczNjQsMCAyMi4zMDQwMiwxOS4wNjY2NiAyMi4zMDQwMiwyNC4zOTc3OCAwLDUuMjAzMTYgLTEyLjM3NzM5LDE0LjM4NTAzIC0xOS4zOTEzOSwxNC4zODUwMyAtMi43NjQwNSwwIC04LjI1NzksLTIuMjY0MDIgLTEyLjIwODQ3LC01LjAzMTExIHogbSAxODkuOTYyOTIsLTE0LjI4ODg3IDMzLjkzNDk1LC0xMi43MzY4MiAtMzYuMzU4ODgsLTAuMTMxMjUgYyAtMzIuNTM5MiwtMC4xMTczNiAtMzYuMzU0MjQsMC40NjMwNyAtMzYuMzE0NzUsNS41MjQ3NSAwLjA0MDEsNS4xMjc1NyAzLjMzMDczLDIwLjI4Mzk1IDQuMzcyNywyMC4xMzk2NyAwLjIzNzIyLC0wLjAzMjkgMTUuNzAxNzcsLTUuNzkxMjQgMzQuMzY1OTgsLTEyLjc5NjQ4IHogbSAtNDQzLjQ5MzQzLC0yLjI3OTMgMy40NjgyNSwtMTAuMjg3NjEgLTMwLjQ2Njg2LC0xLjAyNDA0IGMgLTE2Ljc1Njc0NCwtMC41NjMyMiAtMzAuNDYzNTg0LC0wLjEzMjEzIC0zMC40NTk1OCwwLjk1ODA0IDAuMDA1OCwxLjU5NTEzIDUyLjUwNjU3LDIyLjEwNzA3IDUzLjY2MTc0LDIwLjk2NTUyIDAuMTgwMzUsLTAuMTc4NCAxLjg4ODkyLC00Ljk1MzcyIDMuNzk2NDUsLTEwLjYxMTkxIHogbSAyMDguOTA5MiwtMzEuODg2OTUgYyA3LjE2NjY3LDEuMTQ2IDE1LjI0OTgxLDQuMDc5MjQgMTcuOTYyNTYsNi41MTgzNSA0LjIxMjc5LDMuNzg3ODMgNi4wNDUyOCwzLjUyOTY2IDEyLjU2MjA3LC0xLjc2OTg1IDQuMTk2NDMsLTMuNDEyNSA5LjY1MDI2LC02LjIwNDU3IDEyLjExOTYzLC02LjIwNDU3IDIuNDY5MzksMCA0LjQ4OTgyLC0wLjcxMzA4IDQuNDg5ODIsLTEuNTg0NjcgMCwtMy4wMDkxOCAtNDYuNTM5NTQsLTc5LjIxMjUyIC00OC4zMTQ0NywtNzkuMTA5NjEgLTIuMDg1LDAuMTIwODcyIC00OS43ODYwMyw4MC4wODc5OCAtNTEuMjU0NjQsODUuOTI0MzcgLTAuNjE2MzQsMi40NDk1MiAxLjMxODA0LDMuMzUzNzEgNS4wNzM2NCwyLjM3MTYgMy4zMzgzNiwtMC44NzMgNy45NTQxNiwwLjY4MzI2IDEwLjI1NzI3LDMuNDU4MzYgMy43MzU0LDQuNTAwODcgNS4yNjEwOCw0LjE0MjI5IDE0LjEzMDY4LC0zLjMyMDk3IDguNDI2NDcsLTcuMDkwNDEgMTEuOTMwOCwtOC4wNDg4IDIyLjk3MzQ0LC02LjI4MzAxIHoiDQogICAgICAgc3R5bGU9ImZpbGw6IzMzMzMzMztmaWxsLW9wYWNpdHk6MSIgLz4NCiAgICA8cGF0aA0KICAgICAgIHN0eWxlPSJmaWxsOiM2Mzk4YWE7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmUiDQogICAgICAgZD0ibSAzMDkuNTQ1NzksMTQwLjg3OTIyIGMgLTAuNTAwNzUsLTAuMjMzMTEgLTEuMTE4MDQsLTAuNzY3OTkgLTIuNTI3OCwtMi4xOTAzNSAtMS45MTE4OCwtMS45Mjg5NyAtMi42NzE4OCwtMi40OTAxMyAtNC4yNjEwOCwtMy4xNDYyOCAtMi4wODc5MSwtMC44NjIwNCAtNC4zNTQ5LC0xLjA5NDIzIC02LjQ4MjMxLC0wLjY2MzkxIC0xLjg5ODA4LDAuMzgzOTMgLTIuNDI0MzUsMC40MjUyNyAtMy4yODI0MiwwLjI1NzggLTEuNDMyMjQsLTAuMjc5NTMgLTEuOTQxNTcsLTEuMTQ5MjkgLTEuNTM1ODMsLTIuNjIyNzIgMC41MDU3MywtMS44MzY1NyA0LjMzNjkzLC04Ljk0MjU1IDEyLjAwODk5LC0yMi4yNzM4NyAxNS41ODM3LC0yNy4wNzg5ODggMzYuNTM2MjQsLTYxLjIyMDk2OCAzOC44NTA1NiwtNjMuMzA2NjYyIDAuMjU2MzEsLTAuMjMwOTk0IDAuMjY1LC0wLjIzMDk5NCAwLjUyMjQ4LDAgMS4zNzc2OCwxLjIzNTk3NiA5LjQ3NjIsMTMuNzI1ODg5IDIwLjU0MDM2LDMxLjY3ODI5OCAxNC45NjY5NiwyNC4yODUwMDQgMjcuNDExMDIsNDUuNjQzNzE0IDI3LjQxMTAyLDQ3LjA0NzcwNCAwLDAuODU3MjkgLTEuMzE2MDgsMS4zNzIxNSAtNC4wODU5MSwxLjU5ODQ1IC0zLjQ0MjI2LDAuMjgxMjQgLTcuNDI0NzgsMi4zMDE4OCAtMTIuODY4ODcsNi41MjkzNiAtMi41ODcxMiwyLjAwODk4IC0zLjY5MTI2LDIuNzU5MzMgLTQuOTUwNjIsMy4zNjQzOCAtMS4wNDkyOCwwLjUwNDExIC0xLjEzNjkyLDAuNTI0MzcgLTIuMjY4NTQsMC41MjQzNyAtMS4xMTM2OCwwIC0xLjIyNjYxLC0wLjAyNDkgLTIuMDk2MjMsLTAuNDYxMjggLTAuNTEyMTMsLTAuMjU3MDIgLTEuNTA0NjksLTAuOTQ5MyAtMi4yNDE1NSwtMS41NjM0MiAtMi4xNzg0OCwtMS44MTU2MSAtNC43OTkxOCwtMy4xMzYxNCAtOS4wNzE5NywtNC41NzEyNCAtNS40Mjk5NywtMS44MjM3NiAtMTEuMjQ0NTQsLTIuOTE4NCAtMTYuMTk1NTEsLTMuMDQ4OTYgLTMuOTA5MzQsLTAuMTAzMDggLTUuNzEyMDEsMC4yNDc5OCAtOC42NzYwMiwxLjY4OTYzIC0yLjQxOTg4LDEuMTc2OTggLTMuNTg2MjEsMi4wMTMxMSAtOS4xMjQ3NSw2LjU0MTQ1IC01LjYzMzc2LDQuNjA2MTcgLTcuNjM0NDIsNS41NjIwNSAtOS42NjQsNC42MTcyNSB6IiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6IzYzOThhYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSINCiAgICAgICBkPSJtIDEyOC42Mzc4NiwxNzAuNzM5IGMgLTEwLjE1OSwtMi45NjA3IC00NS41MDMxNzEsLTE2LjkxOTYyIC01MC40NTA5MjQsLTE5LjkyNTIzIC0wLjY4MjkxNiwtMC40MTQ4NCAtMC43MzgwOTgsLTAuNDc3ODcgLTAuNTQzMjA3LC0wLjYyMDM4IDEuMTMxNTYzLC0wLjgyNzQxIDEyLjMzNzk4MywtMS4yMzkwMSAyNS4wMDQwMzEsLTAuOTE4MzYgNS4wNTEzMSwwLjEyNzg4IDM1LjUwMTMyLDEuMTMzMjMgMzUuNTUwOSwxLjE3Mzc3IDAuMDk5NywwLjA4MTUgLTYuNTIxNjQsMTkuMjg4OCAtNy4wMzA1MSwyMC4zOTQzMyAtMC4yMTI1MSwwLjQ2MTcgLTAuNjUwNjMsMC40NDM2NyAtMi41MzAyOSwtMC4xMDQxMyB6IiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6IzYzOThhYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSINCiAgICAgICBkPSJtIDU0My42OTQxMywxNzUuMzEwNTUgYyAtMS4zODYyLC0yLjcxMjg3IC0zLjg4NzY5LC0xNC45NzA2NyAtMy45NjA3OCwtMTkuNDA4NTggLTAuMDI4NCwtMS43MjQyNCAwLjE4NjY3LC0yLjQyNzQxIDAuOTYwNiwtMy4xNDA4IDEuNzczNzgsLTEuNjM1MDEgNS4zNzkzOCwtMi4yMjMyIDE1LjI5MDE3LC0yLjQ5NDM0IDUuMDAzNDcsLTAuMTM2ODkgMjguMTAxOSwtMC4xNTc5NiA0NC40MTEyNywtMC4wNDA1IGwgMTEuNDI4NTksMC4wODIzIC0yNy41MTc3LDEwLjMxNDI3IGMgLTI1LjA5MjkyLDkuNDA1NCAtMzkuNjg0NzMsMTQuODQxMjYgLTQwLjIyNDkxLDE0Ljk4NDkgLTAuMTM1MTcsMC4wMzYgLTAuMjY5ODEsLTAuMDY3NCAtMC4zODcyNCwtMC4yOTcyMyBsIDAsMCB6IiAvPg0KICAgIDxwYXRoDQogICAgICAgc3R5bGU9ImZpbGw6IzYzOThhYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZSINCiAgICAgICBkPSJtIDE3OC4wODgzNSwzMTUuNTE0MzMgYyAwLC0wLjc3MDc4IDMuMjY4OSwtNi41MzMxIDExLjU1Mzk1LC0yMC4zNjY5OCAxOS44NTExOCwtMzMuMTQ2MzEgMjguOTI3MTUsLTQ1LjE2MDEyIDQwLjA3MjkyLC01My4wNDQyOSA5Ljk3MTI3LC03LjA1MzM3IDE1LjMwMjc5LC0xMS45Mjk0IDIxLjI0NTM5LC0xOS40MzAzMyBsIDMuNjY0MDksLTQuNjI0OTIgNC45Mzk5LDQuODU2NTIgYyA4LjY0Nzg0LDguNTAxODkgMTMuODYxMywxMC45NjY2OCAyMy4yOTcxNywxMS4wMTQzMiAxMS41NDA1OCwwLjA1ODMgMjQuMTc4NDksLTYuMzg4MSAyNC4xNzg0OSwtMTIuMzMyOTkgMCwtMS4zMzk4IDAuOTU0MDQsLTIuNzIyMzYgMS44Nzg1NywtMi43MjIzNiAwLjM5MTMyLDAgMi42MTY4NiwwLjY4MzY1IDQuOTQ1NjUsMS41MTkyMyA2LjA2OTkyLDIuMTc3OSA5LjYzMDI4LDIuOTY1NDggMTQuNjA5MTIsMy4yMzE2NSA0LjkzOTk4LDAuMjY0MDkgOC41NDg0OCwtMC4xNzA0IDEzLjM1ODE3LC0xLjYwODQxIDQuNzI1NjEsLTEuNDEyODggNy40NDcwOSwtMi44NTkwNSAxNS41OTgzMywtOC4yODg4MiA0LjEwNzYsLTIuNzM2MTggNy41OTk1NCwtNC45NzQ4NyA3Ljc1OTg4LC00Ljk3NDg3IDAuMTYwMzMsMCAzLjEyNTM0LDEuNzE4OTYgNi41ODg5LDMuODE5OTEgMy40NjM1NiwyLjEwMDk1IDcuNjI1NDIsNC4zODEzMyA5LjI0ODU5LDUuMDY3NTEgMTEuMDY4NjIsNC42NzkxOCAyMy4wMjQ0NSw0LjM3MzkgMzMuOTcxMjYsLTAuODY3NDEgMS45NTc5NSwtMC45Mzc0NyA2LjU2NzkzLC0zLjczMDc0IDEwLjI0NDQsLTYuMjA3MjcgMy42NzY0OCwtMi40NzY1MyA2LjczNjEzLC00LjQ0NTc2IDYuNzk5MjMsLTQuMzc2MDYgMC4wNjMxLDAuMDY5NyAxLjQ1NjA1LDIuOTIwOCAzLjA5NTQ0LDYuMzM1NzggMS42Mzk0LDMuNDE0OTggMy42OTg5NSw3LjI2NjcgNC41NzY3OSw4LjU1OTM3IDMuODAwMDEsNS41OTU3OCA4LjE3NTg4LDkuNzUxNDEgMTQuMDgzNDMsMTMuMzc0NjQgNi4wODEyMiwzLjcyOTc1IDkuODMyMDYsOC42ODY4IDEwLjIxODgyLDEzLjUwNTA3IDAuMzgzNjcsNC43Nzk2OCAtMS43MDMyOSw5LjAxOTM5IC03LjcyMTg5LDE1LjY4NzIxIC00LjY5NzQ3LDUuMjA0MTkgLTUuODczMyw3LjIzNTQgLTUuODYxMTMsMTAuMTI0OTEgMC4wMTIyLDIuODkyNjIgMS43MDEwMyw2LjIyODU0IDQuNjY5NjQsOS4yMjM3OSA0LjgwNTMzLDQuODQ4NDQgMTIuMzQ2MDUsNi4yODc3NyAyMy40MzUzNCw0LjQ3MzE5IDIuNDc0MDgsLTAuNDA0ODQgNS41OTQ3OSwtMC43Mzc1NyA2LjkzNDkxLC0wLjczOTM4IDQuMjg1NTEsLTAuMDA2IDYuOTAzMTksMi4wOTU5NSAxMS44OTI1MSw5LjU0ODU5IDMuNDQzNTEsNS4xNDM2NSAxMC45NzM5NiwxNy43NTUwOCAxMC45NzM5NiwxOC4zNzgzNiAwLDAuMzI0MDcgLTAuMzUxNDUsMC41NTIwOCAtMC44NTA5NywwLjU1MjA4IC0xLjA1MTA5LDAgLTUuNjIzMTQsLTEuMjQzOCAtOC45MzIxNCwtMi40Mjk5NCAtNC4zNDg1LC0xLjU1ODc1IC01Ny4yNzIzOCwtMjIuMDA1MjYgLTc0Ljc0Nzg2LC0yOC44Nzc5NSAtNDYuNjYzNSwtMTguMzUxNjIgLTYyLjAyODA1LC0yNC4yMTI0NiAtNjkuNTM2NTcsLTI2LjUyNDg5IC04LjExNDE3LC0yLjQ5ODk1IC0xMy42NDAyOSwtMy4wODUyMiAtMTguMTI2NjEsLTEuOTIzMDYgLTUuNTc5OTYsMS40NDU0NiAtODEuNzIwNjcsMzAuODY4ODggLTEyNi4xMzI0NSw0OC43NDE5NSAtMjEuOTMxMTksOC44MjYgLTI0LjY3NzQ5LDkuODc1NzcgLTI4Ljc4MTE2LDExLjAwMTU5IC0zLjI2MzAzLDAuODk1MjEgLTMuMTQ0MDcsMC44ODI5NCAtMy4xNDQwNywwLjMyNDI2IHoiIC8+DQogIDwvZz4NCjwvc3ZnPg==');
    background-position: 16px 80%;
    background-repeat: no-repeat;
    background-size: 20px 12px;
    padding-left: 2.5em;
}

.multi-language-selector .language-option[data-lang='kotlin'],
.exampleblock[data-lang=kotlin] > .content .title {
    background-image: url('data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA2MCA2MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjAgNjA7Ij4NCjxnPg0KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iWE1MSURfM18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTUuOTU5NCIgeTE9Ii0xMy4wMTQzIiB4Mj0iNDQuMzA2OCIgeTI9IjE1LjMzMzIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCA2MSkiPg0KCQk8c3RvcCAgb2Zmc2V0PSI5LjY3NzAwMGUtMDIiIHN0eWxlPSJzdG9wLWNvbG9yOiMwMDk1RDUiLz4NCgkJPHN0b3AgIG9mZnNldD0iMC4zMDA3IiBzdHlsZT0ic3RvcC1jb2xvcjojMjM4QUQ5Ii8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuNjIxMSIgc3R5bGU9InN0b3AtY29sb3I6IzU1N0JERSIvPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjg2NDMiIHN0eWxlPSJzdG9wLWNvbG9yOiM3NDcyRTIiLz4NCgkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzgwNkVFMyIvPg0KCTwvbGluZWFyR3JhZGllbnQ+DQoJPHBvbHlnb24gaWQ9IlhNTElEXzJfIiBzdHlsZT0iZmlsbDp1cmwoI1hNTElEXzNfKTsiIHBvaW50cz0iMCw2MCAzMC4xLDI5LjkgNjAsNjAgCSIvPg0KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNC4yMDkyIiB5MT0iNDguOTQwOSIgeDI9IjIwLjY3MzQiIHkyPSI2NS40MDUiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCA2MSkiPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjExODMiIHN0eWxlPSJzdG9wLWNvbG9yOiMwMDk1RDUiLz4NCgkJPHN0b3AgIG9mZnNldD0iMC40MTc4IiBzdHlsZT0ic3RvcC1jb2xvcjojM0M4M0RDIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuNjk2MiIgc3R5bGU9InN0b3AtY29sb3I6IzZENzRFMSIvPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjgzMzMiIHN0eWxlPSJzdG9wLWNvbG9yOiM4MDZFRTMiLz4NCgk8L2xpbmVhckdyYWRpZW50Pg0KCTxwb2x5Z29uIHN0eWxlPSJmaWxsOnVybCgjU1ZHSURfMV8pOyIgcG9pbnRzPSIwLDAgMzAuMSwwIDAsMzIuNSAJIi8+DQogICAgPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8yXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMTAuMTAxNyIgeTE9IjUuODM2MiIgeDI9IjQ1LjczMTUiIHkyPSI2MS42Njk0IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgNjEpIj4NCgkJPHN0b3AgIG9mZnNldD0iMC4xMDc1IiBzdHlsZT0ic3RvcC1jb2xvcjojQzc1N0JDIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuMjEzOCIgc3R5bGU9InN0b3AtY29sb3I6I0QwNjA5QSIvPg0KCQk8c3RvcCAgb2Zmc2V0PSIwLjQyNTQiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMTcyNUMiLz4NCgkJPHN0b3AgIG9mZnNldD0iMC42MDQ4IiBzdHlsZT0ic3RvcC1jb2xvcjojRUU3RTJGIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuNzQzIiBzdHlsZT0ic3RvcC1jb2xvcjojRjU4NjEzIi8+DQoJCTxzdG9wICBvZmZzZXQ9IjAuODIzMiIgc3R5bGU9InN0b3AtY29sb3I6I0Y4ODkwOSIvPg0KCTwvbGluZWFyR3JhZGllbnQ+DQoJPHBvbHlnb24gc3R5bGU9ImZpbGw6dXJsKCNTVkdJRF8yXyk7IiBwb2ludHM9IjMwLjEsMCAwLDMxLjcgMCw2MCAzMC4xLDI5LjkgNjAsMCAJIi8+DQo8L2c+DQo8L3N2Zz4=');
    background-position: 17px 80%;
    background-repeat: no-repeat;
    background-size: 11px 11px;
    padding-left: 2.3em;
}

.multi-language-selector {
    display: block;
}

.multi-language-selector .language-option[data-lang='groovy'] {
    background-position: 20px center;
    padding-left: 32px;
}

.multi-language-selector .language-option[data-lang='kotlin'] {
    background-position: 30px center;
    padding-left: 27px;
}

.multi-language-selector .language-option {
    background-color: white;
    border: 1px solid #f7f7f8;
    border-radius: 4px 4px 0 0;
    cursor: pointer;
    display: inline-block;
    font-weight: normal;
    font-family: 'Lato', Arial, sans-serif;
    margin: 0;
    padding: 4px 20px;
    min-width: 130px;
    max-width: 320px;
    text-align: center;
    filter: grayscale(1);
    -webkit-filter: grayscale(1);
    opacity: 0.7;
}

.multi-language-selector .language-option.selected {
    background-color: #f7f7f8;
    color: #02303a;
    filter: none;
    -webkit-filter: none;
    opacity: 1;
}

.multi-language-text.hidden,
.multi-language-selector ~ .multi-language-sample.hidden {
    display: none;
}

.multi-language-sample {
    border-radius: 0 0 4px 4px;
}

/*
 * Ensure that blocks of code do not wrap by applying the behavior of `[listing%nowrap]` by default.
 *
 * These styles are copied from a CSS ruleset in asciidoctor.css that has the same group of
 * selectors except that they end with `.nowrap`.
 */
.literalblock pre,
.literalblock pre[class],
.listingblock pre,
.listingblock pre[class] {
    overflow-x: auto;
    white-space: pre;
    word-wrap: normal;
}

/*
 * This CSS ruleset solves: https://github.com/gradle/guides/issues/113#issuecomment-314826749.
 */
.literalblock pre::after,
.literalblock pre[class]::after,
.listingblock pre::after,
.listingblock pre[class]::after {
    content: "";
}

.quoteblock blockquote,
.quoteblock blockquote p {
    text-align: left;
    text-align: start;
}

div.screenshot {
    box-shadow: 0 0 20px 1px rgba(0, 0, 0, 0.2);
    margin-left: auto;
    margin-right: auto;
    width: 90%;
}

.inset {
    box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.1);
    padding: 1em;
}

.image.inline-icon img {
    vertical-align: sub;
}

/* TOC */
#header > h1:first-child + #toc {
    background: none;
    border: 0 none;
    margin-top: 0;
}

#header #toctitle {
    margin-bottom: 0.425rem;
}

#toc,
#content #toc {
    border: 0 none;
}

#toc > ul {
    margin-left: 0;
    font-family: inherit;
}

#toc > ul > li {
    line-height: 1.25;
    margin-top: 0;
    padding-bottom: 0.5rem;
}

#toc > ul > li:last-of-type {
    padding-bottom: 0;
}

#toc a {
    font-style: normal;
}

#toc a:hover,
#toc a:focus,
#toc a:hover code,
#toc a:focus code {
    color: #1DA2BD;
}

#toc a:active {
    text-decoration: none;
}

@media screen and (min-width: 75rem) and (min-height: 48rem) {
    #header #toc {
        font-size: 1rem;
        background: #f7f7f8;
        border-radius: 0;
        margin-bottom: 0;
        padding: 15px 0 0;
    }

    #header #toctitle {
        font-size: 1rem;
        font-weight: 700;
        margin: 0.4rem 0 0.5rem 0;
    }

    #toc a {
        color: #02303A;
    }

    #toc a.active {
        color: #1BA8C4;
    }
}

/* Site header specific styles */
.hamburger {
    background-color: transparent;
    background-image: none;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-left: auto;
    padding: 11px 10px;
}

.hamburger:focus {
    outline: 0;
}

.hamburger__bar {
    display: block;
    width: 22px;
    height: 2px;
    background-color: black;
    border-radius: 1px;
}

.hamburger__bar + .hamburger__bar {
    margin-top: 4px;
}

.site-header {
    background-color: white;
}

/* Override javadoc styles */
.site-header div {
    font-family: 'Lato', Arial, sans-serif;
}

.site-header__navigation-header a {
    align-self: center;
    border-bottom: 0 none;
    height: 36px;
}

.site-header .site-header-version {
    align-self: flex-end;
    color: #1da2bd;
    font-size: 20px;
    padding-left: 1px;
}

.site-header__navigation {
    display: flex;
    flex-direction: column;
}

.site-header__navigation-header {
    display: flex;
    flex: 0 0 auto;
    margin-left: 12px;
}

.site-header__navigation-collapsible {
    flex: 1 1 auto;
    height: 210px;
    overflow: visible;
    transition: height 0.3s ease;
}

.site-header__navigation-items {
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    align-items: flex-start;
    max-height: 210px; /* This matches the collapsible height above */
    margin: 0 20px;
    padding-top: 12px;
    padding-left: 0;
    list-style-type: none;
}

.site-header__navigation-item {
    flex: 0 1 auto;
    font-size: 16px;
    width: 250px;
}

.site-header__navigation-item .site-header__navigation-link {
    position: relative;
    display: inline-block;
    cursor: pointer;
    width: 100%;
    padding: 5px;
    line-height: 20px;
    border: 0 none;
    color: #02303A;
    text-decoration: none;
    transition: none;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
}

.site-header__navigation-item .site-header__navigation-link:hover {
    color: #1DA2BD;
}

.site-header__navigation-item .site-header__navigation-link.active {
    font-weight: 500;
}

/* Navigation submenu styles */
.site-header__navigation-submenu-section {
    position: relative;
}

.site-header__navigation-submenu-section .site-header__down-arrow {
    width: 8px;
    height: 8px;
    margin-left: 2px;
    margin-top: 0;
}

.site-header__navigation-submenu-section .site-header__navigation-link:hover {
    color: #02303A;
}

.site-header__navigation-submenu-section .site-header__navigation-link:hover path {
    fill: none;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link:hover {
    color: #1DA2BD;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu {
    display: none;
    width: 170px;
    background-color: white;
    top: 40px;
    left: 21px; /* NOTE: This must match the padding of .site-header__navigation-link */
    padding: 3px 10px 6px 10px;
    z-index: 100;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link {
    width: 100%;
    color: #02303A;
    white-space: nowrap;
    display: inline-block;
    padding-top: 3px;
    border: 0 none;
    transition: none;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
}

.site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link .site-header__navigation-submenu-item-link-text {
    display: inline-block;
    font-size: 16px;
}

.site-header__navigation-submenu-section.open .site-header__navigation-submenu {
    display: block;
}

/* Top navigation mobile styles */
@media (max-width: 1023px) {
    .site-header__navigation-collapsible--collapse {
        height: 0;
        overflow-y: hidden;
    }

    .site-header__navigation-submenu-section .site-header__navigation-submenu {
        padding: 0 1rem 0.5rem 1.5rem;
        display: block;
        top: 30px !important;
        left: 0 !important;
    }

    .site-header__navigation-item,
    .site-header__navigation-submenu-section .site-header__navigation-submenu .site-header__navigation-submenu-item-link .site-header__navigation-submenu-item-link-text {
        font-size: 18px;
    }

    .site-header {
        padding: 5px 12px;
    }

    .site-header-version {
        display: none;
    }

    .site-footer__navigation {
        flex-direction: column;
    }

    .site-footer__links {
        flex-wrap: wrap;
    }

    .site-footer__link-group {
        margin-bottom: 1rem;
    }
}

/* Top navigation desktop styles */
@media (min-width: 1024px) {
    .site-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        -webkit-box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .15);
        -moz-box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .15);
        box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .15);
        z-index: 1;
    }

    /*
      Pushes the section headings to just below the top nav bar when a user
      navigates directly to section anchors.
     */
    #content h2[id], #content h3[id], #content h4[id], #content h5[id] {
        padding-top: 60px;
    }

    #content h2[id] {
        /* Little extra room above h2s */
        margin-top: -1em;
    }

    #content h3[id], #content h4[id], #content h5[id] {
        margin-top: -60px;
    }

    .site-header__navigation {
        flex-direction: row;
    }

    .site-header__navigation-button {
        display: none;
    }

    .site-header__navigation-items {
        flex-direction: row;
        align-items: center;
        float: right;
        width: auto;
        padding-top: 0;
    }

    .site-header__navigation-item {
        width: auto;
    }

    .site-header__navigation-item .site-header__navigation-link {
        padding: 15px 18px;
    }

    .site-header__navigation-item:last-of-type .site-header__navigation-link {
        padding-right: 0;
    }

    .site-header__navigation-link--button {
        padding: 6px 12px;
    }

    .site-header__navigation-collapsible {
        height: auto;
    }

    .site-header__navigation-submenu-section .site-header__navigation-submenu {
        position: absolute;
        border: 1px solid #9a9a9a;
        border-radius: 3px;
    }

    .site-header__navigation-submenu-section:hover .site-header__navigation-submenu {
        display: block;
    }

    /*
      Pushes the section headings to just below the top nav bar when a user
      navigates directly to section anchors. It doesn't work if you try
      to apply the padding and margin to the `h` elements directly.
     */
    .chapter a[name],
    .chapter .anchor {
        padding-top: 60px;
        margin-top: -60px;
        text-decoration: none;
        border: none;
        display: inline-block;
    }
}

/* Side Navigation styles */
/* Docs Navigation */
.docs-navigation {
    display: none;
    padding-left: 5px;
}

.docs-navigation .search-container {
    display: none;
    margin-bottom: 1rem;
}

.docs-navigation .search-input {
    height: 30px;
    line-height: 30px;
    box-sizing: border-box;
    padding: 0 20px 0 30px;
    border: 1px solid #e3e3e3;
    border-radius: 3px;
    color: #666;
    outline: none;
    margin-right: 10px;
    transition: border-color 0.2s ease;
    background: white url('data:image/svg+xml;utf8,<svg height="20px" version="1.1" viewBox="0 0 32 32" width="20px" xmlns="http://www.w3.org/2000/svg"><g fill="#cccccc" fill-rule="evenodd" stroke="none" stroke-width="1"><path d="M19.4271164,21.4271164 C18.0372495,22.4174803 16.3366522,23 14.5,23 C9.80557939,23 6,19.1944206 6,14.5 C6,9.80557939 9.80557939,6 14.5,6 C19.1944206,6 23,9.80557939 23,14.5 C23,16.3366522 22.4174803,18.0372495 21.4271164,19.4271164 L27.0119176,25.0119176 C27.5621186,25.5621186 27.5575313,26.4424687 27.0117185,26.9882815 L26.9882815,27.0117185 C26.4438648,27.5561352 25.5576204,27.5576204 25.0119176,27.0119176 L19.4271164,21.4271164 L19.4271164,21.4271164 Z M14.5,21 C18.0898511,21 21,18.0898511 21,14.5 C21,10.9101489 18.0898511,8 14.5,8 C10.9101489,8 8,10.9101489 8,14.5 C8,18.0898511 10.9101489,21 14.5,21 L14.5,21 Z"/></g></svg>') no-repeat 8px 5px;
    background-size: 20px;
    vertical-align: middle !important;
    max-width: 100%;
}

.docs-navigation .search-input:focus {
    border-color: #1BA8CB;
}

.docs-navigation .search-input::placeholder {
    color: #ccc;
}

/* Docsearch overrides */
.docs-navigation .algolia-autocomplete {
    display: block !important;
    flex: 1;
}

.docs-navigation .algolia-autocomplete .ds-dropdown-menu {
    width: 100%;
    min-width: 0 !important;
    max-width: none !important;
    padding: .75rem 0 !important;
    background-color: #fff !important;
    background-clip: padding-box;
    border: 1px solid #e3e3e3 !important;
    box-shadow: 0 .5rem 1rem rgba(0, 0, 0, .175) !important;
}

@media (min-width: 768px) {
    .docs-navigation .algolia-autocomplete .ds-dropdown-menu {
        width: 300%;
    }
}

.docs-navigation .algolia-autocomplete .ds-dropdown-menu [class^="ds-dataset-"] {
    padding: 0 !important;
    overflow: visible !important;
    background-color: transparent !important;
    border: 0 !important;
}

.docs-navigation .algolia-autocomplete .ds-dropdown-menu .ds-suggestions {
    margin-top: 0 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion {
    padding: 0 15px !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--category-header {
    font-weight: 800 !important;
    color: #1BA8CB !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--wrapper {}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--subcategory-column {}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--content {
    padding: 0 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--title {
    display: block !important;
    color: #02303A;
    padding: .25rem 1rem !important;
    margin-bottom: 0 !important;
    font-weight: 500 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--text {
    padding: 0 1rem .5rem !important;
    margin-top: -.25rem !important;
    font-size: 0.9em !important;
    font-weight: 400 !important;
    line-height: 1.25 !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-footer {
    float: none !important;
    width: auto !important;
    height: auto !important;
    padding: .75rem 1rem 0;
    font-size: .875rem !important;
    line-height: 1 !important;
    color: #767676 !important;
    border-top: 1px solid #e3e3e3 !important;
    text-align: right;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-footer a {
    font-size: .875rem;
    text-decoration: underline;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-footer--logo {
    display: inline !important;
    overflow: visible !important;
    color: inherit !important;
    text-indent: 0 !important;
    background: none !important;
}

.docs-navigation .algolia-autocomplete .algolia-docsearch-suggestion--highlight {
    background-color: rgba(143, 187, 237, .1) !important;
}

.docs-navigation .algolia-autocomplete .ds-suggestion .ds-cursor .algolia-docsearch-suggestion--content {
    background-color: rgba(208, 189, 236, .15) !important;
}

.docs-navigation a {
    color: #02303A;
    display: block;
    font-size: 1rem;
    line-height: 1.25;
}

.docs-navigation a code {
    color: #02303A;
    overflow-wrap: break-word;
    padding: 0;
    word-break: break-all;
}

.docs-navigation a.active {
    color: #1BA8C4;
}

.docs-navigation ul {
    list-style-type: none;
    margin: 0.5em 0;
    padding: 0;
}

.docs-navigation ul:last-of-type {
    margin-bottom: 0;
}

.docs-navigation li:first-of-type {
    margin-top: 0;
}

.docs-navigation li {
    margin-bottom: 0.5em;
}

.docs-navigation li:last-of-type {
    margin-bottom: 0;
}

.docs-navigation .nav-dropdown {
    background: transparent url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iNiIgdmlld0JveD0iMCAwIDE5IDExIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIHRyYW5zZm9ybT0icm90YXRlKC0xODAgOS4zNzQgNS40OTQpIiBkPSJNMTcuOTk5MSAxMC40MjI4MjVMOS4zNzQxIDAuNTY1NTc1IDAuNzQ5MSAxMC40MjI4MjUiIHN0cm9rZT0iIzAyMzAzQSIgb3BhY2l0eT0iMC43IiBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+') no-repeat center right;
}

.docs-navigation > ul ul,
.docs-navigation > ul ul ul {
    display: none;
    height: 0;
    margin-left: 1rem;
}

.docs-navigation > ul ul:target,
.docs-navigation > ul ul:target ul,
.docs-navigation > ul .nav-dropdown.expanded ~ ul {
    display: block;
    height: auto;
}

.docs-navigation h3 {
    font-size: 1rem;
    font-weight: 700;
    line-height: 1.5;
    margin: 1.5em 0 0;
}

.docs-navigation .docs-home-link {
    position: relative;
}

.docs-navigation .pdf-link-container {
    display: inline-block;
    position: absolute;
    top: -1.25em;
    right: 0;
}

.docs-navigation .pdf-link-container a {
    color: #999;
    font-size: 12px;
}

.docs-navigation .pdf-link-container svg {
    fill: #999;
    height: 12px;
    vertical-align: bottom;
}

@media screen and (min-width: 45rem) {
    .main-content {
        display: flex;
        justify-content: center;
    }
}

/* User guide navigation appears for desktops */
@media screen and (min-width: 64rem) {
    .main-content {
        padding-top: 75px;
    }

    .docs-navigation {
        display: block;
        flex: 0 0 auto;
        width: 13.75rem;
    }

    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        flex: 0 0 45rem;
        margin: 0 20px;
    }
}

/* Fixed intra-chapter navigation for desktops */
@media screen and (min-width: 75rem) and (min-height: 48rem) {
    .appendix #header #toc,
    .book #header #toc,
    .chapter #header #toc {
        position: fixed;
        left: calc(50% + 380px);
        top: 50px;
        width: 13.75rem;
        padding-top: 15px;
        font-size: 1rem;
        background-color: #F7F7F8;
    }

    .appendix #toc a,
    .book #toc a,
    .chapter #toc a {
        color: #02303A;
        display: inline-block;
    }

    .appendix #toc a.active,
    .book #toc a.active,
    .chapter #toc a.active {
        color: #1BA8C4;
    }

    .docs-navigation {
        flex-basis: 13.75rem;
    }

    /* Sneaky way to make room for TOC */
    .secondary-navigation {
        flex: 0 0 13.75rem;
    }
}

@media screen and (min-width: 84.375rem) and (min-height: 48rem) {
    .appendix #header #toc,
    .book #header #toc,
    .chapter #header #toc {
        left: calc(50% + 26.25rem);
    }
}

@media screen and (min-width: 93.75rem) and (min-height: 48rem) {
    .appendix #header #toc,
    .book #header #toc,
    .chapter #header #toc {
        left: calc(50% + 31.25rem);
    }
}

/* Userguide Meta */
.chapter-meta {
    float: right;
    text-align: right;
}

.chapter-meta .edit-link {
    color: #999;
    font-size: 0.9em;
    padding-right: 3px;
}

.chapter-meta .edit-link svg {
    margin-right: 1px;
}

/* Clever use of RTL to fill in all stars to left of hover position */
.rating {
    direction: rtl;
}

.rating > .star {
    cursor: pointer;
    display: table-cell;
    padding: 3px;
}

.rating > .star:hover > svg > g,
.rating > .star:hover ~ .star > svg > g,
.rating > .star.selected > svg > g,
.rating > .star.selected ~ .star > svg > g {
    fill: #999;
}

/* Footer styles */
.site-footer {
}

.site-footer__navigation {
    display: flex;
    max-width: 75rem;
    margin: 3rem auto 0 auto;
    padding: 0.5rem 0.75rem;
}

.site-footer__links {
    display: flex;
    flex: 1 1 auto;
}

.site-footer__links .site-footer__links-list {
    list-style-type: none;
    margin: 0;
}

.site-footer__links .site-footer__links-list a {
    color: #666;
}

.site-footer__link-group {
    flex: 1 1 auto;
    flex-basis: 175px;
}

.site-footer__link-group header {
    color: #555;
}

.site-footer__subscribe-newsletter {
    flex: 0 0 350px;
}

.site-footer__subscribe-newsletter .newsletter-form__header h5 {
    color: #555;
    margin-top: 0;
}

.site-footer__subscribe-newsletter p {
    font-size: 0.875rem;
    margin: 2px 0 0 2px;
    opacity: 0.7;
}

.site-footer__subscribe-newsletter .disclaimer {
    font-size: 0.75rem;
    opacity: 0.55;
}

.site-footer__subscribe-newsletter .newsletter-form {
    padding-top: 6px;
    display: flex;
    justify-content: flex-start;
}

.site-footer__subscribe-newsletter .email,
.site-footer__subscribe-newsletter .submit {
    height: 40px;
}

.site-footer__subscribe-newsletter .email {
    line-height: 40px;
    width: 250px;
    color: #1DA2BD;
    font-size: 16px;
    padding-left: 20px;
    border-top-left-radius: 4px;
    border-bottom-left-radius: 4px;
    border-style: none;
}

.site-footer__subscribe-newsletter .submit {
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    width: 100px;
    background-color: #1BA8CB;
    color: white;
    font-weight: 500;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    border-style: none;
    cursor: pointer;
    transition: all .3s ease;
}

/* Secondary footer (below) */
.site-footer-secondary {
    background-color: white;
}

.site-footer-secondary__contents {
    display: flex;
    align-items: center;
    justify-content: space-between;
    max-width: 75rem;
    margin-left: auto;
    margin-right: auto;
    font-size: 0.875rem;
    padding: 0.5rem 0.75rem;
}

/*
 * 1. Value is the largest computed width among 'site-footer__copy' and 'site-footer__links'.
 */
.site-footer__copy,
.site-footer__secondary-links {
    flex-grow: 0;
    flex-basis: 280px;
    /* 1. */
}

/*
 * 1. 'flex-shrink: 1' is applied to the element with the smallest computed width among
 *    'site-footer__copy' and 'site-footer__links'.
 */
.site-footer__copy {
    flex-shrink: 1;
    /* 1. */
}

.site-footer__logo {
    flex: 0 0 auto;
    margin-right: 10px;
    margin-left: 10px;
}

.site-footer__logo svg {
    width: 35px;
    height: 35px;
}

/*
 * 1. 'flex-shrink: 0' is applied to the element with the largest computed width among
 *    'site-footer__copy' and 'site-footer__links'.
 */
.site-footer__secondary-links {
    flex-shrink: 0;
    /* 1 */
    text-align: right;
    white-space: nowrap;
}

.site-footer-secondary a {
    color: #999;
}

.site-footer-secondary__links a:not(:last-child) {
    padding-right: 10px;
}

.site-footer-secondary__links a:not(:first-child) {
    padding-left: 10px;
}

@media all and (max-width: 29.99rem) {
    .site-footer__rights,
    .site-footer-secondary__links {
        display: none;
    }

    .site-footer__logo {
        order: 1;
        text-align: left;
    }

    .site-footer__copy {
        order: 2;
        text-align: right;
    }
}

/* Avoid the footer taking up much of the screen on short displays */
@media all and (max-height: 56.25rem) {
    .site-footer__navigation {
        margin: 1.5rem auto 0 auto;
        padding-top: 0;
        padding-bottom: 0;
    }
}

@media screen and (min-width: 84.375rem) {
    .ui-logos .ui-logo {
        box-shadow: 0 6px 15px 1px rgba(0, 0, 0, 0.56);
    }

    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        flex-basis: 50rem;
        max-width: 50rem;
    }
}

@media screen and (min-width: 93.75rem) {
    .main-content > .appendix,
    .main-content > .book,
    .main-content > .chapter {
        flex-basis: 60rem;
        max-width: 60rem;
    }
}

/* User Manual Home */
.technology-logos,
.ui-logos {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: space-around;
}

.technology-logo,
.ui-logo {
    flex: 0 1 auto;
}

.ui-logo {
    width: 224px;
    height: 135px;
    margin: 12px;
}

</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<meta name="adoc-src-path" content="/userguide_single.adoc">
<meta name="robots" content="noindex">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@gradle">
<meta name="twitter:creator" content="@gradle">
<meta name="twitter:title" content="Gradle User Manual: Version {gradleVersion}">
<meta name="twitter:description" content="Single-page Gradle User Manual for Gradle 6.0.1">
<meta name="twitter:url" content="https://docs.gradle.org/6.0.1/userguide/userguide_single.html">
<meta name="twitter:image" content="https://gradle.org/images/gradle-256x256.png">

<link href="//assets.gradle.com" rel="preconnect" crossorigin="">
<link href="asset?aid=0" rel="stylesheet">



<header class="site-layout__header site-header" itemscope itemtype="https://schema.org/WPHeader">
    <nav class="site-header__navigation" itemscope itemtype="https://schema.org/SiteNavigationElement">
        <div class="site-header__navigation-header">
            <a class="logo" href="https://docs.gradle.org" title="Gradle Docs" target="_top">
                <svg width="139px" height="43px" viewbox="0 0 278 86" version="1.1" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <style>.cls-1 {
                            fill: #02303a;
                        }</style>
                    </defs>
                    <title>摇篮</title>
                    <path class="cls-1" d="M155,56.32V70.27a18.32,18.32,0,0,1-5.59,2.83,21.82,21.82,0,0,1-6.36.89,21.08,21.08,0,0,1-7.64-1.31A17.12,17.12,0,0,1,129.59,69a16.14,16.14,0,0,1-3.73-5.58,18.78,18.78,0,0,1-1.31-7.08,19.58,19.58,0,0,1,1.26-7.14A15.68,15.68,0,0,1,135,40a20.39,20.39,0,0,1,7.45-1.29,22,22,0,0,1,3.92.33,20.43,20.43,0,0,1,3.39.92,15.16,15.16,0,0,1,2.85,1.42A17.3,17.3,0,0,1,155,43.25l-1.84,2.91a1.72,1.72,0,0,1-1.12.84,2,2,0,0,1-1.5-.34L149,45.75a10.49,10.49,0,0,0-1.75-.79,14.33,14.33,0,0,0-2.17-.54,15.29,15.29,0,0,0-2.78-.22,11.91,11.91,0,0,0-4.61.86,9.66,9.66,0,0,0-3.52,2.46,10.9,10.9,0,0,0-2.24,3.84,14.88,14.88,0,0,0-.79,5,15.23,15.23,0,0,0,.85,5.28,11.06,11.06,0,0,0,2.38,3.94A10.15,10.15,0,0,0,138.05,68a14.28,14.28,0,0,0,8.25.44,17.1,17.1,0,0,0,2.94-1.09V61.14h-4.35a1.3,1.3,0,0,1-1-.35,1.15,1.15,0,0,1-.35-.85V56.32Zm10.47-2.93a10.53,10.53,0,0,1,2.72-3.45,5.77,5.77,0,0,1,3.72-1.25,4.5,4.5,0,0,1,2.72.74l-.38,4.41a1.18,1.18,0,0,1-.34.61,1,1,0,0,1-.61.18,6.76,6.76,0,0,1-1.06-.12,8.22,8.22,0,0,0-1.38-.12,5,5,0,0,0-1.74.28,4.37,4.37,0,0,0-1.37.83,5.55,5.55,0,0,0-1.07,1.3,12.26,12.26,0,0,0-.87,1.74V73.61H160V49.14h3.45a1.94,1.94,0,0,1,1.27.32,1.9,1.9,0,0,1,.48,1.16Zm11.36-.84A14.49,14.49,0,0,1,187,48.69a9.92,9.92,0,0,1,3.84.7,8.06,8.06,0,0,1,2.86,2,8.38,8.38,0,0,1,1.78,3,11.64,11.64,0,0,1,.61,3.82V73.61h-2.68a2.64,2.64,0,0,1-1.28-.25,1.72,1.72,0,0,1-.72-1l-.52-1.77a20.25,20.25,0,0,1-1.82,1.47,10.86,10.86,0,0,1-1.83,1.06,10.36,10.36,0,0,1-2,.66,12,12,0,0,1-2.4.22,9.64,9.64,0,0,1-2.86-.41,6.28,6.28,0,0,1-2.27-1.26,5.6,5.6,0,0,1-1.48-2.07,7.38,7.38,0,0,1-.52-2.89,5.7,5.7,0,0,1,.31-1.85,5.3,5.3,0,0,1,1-1.75,8.25,8.25,0,0,1,1.83-1.57,11.17,11.17,0,0,1,2.75-1.29,23.28,23.28,0,0,1,3.81-.9,36.77,36.77,0,0,1,5-.41V58.16a5.35,5.35,0,0,0-1.05-3.64,3.83,3.83,0,0,0-3-1.18,7.3,7.3,0,0,0-2.38.33,9.39,9.39,0,0,0-1.65.75l-1.3.75a2.52,2.52,0,0,1-1.3.34,1.7,1.7,0,0,1-1.05-.32,2.61,2.61,0,0,1-.69-.76Zm13.5,10.61a31.66,31.66,0,0,0-4.3.45,11,11,0,0,0-2.79.82,3.57,3.57,0,0,0-1.5,1.17,2.89,2.89,0,0,0,.47,3.67,3.93,3.93,0,0,0,2.39.67,7,7,0,0,0,3.14-.66,9.52,9.52,0,0,0,2.59-2Zm32.53-25V73.61h-3.6a1.39,1.39,0,0,1-1.48-1.07l-.5-2.36a12.4,12.4,0,0,1-3.4,2.74,9.17,9.17,0,0,1-4.47,1,7.95,7.95,0,0,1-6.55-3.26A11.61,11.61,0,0,1,201,66.79a19.71,19.71,0,0,1-.66-5.34,16.77,16.77,0,0,1,.74-5.06,12.21,12.21,0,0,1,2.13-4,9.88,9.88,0,0,1,3.31-2.69,9.64,9.64,0,0,1,4.34-1,8.63,8.63,0,0,1,3.51.64,9,9,0,0,1,2.6,1.74V38.17ZM217,55.39a5.94,5.94,0,0,0-2.18-1.72,6.54,6.54,0,0,0-2.54-.5,5.68,5.68,0,0,0-2.41.5A4.87,4.87,0,0,0,208,55.19a7.19,7.19,0,0,0-1.17,2.57,14.83,14.83,0,0,0-.4,3.69,16.34,16.34,0,0,0,.34,3.63,7.14,7.14,0,0,0,1,2.44,3.79,3.79,0,0,0,1.58,1.36,5,5,0,0,0,2.07.41,6,6,0,0,0,3.13-.76A9.19,9.19,0,0,0,217,66.36Zm17.67-17.22V73.61h-5.89V38.17ZM245.1,62.11a11.37,11.37,0,0,0,.67,3.26,6.54,6.54,0,0,0,1.38,2.27,5.39,5.39,0,0,0,2,1.33,7.26,7.26,0,0,0,2.61.44,8.21,8.21,0,0,0,2.47-.33,11.51,11.51,0,0,0,1.81-.74c.52-.27,1-.52,1.36-.74a2.31,2.31,0,0,1,1.13-.33,1.21,1.21,0,0,1,1.1.55L261.36,70a9.45,9.45,0,0,1-2.19,1.92,12.18,12.18,0,0,1-2.54,1.24,14,14,0,0,1-2.7.66,18.78,18.78,0,0,1-2.65.19,12.93,12.93,0,0,1-4.75-.85,10.65,10.65,0,0,1-3.82-2.5,11.8,11.8,0,0,1-2.55-4.1,15.9,15.9,0,0,1-.93-5.67,13.55,13.55,0,0,1,.81-4.71,11.34,11.34,0,0,1,2.33-3.84,11,11,0,0,1,3.69-2.59,12.31,12.31,0,0,1,4.93-1,11.86,11.86,0,0,1,4.27.74,9.25,9.25,0,0,1,3.36,2.16,9.84,9.84,0,0,1,2.21,3.48,13,13,0,0,1,.8,4.71,3.82,3.82,0,0,1-.29,1.8,1.19,1.19,0,0,1-1.1.46Zm11.23-3.55A7.28,7.28,0,0,0,256,56.4a5.16,5.16,0,0,0-1-1.77,4.44,4.44,0,0,0-1.63-1.21,5.68,5.68,0,0,0-2.3-.44,5.46,5.46,0,0,0-4,1.45,7.13,7.13,0,0,0-1.87,4.13ZM112.26,14a13.72,13.72,0,0,0-19.08-.32,1.27,1.27,0,0,0-.41.93,1.31,1.31,0,0,0,.38.95l1.73,1.73a1.31,1.31,0,0,0,1.71.12,7.78,7.78,0,0,1,4.71-1.57,7.87,7.87,0,0,1,5.57,13.43C96,40.2,81.41,9.66,48.4,25.37a4.48,4.48,0,0,0-2,6.29l5.66,9.79a4.49,4.49,0,0,0,6.07,1.67l.14-.08-.11.08,2.51-1.41a57.72,57.72,0,0,0,7.91-5.89,1.37,1.37,0,0,1,1.8-.06h0a1.29,1.29,0,0,1,0,2A59.79,59.79,0,0,1,62.11,44l-.09.05-2.51,1.4a7,7,0,0,1-3.47.91,7.19,7.19,0,0,1-6.23-3.57l-5.36-9.24C34.17,40.81,27.93,54.8,31.28,72.5a1.31,1.31,0,0,0,1.29,1.06h6.09A1.3,1.3,0,0,0,40,72.42a8.94,8.94,0,0,1,17.73,0A1.3,1.3,0,0,0,59,73.56h5.94a1.31,1.31,0,0,0,1.3-1.14,8.93,8.93,0,0,1,17.72,0,1.3,1.3,0,0,0,1.29,1.14h5.87a1.3,1.3,0,0,0,1.3-1.28c.14-8.28,2.37-17.79,8.74-22.55C123.15,33.25,117.36,19.12,112.26,14ZM89.79,38.92l-4.2-2.11h0a2.64,2.64,0,1,1,4.2,2.12Z"></path>
                </svg>
            </a>
            <div class="site-header__doc-type sr-only">用户手册</div>
            <div class="site-header-version"></div>
            <button type="button" aria-label="导航菜单" class="site-header__navigation-button hamburger"></button>
        </div>
        <div class="site-header__navigation-collapsible site-header__navigation-collapsible--collapse">
            <ul class="site-header__navigation-items">
                <li class="site-header__navigation-item site-header__navigation-submenu-section" tabindex="0">
                    <span class="site-header__navigation-link">社区<svg class="site-header__down-arrow site-header__icon-light" width="19" height="11" viewbox="0 0 19 11" xmlns="http://www.w3.org/2000/svg"><title>打开社区菜单</title><path transform="rotate(-180 9.374 5.494)" d="M17.9991 10.422825L9.3741 0.565575 0.7491 10.422825" stroke="#02303A" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                    </span>
                    <div class="site-header__navigation-submenu">
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://gradle.org/" target="_top" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">社区之家</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://discuss.gradle.org/" target="_top" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">社区论坛</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://plugins.gradle.org" target="_top" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">社区插件</span>
                            </a>
                        </div>
                    </div>
                </li>
                <li class="site-header__navigation-item" itemprop="name">
                    <a class="site-header__navigation-link" href="https://gradle.com/training/" target="_top" itemprop="url">训练</a>
                </li>
                <li class="site-header__navigation-item site-header__navigation-submenu-section" tabindex="0">
                    <span class="site-header__navigation-link">新闻<svg class="site-header__down-arrow site-header__icon-light" width="19" height="11" viewbox="0 0 19 11" xmlns="http://www.w3.org/2000/svg"><title>打开社区菜单</title><path transform="rotate(-180 9.374 5.494)" d="M17.9991 10.422825L9.3741 0.565575 0.7491 10.422825" stroke="#02303A" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                    </span>
                    <div class="site-header__navigation-submenu">
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://newsletter.gradle.com" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">通讯</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item" itemprop="name">
                            <a class="site-header__navigation-submenu-item-link" href="https://blog.gradle.org" itemprop="url">
                                <span class="site-header__navigation-submenu-item-link-text">博客</span>
                            </a>
                        </div>
                        <div class="site-header__navigation-submenu-item">
                            <a class="site-header__navigation-submenu-item-link" href="https://twitter.com/gradle">
                                <span class="site-header__navigation-submenu-item-link-text">推特</span>
                            </a>
                        </div>
                    </div>
                </li>
                <li class="site-header__navigation-item" itemprop="name">
                    <a class="site-header__navigation-link" href="https://gradle.com" target="_top" itemprop="url">企业</a>
                </li>
                <li class="site-header__navigation-item">
                    <a class="site-header__navigation-link" title="GitHub上的Gradle" href="https://github.com/gradle/gradle"><svg width="20" height="20" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><title>的github</title><path d="M10 0C4.477 0 0 4.477 0 10c0 4.418 2.865 8.166 6.839 9.489.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.342-3.369-1.342-.454-1.155-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.831.092-.646.35-1.086.636-1.336-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.268 2.75 1.026A9.578 9.578 0 0 1 10 4.836c.85.004 1.705.114 2.504.337 1.909-1.294 2.747-1.026 2.747-1.026.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.579.688.481C17.137 18.163 20 14.418 20 10c0-5.523-4.478-10-10-10" fill="#02303A" fill-rule="evenodd"></path></svg></a>
                </li>
            </ul>
        </div>
    </nav>
</header>

<main class="main-content">
    <!-- Primary Navigation -->
    <nav class="docs-navigation">
        <div class="search-container">
            <input type="search" name="q" id="search-input" class="search-input" placeholder="搜索文档">
        </div>
        <ul>
            <li><a href="userguide.html">文件首页</a></li>
            <li><a href="https://guides.gradle.org">讲解</a></li>
            <li><a href="../release-notes.html">发行说明</a></li>
            <li><a class="nav-dropdown" href="#gradle-api" data-toggle="collapse" aria-expanded="false" aria-controls="gradle-api">Gradle API</a>
                <ul id="gradle-api">
                    <li><a href="../javadoc/index.html?overview-summary.html">Java文档</a></li>
                    <li><a href="../dsl/index.html">Groovy DSL参考</a></li>
                    <li><a href="groovy_build_script_primer.html">Groovy DSL入门</a></li>
                    <li><a href="https://gradle.github.io/kotlin-dsl-docs/api/" target="_blank">Kotlin DSL API</a></li>
                    <li><a href="kotlin_dsl.html">Kotlin DSL入门</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="user-manual">用户手册</h3>
        <div class="docs-home-link">
            <div class="pdf-link-container">
                <a href="userguide.pdf">
                    <svg width="10px" height="12px" viewbox="0 0 10 12" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M6.01302083,0.857142857 C6.2421875,0.857142857 6.4296875,1.05 6.4296875,1.28571429 L6.4296875,5.14285714 L8.875,5.14285714 C9.05989583,5.14285714 9.15364583,5.37321429 9.0234375,5.50714286 L5.29427083,9.35357143 C5.13020833,9.52232143 4.8671875,9.52232143 4.703125,9.35357143 L0.979166667,5.50714286 C0.848958333,5.37321429 0.940104167,5.14285714 1.12760417,5.14285714 L3.57291667,5.14285714 L3.57291667,1.28571429 C3.57291667,1.05 3.76041667,0.857142857 3.98958333,0.857142857 L6.01302083,0.857142857 Z M6.01302083,0 L3.98958333,0 C3.29947917,0 2.73958333,0.575892857 2.73958333,1.28571429 L2.73958333,4.28571429 L1.12760417,4.28571429 C0.203125,4.28571429 -0.265625,5.4375 0.390625,6.1125 L4.11458333,9.95892857 C4.60416667,10.4625 5.39583333,10.4625 5.88541667,9.95892857 L9.61197917,6.11517857 C10.265625,5.44285714 9.80208333,4.28839286 8.875,4.28839286 L7.26302083,4.28839286 L7.26302083,1.28571429 C7.26302083,0.575892857 6.70052083,0 6.01302083,0 Z M10,11.6785714 L10,11.4642857 C10,11.2875 9.859375,11.1428571 9.6875,11.1428571 L0.3125,11.1428571 C0.140625,11.1428571 0,11.2875 0,11.4642857 L0,11.6785714 C0,11.8553571 0.140625,12 0.3125,12 L9.6875,12 C9.859375,12 10,11.8553571 10,11.6785714 Z"></path></svg> PDF格式</a>
            </div>
        </div>
        <ul>
            <li><a href="getting_started.html">入门</a></li>
            <li><a href="installation.html">安装Gradle</a></li>
            <li><a class="nav-dropdown" href="#upgrading-gradle" data-toggle="collapse" aria-expanded="false" aria-controls="upgrading-gradle">升级Gradle ...</a>
                <ul id="upgrading-gradle">
                    <li><a href="upgrading_version_5.html">版本5。X至6.0</a></li>
                    <li><a href="upgrading_version_4.html">版本4。X至5.0</a></li>
                    <li><a href="feature_lifecycle.html">Gradle的功能生命周期</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#migrating-to-gradle" data-toggle="collapse" aria-expanded="false" aria-controls="migrating-to-gradle">迁移至Gradle ...</a>
                <ul id="migrating-to-gradle">
                    <li><a href="migrating_from_maven.html">从Maven</a></li>
                    <li><a href="migrating_from_ant.html">来自蚂蚁</a></li>
                </ul>
            </li>
            <li><a href="troubleshooting.html">对构建进行故障排除</a></li>
        </ul>

        <h3 id="running-gradle-builds">运行Gradle构建</h3>
        <ul>
            <li><a class="nav-dropdown" href="#customizing-execution" data-toggle="collapse" aria-expanded="false" aria-controls="customizing-execution">自定义执行</a>
                <ul id="customizing-execution">
                    <li><a href="build_environment.html">配置构建环境</a></li>
                    <li><a href="gradle_daemon.html">配置Gradle守护程序</a></li>
                    <li><a href="init_scripts.html">使用初始化脚本</a></li>
                </ul>
            </li>
            <li><a href="intro_multi_project_builds.html">执行多项目构建</a></li>
            <li><a href="https://guides.gradle.org/creating-build-scans/">检查Gradle构建</a></li>
            <li><a class="nav-dropdown" href="#optimizing-build-performance" data-toggle="collapse" aria-expanded="false" aria-controls="optimizing-build-performance">优化构建时间</a>
                <ul id="optimizing-build-performance">
                    <li><a href="https://guides.gradle.org/performance/">构建绩效指南</a></li>
                    <li><a href="build_cache.html">启用和配置构建缓存</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="authoring-gradle-builds">编写Gradle构建</h3>
        <ul>
            <li><a class="nav-dropdown" href="#learning-the-basics" data-toggle="collapse" aria-expanded="false" aria-controls="learning-the-basics">学习基础</a>
                <ul id="learning-the-basics">
                    <li><a href="tutorial_using_tasks.html">介绍构建脚本的基础</a></li>
                    <li><a href="more_about_tasks.html">处理任务</a></li>
                    <li><a href="writing_build_scripts.html">了解有关构建脚本的更多信息</a></li>
                    <li><a href="working_with_files.html">处理文件</a></li>
                    <li><a href="plugins.html">使用Gradle插件</a></li>
                    <li><a href="build_lifecycle.html">了解构建生命周期</a></li>
                    <li><a href="logging.html">使用记录</a></li>
                    <li><a href="multi_project_builds.html">配置多项目构建</a></li>
                    <li><a href="potential_traps.html">避免陷阱</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#authoring-sustainable-builds" data-toggle="collapse" aria-expanded="false" aria-controls="authoring-sustainable-builds">创作可持续建筑</a>
                <ul id="authoring-sustainable-builds">
                    <li><a href="organizing_gradle_projects.html">组织构建逻辑</a></li>
                    <li><a href="authoring_maintainable_build_scripts.html">遵循最佳实践</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#advanced-techniques" data-toggle="collapse" aria-expanded="false" aria-controls="advanced-techniques">先进技术</a>
            <ul id="advanced-techniques">
                <li><a href="https://guides.gradle.org/using-the-worker-api/">开发并行任务</a></li>
                <li><a href="test_kit.html">使用TestKit测试构建</a></li>
                <li><a href="ant.html">从Gradle使用Ant</a></li>
            </ul>
            </li><li><a class="nav-dropdown" href="#sample-gradle-builds" data-toggle="collapse" aria-expanded="false" aria-controls="sample-gradle-builds">Gradle项目示例</a>
                <ul id="sample-gradle-builds">
                    <li><a href="https://github.com/gradle/gradle/tree/master/subprojects/docs/src/samples">Groovy DSL样本</a></li>
                    <li><a href="https://github.com/gradle/kotlin-dsl/tree/master/samples">Kotlin DSL样本</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="authoring-gradle-builds-java">编写JVM构建</h3>
        <ul>
            <li><a href="building_java_projects.html">构建Java和JVM项目</a></li>
            <li><a href="java_testing.html">测试Java和JVM项目</a></li>
            <li><a href="dependency_management_for_java_projects.html">管理依赖关系</a></li>
            <li><a class="nav-dropdown" href="#jvm-plugins" data-toggle="collapse" aria-expanded="false" aria-controls="jvm-plugins">JVM插件</a>
                <ul id="jvm-plugins">
                    <li><a href="java_library_plugin.html">Java库插件</a></li>
                    <li><a href="application_plugin.html">Java应用程序插件</a></li>
                    <li><a href="java_platform_plugin.html">Java平台插件</a></li>
                    <li><a href="groovy_plugin.html">Groovy插件</a></li>
                    <li><a href="scala_plugin.html">Scala插件</a></li>
                </ul>
            </li>
        </ul>

        <h3 id="authoring-gradle-builds-native">编写C ++ / Swift构建</h3>
        <ul>
            <li><a href="building_cpp_projects.html">构建C ++项目</a></li>
            <li><a href="cpp_testing.html">测试C ++项目</a></li>
            <li><a href="building_swift_projects.html">建立Swift项目</a></li>
            <li><a href="swift_testing.html">测试Swift项目</a></li>
        </ul>

        <h3 id="managing-dependencies">使用依赖项</h3>
        <ul>
            <li><a class="nav-dropdown" href="#learning-the-basics-dependency-management" data-toggle="collapse" aria-expanded="false" aria-controls="learning-the-basics-dependency-management">学习基础</a>
                <ul id="learning-the-basics-dependency-management">
                    <li><a href="core_dependency_management.html">什么是依赖管理？</a></li>
                    <li><a href="declaring_repositories.html">声明存储库</a></li>
                    <li><a href="declaring_dependencies.html">声明依赖项</a></li>
                    <li><a href="library_vs_application.html">了解库和应用程序的差异</a></li>
                    <li><a href="viewing_debugging_dependencies.html">查看和调试依赖项</a></li>
                    <li><a href="dependency_resolution.html">了解分辨率</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#declaring-dependency-versions" data-toggle="collapse" aria-expanded="false" aria-controls="declaring-dependency-versions">声明版本</a>
                <ul id="declaring-dependency-versions">
                    <li><a href="single_versions.html">声明版本和范围</a></li>
                    <li><a href="rich_versions.html">声明丰富版本</a></li>
                    <li><a href="dynamic_versions.html">处理变更版本</a></li>
                    <li><a href="dependency_locking.html">锁定版本</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#controlling-transitive-dependencies" data-toggle="collapse" aria-expanded="false" aria-controls="controlling-transitive-dependencies">控制翻译</a>
                <ul id="controlling-transitive-dependencies">
                    <li><a href="dependency_constraints.html">升级版本</a></li>
                    <li><a href="dependency_downgrade_and_exclude.html">降级和排除</a></li>
                    <li><a href="platforms.html">共享版本</a></li>
                    <li><a href="dependency_version_alignment.html">对齐依赖</a></li>
                    <li><a href="dependency_capability_conflict.html">处理互斥依赖性</a></li>
                    <li><a href="component_metadata_rules.html">修复元数据</a></li>
                    <li><a href="resolution_rules.html">自定义分辨率</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#modeling-features" data-toggle="collapse" aria-expanded="false" aria-controls="modeling-features">图书馆的生产和消费形式</a>
                <ul id="modeling-features">
                    <li><a href="component_capabilities.html">声明图书馆的能力</a></li>
                    <li><a href="feature_variants.html">建模功能变体和可选依赖项</a></li>
                    <li><a href="variant_model.html">了解变体选择</a></li>
                    <li><a href="variant_attributes.html">声明变体属性</a></li>
                    <li><a href="cross_project_publications.html">共享项目成果</a></li>
                    <li><a href="artifact_transforms.html">改造神器</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#multi-repo" data-toggle="collapse" aria-expanded="false" aria-controls="multi-repo">在多仓库环境中工作</a>
                <ul id="multi-repo">
                    <li><a href="composite_builds.html">组成建筑</a></li>
                </ul>
            </li>
            <li><a class="nav-dropdown" href="#publishing" data-toggle="collapse" aria-expanded="false" aria-controls="publishing">出版图书馆</a>
                <ul id="publishing">
                    <li><a href="publishing_setup.html">设置发布</a></li>
                    <li><a href="publishing_gradle_module_metadata.html">了解Gradle模块元数据</a></li>
                    <li><a href="publishing_signing.html">签署文物</a></li>
                    <li><a href="publishing_customization.html">定制出版</a></li>
                    <li><a href="publishing_maven.html">Maven发布插件</a></li>
                    <li><a href="publishing_ivy.html">常春藤发布插件</a></li>
                </ul>
            </li>
            <li><a href="dependency_management_terminology.html">术语</a></li>
        </ul>

        <h3 id="extending-gradle">扩展摇篮</h3>
        <ul>
            <li><a href="https://gradle.org/guides/?q=Plugin Development">插件开发教程</a></li>
            <li><a href="custom_tasks.html">编写Gradle任务类型</a></li>
            <li><a href="custom_plugins.html">编写Gradle插件</a></li>
            <li><a href="custom_gradle_types.html">编写自定义Gradle类型</a></li>
            <li><a href="lazy_configuration.html">延迟配置任务</a></li>
            <li><a href="task_configuration_avoidance.html">使用避免任务配置</a></li>
        </ul>

        <h3 id="reference">参考</h3>
        <ul>
            <li><a href="plugin_reference.html">核心插件</a></li>
            <li><a href="command_line_interface.html">命令行界面</a></li>
            <li id="third-party-integration"><a href="third_party_integration.html">Gradle和第三方工具</a></li>
            <li><a href="gradle_wrapper.html">摇篮包装</a></li>
            <li><a href="directory_layout.html">Gradle管理的目录</a></li>
        </ul>
    </nav>
    <!-- End Primary Navigation -->
    <div class="chapter">
        <aside class="chapter-meta js-chapter-meta">
            <div class="rating js-rating-widget">
                <!--NOTE: These are "backwards" because we use a right-to-left trick for hover state-->
                <i class="star js-analytics-event js-rating" title="优秀的文档" data-action="rating" data-label="5"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="好的文件" data-action="rating" data-label="4"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="确定文档" data-action="rating" data-label="3"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="文档不良" data-action="rating" data-label="2"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
                <i class="star js-analytics-event js-rating" title="无法使用的文件" data-action="rating" data-label="1"><svg width="16px" height="15px" viewbox="0 0 16 15" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="#999999" transform="translate(-33.000000, -11.000000)" stroke-width="1" fill="none" fill-rule="evenodd"><path d="M40.9955595,22.8514234 L36.7915654,24.9948806 L36.7915654,24.9948806 C36.7423632,25.019967 36.6821404,25.0004172 36.657054,24.951215 C36.6471785,24.931846 36.6438844,24.9097862 36.6476706,24.8883772 L37.4490484,20.357021 L37.4490484,20.357021 C37.4549065,20.3238963 37.4437179,20.2900458 37.419273,20.2669371 L34.0268385,17.0599455 L34.0268385,17.0599455 C33.9867045,17.0220055 33.984926,16.9587139 34.0228661,16.91858 C34.0384357,16.9021101 34.0591382,16.8914177 34.0815807,16.888255 L38.7752895,16.2268062 L38.7752895,16.2268062 C38.8076013,16.2222528 38.8356591,16.2022207 38.8504587,16.1731387 L40.9518588,12.0437603 L40.9518588,12.0437603 C40.9769072,11.9945387 41.0371149,11.9749424 41.0863365,11.9999908 C41.1051882,12.0095843 41.1205124,12.0249085 41.1301059,12.0437603 L43.2315061,16.1731387 L43.2315061,16.1731387 C43.2463056,16.2022207 43.2743635,16.2222528 43.3066753,16.2268062 L48.0003841,16.888255 L48.0003841,16.888255 C48.0550722,16.8959618 48.0931581,16.9465428 48.0854513,17.001231 C48.0822887,17.0236735 48.0715962,17.044376 48.0551263,17.0599455 L44.6626917,20.2669371 L44.6626917,20.2669371 C44.6382468,20.2900458 44.6270582,20.3238963 44.6329164,20.357021 L45.4342941,24.8883772 L45.4342941,24.8883772 C45.4439121,24.9427617 45.4076217,24.9946461 45.3532371,25.0042641 C45.3318281,25.0080503 45.3097683,25.0047561 45.2903993,24.9948806 L41.0864052,22.8514234 L41.0864052,22.8514234 C41.0578708,22.8368748 41.024094,22.8368748 40.9955595,22.8514234 Z"></path></g></svg></i>
            </div>

            <div class="quick-edit">
                <a class="edit-link js-edit-link" href="https://github.com/gradle/gradle/edit/master/subprojects/docs/src/docs/userguide/">
                    <svg width="11px" height="12px" viewbox="0 0 11 12" version="1.1" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><g stroke="#999999" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 5.11724219 9 11.5 0.5 11.5 0.5 2.5 5 2.5"></polyline><polygon fill="#999999" points="9.59427002 0.565307617 4.31427002 5.84530762 4.31427002 6.56530762 5.03427002 6.56530762 10.31427 1.28530762"></polygon></g></svg>编辑这个页面</a>
            </div>
        </aside>
<div id="header">
<h1>Gradle用户手册：版本6.0.1</h1>
<div class="details">
<span id="revnumber">版本6.0.1</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">目录</div>
<ul class="sectlevel1">
<li><a href="#part:about_gradle">关于摇篮</a>
<ul class="sectlevel2">
<li><a href="#what_is_gradle">什么是Gradle？</a></li>
</ul>
</li>
<li><a href="#part:getting_started">入门</a>
<ul class="sectlevel2">
<li><a href="#getting_started">入门</a></li>
<li><a href="#installation">安装Gradle</a></li>
<li><a href="#troubleshooting">对构建进行故障排除</a></li>
</ul>
</li>
<li><a href="#part:upgrading_and_migrating">升级和迁移</a>
<ul class="sectlevel2">
<li><a href="#upgrading_version_5">将您的构建从Gradle 5.x升级到6.0</a></li>
<li><a href="#upgrading_version_4">将您的构建从Gradle 4.x升级到5.0</a></li>
<li><a href="#migrating_from_maven">从Apache Maven迁移构建</a></li>
<li><a href="#migrating_from_ant">从Apache Ant迁移构建</a></li>
</ul>
</li>
<li><a href="#part:running_builds">运行Gradle构建</a>
<ul class="sectlevel2">
<li><a href="#build_environment">搭建环境</a></li>
<li><a href="#gradle_daemon">Gradle守护程序</a></li>
<li><a href="#init_scripts">初始化脚本</a></li>
<li><a href="#intro_multi_project_builds">执行多项目构建</a></li>
<li><a href="#build_cache">构建缓存</a></li>
</ul>
</li>
<li><a href="#part:authoring_builds">编写Gradle构建</a>
<ul class="sectlevel2">
<li><a href="#tutorial_using_tasks">构建脚本基础</a></li>
<li><a href="#more_about_tasks">创作任务</a></li>
<li><a href="#writing_build_scripts">编写构建脚本</a></li>
<li><a href="#working_with_files">处理文件</a></li>
<li><a href="#plugins">使用Gradle插件</a></li>
<li><a href="#build_lifecycle">建立生命周期</a></li>
<li><a href="#logging">记录中</a></li>
<li><a href="#multi_project_builds">创作多项目构建</a></li>
<li><a href="#organizing_gradle_projects">组织Gradle项目</a></li>
<li><a href="#authoring_maintainable_build_scripts">创作可维护版本的最佳实践</a></li>
<li><a href="#lazy_configuration">延迟配置</a></li>
<li><a href="#test_kit">使用TestKit测试构建逻辑</a></li>
<li><a href="#ant">从Gradle使用Ant</a></li>
</ul>
</li>
<li><a href="#part:dependency_management">依赖管理</a>
<ul class="sectlevel2">
<li><a href="#learning_the_basics">学习基础</a></li>
<li><a href="#declaring_versions">声明版本</a></li>
<li><a href="#controlling_transitive_dependencies">控制传递依存关系</a></li>
<li><a href="#producing_and_consuming_variants_of_libraries">图书馆的生产和消费形式</a></li>
<li><a href="#working_in_a_multi_repo_environment">在多仓库环境中工作</a></li>
<li><a href="#publishing_libraries">出版图书馆</a></li>
</ul>
</li>
<li><a href="#part:jvm_projects">Java和其他JVM项目</a>
<ul class="sectlevel2">
<li><a href="#building_java_projects">构建Java和JVM项目</a></li>
<li><a href="#java_testing">在Java和JVM项目中进行测试</a></li>
<li><a href="#dependency_management_for_java_projects">管理JVM项目的依赖关系</a></li>
</ul>
</li>
<li><a href="#part:native_projects">C ++和其他本机项目</a>
<ul class="sectlevel2">
<li><a href="#building_cpp_projects">构建C ++项目</a></li>
<li><a href="#cpp_testing">在C ++项目中进行测试</a></li>
<li><a href="#building_swift_projects">建立Swift项目</a></li>
<li><a href="#swift_testing">在Swift项目中进行测试</a></li>
</ul>
</li>
<li><a href="#native_projects_using_the_software_model">使用软件模型的本机项目</a>
<ul class="sectlevel2">
<li><a href="#native_software">构建本机软件</a></li>
<li><a href="#software_model_concepts">软件模型概念</a></li>
<li><a href="#software_model">基于规则的模型配置</a></li>
<li><a href="#rule_source">在插件中实现模型规则</a></li>
<li><a href="#software_model_extend">扩展软件模型</a></li>
</ul>
</li>
<li><a href="#part:extending_gradle">扩展摇篮</a>
<ul class="sectlevel2">
<li><a href="#custom_tasks">开发自定义Gradle任务类型</a></li>
<li><a href="#custom_plugins">开发自定义Gradle插件</a></li>
<li><a href="#custom_gradle_types">开发自定义Gradle类型</a></li>
<li><a href="#java_gradle_plugin">Gradle插件开发插件</a></li>
</ul>
</li>
<li><a href="#part:reference">参考</a>
<ul class="sectlevel2">
<li><a href="#groovy_build_script_primer">Groovy构建脚本入门</a></li>
<li><a href="#kotlin_dsl">Gradle Kotlin DSL入门</a></li>
<li><a href="#plugin_reference">Gradle插件参考</a></li>
<li><a href="#command_line_interface">命令行界面</a></li>
<li><a href="#third_party_integration">Gradle和第三方工具</a></li>
<li><a href="#gradle_wrapper">摇篮包装</a></li>
<li><a href="#directory_layout">目录和文件Gradle的使用</a></li>
</ul>
</li>
<li><a href="#part:plugins">外挂程式</a>
<ul class="sectlevel2">
<li><a href="#antlr_plugin">ANTLR插件</a></li>
<li><a href="#application_plugin">应用插件</a></li>
<li><a href="#base_plugin">基础插件</a></li>
<li><a href="#build_init_plugin">构建初始化插件</a></li>
<li><a href="#checkstyle_plugin">Checkstyle插件</a></li>
<li><a href="#codenarc_plugin">CodeNarc插件</a></li>
<li><a href="#distribution_plugin">发行插件</a></li>
<li><a href="#ear_plugin">耳塞</a></li>
<li><a href="#eclipse_plugin">Eclipse插件</a></li>
<li><a href="#groovy_plugin">Groovy插件</a></li>
<li><a href="#idea_plugin">IDEA插件</a></li>
<li><a href="#publishing_ivy">常春藤发布插件</a></li>
<li><a href="#jacoco_plugin">JaCoCo插件</a></li>
<li><a href="#java_plugin">Java插件</a></li>
<li><a href="#java_library_plugin">Java库插件</a></li>
<li><a href="#java_library_distribution_plugin">Java库发行插件</a></li>
<li><a href="#java_platform_plugin">Java平台插件</a></li>
<li><a href="#publishing_maven">Maven发布插件</a></li>
<li><a href="#maven_plugin">Maven插件</a></li>
<li><a href="#pmd_plugin">PMD插件</a></li>
<li><a href="#scala_plugin">Scala插件</a></li>
<li><a href="#signing_plugin">签名插件</a></li>
<li><a href="#war_plugin">战争插件</a></li>
</ul>
</li>
<li><a href="#license_information">许可证信息</a></li>
<li><a href="#licenses">许可证信息</a>
<ul class="sectlevel2">
<li><a href="#sec:gradle_documentation">Gradle文档</a></li>
<li><a href="#licenses:build_scan_plugin">Gradle Build扫描插件</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="part:about_gradle"><a class="anchor" href="#part:about_gradle"></a> <a class="link" href="#part:about_gradle">关于摇篮</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what_is_gradle"><a class="anchor" href="#what_is_gradle"></a> <a class="link" href="#what_is_gradle">什么是Gradle？</a></h3>
<div class="sect3">
<h4 id="gradle_overview"><a class="anchor" href="#gradle_overview"></a> <a class="link" href="#gradle_overview">总览</a></h4>
<div class="paragraph">
<p>Gradle是一个开放源代码的<a href="https://en.wikipedia.org/wiki/Build_automation">构建自动化</a>工具，旨在灵活地构建几乎任何类型的软件。以下是其一些最重要功能的高级概述：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">高性能</dt>
<dd>
<p>Gradle通过仅运行需要运行的任务来避免不必要的工作，因为它们的输入或输出已更改。您还可以使用构建缓存来重用以前运行的任务输出，甚至可以重用其他机器（带有共享构建缓存）的任务输出。</p>
<div class="paragraph">
<p>Gradle实施了许多其他优化，并且开发团队不断努力以提高Gradle的性能。</p>
</div>
</dd>
<dt class="hdlist1">JVM基础</dt>
<dd>
<p>Gradle在JVM上运行，并且必须安装Java开发工具包（JDK）才能使用它。对于熟悉Java平台的用户来说，这是一个好处，因为您可以在构建逻辑中使用标准Java API，例如自定义任务类型和插件。它还使在不同平台上运行Gradle变得容易。</p>
<div class="paragraph">
<p>请注意，Gradle不仅限于构建JVM项目，它甚至附带对构建本机项目的支持。</p>
</div>
</dd>
<dt class="hdlist1">约定</dt>
<dd>
<p>Gradle从Maven的书中摘取了叶子，并通过实现约定使常见类型的项目（例如Java项目）易于构建。应用适当的插件，您可以轻松地为许多项目使用苗条的构建脚本。但是这些约定并不限制您：Gradle允许您覆盖它们，添加自己的任务以及对基于约定的构建进行许多其他自定义。</p>
</dd>
<dt class="hdlist1">可扩展性</dt>
<dd>
<p>您可以轻松扩展Gradle以提供您自己的任务类型甚至构建模型。有关此示例，请参见Android构建支持：它添加了许多新的构建概念，例如口味和构建类型。</p>
</dd>
<dt class="hdlist1">IDE支持</dt>
<dd>
<p>几个主要的IDE允许您导入Gradle构建并与其进行交互：Android Studio，IntelliJ IDEA，Eclipse和NetBeans。Gradle还支持生成将项目加载到Visual Studio所需的解决方案文件。</p>
</dd>
<dt class="hdlist1">洞察力</dt>
<dd>
<p><a href="https://scans.gradle.com/">构建扫描</a>提供了有关构建运行的广泛信息，可用于识别构建问题。他们特别擅长帮助您确定构建性能的问题。您还可以与其他人共享构建扫描，如果您在解决构建问题时需要征求意见，这将特别有用。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="five_things"><a class="anchor" href="#five_things"></a> <a class="link" href="#five_things">您需要了解有关Gradle的五件事</a></h4>
<div class="paragraph">
<p>Gradle是一种灵活而强大的构建工具，当您初次启动时，很容易感到恐惧。但是，了解以下核心原则将使Gradle更加容易上手，并且您将在不知道该工具的情况下熟练掌握该工具。</p>
</div>
<div class="sect4">
<h5 id="1_gradle_is_a_general_purpose_build_tool"><a class="anchor" href="#1_gradle_is_a_general_purpose_build_tool"></a> <a class="link" href="#1_gradle_is_a_general_purpose_build_tool">1。Gradle是通用构建工具</a></h5>
<div class="paragraph">
<p>Gradle允许您构建任何软件，因为它对正在尝试构建的内容或应如何完成的工作做出很少的假设。最明显的限制是，依赖项管理当前仅支持与Maven和Ivy兼容的存储库以及文件系统。</p>
</div>
<div class="paragraph">
<p>这并不意味着您需要做很多工作来创建构建。Gradle通过添加一层约定和通过<a href="#plugins"><em>插件</em></a>预先构建的功能，可以轻松构建常见类型的项目（例如Java库）。您甚至可以创建和发布自定义插件来封装自己的约定并构建功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="the_core_model_is_based_on_tasks"><a class="anchor" href="#the_core_model_is_based_on_tasks"></a> <a class="link" href="#the_core_model_is_based_on_tasks">2。核心模型基于任务</a></h5>
<div class="paragraph">
<p>Gradle将其构建模型建模为任务（工作单元）的有向无环图（DAG）。这意味着构建实质上配置了一组任务，并根据它们的依赖关系将它们连接在一起以创建该DAG。创建任务图后，Gradle将确定需要按顺序运行的任务，然后继续执行它们。</p>
</div>
<div class="paragraph">
<p>此图显示了两个示例任务图，一个是抽象图，另一个是具体图，其中任务之间的依赖性表示为箭头：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/task-dag-examples.png" alt="任务图示例">
</div>
<div class="title">图1。Gradle任务图的两个示例</div>
</div>
<div class="paragraph">
<p>这样，几乎所有构建过程都可以建模为任务图，这就是Gradle如此灵活的原因之一。任务图既可以由插件定义，也可以由您自己的构建脚本定义，任务通过<a href="#sec:task_dependencies">任务依赖机制</a>链接在一起。</p>
</div>
<div class="paragraph">
<p>任务本身包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>动作-做某事的工作，例如复制文件或编译源代码</p>
</li>
<li>
<p>输入-操作使用或对其进行操作的值，文件和目录</p>
</li>
<li>
<p>输出-操作修改或生成的文件和目录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>实际上，以上所有内容都是可选的，具体取决于任务需要执行的操作。有些任务（例如<a href="#sec:base_tasks">标准生命周期任务）</a>甚至没有任何动作。他们只是为了方便而将多个任务聚合在一起。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">您选择要运行的任务。通过指定执行所需任务的任务来节省时间，但仅此而已。如果您只想运行单元测试，请选择执行该任务的任务-通常<code>test</code> 。如果您要打包应用程序，则大多数构建都有<code>assemble</code>任务。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后一件事：Gradle的<a href="#sec:up_to_date_checks">增量构建</a>支持是可靠且可靠的，因此请避免使用<code>clean</code>除非您确实确实想要执行清理。</p>
</div>
</div>
<div class="sect4">
<h5 id="3_gradle_has_several_fixed_build_phases"><a class="anchor" href="#3_gradle_has_several_fixed_build_phases"></a> <a class="link" href="#3_gradle_has_several_fixed_build_phases">3。Gradle有几个固定的构建阶段</a></h5>
<div class="paragraph">
<p>重要的是要了解Gradle分三个阶段评估和执行构建脚本：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>初始化</p>
<div class="paragraph">
<p>设置构建环境，并确定哪些项目将参与其中。</p>
</div>
</li>
<li>
<p>组态</p>
<div class="paragraph">
<p>构造和配置构建的任务图，然后根据用户要运行的任务确定需要运行的任务和运行顺序。</p>
</div>
</li>
<li>
<p>执行</p>
<div class="paragraph">
<p>运行在配置阶段结束时选择的任务。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>这些阶段构成了Gradle的<a href="#build_lifecycle">Build Lifecycle</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">与Apache Maven术语的比较</div>
<div class="paragraph">
<p>Gradle的构建阶段与Maven的阶段不同。Maven使用其阶段将构建执行划分为多个阶段。它们的作用与Gradle的任务图相似，但灵活性较差。</p>
</div>
<div class="paragraph">
<p>Maven的构建生命周期概念与Gradle的<a href="#sec:base_tasks">生命周期任务</a>大致相似。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>设计良好的构建脚本主要由<a href="#sec:avoid_imperative_logic_in_scripts">声明性配置而不是命令式逻辑组成</a> 。可以理解，在配置阶段评估该配置。即便如此，许多此类构建也具有任务操作，例如通过<code>doLast {}</code>和<code>doFirst {}</code>块-在执行阶段进行评估。这很重要，因为在配置阶段评估的代码不会看到在执行阶段发生的更改。</p>
</div>
<div class="paragraph">
<p>配置阶段的另一个重要方面是， <em>每次构建运行时都会</em>评估其中涉及的所有内容。这就是为什么最佳做法是<a href="#sec:minimize_logic_executed_configuration_phase">在配置阶段避免昂贵的工作</a> 。<a href="https://scans.gradle.com/">构建扫描</a>可以帮助您识别此类热点。</p>
</div>
</div>
<div class="sect4">
<h5 id="4_gradle_is_extensible_in_more_ways_than_one"><a class="anchor" href="#4_gradle_is_extensible_in_more_ways_than_one"></a> <a class="link" href="#4_gradle_is_extensible_in_more_ways_than_one">4。Gradle的扩展方式不止一种</a></h5>
<div class="paragraph">
<p>如果您可以仅使用Gradle捆绑的构建逻辑来构建项目，那将是很好的，但这几乎是不可能的。大多数构建都有一些特殊要求，这意味着您需要添加自定义构建逻辑。</p>
</div>
<div class="paragraph">
<p>Gradle提供了多种机制来扩展它，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#">自定义任务类型</a> 。</p>
<div class="paragraph">
<p>当您希望构建完成现有任务无法完成的工作时，只需编写自己的任务类型即可。通常最好将自定义任务类型的源文件放在<a href="#sec:build_sources"><em>buildSrc</em></a>目录或打包的插件中。然后，您可以像Gradle提供的任何任务一样使用自定义任务类型。</p>
</div>
</li>
<li>
<p>自定义任务动作。</p>
<div class="paragraph">
<p>您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:doFirst(org.gradle.api.Action)">Task.doFirst（）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:doLast(org.gradle.api.Action)">Task.doLast（）</a>方法附加在任务之前或之后执行的自定义构建逻辑。</p>
</div>
</li>
<li>
<p>项目和任务的<a href="#sec:extra_properties">额外属性</a> 。</p>
<div class="paragraph">
<p>这些允许您将自己的属性添加到项目或任务中，然后可以从您自己的自定义操作或任何其他构建逻辑中使用它们。额外的属性甚至可以应用于您未明确创建的任务，例如Gradle的核心插件创建的任务。</p>
</div>
</li>
<li>
<p>自定义约定。</p>
<div class="paragraph">
<p>约定是简化构建的强大方法，因此用户可以更轻松地理解和使用它们。使用标准项目结构和命名约定的<a href="#building_java_projects">构建</a> （例如<a href="#building_java_projects">Java build）</a>可以看出这一点。您可以编写自己的提供约定的插件-它们只需要为构建的相关方面配置默认值。</p>
</div>
</li>
<li>
<p><a href="https://guides.gradle.org/implementing-gradle-plugins/#modeling_dsl_like_apis">自定义模型</a> 。</p>
<div class="paragraph">
<p>Gradle允许您将新概念引入除任务，文件和依赖项配置之外的内部版本。您可以在大多数语言插件中看到这一点，这些插件将<a href="#sec:java_source_sets"><em>源集</em></a>的概念添加到了构建中。构建过程的适当建模可以大大提高构建的易用性及其效率。</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="5_build_scripts_operate_against_an_api"><a class="anchor" href="#5_build_scripts_operate_against_an_api"></a> <a class="link" href="#5_build_scripts_operate_against_an_api">5，构建脚本针对API进行操作</a></h5>
<div class="paragraph">
<p>将Gradle的构建脚本视为可执行代码很容易，因为这就是它们。但是，这是一个实现细节：精心设计构建脚本描述构建软件，这些措施不应该<em>怎么</em>做的工作都需要<em>哪些</em>步骤。这是定制任务类型和插件的工作。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>人们普遍误认为Gradle的功能和灵活性来自其构建脚本是代码这一事实。这离事实还远。提供功能的是底层模型和API。正如我们在最佳实践中建议的那样，您应该<a href="#sec:avoid_imperative_logic_in_scripts">避免在构建脚本中放置太多（如果有）命令式逻辑</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然而，在一个区域中，将构建脚本视为可执行代码很有用：了解构建脚本的语法如何映射到Gradle的API。由<a href="https://docs.gradle.org/6.0.1/dsl/">Groovy DSL参考</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/">Javadocs</a>组成的API文档列出了方法和属性，并引用了闭包和操作。这些在构建脚本的上下文中是什么意思？查看<a href="#groovy_build_script_primer">Groovy Build Script Primer，</a>以了解该问题的答案，以便您可以有效地使用API文档。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">由于Gradle在JVM上运行，因此构建脚本也可以使用标准<a href="https://docs.oracle.com/javase/8/docs/api">Java API</a> 。 Groovy构建脚本可以另外使用Groovy API，而Kotlin构建脚本可以使用Kotlin。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="part:getting_started"><a class="anchor" href="#part:getting_started"></a> <a class="link" href="#part:getting_started">入门</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="getting_started"><a class="anchor" href="#getting_started"></a> <a class="link" href="#getting_started">入门</a></h3>
<div class="paragraph">
<p>每个人都必须从某个地方开始，如果您是Gradle的新手，那么这就是开始的地方。</p>
</div>
<div class="sect3">
<h4 id="before_you_start"><a class="anchor" href="#before_you_start"></a> <a class="link" href="#before_you_start">在你开始前</a></h4>
<div class="paragraph">
<p>为了有效地使用Gradle，您需要了解Gradle是什么并了解其一些基本概念。因此，在您开始认真使用Gradle之前，我们强烈建议您阅读<a href="#what_is_gradle">什么是Gradle？</a> 。</p>
</div>
<div class="paragraph">
<p>即使您有使用Gradle的经验，我们还是建议您阅读<a href="#five_things">有关Gradle</a>的第<a href="#five_things">5</a>部分<a href="#five_things">要了解的知识，</a>因为它<a href="#five_things">可以消除</a>一些常见的误解。</p>
</div>
</div>
<div class="sect3">
<h4 id="gs:installation"><a class="anchor" href="#gs:installation"></a> <a class="link" href="#gs:installation">安装</a></h4>
<div class="paragraph">
<p>如果您只想运行现有的Gradle构建，那么如果构建中有<a href="#gradle_wrapper">Gradle Wrapper</a> ，则可以通过构建的根目录中的<em>gradlew</em>和/或<em>gradlew.bat</em>文件进行识别，而无需安装Gradle。您只需要确保您的系统<a href="#sec:prerequisites">满足Gradle的前提条件即可</a> 。</p>
</div>
<div class="paragraph">
<p>Android Studio随附了可以正常使用的Gradle安装，因此在这种情况下，您无需单独安装Gradle。</p>
</div>
<div class="paragraph">
<p>为了创建新的构建或将Wrapper添加到现有构建，您将需要<a href="#installation">根据以下说明</a>安装Gradle。请注意，除了该页面上所述的方法以外，还有其他安装Gradle的方法，因为几乎不可能跟踪那里的所有软件包管理器。</p>
</div>
</div>
<div class="sect3">
<h4 id="try_gradle"><a class="anchor" href="#try_gradle"></a> <a class="link" href="#try_gradle">尝试Gradle</a></h4>
<div class="paragraph">
<p>积极使用Gradle是了解它的一种好方法，因此，一旦您安装了Gradle，请尝试以下入门实践教程之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://guides.gradle.org/creating-new-gradle-builds/">创建一个基本的Gradle构建</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/building-android-apps/">建立Android应用程式</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/building-java-libraries/">构建Java库</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/building-kotlin-jvm-libraries/">构建Kotlin JVM库</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/building-cpp-libraries/">构建C ++库</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/creating-build-scans/">创建构建扫描</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有许多其他<a href="https://guides.gradle.org/">教程和指南</a>可用，您可以按类别进行过滤，例如<a href="https://guides.gradle.org/?q=Fundamentals">Fundamentals</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="command_line_vs_ides"><a class="anchor" href="#command_line_vs_ides"></a> <a class="link" href="#command_line_vs_ides">命令行与IDE</a></h4>
<div class="paragraph">
<p>有些人是核心命令行用户，而另一些人则更喜欢永远不要离开他们的IDE。许多人愉快地使用两者，并且Gradle尽力不歧视。<a href="#ides">几个主要的IDE</a>支持Gradle，并且可以通过<a href="#embedding">Tooling API</a>通过IDE进行<a href="#command_line_interface">命令行中的</a>所有操作。</p>
</div>
<div class="paragraph">
<p>Android Studio和IntelliJ IDEA用户在编辑它们时应考虑使用<a href="#kotlin_dsl">Kotlin DSL构建脚本</a>来获得出色的IDE支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="executing_gradle_builds"><a class="anchor" href="#executing_gradle_builds"></a> <a class="link" href="#executing_gradle_builds">执行Gradle构建</a></h4>
<div class="paragraph">
<p>如果您遵循<a href="#try_gradle">上面链接的</a>任何教程，您将执行Gradle构建。但是，如果没有任何说明就获得了Gradle构建，该怎么办？</p>
</div>
<div class="paragraph">
<p>以下是一些有用的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>确定项目是否有Gradle包装器， <a href="#sec:using_wrapper">如果有</a> ，请<a href="#sec:using_wrapper">使用它</a> -主IDE默认在可用时使用包装器。</p>
</li>
<li>
<p>发现项目结构。</p>
<div class="paragraph">
<p>使用IDE导入构建或运行<code>gradle projects</code>从命令行。如果仅列出了根项目，则它是单项目构建。否则，它是一个<a href="#intro_multi_project_builds">多项目构建</a> 。</p>
</div>
</li>
<li>
<p>找出可以运行的任务。</p>
<div class="paragraph">
<p>如果已将内部版本导入到IDE，则应该有权访问显示所有可用任务的视图。从命令行运行<code>gradle tasks</code> 。</p>
</div>
</li>
<li>
<p>通过了解更多有关任务的信息<code>gradle help --task <taskname></code> 。</p>
<div class="paragraph">
<p>的<code>help</code>任务可以显示有关任务的其他信息，包括哪些项目包含该任务以及该任务支持的选项。</p>
</div>
</li>
<li>
<p>运行您感兴趣的任务。</p>
<div class="paragraph">
<p>许多基于约定的构建都与Gradle的<a href="#sec:base_tasks">生命周期任务</a>集成在一起，因此，当您没有想要对构建进行更具体的处理时，可以使用它们。例如，大多数构建具有<code>clean</code> ， <code>check</code> ， <code>assemble</code>和<code>build</code>任务。</p>
</div>
<div class="paragraph">
<p>在命令行中，只需运行<code>gradle <taskname></code>执行特定任务。您可以在<a href="#command_line_interface">相应的用户手册章节中</a>了解有关命令行执行的更多信息。如果您使用的是IDE，请查看其文档以了解如何运行任务。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Gradle构建通常会在项目结构和任务上遵循标准约定，因此，如果您熟悉相同类型的其他构建（例如Java，Android或本机构建），那么构建的文件和目录结构也应熟悉以及许多任务和项目属性。</p>
</div>
<div class="paragraph">
<p>对于更专业的构建或具有重大定制的构建，理想情况下，您应该可以访问有关如何运行构建以及可以配置哪些<a href="#build_environment">构建属性的</a>文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="authoring_gradle_builds"><a class="anchor" href="#authoring_gradle_builds"></a> <a class="link" href="#authoring_gradle_builds">编写Gradle版本</a></h4>
<div class="paragraph">
<p>学习创建和维护Gradle构建是一个过程，需要花费一些时间。我们建议您从适用于项目的适当核心插件及其约定开始，然后在您进一步了解该工具时逐渐合并自定义项。</p>
</div>
<div class="paragraph">
<p>以下是掌握Gradle的一些有用的第一步：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>尝试一两个<a href="#try_gradle">基本教程，</a>以了解Gradle构建的外观，特别是与您使用的项目类型（Java，本机，Android等）相匹配的构建。</p>
</li>
<li>
<p>确保您已阅读<a href="#five_things">有关Gradle的5件事</a> ！</p>
</li>
<li>
<p>了解Gradle构建的基本元素： <a href="#sec:projects_and_tasks">项目</a> ， <a href="#more_about_tasks">任务</a>和<a href="#working_with_files">文件API</a> 。</p>
</li>
<li>
<p>如果要为JVM构建软件，请确保在《 <a href="#building_java_projects">构建Java和JVM项目》</a>和《 <a href="#java_testing">在Java和JVM项目中测试》中</a>阅读有关这些类型<a href="#java_testing">项目的详细信息</a> 。</p>
</li>
<li>
<p>熟悉Gradle随附的<a href="#plugin_reference">核心插件</a> ，因为它们提供了许多开箱即用的有用功能。</p>
</li>
<li>
<p>了解如何<a href="#authoring_maintainable_build_scripts">编写可维护的构建脚本</a>以及如何<a href="#organizing_gradle_projects">最好地组织Gradle项目</a> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>该用户手册包含许多其他有用的信息，您可以在<a href="https://guides.gradle.org/">Gradle Guides中</a>找到有关Gradle各种功能的更多教程。</p>
</div>
</div>
<div class="sect3">
<h4 id="integrating_3rd_party_tools_with_gradle"><a class="anchor" href="#integrating_3rd_party_tools_with_gradle"></a> <a class="link" href="#integrating_3rd_party_tools_with_gradle">将第三方工具与Gradle集成</a></h4>
<div class="paragraph">
<p>Gradle的灵活性意味着它可以轻松地与其他工具配合使用，例如在“ <a href="#third_party_integration">Gradle和第三方工具”</a>页面上列出的<a href="#third_party_integration">工具</a> 。</p>
</div>
<div class="paragraph">
<p>集成有两种主要模式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>工具通过<a href="#embedding">Tooling API</a>驱动Gradle（使用它来提取有关构建的信息并运行它）</p>
</li>
<li>
<p>Gradle通过第三方工具的API调用或生成工具信息-通常是通过插件和自定义任务类型来完成</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>具有现有的基于Java的API的工具通常易于集成。您可以在Gradle的<a href="https://plugins.gradle.org/">插件门户</a>上找到许多此类集成。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="installation"><a class="anchor" href="#installation"></a> <a class="link" href="#installation">安装Gradle</a></h3>
<div class="paragraph">
<p>您可以在Linux，macOS或Windows上安装Gradle构建工具。本文档涵盖使用软件包管理器（如SDKMAN）进行安装！或Homebrew，以及手动安装。</p>
</div>
<div class="paragraph">
<p>建议使用<a href="#sec:upgrading_wrapper">Gradle包装器</a>升级Gradle。</p>
</div>
<div class="paragraph">
<p>您可以在“ <a href="https://gradle.org/releases">发行版”页面</a>上找到所有发行版及其校验和。</p>
</div>
<div class="sect3">
<h4 id="sec:prerequisites"><a class="anchor" href="#sec:prerequisites"></a> <a class="link" href="#sec:prerequisites">先决条件</a></h4>
<div class="paragraph">
<p>Gradle可在所有主要操作系统上运行，并且仅需要<a href="https://jdk.java.net/">Java开发套件</a>版本8或更高版本即可运行。要检查，运行<code>java -version</code> 。您应该会看到以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ java -version
java version "1.8.0_151"
Java(TM) SE Runtime Environment (build 1.8.0_151-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</pre>
</div>
</div>
<div class="paragraph">
<p>Gradle附带了自己的Groovy库，因此不需要安装Groovy。Gradle将忽略任何现有的Groovy安装。</p>
</div>
<div class="paragraph">
<p>Gradle使用在路径中找到的任何JDK。或者，您可以设置<code>JAVA_HOME</code>环境变量以指向所需JDK的安装目录。</p>
</div>
</div>
<div class="sect3">
<h4 id="installing_with_a_package_manager"><a class="anchor" href="#installing_with_a_package_manager"></a> <a class="link" href="#installing_with_a_package_manager">使用软件包管理器进行安装</a></h4>
<div class="paragraph">
<p><a href="http://sdkman.io">SDKMAN！</a> 是用于管理大多数类Unix系统（macOS，Linux，Cygwin，Solaris和FreeBSD）上多个软件开发套件的并行版本的工具。我们部署并维护可从SDKMAN！获得的版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ sdk install gradle</pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://brew.sh">Homebrew</a>是“ macOS缺少的软件包管理器”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ brew install gradle</pre>
</div>
</div>
<div class="paragraph">
<p>可以使用其他软件包管理器，但是它们分发的Gradle版本不受Gradle，Inc.的控制。Linux软件包管理器可能会分发与正式版本相比不兼容或不完整的Gradle修改版（可从SDKMAN获得！或以下）。</p>
</div>
<div class="paragraph">
<p><a href="#sec:installation_next_steps">↓继续下一步</a></p>
</div>
</div>
<div class="sect3">
<h4 id="installing_manually"><a class="anchor" href="#installing_manually"></a> <a class="link" href="#installing_manually">手动安装</a></h4>
<div class="sect4">
<h5 id="step_1_download_the_latest_gradle_distribution"><a class="anchor" href="#step_1_download_the_latest_gradle_distribution"></a> <a class="link" href="#step_1_download_the_latest_gradle_distribution">步骤1。</a><a href="https://gradle.org/releases">下载</a>最新的Gradle发行版</h5>
<div class="paragraph">
<p>分发ZIP文件有两种形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅二进制（bin）</p>
</li>
<li>
<p>完整（全部）包含文件和资料</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>需要使用旧版本吗？请参阅<a href="https://gradle.org/releases">发布页面</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="step_2_unpack_the_distribution"><a class="anchor" href="#step_2_unpack_the_distribution"></a> <a class="link" href="#step_2_unpack_the_distribution">第2步。打开发行包</a></h5>
<div class="sect5">
<h6 id="linux_macos_users"><a class="anchor" href="#linux_macos_users"></a> <a class="link" href="#linux_macos_users">Linux和MacOS用户</a></h6>
<div class="paragraph">
<p>在您选择的目录中解压缩分发zip文件，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ mkdir /opt/gradle
❯ unzip -d /opt/gradle gradle-6.0.1-bin.zip
❯ ls /opt/gradle/gradle-6.0.1
LICENSE  NOTICE  bin  getting-started.html  init.d  lib  media</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="microsoft_windows_users"><a class="anchor" href="#microsoft_windows_users"></a> <a class="link" href="#microsoft_windows_users">Microsoft Windows用户</a></h6>
<div class="paragraph">
<p>创建一个新目录<code>C:\Gradle</code>与<strong>文件资源管理器</strong> 。</p>
</div>
<div class="paragraph">
<p>打开第二个“ <strong>文件资源管理器”</strong>窗口，然后转到下载Gradle发行版的目录。双击ZIP存档以显示内容。拖动内容文件夹<code>gradle-6.0.1</code>到您新创建的<code>C:\Gradle</code>夹。</p>
</div>
<div class="paragraph">
<p>或者，您可以将Gradle发行版ZIP解压缩到<code>C:\Gradle</code>使用您选择的存档工具。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="step_3_configure_your_system_environment"><a class="anchor" href="#step_3_configure_your_system_environment"></a> <a class="link" href="#step_3_configure_your_system_environment">第三步配置系统环境</a></h5>
<div class="paragraph">
<p>要运行Gradle，从Gradle网站到解压缩文件的路径必须在终端的路径上。对于每个操作系统，执行此操作的步骤都不同。</p>
</div>
<div class="sect5">
<h6 id="linux_macos_users_2"><a class="anchor" href="#linux_macos_users_2"></a> <a class="link" href="#linux_macos_users_2">Linux和MacOS用户</a></h6>
<div class="paragraph">
<p>配置您的<code>PATH</code>环境变量包括<code>bin</code>解压缩发行版的目录，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ export PATH=$PATH:/opt/gradle/gradle-6.0.1/bin</pre>
</div>
</div>
<div class="paragraph">
<p>或者，您也可以添加环境变量<code>GRADLE_HOME</code>并将其指向未压缩的发行版。而不是将特定版本的Gradle添加到您的<code>PATH</code> ， 你可以加<code><em>$GRADLE_HOME</em>/bin</code>给你<code>PATH</code> 。升级到其他版本的Gradle时，只需更改<code>GRADLE_HOME</code>环境变量。</p>
</div>
</div>
<div class="sect5">
<h6 id="microsoft_windows_users_2"><a class="anchor" href="#microsoft_windows_users_2"></a> <a class="link" href="#microsoft_windows_users_2">Microsoft Windows用户</a></h6>
<div class="paragraph">
<p>在<strong>文件资源管理器中，</strong>右键单击<code>This PC</code> （要么<code>Computer</code> ）图标，然后单击<code>Properties</code> → <code>Advanced System Settings</code> → <code>Environmental Variables</code> 。</p>
</div>
<div class="paragraph">
<p>下<code>System Variables</code>选择<code>Path</code> ，然后点击<code>Edit</code> 。为添加一个条目<code>C:\Gradle\gradle-6.0.1\bin</code> 。单击确定保存。</p>
</div>
<div class="paragraph">
<p>或者，您也可以添加环境变量<code>GRADLE_HOME</code>并将其指向未压缩的发行版。而不是将特定版本的Gradle添加到您的<code>Path</code> ， 你可以加<code><em>%GRADLE_HOME%</em>/bin</code>给你<code>Path</code> 。升级到其他版本的Gradle时，只需更改<code>GRADLE_HOME</code>环境变量。</p>
</div>
<div class="paragraph">
<p><a href="#sec:installation_next_steps">↓继续下一步</a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:running_and_testing_your_installation"><a class="anchor" href="#sec:running_and_testing_your_installation"></a> <a class="link" href="#sec:running_and_testing_your_installation">验证安装</a></h4>
<div class="paragraph">
<p>打开控制台（或Windows命令提示符）并运行<code>gradle -v</code>运行gradle并显示版本，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ gradle -v

------------------------------------------------------------
Gradle 6.0.1
------------------------------------------------------------

(environment specific information)</pre>
</div>
</div>
<div class="paragraph">
<p>如果遇到任何麻烦，请参阅“ <a href="#sec:troubleshooting_installation">排除安装故障</a> ” <a href="#sec:troubleshooting_installation">部分</a> 。</p>
</div>
<div class="paragraph">
<p>您可以通过下载SHA-256文件（可从<a href="https://gradle.org/releases">发行版中获得</a> ）并按照以下<a href="#sec:verification">验证说明</a>来验证Gradle分发的完整性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:installation_next_steps"><a class="anchor" href="#sec:installation_next_steps"></a> <a class="link" href="#sec:installation_next_steps">下一步</a></h4>
<div class="paragraph">
<p>现在您已经安装了Gradle，请使用以下资源进行入门：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>按照“ <a href="https://guides.gradle.org/creating-new-gradle-builds/">创建新的Gradle构建”</a>教程创建第一个Gradle项目。</p>
</li>
<li>
<p>与核心工程师一起注册<a href="https://gradle.org/training/intro-to-gradle/">Gradle现场入门培训</a> 。</p>
</li>
<li>
<p>了解如何通过<a href="#command_line_interface">命令行界面</a>完成常见任务。</p>
</li>
<li>
<p><a href="#build_environment">配置Gradle执行</a> ，例如使用HTTP代理下载依赖项。</p>
</li>
<li>
<p>订阅<a href="https://newsletter.gradle.com/">Gradle通讯</a>以获取每月发布和社区更新。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="troubleshooting"><a class="anchor" href="#troubleshooting"></a> <a class="link" href="#troubleshooting">对构建进行故障排除</a></h3>
<div class="paragraph">
<p>以下是常见问题的集合以及解决这些问题的建议。您可以获取其他技巧，并搜索<a href="https://discuss.gradle.org/c/help-discuss">Gradle论坛</a>和<a href="https://stackoverflow.com/questions/tagged/gradle">StackOverflow #gradle</a>答案以及来自<a href="https://help.gradle.org/">help.gradle.org的</a> Gradle文档。</p>
</div>
<div class="sect3">
<h4 id="sec:troubleshooting_installation"><a class="anchor" href="#sec:troubleshooting_installation"></a> <a class="link" href="#sec:troubleshooting_installation">对Gradle安装进行故障排除</a></h4>
<div class="paragraph">
<p>如果您按照<a href="#installation">安装说明进行操作</a> ，但无法执行Gradle构建，则以下一些技巧可能会有所帮助。</p>
</div>
<div class="paragraph">
<p>如果您仅在调用<a href="#gradle_wrapper">Gradle Wrapper</a>之外安装了<a href="#gradle_wrapper">Gradle</a> ，则可以通过运行以下命令检查Gradle的安装<code>gradle --version</code>在一个终端。</p>
</div>
<div class="paragraph">
<p>您应该会看到以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ gradle --version

-----------------------------------------------------------
Gradle 4.6
------------------------------------------------------------

Build time:   2018-02-21 15:28:42 UTC
Revision:     819e0059da49f469d3e9b2896dc4e72537c4847d

Groovy:       2.4.12
Ant:          Apache Ant(TM) version 1.9.9 compiled on February 2 2017
JVM:          1.8.0_151 (Oracle Corporation 25.151-b12)
OS:           Mac OS X 10.13.3 x86_64</pre>
</div>
</div>
<div class="paragraph">
<p>如果没有，您可能会看到一些东西。</p>
</div>
<div class="sect4">
<h5 id="command_not_found_gradle"><a class="anchor" href="#command_not_found_gradle"></a> <a class="link" href="#command_not_found_gradle">找不到命令：gradle</a></h5>
<div class="paragraph">
<p>如果收到“找不到命令：gradle”，则需要确保Gradle已正确添加到您的<code>PATH</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="java_home_is_set_to_an_invalid_directory"><a class="anchor" href="#java_home_is_set_to_an_invalid_directory"></a> <a class="link" href="#java_home_is_set_to_an_invalid_directory">JAVA_HOME设置为无效目录</a></h5>
<div class="paragraph">
<p>如果您得到以下信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR: JAVA_HOME is set to an invalid directory

Please set the JAVA_HOME variable in your environment to match the location of your Java installation.</pre>
</div>
</div>
<div class="paragraph">
<p>您需要确保<a href="https://www.java.com/en/download/help/index_installing.xml">正确安装</a>了<a href="https://jdk.java.net/">Java Development Kit</a>版本8或更高版本， <code>JAVA_HOME</code>设置环境变量，并将<a href="https://www.java.com/en/download/help/path.xml">Java添加到您的<code>PATH</code></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="permission_denied"><a class="anchor" href="#permission_denied"></a> <a class="link" href="#permission_denied">没有权限</a></h5>
<div class="paragraph">
<p>如果您获得“权限被拒绝”，则意味着Gradle可能存在于正确的位置，但不可执行。您可以使用解决此问题<code>chmod +x path/to/executable</code>在基于* nix的系统上。</p>
</div>
</div>
<div class="sect4">
<h5 id="other_installation_failures"><a class="anchor" href="#other_installation_failures"></a> <a class="link" href="#other_installation_failures">其他安装失败</a></h5>
<div class="paragraph">
<p>如果<code>gradle --version</code>可以，但是您所有的构建都因相同的错误而失败，其中一个Gradle构建配置脚本可能存在问题。</p>
</div>
<div class="paragraph">
<p>您可以通过运行来验证问题出在Gradle脚本上<code>gradle help</code>它执行配置脚本，但不执行Gradle任务。如果错误仍然存在，则构建配置存在问题。如果不是，则问题在于执行一个或多个请求的任务（Gradle首先执行配置脚本，然后执行构建步骤）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:troubleshooting_dependency_resolution"><a class="anchor" href="#sec:troubleshooting_dependency_resolution"></a> <a class="link" href="#sec:troubleshooting_dependency_resolution">调试依赖项解析</a></h4>
<div class="paragraph">
<p>常见的解决依赖问题，如解决版本冲突覆盖在<a href="#">故障排除依赖解析</a> 。</p>
</div>
<div class="paragraph">
<p>您可以通过单击“ <em>依赖关系”</em>视图并使用搜索功能（指定解决原因）来查看依赖关系树，并查看哪些已解决的依赖关系版本与请求的版本不同。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/troubleshooting-dependency-management-build-scan.png" alt="解决依赖性管理构建扫描故障">
</div>
<div class="title">图2。调试依赖项与构建扫描冲突</div>
</div>
<div class="paragraph">
<p>可以使用带有筛选条件的<a href="https://scans.gradle.com/s/sample/troubleshooting-userguide/dependencies?expandAll&filters=WzFd&toggled=W1swXSxbMF0sWzAsMF0sWzAsMV1d">实际构建扫描</a>进行探索。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:troubleshooting_performance"><a class="anchor" href="#sec:troubleshooting_performance"></a> <a class="link" href="#sec:troubleshooting_performance">对缓慢的Gradle构建进行故障排除</a></h4>
<div class="paragraph">
<p>有关构建性能问题（包括“同步时间慢”），请参阅《 <a href="https://guides.gradle.org/performance/">提高Gradle构建的性能</a>指南》。</p>
</div>
<div class="paragraph">
<p>Android开发人员应观看Android SDK Tools团队的有关<a href="https://youtu.be/7ll-rkLCtyk">加速Android Gradle构建</a>的演示。Android Studio用户指南还介绍了许多<a href="https://developer.android.com/studio/build/optimize-your-build.html">有关优化构建速度的</a>技巧。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:troubleshooting_build_logic"><a class="anchor" href="#sec:troubleshooting_build_logic"></a> <a class="link" href="#sec:troubleshooting_build_logic">调试构建逻辑</a></h4>
<div class="sect4">
<h5 id="attaching_a_debugger_to_your_build"><a class="anchor" href="#attaching_a_debugger_to_your_build"></a> <a class="link" href="#attaching_a_debugger_to_your_build">将调试器附加到构建</a></h5>
<div class="paragraph">
<p>您可以设置断点并调试<a href="#sec:packaging_a_plugin">buildSrc和独立插件</a>通过设置在摇篮构建自身<code>org.gradle.debug</code>属性设置为“ true”，然后将远程调试器附加到端口5005。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ gradle help -Dorg.gradle.debug=true</pre>
</div>
</div>
<div class="paragraph">
<p>此外，如果您采用了Kotlin DSL，则还可以自己调试构建脚本。</p>
</div>
<div class="paragraph">
<p>以下视频演示了如何使用IntelliJ IDEA调试示例构建。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/remote-debug-gradle.gif" alt="远程调试gradle">
</div>
<div class="title">图3。交互式调试构建脚本</div>
</div>
</div>
<div class="sect4">
<h5 id="adding_and_changing_logging"><a class="anchor" href="#adding_and_changing_logging"></a> <a class="link" href="#adding_and_changing_logging">添加和更改日志记录</a></h5>
<div class="paragraph">
<p>除了<a href="#sec:command_line_logging">控制日志记录的详细程度之外</a> ，您还可以控制任务结果的显示（例如，“生命周期记录中使用“ UP-TO-DATE”） <a href="#sec:command_line_customizing_log_format"><code>--console=verbose</code>标志</a></p>
</div>
<div class="paragraph">
<p>您还可以通过注册各种事件侦听器，用自己的Gradle日志记录代替许多日志记录。<a href="#sec:changing_what_gradle_logs">日志记录文档中说明</a>了一个<a href="#sec:changing_what_gradle_logs">自定义事件记录器的</a>示例。您还可以<a href="#sec:external_tools">从外部工具控制日志记录</a> ，使它们更加冗长，以便调试它们的执行。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content"><a href="#gradle_daemon">Gradle守护程序的</a>其他日志可以在下面找到<code>GRADLE_USER_HOME/daemon/<gradle-version>/</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="task_executed_when_it_should_have_been_up_to_date"><a class="anchor" href="#task_executed_when_it_should_have_been_up_to_date"></a> <a class="link" href="#task_executed_when_it_should_have_been_up_to_date">应该在UP-TO-DATE执行的任务</a></h5>
<div class="paragraph">
<p><code>--info</code>日志解释了执行任务的原因，尽管构建扫描通过转到“ <em>时间轴”</em>视图并单击要检查的任务以一种可搜索的直观方式来执行该任务。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/troubleshooting-task-execution-build-scan.png" alt="对任务执行构建扫描进行故障排除">
</div>
<div class="title">图4。使用构建扫描调试增量构建</div>
</div>
<div class="paragraph">
<p>您可以从此<a href="#sec:task_outcomes">清单中</a>了解任务结果的含义。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:troubleshooting_ide_integration"><a class="anchor" href="#sec:troubleshooting_ide_integration"></a> <a class="link" href="#sec:troubleshooting_ide_integration">调试IDE集成</a></h4>
<div class="paragraph">
<p>可以通过“刷新” Gradle解决IDE中许多不常见的错误。另请参阅有关<a href="https://www.jetbrains.com/help/idea/gradle.html">在IntelliJ IDEA</a>和<a href="http://www.vogella.com/tutorials/EclipseGradle/article.html">Eclipse中</a>使用Gradle的更多文档。</p>
</div>
<div class="sect4">
<h5 id="refreshing_intellij_idea"><a class="anchor" href="#refreshing_intellij_idea"></a> <a class="link" href="#refreshing_intellij_idea">刷新IntelliJ IDEA</a></h5>
<div class="paragraph">
<p><strong>注意：</strong>这仅适用于<a href="https://www.jetbrains.com/help/idea/gradle.html#link_gradle_project">链接到IntelliJ的</a> Gradle项目。</p>
</div>
<div class="paragraph">
<p>从主菜单转到<code>View</code> > <code>Tool Windows</code> > <code>Gradle</code> 。然后单击<em>刷新</em>图标。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/troubleshooting-refresh-intellij.png" alt="故障排除刷新IntelliJ">
</div>
<div class="title">图5。在IntelliJ IDEA中刷新Gradle项目</div>
</div>
</div>
<div class="sect4">
<h5 id="refreshing_eclipse_using_buildship"><a class="anchor" href="#refreshing_eclipse_using_buildship"></a> <a class="link" href="#refreshing_eclipse_using_buildship">刷新Eclipse（使用Buildship）</a></h5>
<div class="paragraph">
<p>如果您将<a href="https://projects.eclipse.org/projects/tools.buildship">Buildship</a>用于Eclipse IDE，则可以通过打开“ Gradle Tasks”视图并单击“ Refresh”图标，或执行以下操作来重新同步Gradle构建。 <code>Gradle</code> > <code>Refresh Gradle Project</code>编辑Gradle脚本时从上下文菜单执行命令。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/troubleshooting-refresh-eclipse.png" alt="对刷新蚀进行故障排除">
</div>
<div class="title">图6。在Eclipse Buildship中刷新Gradle项目</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getting_additional_help"><a class="anchor" href="#getting_additional_help"></a> <a class="link" href="#getting_additional_help">获得更多帮助</a></h4>
<div class="paragraph">
<p>如果您在这里没有找到解决问题的方法，请在<a href="https://discuss.gradle.org/c/help-discuss">帮助论坛</a>上与Gradle社区联系，或者使用<a href="https://help.gradle.org/">help.gradle.org</a>搜索相关的开发人员资源。</p>
</div>
<div class="paragraph">
<p>如果您认为自己在Gradle中发现了错误，请在GitHub上<a href="https://github.com/gradle/gradle/issues">提交问题</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">﻿<div class="sect1">
<h2 id="part:upgrading_and_migrating"><a class="anchor" href="#part:upgrading_and_migrating"></a> <a class="link" href="#part:upgrading_and_migrating">升级和迁移</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="upgrading_version_5"><a class="anchor" href="#upgrading_version_5"></a> <a class="link" href="#upgrading_version_5">将您的构建从Gradle 5.x升级到6.0</a></h3>
<div class="paragraph">
<p>本章提供了将Gradle 5.x构建迁移到Gradle 6.0所需的信息。要从Gradle 4.x迁移，请先完成从<a href="#upgrading_version_4">4.x到5.0的指南</a> 。</p>
</div>
<div class="paragraph">
<p>我们建议所有用户执行以下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>尝试跑步<code>gradle help --scan</code>并查看生成的构建扫描的<a href="https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality">弃用视图</a> 。</p>
<div class="imageblock">
<div class="content">
<img src="img/deprecations.png" alt="Gradle构建扫描的弃用视图">
</div>
</div>
<div class="paragraph">
<p>这样一来，您就可以看到适用于您的构建的所有弃用警告。</p>
</div>
<div class="paragraph">
<p>或者，您可以运行<code>gradle help --warning-mode=all</code>在控制台中查看弃用项，尽管它可能不会报告太多详细信息。</p>
</div>
</li>
<li>
<p>更新您的插件。</p>
<div class="paragraph">
<p>一些插件将随新版本的Gradle一起中断，例如，因为它们使用已被删除或更改的内部API。上一步将通过在插件确实尝试使用API弃用的部分时发出弃用警告来帮助您识别潜在的问题。</p>
</div>
</li>
<li>
<p>跑<code>gradle wrapper --gradle-version 6.0.1</code>将项目更新到6.0.1。</p>
</li>
<li>
<p>尝试使用《 <a href="#troubleshooting">故障排除指南》</a>运行项目并调试所有错误。</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="changes_6.0"><a class="anchor" href="#changes_6.0"></a> <a class="link" href="#changes_6.0">从5.6及更早版本升级</a></h4>
<div class="sect4">
<h5 id="deprecations"><a class="anchor" href="#deprecations"></a> <a class="link" href="#deprecations">弃用</a></h5>
<div class="sect5">
<h6 id="dependencies_should_no_longer_be_declared_using_the_compile_and_runtime_configurations"><a class="anchor" href="#dependencies_should_no_longer_be_declared_using_the_compile_and_runtime_configurations"></a> <a class="link" href="#dependencies_should_no_longer_be_declared_using_the_compile_and_runtime_configurations">依赖关系不应再使用<code>compile</code>和<code>runtime</code>构型</a></h6>
<div class="paragraph">
<p>的用法<code>compile</code>和<code>runtime</code>从<a href="https://docs.gradle.org/3.4/release-notes.html#the-java-library-plugin">Gradle 3.4</a>开始，不鼓励使用Java生态系统插件中的配置。</p>
</div>
<div class="paragraph">
<p>这些配置用于编译和运行来自<code>main</code>源集。其他来源集会创建类似的配置（例如<code>testCompile</code>和<code>testRuntime</code>为了<code>test</code>源集），也不应使用。的<code>implementation</code> ， <code>api</code> ， <code>compileOnly</code>和<code>runtimeOnly</code>配置应用于声明依赖关系，并且<code>compileClasspath</code>和<code>runtimeClasspath</code>解决依赖关系的配置。请参阅<a href="#sec:java_library_configurations_graph">这些配置的关系</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="legacy_publication_system_is_deprecated_and_replaced_with_the_publish_plugins"><a class="anchor" href="#legacy_publication_system_is_deprecated_and_replaced_with_the_publish_plugins"></a> <a class="link" href="#legacy_publication_system_is_deprecated_and_replaced_with_the_publish_plugins">旧版发布系统已弃用，并替换为<code>*-publish</code>外挂程式</a></h6>
<div class="paragraph">
<p>的<code>uploadArchives</code>任务和<code>maven</code>插件已弃用。</p>
</div>
<div class="paragraph">
<p>用户应使用以下任一方法迁移到Gradle的<a href="#">发布系统</a> ： <a href="#"><code>maven-publish</code></a>要么<a href="#"><code>ivy-publish</code></a>插件。自Gradle 4.8起，这些插件一直稳定。</p>
</div>
<div class="paragraph">
<p>发布系统也是确保<a href="#">Gradle Module元数据</a>发布的唯一方法。</p>
</div>
</div>
<div class="sect5">
<h6 id="problems_with_tasks_emit_deprecation_warnings"><a class="anchor" href="#problems_with_tasks_emit_deprecation_warnings"></a> <a class="link" href="#problems_with_tasks_emit_deprecation_warnings">任务问题会发出弃用警告</a></h6>
<div class="paragraph">
<p>当Gradle检测到任务定义问题（例如错误定义的输入或输出）时，它将在控制台上显示以下消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.0/userguide/command_line_interface.html#sec:command_line_warnings</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论使用哪种命令行开关，都将在每次构建的<a href="https://scans.gradle.com/s/txrptciitl2ha/deprecations">构建扫描中</a>显示不赞成使用的警告。</p>
</div>
<div class="paragraph">
<p>使用以下命令执行构建时<code>--warning-mode all</code> ，将显示单个警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>&gt; Task :myTask
Property 'inputDirectory' is declared without normalization specified. Properties of cacheable work must declare their normalization via @PathSensitive, @Classpath or @CompileClasspath. Defaulting to PathSensitivity.ABSOLUTE. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
Property 'outputFile' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您拥有相关任务的代码，则可以<a href="#sec:task_input_validation">按照建议</a>进行修复。您也可以使用<code>--stacktrace</code>查看每个警告在代码中的来源。</p>
</div>
<div class="paragraph">
<p>否则，您需要将问题报告给相关任务或插件的维护者。</p>
</div>
</div>
<div class="sect5">
<h6 id="old_api_for_incremental_tasks_incrementaltaskinputs_has_been_deprecated"><a class="anchor" href="#old_api_for_incremental_tasks_incrementaltaskinputs_has_been_deprecated"></a> <a class="link" href="#old_api_for_incremental_tasks_incrementaltaskinputs_has_been_deprecated">用于增量任务的旧API， <code>IncrementalTaskInputs</code> ，已弃用</a></h6>
<div class="paragraph">
<p>在Gradle 5.4中，我们引入了用于实现<a href="#incremental_tasks">增量任务</a>的新API： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html">InputChanges</a> 。基于旧API <code>IncrementalTaskInputs</code>已不推荐使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="forced_dependencies"><a class="anchor" href="#forced_dependencies"></a> <a class="link" href="#forced_dependencies">强制依赖</a></h6>
<div class="paragraph">
<p>强制使用依赖版本<code>force = true</code>不推荐使用第一层依赖项。</p>
</div>
<div class="paragraph">
<p>强制同时具有语义和顺序问题，可以通过使用<a href="#rich-version-constraints">严格的版本约束</a>来避免。</p>
</div>
</div>
<div class="sect5">
<h6 id="search_upwards_related_apis_in_startparameter_have_been_deprecated"><a class="anchor" href="#search_upwards_related_apis_in_startparameter_have_been_deprecated"></a> <a class="link" href="#search_upwards_related_apis_in_startparameter_have_been_deprecated">在中向上搜索相关的API <code>StartParameter</code>已弃用</a></h6>
<div class="paragraph">
<p>在Gradle 5.0中，我们删除了<code>--no-search-upward</code> CLI参数。</p>
</div>
<div class="paragraph">
<p>中的相关API <code>StartParameter</code> （喜欢<code>isSearchUpwards()</code> ）现已弃用。</p>
</div>
</div>
<div class="sect5">
<h6 id="apis_buildlistener_buildstarted_and_gradle_buildstarted_have_been_deprecated"><a class="anchor" href="#apis_buildlistener_buildstarted_and_gradle_buildstarted_have_been_deprecated"></a> <a class="link" href="#apis_buildlistener_buildstarted_and_gradle_buildstarted_have_been_deprecated">蜜蜂<code>BuildListener.buildStarted</code>和<code>Gradle.buildStarted</code>已弃用</a></h6>
<div class="paragraph">
<p>这些方法当前无法按预期方式工作，因为在构建开始之后将永远不会调用回调。</p>
</div>
<div class="paragraph">
<p>不建议使用该方法以避免混淆。</p>
</div>
</div>
<div class="sect5">
<h6 id="implicit_duplicate_strategy_for_copy_or_archive_tasks_has_been_deprecated"><a class="anchor" href="#implicit_duplicate_strategy_for_copy_or_archive_tasks_has_been_deprecated"></a> <a class="link" href="#implicit_duplicate_strategy_for_copy_or_archive_tasks_has_been_deprecated">隐式重复策略<code>Copy</code>或归档任务已被弃用</a></h6>
<div class="paragraph">
<p>存档任务<code>Tar</code>和<code>Zip</code>默认情况下，所创建的存档中存在相同路径的多个条目。这可能会导致<a href="https://github.com/gradle/gradle/issues/9990">“严重无效的zip文件”，从而触发zip炸弹检测</a> 。</p>
</div>
<div class="paragraph">
<p>为了防止这种情况的发生，创建存档时遇到重复会产生弃用消息，并且将使从Gradle 7.0开始的构建失败。</p>
</div>
<div class="paragraph">
<p><code>Copy</code>任务还可以愉快地将具有相同相对路径的多个源复制到目标目录。此行为也已被弃用。</p>
</div>
<div class="paragraph">
<p>如果要允许重复，则可以明确指定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>task archive(type: Zip) {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE // allow duplicates
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="executing_gradle_without_a_settings_file_has_been_deprecated"><a class="anchor" href="#executing_gradle_without_a_settings_file_has_been_deprecated"></a> <a class="link" href="#executing_gradle_without_a_settings_file_has_been_deprecated">在不使用设置文件的情况下执行Gradle已被弃用</a></h6>
<div class="paragraph">
<p>Gradle构建由<code>settings.gradle[.kts]</code>文件在当前目录或父目录中。没有设置文件，Gradle构建是未定义的，并且将发出弃用警告。</p>
</div>
<div class="paragraph">
<p>在Gradle 7.0中，Gradle仅允许您调用<code>init</code>任务或诊断命令行标志，例如<code>--version</code> ，具有未定义的版本。</p>
</div>
</div>
<div class="sect5">
<h6 id="calling_project_afterevaluate_on_an_evaluated_project_has_been_deprecated"><a class="anchor" href="#calling_project_afterevaluate_on_an_evaluated_project_has_been_deprecated"></a> <a class="link" href="#calling_project_afterevaluate_on_an_evaluated_project_has_been_deprecated">呼唤<code>Project.afterEvaluate</code>在评估项目上已被弃用</a></h6>
<div class="paragraph">
<p>评估项目后，Gradle会忽略传递给的所有配置<code>Project#afterEvaluate</code>并发出弃用警告。这种情况将成为Gradle 7.0中的错误。</p>
</div>
</div>
<div class="sect5">
<h6 id="deprecated_plugins"><a class="anchor" href="#deprecated_plugins"></a> <a class="link" href="#deprecated_plugins">不推荐使用的插件</a></h6>
<div class="paragraph">
<p>以下捆绑插件从未发布过，将在Gradle的下一个主要版本中删除：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.coffeescript-base</code></p>
</li>
<li>
<p><code>org.gradle.envjs</code></p>
</li>
<li>
<p><code>org.gradle.javascript-base</code></p>
</li>
<li>
<p><code>org.gradle.jshint</code></p>
</li>
<li>
<p><code>org.gradle.rhino</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其中一些插件可能会在<a href="https://plugins.gradle.org/">插件门户</a>上进行替换。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes"><a class="anchor" href="#potential_breaking_changes"></a> <a class="link" href="#potential_breaking_changes">潜在的重大变化</a></h5>
<div class="sect5">
<h6 id="android_gradle_plugin_3_3_and_earlier_is_no_longer_supported"><a class="anchor" href="#android_gradle_plugin_3_3_and_earlier_is_no_longer_supported"></a> <a class="link" href="#android_gradle_plugin_3_3_and_earlier_is_no_longer_supported">不再支持Android Gradle Plugin 3.3和更早版本</a></h6>
<div class="paragraph">
<p>Gradle 6.0支持Android Gradle插件版本3.4及更高版本。</p>
</div>
</div>
<div class="sect5">
<h6 id="build_scan_plugin_2_x_is_no_longer_supported"><a class="anchor" href="#build_scan_plugin_2_x_is_no_longer_supported"></a> <a class="link" href="#build_scan_plugin_2_x_is_no_longer_supported">不再支持构建扫描插件2.x</a></h6>
<div class="paragraph">
<p>对于Gradle 6，必须使用Gradle Enterprise插件代替对构建扫描插件的使用。这还需要更改插件的应用方式。有关更多信息，请参阅<a href="https://gradle.com/help/gradle-6-build-scan-plugin" class="bare">https://gradle.com/help/gradle-6-build-scan-plugin</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="updates_to_bundled_gradle_dependencies"><a class="anchor" href="#updates_to_bundled_gradle_dependencies"></a> <a class="link" href="#updates_to_bundled_gradle_dependencies">更新捆绑的Gradle依赖项</a></h6>
<div class="ulist">
<ul>
<li>
<p>Groovy已更新为<a href="http://groovy-lang.org/changelogs/changelog-2.5.8.html">Groovy 2.5.8</a> 。</p>
</li>
<li>
<p>Kotlin已更新至<a href="https://blog.jetbrains.com/kotlin/2019/08/kotlin-1-3-50-released/">Kotlin 1.3.50</a> 。</p>
</li>
<li>
<p>Ant已更新为<a href="https://archive.apache.org/dist/ant/RELEASE-NOTES-1.10.7.html">Ant 1.10.7</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="updates_to_default_integration_versions"><a class="anchor" href="#updates_to_default_integration_versions"></a> <a class="link" href="#updates_to_default_integration_versions">更新为默认集成版本</a></h6>
<div class="ulist">
<ul>
<li>
<p>Checkstyle已更新为<a href="https://checkstyle.org/releasenotes.html#Release_8.24">Checkstyle 8.24</a> 。</p>
</li>
<li>
<p>CodeNarc已更新为<a href="https://github.com/CodeNarc/CodeNarc/blob/master/CHANGELOG.md#version-14---may-2019">CodeNarc 1.4</a> 。</p>
</li>
<li>
<p>PMD已更新至<a href="https://pmd.github.io/latest/pmd_release_notes.html#28-july-2019---6170">PMD 6.17.0</a> 。</p>
</li>
<li>
<p>JaCoCo已更新至<a href="http://www.jacoco.org/jacoco/trunk/doc/changes.html">0.8.5</a> 。由<a href="https://github.com/Godin">Evgeny Mandrikov</a>贡献</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_build_and_task_names_in_composite_builds"><a class="anchor" href="#changes_to_build_and_task_names_in_composite_builds"></a> <a class="link" href="#changes_to_build_and_task_names_in_composite_builds">复合构建中对构建和任务名称的更改</a></h6>
<div class="paragraph">
<p>以前，Gradle使用根项目的名称作为所包含构建的构建名称。现在，使用构建的根目录名称，并且如果不相同，则不考虑根项目名称。如果通过设置文件包含构建，则可以为构建指定其他名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">includeBuild(&quot;some-other-build&quot;) {
    name = &quot;another-name&quot;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>先前的行为是有问题的，因为它导致在构建期间的不同时间使用不同的名称。</p>
</div>
</div>
<div class="sect5">
<h6 id="buildsrc_is_now_reserved_as_a_project_and_subproject_build_name"><a class="anchor" href="#buildsrc_is_now_reserved_as_a_project_and_subproject_build_name"></a> <a class="link" href="#buildsrc_is_now_reserved_as_a_project_and_subproject_build_name">现在，将buildSrc保留为项目和子项目的构建名称</a></h6>
<div class="paragraph">
<p>以前，Gradle并未阻止将名称“ buildSrc”用于多项目构建的子项目或作为包含的构建的名称。现在，这是不允许的。现在，名称“ buildSrc”保留给常规的buildSrc项目，该项目用于构建额外的构建逻辑。</p>
</div>
<div class="paragraph">
<p>buildSrc的典型用法不受此更改的影响。仅当您的设置文件指定时，您才会受到影响<code>include("buildSrc")</code>要么<code>includeBuild("buildSrc")</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="scala_zinc_compiler"><a class="anchor" href="#scala_zinc_compiler"></a> <a class="link" href="#scala_zinc_compiler">Scala Zinc编译器</a></h6>
<div class="paragraph">
<p>Zinc编译器已升级到版本1.3.0。Gradle不再支持为Scala 2.9构建。</p>
</div>
<div class="paragraph">
<p>Gradle支持的最小Zinc编译器为1.2.0，最大测试版本为1.3.0。</p>
</div>
<div class="paragraph">
<p>为了更轻松地选择Zinc编译器的版本，您现在可以配置一个<code>zincVersion</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>scala {
    zincVersion = "1.2.1"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请删除您添加到<code>zinc</code>配置并使用此属性。如果您尝试使用<code>com.typesafe.zinc:zinc</code>依赖，Gradle将切换到新的Zinc实现。</p>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_build_cache"><a class="anchor" href="#changes_to_build_cache"></a> <a class="link" href="#changes_to_build_cache">对构建缓存的更改</a></h6>

</div>
<div class="sect5">
<h6 id="local_build_cache_is_always_a_directory_cache"><a class="anchor" href="#local_build_cache_is_always_a_directory_cache"></a> <a class="link" href="#local_build_cache_is_always_a_directory_cache">本地构建缓存始终是目录缓存</a></h6>
<div class="paragraph">
<p>过去，可以将任何构建缓存实现用作<code>local</code>缓存。不再允许这样做，因为本地缓存必须始终是<code>DirectoryBuildCache</code> 。</p>
</div>
<div class="paragraph">
<p>致电<code>BuildCacheConfiguration.local(Class)</code>除了<code>DirectoryBuildCache</code>因为该类型将使构建失败。用<code>DirectoryBuildCache</code>类型将产生弃用警告。</p>
</div>
<div class="paragraph">
<p>使用<code>getLocal()</code>和<code>local(Action)</code>代替。</p>
</div>
</div>
<div class="sect5">
<h6 id="failing_to_pack_or_unpack_cached_results_will_now_fail_the_build"><a class="anchor" href="#failing_to_pack_or_unpack_cached_results_will_now_fail_the_build"></a> <a class="link" href="#failing_to_pack_or_unpack_cached_results_will_now_fail_the_build">无法打包或解包缓存结果现在将使构建失败</a></h6>
<div class="paragraph">
<p>过去，当Gradle在打包缓存任务的结果时遇到问题时，Gradle会忽略该问题并继续运行构建。</p>
</div>
<div class="paragraph">
<p>当遇到损坏的缓存工件时，Gradle会删除已解包的所有内容，然后重新执行任务以确保构建有成功的机会。</p>
</div>
<div class="paragraph">
<p>尽管此行为旨在使构建成功，但会产生隐藏问题的不利影响，并导致缓存性能下降。</p>
</div>
<div class="paragraph">
<p>在Gradle 6.0中，打包和解包错误都将导致构建失败，因此这些问题将更容易得到解决。</p>
</div>
</div>
<div class="sect5">
<h6 id="buildsrc_projects_automatically_use_build_cache_configuration"><a class="anchor" href="#buildsrc_projects_automatically_use_build_cache_configuration"></a> <a class="link" href="#buildsrc_projects_automatically_use_build_cache_configuration">buildSrc项目自动使用构建缓存配置</a></h6>
<div class="paragraph">
<p>以前，为了将构建缓存用于buildSrc构建，您需要在buildSrc构建中复制构建缓存配置。现在，它会自动使用顶级设置脚本定义的构建缓存配置。</p>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_dependency_management"><a class="anchor" href="#changes_to_dependency_management"></a> <a class="link" href="#changes_to_dependency_management">依赖管理的变化</a></h6>

</div>
<div class="sect5">
<h6 id="gradle_module_metadata_is_always_published"><a class="anchor" href="#gradle_module_metadata_is_always_published"></a> <a class="link" href="#gradle_module_metadata_is_always_published">Gradle模块元数据总是发布</a></h6>
<div class="paragraph">
<p><a href="https://blog.gradle.org/gradle-metadata-1.0">Gradle模块元数据</a>在Gradle 5.3中正式引入，它的创建是为了解决多年来困扰依赖管理的许多问题，特别是但不限于Java生态系统。</p>
</div>
<div class="paragraph">
<p>在Gradle 6.0中，默认情况下启用了Gradle模块元数据。</p>
</div>
<div class="paragraph">
<p>这意味着，如果使用Gradle发布库并使用<a href="#">maven-publish</a>或<a href="#">ivy-publish</a>插件，则<strong>除</strong>传统元数据<strong>外，还将</strong>始终发布Gradle Module元数据文件。</p>
</div>
<div class="paragraph">
<p>传统的元数据文件将包含一个标记，以便Gradle知道还有其他元数据要使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="gradle_module_metadata_has_stricter_validation"><a class="anchor" href="#gradle_module_metadata_has_stricter_validation"></a> <a class="link" href="#gradle_module_metadata_has_stricter_validation">Gradle模块元数据具有更严格的验证</a></h6>
<div class="paragraph">
<p>发布Gradle模块元数据时，将验证以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>变体名称必须唯一，</p>
</li>
<li>
<p>每个变体必须至少具有<a href="#">一个属性</a> ，</p>
</li>
<li>
<p>两个变体不能具有<a href="#">完全相同的属性和功能</a> ，</p>
</li>
<li>
<p>如果存在依赖关系，则所有变体中的至少一个必须包含<a href="#">版本信息</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些也记录在<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">规范</a>中。</p>
</div>
</div>
<div class="sect5">
<h6 id="maven_or_ivy_repositories_are_no_longer_queried_for_artifacts_without_metadata_by_default"><a class="anchor" href="#maven_or_ivy_repositories_are_no_longer_queried_for_artifacts_without_metadata_by_default"></a> <a class="link" href="#maven_or_ivy_repositories_are_no_longer_queried_for_artifacts_without_metadata_by_default">默认情况下，不再向Maven或Ivy存储库查询没有元数据的工件</a></h6>
<div class="paragraph">
<p>如果Gradle无法找到元数据文件（ <code>.pom</code>要么<code>ivy.xml</code> ）中定义的存储库中的模块<code>repositories { }</code>部分，现在假定该模块在该存储库中不存在。</p>
</div>
<div class="paragraph">
<p>对于动态版本， <code>maven-metadata.xml</code> Maven存储库中需要包含相应模块的代码。</p>
</div>
<div class="paragraph">
<p>以前，Gradle还会查找默认工件（ <code>.jar</code> ）。使用多个存储库会使构建速度变慢时，此行为通常会导致大量不必要的请求。</p>
</div>
<div class="paragraph">
<p>您可以通过添加以下内容来选择选定存储库的旧行为<code>artifact()</code> <a href="#sec:supported_metadata_sources">元数据源</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="changing_the_pom_packaging_property_no_longer_changes_the_artifact_extension"><a class="anchor" href="#changing_the_pom_packaging_property_no_longer_changes_the_artifact_extension"></a> <a class="link" href="#changing_the_pom_packaging_property_no_longer_changes_the_artifact_extension">更换绒球<code>packaging</code>属性不再更改工件扩展</a></h6>
<div class="paragraph">
<p>以前，如果pom包装不是<em>jar</em> ， <em>ejb</em> ， <em>bundle</em>或<em>maven-plugin</em> ，则在发布期间会更改发布到Maven存储库的主要工件的扩展名，以匹配pom包装。</p>
</div>
<div class="paragraph">
<p>此行为导致Gradle Module元数据损坏，并且由于处理不同的包装类型而难以理解。</p>
</div>
<div class="paragraph">
<p>创建工件时，构建作者可以更改工件名称，以获得与以前相同的结果-例如，通过设置<code>jar.archiveExtension.set(pomPackaging)</code>明确地。</p>
</div>
</div>
<div class="sect5">
<h6 id="an_ivy_xml_published_for_java_libraries_contains_more_information"><a class="anchor" href="#an_ivy_xml_published_for_java_libraries_contains_more_information"></a> <a class="link" href="#an_ivy_xml_published_for_java_libraries_contains_more_information">一个<code>ivy.xml</code>为Java库发布的出版物包含更多信息</a></h6>
<div class="paragraph">
<p>进行了一些修复，以产生更正确的结果<code>ivy.xml</code>中的元数据<code>ivy-publish</code>插入。</p>
</div>
<div class="paragraph">
<p>结果，内部结构<code>ivy.xml</code>文件已更改。的<code>runtime</code>配置现在包含更多信息，与Java库的<em>runtimeElements</em>变体相对应。的<code>default</code>配置应产生与以前相同的结果。</p>
</div>
<div class="paragraph">
<p>通常，建议用户从<code>ivy.xml</code>到新的Gradle Module元数据格式。</p>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_plugins_and_build_scripts"><a class="anchor" href="#changes_to_plugins_and_build_scripts"></a> <a class="link" href="#changes_to_plugins_and_build_scripts">插件和构建脚本的更改</a></h6>

</div>
<div class="sect5">
<h6 id="classes_from_buildsrc_are_no_longer_visible_to_settings_scripts"><a class="anchor" href="#classes_from_buildsrc_are_no_longer_visible_to_settings_scripts"></a> <a class="link" href="#classes_from_buildsrc_are_no_longer_visible_to_settings_scripts">来自的课程<code>buildSrc</code>设置脚本不再可见</a></h6>
<div class="paragraph">
<p>以前，buildSrc项目是在应用项目的设置脚本之前构建的，并且其类在脚本中可见。现在，在设置脚本及其类对它不可见之后，将构建buildSrc。buildSrc类对于项目构建脚本和脚本插件仍然可见。</p>
</div>
<div class="paragraph">
<p>可以通过<a href="#sec:build_script_external_dependencies">声明外部依赖项</a>从设置脚本中使用自定义逻辑。</p>
</div>
</div>
<div class="sect5">
<h6 id="the_pluginmanagement_block_in_settings_scripts_is_now_isolated"><a class="anchor" href="#the_pluginmanagement_block_in_settings_scripts_is_now_isolated"></a> <a class="link" href="#the_pluginmanagement_block_in_settings_scripts_is_now_isolated">的<code>pluginManagement</code>现在隔离了设置脚本中的阻止</a></h6>
<div class="paragraph">
<p>以前，任何<code>pluginManagement {}</code>设置脚本中的块是在脚本的正常执行期间执行的。</p>
</div>
<div class="paragraph">
<p>现在，它们以与<code>buildscript {}</code>要么<code>plugins {}</code> 。这意味着该块中的代码无法引用脚本中其他地方声明的任何内容。</p>
</div>
<div class="paragraph">
<p>进行了此更改，以便<code>pluginManagement</code>解决设置脚本本身的插件时，也可以应用配置。</p>
</div>
</div>
<div class="sect5">
<h6 id="plugins_and_classes_loaded_in_settings_scripts_are_visible_to_project_scripts_and_buildsrc"><a class="anchor" href="#plugins_and_classes_loaded_in_settings_scripts_are_visible_to_project_scripts_and_buildsrc"></a> <a class="link" href="#plugins_and_classes_loaded_in_settings_scripts_are_visible_to_project_scripts_and_buildsrc">设置脚本中加载的插件和类对项目脚本可见，并且<code>buildSrc</code></a></h6>
<div class="paragraph">
<p>以前，通过使用<code>buildscript {}</code>在脚本之外不可见。现在，它们对于所有项目构建脚本都是可见的。</p>
</div>
<div class="paragraph">
<p>它们也对<code>buildSrc</code>构建脚本及其设置脚本。</p>
</div>
<div class="paragraph">
<p>进行了此更改，以便应用于设置脚本的插件可以为整个构建贡献逻辑。</p>
</div>
</div>
<div class="sect5">
<h6 id="plugin_validation_changes"><a class="anchor" href="#plugin_validation_changes"></a> <a class="link" href="#plugin_validation_changes">插件验证更改</a></h6>
<div class="ulist">
<ul>
<li>
<p>的<code>validateTaskProperties</code>现在不推荐使用任务，使用<code>validatePlugins</code>代替。新名称更好地反映了以下事实：它还可以验证工件转换参数和其他非财产定义。</p>
</li>
<li>
<p>的<code>ValidateTaskProperties</code>类型替换为<code>ValidatePlugins</code> 。</p>
</li>
<li>
<p>的<code>setClasses()</code>方法已删除。使用<code>getClasses().setFrom()</code>代替。</p>
</li>
<li>
<p>的<code>setClasspath()</code>方法也被删除。使用<code>getClasspath().setFrom()</code>代替。</p>
</li>
<li>
<p>默认情况下，现在已启用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/devel/tasks/ValidatePlugins.html#getFailOnWarning--">failOnWarning</a>选项。</p>
</li>
<li>
<p>现在，以下任务验证错误会在运行时使构建失败，并会升级为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/devel/tasks/ValidatePlugins.html">ValidatePlugins的</a>错误：</p>
<div class="ulist">
<ul>
<li>
<p>任务属性带有不允许用于任务的属性注释，例如<code>@InputArtifact</code> 。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_kotlin_dsl"><a class="anchor" href="#changes_to_kotlin_dsl"></a> <a class="link" href="#changes_to_kotlin_dsl">对Kotlin DSL的更改</a></h6>

</div>
<div class="sect5">
<h6 id="using_the_embedded_kotlin_plugin_now_requires_a_repository"><a class="anchor" href="#using_the_embedded_kotlin_plugin_now_requires_a_repository"></a> <a class="link" href="#using_the_embedded_kotlin_plugin_now_requires_a_repository">使用<code>embedded-kotlin</code>插件现在需要一个存储库</a></h6>
<div class="paragraph">
<p>就像使用<code>kotlin-dsl</code>插件，现在需要声明一个存储库，如果您应用该存储库，可以在其中找到Kotlin依赖项<code>embedded-kotlin</code>插入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `embedded-kotlin`
}

repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="kotlin_dsl_ide_support_now_requires_kotlin_intellij_plugin_1_3_50"><a class="anchor" href="#kotlin_dsl_ide_support_now_requires_kotlin_intellij_plugin_1_3_50"></a> <a class="link" href="#kotlin_dsl_ide_support_now_requires_kotlin_intellij_plugin_1_3_50">Kotlin DSL IDE支持现在需要> = 1.3.50的Kotlin IntelliJ插件</a></h6>
<div class="paragraph">
<p>对于1.3.50之前的Kotlin IntelliJ插件版本，当<em>Gradle JVM</em>设置为不同于<em>Project SDK中</em>的版本时，将错误地突出显示Kotlin DSL脚本。只需将您的IDE插件升级到> = 1.3.50，即可恢复正确的Kotlin DSL脚本突出显示行为。</p>
</div>
</div>
<div class="sect5">
<h6 id="kotlin_dsl_script_base_types_no_longer_extend_project_settings_or_gradle"><a class="anchor" href="#kotlin_dsl_script_base_types_no_longer_extend_project_settings_or_gradle"></a> <a class="link" href="#kotlin_dsl_script_base_types_no_longer_extend_project_settings_or_gradle">Kotlin DSL脚本基础类型不再扩展<code>Project</code> ， <code>Settings</code>要么<code>Gradle</code></a></h6>
<div class="paragraph">
<p>在以前的版本中，Kotlin DSL脚本被编译为实现三个Gradle核心配置接口之一的类，以便向脚本隐式公开其API。 <code>org.gradle.api.Project</code>对于项目脚本， <code>org.gradle.api.initialization.Settings</code>用于设置脚本和<code>org.gradle.api.invocation.Gradle</code>用于初始化脚本。</p>
</div>
<div class="paragraph">
<p>让脚本实例实现应该配置的模型对象的核心Gradle接口很方便，因为它使模型对象API立即可用于脚本主体，但这也是一个谎言，每当脚本实例出现时，都可能引起各种麻烦。脚本本身代替模型对象的使用，工程脚本<strong>不</strong>正确的<code>Project</code>实例只是因为它实现了核心<code>Project</code>界面，设置和初始化脚本也是如此。</p>
</div>
<div class="paragraph">
<p>在6.0中，所有Kotlin DSL脚本均编译为实现新引入的类的类<code>org.gradle.kotlin.dsl.KotlinScript</code>接口和相应的模型对象现在可以作为脚本主体中的<em>隐式接收器</em>使用。换句话说，项目脚本的行为就像脚本的主体包含在<code>with(project) { …​ }</code>块，一个设置脚本，好像脚本的主体包含在一个<code>with(settings) { …​ }</code>块和一个初始化脚本，好像脚本的主体包含在一个<code>with(gradle) { …​ }</code>块。这意味着相应的模型对象也可以作为脚本主体中的属性使用， <code>project</code>项目脚本的属性， <code>settings</code>设置脚本和<code>gradle</code>初始化脚本的属性。</p>
</div>
<div class="paragraph">
<p>作为更改的一部分， <code>SettingsScriptApi</code>界面不再由设置脚本和<code>InitScriptApi</code>接口不再由初始化脚本实现。应该将它们替换为相应的模型对象接口， <code>Settings</code>和<code>Gradle</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="miscellaneous"><a class="anchor" href="#miscellaneous"></a> <a class="link" href="#miscellaneous">杂</a></h6>

</div>
<div class="sect5">
<h6 id="javadoc_and_groovydoc_dont_include_timestamps_by_default"><a class="anchor" href="#javadoc_and_groovydoc_dont_include_timestamps_by_default"></a> <a class="link" href="#javadoc_and_groovydoc_dont_include_timestamps_by_default">Javadoc和Groovydoc默认不包含时间戳</a></h6>
<div class="paragraph">
<p>生成的文档中的时间戳实际使用非常有限，但是，它们使得无法构建可重复的文档。因此， <code>Javadoc</code>和<code>Groovydoc</code>现在，任务已配置为在默认情况下不再包含时间戳。</p>
</div>
</div>
<div class="sect5">
<h6 id="user_provided_config_loc_properties_are_ignored_by_checkstyle"><a class="anchor" href="#user_provided_config_loc_properties_are_ignored_by_checkstyle"></a> <a class="link" href="#user_provided_config_loc_properties_are_ignored_by_checkstyle">用户提供的'config_loc'属性被Checkstyle忽略</a></h6>
<div class="paragraph">
<p>Gradle始终使用<code>configDirectory</code>作为运行Checkstyle时'config_loc'的值。</p>
</div>
</div>
<div class="sect5">
<h6 id="new_tooling_api_progress_event"><a class="anchor" href="#new_tooling_api_progress_event"></a> <a class="link" href="#new_tooling_api_progress_event">新的Tooling API进度事件</a></h6>
<div class="paragraph">
<p>在Gradle 6.0中，我们引入了一个新的progress事件（ <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/tooling/events/test/TestOutputEvent.html">org.gradle.tooling.events.test.TestOutputEvent</a> ），以公开测试执行的输出。此新事件违反了具有<code>StartEvent</code> -- <code>FinisEvent</code>对表示进展。 <code>TaskOutputEvent</code>很简单<code>ProgressEvent</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_the_task_container_behavior"><a class="anchor" href="#changes_to_the_task_container_behavior"></a> <a class="link" href="#changes_to_the_task_container_behavior">任务容器行为的更改</a></h6>
<div class="paragraph">
<p>现在，任务容器上的以下不推荐使用的方法会导致错误：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TaskContainer.add()</code></p>
</li>
<li>
<p><code>TaskContainer.addAll()</code></p>
</li>
<li>
<p><code>TaskContainer.remove()</code></p>
</li>
<li>
<p><code>TaskContainer.removeAll()</code></p>
</li>
<li>
<p><code>TaskContainer.retainAll()</code></p>
</li>
<li>
<p><code>TaskContainer.clear()</code></p>
</li>
<li>
<p><code>TaskContainer.iterator().remove()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，以下不推荐使用的功能现在会导致错误：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>替换已经实现的任务。</p>
</li>
<li>
<p>用不兼容的类型替换已注册（未实现）的任务。兼容类型是注册类型的相同类型或子类型。</p>
</li>
<li>
<p>替换从未注册的任务。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="replaced_and_removed_apis"><a class="anchor" href="#replaced_and_removed_apis"></a> <a class="link" href="#replaced_and_removed_apis">替换和删除的API</a></h6>

</div>
<div class="sect5">
<h6 id="methods_on_defaulttask_and_projectlayout_replaced_with_objectfactory"><a class="anchor" href="#methods_on_defaulttask_and_projectlayout_replaced_with_objectfactory"></a> <a class="link" href="#methods_on_defaulttask_and_projectlayout_replaced_with_objectfactory">方法论<code>DefaultTask</code>和<code>ProjectLayout</code>替换为<code>ObjectFactory</code></a></h6>
<div class="paragraph">
<p>使用<code>ObjectFactory.fileProperty()</code>而不是现在删除的以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DefaultTask.newInputFile()</code></p>
</li>
<li>
<p><code>DefaultTask.newOutputFile()</code></p>
</li>
<li>
<p><code>ProjectLayout.fileProperty()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用<code>ObjectFactory.directoryProperty()</code>而不是现在删除的以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DefaultTask.newInputDirectory()</code></p>
</li>
<li>
<p><code>DefaultTask.newOutputDirectory()</code></p>
</li>
<li>
<p><code>ProjectLayout.directoryProperty()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="annotation_nullable_has_been_removed"><a class="anchor" href="#annotation_nullable_has_been_removed"></a> <a class="link" href="#annotation_nullable_has_been_removed">注解<code>@Nullable</code>已被删除</a></h6>
<div class="paragraph">
<p>的<code>org.gradle.api.Nullable</code>注释类型已被删除。使用<code>javax.annotation.Nullable</code>从JSR-305代替。</p>
</div>
</div>
<div class="sect5">
<h6 id="the_findbugs_plugin_has_been_removed"><a class="anchor" href="#the_findbugs_plugin_has_been_removed"></a> <a class="link" href="#the_findbugs_plugin_has_been_removed">FindBugs插件已被删除</a></h6>
<div class="paragraph">
<p>不推荐使用的FindBugs插件已被删除。或者，您可以使用<a href="https://plugins.gradle.org/search?term=spotbugs">Gradle插件门户中</a>的<a href="https://plugins.gradle.org/plugin/com.github.spotbugs">SpotBugs插件</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="the_jdepend_plugin_has_been_removed"><a class="anchor" href="#the_jdepend_plugin_has_been_removed"></a> <a class="link" href="#the_jdepend_plugin_has_been_removed">JDepend插件已被删除</a></h6>
<div class="paragraph">
<p>不推荐使用的JDepend插件已被删除。<a href="https://plugins.gradle.org">Gradle插件门户</a>上有许多社区提供的用于代码和体系结构分析的<a href="https://plugins.gradle.org">插件</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="the_osgi_plugin_has_been_removed"><a class="anchor" href="#the_osgi_plugin_has_been_removed"></a> <a class="link" href="#the_osgi_plugin_has_been_removed">OSGI插件已被删除</a></h6>
<div class="paragraph">
<p>不推荐使用的OSGI插件已被删除。<a href="https://plugins.gradle.org/search?term=osgi">Gradle插件门户</a>上有许多社区提供的OSGI插件。</p>
</div>
</div>
<div class="sect5">
<h6 id="the_announce_and_build_announcements_plugins_have_been_removed"><a class="anchor" href="#the_announce_and_build_announcements_plugins_have_been_removed"></a> <a class="link" href="#the_announce_and_build_announcements_plugins_have_been_removed">公告和构建公告插件已被删除</a></h6>
<div class="paragraph">
<p>不推荐使用的announce和build-announcements插件已被删除。<a href="https://plugins.gradle.org">Gradle插件门户</a>上有许多社区提供的用于发送通知的<a href="https://plugins.gradle.org">插件</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="the_compare_gradle_builds_plugin_has_been_removed"><a class="anchor" href="#the_compare_gradle_builds_plugin_has_been_removed"></a> <a class="link" href="#the_compare_gradle_builds_plugin_has_been_removed">比较Gradle构建插件已被删除</a></h6>
<div class="paragraph">
<p>不推荐使用的Compare Gradle Builds插件已被删除。请使用<a href="https://scans.gradle.com/">构建扫描</a>进行构建分析和比较。</p>
</div>
</div>
<div class="sect5">
<h6 id="the_play_plugins_have_been_removed"><a class="anchor" href="#the_play_plugins_have_been_removed"></a> <a class="link" href="#the_play_plugins_have_been_removed">Play插件已被删除</a></h6>
<div class="paragraph">
<p>不推荐使用的Play插件已被删除。可从插件门户网站获得外部替代品<a href="https://gradle.github.io/playframework">Play Framework插件</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="method_abstractcompile_compile_method_has_been_removed"><a class="anchor" href="#method_abstractcompile_compile_method_has_been_removed"></a> <a class="link" href="#method_abstractcompile_compile_method_has_been_removed">方法<code>AbstractCompile.compile()</code>方法已删除</a></h6>
<div class="paragraph">
<p>抽象方法<code>compile()</code>不再由声明<code>AbstractCompile</code> 。</p>
</div>
<div class="paragraph">
<p>任务扩展<code>AbstractCompile</code>可以自己实施<code>@TaskAction</code>方法及其选择的名称。</p>
</div>
<div class="paragraph">
<p>他们还可以自由添加带有注释的方法<code>@TaskAction</code>使用<code>InputChanges</code>参数，而不必实现一个无参数的参数。</p>
</div>
</div>
<div class="sect5">
<h6 id="other_deprecated_behaviors_and_apis"><a class="anchor" href="#other_deprecated_behaviors_and_apis"></a> <a class="link" href="#other_deprecated_behaviors_and_apis">其他不建议使用的行为和API</a></h6>
<div class="ulist">
<ul>
<li>
<p>的<code>org.gradle.util.GUtil.savePropertiesNoDateComment</code>已被删除。此内部方法没有公共替代方法。</p>
</li>
<li>
<p>不推荐使用的课程<code>org.gradle.api.tasks.compile.CompilerArgumentProvider</code>已被删除。使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/process/CommandLineArgumentProvider.html">org.gradle.process。改为使用CommandLineArgumentProvider</a> 。</p>
</li>
<li>
<p>不推荐使用的课程<code>org.gradle.api.ConventionProperty</code>已被删除。使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供程序</a>而不是约定属性。</p>
</li>
<li>
<p>不推荐使用的课程<code>org.gradle.reporting.DurationFormatter</code>已被删除。</p>
</li>
<li>
<p>桥接方法<code>org.gradle.api.tasks.TaskInputs.property(String name, @Nullable Object value)</code>返回<code>TaskInputs</code>已被删除。使用该方法的插件必须与Gradle 4.3一起编译才能在Gradle 6.0上运行。</p>
</li>
<li>
<p>以下二传手已被从<code>JacocoReportBase</code> ：</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html#org.gradle.testing.jacoco.tasks.JacocoReport:executionData">executionData-</a>使用<code>getExecutionData().setFrom()</code>代替。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html#org.gradle.testing.jacoco.tasks.JacocoReport:sourceDirectories">sourceDirectories-</a>使用<code>getSourceDirectories().setFrom()</code>代替。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html#org.gradle.testing.jacoco.tasks.JacocoReport:classDirectories">classDirectories-</a>使用<code>getClassDirectories().setFrom()</code>代替。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html#org.gradle.testing.jacoco.tasks.JacocoReport:additionalClassDirs">AdditionalClassDirs-</a>使用<code>getAdditionalClassDirs().setFrom()</code>代替。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html#org.gradle.testing.jacoco.tasks.JacocoReport:additionalSourceDirs">AdditionalSourceDirs-</a>使用<code>getAdditionalSourceDirs().setFrom()</code>代替。</p>
</li>
</ul>
</div>
</li>
<li>
<p>的<code>append</code>财产<code>JacocoTaskExtension</code>已被删除。
<code>append</code>现在对于Jacoco代理始终配置为true。</p>
</li>
<li>
<p>的<code>configureDefaultOutputPathForJacocoMerge</code>方法开启<code>JacocoPlugin</code>已被删除。该方法从未打算公开。</p>
</li>
<li>
<p>耳插件的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ear/descriptor/DeploymentDescriptor.html#getFileName--">部署描述符文件名</a>中的文件路径不再被允许。使用简单的名称，例如<code>application.xml</code> ，而不是。</p>
</li>
<li>
<p>的<code>org.gradle.testfixtures.ProjectBuilder</code>构造函数已被删除。请用<code>ProjectBuilder.builder()</code>代替。</p>
</li>
<li>
<p>启用<a href="#sec:incremental_groovy_compilation">增量Groovy编译后</a> ，错误的源根配置或为Groovy启用Java注释现在使构建失败。在这些情况下要进行编译时，请禁用增量Groovy编译。</p>
</li>
<li>
<p><code>ComponentSelectionRule</code>不再可以注入元数据或常春藤描述符。使用上的方法<a href="#sec:component_selection_rules"><code>ComponentSelection</code>参数</a>代替。</p>
</li>
<li>
<p>现在，在不声明输出的情况下声明<a href="#incremental_tasks">增量任务</a>是一个错误。声明文件输出或改用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-groovy.lang.Closure-">TaskOutputs.upToDateWhen（）</a> 。</p>
</li>
<li>
<p>的<code>getEffectiveAnnotationProcessorPath()</code>方法已从中删除<code>JavaCompile</code>和<code>ScalaCompile</code>任务。</p>
</li>
<li>
<p>使用类型更改任务属性的值<code>Property<T></code>任务开始执行后，现在会导致错误。</p>
</li>
<li>
<p>的<code>isLegacyLayout()</code>方法已从中删除<code>SourceSetOutput</code> 。</p>
</li>
<li>
<p>地图返回者<code>TaskInputs.getProperties()</code>现在无法修改。尝试修改它会导致<code>UnsupportedOperationException</code>被抛出。</p>
</li>
<li>
<p>在5.6中引入的孵化<a href="#sub:selecting-between-candidates">功能解析</a> API进行了细微更改，以允许基于变体名称进行变体选择</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_5.6"><a class="anchor" href="#changes_5.6"></a> <a class="link" href="#changes_5.6">从5.5或更早版本升级</a></h4>
<div class="sect4">
<h5 id="deprecations_2"><a class="anchor" href="#deprecations_2"></a> <a class="link" href="#deprecations_2">弃用</a></h5>
<div class="sect5">
<h6 id="changing_the_contents_of_configurablefilecollection_task_properties_after_task_starts_execution"><a class="anchor" href="#changing_the_contents_of_configurablefilecollection_task_properties_after_task_starts_execution"></a> <a class="link" href="#changing_the_contents_of_configurablefilecollection_task_properties_after_task_starts_execution">更改内容<code>ConfigurableFileCollection</code>任务开始执行后的任务属性</a></h6>
<div class="paragraph">
<p>当任务属性具有类型时<code>ConfigurableFileCollection</code> ，则一旦任务开始执行，该属性引用的文件集合将忽略对该集合内容所做的更改。这有两个好处。首先，这可以防止在任务执行期间意外更改属性值，这可能导致Gradle进行最新检查并使用与任务操作使用的值不同的值来构建缓存查找。其次，这提高了性能，因为Gradle可以一次计算值并缓存结果。</p>
</div>
<div class="paragraph">
<p>这将成为Gradle 6.0中的错误。</p>
</div>
</div>
<div class="sect5">
<h6 id="creating_signoperation_instances"><a class="anchor" href="#creating_signoperation_instances"></a> <a class="link" href="#creating_signoperation_instances">创造<code>SignOperation</code>实例</a></h6>
<div class="paragraph">
<p>创造<code>SignOperation</code>现在不推荐直接使用实例。相反， <code>SigningExtension</code>应该用来创建这些实例。</p>
</div>
<div class="paragraph">
<p>这将成为Gradle 6.0中的错误。</p>
</div>
</div>
<div class="sect5">
<h6 id="declaring_an_incremental_task_without_outputs"><a class="anchor" href="#declaring_an_incremental_task_without_outputs"></a> <a class="link" href="#declaring_an_incremental_task_without_outputs">声明没有输出的增量任务</a></h6>
<div class="paragraph">
<p>现在不建议声明<a href="#incremental_tasks">增量任务</a>而不声明输出。声明文件输出或改用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-groovy.lang.Closure-">TaskOutputs.upToDateWhen（）</a> 。</p>
</div>
<div class="paragraph">
<p>这将成为Gradle 6.0中的错误。</p>
</div>
</div>
<div class="sect5">
<h6 id="method_workerexecutor_submit_is_deprecated"><a class="anchor" href="#method_workerexecutor_submit_is_deprecated"></a> <a class="link" href="#method_workerexecutor_submit_is_deprecated">方法<code>WorkerExecutor.submit()</code>不推荐使用</a></h6>
<div class="paragraph">
<p>的<code>WorkerExecutor.submit()</code>现在不推荐使用该方法。新的<code>noIsolation()</code> ， <code>classLoaderIsolation()</code>和<code>processIsolation()</code>现在应该使用方法提交工作。见<a href="#using-the-worker-api">的userguide</a>上使用这些方法的详细信息。</p>
</div>
<div class="paragraph">
<p><code>WorkerExecutor.submit()</code>将在Gradle 7.0中删除。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_2"><a class="anchor" href="#potential_breaking_changes_2"></a> <a class="link" href="#potential_breaking_changes_2">潜在的重大变化</a></h5>
<div class="sect5">
<h6 id="task_dependencies_are_honored_for_task_input_properties_whose_value_is_a_property"><a class="anchor" href="#task_dependencies_are_honored_for_task_input_properties_whose_value_is_a_property"></a> <a class="link" href="#task_dependencies_are_honored_for_task_input_properties_whose_value_is_a_property">任务依赖于任务<code>@Input</code>其值为a的属性<code>Property</code></a></h6>
<div class="paragraph">
<p>以前，任务的任务依赖性将被忽略<code>@Input</code>类型的属性<code>Property<T></code> 。现在已兑现了这些荣誉，因此可以将任务输出属性附加到任务<code>@Input</code>属性。</p>
</div>
<div class="paragraph">
<p>这可能会在任务依赖关系图中引入意外的循环，在该图中，输出属性的值将被映射以产生输入属性的值。</p>
</div>
</div>
<div class="sect5">
<h6 id="declaring_task_dependencies_using_a_file_provider_that_does_not_represent_a_task_output"><a class="anchor" href="#declaring_task_dependencies_using_a_file_provider_that_does_not_represent_a_task_output"></a> <a class="link" href="#declaring_task_dependencies_using_a_file_provider_that_does_not_represent_a_task_output">使用文件声明任务依赖性<code>Provider</code>不代表任务输出</a></h6>
<div class="paragraph">
<p>以前，可以通过<code>Task.dependsOn()</code>一种<code>Provider<File></code> ， <code>Provider<RegularFile></code>要么<code>Provider<Directory></code>实例不代表任务输出。这些提供程序将被默默忽略。</p>
</div>
<div class="paragraph">
<p>现在这是一个错误，因为Gradle不知道如何生成不是任务输出的文件。</p>
</div>
<div class="paragraph">
<p><strong>请注意</strong> ，仍然可以通过<code>Task.dependsOn()</code>一种<code>Provider</code>例如，它返回一个文件并代表任务输出<code>myTask.dependsOn(jar.archiveFile)</code>要么<code>myTask.dependsOn(taskProvider.flatMap { it.outputDirectory })</code> ， 当。。。的时候<code>Provider</code>是带注释的<code>@OutputFile</code>要么<code>@OutputDirectory</code>任务的属性。</p>
</div>
</div>
<div class="sect5">
<h6 id="setting_property_value_to_null_uses_the_property_convention"><a class="anchor" href="#setting_property_value_to_null_uses_the_property_convention"></a> <a class="link" href="#setting_property_value_to_null_uses_the_property_convention">设置<code>Property</code>重视<code>null</code>使用属性约定</a></h6>
<div class="paragraph">
<p>以前，打电话<code>Property.set(null)</code>总是会将属性的值重置为“未定义”。现在，使用<code>convention()</code>方法将用于确定属性的值。</p>
</div>
</div>
<div class="sect5">
<h6 id="enhanced_validation_of_names_for_publishing_publications_and_publishing_repositories"><a class="anchor" href="#enhanced_validation_of_names_for_publishing_publications_and_publishing_repositories"></a> <a class="link" href="#enhanced_validation_of_names_for_publishing_publications_and_publishing_repositories">增强名称验证<code>publishing.publications</code>和<code>publishing.repositories</code></a></h6>
<div class="paragraph">
<p>存储库名称和发布名称用于构造要发布的任务名称。可以提供一个名称，该名称将导致无效的任务名称。出版物和存储库的名称现在仅限于<code>[A-Za-z0-9_\\-.]+</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="restricted_worker_api_classloader_and_process_classpath"><a class="anchor" href="#restricted_worker_api_classloader_and_process_classpath"></a> <a class="link" href="#restricted_worker_api_classloader_and_process_classpath">受限制的Worker API类加载器和进程类路径</a></h6>
<div class="paragraph">
<p>Gradle现在可以防止内部依赖项（例如Guava）泄漏到Worker API操作使用的类路径中。这解决了工作者需要使用Gradle内部也使用的依赖项<a href="https://github.com/gradle/gradle/issues/3698">的问题</a> 。</p>
</div>
<div class="paragraph">
<p>在以前的版本中，可能依赖于这些泄漏的类。现在，依赖此行为的插件将失败。要修复插件，工作程序应在其类路径中明确包含所有必需的依赖项。</p>
</div>
</div>
<div class="sect5">
<h6 id="default_pmd_version_upgraded_to_6_15_0"><a class="anchor" href="#default_pmd_version_upgraded_to_6_15_0"></a> <a class="link" href="#default_pmd_version_upgraded_to_6_15_0">默认PMD版本已升级到6.15.0</a></h6>
<div class="paragraph">
<p>默认情况下<a href="#pmd_plugin">，PMD插件</a>已升级为使用<a href="https://pmd.github.io/pmd-6.15.0/pmd_release_notes.html">PMD版本6.15.0</a>而不是6.8.0。</p>
</div>
<div class="paragraph">
<p>由<a href="https://github.com/wreulicke">wreulicke</a>贡献</p>
</div>
</div>
<div class="sect5">
<h6 id="configuration_copies_have_unique_names"><a class="anchor" href="#configuration_copies_have_unique_names"></a> <a class="link" href="#configuration_copies_have_unique_names">配置副本具有唯一的名称</a></h6>
<div class="paragraph">
<p>以前，配置的所有副本始终使用以下名称： <code><OriginConfigurationName>Copy</code> 。现在，当创建多个副本时，通过从第二个副本开始添加索引，每个副本将具有唯一的名称。 （例如<code>CompileOnlyCopy2</code> ）</p>
</div>
</div>
<div class="sect5">
<h6 id="changed_classpath_filtering_for_eclipse"><a class="anchor" href="#changed_classpath_filtering_for_eclipse"></a> <a class="link" href="#changed_classpath_filtering_for_eclipse">更改了Eclipse的类路径过滤</a></h6>
<div class="paragraph">
<p>Gradle 5.6不再在Eclipse模型中提供自定义类路径属性。相反，它提供了<a href="https://www.eclipse.org/eclipse/news/4.8/jdt.php#jdt-test-sources">Eclipse测试源</a>的属性。此更改需要Buildship 3.1.1或更高版本。</p>
</div>
</div>
<div class="sect5">
<h6 id="embedded_kotlin_upgraded_to_1_3_41"><a class="anchor" href="#embedded_kotlin_upgraded_to_1_3_41"></a> <a class="link" href="#embedded_kotlin_upgraded_to_1_3_41">嵌入式Kotlin升级到1.3.41</a></h6>
<div class="paragraph">
<p>Gradle Kotlin DSL脚本和Gradle插件使用<code>kotlin-dsl</code>插件现在使用Kotlin 1.3.41进行编译。</p>
</div>
<div class="paragraph">
<p>请参阅Kotlin <a href="https://blog.jetbrains.com/kotlin/2019/06/kotlin-1-3-40-released/">博客文章</a>和<a href="https://github.com/JetBrains/kotlin/blob/1.3.40/ChangeLog.md">changelog</a>以获取有关所包含更改的更多信息。</p>
</div>
<div class="paragraph">
<p>现在支持的最低Kotlin Gradle插件版本为1.2.31。以前是1.2.21。</p>
</div>
</div>
<div class="sect5">
<h6 id="automatic_capability_conflict_resolution"><a class="anchor" href="#automatic_capability_conflict_resolution"></a> <a class="link" href="#automatic_capability_conflict_resolution">自动能力冲突解决</a></h6>
<div class="paragraph">
<p>在功能冲突的情况下，Gradle的早期版本将自动选择具有最高功能版本的模块。从5.6开始，这是可以使用以下方式激活的选择加入行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>configurations.all {
   resolutionStrategy.capabilitiesResolution.all { selectHighestVersion() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多选项，请参见<a href="#sub:capabilities">文档的功能部分</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="file_removal_operations_dont_follow_symlinked_directories"><a class="anchor" href="#file_removal_operations_dont_follow_symlinked_directories"></a> <a class="link" href="#file_removal_operations_dont_follow_symlinked_directories">文件删除操作不遵循符号链接目录</a></h6>
<div class="paragraph">
<p>当Gradle由于各种原因不得不删除任务的输出文件时，它将不会遵循符号链接目录。符号链接本身将被删除，但链接目录的内容将保持不变。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="disabled_debug_argument_parsing_in_javaexec"><a class="anchor" href="#disabled_debug_argument_parsing_in_javaexec"></a> <a class="link" href="#disabled_debug_argument_parsing_in_javaexec">禁用JavaExec中的调试参数解析</a></h5>
<div class="paragraph">
<p>Gradle 5.6引入了新的DSL元素（ <code>JavaForkOptions.debugOptions(Action<JavaDebugOptions>)</code> ）为派生的Java进程配置调试属性。由于此更改，Gradle不再解析与调试相关的JVM参数。所以， <code>JavaForkOptions.getDebu()</code>不再返回<code>true</code>如果<code>-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005</code>或者<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005</code>参数指定给进程。</p>
</div>
</div>
<div class="sect4">
<h5 id="scala_2_9_and_zinc_compiler"><a class="anchor" href="#scala_2_9_and_zinc_compiler"></a> <a class="link" href="#scala_2_9_and_zinc_compiler">Scala 2.9和Zinc编译器</a></h5>
<div class="paragraph">
<p>Gradle不再支持使用Scala 2.9构建应用程序。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_5.5"><a class="anchor" href="#changes_5.5"></a> <a class="link" href="#changes_5.5">从5.4或更早版本升级</a></h4>
<div class="sect4">
<h5 id="deprecations_3"><a class="anchor" href="#deprecations_3"></a> <a class="link" href="#deprecations_3">弃用</a></h5>
<div class="sect5">
<h6 id="play"><a class="anchor" href="#play"></a> <a class="link" href="#play">玩</a></h6>
<div class="paragraph">
<p>内置的<a href="play_plugin.html#play_plugin">Play插件</a>已被弃用，将由插件门户提供的新<a href="https://gradle.github.io/playframework">Play Framework插件</a>取代。</p>
</div>
</div>
<div class="sect5">
<h6 id="build_comparison"><a class="anchor" href="#build_comparison"></a> <a class="link" href="#build_comparison">构建比较</a></h6>
<div class="paragraph">
<p><em>构建比较</em>插件已被弃用，并将在下一个主要版本的Gradle中删除。</p>
</div>
<div class="paragraph">
<p><a href="https://gradle.com/build-scans">构建扫描</a>显示了对<a href="https://gradle.com/build-scans">构建的</a>更深入了解，您可以使用<a href="https://gradle.com/">Gradle Enterprise</a>直接比较两个构建的构建扫描。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_3"><a class="anchor" href="#potential_breaking_changes_3"></a> <a class="link" href="#potential_breaking_changes_3">潜在的重大变化</a></h5>
<div class="sect5">
<h6 id="user_supplied_eclipse_project_names_may_be_ignored_on_conflict"><a class="anchor" href="#user_supplied_eclipse_project_names_may_be_ignored_on_conflict"></a> <a class="link" href="#user_supplied_eclipse_project_names_may_be_ignored_on_conflict">用户提供的Eclipse项目名称可能在冲突时被忽略</a></h6>
<div class="paragraph">
<p>通过以下方式配置的项目名称<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/EclipseProject.html"><code>EclipseProject.setName(…​)</code></a>即使名称引起冲突和导入/同步错误，在所有情况下Gradle和Buildship都将其视为荣誉。</p>
</div>
<div class="paragraph">
<p>如果这些名称与Eclipse工作空间中的其他项目名称冲突，那么Gradle现在可以对这些名称进行重复数据删除。对于具有用户指定名称的项目，这可能导致不同的Eclipse项目名称。</p>
</div>
<div class="paragraph">
<p>要利用此行为，需要即将发布的Buildship 3.1.1版本。</p>
</div>
<div class="paragraph">
<p>由<a href="https://github.com/fraenkelc">ChristianFränkel</a>贡献</p>
</div>
</div>
<div class="sect5">
<h6 id="default_jacoco_version_upgraded_to_0_8_4"><a class="anchor" href="#default_jacoco_version_upgraded_to_0_8_4"></a> <a class="link" href="#default_jacoco_version_upgraded_to_0_8_4">JaCoCo的默认版本已升级到0.8.4</a></h6>
<div class="paragraph">
<p><a href="#jacoco_plugin">JaCoCo插件</a>已升级为默认使用<a href="http://www.jacoco.org/jacoco/trunk/doc/changes.html">JaCoCo版本0.8.4</a>而不是0.8.3。</p>
</div>
<div class="paragraph">
<p>由<a href="https://github.com/Godin">Evgeny Mandrikov</a>贡献</p>
</div>
</div>
<div class="sect5">
<h6 id="embedded_ant_version_upgraded_to_1_9_14"><a class="anchor" href="#embedded_ant_version_upgraded_to_1_9_14"></a> <a class="link" href="#embedded_ant_version_upgraded_to_1_9_14">嵌入式Ant版本已升级到1.9.14</a></h6>
<div class="paragraph">
<p>与摇篮分发的Ant版本已经升级到了<a href="https://archive.apache.org/dist/ant/RELEASE-NOTES-1.9.14.html">14年9月1日</a>从1.9.13。</p>
</div>
</div>
<div class="sect5">
<h6 id="type_dependencyhandler_now_statically_exposes_extensionaware"><a class="anchor" href="#type_dependencyhandler_now_statically_exposes_extensionaware"></a> <a class="link" href="#type_dependencyhandler_now_statically_exposes_extensionaware">类型<code>DependencyHandler</code>现在静态暴露<code>ExtensionAware</code></a></h6>
<div class="paragraph">
<p>这会影响使用以下内容的Kotlin DSL构建脚本<code>ExtensionAware</code>扩展成员，例如<code>extra</code>内部的属性访问器<code>dependencies {}</code>块。这些成员的接收者将不再是附件<code>Project</code>实例但<code>dependencies</code>对象本身，最里面的<code>ExtensionAware</code>合格的接收者。为了解决<code>Project</code>里面的额外属性<code>dependencies {}</code>接收者必须明确资格，即<code>project.extra</code>而不只是<code>extra</code> 。受影响的扩展程序还包括<code>the<T>()</code>和<code>configure<T>(T.() → Unit)</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="improved_processing_of_dependency_excludes"><a class="anchor" href="#improved_processing_of_dependency_excludes"></a> <a class="link" href="#improved_processing_of_dependency_excludes">改进的依赖性处理排除</a></h6>
<div class="paragraph">
<p>当存在大量排除项时，在某些复杂的依赖图中，Gradle的早期版本可能会产生错误的结果或随机的依赖顺序。为了减轻这种情况，计算排除的算法已被重写。在少数情况下，由于正确性的改变，这可能会导致分辨率有所不同。</p>
</div>
</div>
<div class="sect5">
<h6 id="improved_classpath_separation_for_worker_processes"><a class="anchor" href="#improved_classpath_separation_for_worker_processes"></a> <a class="link" href="#improved_classpath_separation_for_worker_processes">改进了工作进程的类路径分离</a></h6>
<div class="paragraph">
<p>使用时由<a href="#worker_api">Worker API</a>启动的工作程序守护程序的系统类路径<code>PROCESS</code>隔离已减少到最少的Gradle基础结构集。用户代码仍被隔离到单独的类加载器中，以将其与Gradle运行时隔离。对于使用worker API的任务，这应该是透明的更改，但是Gradle的早期版本在worker进程中混合了用户代码和Gradle内部。依赖于诸如<code>java.class.path</code>系统属性可能会受到影响，因为<code>java.class.path</code>现在仅表示Gradle内部结构的类路径。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_5.4"><a class="anchor" href="#changes_5.4"></a> <a class="link" href="#changes_5.4">从5.3或更早版本升级</a></h4>
<div class="sect4">
<h5 id="deprecations_4"><a class="anchor" href="#deprecations_4"></a> <a class="link" href="#deprecations_4">弃用</a></h5>
<div class="sect5">
<h6 id="using_custom_local_build_cache_implementations"><a class="anchor" href="#using_custom_local_build_cache_implementations"></a> <a class="link" href="#using_custom_local_build_cache_implementations">使用自定义本地构建缓存实现</a></h6>
<div class="paragraph">
<p>现在不建议将自定义生成缓存实现用于本地生成缓存。唯一允许的类型是<code>DirectoryBuildCache</code>向前走。使用自定义生成缓存实现作为远程生成缓存的支持没有变化。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_4"><a class="anchor" href="#potential_breaking_changes_4"></a> <a class="link" href="#potential_breaking_changes_4">潜在的重大变化</a></h5>
<div class="sect5">
<h6 id="use_https_when_configuring_google_hosted_libraries_via_googleapis"><a class="anchor" href="#use_https_when_configuring_google_hosted_libraries_via_googleapis"></a> <a class="link" href="#use_https_when_configuring_google_hosted_libraries_via_googleapis">通过配置Google托管库时使用HTTPS<code>googleApis()</code></a></h6>
<div class="paragraph">
<p>可通过以下网址访问Google托管库网址<code>JavaScriptRepositoriesExtension#GOOGLE_APIS_REPO_URL</code>已更改为使用HTTPS协议。更改还会影响通过以下方式配置的Ivy存储库<code>googleApis()</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_5.3"><a class="anchor" href="#changes_5.3"></a> <a class="link" href="#changes_5.3">从5.2或更早版本升级</a></h4>
<div class="sect4">
<h5 id="potential_breaking_changes_5"><a class="anchor" href="#potential_breaking_changes_5"></a> <a class="link" href="#potential_breaking_changes_5">潜在的重大变化</a></h5>
<div class="sect5">
<h6 id="bug_fixes_in_platform_resolution"><a class="anchor" href="#bug_fixes_in_platform_resolution"></a> <a class="link" href="#bug_fixes_in_platform_resolution">修复了平台分辨率中的错误</a></h6>
<div class="paragraph">
<p>从Gradle 5.0到5.2.1（包括）存在一个错误，其中强制平台可能包含依赖性而不是约束。只要POM文件同时定义了依赖项和“约束”（通过<code><dependencyManagement></code> ），并且您使用了<code>enforcedPlatform</code> 。Gradle 5.3修复了此错误，这意味着如果您依靠此损坏的行为，则分辨率结果可能会有所不同。同样，Gradle 5.3将不再尝试下载jar <code>platform</code>和<code>enforcedPlatform</code>依赖性（因为它们只能带来约束）。</p>
</div>
</div>
<div class="sect5">
<h6 id="automatic_target_jvm_version"><a class="anchor" href="#automatic_target_jvm_version"></a> <a class="link" href="#automatic_target_jvm_version">自动目标JVM版本</a></h6>
<div class="paragraph">
<p>如果您使用任何Java插件，Gradle现在将尽力选择与正在编译的模块的目标兼容性匹配的依赖项。实际上，这意味着如果您具有为Java 8构建的模块A和为Java 8构建的模块B，则没有任何变化。但是，如果B是为Java 9+构建的，则它不再与二进制兼容，并且Gradle会抱怨如下错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Unable to find a matching variant of project :producer:
  - Variant 'apiElements' capability test:producer:unspecified:
      - Required org.gradle.dependency.bundling 'external' and found compatible value 'external'.
      - Required org.gradle.jvm.version '8' and found incompatible value '9'.
      - Required org.gradle.usage 'java-api' and found compatible value 'java-api-jars'.
  - Variant 'runtimeElements' capability test:producer:unspecified:
      - Required org.gradle.dependency.bundling 'external' and found compatible value 'external'.
      - Required org.gradle.jvm.version '8' and found incompatible value '9'.
      - Required org.gradle.usage 'java-api' and found compatible value 'java-runtime-jars'.</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，这表明您的项目配置错误并且您的依赖项不兼容。但是，在某些情况下，您仍然可能想要这样做，例如，当模块的类的<em>子集</em>实际上实际上需要Java 9依赖项，并且不打算在早期版本中使用时。Java通常不鼓励您这样做（您应该拆分模块），但是如果遇到此问题，可以通过在使用者方面禁用此新行为来解决：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>java {
   disableAutoTargetJvm()
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="bug_fix_in_maven_ivy_interoperability_with_dependency_substitution"><a class="anchor" href="#bug_fix_in_maven_ivy_interoperability_with_dependency_substitution"></a> <a class="link" href="#bug_fix_in_maven_ivy_interoperability_with_dependency_substitution">通过依赖替换在Maven / Ivy互操作性中的错误修复</a></h6>
<div class="paragraph">
<p>如果您有一个指向Ivy依赖项的Maven依赖项， <code>default</code>配置依赖项与<code>compile</code> + <code>runtime</code> + <code>master</code> <em>和</em>常春藤依赖被替换（使用<code>resolutionStrategy.force</code> ， <code>resolutionStrategy.eachDependency</code>要么<code>resolutionStrategy.dependencySubstitution</code> ），那么此修复程序将影响您。Gradle在5.0之前的传统行为仍然存在，而不是被改进的pom支持所引入的更改所取代。</p>
</div>
</div>
<div class="sect5">
<h6 id="delete_operations_correctly_handle_symbolic_links_on_windows"><a class="anchor" href="#delete_operations_correctly_handle_symbolic_links_on_windows"></a> <a class="link" href="#delete_operations_correctly_handle_symbolic_links_on_windows">删除操作可以正确处理Windows上的符号链接</a></h6>
<div class="paragraph">
<p>Gradle不再忽略<code>followSymlink</code> Windows上的选项<code>clean</code>任务全部<code>Delete</code>任务，以及<code>project.delete {}</code>在连接点和符号链接存在的情况下进行操作。</p>
</div>
</div>
<div class="sect5">
<h6 id="fix_in_publication_of_additional_artifacts"><a class="anchor" href="#fix_in_publication_of_additional_artifacts"></a> <a class="link" href="#fix_in_publication_of_additional_artifacts">修复其他工件的发布</a></h6>
<div class="paragraph">
<p>在以前的Gradle版本中，在项目级别注册的其他工件没有发布<code>maven-publish</code>要么<code>ivy-publish</code>除非它们也作为工件添加到发布配置中。</p>
</div>
<div class="paragraph">
<p>使用Gradle 5.3，现在可以正确解释和发布这些工件了。</p>
</div>
<div class="paragraph">
<p>这意味着在项目<em>和</em>发布（Ivy或Maven）上都注册的工件会导致发布失败，因为它将创建重复的条目。解决方法是从发布配置中删除这些工件。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_5.2"><a class="anchor" href="#changes_5.2"></a> <a class="link" href="#changes_5.2">从5.1或更早版本升级</a></h4>
<div class="sect4">
<h5 id="potential_breaking_changes_6"><a class="anchor" href="#potential_breaking_changes_6"></a> <a class="link" href="#potential_breaking_changes_6">潜在的重大变化</a></h5>
<div class="paragraph">
<p>没有</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_5.1"><a class="anchor" href="#changes_5.1"></a> <a class="link" href="#changes_5.1">从5.0及更低版本升级</a></h4>
<div class="sect4">
<h5 id="deprecations_5"><a class="anchor" href="#deprecations_5"></a> <a class="link" href="#deprecations_5">弃用</a></h5>
<div class="paragraph">
<p>按照API链接了解如何处理这些弃用（如果此处未提供其他信息）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>二传手<code>classes</code>和<code>classpath</code>上<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/devel/tasks/ValidateTaskProperties.html"><code>ValidateTaskProperties</code></a></p>
</li>
<li>
<p>不应为诸如<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileCollection.html"><code>ConfigurableFileCollection</code></a> 。使用<code>setFrom</code>代替。例如，</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>    validateTaskProperties.getClasses().setFrom(fileCollection)
    validateTaskProperties.getClasspath().setFrom(fileCollection)</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_7"><a class="anchor" href="#potential_breaking_changes_7"></a> <a class="link" href="#potential_breaking_changes_7">潜在的重大变化</a></h5>
<div class="paragraph">
<p>以前不建议以下更改：</p>
</div>
<div class="sect5">
<h6 id="signing_api_changes"><a class="anchor" href="#signing_api_changes"></a> <a class="link" href="#signing_api_changes">签名API更改</a></h6>
<div class="paragraph">
<p>输入和输出文件<code>Sign</code>现在可以通过跟踪任务<code>Signature.getToSign()</code>和<code>Signature.getFile()</code> ， 分别。</p>
</div>
</div>
<div class="sect5">
<h6 id="collection_properties_default_to_empty_collection"><a class="anchor" href="#collection_properties_default_to_empty_collection"></a> <a class="link" href="#collection_properties_default_to_empty_collection">集合属性默认为空集合</a></h6>
<div class="paragraph">
<p>在Gradle 5.0中，使用创建的collection属性实例<code>ObjectFactory</code>将没有定义值，需要插件作者明确设置初始值。事实证明这很尴尬并且容易出错。 <code>ObjectFactory</code>现在返回带有空集合作为其初始值的实例。</p>
</div>
</div>
<div class="sect5">
<h6 id="worker_api_working_directory_of_a_worker_can_no_longer_be_set"><a class="anchor" href="#worker_api_working_directory_of_a_worker_can_no_longer_be_set"></a> <a class="link" href="#worker_api_working_directory_of_a_worker_can_no_longer_be_set">Worker API：无法再设置工人的工作目录</a></h6>
<div class="paragraph">
<p>由于JDK 11不再支持更改正在运行的进程的工作目录，因此现在禁止通过其fork选项设置工作程序的工作目录。现在，所有工作人员都使用相同的工作目录来启用重用。请改为将文件和目录作为参数传递。请参阅<a href="#worker_api">Worker API文档</a>中的示例。</p>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_native_linking_tasks"><a class="anchor" href="#changes_to_native_linking_tasks"></a> <a class="link" href="#changes_to_native_linking_tasks">更改本机链接任务</a></h6>
<div class="paragraph">
<p>要扩展我们惯用的<a href="#">Provider API</a>做法，请从<code>org.gradle.nativeplatform.tasks.LinkSharedLibrary</code>受此更改的影响。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInstallName()</code>更改为返回一个<code>Property</code> 。</p>
</li>
<li>
<p><code>setInstallName(String)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="passing_arguments_to_windows_resource_compiler"><a class="anchor" href="#passing_arguments_to_windows_resource_compiler"></a> <a class="link" href="#passing_arguments_to_windows_resource_compiler">将参数传递给Windows Resource Compiler</a></h6>
<div class="paragraph">
<p>为了扩展我们惯用的<a href="#">Provider API</a>做法， <code>WindowsResourceCompile</code>任务已转换为使用提供程序API。</p>
</div>
<div class="paragraph">
<p>现在，传递其他编译器参数的方式与<code>CppCompile</code>和其他任务。</p>
</div>
</div>
<div class="sect5">
<h6 id="copied_configuration_no_longer_shares_a_list_of_beforeresolve_actions_with_original"><a class="anchor" href="#copied_configuration_no_longer_shares_a_list_of_beforeresolve_actions_with_original"></a> <a class="link" href="#copied_configuration_no_longer_shares_a_list_of_beforeresolve_actions_with_original">复制的配置不再共享以下列表<code>beforeResolve</code>原始动作</a></h6>
<div class="paragraph">
<p>清单<code>beforeResolve</code>操作将不再在复制的配置和原始配置之间共享。相反，复制的配置会收到<code>beforeResolve</code>复制时的操作。任何<code>beforeResolve</code>复制（添加到任一配置）后添加的操作将不会在原始副本和副本之间共享。这可能会破坏依赖于先前行为的插件。</p>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_incubating_pom_customization_types"><a class="anchor" href="#changes_to_incubating_pom_customization_types"></a> <a class="link" href="#changes_to_incubating_pom_customization_types">孵化POM定制类型的更改</a></h6>
<div class="ulist">
<ul>
<li>
<p>的类型<code>MavenPomDeveloper.properties</code>已从<code>Property<Map<String, String>></code>至<code>MapProperty<String, String></code> 。</p>
</li>
<li>
<p>的类型<code>MavenPomContributor.properties</code>已从<code>Property<Map<String, String>></code>至<code>MapProperty<String, String></code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="changes_to_specifying_operating_system_for_native_projects"><a class="anchor" href="#changes_to_specifying_operating_system_for_native_projects"></a> <a class="link" href="#changes_to_specifying_operating_system_for_native_projects">对本机项目指定操作系统的更改</a></h6>
<div class="paragraph">
<p>孵化<code>operatingSystems</code>本机组件上的属性已替换为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/cpp/CppComponent.html#getTargetMachines()">targetMachines</a>属性。</p>
</div>
</div>
<div class="sect5">
<h6 id="changes_for_archive_tasks_zip_jar_war_ear_tar"><a class="anchor" href="#changes_for_archive_tasks_zip_jar_war_ear_tar"></a> <a class="link" href="#changes_for_archive_tasks_zip_jar_war_ear_tar">存档任务的更改（ <code>Zip</code> ， <code>Jar</code> ， <code>War</code> ， <code>Ear</code> ， <code>Tar</code> ）</a></h6>
<div class="sect6">
<h7 id="change_in_behavior_for_tasks_extending_abstractarchivetask"><a class="anchor" href="#change_in_behavior_for_tasks_extending_abstractarchivetask"></a> <a class="link" href="#change_in_behavior_for_tasks_extending_abstractarchivetask">行为变化以扩展任务<code>AbstractArchiveTask</code></a></h7>
<div class="paragraph">
<p>的<code>AbstractArchiveTask</code>使用<a href="#sec:lazy_configuration_reference">Provider API</a>有几个新属性。扩展这些类型并从基类覆盖方法的插件可能不再具有相同的行为。在内部， <code>AbstractArchiveTask</code>喜欢新的属性和方法，例如<code>getArchiveName()</code>是新建筑的立面。</p>
</div>
<div class="paragraph">
<p>如果您的插件/构建仅使用这些类型（而不扩展它们），则没有任何改变。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="upgrading_version_4"><a class="anchor" href="#upgrading_version_4"></a> <a class="link" href="#upgrading_version_4">将您的构建从Gradle 4.x升级到5.0</a></h3>
<div class="paragraph">
<p>本章提供了将较早的Gradle 4.x构建迁移到Gradle 5.0所需的信息。在大多数情况下，您将需要应用升级版本之后的所有版本中的更改。例如，如果要从Gradle 4.3升级，则还需要应用4.4、4.5等以来的更改。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">如果您使用的是Android Gradle，则需要同时升级到Android Gradle插件和Android Studio的3.3版或更高版本。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="for_all_users"><a class="anchor" href="#for_all_users"></a> <a class="link" href="#for_all_users">对于所有用户</a></h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果尚未使用最新的4.10.x版本，请阅读以下各节<a href="#changes_4.10">，</a>以帮助您将项目升级到最新的4.10.x版本。我们建议升级到最新的4.10.x版本，以获取最有用的警告和弃用信息，然后再升级到5.0。避免同时升级Gradle并迁移到Kotlin DSL，以便在出现潜在问题时简化故障排除。</p>
</li>
<li>
<p>尝试跑步<code>gradle help --scan</code>并查看生成的构建扫描的<a href="https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality">弃用视图</a> 。如果没有警告，则不会出现“弃用”选项卡。</p>
<div class="imageblock">
<div class="content">
<img src="img/deprecations.png" alt="Gradle构建扫描的弃用视图">
</div>
</div>
<div class="paragraph">
<p>这样一来，您就可以看到适用于您的构建的所有弃用警告。如果您尝试直接升级到Gradle 5.x，它将生成（可能不太明显）错误。</p>
</div>
<div class="paragraph">
<p>或者，您可以运行<code>gradle help --warning-mode=all</code>在控制台中查看弃用项，尽管它可能不会报告太多详细信息。</p>
</div>
</li>
<li>
<p>更新您的插件。</p>
<div class="paragraph">
<p>一些插件将随新版本的Gradle一起中断，例如，因为它们使用已被删除或更改的内部API。上一步将通过在插件确实尝试使用API弃用的部分时发出弃用警告来帮助您识别潜在的问题。</p>
</div>
<div class="paragraph">
<p>特别是，您至少需要使用2.x版本的<a href="https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow"><strong>Shadow Plugin</strong></a> 。</p>
</div>
</li>
<li>
<p>跑<code>gradle wrapper --gradle-version 5.0</code>将项目更新到5.0</p>
</li>
<li>
<p>如果还没有，请转到Java 8或更高版本。而Gradle 4.x需要Java 7，Gradle 5需要Java 8才能运行。</p>
</li>
<li>
<p>阅读“ <a href="#changes_5.0">从4.10升级”</a>部分并进行必要的更改。</p>
</li>
<li>
<p>尝试使用《 <a href="#troubleshooting">故障排除指南》</a>运行项目并调试所有错误。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此外，Gradle还添加了一些重要的新功能和改进的功能，您应该在构建中考虑使用这些功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rel4.8:switch_to_publishing_plugins">Maven Publish和Ivy Publish插件</a>现在支持使用<a href="#signing_plugin">Signing Plugin进行</a>数字签名。</p>
</li>
<li>
<p>在构建中使用本机<a href="#rel5.0:bom_import">BOM导入</a> 。</p>
</li>
<li>
<p>用于使工作单元并行运行的<a href="#worker_api">Worker API</a> 。</p>
</li>
<li>
<p>用于<a href="#rel4.9:lazy_task_creation">延迟创建和配置任务的</a>新API，可以显着缩短构建的配置时间。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>需要注意的其他值得注意的更改可能会破坏您的构建，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rel5.0:pom_compile_runtime_separation">使用POM时将编译和运行时依赖项分离</a></p>
</li>
<li>
<p>进行更改意味着您应该<a href="#rel4.8:configure_internal_tasks">配置现有的<code>wrapper</code>和<code>init</code>任务，</a>而不是定义自己的<a href="#rel4.8:configure_internal_tasks">任务</a> 。</p>
</li>
<li>
<p><a href="#rel4.8:pom_wildcard_exclusions">在Maven POM排除中使用隐式通配符</a>可能会导致排除以前没有的依赖项。</p>
</li>
<li>
<p><a href="#rel4.6:annotation_processor_configuration">更改了将Java注释处理器添加到项目中的方式</a> 。</p>
</li>
<li>
<p>命令行客户端Gradle守护程序以及所有工作程序（包括编译器和测试执行程序）的<a href="#rel5.0:default_memory_settings">默认内存设置</a>已大大减少。</p>
</li>
<li>
<p><a href="#rel5.0:default_tool_versions">几个代码质量插件</a>的<a href="#rel5.0:default_tool_versions">默认版本</a>已更新。</p>
</li>
<li>
<p><a href="#rel5.0:library_upgrades">Gradle使用的</a>几个<a href="#rel5.0:library_upgrades">库版本</a>已升级。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="changes_5.0"><a class="anchor" href="#changes_5.0"></a> <a class="link" href="#changes_5.0">从4.10及更早版本升级</a></h4>
<div class="paragraph">
<p>如果您尚未使用4.10版本，请跳至适用于当前Gradle版本的部分，然后逐步升级，直至到达此处。然后，从Gradle 4.10移至5.0时应用这些更改。</p>
</div>
<div class="sect4">
<h5 id="other_changes"><a class="anchor" href="#other_changes"></a> <a class="link" href="#other_changes">其他变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>的<code>enableFeaturePreview('IMPROVED_POM_SUPPORT')</code>和<code>enableFeaturePreview('STABLE_PUBLISHING')</code>标志不再是必需的。现在默认情况下启用了这些功能。</p>
</li>
<li>
<p>Gradle现在捆绑了Java 9及更高版本的<a href="#rel5.0:jaxb_and_java9">JAXB</a> 。您可以删除<code>--add-modules java.xml.bind</code>来自的选项<code>org.gradle.jvmargs</code> （如果已设置）。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_8"><a class="anchor" href="#potential_breaking_changes_8"></a> <a class="link" href="#potential_breaking_changes_8">潜在的重大变化</a></h5>
<div class="paragraph">
<p>本部分中的更改有可能破坏您的构建，但是大多数版本已被弃用了相当长的时间，很少有构建会受到大量构建的影响。我们强烈建议您首先升级到Gradle 4.10，以获取有关弃用会影响构建的报告。</p>
</div>
<div class="paragraph">
<p>以下重大变化不是因为弃用，而是行为变化的结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rel5.0:pom_compile_runtime_separation">使用POM时将编译和运行时依赖项分离</a></p>
</li>
<li>
<p>的评价<code>publishing {}</code>块不再推迟到需要时才执行，但其行为类似于其他任何块。请用<code>afterEvaluate {}</code>如果您需要推迟评估。</p>
</li>
<li>
<p>的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.javadoc.Javadoc.html"><code>Javadoc</code></a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.javadoc.Groovydoc.html"><code>Groovydoc</code></a>现在，任务会在执行之前删除文档的目标目录。已添加此功能以从上一次任务执行中删除过时的输出文件。</p>
</li>
<li>
<p><a href="#">Java库分发插件</a>现在基于<a href="#">Java库插件</a>而不是<a href="#">Java插件</a> 。</p>
<div class="paragraph">
<p>在应用Java插件时，其行为略有不同（例如，它添加了<code>api</code>组态）。因此，请确保在升级后检查内部版本是否符合预期。</p>
</div>
</li>
<li>
<p>的<code>html</code>财产<code>CheckstyleReport</code>和<code>FindBugsReport</code>现在返回一个<a href="https://docs.gradle.org/current/dsl/org.gradle.api.reporting.CustomizableHtmlReport.html"><code>CustomizableHtmlReport</code></a>从静态类型的语言（例如Java和Kotlin）更易于配置的实例。</p>
</li>
<li>
<p><a href="#rel5.0:configuration_avoidance">配置避免API</a>已更新，可以防止创建和配置从未使用过的任务。</p>
</li>
<li>
<p>命令行客户端Gradle守护程序以及所有工作程序（包括编译器和测试执行程序）的<a href="#rel5.0:default_memory_settings">默认内存设置</a>已大大减少。</p>
</li>
<li>
<p><a href="#rel5.0:default_tool_versions">几个代码质量插件</a>的<a href="#rel5.0:default_tool_versions">默认版本</a>已更新。</p>
</li>
<li>
<p><a href="#rel5.0:library_upgrades">Gradle使用的</a>几个<a href="#rel5.0:library_upgrades">库版本</a>已升级。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下重大更改将在Gradle 4.10中作为弃用警告显示：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">一般</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><<</code>任务定义不再有效。换句话说，您不能使用语法<code>task myTask << { …​ }</code> 。</p>
<div class="paragraph">
<p>改用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:doLast(org.gradle.api.Action)">Task.doLast（）</a>方法，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>task myTask {
    doLast {
        ...
    }
}</pre>
</div>
</div>
</li>
<li>
<p>您不能再在域对象名称中使用以下任何字符，例如项目和任务名称： <space><code>/ \ : < > " ? * |</code> 。您也不应该使用<code>.</code>作为前导或结尾字符。</space></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">运行Gradle和构建环境</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>如前所述，Gradle无法再在Java 7上运行。但是，您仍然可以使用<a href="https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_cross_compilation">分支编译和测试</a>来构建和测试Java 6及更高版本的软件。</p>
</li>
<li>
<p>的<code>-Dtest.single</code>命令行选项已被删除-改用<a href="#test_filtering">测试过滤</a> 。</p>
</li>
<li>
<p>的<code>-Dtest.debug</code>命令行选项已删除-使用<a href="#sec:debugging_java_tests"><code>--debug-jvm</code>选项</a> 。</p>
</li>
<li>
<p>的<code>-u</code> / <code>--no-search-upward</code>命令行选项已被删除-确保所有构建都具有<em>settings.gradle</em>文件。</p>
</li>
<li>
<p>的<code>--recompile-scripts</code>命令行选项已被删除。</p>
</li>
<li>
<p>除非嵌套的构建具有<em>settings.gradle</em>文件，否则您不能再将Gradle嵌套在另一个Gradle构建的子目录中。</p>
</li>
<li>
<p>的<code>DirectoryBuildCache.setTargetSizeInMB(long)</code>方法已删除—使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.local.DirectoryBuildCache.html#org.gradle.caching.local.DirectoryBuildCache:removeUnusedEntriesAfterDays">DirectoryBuildCache.removeUnusedEntriesAfterDays</a>代替。</p>
</li>
<li>
<p>的<code>org.gradle.readLoggingConfigFile</code>系统属性不再执行任何操作-更新受影响的测试以与您的<code>java.util.logging</code>设置。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">处理文件</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>您无法再投射<code>FileCollection</code>对象使用其他类型<code>as</code>关键字或<code>asType()</code>方法。</p>
</li>
<li>
<p>您不能再通过<code>null</code>作为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#from-java.lang.Object-org.gradle.api.Action-">CopySpec.from（Object，Action）</a>的配置操作。</p>
</li>
<li>
<p>为了与Kotlin DSL更好地兼容， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DuplicatesStrategy.html">CopySpec.duplicatesStrategy</a>不再可以为空。属性设置器不再接受<code>null</code>作为将属性重置为默认值的一种方法。使用<code>DuplicatesStrategy.INHERIT</code>代替。</p>
</li>
<li>
<p>的<code>FileCollection.stopExecutionIfEmpty()</code>方法已删除—在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/SkipWhenEmpty.html">@SkipWhenEmpty</a>注释上使用<code>FileCollection</code>任务属性。</p>
</li>
<li>
<p>的<code>FileCollection.add()</code>方法已删除—使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)">Project.fileTree（）</a>创建可配置的文件集合/文件树，并通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileCollection.html#from-java.lang.Object...-">ConfigurableFileCollection.from（）</a>将其添加到其中。</p>
</li>
<li>
<p><code>SimpleFileCollection</code>已被删除-改用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（Object ...）</a> 。</p>
</li>
<li>
<p>没有自己的课程扩展<code>AbstractFileCollection</code> -改用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（）</a>方法。此问题可能显示为丢失<code>getBuildDependencies()</code>方法。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Java构建</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>的<code>CompileOptions.bootClasspath</code>属性已删除-使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:bootstrapClasspath">CompileOptions.bootstrapClasspath</a>代替。</p>
</li>
<li>
<p>您不能再使用<code>-source-path</code>作为通用的编译器参数—改用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:sourcepath">CompileOptions.sourcepath</a> 。</p>
</li>
<li>
<p>您不能再使用<code>-processorpath</code>作为通用的编译器参数—改用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:annotationProcessorPath">CompileOptions.annotationProcessorPath</a> 。</p>
</li>
<li>
<p>Gradle将不再自动应用编译类路径上的注释处理器-改用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:annotationProcessorPath">CompileOptions.annotationProcessorPath</a> 。</p>
</li>
<li>
<p>的<code>testClassesDir</code>属性已从“ <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试”</a>任务中删除-改用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:testClassesDirs">testClassesDirs</a> 。</p>
</li>
<li>
<p>的<code>classesDir</code>属性已从<em>JDepend</em>任务和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSetOutput.html">SourceSetOutput中删除</a> 。请改用<em>JDepend.classesDirs</em>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSetOutput.html#org.gradle.api.tasks.SourceSetOutput:classesDirs">SourceSetOutput.classesDirs</a>属性。</p>
</li>
<li>
<p>的<code>JavaLibrary(PublishArtifact, DependencySet)</code>构造函数已被删除<a href="https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow">-Shadow Plugin</a>已使用了它，因此请确保至少升级到该插件的2.x版本。</p>
</li>
<li>
<p>的<code>JavaBasePlugin.configureForSourceSet()</code>方法已删除。</p>
</li>
<li>
<p>您不再可以创建自己的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/JavaPluginConvention.html">JavaPluginConvention</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/ApplicationPluginConvention.html">ApplicationPluginConvention</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/WarPluginConvention.html">WarPluginConvention</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ear/EarPluginConvention.html">EarPluginConvention</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/BasePluginConvention.html">BasePluginConvention</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/ProjectReportsPluginConvention.html">ProjectReportsPluginConvention</a>实例。</p>
</li>
<li>
<p>的<code>Maven</code>用于发布过时的Maven 2元数据格式的插件。这已更改，现在将发布Maven 3元数据，就像<code>Maven Publish</code>插入。</p>
<div class="paragraph">
<p>随着对Maven 2支持的删除，配置唯一快照行为的方法也被删除。Maven 3仅支持唯一的快照，因此我们决定删除它们。</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">任务和属性</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>删除了以下与<a href="#sec:lazy_properties">惰性属性</a>相关的旧类和方法-使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-">ObjectFactory.property（）</a>创建<code>Property</code>实例：</p>
<div class="ulist">
<ul>
<li>
<p><code>PropertyState</code></p>
</li>
<li>
<p><code>DirectoryVar</code></p>
</li>
<li>
<p><code>RegularFileVar</code></p>
</li>
<li>
<p><code>ProjectLayout.newDirectoryVar()</code></p>
</li>
<li>
<p><code>ProjectLayout.newFileVar()</code></p>
</li>
<li>
<p><code>Project.property(Class)</code></p>
</li>
<li>
<p><code>Script.property(Class)</code></p>
</li>
<li>
<p><code>ProviderFactory.property(Class)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>使用<a href="task_configuration_avoidance.html#sec:task_configuration_avoidance_migration_guidelines">任务配置避免</a> API配置和注册的<a href="task_configuration_avoidance.html#sec:task_configuration_avoidance_migration_guidelines">任务</a>对可以从配置操作中调用的其他方法有更多限制。</p>
</li>
<li>
<p>内置的<code>@Option</code>和<code>@OptionValues</code>注释-包<code>org.gradle.api.internal.tasks.options</code> —已被删除。请改用公共<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/options/Option.html">@Option</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/options/OptionValues.html">@OptionValues</a>批注。</p>
</li>
<li>
<p>的<code>Task.deleteAllActions()</code>方法已删除，无法替代。</p>
</li>
<li>
<p>的<code>Task.dependsOnTaskDidWork()</code>方法已删除-使用<a href="#sec:up_to_date_checks">声明的输入和输出</a>代替。</p>
</li>
<li>
<p>以下属性和方法<code>TaskInternal</code>已被删除-使用任务依赖项，任务规则，可重用的实用程序方法或<a href="#worker_api">Worker API</a>代替直接执行任务。</p>
<div class="ulist">
<ul>
<li>
<p><code>execute()</code></p>
</li>
<li>
<p><code>executer</code></p>
</li>
<li>
<p><code>getValidators()</code></p>
</li>
<li>
<p><code>addValidator()</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputs.html#file-java.lang.Object-">TaskInputs.file（Object）</a>方法不能再使用可解析为单个常规文件以外的任何参数的参数来调用。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputs.html#dir-java.lang.Object-">TaskInputs.dir（Object）</a>方法不能再使用可解析为单个目录以外的任何参数的参数来调用。</p>
</li>
<li>
<p>您不再可以通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputs.html">TaskInputs</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskOutputs.html">TaskOutputs</a>注册无效的输入和输出。</p>
</li>
<li>
<p>的<code>TaskDestroyables.file()</code>和<code>TaskDestroyables.files()</code>方法已删除-使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskDestroyables.html#register-java.lang.Object...-">TaskDestroyables.register（）</a>代替。</p>
</li>
<li>
<p><code>SimpleWorkResult</code>已被删除-使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/WorkResult.html#getDidWork--">WorkResult.didWork</a> 。</p>
</li>
<li>
<p>现在，覆盖<a href="#deprecations_4.8">4.8</a>中<a href="#deprecations_4.8">弃用的</a>内置任务会产生错误。</p>
<div class="paragraph">
<p>尝试替换内置任务将产生类似于以下内容的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; Cannot add task 'wrapper' as a task with that name already exists.</pre>
</div>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Scala和Play</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>不再支持Play 2.2-请升级您使用的Play版本。</p>
</li>
<li>
<p>的<code>ScalaDocOptions.styleSheet</code>属性已删除— Scala 2.11.8及更高版本中的Scaladoc Ant任务不再支持此属性。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Kotlin DSL</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>现在，工件配置访问器的类型为<code>NamedDomainObjectProvider<Configuration></code>代替<code>Configuration</code></p>
</li>
<li>
<p><code>PluginAware.apply<T>(to)</code>被重命名<code>PluginAware.applyTo<T>(target)</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两项更改都可能导致脚本编译错误。请参阅<a href="https://github.com/gradle/kotlin-dsl/releases/tag/v1.0.0#breaking-changes">Gradle Kotlin DSL发行说明，</a>以获取更多信息以及如何修复因上述更改而损坏的构建。</p>
</div>
</dd>
<dt class="hdlist1">杂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>的<code>ConfigurableReport.setDestination(Object)</code>方法已删除-使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/reporting/ConfigurableReport.html#setDestination-java.io.File-">ConfigurableReport.setDestination（File）</a>代替。</p>
</li>
<li>
<p>的<code>Signature.setFile(File)</code>方法已删除— Gradle不支持更改生成的签名的输出文件。</p>
</li>
<li>
<p>唯读<code>Signature.toSignArtifact</code>属性已被删除-永远不应成为公共API的一部分。</p>
</li>
<li>
<p>的<code>@DeferredConfigurable</code>注释已删除。</p>
</li>
<li>
<p>方法<code>isDeferredConfigurable()</code>已从移除<code>ExtensionSchema</code> 。</p>
</li>
<li>
<p><code>IdeaPlugin.performPostEvaluationActions()</code>和<code>EclipsePlugin.performPostEvaluationActions()</code>已被删除。</p>
</li>
<li>
<p><code>The `BroadcastingCollectionEventRegister.getAddAction()</code>方法已删除，无法替代。</p>
</li>
<li>
<p>内置的<code>org.gradle.util</code>默认情况下，不再导入软件包。</p>
<div class="paragraph">
<p>理想情况下，您不应该使用此程序包中的类，但是，作为一种快速解决方案，您可以将显式导入添加到这些类的构建脚本中。</p>
</div>
</li>
<li>
<p>的<code>gradlePluginPortal()</code> <a href="#rel5.0:gradle_plugin_portal_metadata">默认情况下，</a>存储库<a href="#rel5.0:gradle_plugin_portal_metadata">不再查找没有POM的JAR</a> 。</p>
</li>
<li>
<p>Tooling API不能再使用Gradle 2.6以下的Gradle版本连接到构建。通过TestKit运行的构建也是如此。</p>
</li>
<li>
<p>Gradle 5.0需要最低版本的Tooling API客户端3.0。较旧的客户端库无法再使用Gradle 5.0运行构建。</p>
</li>
<li>
<p>IdeaModule Tooling API模型元素包含用于检索资源和测试资源的方法，因此已将这些元素从结果中删除。 <code>IdeaModule.getSourceDirs()</code>和<code>IdeaModule.getTestSourceDirs()</code> 。</p>
</li>
<li>
<p>在以前的Gradle版本中， <code>source</code>在<code>SourceTask</code>可从子类访问。情况不再如此，因为<code>source</code>字段现在声明为<code>private</code> 。</p>
</li>
<li>
<p>在Worker API中， <a href="#rel5.0:worker_api">不能再设置worker的工作目录</a> 。</p>
</li>
<li>
<p>与<a href="#rel5.0:dependency_constraints">依赖关系和版本约束</a>有关的行为更改可能会影响少量用户。</p>
</li>
<li>
<p><a href="#rel5.0:changes_to_default_task">对DefaultTask</a>上的<a href="#rel5.0:changes_to_default_task">属性工厂方法进行</a>了一些更改，这些更改可能会影响自定义任务的创建。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.10"><a class="anchor" href="#changes_4.10"></a> <a class="link" href="#changes_4.10">从4.9或更早版本升级</a></h4>
<div class="paragraph">
<p>如果您尚未安装4.9版，请跳至适用于当前Gradle版本的部分，然后逐步升级，直至到达此处。然后，在升级到Gradle 4.10时应用这些更改。</p>
</div>
<div class="sect4">
<h5 id="deprecated_classes_methods_and_properties"><a class="anchor" href="#deprecated_classes_methods_and_properties"></a> <a class="link" href="#deprecated_classes_methods_and_properties">不推荐使用的类，方法和属性</a></h5>
<div class="paragraph">
<p>按照API链接了解如何处理这些弃用（如果此处未提供其他信息）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TaskContainer.add()</code>和<code>TaskContainer.addAll()</code> -改用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html#create-java.lang.String-java.lang.Class-org.gradle.api.Action-">TaskContainer.create（）</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-java.lang.Class-org.gradle.api.Action-">TaskContainer.register（）</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_9"><a class="anchor" href="#potential_breaking_changes_9"></a> <a class="link" href="#potential_breaking_changes_9">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>Kotlin DSL中存在一些潜在的重大更改—请参阅该<a href="https://github.com/gradle/kotlin-dsl/releases/tag/v1.0-RC3">项目的发行说明中</a>的<em>“重大更改”</em>部分。</p>
</li>
<li>
<p>您不能再使用具有惰性任务配置的任何<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:beforeEvaluate(org.gradle.api.Action)">Project.beforeEvaluate（）</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:afterEvaluate(org.gradle.api.Action)">Project.afterEvaluate（）</a>方法，例如在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-java.lang.Class-org.gradle.api.Action-">TaskContainer.register（）</a>块内。</p>
</li>
<li>
<p><a href="#rel4.10:aws_s3_permissions">发布到AWS S3需要新权限</a> 。</p>
</li>
<li>
<p><a href="#">Java Gradle插件开发插件</a>使用的类<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/devel/tasks/PluginUnderTestMetadata.html">PluginUnderTestMetadata</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/devel/tasks/GeneratePluginDescriptors.html">GeneratePluginDescriptors</a>均已更新，可以使用提供程序API。</p>
<div class="paragraph">
<p>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html#set-T-">Property.set（）</a>方法修改其值，而不要使用标准的属性分配语法，除非您在Groovy构建脚本中这样做。在这种情况下，标准属性分配仍然有效。</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.9"><a class="anchor" href="#changes_4.9"></a> <a class="link" href="#changes_4.9">从4.8或更早版本升级</a></h4>
<div class="ulist">
<ul>
<li>
<p><a href="#rel4.9:lazy_task_creation">考虑尝试使用惰性API进行任务创建和配置</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_10"><a class="anchor" href="#potential_breaking_changes_10"></a> <a class="link" href="#potential_breaking_changes_10">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>您不能再将GPath语法与<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-">task.withType（）一起使用</a> 。</p>
<div class="paragraph">
<p>请改用<a href="https://docs.groovy-lang.org/latest/html/documentation/#_spread_operator">Groovy的传播算子</a> 。例如，您将替换<code>tasks.withType(JavaCompile).name</code>与<code>tasks.withType(JavaCompile)*.name</code> 。</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.8"><a class="anchor" href="#changes_4.8"></a> <a class="link" href="#changes_4.8">从4.7或更早版本升级</a></h4>
<div class="ulist">
<ul>
<li>
<p><a href="#rel4.8:switch_to_publishing_plugins">切换到Maven Publish和Ivy Publish插件</a></p>
</li>
<li>
<p><a href="#rel4.8:deferred_configuration">将延迟配置与发布插件一起使用</a></p>
</li>
<li>
<p><a href="#rel4.8:configure_internal_tasks">配置现有<code>wrapper</code>和<code>init</code>任务</a>而不是定义自己的<a href="#rel4.8:configure_internal_tasks">任务</a></p>
</li>
<li>
<p>如果当前正在为此目的使用插件或自定义解决方案，请考虑迁移到内置<a href="#">依赖项锁定机制</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_11"><a class="anchor" href="#potential_breaking_changes_11"></a> <a class="link" href="#potential_breaking_changes_11">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>现在，如果找不到指定的初始化脚本，构建将失败。</p>
</li>
<li>
<p><code>TaskContainer.remove()</code>现在实际上删除了给定的任务-一些插件可能不小心依赖了旧的行为。</p>
</li>
<li>
<p><a href="#rel4.8:pom_wildcard_exclusions">Gradle现在可以在Maven POM排除中使用隐式通配符</a> 。</p>
</li>
<li>
<p>Kotlin DSL现在遵守JSR-305封装注释。</p>
<div class="paragraph">
<p>这将导致根据JSR-305注释的某些类型在以前被视为不可为空的情况下被视为可为空。这可能会导致生成脚本中的编译错误。有关详细信息，请参阅<a href="https://github.com/gradle/kotlin-dsl/releases/tag/v0.17.4">相关的Kotlin DSL发行说明</a> 。</p>
</div>
</li>
<li>
<p>错误消息现在将定向到标准错误而不是标准输出，除非将控制台同时附加到标准输出和标准错误。这可能会影响抓取构建的普通控制台输出的工具。如果要从较早版本的Gradle升级，请忽略此更改。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="deprecations_4.8"><a class="anchor" href="#deprecations_4.8"></a> <a class="link" href="#deprecations_4.8">弃用</a></h5>
<div class="paragraph">
<p>在此版本之前，允许内部版本替换内置任务。<a href="https://docs.gradle.org/4.8/release-notes.html#overwriting-gradle's-built-in-tasks">不推荐使用此功能</a> 。</p>
</div>
<div class="paragraph">
<p>不应替换的内置任务的完整列表是： <code>wrapper</code> ， <code>init</code> ， <code>help</code> ， <code>tasks</code> ， <code>projects</code> ， <code>buildEnvironment</code> ， <code>components</code> ， <code>dependencies</code> ， <code>dependencyInsight</code> ， <code>dependentComponents</code> ， <code>model</code> ， <code>properties</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.7"><a class="anchor" href="#changes_4.7"></a> <a class="link" href="#changes_4.7">从4.6及更早版本升级</a></h4>
<div class="sect4">
<h5 id="potential_breaking_changes_12"><a class="anchor" href="#potential_breaking_changes_12"></a> <a class="link" href="#potential_breaking_changes_12">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>按照约定，Gradle现在将在根项目的<em>config / checkstyle</em>目录中查找Checkstyle配置文件。</p>
<div class="paragraph">
<p>除非您通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CheckstyleExtension.html#org.gradle.api.plugins.quality.CheckstyleExtension:configDir">checkstyle.configDir</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CheckstyleExtension.html#org.gradle.api.plugins.quality.CheckstyleExtension:config">checkstyle.config</a>显式配置它们的路径，否则子项目中的Checkstyle配置文件（旧的聚会场所）将被忽略。</p>
</div>
</li>
<li>
<p>Gradle <a href="#rel4.7:plain_console_output">普通控制台输出</a>的结构已更改，这可能会破坏抓取该输出的工具。</p>
</li>
<li>
<p>与编译，链接和安装相关的许多本机任务的API <a href="#rel:4.6:native_task_api_changes">发生了重大变化</a> 。</p>
</li>
<li>
<p>[Kotlin DSL]现在必须显式键入用于访问Gradle的构建属性的委托属性（例如，在<em>gradle.properties中</em>定义）。</p>
</li>
<li>
<p>[Kotlin DSL]声明一个<code>plugins {}</code>现在，嵌套作用域内的block会引发异常。</p>
</li>
<li>
<p>[Kotlin DSL]只有一个<code>pluginManagement {}</code>现在允许阻止。</p>
</li>
<li>
<p>缓存控制DSL由<code>org.gradle.api.artifacts.cache.*</code>接口不再可用。</p>
</li>
<li>
<p><code>getEnabledDirectoryReportDestinations()</code> ， <code>getEnabledFileReportDestinations()</code>和<code>getEnabledReportNames()</code>已全部从中移除<code>org.gradle.api.reporting.ReportContainer</code> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/StartParameter.html#getProjectProperties--">StartParameter.projectProperties</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/StartParameter.html#getSystemPropertiesArgs--">StartParameter.systemPropertiesArgs</a>现在返回不可变映射。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.6"><a class="anchor" href="#changes_4.6"></a> <a class="link" href="#changes_4.6">从4.5或更早版本升级</a></h4>
<div class="sect4">
<h5 id="deprecations_6"><a class="anchor" href="#deprecations_6"></a> <a class="link" href="#deprecations_6">弃用</a></h5>
<div id="rel4.6:annotation_processor_configuration" class="ulist">
<ul>
<li>
<p>您不应该将注释处理器放在编译类路径上，也不要使用<code>-processorpath</code>编译器参数。</p>
<div class="paragraph">
<p>它们应添加到<code>annotationProcessor</code>配置代替。如果您不想进行任何处理，但是编译类路径无意中包含了处理器（例如，作为您依赖的库的一部分），请使用<code>-proc:none</code>编译器参数忽略它。</p>
</div>
</li>
<li>
<p>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/process/CommandLineArgumentProvider.html">CommandLineArgumentProvider</a>代替<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/compile/CompilerArgumentProvider.html">CompilerArgumentProvider</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_13"><a class="anchor" href="#potential_breaking_changes_13"></a> <a class="link" href="#potential_breaking_changes_13">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>Java插件现在添加了<code><em>sourceSet</em>AnnotationProcessor</code>每个源集的配置，如果其中任何一个与您现有的配置相匹配，则可能会中断。我们建议您删除冲突的配置声明。</p>
</li>
<li>
<p>的<code>StartParameter.taskOutputCacheEnabled</code>属性已由<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/StartParameter.html#setBuildCacheEnabled-boolean-">StartParameter.setBuildCacheEnabled（boolean）</a>取代。</p>
</li>
<li>
<p>现在，Visual Studio集成仅为<a href="#rel4.6:visual_studio_single_solution">构建中的所有组件配置一个解决方案</a> 。</p>
</li>
<li>
<p>Gradle已用4.5.5版本替换了HttpClient 4.4.1。</p>
</li>
<li>
<p>Gradle现在捆绑了<code>kotlin-stdlib-jdk8</code>工件代替<code>kotlin-stdlib-jre8</code> 。这可能会影响您的构建。请参阅<a href="http://kotlinlang.org/docs/reference/whatsnew12.html#kotlin-standard-library-artifacts-and-split-packages">Kotlin文档</a>以了解更多详细信息。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.5"><a class="anchor" href="#changes_4.5"></a> <a class="link" href="#changes_4.5">从4.4或更早版本升级</a></h4>
<div class="ulist">
<ul>
<li>
<p>确保您具有<em>settings.gradle</em>文件：它避免了性能下降，并允许您设置根项目的名称。</p>
</li>
<li>
<p>Gradle现在忽略包含的构建（ <a href="#">复合构建</a> ）的构建缓存配置，而是对所有构建使用根构建的配置。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_14"><a class="anchor" href="#potential_breaking_changes_14"></a> <a class="link" href="#potential_breaking_changes_14">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>两个超载<code>ValidateTaskProperties.setOutputFile()</code>方法已删除。当从构建脚本访问任务时，它们将被自动生成的setter替换，但是构建脚本之外的插件和其他代码不会出现这种情况。</p>
</li>
<li>
<p>Maven Publish插件现在可以生成更完整的maven-metadata.xml文件，包括维护以下列表： <code><snapshotVersion></code>元素。一些旧版本的Maven可能无法使用此元数据。</p>
</li>
<li>
<p><a href="#rel4.5:http_build_cache_no_follow_redirects"><code>HttpBuildCache</code>不再遵循重定向</a> 。</p>
</li>
<li>
<p>的<code>Depend</code>任务类型已被删除。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（Object）</a>不再规范不区分大小写的文件系统上文件路径的大小写。现在，在这种情况下，它会忽略大小写，并且不会影响文件系统。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/ListProperty.html">ListProperty</a>不再扩展<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">Property</a> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.4"><a class="anchor" href="#changes_4.4"></a> <a class="link" href="#changes_4.4">从4.3或更早版本升级</a></h4>
<div class="sect4">
<h5 id="potential_breaking_changes_15"><a class="anchor" href="#potential_breaking_changes_15"></a> <a class="link" href="#potential_breaking_changes_15">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>现在，非JVM测试任务以及<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">Test</a>扩展了<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.AbstractTestTask.html">AbstractTestTask</a> 。插件应注意配置所有类型的任务<code>AbstractTestTask</code>因为这。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html#org.gradle.plugins.ide.eclipse.model.EclipseClasspath:defaultOutputDir">EclipseClasspath.defaultOutputDir</a>的默认输出位置已从更改为<em><code>$projectDir</code> / bin</em>到<em><code>$projectDir</code> / bin / default</em> 。</p>
</li>
<li>
<p>已弃用<code>InstallExecutable.setDestinationDir(Provider)</code>已删除-使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.InstallExecutable.html#org.gradle.nativeplatform.tasks.InstallExecutable:installDirectory">InstallExecutable.installDirectory</a>代替。</p>
</li>
<li>
<p>已弃用<code>InstallExecutable.setExecutable(Provider)</code>已删除-使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.InstallExecutable.html#org.gradle.nativeplatform.tasks.InstallExecutable:executableFile">InstallExecutable.executableFile</a>代替。</p>
</li>
<li>
<p>Gradle将不再喜欢在路径上找到的Visual Studio版本，而不是其他位置。现在是不得已了。</p>
<div class="paragraph">
<p>您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html#org.gradle.nativeplatform.toolchain.VisualCpp:installDir">VisualCpp.setInstallDir（Object）</a>指定所需的Visual Studio版本的安装目录来绕过工具链发现。</p>
</div>
</li>
<li>
<p><code>pluginManagement.repositories</code>现在是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html">RepositoryHandler</a>类型，而不是<code>PluginRepositoriesSpec</code> ，已被删除。</p>
</li>
<li>
<p>依赖关系解决期间的5xx HTTP错误现在将触发构建中的异常。</p>
</li>
<li>
<p>嵌入式Apache Ant已从1.9.6升级到1.9.9。</p>
</li>
<li>
<p><a href="#rel4.4:security_library_upgrades">Gradle使用的一些第三方库已升级，</a>可以解决安全问题。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.3"><a class="anchor" href="#changes_4.3"></a> <a class="link" href="#changes_4.3">从4.2或更早版本升级</a></h4>
<div class="ulist">
<ul>
<li>
<p>的<code>plugins {}</code>现在，block可以<a href="#sec:subprojects_plugins_dsl">在子项目</a>中<a href="#sec:subprojects_plugins_dsl">使用，</a>也可以<a href="#sec:buildsrc_plugins_dsl">在<em>buildSrc</em>目录中</a>用于<a href="#sec:buildsrc_plugins_dsl">插件</a> 。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="other_deprecations"><a class="anchor" href="#other_deprecations"></a> <a class="link" href="#other_deprecations">其他折旧</a></h5>
<div class="ulist">
<ul>
<li>
<p>您不应再通过Tooling API运行2.6之前的Gradle版本。</p>
</li>
<li>
<p>您不应再通过比3.0更旧版本的Tooling API运行任何版本的Gradle。</p>
</li>
<li>
<p>您不应再链接<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputs.html#property-java.lang.String-java.lang.Object-">TaskInputs.property（String，Object）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputs.html#properties-java.util.Map-">TaskInputs.properties（Map）</a>方法。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_16"><a class="anchor" href="#potential_breaking_changes_16"></a> <a class="link" href="#potential_breaking_changes_16">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/DefaultTask.html#newOutputDirectory--">DefaultTask.newOutputDirectory（）</a>现在返回一个<code>DirectoryProperty</code>代替<code>DirectoryVar</code> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/DefaultTask.html#newOutputFile--">DefaultTask.newOutputFile（）</a>现在返回一个<code>RegularFileProperty</code>代替<code>RegularFileVar</code> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/DefaultTask.html#newInputFile--">DefaultTask.newInputFile（）</a>现在返回一个<code>RegularFileProperty</code>代替<code>RegularFileVar</code> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html#getBuildDirectory--">ProjectLayout.buildDirectory</a>现在返回一个<code>DirectoryProperty</code>代替<code>DirectoryVar</code> 。</p>
</li>
<li>
<p>现在是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask.html#org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask:compilerArgs">AbstractNativeCompileTask.compilerArgs</a>类型<code>ListProperty<String></code>代替<code>List<String></code> 。</p>
</li>
<li>
<p>现在， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask.html#org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask:objectFileDir">AbstractNativeCompileTask.objectFileDir</a>是类型<code>DirectoryProperty</code>代替<code>File</code> 。</p>
</li>
<li>
<p>现在是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.AbstractLinkTask.html#org.gradle.nativeplatform.tasks.AbstractLinkTask:linkerArgs">AbstractLinkTask.linkerArgs</a>类型<code>ListProperty<String></code>代替<code>List<String></code> 。</p>
</li>
<li>
<p><code>TaskDestroyables.getFiles()</code>不再是公共API的一部分。</p>
</li>
<li>
<p>现在，依赖项的版本范围重叠会导致Gradle选择一个满足所有声明范围的版本。</p>
<div class="paragraph">
<p>例如，如果对<code>some-module</code>找到的版本范围为<code>[3,6]</code>以及与<code>[4,8]</code> ，Gradle现在选择版本6而不是版本8。先前的行为是选择8。</p>
</div>
</li>
<li>
<p>元素的顺序<code>Iterable</code>标有的属性<code>@OutputFiles</code>要么<code>@OutputDirectories</code>现在很重要。如果顺序更改，则该属性将不再被认为是最新的。</p>
<div class="paragraph">
<p>优先使用单独的属性<code>@OutputFile</code> / <code>@OutputDirectory</code>注释或使用<code>Map</code>具有的属性<code>@OutputFiles</code> / <code>@OutputDirectories</code>代替。</p>
</div>
</li>
<li>
<p>当存在可以检查的另一个存储库时，Gradle将不再忽略该存储库中的依赖项解决错误。依赖关系解析将失败。这导致相对于分辨率结果更具确定性的行为。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.2"><a class="anchor" href="#changes_4.2"></a> <a class="link" href="#changes_4.2">从4.1或更早版本升级</a></h4>
<div class="sect4">
<h5 id="potential_breaking_changes_17"><a class="anchor" href="#potential_breaking_changes_17"></a> <a class="link" href="#potential_breaking_changes_17">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>的<code>withPathSensitivity()</code> <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskFilePropertyBuilder.html">TaskFilePropertyBuilder</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskOutputFilePropertyBuilder.html">TaskOutputFilePropertyBuilder</a>上的方法已删除。</p>
</li>
<li>
<p>捆绑<code>bndlib</code>已从3.2.0升级到3.4.0。</p>
</li>
<li>
<p>FindBugs插件不再从其分析中呈现进度信息。如果您以任何方式依赖该输出，都可以使用<em>FindBugs.showProgress</em>启用它。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_4.1"><a class="anchor" href="#changes_4.1"></a> <a class="link" href="#changes_4.1">从4.0升级</a></h4>
<div class="ulist">
<ul>
<li>
<p>考虑使用新的<a href="#worker_api">Worker API</a>来使构建中的工作单元并行运行。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="deprecated_classes_methods_and_properties_2"><a class="anchor" href="#deprecated_classes_methods_and_properties_2"></a> <a class="link" href="#deprecated_classes_methods_and_properties_2">不推荐使用的类，方法和属性</a></h5>
<div class="paragraph">
<p>按照API链接了解如何处理这些弃用（如果此处未提供其他信息）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Nullable.html">可空</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="potential_breaking_changes_18"><a class="anchor" href="#potential_breaking_changes_18"></a> <a class="link" href="#potential_breaking_changes_18">潜在的重大变化</a></h5>
<div class="ulist">
<ul>
<li>
<p>现在，与Java项目具有<a href="#sub:project_dependencies">项目依赖性</a>的非Java项目会消耗<code>runtimeElements</code>默认配置，而不是<code>default</code>组态。</p>
<div class="paragraph">
<p>要覆盖此行为，您可以显式声明要在项目依赖项中使用的配置。例如： <code>project(path: ':myJavaProject', configuration: 'default')</code> 。</p>
</div>
</li>
<li>
<p>默认的Zinc编译器从0.3.13升级到0.3.15。</p>
</li>
<li>
<p>[Kotlin DSL]基础包从改名<code>org.gradle.script.lang.kotlin</code>至<code>org.gradle.kotlin.dsl</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="changes_in_detail"><a class="anchor" href="#changes_in_detail"></a> <a class="link" href="#changes_in_detail">细节变化</a></h4>
<div class="sect4">
<h5 id="rel5.0:default_memory_settings"><a class="anchor" href="#rel5.0:default_memory_settings"></a> <a class="link" href="#rel5.0:default_memory_settings">[5.0]默认内存设置已更改</a></h5>
<div class="paragraph">
<p>现在，命令行客户端从64MB的堆开始，而不是1GB。这可能会影响使用以下命令直接在客户端VM内部运行的内部版本<code>--no-daemon</code>模式。我们不鼓励使用<code>--no-daemon</code> ，但如果必须使用它，则可以使用<code>GRADLE_OPTS</code>环境变量。</p>
</div>
<div class="paragraph">
<p>Gradle守护程序现在从512MB的堆而不是1GB的堆开始。大型项目可能必须使用<a href="https://docs.gradle.org/current/userguide/build_environment.html#sec:configuring_jvm_memory"><code>org.gradle.jvmargs</code></a>属性。</p>
</div>
<div class="paragraph">
<p>现在，所有工作程序（包括编译器和测试执行程序）都以512MB的堆开始。先前的默认值为物理内存的1/4。大型项目可能必须在相关任务上增加此设置，例如<a href="https://docs.gradle.org/current/userguide/build_environment.html#example_set_java_compile_options_for_javacompile_tasks"><code>JavaCompile</code></a>要么<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.testing.Test.html"><code>Test</code></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:default_tool_versions"><a class="anchor" href="#rel5.0:default_tool_versions"></a> <a class="link" href="#rel5.0:default_tool_versions">[5.0]代码质量插件的新默认版本</a></h5>
<div class="paragraph">
<p>以下代码质量插件的默认工具版本已更新：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://checkstyle.sourceforge.net">Checkstyle插件</a>现在默认使用<a href="http://checkstyle.sourceforge.net/releasenotes.html#Release_8.12">8.12</a>而不是6.19。</p>
</li>
<li>
<p>现在， <a href="http://codenarc.sourceforge.net">CodeNarc插件</a>默认使用<a href="https://github.com/CodeNarc/CodeNarc/blob/master/CHANGELOG.md#version-121-aug-2018">1.2.1</a>而不是1.1。</p>
</li>
<li>
<p><a href="https://www.jacoco.org/jacoco/">JaCoCo插件</a>现在默认使用<a href="https://www.jacoco.org/jacoco/trunk/doc/changes.html">0.8.2</a>而不是0.8.1。</p>
</li>
<li>
<p>现在， <a href="https://pmd.github.io/">PMD插件</a>默认使用<a href="https://pmd.github.io/pmd-6.8.0/pmd_release_notes.html#30-september-2018---680">6.8.0</a>而不是5.6.1。</p>
<div class="paragraph">
<p>此外，默认规则集已从现已弃用的版本更改为<code>java-basic</code>至<code>category/java/errorprone.xml</code> 。</p>
</div>
<div class="paragraph">
<p>但是，我们建议显式配置规则集。</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:library_upgrades"><a class="anchor" href="#rel5.0:library_upgrades"></a> <a class="link" href="#rel5.0:library_upgrades">[5.0]库升级</a></h5>
<div class="paragraph">
<p>Gradle使用的几个库已升级：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Groovy从2.4.15升级到<a href="https://groovy-lang.org/releasenotes/groovy-2.5.html">2.5.4</a> 。</p>
</li>
<li>
<p>Ant已从1.9.11升级到<a href="https://archive.apache.org/dist/ant/RELEASE-NOTES-1.9.13.html">1.9.13</a> 。</p>
</li>
<li>
<p>用于访问S3支持的Maven / Ivy存储库的AWS开发工具包已从1.11.267升级到<a href="https://github.com/aws/aws-sdk-java/blob/master/CHANGELOG.md#111407-2018-09-11">1.11.407</a> 。</p>
</li>
<li>
<p>OSGi插件使用的BND库已从3.4.0升级到<a href="https://github.com/bndtools/bnd/wiki/Changes-in-4.0.0">4.0.0</a> 。</p>
</li>
<li>
<p>用于访问Google Cloud Storage支持的Maven / Ivy存储库的Google Cloud Storage JSON API客户端库已从v1-rev116-1.23.0升级到v1-rev136-1.25.0。</p>
</li>
<li>
<p>Ivy已从2.2.0升级到<a href="http://ant.apache.org/ivy/history/2.3.0/release-notes.html">2.3.0</a> 。</p>
</li>
<li>
<p>JUnit平台库由<code>Test</code>任务已从1.0.3升级到1.3.1。</p>
</li>
<li>
<p>用于访问Maven存储库的Maven Wagon库已从2.4升级到3.0.0。</p>
</li>
<li>
<p>SLF4J已从1.7.16升级到<a href="https://www.slf4j.org/news.html">1.7.25</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:dependency_constraints"><a class="anchor" href="#rel5.0:dependency_constraints"></a> <a class="link" href="#rel5.0:dependency_constraints">[5.0]改进了对依赖关系和版本限制的支持</a></h5>
<div class="paragraph">
<p>通过Gradle 4.x发布流，新<code>@Incubating</code>功能已添加到依赖关系解析引擎。其中包括复杂的版本限制（ <code>prefer</code> ， <code>strictly</code> ， <code>reject</code> ），依赖项约束，以及<code>platform</code>依赖性。</p>
</div>
<div class="paragraph">
<p>如果您一直在使用<code>IMPROVED_POM_SUPPORT</code>功能预览，使用约束条件或偏好，拒绝和其他特定版本指示，然后确保对依赖关系解决方案的结果进行了仔细的研究。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:bom_import"><a class="anchor" href="#rel5.0:bom_import"></a> <a class="link" href="#rel5.0:bom_import">[5.0] BOM导入</a></h5>
<div class="paragraph">
<p>Gradle现在提供了对导入物料清单（BOM）文件的支持，这些文件实际上是使用<code><dependencyManagement></code>部分以控制直接和传递依赖项的版本。您需要做的就是将POM声明为<code>platform</code>依赖性。</p>
</div>
<div class="paragraph">
<p>以下示例选择了<code>gson</code>和<code>dom4j</code>声明的Spring Boot BOM的依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>dependencies {
    // import a BOM
    implementation platform('org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE')

    // define dependencies without versions
    implementation 'com.google.code.gson:gson'
    implementation 'dom4j:dom4j'
}</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:pom_compile_runtime_separation"><a class="anchor" href="#rel5.0:pom_compile_runtime_separation"></a> <a class="link" href="#rel5.0:pom_compile_runtime_separation">[5.0]使用POM时，将编译和运行时依赖项分开</a></h5>
<div class="paragraph">
<p>从Gradle 1.0开始，Java编译类路径中已包含运行时范围的依赖项，它具有一些缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>编译类路径比其所需的要大得多，从而减慢了编译速度。</p>
</li>
<li>
<p>编译类路径包括不影响编译的运行时范围文件，当这些文件更改时，会导致不必要的重新编译。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过这种新行为，Java和Java库插件都可以<a href="#sec:java_library_separation">实现编译范围和运行时范围</a>的<a href="#sec:java_library_separation">分离</a> 。这意味着编译类路径仅包含编译范围的依赖关系，而运行时类路径也添加了运行时范围的依赖关系。如果您使用Gradle开发和发布Java库，而两者之间的分隔是<code>api</code>和<code>implementation</code>依赖关系反映在已发布的范围中。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:changes_to_default_task"><a class="anchor" href="#rel5.0:changes_to_default_task"></a> <a class="link" href="#rel5.0:changes_to_default_task">[5.0]更改了属性工厂方法<code>DefaultTask</code></a></h5>
<div class="sect5">
<h6 id="property_factory_methods_on_defaulttask_are_now_final"><a class="anchor" href="#property_factory_methods_on_defaulttask_are_now_final"></a> <a class="link" href="#property_factory_methods_on_defaulttask_are_now_final">属性工厂方法<code>DefaultTask</code>现在是最终的</a></h6>
<div class="paragraph">
<p>属性工厂方法如<code>newInputFile()</code>旨在从扩展类型的构造函数中调用<code>DefaultTask</code> 。这些方法现在是最终方法，以避免子类覆盖这些方法并使用未初始化的状态。</p>
</div>
</div>
<div class="sect5">
<h6 id="inputs_and_outputs_are_not_automatically_registered"><a class="anchor" href="#inputs_and_outputs_are_not_automatically_registered"></a> <a class="link" href="#inputs_and_outputs_are_not_automatically_registered">输入和输出不会自动注册</a></h6>
<div class="paragraph">
<p>这些方法返回的Property实例不再自动注册为任务的输入或输出。需要以常规方式将Property实例声明为输入或输出，例如附加注释，例如<code>@OutputFile</code>或使用运行时API来注册属性。</p>
</div>
<div class="paragraph">
<p>例如，您以前可能使用以下语法，并且将两个outputFile实例都注册为声明的输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">MyTask</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// note: no annotation here</span>
    <span class="directive">final</span> RegularFileProperty outputFile = newOutputFile()
}

task myOtherTask {
    <span class="keyword">def</span> outputFile = newOutputFile()
    doLast { ... }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class MyTask : DefaultTask() {
    // note: no annotation here
    val outputFile: RegularFileProperty = newOutputFile()
}

task(&quot;myOtherTask&quot;) {
    val outputFile = newOutputFile()
    doLast { ... }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在您必须明确注册<code>outputFile</code> ， 像这样：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">MyTask</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@OutputFile</span> <span class="comment">// property needs an annotation</span>
    <span class="directive">final</span> RegularFileProperty outputFile = project.objects.fileProperty()
}

task myOtherTask {
    <span class="keyword">def</span> outputFile = project.objects.fileProperty()
    outputs.file(outputFile) <span class="comment">// or to be registered using the runtime API</span>
    doLast { ... }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class MyTask : DefaultTask() {
    @OutputFile // property needs an annotation
    val outputFile: RegularFileProperty = project.objects.fileProperty()
}

task(&quot;myOtherTask&quot;) {
    val outputFile = project.objects.fileProperty()
    outputs.file(outputFile) // or to be registered using the runtime API
    doLast { ... }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:jaxb_and_java9"><a class="anchor" href="#rel5.0:jaxb_and_java9"></a> <a class="link" href="#rel5.0:jaxb_and_java9">[5.0] Gradle现在捆绑了Java 9和更高版本的JAXB</a></h5>
<div class="paragraph">
<p>为了使用S3支持的工件存储库，您以前必须添加<code>--add-modules java.xml.bind</code>至<code>org.gradle.jvmargs</code>在Java 9及更高版本上运行时。</p>
</div>
<div class="paragraph">
<p>由于Java 11不再包含<code>java.xml.bind</code>模块，Gradle现在捆绑了JAXB 2.3.1（ <code>com.sun.xml.bind:jaxb-impl</code> ），并在Java 9及更高版本上使用它。</p>
</div>
<div class="paragraph">
<p>请删除<code>--add-modules java.xml.bind</code>来自的选项<code>org.gradle.jvmargs</code> （如果已设置）。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:gradle_plugin_portal_metadata"><a class="anchor" href="#rel5.0:gradle_plugin_portal_metadata"></a> <a class="link" href="#rel5.0:gradle_plugin_portal_metadata">[5.0] <code>gradlePluginPortal()</code>默认情况下，存储库不再查找没有POM的JAR</a></h5>
<div class="paragraph">
<p>有了这种新的行为，如果在插件中找到了插件或插件的传递依赖项， <code>gradlePluginPortal()</code>存储库中没有Maven POM，它将无法解决。</p>
</div>
<div class="paragraph">
<p>在没有POM的情况下发布到Maven存储库的工件应得到修复。如果遇到此类工件，请让插件或库作者发布具有适当元数据的新版本。</p>
</div>
<div class="paragraph">
<p>如果您遇到了错误的插件，可以通过重新启用JAR作为该插件的元数据源来解决<code>gradlePluginPortal()</code>资料库：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">pluginManagement {
    repositories {
        gradlePluginPortal().tap {
            metadataSources {
                mavenPom()
                artifact()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">pluginManagement {
    repositories {
        gradlePluginPortal().apply {
            (this as MavenArtifactRepository).metadataSources {
                mavenPom()
                artifact()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:java_library_distribution_plugin"><a class="anchor" href="#rel5.0:java_library_distribution_plugin"></a> <a class="link" href="#rel5.0:java_library_distribution_plugin">Java库分发插件利用Java库插件</a></h5>
<div class="paragraph">
<p><a href="#">Java库分发插件</a>现在基于<a href="#">Java库插件</a>而不是<a href="#">Java插件</a> 。</p>
</div>
<div class="paragraph">
<p>此外，该插件创建的默认发行版将包含<code>runtimeClasspath</code>配置而不是不推荐使用<code>runtime</code>组态。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:configuration_avoidance"><a class="anchor" href="#rel5.0:configuration_avoidance"></a> <a class="link" href="#rel5.0:configuration_avoidance">配置回避API禁止常见的配置错误</a></h5>
<div class="paragraph">
<p>Gradle 4.9中引入的<a href="task_configuration_avoidance.html">避免配置API</a>使您可以避免创建和配置从未使用过的任务。</p>
</div>
<div class="paragraph">
<p>使用现有的API，此示例添加了两个任务（ <code>foo</code>和<code>bar</code> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>) {
    tasks.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.create(&quot;foo&quot;) {
    tasks.create(&quot;bar&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将其转换为使用新的API时，会发生一些令人惊讶的事情： <code>bar</code>不存在。新的API仅在必要时执行配置操作，因此<code>register()</code>为了任务<code>bar</code>仅在以下情况下执行<code>foo</code>已配置。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.register(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>) {
    tasks.register(<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>) <span class="comment">// WRONG</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;foo&quot;) {
    tasks.register(&quot;bar&quot;) // WRONG
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了避免这种情况，Gradle现在可以检测到这种情况，并防止修改基础容器（通过<code>create()</code>要么<code>register()</code> ）时使用新的API。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel5.0:worker_api"><a class="anchor" href="#rel5.0:worker_api"></a> <a class="link" href="#rel5.0:worker_api">[5.0] Worker API：无法再设置工人的工作目录</a></h5>
<div class="paragraph">
<p>由于JDK 11不再支持更改正在运行的进程的工作目录，因此现在禁止通过其fork选项设置工作程序的工作目录。</p>
</div>
<div class="paragraph">
<p>现在，所有工作人员都使用相同的工作目录来启用重用。</p>
</div>
<div class="paragraph">
<p>请改为将文件和目录作为参数传递。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel4.10:aws_s3_permissions"><a class="anchor" href="#rel4.10:aws_s3_permissions"></a> <a class="link" href="#rel4.10:aws_s3_permissions">[4.10]发布到AWS S3需要新权限</a></h5>
<div class="paragraph">
<p>S3存储库传输协议允许Gradle将工件发布到AWS S3存储桶。从此版本开始，每个上传到S3存储桶的工件都将配备<code>bucket-owner-full-control</code>罐头ACL。确保用于发布工件的AWS账户具有<code>s3:PutObjectAcl</code>和<code>s3:PutObjectVersionAcl</code>权限，否则上传将失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">Version</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">2012-10-17</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">Statement</span><span class="delimiter">&quot;</span></span>:[
        <span class="error">/</span><span class="error">/</span> <span class="error">.</span><span class="error">.</span><span class="error">.</span>
        {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">Effect</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">Allow</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>:[
                <span class="string"><span class="delimiter">&quot;</span><span class="content">s3:PutObject</span><span class="delimiter">&quot;</span></span>, <span class="error">/</span><span class="error">/</span> <span class="error">n</span><span class="error">e</span><span class="error">c</span><span class="error">e</span><span class="error">s</span><span class="error">s</span><span class="error">a</span><span class="error">r</span><span class="error">y</span> <span class="error">f</span><span class="error">o</span><span class="error">r</span> <span class="error">u</span><span class="error">p</span><span class="error">l</span><span class="error">o</span><span class="error">a</span><span class="error">d</span><span class="error">i</span><span class="error">n</span><span class="error">g</span> <span class="error">o</span><span class="error">b</span><span class="error">j</span><span class="error">e</span><span class="error">c</span><span class="error">t</span><span class="error">s</span>
                <span class="string"><span class="delimiter">&quot;</span><span class="content">s3:PutObjectAcl</span><span class="delimiter">&quot;</span></span>, <span class="error">/</span><span class="error">/</span> <span class="error">r</span><span class="error">e</span><span class="error">q</span><span class="error">u</span><span class="error">i</span><span class="error">r</span><span class="error">e</span><span class="error">d</span> <span class="error">s</span><span class="error">t</span><span class="error">a</span><span class="error">r</span><span class="error">t</span><span class="error">i</span><span class="error">n</span><span class="error">g</span> <span class="error">w</span><span class="error">i</span><span class="error">t</span><span class="error">h</span> <span class="error">t</span><span class="error">h</span><span class="error">i</span><span class="error">s</span> <span class="error">r</span><span class="error">e</span><span class="error">l</span><span class="error">e</span><span class="error">a</span><span class="error">s</span><span class="error">e</span>
                <span class="string"><span class="delimiter">&quot;</span><span class="content">s3:PutObjectVersionAcl</span><span class="delimiter">&quot;</span></span> <span class="error">/</span><span class="error">/</span> <span class="error">i</span><span class="error">f</span> <span class="error">S</span><span class="integer">3</span> <span class="error">b</span><span class="error">u</span><span class="error">c</span><span class="error">k</span><span class="error">e</span><span class="error">t</span> <span class="error">v</span><span class="error">e</span><span class="error">r</span><span class="error">s</span><span class="error">i</span><span class="error">o</span><span class="error">n</span><span class="error">i</span><span class="error">n</span><span class="error">g</span> <span class="error">i</span><span class="error">s</span> <span class="error">e</span><span class="error">n</span><span class="error">a</span><span class="error">b</span><span class="error">l</span><span class="error">e</span><span class="error">d</span>
            ],
            <span class="key"><span class="delimiter">&quot;</span><span class="content">Resource</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">arn:aws:s3:::myCompanyBucket/*</span><span class="delimiter">&quot;</span></span>
        }
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="#sub:s3_cross_account">AWS S3跨账户访问</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel4.9:lazy_task_creation"><a class="anchor" href="#rel4.9:lazy_task_creation"></a> <a class="link" href="#rel4.9:lazy_task_creation">[4.9]考虑尝试使用惰性API进行任务创建和配置</a></h5>
<div class="paragraph">
<p>Gradle 4.9引入了一种新的方式来创建和配置惰性工作的任务。如果将这种方法用于配置成本很高的任务，或者有许多任务，那么当这些任务不运行时，构建配置时间将大大减少。</p>
</div>
<div class="paragraph">
<p>您可以在“ <a href="task_configuration_avoidance.html#task_configuration_avoidance">避免任务配置”</a>一章中了解有关延迟创建任务的更多信息。您还可以在<a href="https://blog.gradle.org/preview-avoiding-task-configuration-time">此博客文章中</a>了解此新功能的背景。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel4.8:switch_to_publishing_plugins"><a class="anchor" href="#rel4.8:switch_to_publishing_plugins"></a> <a class="link" href="#rel4.8:switch_to_publishing_plugins">[4.8]切换到Maven Publish和Ivy Publish插件</a></h5>
<div class="paragraph">
<p>现在，发布插件已经稳定了，我们建议您从标准Java项目（即基于<a href="#java_plugin">Java Plugin的</a>项目）的<a href="artifact_management.html#artifact_management">旧发布</a>机制中迁移。其中包括使用以下任何一项的项目： <a href="#java_library_plugin">Java库插件</a> ， <a href="#application_plugin">应用程序插件</a>或<a href="#war_plugin">War插件</a> 。</p>
</div>
<div class="paragraph">
<p>要使用新方法，只需替换任何<code>upload<Conf></code>配置与<code>publishing {}</code>块。有关更多信息，请参见<a href="#publishing_overview">发布概述一章</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel4.8:deferred_configuration"><a class="anchor" href="#rel4.8:deferred_configuration"></a> <a class="link" href="#rel4.8:deferred_configuration">[4.8]使用延迟配置发布插件</a></h5>
<div class="paragraph">
<p>在Gradle 4.8之前， <code>publishing {}</code>隐式地将块视为在评估项目后就执行了其中的所有逻辑。这令人困惑，因为它是唯一以这种方式运行的块。作为Gradle 4.8稳定工作的一部分，我们将弃用此行为，并要求所有用户迁移其内部版本。</p>
</div>
<div class="paragraph">
<p>通过将以下内容添加到设置文件中，可以打开新的稳定行为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">enableFeaturePreview(<span class="string"><span class="delimiter">'</span><span class="content">STABLE_PUBLISHING</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">enableFeaturePreview(&quot;STABLE_PUBLISHING&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们建议使用本地存储库进行测试运行，以查看所有工件是否仍具有预期的坐标。在大多数情况下，一切都应该像以前一样工作，您已完成。但是，您的发布块可能依赖于隐式延迟的配置，尤其是如果它依赖于在构建的配置阶段可能更改的值。</p>
</div>
<div class="paragraph">
<p>例如，在新行为下，以下逻辑假定<code>jar.archiveBaseName</code>之后不会改变<code>artifactId</code>设置为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    publishing {
        publications {
            mavenJava {
                from components.java
                artifactId = jar.archiveBaseName
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    publishing {
        publications {
            named&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
                from(components[&quot;java&quot;])
                artifactId = tasks.jar.get().archiveBaseName.get()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果该假设不正确或将来可能不正确，则<code>artifactId</code>必须在<code>afterEvaluate {}</code>阻止，像这样：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    publishing {
        publications {
            mavenJava {
                from components.java
                afterEvaluate {
                    artifactId = jar.archiveBaseName
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    publishing {
        publications {
            named&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
                from(components[&quot;java&quot;])
                afterEvaluate {
                    artifactId = tasks.jar.get().archiveBbaseName.get()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rel4.8:configure_internal_tasks"><a class="anchor" href="#rel4.8:configure_internal_tasks"></a> <a class="link" href="#rel4.8:configure_internal_tasks">[4.8]配置现有<code>wrapper</code>和<code>init</code>任务</a></h5>
<div class="paragraph">
<p>您不再应该定义自己的<code>wrapper</code>和<code>init</code>任务。而是配置现有任务，例如，通过转换以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task wrapper(<span class="key">type</span>: Wrapper) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">task&lt;Wrapper&gt;(&quot;wrapper&quot;) {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对此：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">wrapper {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.wrapper {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rel4.8:pom_wildcard_exclusions"><a class="anchor" href="#rel4.8:pom_wildcard_exclusions"></a> <a class="link" href="#rel4.8:pom_wildcard_exclusions">[4.8] Gradle现在可以在Maven POM排除中使用隐式通配符</a></h5>
<div class="paragraph">
<p>如果Maven POM中的排除项丢失了<code>groupId</code>要么<code>artifactId</code> ，Gradle用来忽略排除。现在，缺少的元素被视为隐式通配符-例如<code><groupId>*</groupId></code> -这意味着您的某些依赖现在可能已被排除在以前的位置。</p>
</div>
<div class="paragraph">
<p>您将需要显式声明所需的任何缺少的依赖项。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel4.7:plain_console_output"><a class="anchor" href="#rel4.7:plain_console_output"></a> <a class="link" href="#rel4.7:plain_console_output">[4.7]更改了Gradle普通控制台输出的结构</a></h5>
<div class="paragraph">
<p>普通控制台模式现在与格式丰富的控制台一致地格式化输出，这意味着输出格式已更改。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>现在，即使其他任务与其并行执行，由给定任务产生的输出也可以分组在一起。</p>
</li>
<li>
<p>任务执行标头以“>”任务前缀打印。</p>
</li>
<li>
<p>在生成执行过程中产生的所有输出都将写入标准输出文件句柄。这包括写入System.err的消息，除非您要将标准错误重定向到文件或任何其他非控制台目标。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这可能会破坏从普通控制台输出中抓取详细信息的工具。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel:4.6:native_task_api_changes"><a class="anchor" href="#rel:4.6:native_task_api_changes"></a> <a class="link" href="#rel:4.6:native_task_api_changes">[4.6]与编译，链接和安装相关的本机任务的API更改</a></h5>
<div class="paragraph">
<p>与编译，链接和安装本机库和应用程序有关的许多任务已转换为Provider API，以便它们支持<a href="#lazy_configuration">延迟配置</a> 。此转换对任务的API进行了一些重大更改，以使它们与Provider API的约定相匹配。</p>
</div>
<div class="paragraph">
<p>以下任务已更改：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.AbstractLinkTask.html">AbstractLinkTask</a>及其子类</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>getDestinationDir()</code>被替换为<code>getDestinationDirectory()</code> 。</p>
</li>
<li>
<p><code>getBinaryFile()</code> ， <code>getOutputFile()</code>被替换为<code>getLinkedFile()</code> 。</p>
</li>
<li>
<p><code>setOutputFile(File)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>setOutputFile(Provider)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>getTargetPlatform()</code>更改为返回一个<code>Property</code> 。</p>
</li>
<li>
<p><code>setTargetPlatform(NativePlatform)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>getToolChain()</code>更改为返回一个<code>Property</code> 。</p>
</li>
<li>
<p><code>setToolChain(NativeToolChain)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.CreateStaticLibrary.html">CreateStaticLibrary</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>getOutputFile()</code>更改为返回一个<code>Property</code> 。</p>
</li>
<li>
<p><code>setOutputFile(File)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>setOutputFile(Provider)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>getTargetPlatform()</code>更改为返回一个<code>Property</code> 。</p>
</li>
<li>
<p><code>setTargetPlatform(NativePlatform)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>getToolChain()</code>更改为返回一个<code>Property</code> 。</p>
</li>
<li>
<p><code>setToolChain(NativeToolChain)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>getStaticLibArgs()</code>更改为返回一个<code>ListProperty</code> 。</p>
</li>
<li>
<p><code>setStaticLibArgs(List)</code>去掉了。使用<code>ListProperty.set()</code>代替。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.InstallExecutable.html">InstallExecutable</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>getSourceFile()</code>被替换为<code>getExecutableFile()</code> 。</p>
</li>
<li>
<p><code>getPlatform()</code>被替换为<code>getTargetPlatform()</code> 。</p>
</li>
<li>
<p><code>setTargetPlatform(NativePlatform)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
<li>
<p><code>getToolChain()</code>更改为返回一个<code>Property</code> 。</p>
</li>
<li>
<p><code>setToolChain(NativeToolChain)</code>去掉了。使用<code>Property.set()</code>代替。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下还看到了类似的更改：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.assembler.tasks.Assemble.html">组装</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.rc.tasks.WindowsResourceCompile.html">WindowsResourceCompile</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/tasks/StripSymbols.html">带状符号</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/tasks/ExtractSymbols.html">提取符号</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/swift/tasks/SwiftCompile.html">Swift编译</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/tasks/LinkMachOBundle.html">LinkMachOBundle</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="rel4.6:visual_studio_single_solution"><a class="anchor" href="#rel4.6:visual_studio_single_solution"></a> <a class="link" href="#rel4.6:visual_studio_single_solution">[4.6] Visual Studio集成仅对构建的所有组件支持单个解决方案文件</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html">VisualStudioExtension</a>不再具有<code>solutions</code>属性。相反，您可以通过根项目中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.ide.visualstudio.VisualStudioRootExtension.html">VisualStudioRootExtension</a>配置单个解决方案，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    visualStudio {
        solution {
            solutionFile.location = <span class="string"><span class="delimiter">&quot;</span><span class="content">vs/</span><span class="inline"><span class="inline-delimiter">${</span>name<span class="inline-delimiter">}</span></span><span class="content">.sln</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，不再需要为每个组件生成解决方案文件的单个任务，而只需一个任务<code>visualStudio</code>任务，生成一个解决方案文件，其中包含构建中的所有组件。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel4.5:http_build_cache_no_follow_redirects"><a class="anchor" href="#rel4.5:http_build_cache_no_follow_redirects"></a> <a class="link" href="#rel4.5:http_build_cache_no_follow_redirects">[4.5] <code>HttpBuildCache</code>不再跟随重定向</a></h5>
<div class="paragraph">
<p>通过连接到HTTP构建缓存后端时<code>HttpBuildCache</code> ，Gradle不再遵循重定向，而是将其视为错误。从构建缓存后端获取重定向主要是配置错误（例如，使用“ http” URL而不是“ https”），这会对性能产生负面影响。</p>
</div>
</div>
<div class="sect4">
<h5 id="rel4.4:security_library_upgrades"><a class="anchor" href="#rel4.4:security_library_upgrades"></a> <a class="link" href="#rel4.4:security_library_upgrades">[4.4]第三方依赖项升级</a></h5>
<div class="paragraph">
<p>此版本包括第三方依赖项的多个升级：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>杰克逊：2.6.6→2.8.9</p>
</li>
<li>
<p>plexus-utils：2.0.6→2.1</p>
</li>
<li>
<p>xercesImpl：2.9.1→2.11.0</p>
</li>
<li>
<p>bsh：2.0b4→2.0b6</p>
</li>
<li>
<p>弹跳城堡：1.57→1.58</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这可以修复以下安全问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7525">CVE-2017-7525</a> （关键）</p>
</li>
<li>
<p>SONATYPE-2017-0359（关键）</p>
</li>
<li>
<p>SONATYPE-2017-0355（严重）</p>
</li>
<li>
<p>SONATYPE-2017-0398（关键）</p>
</li>
<li>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-4002">CVE-2013-4002</a> （严重）</p>
</li>
<li>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2510">CVE-2016-2510</a> （严重）</p>
</li>
<li>
<p>SONATYPE-2016-0397（严重）</p>
</li>
<li>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2625">CVE-2009-2625</a> （严重）</p>
</li>
<li>
<p>SONATYPE-2017-0348（严重）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle没有公开针对这些第三方依赖的公共API，但是那些自定义Gradle的人会希望知道。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migrating_from_maven"><a class="anchor" href="#migrating_from_maven"></a> <a class="link" href="#migrating_from_maven">从Apache Maven迁移构建</a></h3>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">患有缓慢的Maven构建？<a href="https://gradle.com/training/build-cache-deep-dive/?bid=docs-migrating-maven">在此处注册</a>以参加我们的Build Cache培训课程，以了解Gradle Enterprise如何将Maven的构建速度提高多达90％。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://maven.apache.org">Apache Maven</a>是用于Java和其他基于JVM的项目的构建工具，这些项目已得到广泛使用，因此想要使用Gradle的人们通常必须迁移现有的Maven构建。本指南将通过解释这两种工具的模型之间的差异和相似之处，并提供简化步骤可以帮助您进行迁移。</p>
</div>
<div class="paragraph">
<p>转换构建可能会很吓人，但您不必一个人做。您可以从<a href="https://gradle.org/help">help.gradle.org</a>搜索文档，论坛和StackOverflow，或者在<a href="https://gradle.org/help">遇到麻烦时</a>访问<a href="https://discuss.gradle.org/c/help-discuss">论坛上的Gradle社区</a> 。</p>
</div>
<div class="sect3">
<h4 id="migmvn:making_a_case"><a class="anchor" href="#migmvn:making_a_case"></a> <a class="link" href="#migmvn:making_a_case">进行迁移</a></h4>
<div class="paragraph">
<p>Gradle和Maven之间的主要区别是灵活性，性能，用户体验和依赖性管理。<a href="https://gradle.org/maven-vs-gradle">Maven与Gradle功能比较中</a>提供了这些方面的直观概述。</p>
</div>
<div class="paragraph">
<p>自Gradle 3.0以来，Gradle投入了大量资金，以使Gradle的构建速度更快，并具有<a href="https://blog.gradle.org/introducing-gradle-build-cache">构建缓存</a> ， <a href="https://blog.gradle.org/incremental-compiler-avoidance">避免编译</a>和改进的增量Java编译器等功能。对于大多数项目，即使不使用构建缓存，Gradle的速度也比Maven快2-10倍。可以在<a href="https://gradle.org/gradle-vs-maven-performance/">此处</a>找到有关从Maven切换到Gradle的深入性能比较和业务案例。</p>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:general_guidelines"><a class="anchor" href="#migmvn:general_guidelines"></a> <a class="link" href="#migmvn:general_guidelines">一般准则</a></h4>
<div class="paragraph">
<p>对于如何构建项目，Gradle和Maven有着根本不同的看法。Gradle提供了一种灵活且可扩展的构建模型，该模型将实际工作委托给<a href="#the_core_model_is_based_on_tasks"><em>任务依赖关系图</em></a> 。Maven使用固定的线性阶段模型，可以在其中附加目标（完成工作的事物）。这可能会使两者之间的迁移看起来令人生畏，但迁移可能出奇的容易，因为Gradle遵循许多与Maven相同的约定（例如<a href="#sec:java_project_layout">标准项目结构）</a> ，并且其依赖项管理以类似的方式工作。</p>
</div>
<div class="paragraph">
<p>在这里，我们列出了一系列步骤供您遵循，这将有助于促进将任何Maven构建移植到Gradle：</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">并排保留旧的Maven构建和新的Gradle构建。您知道Maven构建可以工作，因此您应该保留它，直到您确信Gradle构建可以生成所有相同的工件，然后再做您需要的事情。这也意味着用户可以在不获取源树的新副本的情况下尝试Gradle构建。
</td>
</tr>
</tbody></table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://scans.gradle.com#maven">创建Maven构建的构建扫描</a> 。</p>
<div class="paragraph">
<p>构建扫描将使可视化您现有Maven构建中发生的事情变得更加容易。对于Maven构建，您将能够查看项目结构，正在使用的插件，构建步骤的时间表等等。保持方便，以便可以将其与转换项目时获得的Gradle构建扫描进行比较。</p>
</div>
</li>
<li>
<p>开发一种机制来验证两个构建产生相同的工件</p>
<div class="paragraph">
<p>这是确保您的部署和测试不中断的至关重要的一步。即使是很小的更改，例如JAR中清单文件的内容，也会引起问题。如果您的Gradle构建产生的输出与Maven构建产生的输出相同，则这将使您和其他人对切换充满信心，并使更容易实施将带来最大收益的重大更改。</p>
</div>
<div class="paragraph">
<p>这并不意味着您需要在每个阶段都验证每个工件，尽管这样做可以帮助您快速确定问题的根源。您可以只关注关键输出，例如最终报告以及已发布或部署的工件。</p>
</div>
<div class="paragraph">
<p>与Maven相比，您需要考虑Gradle产生的构建输出中的某些固有差异。生成的POM将仅包含消耗所需的信息，并且它们将使用<code><compile></code>和<code><runtime></code>适用于这种情况的范围。您可能还会看到归档文件中的文件顺序和类路径中的文件顺序不同。大多数差异将是良性的，但值得识别它们并验证它们是否正确。</p>
</div>
</li>
<li>
<p><a href="#migmvn:automatic_conversion">运行自动转换</a></p>
<div class="paragraph">
<p>这将创建您需要的所有Gradle构建文件，即使对于<a href="#migmvn:multimodule_builds">多模块构建也是如此</a> 。对于更简单的Maven项目，Gradle构建将可以运行！</p>
</div>
</li>
<li>
<p><a href="https://guides.gradle.org/creating-build-scans">为Gradle build创建一个build扫描</a> 。</p>
<div class="paragraph">
<p>构建扫描将使可视化构建中的事情变得更加容易。对于Gradle构建，您将能够查看项目结构，依赖项（常规和项目间的依赖关系），正在使用的插件以及构建的控制台输出。</p>
</div>
<div class="paragraph">
<p>此时您的构建可能会失败，但这没关系；扫描仍将运行。将Gradle生成的生成扫描与Maven生成的生成扫描进行比较，然后继续执行此列表以排除故障。</p>
</div>
<div class="paragraph">
<p>我们建议您在迁移期间定期生成构建扫描，以帮助您确定问题并排除故障。如果需要，还可以使用Gradle构建扫描来确定<a href="https://guides.gradle.org/performance/">提高构建性能的</a>机会，毕竟性能是首先切换到Gradle的主要原因。</p>
</div>
</li>
<li>
<p><a href="#migmvn:migrating_deps">验证您的依赖关系并解决任何问题</a></p>
</li>
<li>
<p><a href="#migmvn:integration_tests">配置集成和功能测试</a></p>
<div class="paragraph">
<p>通过配置额外的源集，可以简单地迁移许多测试。如果您使用的是第三方库（例如<a href="http://docs.fitnesse.org/FrontPage">FitNesse）</a> ，请查看<a href="https://plugins.gradle.org/">Gradle Plugin Portal</a>上是否有合适的社区插件。</p>
</div>
</li>
<li>
<p>用Gradle等效项替换Maven插件</p>
<div class="paragraph">
<p>对于<a href="#migmvn:common_plugins">流行的插件</a> ，Gradle经常有一个等效的插件供您使用。您可能还会发现可以<a href="#migmvn:unnecessary_plugins">用内置的Gradle功能替换插件</a> 。最后，您可能需要<a href="#migmvn:custom_plugins">通过自己的自定义插件和任务类型</a>重新实现Maven插件。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>本章的其余部分更详细地介绍了将构建从Maven迁移到Gradle的特定方面。</p>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:build_lifecycle"><a class="anchor" href="#migmvn:build_lifecycle"></a> <a class="link" href="#migmvn:build_lifecycle">了解构建生命周期</a></h4>
<div class="paragraph">
<p>Maven构建基于<a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html"><em>构建生命周期</em></a>的概念，该概念由一组固定阶段组成。这可能会成为用户迁移到Gradle的障碍，因为它的构建生命周期<a href="#build_lifecycle">有所不同</a> ，尽管了解Gradle的构建方式如何适合初始化，配置和执行阶段的结构很重要。幸运的是，Gradle具有可以模仿Maven各个阶段的功能： <a href="#sec:lifecycle_tasks"><em>生命周期任务</em></a> 。</p>
</div>
<div class="paragraph">
<p>这些使您可以通过创建仅依赖于您感兴趣的任务的无操作任务来定义自己的“生命周期”。为了使Maven用户更容易过渡到Gradle，由所有JVM语言插件（如<a href="#java_library_plugin">Java库插件）</a>应用的<a href="#sec:base_tasks">基本插件</a>提供了一组与主要Maven阶段相对应的生命周期任务。</p>
</div>
<div class="paragraph">
<p>这是一些主要的Maven阶段以及它们映射到的Gradle任务的列表：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>clean</code></dt>
<dd>
<p>使用<code>clean</code>基本插件提供的任务。</p>
</dd>
<dt class="hdlist1"><code>compile</code></dt>
<dd>
<p>使用<code>classes</code> <a href="#sec:java_tasks">Java插件</a>和其他JVM语言插件提供的任务。这将编译所有类所有语言的所有源文件，并且进行<a href="#migmvn:filtering_resources">资源过滤</a>通过<code>processResources</code>任务。</p>
</dd>
<dt class="hdlist1"><code>test</code></dt>
<dd>
<p>使用<code>test</code> Java插件提供的任务。它仅运行单元测试，或更具体而言，运行组成单元测试的测试。 <a href="#source_sets"><code>test</code>源集</a> 。</p>
</dd>
<dt class="hdlist1"><code>package</code></dt>
<dd>
<p>使用<code>assemble</code>基本插件提供的任务。这将构建适合该项目的任何软件包，例如Java库的JAR或传统Java Webapp的WAR。</p>
</dd>
<dt class="hdlist1"><code>verify</code></dt>
<dd>
<p>使用<code>check</code>基本插件提供的任务。这将运行附加到它的所有验证任务，通常包括单元测试，任何静态分析任务（例如<a href="#checkstyle_plugin">Checkstyle</a> ）以及其他任务。如果要包括集成测试，则必须<a href="#migmvn:integration_tests">手动配置这些</a> ，这是一个简单的过程。</p>
</dd>
<dt class="hdlist1"><code>install</code></dt>
<dd>
<p>使用<code>publishToMavenLocal</code> <a href="#publishing_maven:tasks">Maven发布插件</a>提供的任务。</p>
<div class="paragraph">
<p>请注意，Gradle构建不需要您“安装”工件，因为您可以访问更合适的功能，例如<a href="#sub:project_dependencies">项目间依赖</a>和<a href="#">复合构建</a> 。您只能使用<code>publishToMavenLocal</code>与Maven版本互操作。</p>
</div>
<div class="paragraph">
<p>Gradle还允许您解决对本地Maven缓存的依赖关系，如“ <a href="#migmvn:declaring_repos">声明存储库”</a>部分中所述。</p>
</div>
</dd>
<dt class="hdlist1"><code>deploy</code></dt>
<dd>
<p>使用<code>publish</code> <a href="#publishing_maven:tasks">Maven发布插件</a>提供的任务-确保您从较旧的Maven插件（ID： <code>maven</code> ）（如果您的版本正在使用该版本）。这会将您的程序包发布到所有已配置的发布存储库。即使定义了多个存储库，也有其他任务可以使您发布到单个存储库。</p>
<div class="paragraph">
<p>请注意， <em>默认情况下</em> ，Maven Publish Plugin不发布<strong>源代码和Javadoc JAR</strong> ，但是可以很容易地激活它，如<a href="#sec:java_packaging">构建Java项目的指南</a>中<a href="#sec:java_packaging">所述</a> 。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:automatic_conversion"><a class="anchor" href="#migmvn:automatic_conversion"></a> <a class="link" href="#migmvn:automatic_conversion">执行自动转换</a></h4>
<div class="paragraph">
<p>摇篮的<a href="#build_init_plugin"><code>init</code> task</a>通常用于创建新的骨架项目，但是您也可以使用它将现有的Maven构建自动转换为Gradle。将Gradle <a href="#installation">安装到系统上后</a> ，只需执行以下命令</p>
</div>
<div class="listingblock terminal">
<div class="content">
<pre>&gt; gradle init</pre>
</div>
</div>
<div class="paragraph">
<p>从根项目目录中，让Gradle做它的事情。这基本上包括解析现有的POM并生成相应的Gradle构建脚本。如果您要迁移<a href="#multi_project_builds">多项目版本，</a> Gradle还将创建一个设置脚本。</p>
</div>
<div class="paragraph">
<p>您会发现新的Gradle构建包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POM中指定的所有自定义存储库</p>
</li>
<li>
<p>您的外部和项目间依赖性</p>
</li>
<li>
<p>用于构建项目的适当插件（仅限于<a href="#">Maven Publish</a> ， <a href="#">Java</a>和<a href="#">War</a>插件中的一个或多个）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关自动转换功能的完整列表，请参见<a href="#sec:pom_maven_conversion">Build Init插件一章</a> 。</p>
</div>
<div class="paragraph">
<p>要记住的一件事是程序集不会自动转换。它们不一定要转换，但是您将需要做一些手工工作。选项包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<a href="#distribution_plugin">分发插件</a></p>
</li>
<li>
<p>使用<a href="#java_library_distribution_plugin">Java库分发插件</a></p>
</li>
<li>
<p>使用<a href="#application_plugin">应用程序插件</a></p>
</li>
<li>
<p><a href="#sec:creating_archives_example">创建自定义存档任务</a></p>
</li>
<li>
<p>从<a href="https://plugins.gradle.org/">Gradle插件门户</a>使用合适的社区插件</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您的Maven构建没有很多插件或以自定义方式提供很多插件，则只需运行</p>
</div>
<div class="listingblock terminal">
<div class="content">
<pre>&gt; gradle build</pre>
</div>
</div>
<div class="paragraph">
<p>迁移完成后。这将运行测试并产生所需的工件，而您无需任何额外的干预。</p>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:migrating_deps"><a class="anchor" href="#migmvn:migrating_deps"></a> <a class="link" href="#migmvn:migrating_deps">迁移依赖项</a></h4>
<div class="paragraph">
<p>Gradle的依赖项管理系统比Maven的依赖项管理系统更灵活，但它仍支持相同的存储库，声明的依赖项，范围（Gradle中的<a href="#sec:what-are-dependency-configurations">依赖项配置</a> ）和可传递依赖项的概念。实际上，Gradle与兼容Maven的存储库完美配合，这使得迁移依赖关系变得容易。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">两种工具之间的显着区别是它们如何管理版本冲突。Maven使用“最接近”的匹配算法，而Gradle选择最新的匹配算法。不过，请放心，您可以控制选择哪个版本，如《 <a href="#">管理传递性依赖关系》中所述</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在以下各节中，我们将向您展示如何迁移Maven构建的依赖管理信息中最常见的元素。</p>
</div>
<div class="sect4">
<h5 id="migmvn:declaring_deps"><a class="anchor" href="#migmvn:declaring_deps"></a> <a class="link" href="#migmvn:declaring_deps">声明依赖</a></h5>
<div class="paragraph">
<p>Gradle使用与Maven相同的依赖项标识符组件：组ID，工件ID和版本。它还支持分类器。因此，您要做的就是将标识符的依赖项信息替换为Gradle的语法，这在“ <a href="#">声明依赖项”</a>一章中进行了介绍。</p>
</div>
<div class="paragraph">
<p>例如，考虑对Log4J的这种Maven风格的依赖关系：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>log4j<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>log4j<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>1.2.12<span class="tag">&lt;/version&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;/dependencies&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Gradle构建脚本中，这种依赖关系如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">范例1。声明一个简单的编译时依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">log4j:log4j:1.2.12</span><span class="delimiter">'</span></span>  // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;log4j:log4j:1.2.12&quot;)  // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>将Log4J的1.2.12版附加到<code>implementation</code>配置（范围）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>字符串标识符采用的Maven值<code>groupId</code> ， <code>artifactId</code>和<code>version</code> ，尽管Gradle称他们为<code>group</code> ， <code>module</code>和<code>version</code> 。</p>
</div>
<div class="paragraph">
<p>上面的例子提出了一个明显的问题：那是什么<code>implementation</code>组态？它是<a href="#tab:configurations">Java插件</a>提供的标准依赖项配置之一，通常用于替代Maven的默认配置<code>compile</code>范围。</p>
</div>
<div class="paragraph">
<p>Maven的作用域和Gradle的标准配置之间的几个区别归结为Gradle区分了构建模块所需的依赖项和构建依赖于该模块的模块所需的依赖项。Maven没有这种区别，因此已发布的POM通常包括库的使用者实际上不需要的依赖项。</p>
</div>
<div class="paragraph">
<p>以下是主要的Maven依赖范围以及如何处理它们的迁移：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>compile</code></dt>
<dd>
<p>Gradle有两种配置可以代替<code>compile</code>范围： <code>implementation</code>和<code>api</code> 。前者可用于任何应用Java插件的项目，而<code>api</code>仅适用于专门应用<a href="#java_library_plugin">Java库插件的项目</a> 。</p>
<div class="paragraph">
<p>在大多数情况下，您只需使用<code>implementation</code>配置，尤其是在构建应用程序或Webapp时。但是，如果您要构建库，则可以了解应使用以下方法声明哪些依赖项： <code>api</code>在<a href="#sec:building_java_libraries">构建Java库</a>的部分中。关于之间差异的更多信息<code>api</code>和<code>implementation</code>上面链接的“ Java库插件”一章中提供了该工具。</p>
</div>
</dd>
<dt class="hdlist1"><code>runtime</code></dt>
<dd>
<p>使用<code>runtimeOnly</code>组态。</p>
</dd>
<dt class="hdlist1"><code>test</code></dt>
<dd>
<p>Gradle区分了<em>编译</em>项目测试所需的那些依赖项和仅<em>运行</em>它们所需的那些依赖项。</p>
<div class="paragraph">
<p>测试编译所需的依赖关系应针对<code>testImplementation</code>组态。仅运行测试所需的那些应该使用<code>testRuntimeOnly</code> 。</p>
</div>
</dd>
<dt class="hdlist1"><code>provided</code></dt>
<dd>
<p>使用<code>compileOnly</code>组态。</p>
<div class="paragraph">
<p>请注意，“ <a href="#sec:war_dependency_management">战争插件”</a>添加了<code>providedCompile</code>和<code>providedRuntime</code>依赖项配置。这些行为与<code>compileOnly</code>并只需确保这些依赖关系未打包在WAR文件中即可。但是，依赖项包含在运行时和测试运行时类路径中，因此，如果需要这样做，请使用这些配置。</p>
</div>
</dd>
<dt class="hdlist1"><code>import</code></dt>
<dd>
<p>的<code>import</code>范围主要用于<code><dependencyManagement></code>阻止并仅适用于仅POM的出版物。阅读有关<a href="#migmvn:using_boms">使用物料清单</a>的部分，以了解有关如何复制此行为的更多信息。</p>
<div class="paragraph">
<p>您还可以指定对仅POM的发布的常规依赖性。在这种情况下，在该POM中声明的依赖关系将被视为构建的常规传递依赖关系。</p>
</div>
<div class="paragraph">
<p>例如，假设您要使用<code>groovy-all</code>用于测试的POM。这是仅POM的出版物，在<code><dependencies></code>块。Gradle构建中的适当配置如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例2消耗仅POM依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.codehaus.groovy:groovy-all:2.5.4</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;org.codehaus.groovy:groovy-all:2.5.4&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>结果就是<code>compile</code>和<code>runtime</code>范围的依赖<code>groovy-all</code> POM被添加到测试运行时类路径中，而只有<code>compile</code>作用域依赖项被添加到测试编译类路径中。与其他作用域的依赖关系将被忽略。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="migmvn:declaring_repos"><a class="anchor" href="#migmvn:declaring_repos"></a> <a class="link" href="#migmvn:declaring_repos">声明存储库</a></h5>
<div class="paragraph">
<p>Gradle允许您从任何与Maven兼容或与Ivy兼容的存储库中检索已声明的依赖项。与Maven不同，它没有默认存储库，因此您必须声明至少一个。为了具有与Maven构建相同的行为，只需在Gradle构建中配置<a href="#sub:maven_central">Maven Central</a> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">范例3。配置内部版本以使用Maven Central</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>repositories {}</code>块以配置自定义存储库，如“ <a href="#sec:maven_repo">存储库类型”</a>一章中所述。</p>
</div>
<div class="paragraph">
<p>最后，Gradle允许您解决对<a href="#sub:maven_local">本地Maven缓存/存储库的</a>依赖关系。这有助于Gradle构建与Maven构建进行互操作，但是如果您不需要这种互操作性，则不应该使用该技术。如果你想通过文件系统共享公布的文物，考虑配置一个<a href="#sec:maven_repo">自定义Maven仓库</a>用<code>file://</code>网址。</p>
</div>
<div class="paragraph">
<p>您可能还对学习Gradle自己的<a href="#sec:dependency_cache">依赖项缓存</a>感兴趣，它比Maven的行为更可靠，并且可以被多个并发的Gradle进程安全地使用。</p>
</div>
</div>
<div class="sect4">
<h5 id="migmvn:controlling_dep_versions"><a class="anchor" href="#migmvn:controlling_dep_versions"></a> <a class="link" href="#migmvn:controlling_dep_versions">控制依赖项版本</a></h5>
<div class="paragraph">
<p>传递依赖项的存在意味着您可以轻松地在依赖关系图中最终获得同一依赖项的多个版本。默认情况下，Gradle将在图中选择依赖项的最新版本，但这并不总是正确的解决方案。这就是为什么它提供了几种机制来控制解决给定依赖项的哪个版本的原因。</p>
</div>
<div class="paragraph">
<p>在每个项目的基础上，您可以使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:adding-constraints-transitive-deps">依赖约束</a></p>
</li>
<li>
<p><a href="#migmvn:using_boms">的材料清单</a> （BOM表的Maven）</p>
</li>
<li>
<p><a href="#sec:enforcing_dependency_version">覆盖传递版本</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在<a href="#">控制传递依赖项</a>一章中列出了更多专门的选项。</p>
</div>
<div class="paragraph">
<p>如果要确保多项目构建中所有项目的版本一致性，请参见<code><dependencyManagement></code>在Maven工程中，您可以使用<a href="#java_platform_plugin">Java Platform Plugin</a> 。这使您可以声明一组可以应用于多个项目的依赖关系约束。您甚至可以将平台发布为Maven BOM或使用Gradle的元数据格式发布。有关如何执行此操作的更多信息，请参见插件页面，尤其是在使用<a href="#sec:java_platform_consumption">平台</a>部分，以了解如何将平台应用于同一构建中的其他项目。</p>
</div>
</div>
<div class="sect4">
<h5 id="migmvn:excluding_deps"><a class="anchor" href="#migmvn:excluding_deps"></a> <a class="link" href="#migmvn:excluding_deps">排除传递依赖</a></h5>
<div class="paragraph">
<p>Maven构建使用排除项将不需要的依赖关系或不需要的依赖关系<em>版本</em>排除在依赖关系图中。您可以使用Gradle做同样的事情，但这不一定是<em>正确的</em>事情。Gradle提供了其他选项，这些选项可能更适合给定的情况，因此您确实需要了解<em>为什么</em>存在排除项才能正确迁移它。</p>
</div>
<div class="paragraph">
<p>如果您出于与版本无关的原因要排除依赖关系，请查看关于<a href="#sec:excluding-transitive-deps">排除传递依赖关系</a>的部分。它显示了如何将排除项附加到整个配置（通常是最合适的解决方案）或依赖项。您甚至可以轻松地将排除应用于所有配置。</p>
</div>
<div class="paragraph">
<p>如果您对控制实际解决依赖关系的版本更感兴趣，请参阅上一节。</p>
</div>
</div>
<div class="sect4">
<h5 id="migmvn:optional_deps"><a class="anchor" href="#migmvn:optional_deps"></a> <a class="link" href="#migmvn:optional_deps">处理可选的依赖</a></h5>
<div class="paragraph">
<p>关于可选依赖项，您可能会遇到两种情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您的某些传递依赖项被声明为可选</p>
</li>
<li>
<p>您想在项目的已发布POM中将一些直接依赖项声明为可选项</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于第一种情况，Gradle的行为与Maven相同，只是忽略了声明为可选的任何传递依赖。如果相同的依存关系在依存关系图中的其他位置显示为非可选，则无法解析它们并且对所选版本没有影响。</p>
</div>
<div class="paragraph">
<p>至于将依赖项发布为可选的，Gradle提供了一个更丰富的模型，称为<a href="#feature_variants">Feature Variants</a> ，它可以让您声明库提供的“可选功能”。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:using_boms"><a class="anchor" href="#migmvn:using_boms"></a> <a class="link" href="#migmvn:using_boms">使用物料清单（BOM）</a></h4>
<div class="paragraph">
<p>Maven允许您通过在内部定义依赖项来共享依赖项约束<code><dependencyManagement></code>包装类型为POM的POM文件部分<code>pom</code> 。然后可以将这种特殊类型的POM（物料清单）导入其他POM中，以便在项目中拥有一致的库版本。</p>
</div>
<div class="paragraph">
<p>Gradle可以通过基于<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:platform(java.lang.Object)">platform（）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:enforcedPlatform(java.lang.Object)">forcedPlatform（）</a>方法的特殊依赖项语法，将此类BOM用于相同的目的。您只需以常规方式声明依赖项，然后将依赖项标识符包装在适当的方法中，如“导入” Spring Boot Dependencies BOM的示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例4在Gradle版本中导入BOM</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation platform(<span class="string"><span class="delimiter">'</span><span class="content">org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE</span><span class="delimiter">'</span></span>) // <b class="conum">(1)</b>

    implementation <span class="string"><span class="delimiter">'</span><span class="content">com.google.code.gson:gson</span><span class="delimiter">'</span></span> // <b class="conum">(2)</b>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">dom4j:dom4j</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(platform(&quot;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE&quot;))  // <b class="conum">(1)</b>

    implementation(&quot;com.google.code.gson:gson&quot;)  // <b class="conum">(2)</b>
    implementation(&quot;dom4j:dom4j&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>应用Spring Boot Dependencies BOM</p>
</li>
<li>
<p>添加依赖项，其版本由该BOM表定义</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您可以了解有关此功能的更多信息以及两者之间的区别<code>platform()</code>和<code>enforcedPlatform()</code>在有关<a href="#sub:bom_import">从Maven BOM导入版本建议</a>的部分中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">您可以使用此功能来应用<code><dependencyManagement></code>从任何依赖项的POM到Gradle构建的信息，甚至那些没有打包类型的信息<code>pom</code> 。都<code>platform()</code>和<code>enforcedPlatform()</code>将忽略在<code><dependencies></code>块。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:multimodule_builds"><a class="anchor" href="#migmvn:multimodule_builds"></a> <a class="link" href="#migmvn:multimodule_builds">迁移多模块构建（项目聚合）</a></h4>
<div class="paragraph">
<p>Maven的多模块构建与Gradle的<a href="#">多项目构建</a>很好地映射。尝试相应的<a href="https://guides.gradle.org/creating-multi-project-builds/">教程，</a>以了解如何设置基本的多项目Gradle构建。</p>
</div>
<div class="paragraph">
<p>要迁移多模块Maven构建，只需执行以下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建与以下内容匹配的设置脚本： <code><modules></code>根POM的块。</p>
<div class="paragraph">
<p>例如这个<code><modules></code>块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;modules&gt;</span>
    <span class="tag">&lt;module&gt;</span>simple-weather<span class="tag">&lt;/module&gt;</span>
    <span class="tag">&lt;module&gt;</span>simple-webapp<span class="tag">&lt;/module&gt;</span>
<span class="tag">&lt;/modules&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过在设置脚本中添加以下行来迁移：</p>
</div>
<div class="exampleblock">
<div class="title">示例5声明哪些项目是构建的一部分</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">simple-multi-module</span><span class="delimiter">'</span></span>  // <b class="conum">(1)</b>

include <span class="string"><span class="delimiter">'</span><span class="content">simple-weather</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">simple-webapp</span><span class="delimiter">'</span></span>  // <b class="conum">(2)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;simple-multi-module&quot;  // <b class="conum">(1)</b>

include(&quot;simple-weather&quot;, &quot;simple-webapp&quot;)  // <b class="conum">(2)</b></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>设置整个项目的名称</p>
</li>
<li>
<p>配置两个子项目作为此构建的一部分</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle projects</code></strong></div>
<div class="content">
<pre>&gt; gradle projects

------------------------------------------------------------
Root project
------------------------------------------------------------

Root project 'simple-multi-module'
+--- Project ':simple-weather'
\--- Project ':simple-webapp'

To see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasks
For example, try running gradle :simple-weather:tasks</pre>
</div>
</div>
</li>
<li>
<p>将跨模块依赖项替换为<a href="#sub:project_dependencies">项目依赖项</a> 。</p>
</li>
<li>
<p>使用<a href="#sec:cross_project_configuration">跨项目配置</a>复制项目继承。</p>
<div class="paragraph">
<p>这基本上涉及创建一个根项目构建脚本，该脚本将共享配置注入到适当的子项目中。</p>
</div>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="migmvn:sub:sharing-versions"><a class="anchor" href="#migmvn:sub:sharing-versions"></a> <a class="link" href="#migmvn:sub:sharing-versions">跨项目共享版本</a></h5>
<div class="paragraph">
<p>如果您要复制Maven模式，即在<code>dependencyManagement</code> POM根文件部分，最好的方法是利用<code>java-platform</code>插入。您将需要为此添加一个专用项目，并在构建的常规项目中使用它。有关此模式的更多详细信息，请参见<a href="#">文档</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:profiles_and_properties"><a class="anchor" href="#migmvn:profiles_and_properties"></a> <a class="link" href="#migmvn:profiles_and_properties">迁移Maven配置文件和属性</a></h4>
<div class="paragraph">
<p>Maven允许您使用各种属性对构建进行参数化。一些是项目模型的只读属性，其他是在POM中用户定义的。它甚至允许您将系统属性视为项目属性。</p>
</div>
<div class="paragraph">
<p>Gradle具有类似的项目属性系统，尽管它可以区分项目属性和系统属性。例如，您可以在以下位置定义属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>构建脚本</p>
</li>
<li>
<p>一种<code>gradle.properties</code>根项目目录中的文件</p>
</li>
<li>
<p>一种<code>gradle.properties</code>文件在<code>$HOME/.gradle</code>目录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些不是唯一的选择，因此，如果您有兴趣了解有关如何以及在何处定义属性的更多信息，请查阅“ <a href="#build_environment">构建环境”</a>一章。</p>
</div>
<div class="paragraph">
<p>您需要了解的一项重要行为是，在构建脚本和一个外部属性文件中定义了相同的属性时会发生什么：构建脚本值优先。总是。幸运的是，您可以模仿配置文件的概念以提供可覆盖的默认值。</p>
</div>
<div class="paragraph">
<p>这使我们进入了Maven配置文件。这些是根据环境，目标平台或任何其他类似因素启用和禁用不同配置的方法。从逻辑上讲，它们仅是有限的“ if”语句。而且由于Gradle具有更强大的声明条件的方法，因此它不需要正式支持配置文件（依赖项的POM中除外）。您将看到，通过将条件与辅助构建脚本结合起来，可以轻松获得相同的行为。</p>
</div>
<div class="paragraph">
<p>假设您根据环境有不同的部署设置：本地开发（默认），测试环境和生产。要添加类似概要文件的行为，首先要在项目根目录中为每个环境创建构建脚本： <code>profile-default.gradle</code> ， <code>profile-test.gradle</code>和<code>profile-prod.gradle</code> 。然后，您可以根据自己选择的<a href="#sec:project_properties">项目属性</a>有条件地应用这些概要文件脚本之一。</p>
</div>
<div class="paragraph">
<p>下面的示例演示了使用名为的项目属性的基本技术<code>buildProfile</code>和配置文件脚本，它们只是初始化一个<a href="#sec:extra_properties">额外的项目属性，</a>称为<code>message</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">范例6。模仿Gradle中的Maven配置文件的行为</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">if</span> (!hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">buildProfile</span><span class="delimiter">'</span></span>)) ext.buildProfile = <span class="string"><span class="delimiter">'</span><span class="content">default</span><span class="delimiter">'</span></span>  // <b class="conum">(1)</b>

apply <span class="key">from</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">profile-</span><span class="inline"><span class="inline-delimiter">${</span>buildProfile<span class="inline-delimiter">}</span></span><span class="content">.gradle</span><span class="delimiter">&quot;</span></span>  // <b class="conum">(2)</b>

task greeting {
    doLast {
        println message  // <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">profile-default.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.message = <span class="string"><span class="delimiter">'</span><span class="content">foobar</span><span class="delimiter">'</span></span>  // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">profile-test.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.message = <span class="string"><span class="delimiter">'</span><span class="content">testing 1 2 3</span><span class="delimiter">'</span></span>  // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">profile-prod.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.message = <span class="string"><span class="delimiter">'</span><span class="content">Hello, world!</span><span class="delimiter">'</span></span>  // <b class="conum">(4)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val buildProfile: String? by project  // <b class="conum">(1)</b>

apply(from = &quot;profile-${buildProfile ?: &quot;default&quot;}.gradle.kts&quot;)  // <b class="conum">(2)</b>

tasks.register(&quot;greeting&quot;) {
    val message: String by project.extra
    doLast {
        println(message)  // <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">profile-default.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val message by extra(&quot;foobar&quot;)  // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">profile-test.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val message by extra(&quot;testing 1 2 3&quot;)  // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">profile-prod.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val message by extra(&quot;Hello, world!&quot;)  // <b class="conum">(4)</b></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>检查（Groovy）的存在或绑定（Kotlin） <code>buildProfile</code>项目物业</p>
</li>
<li>
<p>使用以下值应用适当的配置文件脚本<code>buildProfile</code>在脚本文件名中</p>
</li>
<li>
<p>打印出<code>message</code>额外项目财产</p>
</li>
<li>
<p>初始化<code>message</code>额外的项目属性，其值随后可以在主构建脚本中使用</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>完成此设置后，您可以通过传递所用项目属性的值来激活其中一个配置文件- <code>buildProfile</code>在这种情况下：</p>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle greeting</code></strong></div>
<div class="content">
<pre>&gt; gradle greeting
foobar</pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -PbuildProfile=test greeting</code></strong></div>
<div class="content">
<pre>&gt; gradle -PbuildProfile=test greeting
testing 1 2 3</pre>
</div>
</div>
<div class="paragraph">
<p>您不仅限于检查项目属性。您还可以检查环境变量，JDK版本，运行构建的OS或您可以想象的任何其他内容。</p>
</div>
<div class="paragraph">
<p>要记住的一件事是，高级条件语句使构建更难以理解和维护，类似于它们使面向对象的代码复杂化的方式。配置文件也是如此。Gradle提供了许多更好的方法来避免广泛使用Maven经常需要的配置文件，例如，通过配置多个彼此不同的任务。见<code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code> <a href="#publishing_maven:tasks">Maven发布插件</a>创建的任务。</p>
</div>
<div class="paragraph">
<p>有关在Gradle中使用Maven概要文件的冗长讨论，请参阅<a href="https://blog.gradle.org/maven-pom-profiles">此博客文章</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:filtering_resources"><a class="anchor" href="#migmvn:filtering_resources"></a> <a class="link" href="#migmvn:filtering_resources">筛选资源</a></h4>
<div class="paragraph">
<p>Maven的阶段称为<code>process-resources</code>有目标<code>resources:resources</code>默认绑定到它。这使构建作者有机会在各种文件上执行变量替换，例如Web资源，打包的属性文件等。</p>
</div>
<div class="paragraph">
<p>Gradle的Java插件提供了一个<code>processResources</code>任务要做同样的事情。这是一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a>任务，可从配置的资源目录复制文件- <code>src/main/resources</code>默认情况下-到输出目录。和任何<code>Copy</code>任务，您可以将其配置为执行<a href="#filtering_files">文件过滤</a> ， <a href="#sec:renaming_files">重命名</a>和<a href="#sec:filtering_files">内容过滤</a> 。</p>
</div>
<div class="paragraph">
<p>例如，这是将源文件视为<a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_simpletemplateengine">Groovy的配置。 <code>SimpleTemplateEngine</code></a>模板，提供<code>version</code>和<code>buildNumber</code>这些模板的属性：</p>
</div>
<div class="exampleblock">
<div class="title">范例7。通过以下方式过滤资源的内容<code>processResources</code>任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">processResources {
    expand(<span class="key">version</span>: version, <span class="key">buildNumber</span>: currentBuildNumber)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks {
    processResources {
        expand(&quot;version&quot; to version, &quot;buildNumber&quot; to currentBuildNumber)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html">CopySpec</a>的API文档以查看所有可用选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:integration_tests"><a class="anchor" href="#migmvn:integration_tests"></a> <a class="link" href="#migmvn:integration_tests">配置集成测试</a></h4>
<div class="paragraph">
<p>许多Maven构建都包含某种形式的集成测试，Maven通过额外的一组阶段来支持这些集成测试： <code>pre-integration-test</code> ， <code>integration-test</code> ， <code>post-integration-test</code>和<code>verify</code> 。它还使用Failsafe插件代替Surefire，以便失败的集成测试不会自动使构建失败（因为您可能需要清理资源，例如正在运行的应用程序服务器）。</p>
</div>
<div class="paragraph">
<p>如我们<a href="#sec:configuring_java_integration_tests">在Java和JVM项目中测试</a>章节中所述，此行为很容易在带有源集的Gradle中复制。然后，您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object[])">Task.finalizedBy（）</a>将清理任务（例如关闭测试服务器的清理任务）配置为始终在集成测试之后运行，而不管它们是否成功。</p>
</div>
<div class="paragraph">
<p>如果您确实不希望集成测试使构建失败，那么可以使用Java测试一章的“ <a href="#sec:test_execution">测试执行”</a>部分中描述的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:ignoreFailures">Test.ignoreFailures</a>设置。</p>
</div>
<div class="paragraph">
<p>源集还为您在集成测试中放置源文件的位置提供了很大的灵活性。您可以轻松地将它们保存在与单元测试相同的目录中，或更优选地，将它们保存在单独的源目录中，例如<code>src/integTest/java</code> 。要支持其他类型的测试，您只需添加更多源集和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试</a>任务！</p>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:common_plugins"><a class="anchor" href="#migmvn:common_plugins"></a> <a class="link" href="#migmvn:common_plugins">迁移常用插件</a></h4>
<div class="paragraph">
<p>Maven和Gradle共享一种通过插件扩展构建的通用方法。尽管表面上的插件系统有很大不同，但是它们共享许多基于功能的插件，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>阴影/阴影</p>
</li>
<li>
<p>码头</p>
</li>
<li>
<p>Checkstyle</p>
</li>
<li>
<p>JaCoCo</p>
</li>
<li>
<p>AntRun（请参阅下一节）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为什么这么重要？由于许多插件依赖于标准Java约定，因此迁移仅是在Gradle中复制Maven插件的配置即可。例如，这是一个简单的Maven Checkstyle插件配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">...
<span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>maven-checkstyle-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>2.17<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;executions&gt;</span>
    <span class="tag">&lt;execution&gt;</span>
      <span class="tag">&lt;id&gt;</span>validate<span class="tag">&lt;/id&gt;</span>
      <span class="tag">&lt;phase&gt;</span>validate<span class="tag">&lt;/phase&gt;</span>
      <span class="tag">&lt;configuration&gt;</span>
        <span class="tag">&lt;configLocation&gt;</span>checkstyle.xml<span class="tag">&lt;/configLocation&gt;</span>
        <span class="tag">&lt;encoding&gt;</span>UTF-8<span class="tag">&lt;/encoding&gt;</span>
        <span class="tag">&lt;consoleOutput&gt;</span>true<span class="tag">&lt;/consoleOutput&gt;</span>
        <span class="tag">&lt;failsOnError&gt;</span>true<span class="tag">&lt;/failsOnError&gt;</span>
        <span class="tag">&lt;linkXRef&gt;</span>false<span class="tag">&lt;/linkXRef&gt;</span>
      <span class="tag">&lt;/configuration&gt;</span>
      <span class="tag">&lt;goals&gt;</span>
        <span class="tag">&lt;goal&gt;</span>check<span class="tag">&lt;/goal&gt;</span>
      <span class="tag">&lt;/goals&gt;</span>
    <span class="tag">&lt;/execution&gt;</span>
  <span class="tag">&lt;/executions&gt;</span>
<span class="tag">&lt;/plugin&gt;</span>
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>迁移到Gradle时，可以安全地忽略配置块之外的所有内容。在这种情况下，相应的Gradle配置如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">范例8。配置Gradle Checkstyle插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">checkstyle {
    config = resources.text.fromFile(<span class="string"><span class="delimiter">'</span><span class="content">checkstyle.xml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">UTF-8</span><span class="delimiter">'</span></span>)
    showViolations = <span class="predefined-constant">true</span>
    ignoreFailures = <span class="predefined-constant">false</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">checkstyle {
    config = resources.text.fromFile(&quot;checkstyle.xml&quot;, &quot;UTF-8&quot;)
    isShowViolations = true
    isIgnoreFailures = false
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Checkstyle任务会自动添加为<code>check</code>任务，其中还包括<code>test</code> 。如果要确保Checkstyle在测试之前运行，则只需使用mustRunAfter（）方法指定一个顺序即可：</p>
</div>
<div class="exampleblock">
<div class="title">范例9。控制何时<code>checkstyle</code>任务运行</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test.mustRunAfter checkstyleMain, checkstyleTest</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks {
    test {
        mustRunAfter(checkstyleMain, checkstyleTest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，Gradle配置通常比Maven等效配置短得多。您还将拥有一个更加灵活的执行模型，因为您不再受Maven固定阶段的约束。</p>
</div>
<div class="paragraph">
<p>从Maven迁移项目时，请不要忘记源集。与Maven相比，它们通常为处理集成测试或生成的源提供了更优雅的解决方案，因此您应将它们纳入迁移计划中。</p>
</div>
<div class="sect4">
<h5 id="ant_goals"><a class="anchor" href="#ant_goals"></a> <a class="link" href="#ant_goals">蚂蚁目标</a></h5>
<div class="paragraph">
<p>许多Maven构建依赖于AntRun插件来自定义构建，而没有实现自定义Maven插件的开销。Gradle没有等效的插件，因为Ant是Gradle构建中的一等公民，通过<code>ant</code>宾语。例如，您可以使用Ant的Echo任务，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例10调用Ant任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task sayHello {
    doLast {
        ant.echo <span class="key">message</span>: <span class="string"><span class="delimiter">'</span><span class="content">Hello!</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;sayHello&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;echo&quot;(&quot;message&quot; to &quot;Hello!&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>本机还支持Ant属性和文件集。要了解更多信息，请参阅《 <a href="#ant">从Gradle中使用Ant》</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>仅<a href="#custom_tasks">创建自定义任务类型</a>来替换Ant为您所做的工作可能更简单，更简洁。然后，您可以更轻松地从<a href="#sec:up_to_date_checks">增量构建</a>和其他有用的Gradle功能中受益。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:unnecessary_plugins"><a class="anchor" href="#migmvn:unnecessary_plugins"></a> <a class="link" href="#migmvn:unnecessary_plugins">了解您不需要哪些插件</a></h4>
<div class="paragraph">
<p>值得记住的是，Gradle版本通常比Maven版本更易于扩展和自定义。在这种情况下，这意味着您可能不需要Gradle插件来替换Maven。例如，Maven Enforcer插件允许您控制依赖项版本和环境因素，但是可以在常规Gradle构建脚本中轻松配置这些内容。</p>
</div>
</div>
<div class="sect3">
<h4 id="migmvn:custom_plugins"><a class="anchor" href="#migmvn:custom_plugins"></a> <a class="link" href="#migmvn:custom_plugins">处理不常见和自定义的插件</a></h4>
<div class="paragraph">
<p>您可能会遇到Gradle中没有对应版本的Maven插件，特别是如果您或组织中的某人编写了自定义插件。这种情况取决于您了解Gradle（以及可能的Maven）的工作方式，因为您通常必须编写自己的插件。</p>
</div>
<div class="paragraph">
<p>为了进行迁移，Maven插件有两种主要类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>那些使用Maven项目对象的对象。</p>
</li>
<li>
<p>那些没有。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为什么这很重要？因为如果使用后者之一，则可以轻松地将其重新实现为<a href="#custom_tasks">自定义Gradle任务类型</a> 。只需定义与mojo参数相对应的任务输入和输出，然后将执行逻辑转换为任务动作即可。</p>
</div>
<div class="paragraph">
<p>如果插件依赖于Maven项目，那么您将不得不重写它。不要首先考虑Maven插件的工作原理，而要看看它试图解决的问题。然后尝试解决如何在Gradle中解决该问题。您可能会发现这两个构建模型之间的差异足以使Maven插件代码“转录”到Gradle插件中才有效。从好的方面来说，该插件可能比原始的Maven插件更容易编写，因为Gradle具有更丰富的构建模型和API。</p>
</div>
<div class="paragraph">
<p>如果您确实需要通过构建脚本或插件来实现自定义逻辑，请查看<a href="https://gradle.org/guides/?q=Plugin Development">与插件开发相关</a>的<a href="https://gradle.org/guides/?q=Plugin Development">指南</a> 。另外，请确保熟悉Gradle的<a href="https://docs.gradle.org/6.0.1/dsl/">Groovy DSL参考</a> ，该<a href="https://docs.gradle.org/6.0.1/dsl/">参考</a>提供了有关您将使用的API的全面文档。它详细介绍了标准配置块（以及支持它们的对象），系统中的核心类型（ <code>Project</code> ， <code>Task</code>等等），以及标准的任务类型集。主要入口点是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a>接口，因为它是支持构建脚本的顶级对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="further_reading"><a class="anchor" href="#further_reading"></a> <a class="link" href="#further_reading">进一步阅读</a></h4>
<div class="paragraph">
<p>本章涵盖了将Maven构建迁移到Gradle的主要主题。剩下的就是迁移期间或迁移之后可能有用的其他一些方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解如何配置Gradle的<a href="#build_environment">构建环境</a> ，包括用于运行Gradle的JVM设置</p>
</li>
<li>
<p>了解如何<a href="#organizing_gradle_projects">有效构建构建</a></p>
</li>
<li>
<p><a href="#logging">配置Gradle的日志</a>并在构建中使用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后，本指南仅涉及Gradle的一些功能，我们鼓励您从用户手册的其他章节以及教程式的<a href="https://guides.gradle.org/">Gradle指南中</a>了解其余内容。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migrating_from_ant"><a class="anchor" href="#migrating_from_ant"></a> <a class="link" href="#migrating_from_ant">从Apache Ant迁移构建</a></h3>
<div class="paragraph">
<p><a href="https://ant.apache.org/">Apache Ant</a>是在Java世界中具有悠久历史的构建工具，尽管有越来越少的团队，但它仍被广泛使用。虽然灵活，但缺少约定和Gradle可以提供的许多强大功能。迁移到Gradle是值得的，因此您的构建可以变得更苗条，更简单和更快，同时仍保留您使用Ant所享有的灵活性。您还将受益于对多项目构建的强大支持以及易于使用的灵活依赖管理。</p>
</div>
<div class="paragraph">
<p>从Ant迁移到Gradle的最大挑战是，没有标准的Ant构建之类的东西。这使得很难提供具体说明。幸运的是，Gradle具有与Ant的强大集成功能，可以使过程相对平稳。甚至从基于<a href="https://ant.apache.org/ivy/">Ivy</a>的依赖项管理迁移也不是特别困难，因为Gradle具有基于<a href="#sub:terminology_configuration">依赖项配置</a>的类似模型，该模型可与Ivy兼容的存储库一起使用。</p>
</div>
<div class="paragraph">
<p>我们将首先概述将构建从Ant迁移到Gradle时应考虑的事项，并提供有关如何进行的一些一般性指导。</p>
</div>
<div class="sect3">
<h4 id="migant:general_guidelines"><a class="anchor" href="#migant:general_guidelines"></a> <a class="link" href="#migant:general_guidelines">一般准则</a></h4>
<div class="paragraph">
<p>当您承诺将构建从Ant迁移到Gradle时，应牢记既有内容又要在何处结束的性质。您是否需要Gradle构建来反映现有Ant构建的结构？还是您想改用Gradle惯用的方法？您正在寻找的主要好处是什么？</p>
</div>
<div class="paragraph">
<p>要理解其含义，请考虑您可以针对的两个极端端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过导入的构建<a href="#sec:import_ant_build"><code>ant.importBuild()</code></a></p>
<div class="paragraph">
<p>这种方法快速，简单，并且适用于许多基于Ant的构建。最后，您得到的构建实际上与原始Ant构建完全相同，只是您的Ant目标成为了Gradle任务。甚至保留了目标之间的依赖关系。</p>
</div>
<div class="paragraph">
<p>缺点是您仍在使用Ant构建，必须继续对其进行维护。您还将失去Gradle约定，许多插件，依赖管理等优点。您仍然可以使用<a href="#sec:up_to_date_checks">增量构建信息</a>来增强构建，但是比正常的Gradle构建要付出更多的努力。</p>
</div>
</li>
<li>
<p>惯用的Gradle构建</p>
<div class="paragraph">
<p>如果您想将来对构建进行验证，那么这里就是您要结束的地方。利用Gradle的约定和插件将导致更小，更易于维护的构建，其结构对于许多Java开发人员来说都是熟悉的。您还将发现更容易利用Gradle的强大功能来提高构建性能。</p>
</div>
<div class="paragraph">
<p>主要缺点是执行迁移所需的额外工作，尤其是在现有构建很复杂且具有许多项目间依赖关系的情况下。但是，这种构建通常会从转向idomatic Gradle的过程中受益最大。另外，Gradle提供了许多可以简化迁移的功能，例如直接从Gradle构建中<a href="#sec:using_ant_tasks">使用核心和自定义Ant任务的功能</a> 。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>从长远来看，理想情况下，您希望最终接近第二种选择，但是您不必一there而就。</p>
</div>
<div class="paragraph">
<p>接下来是一系列步骤，可帮助您确定要采用的方法以及如何执行该方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>并排保留旧的Ant构建和新的Gradle构建</p>
<div class="paragraph">
<p>您知道Ant构建是可行的，因此您应该保留它，直到确信Gradle构建会生成所有相同的工件，然后再做您需要的事情。这也意味着用户可以在不获取源树的新副本的情况下尝试Gradle构建。</p>
</div>
<div class="paragraph">
<p>在准备好进行切换之前，请勿尝试更改构建的目录和文件结构。</p>
</div>
</li>
<li>
<p>开发一种机制来验证两个构建产生相同的工件</p>
<div class="paragraph">
<p>这是确保您的部署和测试不中断的至关重要的一步。即使是很小的更改，例如JAR中清单文件的内容，也会引起问题。如果您的Gradle构建产生与Ant构建相同的输出，这将使您和其他人对切换充满信心，并使更容易实施将带来最大收益的重大更改。</p>
</div>
</li>
<li>
<p>确定您是否具有多项目构建</p>
<div class="paragraph">
<p>与单项目构建相比，多项目构建通常更难迁移且需要更多的工作。我们在<a href="#migant:multi_project_builds">迁移多项目构建</a>部分中提供了一些专门的建议，以帮助完成该过程。</p>
</div>
</li>
<li>
<p>找出每个项目要使用的插件</p>
<div class="paragraph">
<p>我们期望绝大多数Ant构建都是针对<a href="#building_java_projects">基于JVM的项目的</a> ，为此，有大量的插件可提供您所需的许多功能。Gradle不仅随附了<a href="#plugin_reference">核心插件</a> ，您还可以在<a href="https://plugins.gradle.org/">Plugin Portal</a>上找到许多有用的<a href="https://plugins.gradle.org/">插件</a> 。</p>
</div>
<div class="paragraph">
<p>即使<a href="#java_plugin">Java插件</a>或其派生工具之一（例如<a href="#java_library_plugin">Java库插件</a> ）与您的构建不是很好的匹配，您也应至少考虑将<a href="#base_plugin">Base Plugin</a>用于其生命周期任务。</p>
</div>
</li>
<li>
<p>导入Ant构建或从头开始创建Gradle构建</p>
<div class="paragraph">
<p>此步骤很大程度上取决于构建的要求。如果精选的Gradle插件可以完成您的Ant构建所做的大部分工作，那么创建一个不依赖于Ant构建的新鲜Gradle构建脚本可能很有意义，要么自己实现缺失的片段，要么<a href="#sec:using_ant_tasks">利用现有的</a>片段<a href="#sec:using_ant_tasks">蚂蚁任务</a> 。</p>
</div>
<div class="paragraph">
<p>另一种方法是<a href="#sec:import_ant_build">将Ant构建</a>导入到Gradle构建脚本中，并逐步替换Ant构建功能。这样可以使您在每个阶段都有一个有效的Gradle构建，但是需要一些工作才能使Gradle任务与Ant任务一起正常工作。您可以在<a href="#migant:imported_builds">使用导入的版本中</a>了解有关此方法的更多信息。</p>
</div>
</li>
<li>
<p>为现有目录和文件结构配置构建</p>
<div class="paragraph">
<p>Gradle利用约定来消除与旧版本相关联的许多样板，并在用户熟悉这些约定后使用户更轻松地使用新版本。但这并不意味着您必须遵循它们。</p>
</div>
<div class="paragraph">
<p>Gradle提供了许多配置选项，可以实现高度的自定义。这些选项通常可以通过提供约定的插件使用。例如，用于生产Java代码的标准源目录结构- <code>src/main/java</code>由Java插件提供，它允许您<a href="#sec:custom_java_source_set_paths">配置其他源路径</a> 。可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a>对象上的属性修改许多路径。</p>
</div>
</li>
<li>
<p>如果愿意，可以迁移到标准Gradle约定</p>
<div class="paragraph">
<p>一旦确信Gradle构建会产生与Ant构建相同的工件和其他资源，就可以考虑迁移到标准约定，例如源目录路径。这样做将允许您删除覆盖这些约定所需的额外配置。新的团队成员还将发现更改后更容易使用构建。</p>
</div>
<div class="paragraph">
<p>由您决定此步骤是否值得花费时间，精力和可能造成的潜在中断，而这又取决于您的特定构建和团队。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>本章的其余部分介绍了您在迁移期间可能要处理的一些常见方案，例如依赖性管理和使用Ant任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="migant:imported_builds"><a class="anchor" href="#migant:imported_builds"></a> <a class="link" href="#migant:imported_builds">使用导入的版本</a></h4>
<div class="paragraph">
<p>许多迁移的第一步将涉及使用以下命令<a href="#sec:import_ant_build">导入Ant构建</a> <code>ant.importBuild()</code> 。如果这样做，那么如何在不立即替换所有内容的情况下过渡到标准Gradle构建？</p>
</div>
<div class="paragraph">
<p>要记住的重要一点是，Ant目标变成了真正的Gradle任务，这意味着您可以执行诸如修改其任务依赖性，附加额外的任务动作等操作。这使您可以用本地Gradle任务替代等效的Ant任务，并保持与其他现有任务的任何链接。</p>
</div>
<div class="paragraph">
<p>例如，假设您有一个Java库项目要从Ant迁移到Gradle。Gradle构建脚本中包含导入Ant构建的行，现在想使用标准Gradle机制来编译Java源文件。但是，您想继续使用现有的<code>package</code>创建库的JAR文件的任务。</p>
</div>
<div class="paragraph">
<p>以示意图的形式，情况如下所示，其中每个框代表一个目标/任务：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/ant-task-migration.png" alt="蚂蚁任务迁移">
</div>
</div>
<div class="paragraph">
<p>这个想法是替代标准Gradle <code>compileJava</code>蚂蚁的任务<code>build</code>任务。此替换涉及几个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>应用<a href="#java_library_plugin">Java库插件</a></p>
<div class="paragraph">
<p>这提供了<code>compileJava</code>如图所示的任务。</p>
</div>
</li>
<li>
<p>重命名旧的<code>build</code>任务</p>
<div class="paragraph">
<p>名字<code>build</code>与标准冲突<code>build</code> <a href="#base_plugin">基本插件</a> （通过Java库插件）提供的任务。</p>
</div>
</li>
<li>
<p>配置编译以使用现有目录结构</p>
<div class="paragraph">
<p>Ant构建很有可能不符合标准Gradle目录结构，因此您需要告诉Gradle在哪里可以找到源文件以及在哪里放置编译好的类，因此<code>package</code>可以找到他们。</p>
</div>
</li>
<li>
<p>更新任务依赖项</p>
<div class="paragraph">
<p><code>compileJava</code>必须依靠<code>prepare</code> ， <code>package</code>必须依靠<code>compileJava</code>而不是<code>ant_build</code>和<code>assemble</code>必须依靠<code>package</code>而不是标准Gradle <code>jar</code>任务。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>应用插件就像插入一个插件一样简单<code>plugins {}</code>在Gradle构建脚本的开头（即之前）阻塞<code>ant.importBuild()</code> 。这是应用Java库插件的方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例11应用Java库插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>重命名<code>build</code>任务，请使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/AntBuilder.html#importBuild-java.lang.Object-org.gradle.api.Transformer-">AntBuilder.importBuild（）</a>的变体，它接受一个转换器，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">范例12。重命名导入目标</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild(<span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span>) { <span class="predefined-type">String</span> oldTargetName -&gt;
    <span class="keyword">return</span> oldTargetName == <span class="string"><span class="delimiter">'</span><span class="content">build</span><span class="delimiter">'</span></span> ? <span class="string"><span class="delimiter">'</span><span class="content">ant_build</span><span class="delimiter">'</span></span> : oldTargetName  // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;) { oldTargetName -&gt;
    if (oldTargetName == &quot;build&quot;) &quot;ant_build&quot; else oldTargetName  // <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>重命名<code>build</code>瞄准<code>ant_build</code>并保持所有其他目标不变</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在<a href="#sec:custom_java_source_set_paths">构建Java和JVM项目</a>一章中介绍了为源配置不同的路径，同时您可以以类似的方式更改已编译类的输出目录。</p>
</div>
<div class="paragraph">
<p>假设原始的Ant构建将这些路径存储在Ant属性中， <code>src.dir</code> Java源文件和<code>classes.dir</code>用于输出。这是配置Gradle使用这些路径的方法：</p>
</div>
<div class="exampleblock">
<div class="title">范例13。配置源集</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    main {
        java {
            srcDirs = [ ant.properties[<span class="string"><span class="delimiter">'</span><span class="content">src.dir</span><span class="delimiter">'</span></span>] ]
            outputDir = file(ant.properties[<span class="string"><span class="delimiter">'</span><span class="content">classes.dir</span><span class="delimiter">'</span></span>])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    main {
        java.setSrcDirs(listOf(ant.properties[&quot;src.dir&quot;]))
        java.outputDir = file(ant.properties[&quot;classes.dir&quot;] ?: &quot;$buildDir/classes&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最终，您应该尽可能地针对您的项目类型切换标准目录结构，然后就可以删除此自定义设置。</p>
</div>
<div class="paragraph">
<p>最后一步也很简单，涉及使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn">Task.dependsOn</a>属性和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])">Task.dependsOn（）</a>方法来分离和链接任务。该属性适合<em>替换</em>依赖关系，而该方法是添加到现有依赖关系的首选方法。</p>
</div>
<div class="paragraph">
<p>这是示例场景所需的必需任务依赖项配置，该配置应在Ant构建导入之后进行：</p>
</div>
<div class="exampleblock">
<div class="title">范例14。配置任务依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">compileJava.dependsOn <span class="string"><span class="delimiter">'</span><span class="content">prepare</span><span class="delimiter">'</span></span>  // <b class="conum">(1)</b>
<span class="keyword">package</span>.dependsOn = [ <span class="string"><span class="delimiter">'</span><span class="content">compileJava</span><span class="delimiter">'</span></span> ]  // <b class="conum">(2)</b>
assemble.dependsOn = [ <span class="string"><span class="delimiter">'</span><span class="content">package</span><span class="delimiter">'</span></span> ]  // <b class="conum">(3)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks {
    compileJava {
        dependsOn(&quot;prepare&quot;)  // <b class="conum">(1)</b>
    }
    named(&quot;package&quot;) {
        setDependsOn(listOf(compileJava))  // <b class="conum">(2)</b>
    }
    assemble {
        setDependsOn(listOf(&quot;package&quot;))  // <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使编译取决于<code>prepare</code>任务</p>
</li>
<li>
<p>分离器<code>package</code>来自<code>ant_build</code>任务，并使其取决于<code>compileJava</code></p>
</li>
<li>
<p>分离器<code>assemble</code>从标准Gradle <code>jar</code>任务，并使其取决于<code>package</code>代替</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>而已！这四个步骤将成功用Gradle实现替换旧的Ant编译。即使是很小的迁移也会有很大帮助，因为您将能够利用Gradle的<a href="#sec:incremental_compile">增量Java编译</a>来加快构建速度。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>这只是如何逐步执行迁移的演示。由于这三个方面都已很好地集成在Gradle中，因此在此阶段包含资源处理（如属性文件）和打包内容可能更有意义。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您必须问自己的一个重要问题是，每个阶段要迁移多少任务。您可以一次迁移的块越大越好，但是这必须抵消更改将影响Ant构建中的自定义步骤数量。</p>
</div>
<div class="paragraph">
<p>例如，如果Ant构建遵循相当标准的方法进行编译，静态资源，打包和单元测试，则可能值得将所有这些一起迁移。但是，如果构建对编译后的类执行了一些额外的处理，或者在处理静态资源时执行了一些独特的处理，则可能值得将这些任务分成单独的阶段。</p>
</div>
</div>
<div class="sect3">
<h4 id="migant:managing_dependencies"><a class="anchor" href="#migant:managing_dependencies"></a> <a class="link" href="#migant:managing_dependencies">管理依赖</a></h4>
<div class="paragraph">
<p>Ant构建通常采用以下两种方法之一来处理二进制<a href="#sub:terminology_dependency">依赖性</a> （例如库）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将它们与项目一起存储在本地“ lib”目录中</p>
</li>
<li>
<p>使用<a href="https://ant.apache.org/ivy/">Apache Ivy</a>来管理它们</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>他们每个都需要使用不同的技术来迁移到Gradle，但是无论哪种情况，您都会发现过程很简单。我们将在以下各节中详细介绍每种方案。</p>
</div>
<div class="sect4">
<h5 id="migant:filesystem_deps"><a class="anchor" href="#migant:filesystem_deps"></a> <a class="link" href="#migant:filesystem_deps">从目录服务依赖项</a></h5>
<div class="paragraph">
<p>当您尝试迁移将其依赖项存储在本地或网络上的文件系统上的构建时，应考虑是否最终要使用远程存储库移至托管依赖项。这是因为您可以通过以下两种方式之一将文件系统依赖项合并到Gradle构建中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义<a href="#sub:flat_dir_resolver">平面目录存储库</a>并使用标准依赖项声明</p>
</li>
<li>
<p>将文件直接附加到适当的依赖项配置（ <a href="#sub:file_dependencies">文件依赖项</a> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果采用第一种方法，则更容易迁移到从Maven或Ivy兼容存储库提供的托管依赖项中，但是这样做需要所有文件都符合命名约定“ <modulename>- <version><extension>”。</extension></version></modulename></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果您将依赖项存储在标准的Maven存储库布局中， <code><repoDir>/<group>/<module>/<version></code> —然后，您可以使用“ file：//” URL定义<a href="#sec:declaring_custom_repository">自定义Maven存储库</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了演示这两种技术，请考虑一个在其项目中具有以下库JAR的项目<code>libs</code>目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>libs
├── our-custom.jar
├── log4j-1.2.8.jar
└── commons-io-2.1.jar</pre>
</div>
</div>
<div class="paragraph">
<p>文件<code>our-custom.jar</code>缺少版本号，因此必须将其添加为文件依赖项。但是其他两个JAR匹配所需的命名约定，因此可以声明为从平面目录存储库检索的常规<a href="#sub:module_dependencies">模块依赖项</a> 。</p>
</div>
<div class="paragraph">
<p>下面的示例构建脚本演示了如何将所有这些库合并到构建中：</p>
</div>
<div class="exampleblock">
<div class="title">示例15声明文件系统提供的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    flatDir {
        name = <span class="string"><span class="delimiter">'</span><span class="content">libs dir</span><span class="delimiter">'</span></span>
        dir file(<span class="string"><span class="delimiter">'</span><span class="content">libs</span><span class="delimiter">'</span></span>)  // <b class="conum">(1)</b>
    }
}

dependencies {
    implementation files(<span class="string"><span class="delimiter">'</span><span class="content">libs/our-custom.jar</span><span class="delimiter">'</span></span>)  // <b class="conum">(2)</b>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">:log4j:1.2.8</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">:commons-io:2.1</span><span class="delimiter">'</span></span>  // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    flatDir {
        name = &quot;libs dir&quot;
        dir(file(&quot;libs&quot;))  // <b class="conum">(1)</b>
    }
}

dependencies {
    implementation(files(&quot;libs/our-custom.jar&quot;))  // <b class="conum">(2)</b>
    implementation(&quot;:log4j:1.2.8&quot;)     // <b class="conum">(3)</b>
    implementation(&quot;:commons-io:2.1&quot;)  // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>指定包含JAR文件的目录的路径</p>
</li>
<li>
<p>声明未版本化JAR的<em>文件依赖关系</em></p>
</li>
<li>
<p>使用标准依赖关系坐标声明依赖关系-请注意，未指定任何组，但是每个标识符都有一个前导<code>:</code> ，表示一个空组</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以上示例将添加<code>our-custom.jar</code> ， <code>log4j-1.2.8.jar</code>和<code>commons-io-2.1.jar</code>到<code>implementation</code>配置，用于编译项目的代码。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>您也可以在这些模块依赖项中指定一个组，即使它们实际上没有组。这是因为平面目录存储库只是忽略了信息。</p>
</div>
<div class="paragraph">
<p>如果以后再添加一个与Maven或Ivy兼容的常规存储库，则Gradle将优先从该存储库中下载用组声明的模块依赖关系，而不是从平面目录中下载。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="migant:ivy_deps"><a class="anchor" href="#migant:ivy_deps"></a> <a class="link" href="#migant:ivy_deps">迁移常春藤依赖</a></h5>
<div class="paragraph">
<p>Apache Ivy是一个独立的依赖项管理工具，已与Ant一起广泛使用。它的工作方式与Gradle类似。实际上，它们都允许您</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义自己的<a href="#sub:terminology_configuration">配置</a></p>
</li>
<li>
<p>相互扩展配置</p>
</li>
<li>
<p>将依赖项附加到配置</p>
</li>
<li>
<p>解决来自Ivy兼容存储库的依赖关系</p>
</li>
<li>
<p>将工件发布到兼容Ivy的存储库</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最明显的区别是Gradle具有针对特定项目类型的标准配置。例如， <a href="#tab:configurations">Java插件</a>定义如下配置<code>implementation</code> ， <code>testImplementation</code>和<code>runtimeOnly</code> 。不过，您仍然可以<a href="#sec:defining-custom-configurations">定义自己的依赖项配置</a> 。</p>
</div>
<div class="paragraph">
<p>这种相似性意味着从Ivy迁移到Gradle通常非常简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将模块声明中的依赖项声明翻译为Gradle构建脚本的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure)">依赖项{}</a>块，最好使用您所应用的任何插件提供的标准配置。</p>
</li>
<li>
<p>将模块描述符中的所有配置声明转录到构建脚本的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure)">configuration {}</a>块中，以获取任何无法用Gradle的标准配置替代的自定义配置。</p>
</li>
<li>
<p>将解析器从您的Ivy设置文件转录到构建脚本的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)">存储库{}</a>块中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多信息，请参见有关<a href="#sec:what-are-dependency-configurations">管理依赖关系配置</a> ， <a href="#sec:dependency-types">声明依赖关系</a>和<a href="#declaring-repositories">声明存储库</a>的章节。</p>
</div>
<div class="paragraph">
<p>Ivy提供了一些Ant任务，这些任务处理Ivy的获取依赖项的过程。该过程的基本步骤包括：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>配置</em> -应用常春藤设置文件中定义的配置</p>
</li>
<li>
<p><em>解决</em> -找到声明的依赖项，并在必要时将其下载到缓存</p>
</li>
<li>
<p><em>检索</em> -将缓存的依赖项复制到另一个目录</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Gradle的过程类似，但是您不必显式调用前两个步骤，因为它会自动执行它们。第三步根本不会发生-除非您创建要执行的任务-因为Gradle通常通常直接在类路径中使用依赖项缓存中的文件，并将其用作组装应用程序包的源。</p>
</div>
<div class="paragraph">
<p>让我们更详细地了解Ivy的步骤如何映射到Gradle：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">组态</dt>
<dd>
<p>如您所见，Gradle的大多数与依赖相关的配置都包含在构建脚本中， <code>dependencies {}</code>块。另一个特别重要的配置元素是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ResolutionStrategy.html">resolutionStrategy</a> ，可以从依赖项配置中访问它。这提供了您可能从Ivy的冲突管理器中获得的许多功能，并且是控制可传递依赖项和缓存的有效方法。</p>
<div class="paragraph">
<p>一些Ivy配置选项在Gradle中没有等效项。例如，由于Gradle确保其依赖项缓存是并发安全的，因此没有锁定策略。也没有“最新策略”，因为拥有可靠的单一冲突解决策略比较容易。如果选择了“错误”版本，则可以使用强制版本或其他解决方案策略选项轻松覆盖它。</p>
</div>
<div class="paragraph">
<p>有关Gradle这方面的更多信息，请参见<a href="#">控制传递依赖</a>的章节。</p>
</div>
</dd>
<dt class="hdlist1">解析度</dt>
<dd>
<p>在构建开始时，Gradle将自动解决您声明的所有依赖项并将其下载到其缓存中。它在存储库中搜索那些依赖项，其搜索顺序由<a href="#sec:declaring_multiple_repositories">存储库的声明</a>顺序定义。</p>
<div class="paragraph">
<p>值得注意的是，Gradle支持与Ivy相同的动态版本语法，因此您仍然可以使用类似<code>1.0.+</code> 。您也可以使用特殊<code>latest.integration</code>和<code>latest.release</code>标签，如果你愿意。如果决定使用这种<a href="#sub:declaring_dependency_with_dynamic_version">动态</a>和<a href="#sub:declaring_dependency_with_changing_version">变化的</a>依赖关系，则可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ResolutionStrategy.html">resolutionStrategy</a>为它们配置缓存行为。</p>
</div>
<div class="paragraph">
<p>如果您使用动态和/或更改依赖关系，则可能还需要考虑<a href="#">依赖关系锁定</a> 。这是使构建更可靠并允许可<a href="https://reproducible-builds.org/">复制的构建</a>的一种方法。</p>
</div>
</dd>
<dt class="hdlist1">恢复</dt>
<dd>
<p>如前所述，Gradle不会自动从依赖项缓存中复制文件。它的标准任务通常直接使用文件。如果要将依赖项复制到本地目录，可以在构建脚本中使用以下<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a>任务：</p>
<div class="exampleblock">
<div class="title">示例16。将依赖项复制到本地目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task retrieveRuntimeDependencies(<span class="key">type</span>: Copy) {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/libs</span><span class="delimiter">&quot;</span></span>
    from configurations.runtimeClasspath
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks {
    register&lt;Copy&gt;(&quot;retrieveRuntimeDependencies&quot;) {
        into(&quot;$buildDir/libs&quot;)
        from(configurations.runtimeClasspath)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>配置也是文件集合，因此为什么可以在配置文件中使用它<code>from()</code>组态。您可以使用类似的技术将配置附加到编译任务或生成文档的任务。有关更多示例和有关Gradle文件API的信息，请参见<a href="#working_with_files">使用文件</a>一章。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="migant:ivy_publishing"><a class="anchor" href="#migant:ivy_publishing"></a> <a class="link" href="#migant:ivy_publishing">发布工件</a></h4>
<div class="paragraph">
<p>使用Ivy来管理依赖项的项目也经常使用它来发布JAR和其他工件到存储库。如果您要迁移这样的构建，那么您将很高兴知道Gradle内置了对将工件发布到兼容Ivy的存储库的支持。</p>
</div>
<div class="paragraph">
<p>在尝试迁移构建的此特定方面之前，请阅读“ <a href="#publishing_overview">发布”</a>一章，以了解Gradle的发布模型。该章的示例基于Maven存储库，但Ivy存储库也使用相同的模型。</p>
</div>
<div class="paragraph">
<p>基本的迁移过程如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将<a href="#publishing_ivy">常春藤发布插件</a>应用于您的构建</p>
</li>
<li>
<p><a href="#publishing_ivy:publications">配置至少一个发布</a> ，表示将发布的内容（如果需要，还包括其他工件）</p>
</li>
<li>
<p><a href="#publishing_ivy:repositories">配置一个或多个存储库以将工件发布到</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>完成这些操作后，您将能够为每个发布生成一个Ivy模块描述符，并将它们发布到一个或多个存储库中。</p>
</div>
<div class="paragraph">
<p>假设您已经定义了一个名为“ myLibrary”的发布和一个名为“ myRepo”的存储库。然后，Ivy的Ant任务将映射到Gradle任务，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><deliver></code> →<code>generateDescriptorFileForMyLibraryPublication</code></p>
</li>
<li>
<p><code><publish></code> →<code>publishMyLibraryPublicationToMyRepoRepository</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有一个方便<code>publish</code>将<em>所有</em>出版物发布到<em>所有</em>存储库的任务。如果您希望限制将哪些出版物转到哪个存储库，请查看<a href="#sec:publishing_maven:conditional_publishing">“出版”一章</a>的<a href="#sec:publishing_maven:conditional_publishing">相关部分</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">关于依赖版本</div>
<div class="paragraph">
<p>在默认情况下，Ivy在生成模块描述符时会自动将动态依赖关系的版本替换为已解析的“静态”版本。摇篮<em>不会</em>模仿这种行为：宣告依赖版本保持不变。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="https://plugins.gradle.org/plugin/nebula.ivy-resolved-dependencies">Nebula Ivy Resolved Plugin</a>复制默认的Ivy行为。或者，您可以<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html#org.gradle.api.publish.ivy.IvyModuleDescriptorSpec:withXml(org.gradle.api.Action)">自定义描述符文件</a> ，使其包含所需的版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="migant:custom_tasks"><a class="anchor" href="#migant:custom_tasks"></a> <a class="link" href="#migant:custom_tasks">处理自定义Ant任务</a></h4>
<div class="paragraph">
<p>Ant的优点之一是创建自定义任务并将其合并到构建中相当容易。如果您有这样的任务，则有两个主要选项可将它们迁移到Gradle构建：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:using_custom_ant_tasks">使用</a> Gradle构建中<a href="#sec:using_custom_ant_tasks">的定制Ant任务</a></p>
</li>
<li>
<p>将任务重写为<a href="#custom_tasks">自定义Gradle任务类型</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一个选项通常快速简便，但并非总是如此。而且，如果要将任务集成到增量构建中，则必须使用<a href="#sec:task_input_output_runtime_api">增量构建运行时API</a> 。您还经常需要处理笨拙的Ant路径和文件集。</p>
</div>
<div class="paragraph">
<p>如果有时间，从长远来看，第二个选项是可取的。Gradle任务类型往往比Ant任务更简单，因为它们不必使用基于XML的接口。您还可以访问Gradle的丰富API。最后，这种方法可以利用基于类型化属性的<a href="#sec:task_input_output_annotations">类型安全增量构建API</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="migant:working_with_files"><a class="anchor" href="#migant:working_with_files"></a> <a class="link" href="#migant:working_with_files">处理文件</a></h4>
<div class="paragraph">
<p>Ant有许多处理文件的任务，其中大多数具有Gradle等效项。与从Ant到Gradle迁移的其他区域一样，您可以在Gradle构建中<a href="#sec:using_ant_tasks">使用这些Ant任务</a> 。但是，我们强烈建议在可能的情况下迁移到本地Gradle构造，以使该构造受益于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:up_to_date_checks">增量构建</a></p>
</li>
<li>
<p>易于与构建的其他部分集成，例如依赖项配置</p>
</li>
<li>
<p>更多惯用的构建脚本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>也就是说，使用没有直接等效项的Ant任务会很方便，例如<code><checksum></code>和<code><chown></code> 。即使这样，从长远来看，最好将它们转换为使用标准Java API或第三方库来实现同一目的的本地Gradle任务类型。</p>
</div>
<div class="paragraph">
<p>这是Ant构建所使用的最常见的文件相关元素，以及Gradle等效项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><copy></code> -更喜欢Gradle <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">Copy</a>任务类型</p>
</li>
<li>
<p><code><zip></code> （加上Java变体）-首选<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">Zip</a>任务类型（加上<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">Jar</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.War.html">War</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ear.Ear.html">Ear</a> ）</p>
</li>
<li>
<p><code><unzip></code> —最好将<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)">Project.zipTree（）</a>方法与<code>Copy</code>任务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以看到Gradle文件API的几个示例，并在“ <a href="#working_with_files">使用文件”</a>一章中了解有关它的更多信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">在路径和文件集上</div>
<div class="paragraph">
<p>Ant利用类路径结构和文件集的概念来使用户能够处理文件和目录的集合。Gradle有一个基于<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">FileCollection</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">FileTree</a>的更简单，更强大的模型，可以将其视为内部版本的对象。两种类型都允许基于Ant的glob语法进行过滤，例如<code>**/books_*</code> 。在“ <a href="#working_with_files">使用文件”</a>一章中了解有关Gradle文件API的这些类型和其他方面的更多信息。</p>
</div>
<div class="paragraph">
<p>您仍然可以通过构建从内部构建Ant路径和文件集。 <code>ant</code>对象，如果您需要与需要它们的Ant任务进行交互。有关<a href="#ant">Ant集成</a>的章节提供了同时使用这两个示例的示例<code><path></code>和<code><fileset></code> 。甚至<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html#addToAntBuilder-java.lang.Object-java.lang.String-org.gradle.api.file.FileCollection.AntType-">有一种方法<code>FileCollection</code></a>将文件集合转换为文件集或类似的Ant类型。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="migant:properties"><a class="anchor" href="#migant:properties"></a> <a class="link" href="#migant:properties">迁移蚂蚁属性</a></h4>
<div class="paragraph">
<p>Ant利用属性映射来存储可在整个构建过程中重复使用的值。这种方法的最大缺点是属性值都是字符串，并且属性本身的行为类似于全局变量。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="title">与Gradle中的Ant属性交互</div>
<div class="paragraph">
<p>有时，您可能想直接从Gradle构建中使用Ant任务，而该任务需要设置一个或多个Ant属性。在这种情况下，您可以通过<code>ant</code>对象，如<a href="#sec:ant_properties">使用Gradle</a>中的<a href="#sec:ant_properties">Ant</a>一章所述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle确实以<a href="#sec:project_properties">项目属性</a>的形式使用了类似的东西，这是参数化构建的合理方法。这些可以在命令行中的<a href="#sec:gradle_configuration_properties"><code>gradle.properties</code>文件</a> ，甚至通过特殊命名的系统属性和环境变量。</p>
</div>
<div class="paragraph">
<p>如果您已有现有的Ant属性文件，则可以将其内容复制到项目的<code>gradle.properties</code>文件。请注意以下两点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>设定的属性<code>gradle.properties</code> <strong>不要</strong>覆盖在构建脚本中定义的具有相同名称的其他<a href="#sec:extra_properties">项目属性</a></p>
</li>
<li>
<p>导入的Ant任务不会自动“查看” Gradle项目属性-您必须将它们复制到Ant属性映射中才能实现</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要理解的另一个重要因素是，Gradle构建脚本可与面向对象的API一起使用，并且通常最好尽可能使用任务，源集和其他对象的属性。例如，此构建脚本片段创建用于将Javadoc文档打包为JAR并将其解压缩的任务，并通过其属性链接任务：</p>
</div>
<div class="exampleblock">
<div class="title">示例17使用任务属性代替项目属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext {
    tmpDistDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/dist</span><span class="delimiter">&quot;</span></span>)
}

task javadocJarArchive(<span class="key">type</span>: Jar) {
    from javadoc  // <b class="conum">(1)</b>
    archiveClassifier = <span class="string"><span class="delimiter">'</span><span class="content">javadoc</span><span class="delimiter">'</span></span>
}

task unpackJavadocs(<span class="key">type</span>: Copy) {
    from zipTree(javadocJarArchive.archiveFile)  // <b class="conum">(2)</b>
    into tmpDistDir  // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val tmpDistDir by extra { file(&quot;$buildDir/dist&quot;) }

tasks {
    register&lt;Jar&gt;(&quot;javadocJarArchive&quot;) {
        from(javadoc)  // <b class="conum">(1)</b>
        archiveClassifier.set(&quot;javadoc&quot;)
    }

    register&lt;Copy&gt;(&quot;unpackJavadocs&quot;) {
        from(zipTree(named&lt;Jar&gt;(&quot;javadocJarArchive&quot;).get().archiveFile))  // <b class="conum">(2)</b>
        into(tmpDistDir)  // <b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>全部打包<code>javadoc</code>的输出文件-等效于<code>from javadoc.destinationDir</code></p>
</li>
<li>
<p>使用由Java持有的Javadoc JAR的位置<code>javadocJar</code>任务</p>
</li>
<li>
<p>使用额外的项目属性，称为<code>tmpDistDir</code>定义“ dist”目录的位置</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>从示例中您可以看到<code>tmpDistDir</code> ，仍然经常需要通过属性定义路径等，这就是为什么Gradle还提供了可以附加到项目，任务和某些其他类型的对象上的<a href="#sec:extra_properties">额外属性的</a>原因。</p>
</div>
</div>
<div class="sect3">
<h4 id="migant:multi_project_builds"><a class="anchor" href="#migant:multi_project_builds"></a> <a class="link" href="#migant:multi_project_builds">迁移多项目构建</a></h4>
<div class="paragraph">
<p>多项目构建对于迁移是一个特殊的挑战，因为在Ant中没有用于构建它们或处理项目间依赖关系的标准方法。他们中的大多数人可能会使用<code><ant></code>以某种方式完成任务，但这就是人们可以说的全部。</p>
</div>
<div class="paragraph">
<p>幸运的是，Gradle的多项目支持可以处理相当不同的项目结构，并且在构建和维护多项目构建方面比Ant提供了更强大和有用的支持。的<code>ant.importBuild()</code>方法也可以处理<code><ant></code>和<code><antcall></code>透明地执行任务，从而可以分阶段迁移。</p>
</div>
<div class="paragraph">
<p>我们将在此处建议一个迁移过程，并希望它可以适合您的情况，或者至少可以给您一些想法。它像这样分解：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>从学习<a href="#multi_project_builds">Gradle如何配置多项目构建开始</a> 。</p>
</li>
<li>
<p>在构建的每个项目中创建一个Gradle构建脚本，将其内容设置为此行：</p>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild <span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>更换<code>build.xml</code>以及与项目相对应的实际Ant构建文件的路径。如果没有相应的Ant构建文件，请将Gradle构建脚本保留为空。在这种情况下，您的构建可能不适合这种迁移方法，但是请继续执行这些步骤，以查看是否仍然可以进行分阶段迁移。</p>
</div>
</li>
<li>
<p>创建一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])">包含所有</a>现在具有Gradle构建脚本<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])">的项目</a>的设置文件。</p>
</li>
<li>
<p>实现项目间的依赖关系。</p>
<div class="paragraph">
<p>多项目构建中的某些项目将取决于该构建中一个或多个其他项目产生的工件。这样的项目需要确保它们所依赖的那些项目已经产生了它们的工件，并且他们知道通往这些工件的路径。</p>
</div>
<div class="paragraph">
<p>确保所需工件的生产通常意味着要通过调用其他项目的构建<code><ant></code>任务。不幸的是，这会绕过Gradle构建，而忽略了您对Gradle构建脚本所做的任何更改。您将需要替换使用的目标<code><ant></code>具有Gradle <a href="#sec:adding_dependencies_to_tasks">任务依赖性的任务</a> 。</p>
</div>
<div class="paragraph">
<p>例如，假设您有一个Web项目，该项目依赖于同一构建中的“ util”库。“ web”的Ant构建文件可能具有这样的目标：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">web / build.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">    <span class="tag">&lt;target</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">buildRequiredProjects</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;ant</span> <span class="attribute-name">dir</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${root.dir}/util</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">target</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">build</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>  <b class="conum">(1)</b>
    <span class="tag">&lt;/target&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>root.dir</code>将必须由构建定义</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如下面的示例所示，假定“ web”项目的“ compile”任务是需要事先构建“ util”的事物，可以用相应的Gradle构建脚本中的项目间任务依赖关系来代替。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">web / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild <span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span>

compile.dependsOn = [ <span class="string"><span class="delimiter">'</span><span class="content">:util:build</span><span class="delimiter">'</span></span> ]</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">web / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;)

tasks {
    named&lt;Task&gt;(&quot;compile&quot;) {
        setDependsOn(listOf(&quot;:util:build&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>它不像Gradle的<a href="#sec:project_jar_dependencies">项目依赖项</a>那样健壮或强大，但是它解决了当前的问题，而无需对构建进行大的更改。请小心删除或覆盖对委派给其他子项目的任务的任何依赖，例如<code>buildRequiredProjects</code>任务。</p>
</div>
</li>
<li>
<p>确定不依赖于其他项目的项目，并将其迁移到惯用的Gradle构建脚本。</p>
<div class="paragraph">
<p>只需遵循本指南其余部分中的建议即可迁移单个项目构建。如其他地方所述，理想情况下，应尽可能使用Gradle标准插件。这可能意味着您需要为每个构建添加一个额外的复制任务，以将生成的工件复制到其余Ant构建所期望的位置。</p>
</div>
</li>
<li>
<p>当项目完全依赖于具有完全迁移的Gradle构建的项目时，即可进行迁移。</p>
<div class="paragraph">
<p>此时，您应该能够切换到使用附加到适当的依赖性配置的适当的项目依赖性。</p>
</div>
</li>
<li>
<p>一旦没有任何Ant构建依赖项目，请清理它们。</p>
<div class="paragraph">
<p>在第5步中，我们提到您可能需要添加复制任务才能满足从属Ant构建的要求。一旦这些构建已被迁移，就不再需要这种构建逻辑，应将其删除。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>在该过程的最后，您应该拥有一个Gradle构建，您可以确信它可以按预期工作，并且构建逻辑比以前少得多。</p>
</div>
</div>
<div class="sect3">
<h4 id="further_reading_2"><a class="anchor" href="#further_reading_2"></a> <a class="link" href="#further_reading_2">进一步阅读</a></h4>
<div class="paragraph">
<p>本章涵盖了特定于将Ant构建迁移到Gradle的主要主题。剩下的就是迁移期间或迁移之后可能有用的其他一些方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解如何配置Gradle的<a href="#build_environment">构建环境</a> ，包括用于运行Gradle的JVM设置</p>
</li>
<li>
<p>了解如何<a href="#organizing_gradle_projects">有效构建构建</a></p>
</li>
<li>
<p><a href="#logging">配置Gradle的日志</a>并在构建中使用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后，本指南仅涉及Gradle的一些功能，我们鼓励您从用户手册的其他章节以及教程式的<a href="https://guides.gradle.org/">Gradle指南中</a>了解其余内容。</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="sect1">
<h2 id="part:running_builds"><a class="anchor" href="#part:running_builds"></a> <a class="link" href="#part:running_builds">运行Gradle构建</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="build_environment"><a class="anchor" href="#build_environment"></a> <a class="link" href="#build_environment">搭建环境</a></h3>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">有兴趣配置构建缓存以加快构建速度吗？<a href="https://gradle.com/training/build-cache-deep-dive/?bid=docs-build-environment">在此处注册</a>以参加我们的Build Cache培训课程，以了解顶级工程团队用来提高构建速度的一些技巧。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph lead">
<p>Gradle提供了多种机制来配置Gradle本身和特定项目的行为。以下是使用这些机制的参考。</p>
</div>
<div class="paragraph">
<p>在配置Gradle行为时，您可以使用以下方法，以从高到低的优先级顺序列出（第一个获胜）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#command_line_interface">命令行标志，</a>例如<code>--build-cache</code> 。这些优先于属性和环境变量。</p>
</li>
<li>
<p><a href="#sec:gradle_system_properties">系统属性，</a>例如<code>systemProp.http.proxyHost=somehost.org</code>存储在<code>gradle.properties</code>文件。</p>
</li>
<li>
<p><a href="#sec:gradle_configuration_properties">Gradle属性，</a>例如<code>org.gradle.caching=true</code>通常存储在<code>gradle.properties</code>项目根目录中的文件或<code>GRADLE_USER_HOME</code>环境变量。</p>
</li>
<li>
<p><a href="#sec:gradle_environment_variables">环境变量，</a>例如<code>GRADLE_OPTS</code>源于执行Gradle的环境。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了配置构建环境外，您还可以使用<a href="#sec:project_properties">Project属性</a>配置给定的项目构建，例如<code>-PreleaseType=final</code> 。</p>
</div>
<div class="sect3">
<h4 id="sec:gradle_configuration_properties"><a class="anchor" href="#sec:gradle_configuration_properties"></a> <a class="link" href="#sec:gradle_configuration_properties">摇篮属性</a></h4>
<div class="paragraph">
<p>Gradle提供了几个选项，可以轻松配置将用于执行构建的Java流程。虽然可以通过您的本地环境配置这些<code>GRADLE_OPTS</code>要么<code>JAVA_OPTS</code> ，将某些设置（例如JVM内存配置和Java主目录）存储在版本控制中非常有用，这样整个团队就可以在一致的环境中工作。</p>
</div>
<div class="paragraph">
<p>为构建建立一致的环境就像将这些设置放入<code>gradle.properties</code>文件。配置是您所有的组合<code>gradle.properties</code>文件，但如果在多个位置配置了一个选项，则<em>第一个赢</em> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>系统属性，例如何时<code>-Dgradle.user.home</code>在命令行上设置。</p>
</li>
<li>
<p><code>gradle.properties</code>在<code>GRADLE_USER_HOME</code>目录。</p>
</li>
<li>
<p><code>gradle.properties</code>在项目根目录中。</p>
</li>
<li>
<p><code>gradle.properties</code>在Gradle安装目录中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下属性可用于配置Gradle构建环境：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.gradle.caching=(true,false)</code></dt>
<dd>
<p>设置为true时，Gradle将在可能的情况下重用任何先前构建的任务输出，从而使构建速度更快。了解有关<a href="#build_cache">使用构建缓存的</a>更多信息。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.caching.debug=(true,false)</code></dt>
<dd>
<p>设置为true时，单个输入属性哈希值和每个任务的构建缓存键都记录在控制台上。了解有关<a href="#sec:task_output_caching">任务输出缓存的</a>更多信息。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.configureondemand=(true,false)</code></dt>
<dd>
<p>启用<a href="#sec:configuration_on_demand">按需</a>孵化<a href="#sec:configuration_on_demand">配置</a> ，Gradle将尝试仅配置必要的项目。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.console=(auto,plain,rich,verbose)</code></dt>
<dd>
<p>自定义控制台输出的颜色或详细程度。默认值取决于如何调用Gradle。有关其他详细信息，请参见<a href="#sec:command_line_logging">命令行日志记录</a> 。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.daemon=(true,false)</code></dt>
<dd>
<p>设置为<code>true</code> <a href="#gradle_daemon">Gradle守护程序</a>用于运行构建。默认为<code>true</code> 。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.daemon.idletimeout=(# of idle millis)</code></dt>
<dd>
<p>在指定的空闲毫秒数后，Gradle守护程序将自行终止。默认为<code>10800000</code> （3小时）。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.debug=(true,false)</code></dt>
<dd>
<p>设置为<code>true</code> ，Gradle将在启用远程调试的情况下运行构建，并监听端口5005。请注意，这等同于添加<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005</code>到JVM命令行，并将挂起虚拟机，直到连接了调试器。默认为<code>false</code> 。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.java.home=(path to JDK home)</code></dt>
<dd>
<p>指定用于Gradle构建过程的Java主页。该值可以设置为<code>jdk</code>要么<code>jre</code>但是，根据构建的功能，使用JDK更为安全。合理的默认值源自您的环境（ <code>JAVA_HOME</code>或通往<code>java</code> ）（如果未指定设置）。这不会影响用于启动Gradle客户端VM的Java版本（ <a href="#sec:gradle_environment_variables">请参阅环境变量</a> ）。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.jvmargs=(JVM arguments)</code></dt>
<dd>
<p>指定用于Gradle守护程序的JVM参数。该设置对于<a href="#sec:configuring_jvm_memory">配置JVM内存设置</a>以提高构建性能特别有用。这不会影响Gradle客户端VM的JVM设置。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.logging.level=(quiet,warn,lifecycle,info,debug)</code></dt>
<dd>
<p>当设置为安静，警告，生命周期，信息或调试时，Gradle将使用此日志级别。这些值不区分大小写。的<code>lifecycle</code>级别是默认值。请参阅<a href="#sec:choosing_a_log_level">选择日志级别</a> 。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.parallel=(true,false)</code></dt>
<dd>
<p>配置后，Gradle会分叉至<code>org.gradle.workers.max</code> JVM并行执行项目。要了解有关并行任务执行的更多信息，请参阅<a href="https://guides.gradle.org/performance/#parallel_execution">Gradle性能指南</a> 。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.warning.mode=(all,fail,summary,none)</code></dt>
<dd>
<p>设置为<code>all</code> ， <code>summary</code>要么<code>none</code> ，Gradle将使用不同的警告类型显示。有关详细信息，请参见<a href="#sec:command_line_logging">命令行日志记录选项</a> 。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.workers.max=(max # of worker processes)</code></dt>
<dd>
<p>配置后，Gradle将使用最多给定数量的工人。默认值为CPU处理器数。另请参阅<a href="#sec:command_line_performance">性能命令行选项</a> 。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.priority=(low,normal)</code></dt>
<dd>
<p>指定Gradle守护程序及其启动的所有进程的调度优先级。默认为<code>normal</code> 。另请参阅<a href="#sec:command_line_performance">性能命令行选项</a> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>下面的示例演示各种属性的用法。</p>
</div>
<div class="exampleblock">
<div class="title">示例18使用gradle.properties文件设置属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">gradlePropertiesProp=gradlePropertiesValue
sysProp=shouldBeOverWrittenBySysProp
systemProp.system=systemValue</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task printProps {
    doLast {
        println commandLineProjectProp
        println gradlePropertiesProp
        println systemProjectProp
        println <span class="predefined-type">System</span>.properties[<span class="string"><span class="delimiter">'</span><span class="content">system</span><span class="delimiter">'</span></span>]
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Project properties can be accessed via delegation
val commandLineProjectProp: String by project
val gradlePropertiesProp: String by project
val systemProjectProp: String by project

tasks.register(&quot;printProps&quot;) {
    doLast {
        println(commandLineProjectProp)
        println(gradlePropertiesProp)
        println(systemProjectProp)
        println(System.getProperty(&quot;system&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle -q -PcommandLineProjectProp=commandLineProjectPropValue -Dorg.gradle.project.systemProjectProp=systemPropertyValue printProps
commandLineProjectPropValue
gradlePropertiesValue
systemPropertyValue
systemValue</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:gradle_system_properties"><a class="anchor" href="#sec:gradle_system_properties"></a> <a class="link" href="#sec:gradle_system_properties">系统属性</a></h4>
<div class="paragraph">
<p>使用<code>-D</code>命令行选项，您可以将系统属性传递给运行Gradle的JVM。的<code>-D</code>的选项<code>gradle</code>该命令与<code>-D</code>的选项<code>java</code>命令。</p>
</div>
<div class="paragraph">
<p>您还可以在以下位置设置系统属性<code>gradle.properties</code>带有前缀的文件<code>systemProp.</code></p>
</div>
<div class="listingblock">
<div class="title">在中指定系统属性<code>gradle.properties</code></div>
<div class="content">
<pre>systemProp.gradle.wrapperUser=myuser
systemProp.gradle.wrapperPassword=mypassword</pre>
</div>
</div>
<div class="paragraph">
<p>以下系统属性可用。请注意，命令行选项优先于系统属性。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>gradle.wrapperUser=(myuser)</code></dt>
<dd>
<p>指定用户名以使用HTTP基本认证从服务器下载Gradle发行版。在<a href="#sec:authenticated_download">身份验证的包装下载中</a>了解更多信息。</p>
</dd>
<dt class="hdlist1"><code>gradle.wrapperPassword=(mypassword)</code></dt>
<dd>
<p>指定使用Gradle包装器下载Gradle发行版的密码。</p>
</dd>
<dt class="hdlist1"><code>gradle.user.home=(path to directory)</code></dt>
<dd>
<p>指定Gradle用户的主目录。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在多项目构建中，“ <code>systemProp.</code>在除根目录以外的任何项目中设置的属性都将被忽略。也就是说，只有根项目的<code>gradle.properties</code>将检查文件中以“ <code>systemProp.</code> “ 字首。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:gradle_environment_variables"><a class="anchor" href="#sec:gradle_environment_variables"></a> <a class="link" href="#sec:gradle_environment_variables">环境变量</a></h4>
<div class="paragraph">
<p>以下环境变量可用于<code>gradle</code>命令。请注意，命令行选项和系统属性优先于环境变量。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>GRADLE_OPTS</code></dt>
<dd>
<p>指定启动Gradle客户端VM时要使用的JVM参数。客户端VM仅处理命令行输入/输出，因此很少需要更改其VM选项。实际的构建由Gradle守护程序运行，不受此环境变量的影响。</p>
</dd>
<dt class="hdlist1"><code>GRADLE_USER_HOME</code></dt>
<dd>
<p>指定Gradle用户的主目录（默认为<code>$USER_HOME/.gradle</code>如果未设置）。</p>
</dd>
<dt class="hdlist1"><code>JAVA_HOME</code></dt>
<dd>
<p>指定要用于客户端VM的JDK安装目录。除非在Gradle属性文件中指定了另一个虚拟机，否则该虚拟机也用于守护程序。 <code>org.gradle.java.home</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:project_properties"><a class="anchor" href="#sec:project_properties"></a> <a class="link" href="#sec:project_properties">项目性质</a></h4>
<div class="paragraph">
<p>您可以通过将属性直接添加到您的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a>对象<code>-P</code>命令行选项。</p>
</div>
<div class="paragraph">
<p>当Gradle看到特别命名的系统属性或环境变量时，它也可以设置项目属性。如果环境变量名称看起来像<code>ORG_GRADLE_PROJECT<em>_prop</em>=somevalue</code> ，那么Gradle将设置一个<code>prop</code>项目对象的属性，其值为<code>somevalue</code> 。Gradle还为系统属性支持此功能，但是具有不同的命名模式，看起来像<code>org.gradle.project.<em>prop</em></code> 。以下两项都将<code>foo</code>项目对象上的属性<code>"bar"</code> 。</p>
</div>
<div class="listingblock">
<div class="title">通过系统属性设置项目属性</div>
<div class="content">
<pre>org.gradle.project.foo=bar</pre>
</div>
</div>
<div class="listingblock">
<div class="title">通过环境变量设置项目属性</div>
<div class="content">
<pre>ORG_GRADLE_PROJECT_foo=bar</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>用户主目录中的属性文件优先于项目目录中的属性文件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当您对连续集成服务器没有管理员权限并且需要设置不容易看到的属性值时，此功能非常有用。由于您无法使用<code>-P</code>在这种情况下，如果不选择该选项，也不要更改系统级配置文件，则正确的策略是更改连续集成构建作业的配置，并添加与预期模式匹配的环境变量设置。这对于系统上的普通用户是不可见的。</p>
</div>
<div class="paragraph">
<p>您可以像使用变量一样使用名称来访问构建脚本中的项目属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果引用了项目属性但该属性不存在，则将引发异常，并且构建将失败。</p>
</div>
<div class="paragraph">
<p>在使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:hasProperty(java.lang.String)">Project.hasProperty（java.lang。）访问可选项目属性之前，应检查是否存在可选项目属性</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:hasProperty(java.lang.String)">。字符串）</a>方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_jvm_memory"><a class="anchor" href="#sec:configuring_jvm_memory"></a> <a class="link" href="#sec:configuring_jvm_memory">配置JVM内存</a></h4>
<div class="paragraph">
<p>您可以通过以下方式调整Gradle的JVM选项：</p>
</div>
<div class="paragraph">
<p>的<code>org.gradle.jvmargs</code> Gradle属性控制运行构建的VM。默认为<code>-Xmx512m "-XX:MaxMetaspaceSize=256m"</code></p>
</div>
<div class="listingblock">
<div class="title">更改构建VM的JVM设置</div>
<div class="content">
<pre>org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>JAVA_OPTS</code>环境变量控制命令行客户端，该客户端仅用于显示控制台输出。默认为<code>-Xmx64m</code></p>
</div>
<div class="listingblock">
<div class="title">更改客户端VM的JVM设置</div>
<div class="content">
<pre>JAVA_OPTS="-Xmx64m -XX:MaxPermSize=64m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8"</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在一种情况下，客户端VM也可以用作构建VM：如果停用<a href="#gradle_daemon">Gradle Daemon</a> ，并且客户端VM具有与构建VM所需的相同设置，则客户端VM将直接运行构建。否则，客户端虚拟机将派生一个新的虚拟机来运行实际的构建，以便采用不同的设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>某些任务，例如<code>test</code>任务，还分叉其他JVM进程。您可以通过任务本身来配置它们。他们都用<code>-Xmx512m</code>默认。</p>
</div>
<div class="exampleblock">
<div class="title">示例19设置<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a>任务的Java编译选项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}

tasks.withType(JavaCompile) {
    options.compilerArgs += [<span class="string"><span class="delimiter">'</span><span class="content">-Xdoclint:none</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">-Xlint:none</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">-nowarn</span><span class="delimiter">'</span></span>]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}

tasks.withType&lt;JavaCompile&gt;().configureEach {
    options.compilerArgs = listOf(&quot;-Xdoclint:none&quot;, &quot;-Xlint:none&quot;, &quot;-nowarn&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">Test</a> API文档中的其他示例，以及<a href="#sec:test_execution">Java插件参考中的测试执行</a> 。</p>
</div>
<div class="paragraph">
<p><a href="https://scans.gradle.com">使用</a>您的主机时， <a href="https://scans.gradle.com">构建扫描</a>会告诉您有关执行构建的JVM的信息。 <code>--scan</code>选项。</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://scans.gradle.com/s/sample/cpp-parallel/infrastructure"><img src="img/build-scan-infrastructure.png" alt="构建扫描中的构建环境"></a>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_task_using_project_properties"><a class="anchor" href="#sec:configuring_task_using_project_properties"></a> <a class="link" href="#sec:configuring_task_using_project_properties">使用项目属性配置任务</a></h4>
<div class="paragraph">
<p>可以根据调用时指定的项目属性来更改任务的行为。</p>
</div>
<div class="paragraph">
<p>假设您想确保发布版本仅由CI触发。一种简单的解决方法是通过<code>isCI</code>项目属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例20防止释放到CI外</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task performRelease {
    doLast {
        <span class="keyword">if</span> (project.hasProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">isCI</span><span class="delimiter">&quot;</span></span>)) {
            println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Performing release actions</span><span class="delimiter">&quot;</span></span>)
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidUserDataException(<span class="string"><span class="delimiter">&quot;</span><span class="content">Cannot perform release outside of CI</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;performRelease&quot;) {
    doLast {
        if (project.hasProperty(&quot;isCI&quot;)) {
            println(&quot;Performing release actions&quot;)
        } else {
            throw InvalidUserDataException(&quot;Cannot perform release outside of CI&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle performRelease -PisCI=true --quiet
Performing release actions</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:accessing_the_web_via_a_proxy"><a class="anchor" href="#sec:accessing_the_web_via_a_proxy"></a> <a class="link" href="#sec:accessing_the_web_via_a_proxy">通过HTTP代理访问网络</a></h4>
<div class="paragraph">
<p>通过标准JVM系统属性来配置HTTP或HTTPS代理（例如，用于下载依赖项）。这些属性可以直接在构建脚本中设置。例如，设置HTTP代理主机可以通过<code>System.setProperty('http.proxyHost', 'www.somehost.org')</code> 。另外，可以<a href="#sec:gradle_configuration_properties">在gradle.properties中指定</a>属性。</p>
</div>
<div class="listingblock">
<div class="title">使用配置HTTP代理<code>gradle.properties</code></div>
<div class="content">
<pre>systemProp.http.proxyHost=www.somehost.org
systemProp.http.proxyPort=8080
systemProp.http.proxyUser=userid
systemProp.http.proxyPassword=password
systemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost</pre>
</div>
</div>
<div class="paragraph">
<p>HTTPS有单独的设置。</p>
</div>
<div class="listingblock">
<div class="title">使用配置HTTPS代理<code>gradle.properties</code></div>
<div class="content">
<pre>systemProp.https.proxyHost=www.somehost.org
systemProp.https.proxyPort=8080
systemProp.https.proxyUser=userid
systemProp.https.proxyPassword=password
systemProp.https.nonProxyHosts=*.nonproxyrepos.com|localhost</pre>
</div>
</div>
<div class="paragraph">
<p>您可能需要设置其他属性才能访问其他网络。这里有2个参考可能会有所帮助：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://git-wip-us.apache.org/repos/asf?p=ant.git;a=blob;f=src/main/org/apache/tools/ant/util/ProxySetup.java;hb=HEAD">Ant代码库中的ProxySetup.java</a></p>
</li>
<li>
<p><a href="http://download.oracle.com/javase/7/docs/technotes/guides/net/properties.html">JDK 7网络属性</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="ntlm_authentication"><a class="anchor" href="#ntlm_authentication"></a> <a class="link" href="#ntlm_authentication">NTLM身份验证</a></h5>
<div class="paragraph">
<p>如果您的代理服务器需要NTLM身份验证，则可能需要提供身份验证域以及用户名和密码。您可以通过两种方式提供用于向NTLM代理进行身份验证的域：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>设置<code>http.proxyUser</code>系统属性的值如<code><em>domain</em>/<em>username</em></code> 。</p>
</li>
<li>
<p>通过提供身份验证域<code>http.auth.ntlm.domain</code>系统属性。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gradle_daemon"><a class="anchor" href="#gradle_daemon"></a> <a class="link" href="#gradle_daemon">Gradle守护程序</a></h3>
<div class="quoteblock">
<blockquote>守护程序是一种计算机程序，它作为后台进程运行，而不是受交互式用户的直接控制。
</blockquote>
<div class="attribution">—维基百科</div>
</div>
<div class="paragraph">
<p>Gradle在Java虚拟机（JVM）上运行，并使用一些支持库，这些库需要很短的初始化时间。结果，有时启动似乎有些慢。解决此问题的方法是Gradle <em>Daemon</em> ：这是一个长期存在的后台进程，与以往相比，它可以更快地执行构建。通过避免昂贵的引导过程以及利用缓存（将有关项目的数据保留在内存中），我们可以实现这一目标。使用Daemon运行Gradle构建与没有运行没有什么不同。只需配置您是否要使用它-其他所有事情都由Gradle透明地处理。</p>
</div>
<div class="sect3">
<h4 id="sec:why_the_daemon"><a class="anchor" href="#sec:why_the_daemon"></a> <a class="link" href="#sec:why_the_daemon">为什么Gradle Daemon对性能很重要</a></h4>
<div class="paragraph">
<p>守护进程是一个长期存在的过程，因此我们不仅可以避免每次构建都需要启动JVM的开销，而且还可以在内存中缓存有关项目结构，文件，任务等的信息。</p>
</div>
<div class="paragraph">
<p>推理很简单：通过重用以前构建的计算来提高构建速度。但是，这样做的好处是巨大的：我们通常会在以后的构建中将构建时间减少15-75％。我们建议您使用<code>--profile</code>来了解Gradle守护程序可以为您带来的影响。</p>
</div>
<div class="paragraph">
<p>默认情况下，Gradle Daemon从Gradle 3.0开始启用，因此您无需做任何事情即可从中受益。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:status"><a class="anchor" href="#sec:status"></a> <a class="link" href="#sec:status">运行守护程序状态</a></h4>
<div class="paragraph">
<p>要获取正在运行的Gradle守护进程及其状态的列表，请使用<code>--status</code>命令。</p>
</div>
<div class="paragraph">
<p>样本输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>    PID VERSION                 STATUS
  28411 3.0                     IDLE
  34247 3.0                     BUSY</code></pre>
</div>
</div>
<div class="paragraph">
<p>当前，给定的Gradle版本只能连接到相同版本的守护程序。这意味着状态输出将仅显示正在调用的Gradle版本的守护程序，而不显示任何其他版本的守护程序。Gradle的未来版本将解除此约束，并将显示所有Gradle版本的正在运行的守护程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:disabling_the_daemon"><a class="anchor" href="#sec:disabling_the_daemon"></a> <a class="link" href="#sec:disabling_the_daemon">禁用守护程序</a></h4>
<div class="paragraph">
<p>Gradle守护程序默认情况下处于启用状态，我们建议始终启用它。有几种方法可以禁用守护程序，但是最常见的一种方法是添加该行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>org.gradle.daemon=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>到文件<code>«USER_HOME»/.gradle/gradle.properties</code> ，在哪里<code>«USER_HOME»</code>是您的主目录。通常是以下之一，具体取决于您的平台：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>C:\Users\<username></code> （Windows Vista和7+）</p>
</li>
<li>
<p><code>/Users/<username></code> （苹果系统）</p>
</li>
<li>
<p><code>/home/<username></code> （Linux）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果该文件不存在，请使用文本编辑器创建它。您可以在下面的“ <a href="#daemon_faq">守护程序常见问题”中</a>找到其他禁用（启用）守护<a href="#daemon_faq">程序的</a>方法的详细信息。该部分还包含有关守护程序如何工作的更多详细信息。</p>
</div>
<div class="paragraph">
<p>请注意，启用了守护程序后，无论特定构建使用的Gradle版本如何，所有构建都将利用速度提升。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="title">持续集成</div>
<div class="paragraph">
<p>从Gradle 3.0开始，我们默认启用Daemon并建议将其用于开发人员的计算机和Continuous Integration服务器。但是，如果您怀疑Daemon使CI构建不稳定，则可以将其禁用以对每个构建使用全新的运行时，因为运行时与任何先前的构建<em>完全</em>隔离。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:stopping_an_existing_daemon"><a class="anchor" href="#sec:stopping_an_existing_daemon"></a> <a class="link" href="#sec:stopping_an_existing_daemon">停止现有的守护程序</a></h4>
<div class="paragraph">
<p>如前所述，守护进程是一个后台进程。不过，您不必担心计算机上会建立Gradle进程。与可用系统总内存相比，每个守护程序都会监视其内存使用情况，如果可用系统内存不足，则每台守护程序都会在空闲时停止运行。如果出于任何原因要显式停止运行Daemon进程，请使用以下命令<code>gradle --stop</code> 。</p>
</div>
<div class="paragraph">
<p>这将终止所有与用于执行命令的相同Gradle版本一起启动的Daemon进程。如果您安装了Java开发工具包（JDK），则可以通过运行Java调试器轻松地验证守护程序是否已停止<code>jps</code>命令。您将看到列出的所有正在运行的守护程序，名称如下： <code>GradleDaemon</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="daemon_faq"><a class="anchor" href="#daemon_faq"></a> <a class="link" href="#daemon_faq">常问问题</a></h4>
<div class="sect4">
<h5 id="sec:ways_to_disable_gradle_daemon"><a class="anchor" href="#sec:ways_to_disable_gradle_daemon"></a> <a class="link" href="#sec:ways_to_disable_gradle_daemon">如何禁用Gradle守护程序？</a></h5>
<div class="paragraph">
<p>有两种建议的方法可以持久禁用环境的守护程序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过环境变量：添加标志<code>-Dorg.gradle.daemon=false</code>到<code>GRADLE_OPTS</code>环境变量</p>
</li>
<li>
<p>通过属性文件：添加<code>org.gradle.daemon=false</code>到<code>«GRADLE_USER_HOME»/gradle.properties</code>文件</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>注意， <code>«GRADLE_USER_HOME»</code>默认为<code>«USER_HOME»/.gradle</code> ，在哪里<code>«USER_HOME»</code>是当前用户的主目录。可以通过<code>-g</code>和<code>--gradle-user-home</code>命令行开关，以及通过<code>GRADLE_USER_HOME</code>环境变量和<code>org.gradle.user.home</code> JVM系统属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>两种方法具有相同的效果。使用哪一个取决于个人喜好。大多数Gradle用户选择第二个选项并将条目添加到用户<code>gradle.properties</code>文件。</p>
</div>
<div class="paragraph">
<p>在Windows上，此命令将为当前用户禁用守护程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>(if not exist "%USERPROFILE%/.gradle" mkdir "%USERPROFILE%/.gradle") &amp;&amp; (echo. &gt;&gt; "%USERPROFILE%/.gradle/gradle.properties" &amp;&amp; echo org.gradle.daemon=false &gt;&gt; "%USERPROFILE%/.gradle/gradle.properties")</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类似UNIX的操作系统上，以下Bash shell命令将为当前用户禁用守护程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">mkdir -p ~/.gradle &amp;&amp; echo &quot;org.gradle.daemon=false&quot; &gt;&gt; ~/.gradle/gradle.properties</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦以这种方式为构建环境禁用了守护程序，除非使用以下命令明确请求，否则不会启动Gradle守护程序。 <code>--daemon</code>选项。</p>
</div>
<div class="paragraph">
<p>的<code>--daemon</code>和<code>--no-daemon</code>命令行选项，在使用Gradle命令行界面时，可启用和禁用守护程序用于单独的构建调用。在考虑构建环境时，这些命令行选项具有<em>最高</em>优先级。通常，为环境（例如用户帐户）启用守护程序更为方便，以便所有构建都使用守护程序而无需记住提供<code>--daemon</code>选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:why_is_there_more_than_one_daemon_process_on_my_machine"><a class="anchor" href="#sec:why_is_there_more_than_one_daemon_process_on_my_machine"></a> <a class="link" href="#sec:why_is_there_more_than_one_daemon_process_on_my_machine">为什么我的机器上有多个守护进程？</a></h5>
<div class="paragraph">
<p>Gradle为什么要创建一个新的守护进程，而不是使用已经运行的守护进程，有几个原因。基本规则是，如果没有可用的空闲或兼容守护程序，则Gradle将启动新的守护程序。Gradle将杀死任何闲置了3个小时或更长时间的守护进程，因此您不必担心手动清理它们。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">闲</dt>
<dd>
<p>空闲的守护程序是当前未执行构建或未执行其他有用工作的守护程序。</p>
</dd>
<dt class="hdlist1">兼容</dt>
<dd>
<p>兼容的守护程序是可以（或可以使其）满足所请求构建环境的要求的守护程序。用于执行构建的Java运行时是构建环境的一个示例方面。另一个示例是构建运行时所需的JVM系统属性集。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>守护程序可能无法满足请求的构建环境的某些方面。如果守护程序与Java 8运行时一起运行，但是请求的环境要求Java 10，则该守护程序不兼容，必须启动另一个守护程序。而且，一旦JVM启动，就无法更改Java运行时的某些属性。例如，不可能更改内存分配（例如<code>-Xmx1024m</code> ），默认文本编码，正在运行的JVM的默认语言环境等。</p>
</div>
<div class="paragraph">
<p>通常从构建客户端（例如Gradle命令行客户端，IDE等）环境的各个方面隐式构建“请求的构建环境”，并通过命令行开关和设置显式构建“请求的构建环境”。有关如何指定和控制<a href="#build_environment">构建环境</a>的详细信息，请参见<a href="#build_environment">构建</a>环境。</p>
</div>
<div class="paragraph">
<p>以下JVM系统属性实际上是不可变的。如果所请求的构建环境需要这些属性中的任何一个，且其值与守护程序的JVM具有的该属性的值不同，则守护程序不兼容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>file.encoding</p>
</li>
<li>
<p>用户语言</p>
</li>
<li>
<p>用户国家</p>
</li>
<li>
<p>用户变量</p>
</li>
<li>
<p>java.io.tmpdir</p>
</li>
<li>
<p>javax.net.ssl.keyStore</p>
</li>
<li>
<p>javax.net.ssl.keyStorePassword</p>
</li>
<li>
<p>javax.net.ssl.keyStoreType</p>
</li>
<li>
<p>javax.net.ssl.trustStore</p>
</li>
<li>
<p>javax.net.ssl.trustStorePassword</p>
</li>
<li>
<p>javax.net.ssl.trustStoreType</p>
</li>
<li>
<p>com.sun.management.jmxremote</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由启动参数控制的以下JVM属性也实际上是不可变的。为了使守护程序兼容，请求的构建环境和守护程序的环境的相应属性必须完全匹配。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>最大堆大小（即-Xmx JVM参数）</p>
</li>
<li>
<p>最小堆大小（即-Xms JVM参数）</p>
</li>
<li>
<p>引导类路径（即-Xbootclasspath参数）</p>
</li>
<li>
<p>“断言”状态（即-ea参数）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所需的Gradle版本是所请求的构建环境的另一方面。守护进程与特定的Gradle运行时耦合。在使用不同Gradle版本的会话中处理多个Gradle项目是导致多个Daemon进程运行的常见原因。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:how_much_memory_does_the_daemon_use_and_can_i_give_it_more"><a class="anchor" href="#sec:how_much_memory_does_the_daemon_use_and_can_i_give_it_more"></a> <a class="link" href="#sec:how_much_memory_does_the_daemon_use_and_can_i_give_it_more">守护程序使用多少内存，我可以给它更多空间吗？</a></h5>
<div class="paragraph">
<p>如果请求的构建环境未指定最大堆大小，则守护程序将使用最多512MB的堆。它将使用JVM的默认最小堆大小。对于大多数构建来说，512MB绰绰有余。具有数百个子项目的较大内部版本，大量配置和源代码可能需要或具有更好的性能，并具有更多的内存。</p>
</div>
<div class="paragraph">
<p>要增加守护程序可以使用的内存量，请在请求的构建环境中指定适当的标志。有关详细信息，请参见<a href="#build_environment">Build Environment</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:how_can_i_stop_a_daemon"><a class="anchor" href="#sec:how_can_i_stop_a_daemon"></a> <a class="link" href="#sec:how_can_i_stop_a_daemon">如何停止守护程序？</a></h5>
<div class="paragraph">
<p>闲置3个小时或更短的时间后，守护进程将自动终止。如果您希望在此之前停止Daemon进程，则可以通过操作系统终止该进程或运行该进程。 <code>gradle --stop</code>命令。的<code>--stop</code> switch导致Gradle请求<em>所有</em>正在运行<em>的，与用于运行命令的Gradle版本相同的</em> Daemon进程自行终止。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:what_can_go_wrong_with_daemon"><a class="anchor" href="#sec:what_can_go_wrong_with_daemon"></a> <a class="link" href="#sec:what_can_go_wrong_with_daemon">守护程序会出什么问题？</a></h5>
<div class="paragraph">
<p>在日常开发中，使Daemon健壮，透明且不引人注目的工程已经投入了大量精力。但是，守护进程有时会被破坏或耗尽。Gradle构建从多个源执行任意代码。虽然Gradle本身是为Daemon设计并经过严格测试的，但用户构建脚本和第三方插件可能会通过内存泄漏或全局状态损坏等缺陷破坏Daemon进程的稳定性。</p>
</div>
<div class="paragraph">
<p>通过运行无法正确释放资源的构建，还可能破坏守护程序（通常是构建环境）的稳定性。当使用Microsoft Windows时，这是一个特别棘手的问题，因为它对读取或写入后无法关闭文件的程序的宽容度较小。</p>
</div>
<div class="paragraph">
<p>Gradle主动监视堆使用情况，并尝试检测何时泄漏开始耗尽守护程序中的可用堆空间。当检测到问题时，Gradle守护程序将完成当前正在运行的构建，并在下一个构建中主动重新启动该守护程序。默认情况下启用此监视，但是可以通过设置<code>org.gradle.daemon.performance.enable-monitoring</code>系统属性为false。</p>
</div>
<div class="paragraph">
<p>如果怀疑Daemon进程变得不稳定，则可以将其杀死。回想一下<code>--no-daemon</code>可以为构建指定开关，以防止使用守护程序。这对于诊断守护程序是否实际上是问题的元凶很有用。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:tools_and_ides"><a class="anchor" href="#sec:tools_and_ides"></a> <a class="link" href="#sec:tools_and_ides">工具和IDE</a></h4>
<div class="paragraph">
<p>IDE和其他工具用于与Gradle集成的<a href="#embedding">Gradle Tooling API</a> <em>始终</em>使用Gradle守护程序来执行构建。如果您要在IDE中执行Gradle构建，则您正在使用Gradle Daemon，不需要为您的环境启用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:how_does_the_gradle_daemon_make_builds_faster"><a class="anchor" href="#sec:how_does_the_gradle_daemon_make_builds_faster"></a> <a class="link" href="#sec:how_does_the_gradle_daemon_make_builds_faster">Gradle守护程序如何使构建更快？</a></h4>
<div class="paragraph">
<p>Gradle守护程序是一个<em>长期存在的</em>构建过程。在两次构建之间，它空闲地等待下一次构建。这具有明显的好处，即对于多个构建只需要一次将Gradle加载到内存中，而不是对于每个构建一次。这本身就是一项重大的性能优化，但并非止于此。</p>
</div>
<div class="paragraph">
<p>对于现代JVM性能而言，故事的重要部分是运行时代码优化。例如，HotSpot（Oracle提供的JVM实现，用作OpenJDK的基础）在运行时对代码进行优化。优化是渐进的，不是瞬时的。也就是说，在执行过程中对代码进行了逐步优化，这意味着纯粹由于此优化过程而使得后续构建可以更快。使用HotSpot进行的实验表明，需要5到10次构建才能稳定优化。守护程序的第一个构建和第10个构建之间的可感知构建时间差异可能非常明显。</p>
</div>
<div class="paragraph">
<p>守护程序还允许跨构建更有效地进行内存缓存。例如，构建所需的类（例如，插件，构建脚本）可以保存在构建之间的内存中。同样，Gradle可以维护构建数据的内存中缓存，例如用于增量构建的任务输入和输出的哈希值。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="init_scripts"><a class="anchor" href="#init_scripts"></a> <a class="link" href="#init_scripts">初始化脚本</a></h3>
<div class="paragraph">
<p>Gradle提供了一种强大的机制，可以根据当前环境自定义构建。该机制还支持希望与Gradle集成的工具。</p>
</div>
<div class="paragraph">
<p>请注意，这与“ <code>init</code> “ <code>build-init</code> ”插件（请参阅<a href="#build_init_plugin">Build Init插件</a> ）。</p>
</div>
<div class="sect3">
<h4 id="sec:basic_usage"><a class="anchor" href="#sec:basic_usage"></a> <a class="link" href="#sec:basic_usage">基本用法</a></h4>
<div class="paragraph">
<p>初始化脚本（又称<em>初始化脚本</em> ）与Gradle中的其他脚本相似。但是，这些脚本在构建开始之前运行。以下是几种可能的用途：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>设置企业范围的配置，例如在哪里可以找到自定义插件。</p>
</li>
<li>
<p>根据当前环境设置属性，例如开发人员的计算机与持续集成服务器。</p>
</li>
<li>
<p>提供构建所需的有关用户的个人信息，例如存储库或数据库身份验证凭据。</p>
</li>
<li>
<p>定义机器特定的详细信息，例如JDK的安装位置。</p>
</li>
<li>
<p>注册构建侦听器。希望监听Gradle事件的外部工具可能会发现这很有用。</p>
</li>
<li>
<p>注册构建记录器。您可能希望自定义Gradle如何记录它生成的事件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>初始化脚本的一个主要限制是它们无法访问<code>buildSrc</code>项目（有关此功能的详细信息，请参见<a href="#sec:build_sources">使用buildSrc提取命令式逻辑</a> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:using_an_init_script"><a class="anchor" href="#sec:using_an_init_script"></a> <a class="link" href="#sec:using_an_init_script">使用初始化脚本</a></h4>
<div class="paragraph">
<p>有几种使用初始化脚本的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在命令行上指定一个文件。命令行选项是<code>-I</code>要么<code>--init-script</code>然后是脚本的路径。命令行选项可以多次出现，每次添加另一个初始化脚本。如果命令行上指定的任何文件不存在，则构建将失败。</p>
</li>
<li>
<p>放置一个名为<code>init.gradle</code> （要么<code>init.gradle.kts</code>对于Kotlin） <code><em>USER_HOME</em>/.gradle/</code>目录。</p>
</li>
<li>
<p>放置一个以<code>.gradle</code> （要么<code>.init.gradle.kts</code>对于Kotlin） <code><em>USER_HOME</em>/.gradle/init.d/</code>目录。</p>
</li>
<li>
<p>放置一个以<code>.gradle</code> （要么<code>.init.gradle.kts</code>对于Kotlin） <code><em>GRADLE_HOME</em>/init.d/</code>目录，在Gradle发行版中。这使您可以打包包含一些自定义构建逻辑和插件的自定义Gradle发行版。您可以将其与<a href="#gradle_wrapper">Gradle包装器</a>结合使用，以使自定义逻辑可用于企业中的所有内部版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果发现一个以上的初始化脚本，它们将全部按照上述指定的顺序执行。给定目录中的脚本按字母顺序执行。例如，这允许使用一种工具在命令行上指定一个初始化脚本，并且用户可以将一个脚本放入其主目录中以定义环境，并且在执行Gradle时，这两个脚本都将运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:writing_an_init_script"><a class="anchor" href="#sec:writing_an_init_script"></a> <a class="link" href="#sec:writing_an_init_script">编写一个初始化脚本</a></h4>
<div class="paragraph">
<p>类似于Gradle构建脚本，初始化脚本是Groovy或Kotlin脚本。每个初始化脚本都有一个与之关联的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html">Gradle</a>实例。初始化脚本中的任何属性引用和方法调用都将委托给此对象<code>Gradle</code>实例。</p>
</div>
<div class="paragraph">
<p>每个初始化脚本还实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Script.html">脚本</a>接口。</p>
</div>
<div class="sect4">
<h5 id="sec:configuring_projects_from_an_init_script"><a class="anchor" href="#sec:configuring_projects_from_an_init_script"></a> <a class="link" href="#sec:configuring_projects_from_an_init_script">通过初始化脚本配置项目</a></h5>
<div class="paragraph">
<p>您可以使用初始化脚本来配置构建中的项目。这与在多项目构建中配置项目的方式类似。以下示例显示了<em>在</em>评估项目<em>之前</em>如何通过初始化脚本执行额外的配置。此样本使用此功能来配置额外的存储库，以仅用于某些环境。</p>
</div>
<div class="exampleblock">
<div class="title">示例21在评估项目之前，使用init脚本执行额外的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}

task showRepos {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">All repos:</span><span class="delimiter">&quot;</span></span>
        println repositories.collect { <span class="local-variable">it</span>.name }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">初始化等级</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    repositories {
        mavenLocal()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}

tasks.register(&quot;showRepos&quot;) {
    doLast {
        println(&quot;All repos:&quot;)
        //TODO:kotlin-dsl remove filter once we're no longer on a kotlin eap
        println(repositories.map { it.name }.filter { it != &quot;maven&quot; })
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">init.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    repositories {
        mavenLocal()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="output_when_applying_the_init_script"><a class="anchor" href="#output_when_applying_the_init_script"></a> <a class="link" href="#output_when_applying_the_init_script">应用初始化脚本时的输出</a></h6>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&gt; gradle --init-script init.gradle -q showRepos
All <span class="key">repos</span>:
[MavenLocal, MavenRepo]</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">&gt; gradle --init-script init.gradle.kts -q showRepos
All repos:
[MavenLocal, MavenRepo]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:custom_classpath"><a class="anchor" href="#sec:custom_classpath"></a> <a class="link" href="#sec:custom_classpath">初始化脚本的外部依赖关系</a></h4>
<div class="paragraph">
<p>在<a href="#sec:build_script_external_dependencies">构建脚本的外部依赖关系中，</a>说明了如何向构建脚本添加外部依赖关系。初始化脚本也可以声明依赖关系。您可以使用<code>initscript()</code>方法，传入一个声明初始化脚本类路径的闭包。</p>
</div>
<div class="exampleblock">
<div class="title">示例22声明初始化脚本的外部依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">初始化等级</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">initscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath <span class="string"><span class="delimiter">'</span><span class="content">org.apache.commons:commons-math:2.0</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">init.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">initscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath(&quot;org.apache.commons:commons-math:2.0&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>封闭传递给<code>initscript()</code>方法配置<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/initialization/dsl/ScriptHandler.html">ScriptHandler</a>实例。您可以通过将依赖项添加到<code>classpath</code>组态。这与您声明Java编译类路径的方式相同。您可以使用<a href="#">声明依赖项中</a>描述的任何依赖项类型，项目依赖项除外。</p>
</div>
<div class="paragraph">
<p>声明了初始化脚本的类路径后，您可以像使用该类路径上的任何其他类一样，使用初始化脚本中的类。以下示例将添加到前面的示例中，并使用init脚本classpath中的类。</p>
</div>
<div class="exampleblock">
<div class="title">示例23具有外部依赖项的初始化脚本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">初始化等级</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.apache.commons.math.fraction.Fraction</span>

initscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath <span class="string"><span class="delimiter">'</span><span class="content">org.apache.commons:commons-math:2.0</span><span class="delimiter">'</span></span>
    }
}

println Fraction.ONE_FIFTH.multiply(<span class="integer">2</span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">init.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.apache.commons.math.fraction.Fraction

initscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath(&quot;org.apache.commons:commons-math:2.0&quot;)
    }
}

println(Fraction.ONE_FIFTH.multiply(2))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>应用初始化脚本时的输出</p>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&gt; gradle --init-script init.gradle -q doNothing
<span class="integer">2</span> / <span class="integer">5</span></code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">&gt; gradle --init-script init.gradle.kts -q doNothing
2 / 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:init_script_plugins"><a class="anchor" href="#sec:init_script_plugins"></a> <a class="link" href="#sec:init_script_plugins">初始化脚本插件</a></h4>
<div class="paragraph">
<p>类似于Gradle构建脚本或Gradle设置文件，可以将插件应用于初始化脚本。</p>
</div>
<div class="exampleblock">
<div class="title">示例24在初始化脚本中使用插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">初始化等级</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: EnterpriseRepositoryPlugin

<span class="type">class</span> <span class="class">EnterpriseRepositoryPlugin</span> <span class="directive">implements</span> Plugin&lt;Gradle&gt; {

    <span class="directive">private</span> <span class="directive">static</span> <span class="predefined-type">String</span> ENTERPRISE_REPOSITORY_URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">https://repo.gradle.org/gradle/repo</span><span class="delimiter">&quot;</span></span>

    <span class="type">void</span> apply(Gradle gradle) {
        <span class="comment">// ONLY USE ENTERPRISE REPO FOR DEPENDENCIES</span>
        gradle.allprojects { project -&gt;
            project.repositories {

                <span class="comment">// Remove all repositories not pointing to the enterprise repository url</span>
                all { ArtifactRepository repo -&gt;
                    <span class="keyword">if</span> (!(repo <span class="keyword">instanceof</span> MavenArtifactRepository) ||
                          repo.url.toString() != ENTERPRISE_REPOSITORY_URL) {
                        project.logger.lifecycle <span class="string"><span class="delimiter">&quot;</span><span class="content">Repository </span><span class="inline"><span class="inline-delimiter">${</span>repo.url<span class="inline-delimiter">}</span></span><span class="content"> removed. Only </span><span class="inline"><span class="inline-delimiter">$</span>ENTERPRISE_REPOSITORY_URL</span><span class="content"> is allowed</span><span class="delimiter">&quot;</span></span>
                        remove repo
                    }
                }

                <span class="comment">// add the enterprise repository</span>
                maven {
                    name <span class="string"><span class="delimiter">&quot;</span><span class="content">STANDARD_ENTERPRISE_REPO</span><span class="delimiter">&quot;</span></span>
                    url ENTERPRISE_REPOSITORY_URL
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="comment">// tag::show-repos-task[]</span>
repositories{
    mavenCentral()
}

 task showRepositories {
     doLast {
         repositories.each {
             println <span class="string"><span class="delimiter">&quot;</span><span class="content">repository: </span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span>.name<span class="inline-delimiter">}</span></span><span class="content"> ('</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span>.url<span class="inline-delimiter">}</span></span><span class="content">')</span><span class="delimiter">&quot;</span></span>
         }
     }
}
<span class="comment">// end::show-repos-task[]</span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">init.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply&lt;EnterpriseRepositoryPlugin&gt;()

class EnterpriseRepositoryPlugin : Plugin&lt;Gradle&gt; {
    companion object {
        const val ENTERPRISE_REPOSITORY_URL = &quot;https://repo.gradle.org/gradle/repo&quot;
    }

    override fun apply(gradle: Gradle) {
        // ONLY USE ENTERPRISE REPO FOR DEPENDENCIES
        gradle.allprojects {
            repositories {

                // Remove all repositories not pointing to the enterprise repository url
                all {
                    if (this !is MavenArtifactRepository || url.toString() != ENTERPRISE_REPOSITORY_URL) {
                        project.logger.lifecycle(&quot;Repository ${(this as? MavenArtifactRepository)?.url ?: name} removed. Only $ENTERPRISE_REPOSITORY_URL is allowed&quot;)
                        remove(this)
                    }
                }

                // add the enterprise repository
                add(maven {
                    name = &quot;STANDARD_ENTERPRISE_REPO&quot;
                    url = uri(ENTERPRISE_REPOSITORY_URL)
                })
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// tag::show-repos-task[]
repositories{
    mavenCentral()
}

tasks.register(&quot;showRepositories&quot;) {
    doLast {
        repositories.map { it as MavenArtifactRepository }.forEach {
            println(&quot;repository: ${it.name} ('${it.url}')&quot;)
        }
    }
}
// end::show-repos-task[]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>应用初始化脚本时的输出</p>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&gt; gradle --init-script init.gradle -q showRepositories
<span class="key">repository</span>: STANDARD_ENTERPRISE_REPO (<span class="string"><span class="delimiter">'</span><span class="content">https://repo.gradle.org/gradle/repo</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">&gt; gradle --init-script init.gradle.kts -q showRepositories
repository: STANDARD_ENTERPRISE_REPO ('https://repo.gradle.org/gradle/repo')</code></pre>
</div>
</div>
<div class="paragraph">
<p>初始化脚本中的插件可确保在运行构建时仅使用指定的存储库。</p>
</div>
<div class="paragraph">
<p>在初始化脚本中应用插件时，Gradle实例化插件并调用插件实例的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html#apply-T-">Plugin.apply（T）</a>方法。的<code>gradle</code>对象作为参数传递，可用于配置构建的各个方面。当然，可以将应用的插件解析为外部依赖项，如<a href="#sec:custom_classpath">初始化脚本的外部依赖项中所述</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="intro_multi_project_builds"><a class="anchor" href="#intro_multi_project_builds"></a> <a class="link" href="#intro_multi_project_builds">执行多项目构建</a></h3>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">Gradle构建缓存可以帮助将多项目构建的构建时间减少多达90％。<a href="https://gradle.com/training/build-cache-deep-dive/?bid=docs-multi-project-builds">在此处注册</a>以参加我们的实时构建缓存培训课程，以了解如何进行。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除非碰巧是一个庞大的整体应用程序，否则只有最小的项目具有单个构建文件和源代码树。消化和理解一个项目的过程通常要容易得多，该项目被分为多个较小的，相互依赖的模块。但是，“相互依赖”一词很重要，这就是为什么您通常希望通过单个构建将模块链接在一起的原因。</p>
</div>
<div class="paragraph">
<p>Gradle通过<em>多项目</em>构建来支持此方案。</p>
</div>
<div class="sect3">
<h4 id="sec:structure_of_a_multiproject_build"><a class="anchor" href="#sec:structure_of_a_multiproject_build"></a> <a class="link" href="#sec:structure_of_a_multiproject_build">多项目构建的结构</a></h4>
<div class="paragraph">
<p>此类构建具有各种形状和大小，但它们确实具有一些共同的特征：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>settings.gradle</code>根目录或<code>master</code>项目目录</p>
</li>
<li>
<p>一种<code>build.gradle</code>根目录或<code>master</code>目录</p>
</li>
<li>
<p>有自己的子目录<code>*.gradle</code>构建文件（某些多项目构建可能会省略子项目构建脚本）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>settings.gradle</code>文件告诉Gradle项目和子项目的结构。幸运的是，您无需阅读此文件即可简单地了解项目结构，因为您可以运行以下命令<code>gradle projects</code> 。这是在Gradle示例中的Java <em>多项目</em>构建中使用该命令的输出：</p>
</div>
<div class="sect4">
<h5 id="example_listing_the_projects_in_a_build"><a class="anchor" href="#example_listing_the_projects_in_a_build"></a> <a class="link" href="#example_listing_the_projects_in_a_build">示例：列出构建中的项目</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q projects</code></strong></div>
<div class="content">
<pre>&gt; gradle -q projects

------------------------------------------------------------
Root project
------------------------------------------------------------

Root project 'multiproject'
+--- Project ':api'
+--- Project ':services'
|    +--- Project ':services:shared'
|    \--- Project ':services:webservice'
\--- Project ':shared'

To see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasks
For example, try running gradle :api:tasks</pre>
</div>
</div>
<div class="paragraph">
<p>这告诉您<em>multiproject</em>具有三个直接子项目： <em>api</em> ， <em>services</em>和<em>shared</em> 。然后， <em>services</em>项目具有其自己的子级， <em>shared</em>和<em>webservice</em> 。这些映射到目录结构，因此很容易找到它们。例如，你可以找到在<em>web服务</em> <code><root>/services/webservice</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，Gradle使用其找到的目录名称<code>settings.gradle</code>作为根项目的名称。这通常不会引起问题，因为所有开发人员在处理项目时都签出相同的目录名称。在Continuous Integration服务器上，例如Jenkins，目录名称可能是自动生成的，并且与VCS中的名称不匹配。因此，建议即使在单个项目构建中，也始终将根项目名称设置为可预测的名称。您可以通过设置配置根项目名称<code>rootProject.name</code> 。</p>
</div>
<div class="paragraph">
<p>每个项目通常都会有自己的构建文件，但不一定是这种情况。在上面的示例中， <em>服务</em>项目只是其他子项目的容器或分组。相应目录中没有构建文件。但是， <em>多</em>项目的根项目确实有一个。</p>
</div>
<div class="paragraph">
<p>根<code>build.gradle</code>通常用于在子项目之间共享通用配置，例如通过对所有子项目应用相同的插件集和依赖项。当最好将所有配置都放在一个位置时，它也可以用于配置单个子项目。这意味着在发现特定子项目的配置方式时，应始终检查根构建文件。</p>
</div>
<div class="paragraph">
<p>要记住的另一件事是，可能不会调用构建文件<code>build.gradle</code> 。许多项目将在子项目名称之后命名构建文件，例如<code>api.gradle</code>和<code>services.gradle</code>来自上一个示例。这种方法在IDE中有很大帮助，因为很难确定<code>build.gradle</code>您要打开的文件有二十种。这小小的魔力是由<code>settings.gradle</code>文件，但是作为构建用户，您无需了解其操作的详细信息。只需浏览一下子项目目录，即可找到带有<code>.gradle</code>后缀。</p>
</div>
<div class="paragraph">
<p>一旦知道哪些子项目可用，构建用户的关键问题就是如何在项目中执行任务。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:executing_a_multiproject_build"><a class="anchor" href="#sec:executing_a_multiproject_build"></a> <a class="link" href="#sec:executing_a_multiproject_build">执行多项目构建</a></h4>
<div class="paragraph">
<p>从用户的角度来看，多项目构建仍然是您可以运行的任务的集合。不同之处在于您可能想控制要执行<em>哪个</em>项目的任务。您在这里有两个选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>转到与您感兴趣的子项目相对应的目录，然后执行<code>gradle <task></code>像平常一样。</p>
</li>
<li>
<p>使用任何目录中的合格任务名称，尽管通常是从根目录完成的。例如： <code>gradle :services:webservice:build</code>将构建<em>webservice</em>子项目及其依赖的任何子项目。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一种方法类似于单项目用例，但在多项目构建的情况下，Gradle的工作方式略有不同。命令<code>gradle test</code>将执行<code>test</code>相对于当前工作目录的任何子项目中具有该任务的任务。因此，如果您从根项目目录运行命令，则将运行<code>test</code>在<em>api中</em> ， <em>shared</em> ， <em>services：shared</em>和<em>services：webservice</em> 。如果从services项目目录运行命令，则将仅在<em>services：shared</em>和<em>services：webservice中</em>执行任务。</p>
</div>
<div class="paragraph">
<p>为了更好地控制执行的内容，请使用限定名称（提到的第二种方法）。这些路径与目录路径一样，但是使用“：”代替“ /”或“ \”。如果路径以“：”开头，则相对于根项目解析路径。换句话说，前导“：”代表根项目本身。所有其他冒号都是路径分隔符。</p>
</div>
<div class="paragraph">
<p>这种方法适用于任何任务，因此，如果您想知道特定子项目中的任务，只需使用<code>tasks</code>任务，例如<code>gradle :services:webservice:tasks</code> 。</p>
</div>
<div class="paragraph">
<p>无论您使用哪种技术来执行任务，Gradle都会负责构建目标依赖的任何子项目。您不必自己担心项目间的依赖性。如果您对如何配置感兴趣，可以<a href="#multi_project_builds">稍后在用户手册中</a>阅读有关编写多项目构建的信息。</p>
</div>
<div class="paragraph">
<p>最后一件事要注意。使用Gradle包装器时，第一种方法效果不佳，因为如果不在项目根目录中，则必须指定包装器脚本的路径。例如，如果您在<em>webservice</em>子项目目录中，则必须运行<code>../../gradlew build</code> 。</p>
</div>
<div class="paragraph">
<p>作为构建用户，这就是您真正需要了解的多项目构建的全部内容。现在，您可以确定一个构建是否是一个多项目构建，并可以发现其结构。最后，您可以在特定子项目中执行任务。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build_cache"><a class="anchor" href="#build_cache"></a> <a class="link" href="#build_cache">构建缓存</a></h3>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">是否想了解顶级工程团队用来保持构建快速和高性能的提示和技巧？<a href="https://gradle.com/training/build-cache-deep-dive/?bid=docs-build-cache">在此处注册</a>以获取我们的构建缓存培训。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">此处描述的构建缓存功能与<a href="https://developer.android.com/studio/build/build-cache.html">Android插件构建缓存不同</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="sec:build_cache_intro"><a class="anchor" href="#sec:build_cache_intro"></a> <a class="link" href="#sec:build_cache_intro">总览</a></h4>
<div class="paragraph">
<p>Gradle <em>构建缓存</em>是一种缓存机制，旨在通过重用其他构建生成的输出来节省时间。构建缓存通过以下方式工作：存储（本地或远程）构建输出，并允许构建在确定输入未更改时从缓存中获取这些输出，从而避免了重新生成它们的昂贵工作。</p>
</div>
<div class="paragraph">
<p>使用构建缓存的第一个功能是<em>任务输出缓存</em> 。本质上，任务输出缓存利用与Gradle用于避免以前的本地版本已经产生一组任务输出<a href="#sec:up_to_date_checks">的最新检查</a>相同的情报。但是，任务输出缓存不仅限于同一个工作空间中的先前版本，还使Gradle可以重用本地计算机上任何位置的任何早期版本的任务输出。当使用共享的构建缓存进行任务输出缓存时，这甚至可以在开发人员机器和构建代理之间使用。</p>
</div>
<div class="paragraph">
<p>除任务外， <a href="#sec:abm_artifact_transforms">工件转换</a>还可以利用构建缓存并<a href="#sec:abm_artifact_transforms">像</a>任务输出缓存一样重复使用其输出。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">有关学习如何使用构建缓存的动手方法，请尝试<a href="https://guides.gradle.org/using-build-cache/">使用“构建缓存”</a>指南。它涵盖了可以改进缓存的不同方案，并详细讨论了为构建启用缓存时需要注意的不同警告。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_cache_enable"><a class="anchor" href="#sec:build_cache_enable"></a> <a class="link" href="#sec:build_cache_enable">启用构建缓存</a></h4>
<div class="paragraph">
<p>默认情况下，不启用构建缓存。您可以通过以下两种方式启用构建缓存：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">与运行<code>--build-cache</code>在命令行上</dt>
<dd>
<p>Gradle仅将构建缓存用于此构建。</p>
</dd>
<dt class="hdlist1">放<code>org.gradle.caching=true</code>在你的<code>gradle.properties</code></dt>
<dd>
<p>Gradle将尝试为所有构建重用先前构建的输出，除非已明确禁用<code>--no-build-cache</code> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>启用构建缓存后，它将在Gradle用户主目录中存储构建输出。有关配置此目录或其他类型的构建缓存的信息，请参阅“ <a href="#sec:build_cache_configure">配置构建缓存”</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:task_output_caching"><a class="anchor" href="#sec:task_output_caching"></a> <a class="link" href="#sec:task_output_caching">任务输出缓存</a></h4>
<div class="paragraph">
<p>除了<a href="#sec:up_to_date_checks">最新检查中</a>描述的增量构建之外，Gradle还可以通过将输入与任务匹配来重用任务以前执行的输出，从而节省时间。任务输出可以通过构建缓存在一台计算机上的构建之间，甚至在不同计算机上运行的构建之间重复使用。</p>
</div>
<div class="paragraph">
<p>我们关注的用例是用户拥有一个组织范围的远程构建缓存，该缓存由连续的集成构建定期填充。开发人员和其他持续集成代理应从远程构建缓存中加载缓存条目。我们预计将不允许开发人员填充远程构建缓存，并且所有连续集成构建都会在运行完后填充构建缓存。 <code>clean</code>任务。</p>
</div>
<div class="paragraph">
<p>为了使您的构建能够很好地使用任务输出缓存，它必须与<a href="#sec:up_to_date_checks">增量构建</a>功能一起正常工作。例如，当连续两次运行构建时，所有带有输出的任务都应为<code>UP-TO-DATE</code> 。在不满足此先决条件的情况下启用任务输出缓存时，您不能期望更快的构建或正确的构建。</p>
</div>
<div class="paragraph">
<p>启用构建缓存时，将自动启用任务输出缓存，请参阅<a href="#sec:build_cache_enable">启用构建缓存</a> 。</p>
</div>
<div class="sect4">
<h5 id="sec:task_output_caching_example"><a class="anchor" href="#sec:task_output_caching_example"></a> <a class="link" href="#sec:task_output_caching_example">它是什么样子的</a></h5>
<div class="paragraph">
<p>让我们从使用Java插件的项目开始，该项目具有一些Java源文件。我们是第一次运行构建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; gradle --build-cache compileJava
:compileJava
:processResources
:classes
:jar
:assemble

BUILD SUCCESSFUL</pre>
</div>
</div>
<div class="paragraph">
<p>我们在输出中看到本地构建缓存使用的目录。除此之外，构建与没有构建缓存的情况相同。让我们清理并再次运行构建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; gradle clean
:clean

BUILD SUCCESSFUL</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; gradle --build-cache assemble
:compileJava FROM-CACHE
:processResources
:classes
:jar
:assemble

BUILD SUCCESSFUL</pre>
</div>
</div>
<div class="paragraph">
<p>现在我们看到了，而不是执行<code>:compileJava</code>任务，该任务的输出已从构建缓存中加载。由于其他任务不可缓存，因此尚未从构建缓存中加载其他任务。这是因为<code>:classes</code>和<code>:assemble</code>是<a href="#sec:lifecycle_tasks">生命周期的任务，</a>并且<code>:processResources</code>和<code>:jar</code>是不可复制的类似复制的任务，因为执行它们通常更快。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:task_output_caching_details"><a class="anchor" href="#sec:task_output_caching_details"></a> <a class="link" href="#sec:task_output_caching_details">可缓存的任务</a></h4>
<div class="paragraph">
<p>由于任务描述了其所有输入和输出，因此Gradle可以计算生成<em>缓存密钥</em> ，该<em>密钥</em>根据其输入唯一定义任务的输出。该构建缓存键用于从构建缓存请求先前的输出或将新的输出存储在构建缓存中。如果以前的构建输出已经被其他人（例如您的持续集成服务器或其他开发人员）存储在缓存中，则可以避免在本地执行大多数任务。</p>
</div>
<div class="paragraph">
<p>以下输入<a href="#sec:how_does_it_work">以与最新检查</a>相同的方式为任务的构建高速缓存键提供帮助：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任务类型及其类路径</p>
</li>
<li>
<p>输出属性的名称</p>
</li>
<li>
<p>如<a href="#sec:task_input_output_annotations">“自定义任务类型”一节中</a>所述，注释的属性名称和值</p>
</li>
<li>
<p>DSL通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputs.html">TaskInputs</a>添加的属性的名称和值</p>
</li>
<li>
<p>Gradle发行版，buildSrc和插件的类路径</p>
</li>
<li>
<p>当构建脚本影响任务执行时的内容</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>任务类型需要使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/CacheableTask.html">@CacheableTask</a>批注选择加入任务输出缓存。请注意， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/CacheableTask.html">@ CacheableTask</a>不是子类继承的。自定义任务类型默认情况下<em>不可</em>缓存。</p>
</div>
<div class="sect4">
<h5 id="sec:task_output_caching_cacheable_tasks"><a class="anchor" href="#sec:task_output_caching_cacheable_tasks"></a> <a class="link" href="#sec:task_output_caching_cacheable_tasks">内置可缓存任务</a></h5>
<div class="paragraph">
<p>当前，以下内置Gradle任务是可缓存的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java工具链： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.javadoc.Javadoc.html">Javadoc</a></p>
</li>
<li>
<p>Groovy工具链： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.GroovyCompile.html">GroovyCompile</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.javadoc.Groovydoc.html">Groovydoc</a></p>
</li>
<li>
<p>Scala工具链： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.scala.ScalaCompile.html">ScalaCompile</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/scala/tasks/PlatformScalaCompile.html">PlatformScalaCompile</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.scala.ScalaDoc.html">ScalaDoc</a></p>
</li>
<li>
<p>本机工具链： <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/cpp/tasks/CppCompile.html">CppCompile</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/c/tasks/CCompile.html">CCompile</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/swift/tasks/SwiftCompile.html">SwiftCompile</a></p>
</li>
<li>
<p>测试： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试</a></p>
</li>
<li>
<p>代码质量任务： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Checkstyle.html">Checkstyle</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CodeNarc.html">CodeNarc</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Pmd.html">Pmd</a></p>
</li>
<li>
<p>JaCoCo： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoMerge.html">JacocoMerge</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html">JacocoReport</a></p>
</li>
<li>
<p>其他任务： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.antlr.AntlrTask.html">AntlrTask</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/devel/tasks/ValidatePlugins.html">ValidatePlugins</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.WriteProperties.html">WriteProperties</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当前所有其他内置任务都不可缓存。</p>
</div>
<div class="paragraph">
<p>诸如<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">Copy</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">Jar之</a>类的某些任务通常没有意义使其可缓存，因为Gradle只是将文件从一个位置复制到另一位置。使不产生输出或没有任务动作的可缓存任务也没有意义。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:task_output_caching_cacheable_3rd_party"><a class="anchor" href="#sec:task_output_caching_cacheable_3rd_party"></a> <a class="link" href="#sec:task_output_caching_cacheable_3rd_party">第三方插件</a></h5>
<div class="paragraph">
<p>有一些第三方插件可以很好地与构建缓存配合使用。最突出的示例是<a href="https://developer.android.com/studio/releases/gradle-plugin.html">Android插件3.1+</a>和<a href="https://blog.gradle.org/kotlin-build-cache-use">Kotlin插件1.2.21+</a> 。对于其他第三方插件，请查看其文档以了解它们是否支持构建缓存。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:task_output_caching_inputs"><a class="anchor" href="#sec:task_output_caching_inputs"></a> <a class="link" href="#sec:task_output_caching_inputs">声明任务输入和输出</a></h5>
<div class="paragraph">
<p>具有可缓存任务的输入和输出的完整图片非常重要，这样一个构建的结果可以安全地在其他地方重复使用。</p>
</div>
<div class="paragraph">
<p>缺少任务输入会导致不正确的缓存命中，其中，由于两个执行都使用相同的缓存键，因此不同的结果被视为相同。如果Gradle不能完全捕获给定任务的所有输出，则缺少任务输出会导致构建失败。错误声明的任务输入会导致高速缓存未命中，尤其是在包含易失性数据或绝对路径时。（有关应声明为输入和输出的信息，请参见<a href="#sec:task_inputs_outputs">“任务输入和输出”一</a>节。）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>任务路径<em>不是</em>构建缓存键的输入。这意味着具有不同任务路径的任务可以重用彼此的输出，只要Gradle确定执行它们会产生相同的结果即可。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了确保正确声明了输入和输出，请使用集成测试（例如，使用TestKit）检查任务是否为相同的输入产生相同的输出并捕获该任务的所有输出文件。我们建议添加测试以确保任务输入可重定位，即可以将任务从缓存加载到其他构建目录中（请参阅<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/PathSensitive.html">@PathSensitive</a> ）。</p>
</div>
<div class="paragraph">
<p>为了处理任务的易失性输入，请考虑<a href="#sec:configure_input_normalization">配置输入标准化</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enable_caching_of_non_cacheable_tasks"><a class="anchor" href="#enable_caching_of_non_cacheable_tasks"></a> <a class="link" href="#enable_caching_of_non_cacheable_tasks">启用不可缓存任务的缓存</a></h4>
<div class="paragraph">
<p>如我们所见，如果内置任务或插件提供的任务的类用注释，则可以缓存。 <code>Cacheable</code>注解。但是，如果您想使可缓存任务成为其不可缓存的类，该怎么办？让我们举一个具体的例子：您的构建脚本使用通用<code>NpmTask</code>通过委派NPM（并运行）来创建JavaScript包的任务<code>npm run bundle</code> ）。此过程类似于复杂的编译任务，但是<code>NpmTask</code>太通用了，默认情况下无法缓存：它只接受参数并使用这些参数运行npm。</p>
</div>
<div class="paragraph">
<p>这个任务的输入和输出很容易弄清楚。输入是包含JavaScript文件和NPM配置文件的目录。输出是此任务生成的捆绑文件。</p>
</div>
<div class="sect4">
<h5 id="using_annotations"><a class="anchor" href="#using_annotations"></a> <a class="link" href="#using_annotations">使用注释</a></h5>
<div class="paragraph">
<p>我们创建一个子类<code>NpmTask</code>并使用<a href="#sec:task_input_output_annotations">注释声明输入和输出</a> 。</p>
</div>
<div class="paragraph">
<p>如果可能，最好使用委托而不是创建子类。内置的就是这种情况<code>JavaExec</code> ， <code>Exec</code> ， <code>Copy</code>和<code>Sync</code>任务，其中有一个方法<code>Project</code>做实际的工作。</p>
</div>
<div class="paragraph">
<p>如果您是现代JavaScript开发人员，那么您就会知道捆绑可能会很长，值得缓存。为此，我们需要使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/CacheableTask.html">@CacheableTask</a>批注告诉Gradle它允许缓存该任务的输出。</p>
</div>
<div class="paragraph">
<p>这足以使任务可缓存在您自己的计算机上。但是，默认情况下，输入文件由其绝对路径标识。因此，如果需要在使用不同路径的几个开发人员或计算机之间共享缓存，则将无法正常工作。因此，我们还需要设置<a href="https://guides.gradle.org/using-build-cache/#relocatability">路径灵敏度</a> 。在这种情况下，可以使用输入文件的相对路径来标识它们。</p>
</div>
<div class="paragraph">
<p>注意，可以通过覆盖基类的getter并对该方法进行注释来覆盖基类的属性注释。</p>
</div>
<div class="exampleblock">
<div class="title">示例25自定义可缓存BundleTask</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@CacheableTask</span>                                       // <b class="conum">(1)</b>
<span class="type">class</span> <span class="class">BundleTask</span> <span class="directive">extends</span> NpmTask {

    <span class="annotation">@Override</span> <span class="annotation">@Internal</span>                              // <b class="conum">(2)</b>
    ListProperty&lt;<span class="predefined-type">String</span>&gt; getArgs() {
        <span class="local-variable">super</span>.getArgs()
    }

    <span class="annotation">@InputDirectory</span>
    <span class="annotation">@SkipWhenEmpty</span>
    <span class="annotation">@PathSensitive</span>(PathSensitivity.RELATIVE)         // <b class="conum">(3)</b>
    <span class="directive">final</span> DirectoryProperty scripts = project.objects.directoryProperty()

    <span class="annotation">@InputFiles</span>
    <span class="annotation">@PathSensitive</span>(PathSensitivity.RELATIVE)         // <b class="conum">(4)</b>
    <span class="directive">final</span> ConfigurableFileCollection configFiles = project.files()

    <span class="annotation">@OutputFile</span>
    <span class="directive">final</span> RegularFileProperty bundle = project.objects.fileProperty()

    BundleTask() {
        args.addAll(<span class="string"><span class="delimiter">&quot;</span><span class="content">run</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bundle</span><span class="delimiter">&quot;</span></span>)
        bundle.set(project.layout.buildDirectory.file(<span class="string"><span class="delimiter">&quot;</span><span class="content">bundle.js</span><span class="delimiter">&quot;</span></span>))
        scripts.set(project.layout.projectDirectory.dir(<span class="string"><span class="delimiter">&quot;</span><span class="content">scripts</span><span class="delimiter">&quot;</span></span>))
        configFiles.from(project.layout.projectDirectory.file(<span class="string"><span class="delimiter">&quot;</span><span class="content">package.json</span><span class="delimiter">&quot;</span></span>))
        configFiles.from(project.layout.projectDirectory.file(<span class="string"><span class="delimiter">&quot;</span><span class="content">package-lock.json</span><span class="delimiter">&quot;</span></span>))
    }
}

task bundle(<span class="key">type</span>: BundleTask)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">@CacheableTask                                       // <b class="conum">(1)</b>
open class BundleTask : NpmTask() {

    @get:Internal                                    // <b class="conum">(2)</b>
    override val args
        get() = super.args


    @get:InputDirectory
    @get:SkipWhenEmpty
    @get:PathSensitive(PathSensitivity.RELATIVE)     // <b class="conum">(3)</b>
    val scripts: DirectoryProperty = project.objects.directoryProperty()

    @get:InputFiles
    @get:PathSensitive(PathSensitivity.RELATIVE)     // <b class="conum">(4)</b>
    val configFiles: ConfigurableFileCollection = project.files()

    @get:OutputFile
    val bundle: RegularFileProperty = project.objects.fileProperty()

    init {
        args.addAll(&quot;run&quot;, &quot;bundle&quot;)
        bundle.set(project.layout.buildDirectory.file(&quot;bundle.js&quot;))
        scripts.set(project.layout.projectDirectory.dir(&quot;scripts&quot;))
        configFiles.from(project.layout.projectDirectory.file(&quot;package.json&quot;))
        configFiles.from(project.layout.projectDirectory.file(&quot;package-lock.json&quot;))
    }
}

tasks.register&lt;BundleTask&gt;(&quot;bundle&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>（1）添加<code>@Cacheable</code>为任务启用缓存。</p>
</li>
<li>
<p>（2）重写基类的属性的getter以将输入注释更改为<code>@Internal</code> 。</p>
</li>
<li>
<p>（3）（4）声明路径灵敏度。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="using_the_runtime_api"><a class="anchor" href="#using_the_runtime_api"></a> <a class="link" href="#using_the_runtime_api">使用运行时API</a></h5>
<div class="paragraph">
<p>如果由于某种原因无法创建新的自定义任务类，则还可以使用<a href="#sec:task_input_output_runtime_api">运行时API</a>声明输入和输出，从而使任务可缓存。</p>
</div>
<div class="paragraph">
<p>要为任务启用缓存，您需要使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskOutputs.html#cacheIf-org.gradle.api.specs.Spec-">TaskOutputs.cacheIf（）</a>方法。</p>
</div>
<div class="paragraph">
<p>通过运行时API进行的声明与上述注释具有相同的效果。请注意，您无法通过运行时API覆盖文件输入和输出。通过指定相同的属性名称，可以覆盖输入属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例26。使捆绑任务可缓存</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task bundle(<span class="key">type</span>: NpmTask) {
    args = [<span class="string"><span class="delimiter">'</span><span class="content">run</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">bundle</span><span class="delimiter">'</span></span>]

    outputs.cacheIf { <span class="predefined-constant">true</span> }

    inputs.dir(file(<span class="string"><span class="delimiter">&quot;</span><span class="content">scripts</span><span class="delimiter">&quot;</span></span>))
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">scripts</span><span class="delimiter">&quot;</span></span>)
        .withPathSensitivity(PathSensitivity.RELATIVE)

    inputs.files(<span class="string"><span class="delimiter">&quot;</span><span class="content">package.json</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">package-lock.json</span><span class="delimiter">&quot;</span></span>)
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">configFiles</span><span class="delimiter">&quot;</span></span>)
        .withPathSensitivity(PathSensitivity.RELATIVE)

    outputs.file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/bundle.js</span><span class="delimiter">&quot;</span></span>)
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">bundle</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;NpmTask&gt;(&quot;bundle&quot;) {
    args.set(listOf(&quot;run&quot;, &quot;bundle&quot;))

    outputs.cacheIf { true }

    inputs.dir(file(&quot;scripts&quot;))
        .withPropertyName(&quot;scripts&quot;)
        .withPathSensitivity(PathSensitivity.RELATIVE)

    inputs.files(&quot;package.json&quot;, &quot;package-lock.json&quot;)
        .withPropertyName(&quot;configFiles&quot;)
        .withPathSensitivity(PathSensitivity.RELATIVE)

    outputs.file(&quot;$buildDir/bundle.js&quot;)
        .withPropertyName(&quot;bundle&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_cache_configure"><a class="anchor" href="#sec:build_cache_configure"></a> <a class="link" href="#sec:build_cache_configure">配置构建缓存</a></h4>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:buildCache(org.gradle.api.Action)">Settings.buildCache（org.gradle.api。动作）</a>阻止<code>settings.gradle</code> 。</p>
</div>
<div class="paragraph">
<p>Gradle支持<code>local</code>和一个<code>remote</code>可以单独配置的构建缓存。启用两个构建缓存后，Gradle会先尝试从本地构建缓存加载构建输出，然后如果找不到构建输出，则尝试远程构建缓存。如果在远程缓存中找到了输出，则它们也将存储在本地缓存中，因此下次将在本地找到它们。Gradle存储（“推送”）构建输出在已启用并且将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/caching/configuration/BuildCache.html#isPush--">BuildCache.isPush（）</a>设置为<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，本地构建缓存已启用推送，而远程构建缓存已禁用推送。</p>
</div>
<div class="paragraph">
<p>本地构建缓存已预先配置为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.local.DirectoryBuildCache.html">DirectoryBuildCache</a>并默认启用。可以通过指定要连接到的构建缓存的类型来配置远程构建缓存（ <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.configuration.BuildCacheConfiguration.html#org.gradle.caching.configuration.BuildCacheConfiguration:remote(java.lang.Class)">BuildCacheConfiguration.remote（java.lang。类）</a> ）。</p>
</div>
<div class="sect4">
<h5 id="sec:build_cache_configure_local"><a class="anchor" href="#sec:build_cache_configure_local"></a> <a class="link" href="#sec:build_cache_configure_local">内置本地构建缓存</a></h5>
<div class="paragraph">
<p>内置的本地构建缓存<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.local.DirectoryBuildCache.html">DirectoryBuildCache</a>使用一个目录来存储构建缓存工件。默认情况下，该目录位于Gradle用户主目录中，但其位置是可配置的。</p>
</div>
<div class="paragraph">
<p>Gradle将通过删除最近尚未使用的条目来节省磁盘空间，从而定期清理本地缓存目录。</p>
</div>
<div class="paragraph">
<p>有关配置选项的更多详细信息，请参考<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.local.DirectoryBuildCache.html">DirectoryBuildCache</a>的DSL文档。这是配置示例。</p>
</div>
<div class="exampleblock">
<div class="title">示例27配置本地缓存</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildCache {
    local {
        directory = <span class="keyword">new</span> <span class="predefined-type">File</span>(rootDir, <span class="string"><span class="delimiter">'</span><span class="content">build-cache</span><span class="delimiter">'</span></span>)
        removeUnusedEntriesAfterDays = <span class="integer">30</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildCache {
    local {
        directory = File(rootDir, &quot;build-cache&quot;)
        removeUnusedEntriesAfterDays = 30
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:build_cache_configure_remote"><a class="anchor" href="#sec:build_cache_configure_remote"></a> <a class="link" href="#sec:build_cache_configure_remote">远程HTTP构建缓存</a></h5>
<div class="paragraph">
<p>Gradle具有内置支持，可通过HTTP连接到远程构建缓存后端。有关协议外观的更多详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.http.HttpBuildCache.html">HttpBuildCache</a> 。请注意，通过使用以下配置，本地构建缓存将用于存储构建输出，而本地和远程构建缓存将用于检索构建输出。</p>
</div>
<div class="exampleblock">
<div class="title">示例28。从HttpBuildCache加载</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildCache {
    remote(HttpBuildCache) {
        url = <span class="string"><span class="delimiter">'</span><span class="content">https://example.com:8123/cache/</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildCache {
    remote&lt;HttpBuildCache&gt; {
        url = uri(&quot;https://example.com:8123/cache/&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以配置<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.http.HttpBuildCache.html">HttpBuildCache</a>用于访问构建缓存服务器的凭据，如以下示例所示。</p>
</div>
<div class="exampleblock">
<div class="title">示例29。配置远程HTTP缓存</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildCache {
    remote(HttpBuildCache) {
        url = <span class="string"><span class="delimiter">'</span><span class="content">https://example.com:8123/cache/</span><span class="delimiter">'</span></span>
        credentials {
            username = <span class="string"><span class="delimiter">'</span><span class="content">build-cache-user</span><span class="delimiter">'</span></span>
            password = <span class="string"><span class="delimiter">'</span><span class="content">some-complicated-password</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildCache {
    remote&lt;HttpBuildCache&gt; {
        url = uri(&quot;https://example.com:8123/cache/&quot;)
        credentials {
            username = &quot;build-cache-user&quot;
            password = &quot;some-complicated-password&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>当您尝试将生成缓存后端与HTTPS URL结合使用时，可能会遇到不受信任的SSL证书问题。理想的解决方案是为某人添加有效的SSL证书到构建缓存后端，但是我们认识到您可能无法做到这一点。在这种情况下，请将<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.caching.http.HttpBuildCache.html#org.gradle.caching.http.HttpBuildCache:allowUntrustedServer">HttpBuildCache.isAllowUntrustedServer（）</a>设置为<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>这是一个方便的解决方法，但是您不应该将其用作长期解决方案。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例30允许不受信任的缓存服务器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildCache {
    remote(HttpBuildCache) {
        url = <span class="string"><span class="delimiter">'</span><span class="content">https://example.com:8123/cache/</span><span class="delimiter">'</span></span>
        allowUntrustedServer = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildCache {
    remote&lt;HttpBuildCache&gt; {
        url = uri(&quot;https://example.com:8123/cache/&quot;)
        isAllowUntrustedServer = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:build_cache_configure_use_cases"><a class="anchor" href="#sec:build_cache_configure_use_cases"></a> <a class="link" href="#sec:build_cache_configure_use_cases">配置用例</a></h5>
<div class="paragraph">
<p>远程构建缓存的推荐用例是，连续集成服务器从干净的构建中填充它，而开发人员仅从其加载。然后，配置将如下所示。</p>
</div>
<div class="exampleblock">
<div class="title">示例31。CI推送用例的推荐设置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">boolean</span> isCiServer = <span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>)

buildCache {
    remote(HttpBuildCache) {
        url = <span class="string"><span class="delimiter">'</span><span class="content">https://example.com:8123/cache/</span><span class="delimiter">'</span></span>
        push = isCiServer
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val isCiServer = System.getenv().containsKey(&quot;CI&quot;)

buildCache {
    remote&lt;HttpBuildCache&gt; {
        url = uri(&quot;https://example.com:8123/cache/&quot;)
        isPush = isCiServer
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用<code>buildSrc</code>目录，则应确保它使用与主构建相同的构建缓存配置。这可以通过将相同的脚本应用于<code>buildSrc/settings.gradle</code>和<code>settings.gradle</code>如以下示例所示。</p>
</div>
<div class="exampleblock">
<div class="title">示例32buildSrc和主构建的一致设置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">from</span>: <span class="keyword">new</span> <span class="predefined-type">File</span>(settingsDir, <span class="string"><span class="delimiter">'</span><span class="content">gradle/buildCacheSettings.gradle</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">gradle / buildCacheSettings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">boolean</span> isCiServer = <span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>)

buildCache {
    local {
        enabled = !isCiServer
    }
    remote(HttpBuildCache) {
        url = <span class="string"><span class="delimiter">'</span><span class="content">https://example.com:8123/cache/</span><span class="delimiter">'</span></span>
        push = isCiServer
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">buildSrc / settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">from</span>: <span class="keyword">new</span> <span class="predefined-type">File</span>(settingsDir, <span class="string"><span class="delimiter">'</span><span class="content">../gradle/buildCacheSettings.gradle</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(from = File(settingsDir, &quot;gradle/buildCacheSettings.gradle.kts&quot;))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">gradle / buildCacheSettings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val isCiServer = System.getenv().containsKey(&quot;CI&quot;)

buildCache {
    local {
        isEnabled = !isCiServer
    }
    remote&lt;HttpBuildCache&gt; {
        url = uri(&quot;https://example.com:8123/cache/&quot;)
        isPush = isCiServer
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">buildSrc / settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(from = File(settingsDir, &quot;../gradle/buildCacheSettings.gradle.kts&quot;))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以从<a href="#sec:using_an_init_script">init脚本</a>配置构建缓存，该<a href="#sec:using_an_init_script">脚本</a>可以在命令行中使用，可以添加到Gradle用户主目录中，也可以作为自定义Gradle发行版的一部分。</p>
</div>
<div class="exampleblock">
<div class="title">例子33。初始化脚本来配置构建缓存</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">初始化等级</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gradle.settingsEvaluated { settings -&gt;
    settings.buildCache {
        <span class="comment">// vvv Your custom configuration goes here</span>
        remote(HttpBuildCache) {
            url = <span class="string"><span class="delimiter">'</span><span class="content">https://example.com:8123/cache/</span><span class="delimiter">'</span></span>
        }
        <span class="comment">// ^^^ Your custom configuration goes here</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">init.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">gradle.settingsEvaluated {
    buildCache {
        // vvv Your custom configuration goes here
        remote&lt;HttpBuildCache&gt; {
            url = uri(&quot;https://example.com:8123/cache/&quot;)
        }
        // ^^^ Your custom configuration goes here
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:build_cache_composite"><a class="anchor" href="#sec:build_cache_composite"></a> <a class="link" href="#sec:build_cache_composite">构建缓存和复合构建</a></h5>
<div class="paragraph">
<p>Gradle的<a href="#composite_builds">复合构建功能</a>允许将其他完整的Gradle构建包括在内。无论包含的构建是否自行定义构建缓存配置，此类包含的构建都会从顶级构建中继承构建缓存配置。</p>
</div>
<div class="paragraph">
<p>对于任何包含的构建，当前存在的构建缓存配置都将被有效忽略，而有利于顶层构建的配置。这也适用于任何<code>buildSrc</code>任何包含的版本的项目。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_cache_setup_http_backend"><a class="anchor" href="#sec:build_cache_setup_http_backend"></a> <a class="link" href="#sec:build_cache_setup_http_backend">如何设置HTTP构建缓存后端</a></h4>
<div class="paragraph">
<p>Gradle为<a href="https://hub.docker.com/r/gradle/build-cache-node/">构建缓存节点</a>提供Docker映像，该映像可与Gradle Enterprise连接以进行集中管理。缓存节点也可以在不安装功能受限的Gradle Enterprise的情况下使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_cache_implement"><a class="anchor" href="#sec:build_cache_implement"></a> <a class="link" href="#sec:build_cache_implement">实施自己的构建缓存</a></h4>
<div class="paragraph">
<p>使用不同的构建缓存后端存储构建输出（连接到HTTP后端的内置支持未涵盖在内）要求实现自己的逻辑以连接到自定义构建缓存后端。为此，可以通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/caching/configuration/BuildCacheConfiguration.html#registerBuildCacheService-java.lang.Class-java.lang.Class-">BuildCacheConfiguration.registerBuildCacheService（java.lang。类，java.lang。类）</a> 。</p>
</div>
<div class="paragraph">
<p><a href="https://gradle.com/build-cache">Gradle Enterprise</a>包含一个高性能，易于安装和操作的共享构建缓存后端。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">﻿<div class="sect1">
<h2 id="part:authoring_builds"><a class="anchor" href="#part:authoring_builds"></a> <a class="link" href="#part:authoring_builds">编写Gradle构建</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="tutorial_using_tasks"><a class="anchor" href="#tutorial_using_tasks"></a> <a class="link" href="#tutorial_using_tasks">构建脚本基础</a></h3>
<div class="paragraph">
<p>本章向您介绍编写Gradle构建脚本的基础。要获得快速动手的介绍，请尝试<a href="https://guides.gradle.org/creating-new-gradle-builds/">创建新的Gradle构建</a>指南。</p>
</div>
<div class="sect3">
<h4 id="sec:projects_and_tasks"><a class="anchor" href="#sec:projects_and_tasks"></a> <a class="link" href="#sec:projects_and_tasks">项目与任务</a></h4>
<div class="paragraph">
<p>Gradle中的所有内容都基于两个基本概念： <em>项目</em>和<em>任务</em> 。</p>
</div>
<div class="paragraph">
<p>每个Gradle构建都由一个或多个<em>项目组成</em> 。项目代表什么取决于您在Gradle中所做的事情。例如，一个项目可能代表一个JAR库或一个Web应用程序。它可能表示从其他项目产生的JAR组装而成的发行版ZIP。项目不一定代表要构建的事物。它可能表示要完成的事情，例如将应用程序部署到暂存或生产环境。暂时不要担心这似乎还不清楚。Gradle的按惯例构建支持为项目的定义添加了更具体的定义。</p>
</div>
<div class="paragraph">
<p>每个项目由一个或多个<em>任务组成</em> 。任务代表构建执行的一些原子工作。这可能是编译某些类，创建JAR，生成Javadoc或将一些存档发布到存储库。</p>
</div>
<div class="paragraph">
<p>现在，我们将研究在一个项目中构建一些简单的任务。后面的章节将介绍处理多个项目，以及有关处理项目和任务的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:hello_world"><a class="anchor" href="#sec:hello_world"></a> <a class="link" href="#sec:hello_world">你好，世界</a></h4>
<div class="paragraph multi-language-text lang-groovy">
<p>您使用以下命令运行Gradle构建<code>gradle</code>命令。的<code>gradle</code>命令查找名为<code>build.gradle</code>在当前目录中。 <sup class="footnote">[ <a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="查看脚注。">1</a> ]</sup> 我们称之为<code>build.gradle</code>提交一个<em>构建脚本</em> ，尽管严格来说它是一个构建配置脚本，我们将在后面看到。构建脚本定义项目及其任务。</p>
</div>
<div class="paragraph multi-language-text lang-groovy">
<p>要尝试此操作，请创建以下名为<code>build.gradle</code> 。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>您使用以下命令运行Gradle构建<code>gradle</code>命令。的<code>gradle</code>命令查找名为<code>build.gradle.kts</code>在当前目录中。 <sup class="footnote">[ <a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="查看脚注。">2</a> ]</sup> 我们称之为<code>build.gradle.kts</code>提交一个<em>构建脚本</em> ，尽管严格来说它是一个构建配置脚本，我们将在后面看到。构建脚本定义项目及其任务。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>要尝试此操作，请创建以下名为<code>build.gradle.kts</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例34您的第一个构建脚本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;hello&quot;) {
    doLast {
        println(&quot;Hello world!&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在命令行外壳中，移动到包含目录并使用以下命令执行构建脚本<code>gradle -q hello</code> ：</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="title">是什么<code>-q</code>做？</div>
<div class="paragraph">
<p>本用户指南中的大多数示例都与<code>-q</code>命令行选项。这将取消Gradle的日志消息，因此仅显示任务的输出。这样可以使本用户指南中的示例输出更加清晰。如果不想，则不需要使用此选项。有关影响Gradle输出的命令行选项的更多详细信息，请参见<a href="#logging">日志记录</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例35执行构建脚本</div>
<div class="content">
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
Hello world!</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里发生了什么？该构建脚本定义了一个任务，称为<code>hello</code> ，并为其添加操作。当你跑步<code>gradle hello</code> ，Gradle执行<code>hello</code>任务，依次执行您提供的操作。该动作只是一个包含一些要执行代码的块。</p>
</div>
<div class="paragraph">
<p>如果您认为这看起来类似于Ant的目标，那将是正确的。Gradle任务等效于Ant目标，但是正如您将看到的，它们的功能要强大得多。我们使用了与Ant不同的术语，因为我们认为“ <em>任务</em> ”一词比“ <em>目标</em> ”一词更具表现力。不幸的是，这会引入与Ant的术语冲突，因为Ant会调用其命令，例如<code>javac</code>要么<code>copy</code> ， 任务。因此，当我们谈论任务时，我们<em>总是</em>指Gradle任务，它等同于Ant的目标。如果我们谈论Ant任务（Ant命令），则明确地说出<em>Ant task</em> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_scripts_are_code"><a class="anchor" href="#sec:build_scripts_are_code"></a> <a class="link" href="#sec:build_scripts_are_code">构建脚本是代码</a></h4>
<div class="paragraph">
<p>Gradle的构建脚本为您提供了Groovy和Kotlin的全部功能。作为一个开胃菜，看看这个：</p>
</div>
<div class="exampleblock">
<div class="title">示例36。在Gradle的任务中使用Groovy或Kotlin</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task upper {
    doLast {
        <span class="predefined-type">String</span> someString = <span class="string"><span class="delimiter">'</span><span class="content">mY_nAmE</span><span class="delimiter">'</span></span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Original: </span><span class="inline"><span class="inline-delimiter">$</span>someString</span><span class="delimiter">&quot;</span></span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Upper case: </span><span class="inline"><span class="inline-delimiter">${</span>someString.toUpperCase()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;upper&quot;) {
    doLast {
        val someString = &quot;mY_nAmE&quot;
        println(&quot;Original: $someString&quot;)
        println(&quot;Upper case: ${someString.toUpperCase()}&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q upper</code></strong></div>
<div class="content">
<pre>&gt; gradle -q upper
Original: mY_nAmE
Upper case: MY_NAME</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要么</p>
</div>
<div class="exampleblock">
<div class="title">示例37。在Gradle的任务中使用Groovy或Kotlin</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task count {
    doLast {
        <span class="integer">4</span>.times { print <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="content"> </span><span class="delimiter">&quot;</span></span> }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;count&quot;) {
    doLast {
        repeat(4) { print(&quot;$it &quot;) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q count</code></strong></div>
<div class="content">
<pre>&gt; gradle -q count
0 1 2 3</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:task_dependencies"><a class="anchor" href="#sec:task_dependencies"></a> <a class="link" href="#sec:task_dependencies">任务依赖性</a></h4>
<div class="paragraph">
<p>您可能已经猜到了，您可以声明依赖于其他任务的任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例38。声明依赖于其他任务的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>
    }
}
task intro {
    dependsOn hello
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm Gradle</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;hello&quot;) {
    doLast {
        println(&quot;Hello world!&quot;)
    }
}
tasks.register(&quot;intro&quot;) {
    dependsOn(&quot;hello&quot;)
    doLast {
        println(&quot;I'm Gradle&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q intro</code></strong></div>
<div class="content">
<pre>&gt; gradle -q intro
Hello world!
I'm Gradle</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要添加依赖项，不需要存在相应的任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例39。懒惰的DependOn-其他任务不存在（尚未）</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    dependsOn <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
    }
}
task taskY {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;taskX&quot;) {
    dependsOn(&quot;taskY&quot;)
    doLast {
        println(&quot;taskX&quot;)
    }
}
tasks.register(&quot;taskY&quot;) {
    doLast {
        println(&quot;taskY&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskX
taskY
taskX</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的依赖<code>taskX</code>至<code>taskY</code>可能在之前声明<code>taskY</code>被定义为。对于多项目构建，这种自由非常重要。<a href="#sec:adding_dependencies_to_tasks">将依赖项添加到任务</a>中将详细讨论任务依赖<a href="#sec:adding_dependencies_to_tasks">项</a> 。</p>
</div>
<div class="paragraph">
<p>请注意，在引用尚未定义的任务时，不能使用<a href="#sec:shortcut_notations">快捷方式表示法</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:dynamic_tasks"><a class="anchor" href="#sec:dynamic_tasks"></a> <a class="link" href="#sec:dynamic_tasks">动态任务</a></h4>
<div class="paragraph">
<p>Groovy或Kotlin的功能可用于定义任务以外的其他功能。例如，您也可以使用它来动态创建任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例40动态创建任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="integer">4</span>.times { counter -&gt;
    task <span class="string"><span class="delimiter">&quot;</span><span class="content">task</span><span class="inline"><span class="inline-delimiter">$</span>counter</span><span class="delimiter">&quot;</span></span> {
        doLast {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm task number </span><span class="inline"><span class="inline-delimiter">$</span>counter</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repeat(4) { counter -&gt;
    tasks.register(&quot;task$counter&quot;) {
        doLast {
            println(&quot;I'm task number $counter&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q task1</code></strong></div>
<div class="content">
<pre>&gt; gradle -q task1
I'm task number 1</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:manipulating_existing_tasks"><a class="anchor" href="#sec:manipulating_existing_tasks"></a> <a class="link" href="#sec:manipulating_existing_tasks">处理现有任务</a></h4>
<div class="paragraph">
<p>创建任务后，就可以通过<em>API</em>对其进行访问。例如，您可以使用它在运行时为任务动态添加依赖项。蚂蚁不允许这样的事情。</p>
</div>
<div class="exampleblock">
<div class="title">示例41。通过API访问任务-添加依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="integer">4</span>.times { counter -&gt;
    task <span class="string"><span class="delimiter">&quot;</span><span class="content">task</span><span class="inline"><span class="inline-delimiter">$</span>counter</span><span class="delimiter">&quot;</span></span> {
        doLast {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm task number </span><span class="inline"><span class="inline-delimiter">$</span>counter</span><span class="delimiter">&quot;</span></span>
        }
    }
}
task0.dependsOn task2, task3</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repeat(4) { counter -&gt;
    tasks.register(&quot;task$counter&quot;) {
        doLast {
            println(&quot;I'm task number $counter&quot;)
        }
    }
}
tasks.named(&quot;task0&quot;) { dependsOn(&quot;task2&quot;, &quot;task3&quot;) }</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q task0</code></strong></div>
<div class="content">
<pre>&gt; gradle -q task0
I'm task number 2
I'm task number 3
I'm task number 0</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以将行为添加到现有任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例42。通过API访问任务-添加行为</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello Earth</span><span class="delimiter">'</span></span>
    }
}
hello.doFirst {
    println <span class="string"><span class="delimiter">'</span><span class="content">Hello Venus</span><span class="delimiter">'</span></span>
}
hello.configure {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello Mars</span><span class="delimiter">'</span></span>
    }
}
hello.configure {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello Jupiter</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val hello by tasks.registering {
    doLast {
        println(&quot;Hello Earth&quot;)
    }
}
hello {
    doFirst {
        println(&quot;Hello Venus&quot;)
    }
}
hello {
    doLast {
        println(&quot;Hello Mars&quot;)
    }
}
hello {
    doLast {
        println(&quot;Hello Jupiter&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
Hello Venus
Hello Earth
Hello Mars
Hello Jupiter</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>电话<code>doFirst</code>和<code>doLast</code>可以执行多次。他们将操作添加到任务操作列表的开头或结尾。执行任务时，将按顺序执行操作列表中的操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:shortcut_notations"><a class="anchor" href="#sec:shortcut_notations"></a> <a class="link" href="#sec:shortcut_notations">Groovy DSL快捷方式符号</a></h4>
<div class="paragraph">
<p>访问<em>现有</em>任务有一种方便的表示法。每个任务都可以作为构建脚本的属性来使用：</p>
</div>
<div class="exampleblock">
<div class="title">例子43。作为构建脚本的属性访问任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>
    }
}
hello.doLast {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Greetings from the </span><span class="inline"><span class="inline-delimiter">$</span>hello</span><span class="content">.name task.</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
Hello world!
Greetings from the hello task.</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样可以实现非常易读的代码，尤其是在使用插件提供的任务时，例如<code>compile</code>任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:extra_task_properties"><a class="anchor" href="#sec:extra_task_properties"></a> <a class="link" href="#sec:extra_task_properties">额外任务属性</a></h4>
<div class="paragraph">
<p>您可以将自己的属性添加到任务。添加名为<code>myProperty</code> ，设定<code>ext.myProperty</code>到初始值。从那时起，可以像预定义的任务属性一样读取和设置属性。</p>
</div>
<div class="exampleblock">
<div class="title">例子44。为任务添加额外的属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task myTask {
    ext.myProperty = <span class="string"><span class="delimiter">&quot;</span><span class="content">myValue</span><span class="delimiter">&quot;</span></span>
}

task printTaskProperties {
    doLast {
        println myTask.myProperty
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;myTask&quot;) {
    extra[&quot;myProperty&quot;] = &quot;myValue&quot;
}

tasks.register(&quot;printTaskProperties&quot;) {
    doLast {
        println(tasks[&quot;myTask&quot;].extra[&quot;myProperty&quot;])
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q printTaskProperties</code></strong></div>
<div class="content">
<pre>&gt; gradle -q printTaskProperties
myValue</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>额外的属性不仅限于任务。您可以在<a href="#sec:extra_properties">Extra属性中</a>阅读有关它们的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:using_ant_tasks_tutorial"><a class="anchor" href="#sec:using_ant_tasks_tutorial"></a> <a class="link" href="#sec:using_ant_tasks_tutorial">使用Ant任务</a></h4>
<div class="paragraph">
<p>蚂蚁任务是Gradle中的一等公民。仅仅依靠Groovy，Gradle就可以为Ant任务提供出色的集成。Groovy附带了出色的功能<code>AntBuilder</code> 。使用Gradle中的Ant任务比使用a中的Ant任务既方便又强大。 <code>build.xml</code>文件。它也可以从Kotlin使用。从下面的示例中，您可以学习如何执行Ant任务以及如何访问Ant属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例45使用AntBuilder执行ant.loadfile目标</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task loadfile {
    doLast {
        <span class="keyword">def</span> files = file(<span class="string"><span class="delimiter">'</span><span class="content">./antLoadfileResources</span><span class="delimiter">'</span></span>).listFiles().sort()
        files.each { <span class="predefined-type">File</span> file -&gt;
            <span class="keyword">if</span> (file.isFile()) {
                ant.loadfile(<span class="key">srcFile</span>: file, <span class="key">property</span>: file.name)
                println <span class="string"><span class="delimiter">&quot;</span><span class="content"> *** </span><span class="inline"><span class="inline-delimiter">$</span>file</span><span class="content">.name ***</span><span class="delimiter">&quot;</span></span>
                println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>ant.properties[file.name]<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;loadfile&quot;) {
    doLast {
        val files = file(&quot;./antLoadfileResources&quot;).listFiles().sorted()
        files.forEach { file -&gt;
            if (file.isFile) {
                ant.withGroovyBuilder {
                    &quot;loadfile&quot;(&quot;srcFile&quot; to file, &quot;property&quot; to file.name)
                }
                println(&quot; *** ${file.name} ***&quot;)
                println(&quot;${ant.properties[file.name]}&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q loadfile</code></strong></div>
<div class="content">
<pre>&gt; gradle -q loadfile
 *** agile.manifesto.txt ***
Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration  over contract negotiation
Responding to change over following a plan
 *** gradle.manifesto.txt ***
Make the impossible possible, make the possible easy and make the easy elegant.
(inspired by Moshe Feldenkrais)</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在构建脚本中使用Ant进行更多操作。您可以在<a href="#ant">Ant中</a>找到更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:using_methods"><a class="anchor" href="#sec:using_methods"></a> <a class="link" href="#sec:using_methods">使用方法</a></h4>
<div class="paragraph">
<p>Gradle扩展了如何组织构建逻辑。上面示例中组织构建逻辑的第一级是提取方法。</p>
</div>
<div class="exampleblock">
<div class="title">示例46。使用方法来组织构建逻辑</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task checksum {
    doLast {
        fileList(<span class="string"><span class="delimiter">'</span><span class="content">./antLoadfileResources</span><span class="delimiter">'</span></span>).each { <span class="predefined-type">File</span> file -&gt;
            ant.checksum(<span class="key">file</span>: file, <span class="key">property</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">cs_</span><span class="inline"><span class="inline-delimiter">$</span>file</span><span class="content">.name</span><span class="delimiter">&quot;</span></span>)
            println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>file</span><span class="content">.name Checksum: </span><span class="inline"><span class="inline-delimiter">${</span>ant.properties[<span class="string"><span class="delimiter">&quot;</span><span class="content">cs_</span><span class="inline"><span class="inline-delimiter">$</span>file</span><span class="content">.name</span><span class="delimiter">&quot;</span></span>]<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        }
    }
}

task loadfile {
    doLast {
        fileList(<span class="string"><span class="delimiter">'</span><span class="content">./antLoadfileResources</span><span class="delimiter">'</span></span>).each { <span class="predefined-type">File</span> file -&gt;
            ant.loadfile(<span class="key">srcFile</span>: file, <span class="key">property</span>: file.name)
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm fond of </span><span class="inline"><span class="inline-delimiter">$</span>file</span><span class="content">.name</span><span class="delimiter">&quot;</span></span>
        }
    }
}

<span class="predefined-type">File</span><span class="type">[]</span> fileList(<span class="predefined-type">String</span> dir) {
    file(dir).listFiles({file -&gt; file.isFile() } <span class="keyword">as</span> <span class="predefined-type">FileFilter</span>).sort()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;checksum&quot;) {
    doLast {
        fileList(&quot;./antLoadfileResources&quot;).forEach { file -&gt;
            ant.withGroovyBuilder {
                &quot;checksum&quot;(&quot;file&quot; to file, &quot;property&quot; to &quot;cs_${file.name}&quot;)
            }
            println(&quot;$file.name Checksum: ${ant.properties[&quot;cs_${file.name}&quot;]}&quot;)
        }
    }
}

tasks.register(&quot;loadfile&quot;) {
    doLast {
        fileList(&quot;./antLoadfileResources&quot;).forEach { file -&gt;
            ant.withGroovyBuilder {
                &quot;loadfile&quot;(&quot;srcFile&quot; to file, &quot;property&quot; to file.name)
            }
            println(&quot;I'm fond of ${file.name}&quot;)
        }
    }
}

fun fileList(dir: String): List&lt;File&gt; =
    file(dir).listFiles { file: File -&gt; file.isFile }.sorted()</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q loadfile</code></strong></div>
<div class="content">
<pre>&gt; gradle -q loadfile
I'm fond of agile.manifesto.txt
I'm fond of gradle.manifesto.txt</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>稍后您将看到可以在多项目构建中的子项目之间共享这种方法。如果您的构建逻辑变得更加复杂，Gradle将为您提供其他非常方便的组织方式。我们为此花了整整一章。请参阅<a href="#organizing_gradle_projects">组织Gradle项目</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:default_tasks"><a class="anchor" href="#sec:default_tasks"></a> <a class="link" href="#sec:default_tasks">默认任务</a></h4>
<div class="paragraph">
<p>如果未指定其他任务，则Gradle允许您定义一个或多个默认任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例47定义默认任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">defaultTasks <span class="string"><span class="delimiter">'</span><span class="content">clean</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">run</span><span class="delimiter">'</span></span>

task clean {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Default Cleaning!</span><span class="delimiter">'</span></span>
    }
}

task run {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Default Running!</span><span class="delimiter">'</span></span>
    }
}

task other {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm not a default task!</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">defaultTasks(&quot;clean&quot;, &quot;run&quot;)

task(&quot;clean&quot;) {
    doLast {
        println(&quot;Default Cleaning!&quot;)
    }
}

tasks.register(&quot;run&quot;) {
    doLast {
        println(&quot;Default Running!&quot;)
    }
}

tasks.register(&quot;other&quot;) {
    doLast {
        println(&quot;I'm not a default task!&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q</code></strong></div>
<div class="content">
<pre>&gt; gradle -q
Default Cleaning!
Default Running!</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这相当于跑步<code>gradle clean run</code> 。在多项目构建中，每个子项目都可以有其自己的特定默认任务。如果子项目未指定默认任务，则使用父项目的默认任务（如果已定义）。</p>
</div>
</div>
<div class="sect3">
<h4 id="configure-by-dag"><a class="anchor" href="#configure-by-dag"></a> <a class="link" href="#configure-by-dag">通过DAG进行配置</a></h4>
<div class="paragraph">
<p>正如我们稍后将详细描述的（请参阅<a href="#build_lifecycle">Build Lifecycle</a> ），Gradle具有配置阶段和执行阶段。在配置阶段之后，Gradle知道应该执行的所有任务。Gradle为您提供了一个利用此信息的机会。一个用例是检查发布任务是否在要执行的任务中。以此为基础，您可以为某些变量分配不同的值。</p>
</div>
<div class="paragraph">
<p>在以下示例中，执行<code>distribution</code>和<code>release</code>任务导致不同的价值<code>version</code>变量。</p>
</div>
<div class="exampleblock">
<div class="title">示例48根据所选任务的不同构建结果</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task distribution {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">We build the zip with version=</span><span class="inline"><span class="inline-delimiter">$</span>version</span><span class="delimiter">&quot;</span></span>
    }
}

task release {
    dependsOn <span class="string"><span class="delimiter">'</span><span class="content">distribution</span><span class="delimiter">'</span></span>
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">We release now</span><span class="delimiter">'</span></span>
    }
}

gradle.taskGraph.whenReady { taskGraph -&gt;
    <span class="keyword">if</span> (taskGraph.hasTask(<span class="string"><span class="delimiter">&quot;</span><span class="content">:release</span><span class="delimiter">&quot;</span></span>)) {
        version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>
    } <span class="keyword">else</span> {
        version = <span class="string"><span class="delimiter">'</span><span class="content">1.0-SNAPSHOT</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;distribution&quot;) {
    doLast {
        println(&quot;We build the zip with version=$version&quot;)
    }
}

tasks.register(&quot;release&quot;) {
    dependsOn(&quot;distribution&quot;)
    doLast {
        println(&quot;We release now&quot;)
    }
}

gradle.taskGraph.whenReady {
    version =
        if (hasTask(&quot;:release&quot;)) &quot;1.0&quot;
        else &quot;1.0-SNAPSHOT&quot;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q distribution</code></div>
<div class="content">
<pre>&gt; gradle -q distribution
We build the zip with version=1.0-SNAPSHOT</pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q release</code></div>
<div class="content">
<pre>&gt; gradle -q release
We build the zip with version=1.0
We release now</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>重要的是<code>whenReady</code>在执行发布任务<em>之前</em>影响发布任务。即使释放任务不是<em>主要</em>任务（即，传递给<code>gradle</code>命令）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>此示例之所以有效，是因为<code>version</code>值仅在执行时读取。在实际版本中使用类似的构造时，必须确保在配置过程中不会急切读取该值。否则，您的构建可能会对配置和执行之间的属性使用不同的值。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_script_external_dependencies"><a class="anchor" href="#sec:build_script_external_dependencies"></a> <a class="link" href="#sec:build_script_external_dependencies">构建脚本的外部依赖关系</a></h4>
<div class="paragraph">
<p>如果构建脚本需要使用外部库，则可以将它们添加到构建脚本本身中的脚本的类路径中。您可以使用<code>buildscript()</code>方法，传入一个声明构建脚本类路径的块。</p>
</div>
<div class="exampleblock">
<div class="title">示例49。声明构建脚本的外部依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-codec</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-codec</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">1.2</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        &quot;classpath&quot;(group = &quot;commons-codec&quot;, name = &quot;commons-codec&quot;, version = &quot;1.2&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>块传递给<code>buildscript()</code>方法配置<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/initialization/dsl/ScriptHandler.html">ScriptHandler</a>实例。您可以通过将依赖项添加到来声明构建脚本类路径<code>classpath</code>组态。这与您声明Java编译类路径的方式相同。您可以使用除项目依赖项以外的任何<a href="#sec:dependency-types">依赖项类型</a> 。</p>
</div>
<div class="paragraph">
<p>声明了构建脚本的类路径后，您可以像在类路径上的任何其他类一样使用构建脚本中的类。以下示例将添加到前面的示例中，并使用构建脚本类路径中的类。</p>
</div>
<div class="exampleblock">
<div class="title">示例50具有外部依赖项的构建脚本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.apache.commons.codec.binary.Base64</span>

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-codec</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-codec</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">1.2</span><span class="delimiter">'</span></span>
    }
}

task encode {
    doLast {
        <span class="keyword">def</span> <span class="type">byte</span><span class="type">[]</span> encodedString = <span class="keyword">new</span> Base64().encode(<span class="string"><span class="delimiter">'</span><span class="content">hello world\n</span><span class="delimiter">'</span></span>.getBytes())
        println <span class="keyword">new</span> <span class="predefined-type">String</span>(encodedString)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.apache.commons.codec.binary.Base64

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        &quot;classpath&quot;(group = &quot;commons-codec&quot;, name = &quot;commons-codec&quot;, version = &quot;1.2&quot;)
    }
}

tasks.register(&quot;encode&quot;) {
    doLast {
        val encodedString = Base64().encode(&quot;hello world\n&quot;.toByteArray())
        println(String(encodedString))
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q encode</code></strong></div>
<div class="content">
<pre>&gt; gradle -q encode
aGVsbG8gd29ybGQK</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于多项目构建，使用项目的<code>buildscript()</code>该方法可用于其所有子项目的构建脚本。</p>
</div>
<div class="paragraph">
<p>构建脚本依赖项可能是Gradle插件。请参阅<a href="#plugins">使用Gradle插件</a>以获取有关Gradle插件的更多信息。</p>
</div>
<div class="paragraph">
<p>每个项目都会自动有一个<code>buildEnvironment</code>可以调用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask.html">BuildEnvironmentReportTask</a>类型的任务来报告构建脚本依赖项的解决方案。</p>
</div>
</div>
<div class="sect3">
<h4 id="further_reading_3"><a class="anchor" href="#further_reading_3"></a> <a class="link" href="#further_reading_3">进一步阅读</a></h4>
<div class="paragraph">
<p>本章仅探讨了可能的内容。以下是一些可能有趣的主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#authoring_maintainable_build_scripts">编写可维护的构建脚本</a></p>
</li>
<li>
<p><a href="#organizing_gradle_projects">整理您的Gradle项目</a></p>
</li>
<li>
<p><a href="#custom_tasks">编写自定义任务</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="more_about_tasks"><a class="anchor" href="#more_about_tasks"></a> <a class="link" href="#more_about_tasks">创作任务</a></h3>
<div class="paragraph">
<p>在<a href="#tutorial_using_tasks">入门教程中，</a>您学习了如何创建简单任务。您还学习了以后如何向这些任务添加其他行为，还学习了如何在任务之间创建依赖关系。这些都是关于简单任务的，但是Gradle将任务的概念进一步扩展了。Gradle支持<em>增强的任务</em> ，这些任务具有自己的属性和方法。这实际上与您习惯使用Ant目标的情况不同。这样的增强任务要么由您提供，要么内置在Gradle中。</p>
</div>
<div class="sect3">
<h4 id="sec:task_outcomes"><a class="anchor" href="#sec:task_outcomes"></a> <a class="link" href="#sec:task_outcomes">任务成果</a></h4>
<div class="paragraph">
<p>当Gradle执行任务时，它可以在控制台UI中以及通过<a href="#embedding">Tooling API</a>将任务标记为不同的结果。这些标签基于任务是否具有要执行的动作，是否应执行那些动作，是否确实执行了这些动作以及这些动作是否进行了任何更改。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(no label)</code>要么<code>EXECUTED</code></dt>
<dd>
<p>任务执行了其动作。</p>
<div class="ulist">
<ul>
<li>
<p>Task有动作，Gradle已确定应将其作为构建的一部分执行。</p>
</li>
<li>
<p>任务没有动作，并且有一些依赖关系，并且任何依赖关系都将执行。另请参见<a href="#sec:lifecycle_tasks">生命周期任务</a> 。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>UP-TO-DATE</code></dt>
<dd>
<p>任务的输出未更改。</p>
<div class="ulist">
<ul>
<li>
<p>任务具有输出和输入，并且它们没有改变。请参阅<a href="#sec:up_to_date_checks">增量构建</a> 。</p>
</li>
<li>
<p>任务有动作，但是任务告诉Gradle它没有更改其输出。</p>
</li>
<li>
<p>Task没有任何动作，并且有一些依赖关系，但是所有依赖关系都是最新的，已跳过或来自缓存。另请参见<a href="#sec:lifecycle_tasks">生命周期任务</a> 。</p>
</li>
<li>
<p>任务没有动作，也没有依赖关系。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>FROM-CACHE</code></dt>
<dd>
<p>任务的输出可以从先前的执行中找到。</p>
<div class="ulist">
<ul>
<li>
<p>任务的输出已从构建缓存中还原。请参阅<a href="#build_cache">构建缓存</a> 。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>SKIPPED</code></dt>
<dd>
<p>任务未执行其动作。</p>
<div class="ulist">
<ul>
<li>
<p>任务已从命令行中明确排除。请参阅<a href="#sec:excluding_tasks_from_the_command_line">从执行中排除任务</a> 。</p>
</li>
<li>
<p>任务有一个<code>onlyIf</code>谓词返回false。请参阅<a href="#sec:using_a_predicate">使用谓词</a> 。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>NO-SOURCE</code></dt>
<dd>
<p>任务不需要执行其动作。</p>
<div class="ulist">
<ul>
<li>
<p>任务具有输入和输出，但<a href="#skip-when-empty">没有源</a> 。例如，源文件是<code>.java</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile的</a>文件。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:defining_tasks"><a class="anchor" href="#sec:defining_tasks"></a> <a class="link" href="#sec:defining_tasks">定义任务</a></h4>
<div class="paragraph">
<p>在<a href="#tutorial_using_tasks">本章中，</a>我们已经看到了如何使用字符串作为任务名称来定义任务。此样式有一些变体，您可能需要在某些情况下使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在“ <a href="task_configuration_avoidance.html">避免任务配置”一章</a>中将更详细地描述任务配置API。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">例子51。使用字符串作为任务名称定义任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>) {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>
    }
}

task(<span class="string"><span class="delimiter">'</span><span class="content">copy</span><span class="delimiter">'</span></span>, <span class="key">type</span>: Copy) {
    from(file(<span class="string"><span class="delimiter">'</span><span class="content">srcDir</span><span class="delimiter">'</span></span>))
    into(buildDir)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;hello&quot;) {
    doLast {
        println(&quot;hello&quot;)
    }
}

tasks.register&lt;Copy&gt;(&quot;copy&quot;) {
    from(file(&quot;srcDir&quot;))
    into(buildDir)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有一种定义任务的替代语法，您可能更喜欢使用：</p>
</div>
<div class="exampleblock">
<div class="title">示例52。使用定义任务<code>tasks</code>容器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.create(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>) {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>
    }
}

tasks.create(<span class="string"><span class="delimiter">'</span><span class="content">copy</span><span class="delimiter">'</span></span>, Copy) {
    from(file(<span class="string"><span class="delimiter">'</span><span class="content">srcDir</span><span class="delimiter">'</span></span>))
    into(buildDir)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;hello&quot;) {
    doLast {
        println(&quot;hello&quot;)
    }
}

tasks {
    register&lt;Copy&gt;(&quot;copy&quot;) {
        from(file(&quot;srcDir&quot;))
        into(buildDir)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，我们将任务添加到<code>tasks</code>采集。看看<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html">TaskContainer</a> ，了解更多<code>register()</code>方法。</p>
</div>
<div class="paragraph">
<p>最后，Groovy和Kotlin DSL有特定于语言的语法：</p>
</div>
<div class="exampleblock">
<div class="title">示例53。使用DSL特定语法定义任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Using Groovy dynamic keywords</span>

task(hello) {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>
    }
}

task(copy, <span class="key">type</span>: Copy) {
    from(file(<span class="string"><span class="delimiter">'</span><span class="content">srcDir</span><span class="delimiter">'</span></span>))
    into(buildDir)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Using Kotlin delegated properties

val hello by tasks.registering {
    doLast {
        println(&quot;hello&quot;)
    }
}

val copy by tasks.registering(Copy::class) {
    from(file(&quot;srcDir&quot;))
    into(buildDir)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>请注意，如果您需要创建的任务以供进一步参考，则Kotlin <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">委托属性</a>语法特别有用。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:locating_tasks"><a class="anchor" href="#sec:locating_tasks"></a> <a class="link" href="#sec:locating_tasks">定位任务</a></h4>
<div class="paragraph">
<p>您通常需要查找在构建文件中定义的任务，例如，对其进行配置或将其用于依赖项。有很多方法可以做到这一点。首先，就像定义任务一样，Groovy和Kotlin DSL具有特定于语言的语法：</p>
</div>
<div class="exampleblock">
<div class="title">示例54使用DSL特定语法访问任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello
task copy(<span class="key">type</span>: Copy)

<span class="comment">// Access tasks using Groovy dynamic properties on Project</span>

println hello.name
println project.hello.name

println copy.destinationDir
println project.copy.destinationDir</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">task(&quot;hello&quot;)
task&lt;Copy&gt;(&quot;copy&quot;)

// Access tasks using Kotlin delegated properties

val hello by tasks.getting
println(hello.name)

val copy by tasks.getting(Copy::class)
println(copy.destinationDir)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>任务也可以通过<code>tasks</code>采集。</p>
</div>
<div class="exampleblock">
<div class="title">例子55。通过任务集合访问任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello
task copy(<span class="key">type</span>: Copy)

println tasks.hello.name
println tasks.named(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>).get().name

println tasks.copy.destinationDir
println tasks.named(<span class="string"><span class="delimiter">'</span><span class="content">copy</span><span class="delimiter">'</span></span>).get().destinationDir</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;hello&quot;)
tasks.register&lt;Copy&gt;(&quot;copy&quot;)

println(tasks[&quot;hello&quot;].name)
println(tasks.named(&quot;hello&quot;).get().name)

println(tasks.getByName&lt;Copy&gt;(&quot;copy&quot;).destinationDir)
println(tasks.named&lt;Copy&gt;(&quot;copy&quot;).get().destinationDir)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用任务路径使用任务路径访问任何项目中的任务<code>tasks.getByPath()</code>方法。您可以致电<code>getByPath()</code>具有任务名称，相对路径或绝对路径的方法。</p>
</div>
<div class="exampleblock">
<div class="title">例子56。通过路径访问任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">project(<span class="string"><span class="delimiter">'</span><span class="content">:projectA</span><span class="delimiter">'</span></span>) {
    task hello
}

task hello

println tasks.getByPath(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>).path
println tasks.getByPath(<span class="string"><span class="delimiter">'</span><span class="content">:hello</span><span class="delimiter">'</span></span>).path
println tasks.getByPath(<span class="string"><span class="delimiter">'</span><span class="content">projectA:hello</span><span class="delimiter">'</span></span>).path
println tasks.getByPath(<span class="string"><span class="delimiter">'</span><span class="content">:projectA:hello</span><span class="delimiter">'</span></span>).path</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">project(&quot;:projectA&quot;) {
    tasks.register(&quot;hello&quot;)
}

tasks.register(&quot;hello&quot;)

println(tasks.getByPath(&quot;hello&quot;).path)
println(tasks.getByPath(&quot;:hello&quot;).path)
println(tasks.getByPath(&quot;projectA:hello&quot;).path)
println(tasks.getByPath(&quot;:projectA:hello&quot;).path)</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
:hello
:hello
:projectA:hello
:projectA:hello</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请查看<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html">TaskContainer，</a>以获取更多用于定位任务的选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_tasks"><a class="anchor" href="#sec:configuring_tasks"></a> <a class="link" href="#sec:configuring_tasks">配置任务</a></h4>
<div class="paragraph">
<p>例如，让我们看一下<code>Copy</code> Gradle提供的任务。创建一个<code>Copy</code>您的构建任务，您可以在构建脚本中声明：</p>
</div>
<div class="exampleblock">
<div class="title">例子57。创建复制任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task myCopy(<span class="key">type</span>: Copy)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;myCopy&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将创建一个没有默认行为的复制任务。可以使用其API来配置任务（请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">Copy</a> ）。以下示例显示了实现同一配置的几种不同方法。</p>
</div>
<div class="paragraph">
<p>为了清楚起见，请意识到此任务的名称是“ <code>myCopy</code> ”，但<em>类型为</em> “ <code>Copy</code> ”。您可以具有多个<em>类型</em>相同但名称不同的任务。您会发现这为您提供了强大的能力来跨特定类型的所有任务实施跨领域关注点。</p>
</div>
<div class="exampleblock">
<div class="title">示例58。使用API配置任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Copy myCopy = tasks.getByName(<span class="string"><span class="delimiter">&quot;</span><span class="content">myCopy</span><span class="delimiter">&quot;</span></span>)
myCopy.from <span class="string"><span class="delimiter">'</span><span class="content">resources</span><span class="delimiter">'</span></span>
myCopy.into <span class="string"><span class="delimiter">'</span><span class="content">target</span><span class="delimiter">'</span></span>
myCopy.include(<span class="string"><span class="delimiter">'</span><span class="content">**/*.txt</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.xml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.properties</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val myCopy = tasks.named&lt;Copy&gt;(&quot;myCopy&quot;)
myCopy {
    from(&quot;resources&quot;)
    into(&quot;target&quot;)
    include(&quot;**/*.txt&quot;, &quot;**/*.xml&quot;, &quot;**/*.properties&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这类似于我们在Java中配置对象的方式。您必须重复上下文（ <code>myCopy</code> ）每次都在配置语句中。这是多余的，阅读起来也不是很好。</p>
</div>
<div class="paragraph">
<p>还有另一种配置任务的方法。它还保留了上下文，并且可以说是最易读的。通常是我们的最爱。</p>
</div>
<div class="exampleblock">
<div class="title">范例59。使用DSL特定语法配置任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Configure task using Groovy dynamic task configuration block</span>
myCopy {
   from <span class="string"><span class="delimiter">'</span><span class="content">resources</span><span class="delimiter">'</span></span>
   into <span class="string"><span class="delimiter">'</span><span class="content">target</span><span class="delimiter">'</span></span>
}
myCopy.include(<span class="string"><span class="delimiter">'</span><span class="content">**/*.txt</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.xml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.properties</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Configure task using Kotlin delegated properties and a lambda
val myCopy by tasks.existing(Copy::class) {
    from(&quot;resources&quot;)
    into(&quot;target&quot;)
}
myCopy { include(&quot;**/*.txt&quot;, &quot;**/*.xml&quot;, &quot;**/*.properties&quot;) }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这适用于<em>任何</em>任务。任务访问只是<code>tasks.named()</code> （科特琳）或<code>tasks.getByName()</code> （Groovy）方法。重要的是要注意，此处使用的块用于<em>配置</em>任务，并且在执行任务时不会对其进行评估。</p>
</div>
<div class="paragraph">
<p>看一下<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html">TaskContainer</a> ，了解更多配置任务的选项。</p>
</div>
<div class="paragraph">
<p>定义任务时，也可以使用配置块。</p>
</div>
<div class="exampleblock">
<div class="title">示例60使用配置块定义任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copy(<span class="key">type</span>: Copy) {
   from <span class="string"><span class="delimiter">'</span><span class="content">resources</span><span class="delimiter">'</span></span>
   into <span class="string"><span class="delimiter">'</span><span class="content">target</span><span class="delimiter">'</span></span>
   include(<span class="string"><span class="delimiter">'</span><span class="content">**/*.txt</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.xml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.properties</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copy&quot;) {
   from(&quot;resources&quot;)
   into(&quot;target&quot;)
   include(&quot;**/*.txt&quot;, &quot;**/*.xml&quot;, &quot;**/*.properties&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="title">不要忘记构建阶段</div>
<div class="paragraph">
<p>任务具有配置和动作。使用时<code>doLast</code> ，您只是使用快捷方式来定义动作。任务的配置部分中定义的代码将在构建的配置阶段执行，无论目标任务是什么。有关<a href="#build_lifecycle">构建生命周期</a>的更多详细信息，请参见<a href="#build_lifecycle">构建生命</a>周期。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:passing_arguments_to_a_task_constructor"><a class="anchor" href="#sec:passing_arguments_to_a_task_constructor"></a> <a class="link" href="#sec:passing_arguments_to_a_task_constructor">将参数传递给任务构造函数</a></h4>
<div class="paragraph">
<p>与配置a的可变属性相反<code>Task</code>创建后，您可以将参数值传递给<code>Task</code>类的构造函数。为了将值传递给<code>Task</code>构造函数，您必须使用注释相关的构造函数<code>@javax.inject.Inject</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子61。任务类<code>@Inject</code>构造函数</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">CustomTask</span> <span class="directive">extends</span> DefaultTask {
    <span class="directive">final</span> <span class="predefined-type">String</span> message
    <span class="directive">final</span> <span class="type">int</span> number

    <span class="annotation">@Inject</span>
    CustomTask(<span class="predefined-type">String</span> message, <span class="type">int</span> number) {
        <span class="local-variable">this</span>.message = message
        <span class="local-variable">this</span>.number = number
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class CustomTask @Inject constructor(
    private val message: String,
    private val number: Int
) : DefaultTask()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以创建一个任务，并在参数列表的末尾传递构造函数参数。</p>
</div>
<div class="exampleblock">
<div class="title">例子62。使用TaskContainer创建带有构造函数参数的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.create(<span class="string"><span class="delimiter">'</span><span class="content">myTask</span><span class="delimiter">'</span></span>, CustomTask, <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>, <span class="integer">42</span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;CustomTask&gt;(&quot;myTask&quot;, &quot;hello&quot;, 42)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>constructorArgs</code>使用Project API的Map参数：</p>
</div>
<div class="exampleblock">
<div class="title">示例63。使用Map创建带有构造函数参数的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task myTask(<span class="key">type</span>: CustomTask, <span class="key">constructorArgs</span>: [<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>, <span class="integer">42</span>])</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">task(&quot;myTask&quot;, &quot;type&quot; to CustomTask::class.java, &quot;constructorArgs&quot; to listOf(&quot;hello&quot;, 42))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">首选使用TaskContainer使用构造函数参数创建任务</div>
<div class="paragraph">
<p>建议使用“ <a href="task_configuration_avoidance.html">避免任务配置”</a> API来缩短配置时间。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在所有情况下，作为构造函数参数传递的值都必须为非null。如果您尝试通过<code>null</code>值，Gradle会抛出一个<code>NullPointerException</code>指示哪个运行时值是<code>null</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:adding_dependencies_to_tasks"><a class="anchor" href="#sec:adding_dependencies_to_tasks"></a> <a class="link" href="#sec:adding_dependencies_to_tasks">向任务添加依赖项</a></h4>
<div class="paragraph">
<p>您可以通过多种方式定义任务的依赖关系。在“ <a href="#sec:task_dependencies">任务依赖项”中</a> ，介绍了使用任务名称定义依赖项。任务名称可以引用与该任务在同一项目中的任务，也可以引用其他项目中的任务。要引用另一个项目中的任务，请在任务名称前添加其所属项目的路径。以下是一个示例，该示例添加了来自<code>projectA:taskX</code>至<code>projectB:taskY</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例64。从另一个项目添加对任务的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">project(<span class="string"><span class="delimiter">'</span><span class="content">projectA</span><span class="delimiter">'</span></span>) {
    task taskX {
        dependsOn <span class="string"><span class="delimiter">'</span><span class="content">:projectB:taskY</span><span class="delimiter">'</span></span>
        doLast {
            println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
        }
    }
}

project(<span class="string"><span class="delimiter">'</span><span class="content">projectB</span><span class="delimiter">'</span></span>) {
    task taskY {
        doLast {
            println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">project(&quot;projectA&quot;) {
    tasks.register(&quot;taskX&quot;) {
        dependsOn(&quot;:projectB:taskY&quot;)
        doLast {
            println(&quot;taskX&quot;)
        }
    }
}

project(&quot;projectB&quot;) {
    tasks.register(&quot;taskY&quot;) {
        doLast {
            println(&quot;taskY&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskX
taskY
taskX</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了使用任务名称，您还可以使用<code>Task</code>对象，如本例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例65。使用任务对象添加依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
    }
}

task taskY {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    }
}

taskX.dependsOn taskY</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val taskX by tasks.registering {
    doLast {
        println(&quot;taskX&quot;)
    }
}

val taskY by tasks.registering {
    doLast {
        println(&quot;taskY&quot;)
    }
}

taskX {
    dependsOn(taskY)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskX
taskY
taskX</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于更高级的用途，您可以使用惰性块定义任务依赖项。求值时，会将正在计算依赖关系的任务传递给该块。惰性块应该返回一个<code>Task</code>或集合<code>Task</code>对象，然后将其视为任务的依赖项。以下示例从<code>taskX</code>以名称开头的项目中的所有任务<code>lib</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">例子66。使用惰性块添加依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
    }
}

<span class="comment">// Using a Groovy Closure</span>
taskX.dependsOn {
    tasks.findAll { task -&gt; task.name.startsWith(<span class="string"><span class="delimiter">'</span><span class="content">lib</span><span class="delimiter">'</span></span>) }
}

task lib1 {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">lib1</span><span class="delimiter">'</span></span>
    }
}

task lib2 {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">lib2</span><span class="delimiter">'</span></span>
    }
}

task notALib {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">notALib</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val taskX by tasks.registering {
    doLast {
        println(&quot;taskX&quot;)
    }
}

// Using a Gradle Provider
taskX {
    dependsOn(provider {
        tasks.filter { task -&gt; task.name.startsWith(&quot;lib&quot;) }
    })
}

tasks.register(&quot;lib1&quot;) {
    doLast {
        println(&quot;lib1&quot;)
    }
}

tasks.register(&quot;lib2&quot;) {
    doLast {
        println(&quot;lib2&quot;)
    }
}

tasks.register(&quot;notALib&quot;) {
    doLast {
        println(&quot;notALib&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskX
lib1
lib2
taskX</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关任务依赖关系的更多信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html">任务</a> API。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:ordering_tasks"><a class="anchor" href="#sec:ordering_tasks"></a> <a class="link" href="#sec:ordering_tasks">订购任务</a></h4>
<div class="paragraph">
<p>在某些情况下，控制两个任务的执行<em>顺序</em>很有用，而不必在这些任务之间引入明确的依赖关系。任务<em>排序</em>和任务<em>相关性</em>之间的主要区别在于，排序规则不影响将执行哪些任务，仅影响将执行它们的顺序。</p>
</div>
<div class="paragraph">
<p>任务排序在许多情况下很有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>强制执行任务的顺序排序：例如，“ build”在“ clean”之前永远不会运行。</p>
</li>
<li>
<p>在构建的早期进行构建验证：例如，在开始发布构建工作之前，请先验证我是否具有正确的凭据。</p>
</li>
<li>
<p>通过在长验证任务之前运行快速验证任务来更快地获得反馈：例如，单元测试应该在集成测试之前运行。</p>
</li>
<li>
<p>汇总特定类型的所有任务的结果的任务：例如，测试报告任务将所有已执行的测试任务的输出合并。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有两种可用的排序规则：“ <em>必须在</em> ” <em>之后运行</em>和“ <em>应在</em> ” <em>之后运行</em> 。</p>
</div>
<div class="paragraph">
<p>当您使用“必须在之后运行”排序规则时，请指定<code>taskB</code>必须总是在之后<code>taskA</code>无论何时<code>taskA</code>和<code>taskB</code>将运行。表示为<code>taskB.mustRunAfter(taskA)</code> 。“应在之后运行”排序规则与之相似，但不太严格，因为它将在两种情况下被忽略。首先，如果使用该规则会引入一个订购周期。其次，当使用并行执行并且任务的所有依赖关系都已满足（“应在之后运行”任务除外）时，则将运行该任务，而不管其“应在之后运行”依赖关系是否已运行。您应该使用“应该在之后运行”，在该顺序很有帮助但并非严格要求的情况下。</p>
</div>
<div class="paragraph">
<p>有了这些规则，仍然可以执行<code>taskA</code>没有<code>taskB</code>反之亦然。</p>
</div>
<div class="exampleblock">
<div class="title">例子67。添加“必须在之后运行”任务排序</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
    }
}
task taskY {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    }
}
taskY.mustRunAfter taskX</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val taskX by tasks.registering {
    doLast {
        println(&quot;taskX&quot;)
    }
}
val taskY by tasks.registering {
    doLast {
        println(&quot;taskY&quot;)
    }
}
taskY { mustRunAfter(taskX) }</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskY taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskY taskX
taskX
taskY</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例68。添加“应在之后运行”任务排序</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
    }
}
task taskY {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    }
}
taskY.shouldRunAfter taskX</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val taskX by tasks.registering {
    doLast {
        println(&quot;taskX&quot;)
    }
}
val taskY by tasks.registering {
    doLast {
        println(&quot;taskY&quot;)
    }
}
taskY { shouldRunAfter(taskX) }</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskY taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskY taskX
taskX
taskY</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在以上示例中，仍然可以执行<code>taskY</code>不会引起<code>taskX</code>跑步：</p>
</div>
<div class="exampleblock">
<div class="title">示例69。任务排序并不意味着任务执行</div>
<div class="content">
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskY</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskY
taskY</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要指定两个任务之间的“必须在之后运行”或“应在之后运行”顺序，请使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object[])">Task.mustRunAfter（java.lang。Object ...）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Task.html#shouldRunAfter-java.lang.Object...-">Task.shouldRunAfter（java.lang。对象...）</a>方法。这些方法接受任务实例，任务名称或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])">Task.dependsOn（java.lang。对象...）</a></p>
</div>
<div class="paragraph">
<p>注意 ” <code>B.mustRunAfter(A)</code> “ 要么 ” <code>B.shouldRunAfter(A)</code> ”并不意味着任务之间有任何执行依赖性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以执行任务<code>A</code>和<code>B</code>独立地。只有两个任务都计划执行时，排序规则才有效。</p>
</li>
<li>
<p>当与<code>--continue</code> ，有可能<code>B</code>在以下情况下执行<code>A</code>失败。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如前所述，如果引入了订购周期，则“应该在之后运行”订购规则将被忽略：</p>
</div>
<div class="exampleblock">
<div class="title">示例70。如果引入了订购周期，则“应在之后运行”任务订购将被忽略</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
    }
}
task taskY {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    }
}
task taskZ {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskZ</span><span class="delimiter">'</span></span>
    }
}
taskX.dependsOn taskY
taskY.dependsOn taskZ
taskZ.shouldRunAfter taskX</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val taskX by tasks.registering {
    doLast {
        println(&quot;taskX&quot;)
    }
}
val taskY by tasks.registering {
    doLast {
        println(&quot;taskY&quot;)
    }
}
val taskZ by tasks.registering {
    doLast {
        println(&quot;taskZ&quot;)
    }
}
taskX { dependsOn(taskY) }
taskY { dependsOn(taskZ) }
taskZ { shouldRunAfter(taskX) }</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskX
taskZ
taskY
taskX</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:adding_a_description_to_a_task"><a class="anchor" href="#sec:adding_a_description_to_a_task"></a> <a class="link" href="#sec:adding_a_description_to_a_task">向任务添加描述</a></h4>
<div class="paragraph">
<p>您可以在任务中添加描述。执行时显示此描述<code>gradle tasks</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子71。向任务添加描述</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copy(<span class="key">type</span>: Copy) {
   description <span class="string"><span class="delimiter">'</span><span class="content">Copies the resource directory to the target directory.</span><span class="delimiter">'</span></span>
   from <span class="string"><span class="delimiter">'</span><span class="content">resources</span><span class="delimiter">'</span></span>
   into <span class="string"><span class="delimiter">'</span><span class="content">target</span><span class="delimiter">'</span></span>
   include(<span class="string"><span class="delimiter">'</span><span class="content">**/*.txt</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.xml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.properties</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copy&quot;) {
   description = &quot;Copies the resource directory to the target directory.&quot;
   from(&quot;resources&quot;)
   into(&quot;target&quot;)
   include(&quot;**/*.txt&quot;, &quot;**/*.xml&quot;, &quot;**/*.properties&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:skipping_tasks"><a class="anchor" href="#sec:skipping_tasks"></a> <a class="link" href="#sec:skipping_tasks">跳过任务</a></h4>
<div class="paragraph">
<p>Gradle提供了多种方法来跳过任务的执行。</p>
</div>
<div class="sect4">
<h5 id="sec:using_a_predicate"><a class="anchor" href="#sec:using_a_predicate"></a> <a class="link" href="#sec:using_a_predicate">使用谓词</a></h5>
<div class="paragraph">
<p>您可以使用<code>onlyIf()</code>将谓词附加到任务的方法。仅当谓词评估为true时，才执行任务的动作。您将谓词实现为闭包。将闭包作为参数传递给任务，如果应该执行任务，则应返回true；如果应跳过任务，则应返回false。在即将执行任务之前就对谓词进行评估。</p>
</div>
<div class="exampleblock">
<div class="title">例子72。使用谓词跳过任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">hello world</span><span class="delimiter">'</span></span>
    }
}

hello.onlyIf { !project.hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">skipHello</span><span class="delimiter">'</span></span>) }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val hello by tasks.registering {
    doLast {
        println(&quot;hello world&quot;)
    }
}

hello {
    onlyIf { !project.hasProperty(&quot;skipHello&quot;) }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle hello -PskipHello</code></strong></div>
<div class="content">
<pre>&gt; gradle hello -PskipHello
&gt; Task :hello SKIPPED

BUILD SUCCESSFUL in 0s</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_stopexecutionexception"><a class="anchor" href="#sec:using_stopexecutionexception"></a> <a class="link" href="#sec:using_stopexecutionexception">使用StopExecutionException</a></h5>
<div class="paragraph">
<p>如果无法使用谓词来表示跳过任务的逻辑，则可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/StopExecutionException.html">StopExecutionException</a> 。如果某个动作引发此异常，则将跳过该动作的进一步执行以及该任务的任何后续动作的执行。构建继续执行下一个任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例73。使用StopExecutionException跳过任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task compile {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">We are doing the compile.</span><span class="delimiter">'</span></span>
    }
}

compile.doFirst {
    <span class="comment">// Here you would put arbitrary conditions in real life.</span>
    <span class="comment">// But this is used in an integration test so we want defined behavior.</span>
    <span class="keyword">if</span> (<span class="predefined-constant">true</span>) { <span class="keyword">throw</span> <span class="keyword">new</span> StopExecutionException() }
}
task myTask {
    dependsOn(<span class="string"><span class="delimiter">'</span><span class="content">compile</span><span class="delimiter">'</span></span>)
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">I am not affected</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val compile by tasks.registering {
    doLast {
        println(&quot;We are doing the compile.&quot;)
    }
}

compile {
    doFirst {
        // Here you would put arbitrary conditions in real life.
        // But this is used in an integration test so we want defined behavior.
        if (true) {
            throw StopExecutionException()
        }
    }
}
tasks.register(&quot;myTask&quot;) {
    dependsOn(compile)
    doLast {
        println(&quot;I am not affected&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q myTask</code></strong></div>
<div class="content">
<pre>&gt; gradle -q myTask
I am not affected</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用Gradle提供的任务，此功能将很有帮助。它允许您添加此类任务的内置操作的<em>有条件</em>执行。 <sup class="footnote">[ <a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="查看脚注。">3</a> ]</sup></p>
</div>
</div>
<div class="sect4">
<h5 id="sec:enabling_and_disabling_tasks"><a class="anchor" href="#sec:enabling_and_disabling_tasks"></a> <a class="link" href="#sec:enabling_and_disabling_tasks">启用和禁用任务</a></h5>
<div class="paragraph">
<p>每个任务都有一个<code>enabled</code>默认为<code>true</code> 。设置为<code>false</code>阻止执行任何任务动作。禁用的任务将标记为“跳过”。</p>
</div>
<div class="exampleblock">
<div class="title">示例74。启用和禁用任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task disableMe {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">This should not be printed if the task is disabled.</span><span class="delimiter">'</span></span>
    }
}
disableMe.enabled = <span class="predefined-constant">false</span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val disableMe by tasks.registering {
    doLast {
        println(&quot;This should not be printed if the task is disabled.&quot;)
    }
}
disableMe {
    enabled = false
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle disableMe</code></strong></div>
<div class="content">
<pre>&gt; gradle disableMe
&gt; Task :disableMe SKIPPED

BUILD SUCCESSFUL in 0s</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:task_timeouts"><a class="anchor" href="#sec:task_timeouts"></a> <a class="link" href="#sec:task_timeouts">任务超时</a></h5>
<div class="paragraph">
<p>每个任务都有一个<code>timeout</code>属性，可用于限制其执行时间。当任务达到超时时，其任务执行线程将被中断。该任务将被标记为失败。终结器任务仍将运行。如果<code>--continue</code>使用后，其他任务可以继续运行。不响应中断的任务无法超时。Gradle的所有内置任务均会及时响应超时。</p>
</div>
<div class="exampleblock">
<div class="title">例子75。指定任务超时</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hangingTask() {
    doLast {
        <span class="predefined-type">Thread</span>.sleep(<span class="integer">100000</span>)
    }
    timeout = <span class="predefined-type">Duration</span>.ofMillis(<span class="integer">500</span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import java.time.Duration

tasks {
    register(&quot;hangingTask&quot;) {
        doLast {
            Thread.sleep(100000)
        }
        timeout.set(Duration.ofMillis(500))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:up_to_date_checks"><a class="anchor" href="#sec:up_to_date_checks"></a> <a class="link" href="#sec:up_to_date_checks">最新检查（AKA增量构建）</a></h4>
<div class="paragraph">
<p>任何构建工具的重要组成部分是避免执行已经完成的工作的能力。考虑编译过程。编译完源文件后，除非更改了一些会影响输出的内容，例如修改源文件或删除输出文件，否则无需重新编译它们。而且编译可能要花费大量时间，因此在不需要时跳过该步骤可以节省大量时间。</p>
</div>
<div class="paragraph">
<p>Gradle通过其称为增量构建的功能来开箱即用地支持此行为。您几乎可以肯定已经看到了它的作用：几乎每次<code>UP-TO-DATE</code>运行构建时，文本会出现在任务名称旁边。任务结果在<a href="#sec:task_outcomes">任务结果中</a>进行了描述。</p>
</div>
<div class="paragraph">
<p>增量构建如何工作？在自己的任务中需要使用什么？让我们来看看。</p>
</div>
<div class="sect4">
<h5 id="sec:task_inputs_outputs"><a class="anchor" href="#sec:task_inputs_outputs"></a> <a class="link" href="#sec:task_inputs_outputs">任务输入和输出</a></h5>
<div class="paragraph">
<p>在最常见的情况下，任务需要一些输入并产生一些输出。如果使用前面的编译示例，则可以看到源文件是输入，对于Java，生成的类文件是输出。其他输入可能包括诸如是否应包含调试信息之类的内容。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/taskInputsOutputs.png" alt="taskInputsOutputs">
</div>
<div class="title">图7。任务输入和输出示例</div>
</div>
<div class="paragraph">
<p>如上图所示，输入的重要特征是它会影响一个或多个输出。根据源文件的内容以及要在其上运行代码的Java运行时的最低版本，会生成不同的字节码。这使它们成为任务输入。但是编译是否具有500MB或600MB的最大可用内存，取决于<code>memoryMaximumSize</code>属性，对生成的字节码没有影响。用Gradle的术语， <code>memoryMaximumSize</code>只是一个内部任务属性。</p>
</div>
<div class="paragraph">
<p>作为增量构建的一部分，Gradle会测试自上次构建以来是否已更改任何任务输入或输出。如果还没有，Gradle可以考虑该任务是最新的，因此跳过执行其动作。另请注意，除非一个任务至少具有一个任务输出，否则增量构建将无法正常工作，尽管任务通常也至少具有一个输入。</p>
</div>
<div class="paragraph">
<p>这对于构建作者来说很简单：您需要告诉Gradle哪些任务属性是输入，哪些是输出。如果任务属性影响输出，请确保将其注册为输入，否则，该任务将被认为是最新的。相反，如果属性不会影响输出，则不要将其注册为输入，否则任务可能会在不需要时执行。也要注意那些不确定的任务，这些任务可能会为完全相同的输入生成不同的输出：不应为增量构建配置这些任务，因为最新的检查将不起作用。</p>
</div>
<div class="paragraph">
<p>现在让我们看一下如何将任务属性注册为输入和输出。</p>
</div>
<div class="sect5">
<h6 id="sec:task_input_output_annotations"><a class="anchor" href="#sec:task_input_output_annotations"></a> <a class="link" href="#sec:task_input_output_annotations">自定义任务类型</a></h6>
<div class="paragraph">
<p>如果您要以类的形式实现自定义任务，则只需两步即可使其与增量构建一起使用：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>为每个任务输入和输出创建类型化的属性（通过getter方法）</p>
</li>
<li>
<p>向每个属性添加适当的注释</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>注释必须放在吸气剂或Groovy属性上。放置在setter上或没有相应带注释的getter的Java字段上的注释将被忽略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle支持三种主要的输入和输出类别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>简单的价值观</p>
<div class="paragraph">
<p>诸如字符串和数字之类的东西。更一般而言，简单值可以具有任何实现的类型<code>Serializable</code> 。</p>
</div>
</li>
<li>
<p>文件系统类型</p>
<div class="paragraph">
<p>这些包括标准<code>File</code>类，还包括Gradle的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">FileCollection</a>类型的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">派生</a>类以及可以传递给<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。Object）</a>方法-用于单个文件/目录属性-或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（java.lang。Object ...）</a>方法。</p>
</div>
</li>
<li>
<p>嵌套值</p>
<div class="paragraph">
<p>自定义类型不符合其他两个类别，但具有自己的属性，即输入或输出。实际上，任务输入或输出嵌套在这些自定义类型中。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，假设您有一个任务来处理各种类型的模板，例如FreeMarker，Velocity，Moustache等。它需要模板源文件，并将它们与一些模型数据结合起来以生成模板文件的填充版本。</p>
</div>
<div class="paragraph">
<p>该任务将具有三个输入和一个输出：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模板源文件</p>
</li>
<li>
<p>模型数据</p>
</li>
<li>
<p>模板引擎</p>
</li>
<li>
<p>写入输出文件的位置</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在编写自定义任务类时，很容易通过注释将属性注册为输入或输出。为了演示，这是一个基本任务实现，其中包含一些合适的输入和输出以及它们的注释：</p>
</div>
<div class="exampleblock">
<div class="title">例子76。自定义任务类</div>
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / src / main / java / org / example / ProcessTemplates.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.example</span>;

<span class="keyword">import</span> <span class="include">java.io.File</span>;
<span class="keyword">import</span> <span class="include">java.util.HashMap</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api</span>.*;
<span class="keyword">import</span> <span class="include">org.gradle.api.file</span>.*;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks</span>.*;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ProcessTemplates</span> <span class="directive">extends</span> DefaultTask {
    <span class="directive">private</span> TemplateEngineType templateEngine;
    <span class="directive">private</span> FileCollection sourceFiles;
    <span class="directive">private</span> TemplateData templateData;
    <span class="directive">private</span> <span class="predefined-type">File</span> outputDir;

    <span class="annotation">@Input</span>
    <span class="directive">public</span> TemplateEngineType getTemplateEngine() {
        <span class="keyword">return</span> <span class="local-variable">this</span>.templateEngine;
    }

    <span class="annotation">@InputFiles</span>
    <span class="directive">public</span> FileCollection getSourceFiles() {
        <span class="keyword">return</span> <span class="local-variable">this</span>.sourceFiles;
    }

    <span class="annotation">@Nested</span>
    <span class="directive">public</span> TemplateData getTemplateData() {
        <span class="keyword">return</span> <span class="local-variable">this</span>.templateData;
    }

    <span class="annotation">@OutputDirectory</span>
    <span class="directive">public</span> <span class="predefined-type">File</span> getOutputDir() { <span class="keyword">return</span> <span class="local-variable">this</span>.outputDir; }

    <span class="comment">// + setter methods for the above - assume we’ve defined them</span>

    <span class="annotation">@TaskAction</span>
    <span class="directive">public</span> <span class="type">void</span> processTemplates() {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">buildSrc / src / main / java / org / example / TemplateData.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.example</span>;

<span class="keyword">import</span> <span class="include">java.util.HashMap</span>;
<span class="keyword">import</span> <span class="include">java.util.Map</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.Input</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">TemplateData</span> {
    <span class="directive">private</span> <span class="predefined-type">String</span> name;
    <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; variables;

    <span class="directive">public</span> TemplateData(<span class="predefined-type">String</span> name, <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; variables) {
        <span class="local-variable">this</span>.name = name;
        <span class="local-variable">this</span>.variables = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;(variables);
    }

    <span class="annotation">@Input</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getName() { <span class="keyword">return</span> <span class="local-variable">this</span>.name; }

    <span class="annotation">@Input</span>
    <span class="directive">public</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; getVariables() {
        <span class="keyword">return</span> <span class="local-variable">this</span>.variables;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle processTemplates</code></div>
<div class="content">
<pre>&gt; gradle processTemplates
&gt; Task :processTemplates


BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle processTemplates</code> （再次运行）</div>
<div class="content">
<pre>&gt; gradle processTemplates
&gt; Task :processTemplates UP-TO-DATE

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中有很多要讨论的内容，因此让我们依次研究每个输入和输出属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>templateEngine</code></p>
<div class="paragraph">
<p>表示在处理源模板（例如FreeMarker，Velocity等）时使用的引擎。您可以将其实现为字符串，但是在这种情况下，我们选择了自定义枚举，因为它提供了更多的类型信息和安全性。由于枚举实现<code>Serializable</code>自动地，我们可以将其视为简单值，并使用<code>@Input</code>注释，就像我们对<code>String</code>属性。</p>
</div>
</li>
<li>
<p><code>sourceFiles</code></p>
<div class="paragraph">
<p>任务将要处理的源模板。单个文件和文件集合需要它们自己的特殊注释。在这种情况下，我们正在处理输入文件的集合，因此我们使用<code>@InputFiles</code>注解。稍后，您会在表格中看到更多面向文件的注释。</p>
</div>
</li>
<li>
<p><code>templateData</code></p>
<div class="paragraph">
<p>对于此示例，我们使用一个自定义类来表示模型数据。但是，它没有实现<code>Serializable</code> ，所以我们不能使用<code>@Input</code>注解。这不是问题，因为其中的属性<code>TemplateData</code> -具有可序列化类型参数的字符串和哈希图-可序列化，并可以使用<code>@Input</code> 。我们用<code>@Nested</code>上<code>templateData</code>让Gradle知道这是具有嵌套输入属性的值。</p>
</div>
</li>
<li>
<p><code>outputDir</code></p>
<div class="paragraph">
<p>生成的文件所在的目录。与输入文件一样，输出文件和目录也有一些注释。代表单个目录的属性需要<code>@OutputDirectory</code> 。您很快就会了解其他。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些带注释的属性意味着，自从Gradle上次执行任务以来，如果源文件，模板引擎，模型数据或生成的文件均未更改，则Gradle将跳过任务。这通常会节省大量时间。您可以<a href="#sec:how_does_it_work">稍后</a>了解Gradle如何检测<a href="#sec:how_does_it_work">更改</a> 。</p>
</div>
<div class="paragraph">
<p>这个示例特别有趣，因为它可以处理源文件的集合。如果仅更改一个源文件，会发生什么？该任务会再次处理所有源文件还是仅处理已修改的源文件？这取决于任务的实现。如果是后者，则任务本身就是增量的，但这与我们在此讨论的功能不同。Gradle通过其<a href="#incremental_tasks">增量任务输入</a>功能确实可以帮助任务实施者。</p>
</div>
<div class="paragraph">
<p>现在您已经在实践中看到了一些输入和输出注释，下面让我们看一下所有可用的注释以及何时使用它们。下表列出了可用的注释以及可以与每个注释一起使用的相应属性类型。</p>
</div>
<table id="table:incremental_build_annotations" class="tableblock frame-all grid-all stretch">
<caption class="title">表格1。增量构建属性类型注释</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">预期物业类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Input.html">Input</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>任何<code>Serializable</code>类型</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>一个简单的输入值</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/InputFile.html">InputFile</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>单个输入文件（不是目录）</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/InputDirectory.html">InputDirectory</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>单个输入目录（不是文件）</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/InputFiles.html">InputFiles</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Iterable<File></code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>输入文件和目录的迭代</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Classpath.html">Classpath</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Iterable<File></code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>代表Java类路径的输入文件和目录的可迭代项。这使任务可以忽略对该属性的不相关更改，例如相同文件的名称不同。这类似于注释属性<code>@PathSensitive(RELATIVE)</code>但是它将忽略直接添加到类路径中的JAR文件的名称，并且会将文件顺序的更改视为类路径中的更改。Gradle将检查类路径上jar文件的内容，并忽略不影响类路径语义的更改（例如文件日期和输入顺序）。另请参见<a href="#sec:task_input_using_classpath_annotations">使用类路径注释</a> 。</p>
</div>
<div class="paragraph">
<p><strong>注意：</strong> <code>@Classpath</code>注解在Gradle 3.2中引入。为了与Gradle的早期版本保持兼容，还应在classpath属性中添加注释<code>@InputFiles</code> 。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/CompileClasspath.html">CompileClasspath</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Iterable<File></code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>代表Java编译类路径的输入文件和目录的可迭代项。这使任务可以忽略不影响classpath中类API的无关更改。另请参见<a href="#sec:task_input_using_classpath_annotations">使用类路径注释</a> 。</p>
</div>
<div class="paragraph">
<p>对类路径的以下几种更改将被忽略：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更改jar或顶级目录的路径。</p>
</li>
<li>
<p>更改时间戳和Jars中条目的顺序。</p>
</li>
<li>
<p>对资源和Jar清单的更改，包括添加或删除资源。</p>
</li>
<li>
<p>更改私有类元素，例如私有字段，方法和内部类。</p>
</li>
<li>
<p>对代码的更改，例如方法体，静态初始化器和字段初始化器（常量除外）。</p>
</li>
<li>
<p>调试信息的更改，例如，对注释的更改会影响类调试信息中的行号。</p>
</li>
<li>
<p>对目录的更改，包括Jars中的目录条目。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@CompileClasspath</code>注解在Gradle 3.4中引入。为了与Gradle 3.3和3.2保持兼容，编译类路径属性还应带有以下注释： <code>@Classpath</code> 。为了与3.2之前的Gradle版本兼容，该属性还应添加以下注释： <code>@InputFiles</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/OutputFile.html">OutputFile</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>单个输出文件（非目录）</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/OutputDirectory.html">OutputDirectory</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>单个输出目录（不是文件）</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/OutputFiles.html">OutputFiles</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Map<String, File></code> ** 要么<code>Iterable<File></code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>输出文件的可迭代或映射。使用文件树将关闭该任务的<a href="#sec:task_output_caching">缓存</a> 。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/OutputDirectories.html">OutputDirectories</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Map<String, File></code> ** 要么<code>Iterable<File></code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>可迭代的输出目录。使用文件树将关闭该任务的<a href="#sec:task_output_caching">缓存</a> 。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Destroys.html">Destroys</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code>要么<code>Iterable<File></code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>指定此任务删除的一个或多个文件。请注意，任务可以定义输入/输出或可销毁对象，但不能同时定义两者。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/LocalState.html">LocalState</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code>要么<code>Iterable<File></code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>指定一个或多个表示<a href="#sec:storing_incremental_task_state">任务本地状态的</a>文件。从缓存中加载任务时，将删除这些文件。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>任何自定义类型</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>可能无法实现的自定义类型<code>Serializable</code>但确实有至少一个字段或属性用此表中的注释之一标记。甚至可能是另一个<code>@Nested</code> 。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Console.html">Console</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>随便哪种</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>指示该属性既不是输入也不是输出。它只是以某种方式影响任务的控制台输出，例如增加或减少任务的详细程度。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Internal.html">Internal</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>随便哪种</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>指示该属性在内部使用，但既不是输入也不是输出。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ReplacedBy.html">ReplacedBy</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>随便哪种</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>指示该属性已被另一个替换，应作为输入或输出忽略。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="skip-when-empty"></a><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/SkipWhenEmpty.html">SkipWhenEmpty</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>用于<code>@InputFiles</code>要么<code>@InputDirectory</code>告诉Gradle如果相应的文件或目录为空以及使用此注释声明的所有其他输入文件为空，则跳过该任务。由于使用该批注声明为空的所有输入文件而被跳过的任务将导致明显的“无源”结果。例如， <code>NO-SOURCE</code>将在控制台输出中发出。</p>
</div>
<div class="paragraph">
<p>暗示<code><a href="#incremental">@Incremental</a></code> 。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="incremental"></a><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/work/Incremental.html">Incremental</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Provider<FileSystemLocation></code>要么<code>FileCollection</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>用于<code>@InputFiles</code>要么<code>@InputDirectory</code>指示Gradle跟踪对带注释的文件属性的更改，因此可以通过以下方式查询更改<code>@<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html">InputChanges.getFileChanges()</a></code> 。<a href="#incremental_tasks">增量任务</a>所需。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Optional.html">Optional</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>随便哪种</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>与<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Optional.html">可选</a> API文档中列出的任何属性类型注释一起使用。该批注禁用对相应属性的验证检查。有关更多详细信息，请参见<a href="#sec:task_input_output_validation">验证部分</a> 。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/PathSensitive.html">PathSensitive</a></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code> *</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="inputs_path_sensitivity"></a>与任何输入文件属性一起使用，以告诉Gradle仅将文件路径的给定部分视为重要。例如，如果属性带有注释<code>@PathSensitive(PathSensitivity.NAME_ONLY)</code> ，然后在不更改文件内容的情况下移动文件不会使任务过时。</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="hdlist">
<table>
<tbody><tr>
<td class="hdlist1">*</td>
<td class="hdlist2">
<p>事实上， <code>File</code>可以是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。对象）</a>和<code>Iterable<File></code>可以是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（java.lang。对象...</a>这包括<code>Callable</code> ，例如闭包，允许懒惰地评估属性值。请注意，类型<code>FileCollection</code>和<code>FileTree</code>是<code>Iterable<File></code> s。</p>
</td>
</tr>
<tr>
<td class="hdlist1">**</td>
<td class="hdlist2">
<p>与上述类似， <code>File</code>可以是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。对象）</a> 。的<code>Map</code>本身可以包裹在<code>Callable</code> s，例如闭包。</p>
</td>
</tr>
</tbody></table>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>注释从所有父类型（包括已实现的接口）继承。属性类型注释会覆盖父类型中声明的任何其他属性类型注释。这样一来<code>@InputFile</code>属性可以变成<code>@InputDirectory</code>子任务类型中的属性。</p>
</div>
<div class="paragraph">
<p>在类型中声明的属性的注释会覆盖超类和任何已实现接口中声明的类似注释。超类注释优先于已实现接口中声明的注释。</p>
</div>
<div class="paragraph">
<p>表格中的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Console.html">Console</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Internal.html">Internal</a>注释是特殊情况，因为它们未声明任务输入或任务输出。那为什么要使用它们呢？这样一来，您就可以利用<a href="#java_gradle_plugin">Java Gradle插件开发插件</a>来帮助您开发和发布自己的插件。该插件检查您的自定义任务类的任何属性是否缺少增量构建注释。这样可以防止您在开发过程中忘记添加适当的注释。</p>
</div>
<div class="sect6">
<h7 id="sec:task_input_using_classpath_annotations"><a class="anchor" href="#sec:task_input_using_classpath_annotations"></a> <a class="link" href="#sec:task_input_using_classpath_annotations">使用类路径注释</a></h7>
<div class="paragraph">
<p>除了<code>@InputFiles</code> ，对于与JVM相关的任务，Gradle理解类路径输入的概念。当Gradle寻找更改时，对运行时和编译类路径的处理会有所不同。</p>
</div>
<div class="paragraph">
<p>与用注释的输入属性相反<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/InputFiles.html">InputFiles</a></code> ，对于classpath属性，文件集合中条目的顺序很重要。另一方面，类路径本身上的目录和jar文件的名称和路径将被忽略。类路径上jar文件中的时间戳以及类文件和资源的顺序也将被忽略，因此用不同文件日期重新创建jar文件不会使任务过时。</p>
</div>
<div class="paragraph">
<p>运行时类路径标记为<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Classpath.html">Classpath</a></code> ，并且它们通过<a href="#sec:configure_input_normalization">类路径规范化</a>提供了进一步的自定义。</p>
</div>
<div class="paragraph">
<p>输入属性带有注释<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/CompileClasspath.html">CompileClasspath</a></code>被视为Java编译类路径。除上述常规类路径规则外，编译类路径会忽略对除类文件以外的所有内容的更改。Gradle使用<a href="#sec:java_compile_avoidance">Java避免编译中</a>描述的相同类分析来进一步过滤不影响类ABI的更改。这意味着仅涉及类实现的更改不会使任务过时。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:task_input_nested_inputs"><a class="anchor" href="#sec:task_input_nested_inputs"></a> <a class="link" href="#sec:task_input_nested_inputs">嵌套输入</a></h7>
<div class="paragraph">
<p>分析时<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code>声明的输入和输出子属性的任务属性Gradle使用实际值的类型。因此，它可以发现运行时子类型声明的所有子属性。</p>
</div>
<div class="paragraph">
<p>添加时<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code>到一个<code><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">Provider</a></code> ，的价值<code>Provider</code>被视为嵌套输入。</p>
</div>
<div class="paragraph">
<p>添加时<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code>对于一个可迭代的对象，每个元素都被视为一个单独的嵌套输入。迭代器中的每个嵌套输入都被分配了一个名称，默认情况下是美元符号，后面是迭代器中的索引，例如<code>$2</code> 。如果可迭代的元素实现<code><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Named.html">Named</a></code> ，然后将该名称用作属性名称。如果不是所有元素都实现，则迭代器中元素的顺序对于可靠的最新检查和缓存至关重要<code><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Named.html">Named</a></code> 。不允许使用多个具有相同名称的元素。</p>
</div>
<div class="paragraph">
<p>添加时<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code>到地图，然后为每个值添加嵌套输入，并使用键作为名称。</p>
</div>
<div class="paragraph">
<p>嵌套输入的类型和类路径也将被跟踪。这确保了对嵌套输入的实现的更改会导致构建过时。通过这种方式，还可以添加用户提供的代码作为输入，例如通过注释<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Action.html">Action</a></code>与财产<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code> 。请注意，应通过操作上的注释属性或通过在任务中手动注册这些操作来跟踪对此类操作的任何输入。</p>
</div>
<div class="paragraph">
<p>使用嵌套输入可以为任务提供更丰富的建模和可扩展性，例如<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:jvmArgumentProviders">Test.getJvmArgumentProviders（）</a>所示。</p>
</div>
<div class="paragraph">
<p>这使我们可以对JaCoCo Java代理进行建模，从而声明必要的JVM参数并将输入和输出提供给Gradle：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">JacocoAgent.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">JacocoAgent</span> <span class="directive">implements</span> CommandLineArgumentProvider {
    <span class="directive">private</span> <span class="directive">final</span> JacocoTaskExtension jacoco;

    <span class="directive">public</span> JacocoAgent(JacocoTaskExtension jacoco) {
        <span class="local-variable">this</span>.jacoco = jacoco;
    }

    <span class="annotation">@Nested</span>
    <span class="annotation">@Optional</span>
    <span class="directive">public</span> JacocoTaskExtension getJacoco() {
        <span class="keyword">return</span> jacoco.isEnabled() ? jacoco : <span class="predefined-constant">null</span>;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Iterable</span>&lt;<span class="predefined-type">String</span>&gt; asArguments() {
        <span class="keyword">return</span> jacoco.isEnabled() ? ImmutableList.of(jacoco.getAsJvmArg()) : <span class="predefined-type">Collections</span>.&lt;<span class="predefined-type">String</span>&gt;emptyList();
    }
}

test.getJvmArgumentProviders().add(<span class="keyword">new</span> JacocoAgent(extension));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为此， <code><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.plugins.JacocoTaskExtension.html">JacocoTaskExtension</a></code>需要具有正确的输入和输出注释。</p>
</div>
<div class="paragraph">
<p>该方法适用于Test JVM参数，因为<code><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:jvmArgumentProviders">Test.getJvmArgumentProviders()</a></code>是一个<code>Iterable</code>带有注释<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code> 。</p>
</div>
<div class="paragraph">
<p>还有其他类型的嵌套输入可用的任务类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.JavaExec.html#org.gradle.api.tasks.JavaExec:argumentProviders">JavaExec.getArgumentProviders（）</a> -模型，例如自定义工具</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.JavaExec.html#org.gradle.api.tasks.JavaExec:jvmArgumentProviders">JavaExec.getJvmArgumentProviders（）</a> -用于Jacoco Java代理</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:compilerArgumentProviders">CompileOptions.getCompilerArgumentProviders（）</a> -模型，例如注释处理器</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Exec.html#org.gradle.api.tasks.Exec:argumentProviders">Exec.getArgumentProviders（）</a> -模型，例如自定义工具</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>同样，这种建模可用于自定义任务。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:task_input_validation"><a class="anchor" href="#sec:task_input_validation"></a> <a class="link" href="#sec:task_input_validation">运行时验证</a></h7>
<div class="paragraph">
<p>在执行构建时，Gradle检查任务类型是否用适当的注释声明。它尝试识别问题，例如在不兼容的类型或setter等上使用注释。未标记有输入/输出注释的任何getter也会被标记。然后，在执行任务时，这些问题就会变成弃用警告。</p>
</div>
<div class="listingblock">
<div class="title">带有未声明输入和输出的任务的示例输出</div>
<div class="content">
<pre>&gt; gradle processTemplatesRuntime
&gt; Task :processTemplatesRuntime
Property 'outputDir' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
Property 'sourceFiles' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
Property 'templateData' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.
Property 'templateEngine' is not annotated with an input or output annotation. This behaviour has been deprecated and is scheduled to be removed in Gradle 7.0.


BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:task_input_output_runtime_api"><a class="anchor" href="#sec:task_input_output_runtime_api"></a> <a class="link" href="#sec:task_input_output_runtime_api">运行时API</a></h6>
<div class="paragraph">
<p>自定义任务类是将您自己的构建逻辑带入增量构建领域的一种简便方法，但是您并不总是有这种选择。因此，Gradle还提供了可用于任何任务的替代API，我们接下来将介绍。</p>
</div>
<div class="paragraph">
<p>如果您无权访问自定义任务类的源，则无法添加上一节中介绍的任何注释。幸运的是，Gradle为此类场景提供了运行时API。它也可以用于临时任务，正如您将在下面看到的那样。</p>
</div>
<div class="sect6">
<h7 id="sec:runtime_api_for_adhoc"><a class="anchor" href="#sec:runtime_api_for_adhoc"></a> <a class="link" href="#sec:runtime_api_for_adhoc">将其用于临时任务</a></h7>
<div class="paragraph">
<p>此运行时API是通过每个Gradle任务上可用的几个恰当命名的属性提供的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:inputs">TaskInputs</a>类型的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputs.html">Task.getInputs</a> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:inputs">（）</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:outputs">TaskOutputs</a>类型的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskOutputs.html">Task.getOutputs</a> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:outputs">（）</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:destroyables">TaskDestroyables</a>类型的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskDestroyables.html">Task.getDestroyables</a> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:destroyables">（）</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些对象具有允许您指定构成任务输入和输出的文件，目录和值的方法。实际上，运行时API与注释几乎具有同等功能。它所缺少的只是<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code> 。</p>
</div>
<div class="paragraph">
<p>让我们以之前的模板处理示例为例，看一下它是使用运行时API的即席任务的外观：</p>
</div>
<div class="exampleblock">
<div class="title">例子77。临时任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task processTemplatesAdHoc {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">engine</span><span class="delimiter">&quot;</span></span>, TemplateEngineType.FREEMARKER)
    inputs.files(fileTree(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/templates</span><span class="delimiter">&quot;</span></span>))
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">sourceFiles</span><span class="delimiter">&quot;</span></span>)
        .withPathSensitivity(PathSensitivity.RELATIVE)
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">templateData.name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">docs</span><span class="delimiter">&quot;</span></span>)
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">templateData.variables</span><span class="delimiter">&quot;</span></span>, [<span class="key">year</span>: <span class="integer">2013</span>])
    outputs.dir(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/genOutput2</span><span class="delimiter">&quot;</span></span>)
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">outputDir</span><span class="delimiter">&quot;</span></span>)

    doLast {
        <span class="comment">// Process the templates here</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;processTemplatesAdHoc&quot;) {
    inputs.property(&quot;engine&quot;, TemplateEngineType.FREEMARKER)
    inputs.files(fileTree(&quot;src/templates&quot;))
        .withPropertyName(&quot;sourceFiles&quot;)
        .withPathSensitivity(PathSensitivity.RELATIVE)
    inputs.property(&quot;templateData.name&quot;, &quot;docs&quot;)
    inputs.property(&quot;templateData.variables&quot;, mapOf(&quot;year&quot; to &quot;2013&quot;))
    outputs.dir(&quot;$buildDir/genOutput2&quot;)
        .withPropertyName(&quot;outputDir&quot;)

    doLast {
        // Process the templates here
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle processTemplatesAdHoc</code></strong></div>
<div class="content">
<pre>&gt; gradle processTemplatesAdHoc
&gt; Task :processTemplatesAdHoc

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>和以前一样，有很多要讨论的。首先，您实际上应该为此编写一个自定义任务类，因为它是一个具有多个配置选项的非平凡实现。在这种情况下，没有任务属性可以存储根源文件夹，输出目录的位置或任何其他设置。故意强调这一事实，即运行时API不需要任务具有任何状态。在增量构建方面，上述临时任务的行为与自定义任务类相同。</p>
</div>
<div class="paragraph">
<p>所有输入和输出定义都是通过以下方法完成的<code>inputs</code>和<code>outputs</code> ， 如<code>property()</code> ， <code>files()</code>和<code>dir()</code> 。Gradle对参数值执行最新检查，以确定任务是否需要再次运行。每个方法对应于一个增量构建批注，例如<code>inputs.property()</code>映射到<code>@Input</code>和<code>outputs.dir()</code>映射到<code>@OutputDirectory</code> 。</p>
</div>
<div class="paragraph">
<p>任务删除的文件可以通过以下方式指定<code>destroyables.register()</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例78。临时任务宣告为可摧毁</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task removeTempDir {
    destroyables.register(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>projectDir</span><span class="content">/tmpDir</span><span class="delimiter">&quot;</span></span>)
    doLast {
        delete(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>projectDir</span><span class="content">/tmpDir</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;removeTempDir&quot;) {
    destroyables.register(&quot;$projectDir/tmpDir&quot;)
    doLast {
        delete(&quot;$projectDir/tmpDir&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行时API和注释之间的显着区别是缺少一种直接对应于<code>@Nested</code> 。这就是为什么该示例使用两个<code>property()</code>模板数据的声明，每个声明一个<code>TemplateData</code>属性。在将运行时API与嵌套值一起使用时，应使用相同的技术。任何给定的任务都可以声明可销毁物品或输入/输出，但不能同时声明两者。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:runtime_api_configuration"><a class="anchor" href="#sec:runtime_api_configuration"></a> <a class="link" href="#sec:runtime_api_configuration">细粒度配置</a></h7>
<div class="paragraph">
<p>运行时API方法仅允许您自己声明输入和输出。但是，面向文件的工具会返回一个生成器-类型为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskInputFilePropertyBuilder.html">TaskInputFilePropertyBuilder-</a>可让您提供有关这些输入和输出的其他信息。</p>
</div>
<div class="paragraph">
<p>您可以在其API文档中了解该构建器提供的所有选项，但是在这里我们将向您展示一个简单的示例，让您大致了解可以做什么。</p>
</div>
<div class="paragraph">
<p>假设我们不想运行<code>processTemplates</code>任务，如果没有源文件，无论它是否是干净的版本。毕竟，如果没有源文件，则无需执行任何任务。构建器允许我们这样配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例79。通过运行时API使用skipWhenEmpty（）</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task processTemplatesAdHocSkipWhenEmpty {
    <span class="comment">// ...</span>

    inputs.files(fileTree(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/templates</span><span class="delimiter">&quot;</span></span>) {
            include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.fm</span><span class="delimiter">&quot;</span></span>
        })
        .skipWhenEmpty()
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">sourceFiles</span><span class="delimiter">&quot;</span></span>)
        .withPathSensitivity(PathSensitivity.RELATIVE)

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;processTemplatesAdHocSkipWhenEmpty&quot;) {
    // ...

    inputs.files(fileTree(&quot;src/templates&quot;) {
            include(&quot;**/*.fm&quot;)
        })
        .skipWhenEmpty()
        .withPropertyName(&quot;sourceFiles&quot;)
        .withPathSensitivity(PathSensitivity.RELATIVE)

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle clean processTemplatesAdHocSkipWhenEmpty</code></strong></div>
<div class="content">
<pre>&gt; gradle clean processTemplatesAdHocSkipWhenEmpty
&gt; Task :processTemplatesAdHocSkipWhenEmpty NO-SOURCE


BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>TaskInputs.files()</code>方法返回具有<code>skipWhenEmpty()</code>方法。调用此方法等效于使用注释属性<a href="#skip-when-empty"><code>@SkipWhenEmpty</code></a> 。</p>
</div>
<div class="paragraph">
<p>既然您已经看到了注释和运行时API，那么您可能想知道应该使用哪个API。我们的建议是尽可能使用批注，有时值得创建自定义任务类，以便您可以使用它们。运行时API更适用于无法使用注释的情况。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:runtime_api_for_custom_tasks"><a class="anchor" href="#sec:runtime_api_for_custom_tasks"></a> <a class="link" href="#sec:runtime_api_for_custom_tasks">将其用于自定义任务类型</a></h7>
<div class="paragraph">
<p>另一类示例涉及为自定义任务类的实例注册其他输入和输出。例如，假设<code>ProcessTemplates</code>任务也需要阅读<code>src/headers/headers.txt</code> （例如，因为它是从一个来源中包含的）。您希望Gradle知道此输入文件，以便只要此文件的内容更改，它就可以重新执行任务。使用运行时API，您可以做到这一点：</p>
</div>
<div class="exampleblock">
<div class="title">示例80。将运行时API与自定义任务类型一起使用</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task processTemplatesWithExtraInputs(<span class="key">type</span>: ProcessTemplates) {
    <span class="comment">// ...</span>

    inputs.file(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/headers/headers.txt</span><span class="delimiter">&quot;</span></span>)
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">headers</span><span class="delimiter">&quot;</span></span>)
        .withPathSensitivity(PathSensitivity.NONE)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;ProcessTemplates&gt;(&quot;processTemplatesWithExtraInputs&quot;) {
    // ...

    inputs.file(&quot;src/headers/headers.txt&quot;)
        .withPropertyName(&quot;headers&quot;)
        .withPathSensitivity(PathSensitivity.NONE)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>像这样使用运行时API有点像使用<code>doLast()</code>和<code>doFirst()</code>以将额外的动作附加到任务上，除非在这种情况下，我们附加有关输入和输出的信息。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果任务类型已经在使用增量构建批注，则使用相同的属性名称注册输入或输出将导致错误。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:task_input_output_side_effects"><a class="anchor" href="#sec:task_input_output_side_effects"></a> <a class="link" href="#sec:task_input_output_side_effects">重要的有益副作用</a></h6>
<div class="paragraph">
<p>一旦声明了任务的正式输入和输出，Gradle就可以推断出有关这些属性的信息。例如，如果将一个任务的输入设置为另一个任务的输出，则意味着第一个任务取决于第二个任务，对吗？Gradle知道这一点并可以采取行动。</p>
</div>
<div class="paragraph">
<p>接下来，我们将介绍此功能，以及Gradle了解输入和输出的其他一些功能。</p>
</div>
<div class="sect6">
<h7 id="sec:inferred_task_dependencies"><a class="anchor" href="#sec:inferred_task_dependencies"></a> <a class="link" href="#sec:inferred_task_dependencies">推断的任务依赖性</a></h7>
<div class="paragraph">
<p>考虑一个打包任务的归档任务<code>processTemplates</code>任务。构建作者将看到存档任务显然需要<code>processTemplates</code>首先运行，因此可能会添加一个显式<code>dependsOn</code> 。但是，如果您这样定义归档任务：</p>
</div>
<div class="exampleblock">
<div class="title">例子81。通过任务输出推断任务依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task packageFiles(<span class="key">type</span>: Zip) {
    from processTemplates.outputs
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Zip&gt;(&quot;packageFiles&quot;) {
    from(processTemplates.get().outputs)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle clean packageFiles</code></strong></div>
<div class="content">
<pre>&gt; gradle clean packageFiles
&gt; Task :processTemplates
&gt; Task :packageFiles


BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle会自动使<code>packageFiles</code>取决于<code>processTemplates</code> 。之所以可以这样做，是因为它知道packageFiles的输入之一需要processTemplates任务的输出。我们称其为推断的任务依赖性。</p>
</div>
<div class="paragraph">
<p>上面的例子也可以写成</p>
</div>
<div class="exampleblock">
<div class="title">示例82。通过任务参数推断任务依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task packageFiles2(<span class="key">type</span>: Zip) {
    from processTemplates
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Zip&gt;(&quot;packageFiles2&quot;) {
    from(processTemplates)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle clean packageFiles2</code></strong></div>
<div class="content">
<pre>&gt; gradle clean packageFiles2
&gt; Task :processTemplates
&gt; Task :packageFiles2


BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这是因为<code>from()</code>方法可以接受任务对象作为参数。在幕后<code>from()</code>使用<code>project.files()</code>包装参数的方法，该参数又将任务的形式输出公开为文件集合。换句话说，这是特例！</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:task_input_output_validation"><a class="anchor" href="#sec:task_input_output_validation"></a> <a class="link" href="#sec:task_input_output_validation">输入和输出验证</a></h7>
<div class="paragraph">
<p>增量构建批注为Gradle提供足够的信息，以对批注的属性执行一些基本验证。特别是，在任务执行之前，它将对每个属性执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@InputFile</code> -验证该属性具有值，并且该路径对应于存在的文件（不是目录）。</p>
</li>
<li>
<p><code>@InputDirectory</code> -与<code>@InputFile</code> ，除了路径必须与目录相对应。</p>
</li>
<li>
<p><code>@OutputDirectory</code> -验证路径与文件不匹配，并在目录不存在的情况下创建目录。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种验证提高了构建的健壮性，使您可以快速识别与输入和输出有关的问题。</p>
</div>
<div class="paragraph">
<p>您有时会希望禁用某些验证，特别是在输入文件可能确实不存在的情况下。这就是为什么Gradle提供<code>@Optional</code>注解：使用它来告诉Gradle特定输入是可选的，因此，如果对应的文件或目录不存在，构建也不会失败。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:task_input_output_continuous_build"><a class="anchor" href="#sec:task_input_output_continuous_build"></a> <a class="link" href="#sec:task_input_output_continuous_build">持续建造</a></h7>
<div class="paragraph">
<p>定义任务输入和输出的另一个好处是连续构建。由于Gradle知道任务所依赖的文件，因此如果其任何输入发生更改，它可以自动再次运行任务。通过在运行Gradle时激活连续构建-通过<code>--continuous</code>要么<code>-t</code>选项-您将把Gradle置于一种状态，在这种状态下，它会不断检查更改并在遇到此类更改时执行所请求的任务。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="#sec:continuous_build">Continuous build中</a>找到有关此功能的更多信息。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:task_input_output_parallelism"><a class="anchor" href="#sec:task_input_output_parallelism"></a> <a class="link" href="#sec:task_input_output_parallelism">任务并行</a></h7>
<div class="paragraph">
<p>定义任务输入和输出的最后一个好处是，当使用“ --parallel”选项时，Gradle可以使用此信息来决定如何运行任务。例如，Gradle在选择要运行的下一个任务时将检查任务的输出，并将避免并发执行写入同一输出目录的任务。同样，Gradle将使用有关任务销毁哪些文件的信息（例如，由<code>Destroys</code>注释），并避免在运行另一个消耗或创建相同文件的任务时运行删除一组文件的任务（反之亦然）。它还可以确定创建一组文件的任务已经运行，并且消耗这些文件的任务尚未运行，并且将避免运行将两者之间的文件删除的任务。通过以这种方式提供任务输入和输出信息，Gradle可以推断任务之间的创建/消耗/销毁关系，并可以确保任务执行不违反那些关系。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:how_does_it_work"><a class="anchor" href="#sec:how_does_it_work"></a> <a class="link" href="#sec:how_does_it_work">它是如何工作的？</a></h5>
<div class="paragraph">
<p>在第一次执行任务之前，Gradle会对输入进行指纹识别。此指纹包含输入文件的路径以及每个文件内容的哈希。然后Gradle执行任务。如果任务成功完成，则Gradle将对输出进行指纹识别。此指纹包含一组输出文件以及每个文件内容的哈希值。Gradle会在下一次执行任务时保留两个指纹。</p>
</div>
<div class="paragraph">
<p>每次之后，在执行任务之前，Gradle都会对输入和输出使用新的指纹。如果新的指纹与以前的指纹相同，则Gradle会假定输出是最新的，并跳过该任务。如果它们不相同，则Gradle执行任务。Gradle会在下一次执行任务时保留两个指纹。</p>
</div>
<div class="paragraph">
<p>如果文件的统计信息（即<code>lastModified</code>和<code>size</code> ）没有更改，Gradle将重复使用上次运行的文件指纹。这意味着当文件的统计信息未更改时，Gradle不会检测到更改。</p>
</div>
<div class="paragraph">
<p>Gradle还将任务<em>代码</em>视为任务输入的一部分。当任务，其动作或其依赖关系在两次执行之间发生变化时，Gradle会将任务视为过时的。</p>
</div>
<div class="paragraph">
<p>Gradle了解文件属性（例如，持有Java类路径的文件属性）是否对顺序敏感。比较此类属性的指纹时，即使文件顺序发生更改，也将导致任务过时。</p>
</div>
<div class="paragraph">
<p>请注意，如果任务指定了输出目录，则自上次执行该任务以来添加到该目录的所有文件都将被忽略，并且不会导致该任务过时。这样一来，不相关的任务可以共享一个输出目录，而不会互相干扰。如果由于某些原因这不是您想要的行为，请考虑使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-groovy.lang.Closure-">TaskOutputs.upToDateWhen（groovy.lang。关闭）</a></p>
</div>
<div class="paragraph">
<p>还请注意，将通过最新检查来检测和处理更改不可用文件的可用性（例如，将断开的符号链接的目标修改为有效文件，反之亦然）。</p>
</div>
<div class="paragraph">
<p>任务的输入还用于计算<a href="#build_cache">构建高速缓存</a>密钥，该密钥在启用后将加载任务输出。有关更多详细信息，请参见<a href="#sec:task_output_caching">任务输出缓存</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>为了跟踪任务，任务动作和嵌套输入的实现，Gradle使用类名称和包含实现的类路径标识符。在某些情况下，Gradle无法准确跟踪实现：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">未知的类加载器</dt>
<dd>
<p>当Gradle尚未创建加载实现的类加载器时，无法确定类路径。</p>
</dd>
<dt class="hdlist1">Java Lambda</dt>
<dd>
<p>Java lambda类是在运行时使用不确定的类名创建的。因此，类名称不能标识lambda的实现，并且不能在不同的Gradle运行之间进行更改。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>当无法精确跟踪任务，任务动作或嵌套输入的实现时，Gradle将禁用该任务的任何缓存。这意味着该任务永远不会是最新的，也不会从<a href="#sec:task_output_caching">构建缓存中</a>加载。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:advanced_inc_build"><a class="anchor" href="#sec:advanced_inc_build"></a> <a class="link" href="#sec:advanced_inc_build">先进技术</a></h5>
<div class="paragraph">
<p>到目前为止，您在本节中看到的所有内容都将涵盖您将遇到的大多数用例，但是有些情况需要特殊对待。接下来，我们将为您提供其中一些解决方案。</p>
</div>
<div class="sect5">
<h6 id="sec:add_cached_input_output_methods"><a class="anchor" href="#sec:add_cached_input_output_methods"></a> <a class="link" href="#sec:add_cached_input_output_methods">添加您自己的缓存的输入/输出方法</a></h6>
<div class="paragraph">
<p>您是否想过<code>from()</code>的方法<code>Copy</code>任务有效吗？没有注释<code>@InputFiles</code>但是传递给它的所有文件都被视为任务的正式输入。发生了什么？</p>
</div>
<div class="paragraph">
<p>实现非常简单，您可以针对自己的任务使用相同的技术来改进其API。编写您的方法，以便它们将文件直接添加到适当的带注释的属性。举例来说，以下是添加<code>sources()</code>自定义方法<code>ProcessTemplates</code>我们前面介绍的类：</p>
</div>
<div class="exampleblock">
<div class="title">示例83。声明添加任务输入的方法</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task processTemplates(<span class="key">type</span>: ProcessTemplates) {
    templateEngine = TemplateEngineType.FREEMARKER
    templateData = <span class="keyword">new</span> TemplateData(<span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span>, [<span class="key">year</span>: <span class="integer">2012</span>])
    outputDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/genOutput</span><span class="delimiter">&quot;</span></span>)

    sources fileTree(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/templates</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;ProcessTemplates&gt;(&quot;processTemplates&quot;) {
    templateEngine = TemplateEngineType.FREEMARKER
    templateData = TemplateData(&quot;test&quot;, mapOf(&quot;year&quot; to &quot;2012&quot;))
    outputDir = file(&quot;$buildDir/genOutput&quot;)

    sources(fileTree(&quot;src/templates&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">ProcessTemplates.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ProcessTemplates</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// ...</span>
    <span class="directive">private</span> FileCollection sourceFiles = getProject().getLayout().files();

    <span class="annotation">@SkipWhenEmpty</span>
    <span class="annotation">@InputFiles</span>
    <span class="annotation">@PathSensitive</span>(PathSensitivity.NONE)
    <span class="directive">public</span> FileCollection getSourceFiles() {
        <span class="keyword">return</span> <span class="local-variable">this</span>.sourceFiles;
    }

    <span class="directive">public</span> <span class="type">void</span> sources(FileCollection sourceFiles) {
        <span class="local-variable">this</span>.sourceFiles = <span class="local-variable">this</span>.sourceFiles.plus(sourceFiles);
    }

    <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle processTemplates</code></div>
<div class="content">
<pre>&gt; gradle processTemplates
&gt; Task :processTemplates


BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>换句话说，只要您在配置阶段将值和文件添加到正式任务的输入和输出中，无论您在构建中的何处添加它们，它们都将被视为此类。</p>
</div>
<div class="paragraph">
<p>如果我们也想支持任务作为参数并将其输出作为输入，则可以使用<code>project.layout.files()</code>像这样的方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例84。声明将任务添加为输入的方法</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyTemplates(<span class="key">type</span>: Copy) {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/tmp</span><span class="delimiter">&quot;</span></span>
    from <span class="string"><span class="delimiter">&quot;</span><span class="content">src/templates</span><span class="delimiter">&quot;</span></span>
}

task processTemplates2(<span class="key">type</span>: ProcessTemplates) {
    <span class="comment">// ...</span>
    sources copyTemplates
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val copyTemplates by tasks.registering(Copy::class) {
    into(&quot;$buildDir/tmp&quot;)
    from(&quot;src/templates&quot;)
}

tasks.register&lt;ProcessTemplates&gt;(&quot;processTemplates2&quot;) {
    // ...
    sources(copyTemplates.get())
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">ProcessTemplates.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">    <span class="comment">// ...</span>
    <span class="directive">public</span> <span class="type">void</span> sources(Task inputTask) {
        <span class="local-variable">this</span>.sourceFiles = <span class="local-variable">this</span>.sourceFiles.plus(getProject().getLayout().files(inputTask));
    }
    <span class="comment">// ...</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle processTemplates2</code></div>
<div class="content">
<pre>&gt; gradle processTemplates2
&gt; Task :copyTemplates
&gt; Task :processTemplates2


BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此技术可以使您的自定义任务更易于使用，并生成更干净的构建文件。作为额外的好处，我们使用<code>getProject().getLayout().files()</code>意味着我们的自定义方法可以设置推断的任务依赖项。</p>
</div>
<div class="paragraph">
<p>最后需要注意的一件事：如果要开发一个将源文件集合作为输入的任务，例如本示例，请考虑使用内置的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceTask.html">SourceTask</a> 。这将使您不必实施我们放入的某些管道<code>ProcessTemplates</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:link_output_dir_to_input_files"><a class="anchor" href="#sec:link_output_dir_to_input_files"></a> <a class="link" href="#sec:link_output_dir_to_input_files">链接一个<code>@OutputDirectory</code>到<code>@InputFiles</code></a></h6>
<div class="paragraph">
<p>当您要将一个任务的输出链接到另一任务的输入时，类型通常匹配，并且简单的属性分配将提供该链接。例如，一个<code>File</code>输出属性可以分配给<code>File</code>输入。</p>
</div>
<div class="paragraph">
<p>不幸的是，当您想要任务中的文件时，这种方法会失效<code>@OutputDirectory</code> （类型<code>File</code> ）成为另一个任务的来源<code>@InputFiles</code>属性（类型<code>FileCollection</code> ）。由于这两种类型不同，因此属性分配将不起作用。</p>
</div>
<div class="paragraph">
<p>举例来说，假设您要使用Java编译任务的输出-通过<code>destinationDir</code>属性-作为定制任务的输入，该定制任务检测包含Java字节码的一组文件。这个自定义任务，我们称之为<code>Instrument</code> ， 有个<code>classFiles</code>带有注释的属性<code>@InputFiles</code> 。您最初可能会尝试像这样配置任务：</p>
</div>
<div class="exampleblock">
<div class="title">示例85。尝试设置推断的任务依赖项失败</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}

task badInstrumentClasses(<span class="key">type</span>: <span class="predefined-type">Instrument</span>) {
    classFiles = fileTree(compileJava.destinationDir)
    destinationDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/instrumented</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}

tasks.register&lt;Instrument&gt;(&quot;badInstrumentClasses&quot;) {
    classFiles = fileTree(tasks.compileJava.get().destinationDir)
    destinationDir = file(&quot;$buildDir/instrumented&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle clean badInstrumentClasses</code></strong></div>
<div class="content">
<pre>&gt; gradle clean badInstrumentClasses
&gt; Task :clean UP-TO-DATE
&gt; Task :badInstrumentClasses NO-SOURCE


BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这段代码显然没有错，但是您可以从控制台输出中看到缺少编译任务。在这种情况下，您将需要在<code>instrumentClasses</code>和<code>compileJava</code>通过<code>dependsOn</code> 。指某东西的用途<code>fileTree()</code>意味着Gradle无法推断任务依赖项本身。</p>
</div>
<div class="paragraph">
<p>一种解决方案是使用<code>TaskOutputs.files</code>属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例86。在输出目录和输入文件之间设置推断的任务依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task instrumentClasses(<span class="key">type</span>: <span class="predefined-type">Instrument</span>) {
    classFiles = compileJava.outputs.files
    destinationDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/instrumented</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Instrument&gt;(&quot;instrumentClasses&quot;) {
    classFiles = tasks.compileJava.get().outputs.files
    destinationDir = file(&quot;$buildDir/instrumented&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle clean instrumentClasses</code></strong></div>
<div class="content">
<pre>&gt; gradle clean instrumentClasses
&gt; Task :clean UP-TO-DATE
&gt; Task :compileJava
&gt; Task :instrumentClasses


BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另外，您可以使用以下方法之一使Gradle本身访问适当的属性<code>project.files()</code> ， <code>project.layout.files()</code>要么<code>project.objects.fileCollection()</code>代替<code>project.fileTree()</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">例子87。设置推断的任务依赖项<code>layout.files()</code></div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task instrumentClasses2(<span class="key">type</span>: <span class="predefined-type">Instrument</span>) {
    classFiles = layout.files(compileJava)
    destinationDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/instrumented</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Instrument&gt;(&quot;instrumentClasses2&quot;) {
    classFiles = layout.files(tasks.compileJava.get())
    destinationDir = file(&quot;$buildDir/instrumented&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle clean instrumentClasses2</code></strong></div>
<div class="content">
<pre>&gt; gradle clean instrumentClasses2
&gt; Task :clean UP-TO-DATE
&gt; Task :compileJava
&gt; Task :instrumentClasses2


BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请记住<code>files()</code> ， <code>layout.files()</code>和<code>objects.fileCollection()</code>可以将任务作为参数，而<code>fileTree()</code>不能。</p>
</div>
<div class="paragraph">
<p>这种方法的缺点是，源任务的所有文件输出都将成为目标的输入文件- <code>instrumentClasses</code>在这种情况下。只要源任务只有一个基于文件的输出即可，例如<code>JavaCompile</code>任务。但是，如果您仅需要链接多个输出属性中的一个，则需要使用以下命令明确告诉Gradle哪个任务生成输入文件： <code>builtBy</code>方法：</p>
</div>
<div class="exampleblock">
<div class="title">例子88。使用builtBy（）设置推断的任务依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task instrumentClassesBuiltBy(<span class="key">type</span>: <span class="predefined-type">Instrument</span>) {
    classFiles = fileTree(compileJava.destinationDir) {
        builtBy compileJava
    }
    destinationDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/instrumented</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Instrument&gt;(&quot;instrumentClassesBuiltBy&quot;) {
    classFiles = fileTree(tasks.compileJava.get().destinationDir) {
        builtBy(tasks.compileJava.get())
    }
    destinationDir = file(&quot;$buildDir/instrumented&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle clean instrumentClassesBuiltBy</code></strong></div>
<div class="content">
<pre>&gt; gradle clean instrumentClassesBuiltBy
&gt; Task :clean UP-TO-DATE
&gt; Task :compileJava
&gt; Task :instrumentClassesBuiltBy


BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您当然可以通过添加一个明确的任务依赖项<code>dependsOn</code> ，但是上述方法提供了更多的语义含义，解释了原因<code>compileJava</code>必须事先运行。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:custom_up_to_date_logic"><a class="anchor" href="#sec:custom_up_to_date_logic"></a> <a class="link" href="#sec:custom_up_to_date_logic">提供自定义的最新逻辑</a></h6>
<div class="paragraph">
<p>Gradle自动处理输出文件和目录的最新检查，但是如果任务输出完全是其他东西怎么办？也许这是对Web服务或数据库表的更新。在这种情况下，Gradle无法知道如何检查任务是否最新。</p>
</div>
<div class="paragraph">
<p>那就是<code>upToDateWhen()</code>方法开启<code>TaskOutputs</code>进来。这采用谓词函数，该谓词函数用于确定任务是否最新。一种用例是完全禁用一项任务的最新检查，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例89。忽略最新检查</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task alwaysInstrumentClasses(<span class="key">type</span>: <span class="predefined-type">Instrument</span>) {
    classFiles = layout.files(compileJava)
    destinationDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/instrumented</span><span class="delimiter">&quot;</span></span>)
    outputs.upToDateWhen { <span class="predefined-constant">false</span> }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Instrument&gt;(&quot;alwaysInstrumentClasses&quot;) {
    classFiles = layout.files(tasks.compileJava.get())
    destinationDir = file(&quot;$buildDir/instrumented&quot;)
    outputs.upToDateWhen { false }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle clean alwaysInstrumentClasses</code></div>
<div class="content">
<pre>&gt; gradle clean alwaysInstrumentClasses
&gt; Task :compileJava
&gt; Task :alwaysInstrumentClasses


BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date</pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle alwaysInstrumentClasses</code></div>
<div class="content">
<pre>&gt; gradle alwaysInstrumentClasses
&gt; Task :compileJava UP-TO-DATE
&gt; Task :alwaysInstrumentClasses


BUILD SUCCESSFUL in 0s
2 actionable tasks: 1 executed, 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>{ false }</code>封闭确保<code>alwaysInstrumentClasses</code>无论输入或输出是否有变化，都将始终执行。</p>
</div>
<div class="paragraph">
<p>您当然可以在闭包中添加更复杂的逻辑。例如，您可以检查数据库表中的特定记录是否存在或已更改。请注意，最新的检查应该可以<em>节省</em>您的时间。不要添加比标准执行任务花费更多或更多时间的检查。实际上，如果某个任务由于很少更新而最终经常运行，则根本不值得进行最新检查。请记住，如果任务在执行任务图中，则检查将始终运行。</p>
</div>
<div class="paragraph">
<p>一个常见的错误是使用<code>upToDateWhen()</code>代替<code>Task.onlyIf()</code> 。如果要基于与任务输入和输出无关的某些条件跳过任务，则应使用<code>onlyIf()</code> 。例如，在要设置或不设置特定属性的情况下要跳过任务的情况。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:configure_input_normalization"><a class="anchor" href="#sec:configure_input_normalization"></a> <a class="link" href="#sec:configure_input_normalization">配置输入标准化</a></h6>
<div class="paragraph">
<p>对于最新检查和<a href="#build_cache">构建缓存，</a> Gradle需要确定两个任务输入属性是否具有相同的值。为此，Gradle首先将两个输入标准化，然后比较结果。例如，对于编译类路径，Gradle从类路径上的类中提取ABI签名，然后按照<a href="#sec:java_compile_avoidance">Java编译规避中的</a>描述比较上一次Gradle运行和当前Gradle运行之间的签名。</p>
</div>
<div class="paragraph">
<p>可以自定义Gradle的内置策略以用于运行时类路径规范化。所有带有注释的输入<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Classpath.html">Classpath</a></code>被认为是运行时类路径。</p>
</div>
<div class="paragraph">
<p>假设您要添加文件<code>build-info.properties</code>到所有产生的jar文件中，这些文件包含有关构建的信息，例如，构建开始的时间戳或用于标识发布了工件的CI作业的一些ID。该文件仅用于审计目的，对运行测试的结果没有影响。但是，此文件是运行时类路径的一部分， <code>test</code>每次构建调用的任务和更改。因此， <code>test</code>永远不会是最新的，也不会从构建缓存中提取。为了再次从增量构建中受益，您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:normalization(org.gradle.api.Action)">Project.normalization（org.gradle.api）告诉Gradle在项目级别的运行时类路径上忽略此文件</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:normalization(org.gradle.api.Action)">。动作）</a> （在<em>消耗</em>项目中）：</p>
</div>
<div class="exampleblock">
<div class="title">示例90。运行时类路径规范化</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">normalization {
    runtimeClasspath {
        ignore <span class="string"><span class="delimiter">'</span><span class="content">build-info.properties</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">normalization {
    runtimeClasspath {
        ignore(&quot;build-info.properties&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要对jar文件中的所有项目执行此文件添加操作，并且要为所有使用者过滤此文件，则可以将上述配置包装在<code>allprojects {}</code>要么<code>subprojects {}</code>阻止根构建脚本。</p>
</div>
<div class="paragraph">
<p>此配置的结果是更改为<code>build-info.properties</code>对于最新检查和<a href="#build_cache">构建缓存</a>键计算将被忽略。请注意，这不会更改<code>test</code>任务-即任何测试仍然能够加载<code>build-info.properties</code>并且运行时类路径仍然与以前相同。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:stale_task_outputs"><a class="anchor" href="#sec:stale_task_outputs"></a> <a class="link" href="#sec:stale_task_outputs">旧任务输出</a></h5>
<div class="paragraph">
<p>当Gradle版本更改时，Gradle将检测到需要删除使用较旧版本的Gradle运行的任务的输出，以确保任务的最新版本从已知的干净状态开始。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>仅针对源集的输出（Java / Groovy / Scala编译）实现了对陈旧的输出目录的自动清除。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:task_rules"><a class="anchor" href="#sec:task_rules"></a> <a class="link" href="#sec:task_rules">任务规则</a></h4>
<div class="paragraph">
<p>有时您想执行一个任务，该任务的行为取决于较大或无限数量的参数值范围。提供此类任务的一种非常好的表达方式是任务规则：</p>
</div>
<div class="exampleblock">
<div class="title">例子91。任务规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.addRule(<span class="string"><span class="delimiter">&quot;</span><span class="content">Pattern: ping&lt;ID&gt;</span><span class="delimiter">&quot;</span></span>) { <span class="predefined-type">String</span> taskName -&gt;
    <span class="keyword">if</span> (taskName.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">ping</span><span class="delimiter">&quot;</span></span>)) {
        task(taskName) {
            doLast {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Pinging: </span><span class="delimiter">&quot;</span></span> + (taskName - <span class="string"><span class="delimiter">'</span><span class="content">ping</span><span class="delimiter">'</span></span>)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.addRule(&quot;Pattern: ping&lt;ID&gt;&quot;) {
    val taskName = this
    if (startsWith(&quot;ping&quot;)) {
        task(taskName) {
            doLast {
                println(&quot;Pinging: &quot; + (taskName.replace(&quot;ping&quot;, &quot;&quot;)))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q pingServer1</code></strong></div>
<div class="content">
<pre>&gt; gradle -q pingServer1
Pinging: Server1</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>String参数用作规则的描述，显示为<code>gradle tasks</code> 。</p>
</div>
<div class="paragraph">
<p>规则不仅在从命令行调用任务时使用。您还可以在基于规则的任务上创建dependsOn关系：</p>
</div>
<div class="exampleblock">
<div class="title">示例92。对基于规则的任务的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.addRule(<span class="string"><span class="delimiter">&quot;</span><span class="content">Pattern: ping&lt;ID&gt;</span><span class="delimiter">&quot;</span></span>) { <span class="predefined-type">String</span> taskName -&gt;
    <span class="keyword">if</span> (taskName.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">ping</span><span class="delimiter">&quot;</span></span>)) {
        task(taskName) {
            doLast {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Pinging: </span><span class="delimiter">&quot;</span></span> + (taskName - <span class="string"><span class="delimiter">'</span><span class="content">ping</span><span class="delimiter">'</span></span>)
            }
        }
    }
}

task groupPing {
    dependsOn pingServer1, pingServer2
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.addRule(&quot;Pattern: ping&lt;ID&gt;&quot;) {
    val taskName = this
    if (startsWith(&quot;ping&quot;)) {
        task(taskName) {
            doLast {
                println(&quot;Pinging: &quot; + (taskName.replace(&quot;ping&quot;, &quot;&quot;)))
            }
        }
    }
}

task(&quot;groupPing&quot;) {
    dependsOn(&quot;pingServer1&quot;, &quot;pingServer2&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q groupPing</code></strong></div>
<div class="content">
<pre>&gt; gradle -q groupPing
Pinging: Server1
Pinging: Server2</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您运行“ <code>gradle -q tasks</code> ”您将找不到名为“的任务<code>pingServer1</code> “ 要么 ” <code>pingServer2</code> ”，但此脚本正在根据运行这些任务的请求执行逻辑。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:finalizer_tasks"><a class="anchor" href="#sec:finalizer_tasks"></a> <a class="link" href="#sec:finalizer_tasks">终结器任务</a></h4>
<div class="paragraph">
<p>当计划运行终结任务时，终结任务会自动添加到任务图中。</p>
</div>
<div class="exampleblock">
<div class="title">示例93。添加任务终结器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
    }
}
task taskY {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    }
}

taskX.finalizedBy taskY</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val taskX by tasks.registering {
    doLast {
        println(&quot;taskX&quot;)
    }
}
val taskY by tasks.registering {
    doLast {
        println(&quot;taskY&quot;)
    }
}

taskX { finalizedBy(taskY) }</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskX
taskX
taskY</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使完成任务失败，也将执行终结器任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例94。失败任务的任务终结器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task taskX {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskX</span><span class="delimiter">'</span></span>
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>()
    }
}
task taskY {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">taskY</span><span class="delimiter">'</span></span>
    }
}

taskX.finalizedBy taskY</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val taskX by tasks.registering {
    doLast {
        println(&quot;taskX&quot;)
        throw RuntimeException()
    }
}
val taskY by tasks.registering {
    doLast {
        println(&quot;taskY&quot;)
    }
}

taskX { finalizedBy(taskY) }</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q taskX</code></strong></div>
<div class="content">
<pre>&gt; gradle -q taskX
taskX
taskY

FAILURE: Build failed with an exception.

* Where:
Build file '/home/user/gradle/samples/groovy/build.gradle' line: 4

* What went wrong:
Execution failed for task ':taskX'.
&gt; java.lang.RuntimeException (no error message)

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 0s</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另一方面，如果已完成任务没有执行任何工作，例如，如果认为已完成任务或从属任务失败，则不会执行最终任务。</p>
</div>
<div class="paragraph">
<p>在构建创建无论构建失败还是成功都必须清除的资源的情况下，终结器任务很有用。这样的资源的一个示例是一个Web容器，它在集成测试任务之前启动，并且即使某些测试失败，也应始终将其关闭。</p>
</div>
<div class="paragraph">
<p>要指定终结器任务，请使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object[])">Task.finalizedBy（java.lang。对象...）</a>方法。此方法接受任务实例，任务名称或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])">Task.dependsOn（java.lang。对象...</a></p>
</div>
</div>
<div class="sect3">
<h4 id="sec:lifecycle_tasks"><a class="anchor" href="#sec:lifecycle_tasks"></a> <a class="link" href="#sec:lifecycle_tasks">生命周期任务</a></h4>
<div class="paragraph">
<p>生命周期任务是不能自行工作的任务。他们通常没有任何任务动作。生命周期任务可以代表几个概念：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>工作流程步骤（例如，使用<code>check</code> ）</p>
</li>
<li>
<p>可构建的事物（例如，使用以下命令为本机组件创建调试的32位可执行文件： <code>debug32MainExecutable</code> ）</p>
</li>
<li>
<p>一个方便的任务，可以执行许多相同的逻辑任务（例如，使用<code>compileAll</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>基本插件定义了几个<a href="#sec:base_tasks">标准的生命周期任务</a> ，例如<code>build</code> ， <code>assemble</code>和<code>check</code> 。所有核心语言插件（如<a href="#java_plugin">Java插件</a> ）都应用基本插件，因此具有相同的生命周期任务基本集。</p>
</div>
<div class="paragraph">
<p>除非生命周期任务具有操作，否则其<a href="#sec:task_outcomes">结果</a>取决于其任务依赖性。如果执行了这些依赖关系中的任何一个，则将考虑生命周期任务<code>EXECUTED</code> 。如果所有任务相关性都是最新的，已跳过或已从缓存中删除，则将考虑生命周期任务<code>UP-TO-DATE</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:the_idea_behind_gradle_tasks"><a class="anchor" href="#sec:the_idea_behind_gradle_tasks"></a> <a class="link" href="#sec:the_idea_behind_gradle_tasks">摘要</a></h4>
<div class="paragraph">
<p>如果您来自Ant，则增强的Gradle任务（如<em>Copy）</em>似乎是Ant目标与Ant任务之间的交叉。尽管Ant的任务和目标实际上是不同的实体，但是Gradle将这些概念组合为一个实体。简单的Gradle任务就像Ant的目标一样，但是增强的Gradle任务也包括Ant任务的各个方面。Gradle的所有任务共享一个通用的API，您可以在它们之间创建依赖关系。这些任务比Ant任务更容易配置。它们充分利用了类型系统，并且更具表现力且易于维护。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing_build_scripts"><a class="anchor" href="#writing_build_scripts"></a> <a class="link" href="#writing_build_scripts">编写构建脚本</a></h3>
<div class="paragraph">
<p>本章着眼于编写构建脚本的一些细节。</p>
</div>
<div class="sect3">
<h4 id="sec:the_gradle_build_language"><a class="anchor" href="#sec:the_gradle_build_language"></a> <a class="link" href="#sec:the_gradle_build_language">Gradle构建语言</a></h4>
<div class="paragraph">
<p>Gradle提供了一种<em>特定</em>于<em>领域的语言</em>或DSL，用于描述构建。Groovy和Kotlin中提供了这种构建语言。</p>
</div>
<div class="paragraph">
<p>Groovy构建脚本可以包含任何Groovy语言元素。 <sup class="footnote">[ <a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="查看脚注。">4</a> ]</sup> Kotlin构建脚本可以包含任何Kotlin语言元素。Gradle假定每个构建脚本都是使用UTF-8编码的。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:project_api"><a class="anchor" href="#sec:project_api"></a> <a class="link" href="#sec:project_api">专案API</a></h4>
<div class="paragraph">
<p>构建脚本通过配置<em>项目来</em>描述您的构建。项目是一个抽象的概念，但是通常您将Gradle项目映射到需要构建的软件组件，例如库或应用程序。您拥有的每个构建脚本都与一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a>类型的对象相关联，并在执行该构建脚本时对其进行配置<code>Project</code> 。</p>
</div>
<div class="paragraph">
<p>实际上，构建脚本中的几乎所有顶级属性和块都是<code>Project</code> API。为了演示，请看以下示例构建脚本，该脚本显示其项目名称，可通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:name">Project.name</a>属性访问该名称：</p>
</div>
<div class="exampleblock">
<div class="title">示例95。访问项目对象的属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println name
println project.name</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">println(name)
println(project.name)</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q check</code></strong></div>
<div class="content">
<pre>&gt; gradle -q check
projectApi
projectApi</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>都<code>println</code>语句打印出相同的属性。第一个使用顶级引用<code>name</code>的属性<code>Project</code>宾语。另一条语句使用<code>project</code>属性可用于任何构建脚本，该脚本返回关联的<code>Project</code>宾语。仅当您定义一个属性或方法与该方法的成员同名时<code>Project</code>对象，您是否需要使用<code>project</code>属性。</p>
</div>
<div class="sect4">
<h5 id="sec:standard_project_properties"><a class="anchor" href="#sec:standard_project_properties"></a> <a class="link" href="#sec:standard_project_properties">标准项目属性</a></h5>
<div class="paragraph">
<p>的<code>Project</code>对象提供了一些标准属性，这些属性在您的构建脚本中可用。下表列出了一些常用的。</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表2。项目属性</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>project</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">项目</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的<code>Project</code>实例</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目目录的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目的绝对路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目说明。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>projectDir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>File</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含构建脚本的目录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>buildDir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>File</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>projectDir</em>/build</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>group</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>unspecified</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>unspecified</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ant</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/AntBuilder.html">蚂蚁建筑</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>AntBuilder</code>实例</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title">重要</div>
</td>
<td class="content">
<div class="title">与其他目标脚本</div>
<div class="paragraph">
<p>此处描述的<em>构建脚本</em>针对<code>Project</code>对象。也有分别针对<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html">设置</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html">Gradle</a>对象的<a href="#sec:settings_file">设置脚本</a>和<a href="#init_scripts">初始化脚本</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:the_script_api"><a class="anchor" href="#sec:the_script_api"></a> <a class="link" href="#sec:the_script_api">脚本API</a></h4>
<div class="paragraph">
<p>当Gradle执行Groovy构建脚本时（ <code>.gradle</code> ），它将脚本编译为实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Script.html">Script</a>的类。这意味着该方法声明的所有属性和方法<code>Script</code>界面在您的脚本中可用。</p>
</div>
<div class="paragraph">
<p>当Gradle执行Kotlin构建脚本（ <code>.gradle.kts</code> ），它将脚本编译为<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/-kotlin-build-script/index.html">KotlinBuildScript</a>的子类。这意味着，所有由<code>KotlinBuildScript</code>类型在您的脚本中可用。另请分别参阅<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/-kotlin-settings-script/index.html">KotlinSettingsScript</a>和<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/-kotlin-init-script/index.html">KotlinInitScript</a>类型以获取设置脚本和初始化脚本。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:declaring_variables"><a class="anchor" href="#sec:declaring_variables"></a> <a class="link" href="#sec:declaring_variables">声明变量</a></h4>
<div class="paragraph">
<p>可以在构建脚本中声明两种变量：局部变量和额外属性。</p>
</div>
<div class="sect4">
<h5 id="sec:local_variables"><a class="anchor" href="#sec:local_variables"></a> <a class="link" href="#sec:local_variables">局部变量</a></h5>
<div class="paragraph multi-language-text lang-groovy">
<p>局部变量用<code>def</code>关键词。它们仅在声明它们的范围内可见。局部变量是基础Groovy语言的功能。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>局部变量用<code>val</code>关键词。它们仅在声明它们的范围内可见。局部变量是基础Kotlin语言的功能。</p>
</div>
<div class="exampleblock">
<div class="title">例子96。使用局部变量</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> dest = <span class="string"><span class="delimiter">&quot;</span><span class="content">dest</span><span class="delimiter">&quot;</span></span>

task copy(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="content">source</span><span class="delimiter">&quot;</span></span>
    into dest
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val dest = &quot;dest&quot;

tasks.register&lt;Copy&gt;(&quot;copy&quot;) {
    from(&quot;source&quot;)
    into(dest)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:extra_properties"><a class="anchor" href="#sec:extra_properties"></a> <a class="link" href="#sec:extra_properties">额外的属性</a></h5>
<div class="paragraph">
<p>Gradle的域模型中的所有增强对象都可以容纳额外的用户定义属性。这包括但不限于项目，任务和源集。</p>
</div>
<div class="paragraph multi-language-text lang-groovy">
<p>可以通过拥有对象的属性添加，读取和设置额外的属性<code>ext</code>属性。或者， <code>ext</code>块可用于一次添加多个属性。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>可以通过拥有对象的属性添加，读取和设置额外的属性<code>extra</code>属性。或者，可以使用以下方法通过Kotlin委托的属性来解决它们： <code>by extra</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例97。使用额外的属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}

ext {
    springVersion = <span class="string"><span class="delimiter">&quot;</span><span class="content">3.1.0.RELEASE</span><span class="delimiter">&quot;</span></span>
    emailNotification = <span class="string"><span class="delimiter">&quot;</span><span class="content">build@master.org</span><span class="delimiter">&quot;</span></span>
}

sourceSets.all { ext.purpose = <span class="predefined-constant">null</span> }

sourceSets {
    main {
        purpose = <span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>
    }
    test {
        purpose = <span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span>
    }
    plugin {
        purpose = <span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>
    }
}

task printProperties {
    doLast {
        println springVersion
        println emailNotification
        sourceSets.matching { <span class="local-variable">it</span>.purpose == <span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span> }.each { println <span class="local-variable">it</span>.name }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}

val springVersion by extra(&quot;3.1.0.RELEASE&quot;)
val emailNotification by extra { &quot;build@master.org&quot; }

sourceSets.all { extra[&quot;purpose&quot;] = null }

sourceSets {
    main {
        extra[&quot;purpose&quot;] = &quot;production&quot;
    }
    test {
        extra[&quot;purpose&quot;] = &quot;test&quot;
    }
    create(&quot;plugin&quot;) {
        extra[&quot;purpose&quot;] = &quot;production&quot;
    }
}

tasks.register(&quot;printProperties&quot;) {
    doLast {
        println(springVersion)
        println(emailNotification)
        sourceSets.matching { it.extra[&quot;purpose&quot;] == &quot;production&quot; }.forEach { println(it.name) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q printProperties</code></strong></div>
<div class="content">
<pre>&gt; gradle -q printProperties
3.1.0.RELEASE
build@master.org
main
plugin</pre>
</div>
</div>
</div>
</div>
<div class="paragraph multi-language-text lang-groovy">
<p>在此示例中， <code>ext</code>块将两个额外的属性添加到<code>project</code>宾语。此外，一个名为<code>purpose</code>通过设置添加到每个来源集<code>ext.purpose</code>至<code>null</code> （ <code>null</code>是允许的值）。添加属性后，就可以像预定义属性一样读取和设置它们。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>在此示例中，两个额外的属性被添加到<code>project</code>对象使用<code>by extra</code> 。此外，一个名为<code>purpose</code>通过设置添加到每个来源集<code>extra["purpose"]</code>至<code>null</code> （ <code>null</code>是允许的值）。添加属性后，即可读取并设置它们<code>extra</code> 。</p>
</div>
<div class="paragraph">
<p>通过要求特殊的语法来添加属性，当尝试设置（预定义或额外的）属性但该属性拼写错误或不存在时，Gradle可能会快速失败。可以从可以访问其所属对象的任何位置访问其他属性，从而使它们的范围比局部变量大。从子项目中可以看到项目的其他属性。</p>
</div>
<div class="paragraph">
<p>有关其他属性及其API的更多详细信息，请参阅API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html">ExtraPropertiesExtension</a>类。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_arbitrary_objects"><a class="anchor" href="#sec:configuring_arbitrary_objects"></a> <a class="link" href="#sec:configuring_arbitrary_objects">配置任意对象</a></h4>
<div class="paragraph">
<p>您可以通过以下易读的方式配置任意对象。</p>
</div>
<div class="exampleblock">
<div class="title">例子98。配置任意对象</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">java.text.FieldPosition</span>

task configure {
    doLast {
        <span class="keyword">def</span> pos = configure(<span class="keyword">new</span> <span class="predefined-type">FieldPosition</span>(<span class="integer">10</span>)) {
            beginIndex = <span class="integer">1</span>
            endIndex = <span class="integer">5</span>
        }
        println pos.beginIndex
        println pos.endIndex
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import java.text.FieldPosition

tasks.register(&quot;configure&quot;) {
    doLast {
        val pos = FieldPosition(10).apply {
            beginIndex = 1
            endIndex = 5
        }
        println(pos.beginIndex)
        println(pos.endIndex)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q configure</code></strong></div>
<div class="content">
<pre>&gt; gradle -q configure
1
5</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_arbitrary_objects_using_an_external_script"><a class="anchor" href="#sec:configuring_arbitrary_objects_using_an_external_script"></a> <a class="link" href="#sec:configuring_arbitrary_objects_using_an_external_script">使用外部脚本配置任意对象</a></h4>
<div class="paragraph">
<p>您还可以使用外部脚本配置任意对象。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="title">仅由Groovy脚本支持</div>
<div class="paragraph">
<p>Kotlin DSL尚不支持使用外部脚本配置任意对象。有关更多信息，请参见<a href="https://github.com/gradle/kotlin-dsl/issues/659">gradle / kotlin-dsl＃659</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例99。使用脚本配置任意对象</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task configure {
    doLast {
        <span class="keyword">def</span> pos = <span class="keyword">new</span> java.text.FieldPosition(<span class="integer">10</span>)
        <span class="comment">// Apply the script</span>
        apply <span class="key">from</span>: <span class="string"><span class="delimiter">'</span><span class="content">other.gradle</span><span class="delimiter">'</span></span>, <span class="key">to</span>: pos
        println pos.beginIndex
        println pos.endIndex
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">其他等级</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Set properties.</span>
beginIndex = <span class="integer">1</span>
endIndex = <span class="integer">5</span></code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q configure</code></div>
<div class="content">
<pre>&gt; gradle -q configure
1
5</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="groovy-dsl-basics"><a class="anchor" href="#groovy-dsl-basics"></a> <a class="link" href="#groovy-dsl-basics">一些Groovy基础知识</a></h4>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">在寻找Kotlin的一些基础知识时， <a href="https://kotlinlang.org/docs/reference/">Kotlin参考文档</a>和<a href="https://kotlinlang.org/docs/tutorials/koans.html">Kotlin Koans</a>应该对您有用。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/latest/html/documentation/index.html">Groovy语言</a>提供了许多用于创建DSL的功能，而Gradle构建语言则利用了这些功能。了解构建语言的工作原理将在您编写构建脚本时，特别是在开始编写自定义插件和任务时，对您有所帮助。</p>
</div>
<div class="sect4">
<h5 id="sec:groovy_jdk"><a class="anchor" href="#sec:groovy_jdk"></a> <a class="link" href="#sec:groovy_jdk">Groovy JDK</a></h5>
<div class="paragraph">
<p>Groovy向标准Java类添加了许多有用的方法。例如， <code>Iterable</code>得到一个<code>each</code>方法，该方法在<code>Iterable</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例100Groovy JDK方法</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Iterable gets an each() method</span>
configurations.runtimeClasspath.each { <span class="predefined-type">File</span> f -&gt; println f }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息， <a href="https://groovy-lang.org/gdk.html" class="bare">请</a>访问<a href="https://groovy-lang.org/gdk.html" class="bare">https://groovy-lang.org/gdk.html</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:property_accessors"><a class="anchor" href="#sec:property_accessors"></a> <a class="link" href="#sec:property_accessors">财产访问者</a></h5>
<div class="paragraph">
<p>Groovy自动将属性引用转换为对适当的getter或setter方法的调用。</p>
</div>
<div class="exampleblock">
<div class="title">示例101财产访问者</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Using a getter method</span>
println project.buildDir
println getProject().getBuildDir()

<span class="comment">// Using a setter method</span>
project.buildDir = <span class="string"><span class="delimiter">'</span><span class="content">target</span><span class="delimiter">'</span></span>
getProject().setBuildDir(<span class="string"><span class="delimiter">'</span><span class="content">target</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:optional_parentheses_on_method_calls"><a class="anchor" href="#sec:optional_parentheses_on_method_calls"></a> <a class="link" href="#sec:optional_parentheses_on_method_calls">方法调用上的可选括号</a></h5>
<div class="paragraph">
<p>括号对于方法调用是可选的。</p>
</div>
<div class="exampleblock">
<div class="title">例子102。不带括号的方法调用</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test.systemProperty <span class="string"><span class="delimiter">'</span><span class="content">some.prop</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>
test.systemProperty(<span class="string"><span class="delimiter">'</span><span class="content">some.prop</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:list_and_map_literals"><a class="anchor" href="#sec:list_and_map_literals"></a> <a class="link" href="#sec:list_and_map_literals">列出和映射文字</a></h5>
<div class="paragraph">
<p>Groovy提供了一些定义的捷径<code>List</code>和<code>Map</code>实例。两种文字都很简单，但是map文字有一些有趣的变化。</p>
</div>
<div class="paragraph">
<p>例如，“ <code>apply</code> ”方法（通常在其中应用插件的地方）实际上带有一个map参数。但是，当您有类似“ <code>apply plugin:'java'</code> ”，您实际上并没有使用地图文字，而是实际上使用了“命名参数”，它们的语法与地图文字几乎完全相同（不带括弧）。调用该方法时，已命名的参数列表将转换为映射，但它并非以映射开头。</p>
</div>
<div class="exampleblock">
<div class="title">示例103列出和映射文字</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// List literal</span>
test.includes = [<span class="string"><span class="delimiter">'</span><span class="content">org/gradle/api/**</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">org/gradle/internal/**</span><span class="delimiter">'</span></span>]

<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;()
list.add(<span class="string"><span class="delimiter">'</span><span class="content">org/gradle/api/**</span><span class="delimiter">'</span></span>)
list.add(<span class="string"><span class="delimiter">'</span><span class="content">org/gradle/internal/**</span><span class="delimiter">'</span></span>)
test.includes = list

<span class="comment">// Map literal.</span>
<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; map = [<span class="key">key1</span>:<span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>, <span class="key">key2</span>: <span class="string"><span class="delimiter">'</span><span class="content">value2</span><span class="delimiter">'</span></span>]

<span class="comment">// Groovy will coerce named arguments</span>
<span class="comment">// into a single map argument</span>
apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:closures_as_the_last_parameter_in_a_method"><a class="anchor" href="#sec:closures_as_the_last_parameter_in_a_method"></a> <a class="link" href="#sec:closures_as_the_last_parameter_in_a_method">闭包作为方法中的最后一个参数</a></h5>
<div class="paragraph">
<p>Gradle DSL在许多地方使用闭包。您可以<a href="https://docs.groovy-lang.org/latest/html/documentation/index.html#_closures">在此处</a>找到有关闭包的更多信息。当方法的最后一个参数是闭包时，可以将闭包放在方法调用之后：</p>
</div>
<div class="exampleblock">
<div class="title">例子104。闭包作为方法参数</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">in a closure</span><span class="delimiter">&quot;</span></span>
}
repositories() { println <span class="string"><span class="delimiter">&quot;</span><span class="content">in a closure</span><span class="delimiter">&quot;</span></span> }
repositories({ println <span class="string"><span class="delimiter">&quot;</span><span class="content">in a closure</span><span class="delimiter">&quot;</span></span> })</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:closure_delegate"><a class="anchor" href="#sec:closure_delegate"></a> <a class="link" href="#sec:closure_delegate">封闭代表</a></h5>
<div class="paragraph">
<p>每个封口都有一个<code>delegate</code>对象，Groovy用来查找不是局部变量或闭包参数的变量和方法引用。Gradle将此用于<em>配置闭包</em> ，其中<code>delegate</code> object设置为要配置的对象。</p>
</div>
<div class="exampleblock">
<div class="title">例子105。闭幕代表</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="keyword">assert</span> delegate == project.dependencies
    testImplementation(<span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>)
    delegate.testImplementation(<span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="script-default-imports"><a class="anchor" href="#script-default-imports"></a> <a class="link" href="#script-default-imports">默认导入</a></h4>
<div class="paragraph">
<p>为了使构建脚本更加简洁，Gradle会自动向Gradle脚本添加一组导入语句。这意味着代替使用<code>throw new org.gradle.api.tasks.StopExecutionException()</code>你可以输入<code>throw new StopExecutionException()</code>代替。</p>
</div>
<div class="paragraph">
<p>下面列出了添加到每个脚本的导入：</p>
</div>
<div class="listingblock">
<div class="title">Gradle默认导入</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.component.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.dsl.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.ivy.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.maven.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.query.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.repositories.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.result.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.transform.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.artifacts.type.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.attributes.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.attributes.java.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.capabilities.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.component.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.credentials.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.distribution.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.distribution.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.execution.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.file.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.initialization.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.initialization.definition.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.initialization.dsl.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.invocation.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.java.archives.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.logging.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.logging.configuration.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.model.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.plugins.antlr.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.plugins.quality.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.plugins.scala.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.provider.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.ivy.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.ivy.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.ivy.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.maven.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.maven.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.maven.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.publish.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.reflect.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.reporting.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.reporting.components.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.reporting.dependencies.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.reporting.dependents.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.reporting.model.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.reporting.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.resources.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.specs.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.ant.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.application.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.bundling.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.compile.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.diagnostics.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.incremental.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.javadoc.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.options.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.scala.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.testing.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.testing.junit.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.testing.junitplatform.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.testing.testng.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.util.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.wrapper.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.authentication.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.authentication.aws.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.authentication.http.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.buildinit.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.buildinit.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.caching.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.caching.configuration.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.caching.http.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.caching.local.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.concurrent.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.external.javadoc.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.ide.visualstudio.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.ide.visualstudio.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.ide.visualstudio.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.ide.xcode.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.ide.xcode.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.ide.xcode.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.ivy.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.application.scripts.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.application.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.platform.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.tasks.api.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.test.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.jvm.toolchain.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.assembler.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.assembler.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.assembler.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.base.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.base.artifact.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.base.compile.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.base.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.base.sources.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.c.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.c.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.c.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.coffeescript.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.cpp.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.cpp.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.cpp.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.java.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.java.artifact.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.java.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.java.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.javascript.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.jvm.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.jvm.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.jvm.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.nativeplatform.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.nativeplatform.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.objectivec.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.objectivec.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.objectivec.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.objectivecpp.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.objectivecpp.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.objectivecpp.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.rc.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.rc.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.rc.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.routes.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.scala.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.scala.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.scala.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.scala.toolchain.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.swift.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.swift.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.swift.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.language.twirl.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.maven.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.model.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.platform.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.cpp.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.cpp.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.cunit.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.cunit.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.cunit.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.googletest.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.googletest.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.xctest.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.xctest.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.test.xctest.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.toolchain.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.nativeplatform.toolchain.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.normalization.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.platform.base.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.platform.base.binary.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.platform.base.component.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.platform.base.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.play.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.play.distribution.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.play.platform.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.play.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.play.plugins.ide.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.play.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.play.toolchain.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugin.devel.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugin.devel.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugin.devel.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugin.management.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugin.use.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.ear.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.ear.descriptor.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.ide.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.ide.api.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.ide.eclipse.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.ide.idea.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.base.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.coffeescript.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.envjs.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.envjs.browser.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.envjs.http.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.envjs.http.simple.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.jshint.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.javascript.rhino.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.signing.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.signing.signatory.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.signing.signatory.pgp.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.signing.type.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.plugins.signing.type.pgp.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.process.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.swiftpm.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.swiftpm.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.swiftpm.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.testing.base.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.testing.base.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.testing.jacoco.plugins.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.testing.jacoco.tasks.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.testing.jacoco.tasks.rules.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.testkit.runner.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.vcs.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.vcs.git.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.work.*</span>
<span class="keyword">import</span> <span class="include">org.gradle.workers.*</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="working_with_files"><a class="anchor" href="#working_with_files"></a> <a class="link" href="#working_with_files">处理文件</a></h3>
<div class="paragraph">
<p>几乎每个Gradle构建都以某种方式与文件交互：考虑源文件，文件依赖项，报告等。这就是为什么Gradle带有一个全面的API，该API使执行所需的文件操作变得简单。</p>
</div>
<div class="paragraph">
<p>API包含两个部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>指定要处理的文件和目录</p>
</li>
<li>
<p>指定如何处理它们</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>“ <a href="#sec:locating_files">深度文件路径”</a>部分详细介绍了第一个，而后续部分（例如“ <a href="#sec:copying_files">深度文件复制”</a> ）覆盖了第二个。首先，我们将向您展示用户遇到的最常见情况的示例。</p>
</div>
<div class="sect3">
<h4 id="sec:copying_single_file_example"><a class="anchor" href="#sec:copying_single_file_example"></a> <a class="link" href="#sec:copying_single_file_example">复制单个文件</a></h4>
<div class="paragraph">
<p>您可以通过创建Gradle内置的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">Copy</a>任务实例并将其配置为文件的位置以及您想要放置的位置来<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a>文件。此示例模仿将生成的报告复制到将打包到存档中的目录中，例如ZIP或TAR：</p>
</div>
<div class="exampleblock">
<div class="title">例子106。如何复制一个文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyReport(<span class="key">type</span>: Copy) {
    from file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports/my-report.pdf</span><span class="delimiter">&quot;</span></span>)
    into file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyReport&quot;) {
    from(file(&quot;$buildDir/reports/my-report.pdf&quot;))
    into(file(&quot;$buildDir/toArchive&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。Object）</a>方法用于创建相对于当前项目的文件或目录路径，并且是使构建脚本不管项目路径如何都可以工作的常用方法。文件和目录路径然后用于使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:from(java.lang.Object[])">Copy.from（java.lang。对象...）</a>以及使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:into(java.lang.Object)">Copy.into（java.lang。对象）</a> 。</p>
</div>
<div class="paragraph">
<p>您甚至可以直接使用路径而无需<code>file()</code>方法，如<a href="#sec:copying_files">在深入复制文件</a>一节中所述：</p>
</div>
<div class="exampleblock">
<div class="title">例子107。使用隐式字符串路径</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyReport2(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports/my-report.pdf</span><span class="delimiter">&quot;</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyReport2&quot;) {
    from(&quot;$buildDir/reports/my-report.pdf&quot;)
    into(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尽管硬编码路径仅举几个简单的例子，但它们也使构建变脆。最好使用可靠的单一事实来源，例如任务或共享项目属性。在下面的修改示例中，我们使用在其他位置定义的报表任务，该报表任务的位置存储在报表任务中。 <code>outputFile</code>属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例108。优先于硬编码路径的任务/项目属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyReport3(<span class="key">type</span>: Copy) {
    from myReportTask.outputFile
    into archiveReportsTask.dirToArchive
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyReport3&quot;) {
    val outputFile: File by myReportTask.get().extra
    val dirToArchive: File by archiveReportsTask.get().extra
    from(outputFile)
    into(dirToArchive)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还假设报告将由<code>archiveReportsTask</code> ，它为我们提供了将要归档的目录，因此也为我们提供了报告副本的存放位置。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:copying_multiple_files_example"><a class="anchor" href="#sec:copying_multiple_files_example"></a> <a class="link" href="#sec:copying_multiple_files_example">复制多个文件</a></h4>
<div class="paragraph">
<p>您可以通过提供多个参数来轻松地将前面的示例扩展到多个文件<code>from()</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例109在from（）中使用多个参数</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyReportsForArchiving(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports/my-report.pdf</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">src/docs/manual.pdf</span><span class="delimiter">&quot;</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyReportsForArchiving&quot;) {
    from(&quot;$buildDir/reports/my-report.pdf&quot;, &quot;src/docs/manual.pdf&quot;)
    into(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在将两个文件复制到存档目录中。您也可以使用多个<code>from()</code>语句执行相同的操作，如“ <a href="#sec:copying_files">文件深度复制</a> ”部分的第一个示例所示。</p>
</div>
<div class="paragraph">
<p>现在考虑另一个示例：如果要复制目录中的所有PDF而不必指定每个PDF，该怎么办？为此，请将包含和/或排除模式附加到副本规范中。在这里，我们使用字符串模式仅包含PDF：</p>
</div>
<div class="exampleblock">
<div class="title">例子110。使用平面过滤器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyPdfReportsForArchiving(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports</span><span class="delimiter">&quot;</span></span>
    include <span class="string"><span class="delimiter">&quot;</span><span class="content">*.pdf</span><span class="delimiter">&quot;</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyPdfReportsForArchiving&quot;) {
    from(&quot;$buildDir/reports&quot;)
    include(&quot;*.pdf&quot;)
    into(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如下图所示，需要注意的一件事是，只有直接存在于<code>reports</code>目录被复制：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/copy-with-flat-filter-example.png" alt="使用平面过滤器复制示例">
</div>
<div class="title">图8。平面滤镜对复印的影响</div>
</div>
<div class="paragraph">
<p>您可以使用Ant样式的glob模式将文件包含在子目录中（ <code>**/*</code> ），如本更新示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子111。使用深层过滤器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyAllPdfReportsForArchiving(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports</span><span class="delimiter">&quot;</span></span>
    include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.pdf</span><span class="delimiter">&quot;</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyAllPdfReportsForArchiving&quot;) {
    from(&quot;$buildDir/reports&quot;)
    include(&quot;**/*.pdf&quot;)
    into(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此任务具有以下效果：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/copy-with-deep-filter-example.png" alt="使用深层过滤器复制示例">
</div>
<div class="title">图9。深层过滤器对复制的影响</div>
</div>
<div class="paragraph">
<p>要记住的一件事是，像这样的深层过滤器具有复制下面的目录结构的副作用。 <code>reports</code>以及文件。如果只想复制没有目录结构的文件，则需要使用显式<code>fileTree(<em>dir</em>) { <em>includes</em> }.files</code>表达。在“ <a href="#sec:file_trees">文件树”</a>部分中，我们将更多地讨论文件树和文件集合之间的区别。</p>
</div>
<div class="paragraph">
<p>这只是在Gradle构建中处理文件操作时可能遇到的各种行为之一。幸运的是，Gradle为几乎所有这些用例提供了优雅的解决方案。请阅读本章后面<em>的深入</em>部分，以详细了解Gradle中文件操作的工作方式以及配置它们的选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:copying_directories_example"><a class="anchor" href="#sec:copying_directories_example"></a> <a class="link" href="#sec:copying_directories_example">复制目录层次结构</a></h4>
<div class="paragraph">
<p>您可能不仅需要复制文件，还需要复制它们所在的目录结构。当您将目录指定为目录时，这是默认行为。 <code>from()</code>参数，如以下示例所示，该示例复制了<code>reports</code>目录，包括其所有子目录，到目标：</p>
</div>
<div class="exampleblock">
<div class="title">例子112。复制整个目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyReportsDirForArchiving(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports</span><span class="delimiter">&quot;</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyReportsDirForArchiving&quot;) {
    from(&quot;$buildDir/reports&quot;)
    into(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>用户苦苦挣扎的关键方面是控制有多少目录结构到达目的地。在上面的示例中，您得到了<code>toArchive/reports</code>目录或执行所有操作<code>reports</code>直接进入<code>toArchive</code> ？答案是后者。如果目录是<code>from()</code>路径，则它<em>不会</em>出现在目的地中。</p>
</div>
<div class="paragraph">
<p>那么如何确保<code>reports</code>本身会被复制，但不会复制到该目录中的任何其他目录<code>$buildDir</code> ？答案是将其添加为包含模式：</p>
</div>
<div class="exampleblock">
<div class="title">示例113。复制整个目录，包括它本身</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyReportsDirForArchiving2(<span class="key">type</span>: Copy) {
    from(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="delimiter">&quot;</span></span>) {
        include <span class="string"><span class="delimiter">&quot;</span><span class="content">reports/**</span><span class="delimiter">&quot;</span></span>
    }
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyReportsDirForArchiving2&quot;) {
    from(&quot;$buildDir&quot;) {
        include(&quot;reports/**&quot;)
    }
    into(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您将获得与以前相同的行为，除了目标中有一个额外的目录级别，即<code>toArchive/reports</code> 。</p>
</div>
<div class="paragraph">
<p>要注意的一件事是<code>include()</code>指令仅适用于<code>from()</code> ，而上一节中的指令适用于整个任务。复制规范中的这些不同级别的粒度使您可以轻松处理遇到的大多数需求。您可以在有关<a href="#sub:using_child_copy_specifications">子规范</a>的部分中了解有关此内容的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:creating_archives_example"><a class="anchor" href="#sec:creating_archives_example"></a> <a class="link" href="#sec:creating_archives_example">创建档案（zip，tar等）</a></h4>
<div class="paragraph">
<p>从Gradle的角度来看，将文件打包到档案中实际上是一个副本，其中目标是档案文件而不是文件系统上的目录。这意味着创建存档看起来很像具有相同功能的复制！</p>
</div>
<div class="paragraph">
<p>最简单的情况是归档目录的全部内容，此示例通过创建目录的ZIP来演示。 <code>toArchive</code>目录：</p>
</div>
<div class="exampleblock">
<div class="title">示例114。将目录归档为ZIP</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task packageDistribution(<span class="key">type</span>: Zip) {
    archiveFileName = <span class="string"><span class="delimiter">&quot;</span><span class="content">my-distribution.zip</span><span class="delimiter">&quot;</span></span>
    destinationDirectory = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/dist</span><span class="delimiter">&quot;</span></span>)

    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Zip&gt;(&quot;packageDistribution&quot;) {
    archiveFileName.set(&quot;my-distribution.zip&quot;)
    destinationDirectory.set(file(&quot;$buildDir/dist&quot;))

    from(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，我们如何指定存档的目的地和名称，而不是<code>into()</code> ：两者都是必需的。您常常看不到它们的显式设置，因为大多数项目都使用<a href="#base_plugin">Base Plugin</a> 。它为这些属性提供了一些常规值。下一个示例对此进行了演示，您可以在<a href="#sec:archive_naming">归档命名</a>部分中了解有关约定的更多信息。</p>
</div>
<div class="paragraph">
<p>每种存档类型都有其自己的任务类型，最常见的是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">Zip</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Tar.html">Tar</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">Jar</a> 。它们都共享以下的大多数配置选项<code>Copy</code> ，包括过滤和重命名。</p>
</div>
<div class="paragraph">
<p>最常见的情况之一是将文件复制到存档的指定子目录中。例如，假设您要将所有PDF打包到<code>docs</code>档案根目录中的目录。这个<code>docs</code>目录在源位置中不存在，因此您必须将其创建为存档的一部分。您可以通过添加一个<code>into()</code>仅PDF的声明：</p>
</div>
<div class="exampleblock">
<div class="title">示例115。使用基本插件的存档名称约定</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">base</span><span class="delimiter">'</span></span>
}

version = <span class="string"><span class="delimiter">&quot;</span><span class="content">1.0.0</span><span class="delimiter">&quot;</span></span>

task packageDistribution(<span class="key">type</span>: Zip) {
    from(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>) {
        exclude <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.pdf</span><span class="delimiter">&quot;</span></span>
    }

    from(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>) {
        include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.pdf</span><span class="delimiter">&quot;</span></span>
        into <span class="string"><span class="delimiter">&quot;</span><span class="content">docs</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    base
}

version = &quot;1.0.0&quot;

tasks.register&lt;Zip&gt;(&quot;packageDistribution&quot;) {
    from(&quot;$buildDir/toArchive&quot;) {
        exclude(&quot;**/*.pdf&quot;)
    }

    from(&quot;$buildDir/toArchive&quot;) {
        include(&quot;**/*.pdf&quot;)
        into(&quot;docs&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，您可以拥有多个<code>from()</code>复制规范中的声明，每个声明都有自己的配置。有关此功能的更多信息，请参见<a href="#sub:using_child_copy_specifications">使用子副本规范</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:unpacking_archives_example"><a class="anchor" href="#sec:unpacking_archives_example"></a> <a class="link" href="#sec:unpacking_archives_example">解压缩档案</a></h4>
<div class="paragraph">
<p>档案实际上是独立的文件系统，因此解压缩它们是将文件从该文件系统复制到本地文件系统，甚至复制到另一个档案的情况。\ Gradle通过提供一些包装器功能来实现此目的，这些包装器功能使档案可以作为文件（ <a href="#sec:file_trees">文件树</a> ）的分层集合使用。</p>
</div>
<div class="paragraph">
<p>感兴趣的两个功能是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)">Project.zipTree（java.lang。Object）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:tarTree(java.lang.Object)">Project.tarTree（java.lang。对象）</a> ，该文件从相应的存档文件生成<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">FileTree</a> 。该文件树随后可用于<code>from()</code>规格，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例116。解压缩ZIP文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task unpackFiles(<span class="key">type</span>: Copy) {
    from zipTree(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/resources/thirdPartyResources.zip</span><span class="delimiter">&quot;</span></span>)
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/resources</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;unpackFiles&quot;) {
    from(zipTree(&quot;src/resources/thirdPartyResources.zip&quot;))
    into(&quot;$buildDir/resources&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与普通副本一样，您可以控制通过<a href="#sec:filtering_files">过滤器</a>解压缩哪些文件，甚至可以在解压缩文件时<a href="#sec:renaming_files">重命名文件</a> 。</p>
</div>
<div class="paragraph">
<p>可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.AbstractCopyTask#eachFile(org.gradle.api.Action)">eachFile（）</a>方法处理更高级的处理。例如，您可能需要将存档的不同子树提取到目标目录内的不同路径中。以下示例使用该方法提取存档文件中的文件<code>libs</code>目录到根目标目录，而不是<code>libs</code>子目录：</p>
</div>
<div class="exampleblock">
<div class="title">示例117解压缩ZIP文件的子集</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task unpackLibsDirectory(<span class="key">type</span>: Copy) {
    from(zipTree(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/resources/thirdPartyResources.zip</span><span class="delimiter">&quot;</span></span>)) {
        include <span class="string"><span class="delimiter">&quot;</span><span class="content">libs/**</span><span class="delimiter">&quot;</span></span>  // <b class="conum">(1)</b>
        eachFile { fcd -&gt;
            fcd.relativePath = <span class="keyword">new</span> RelativePath(<span class="predefined-constant">true</span>, fcd.relativePath.segments.drop(<span class="integer">1</span>))  // <b class="conum">(2)</b>
        }
        includeEmptyDirs = <span class="predefined-constant">false</span>  // <b class="conum">(3)</b>
    }
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/resources</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;unpackLibsDirectory&quot;) {
    from(zipTree(&quot;src/resources/thirdPartyResources.zip&quot;)) {
        include(&quot;libs/**&quot;)  // <b class="conum">(1)</b>
        eachFile {
            relativePath = RelativePath(true, *relativePath.segments.drop(1).toTypedArray())  // <b class="conum">(2)</b>
        }
        includeEmptyDirs = false  // <b class="conum">(3)</b>
    }
    into(&quot;$buildDir/resources&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>仅提取驻留在文件中的文件子集<code>libs</code>目录</p>
</li>
<li>
<p>通过拖放文件，将提取文件的路径重新映射到目标目录。 <code>libs</code>文件路径中的段</p>
</li>
<li>
<p>忽略由于重新映射而导致的空目录，请参阅下面的注意事项</p>
</li>
</ol>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>您不能使用此技术更改空目录的目标路径。您可以在<a href="https://github.com/gradle/gradle/issues/2940">本期中</a>了解更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您是Java开发人员，并且想知道为什么没有<code>jarTree()</code>方法，那是因为<code>zipTree()</code>适用于JAR，WAR和EAR。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:creating_uber_jar_example"><a class="anchor" href="#sec:creating_uber_jar_example"></a> <a class="link" href="#sec:creating_uber_jar_example">创建“超级”或“胖” JAR</a></h4>
<div class="paragraph">
<p>在Java空间中，通常将应用程序及其依赖项打包为一个分发归档文件中的独立JAR。仍然会发生这种情况，但是现在有另一种常见的方法：将依赖项的类和资源直接放入应用程序JAR中，创建所谓的uber或fat JAR。</p>
</div>
<div class="paragraph">
<p>Gradle使此方法易于实现。考虑目标：将其他JAR文件的内容复制到应用程序JAR中。您所需<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)">要做的就是</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)">Project.zipTree（java.lang。Object）</a>方法和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">Jar</a>任务，如<code>uberJar</code>以下示例中的任务：</p>
</div>
<div class="exampleblock">
<div class="title">例子118。创建Java uber或fat JAR</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}

version = <span class="string"><span class="delimiter">'</span><span class="content">1.0.0</span><span class="delimiter">'</span></span>

repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">commons-io:commons-io:2.6</span><span class="delimiter">'</span></span>
}

task uberJar(<span class="key">type</span>: Jar) {
    archiveClassifier = <span class="string"><span class="delimiter">'</span><span class="content">uber</span><span class="delimiter">'</span></span>

    from sourceSets.main.output

    dependsOn configurations.runtimeClasspath
    from {
        configurations.runtimeClasspath.findAll { <span class="local-variable">it</span>.name.endsWith(<span class="string"><span class="delimiter">'</span><span class="content">jar</span><span class="delimiter">'</span></span>) }.collect { zipTree(<span class="local-variable">it</span>) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}

version = &quot;1.0.0&quot;

repositories {
    mavenCentral()
}

dependencies {
    implementation(&quot;commons-io:commons-io:2.6&quot;)
}

tasks.register&lt;Jar&gt;(&quot;uberJar&quot;) {
    archiveClassifier.set(&quot;uber&quot;)

    from(sourceSets.main.get().output)

    dependsOn(configurations.runtimeClasspath)
    from({
        configurations.runtimeClasspath.get().filter { it.name.endsWith(&quot;jar&quot;) }.map { zipTree(it) }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，我们将采用项目的运行时依赖关系- <code>configurations.runtimeClasspath.files</code> —并使用来包装每个JAR文件<code>zipTree()</code>方法。结果是ZIP文件树的集合，这些文件树的内容与应用程序类一起复制到uber JAR中。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:creating_directories_example"><a class="anchor" href="#sec:creating_directories_example"></a> <a class="link" href="#sec:creating_directories_example">创建目录</a></h4>
<div class="paragraph">
<p>许多任务需要创建目录来存储它们生成的文件，这就是为什么Gradle在明确定义文件和目录输出时会自动管理任务的这一方面的原因。您可以在用户手册的<a href="#sec:up_to_date_checks">增量构建</a>部分中了解此功能。所有Gradle核心任务都确保必要时使用此机制创建所需的任何输出目录。</p>
</div>
<div class="paragraph">
<p>如果需要手动创建目录，可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:mkdir(java.lang.Object)">Project.mkdir（java.lang。对象）</a>方法从您的构建脚本或自定义任务实现中获取。这是一个简单的示例，可以创建一个<code>images</code>项目文件夹中的目录：</p>
</div>
<div class="exampleblock">
<div class="title">示例119。手动创建目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task ensureDirectory {
    doLast {
        mkdir <span class="string"><span class="delimiter">&quot;</span><span class="content">images</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;ensureDirectory&quot;) {
    doLast {
        mkdir(&quot;images&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如<a href="https://ant.apache.org/manual/Tasks/mkdir.html">Apache Ant手册</a>所述， <code>mkdir</code>任务将自动在给定路径中创建所有必需的目录，并且如果该目录已存在则不执行任何操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:moving_files_example"><a class="anchor" href="#sec:moving_files_example"></a> <a class="link" href="#sec:moving_files_example">移动文件和目录</a></h4>
<div class="paragraph">
<p>Gradle没有用于移动文件和目录的API，但是您可以使用<a href="#ant">Apache Ant集成</a>轻松地做到这一点，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子120。使用Ant任务移动目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task moveReports {
    doLast {
        ant.move <span class="key">file</span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>buildDir<span class="inline-delimiter">}</span></span><span class="content">/reports</span><span class="delimiter">&quot;</span></span>,
                 <span class="key">todir</span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>buildDir<span class="inline-delimiter">}</span></span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;moveReports&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;move&quot;(&quot;file&quot; to &quot;${buildDir}/reports&quot;, &quot;todir&quot; to &quot;${buildDir}/toArchive&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这不是常见的要求，在丢失信息并可能容易破坏构建时应谨慎使用。通常，最好是复制目录和文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:renaming_files_example"><a class="anchor" href="#sec:renaming_files_example"></a> <a class="link" href="#sec:renaming_files_example">重命名副本中的文件</a></h4>
<div class="paragraph">
<p>构建使用和生成的文件有时没有合适的名称，在这种情况下，您需要在复制文件时重命名它们。Gradle允许您使用<code>rename()</code>组态。</p>
</div>
<div class="paragraph">
<p>下面的示例从任何包含它的文件的名称中删除“ -staging-”标记：</p>
</div>
<div class="exampleblock">
<div class="title">示例121。在复制文件时重命名文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyFromStaging(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="content">src/main/webapp</span><span class="delimiter">&quot;</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/explodedWar</span><span class="delimiter">&quot;</span></span>

    rename <span class="string"><span class="delimiter">'</span><span class="content">(.+)-staging(.+)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">$1$2</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyFromStaging&quot;) {
    from(&quot;src/main/webapp&quot;)
    into(&quot;$buildDir/explodedWar&quot;)

    rename(&quot;(.+)-staging(.+)&quot;, &quot;$1$2&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以为此使用正则表达式，如上面的示例所示，也可以使用使用更复杂的逻辑来确定目标文件名的闭包。例如，以下任务将截断文件名：</p>
</div>
<div class="exampleblock">
<div class="title">例子122。复制文件时截断文件名</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyWithTruncate(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports</span><span class="delimiter">&quot;</span></span>
    rename { <span class="predefined-type">String</span> filename -&gt;
        <span class="keyword">if</span> (filename.size() &gt; <span class="integer">10</span>) {
            <span class="keyword">return</span> filename[<span class="integer">0</span>..<span class="integer">7</span>] + <span class="string"><span class="delimiter">&quot;</span><span class="content">~</span><span class="delimiter">&quot;</span></span> + filename.size()
        }
        <span class="keyword">else</span> <span class="keyword">return</span> filename
    }
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyWithTruncate&quot;) {
    from(&quot;$buildDir/reports&quot;)
    rename { filename: String -&gt;
        if (filename.length &gt; 10) {
            filename.slice(0..7) + &quot;~&quot; + filename.length
        }
        else filename
    }
    into(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与过滤一样，您也可以将重命名配置为文件子级规范的一部分，从而对文件的子集进行重命名<code>from()</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:deleting_files_example"><a class="anchor" href="#sec:deleting_files_example"></a> <a class="link" href="#sec:deleting_files_example">删除文件和目录</a></h4>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">Delete</a>任务或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:delete(org.gradle.api.Action)">Project.delete（org.gradle.api。）轻松删除文件和目录</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:delete(org.gradle.api.Action)">。动作）</a>方法。在这两种情况下，您都可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（java.lang。对象...）</a>方法。</p>
</div>
<div class="paragraph">
<p>例如，以下任务将删除构建输出目录的全部内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例123删除目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task myClean(<span class="key">type</span>: Delete) {
    delete buildDir
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Delete&gt;(&quot;myClean&quot;) {
    delete(buildDir)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要进一步控制删除哪些文件，则不能以与复制文件相同的方式使用包含和排除。相反，您必须使用内置的过滤机制<code>FileCollection</code>和<code>FileTree</code> 。以下示例仅用于清除源目录中的临时文件：</p>
</div>
<div class="exampleblock">
<div class="title">例子124。删除符合特定模式的文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task cleanTempFiles(<span class="key">type</span>: Delete) {
    delete fileTree(<span class="string"><span class="delimiter">&quot;</span><span class="content">src</span><span class="delimiter">&quot;</span></span>).matching {
        include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.tmp</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Delete&gt;(&quot;cleanTempFiles&quot;) {
    delete(fileTree(&quot;src&quot;).matching {
        include(&quot;**/*.tmp&quot;)
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在下一部分中，您将了解有关文件集合和文件树的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:locating_files"><a class="anchor" href="#sec:locating_files"></a> <a class="link" href="#sec:locating_files">深度文件路径</a></h4>
<div class="paragraph">
<p>为了对文件执行某些操作，您需要知道它在哪里，这就是文件路径提供的信息。Gradle建立在标准Java之上<code><a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html">File</a></code>类，表示单个文件的位置，并提供用于处理路径集合的新API。本节向您展示如何使用Gradle API指定用于任务和文件操作的文件路径。</p>
</div>
<div class="paragraph">
<p>但首先，重要的是有关在构建中使用硬编码的文件路径的注意事项。</p>
</div>
<div class="sect4">
<h5 id="sec:hard_coded_file_paths"><a class="anchor" href="#sec:hard_coded_file_paths"></a> <a class="link" href="#sec:hard_coded_file_paths">在硬编码的文件路径上</a></h5>
<div class="paragraph">
<p>本章中的许多示例都将硬编码路径用作字符串文字。这使它们易于理解，但是对于实际构建而言，这不是一个好习惯。问题在于路径经常更改，并且您需要更改的位置越多，您越有可能错过其中一个并破坏构建。</p>
</div>
<div class="paragraph">
<p>在可能的情况下，应使用任务，任务属性和<a href="#sec:extra_properties">项目属性</a> （按优先顺序）来配置文件路径。例如，如果要创建一个打包Java应用程序的已编译类的任务，则应针对以下目标：</p>
</div>
<div class="exampleblock">
<div class="title">示例125如何减少构建中的硬编码路径数</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext {
    archivesDirPath = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/archives</span><span class="delimiter">&quot;</span></span>
}

task packageClasses(<span class="key">type</span>: Zip) {
    archiveAppendix = <span class="string"><span class="delimiter">&quot;</span><span class="content">classes</span><span class="delimiter">&quot;</span></span>
    destinationDirectory = file(archivesDirPath)

    from compileJava
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val archivesDirPath by extra { &quot;$buildDir/archives&quot; }

tasks.register&lt;Zip&gt;(&quot;packageClasses&quot;) {
    archiveAppendix.set(&quot;classes&quot;)
    destinationDirectory.set(file(archivesDirPath))

    from(tasks.compileJava)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>看看我们如何使用<code>compileJava</code>任务作为要打包的文件的源，我们创建了一个项目属性<code>archivesDirPath</code>来存储我们存放档案的位置，依据是我们很可能会在构建中的其他地方使用它。</p>
</div>
<div class="paragraph">
<p>直接将任务用作这样的参数依赖于它具有已<a href="#sec:task_inputs_outputs">定义的output</a> ，因此并非总是可能的。此外，可以通过依赖Java插件的约定进一步改进此示例<code>destinationDirectory</code>而不是覆盖它，但是它确实演示了项目属性的使用。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:single_file_paths"><a class="anchor" href="#sec:single_file_paths"></a> <a class="link" href="#sec:single_file_paths">单个文件和目录</a></h5>
<div class="paragraph">
<p>Gradle提供了<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。对象）</a>方法，用于指定单个文件或目录的位置。相对路径相对于项目目录进行解析，而绝对路径保持不变。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>永远不要使用<code>new File(relative path)</code>因为这会创建相对于当前工作目录（CWD）的路径。Gradle无法保证CWD的位置，这意味着依赖它的构建可能随时会损坏。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下是一些使用<code>file()</code>具有不同类型参数的方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例126定位文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Using a relative path</span>
<span class="predefined-type">File</span> configFile = file(<span class="string"><span class="delimiter">'</span><span class="content">src/config.xml</span><span class="delimiter">'</span></span>)

<span class="comment">// Using an absolute path</span>
configFile = file(configFile.absolutePath)

<span class="comment">// Using a File object with a relative path</span>
configFile = file(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">'</span><span class="content">src/config.xml</span><span class="delimiter">'</span></span>))

<span class="comment">// Using a java.nio.file.Path object with a relative path</span>
configFile = file(Paths.get(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">config.xml</span><span class="delimiter">'</span></span>))

<span class="comment">// Using an absolute java.nio.file.Path object</span>
configFile = file(Paths.get(<span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">'</span><span class="content">user.home</span><span class="delimiter">'</span></span>)).resolve(<span class="string"><span class="delimiter">'</span><span class="content">global-config.xml</span><span class="delimiter">'</span></span>))</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Using a relative path
var configFile = file(&quot;src/config.xml&quot;)

// Using an absolute path
configFile = file(configFile.absolutePath)

// Using a File object with a relative path
configFile = file(File(&quot;src/config.xml&quot;))

// Using a java.nio.file.Path object with a relative path
configFile = file(Paths.get(&quot;src&quot;, &quot;config.xml&quot;))

// Using an absolute java.nio.file.Path object
configFile = file(Paths.get(System.getProperty(&quot;user.home&quot;)).resolve(&quot;global-config.xml&quot;))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，您可以传递字符串， <code>File</code>实例和<code><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html">Path</a></code>实例<code>file()</code>方法，所有这些导致绝对<code>File</code>宾语。您可以在上一节中链接的参考指南中找到参数类型的其他选项。</p>
</div>
<div class="paragraph">
<p>在多项目构建中会发生什么？的<code>file()</code>方法将始终将相对路径转换为相对于当前项目目录（可能是子项目）的路径。如果要使用相对于<em>根项目</em>目录的路径，则需要使用特殊的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:rootDir">Project.getRootDir（）</a>属性来构造绝对路径，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子127。创建相对于父项目的路径</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="predefined-type">File</span> configFile = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>rootDir</span><span class="content">/shared/config.xml</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val configFile = file(&quot;$rootDir/shared/config.xml&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设您要在一个多项目构建中<code>dev/projects/AcmeHealth</code>目录。您可以在要修复的库的构建中使用以上示例-位于<code>AcmeHealth/subprojects/AcmePatientRecordLib/build.gradle</code> 。文件路径将解析为的绝对版本<code>dev/projects/AcmeHealth/shared/config.xml</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>file()</code>方法可用于配置具有类型属性的任何任务<code>File</code> 。但是，许多任务可以处理多个文件，因此接下来我们将介绍如何指定文件集。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:file_collections"><a class="anchor" href="#sec:file_collections"></a> <a class="link" href="#sec:file_collections">文件收集</a></h5>
<div class="paragraph">
<p><em>文件集合</em>只是由<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">FileCollection</a>接口表示的一组文件路径。<em>任何</em>文件路径。重要的是要了解文件路径不必以任何方式相关，因此它们不必位于同一目录中，甚至不必具有共享的父目录。您还将发现Gradle API的许多部分都在使用<code>FileCollection</code> ，例如本章稍后讨论的复制API和<a href="#sec:what-are-dependency-configurations">依赖项配置</a> 。</p>
</div>
<div class="paragraph">
<p>建议的指定文件集合的方法是使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object...-">ProjectLayout.files（java.lang。Object ...）</a>方法，该方法返回一个<code>FileCollection</code>实例。此方法非常灵活，可让您传递多个字符串， <code>File</code>实例，字符串集合， <code>File</code> s等。如果任务<a href="#sec:task_inputs_outputs">定义了输出，</a>您甚至可以将任务作为参数传递。在参考指南中了解所有受支持的参数类型。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>虽然<code>files()</code>方法接受<code>File</code>实例，永远不要使用<code>new File(relative path)</code>使用它，因为这会创建相对于当前工作目录（CWD）的路径。Gradle无法保证CWD的位置，这意味着依赖它的构建可能随时会损坏。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。</a><a href="#sec:single_file_paths">上一节中</a>介绍的Object）方法，所有相对路径都相对于当前项目目录进行评估。以下示例演示了您可以使用的各种参数类型-字符串， <code>File</code>实例，列表和<code><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html">Path</a></code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例128。创建文件集合</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">FileCollection collection = layout.files(<span class="string"><span class="delimiter">'</span><span class="content">src/file1.txt</span><span class="delimiter">'</span></span>,
                                  <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">'</span><span class="content">src/file2.txt</span><span class="delimiter">'</span></span>),
                                  [<span class="string"><span class="delimiter">'</span><span class="content">src/file3.csv</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">src/file4.csv</span><span class="delimiter">'</span></span>],
                                  Paths.get(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">file5.txt</span><span class="delimiter">'</span></span>))</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val collection: FileCollection = layout.files(
    &quot;src/file1.txt&quot;,
    File(&quot;src/file2.txt&quot;),
    listOf(&quot;src/file3.csv&quot;, &quot;src/file4.csv&quot;),
    Paths.get(&quot;src&quot;, &quot;file5.txt&quot;)
)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>文件集合在Gradle中具有一些重要的属性。他们可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>懒惰地创建</p>
</li>
<li>
<p>遍历</p>
</li>
<li>
<p>已过滤</p>
</li>
<li>
<p>合并的</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当您需要在构建运行时评估组成集合的文件时， <em>延迟创建</em>文件集合非常有用。在以下示例中，我们查询文件系统以找出特定目录中存在哪些文件，然后将它们放入文件集合中：</p>
</div>
<div class="exampleblock">
<div class="title">示例129实施文件收集</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task list {
    doLast {
        <span class="predefined-type">File</span> srcDir

        <span class="comment">// Create a file collection using a closure</span>
        collection = layout.files { srcDir.listFiles() }

        srcDir = file(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>)
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Contents of </span><span class="inline"><span class="inline-delimiter">$</span>srcDir</span><span class="content">.name</span><span class="delimiter">&quot;</span></span>
        collection.collect { relativePath(<span class="local-variable">it</span>) }.sort().each { println <span class="local-variable">it</span> }

        srcDir = file(<span class="string"><span class="delimiter">'</span><span class="content">src2</span><span class="delimiter">'</span></span>)
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Contents of </span><span class="inline"><span class="inline-delimiter">$</span>srcDir</span><span class="content">.name</span><span class="delimiter">&quot;</span></span>
        collection.collect { relativePath(<span class="local-variable">it</span>) }.sort().each { println <span class="local-variable">it</span> }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;list&quot;) {
    doLast {
        var srcDir: File? = null

        val collection = layout.files({
            srcDir?.listFiles()
        })

        srcDir = file(&quot;src&quot;)
        println(&quot;Contents of ${srcDir.name}&quot;)
        collection.map { relativePath(it) }.sorted().forEach { println(it) }

        srcDir = file(&quot;src2&quot;)
        println(&quot;Contents of ${srcDir.name}&quot;)
        collection.map { relativePath(it) }.sorted().forEach { println(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q list</code></strong></div>
<div class="content">
<pre>&gt; gradle -q list
Contents of src
src/dir1
src/file1.txt
Contents of src2
src2/dir1
src2/dir2</pre>
</div>
</div>
<div class="paragraph">
<p>延迟创建的关键是传递一个闭包（在Groovy中）或一个<code>Provider</code> （在科特林）到<code>files()</code>方法。您的闭包/提供者只需要返回一个被接受的类型的值<code>files()</code> ， 如<code>List<File></code> ， <code>String</code> ， <code>FileCollection</code>等</p>
</div>
<div class="paragraph">
<p><em>遍历文件集合</em>可以通过以下方式完成<code>each()</code> Groovy中的方法<code>forEach</code>集合中的方法（在Kotlin中）或在集合中使用集合<code>for</code>环。在这两种方法中，文件集合都被视为一组<code>File</code>实例，即您的迭代变量将是类型<code>File</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例演示了此类迭代以及如何使用来将文件集合转换为其他类型。 <code>as</code>运算符或支持的属性：</p>
</div>
<div class="exampleblock">
<div class="title">例子130。使用文件集合</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">        <span class="comment">// Iterate over the files in the collection</span>
        collection.each { <span class="predefined-type">File</span> file -&gt;
            println file.name
        }

        <span class="comment">// Convert the collection to various types</span>
        <span class="predefined-type">Set</span> set = collection.files
        <span class="predefined-type">Set</span> set2 = collection <span class="keyword">as</span> <span class="predefined-type">Set</span>
        <span class="predefined-type">List</span> list = collection <span class="keyword">as</span> <span class="predefined-type">List</span>
        <span class="predefined-type">String</span> path = collection.asPath
        <span class="predefined-type">File</span> file = collection.singleFile

        <span class="comment">// Add and subtract collections</span>
        <span class="keyword">def</span> union = collection + layout.files(<span class="string"><span class="delimiter">'</span><span class="content">src/file2.txt</span><span class="delimiter">'</span></span>)
        <span class="keyword">def</span> difference = collection - layout.files(<span class="string"><span class="delimiter">'</span><span class="content">src/file2.txt</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">        // Iterate over the files in the collection
        collection.forEach { file: File -&gt;
            println(file.name)
        }

        // Convert the collection to various types
        val set: Set&lt;File&gt; = collection.files
        val list: List&lt;File&gt; = collection.toList()
        val path: String = collection.asPath
        val file: File = collection.singleFile

        // Add and subtract collections
        val union = collection + layout.files(&quot;src/file2.txt&quot;)
        val difference = collection - layout.files(&quot;src/file2.txt&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以在示例末尾看到<em>如何</em>使用<code>+</code>和<code>-</code>运算符来合并和减去它们。生成的文件集合的一个重要特征是它们是<em>实时的</em> 。换句话说，以这种方式组合文件集合时，结果始终反映源文件集合中当前的内容，即使它们在构建过程中发生了变化。</p>
</div>
<div class="paragraph">
<p>例如，想象<code>collection</code>在上面的示例中，获得了一个或两个额外的文件<code>union</code>被建造。只要你用<code>union</code>这些文件添加到<code>collection</code> ， <code>union</code>还将包含这些其他文件。同样的<code>different</code>文件收集。</p>
</div>
<div class="paragraph">
<p>当涉及到<em>过滤</em>时，实时收集也很重要。如果要使用文件集合的子集，则可以利用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html#filter-org.gradle.api.specs.Spec-">FileCollection.filter（org.gradle.api.specs。Spec）</a>方法来确定要“保留”的文件。在以下示例中，我们创建一个新集合，该集合仅包含源集合中以.txt结尾的文件：</p>
</div>
<div class="exampleblock">
<div class="title">示例131过滤文件集合</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">        FileCollection textFiles = collection.filter { <span class="predefined-type">File</span> f -&gt;
            f.name.endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">.txt</span><span class="delimiter">&quot;</span></span>)
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">        val textFiles: FileCollection = collection.filter { f: File -&gt;
            f.name.endsWith(&quot;.txt&quot;)
        }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q filterTextFiles</code></strong></div>
<div class="content">
<pre>&gt; gradle -q filterTextFiles
src/file1.txt
src/file2.txt
src/file5.txt</pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>collection</code>随时进行更改，方法是添加或删除文件本身，然后<code>textFiles</code>将立即反映出更改，因为它也是实时收集。请注意，您传递给的闭包<code>filter()</code>需要一个<code>File</code>作为参数，应返回布尔值。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:file_trees"><a class="anchor" href="#sec:file_trees"></a> <a class="link" href="#sec:file_trees">文件树</a></h5>
<div class="paragraph">
<p><em>文件树</em>是一个文件集合，它保留其包含的文件的目录结构，并具有<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">FileTree</a>类型。这意味着文件树中的所有路径必须具有共享的父目录。下图突出显示了在复制文件的常见情况下文件树和文件集合之间的区别：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/file-collection-vs-file-tree.png" alt="文件收集与文件树">
</div>
<div class="title">图10。复制文件时文件树和文件集合的行为差异</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">虽然<code>FileTree</code>延伸<code>FileCollection</code> （一种关系），他们的行为确实有所不同。换句话说，您可以在需要文件收集的任何地方使用文件树，但请记住：文件收集是文件的平面列表/集合，而文件树是文件和目录的层次结构。要将文件树转换为平面集合，请使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html#getFiles--">FileTree.getFiles（）</a>属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>创建文件树的最简单方法是将文件或目录路径传递给<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)">Project.fileTree（java.lang。对象）</a>方法。这将创建一个包含该基本目录中所有文件和目录的树（而不是基本目录本身）。以下示例演示了如何使用基本方法，以及如何使用Ant样式的模式过滤文件和目录：</p>
</div>
<div class="exampleblock">
<div class="title">示例132创建文件树</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Create a file tree with a base directory</span>
ConfigurableFileTree tree = fileTree(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src/main</span><span class="delimiter">'</span></span>)

<span class="comment">// Add include and exclude patterns to the tree</span>
tree.include <span class="string"><span class="delimiter">'</span><span class="content">**/*.java</span><span class="delimiter">'</span></span>
tree.exclude <span class="string"><span class="delimiter">'</span><span class="content">**/Abstract*</span><span class="delimiter">'</span></span>

<span class="comment">// Create a tree using closure</span>
tree = fileTree(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>) {
    include <span class="string"><span class="delimiter">'</span><span class="content">**/*.java</span><span class="delimiter">'</span></span>
}

<span class="comment">// Create a tree using a map</span>
tree = fileTree(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>, <span class="key">include</span>: <span class="string"><span class="delimiter">'</span><span class="content">**/*.java</span><span class="delimiter">'</span></span>)
tree = fileTree(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>, <span class="key">includes</span>: [<span class="string"><span class="delimiter">'</span><span class="content">**/*.java</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.xml</span><span class="delimiter">'</span></span>])
tree = fileTree(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>, <span class="key">include</span>: <span class="string"><span class="delimiter">'</span><span class="content">**/*.java</span><span class="delimiter">'</span></span>, <span class="key">exclude</span>: <span class="string"><span class="delimiter">'</span><span class="content">**/*test*/**</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Create a file tree with a base directory
var tree: ConfigurableFileTree = fileTree(&quot;src/main&quot;)

// Add include and exclude patterns to the tree
tree.include(&quot;**/*.java&quot;)
tree.exclude(&quot;**/Abstract*&quot;)

// Create a tree using closure
tree = fileTree(&quot;src&quot;) {
    include(&quot;**/*.java&quot;)
}

// Create a tree using a map
tree = fileTree(&quot;dir&quot; to &quot;src&quot;, &quot;include&quot; to &quot;**/*.java&quot;)
tree = fileTree(&quot;dir&quot; to &quot;src&quot;, &quot;includes&quot; to listOf(&quot;**/*.java&quot;, &quot;**/*.xml&quot;))
tree = fileTree(&quot;dir&quot; to &quot;src&quot;, &quot;include&quot; to &quot;**/*.java&quot;, &quot;exclude&quot; to &quot;**/*test*/**&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/util/PatternFilterable.html">PatternFilterable</a>的API文档中看到更多受支持的模式示例。另外，请参阅API文档以获取<code>fileTree()</code>查看可以作为基本目录传递的类型。</p>
</div>
<div class="paragraph">
<p>默认， <code>fileTree()</code>返回一个<code>FileTree</code>为方便起见，应用一些默认排除模式的实例—实际上与Ant相同。有关完整的默认排除列表，请参见<a href="http://ant.apache.org/manual/dirtasks.html#defaultexcludes">Ant手册</a> 。</p>
</div>
<div class="paragraph">
<p>如果这些默认排除措施有问题，您可以使用<a href="https://ant.apache.org/manual/Tasks/defaultexcludes.html"><code>defaultexcludes</code> Ant任务</a> ，如本例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例133更改复制任务的Ant默认排除项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task forcedCopy (<span class="key">type</span>: Copy) {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/inPlaceApp</span><span class="delimiter">&quot;</span></span>
    from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>

    doFirst {
        ant.defaultexcludes <span class="key">remove</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">**/.git</span><span class="delimiter">&quot;</span></span>
        ant.defaultexcludes <span class="key">remove</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">**/.git/**</span><span class="delimiter">&quot;</span></span>
        ant.defaultexcludes <span class="key">remove</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*~</span><span class="delimiter">&quot;</span></span>
    }

    doLast {
        ant.defaultexcludes <span class="keyword">default</span>: <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;forcedCopy&quot;) {
    into(&quot;$buildDir/inPlaceApp&quot;)
    from(&quot;src/main/webapp&quot;)

    doFirst {
        ant.withGroovyBuilder {
            &quot;defaultexcludes&quot;(&quot;remove&quot; to &quot;**/.git&quot;)
            &quot;defaultexcludes&quot;(&quot;remove&quot; to &quot;**/.git/**&quot;)
            &quot;defaultexcludes&quot;(&quot;remove&quot; to &quot;**/*~&quot;)
        }
    }

    doLast {
        ant.withGroovyBuilder {
            &quot;defaultexcludes&quot;(&quot;default&quot; to true)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通常，最好在每次更改默认排除项时都将其重置，因为修改对整个构建都是可见的。上面的示例正在执行其重置<code>doLast</code>行动。</p>
</div>
<div class="paragraph">
<p>您可以使用文件树来执行许多与文件集合相同的事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>遍历它们（深度优先）</p>
</li>
<li>
<p>过滤它们（使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html#matching-org.gradle.api.Action-">FileTree.matching（org.gradle.api。动作）</a>和蚂蚁风格的图案）</p>
</li>
<li>
<p>合并它们</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html#visit-org.gradle.api.Action-">FileTree.visit（org.gradle.api。动作）</a>方法。下面的示例演示了所有这些技术：</p>
</div>
<div class="exampleblock">
<div class="title">实施例134。使用文件树</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Iterate over the contents of a tree</span>
tree.each {<span class="predefined-type">File</span> file -&gt;
    println file
}

<span class="comment">// Filter a tree</span>
FileTree filtered = tree.matching {
    include <span class="string"><span class="delimiter">'</span><span class="content">org/gradle/api/**</span><span class="delimiter">'</span></span>
}

<span class="comment">// Add trees together</span>
FileTree sum = tree + fileTree(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src/test</span><span class="delimiter">'</span></span>)

<span class="comment">// Visit the elements of the tree</span>
tree.visit {element -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>element</span><span class="content">.relativePath =&gt; </span><span class="inline"><span class="inline-delimiter">$</span>element</span><span class="content">.file</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Iterate over the contents of a tree
tree.forEach{ file: File -&gt;
    println(file)
}

// Filter a tree
val filtered: FileTree = tree.matching {
    include(&quot;org/gradle/api/**&quot;)
}

// Add trees together
val sum: FileTree = tree + fileTree(&quot;src/test&quot;)

// Visit the elements of the tree
tree.visit {
    println(&quot;${this.relativePath} =&gt; ${this.file}&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们已经讨论了如何创建自己的文件树和文件集合，但是也要记住，许多Gradle插件提供了自己的文件树实例，例如<a href="#sec:java_source_sets">Java的源集</a> 。这些文件的使用和操作方式与您自己创建的文件树完全相同。</p>
</div>
<div class="paragraph">
<p>用户通常需要的另一种特定类型的文件树是归档文件，即ZIP文件，TAR文件等。我们接下来将介绍它们。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:archive_contents"><a class="anchor" href="#sec:archive_contents"></a> <a class="link" href="#sec:archive_contents">将存档用作文件树</a></h5>
<div class="paragraph">
<p>归档是打包到单个文件中的目录和文件层次结构。换句话说，这是文件树的特例，这正是Gradle处理档案的方式。而不是使用<code>fileTree()</code>方法，仅适用于普通文件系统，请使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)">Project.zipTree（java.lang。Object）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:tarTree(java.lang.Object)">Project.tarTree（java.lang。对象）</a>方法来包装相应类型的存档文件（请注意，JAR，WAR和EAR文件是ZIP）。两种方法都返回<code>FileTree</code>然后您可以使用与普通文件树相同的方式使用实例。例如，您可以通过将归档文件的内容复制到文件系统上的某个目录中来提取其一部分或全部文件。或者，您可以将一个档案合并到另一个档案中。</p>
</div>
<div class="paragraph">
<p>以下是创建基于归档的文件树的一些简单示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例135将归档文件用作文件树</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Create a ZIP file tree using path</span>
FileTree zip = zipTree(<span class="string"><span class="delimiter">'</span><span class="content">someFile.zip</span><span class="delimiter">'</span></span>)

<span class="comment">// Create a TAR file tree using path</span>
FileTree tar = tarTree(<span class="string"><span class="delimiter">'</span><span class="content">someFile.tar</span><span class="delimiter">'</span></span>)

<span class="comment">//tar tree attempts to guess the compression based on the file extension</span>
<span class="comment">//however if you must specify the compression explicitly you can:</span>
FileTree someTar = tarTree(resources.gzip(<span class="string"><span class="delimiter">'</span><span class="content">someTar.ext</span><span class="delimiter">'</span></span>))</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Create a ZIP file tree using path
val zip: FileTree = zipTree(&quot;someFile.zip&quot;)

// Create a TAR file tree using path
val tar: FileTree = tarTree(&quot;someFile.tar&quot;)

// tar tree attempts to guess the compression based on the file extension
// however if you must specify the compression explicitly you can:
val someTar: FileTree = tarTree(resources.gzip(&quot;someTar.ext&quot;))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#sec:unpacking_archives_example">在</a>我们介绍<a href="#sec:unpacking_archives_example">的常见方案中，</a>您可以看到提取存档文件的实际示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:specifying_multiple_files"><a class="anchor" href="#sec:specifying_multiple_files"></a> <a class="link" href="#sec:specifying_multiple_files">了解对文件集合的隐式转换</a></h5>
<div class="paragraph">
<p>Gradle中的许多对象都有接受一组输入文件的属性。例如， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a>任务有一个<code>source</code>定义要编译的源文件的属性。您可以使用api docs中提到的<a href="#sec:file_collections">files（）</a>方法支持的任何类型来设置此属性的值。这意味着您可以例如将属性设置为<code>File</code> ， <code>String</code> ，收藏， <code>FileCollection</code>甚至是闭包或提供者。</p>
</div>
<div class="paragraph">
<p><strong>这是特定任务的功能</strong> ！这意味着隐含转换将不会仅针对具有<code>FileCollection</code>要么<code>FileTree</code>属性。如果您想知道在特定情况下是否发生隐式转换，则需要阅读相关文档，例如相应任务的API文档。另外，您可以通过显式使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object...-">ProjectLayout.files（java.lang。对象...）</a> 。</p>
</div>
<div class="paragraph">
<p>以下是一些不同类型的参数的示例， <code>source</code>财产可以带：</p>
</div>
<div class="exampleblock">
<div class="title">实施例136。指定一组文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task compile(<span class="key">type</span>: JavaCompile) {

    <span class="comment">// Use a File object to specify the source directory</span>
    source = file(<span class="string"><span class="delimiter">'</span><span class="content">src/main/java</span><span class="delimiter">'</span></span>)

    <span class="comment">// Use a String path to specify the source directory</span>
    source = <span class="string"><span class="delimiter">'</span><span class="content">src/main/java</span><span class="delimiter">'</span></span>

    <span class="comment">// Use a collection to specify multiple source directories</span>
    source = [<span class="string"><span class="delimiter">'</span><span class="content">src/main/java</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">../shared/java</span><span class="delimiter">'</span></span>]

    <span class="comment">// Use a FileCollection (or FileTree in this case) to specify the source files</span>
    source = fileTree(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src/main/java</span><span class="delimiter">'</span></span>).matching { include <span class="string"><span class="delimiter">'</span><span class="content">org/gradle/api/**</span><span class="delimiter">'</span></span> }

    <span class="comment">// Using a closure to specify the source files.</span>
    source = {
        <span class="comment">// Use the contents of each zip file in the src dir</span>
        file(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>).listFiles().findAll {<span class="local-variable">it</span>.name.endsWith(<span class="string"><span class="delimiter">'</span><span class="content">.zip</span><span class="delimiter">'</span></span>)}.collect { zipTree(<span class="local-variable">it</span>) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;JavaCompile&gt;(&quot;compile&quot;) {
    // Use a File object to specify the source directory
    source = fileTree(file(&quot;src/main/java&quot;))

    // Use a String path to specify the source directory
    source = fileTree(&quot;src/main/java&quot;)

    // Use a collection to specify multiple source directories
    source = fileTree(listOf(&quot;src/main/java&quot;, &quot;../shared/java&quot;))

    // Use a FileCollection (or FileTree in this case) to specify the source files
    source = fileTree(&quot;src/main/java&quot;).matching { include(&quot;org/gradle/api/**&quot;) }

    // Using a closure to specify the source files.
    setSource({
        // Use the contents of each zip file in the src dir
        file(&quot;src&quot;).listFiles().filter { it.name.endsWith(&quot;.zip&quot;) }.map { zipTree(it) }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要注意的另一件事是，像<code>source</code>在Gradle核心任务中有相应的方法。这些方法遵循以下约定： <em>附加</em>到值的集合，而不是替换它们。同样，此方法接受<a href="#sec:file_collections">files（）</a>方法支持的任何类型，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">实施例137。附加一组文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">compile {
    <span class="comment">// Add some source directories use String paths</span>
    source <span class="string"><span class="delimiter">'</span><span class="content">src/main/java</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">src/main/groovy</span><span class="delimiter">'</span></span>

    <span class="comment">// Add a source directory using a File object</span>
    source file(<span class="string"><span class="delimiter">'</span><span class="content">../shared/java</span><span class="delimiter">'</span></span>)

    <span class="comment">// Add some source directories using a closure</span>
    source { file(<span class="string"><span class="delimiter">'</span><span class="content">src/test/</span><span class="delimiter">'</span></span>).listFiles() }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;JavaCompile&gt;(&quot;compile&quot;) {
    // Add some source directories use String paths
    source(&quot;src/main/java&quot;, &quot;src/main/groovy&quot;)

    // Add a source directory using a File object
    source(file(&quot;../shared/java&quot;))

    // Add some source directories using a closure
    setSource({ file(&quot;src/test/&quot;).listFiles() })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于这是一个常规约定，因此建议您在自己的自定义任务中遵循它。具体来说，如果您计划添加一种方法来配置基于集合的属性，请确保该方法追加而不是替换值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:copying_files"><a class="anchor" href="#sec:copying_files"></a> <a class="link" href="#sec:copying_files">深度复制文件</a></h4>
<div class="paragraph">
<p>在Gradle中复制文件的基本过程很简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a>类型的任务</p>
</li>
<li>
<p>指定要复制的文件（可能还有目录）</p>
</li>
<li>
<p>指定复制文件的目的地</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是这种明显的简单性隐藏了一个丰富的API，该API可以对复制的文件，复制的位置以及复制时发生的情况进行细粒度的控制-例如，文件重命名和文件内容的令牌替换都是可能的。</p>
</div>
<div class="paragraph">
<p>让我们从列表中的最后两项开始，它们形成了所谓的<em>复制规范</em> 。这正式基于<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html">CopySpec</a>接口， <code>Copy</code>任务实现，并提供：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#from-java.lang.Object...-">CopySpec.from（java.lang。Object ...）</a>方法来定义要复制的内容</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#into-java.lang.Object-">CopySpec.into（java.lang。对象）</a>方法来定义目标</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>CopySpec</code>还有几种其他方法可以让您控制复制过程，但这两个是唯一必需的方法。 <code>into()</code>非常简单，需要以<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。对象）</a>方法。的<code>from()</code>配置要灵活得多。</p>
</div>
<div class="paragraph">
<p>不仅<code>from()</code>接受多个参数，它还允许几种不同类型的参数。例如，一些最常见的类型是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>String</code> —视为文件路径，或者，如果以“ file：//”开头，则视为文件URI</p>
</li>
<li>
<p>一种<code>File</code> —用作文件路径</p>
</li>
<li>
<p>一种<code>FileCollection</code>要么<code>FileTree</code> —集合中的所有文件都包含在副本中</p>
</li>
<li>
<p>任务-包含构成任务<a href="#sec:task_inputs_outputs">定义的输出</a>的文件或目录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>事实上， <code>from()</code>接受与<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（java.lang。对象...），</a>因此请参见该方法以获取可接受类型的更详细列表。</p>
</div>
<div class="paragraph">
<p>其他需要考虑的是文件路径是指哪种类型的东西：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个文件—该文件被原样复制</p>
</li>
<li>
<p>目录-这实际上被视为文件树：其中的所有内容（包括子目录）都将被复制。但是，目录本身不包括在副本中。</p>
</li>
<li>
<p>文件不存在-路径被忽略</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是一个使用多个<code>from()</code>规范，每个都有不同的参数类型。您可能还会注意到<code>into()</code>使用闭包（在Groovy中）或提供程序（在Kotlin中）懒惰地配置-这种技术也适用于<code>from()</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">实施例138。指定复制任务源文件和目标目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task anotherCopyTask (<span class="key">type</span>: Copy) {
    <span class="comment">// Copy everything under src/main/webapp</span>
    from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>
    <span class="comment">// Copy a single file</span>
    from <span class="string"><span class="delimiter">'</span><span class="content">src/staging/index.html</span><span class="delimiter">'</span></span>
    <span class="comment">// Copy the output of a task</span>
    from copyTask
    <span class="comment">// Copy the output of a task using Task outputs explicitly.</span>
    from copyTaskWithPatterns.outputs
    <span class="comment">// Copy the contents of a Zip file</span>
    from zipTree(<span class="string"><span class="delimiter">'</span><span class="content">src/main/assets.zip</span><span class="delimiter">'</span></span>)
    <span class="comment">// Determine the destination directory later</span>
    into { getDestDir() }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;anotherCopyTask&quot;) {
    // Copy everything under src/main/webapp
    from(&quot;src/main/webapp&quot;)
    // Copy a single file
    from(&quot;src/staging/index.html&quot;)
    // Copy the output of a task
    from(copyTask)
    // Copy the output of a task using Task outputs explicitly.
    from(tasks[&quot;copyTaskWithPatterns&quot;].outputs)
    // Copy the contents of a Zip file
    from(zipTree(&quot;src/main/assets.zip&quot;))
    // Determine the destination directory later
    into({ getDestDir() })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>into()</code>与<a href="#sub:using_child_copy_specifications">子规范</a>不同，即使语法相似。注意参数的数量以区分它们。</p>
</div>
<div class="sect4">
<h5 id="filtering_files"><a class="anchor" href="#filtering_files"></a> <a class="link" href="#filtering_files">过滤文件</a></h5>
<div class="paragraph">
<p>您已经看到您可以直接在文件中过滤文件集合和文件树<code>Copy</code>任务，但您也可以通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#include-java.lang.String...-">CopySpec.include（java.lang。字符串...）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#exclude-java.lang.String...-">CopySpec.exclude（java.lang。String ...）</a>方法。</p>
</div>
<div class="paragraph">
<p>这两种方法通常都与Ant样式的包含或排除模式一起使用，如<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/util/PatternFilterable.html">PatternFilterable中所述</a> 。您还可以通过使用带<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTreeElement.html">FileTreeElement</a>并返回的闭包来执行更复杂的逻辑<code>true</code>是否应包含文件或<code>false</code>除此以外。下面的示例演示了这两种形式，确保仅复制.html和.jsp文件，但其内容中带有单词“ DRAFT”的.html文件除外：</p>
</div>
<div class="exampleblock">
<div class="title">示例139选择要复制的文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyTaskWithPatterns (<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/explodedWar</span><span class="delimiter">&quot;</span></span>
    include <span class="string"><span class="delimiter">'</span><span class="content">**/*.html</span><span class="delimiter">'</span></span>
    include <span class="string"><span class="delimiter">'</span><span class="content">**/*.jsp</span><span class="delimiter">'</span></span>
    exclude { FileTreeElement details -&gt;
        details.file.name.endsWith(<span class="string"><span class="delimiter">'</span><span class="content">.html</span><span class="delimiter">'</span></span>) &amp;&amp;
            details.file.text.contains(<span class="string"><span class="delimiter">'</span><span class="content">DRAFT</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;copyTaskWithPatterns&quot;) {
    from(&quot;src/main/webapp&quot;)
    into(&quot;$buildDir/explodedWar&quot;)
    include(&quot;**/*.html&quot;)
    include(&quot;**/*.jsp&quot;)
    exclude { details: FileTreeElement -&gt;
        details.file.name.endsWith(&quot;.html&quot;) &amp;&amp;
            details.file.readText().contains(&quot;DRAFT&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可能会问自己一个问题，当包含和排除模式重叠时会发生什么？哪个模式获胜？基本规则如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果没有明确的包含或排除，则包括所有内容</p>
</li>
<li>
<p>如果指定了至少一个包含，则仅包含与模式匹配的文件和目录</p>
</li>
<li>
<p>任何排除模式都会覆盖所有包含，因此，如果文件或目录至少匹配一个排除模式，则无论包含模式如何，都不会将其包括在内</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>创建合并的包含和排除规范时请牢记这些规则，以便最终获得所需的确切行为。</p>
</div>
<div class="paragraph">
<p>请注意，以上示例中的包含和排除将适用于<em>所有</em> <code>from()</code>配置。如果要将过滤应用于复制文件的子集，则需要使用<a href="#sub:using_child_copy_specifications">子规范</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:renaming_files"><a class="anchor" href="#sec:renaming_files"></a> <a class="link" href="#sec:renaming_files">重命名文件</a></h5>
<div class="paragraph">
<p><a href="#sec:renaming_files_example">如何重命名复制文件</a>的<a href="#sec:renaming_files_example">示例</a>为您提供了执行此操作所需的大多数信息。它演示了两个重命名选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用正则表达式</p>
</li>
<li>
<p>使用闭包</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>正则表达式是一种灵活的重命名方法，尤其是在Gradle支持正则表达式组的情况下，该组允许您删除和替换部分源文件名。下面的示例说明如何使用简单的正则表达式从包含字符串的任何文件名中删除字符串“ -staging-”：</p>
</div>
<div class="exampleblock">
<div class="title">例子140。在复制文件时重命名文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task rename (<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/explodedWar</span><span class="delimiter">&quot;</span></span>
    <span class="comment">// Use a closure to convert all file names to upper case</span>
    rename { <span class="predefined-type">String</span> fileName -&gt;
        fileName.toUpperCase()
    }
    <span class="comment">// Use a regular expression to map the file name</span>
    rename <span class="string"><span class="delimiter">'</span><span class="content">(.+)-staging-(.+)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">$1$2</span><span class="delimiter">'</span></span>
    rename(<span class="regexp"><span class="delimiter">/</span><span class="content">(.+)-staging-(.+)</span><span class="delimiter">/</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">$1$2</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;rename&quot;) {
    from(&quot;src/main/webapp&quot;)
    into(&quot;$buildDir/explodedWar&quot;)
    // Use a closure to convert all file names to upper case
    rename { fileName: String -&gt;
        fileName.toUpperCase()
    }
    // Use a regular expression to map the file name
    rename(&quot;(.+)-staging-(.+)&quot;, &quot;$1$2&quot;)
    rename(&quot;(.+)-staging-(.+)&quot;.toRegex().pattern, &quot;$1$2&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用Java支持的任何正则表达式<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a></code>类和替换字符串（的第二个参数<code>rename()</code>按照与<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)">Matcher.appendReplacement()</a></code>方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">Groovy构建脚本中的正则表达式</div>
<div class="paragraph">
<p>人们在这种情况下使用正则表达式时会遇到两个常见问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果对第一个参数使用斜杠字符串（以“ /”分隔），则<em>必须在</em>其中加上括号<code>rename()</code>如上例所示。</p>
</li>
<li>
<p>在第二个参数中使用单引号是最安全的，否则您需要在组替换中转义'$'，即<code>"\$1\$2"</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>第一个是不便之处，但斜杠字符串的优点是您不必在正则表达式中转义反斜杠（'\'）字符。第二个问题来自Groovy对使用以下语言的嵌入式表达式的支持<code>${ }</code>双引号和斜杠字符串中的语法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的关闭语法<code>rename()</code>非常简单明了，可用于简单正则表达式无法处理的任何要求。系统会为您提供文件名，并为该文件返回一个新名称，或者<code>null</code>如果您不想更改名称。请注意，将对复制的每个文件执行关闭操作，因此请尽量避免执行昂贵的操作。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:filtering_files"><a class="anchor" href="#sec:filtering_files"></a> <a class="link" href="#sec:filtering_files">过滤文件内容（令牌替换，模板等）</a></h5>
<div class="paragraph">
<p>不要与过滤复制哪些文件混淆， <em>文件内容过滤</em>使您可以在复制文件时转换其内容。这可能涉及使用令牌替换的基本模板，删除文本行，或者使用成熟的模板引擎进行更复杂的过滤。</p>
</div>
<div class="paragraph">
<p>以下示例演示了几种过滤形式，包括使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#expand-java.util.Map-">CopySpec.expand（java.util。Map）</a>方法，另一个使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#filter-java.lang.Class-">CopySpec.filter（java.lang。类）</a>和一个<a href="https://ant.apache.org/manual/Types/filterchain.html">Ant过滤器</a> ：</p>
</div>
<div class="exampleblock">
<div class="title">实施例141。复制文件时过滤文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.apache.tools.ant.filters.FixCrLfFilter</span>
<span class="keyword">import</span> <span class="include">org.apache.tools.ant.filters.ReplaceTokens</span>

task filter(<span class="key">type</span>: Copy) {
    from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/explodedWar</span><span class="delimiter">&quot;</span></span>
    <span class="comment">// Substitute property tokens in files</span>
    expand(<span class="key">copyright</span>: <span class="string"><span class="delimiter">'</span><span class="content">2009</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">2.3.1</span><span class="delimiter">'</span></span>)
    expand(project.properties)
    <span class="comment">// Use some of the filters provided by Ant</span>
    filter(FixCrLfFilter)
    filter(ReplaceTokens, <span class="key">tokens</span>: [<span class="key">copyright</span>: <span class="string"><span class="delimiter">'</span><span class="content">2009</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">2.3.1</span><span class="delimiter">'</span></span>])
    <span class="comment">// Use a closure to filter each line</span>
    filter { <span class="predefined-type">String</span> line -&gt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">[</span><span class="inline"><span class="inline-delimiter">$</span>line</span><span class="content">]</span><span class="delimiter">&quot;</span></span>
    }
    <span class="comment">// Use a closure to remove lines</span>
    filter { <span class="predefined-type">String</span> line -&gt;
        line.startsWith(<span class="string"><span class="delimiter">'</span><span class="content">-</span><span class="delimiter">'</span></span>) ? <span class="predefined-constant">null</span> : line
    }
    filteringCharset = <span class="string"><span class="delimiter">'</span><span class="content">UTF-8</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.apache.tools.ant.filters.FixCrLfFilter
import org.apache.tools.ant.filters.ReplaceTokens
tasks.register&lt;Copy&gt;(&quot;filter&quot;) {
    from(&quot;src/main/webapp&quot;)
    into(&quot;$buildDir/explodedWar&quot;)
    // Substitute property tokens in files
    expand(&quot;copyright&quot; to &quot;2009&quot;, &quot;version&quot; to &quot;2.3.1&quot;)
    expand(project.properties)
    // Use some of the filters provided by Ant
    filter(FixCrLfFilter::class)
    filter(ReplaceTokens::class, &quot;tokens&quot; to mapOf(&quot;copyright&quot; to &quot;2009&quot;, &quot;version&quot; to &quot;2.3.1&quot;))
    // Use a closure to filter each line
    filter { line: String -&gt;
        &quot;[$line]&quot;
    }
    // Use a closure to remove lines
    filter { line: String -&gt;
        if (line.startsWith('-')) null else line
    }
    filteringCharset = &quot;UTF-8&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>filter()</code>方法有两个变体，它们的行为不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个需要一个<code><a href="https://docs.oracle.com/javase/8/docs/api/java/io/FilterReader.html">FilterReader</a></code>旨在与Ant过滤器一起使用，例如<code>ReplaceTokens</code></p>
</li>
<li>
<p>可以使用一个闭包或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Transformer.html">Transformer</a> ，它为源文件的每一行定义转换</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，两个变体都假定源文件是基于文本的。当您使用<code>ReplaceTokens</code>上课<code>filter()</code> ，结果是一个模板引擎替换了以下形式的标记<code>@tokenName@</code> （Ant样式令牌）以及您定义的值。</p>
</div>
<div class="paragraph">
<p>的<code>expand()</code>方法将源文件视为<a href="https://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html">Groovy模板</a> ，该<a href="https://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html">模板</a>评估和扩展表单的表达式<code>${expression}</code> 。您可以传入属性名称和值，然后在源文件中对其进行扩展。 <code>expand()</code>由于嵌入的表达式是成熟的Groovy表达式，因此不仅仅可以进行基本的令牌替换。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">良好的做法是在读写文件时指定字符集，否则转换将不适用于非ASCII文本。您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#getFilteringCharset--">CopySpec.getFilteringCharset（）</a>属性配置字符集。如果未指定，则使用JVM默认字符集，该字符集可能与所需的字符集不同。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_the_copyspec_class"><a class="anchor" href="#sec:using_the_copyspec_class"></a> <a class="link" href="#sec:using_the_copyspec_class">使用<code>CopySpec</code>类</a></h5>
<div class="paragraph">
<p>复制规范（或简称复制规范）确定将复制到何处以及在复制过程中文件发生什么情况。您已经以配置形式查看了许多示例<code>Copy</code>和存档任务。但是复制规范具有两个属性，值得更详细介绍：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>它们可以独立于任务</p>
</li>
<li>
<p>它们是分层的</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这些属性中的第一个允许您<em>在构建中共享副本规范</em> 。第二个在整个复印规范中提供细粒度的控制。</p>
</div>
<div class="sect5">
<h6 id="sub:sharing_copy_specs"><a class="anchor" href="#sub:sharing_copy_specs"></a> <a class="link" href="#sub:sharing_copy_specs">共享复印规格</a></h6>
<div class="paragraph">
<p>考虑一个具有多个任务的构建，这些任务可以复制项目的静态网站资源或将其添加到存档中。一个任务可能会将资源复制到本地HTTP服务器的文件夹中，另一任务可能会将它们打包到分发中。您可以在每次需要时手动指定文件位置和适当的包含物，但是人为错误更容易出现，从而导致任务之间的不一致。</p>
</div>
<div class="paragraph">
<p>Gradle提供的一种解决方案是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:copySpec(org.gradle.api.Action)">Project.copySpec（org.gradle.api。动作）</a>方法。这使您可以在任务外部创建副本规格，然后可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#with-org.gradle.api.file.CopySpec...-">CopySpec.with（org.gradle.api.file将其附加到适当的任务</a><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#with-org.gradle.api.file.CopySpec...-">。CopySpec ...）</a>方法。下面的示例演示了如何完成此操作：</p>
</div>
<div class="exampleblock">
<div class="title">实施例142。共享复印规格</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">CopySpec webAssetsSpec = copySpec {
    from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>
    include <span class="string"><span class="delimiter">'</span><span class="content">**/*.html</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.png</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.jpg</span><span class="delimiter">'</span></span>
    rename <span class="string"><span class="delimiter">'</span><span class="content">(.+)-staging(.+)</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">$1$2</span><span class="delimiter">'</span></span>
}

task copyAssets (<span class="key">type</span>: Copy) {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/inPlaceApp</span><span class="delimiter">&quot;</span></span>
    with webAssetsSpec
}

task distApp(<span class="key">type</span>: Zip) {
    archiveFileName = <span class="string"><span class="delimiter">'</span><span class="content">my-app-dist.zip</span><span class="delimiter">'</span></span>
    destinationDirectory = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/dists</span><span class="delimiter">&quot;</span></span>)

    from appClasses
    with webAssetsSpec
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val webAssetsSpec: CopySpec = copySpec {
    from(&quot;src/main/webapp&quot;)
    include(&quot;**/*.html&quot;, &quot;**/*.png&quot;, &quot;**/*.jpg&quot;)
    rename(&quot;(.+)-staging(.+)&quot;, &quot;$1$2&quot;)
}

tasks.register&lt;Copy&gt;(&quot;copyAssets&quot;) {
    into(&quot;$buildDir/inPlaceApp&quot;)
    with(webAssetsSpec)
}

tasks.register&lt;Zip&gt;(&quot;distApp&quot;) {
    archiveFileName.set(&quot;my-app-dist.zip&quot;)
    destinationDirectory.set(file(&quot;$buildDir/dists&quot;))

    from(appClasses)
    with(webAssetsSpec)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这俩<code>copyAssets</code>和<code>distApp</code>任务将处理下的静态资源<code>src/main/webapp</code> ，由<code>webAssetsSpec</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>定义的配置<code>webAssetsSpec</code>将<em>不适</em>用于由包括应用类<code>distApp</code>任务。那是因为<code>from appClasses</code>是其自己的子规范，独立于<code>with webAssetsSpec</code> 。</p>
</div>
<div class="paragraph">
<p>这可能会使您感到困惑，因此最好进行治疗<code>with()</code>作为额外<code>from()</code>任务中的规范。因此，定义至少没有一个副本的独立副本规范是没有意义的<code>from()</code>定义。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果遇到要将相同的副本配置应用于<em>不同</em>的文件集的情况，则可以直接共享配置块，而无需使用<code>copySpec()</code> 。这是一个具有两个独立任务的示例，这些任务恰好只希望处理图像文件：</p>
</div>
<div class="exampleblock">
<div class="title">示例143。仅共享复印模式</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> webAssetPatterns = {
    include <span class="string"><span class="delimiter">'</span><span class="content">**/*.html</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.png</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.jpg</span><span class="delimiter">'</span></span>
}

task copyAppAssets(<span class="key">type</span>: Copy) {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/inPlaceApp</span><span class="delimiter">&quot;</span></span>
    from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>, webAssetPatterns
}

task archiveDistAssets(<span class="key">type</span>: Zip) {
    archiveFileName = <span class="string"><span class="delimiter">'</span><span class="content">distribution-assets.zip</span><span class="delimiter">'</span></span>
    destinationDirectory = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/dists</span><span class="delimiter">&quot;</span></span>)

    from <span class="string"><span class="delimiter">'</span><span class="content">distResources</span><span class="delimiter">'</span></span>, webAssetPatterns
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val webAssetPatterns = Action&lt;CopySpec&gt; {
    include(&quot;**/*.html&quot;, &quot;**/*.png&quot;, &quot;**/*.jpg&quot;)
}

tasks.register&lt;Copy&gt;(&quot;copyAppAssets&quot;) {
    into(&quot;$buildDir/inPlaceApp&quot;)
    from(&quot;src/main/webapp&quot;, webAssetPatterns)
}

tasks.register&lt;Zip&gt;(&quot;archiveDistAssets&quot;) {
    archiveFileName.set(&quot;distribution-assets.zip&quot;)
    destinationDirectory.set(file(&quot;$buildDir/dists&quot;))

    from(&quot;distResources&quot;, webAssetPatterns)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，我们将复制配置分配给它自己的变量，并将其应用于任何<code>from()</code>我们想要的规格。这不仅适用于包含项，而且还适用于排除项，文件重命名和文件内容过滤。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:using_child_copy_specifications"><a class="anchor" href="#sub:using_child_copy_specifications"></a> <a class="link" href="#sub:using_child_copy_specifications">使用子规范</a></h6>
<div class="paragraph">
<p>如果仅使用单个副本规范，则文件筛选和重命名将应用于<em>所有</em>复制的文件。有时这就是您想要的，但并非总是如此。考虑以下示例，该示例将文件复制到目录结构中，Java Servlet容器可使用该目录结构来交付网站：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/exploded-war-child-copy-spec-example.png" alt="爆炸战争儿童副本规格示例">
</div>
<div class="title">图11。为Servlet容器创建分解的WAR</div>
</div>
<div class="paragraph">
<p>这不是简单的副本，因为<code>WEB-INF</code>目录及其子目录在项目中不存在，因此必须在复制期间创建它们。此外，我们只希望HTML和图像文件直接进入根文件夹- <code>build/explodedWar</code> —并且只有JavaScript文件进入<code>js</code>目录。因此，我们需要针对这两套文件使用单独的过滤器模式。</p>
</div>
<div class="paragraph">
<p>解决方案是使用<em>子级规范</em> ，该<em>规范</em>可同时应用于<code>from()</code>和<code>into()</code>声明。以下任务定义完成了必要的工作：</p>
</div>
<div class="exampleblock">
<div class="title">实施例144。嵌套副本规格</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task nestedSpecs(<span class="key">type</span>: Copy) {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/explodedWar</span><span class="delimiter">&quot;</span></span>
    exclude <span class="string"><span class="delimiter">'</span><span class="content">**/*staging*</span><span class="delimiter">'</span></span>
    from(<span class="string"><span class="delimiter">'</span><span class="content">src/dist</span><span class="delimiter">'</span></span>) {
        include <span class="string"><span class="delimiter">'</span><span class="content">**/*.html</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.png</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.jpg</span><span class="delimiter">'</span></span>
    }
    from(sourceSets.main.output) {
        into <span class="string"><span class="delimiter">'</span><span class="content">WEB-INF/classes</span><span class="delimiter">'</span></span>
    }
    into(<span class="string"><span class="delimiter">'</span><span class="content">WEB-INF/lib</span><span class="delimiter">'</span></span>) {
        from configurations.runtimeClasspath
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Copy&gt;(&quot;nestedSpecs&quot;) {
    into(&quot;$buildDir/explodedWar&quot;)
    exclude(&quot;**/*staging*&quot;)
    from(&quot;src/dist&quot;) {
        include(&quot;**/*.html&quot;, &quot;**/*.png&quot;, &quot;**/*.jpg&quot;)
    }
    from(sourceSets.main.get().output) {
        into(&quot;WEB-INF/classes&quot;)
    }
    into(&quot;WEB-INF/lib&quot;) {
        from(configurations.runtimeClasspath)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意<code>src/dist</code>配置具有嵌套的包含规范：这是子副本规范。当然，您可以根据需要在此处添加内容过滤和重命名。子副本规范仍然是副本规范。</p>
</div>
<div class="paragraph">
<p>上面的示例还演示了如何通过使用子级将文件复制到目标的子目录中<code>into()</code>在一个<code>from()</code>还是一个孩子<code>from()</code>在<code>into()</code> 。两种方法都是可以接受的，但是您可能需要创建并遵循约定以确保各个构建文件之间的一致性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">不要拿你的<code>into()</code>规格混在一起！对于普通副本（一个到文件系统而不是存档），应该始终有<em>一个</em> “根” <code>into()</code>仅指定副本的整体目标目录。任何其他<code>into()</code>应该附有子规范，其路径将相对于根<code>into()</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后要注意的一点是，子副本规范继承了其目标路径，包括其模式，排除模式，复制操作，名称映射和来自其父级的过滤器。因此，请注意放置配置的位置。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:project_copy_method"><a class="anchor" href="#sec:project_copy_method"></a> <a class="link" href="#sec:project_copy_method">在自己的任务中复制文件</a></h5>
<div class="paragraph">
<p>在某些情况下，您可能需要复制文件或目录作为任务的<em>一部分</em> 。例如，基于不受支持的存档格式的自定义存档任务可能要在将文件存档之前将文件复制到临时目录。您仍然想利用Gradle的copy API，但无需引入额外的功能<code>Copy</code>任务。</p>
</div>
<div class="paragraph">
<p>解决方案是使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:copy(org.gradle.api.Action)">Project.copy（org.gradle.api。动作）</a>方法。它的工作方式与<code>Copy</code>通过使用复制规范对其进行配置。这是一个简单的例子：</p>
</div>
<div class="exampleblock">
<div class="title">示例145使用copy（）方法复制文件时不进行最新检查</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyMethod {
    doLast {
        copy {
            from <span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>
            into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/explodedWar</span><span class="delimiter">&quot;</span></span>
            include <span class="string"><span class="delimiter">'</span><span class="content">**/*.html</span><span class="delimiter">'</span></span>
            include <span class="string"><span class="delimiter">'</span><span class="content">**/*.jsp</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;copyMethod&quot;) {
    doLast {
        copy {
            from(&quot;src/main/webapp&quot;)
            into(&quot;$buildDir/explodedWar&quot;)
            include(&quot;**/*.html&quot;)
            include(&quot;**/*.jsp&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例演示了基本语法，还强调了使用<code>copy()</code>方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>的<code>copy()</code>方法不是<a href="#sec:up_to_date_checks">增量的</a> 。这个例子的<code>copyMethod</code>任务将<em>始终</em>执行，因为它没有有关组成任务输入的文件的信息。您必须手动定义任务输入和输出。</p>
</li>
<li>
<p>使用任务作为复制源，即作为参数<code>from()</code> ，则不会在您的任务和该副本源之间建立自动任务依赖关系。因此，如果您使用<code>copy()</code>方法作为任务操作的一部分，必须显式声明所有输入和输出，以获得正确的行为。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例显示了如何通过使用<a href="#sec:task_input_output_runtime_api">动态API进行任务输入和输出</a>来解决这些限制：</p>
</div>
<div class="exampleblock">
<div class="title">例子146。使用带有最新检查的copy（）方法复制文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task copyMethodWithExplicitDependencies {
    <span class="comment">// up-to-date check for inputs, plus add copyTask as dependency</span>
    inputs.files(copyTask)
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">inputs</span><span class="delimiter">&quot;</span></span>)
        .withPathSensitivity(PathSensitivity.RELATIVE)
    outputs.dir(<span class="string"><span class="delimiter">'</span><span class="content">some-dir</span><span class="delimiter">'</span></span>) <span class="comment">// up-to-date check for outputs</span>
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">outputDir</span><span class="delimiter">&quot;</span></span>)
    doLast{
        copy {
            <span class="comment">// Copy the output of copyTask</span>
            from copyTask
            into <span class="string"><span class="delimiter">'</span><span class="content">some-dir</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;copyMethodWithExplicitDependencies&quot;) {
    // up-to-date check for inputs, plus add copyTask as dependency
    inputs.files(copyTask)
        .withPropertyName(&quot;inputs&quot;)
        .withPathSensitivity(PathSensitivity.RELATIVE)
    outputs.dir(&quot;some-dir&quot;) // up-to-date check for outputs
        .withPropertyName(&quot;outputDir&quot;)
    doLast {
        copy {
            // Copy the output of copyTask
            from(copyTask)
            into(&quot;some-dir&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这些限制使得最好使用<code>Copy</code>尽可能的执行任务，因为它内置支持增量构建和任务依赖性推断。这就是为什么<code>copy()</code>此方法供需要复制文件作为其功能一部分的<a href="#custom_tasks">自定义任务</a>使用。使用<code>copy()</code>方法应声明与复制操作相关的必要输入和输出。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:sync_task"><a class="anchor" href="#sec:sync_task"></a> <a class="link" href="#sec:sync_task">使用目录镜像目录和文件集合<code>Sync</code>任务</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Sync.html">同步</a>任务，扩展了<code>Copy</code>任务，将源文件复制到目标目录，然后从目标目录中删除所有未复制的文件。换句话说，它将目录的内容与其源同步。这对于执行诸如安装应用程序，创建归档的分解副本或维护项目依赖项副本之类的操作很有用。</p>
</div>
<div class="paragraph">
<p>这是一个在项目中维护项目运行时依赖项副本的示例。 <code>build/libs</code>目录。</p>
</div>
<div class="exampleblock">
<div class="title">示例147使用同步任务复制依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task libs(<span class="key">type</span>: Sync) {
    from configurations.runtime
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/libs</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Sync&gt;(&quot;libs&quot;) {
    from(configurations[&quot;runtime&quot;])
    into(&quot;$buildDir/libs&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:sync(org.gradle.api.Action)">Project.sync（org.gradle.api在您自己的任务中执行相同的功能</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:sync(org.gradle.api.Action)">。动作）</a>方法。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:archives"><a class="anchor" href="#sec:archives"></a> <a class="link" href="#sec:archives">深入创建档案</a></h4>
<div class="paragraph">
<p>档案本质上是独立的文件系统，Gradle照这样对待它们。这就是为什么使用存档与使用文件和目录非常相似，包括文件权限之类的原因。</p>
</div>
<div class="paragraph">
<p>开箱即用，Gradle支持创建ZIP和TAR归档文件，并且通过扩展支持Java的JAR，WAR和EAR格式-Java的归档文件格式均为ZIP。这些格式中的每一个都有一个相应的任务类型来创建它们： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">Zip</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Tar.html">Tar</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">Jar</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.War.html">War</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ear.Ear.html">Ear</a> 。这些都以相同的方式工作，并且基于复制规范，就像<code>Copy</code>任务。</p>
</div>
<div class="paragraph">
<p>创建存档文件本质上是目的地是隐式的文件副本，即存档文件本身。这是一个基本示例，该示例指定目标存档文件的路径和名称：</p>
</div>
<div class="exampleblock">
<div class="title">实施例148。将目录归档为ZIP</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task packageDistribution(<span class="key">type</span>: Zip) {
    archiveFileName = <span class="string"><span class="delimiter">&quot;</span><span class="content">my-distribution.zip</span><span class="delimiter">&quot;</span></span>
    destinationDirectory = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/dist</span><span class="delimiter">&quot;</span></span>)

    from <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/toArchive</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Zip&gt;(&quot;packageDistribution&quot;) {
    archiveFileName.set(&quot;my-distribution.zip&quot;)
    destinationDirectory.set(file(&quot;$buildDir/dist&quot;))

    from(&quot;$buildDir/toArchive&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在下一节中，您将学习基于约定的档案名称，这可以避免您始终配置目标目录和档案名称。</p>
</div>
<div class="paragraph">
<p>创建档案时，可以使用复制规范的全部功能，这意味着您可以执行内容过滤，文件重命名或上一节中介绍的其他任何操作。一个特别常见的要求是将文件复制到源文件夹中不存在的档案的子目录中，这可以通过以下方式实现<code>into()</code> <a href="#sub:using_child_copy_specifications">子规范</a> 。</p>
</div>
<div class="paragraph">
<p>Gradle当然可以允许您创建任意数量的存档任务，但是要记住，许多基于约定的插件提供了自己的存档任务。例如，Java插件添加了一个<code>jar</code>将项目的已编译类和资源打包到JAR中的任务。这些插件中的许多插件为归档名称以及所使用的复制规范提供了明智的约定。我们建议您尽可能使用这些任务，而不要用自己的任务覆盖它们。</p>
</div>
<div class="sect4">
<h5 id="sec:archive_naming"><a class="anchor" href="#sec:archive_naming"></a> <a class="link" href="#sec:archive_naming">档案命名</a></h5>
<div class="paragraph">
<p>Gradle围绕档案的命名以及根据项目使用的插件在何处创建档案有一些约定。主要约定由<a href="#base_plugin">基本插件提供</a> ，默认情况下，该<a href="#base_plugin">插件会</a>在<code>$buildDir/distributions</code>目录，通常使用<em>[projectName]-[version]。[type]</em>形式的档案名称。</p>
</div>
<div class="paragraph">
<p>以下示例来自一个名为<code>zipProject</code> ，因此<code>myZip</code>任务创建一个名为<code>zipProject-1.0.zip</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例149创建ZIP存档</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">base</span><span class="delimiter">'</span></span>
}

version = <span class="float">1.0</span>

task myZip(<span class="key">type</span>: Zip) {
    from <span class="string"><span class="delimiter">'</span><span class="content">somedir</span><span class="delimiter">'</span></span>

    doLast {
        println archiveFileName.get()
        println relativePath(destinationDirectory)
        println relativePath(archiveFile)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    base
}

version = &quot;1.0&quot;

tasks.register&lt;Zip&gt;(&quot;myZip&quot;) {
    from(&quot;somedir&quot;)

    doLast {
        println(archiveFileName.get())
        println(relativePath(destinationDirectory))
        println(relativePath(archiveFile))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q myZip</code></strong></div>
<div class="content">
<pre>&gt; gradle -q myZip
zipProject-1.0.zip
build/distributions
build/distributions/zipProject-1.0.zip</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，归档文件的名称<em>并非</em>来自创建归档文件的任务的名称。</p>
</div>
<div class="paragraph">
<p>如果要更改生成的存档文件的名称和位置，则可以为<code>archiveFileName</code>和<code>destinationDirectory</code>相应任务的属性。这些优先于其他适用的约定。</p>
</div>
<div class="paragraph">
<p>或者，您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html#org.gradle.api.tasks.bundling.AbstractArchiveTask:archiveFileName">AbstractArchiveTask.getArchiveFileName（）</a>提供的默认存档名称模式： <em>[archiveBaseName]-[archiveAppendix]-[archiveVersion]-[archiveClassifier]。[archiveExtension]</em> 。如果需要，可以分别在任务上设置每个属性。请注意，基本插件将项目名称的约定用于<em>archiveBaseName</em> ，将项目版本的<em>约定</em>用于<em>archiveVersion</em> ，将存档类型的<em>约定</em>用于<em>archiveExtension</em> 。它不提供其他属性的值。</p>
</div>
<div class="paragraph">
<p>此示例（与上述项目来自同一项目）仅配置了<code>archiveBaseName</code>属性，覆盖项目名称的默认值：</p>
</div>
<div class="exampleblock">
<div class="title">示例150归档任务的配置-自定义归档名称</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task myCustomZip(<span class="key">type</span>: Zip) {
    archiveBaseName = <span class="string"><span class="delimiter">'</span><span class="content">customName</span><span class="delimiter">'</span></span>
    from <span class="string"><span class="delimiter">'</span><span class="content">somedir</span><span class="delimiter">'</span></span>

    doLast {
        println archiveFileName.get()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Zip&gt;(&quot;myCustomZip&quot;) {
    archiveBaseName.set(&quot;customName&quot;)
    from(&quot;somedir&quot;)

    doLast {
        println(archiveFileName.get())
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q myCustomZip</code></strong></div>
<div class="content">
<pre>&gt; gradle -q myCustomZip
customName-1.0.zip</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以覆盖默认值<code>archiveBaseName</code>使用<em>project</em>属性生成的<em>所有</em>归档任务的值<code>archivesBaseName</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例151归档任务的配置-附录和分类器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">base</span><span class="delimiter">'</span></span>
}

version = <span class="float">1.0</span>
archivesBaseName = <span class="string"><span class="delimiter">&quot;</span><span class="content">gradle</span><span class="delimiter">&quot;</span></span>

task myZip(<span class="key">type</span>: Zip) {
    from <span class="string"><span class="delimiter">'</span><span class="content">somedir</span><span class="delimiter">'</span></span>
}

task myOtherZip(<span class="key">type</span>: Zip) {
    archiveAppendix = <span class="string"><span class="delimiter">'</span><span class="content">wrapper</span><span class="delimiter">'</span></span>
    archiveClassifier = <span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>
    from <span class="string"><span class="delimiter">'</span><span class="content">somedir</span><span class="delimiter">'</span></span>
}

task echoNames {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Project name: </span><span class="inline"><span class="inline-delimiter">${</span>project.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        println myZip.archiveFileName.get()
        println myOtherZip.archiveFileName.get()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    base
}

version = &quot;1.0&quot;
base.archivesBaseName = &quot;gradle&quot;

val myZip by tasks.registering(Zip::class) {
    from(&quot;somedir&quot;)
}

val myOtherZip by tasks.registering(Zip::class) {
    archiveAppendix.set(&quot;wrapper&quot;)
    archiveClassifier.set(&quot;src&quot;)
    from(&quot;somedir&quot;)
}

tasks.register(&quot;echoNames&quot;) {
    doLast {
        println(&quot;Project name: ${project.name}&quot;)
        println(myZip.get().archiveFileName.get())
        println(myOtherZip.get().archiveFileName.get())
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q echoNames</code></strong></div>
<div class="content">
<pre>&gt; gradle -q echoNames
Project name: zipProject
gradle-1.0.zip
gradle-wrapper-1.0-src.zip</pre>
</div>
</div>
<div class="paragraph">
<p>您可以在<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html">AbstractArchiveTask</a>的API文档中找到所有可能的存档任务属性，但是我们还在这里总结了主要的存档任务属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>archiveFileName</code> - <code>Property<String></code> ，默认值：<code><em>archiveBaseName</em>-<em>archiveAppendix</em>-<em>archiveVersion</em>-<em>archiveClassifier</em>.<em>archiveExtension</em></code></dt>
<dd>
<p>生成的档案的完整文件名。如果默认值中的任何属性为空，则会删除其“-”分隔符。</p>
</dd>
<dt class="hdlist1"><code>archiveFile</code> - <code>Provider<RegularFile></code> ， <em>只读</em> ，默认值：<code><em>destinationDirectory</em>/<em>archiveFileName</em></code></dt>
<dd>
<p>生成的存档的绝对文件路径。</p>
</dd>
<dt class="hdlist1"><code>destinationDirectory</code> - <code>DirectoryProperty</code> ，默认值：取决于档案类型</dt>
<dd>
<p>将生成的归档文件放入的目标目录。默认情况下，JAR和WAR进入<code>$buildDir/libs</code> 。ZIP和TAR进入<code>$buildDir/distributions</code> 。</p>
</dd>
<dt class="hdlist1"><code>archiveBaseName</code> - <code>Property<String></code> ，默认值：<code><em>project.name</em></code></dt>
<dd>
<p>归档文件名称的基本名称部分，通常是项目名称或它所包含内容的其他描述性名称。</p>
</dd>
<dt class="hdlist1"><code>archiveAppendix</code> - <code>Property<String></code> ，默认值：<code>null</code></dt>
<dd>
<p>归档文件名称的附录部分，紧随基本名称之后。它通常用于区分不同形式的内容，例如代码和文档，或最小分发与完整或完整分发。</p>
</dd>
<dt class="hdlist1"><code>archiveVersion</code> - <code>Property<String></code> ，默认值：<code><em>project.version</em></code></dt>
<dd>
<p>归档文件名称的版本部分，通常以正常项目或产品版本的形式。</p>
</dd>
<dt class="hdlist1"><code>archiveClassifier</code> - <code>Property<String></code> ，默认值：<code>null</code></dt>
<dd>
<p>存档文件名的分类器部分。通常用于区分针对不同平台的档案。</p>
</dd>
<dt class="hdlist1"><code>archiveExtension</code> - <code>Property<String></code> ，默认值：取决于存档类型和压缩类型</dt>
<dd>
<p>存档的文件扩展名。默认情况下，此设置基于存档任务类型和压缩类型（如果要创建TAR）。将是以下之一： <code>zip</code> ， <code>jar</code> ， <code>war</code> ， <code>tar</code> ， <code>tgz</code>要么<code>tbz2</code> 。当然，您可以根据需要将其设置为自定义扩展名。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="sec:sharing_content_between_multiple_archives"><a class="anchor" href="#sec:sharing_content_between_multiple_archives"></a> <a class="link" href="#sec:sharing_content_between_multiple_archives">在多个档案之间共享内容</a></h5>
<div class="paragraph">
<p><a href="#sub:sharing_copy_specs">如前所述</a> ，您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:copySpec(org.gradle.api.Action)">Project.copySpec（org.gradle.api。动作）</a>方法以在档案之间共享内容。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:reproducible_archives"><a class="anchor" href="#sec:reproducible_archives"></a> <a class="link" href="#sec:reproducible_archives">可复制的构建</a></h5>
<div class="paragraph">
<p>有时，需要在不同的计算机上逐字节地完全相同地创建归档。您希望确保无论在何时何地从源代码构建工件都可以产生相同的结果。这对于诸如<a href="https://reproducible-builds.org/">reproducible-builds.org之类的</a>项目是必需的。</p>
</div>
<div class="paragraph">
<p>由于一个存档中文件的顺序受基础文件系统的影响，因此复制相同的逐字节存档会带来一些挑战。每次从源代码构建ZIP，TAR，JAR，WAR或EAR时，归档文件中文件的顺序可能会更改。时间戳不同的文件也会导致不同版本的存档之间存在差异。Gradle附带的所有<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html">AbstractArchiveTask</a> （例如Jar，Zip）任务都支持生成可复制的存档。</p>
</div>
<div class="paragraph">
<p>例如，使<code>Zip</code>任务可重现，您需要将<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:reproducibleFileOrder">Zip.isReproducibleFileOrder（）</a>设置为<code>true</code>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:preserveFileTimestamps">Zip.isPreserveFileTimestamps（）</a>到<code>false</code> 。为了使您的构建中的所有存档任务都可重现，请考虑将以下配置添加到构建文件中：</p>
</div>
<div class="exampleblock">
<div class="title">示例152激活可复制的档案</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = <span class="predefined-constant">false</span>
    reproducibleFileOrder = <span class="predefined-constant">true</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType&lt;AbstractArchiveTask&gt;().configureEach {
    isPreserveFileTimestamps = false
    isReproducibleFileOrder = true
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通常，您将需要发布档案，以便可以从另一个项目中使用它。<a href="artifact_management.html#artifact_management">旧版发行中</a>介绍了此过程。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="plugins"><a class="anchor" href="#plugins"></a> <a class="link" href="#plugins">使用Gradle插件</a></h3>
<div class="paragraph">
<p>Gradle的核心故意为现实世界的自动化提供很少的支持。所有有用的功能（如编译Java代码的功能）都由<em>plugins</em>添加。插件添加新任务（例如<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a> ），域对象（例如<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSet.html">SourceSet</a> ），约定（例如Java源位于<code>src/main/java</code> ），以及扩展核心对象和其他插件的对象。</p>
</div>
<div class="paragraph">
<p>在本章中，我们讨论如何使用插件以及围绕插件的术语和概念。</p>
</div>
<div class="sect3">
<h4 id="sec:what_plugins_do"><a class="anchor" href="#sec:what_plugins_do"></a> <a class="link" href="#sec:what_plugins_do">插件做什么</a></h4>
<div class="paragraph">
<p>将插件应用于项目可以使插件扩展项目的功能。它可以执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>扩展Gradle模型（例如，添加可以配置的新DSL元素）</p>
</li>
<li>
<p>根据约定配置项目（例如，添加新任务或配置合理的默认值）</p>
</li>
<li>
<p>应用特定的配置（例如，添加组织存储库或强制执行标准）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过应用插件，而不是向项目构建脚本添加逻辑，我们可以获得许多好处。应用插件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>促进重用并减少跨多个项目维护相似逻辑的开销</p>
</li>
<li>
<p>允许更高程度的模块化，增强可理解性和组织性</p>
</li>
<li>
<p>封装命令式逻辑，并允许构建脚本尽可能地具有声明性</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:types_of_plugins"><a class="anchor" href="#sec:types_of_plugins"></a> <a class="link" href="#sec:types_of_plugins">插件类型</a></h4>
<div class="paragraph">
<p>Gradle中有两种通用类型的插件， <em>脚本</em>插件和<em>二进制</em>插件。脚本插件是其他构建脚本，可以进一步配置构建，并通常采用声明性方法来操纵构建。尽管可以将它们外部化并从远程位置进行访问，但它们通常在构建中使用。二进制插件是实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">插件</a>接口并采用编程方法来操纵构建的类。二进制插件可以驻留在构建脚本中，项目层次结构中或插件罐的外部。</p>
</div>
<div class="paragraph">
<p>插件通常起初是脚本插件（因为它们易于编写），然后，随着代码变得更有价值，它被迁移到可以轻松测试并在多个项目或组织之间共享的二进制插件。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:using_plugins"><a class="anchor" href="#sec:using_plugins"></a> <a class="link" href="#sec:using_plugins">使用插件</a></h4>
<div class="paragraph">
<p>要使用封装在插件中的构建逻辑，Gradle需要执行两个步骤。首先，它需要<em>解析</em>插件，然后需要<em>将</em>插件应用于目标（通常是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project）</a> 。</p>
</div>
<div class="paragraph">
<p><em>解决</em>插件意味着找到包含给定插件的jar的正确版本，并将其添加为脚本类路径。插件解决后，即可在构建脚本中使用其API。脚本插件是自解析的，因为它们是从应用它们时提供的特定文件路径或URL解析的。作为Gradle发行的一部分提供的核心二进制插件会自动解决。</p>
</div>
<div class="paragraph">
<p><em>应用</em>插件意味着在要使用插件增强的项目上实际执行插件的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html#apply-T-">Plugin.apply（T）</a> 。应用插件是<em>幂等的</em> 。也就是说，您可以安全地多次应用任何插件而不会产生副作用。</p>
</div>
<div class="paragraph">
<p>使用插件的最常见用例是解析插件并将其应用于当前项目。由于这是一个常见的用例，因此建议构建作者使用<a href="#sec:plugins_block">插件DSL</a>一步解决和应用插件。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:script_plugins"><a class="anchor" href="#sec:script_plugins"></a> <a class="link" href="#sec:script_plugins">脚本插件</a></h4>
<div class="exampleblock">
<div class="title">示例153。应用脚本插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">from</span>: <span class="string"><span class="delimiter">'</span><span class="content">other.gradle</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(from = &quot;other.gradle.kts&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>脚本插件会自动解决，可以从本地文件系统或远程位置的脚本中应用。文件系统位置是相对于项目目录的，而远程脚本位置是通过HTTP URL指定的。可以将多个脚本插件（任意一种形式）应用于给定目标。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:binary_plugins"><a class="anchor" href="#sec:binary_plugins"></a> <a class="link" href="#sec:binary_plugins">二进制插件</a></h4>
<div class="paragraph">
<p>您可以通过<em>插件的插件ID来</em>应用插件， <em>插件ID</em>是<em>插件</em>的全局唯一标识符或名称。Core Gradle插件的特殊之处在于它们提供了短名称，例如<code>'java'</code>用于核心<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/JavaPlugin.html">JavaPlugin</a> 。所有其他二进制插件必须使用插件ID的完全限定形式（例如<code>com.github.foo.bar</code> ），尽管某些旧版插件可能仍会使用简短，不合格的格式。放置插件ID的位置取决于您使用的是<a href="#sec:plugins_block">插件DSL</a>还是<a href="#sec:old_plugin_application">buildscript块。</a></p>
</div>
<div class="sect4">
<h5 id="sec:binary_plugin_locations"><a class="anchor" href="#sec:binary_plugin_locations"></a> <a class="link" href="#sec:binary_plugin_locations">二进制插件的位置</a></h5>
<div class="paragraph">
<p>插件就是实现了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">Plugin</a>接口的任何类。Gradle提供了核心插件（例如<code>JavaPlugin</code> ）作为其分发的一部分，这意味着它们会自动解决。但是，非核心二进制插件需要先解决，然后才能应用。这可以通过多种方式实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用插件DSL包括来自插件门户或<a href="#sec:custom_plugin_repositories">自定义存储库</a>的插件（请参阅<a href="#sec:plugins_block">使用插件DSL应用插件</a> ）。</p>
</li>
<li>
<p>包括来自定义为buildscript依赖项的外部jar中的插件（请参阅<a href="#sec:applying_plugins_buildscript">使用buildscript块应用插件</a> ）。</p>
</li>
<li>
<p>在项目的buildSrc目录下将插件定义为源文件（请参阅<a href="#sec:build_sources">使用buildSrc提取功能逻辑</a> ）。</p>
</li>
<li>
<p>在构建脚本中将插件定义为内联类声明。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关定义自己的插件的更多信息，请参见“ <a href="#custom_plugins">自定义插件”</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:plugins_block"><a class="anchor" href="#sec:plugins_block"></a> <a class="link" href="#sec:plugins_block">通过插件DSL应用插件</a></h5>
<div class="paragraph">
<p>插件DSL提供了一种声明插件依赖关系的简洁方便的方法。它与<a href="http://plugins.gradle.org">Gradle插件门户</a>一起使用，可轻松访问核心插件和社区插件。插件DSL块配置<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/use/PluginDependenciesSpec.html">PluginDependenciesSpec</a>的实例。</p>
</div>
<div class="paragraph">
<p>要应用核心插件，可以使用简称：</p>
</div>
<div class="exampleblock">
<div class="title">示例154应用核心插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要从门户网站应用社区插件，必须使用完全限定的插件ID：</p>
</div>
<div class="exampleblock">
<div class="title">示例155应用社区插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">com.jfrog.bintray</span><span class="delimiter">'</span></span> version <span class="string"><span class="delimiter">'</span><span class="content">0.4.1</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;com.jfrog.bintray&quot;) version &quot;0.4.1&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关使用插件DSL的更多信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/use/PluginDependenciesSpec.html">PluginDependenciesSpec</a> 。</p>
</div>
<div class="sect5">
<h6 id="plugins_dsl_limitations"><a class="anchor" href="#plugins_dsl_limitations"></a> <a class="link" href="#plugins_dsl_limitations">插件DSL的局限性</a></h6>
<div class="paragraph">
<p>这种将插件添加到项目中的方法远不止是更方便的语法。插件DSL的处理方式使Gradle可以非常早，非常迅速地确定正在使用的插件。这使Gradle可以做一些聪明的事情，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>优化插件类的加载和重用。</p>
</li>
<li>
<p>允许不同的插件使用不同版本的依赖项。</p>
</li>
<li>
<p>向编辑者提供有关构建脚本中潜在属性和值的详细信息，以提供编辑帮助。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这要求在执行其余构建脚本之前，以Gradle可以轻松，快速提取的方式指定插件。它还要求要使用的插件的定义一定是静态的。</p>
</div>
<div class="paragraph">
<p>两者之间有一些主要区别<code>plugins {}</code>阻止机制和“传统” <code>apply()</code>方法机制。还有一些约束，其中一些是暂时的限制，而该机制仍在开发中，而某些则是新方法固有的。</p>
</div>
<div class="sect6">
<h7 id="sec:constrained_syntax"><a class="anchor" href="#sec:constrained_syntax"></a> <a class="link" href="#sec:constrained_syntax">约束语法</a></h7>
<div class="paragraph">
<p>的<code>plugins {}</code>块不支持任意代码。它是受约束的，以便具有幂等性（每次都产生相同的结果）并且没有副作用（对于Gradle可以随时执行是安全的）。</p>
</div>
<div class="paragraph">
<p>形式是：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="error">«</span>plugin id<span class="error">»</span>                                            // <b class="conum">(1)</b>
    id <span class="error">«</span>plugin id<span class="error">»</span> version <span class="error">«</span>plugin version<span class="error">»</span> [apply <span class="error">«</span><span class="predefined-constant">false</span><span class="error">»</span>]   // <b class="conum">(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>用于核心Gradle插件或构建脚本已可用的插件</p>
</li>
<li>
<p>用于需要解决的二进制Gradle插件</p>
</li>
</ol>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `«plugin id»`                                             // <b class="conum">(1)</b>
    id(«plugin id»)                                           // <b class="conum">(2)</b>
    id(«plugin id») version «plugin version» [apply «false»]  // <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>用于核心Gradle插件</p>
</li>
<li>
<p>用于核心Gradle插件或构建脚本已可用的插件</p>
</li>
<li>
<p>用于需要解决的二进制Gradle插件</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph multi-language-text lang-groovy">
<p>哪里<code>«plugin id»</code>和<code>«plugin version»</code>必须是常量，文字，字符串，并且<code>apply</code>用一个语句<code>boolean</code>可用于禁用立即应用插件的默认行为（例如，您只想在<code>subprojects</code> ）。不允许其他声明；它们的存在将导致编译错误。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>哪里<code>«plugin id»</code> ， 如果<code>#1</code>是静态的Kotlin扩展属性，以核心插件ID命名；并且在情况下<code>#2</code>和<code>#3</code>是一个字符串。
<code>«plugin version»</code>也是一个字符串。的<code>apply</code>用一个语句<code>boolean</code>可用于禁用立即应用插件的默认行为（例如，您只想在<code>subprojects</code> ）。</p>
</div>
<div class="paragraph">
<p>的<code>plugins {}</code> block也必须是buildscript中的顶层语句。它不能嵌套在另一个构造中（例如，if语句或for循环）。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:build_scripts_only"><a class="anchor" href="#sec:build_scripts_only"></a> <a class="link" href="#sec:build_scripts_only">只能在构建脚本中使用</a></h7>
<div class="paragraph">
<p>的<code>plugins {}</code>块当前只能在项目的构建脚本中使用。它不能在脚本插件，settings.gradle文件或init脚本中使用。</p>
</div>
<div class="paragraph">
<p><em>Gradle的未来版本将删除此限制。</em></p>
</div>
<div class="paragraph">
<p>如果限制<code>plugins {}</code>块是禁止的，建议的方法是使用<a href="#sec:applying_plugins_buildscript">buildscript {}块</a>来应用插件。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:subprojects_plugins_dsl"><a class="anchor" href="#sec:subprojects_plugins_dsl"></a> <a class="link" href="#sec:subprojects_plugins_dsl">将插件应用于子项目</a></h6>
<div class="paragraph">
<p>如果您使用的是<a href="#multi_project_builds">多项目构建</a> ，则可能要将插件应用于<a href="#multi_project_builds">构建</a>中的部分或全部子项目，而不是将插件应用于<code>root</code>要么<code>master</code>项目。的默认行为<code>plugins {}</code>阻止是立即<code>resolve</code> <em>和</em> <code>apply</code>插件。但是，您可以使用<code>apply false</code>告诉Gradle不要将插件应用于当前项目的语法，然后使用<code>apply plugin: «plugin id»</code>在里面<code>subprojects</code>阻止或使用<code>plugins {}</code>阻止子项目中的构建脚本：</p>
</div>
<div class="exampleblock">
<div class="title">例子156。仅在某些子项目上应用插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">include <span class="string"><span class="delimiter">'</span><span class="content">helloA</span><span class="delimiter">'</span></span>
include <span class="string"><span class="delimiter">'</span><span class="content">helloB</span><span class="delimiter">'</span></span>
include <span class="string"><span class="delimiter">'</span><span class="content">goodbyeC</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.hello</span><span class="delimiter">'</span></span> version <span class="string"><span class="delimiter">'</span><span class="content">1.0.0</span><span class="delimiter">'</span></span> apply <span class="predefined-constant">false</span>
    id <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.goodbye</span><span class="delimiter">'</span></span> version <span class="string"><span class="delimiter">'</span><span class="content">1.0.0</span><span class="delimiter">'</span></span> apply <span class="predefined-constant">false</span>
}

subprojects {
    <span class="keyword">if</span> (name.startsWith(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>)) {
        apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.hello</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">再见C / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.goodbye</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">include(&quot;helloA&quot;)
include(&quot;helloB&quot;)
include(&quot;goodbyeC&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;org.gradle.sample.hello&quot;) version &quot;1.0.0&quot; apply false
    id(&quot;org.gradle.sample.goodbye&quot;) version &quot;1.0.0&quot; apply false
}

subprojects {
    if (name.startsWith(&quot;hello&quot;)) {
        apply(plugin = &quot;org.gradle.sample.hello&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">再见C / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;org.gradle.sample.goodbye&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果你再跑<code>gradle hello</code>您会看到只有helloA和helloB子项目应用了hello插件。</p>
</div>
<div class="exampleblock">
<div class="title">示例157输出<code>gradle hello</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>&gt; gradle hello
:helloA:hello
:helloB:hello
Hello!
Hello!

BUILD SUCCEEDED</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:buildsrc_plugins_dsl"><a class="anchor" href="#sec:buildsrc_plugins_dsl"></a> <a class="link" href="#sec:buildsrc_plugins_dsl">从<em>buildSrc</em>目录应用插件</a></h6>
<div class="paragraph">
<p>您可以应用驻留在项目的<em>buildSrc</em>目录中的插件，只要它们具有已定义的ID即可。以下示例显示了如何绑定插件实现类- <code>my.MyPlugin</code> —在<em>buildSrc中</em>定义为ID“ my-plugin”：</p>
</div>
<div class="exampleblock">
<div class="title">例子158。用ID定义一个buildSrc插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">java-gradle-plugin</span><span class="delimiter">'</span></span>
}

gradlePlugin {
    plugins {
        myPlugins {
            id = <span class="string"><span class="delimiter">'</span><span class="content">my-plugin</span><span class="delimiter">'</span></span>
            implementationClass = <span class="string"><span class="delimiter">'</span><span class="content">my.MyPlugin</span><span class="delimiter">'</span></span>
        }
    }
}

dependencies {
    compileOnly gradleApi()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
    `java-gradle-plugin`
}

gradlePlugin {
    plugins {
        create(&quot;myPlugins&quot;) {
            id = &quot;my-plugin&quot;
            implementationClass = &quot;my.MyPlugin&quot;
        }
    }
}

dependencies {
    compileOnly(gradleApi())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后可以按常规方式通过ID应用插件：</p>
</div>
<div class="exampleblock">
<div class="title">例子159。从buildSrc应用插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">my-plugin</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;my-plugin&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:plugin_management"><a class="anchor" href="#sec:plugin_management"></a> <a class="link" href="#sec:plugin_management">插件管理</a></h6>
<div class="paragraph">
<p>的<code>pluginManagement {}</code>区块只能出现在<code>settings.gradle</code>文件，它必须是文件或<a href="#init_scripts">初始化脚本中</a>的第一个块。</p>
</div>
<div class="exampleblock">
<div class="title">例子160。按项目和全局配置pluginManagement</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">pluginManagement {
    plugins {
    }
    resolutionStrategy {
    }
    repositories {
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">初始化等级</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">settingsEvaluated { settings -&gt;
    settings.pluginManagement {
        plugins {
        }
        resolutionStrategy {
        }
        repositories {
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">pluginManagement {
    plugins {
    }
    resolutionStrategy {
    }
    repositories {
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">init.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">settingsEvaluated { settings -&gt;
    settings.pluginManagement {
        plugins {
        }
        resolutionStrategy {
        }
        repositories {
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="sec:custom_plugin_repositories"><a class="anchor" href="#sec:custom_plugin_repositories"></a> <a class="link" href="#sec:custom_plugin_repositories">自定义插件存储库</a></h7>
<div class="paragraph">
<p>默认情况下， <code>plugins {}</code> DSL从公共<a href="https://plugins.gradle.org">Gradle插件门户</a>解析插件<a href="https://plugins.gradle.org">。</a> 许多构建作者还希望从私有Maven或Ivy存储库中解析插件，因为这些插件包含专有的实现细节，或者只是为了更好地控制其构建中可用的插件。</p>
</div>
<div class="paragraph">
<p>要指定自定义插件存储库，请使用<code>repositories {}</code>挡在里面<code>pluginManagement {}</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例161示例：使用来自自定义插件存储库的插件。</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">pluginManagement {
    repositories {
        maven {
            url <span class="string"><span class="delimiter">'</span><span class="content">../maven-repo</span><span class="delimiter">'</span></span>
        }
        gradlePluginPortal()
        ivy {
            url <span class="string"><span class="delimiter">'</span><span class="content">../ivy-repo</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">pluginManagement {
    repositories {
        maven(url = &quot;../maven-repo&quot;)
        gradlePluginPortal()
        ivy(url = &quot;../ivy-repo&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这告诉Gradle首先查看Maven存储库中的<code>../maven-repo</code>解决插件时，如果没有在Maven存储库中找到插件，请检查Gradle插件门户。如果您不想搜索Gradle插件门户，请省略<code>gradlePluginPortal()</code>线。最后，位于Ivy的存储库<code>../ivy-repo</code>将被检查。</p>
</div>
</div>
<div class="sect6">
<h7 id="sec:plugin_version_management"><a class="anchor" href="#sec:plugin_version_management"></a> <a class="link" href="#sec:plugin_version_management">插件版本管理</a></h7>
<div class="paragraph">
<p>一种<code>plugins {}</code>挡在里面<code>pluginManagement {}</code>允许将构建的所有插件版本定义在一个位置。然后，可以通过ID将插件按ID应用于任何构建脚本<code>plugins {}</code>块。</p>
</div>
<div class="paragraph">
<p>以这种方式设置插件版本的好处是<code>pluginManagement.plugins {}</code>与构建脚本的<a href="#sec:constrained_syntax">约束语法不同</a> <code>plugins {}</code>块。这允许插件版本从<code>gradle.properties</code> ，或通过其他机制加载。</p>
</div>
<div class="exampleblock">
<div class="title">实施例162。示例：通过管理插件版本<code>pluginManagement</code> 。</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">pluginManagement {
  plugins {
        id <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.hello</span><span class="delimiter">'</span></span> version <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>helloPluginVersion<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.hello</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">helloPluginVersion=1.0.0</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">pluginManagement {
  val helloPluginVersion: String by settings
  plugins {
    id(&quot;org.gradle.sample.hello&quot;) version &quot;${helloPluginVersion}&quot;
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;org.gradle.sample.hello&quot;)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">helloPluginVersion=1.0.0</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>插件版本从<code>gradle.properties</code>并在设置脚本中进行了配置，允许将该插件添加到任何项目中而无需指定版本。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:plugin_resolution_rules"><a class="anchor" href="#sec:plugin_resolution_rules"></a> <a class="link" href="#sec:plugin_resolution_rules">插件解析规则</a></h6>
<div class="paragraph">
<p>插件解析规则可让您修改在<code>plugins {}</code>块，例如更改请求的版本或显式指定实现工件坐标。</p>
</div>
<div class="paragraph">
<p>要添加解析规则，请使用<code>resolutionStrategy {}</code>在 - 的里面<code>pluginManagement {}</code>块：</p>
</div>
<div class="exampleblock">
<div class="title">示例163。插件解析策略。</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">pluginManagement {
    resolutionStrategy {
        eachPlugin {
            <span class="keyword">if</span> (requested.id.namespace == <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>) {
                useModule(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample:sample-plugins:1.0.0</span><span class="delimiter">'</span></span>)
            }
        }
    }
    repositories {
        maven {
            url <span class="string"><span class="delimiter">'</span><span class="content">../maven-repo</span><span class="delimiter">'</span></span>
        }
        gradlePluginPortal()
        ivy {
            url <span class="string"><span class="delimiter">'</span><span class="content">../ivy-repo</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">pluginManagement {
    resolutionStrategy {
        eachPlugin {
            if (requested.id.namespace == &quot;org.gradle.sample&quot;) {
                useModule(&quot;org.gradle.sample:sample-plugins:1.0.0&quot;)
            }
        }
    }
    repositories {
        maven {
            url = uri(&quot;../maven-repo&quot;)
        }
        gradlePluginPortal()
        ivy {
            url = uri(&quot;../ivy-repo&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这告诉Gradle使用指定的插件实现构件，而不是使用其从插件ID到Maven / Ivy坐标的内置默认映射。</p>
</div>
<div class="paragraph">
<p>自定义Maven和Ivy插件存储库除了实际实现插件的<a href="#sec:plugin_markers">工件外</a> ，还必须包含<a href="#sec:plugin_markers">插件标记工件</a> 。有关将插件发布到自定义存储库的更多信息，请阅读<a href="#java_gradle_plugin">Gradle Plugin Development Plugin</a> 。</p>
</div>
<div class="paragraph">
<p>有关使用以下内容的完整文档，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/management/PluginManagementSpec.html">PluginManagementSpec</a> <code>pluginManagement {}</code>块。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:plugin_markers"><a class="anchor" href="#sec:plugin_markers"></a> <a class="link" href="#sec:plugin_markers">插件标记工件</a></h5>
<div class="paragraph">
<p>自从<code>plugins {}</code> DSL块仅允许通过其全局唯一插件声明插件<code>id</code>和<code>version</code>属性，Gradle需要一种方法来查找插件实现工件的坐标。为此，Gradle将查找具有以下坐标的插件标记工件<code>plugin.id:plugin.id.gradle.plugin:plugin.version</code> 。该标记需要依赖于实际的插件实现。这些标记的发布由<a href="#java_gradle_plugin">java-gradle-plugin</a>自动执行。</p>
</div>
<div class="paragraph">
<p>例如，以下完整示例来自<code>sample-plugins</code>项目展示了如何发布<code>org.gradle.sample.hello</code>插件和一个<code>org.gradle.sample.goodbye</code>使用<a href="#java_gradle_plugin">java-gradle-plugin</a> ， <a href="#publishing_maven">maven-publish</a>插件和<a href="#publishing_ivy">ivy-publish</a>插件的组合将插件同时连接到Ivy和Maven存储库。</p>
</div>
<div class="exampleblock">
<div class="title">示例164。完整的插件发布示例</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-gradle-plugin</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">maven-publish</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">ivy-publish</span><span class="delimiter">'</span></span>
}

group <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>
version <span class="string"><span class="delimiter">'</span><span class="content">1.0.0</span><span class="delimiter">'</span></span>

gradlePlugin {
    plugins {
        hello {
            id = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.hello</span><span class="delimiter">'</span></span>
            implementationClass = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.hello.HelloPlugin</span><span class="delimiter">'</span></span>
        }
        goodbye {
            id = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.goodbye</span><span class="delimiter">'</span></span>
            implementationClass = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.goodbye.GoodbyePlugin</span><span class="delimiter">'</span></span>
        }
    }
}

publishing {
    repositories {
        maven {
            url <span class="string"><span class="delimiter">'</span><span class="content">../../consuming/maven-repo</span><span class="delimiter">'</span></span>
        }
        ivy {
            url <span class="string"><span class="delimiter">'</span><span class="content">../../consuming/ivy-repo</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-gradle-plugin`
    `maven-publish`
    `ivy-publish`
}

group = &quot;org.gradle.sample&quot;
version = &quot;1.0.0&quot;

gradlePlugin {
    plugins {
        create(&quot;hello&quot;) {
            id = &quot;org.gradle.sample.hello&quot;
            implementationClass = &quot;org.gradle.sample.hello.HelloPlugin&quot;
        }
        create(&quot;goodbye&quot;) {
            id = &quot;org.gradle.sample.goodbye&quot;
            implementationClass = &quot;org.gradle.sample.goodbye.GoodbyePlugin&quot;
        }
    }
}

publishing {
    repositories {
        maven {
            url = uri(&quot;../../consuming/maven-repo&quot;)
        }
        ivy {
            url = uri(&quot;../../consuming/ivy-repo&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>跑步<code>gradle publish</code>示例目录中的导致以下回购布局存在：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/pluginMarkers.png" alt="pluginMarkers">
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:old_plugin_application"><a class="anchor" href="#sec:old_plugin_application"></a> <a class="link" href="#sec:old_plugin_application">旧版插件应用</a></h5>
<div class="paragraph">
<p>随着<a href="#sec:plugins_block">插件DSL</a>的引入，用户几乎没有理由使用应用插件的旧方法。如果构建作者由于当前工作方式的限制而无法使用插件DSL，则在此进行记录。</p>
</div>
<div class="sect5">
<h6 id="sec:applying_binary_plugins"><a class="anchor" href="#sec:applying_binary_plugins"></a> <a class="link" href="#sec:applying_binary_plugins">应用二进制插件</a></h6>
<div class="exampleblock">
<div class="title">示例165应用二进制插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(plugin = &quot;java&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用<em>插件ID</em>来应用<em>插件</em> 。在上述情况下，我们使用简称“ <code>java</code>以应用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/JavaPlugin.html">JavaPlugin</a> 。</p>
</div>
<div class="paragraph">
<p>除了使用插件ID，还可以通过简单地指定插件的类来应用插件：</p>
</div>
<div class="exampleblock">
<div class="title">例子166。按类型应用二进制插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: JavaPlugin</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply&lt;JavaPlugin&gt;()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>JavaPlugin</code>上面示例中的符号是指<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/JavaPlugin.html">JavaPlugin</a> 。严格来说，此类无需作为<code>org.gradle.api.plugins</code>软件包会自动导入所有构建脚本中（请参阅<a href="#script-default-imports">默认导入</a> ）。</p>
</div>
<div class="paragraph multi-language-text lang-groovy">
<p>此外，没有必要附加<code>.class</code>在Groovy中标识类文字，就像在Java中一样。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>此外，还需要附加一个<code>::class</code>后缀来标识Kotlin中的类文字，而不是<code>.class</code>在Java中。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:applying_plugins_buildscript"><a class="anchor" href="#sec:applying_plugins_buildscript"></a> <a class="link" href="#sec:applying_plugins_buildscript">应用带有buildscript块的插件</a></h6>
<div class="paragraph">
<p>通过将插件添加到构建脚本类路径中，然后应用该插件，可以将已发布为外部jar文件的二进制插件添加到项目中。外部jar可以使用以下命令添加到构建脚本类路径中： <code>buildscript {}</code>如<a href="#sec:build_script_external_dependencies">构建脚本的外部依存关系中所述</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子167。使用带有buildscript块的插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath <span class="string"><span class="delimiter">'</span><span class="content">com.jfrog.bintray.gradle:gradle-bintray-plugin:0.4.1</span><span class="delimiter">'</span></span>
    }
}

apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">com.jfrog.bintray</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath(&quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:0.4.1&quot;)
    }
}

apply(plugin = &quot;com.jfrog.bintray&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:finding_community_plugins"><a class="anchor" href="#sec:finding_community_plugins"></a> <a class="link" href="#sec:finding_community_plugins">寻找社区插件</a></h4>
<div class="paragraph">
<p>Gradle有一个充满活力的插件开发人员社区，他们为各种功能贡献插件。Gradle <a href="https://plugins.gradle.org">插件门户</a>提供了一个用于搜索和浏览社区插件的界面。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:more_on_plugins"><a class="anchor" href="#sec:more_on_plugins"></a> <a class="link" href="#sec:more_on_plugins">有关插件的更多信息</a></h4>
<div class="paragraph">
<p>本章旨在介绍插件和Gradle及其作用。有关插件内部运作的更多信息，请参阅“ <a href="#custom_plugins">自定义插件”</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build_lifecycle"><a class="anchor" href="#build_lifecycle"></a> <a class="link" href="#build_lifecycle">建立生命周期</a></h3>
<div class="paragraph">
<p>我们之前说过，Gradle的核心是一种用于基于依赖的编程的语言。用Gradle术语，这意味着您可以定义任务以及任务之间的依赖关系。Gradle保证这些任务按照它们的依赖关系顺序执行，并且每个任务仅执行一次。这些任务形成有向无<a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">环图</a> 。有一些构建工具在执行任务时会建立这种依赖关系图。<em>在</em>执行任何任务<em>之前，</em> Gradle会构建完整的依赖关系图。这是Gradle的核心所在，它使许多事情成为可能，而这在其他情况下是不可能的。</p>
</div>
<div class="paragraph">
<p>您的构建脚本将配置此依赖关系图。因此，严格来说，它们是<em>构建配置脚本</em> 。</p>
</div>
<div class="sect3">
<h4 id="sec:build_phases"><a class="anchor" href="#sec:build_phases"></a> <a class="link" href="#sec:build_phases">建立阶段</a></h4>
<div class="paragraph">
<p>Gradle构建具有三个不同的阶段。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">初始化</dt>
<dd>
<p>Gradle支持单项目和多项目构建。在初始化阶段，Gradle确定将要参与构建的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">项目</a> ，并为每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">项目</a>创建一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a>实例。</p>
</dd>
<dt class="hdlist1">组态</dt>
<dd>
<p>在此阶段，将配置项目对象。执行作为构建一部分的<em>所有</em>项目的构建脚本。</p>
</dd>
<dt class="hdlist1">执行</dt>
<dd>
<p>Gradle确定要在配置阶段创建和配置的任务子集。子集由传递给<code>gradle</code>命令和当前目录。然后Gradle执行每个选定的任务。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:settings_file"><a class="anchor" href="#sec:settings_file"></a> <a class="link" href="#sec:settings_file">设定档</a></h4>
<div class="paragraph">
<p>除了构建脚本文件外，Gradle还定义了一个设置文件。设置文件由Gradle通过命名约定确定。该文件的默认名称是<code>settings.gradle</code> 。在本章的后面，我们将解释Gradle如何查找设置文件。</p>
</div>
<div class="paragraph">
<p>设置文件在初始化阶段执行。多项目构建必须具有一个<code>settings.gradle</code>文件位于多项目层次结构的根项目中。这是必需的，因为设置文件定义了哪些项目正在参与多项目构建（请参阅<a href="#multi_project_builds">创作多项目构建</a> ）。对于单项目构建，设置文件是可选的。除了定义包含的项目之外，您可能还需要将库添加到构建脚本类路径中（请参阅<a href="#organizing_gradle_projects">组织Gradle项目</a> ）。让我们首先用单个项目构建进行一些自省：</p>
</div>
<div class="exampleblock">
<div class="title">实施例168。单个项目构建</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println <span class="string"><span class="delimiter">'</span><span class="content">This is executed during the initialization phase.</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println <span class="string"><span class="delimiter">'</span><span class="content">This is executed during the configuration phase.</span><span class="delimiter">'</span></span>

task configured {
    println <span class="string"><span class="delimiter">'</span><span class="content">This is also executed during the configuration phase.</span><span class="delimiter">'</span></span>
}

task test {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">This is executed during the execution phase.</span><span class="delimiter">'</span></span>
    }
}

task testBoth {
        doFirst {
          println <span class="string"><span class="delimiter">'</span><span class="content">This is executed first during the execution phase.</span><span class="delimiter">'</span></span>
        }
        doLast {
          println <span class="string"><span class="delimiter">'</span><span class="content">This is executed last during the execution phase.</span><span class="delimiter">'</span></span>
        }
        println <span class="string"><span class="delimiter">'</span><span class="content">This is executed during the configuration phase as well.</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">println(&quot;This is executed during the initialization phase.&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">println(&quot;This is executed during the configuration phase.&quot;)

tasks.register(&quot;configured&quot;) {
    println(&quot;This is also executed during the configuration phase.&quot;)
}

tasks.register(&quot;test&quot;) {
    doLast {
        println(&quot;This is executed during the execution phase.&quot;)
    }
}

tasks.register(&quot;testBoth&quot;) {
    doFirst {
        println(&quot;This is executed first during the execution phase.&quot;)
    }
    doLast {
        println(&quot;This is executed last during the execution phase.&quot;)
    }
    println(&quot;This is executed during the configuration phase as well.&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="output_of_gradle_test_testboth"><a class="anchor" href="#output_of_gradle_test_testboth"></a> <a class="link" href="#output_of_gradle_test_testboth">输出<strong><code>gradle test testBoth</code></strong></a></h5>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&gt; gradle test testBoth
This is executed during the initialization phase.

&gt; Configure project :
This is executed during the configuration phase.
This is also executed during the configuration phase.
This is executed during the configuration phase <span class="keyword">as</span> well.

&gt; Task :test
This is executed during the execution phase.

&gt; Task :testBoth
This is executed first during the execution phase.
This is executed last during the execution phase.

BUILD SUCCESSFUL <span class="keyword">in</span> <span class="integer">0</span>s
<span class="integer">2</span> actionable <span class="key">tasks</span>: <span class="integer">2</span> executed</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">&gt; gradle test testBoth
This is executed during the initialization phase.

&gt; Configure project :
This is executed during the configuration phase.
This is executed during the configuration phase as well.

&gt; Task :test
This is executed during the execution phase.

&gt; Task :testBoth
This is executed first during the execution phase.
This is executed last during the execution phase.

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于构建脚本，将属性访问和方法调用委托给项目对象。同样，设置文件中的属性访问和方法调用也委托给设置对象。查看API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html">Settings</a>类以获取更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:lifecycle_multi_project_builds"><a class="anchor" href="#sec:lifecycle_multi_project_builds"></a> <a class="link" href="#sec:lifecycle_multi_project_builds">多项目构建</a></h4>
<div class="paragraph">
<p>多项目构建是在一次执行Gradle期间构建多个项目的构建。您必须在设置文件中声明参与多项目构建的项目。在致力于该主题的一章中，关于多项目构建的内容还有很多要说的（请参见<a href="#multi_project_builds">创作多项目构建</a> ）。</p>
</div>
<div class="sect4">
<h5 id="sub:project_locations"><a class="anchor" href="#sub:project_locations"></a> <a class="link" href="#sub:project_locations">项目地点</a></h5>
<div class="paragraph">
<p>多项目构建始终由具有单个根的树表示。树中的每个元素代表一个项目。一个项目具有一个路径，该路径表示该项目在多项目构建树中的位置。在大多数情况下，项目路径与项目在文件系统中的物理位置一致。但是，此行为是可配置的。项目树是在<code>settings.gradle</code>文件。默认情况下，假定设置文件的位置也是根项目的位置。但是您可以在设置文件中重新定义根项目的位置。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:building_the_tree"><a class="anchor" href="#sub:building_the_tree"></a> <a class="link" href="#sub:building_the_tree">建树</a></h5>
<div class="paragraph">
<p>在设置文件中，您可以使用一组方法来构建项目树。分层和平面物理布局得到特殊支持。</p>
</div>
<div class="sect5">
<h6 id="sec:hierarchical_layouts"><a class="anchor" href="#sec:hierarchical_layouts"></a> <a class="link" href="#sec:hierarchical_layouts">分层布局</a></h6>
<div class="exampleblock">
<div class="title">示例169分层布局</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">include <span class="string"><span class="delimiter">'</span><span class="content">project1</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">project2:child</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">project3:child1</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">include(&quot;project1&quot;, &quot;project2:child&quot;, &quot;project3:child1&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>include</code>方法将项目路径作为参数。假定项目路径等于相对物理文件系统路径。例如，默认情况下，路径“ services：api”映射到文件夹“ services / api”（相对于项目根目录）。您只需要指定树的叶子即可。这意味着包含路径“ services：hotels：api”将导致创建3个项目：“ services”，“ services：hotels”和“ services：hotels：api”。有关如何使用项目路径的更多示例，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])">Settings.include（java.lang。String []）</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:flat_layouts"><a class="anchor" href="#sec:flat_layouts"></a> <a class="link" href="#sec:flat_layouts">平面布局</a></h6>
<div class="exampleblock">
<div class="title">例子170。平面布局</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">includeFlat <span class="string"><span class="delimiter">'</span><span class="content">project3</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">project4</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">includeFlat(&quot;project3&quot;, &quot;project4&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>includeFlat</code>方法将目录名称作为参数。这些目录必须作为根项目目录的同级存在。这些目录的位置被视为多项目树中根项目的子项目。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub:modifying_element_of_the_project_tree"><a class="anchor" href="#sub:modifying_element_of_the_project_tree"></a> <a class="link" href="#sub:modifying_element_of_the_project_tree">修改项目树的元素</a></h5>
<div class="paragraph">
<p>在设置文件中创建的多项目树由所谓的<em>项目描述符组成</em> 。您可以随时在设置文件中修改这些描述符。要访问描述符，您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例171查找项目树的元素</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println rootProject.name
println project(<span class="string"><span class="delimiter">'</span><span class="content">:projectA</span><span class="delimiter">'</span></span>).name</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">println(rootProject.name)
println(project(&quot;:projectA&quot;).name)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用此描述符，您可以更改名称，项目目录和项目的构建文件。</p>
</div>
<div class="exampleblock">
<div class="title">示例172修改项目树的元素</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">main</span><span class="delimiter">'</span></span>
project(<span class="string"><span class="delimiter">'</span><span class="content">:projectA</span><span class="delimiter">'</span></span>).projectDir = <span class="keyword">new</span> <span class="predefined-type">File</span>(settingsDir, <span class="string"><span class="delimiter">'</span><span class="content">../my-project-a</span><span class="delimiter">'</span></span>)
project(<span class="string"><span class="delimiter">'</span><span class="content">:projectA</span><span class="delimiter">'</span></span>).buildFileName = <span class="string"><span class="delimiter">'</span><span class="content">projectA.gradle</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;main&quot;
project(&quot;:projectA&quot;).projectDir = File(settingsDir, &quot;../my-project-a&quot;)
project(&quot;:projectA&quot;).buildFileName = &quot;projectA.gradle&quot;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请查看API文档中的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/initialization/ProjectDescriptor.html">ProjectDescriptor</a>类以获取更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:initialization"><a class="anchor" href="#sec:initialization"></a> <a class="link" href="#sec:initialization">初始化</a></h4>
<div class="paragraph">
<p>Gradle如何知道要执行单个项目还是进行多个项目？如果您从带有设置文件的目录中触发多项目构建，那么事情很容易。但是Gradle还允许您从参与构建的任何子项目中执行构建。 <sup class="footnote">[ <a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="查看脚注。">5</a> ]</sup> 如果您从一个项目中执行Gradle而没有<code>settings.gradle</code>文件，Gradle查找<code>settings.gradle</code>通过以下方式归档：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它看起来在一个名为<code>master</code>与当前目录具有相同的嵌套级别。</p>
</li>
<li>
<p>如果尚未找到，它将搜索父目录。</p>
</li>
<li>
<p>如果尚未找到，则该构建将作为单个项目构建执行。</p>
</li>
<li>
<p>如果一个<code>settings.gradle</code>找到文件后，Gradle会检查当前项目是否属于所找到的多项目层次结构的一部分<code>settings.gradle</code>文件。如果不是，则将构建作为单个项目构建执行。否则，将执行多项目构建。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种行为的目的是什么？Gradle需要确定您所在的项目是否是多项目构建的子项目。当然，如果它是一个子项目，则仅构建子项目及其从属项目，但是Gradle需要为整个多项目构建创建构建配置（请参见<a href="#multi_project_builds">创作多项目构建</a> ）。如果当前项目包含一个<code>settings.gradle</code>文件，构建始终按以下方式执行：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个单独的项目构建，如果<code>settings.gradle</code>文件未定义多项目层次结构</p>
</li>
<li>
<p>多项目构建，如果<code>settings.gradle</code>文件确实定义了一个多项目层次结构。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>自动搜索<code>settings.gradle</code>该文件仅适用于具有物理层次结构或平面布局的多项目构建。对于平面布局，您还必须遵守上述命名约定（“ <code>master</code> ”）。Gradle支持多项目构建的任意物理布局，但是对于这种任意布局，您需要从设置文件所在的目录执行构建。有关如何从根目录运行部分构建的信息，请参阅<a href="#sec:running_partial_build_from_the_root">按其绝对路径运行任务</a> 。</p>
</div>
<div class="paragraph">
<p>Gradle为参与构建的每个项目创建一个Project对象。对于多项目构建，这些是Settings对象（加上根项目）中指定的项目。默认情况下，每个项目对象的名称都等于其顶级目录的名称，并且除根项目外的每个项目都有一个父项目。任何项目都可以有子项目。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuration_and_execution_of_a_single_project_build"><a class="anchor" href="#sec:configuration_and_execution_of_a_single_project_build"></a> <a class="link" href="#sec:configuration_and_execution_of_a_single_project_build">单个项目构建的配置和执行</a></h4>
<div class="paragraph">
<p>对于单个项目构建， <em>初始化</em>阶段<em>之后</em>的工作流程非常简单。将针对初始化阶段创建的项目对象执行构建脚本。然后Gradle查找名称与作为命令行参数传递的名称相同的任务。如果存在这些任务名称，则会按照传递它们的顺序将它们作为单独的版本执行。在<a href="#multi_project_builds">创作多</a>项目构建中讨论了多项目构建的配置和执行。</p>
</div>
</div>
<div class="sect3">
<h4 id="build_lifecycle_events"><a class="anchor" href="#build_lifecycle_events"></a> <a class="link" href="#build_lifecycle_events">响应构建脚本中的生命周期</a></h4>
<div class="paragraph">
<p>随着构建在生命周期中的进展，您的构建脚本可以接收通知。这些通知通常采用两种形式：您可以实现特定的侦听器接口，也可以提供闭包以在触发通知时执行。下面的示例使用闭包。有关如何使用侦听器接口的详细信息，请参阅API文档。</p>
</div>
<div class="sect4">
<h5 id="sec:project_evaluation"><a class="anchor" href="#sec:project_evaluation"></a> <a class="link" href="#sec:project_evaluation">项目评估</a></h5>
<div class="paragraph">
<p>您可以在评估项目之前和之后立即收到通知。一旦构建脚本中的所有定义均已应用，这可用于执行其他配置，或用于某些自定义日志记录或性能分析。</p>
</div>
<div class="paragraph">
<p>以下是添加了一个<code>test</code>每个项目都有一个任务<code>hasTests</code>属性值为true。</p>
</div>
<div class="exampleblock">
<div class="title">例子173。将测试任务添加到每个具有特定属性集的项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    afterEvaluate { project -&gt;
        <span class="keyword">if</span> (project.hasTests) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Adding test task to </span><span class="inline"><span class="inline-delimiter">$</span>project</span><span class="delimiter">&quot;</span></span>
            project.task(<span class="string"><span class="delimiter">'</span><span class="content">test</span><span class="delimiter">'</span></span>) {
                doLast {
                    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running tests for </span><span class="inline"><span class="inline-delimiter">$</span>project</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">projectA.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">hasTests = <span class="predefined-constant">true</span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    afterEvaluate {
        if (extra[&quot;hasTests&quot;] as Boolean) {
            println(&quot;Adding test task to $project&quot;)
            tasks.register(&quot;test&quot;) {
                doLast {
                    println(&quot;Running tests for $project&quot;)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">projectA.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;hasTests&quot;] = true</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q test</code></div>
<div class="content">
<pre>&gt; gradle -q test
Adding test task to project ':projectA'
Running tests for project ':projectA'</pre>
</div>
</div>
<div class="paragraph">
<p>本示例使用方法<code>Project.afterEvaluate()</code>添加一个闭包，该闭包在评估项目后执行。</p>
</div>
<div class="paragraph">
<p>评估任何项目时，也可能会收到通知。本示例对项目评估执行一些自定义日志记录。请注意<code>afterProject</code>无论项目评估成功还是失败，都将收到通知。</p>
</div>
<div class="exampleblock">
<div class="title">示例174通知事项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gradle.afterProject { project -&gt;
    <span class="keyword">if</span> (project.state.failure) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Evaluation of </span><span class="inline"><span class="inline-delimiter">$</span>project</span><span class="content"> FAILED</span><span class="delimiter">&quot;</span></span>
    } <span class="keyword">else</span> {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Evaluation of </span><span class="inline"><span class="inline-delimiter">$</span>project</span><span class="content"> succeeded</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">gradle.afterProject {
    if (state.failure != null) {
        println(&quot;Evaluation of $project FAILED&quot;)
    } else {
        println(&quot;Evaluation of $project succeeded&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="output_of_gradle_q_test"><a class="anchor" href="#output_of_gradle_q_test"></a> <a class="link" href="#output_of_gradle_q_test">输出<strong><code>gradle -q test</code></strong></a></h6>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&gt; gradle -q test
Evaluation of root project <span class="string"><span class="delimiter">'</span><span class="content">buildProjectEvaluateEvents</span><span class="delimiter">'</span></span> succeeded
Evaluation of project <span class="string"><span class="delimiter">'</span><span class="content">:projectA</span><span class="delimiter">'</span></span> succeeded
Evaluation of project <span class="string"><span class="delimiter">'</span><span class="content">:projectB</span><span class="delimiter">'</span></span> FAILED

<span class="key">FAILURE</span>: Build failed with an exception.

* <span class="key">Where</span>:
Build file <span class="string"><span class="delimiter">'</span><span class="content">/home/user/gradle/samples/groovy/projectB.gradle</span><span class="delimiter">'</span></span> <span class="key">line</span>: <span class="integer">1</span>

* What went <span class="key">wrong</span>:
A problem occurred evaluating project <span class="string"><span class="delimiter">'</span><span class="content">:projectB</span><span class="delimiter">'</span></span>.
&gt; broken

* <span class="key">Try</span>:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at <span class="key">https</span>:<span class="comment">//help.gradle.org</span>

BUILD FAILED <span class="keyword">in</span> <span class="integer">0</span>s</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">&gt; gradle -q test
Evaluation of root project 'buildProjectEvaluateEvents' succeeded
Evaluation of project ':projectA' succeeded
Evaluation of project ':projectB' FAILED

FAILURE: Build failed with an exception.

* Where:
Build file '/home/user/gradle/samples/kotlin/projectB.gradle.kts' line: 1

* What went wrong:
broken

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 0s</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/ProjectEvaluationListener.html">ProjectEvaluationListener</a>添加到<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html">Gradle</a>以接收这些事件。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:task_creation"><a class="anchor" href="#sec:task_creation"></a> <a class="link" href="#sec:task_creation">任务创建</a></h5>
<div class="paragraph">
<p>将任务添加到项目后，您会立即收到通知。在构建文件中使任务可用之前，这可以用于设置一些默认值或添加行为。</p>
</div>
<div class="paragraph">
<p>以下示例设置了<code>srcDir</code>每个任务的属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例175为所有任务设置某些属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.whenTaskAdded { task -&gt;
    task.ext.srcDir = <span class="string"><span class="delimiter">'</span><span class="content">src/main/java</span><span class="delimiter">'</span></span>
}

task a

println <span class="string"><span class="delimiter">&quot;</span><span class="content">source dir is </span><span class="inline"><span class="inline-delimiter">$</span>a</span><span class="content">.srcDir</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.whenTaskAdded {
    extra[&quot;srcDir&quot;] = &quot;src/main/java&quot;
}

val a by tasks.registering

println(&quot;source dir is ${a.get().extra[&quot;srcDir&quot;]}&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q a</code></strong></div>
<div class="content">
<pre>&gt; gradle -q a
source dir is src/main/java</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Action.html">Action</a>添加到<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html">TaskContainer</a>以接收这些事件。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:task_execution_graph_ready"><a class="anchor" href="#sec:task_execution_graph_ready"></a> <a class="link" href="#sec:task_execution_graph_ready">任务执行图准备就绪</a></h5>
<div class="paragraph">
<p>填充任务执行图后，您会立即收到通知（请参阅“ <a href="#configure-by-dag">通过DAG配置”</a> ）。</p>
</div>
<div class="paragraph">
<p>您还可以将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/execution/TaskExecutionGraphListener.html">TaskExecutionGraphListener</a>添加到<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/execution/TaskExecutionGraph.html">TaskExecutionGraph</a>来接收这些事件。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:task_execution"><a class="anchor" href="#sec:task_execution"></a> <a class="link" href="#sec:task_execution">任务执行</a></h5>
<div class="paragraph">
<p>您可以在执行任何任务之前和之后立即收到通知。</p>
</div>
<div class="paragraph">
<p>下面的示例记录每个任务执行的开始和结束。请注意<code>afterTask</code>无论任务是成功完成还是失败，都将收到通知。</p>
</div>
<div class="exampleblock">
<div class="title">实施例176。记录每个任务执行的开始和结束</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task ok

task broken(<span class="key">dependsOn</span>: ok) {
    doLast {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">'</span><span class="content">broken</span><span class="delimiter">'</span></span>)
    }
}

gradle.taskGraph.beforeTask { Task task -&gt;
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">executing </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content"> ...</span><span class="delimiter">&quot;</span></span>
}

gradle.taskGraph.afterTask { Task task, TaskState state -&gt;
    <span class="keyword">if</span> (state.failure) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">FAILED</span><span class="delimiter">&quot;</span></span>
    }
    <span class="keyword">else</span> {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">done</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;ok&quot;)

tasks.register(&quot;broken&quot;) {
    dependsOn(&quot;ok&quot;)
    doLast {
        throw RuntimeException(&quot;broken&quot;)
    }
}

gradle.taskGraph.beforeTask {
    println(&quot;executing $this ...&quot;)
}

gradle.taskGraph.afterTask {
    if (state.failure != null) {
        println(&quot;FAILED&quot;)
    } else {
        println(&quot;done&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="output_of_gradle_q_broken"><a class="anchor" href="#output_of_gradle_q_broken"></a> <a class="link" href="#output_of_gradle_q_broken">输出<strong><code>gradle -q broken</code></strong></a></h6>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&gt; gradle -q broken
executing task <span class="string"><span class="delimiter">'</span><span class="content">:ok</span><span class="delimiter">'</span></span> ...
done
executing task <span class="string"><span class="delimiter">'</span><span class="content">:broken</span><span class="delimiter">'</span></span> ...
FAILED

<span class="key">FAILURE</span>: Build failed with an exception.

* <span class="key">Where</span>:
Build file <span class="string"><span class="delimiter">'</span><span class="content">/home/user/gradle/samples/groovy/build.gradle</span><span class="delimiter">'</span></span> <span class="key">line</span>: <span class="integer">5</span>

* What went <span class="key">wrong</span>:
Execution failed <span class="keyword">for</span> task <span class="string"><span class="delimiter">'</span><span class="content">:broken</span><span class="delimiter">'</span></span>.
&gt; broken

* <span class="key">Try</span>:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at <span class="key">https</span>:<span class="comment">//help.gradle.org</span>

BUILD FAILED <span class="keyword">in</span> <span class="integer">0</span>s</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">&gt; gradle -q broken
executing task ':ok' ...
done
executing task ':broken' ...
FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':broken'.
&gt; broken

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 0s</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以对<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/execution/TaskExecutionListener.html">TaskExecutionGraph</a>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/execution/TaskExecutionGraph.html">TaskExecutionListener</a>来接收这些事件。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logging"><a class="anchor" href="#logging"></a> <a class="link" href="#logging">记录中</a></h3>
<div class="paragraph">
<p>日志是构建工具的主要“ UI”。如果太冗长，则很容易掩盖真正的警告和问题。另一方面，您需要相关信息来确定是否出错。摇篮定义6个日志级别，如图<a href="#logLevels">日志级别</a> 。除了通常可能看到的级别以外，还有两种特定于Gradle的日志级别。这些级别是<em>QUIET</em>和<em>LIFECYCLE</em> 。后者是默认设置，用于报告构建进度。</p>
</div>
<div class="sect3">
<h4 id="logLevels"><a class="anchor" href="#logLevels"></a> <a class="link" href="#logLevels">日志级别</a></h4>
<div class="hdlist">
<table>
<tbody><tr>
<td class="hdlist1">错误</td>
<td class="hdlist2">
<p>错误讯息</p>
</td>
</tr>
<tr>
<td class="hdlist1">安静</td>
<td class="hdlist2">
<p>重要信息消息</p>
</td>
</tr>
<tr>
<td class="hdlist1">警告</td>
<td class="hdlist2">
<p>警告讯息</p>
</td>
</tr>
<tr>
<td class="hdlist1">生命周期</td>
<td class="hdlist2">
<p>进度信息消息</p>
</td>
</tr>
<tr>
<td class="hdlist1">信息</td>
<td class="hdlist2">
<p>信息消息</p>
</td>
</tr>
<tr>
<td class="hdlist1">调试</td>
<td class="hdlist2">
<p>调试信息</p>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>无论使用什么日志级别，都会显示控制台的丰富组件（构建状态和正在进行的工作区域）。在Gradle 4.0之前，这些丰富的组件仅在日志级别显示<code>LIFECYCLE</code>或以下。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:choosing_a_log_level"><a class="anchor" href="#sec:choosing_a_log_level"></a> <a class="link" href="#sec:choosing_a_log_level">选择日志级别</a></h4>
<div class="paragraph">
<p>您可以使用“ <a href="#logLevelCommandLineOptions">日志级别”命令行选项中</a>显示的命令行开关来选择不同的日志级别。您还可以使用以下命令配置日志级别<code>gradle.properties</code> ，请参阅<a href="#sec:gradle_configuration_properties">Gradle属性</a> 。在<a href="#stacktraces">Stacktrace命令行选项中，</a>您会找到影响stacktrace日志记录的命令行开关。</p>
</div>
<table id="logLevelCommandLineOptions" class="tableblock frame-all grid-all fit-content">
<caption class="title">表3。日志级别命令行选项</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">输出日志级别</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有记录选项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生命周期及更高</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-q</code>要么<code>--quiet</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">安静及更高</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-w</code>要么<code>--warn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">警告及更高</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-i</code>要么<code>--info</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INFO及更高</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-d</code>要么<code>--debug</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEBUG及更高版本（即所有日志消息）</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="stacktraces"><a class="anchor" href="#stacktraces"></a> <a class="link" href="#stacktraces">Stacktrace命令行选项</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-s</code>要么<code>--stacktrace</code></dt>
<dd>
<p>打印出截断的堆栈跟踪。我们建议在整个堆栈跟踪中使用此方法。Groovy完整的堆栈跟踪非常冗长（由于底层的动态调用机制。但是，它们通常不包含有关<em>您的</em>代码出了什么问题的相关信息。）此选项为过时警告呈现堆栈跟踪。</p>
</dd>
<dt class="hdlist1"><code>-S</code>要么<code>--full-stacktrace</code></dt>
<dd>
<p>完整的堆栈跟踪信息被打印出来。此选项为过时警告呈现堆栈跟踪。</p>
</dd>
<dt class="hdlist1"><no stacktrace="" options=""></no></dt>
<dd>
<p>如果发生构建错误（例如，编译错误），则不会将任何堆栈跟踪记录打印到控制台。仅在内部异常的情况下，才会打印堆栈跟踪。如果<code>DEBUG</code>选择日志级别，将始终打印截断的堆栈跟踪。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:sending_your_own_log_messages"><a class="anchor" href="#sec:sending_your_own_log_messages"></a> <a class="link" href="#sec:sending_your_own_log_messages">编写自己的日志消息</a></h4>
<div class="paragraph">
<p>登录构建文件的一个简单选项是将消息写入标准输出。Gradle会将写入标准输出的所有内容重定向到位于其日志系统的位置<code>QUIET</code>日志级别。</p>
</div>
<div class="exampleblock">
<div class="title">示例177使用stdout编写日志消息</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println <span class="string"><span class="delimiter">'</span><span class="content">A message which is logged at QUIET level</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">println(&quot;A message which is logged at QUIET level&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle还提供了<code>logger</code>生成脚本的属性，该脚本是<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/logging/Logger.html">Logger</a>的实例。该接口扩展了SLF4J <code>Logger</code>接口，并向其中添加了一些Gradle特定的方法。以下是在构建脚本中如何使用它的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例178编写自己的日志消息</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">logger.quiet(<span class="string"><span class="delimiter">'</span><span class="content">An info log message which is always logged.</span><span class="delimiter">'</span></span>)
logger.error(<span class="string"><span class="delimiter">'</span><span class="content">An error log message.</span><span class="delimiter">'</span></span>)
logger.warn(<span class="string"><span class="delimiter">'</span><span class="content">A warning log message.</span><span class="delimiter">'</span></span>)
logger.lifecycle(<span class="string"><span class="delimiter">'</span><span class="content">A lifecycle info log message.</span><span class="delimiter">'</span></span>)
logger.info(<span class="string"><span class="delimiter">'</span><span class="content">An info log message.</span><span class="delimiter">'</span></span>)
logger.debug(<span class="string"><span class="delimiter">'</span><span class="content">A debug log message.</span><span class="delimiter">'</span></span>)
logger.trace(<span class="string"><span class="delimiter">'</span><span class="content">A trace log message.</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">logger.quiet(&quot;An info log message which is always logged.&quot;)
logger.error(&quot;An error log message.&quot;)
logger.warn(&quot;A warning log message.&quot;)
logger.lifecycle(&quot;A lifecycle info log message.&quot;)
logger.info(&quot;An info log message.&quot;)
logger.debug(&quot;A debug log message.&quot;)
logger.trace(&quot;A trace log message.&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用<a href="https://www.slf4j.org/manual.html#typical_usage">典型的SLF4J模式</a>将占位符替换为实际值，作为日志消息的一部分。</p>
</div>
<div class="exampleblock">
<div class="title">示例179。用占位符编写日志消息</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">logger.info(<span class="string"><span class="delimiter">'</span><span class="content">A {} log message</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">info</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">logger.info(&quot;A {} log message&quot;, &quot;info&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以从构建中使用的其他类（来自<code>buildSrc</code>目录）。只需使用SLF4J记录器。您可以使用与在构建脚本中使用提供的记录器相同的方式来使用此记录器。</p>
</div>
<div class="exampleblock">
<div class="title">例子180。使用SLF4J编写日志消息</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.slf4j.LoggerFactory</span>

<span class="keyword">def</span> slf4jLogger = LoggerFactory.getLogger(<span class="string"><span class="delimiter">'</span><span class="content">some-logger</span><span class="delimiter">'</span></span>)
slf4jLogger.info(<span class="string"><span class="delimiter">'</span><span class="content">An info log message logged using SLF4j</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.slf4j.LoggerFactory

val slf4jLogger = LoggerFactory.getLogger(&quot;some-logger&quot;)
slf4jLogger.info(&quot;An info log message logged using SLF4j&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:external_tools"><a class="anchor" href="#sec:external_tools"></a> <a class="link" href="#sec:external_tools">从外部工具和库记录</a></h4>
<div class="paragraph">
<p>在内部，Gradle使用Ant和Ivy。两者都有自己的日志系统。Gradle将其日志输出重定向到Gradle日志系统。从Ant / Ivy日志级别到Gradle日志级别有1：1映射，但Ant / Ivy除外<code>TRACE</code>日志级别，映射到Gradle <code>DEBUG</code>日志级别。这意味着默认的Gradle日志级别将不会显示任何Ant / Ivy输出，除非它是错误或警告。</p>
</div>
<div class="paragraph">
<p>有许多工具仍然使用标准输出进行日志记录。默认情况下，Gradle将标准输出重定向到<code>QUIET</code>日志级别和标准错误<code>ERROR</code>水平。此行为是可配置的。项目对象提供一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/logging/LoggingManager.html">LoggingManager</a> ，它允许您更改在评估构建脚本时将标准输出或错误重定向到的日志级别。</p>
</div>
<div class="exampleblock">
<div class="title">实施例181。配置标准输出捕获</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">logging.captureStandardOutput LogLevel.INFO
println <span class="string"><span class="delimiter">'</span><span class="content">A message which is logged at INFO level</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">logging.captureStandardOutput(LogLevel.INFO)
println(&quot;A message which is logged at INFO level&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在任务执行过程中更改标准输出或错误的日志级别，任务还提供<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/logging/LoggingManager.html">LoggingManager</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例182配置任务的标准输出捕获</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task logInfo {
    logging.captureStandardOutput LogLevel.INFO
    doFirst {
        println <span class="string"><span class="delimiter">'</span><span class="content">A task message which is logged at INFO level</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;logInfo&quot;) {
    logging.captureStandardOutput(LogLevel.INFO)
    doFirst {
        println(&quot;A task message which is logged at INFO level&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle还提供了与Java Util日志记录，Jakarta Commons日志记录和Log4j日志记录工具包的集成。您的构建类使用这些日志记录工具包编写的任何日志消息都将被重定向到Gradle的日志记录系统。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:changing_what_gradle_logs"><a class="anchor" href="#sec:changing_what_gradle_logs"></a> <a class="link" href="#sec:changing_what_gradle_logs">更改Gradle日志</a></h4>
<div class="paragraph">
<p>您可以使用自己的Gradle替换许多Logging UI。例如，如果您想以某种方式自定义UI，则可以执行此操作-记录更多或更少的信息，或更改格式。您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:useLogger(java.lang.Object)">Gradle.useLogger（java.lang。对象）</a>方法。可通过构建脚本或初始化脚本或通过嵌入API进行访问。请注意，这完全禁用了Gradle的默认输出。下面是一个示例初始化脚本，该脚本更改了记录任务执行和构建完成的方式。</p>
</div>
<div class="exampleblock">
<div class="title">示例183自定义Gradle日志</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">customLogger.init.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">useLogger(<span class="keyword">new</span> CustomEventLogger())

<span class="type">class</span> <span class="class">CustomEventLogger</span> <span class="directive">extends</span> BuildAdapter <span class="directive">implements</span> TaskExecutionListener {

    <span class="type">void</span> beforeExecute(Task task) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">[</span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.name]</span><span class="delimiter">&quot;</span></span>
    }

    <span class="type">void</span> afterExecute(Task task, TaskState state) {
        println()
    }

    <span class="type">void</span> buildFinished(BuildResult result) {
        println <span class="string"><span class="delimiter">'</span><span class="content">build completed</span><span class="delimiter">'</span></span>
        <span class="keyword">if</span> (result.failure != <span class="predefined-constant">null</span>) {
            result.failure.printStackTrace()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">customLogger.init.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">useLogger(CustomEventLogger())

class CustomEventLogger() : BuildAdapter(), TaskExecutionListener {

    override fun beforeExecute(task: Task) {
        println(&quot;[${task.name}]&quot;)
    }

    override fun afterExecute(task: Task, state: TaskState) {
        println()
    }

    override fun buildFinished(result: BuildResult) {
        println(&quot;build completed&quot;)
        if (result.failure != null) {
            result.failure.printStackTrace()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock multi-language-text lang-groovy">
<div class="content">
<pre>$ gradle -I customLogger.init.gradle build

&gt; Task :compile
[compile]
compiling source


&gt; Task :testCompile
[testCompile]
compiling test source


&gt; Task :test
[test]
running unit tests


&gt; Task :build
[build]

build completed
3 actionable tasks: 3 executed</pre>
</div>
</div>
<div class="listingblock multi-language-text lang-kotlin">
<div class="content">
<pre>$ gradle -I customLogger.init.gradle.kts build

&gt; Task :compile
[compile]
compiling source


&gt; Task :testCompile
[testCompile]
compiling test source


&gt; Task :test
[test]
running unit tests


&gt; Task :build
[build]

build completed
3 actionable tasks: 3 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您的记录器可以实现下面列出的任何侦听器接口。注册记录器时，只会替换其实现的接口的记录。其他接口的日志保持不变。您可以在“ <a href="#build_lifecycle_events">构建生命周期”事件中</a>找到有关侦听器接口的更多信息。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/BuildListener.html">BuildListener</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/ProjectEvaluationListener.html">ProjectEvaluationListener</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/execution/TaskExecutionGraphListener.html">TaskExecutionGraphListener</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/execution/TaskExecutionListener.html">TaskExecutionListener</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/execution/TaskActionListener.html">TaskActionListener</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multi_project_builds"><a class="anchor" href="#multi_project_builds"></a> <a class="link" href="#multi_project_builds">创作多项目构建</a></h3>
<div class="paragraph">
<p>对多项目构建的强大支持是Gradle独特的卖点之一。这个话题也是最有智力挑战的。</p>
</div>
<div class="paragraph">
<p>gradle中的多项目构建包含一个根项目以及一个或多个子项目，这些子项目也可能具有子项目。</p>
</div>
<div class="sect3">
<h4 id="sec:cross_project_configuration"><a class="anchor" href="#sec:cross_project_configuration"></a> <a class="link" href="#sec:cross_project_configuration">跨项目配置</a></h4>
<div class="paragraph">
<p>虽然每个子项目都可以完全隔离其他子项目进行配置，但是子项目具有共同的特征是很常见的。因此，通常最好在项目之间共享配置，因此相同的配置会影响多个子项目。</p>
</div>
<div class="paragraph">
<p>让我们从一个非常简单的多项目构建开始。Gradle的核心是通用构建工具，因此项目不必是Java项目。我们的第一个例子是关于海洋生物的。</p>
</div>
<div class="sect4">
<h5 id="sec:configuration_and_execution"><a class="anchor" href="#sec:configuration_and_execution"></a> <a class="link" href="#sec:configuration_and_execution">配置和执行</a></h5>
<div class="paragraph">
<p><a href="#sec:build_phases">构建阶段</a>描述了每个Gradle构建的阶段。让我们放大多项目构建的配置和执行阶段。这里的配置意味着执行<code>build.gradle</code> （要么<code>build.gradle.kts</code> ）文件，这意味着例如下载所有使用'声明的插件<code>apply plugin</code> '或<code>plugins</code>块。默认情况下，所有项目的配置都在执行任何任务之前进行。这意味着当请求来自单个项目的单个任务时，将首先配置多项目构建的<em>所有</em>项目。需要配置每个项目的原因是为了支持访问和更改Gradle项目模型的任何部分的灵活性。</p>
</div>
<div class="sect5">
<h6 id="sec:configuration_on_demand"><a class="anchor" href="#sec:configuration_on_demand"></a> <a class="link" href="#sec:configuration_on_demand">按需配置</a></h6>
<div class="paragraph">
<p><em>配置注入</em>功能和对整个项目模型的访问都是可能的，因为每个项目都在执行阶段之前进行了配置。但是，这种方法在大型的多项目构建中可能不是最有效的。有Gradle构建，其中包含数百个子项目的层次结构。庞大的多项目构建的配置时间可能会变得很明显。可伸缩性是Gradle的一项重要要求。因此，从版本1.4开始，引入了新的孵化“按需配置”模式。</p>
</div>
<div class="paragraph">
<p>按需配置模式尝试仅配置与所请求任务相关的项目，即它仅执行<code>build.gradle[.kts]</code>参与构建的项目文件。这样，可以减少大型多项目构建的配置时间。从长远来看，该模式将成为默认模式，可能是Gradle构建执行的唯一模式。按需配置功能正在不断发展，因此不能保证每个构建都能正常工作。对于已<a href="#sec:decoupled_projects">解耦项目的</a>多项目构建，该功能应该可以很好地工作。在“按需配置”模式下，项目配置如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>始终配置根项目。这样，即可支持典型的通用配置（所有项目或子项目脚本块）。</p>
</li>
<li>
<p>也只在执行Gradle而没有任何任务的情况下配置执行构建的目录中的项目。这样，当按需配置项目时，默认任务将正确运行。</p>
</li>
<li>
<p>支持标准项目依赖关系，并配置了相关项目。如果项目A对项目B具有编译依赖性，则构建A会导致两个项目的配置。</p>
</li>
<li>
<p>支持通过任务路径声明的任务依赖性，并导致配置相关项目。例：<code>someTask.dependsOn(":someOtherProject:someOtherTask")</code></p>
</li>
<li>
<p>通过任务路径从命令行（或Tooling API）请求的任务将导致配置相关项目。例如，构建'projectA：projectB：someTask'导致配置projectB。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>渴望尝试此新功能吗？要在每次构建运行时按需配置，请参阅<a href="#sec:gradle_configuration_properties">Gradle属性</a> 。要仅针对给定的构建按需配置，请参阅<a href="#sec:command_line_performance">面向命令行性能的选项</a> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:defining_common_behavior"><a class="anchor" href="#sec:defining_common_behavior"></a> <a class="link" href="#sec:defining_common_behavior">定义常见行为</a></h5>
<div class="paragraph">
<p>让我们看下面的项目树的一些例子。这是一个多项目构建，其中的根项目名为<code>water</code>和一个名为<code>bluewhale</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">实施例184。多项目树-水和蓝鲸项目</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> bluewhale/
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── bluewhale/
├── build.gradle.kts
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/firstExample/water</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">water</span><span class="delimiter">'</span></span>
include <span class="string"><span class="delimiter">'</span><span class="content">bluewhale</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;water&quot;
include(&quot;bluewhale&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以及<code>bluewhale</code>项目？在Gradle中，构建脚本是可选的。显然，对于单个项目构建，没有构建脚本的项目没有多大意义。对于多项目构建，情况有所不同。让我们来看一下<code>water</code>项目并执行：</p>
</div>
<div class="exampleblock">
<div class="title">示例185水（父）项目的构建脚本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">Closure cl = { task -&gt; println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.project.name</span><span class="delimiter">&quot;</span></span> }
task(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>).doLast(cl)
project(<span class="string"><span class="delimiter">'</span><span class="content">:bluewhale</span><span class="delimiter">'</span></span>) {
    task(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>).doLast(cl)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val cl = Action&lt;Task&gt; { println(&quot;I'm ${this.project.name}&quot;) }
tasks.register(&quot;hello&quot;) { doLast(cl) }
project(&quot;:bluewhale&quot;) {
    tasks.register(&quot;hello&quot;) { doLast(cl) }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
I'm water
I'm bluewhale</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle允许您从任何构建脚本访问多项目构建的任何项目。Project API提供了一种称为<code>project()</code> ，它以路径作为参数，并返回该路径的Project对象。通过任何我们称为<em>跨项目配置的</em>构建脚本来配置项目构建的功能。Gradle通过<em>配置注入</em>实现了这一点。</p>
</div>
<div class="paragraph">
<p>我们对构建脚本不满意<code>water</code>项目。为每个项目显式添加任务很不方便。我们可以做得更好。首先添加另一个名为<code>krill</code>到我们的多项目构建中。</p>
</div>
<div class="exampleblock">
<div class="title">示例186。多项目树-水，蓝鲸和磷虾项目</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> bluewhale/
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> krill/
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── bluewhale/
├── build.gradle.kts
├── krill/
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/addKrill/water</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">water</span><span class="delimiter">'</span></span>

include <span class="string"><span class="delimiter">'</span><span class="content">bluewhale</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">krill</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;water&quot;

include(&quot;bluewhale&quot;, &quot;krill&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们重写<code>water</code>构建脚本并将其简化为一行。</p>
</div>
<div class="exampleblock">
<div class="title">示例187。水利工程建设脚本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.project.name</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    tasks.register(&quot;hello&quot;) {
        doLast {
            println(&quot;I'm ${this.project.name}&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
I'm water
I'm bluewhale
I'm krill</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这很酷还是很酷？以及如何运作？Project API提供了一个属性<code>allprojects</code>它返回一个列表，其中包含当前项目及其下的所有子项目。如果你打电话<code>allprojects</code>对于闭包，闭包的语句将委派给与<code>allprojects</code> 。您也可以通过<code>allprojects.each</code> （在Groovy中）或<code>allprojects.forEach</code> （在Kotlin中），但这会更加冗长。</p>
</div>
<div class="paragraph">
<p>其他构建系统使用继承作为定义常见行为的主要手段。我们还将为项目提供继承，您将在后面看到。但是Gradle使用配置注入作为定义常见行为的常用方法。我们认为它提供了一种配置多项目构建的非常强大而灵活的方式。</p>
</div>
<div class="paragraph">
<p>共享配置的另一种可能性是使用通用的外部脚本。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:subproject_configuration"><a class="anchor" href="#sec:subproject_configuration"></a> <a class="link" href="#sec:subproject_configuration">子项目配置</a></h4>
<div class="paragraph">
<p>Project API还提供了仅用于访问子项目的属性。</p>
</div>
<div class="sect4">
<h5 id="sec:defining_common_behavior_subprojects"><a class="anchor" href="#sec:defining_common_behavior_subprojects"></a> <a class="link" href="#sec:defining_common_behavior_subprojects">定义常见行为</a></h5>
<div class="exampleblock">
<div class="title">实施例188。定义所有项目和子项目的共同行为</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.project.name</span><span class="delimiter">&quot;</span></span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I depend on water</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    tasks.register(&quot;hello&quot;) {
        doLast {
            println(&quot;I'm ${this.project.name}&quot;)
        }
    }
}
subprojects {
    tasks.named(&quot;hello&quot;) {
        doLast {
            println(&quot;- I depend on water&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
I'm krill
- I depend on water</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可能会注意到，有两个代码段引用了“ <code>hello</code>任务。第一个使用“ <code>task</code> ”关键字（在Groovy中）或<code>task()</code>函数（在Kotlin中），构造任务并提供其基本配置。第二部分不使用“ <code>task</code> ”关键字或函数，因为它会进一步配置现有的“ <code>hello</code>任务。您只能在项目中构造一个任务，但是可以添加任意数量的代码块以提供其他配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:adding_specific_behavior"><a class="anchor" href="#sub:adding_specific_behavior"></a> <a class="link" href="#sub:adding_specific_behavior">添加特定行为</a></h5>
<div class="paragraph">
<p>您可以在常见行为之上添加特定行为。通常，我们将项目特定的行为放在要应用此特定行为的项目的构建脚本中。但是，正如我们已经看到的那样，我们不必这样做。我们可以为<code>bluewhale</code>像这样的项目：</p>
</div>
<div class="exampleblock">
<div class="title">示例189为特定项目定义特定行为</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.project.name</span><span class="delimiter">&quot;</span></span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I depend on water</span><span class="delimiter">&quot;</span></span>
        }
    }
}
project(<span class="string"><span class="delimiter">'</span><span class="content">:bluewhale</span><span class="delimiter">'</span></span>).hello {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I'm the largest animal that has ever lived on this planet.</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    tasks.register(&quot;hello&quot;) {
        doLast {
            println(&quot;I'm ${this.project.name}&quot;)
        }
    }
}
subprojects {
    tasks.named(&quot;hello&quot;) {
        doLast {
            println(&quot;- I depend on water&quot;)
        }
    }
}
project(&quot;:bluewhale&quot;).tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;- I'm the largest animal that has ever lived on this planet.&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如前所述，我们通常更喜欢将项目特定的行为放入该项目的构建脚本中。让我们进行重构，并向其中添加一些项目特定的行为<code>krill</code>项目。</p>
</div>
<div class="exampleblock">
<div class="title">示例190定义项目磷虾的特定行为</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> bluewhale
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> krill
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── bluewhale
│   └── build.gradle.kts
├── build.gradle.kts
├── krill
│   └── build.gradle.kts
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/spreadSpecifics/water</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">water</span><span class="delimiter">'</span></span>
include <span class="string"><span class="delimiter">'</span><span class="content">bluewhale</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">krill</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">bluewhale / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">hello.doLast {
  println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I'm the largest animal that has ever lived on this planet.</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">磷虾/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">hello.doLast {
  println <span class="string"><span class="delimiter">&quot;</span><span class="content">- The weight of my species in summer is twice as heavy as all human beings.</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.project.name</span><span class="delimiter">&quot;</span></span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I depend on water</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;water&quot;
include(&quot;bluewhale&quot;, &quot;krill&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">bluewhale / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;- I'm the largest animal that has ever lived on this planet.&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">磷虾/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;- The weight of my species in summer is twice as heavy as all human beings.&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    tasks.register(&quot;hello&quot;) {
        doLast {
            println(&quot;I'm ${this.project.name}&quot;)
        }
    }
}
subprojects {
    tasks.named(&quot;hello&quot;) {
        doLast {
            println(&quot;- I depend on water&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q hello</code></div>
<div class="content">
<pre>&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub:project_filtering"><a class="anchor" href="#sub:project_filtering"></a> <a class="link" href="#sub:project_filtering">项目过滤</a></h5>
<div class="paragraph">
<p>为了展示配置注入的更多功能，让我们添加另一个项目，名为<code>tropicalFish</code>并通过的构建脚本向构建中添加更多行为<code>water</code>项目。</p>
</div>
<div class="sect5">
<h6 id="ssub:filtering_by_name"><a class="anchor" href="#ssub:filtering_by_name"></a> <a class="link" href="#ssub:filtering_by_name">按名称过滤</a></h6>
<div class="exampleblock">
<div class="title">例子191。向某些项目添加自定义行为（按项目名称过滤）</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> bluewhale/
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> krill/
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> settings.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> tropicalFish/</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── bluewhale/
│   └── build.gradle.kts
├── build.gradle.kts
├── krill/
│   └── build.gradle.kts
├── settings.gradle.kts
└── tropicalFish/</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/addTropical/water</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">water</span><span class="delimiter">'</span></span>
include <span class="string"><span class="delimiter">'</span><span class="content">bluewhale</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">krill</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">tropicalFish</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.project.name</span><span class="delimiter">&quot;</span></span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I depend on water</span><span class="delimiter">&quot;</span></span>
        }
    }
}
configure(subprojects.findAll {<span class="local-variable">it</span>.name != <span class="string"><span class="delimiter">'</span><span class="content">tropicalFish</span><span class="delimiter">'</span></span>}) {
    hello {
        doLast {
            println <span class="string"><span class="delimiter">'</span><span class="content">- I love to spend time in the arctic waters.</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;water&quot;
include(&quot;bluewhale&quot;, &quot;krill&quot;, &quot;tropicalFish&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    tasks.register(&quot;hello&quot;) {
        doLast {
            println(&quot;I'm ${this.project.name}&quot;)
        }
    }
}
subprojects {
    tasks.named(&quot;hello&quot;) {
        doLast {
            println(&quot;- I depend on water&quot;)
        }
    }
}
configure(subprojects.filter { it.name != &quot;tropicalFish&quot; }) {
    tasks.named(&quot;hello&quot;) {
        doLast {
            println(&quot;- I love to spend time in the arctic waters.&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q hello</code></div>
<div class="content">
<pre>&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I love to spend time in the arctic waters.
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water
- I love to spend time in the arctic waters.
- The weight of my species in summer is twice as heavy as all human beings.
I'm tropicalFish
- I depend on water</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>configure()</code>方法使用列表作为参数，并将配置应用于此列表中的项目。</p>
</div>
</div>
<div class="sect5">
<h6 id="ssub:filtering_by_properties"><a class="anchor" href="#ssub:filtering_by_properties"></a> <a class="link" href="#ssub:filtering_by_properties">按属性过滤</a></h6>
<div class="paragraph">
<p>使用项目名称进行过滤是一种选择。使用<a href="#sec:extra_properties">额外的项目属性</a>是另一种方法。</p>
</div>
<div class="exampleblock">
<div class="title">示例192向某些项目添加自定义行为（按项目属性过滤）</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> bluewhale
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> krill
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> settings.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> tropicalFish
    <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── bluewhale
│   └── build.gradle.kts
├── build.gradle.kts
├── krill
│   └── build.gradle.kts
├── settings.gradle.kts
└── tropicalFish
    └── build.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/tropicalWithProperties/water</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">water</span><span class="delimiter">'</span></span>
include <span class="string"><span class="delimiter">'</span><span class="content">bluewhale</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">krill</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">tropicalFish</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">bluewhale / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.arctic = <span class="predefined-constant">true</span>
hello.doLast {
  println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I'm the largest animal that has ever lived on this planet.</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">磷虾/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.arctic = <span class="predefined-constant">true</span>
hello.doLast {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">- The weight of my species in summer is twice as heavy as all human beings.</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">I'm </span><span class="inline"><span class="inline-delimiter">$</span>task</span><span class="content">.project.name</span><span class="delimiter">&quot;</span></span>
        }
    }
}
subprojects {
    hello {
        doLast {println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I depend on water</span><span class="delimiter">&quot;</span></span>}
    }

    afterEvaluate { Project project -&gt;
        <span class="keyword">if</span> (project.arctic) {
            hello.configure {
                doLast {
                    println <span class="string"><span class="delimiter">'</span><span class="content">- I love to spend time in the arctic waters.</span><span class="delimiter">'</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">TropicalFish / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.arctic = <span class="predefined-constant">false</span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;water&quot;
include(&quot;bluewhale&quot;, &quot;krill&quot;, &quot;tropicalFish&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">bluewhale / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;arctic&quot;] = true
tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;- I'm the largest animal that has ever lived on this planet.&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">磷虾/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;arctic&quot;] = true
tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;- The weight of my species in summer is twice as heavy as all human beings.&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    tasks.register(&quot;hello&quot;) {
        doLast {
            println(&quot;I'm ${this.project.name}&quot;)
        }
    }
}
subprojects {
    val hello by tasks.existing

    hello {
        doLast { println(&quot;- I depend on water&quot;) }
    }

    afterEvaluate {
        if (extra[&quot;arctic&quot;] as Boolean) {
            hello {
                doLast {
                    println(&quot;- I love to spend time in the arctic waters.&quot;)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">TropicalFish / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;arctic&quot;] = false</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q hello</code></div>
<div class="content">
<pre>&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
- I love to spend time in the arctic waters.
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.
- I love to spend time in the arctic waters.
I'm tropicalFish
- I depend on water</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在构建文件中<code>water</code>我们使用的项目<code>afterEvaluate</code>通知。这意味着在评估子项目的构建脚本<em>之后</em> ，将评估我们传递的闭包。作为财产<code>arctic</code>是在那些构建脚本中设置的，我们必须这样做。您将在“ <a href="#sec:dependencies_which_dependencies">依赖关系-哪些依赖关系？”中</a>找到有关此主题的更多信息<a href="#sec:dependencies_which_dependencies">。</a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:execution_rules_for_multi_project_builds"><a class="anchor" href="#sec:execution_rules_for_multi_project_builds"></a> <a class="link" href="#sec:execution_rules_for_multi_project_builds">多项目构建的执行规则</a></h4>
<div class="paragraph">
<p>当我们执行<code>hello</code>在根项目目录中执行任务时，事情以直观的方式表现。所有的<code>hello</code>执行了不同项目的任务。让我们切换到<code>bluewhale</code> dir，看看如果我们从那里执行Gradle会发生什么。</p>
</div>
<div class="listingblock">
<div class="title">从子项目运行构建</div>
<div class="content">
<pre>&gt; gradle -q hello
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
- I love to spend time in the arctic waters.</pre>
</div>
</div>
<div class="paragraph">
<p>Gradle行为的基本规则很简单。Gradle从<em>当前目录</em>开始向下查找层次结构，以查找名称为的任务<code>hello</code>并执行它们。需要注意的一件事很重要。Gradle <em>始终</em>评估多项目构建中的<em>每个</em>项目并创建所有现有任务对象。然后，根据任务名称参数和当前目录，Gradle过滤应执行的任务。由于Gradle的跨项目配置，必须在执行<em>任何</em>任务之前对<em>每个</em>项目进行评估。在下一部分中，我们将对此进行更详细的研究。现在让我们来看最后一个海洋示例。让我们添加一个任务<code>bluewhale</code>和<code>krill</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例193。项目评估与执行</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">bluewhale / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.arctic = <span class="predefined-constant">true</span>
hello {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">- I'm the largest animal that has ever lived on this planet.</span><span class="delimiter">&quot;</span></span>
    }
}

task distanceToIceberg {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">20 nautical miles</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">磷虾/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.arctic = <span class="predefined-constant">true</span>
hello {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">- The weight of my species in summer is twice as heavy as all human beings.</span><span class="delimiter">&quot;</span></span>
    }
}

task distanceToIceberg {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">5 nautical miles</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">bluewhale / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;arctic&quot;] = true
tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;- I'm the largest animal that has ever lived on this planet.&quot;)
    }
}

tasks.register(&quot;distanceToIceberg&quot;) {
    doLast {
        println(&quot;20 nautical miles&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">磷虾/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;arctic&quot;] = true
tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;- The weight of my species in summer is twice as heavy as all human beings.&quot;)
    }
}

tasks.register(&quot;distanceToIceberg&quot;) {
    doLast {
        println(&quot;5 nautical miles&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q distanceToIceberg</code></div>
<div class="content">
<pre>&gt; gradle -q distanceToIceberg
20 nautical miles
5 nautical miles</pre>
</div>
</div>
<div class="paragraph">
<p>这是没有输出的输出<code>-q</code>选项：</p>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle distanceToIceberg</code></strong></div>
<div class="content">
<pre>&gt; gradle distanceToIceberg

&gt; Task :bluewhale:distanceToIceberg
20 nautical miles

&gt; Task :krill:distanceToIceberg
5 nautical miles

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该构建是从<code>water</code>项目。都没有<code>water</code>也不<code>tropicalFish</code>有一个名字叫的任务<code>distanceToIceberg</code> 。Gradle不在乎。上面已经提到的简单规则是：在具有该名称的层次结构中执行所有任务。只抱怨<em>没有</em>这样的任务！</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:running_partial_build_from_the_root"><a class="anchor" href="#sec:running_partial_build_from_the_root"></a> <a class="link" href="#sec:running_partial_build_from_the_root">按其绝对路径运行任务</a></h4>
<div class="paragraph">
<p>如我们所见，您可以通过输入任何子项目目录来运行多项目构建，然后从那里执行构建。从当前目录开始，将执行项目层次结构的所有匹配任务名称。但是Gradle还提供了按其绝对路径执行任务的方法（另请参见<a href="#sec:project_and_task_paths">Project和task路径</a> ）：</p>
</div>
<div class="listingblock">
<div class="title">按其绝对路径运行任务</div>
<div class="content">
<pre>&gt; gradle -q :hello :krill:hello hello
I'm water
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.
- I love to spend time in the arctic waters.
I'm tropicalFish
- I depend on water</pre>
</div>
</div>
<div class="paragraph">
<p>该构建是从<code>tropicalFish</code>项目。我们执行<code>hello</code>的任务<code>water</code> ， <code>krill</code>和<code>tropicalFish</code>项目。前两个任务由其绝对路径指定，最后一个任务使用上述名称匹配机制执行。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:project_and_task_paths"><a class="anchor" href="#sec:project_and_task_paths"></a> <a class="link" href="#sec:project_and_task_paths">项目和任务路径</a></h4>
<div class="paragraph">
<p>项目路径具有以下模式：它以一个可选的冒号开始，该冒号表示根项目。根项目是路径中唯一没有由其名称指定的项目。项目路径的其余部分是用冒号分隔的项目名称序列，其中下一个项目是上一个项目的子项目。</p>
</div>
<div class="paragraph">
<p>任务的路径只是其项目路径加上任务名称，例如“ <code>:bluewhale:hello</code> ”。在项目内，您可以仅通过名称来解决同一项目的任务。这被解释为相对路径。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:dependencies_which_dependencies"><a class="anchor" href="#sec:dependencies_which_dependencies"></a> <a class="link" href="#sec:dependencies_which_dependencies">依赖关系-哪些依赖关系？</a></h4>
<div class="paragraph">
<p>上一节中的示例非常特殊，因为这些项目没有<em>执行依赖项</em> 。他们只有<em>配置依赖项</em> 。以下各节说明了这两种依赖关系之间的区别。</p>
</div>
<div class="sect4">
<h5 id="sub:execution_time_dependencies"><a class="anchor" href="#sub:execution_time_dependencies"></a> <a class="link" href="#sub:execution_time_dependencies">执行依赖</a></h5>
<div class="sect5">
<h6 id="ssub:dependencies_and_execution_order"><a class="anchor" href="#ssub:dependencies_and_execution_order"></a> <a class="link" href="#ssub:dependencies_and_execution_order">依赖关系和执行顺序</a></h6>
<div class="exampleblock">
<div class="title">示例194。依赖关系和执行顺序</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> consumer
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> producer
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── build.gradle.kts
├── consumer
│   └── build.gradle.kts
├── producer
│   └── build.gradle.kts
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/dependencies/firstMessages/messages</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.producerMessage = <span class="predefined-constant">null</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">include <span class="string"><span class="delimiter">'</span><span class="content">consumer</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">producer</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task action {
    doLast {
        println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Consuming message: </span><span class="inline"><span class="inline-delimiter">${</span>rootProject.producerMessage<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task action {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Producing message:</span><span class="delimiter">&quot;</span></span>
        rootProject.producerMessage = <span class="string"><span class="delimiter">'</span><span class="content">Watch the order of execution.</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;producerMessage&quot;] = null</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">include(&quot;consumer&quot;, &quot;producer&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;action&quot;) {
    doLast {
        println(&quot;Consuming message: ${rootProject.extra[&quot;producerMessage&quot;]}&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;action&quot;) {
    doLast {
        println(&quot;Producing message:&quot;)
        rootProject.extra[&quot;producerMessage&quot;] = &quot;Watch the order of execution.&quot;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q action</code></div>
<div class="content">
<pre>&gt; gradle -q action
Consuming message: null
Producing message:</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这并不能完全满足我们的要求。如果没有其他定义，Gradle将按字母数字顺序执行任务。因此，Gradle将执行“ <code>:consumer:action</code> “之前” <code>:producer:action</code> ”。让我们尝试通过破解来解决此问题，并将生产者项目重命名为“ <code>aProducer</code> ”。</p>
</div>
<div class="exampleblock">
<div class="title">示例195依赖关系和执行顺序</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> aProducer
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> consumer
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── aProducer
│   └── build.gradle.kts
├── build.gradle.kts
├── consumer
│   └── build.gradle.kts
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.producerMessage = <span class="predefined-constant">null</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">include <span class="string"><span class="delimiter">'</span><span class="content">consumer</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">aProducer</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task action {
    doLast {
        println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Consuming message: </span><span class="inline"><span class="inline-delimiter">${</span>rootProject.producerMessage<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">aProducer / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task action {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Producing message:</span><span class="delimiter">&quot;</span></span>
        rootProject.producerMessage = <span class="string"><span class="delimiter">'</span><span class="content">Watch the order of execution.</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;producerMessage&quot;] = null</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">include(&quot;consumer&quot;, &quot;aProducer&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;action&quot;) {
    doLast {
        println(&quot;Consuming message: ${rootProject.extra[&quot;producerMessage&quot;]}&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">aProducer / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;action&quot;) {
    doLast {
        println(&quot;Producing message:&quot;)
        rootProject.extra[&quot;producerMessage&quot;] = &quot;Watch the order of execution.&quot;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q action</code></div>
<div class="content">
<pre>&gt; gradle -q action
Producing message:
Consuming message: Watch the order of execution.</pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果我们切换到<code>consumer</code> dir并执行构建。</p>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q action</code>来自<code>consumer</code>目录</div>
<div class="content">
<pre>&gt; gradle -q action
Consuming message: null</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>问题是两个“ <code>action</code>任务无关。如果您从“ <code>messages</code> Gradle项目会同时执行这两个操作，因为它们具有相同的名称并且位于层次结构中。在最后一个示例中，只有一个“ <code>action</code> ”任务属于层次结构，因此它是唯一执行的任务。我们需要比这个技巧更好的东西。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub:real_life_examples"><a class="anchor" href="#sub:real_life_examples"></a> <a class="link" href="#sub:real_life_examples">现实生活中的例子</a></h5>
<div class="paragraph">
<p>Gradle的多项目功能由现实生活中的用例驱动。一个很好的示例由两个Web应用程序项目和一个父项目组成，该父项目创建了包含两个Web应用程序的发行版。 <sup class="footnote">[ <a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="查看脚注。">6</a> ]</sup> 对于该示例，我们仅使用一个构建脚本并进行<em>跨项目配置</em> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子196。依赖关系-实际示例-跨项目配置</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> date
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> src
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> main
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">├</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> org
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> sample
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> DateServlet.java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> webapp
<span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> web.xml
<span class="error">├</span><span class="error">─</span><span class="error">─</span> hello
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> src
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> main
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">├</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> org
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> sample
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> HelloServlet.java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> webapp
<span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> web.xml
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── build.gradle.kts
├── date
│   └── src
│       └── main
│           ├── java
│           │   └── org
│           │       └── gradle
│           │           └── sample
│           │               └── DateServlet.java
│           └── webapp
│               └── web.xml
├── hello
│   └── src
│       └── main
│           ├── java
│           │   └── org
│           │       └── gradle
│           │           └── sample
│           │               └── HelloServlet.java
│           └── webapp
│               └── web.xml
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/dependencies/webDist</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">webDist</span><span class="delimiter">'</span></span>
include <span class="string"><span class="delimiter">'</span><span class="content">date</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">allprojects {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
    group = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>
    version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>
}

subprojects {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">war</span><span class="delimiter">'</span></span>
    repositories {
        mavenCentral()
    }
    dependencies {
        implementation <span class="string"><span class="delimiter">&quot;</span><span class="content">javax.servlet:servlet-api:2.5</span><span class="delimiter">&quot;</span></span>
    }
}

task explodedDist(<span class="key">type</span>: Copy) {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/explodedDist</span><span class="delimiter">&quot;</span></span>
    subprojects {
        from tasks.withType(War)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;webDist&quot;
include(&quot;date&quot;, &quot;hello&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">allprojects {
    apply(plugin = &quot;java&quot;)
    group = &quot;org.gradle.sample&quot;
    version = &quot;1.0&quot;
}

subprojects {
    apply(plugin = &quot;war&quot;)
    repositories {
        mavenCentral()
    }
    dependencies {
        &quot;providedCompile&quot;(&quot;javax.servlet:servlet-api:2.5&quot;)
    }
}

tasks.register&lt;Copy&gt;(&quot;explodedDist&quot;) {
    into(&quot;$buildDir/explodedDist&quot;)
    subprojects {
        from(tasks.withType&lt;War&gt;())
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们有一组有趣的依赖项。显然<code>date</code>和<code>hello</code>项目具有<em>配置</em>依赖性<code>webDist</code> ，因为webapp项目的所有构建逻辑都是由<code>webDist</code> 。<em>执行</em>依赖关系是另一个方向<code>webDist</code>取决于<code>date</code>和<code>hello</code> 。甚至还有第三种依赖性。 <code>webDist</code>具有<em>配置</em>依赖性<code>date</code>和<code>hello</code>因为它需要知道<code>archivePath</code> 。但是它在<em>执行时</em>要求提供此信息。因此，我们没有循环依赖。</p>
</div>
<div class="paragraph">
<p>这种依赖模式是多项目构建问题空间中的日常工作。如果构建系统不支持这些模式，那么您要么无法解决问题，要么需要进行难看的黑客攻击，这些黑客难以维护并且严重损害了您作为构建大师的生产力。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:project_jar_dependencies"><a class="anchor" href="#sec:project_jar_dependencies"></a> <a class="link" href="#sec:project_jar_dependencies">项目库依赖项</a></h4>
<div class="paragraph">
<p>如果一个项目在编译路径中需要另一个项目生成的jar，而不仅是jar，还需要该jar的可传递依赖项，该怎么办？显然，这是Java多项目构建的非常常见的用例。如<a href="#sub:project_dependencies">项目依赖项中所述</a> ，Gradle为此提供了项目库依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">实施例197。项目库依赖项</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> api
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> src
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">├</span><span class="error">─</span><span class="error">─</span> main
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> org
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> sample
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>                 <span class="error">├</span><span class="error">─</span><span class="error">─</span> api
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>                 <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> Person.java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>                 <span class="error">└</span><span class="error">─</span><span class="error">─</span> apiImpl
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>                     <span class="error">└</span><span class="error">─</span><span class="error">─</span> PersonImpl.java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> test
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> org
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                 <span class="error">└</span><span class="error">─</span><span class="error">─</span> gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                     <span class="error">└</span><span class="error">─</span><span class="error">─</span> PersonTest.java
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> services
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> personService
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> src
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">├</span><span class="error">─</span><span class="error">─</span> main
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> org
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> sample
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>                 <span class="error">└</span><span class="error">─</span><span class="error">─</span> services
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">│</span><span class="error"> </span><span class="error"> </span>                     <span class="error">└</span><span class="error">─</span><span class="error">─</span> PersonService.java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> test
<span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                 <span class="error">└</span><span class="error">─</span><span class="error">─</span> org
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                     <span class="error">└</span><span class="error">─</span><span class="error">─</span> gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                         <span class="error">└</span><span class="error">─</span><span class="error">─</span> sample
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                             <span class="error">└</span><span class="error">─</span><span class="error">─</span> services
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                                 <span class="error">└</span><span class="error">─</span><span class="error">─</span> PersonServiceTest.java
<span class="error">├</span><span class="error">─</span><span class="error">─</span> settings.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> shared
    <span class="error">└</span><span class="error">─</span><span class="error">─</span> src
        <span class="error">└</span><span class="error">─</span><span class="error">─</span> main
            <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
                <span class="error">└</span><span class="error">─</span><span class="error">─</span> org
                    <span class="error">└</span><span class="error">─</span><span class="error">─</span> gradle
                        <span class="error">└</span><span class="error">─</span><span class="error">─</span> sample
                            <span class="error">└</span><span class="error">─</span><span class="error">─</span> shared
                                <span class="error">└</span><span class="error">─</span><span class="error">─</span> Helper.java</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">项目布局</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── api
│   └── src
│       ├── main
│       │   └── java
│       │       └── org
│       │           └── gradle
│       │               └── sample
│       │                   ├── api
│       │                   │   └── Person.java
│       │                   └── apiImpl
│       │                       └── PersonImpl.java
│       └── test
│           └── java
│               └── org
│                   └── gradle
│                       └── PersonTest.java
├── build.gradle.kts
├── services
│   └── personService
│       └── src
│           ├── main
│           │   └── java
│           │       └── org
│           │           └── gradle
│           │               └── sample
│           │                   └── services
│           │                       └── PersonService.java
│           └── test
│               └── java
│                   └── org
│                       └── gradle
│                           └── sample
│                               └── services
│                                   └── PersonServiceTest.java
├── settings.gradle.kts
└── shared
    └── src
        └── main
            └── java
                └── org
                    └── gradle
                        └── sample
                            └── shared
                                └── Helper.java</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/multiproject/dependencies/java</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们有项目“ <code>shared</code> ”，“ <code>api</code> ”和“ <code>personService</code> ”。“ <code>personService</code> ”项目对其他两个项目具有lib依赖关系。“ <code>api</code> ”项目对“ <code>shared</code> ”项目。“ <code>services</code> ”也是一个项目，但我们只是将其用作容器。它没有构建脚本，并且没有任何内容由另一个构建脚本注入。我们使用<code>:</code>分隔符以定义项目路径。请参阅<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])">Settings.include（java.lang。String []）</a> ，以获取有关定义项目路径的更多信息。</p>
</div>
<div id="javadependencies_2" class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">include <span class="string"><span class="delimiter">'</span><span class="content">api</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">shared</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">services:personService</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

subprojects {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
    group = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>
    version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>
    repositories {
        mavenCentral()
    }
    dependencies {
        testImplementation <span class="string"><span class="delimiter">&quot;</span><span class="content">junit:junit:4.12</span><span class="delimiter">&quot;</span></span>
    }
}

project(<span class="string"><span class="delimiter">'</span><span class="content">:api</span><span class="delimiter">'</span></span>) {
    dependencies {
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:shared</span><span class="delimiter">'</span></span>)
    }
}

project(<span class="string"><span class="delimiter">'</span><span class="content">:services:personService</span><span class="delimiter">'</span></span>) {
    dependencies {
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:shared</span><span class="delimiter">'</span></span>), project(<span class="string"><span class="delimiter">'</span><span class="content">:api</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">include(&quot;api&quot;, &quot;shared&quot;, &quot;services:personService&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    apply(plugin = &quot;java&quot;)
    group = &quot;org.gradle.sample&quot;
    version = &quot;1.0&quot;
    repositories {
        mavenCentral()
    }
    dependencies {
        &quot;testImplementation&quot;(&quot;junit:junit:4.12&quot;)
    }
}

project(&quot;:api&quot;) {
    dependencies {
        &quot;implementation&quot;(project(&quot;:shared&quot;))
    }
}

project(&quot;:services:personService&quot;) {
    dependencies {
        &quot;implementation&quot;(project(&quot;:shared&quot;))
        &quot;implementation&quot;(project(&quot;:api&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>所有构建逻辑都在根项目的构建脚本中。 <sup class="footnote">[ <a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="查看脚注。">7</a> ]</sup> “ <em>lib</em> ”依赖项是执行依赖项的一种特殊形式。它导致首先构建另一个项目，并将具有另一个项目的类的jar添加到类路径。还将另一个项目的依赖项添加到类路径中。因此，您可以输入“ <code>api</code>目录并触发“ <code>gradle compile</code> ”。首先是“ <code>shared</code> ”项目建立后， <code>api</code> ”项目已建立。项目依赖性使部分多项目生成成为可能。</p>
</div>
<div class="paragraph">
<p>如果您来自Maven土地，那么您可能会对此感到完全满意。如果您来自常春藤土地，您可能会希望得到更精细的控制。Gradle为您提供以下服务：</p>
</div>
<div class="exampleblock">
<div class="title">实施例198。对依赖项的细粒度控制</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
    group = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>
    version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>
}

project(<span class="string"><span class="delimiter">'</span><span class="content">:api</span><span class="delimiter">'</span></span>) {
    configurations {
        spi
    }
    dependencies {
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:shared</span><span class="delimiter">'</span></span>)
    }
    task spiJar(<span class="key">type</span>: Jar) {
        archiveBaseName = <span class="string"><span class="delimiter">'</span><span class="content">api-spi</span><span class="delimiter">'</span></span>
        from sourceSets.main.output
        include(<span class="string"><span class="delimiter">'</span><span class="content">org/gradle/sample/api/**</span><span class="delimiter">'</span></span>)
    }
    artifacts {
        spi spiJar
    }
}

project(<span class="string"><span class="delimiter">'</span><span class="content">:services:personService</span><span class="delimiter">'</span></span>) {
    dependencies {
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:shared</span><span class="delimiter">'</span></span>)
        implementation project(<span class="key">path</span>: <span class="string"><span class="delimiter">'</span><span class="content">:api</span><span class="delimiter">'</span></span>, <span class="key">configuration</span>: <span class="string"><span class="delimiter">'</span><span class="content">spi</span><span class="delimiter">'</span></span>)
        testImplementation <span class="string"><span class="delimiter">&quot;</span><span class="content">junit:junit:4.12</span><span class="delimiter">&quot;</span></span>, project(<span class="string"><span class="delimiter">'</span><span class="content">:api</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    apply(plugin = &quot;java&quot;)
    group = &quot;org.gradle.sample&quot;
    version = &quot;1.0&quot;
}

project(&quot;:api&quot;) {
    configurations {
        create(&quot;spi&quot;)
    }
    dependencies {
        &quot;implementation&quot;(project(&quot;:shared&quot;))
    }
    tasks.register&lt;Jar&gt;(&quot;spiJar&quot;) {
        archiveBaseName.set(&quot;api-spi&quot;)
        from(project.the&lt;SourceSetContainer&gt;()[&quot;main&quot;].output)
        include(&quot;org/gradle/sample/api/**&quot;)
    }
    artifacts {
        add(&quot;spi&quot;, tasks[&quot;spiJar&quot;])
    }
}

project(&quot;:services:personService&quot;) {
    dependencies {
        &quot;implementation&quot;(project(&quot;:shared&quot;))
        &quot;implementation&quot;(project(path = &quot;:api&quot;, configuration = &quot;spi&quot;))
        &quot;testImplementation&quot;(&quot;junit:junit:4.12&quot;)
        &quot;testImplementation&quot;(project(&quot;:api&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Java插件默认情况下会向您的项目库中添加一个jar，其中包含所有类。在这个例子中，我们创建一个包含唯一的接口“ <em>其他</em>库<code>api</code> ”项目。我们将此库分配给新的<em>依赖项配置</em> 。对于人事服务，我们声明仅应根据“ <code>api</code> ”接口，但已通过“ <code>api</code> ”。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:depending_on_output_of_another_project"><a class="anchor" href="#sec:depending_on_output_of_another_project"></a> <a class="link" href="#sec:depending_on_output_of_another_project">取决于另一个项目产生的任务输出</a></h4>
<div class="paragraph">
<p><a href="#sec:project_jar_dependencies">项目依赖关系</a>模型模块之间的依赖关系。实际上，您说的是您依赖于另一个项目的主要输出。在基于Java的项目中，通常是一个JAR文件。</p>
</div>
<div class="paragraph">
<p>有时您可能想依赖于另一个任务产生的输出。反过来，您将需要确保预先执行任务以产生该输出。声明从一个项目到另一个项目的任务依赖关系是建模这种关系并引入不必要的耦合的一种糟糕方法。对这种依赖关系建模的推荐方法是产生输出，将其标记为“输出”工件，或将其添加到<code>main</code>您可以在使用项目中依赖的源集。</p>
</div>
<div class="paragraph">
<p>假设您正在使用两个子项目进行多项目构建<code>producer</code>和<code>consumer</code> 。子项目<code>producer</code>定义一个名为<code>buildInfo</code>生成包含构建信息（例如项目版本）的属性文件。属性<code>builtBy</code>负责建立推断的任务依赖关系。有关更多信息<code>builtBy</code> ，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSetOutput.html">SourceSetOutput</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例199。任务生成包含构建信息的属性文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task buildInfo(<span class="key">type</span>: BuildInfo) {
    version = project.version
    outputFile = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/generated-resources/build-info.properties</span><span class="delimiter">&quot;</span></span>)
}

sourceSets {
    main {
        output.dir(buildInfo.outputFile.parentFile, <span class="key">builtBy</span>: buildInfo)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val buildInfo by tasks.registering(BuildInfo::class) {
    version = project.version.toString()
    outputFile = file(&quot;$buildDir/generated-resources/build-info.properties&quot;)
}

sourceSets {
    main {
        output.dir(buildInfo.get().outputFile.parentFile, &quot;builtBy&quot; to buildInfo)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>消费项目应该能够在运行时读取属性文件。在生产项目上声明项目依赖关系需要事先创建属性并将其提供给运行时类路径。</p>
</div>
<div class="exampleblock">
<div class="title">示例200声明对生成属性文件的项目的项目依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    runtimeOnly project(<span class="string"><span class="delimiter">'</span><span class="content">:producer</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    runtimeOnly(project(&quot;:producer&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，使用者现在声明了对输出的依赖。 <code>producer</code>项目。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:parallel_execution"><a class="anchor" href="#sec:parallel_execution"></a> <a class="link" href="#sec:parallel_execution">并行项目执行</a></h4>
<div class="paragraph">
<p>随着开发人员桌面和CI服务器上越来越多的CPU内核可用，Gradle能够充分利用这些处理资源非常重要。更具体地说，并行执行尝试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>减少执行受IO约束或不消耗所有可用CPU资源的多项目构建的总构建时间。</p>
</li>
<li>
<p>为小型项目的执行提供更快的反馈，而无需等待其他项目的完成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管Gradle已经通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/Test.html#setMaxParallelForks-int-">Test.setMaxParallelForks（int）</a>提供了并行测试执行，但本节中介绍的功能是在项目级别上并行执行。</p>
</div>
<div class="paragraph">
<p>并行项目执行允许并行执行已解耦的多项目构建中的各个项目（另请参见<a href="#sec:decoupled_projects">解耦项目</a> ）。尽管并行执行并不需要在配置时进行解耦，但长期目标是提供一套功能强大的功能，这些功能可用于完全解耦的项目。这些功能包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:configuration_on_demand">按需配置</a> 。</p>
</li>
<li>
<p>并行配置项目。</p>
</li>
<li>
<p>对未更改的项目重复使用配置。</p>
</li>
<li>
<p>项目级别的最新检查。</p>
</li>
<li>
<p>使用预先构建的工件代替构建依赖项目。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>并行执行如何工作？首先，您需要告诉Gradle使用并行模式。您可以使用<a href="#sec:command_line_performance"><code>--parallel</code>命令行参数</a>或配置您的构建环境（ <a href="#sec:gradle_configuration_properties">Gradle属性</a> ）。除非您提供特定数量的并行线程，否则Gradle会尝试根据可用的CPU内核选择正确的数量。每个并行工作者在执行任务时都专有拥有一个给定的项目。完全支持任务依赖关系，并行工作者将首先开始执行上游任务。请记住，在并行模式下不能保证解耦任务的字母顺序（在顺序执行期间可以看到）。换句话说，在并行模式下，任务将在它们的依赖关系完成后<em>立即运行</em> ，并且可以使用<em>任务工作程序来运行它们</em> ，这可能早于在顺序构建期间开始的任务。您应确保正确声明了任务相关性和任务输入/输出，以避免出现排序问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:decoupled_projects"><a class="anchor" href="#sec:decoupled_projects"></a> <a class="link" href="#sec:decoupled_projects">解耦项目</a></h4>
<div class="paragraph">
<p>Gradle允许任何项目在配置和执行阶段都可以访问任何其他项目。尽管这为构建作者提供了强大的功能和灵活性，但同时也限制了Gradle在构建这些项目时所具有的灵活性。例如，这有效地阻止了Gradle正确地并行构建多个项目，仅配置项目的子集，或替代了预先构建的工件来代替项目依赖项。</p>
</div>
<div class="paragraph">
<p>如果两个项目不直接访问彼此的项目模型，则据说它们是<em>分离</em>的。解耦的项目只能根据声明的依赖项进行交互： <a href="#sub:project_dependencies">项目依赖项</a>和/或<a href="#sec:task_dependencies">任务依赖项</a> 。项目交互的任何其他形式（即，通过修改另一个项目对象或通过从另一个项目对象读取值）都会导致项目耦合。在配置阶段进行耦合的结果是，如果使用“按需配置”选项调用gradle，则生成的结果可能会在几种方面存在缺陷。在执行阶段进行耦合的结果是，如果使用parallel选项调用gradle，则一个项目任务会运行得太晚而无法影响并行构建项目的任务。Gradle不会尝试检测耦合并警告用户，因为引入耦合的可能性太多。</p>
</div>
<div class="paragraph">
<p>耦合项目的一种非常常见的方法是使用<a href="#sec:cross_project_configuration">配置注入</a> 。可能不会立即显现出来，但可以使用Gradle等关键功能<code>allprojects</code>和<code>subprojects</code>关键字会自动导致您的项目结合在一起。这是因为这些关键字用于<code>build.gradle</code>文件，它定义一个项目。通常，这是一个“根项目”，除了定义通用配置外，别无所求，但是就Gradle而言，该根项目仍然是成熟的项目，并且通过使用<code>allprojects</code>该项目实际上已与所有其他项目结合在一起。根项目与子项目的耦合不会影响“按需配置”，而是使用<code>allprojects</code>和<code>subprojects</code>在任何子项目的<code>build.gradle</code>文件将产生影响。</p>
</div>
<div class="paragraph">
<p>这意味着使用任何形式的共享构建脚本逻辑或配置注入（ <code>allprojects</code> ， <code>subprojects</code>等等）将导致您的项目相互关联。在扩展项目去耦概念的同时，提供利用已去耦项目的功能的同时，我们还将引入新功能，以帮助您解决常见的用例（例如配置注入），而不会导致您的项目被耦合。</p>
</div>
<div class="paragraph">
<p>为了充分利用跨项目配置，而不会遇到并行和“按需配置”选项的问题，请遵循以下建议：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>避免子项目的构建脚本引用其他子项目；首选从根项目进行交叉配置。</p>
</li>
<li>
<p>避免在执行时更改其他项目的配置。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:multiproject_build_and_test"><a class="anchor" href="#sec:multiproject_build_and_test"></a> <a class="link" href="#sec:multiproject_build_and_test">多项目构建和测试</a></h4>
<div class="paragraph">
<p>的<code>build</code> Java插件的任务通常用于编译，测试和执行单个项目的代码样式检查（如果使用了CodeQuality插件）。在多项目构建中，您可能经常需要在多个项目中执行所有这些任务。的<code>buildNeeded</code>和<code>buildDependents</code>任务可以帮助您。</p>
</div>
<div class="paragraph">
<p>在<a href="#javadependencies_2">此示例中</a> ， <code>:services:personservice</code> ”项目取决于“ <code>:api</code> ”和“ <code>:shared</code> ”项目。“ <code>:api</code> ”项目还取决于“ <code>:shared</code> ”项目。</p>
</div>
<div class="paragraph">
<p>假设您正在从事一个项目，“ <code>:api</code> ”项目。自执行清理以来，您一直在进行更改，但尚未构建整个项目。您想构建任何必要的支持jar，但仅对已更改的项目执行代码质量和单元测试。的<code>build</code>任务可以做到这一点。</p>
</div>
<div class="exampleblock">
<div class="title">示例201。构建和测试单个项目</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">输出<strong><code>gradle :api:build</code></strong></div>
<div class="content">
<pre>&gt; gradle :api:build
&gt; Task :shared:compileJava
&gt; Task :shared:processResources
&gt; Task :shared:classes
&gt; Task :shared:jar
&gt; Task :api:compileJava
&gt; Task :api:processResources
&gt; Task :api:classes
&gt; Task :api:jar
&gt; Task :api:assemble
&gt; Task :api:compileTestJava
&gt; Task :api:processTestResources
&gt; Task :api:testClasses
&gt; Task :api:test
&gt; Task :api:check
&gt; Task :api:build

BUILD SUCCESSFUL in 0s
9 actionable tasks: 9 executed</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您刚从版本控制系统获得了最新版本的源代码，其中包括其他项目中的更改， <code>:api</code>取决于”，您可能不仅要构建您依赖的所有项目，还要对其进行测试。的<code>buildNeeded</code>任务还从testRuntime配置的项目库依赖项测试所有项目。</p>
</div>
<div class="exampleblock">
<div class="title">示例202。根据项目进行构建和测试</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">输出<strong><code>gradle :api:buildNeeded</code></strong></div>
<div class="content">
<pre>&gt; gradle :api:buildNeeded
&gt; Task :shared:compileJava
&gt; Task :shared:processResources
&gt; Task :shared:classes
&gt; Task :shared:jar
&gt; Task :api:compileJava
&gt; Task :api:processResources
&gt; Task :api:classes
&gt; Task :api:jar
&gt; Task :api:assemble
&gt; Task :api:compileTestJava
&gt; Task :api:processTestResources
&gt; Task :api:testClasses
&gt; Task :api:test
&gt; Task :api:check
&gt; Task :api:build
&gt; Task :shared:assemble
&gt; Task :shared:compileTestJava
&gt; Task :shared:processTestResources
&gt; Task :shared:testClasses
&gt; Task :shared:test
&gt; Task :shared:check
&gt; Task :shared:build
&gt; Task :shared:buildNeeded
&gt; Task :api:buildNeeded

BUILD SUCCESSFUL in 0s
12 actionable tasks: 12 executed</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可能还想重构“ <code>:api</code>在其他项目中使用的项目。如果您进行这些类型的更改，仅测试“ <code>:api</code> ”项目，您还需要测试所有依赖于“ <code>:api</code> ”项目。的<code>buildDependents</code>任务还将测试在指定项目上具有项目库依赖项（在testRuntime配置中）的所有项目。</p>
</div>
<div class="exampleblock">
<div class="title">示例203。建立和测试相关项目</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">输出<strong><code>gradle :api:buildDependents</code></strong></div>
<div class="content">
<pre>&gt; gradle :api:buildDependents
&gt; Task :shared:compileJava
&gt; Task :shared:processResources
&gt; Task :shared:classes
&gt; Task :shared:jar
&gt; Task :api:compileJava
&gt; Task :api:processResources
&gt; Task :api:classes
&gt; Task :api:jar
&gt; Task :api:assemble
&gt; Task :api:compileTestJava
&gt; Task :api:processTestResources
&gt; Task :api:testClasses
&gt; Task :api:test
&gt; Task :api:check
&gt; Task :api:build
&gt; Task :services:personService:compileJava
&gt; Task :services:personService:processResources
&gt; Task :services:personService:classes
&gt; Task :services:personService:jar
&gt; Task :services:personService:assemble
&gt; Task :services:personService:compileTestJava
&gt; Task :services:personService:processTestResources
&gt; Task :services:personService:testClasses
&gt; Task :services:personService:test
&gt; Task :services:personService:check
&gt; Task :services:personService:build
&gt; Task :services:personService:buildDependents
&gt; Task :api:buildDependents

BUILD SUCCESSFUL in 0s
17 actionable tasks: 17 executed</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，您可能要构建和测试所有项目中的所有内容。您在根项目文件夹中运行的任何任务都将使相同的命名任务在所有子项上运行。所以你可以运行“ <code>gradle build</code>来构建和测试所有项目。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:multi_project_and_buildsrc"><a class="anchor" href="#sec:multi_project_and_buildsrc"></a> <a class="link" href="#sec:multi_project_and_buildsrc">多项目和buildSrc</a></h4>
<div class="paragraph">
<p><a href="#sec:build_sources">使用buildSrc来组织构建逻辑</a>告诉我们，我们可以将构建逻辑放在特殊位置进行编译和测试。 <code>buildSrc</code>目录。在多项目构建中，只能有一个<code>buildSrc</code>目录必须位于根目录中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="organizing_gradle_projects"><a class="anchor" href="#organizing_gradle_projects"></a> <a class="link" href="#organizing_gradle_projects">组织Gradle项目</a></h3>
<div class="paragraph">
<p>每个软件项目的源代码和构建逻辑都应以有意义的方式进行组织。该页面列出了导致可读性，可维护性项目的最佳实践。以下各节还介绍了常见问题以及如何避免它们。</p>
</div>
<div class="sect3">
<h4 id="sec:separate_language_source_files"><a class="anchor" href="#sec:separate_language_source_files"></a> <a class="link" href="#sec:separate_language_source_files">特定于语言的单独源文件</a></h4>
<div class="paragraph">
<p>Gradle的语言插件建立了发现和编译源代码的约定。例如，应用<a href="#java_plugin">Java插件</a>的项目将自动编译目录中的代码<code>src/main/java</code> 。其他语言插件遵循相同的模式。目录路径的最后一部分通常指示源文件的预期语言。</p>
</div>
<div class="paragraph">
<p>一些编译器能够在同一源目录中交叉编译多种语言。Groovy编译器可以处理将Java和Groovy源文件混合在一起的情况<code>src/main/groovy</code> 。Gradle建议您根据源语言将源放置在目录中，因为构建性能更高，并且用户和构建都可以做出更强的假设。</p>
</div>
<div class="paragraph">
<p>以下源代码树包含Java和Kotlin源文件。Java源文件存在<code>src/main/java</code> ，而Kotlin源文件位于<code>src/main/kotlin</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> settings.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> src
    <span class="error">└</span><span class="error">─</span><span class="error">─</span> main
        <span class="error">├</span><span class="error">─</span><span class="error">─</span> java
        <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> HelloWorld.java
        <span class="error">└</span><span class="error">─</span><span class="error">─</span> kotlin
            <span class="error">└</span><span class="error">─</span><span class="error">─</span> Utils.kt</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── build.gradle.kts
├── settings.gradle.kts
└── src
    └── main
        ├── java
        │   └── HelloWorld.java
        └── kotlin
            └── Utils.kt</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:separate_test_type_source_files"><a class="anchor" href="#sec:separate_test_type_source_files"></a> <a class="link" href="#sec:separate_test_type_source_files">每种测试类型的源文件分开</a></h4>
<div class="paragraph">
<p>一个项目定义并执行不同类型的测试是很常见的，例如单元测试，集成测试，功能测试或冒烟测试。最好将每种测试类型的测试源代码存储在专用的源目录中。分离的测试源代码对可维护性和关注点分离有积极的影响，因为您可以彼此独立地运行测试类型。</p>
</div>
<div class="paragraph">
<p>以下源代码树演示了如何在基于Java的项目中将单元与集成测试分离。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> integration-test.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> settings.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> src
    <span class="error">├</span><span class="error">─</span><span class="error">─</span> integTest
    <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
    <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> DefaultFileReaderIntegrationTest.java
    <span class="error">├</span><span class="error">─</span><span class="error">─</span> main
    <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
    <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">├</span><span class="error">─</span><span class="error">─</span> DefaultFileReader.java
    <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">├</span><span class="error">─</span><span class="error">─</span> <span class="predefined-type">FileReader</span>.java
    <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> StringUtils.java
    <span class="error">└</span><span class="error">─</span><span class="error">─</span> test
        <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
            <span class="error">└</span><span class="error">─</span><span class="error">─</span> StringUtilsTest.java</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── build.gradle.kts
├── gradle
│   └── integration-test.gradle.kts
├── settings.gradle.kts
└── src
    ├── integTest
    │   └── java
    │       └── DefaultFileReaderIntegrationTest.java
    ├── main
    │   └── java
    │       ├── DefaultFileReader.java
    │       ├── FileReader.java
    │       └── StringUtils.java
    └── test
        └── java
            └── StringUtilsTest.java</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle在<a href="#sec:java_source_sets">源集概念</a>的帮助下对源代码目录进行建模。通过将一个源集的实例指向一个或多个源代码目录，Gradle将自动创建一个相应的编译任务。</p>
</div>
<div class="exampleblock">
<div class="title">例子204。集成测试源集</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">gradle / integration-test.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    integTest {
        java.srcDir file(<span class="string"><span class="delimiter">'</span><span class="content">src/integTest/java</span><span class="delimiter">'</span></span>)
        resources.srcDir file(<span class="string"><span class="delimiter">'</span><span class="content">src/integTest/resources</span><span class="delimiter">'</span></span>)
        compileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">gradle / integration-test.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val sourceSets = the&lt;SourceSetContainer&gt;()

sourceSets {
    create(&quot;integTest&quot;) {
        java.srcDir(file(&quot;src/integTest/java&quot;))
        resources.srcDir(file(&quot;src/integTest/resources&quot;))
        compileClasspath += sourceSets[&quot;main&quot;].output + configurations[&quot;testRuntimeClasspath&quot;]
        runtimeClasspath += output + compileClasspath
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>源集仅负责编译源代码，而不处理执行字节码。为了执行<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试，</a>需要建立相应的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">Test</a>类型的任务。</p>
</div>
<div class="exampleblock">
<div class="title">范例205。集成测试任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">gradle / integration-test.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task integTest(<span class="key">type</span>: Test) {
    description = <span class="string"><span class="delimiter">'</span><span class="content">Runs the integration tests.</span><span class="delimiter">'</span></span>
    group = <span class="string"><span class="delimiter">'</span><span class="content">verification</span><span class="delimiter">'</span></span>
    testClassesDirs = sourceSets.integTest.output.classesDirs
    classpath = sourceSets.integTest.runtimeClasspath
    mustRunAfter test
}

check.dependsOn integTest</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">gradle / integration-test.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Test&gt;(&quot;integTest&quot;) {
    description = &quot;Runs the integration tests.&quot;
    group = &quot;verification&quot;
    testClassesDirs = sourceSets[&quot;integTest&quot;].output.classesDirs
    classpath = sourceSets[&quot;integTest&quot;].runtimeClasspath
    mustRunAfter(tasks[&quot;test&quot;])
}

tasks.named(&quot;check&quot;) {
    dependsOn(&quot;integTest&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:use_standard_conventions"><a class="anchor" href="#sec:use_standard_conventions"></a> <a class="link" href="#sec:use_standard_conventions">尽可能使用标准约定</a></h4>
<div class="paragraph">
<p>所有Gradle核心插件<a href="https://en.wikipedia.org/wiki/Convention_over_configuration">在配置方面均</a>遵循软件工程范例<a href="https://en.wikipedia.org/wiki/Convention_over_configuration">约定</a> 。插件逻辑可在特定上下文中为用户提供合理的默认值和标准，约定。让我们以<a href="#java_plugin">Java插件</a>为例。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它定义了目录<code>src/main/java</code>作为编译的默认源目录。</p>
</li>
<li>
<p>编译后的源代码和其他工件（如JAR文件）的输出目录为<code>build</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过遵循默认约定，项目的新开发人员立即知道如何找到解决方法。尽管可以重新配置这些约定，但使构建脚本用户和作者来管理构建逻辑及其结果变得更加困难。除非您需要适应旧项目的布局，否则请尽量遵循默认约定。请参阅相关插件的参考页面以了解其默认约定。</p>
</div>
</div>
<div class="sect3">
<h4 id="always_define_a_settings_file"><a class="anchor" href="#always_define_a_settings_file"></a> <a class="link" href="#always_define_a_settings_file">始终定义一个设置文件</a></h4>
<div class="paragraph">
<p>Gradle试图找到一个<code>settings.gradle</code> （Groovy DSL）或<code>settings.gradle.kts</code> （Kotlin DSL）文件，每次调用该构建。为此，运行时将目录树的层次结构移至根目录。一旦找到设置文件，该算法即停止搜索。</p>
</div>
<div class="paragraph">
<p>总是添加一个<code>settings.gradle</code>到构建的根目录，以避免对最初的性能产生影响。此建议适用于单个项目构建以及多个项目构建。该文件可以为空，也可以定义所需的项目名称。</p>
</div>
<div class="paragraph">
<p>具有设置文件的典型Gradle项目如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── build.gradle.kts
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_sources"><a class="anchor" href="#sec:build_sources"></a> <a class="link" href="#sec:build_sources">使用<code>buildSrc</code>抽象命令式逻辑</a></h4>
<div class="paragraph">
<p>复杂的构建逻辑通常很适合作为自定义任务或二进制插件进行封装。自定义任务和插件实现不应存在于构建脚本中。使用起来非常方便<code>buildSrc</code>为此，只要不需要在多个独立项目之间共享代码即可。</p>
</div>
<div class="paragraph">
<p>目录<code>buildSrc</code>被视为<a href="#composite_build_intro">包含的构建</a> 。发现目录后，Gradle会自动编译并测试此代码，并将其放入构建脚本的类路径中。对于多项目构建，只能有一个<code>buildSrc</code>目录，该目录必须位于根项目目录中。
<code>buildSrc</code>应该比<a href="#sec:script_plugins">脚本插件</a>更可取，因为它更易于维护，重构和测试代码。</p>
</div>
<div class="paragraph">
<p><code>buildSrc</code>使用适用于Java和Groovy项目的相同<a href="#javalayout">源代码约定</a> 。它还提供对Gradle API的直接访问。可以在专用声明中声明其他依赖项<code>build.gradle</code>下<code>buildSrc</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子206。自定义buildSrc构建脚本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}

dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}

dependencies {
    testImplementation(&quot;junit:junit:4.12&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一个典型的项目包括<code>buildSrc</code>具有以下布局。下的任何代码<code>buildSrc</code>应该使用类似于应用程序代码的软件包。（可选） <code>buildSrc</code>如果需要其他配置（例如，应用插件或声明依赖项），该目录可以托管构建脚本。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> buildSrc
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> src
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">├</span><span class="error">─</span><span class="error">─</span> main
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span> <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> com
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> enterprise
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">├</span><span class="error">─</span><span class="error">─</span> Deploy.java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> DeploymentPlugin.java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>     <span class="error">└</span><span class="error">─</span><span class="error">─</span> test
<span class="error">│</span><span class="error"> </span><span class="error"> </span>         <span class="error">└</span><span class="error">─</span><span class="error">─</span> java
<span class="error">│</span><span class="error"> </span><span class="error"> </span>             <span class="error">└</span><span class="error">─</span><span class="error">─</span> com
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                 <span class="error">└</span><span class="error">─</span><span class="error">─</span> enterprise
<span class="error">│</span><span class="error"> </span><span class="error"> </span>                     <span class="error">└</span><span class="error">─</span><span class="error">─</span> DeploymentPluginTest.java
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── build.gradle.kts
├── buildSrc
│   ├── build.gradle.kts
│   └── src
│       ├── main
│       │   └── java
│       │       └── com
│       │           └── enterprise
│       │               ├── Deploy.java
│       │               └── DeploymentPlugin.java
│       └── test
│           └── java
│               └── com
│                   └── enterprise
│                       └── DeploymentPluginTest.java
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">改变<code>buildSrc</code>导致整个项目过时。因此，当进行小的增量更改时， <a href="#sec:command_line_execution_options"><code>--no-rebuild</code>命令行选项</a>通常有助于获得更快的反馈。不过，请记住要定期或至少在完成后运行完整版本。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="declare_properties_in_gradle_properties_file"><a class="anchor" href="#declare_properties_in_gradle_properties_file"></a> <a class="link" href="#declare_properties_in_gradle_properties_file">在中声明属性<code>gradle.properties</code>文件</a></h4>
<div class="paragraph">
<p>在Gradle中，可以在构建脚本中的<code>gradle.properties</code>文件或作为命令行上的参数。</p>
</div>
<div class="paragraph">
<p>在临时方案中，通常在命令行上声明属性。例如，您可能想要仅针对构建的这一调用传递一个特定的属性值来控制运行时行为。构建脚本中的属性很容易引起维护麻烦，并且使构建脚本逻辑复杂化。的<code>gradle.properties</code>有助于将属性与构建脚本分开，应作为可行的选择加以探讨。这是放置<a href="#sec:gradle_configuration_properties">控制构建环境的属性</a>的好位置。</p>
</div>
<div class="paragraph">
<p>典型的项目设置将<code>gradle.properties</code>文件在构建的根目录中。另外，该文件也可以保存在<code>GRADLE_USER_HOME</code>目录，如果您希望将其应用于计算机上的所有内部版本。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">.
<span class="error">├</span><span class="error">─</span><span class="error">─</span> build.gradle
<span class="error">├</span><span class="error">─</span><span class="error">─</span> gradle.properties
<span class="error">└</span><span class="error">─</span><span class="error">─</span> settings.gradle</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">.
├── build.gradle.kts
├── gradle.properties
└── settings.gradle.kts</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="avoid_overlapping_task_outputs"><a class="anchor" href="#avoid_overlapping_task_outputs"></a> <a class="link" href="#avoid_overlapping_task_outputs">避免任务输出重叠</a></h4>
<div class="paragraph">
<p>任务应该定义输入和输出以获得<a href="#sec:up_to_date_checks">增量构建功能</a>的性能优势。声明任务的输出时，请确保用于写入输出的目录在项目中的所有任务中都是唯一的。</p>
</div>
<div class="paragraph">
<p>混合或覆盖由不同任务生成的输出文件会损害最新的检查，从而导致构建速度变慢。反过来，这些文件系统更改可能会阻止Gradle的<a href="#build_cache">构建缓存</a>正确识别和缓存本来可以缓存的任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:custom_gradle_distribution"><a class="anchor" href="#sec:custom_gradle_distribution"></a> <a class="link" href="#sec:custom_gradle_distribution">使用自定义Gradle发行版对构建进行标准化</a></h4>
<div class="paragraph">
<p>企业通常希望通过定义通用约定或规则来标准化组织中所有项目的构建平台。您可以借助初始化脚本来实现。
<a href="#init_scripts">初始化脚本</a>使在单台计算机上的所有项目中应用构建逻辑变得非常容易。例如，声明内部存储库及其凭证。</p>
</div>
<div class="paragraph">
<p>该方法有一些缺点。首先，您必须在公司中所有开发人员之间交流设置过程。此外，统一更新初始化脚本逻辑可能会带来挑战。</p>
</div>
<div class="paragraph">
<p>自定义Gradle发行版是解决此问题的实用方法。自定义Gradle发行版由标准Gradle发行版以及一个或多个自定义初始化脚本组成。初始化脚本与发行版捆绑在一起，并在每次运行构建时应用。开发人员只需要将签入的<a href="#gradle_wrapper">Wrapper</a>文件指向自定义Gradle发行版的URL。</p>
</div>
<div class="paragraph">
<p>自定义Gradle发行版可能还包含一个<code>gradle.properties</code>文件位于发行版根目录中，该文件提供了组织范围<a href="#sec:gradle_configuration_properties">内用于控制构建环境的一组属性</a> 。</p>
</div>
<div class="paragraph">
<p>以下步骤是创建自定义Gradle发行版的典型步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>实施用于下载和重新打包Gradle发行版的逻辑。</p>
</li>
<li>
<p>使用所需的逻辑定义一个或多个初始化脚本。</p>
</li>
<li>
<p>将初始化脚本与Gradle分发包捆绑在一起。</p>
</li>
<li>
<p>将Gradle发行档案上传到HTTP服务器。</p>
</li>
<li>
<p>更改所有项目的包装器文件，以指向自定义Gradle分发的URL。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您可以找到一个示例（ <code>userguide/organizingGradleProjects/customGradleDistribution</code> ），涵盖了<code>samples</code>标准目录<code>-all</code>摇篮分布。</p>
</div>
<div class="exampleblock">
<div class="title">示例207建立自定义的Gradle发行版</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">base</span><span class="delimiter">'</span></span>
}

<span class="comment">// This is defined in buildSrc</span>
<span class="keyword">import</span> <span class="include">org.gradle.distribution.DownloadGradle</span>

version = <span class="string"><span class="delimiter">'</span><span class="content">0.1</span><span class="delimiter">'</span></span>

task downloadGradle(<span class="key">type</span>: DownloadGradle) {
    description = <span class="string"><span class="delimiter">'</span><span class="content">Downloads the Gradle distribution with a given version.</span><span class="delimiter">'</span></span>
    gradleVersion = <span class="string"><span class="delimiter">'</span><span class="content">4.6</span><span class="delimiter">'</span></span>
}

task createCustomGradleDistribution(<span class="key">type</span>: Zip) {
    description = <span class="string"><span class="delimiter">'</span><span class="content">Builds custom Gradle distribution and bundles initialization scripts.</span><span class="delimiter">'</span></span>

    dependsOn downloadGradle

    archiveFileName = downloadGradle.gradleVersion.map { gradleVersion -&gt;
        <span class="string"><span class="delimiter">&quot;</span><span class="content">mycompany-gradle-</span><span class="inline"><span class="inline-delimiter">${</span>gradleVersion<span class="inline-delimiter">}</span></span><span class="content">-</span><span class="inline"><span class="inline-delimiter">${</span>project.version<span class="inline-delimiter">}</span></span><span class="content">-bin.zip</span><span class="delimiter">&quot;</span></span>
    }

    from zipTree(downloadGradle.destinationFile)

    from(<span class="string"><span class="delimiter">'</span><span class="content">src/init.d</span><span class="delimiter">'</span></span>) {
        into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>downloadGradle.distributionNameBase.get()<span class="inline-delimiter">}</span></span><span class="content">/init.d</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="authoring_maintainable_build_scripts"><a class="anchor" href="#authoring_maintainable_build_scripts"></a> <a class="link" href="#authoring_maintainable_build_scripts">创作可维护版本的最佳实践</a></h3>
<div class="paragraph">
<p>Gradle具有丰富的API，其中包含创建构建逻辑的几种方法。关联的灵活性很容易导致不必要的复杂构建，而自定义代码通常直接添加到构建脚本中。在本章中，我们介绍了几种最佳实践，它们将帮助您开发易于使用的表达性和可维护性版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">如果您感兴趣的话，第三方<a href="https://github.com/nebula-plugins/gradle-lint-plugin">Gradle lint插件</a>可帮助在构建脚本中强制执行所需的代码样式。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="sec:avoid_imperative_logic_in_scripts"><a class="anchor" href="#sec:avoid_imperative_logic_in_scripts"></a> <a class="link" href="#sec:avoid_imperative_logic_in_scripts">避免在脚本中使用命令式逻辑</a></h4>
<div class="paragraph">
<p>Gradle运行时不对构建逻辑强制执行特定样式。因此，很容易以将声明性DSL元素与命令性程序代码混合在一起的构建脚本结束。让我们谈一些具体的例子。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>声明性代码：</em>内置的，与语言无关的DSL元素（例如<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure)">Project.dependencies {}</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)">Project.repositories {}</a> ）或插件公开的DSL</p>
</li>
<li>
<p><em>命令性代码：</em>条件逻辑或非常复杂的任务动作实现</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个构建脚本的最终目标应该是仅包含声明性语言元素，这使代码更易于理解和维护。祈使逻辑应该存在于二进制插件中，然后将其应用于构建脚本。作为辅助产品，如果您将工件发布到二进制存储库，则可以自动使您的团队<a href="https://guides.gradle.org/designing-gradle-plugins/#reusable_logic_should_be_written_as_binary_plugin">在其他项目中重用插件逻辑</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例构建显示了直接在构建脚本中使用条件逻辑的否定示例。尽管此代码段很小，但是很容易想象使用大量过程语句的成熟的构建脚本及其对可读性和可维护性的影响。通过将代码移动到类中， <a href="https://guides.gradle.org/testing-gradle-plugins/">可测试性</a>也成为有效的选择。</p>
</div>
<div class="exampleblock">
<div class="title">实施例208。使用条件逻辑创建任务的构建脚本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">if</span> (project.findProperty(<span class="string"><span class="delimiter">'</span><span class="content">releaseEngineer</span><span class="delimiter">'</span></span>) != <span class="predefined-constant">null</span>) {
    task release {
        doLast {
            logger.quiet <span class="string"><span class="delimiter">'</span><span class="content">Releasing to production...</span><span class="delimiter">'</span></span>

            <span class="comment">// release the artifact to production</span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">if (project.findProperty(&quot;releaseEngineer&quot;) != null) {
    tasks.register(&quot;release&quot;) {
        doLast {
            logger.quiet(&quot;Releasing to production...&quot;)

            // release the artifact to production
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>让我们将构建脚本与实现为二进制插件的相同逻辑进行比较。该代码起初看起来可能涉及更多，但显然更像是典型的应用程序代码。这个特定的插件类位于<a href="#sec:build_sources"><code>buildSrc</code>目录</a> ，使其可自动用于构建脚本。</p>
</div>
<div class="exampleblock">
<div class="title">范例209。一个实现命令式逻辑的二进制插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">ReleasePlugin.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.enterprise</span>;

<span class="keyword">import</span> <span class="include">org.gradle.api.Action</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.Plugin</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.Project</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.Task</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskProvider</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ReleasePlugin</span> <span class="directive">implements</span> Plugin&lt;Project&gt; {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> RELEASE_ENG_ROLE_PROP = <span class="string"><span class="delimiter">&quot;</span><span class="content">releaseEngineer</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> RELEASE_TASK_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">release</span><span class="delimiter">&quot;</span></span>;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> apply(Project project) {
        <span class="keyword">if</span> (project.findProperty(RELEASE_ENG_ROLE_PROP) != <span class="predefined-constant">null</span>) {
            Task task = project.getTasks().create(RELEASE_TASK_NAME);

            task.doLast(<span class="keyword">new</span> <span class="predefined-type">Action</span>&lt;Task&gt;() {
                <span class="annotation">@Override</span>
                <span class="directive">public</span> <span class="type">void</span> execute(Task task) {
                    task.getLogger().quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Releasing to production...</span><span class="delimiter">&quot;</span></span>);

                    <span class="comment">// release the artifact to production</span>
                }
            });
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，构建逻辑已转换为插件，您可以在构建脚本中应用它。该构建脚本已从8行代码缩减为一个内衬。</p>
</div>
<div class="exampleblock">
<div class="title">例子210。一个构建脚本，它使用封装了命令式逻辑的插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">com.enterprise.release</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;com.enterprise.release&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:avoiding_gradle_internal_apis"><a class="anchor" href="#sec:avoiding_gradle_internal_apis"></a> <a class="link" href="#sec:avoiding_gradle_internal_apis">避免使用内部Gradle API</a></h4>
<div class="paragraph">
<p>当Gradle或插件更改时，在插件和构建脚本中使用Gradle内部API可能会破坏构建。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/gradle/gradle/blob/180b9d3fa84b91768364c603380e82947437eda1/buildSrc/subprojects/configuration/src/main/kotlin/org/gradle/gradlebuild/public-api.kt">Gradle公共API定义</a>中列出了以下软件包，但带有<code>internal</code>在名字里：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org/gradle/*
org/gradle/api/**
org/gradle/authentication/**
org/gradle/buildinit/**
org/gradle/caching/**
org/gradle/concurrent/**
org/gradle/deployment/**
org/gradle/external/javadoc/**
org/gradle/ide/**
org/gradle/includedbuild/**
org/gradle/ivy/**
org/gradle/jvm/**
org/gradle/language/**
org/gradle/maven/**
org/gradle/nativeplatform/**
org/gradle/normalization/**
org/gradle/platform/**
org/gradle/play/**
org/gradle/plugin/devel/**
org/gradle/plugin/repository/*
org/gradle/plugin/use/*
org/gradle/plugin/management/*
org/gradle/plugins/**
org/gradle/process/**
org/gradle/testfixtures/**
org/gradle/testing/jacoco/**
org/gradle/tooling/**
org/gradle/swiftpm/**
org/gradle/model/**
org/gradle/testkit/**
org/gradle/testing/**
org/gradle/vcs/**
org/gradle/workers/**</pre>
</div>
</div>
<div class="sect4">
<h5 id="alternatives_for_oft_used_internal_apis"><a class="anchor" href="#alternatives_for_oft_used_internal_apis"></a> <a class="link" href="#alternatives_for_oft_used_internal_apis">常用内部API的替代方案</a></h5>
<div class="paragraph">
<p>要为您的自定义任务提供嵌套的DSL，请不要使用<code>org.gradle.internal.reflect.Instantiator</code> ;改用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a> 。阅读<a href="#lazy_configuration">有关惰性配置的章节</a>可能也会有所帮助。</p>
</div>
<div class="paragraph">
<p>不要使用<code>org.gradle.api.internal.ConventionMapping</code> 。使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者</a>和/或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">财产</a> 。您可以在<a href="https://guides.gradle.org/implementing-gradle-plugins/#capturing_user_input_to_configure_plugin_runtime_behavior">实现插件指南中</a>找到捕获用户输入以配置运行时行为的示例。</p>
</div>
<div class="paragraph">
<p>代替<code>org.gradle.internal.os.OperatingSystem</code> ，请使用另一种方法来检测操作系统，例如<a href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/SystemUtils.html">Apache commons-lang SystemUtils</a>或<code>System.getProperty("os.name")</code> 。</p>
</div>
<div class="paragraph">
<p>使用其他集合或I / O框架代替<code>org.gradle.util.CollectionUtils</code> ， <code>org.gradle.util.GFileUtils</code> ，以及其他类<code>org.gradle.util.*</code> 。</p>
</div>
<div class="paragraph">
<p>Gradle插件作者可能会发现“设计Gradle插件”小节对<a href="https://guides.gradle.org/designing-gradle-plugins/#restricting_the_plugin_implementation_to_gradle_s_public_api">将插件实现限制为Gradle的公共API</a>有所帮助。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:declaring_tasks"><a class="anchor" href="#sec:declaring_tasks"></a> <a class="link" href="#sec:declaring_tasks">声明任务时遵循约定</a></h4>
<div class="paragraph">
<p>任务API为构建作者提供了很大的灵活性，使其可以在构建脚本中声明任务。为了获得最佳的可读性和可维护性，请遵循以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任务类型应该是任务名称后面括号内的唯一键值对。</p>
</li>
<li>
<p>其他配置应在任务的配置块内完成。</p>
</li>
<li>
<p>声明任务时添加的<a href="#sec:hello_world">任务动作</a>只能使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:doFirst(org.gradle.api.Action)">Task.doFirst {}</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:doLast(org.gradle.api.Action)">Task.doLast {}</a>方法声明。</p>
</li>
<li>
<p>在声明临时任务（没有显式类型的任务）时，如果仅声明单个操作，则应使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:doLast(org.gradle.api.Action)">Task.doLast {}</a> 。</p>
</li>
<li>
<p>一个任务应该<a href="#sec:improving_task_discoverability">定义一个组和描述</a> 。</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">示例211按照最佳实践定义任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">com.enterprise.DocsGenerate</span>

task generateHtmlDocs(<span class="key">type</span>: DocsGenerate) {
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    description = <span class="string"><span class="delimiter">'</span><span class="content">Generates the HTML documentation for this project.</span><span class="delimiter">'</span></span>
    title = <span class="string"><span class="delimiter">'</span><span class="content">Project docs</span><span class="delimiter">'</span></span>
    outputDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/docs</span><span class="delimiter">&quot;</span></span>)
}

task allDocs {
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    description = <span class="string"><span class="delimiter">'</span><span class="content">Generates all documentation for this project.</span><span class="delimiter">'</span></span>
    dependsOn generateHtmlDocs

    doLast {
        logger.quiet(<span class="string"><span class="delimiter">'</span><span class="content">Generating all documentation...</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import com.enterprise.DocsGenerate

tasks.register&lt;DocsGenerate&gt;(&quot;generateHtmlDocs&quot;) {
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    description = &quot;Generates the HTML documentation for this project.&quot;
    title = &quot;Project docs&quot;
    outputDir = file(&quot;$buildDir/docs&quot;)
}

tasks.register(&quot;allDocs&quot;) {
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    description = &quot;Generates all documentation for this project.&quot;
    dependsOn(&quot;generateHtmlDocs&quot;)

    doLast {
        logger.quiet(&quot;Generating all documentation...&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:improving_task_discoverability"><a class="anchor" href="#sec:improving_task_discoverability"></a> <a class="link" href="#sec:improving_task_discoverability">提高任务发现能力</a></h4>
<div class="paragraph">
<p>即使是构建的新用户，也应该能够快速而轻松地找到关键信息。在Gradle中，您可以为构建的任何任务声明一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:group">组</a>和一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:description">描述</a> 。<a href="#sec:listing_tasks">任务报告</a>使用分配的值来组织和呈现任务，以便于发现。分配组和描述对于您希望构建用户调用的任何任务最有帮助。</p>
</div>
<div class="paragraph">
<p>示例任务<code>generateDocs</code>生成HTML页面形式的项目文档。该任务应组织在水桶下方<code>Documentation</code> 。该描述应表达其意图。</p>
</div>
<div class="exampleblock">
<div class="title">例子212。声明组和描述的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task generateDocs {
    group = <span class="string"><span class="delimiter">'</span><span class="content">Documentation</span><span class="delimiter">'</span></span>
    description = <span class="string"><span class="delimiter">'</span><span class="content">Generates the HTML documentation for this project.</span><span class="delimiter">'</span></span>

    doLast {
        <span class="comment">// action implementation</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;generateDocs&quot;) {
    group = &quot;Documentation&quot;
    description = &quot;Generates the HTML documentation for this project.&quot;

    doLast {
        // action implementation
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>任务报告的输出反映了分配的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; gradle tasks

&gt; Task :tasks

Documentation tasks
-------------------
generateDocs - Generates the HTML documentation for this project.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:minimize_logic_executed_configuration_phase"><a class="anchor" href="#sec:minimize_logic_executed_configuration_phase"></a> <a class="link" href="#sec:minimize_logic_executed_configuration_phase">最小化在配置阶段执行的逻辑</a></h4>
<div class="paragraph">
<p>对于每个构建脚本开发人员而言，了解<a href="#build_lifecycle">构建生命周期</a>的不同阶段及其对构建逻辑的性能和评估顺序的影响都是至关重要的。在配置阶段，应<em>配置</em>项目及其域对象，而执行阶段仅执行命令行上请求的任务的动作及其依赖项。请注意，任何不属于任务动作的代码都会在<em>每次运行</em>构建时执行。<a href="https://scans.gradle.com/get-started">构建扫描</a>可以帮助您确定每个生命周期阶段所花费的时间。这是诊断常见性能问题的宝贵工具。</p>
</div>
<div class="paragraph">
<p>让我们考虑以下对反模式的描述。在构建脚本中，您可以看到分配给配置的依赖项<code>printArtifactNames</code>在任务操作之外解决。</p>
</div>
<div class="exampleblock">
<div class="title">例子213。应避免在配置过程中执行逻辑</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">log4j:log4j:1.2.17</span><span class="delimiter">'</span></span>
}

task printArtifactNames {
    <span class="comment">// always executed</span>
    <span class="keyword">def</span> libraryNames = configurations.compileClasspath.collect { <span class="local-variable">it</span>.name }

    doLast {
        logger.quiet libraryNames
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;log4j:log4j:1.2.17&quot;)
}

tasks.register(&quot;printArtifactNames&quot;) {
    // always executed
    val libraryNames = configurations.compileClasspath.get().map { it.name }

    doLast {
        logger.quiet(libraryNames.toString())
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>解决依赖关系的代码应移到任务操作中，以避免在实际需要依赖关系之前解决依赖关系带来的性能影响。</p>
</div>
<div class="exampleblock">
<div class="title">例子214。最好在执行阶段执行逻辑</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">log4j:log4j:1.2.17</span><span class="delimiter">'</span></span>
}

task printArtifactNames {
    doLast {
        <span class="keyword">def</span> libraryNames = configurations.compileClasspath.collect { <span class="local-variable">it</span>.name }
        logger.quiet libraryNames
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;log4j:log4j:1.2.17&quot;)
}

tasks.register(&quot;printArtifactNames&quot;) {
    doLast {
        val libraryNames = configurations.compileClasspath.get().map { it.name }
        logger.quiet(libraryNames.toString())
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:avoiding_use_of_gradlebuild"><a class="anchor" href="#sec:avoiding_use_of_gradlebuild"></a> <a class="link" href="#sec:avoiding_use_of_gradlebuild">避免使用<code>GradleBuild</code>任务类型</a></h4>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.GradleBuild.html">GradleBuild</a>任务类型允许构建脚本定义调用另一个Gradle构建的任务。通常不建议使用此类型。在某些极端的情况下，所调用的构建未提供与从命令行或通过Tooling API相同的运行时行为，从而导致意外结果。</p>
</div>
<div class="paragraph">
<p>通常，有一种更好的方法来对需求进行建模。适当的方法取决于当前的问题。这里有一些选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果打算将来自不同模块的任务作为统一构建执行，则将构建建模为<a href="#multi_project_builds">多项目</a>构建。</p>
</li>
<li>
<p>对于物理上分离但偶尔应作为一个单元<a href="#composite_builds">构建</a>的项目，请使用<a href="#composite_builds">复合构建</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:avoiding_inter_project_configuration"><a class="anchor" href="#sec:avoiding_inter_project_configuration"></a> <a class="link" href="#sec:avoiding_inter_project_configuration">避免项目间的配置</a></h4>
<div class="paragraph">
<p>Gradle并不限制构建脚本作者从一个项目进入<a href="#multi_project_builds">多</a>模型构建中的另一个项目的领域模型。高度耦合的项目会损害<a href="#sec:parallel_execution">构建执行性能</a>以及代码的可读性和可维护性。</p>
</div>
<div class="paragraph">
<p>应避免以下做法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])">Task.dependsOn（java.lang。对象...）</a></p>
</li>
<li>
<p>在另一个项目的域对象上设置属性值或调用方法。</p>
</li>
<li>
<p>用<a href="#sec:avoiding_use_of_gradlebuild">GradleBuild</a>执行构建的另一部分。</p>
</li>
<li>
<p>声明不必要的<a href="#sub:project_dependencies">项目依赖项</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:avoiding_passwords_in_plain_text"><a class="anchor" href="#sec:avoiding_passwords_in_plain_text"></a> <a class="link" href="#sec:avoiding_passwords_in_plain_text">避免以纯文本形式存储密码</a></h4>
<div class="paragraph">
<p>大多数构建需要使用一个或多个密码。此需求的原因可能有所不同。一些构建需要密码才能将工件发布到安全的二进制存储库，而其他构建则需要密码来下载二进制文件。密码应始终保持安全，以防止欺诈。在任何情况下，您都不应以纯文本形式将密码添加到构建脚本中，或以<code>gradle.properties</code>文件。这些文件通常位于版本控制存储库中，任何有权访问该文件的人都可以查看。</p>
</div>
<div class="paragraph">
<p>密码应以加密方式存储。目前，Gradle还没有提供用于加密，存储和访问密码的内置机制。解决此问题的一个很好的解决方案是<a href="https://github.com/etiennestuder/gradle-credentials-plugin">Gradle Credentials插件</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lazy_configuration"><a class="anchor" href="#lazy_configuration"></a> <a class="link" href="#lazy_configuration">延迟配置</a></h3>
<div class="paragraph">
<p>随着构建复杂性的增加，知道何时何地配置特定值可能变得难以推理。Gradle提供了几种使用<em>惰性配置</em>来管理这种复杂性的方法。</p>
</div>
<div class="sect3">
<h4 id="sec:lazy_properties"><a class="anchor" href="#sec:lazy_properties"></a> <a class="link" href="#sec:lazy_properties">懒惰的属性</a></h4>
<div class="paragraph">
<p>Gradle提供了惰性属性，这延迟了对属性值的计算，直到真正需要它为止。这些为构建脚本和插件作者提供了三个主要好处：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>构建作者可以将Gradle模型连接在一起，而不必担心何时知道某个特定属性的值。例如，您可能想基于扩展的源目录属性来设置任务的输入源文件，但是直到构建脚本或某些其他插件对其进行配置之前，扩展属性值才是未知的。</p>
</li>
<li>
<p>构建作者可以将任务的输出属性连接到其他任务的输入属性，Gradle会基于此连接自动确定任务依赖性。属性实例携带有关哪个任务（如果有）产生其价值的信息。构建作者无需担心使任务依赖项与配置更改保持同步。</p>
</li>
<li>
<p>构建作者可以避免在配置阶段花费大量资源，这可能会对构建性能产生重大影响。例如，当配置值来自解析文件但仅在运行功能测试时使用时，使用属性实例捕获这意味着仅在运行功能测试时才解析文件，例如， <code>clean</code>运行。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Gradle通过两个接口表示惰性属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者</a>表示只能查询而不能更改的值。</p>
<div class="ulist">
<ul>
<li>
<p>这些类型的属性是只读的。</p>
</li>
<li>
<p>方法<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#get--">Provider.get（）</a>返回属性的当前值。</p>
</li>
<li>
<p>一种<code>Provider</code>可以从另一个创建<code>Provider</code>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-">Provider.map（Transformer）</a> 。</p>
</li>
<li>
<p>许多其他类型扩展<code>Provider</code>可以在任何地方使用<code>Provider</code>是必须的。</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">属性</a>表示可以查询和更改的值。</p>
<div class="ulist">
<ul>
<li>
<p>这些类型的属性是可配置的。</p>
</li>
<li>
<p><code>Property</code>扩展<code>Provider</code>接口。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html#set-T-">Property.set（T）</a>方法为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html#set-T-">属性</a>指定一个值，覆盖可能存在的任何值。</p>
</li>
<li>
<p>方法<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html#set-org.gradle.api.provider.Provider-">Property.set（Provider）</a>指定一个<code>Provider</code>对于属性的值，覆盖可能存在的任何值。这使您可以连接在一起<code>Provider</code>和<code>Property</code>值配置之前的实例。</p>
</li>
<li>
<p>一种<code>Property</code>可以通过工厂方法<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-">ObjectFactory.property（Class）创建</a> 。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>惰性属性旨在传递，仅在需要时才查询。通常，这将在执行阶段发生。有关Gradle构建阶段的更多信息，请参见<a href="#sec:build_phases">构建生命周期</a> 。</p>
</div>
<div class="paragraph">
<p>下面演示了一个可配置的任务<code>greeting</code>属性和只读<code>message</code>从此派生的属性：</p>
</div>
<div class="exampleblock">
<div class="title">实施例215。使用只读和可配置属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// A task that displays a greeting</span>
<span class="type">class</span> <span class="class">Greeting</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// A configurable greeting</span>
    <span class="annotation">@Input</span>
    <span class="directive">final</span> Property&lt;<span class="predefined-type">String</span>&gt; greeting = project.objects.property(<span class="predefined-type">String</span>)

    <span class="comment">// Read-only property calculated from the greeting</span>
    <span class="annotation">@Internal</span>
    <span class="directive">final</span> <span class="predefined-type">Provider</span>&lt;<span class="predefined-type">String</span>&gt; message = greeting.map { <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content"> from Gradle</span><span class="delimiter">'</span></span> }

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> printMessage() {
        logger.quiet(message.get())
    }
}

task greeting(<span class="key">type</span>: Greeting) {
    <span class="comment">// Configure the greeting</span>
    greeting.set(<span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>)

    <span class="comment">// Note that an assignment statement can be used instead of calling Property.set()</span>
    greeting = <span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// A task that displays a greeting
open class Greeting : DefaultTask() {
    // Configurable by the user
    @Input
    val greeting: Property&lt;String&gt; = project.objects.property()

    // Read-only property calculated from the greeting
    @Internal
    val message: Provider&lt;String&gt; = greeting.map { it + &quot; from Gradle&quot; }

    @TaskAction
    fun printMessage() {
        logger.quiet(message.get())
    }
}

tasks.register&lt;Greeting&gt;(&quot;greeting&quot;) {
    // Configure the greeting
    greeting.set(&quot;Hi&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle greeting</code></strong></div>
<div class="content">
<pre>$ gradle greeting

&gt; Task :greeting
Hi from Gradle

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Greeting</code>任务具有类型的属性<code>Property<String></code>表示可配置的问候语和类型的属性<code>Provider<String></code>代表计算出的只读消息。讯息<code>Provider</code>从问候创建<code>Property</code>使用<code>map()</code>方法，因此当Greeting属性的值更改时，其值将保持最新。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，Gradle Groovy DSL会为每种生成设置方法<code>Property</code>任务实现中的类型属性。这些setter方法可让您使用赋值（ <code>=</code> ），以方便操作。</p>
</div>
<div class="paragraph">
<p>Kotlin DSL便利性将在将来的版本中添加。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:creating_property_provider"><a class="anchor" href="#sec:creating_property_provider"></a> <a class="link" href="#sec:creating_property_provider">创建属性或提供程序实例</a></h4>
<div class="paragraph">
<p>都没有<code>Provider</code>也不是它的子类型，例如<code>Property</code>旨在由构建脚本或插件作者实施。Gradle提供了工厂方法来创建这些类型的实例。有关所有类型和工厂的信息，请参阅《 <a href="#sec:lazy_configuration_reference">快速参考</a> 》。在前面的示例中，我们看到了两种工厂方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-">ObjectFactory.property（Class）</a>创建一个新的<code>Property</code>实例。可以从<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Project.html#getObjects--">Project.getObjects（）</a>或通过注入来引用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a>的实例。 <code>ObjectFactory</code>通过构造函数或方法。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-">Provider.map（Transformer）</a>创建一个新的<code>Provider</code>从现有的<code>Provider</code>要么<code>Property</code>实例。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一种<code>Provider</code>也可以通过工厂方法<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/ProviderFactory.html#provider-java.util.concurrent.Callable-">ProviderFactory.provider（Callable）创建</a> 。您应该更喜欢使用<code>map()</code>相反，因为它具有一些有用的好处，我们将在后面看到。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>没有特定的方法使用<code>groovy.lang.Closure</code> 。使用Groovy编写插件或构建脚本时，可以使用<code>map(Transformer)</code>带闭包的方法，Groovy将负责将闭包转换为<code>Transformer</code> 。您可以在前面的示例中看到这一点。</p>
</div>
<div class="paragraph">
<p>同样，在使用Kotlin编写插件或构建脚本时，Kotlin编译器会负责将Kotlin函数转换为<code>Transformer</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:connecting_properties_together"><a class="anchor" href="#sec:connecting_properties_together"></a> <a class="link" href="#sec:connecting_properties_together">将属性连接在一起</a></h4>
<div class="paragraph">
<p>惰性属性的重要特征是它们可以连接在一起，以便对一个属性的更改会自动反映在其他属性中。这是一个示例，其中任务的属性连接到项目扩展的属性：</p>
</div>
<div class="exampleblock">
<div class="title">例子216。将属性连接在一起</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// A project extension</span>
<span class="type">class</span> <span class="class">MessageExtension</span> {
    <span class="comment">// A configurable greeting</span>
    <span class="directive">final</span> Property&lt;<span class="predefined-type">String</span>&gt; greeting

    <span class="annotation">@javax</span>.inject.Inject
    MessageExtension(<span class="predefined-type">ObjectFactory</span> objects) {
        greeting = objects.property(<span class="predefined-type">String</span>)
    }
}

<span class="comment">// A task that displays a greeting</span>
<span class="type">class</span> <span class="class">Greeting</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// A configurable greeting</span>
    <span class="annotation">@Input</span>
    <span class="directive">final</span> Property&lt;<span class="predefined-type">String</span>&gt; greeting = project.objects.property(<span class="predefined-type">String</span>)

    <span class="comment">// Read-only property calculated from the greeting</span>
    <span class="annotation">@Internal</span>
    <span class="directive">final</span> <span class="predefined-type">Provider</span>&lt;<span class="predefined-type">String</span>&gt; message = greeting.map { <span class="local-variable">it</span> + <span class="string"><span class="delimiter">'</span><span class="content"> from Gradle</span><span class="delimiter">'</span></span> }

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> printMessage() {
        logger.quiet(message.get())
    }
}

<span class="comment">// Create the project extension</span>
project.extensions.create(<span class="string"><span class="delimiter">'</span><span class="content">messages</span><span class="delimiter">'</span></span>, MessageExtension)

<span class="comment">// Create the greeting task</span>
task greeting(<span class="key">type</span>: Greeting) {
    <span class="comment">// Attach the greeting from the project extension</span>
    <span class="comment">// Note that the values of the project extension have not been configured yet</span>
    greeting.set(project.messages.greeting)

    <span class="comment">// Note that an assignment statement can be used instead of calling Property.set()</span>
    greeting = project.messages.greeting
}

messages {
    <span class="comment">// Configure the greeting on the extension</span>
    <span class="comment">// Note that there is no need to reconfigure the task's `greeting` property. This is automatically updated as the extension property changes</span>
    greeting = <span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// A project extension
open class MessageExtension(objects: ObjectFactory) {
    // A configurable greeting
    val greeting: Property&lt;String&gt; = objects.property()
}

// A task that displays a greeting
open class Greeting : DefaultTask() {
    // Configurable by the user
    @Input
    val greeting: Property&lt;String&gt; = project.objects.property()

    // Read-only property calculated from the greeting
    @Internal
    val message: Provider&lt;String&gt; = greeting.map { it + &quot; from Gradle&quot; }

    @TaskAction
    fun printMessage() {
        logger.quiet(message.get())
    }
}

// Create the project extension
val messages = project.extensions.create(&quot;messages&quot;, MessageExtension::class)

// Create the greeting task
tasks.register&lt;Greeting&gt;(&quot;greeting&quot;) {
    // Attach the greeting from the project extension
    // Note that the values of the project extension have not been configured yet
    greeting.set(messages.greeting)
}

configure&lt;MessageExtension&gt; {
    // Configure the greeting on the extension
    // Note that there is no need to reconfigure the task's `greeting` property. This is automatically updated as the extension property changes
    greeting.set(&quot;Hi&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle greeting</code></strong></div>
<div class="content">
<pre>$ gradle greeting

&gt; Task :greeting
Hi from Gradle

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>本示例调用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html#set-org.gradle.api.provider.Provider-">Property.set（Provider）</a>方法来附加一个<code>Provider</code>到一个<code>Property</code>提供财产的价值。在这种情况下， <code>Provider</code>碰巧是一个<code>Property</code>也可以，但是您可以连接任何<code>Provider</code>实现，例如使用<code>Provider.map()</code></p>
</div>
</div>
<div class="sect3">
<h4 id="sec:working_with_files_in_lazy_properties"><a class="anchor" href="#sec:working_with_files_in_lazy_properties"></a> <a class="link" href="#sec:working_with_files_in_lazy_properties">处理文件</a></h4>
<div class="paragraph">
<p>在<a href="#working_with_files">“处理文件”中</a> ，我们引入了四种收集类型<code>File</code>类对象：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表4。文件收集回顾</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">只读类型</th>
<th class="tableblock halign-left valign-top">可配置类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">文件集</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileCollection.html">ConfigurableFileCollection</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">文件树</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileTree.html">可配置文件树</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有这些类型也被认为是惰性类型。</p>
</div>
<div class="paragraph">
<p>在本节中，我们将介绍更强类型的模型类型来表示文件系统的元素： <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/Directory.html">Directory</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/RegularFile.html">RegularFile</a> 。这些类型不应与标准Java <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html">File</a>类型混淆，因为它们用于告诉Gradle和其他人您期望更具体的值，例如目录或非目录常规文件。</p>
</div>
<div class="paragraph">
<p>Gradle提供了两个专门的<code>Property</code>用于处理以下类型的值的子类型： <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/RegularFileProperty.html">RegularFileProperty</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html">DirectoryProperty</a> 。<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a>具有创建这些方法的方法： <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#fileProperty--">ObjectFactory.fileProperty（）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#directoryProperty--">ObjectFactory.directoryProperty（）</a> 。</p>
</div>
<div class="paragraph">
<p>一种<code>DirectoryProperty</code>也可以用来创建惰性计算<code>Provider</code>为一个<code>Directory</code>和<code>RegularFile</code>分别通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#dir-java.lang.String-">DirectoryProperty.dir（String）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#file-java.lang.String-">DirectoryProperty.file（String）</a> 。这些方法会创建提供程序，其值是相对于<code>DirectoryProperty</code>它们是从创建的。这些提供程序返回的值将反映对<code>DirectoryProperty</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例217使用文件和目录属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// A task that generates a source file and writes the result to an output directory</span>
<span class="type">class</span> <span class="class">GenerateSource</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// The configuration file to use to generate the source file</span>
    <span class="annotation">@InputFile</span>
    <span class="directive">final</span> RegularFileProperty configFile = project.objects.fileProperty()

    <span class="comment">// The directory to write source files to</span>
    <span class="annotation">@OutputDirectory</span>
    <span class="directive">final</span> DirectoryProperty outputDir = project.objects.directoryProperty()

    <span class="annotation">@TaskAction</span>
    <span class="keyword">def</span> <span class="function">compile</span>() {
        <span class="keyword">def</span> inFile = configFile.get().asFile
        logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">configuration file = </span><span class="inline"><span class="inline-delimiter">$</span>inFile</span><span class="delimiter">&quot;</span></span>)
        <span class="keyword">def</span> dir = outputDir.get().asFile
        logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">output dir = </span><span class="inline"><span class="inline-delimiter">$</span>dir</span><span class="delimiter">&quot;</span></span>)
        <span class="keyword">def</span> className = inFile.text.trim()
        <span class="keyword">def</span> srcFile = <span class="keyword">new</span> <span class="predefined-type">File</span>(dir, <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>className<span class="inline-delimiter">}</span></span><span class="content">.java</span><span class="delimiter">&quot;</span></span>)
        srcFile.text = <span class="string"><span class="delimiter">&quot;</span><span class="content">public class </span><span class="inline"><span class="inline-delimiter">${</span>className<span class="inline-delimiter">}</span></span><span class="content"> { ... }</span><span class="delimiter">&quot;</span></span>
    }
}

<span class="comment">// Create the source generation task</span>
task generate(<span class="key">type</span>: GenerateSource) {
    <span class="comment">// Configure the locations, relative to the project and build directories</span>
    configFile = project.layout.projectDirectory.file(<span class="string"><span class="delimiter">'</span><span class="content">src/main/config.txt</span><span class="delimiter">'</span></span>)
    outputDir = project.layout.buildDirectory.dir(<span class="string"><span class="delimiter">'</span><span class="content">generated-source</span><span class="delimiter">'</span></span>)

    <span class="comment">// Note that a `File` instance can be used as a convenience to set a location</span>
    configFile = file(<span class="string"><span class="delimiter">'</span><span class="content">src/config.txt</span><span class="delimiter">'</span></span>)
}

<span class="comment">// Change the build directory</span>
<span class="comment">// Don't need to reconfigure the task properties. These are automatically updated as the build directory changes</span>
buildDir = <span class="string"><span class="delimiter">'</span><span class="content">output</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// A task that generates a source file and writes the result to an output directory
open class GenerateSource @javax.inject.Inject constructor(objects: ObjectFactory): DefaultTask() {
    @InputFile
    val configFile: RegularFileProperty = objects.fileProperty()

    @OutputDirectory
    val outputDir: DirectoryProperty = objects.directoryProperty()

    @TaskAction
    fun compile() {
        val inFile = configFile.get().asFile
        logger.quiet(&quot;configuration file = $inFile&quot;)
        val dir = outputDir.get().asFile
        logger.quiet(&quot;output dir = $dir&quot;)
        val className = inFile.readText().trim()
        val srcFile = File(dir, &quot;${className}.java&quot;)
        srcFile.writeText(&quot;public class ${className} { }&quot;)
    }
}

// Create the source generation task
tasks.register&lt;GenerateSource&gt;(&quot;generate&quot;) {
    // Configure the locations, relative to the project and build directories
    configFile.set(project.layout.projectDirectory.file(&quot;src/config.txt&quot;))
    outputDir.set(project.layout.buildDirectory.dir(&quot;generated-source&quot;))
}

// Change the build directory
// Don't need to reconfigure the task properties. These are automatically updated as the build directory changes
buildDir = file(&quot;output&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock multi-language-text lang-groovy">
<div class="title">输出<strong><code>gradle print</code></strong></div>
<div class="content">
<pre>$ gradle print

&gt; Task :generate
configuration file = /home/user/gradle/samples/groovy/src/config.txt
output dir = /home/user/gradle/samples/groovy/output/generated-source

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="listingblock multi-language-text lang-kotlin">
<div class="title">输出<strong><code>gradle print</code></strong></div>
<div class="content">
<pre>$ gradle print

&gt; Task :generate
configuration file = /home/user/gradle/samples/kotlin/src/config.txt
output dir = /home/user/gradle/samples/kotlin/output/generated-source

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>本示例创建表示项目位置的提供程序，并通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Project.html#getLayout--">Project.getLayout（）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html#getBuildDirectory--">ProjectLayout.getBuildDirectory（）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html#getProjectDirectory--">ProjectLayout.getProjectDirectory（）</a>构建目录。</p>
</div>
<div class="paragraph">
<p>要关闭循环，请注意<code>DirectoryProperty</code> ，或简单<code>Directory</code> ，可以变成一个<code>FileTree</code>允许使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#getAsFileTree--">DirectoryProperty.getAsFileTree（）</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/Directory.html#getAsFileTree--">Directory.getAsFileTree（）</a>查询目录中包含的文件和目录。而且，从<code>DirectoryProperty</code>或<code>Directory</code> ，您也可以创建<code>FileCollection</code>实例，该实例包含<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#files-java.lang.Object...-">DirectoryProperty.files（Object ...）</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/Directory.html#files-java.lang.Object...-">Directory.files（Object ...）</a>目录中包含的一组文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:working_with_task_dependencies_in_lazy_properties"><a class="anchor" href="#sec:working_with_task_dependencies_in_lazy_properties"></a> <a class="link" href="#sec:working_with_task_dependencies_in_lazy_properties">处理任务输入和输出</a></h4>
<div class="paragraph">
<p>许多内部版本将多个任务连接在一起，其中一个任务将另一个任务的输出作为输入。为了使这项工作有效，我们将需要配置每个任务以知道在哪里寻找其输入并放置其输出，确保生产和消费任务配置在相同的位置，并在任务之间附加任务依赖性。如果这些值中的任何一个可由用户配置或由多个插件配置，则这将很麻烦且脆弱，因为需要按正确的顺序配置任务属性，并且随着值的更改，位置和任务相关性必须保持同步。</p>
</div>
<div class="paragraph">
<p>的<code>Property</code> API不仅跟踪我们已经看到的属性值，而且还跟踪生成该值的任务，从而使此操作变得更加容易，因此您不必也指定它。例如，考虑以下带有生产者和消费者任务的插件，它们相互连接在一起：</p>
</div>
<div class="exampleblock">
<div class="title">实施例218。隐式任务输入文件依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">Producer</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@OutputFile</span>
    <span class="directive">final</span> RegularFileProperty outputFile = project.objects.fileProperty()

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> produce() {
        <span class="predefined-type">String</span> message = <span class="string"><span class="delimiter">'</span><span class="content">Hello, World!</span><span class="delimiter">'</span></span>
        <span class="keyword">def</span> output = outputFile.get().asFile
        output.text = message
        logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Wrote '</span><span class="inline"><span class="inline-delimiter">${</span>message<span class="inline-delimiter">}</span></span><span class="content">' to </span><span class="inline"><span class="inline-delimiter">${</span>output<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

<span class="type">class</span> <span class="class">Consumer</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@InputFile</span>
    <span class="directive">final</span> RegularFileProperty inputFile = project.objects.fileProperty()

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> consume() {
        <span class="keyword">def</span> input = inputFile.get().asFile
        <span class="keyword">def</span> message = input.text
        logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Read '</span><span class="inline"><span class="inline-delimiter">${</span>message<span class="inline-delimiter">}</span></span><span class="content">' from </span><span class="inline"><span class="inline-delimiter">${</span>input<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

<span class="keyword">def</span> producer = tasks.register(<span class="string"><span class="delimiter">&quot;</span><span class="content">producer</span><span class="delimiter">&quot;</span></span>, Producer)
<span class="keyword">def</span> consumer = tasks.register(<span class="string"><span class="delimiter">&quot;</span><span class="content">consumer</span><span class="delimiter">&quot;</span></span>, Consumer)

<span class="comment">// Connect the producer task output to the consumer task input</span>
<span class="comment">// Don't need to add a task dependency to the consumer task. This is automatically added</span>
consumer.configure {
    inputFile = producer.flatMap { <span class="local-variable">it</span>.outputFile }
}

<span class="comment">// Set values for the producer lazily</span>
<span class="comment">// Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes</span>
producer.configure {
    outputFile = layout.buildDirectory.file(<span class="string"><span class="delimiter">'</span><span class="content">file.txt</span><span class="delimiter">'</span></span>)
}

<span class="comment">// Change the build directory.</span>
<span class="comment">// Don't need to update producer.outputFile and consumer.inputFile. These are automatically updated as the build directory changes</span>
buildDir = <span class="string"><span class="delimiter">'</span><span class="content">output</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class Producer : DefaultTask() {
    @OutputFile
    val outputFile: RegularFileProperty = project.objects.fileProperty()

    @TaskAction
    fun produce() {
        val message = &quot;Hello, World!&quot;
        val output = outputFile.get().asFile
        output.writeText( message)
        logger.quiet(&quot;Wrote '${message}' to ${output}&quot;)
    }
}

open class Consumer : DefaultTask() {
    @InputFile
    val inputFile: RegularFileProperty = project.objects.fileProperty()

    @TaskAction
    fun consume() {
        val input = inputFile.get().asFile
        val message = input.readText()
        logger.quiet(&quot;Read '${message}' from ${input}&quot;)
    }
}

val producer by tasks.registering(Producer::class)
val consumer by tasks.registering(Consumer::class)

consumer.configure {
    // Connect the producer task output to the consumer task input
    // Don't need to add a task dependency to the consumer task. This is automatically added
    inputFile.set(producer.flatMap { it.outputFile })
}

producer.configure {
    // Set values for the producer lazily
    // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes
    outputFile.set(layout.buildDirectory.file(&quot;file.txt&quot;))
}

// Change the build directory.
// Don't need to update producer.outputFile and consumer.inputFile. These are automatically updated as the build directory changes
buildDir = file(&quot;output&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock multi-language-text lang-groovy">
<div class="title">输出<strong><code>gradle consumer</code></strong></div>
<div class="content">
<pre>$ gradle consumer

&gt; Task :producer
Wrote 'Hello, World!' to /home/user/gradle/samples/groovy/output/file.txt

&gt; Task :consumer
Read 'Hello, World!' from /home/user/gradle/samples/groovy/output/file.txt

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="listingblock multi-language-text lang-kotlin">
<div class="title">输出<strong><code>gradle consumer</code></strong></div>
<div class="content">
<pre>$ gradle consumer

&gt; Task :producer
Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/output/file.txt

&gt; Task :consumer
Read 'Hello, World!' from /home/user/gradle/samples/kotlin/output/file.txt

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，在定义任何位置之前已连接任务输出和输入。可以在执行任务之前的任何时间调用设置器，更改将自动影响所有相关的输入和输出属性。</p>
</div>
<div class="paragraph">
<p>在此示例中要注意的另一件重要事情是，没有任何明确的任务依赖性。任务输出表示为<code>Providers</code>跟踪哪个任务产生它们的值，并将它们用作任务输入将隐式添加正确的任务依赖性。</p>
</div>
<div class="paragraph">
<p>隐式任务依赖项也适用于不是文件的输入属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例219隐式任务输入依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">Producer</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@OutputFile</span>
    <span class="directive">final</span> RegularFileProperty outputFile = project.objects.fileProperty()

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> produce() {
        <span class="predefined-type">String</span> message = <span class="string"><span class="delimiter">'</span><span class="content">Hello, World!</span><span class="delimiter">'</span></span>
        <span class="keyword">def</span> output = outputFile.get().asFile
        output.text = message
        logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Wrote '</span><span class="inline"><span class="inline-delimiter">${</span>message<span class="inline-delimiter">}</span></span><span class="content">' to </span><span class="inline"><span class="inline-delimiter">${</span>output<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

<span class="type">class</span> <span class="class">Consumer</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@Input</span>
    <span class="directive">final</span> Property&lt;<span class="predefined-type">String</span>&gt; message = project.objects.property(<span class="predefined-type">String</span>)

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> consume() {
        logger.quiet(message.get())
    }
}

task producer(<span class="key">type</span>: Producer)
task consumer(<span class="key">type</span>: Consumer)

<span class="comment">// Connect the producer task output to the consumer task input</span>
<span class="comment">// Don't need to add a task dependency to the consumer task. This is automatically added</span>
consumer.message = producer.outputFile.map { <span class="local-variable">it</span>.asFile.text }

<span class="comment">// Set values for the producer lazily</span>
producer.outputFile = layout.buildDirectory.file(<span class="string"><span class="delimiter">'</span><span class="content">file.txt</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class Producer : DefaultTask() {
    @OutputFile
    val outputFile: RegularFileProperty = project.objects.fileProperty()

    @TaskAction
    fun produce() {
        val message = &quot;Hello, World!&quot;
        val output = outputFile.get().asFile
        output.writeText( message)
        logger.quiet(&quot;Wrote '${message}' to ${output}&quot;)
    }
}

open class Consumer : DefaultTask() {
    @Input
    val message: Property&lt;String&gt; = project.objects.property(String::class)

    @TaskAction
    fun consume() {
        logger.quiet(message.get())
    }
}

val producer by tasks.registering(Producer::class) {
    // Set values for the producer lazily
    // Don't need to update the consumer.inputFile property. This is automatically updated as producer.outputFile changes
    outputFile.set(layout.buildDirectory.file(&quot;file.txt&quot;))
}
val consumer by tasks.registering(Consumer::class) {
    // Connect the producer task output to the consumer task input
    // Don't need to add a task dependency to the consumer task. This is automatically added
    message.set(producer.map { it.outputFile.get().asFile.readText() })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock multi-language-text lang-groovy">
<div class="title">输出<strong><code>gradle consumer</code></strong></div>
<div class="content">
<pre>$ gradle consumer

&gt; Task :producer
Wrote 'Hello, World!' to /home/user/gradle/samples/groovy/build/file.txt

&gt; Task :consumer
Hello, World!

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="listingblock multi-language-text lang-kotlin">
<div class="title">输出<strong><code>gradle consumer</code></strong></div>
<div class="content">
<pre>$ gradle consumer

&gt; Task :producer
Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/build/file.txt

&gt; Task :consumer
Hello, World!

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:working_with_collections"><a class="anchor" href="#sec:working_with_collections"></a> <a class="link" href="#sec:working_with_collections">使用收藏</a></h4>
<div class="paragraph">
<p>Gradle提供了两种惰性属性来帮助配置<code>Collection</code>属性。这些工作完全一样<code>Provider</code>就像文件提供者一样，它们周围还有其他建模：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于<code>List</code>值接口称为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/ListProperty.html">ListProperty</a> 。您可以创建一个新的<code>ListProperty</code>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-">ObjectFactory.listProperty（Class）</a>并指定元素类型。</p>
</li>
<li>
<p>对于<code>Set</code>将该接口称为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/SetProperty.html">SetProperty</a> 。您可以创建一个新的<code>SetProperty</code>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-">ObjectFactory.setProperty（Class）</a>并指定元素类型。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种类型的属性使您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/HasMultipleValues.html#set-java.lang.Iterable-">HasMultipleValues.set（Iterable）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/HasMultipleValues.html#set-org.gradle.api.provider.Provider-">HasMultipleValues.set（Provider）</a>覆盖整个集合值，或通过各种方法添加新元素<code>add</code>方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/HasMultipleValues.html#add-T-">HasMultipleValues.add（T）</a> ：向集合中添加一个元素</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/HasMultipleValues.html#add-org.gradle.api.provider.Provider-">HasMultipleValues.add（Provider）</a> ：将惰性计算的元素添加到集合中</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/HasMultipleValues.html#addAll-org.gradle.api.provider.Provider-">HasMultipleValues.addAll（Provider）</a> ：将延迟计算的元素集合添加到列表中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就像每个<code>Provider</code> ，则在调用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#get--">Provider.get（）</a>时计算集合。以下示例显示了运行中的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/ListProperty.html">ListProperty</a> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例220清单属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">Producer</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@OutputFile</span>
    <span class="directive">final</span> RegularFileProperty outputFile = project.objects.fileProperty()

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> produce() {
        <span class="predefined-type">String</span> message = <span class="string"><span class="delimiter">'</span><span class="content">Hello, World!</span><span class="delimiter">'</span></span>
        <span class="keyword">def</span> output = outputFile.get().asFile
        output.text = message
        logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Wrote '</span><span class="inline"><span class="inline-delimiter">${</span>message<span class="inline-delimiter">}</span></span><span class="content">' to </span><span class="inline"><span class="inline-delimiter">${</span>output<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

<span class="type">class</span> <span class="class">Consumer</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@InputFiles</span>
    <span class="directive">final</span> ListProperty&lt;RegularFile&gt; inputFiles = project.objects.listProperty(RegularFile)

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> consume() {
        inputFiles.get().each { inputFile -&gt;
            <span class="keyword">def</span> input = inputFile.asFile
            <span class="keyword">def</span> message = input.text
            logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Read '</span><span class="inline"><span class="inline-delimiter">${</span>message<span class="inline-delimiter">}</span></span><span class="content">' from </span><span class="inline"><span class="inline-delimiter">${</span>input<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
        }
    }
}

task producerOne(<span class="key">type</span>: Producer)
task producerTwo(<span class="key">type</span>: Producer)
task consumer(<span class="key">type</span>: Consumer)

<span class="comment">// Connect the producer task outputs to the consumer task input</span>
<span class="comment">// Don't need to add task dependencies to the consumer task. These are automatically added</span>
consumer.inputFiles.add(producerOne.outputFile)
consumer.inputFiles.add(producerTwo.outputFile)

<span class="comment">// Set values for the producer tasks lazily</span>
<span class="comment">// Don't need to update the consumer.inputFiles property. This is automatically updated as producer.outputFile changes</span>
producerOne.outputFile = layout.buildDirectory.file(<span class="string"><span class="delimiter">'</span><span class="content">one.txt</span><span class="delimiter">'</span></span>)
producerTwo.outputFile = layout.buildDirectory.file(<span class="string"><span class="delimiter">'</span><span class="content">two.txt</span><span class="delimiter">'</span></span>)

<span class="comment">// Change the build directory.</span>
<span class="comment">// Don't need to update the task properties. These are automatically updated as the build directory changes</span>
buildDir = <span class="string"><span class="delimiter">'</span><span class="content">output</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class Producer : DefaultTask() {
    @OutputFile
    val outputFile: RegularFileProperty = project.objects.fileProperty()

    @TaskAction
    fun produce() {
        val message = &quot;Hello, World!&quot;
        val output = outputFile.get().asFile
        output.writeText( message)
        logger.quiet(&quot;Wrote '${message}' to ${output}&quot;)
    }
}

open class Consumer : DefaultTask() {
    @InputFiles
    val inputFiles: ListProperty&lt;RegularFile&gt; = project.objects.listProperty(RegularFile::class)

    @TaskAction
    fun consume() {
        inputFiles.get().forEach { inputFile -&gt;
            val input = inputFile.asFile
            val message = input.readText()
            logger.quiet(&quot;Read '${message}' from ${input}&quot;)
        }
    }
}

val producerOne by tasks.registering(Producer::class)
val producerTwo by tasks.registering(Producer::class)
val consumer by tasks.registering(Consumer::class) {
    // Connect the producer task outputs to the consumer task input
    // Don't need to add task dependencies to the consumer task. These are automatically added
    inputFiles.add(producerOne.get().outputFile)
    inputFiles.add(producerTwo.get().outputFile)
}

// Set values for the producer tasks lazily
// Don't need to update the consumer.inputFiles property. This is automatically updated as producer.outputFile changes
producerOne { outputFile.set(layout.buildDirectory.file(&quot;one.txt&quot;)) }
producerTwo { outputFile.set(layout.buildDirectory.file(&quot;two.txt&quot;)) }

// Change the build directory.
// Don't need to update the task properties. These are automatically updated as the build directory changes
buildDir = file(&quot;output&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock multi-language-text lang-groovy">
<div class="title">输出<strong><code>gradle consumer</code></strong></div>
<div class="content">
<pre>$ gradle consumer

&gt; Task :producerOne
Wrote 'Hello, World!' to /home/user/gradle/samples/groovy/output/one.txt

&gt; Task :producerTwo
Wrote 'Hello, World!' to /home/user/gradle/samples/groovy/output/two.txt

&gt; Task :consumer
Read 'Hello, World!' from /home/user/gradle/samples/groovy/output/one.txt
Read 'Hello, World!' from /home/user/gradle/samples/groovy/output/two.txt

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed</pre>
</div>
</div>
<div class="listingblock multi-language-text lang-kotlin">
<div class="title">输出<strong><code>gradle consumer</code></strong></div>
<div class="content">
<pre>$ gradle consumer

&gt; Task :producerOne
Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/output/one.txt

&gt; Task :producerTwo
Wrote 'Hello, World!' to /home/user/gradle/samples/kotlin/output/two.txt

&gt; Task :consumer
Read 'Hello, World!' from /home/user/gradle/samples/kotlin/output/one.txt
Read 'Hello, World!' from /home/user/gradle/samples/kotlin/output/two.txt

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:working_with_maps"><a class="anchor" href="#sec:working_with_maps"></a> <a class="link" href="#sec:working_with_maps">使用地图</a></h4>
<div class="paragraph">
<p>Gradle提供了一个惰性<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/MapProperty.html">MapProperty</a>类型以允许<code>Map</code>要配置的值。您可以创建一个<code>MapProperty</code>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#mapProperty-java.lang.Class-java.lang.Class-">ObjectFactory.mapProperty（Class，Class）的</a>实例。</p>
</div>
<div class="paragraph">
<p>与其他物业类型类似， <code>MapProperty</code>有一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/MapProperty.html#set-java.util.Map-">set（）</a>方法，可用于指定属性的值。还有一些其他方法可以将具有惰性值的条目添加到映射中。</p>
</div>
<div class="exampleblock">
<div class="title">示例221地图属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">Generator</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@Input</span>
    <span class="directive">final</span> MapProperty&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Integer</span>&gt; properties = project.objects.mapProperty(<span class="predefined-type">String</span>, <span class="predefined-type">Integer</span>)

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> generate() {
        properties.get().each { key, value -&gt;
            logger.quiet(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>key<span class="inline-delimiter">}</span></span><span class="content"> = </span><span class="inline"><span class="inline-delimiter">${</span>value<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
        }
    }
}

<span class="comment">// Some values to be configured later</span>
<span class="keyword">def</span> b = <span class="integer">0</span>
<span class="keyword">def</span> c = <span class="integer">0</span>

task generate(<span class="key">type</span>: Generator) {
    properties.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="integer">1</span>)
    <span class="comment">// Values have not been configured yet</span>
    properties.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>, providers.provider { b })
    properties.putAll(providers.provider { [<span class="key">c</span>: c, <span class="key">d</span>: c + <span class="integer">1</span>] })
}

<span class="comment">// Configure the values. There is no need to reconfigure the task</span>
b = <span class="integer">2</span>
c = <span class="integer">3</span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class Generator: DefaultTask() {
    @Input
    val properties: MapProperty&lt;String, Int&gt; = project.objects.mapProperty(String::class, Int::class)

    @TaskAction
    fun generate() {
        properties.get().forEach { entry -&gt;
            logger.quiet(&quot;${entry.key} = ${entry.value}&quot;)
        }
    }
}

// Some values to be configured later
var b = 0
var c = 0

tasks.register&lt;Generator&gt;(&quot;generate&quot;) {
    properties.put(&quot;a&quot;, 1)
    // Values have not been configured yet
    properties.put(&quot;b&quot;, providers.provider { b })
    properties.putAll(providers.provider { mapOf(&quot;c&quot; to c, &quot;d&quot; to c + 1) })
}

// Configure the values. There is no need to reconfigure the task
b = 2
c = 3</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle consumer</code></strong></div>
<div class="content">
<pre>$ gradle generate

&gt; Task :generate
a = 1
b = 2
c = 3
d = 4

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:applying_conventions"><a class="anchor" href="#sec:applying_conventions"></a> <a class="link" href="#sec:applying_conventions">将约定应用于属性</a></h4>
<div class="paragraph">
<p>如果尚未为该属性配置任何值，通常您希望将某些<em>约定</em>或默认值应用于该属性。您可以使用<code>convention()</code>方法。此方法接受一个值或一个<code>Provider</code>并将其用作值，直到配置了其他值。</p>
</div>
<div class="exampleblock">
<div class="title">示例222财产约定</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task show {
    doLast {
        <span class="keyword">def</span> property = objects.property(<span class="predefined-type">String</span>)

        <span class="comment">// Set a convention</span>
        property.convention(<span class="string"><span class="delimiter">&quot;</span><span class="content">convention 1</span><span class="delimiter">&quot;</span></span>)
        println(<span class="string"><span class="delimiter">&quot;</span><span class="content">value = </span><span class="delimiter">&quot;</span></span> + property.get())

        <span class="comment">// Can replace the convention</span>
        property.convention(<span class="string"><span class="delimiter">&quot;</span><span class="content">convention 2</span><span class="delimiter">&quot;</span></span>)
        println(<span class="string"><span class="delimiter">&quot;</span><span class="content">value = </span><span class="delimiter">&quot;</span></span> + property.get())

        property.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>)

        <span class="comment">// Once a value is set, the convention is ignored</span>
        property.convention(<span class="string"><span class="delimiter">&quot;</span><span class="content">ignored convention</span><span class="delimiter">&quot;</span></span>)
        println(<span class="string"><span class="delimiter">&quot;</span><span class="content">value = </span><span class="delimiter">&quot;</span></span> + property.get())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;show&quot;) {
    doLast {
        val property = objects.property(String::class)

        property.convention(&quot;convention 1&quot;)
        println(&quot;value = &quot; + property.get())

        // Can replace the convention
        property.convention(&quot;convention 2&quot;)
        println(&quot;value = &quot; + property.get())

        property.set(&quot;value&quot;)
        // Once a value is set, the convention is ignored

        property.convention(&quot;ignored convention&quot;)
        println(&quot;value = &quot; + property.get())
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle show</code></strong></div>
<div class="content">
<pre>$ gradle show

&gt; Task :show
value = convention 1
value = convention 2
value = value

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:unmodifiable_property"><a class="anchor" href="#sec:unmodifiable_property"></a> <a class="link" href="#sec:unmodifiable_property">使财产不可修改</a></h4>
<div class="paragraph">
<p>任务或项目的大多数属性旨在由插件或构建脚本配置，然后将所得的值用于做一些有用的事情。例如，为编译任务指定输出目录的属性可以从插件指定的值开始，然后构建脚本可能将其配置为某个自定义位置，然后任务在运行时使用该值。但是，一旦任务开始运行，我们希望防止对该属性进行任何进一步的更改。这样，我们可以避免使用不同属性的值来避免由不同使用者产生的错误，例如任务操作或Gradle的最新检查或构建缓存或其他任务。</p>
</div>
<div class="paragraph">
<p>惰性属性提供了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html#finalizeValue--">finalizeValue（）</a>方法来使之明确。从那时起，调用此方法将使属性实例不可修改，并且任何进一步尝试更改属性值的尝试都会失败。当任务开始执行时，Gradle会自动使任务的属性最终化。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:lazy_configuration_faqs"><a class="anchor" href="#sec:lazy_configuration_faqs"></a> <a class="link" href="#sec:lazy_configuration_faqs">指导方针</a></h4>
<div class="paragraph">
<p>本节将介绍成功使用Provider API的准则。要了解这些指导原则，请查看<a href="https://github.com/gradle-guides/gradle-site-plugin">gradle-site-plugin</a> ，这是一个Gradle插件，演示了已建立的插件开发技术和实践。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">属性</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者</a>类型具有查询或配置值所需的所有重载。因此，您应该遵循以下准则：</p>
<div class="ulist">
<ul>
<li>
<p>对于可配置的属性，直接通过单个getter公开该<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">Property</a> 。</p>
</li>
<li>
<p>对于不可配置的属性，请直接通过单个getter公开<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供程序</a> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>避免简化诸如<code>obj.getProperty().get()</code>和<code>obj.getProperty().set(T)</code>通过引入其他getter和setter在代码中使用。</p>
</li>
<li>
<p>在将插件迁移为使用提供程序时，请遵循以下准则：</p>
<div class="ulist">
<ul>
<li>
<p>如果是新属性，请使用单个getter将其公开为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">Property</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">Provider</a> 。</p>
</li>
<li>
<p>如果正在孵化，请将其更改为使用单个吸气剂使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">属性</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供程序</a> 。</p>
</li>
<li>
<p>如果它是稳定的属性，请添加新的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">属性</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者，</a>并弃用旧的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">属性</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者</a> 。您应将旧的吸气剂/装料器适当地连接到新的属性中。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:lazy_configuration_roadmap"><a class="anchor" href="#sec:lazy_configuration_roadmap"></a> <a class="link" href="#sec:lazy_configuration_roadmap">未来发展</a></h4>
<div class="paragraph">
<p>展望未来，新属性将使用提供者API。 Groovy Gradle DSL添加了便捷方法，以使在构建脚本中对提供程序的使用几乎是透明的。现有任务将根据需要并以向后兼容的方式将其现有的“原始”属性替换为提供程序。新任务将使用提供程序API设计。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:lazy_configuration_reference"><a class="anchor" href="#sec:lazy_configuration_reference"></a> <a class="link" href="#sec:lazy_configuration_reference">提供程序文件API参考</a></h4>
<div class="paragraph">
<p>将这些类型用于<em>只读</em>值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者</a> < <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/RegularFile.html">RegularFile</a> ></dt>
<dd>
<p>磁盘上的文件</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-">Provider.map（Transformer）</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-">Provider.flatMap（Transformer）</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#file-java.lang.String-">DirectoryProperty.file（String）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者</a> < <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/Directory.html">目录</a> ></dt>
<dd>
<p>磁盘上的目录</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-">Provider.map（Transformer）</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-">Provider.flatMap（Transformer）</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#dir-java.lang.String-">DirectoryProperty.dir（字符串）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">文件集</a></dt>
<dd>
<p>非结构化文件集合</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（Object []）</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object...-">ProjectLayout.files（Object ...）</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#files-java.lang.Object...-">DirectoryProperty.files（Object ...）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">文件树</a></dt>
<dd>
<p>文件层次结构</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)">Project.fileTree（Object）</a>将产生一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileTree.html">ConfigurableFileTree</a> ，或者您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Project.html#zipTree-java.lang.Object-">Project.zipTree（Object）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Project.html#tarTree-java.lang.Object-">Project.tarTree（Object）</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html#getAsFileTree--">DirectoryProperty.getAsFileTree（）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="property_files_api_reference"><a class="anchor" href="#property_files_api_reference"></a> <a class="link" href="#property_files_api_reference">属性文件API参考</a></h4>
<div class="paragraph">
<p>将这些类型用于<em>可变</em>值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/RegularFileProperty.html">RegularFileProperty</a></dt>
<dd>
<p>磁盘上的文件</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#fileProperty--">ObjectFactory.fileProperty（）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html">目录属性</a></dt>
<dd>
<p>磁盘上的目录</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#directoryProperty--">ObjectFactory.directoryProperty（）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileCollection.html">ConfigurableFileCollection</a></dt>
<dd>
<p>非结构化文件集合</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#fileCollection--">ObjectFactory.fileCollection（）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileTree.html">可配置文件树</a></dt>
<dd>
<p>文件层次结构</p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#fileTree--">ObjectFactory.fileTree（）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="lazy_collections_api_reference"><a class="anchor" href="#lazy_collections_api_reference"></a> <a class="link" href="#lazy_collections_api_reference">惰性集合API参考</a></h4>
<div class="paragraph">
<p>将这些类型用于<em>可变</em>值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/ListProperty.html">ListProperty<t></t></a></dt>
<dd>
<p>属性值为<code>List<T></code></p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-">ObjectFactory.listProperty（Class）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/SetProperty.html">设置属性<t></t></a></dt>
<dd>
<p>属性值为<code>Set<T></code></p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-">ObjectFactory.setProperty（Class）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="lazy_objects_api_reference"><a class="anchor" href="#lazy_objects_api_reference"></a> <a class="link" href="#lazy_objects_api_reference">惰性对象API参考</a></h4>
<div class="paragraph">
<p>将这些类型用于<em>只读</em>值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html">提供者<t></t></a></dt>
<dd>
<p>属性的值是的一个实例<code>T</code></p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-">Provider.map（Transformer）</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-">Provider.flatMap（Transformer）</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/ProviderFactory.html#provider-java.util.concurrent.Callable-">ProviderFactory.provider（Callable）</a> 。始终优先选择其他工厂方法之一。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>将这些类型用于<em>可变</em>值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/Property.html">属性<t></t></a></dt>
<dd>
<p>属性的值是的一个实例<code>T</code></p>
<div class="dlist">
<dl>
<dt class="hdlist1">工厂工厂</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-">ObjectFactory.property（Class）</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test_kit"><a class="anchor" href="#test_kit"></a> <a class="link" href="#test_kit">使用TestKit测试构建逻辑</a></h3>
<div class="paragraph">
<p>Gradle TestKit（又名TestKit）是一个库，可帮助测试Gradle插件并一般构建逻辑。目前，它专注于<em>功能</em>测试。也就是说，通过将其作为程序执行的构建的一部分进行测试来测试构建逻辑。随着时间的流逝，TestKit可能会扩展以方便其他类型的测试。</p>
</div>
<div class="sect3">
<h4 id="sec:testkit_usage"><a class="anchor" href="#sec:testkit_usage"></a> <a class="link" href="#sec:testkit_usage">用法</a></h4>
<div class="paragraph">
<p>要使用TestKit，请在插件的版本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例223。声明TestKit依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation gradleTestKit()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(gradleTestKit())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>gradleTestKit()</code>包含TestKit的类以及<a href="#embedding">Gradle Tooling API客户端</a> 。它不包括<a href="http://junit.org">JUnit</a> ， <a href="http://testng.org">TestNG</a>或任何其他测试执行框架的版本。必须明确声明这种依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">示例224声明JUnit依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;junit:junit:4.12&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:functional_testing_with_the_gradle_runner"><a class="anchor" href="#sec:functional_testing_with_the_gradle_runner"></a> <a class="link" href="#sec:functional_testing_with_the_gradle_runner">使用Gradle Runner进行功能测试</a></h4>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html">GradleRunner</a>有助于以编程方式执行Gradle构建并检查结果。</p>
</div>
<div class="paragraph">
<p>可以（例如以编程方式或从模板中）创建人为构建的练习“被测逻辑”。然后可以潜在地以各种方式（例如，任务和参数的不同组合）执行构建。然后可以通过断言以下内容（可能组合使用）来验证逻辑的正确性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>构建的输出；</p>
</li>
<li>
<p>构建的日志（即控制台输出）；</p>
</li>
<li>
<p>由构建执行的任务集及其结果（例如，FAILED，UP-TO-DATE等）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>创建并配置了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#build--">Runner</a>实例之后，可以根据预期结果通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#build--">GradleRunner.build（）</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#buildAndFail--">GradleRunner.buildAndFail（）</a>方法执行构建。</p>
</div>
<div class="paragraph">
<p>以下内容演示了Java JUnit测试中GradleRunner的用法：</p>
</div>
<div class="sect4">
<h5 id="example_using_gradlerunner_with_junit"><a class="anchor" href="#example_using_gradlerunner_with_junit"></a> <a class="link" href="#example_using_gradlerunner_with_junit">示例：将GradleRunner与JUnit一起使用</a></h5>
<div class="listingblock">
<div class="title">BuildLogicFunctionalTest.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.testkit.runner.BuildResult</span>;
<span class="keyword">import</span> <span class="include">org.gradle.testkit.runner.GradleRunner</span>;
<span class="keyword">import</span> <span class="include">org.junit.Before</span>;
<span class="keyword">import</span> <span class="include">org.junit.Rule</span>;
<span class="keyword">import</span> <span class="include">org.junit.Test</span>;
<span class="keyword">import</span> <span class="include">org.junit.rules.TemporaryFolder</span>;

<span class="keyword">import</span> <span class="include">java.io.BufferedWriter</span>;
<span class="keyword">import</span> <span class="include">java.io.File</span>;
<span class="keyword">import</span> <span class="include">java.io.FileWriter</span>;
<span class="keyword">import</span> <span class="include">java.io.IOException</span>;
<span class="keyword">import</span> <span class="include">java.util.Collections</span>;

<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.Assert.assertEquals</span>;
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.Assert.assertTrue</span>;

<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.gradle.testkit.runner.TaskOutcome</span>.*;

<span class="directive">public</span> <span class="type">class</span> <span class="class">BuildLogicFunctionalTest</span> {
    <span class="annotation">@Rule</span> <span class="directive">public</span> <span class="directive">final</span> TemporaryFolder testProjectDir = <span class="keyword">new</span> TemporaryFolder();
    <span class="directive">private</span> <span class="predefined-type">File</span> settingsFile;
    <span class="directive">private</span> <span class="predefined-type">File</span> buildFile;

    <span class="annotation">@Before</span>
    <span class="directive">public</span> <span class="type">void</span> setup() <span class="directive">throws</span> <span class="exception">IOException</span> {
        settingsFile = testProjectDir.newFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">settings.gradle</span><span class="delimiter">&quot;</span></span>);
        buildFile = testProjectDir.newFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">build.gradle</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> testHelloWorldTask() <span class="directive">throws</span> <span class="exception">IOException</span> {
        writeFile(settingsFile, <span class="string"><span class="delimiter">&quot;</span><span class="content">rootProject.name = 'hello-world'</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> buildFileContent = <span class="string"><span class="delimiter">&quot;</span><span class="content">task helloWorld {</span><span class="delimiter">&quot;</span></span> +
                                  <span class="string"><span class="delimiter">&quot;</span><span class="content">    doLast {</span><span class="delimiter">&quot;</span></span> +
                                  <span class="string"><span class="delimiter">&quot;</span><span class="content">        println 'Hello world!'</span><span class="delimiter">&quot;</span></span> +
                                  <span class="string"><span class="delimiter">&quot;</span><span class="content">    }</span><span class="delimiter">&quot;</span></span> +
                                  <span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;
        writeFile(buildFile, buildFileContent);

        BuildResult result = GradleRunner.create()
            .withProjectDir(testProjectDir.getRoot())
            .withArguments(<span class="string"><span class="delimiter">&quot;</span><span class="content">helloWorld</span><span class="delimiter">&quot;</span></span>)
            .build();

        assertTrue(result.getOutput().contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello world!</span><span class="delimiter">&quot;</span></span>));
        assertEquals(SUCCESS, result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:helloWorld</span><span class="delimiter">&quot;</span></span>).getOutcome());
    }

    <span class="directive">private</span> <span class="type">void</span> writeFile(<span class="predefined-type">File</span> destination, <span class="predefined-type">String</span> content) <span class="directive">throws</span> <span class="exception">IOException</span> {
        <span class="predefined-type">BufferedWriter</span> output = <span class="predefined-constant">null</span>;
        <span class="keyword">try</span> {
            output = <span class="keyword">new</span> <span class="predefined-type">BufferedWriter</span>(<span class="keyword">new</span> <span class="predefined-type">FileWriter</span>(destination));
            output.write(content);
        } <span class="keyword">finally</span> {
            <span class="keyword">if</span> (output != <span class="predefined-constant">null</span>) {
                output.close();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用任何测试执行框架。</p>
</div>
<div class="paragraph">
<p>由于Gradle构建脚本是用Groovy编程语言编写的，并且许多插件是用Groovy实现的，所以用Groovy编写Gradle功能测试通常是一种有效的选择。此外，建议使用（基于Groovy的） <a href="https://code.google.com/p/spock/">Spock测试执行框架，</a>因为它比JUnit的使用具有许多引人注目的功能。</p>
</div>
<div class="paragraph">
<p>以下内容演示了Groovy Spock测试中Gradle Runner的用法：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_using_gradlerunner_with_spock"><a class="anchor" href="#example_using_gradlerunner_with_spock"></a> <a class="link" href="#example_using_gradlerunner_with_spock">示例：将GradleRunner与Spock一起使用</a></h5>
<div class="listingblock">
<div class="title">BuildLogicFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.testkit.runner.GradleRunner</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.gradle.testkit.runner.TaskOutcome.*</span>
<span class="keyword">import</span> <span class="include">org.junit.Rule</span>
<span class="keyword">import</span> <span class="include">org.junit.rules.TemporaryFolder</span>
<span class="keyword">import</span> <span class="include">spock.lang.Specification</span>

<span class="type">class</span> <span class="class">BuildLogicFunctionalTest</span> <span class="directive">extends</span> Specification {
    <span class="annotation">@Rule</span> TemporaryFolder testProjectDir = <span class="keyword">new</span> TemporaryFolder()
    <span class="predefined-type">File</span> settingsFile
    <span class="predefined-type">File</span> buildFile

    <span class="keyword">def</span> <span class="function">setup</span>() {
        settingsFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">settings.gradle</span><span class="delimiter">'</span></span>)
        buildFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">build.gradle</span><span class="delimiter">'</span></span>)
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello world task prints hello world</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">given</span>:
        settingsFile &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">rootProject.name = 'hello-world'</span><span class="delimiter">&quot;</span></span>
        buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
            task helloWorld {
                doLast {
                    println 'Hello world!'
                }
            }
        </span><span class="delimiter">&quot;&quot;&quot;</span></span>

        <span class="key">when</span>:
        <span class="keyword">def</span> result = GradleRunner.create()
            .withProjectDir(testProjectDir.root)
            .withArguments(<span class="string"><span class="delimiter">'</span><span class="content">helloWorld</span><span class="delimiter">'</span></span>)
            .build()

        <span class="key">then</span>:
        result.output.contains(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>)
        result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:helloWorld</span><span class="delimiter">&quot;</span></span>).outcome == SUCCESS
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实施任何自定义构建逻辑（如插件和任务类型）通常是一种惯例，该逻辑本质上比独立项目中的外部类复杂。这种方法背后的主要驱动力是将编译后的代码捆绑到一个JAR文件中，将其发布到二进制存储库中，并在各个项目中重复使用。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sub:test-kit-classpath-injection"><a class="anchor" href="#sub:test-kit-classpath-injection"></a> <a class="link" href="#sub:test-kit-classpath-injection">将被测插件放入测试版本</a></h4>
<div class="paragraph">
<p>GradleRunner使用<a href="#embedding">Tooling API</a>执行构建。这意味着构建是在单独的过程中执行的（即，执行测试的过程不是同一过程）。因此，测试版本不会与测试过程共享相同的类路径或类加载器，并且测试代码不会隐式地提供给测试版本。</p>
</div>
<div class="paragraph">
<p>从2.13版开始，Gradle提供了一种<a href="#sub:test-kit-automatic-classpath-injection">常规机制，可以将被测代码注入测试版本中</a> 。</p>
</div>
<div class="paragraph">
<p>对于较早版本的Gradle（2.13之前的版本），可以通过一些额外的配置来手动使被测代码可用。下面的示例演示如何让生成的文件包含被测代码的实现类路径，并使其在测试运行时可用。</p>
</div>
<div class="exampleblock">
<div class="title">示例225使测试类路径下的代码可用于测试</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Write the plugin's classpath to a file to share with the tests</span>
task createClasspathManifest {
    <span class="keyword">def</span> outputDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/</span><span class="inline"><span class="inline-delimiter">$</span>name</span><span class="delimiter">&quot;</span></span>)

    inputs.files(sourceSets.main.runtimeClasspath)
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">runtimeClasspath</span><span class="delimiter">&quot;</span></span>)
        .withNormalizer(ClasspathNormalizer)
    outputs.dir(outputDir)
        .withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">outputDir</span><span class="delimiter">&quot;</span></span>)

    doLast {
        outputDir.mkdirs()
        file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>outputDir</span><span class="content">/plugin-classpath.txt</span><span class="delimiter">&quot;</span></span>).text = sourceSets.main.runtimeClasspath.join(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)
    }
}

<span class="comment">// Add the classpath file to the test runtime classpath</span>
dependencies {
    testRuntimeOnly files(createClasspathManifest)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Write the plugin's classpath to a file to share with the tests
tasks.register(&quot;createClasspathManifest&quot;) {
    val outputDir = file(&quot;$buildDir/$name&quot;)

    inputs.files(sourceSets.main.get().runtimeClasspath)
        .withPropertyName(&quot;runtimeClasspath&quot;)
        .withNormalizer(ClasspathNormalizer::class)
    outputs.dir(outputDir)
        .withPropertyName(&quot;outputDir&quot;)

    doLast {
        outputDir.mkdirs()
        file(&quot;$outputDir/plugin-classpath.txt&quot;).writeText(sourceSets.main.get().runtimeClasspath.joinToString(&quot;\n&quot;))
    }
}

// Add the classpath file to the test runtime classpath
dependencies {
    testRuntimeOnly(files(tasks[&quot;createClasspathManifest&quot;]))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testKit/gradleRunner/manualClasspathInjection</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，测试可以读取该值，并通过使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-java.lang.Iterable-">GradleRunner.withPluginClasspath（java.lang。迭代）</a> 。然后可以使用该类路径通过插件DSL在测试版本中定位插件（请参见<a href="#plugins">插件</a> ）。通过插件DSL应用插件需要定义插件标识符。以下是在Spock框架内执行此操作的示例（在Groovy中） <code>setup()</code>方法，类似于JUnit <code>@Before</code>方法。</p>
</div>
<div class="sect4">
<h5 id="example_injecting_the_code_under_test_classes_into_test_builds"><a class="anchor" href="#example_injecting_the_code_under_test_classes_into_test_builds"></a> <a class="link" href="#example_injecting_the_code_under_test_classes_into_test_builds">示例：将测试类下的代码注入测试版本</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src / test / groovy / org / gradle / sample / BuildLogicFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    <span class="predefined-type">List</span>&lt;<span class="predefined-type">File</span>&gt; pluginClasspath

    <span class="keyword">def</span> <span class="function">setup</span>() {
        settingsFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">settings.gradle</span><span class="delimiter">'</span></span>)
        buildFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">build.gradle</span><span class="delimiter">'</span></span>)

        <span class="keyword">def</span> pluginClasspathResource = getClass().classLoader.findResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">plugin-classpath.txt</span><span class="delimiter">&quot;</span></span>)
        <span class="keyword">if</span> (pluginClasspathResource == <span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Did not find plugin classpath resource, run `testClasses` build task.</span><span class="delimiter">&quot;</span></span>)
        }

        pluginClasspath = pluginClasspathResource.readLines().collect { <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="local-variable">it</span>) }
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello world task prints hello world</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">given</span>:
        buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
            plugins {
                id 'org.gradle.sample.helloworld'
            }
        </span><span class="delimiter">&quot;&quot;&quot;</span></span>

        <span class="key">when</span>:
        <span class="keyword">def</span> result = GradleRunner.create()
            .withProjectDir(testProjectDir.root)
            .withArguments(<span class="string"><span class="delimiter">'</span><span class="content">helloWorld</span><span class="delimiter">'</span></span>)
            .withPluginClasspath(pluginClasspath)
            .build()

        <span class="key">then</span>:
        result.output.contains(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>)
        result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:helloWorld</span><span class="delimiter">&quot;</span></span>).outcome == SUCCESS
    }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testKit/gradleRunner/manualClasspathInjection</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当作为Gradle构建的一部分执行功能测试时，此方法效果很好。从IDE执行功能测试时，还有一些额外的注意事项。即，类路径清单文件指向Gradle而不是IDE生成的类文件等。这意味着在更改被测代码的源代码之后，必须由Gradle重新编译源代码。同样，如果被测代码的有效类路径发生变化，则必须重新生成清单。在任何一种情况下，执行<code>testClasses</code>构建任务将确保一切都是最新的。</p>
</div>
<div class="paragraph">
<p>一些IDE提供了一个方便的选项，可以将“测试类路径的生成和执行”委托给构建。在IntelliJ中，您可以在``偏好设置...''>``构建，执行，部署''>``构建工具''>``Gradle''>``Runner''>``委派IDE生成/运行操作以进行gradle''下找到此选项。请查阅IDE的文档以获取更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:working_with_gradle_versions_prior_to_28"><a class="anchor" href="#sec:working_with_gradle_versions_prior_to_28"></a> <a class="link" href="#sec:working_with_gradle_versions_prior_to_28">使用2.8之前的Gradle版本</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-java.lang.Iterable-">GradleRunner.withPluginClasspath（java.lang。当使用早于2.8的Gradle版本执行构建时，（ Iterable）</a>方法将不起作用（请参阅<a href="#sub:gradle-runner-gradle-version">用于测试的版本</a> ），因为在此类Gradle版本上不支持此功能。</p>
</div>
<div class="paragraph">
<p>相反，必须通过构建脚本本身注入代码。下面的示例演示如何完成此操作。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_injecting_the_code_under_test_classes_into_test_builds_for_gradle_versions_prior_to_2_8"><a class="anchor" href="#example_injecting_the_code_under_test_classes_into_test_builds_for_gradle_versions_prior_to_2_8"></a> <a class="link" href="#example_injecting_the_code_under_test_classes_into_test_builds_for_gradle_versions_prior_to_2_8">示例：将测试类下的代码注入2.8之前的Gradle版本的测试版本中</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src / test / groovy / org / gradle / sample / BuildLogicFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    <span class="predefined-type">List</span>&lt;<span class="predefined-type">File</span>&gt; pluginClasspath

    <span class="keyword">def</span> <span class="function">setup</span>() {
        settingsFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">settings.gradle</span><span class="delimiter">'</span></span>)
        buildFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">build.gradle</span><span class="delimiter">'</span></span>)

        <span class="keyword">def</span> pluginClasspathResource = getClass().classLoader.findResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">plugin-classpath.txt</span><span class="delimiter">&quot;</span></span>)
        <span class="keyword">if</span> (pluginClasspathResource == <span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Did not find plugin classpath resource, run `testClasses` build task.</span><span class="delimiter">&quot;</span></span>)
        }

        pluginClasspath = pluginClasspathResource.readLines().collect { <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="local-variable">it</span>) }
    }

    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello world task prints hello world with pre Gradle 2.8</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">given</span>:
        <span class="keyword">def</span> classpathString = pluginClasspath
            .collect { <span class="local-variable">it</span>.absolutePath.replace(<span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="char">\\</span><span class="char">\\</span><span class="delimiter">'</span></span>) } <span class="comment">// escape backslashes in Windows paths</span>
            .collect { <span class="string"><span class="delimiter">&quot;</span><span class="content">'</span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="content">'</span><span class="delimiter">&quot;</span></span> }
            .join(<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>)

        buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
            buildscript {
                dependencies {
                    classpath files(</span><span class="inline"><span class="inline-delimiter">$</span>classpathString</span><span class="content">)
                }
            }
            apply plugin: &quot;org.gradle.sample.helloworld&quot;
        </span><span class="delimiter">&quot;&quot;&quot;</span></span>

        <span class="key">when</span>:
        <span class="keyword">def</span> result = GradleRunner.create()
            .withProjectDir(testProjectDir.root)
            .withArguments(<span class="string"><span class="delimiter">'</span><span class="content">helloWorld</span><span class="delimiter">'</span></span>)
            .withGradleVersion(<span class="string"><span class="delimiter">&quot;</span><span class="content">2.7</span><span class="delimiter">&quot;</span></span>)
            .build()

        <span class="key">then</span>:
        result.output.contains(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>)
        result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:helloWorld</span><span class="delimiter">&quot;</span></span>).outcome == SUCCESS
    }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testKit/gradleRunner/manualClasspathInjection</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sub:test-kit-automatic-classpath-injection"><a class="anchor" href="#sub:test-kit-automatic-classpath-injection"></a> <a class="link" href="#sub:test-kit-automatic-classpath-injection">使用Java Gradle插件开发插件自动注入</a></h5>
<div class="paragraph">
<p><a href="#java_gradle_plugin">Java Gradle插件开发插件</a>可用于协助Gradle插件的开发。从Gradle 2.13版本开始，该插件提供与TestKit的直接集成。应用于项目时，该插件会自动添加<code>gradleTestKit()</code>对测试编译配置的依赖。此外，它会自动为测试中的代码生成类路径，并通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath--">GradleRunner.withPluginClasspath（）</a>将其注入到任何<code>GradleRunner</code>用户创建的实例。重要的是要注意，该机制当前<em>仅</em>在使用<a href="#sec:plugins_block">插件DSL</a>应用被测插件<em>时才</em>有效。如果<a href="#sub:gradle-runner-gradle-version">目标Gradle版本</a>是2.8之前的<a href="#sub:gradle-runner-gradle-version">版本</a> ，则不会执行自动插件类路径注入。</p>
</div>
<div class="paragraph">
<p>该插件使用以下约定来应用TestKit依赖项并注入类路径：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包含正在测试的代码的源集：<code>sourceSets.main</code></p>
</li>
<li>
<p>用于注入插件类路径的源集：<code>sourceSets.test</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些约定中的任何一个都可以在类<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugin/devel/GradlePluginDevelopmentExtension.html">GradlePluginDevelopmentExtension</a>的帮助下进行重新配置。</p>
</div>
<div class="paragraph">
<p>以下基于Groovy的示例演示了如何使用Java Gradle插件开发插件应用的标准约定自动注入插件类路径。</p>
</div>
<div class="exampleblock">
<div class="title">范例226。使用Java Gradle Development插件生成插件元数据</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">java-gradle-plugin</span><span class="delimiter">'</span></span>
}

dependencies {
    testImplementation(<span class="string"><span class="delimiter">'</span><span class="content">org.spockframework:spock-core:1.3-groovy-2.4</span><span class="delimiter">'</span></span>) {
        exclude <span class="key">module</span>: <span class="string"><span class="delimiter">'</span><span class="content">groovy-all</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    groovy
    `java-gradle-plugin`
}

dependencies {
    testImplementation(&quot;org.spockframework:spock-core:1.3-groovy-2.4&quot;) {
        exclude(module = &quot;groovy-all&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testKit/gradleRunner/automaticClasspathInjectionQuickstart</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="example_automatically_injecting_the_code_under_test_classes_into_test_builds"><a class="anchor" href="#example_automatically_injecting_the_code_under_test_classes_into_test_builds"></a> <a class="link" href="#example_automatically_injecting_the_code_under_test_classes_into_test_builds">示例：自动将测试类下的代码注入到测试版本中</a></h5>
<div class="listingblock">
<div class="title">src / test / groovy / org / gradle / sample / BuildLogicFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello world task prints hello world</span><span class="delimiter">&quot;</span></span>() {
    <span class="key">given</span>:
    settingsFile &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">rootProject.name = 'hello-world'</span><span class="delimiter">&quot;</span></span>
    buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
        plugins {
            id 'org.gradle.sample.helloworld'
        }
    </span><span class="delimiter">&quot;&quot;&quot;</span></span>

    <span class="key">when</span>:
    <span class="keyword">def</span> result = GradleRunner.create()
        .withProjectDir(testProjectDir.root)
        .withArguments(<span class="string"><span class="delimiter">'</span><span class="content">helloWorld</span><span class="delimiter">'</span></span>)
        .withPluginClasspath()
        .build()

    <span class="key">then</span>:
    result.output.contains(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>)
    result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:helloWorld</span><span class="delimiter">&quot;</span></span>).outcome == SUCCESS
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testKit/gradleRunner/automaticClasspathInjectionQuickstart</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下构建脚本演示了如何为使用自定义项目的项目重新配置Java Gradle插件开发插件提供的约定。 <code>Test</code>源集。</p>
</div>
<div class="exampleblock">
<div class="title">示例227重新配置Java Gradle Development插件的类路径生成约定</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">java-gradle-plugin</span><span class="delimiter">'</span></span>
}

sourceSets {
    functionalTest {
        groovy {
            srcDir file(<span class="string"><span class="delimiter">'</span><span class="content">src/functionalTest/groovy</span><span class="delimiter">'</span></span>)
        }
        resources {
            srcDir file(<span class="string"><span class="delimiter">'</span><span class="content">src/functionalTest/resources</span><span class="delimiter">'</span></span>)
        }
        compileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}

task functionalTest(<span class="key">type</span>: Test) {
    testClassesDirs = sourceSets.functionalTest.output.classesDirs
    classpath = sourceSets.functionalTest.runtimeClasspath
}

check.dependsOn functionalTest

gradlePlugin {
    testSourceSets sourceSets.functionalTest
}

dependencies {
    functionalTestImplementation(<span class="string"><span class="delimiter">'</span><span class="content">org.spockframework:spock-core:1.3-groovy-2.4</span><span class="delimiter">'</span></span>) {
        exclude <span class="key">module</span>: <span class="string"><span class="delimiter">'</span><span class="content">groovy-all</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    groovy
    `java-gradle-plugin`
}

sourceSets {
    create(&quot;functionalTest&quot;) {
        withConvention(GroovySourceSet::class) {
            groovy {
                srcDir(file(&quot;src/functionalTest/groovy&quot;))
            }
        }
        resources {
            srcDir(file(&quot;src/functionalTest/resources&quot;))
        }
        compileClasspath += sourceSets.main.get().output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}

tasks.register&lt;Test&gt;(&quot;functionalTest&quot;) {
    testClassesDirs = sourceSets[&quot;functionalTest&quot;].output.classesDirs
    classpath = sourceSets[&quot;functionalTest&quot;].runtimeClasspath
}

tasks.check { dependsOn(tasks[&quot;functionalTest&quot;]) }

gradlePlugin {
    testSourceSets(sourceSets[&quot;functionalTest&quot;])
}

dependencies {
    &quot;functionalTestImplementation&quot;(&quot;org.spockframework:spock-core:1.3-groovy-2.4&quot;) {
        exclude(module = &quot;groovy-all&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testKit/gradleRunner/automaticClasspathInjectionCustomTestSourceSet</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:controlling_the_build_environment"><a class="anchor" href="#sec:controlling_the_build_environment"></a> <a class="link" href="#sec:controlling_the_build_environment">控制构建环境</a></h4>
<div class="paragraph">
<p>运行程序通过在JVM的temp目录内的目录中指定专用的“工作目录”（即，由JVM指定的位置）在隔离的环境中执行测试构建。 <code>java.io.tmpdir</code>系统属性，通常<code>/tmp</code> ）。默认Gradle用户主目录中的任何配置（例如<code>~/.gradle/gradle.properties</code> ）不用于测试执行。TestKit并未公开对环境变量等进行细粒度控制的机制。TestKit的未来版本将提供改进的配置选项。</p>
</div>
<div class="paragraph">
<p>TestKit使用专用的守护程序进程，这些进程在测试执行后会自动关闭。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:gradle-runner-gradle-version"><a class="anchor" href="#sub:gradle-runner-gradle-version"></a> <a class="link" href="#sub:gradle-runner-gradle-version">用于测试的Gradle版本</a></h4>
<div class="paragraph">
<p>Gradle运行器需要Gradle发行版才能执行构建。TestKit并不依赖于Gradle的所有实现。</p>
</div>
<div class="paragraph">
<p>默认情况下，跑步者将尝试根据<code>GradleRunner</code>类是从中加载的。也就是说，期望该类是从Gradle发行版加载的，与使用<code>gradleTestKit()</code>依赖声明。</p>
</div>
<div class="paragraph">
<p>当使用跑步者作为<em>Gradle执行</em>的测试的一部分时（例如执行<code>test</code>插件项目的任务），跑步者将使用与执行测试相同的发行版。当将运行程序用作<em>IDE执行</em>的测试的一部分时，将使用与导入项目时相同的Gradle发行版。这意味着该插件将使用与其构建时相同的Gradle版本进行有效测试。</p>
</div>
<div class="paragraph">
<p>或者，可以通过以下任意一种方式指定要使用的Gradle的不同版本和特定版本<code>GradleRunner</code>方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleVersion-java.lang.String-">GradleRunner.withGradleVersion（java.lang。串）</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleInstallation-java.io.File-">GradleRunner.withGradleInstallation（java.io。文件）</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleDistribution-java.net.URI-">GradleRunner.withGradleDistribution（java.net。URI）</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它可以潜在地用于跨Gradle版本测试构建逻辑。下面演示了编写为Groovy Spock测试的跨版本兼容性测试：</p>
</div>
<div class="sect4">
<h5 id="example_specifying_a_gradle_version_for_test_execution"><a class="anchor" href="#example_specifying_a_gradle_version_for_test_execution"></a> <a class="link" href="#example_specifying_a_gradle_version_for_test_execution">示例：指定用于测试执行的Gradle版本</a></h5>
<div class="listingblock">
<div class="title">BuildLogicFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.testkit.runner.GradleRunner</span>
<span class="keyword">import</span> <span class="include">static</span> <span class="include">org.gradle.testkit.runner.TaskOutcome.*</span>
<span class="keyword">import</span> <span class="include">org.junit.Rule</span>
<span class="keyword">import</span> <span class="include">org.junit.rules.TemporaryFolder</span>
<span class="keyword">import</span> <span class="include">spock.lang.Specification</span>
<span class="keyword">import</span> <span class="include">spock.lang.Unroll</span>

<span class="type">class</span> <span class="class">BuildLogicFunctionalTest</span> <span class="directive">extends</span> Specification {
    <span class="annotation">@Rule</span> <span class="directive">final</span> TemporaryFolder testProjectDir = <span class="keyword">new</span> TemporaryFolder()
    <span class="predefined-type">File</span> settingsFile
    <span class="predefined-type">File</span> buildFile

    <span class="keyword">def</span> <span class="function">setup</span>() {
        settingsFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">settings.gradle</span><span class="delimiter">'</span></span>)
        buildFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">build.gradle</span><span class="delimiter">'</span></span>)
    }

    <span class="annotation">@Unroll</span>
    <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">can execute hello world task with Gradle version #gradleVersion</span><span class="delimiter">&quot;</span></span>() {
        <span class="key">given</span>:
        buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
            task helloWorld {
                doLast {
                    logger.quiet 'Hello world!'
                }
            }
        </span><span class="delimiter">&quot;&quot;&quot;</span></span>

        <span class="key">when</span>:
        <span class="keyword">def</span> result = GradleRunner.create()
            .withGradleVersion(gradleVersion)
            .withProjectDir(testProjectDir.root)
            .withArguments(<span class="string"><span class="delimiter">'</span><span class="content">helloWorld</span><span class="delimiter">'</span></span>)
            .build()

        <span class="key">then</span>:
        result.output.contains(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>)
        result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:helloWorld</span><span class="delimiter">&quot;</span></span>).outcome == SUCCESS

        <span class="key">where</span>:
        gradleVersion &lt;&lt; [<span class="string"><span class="delimiter">'</span><span class="content">2.6</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">2.7</span><span class="delimiter">'</span></span>]
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub:test-kit-compatibility"><a class="anchor" href="#sub:test-kit-compatibility"></a> <a class="link" href="#sub:test-kit-compatibility">使用不同的Gradle版本进行测试时的功能支持</a></h5>
<div class="paragraph">
<p>可以使用GradleRunner在Gradle 1.0及更高版本中执行构建。但是，早期版本不支持某些运行器功能。在这种情况下，跑步者在尝试使用功能时会抛出异常。</p>
</div>
<div class="paragraph">
<p>下表列出了对使用的Gradle版本敏感的功能。</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表5。Gradle版本兼容性</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">特征</th>
<th class="tableblock halign-left valign-top">最低版本</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查执行的任务</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/BuildResult.html#getTasks--">BuildResult.getTasks（）</a>和类似方法检查执行的任务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sub:test-kit-classpath-injection">插件类路径注入</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-java.lang.Iterable-">GradleRunner.withPluginClasspath（java.lang。迭代）</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sub:test-kit-debug">在调试模式下检查构建输出</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/BuildResult.html#getOutput--">BuildResult.getOutput（）</a>在调试模式下运行时检查构建的文本输出。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sub:test-kit-automatic-classpath-injection">自动插件类路径注入</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过应用Java Gradle插件开发插件，通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath--">GradleRunner.withPluginClasspath（）</a>自动注入被测代码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置要由构建使用的环境变量。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gradle Tooling API仅支持在更高版本中设置环境变量。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sub:test-kit-debug"><a class="anchor" href="#sub:test-kit-debug"></a> <a class="link" href="#sub:test-kit-debug">调试构建逻辑</a></h4>
<div class="paragraph">
<p>跑步者使用<a href="#embedding">Tooling API</a>执行构建。这意味着构建是在单独的过程中执行的（即，执行测试的过程不是同一过程）。因此，以调试方式执行<em>测试</em>不允许您调试调试逻辑。在IDE中设置的任何断点都不会因测试版本执行的代码而跳闸。</p>
</div>
<div class="paragraph">
<p>TestKit提供了两种不同的方式来启用调试模式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>设置 ” <code>org.gradle.testkit.debug</code>系统属性为<code>true</code> <em>使用</em> JVM <code>GradleRunner</code> （即不是由跑步者执行构建）；</p>
</li>
<li>
<p>调用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withDebug-boolean-">GradleRunner.withDebug（boolean）</a>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当需要启用调试支持而不对运行程序配置进行临时更改时，可以使用系统属性方法。大多数IDE提供了设置JVM系统属性以执行测试的功能，并且可以使用此功能来设置此系统属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sub:test-kit-build-cache"><a class="anchor" href="#sub:test-kit-build-cache"></a> <a class="link" href="#sub:test-kit-build-cache">使用构建缓存进行测试</a></h4>
<div class="paragraph">
<p>要在测试中启用<a href="#build_cache">构建缓存</a> ，您可以通过<code>--build-cache</code> <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html">GradleRunner的</a>参数或使用<a href="#sec:build_cache_enable">启用构建缓存中</a>描述的其他方法之一。然后，您可以检查任务结果<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/TaskOutcome.html#FROM_CACHE">TaskOutcome。缓存</a>您的插件的自定义任务时的FROM_CACHE 。此结果仅对Gradle 3.5及更高版本有效。</p>
</div>
<div class="sect4">
<h5 id="example_testing_cacheable_tasks"><a class="anchor" href="#example_testing_cacheable_tasks"></a> <a class="link" href="#example_testing_cacheable_tasks">示例：测试可缓存任务</a></h5>
<div class="listingblock">
<div class="title">BuildLogicFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">cacheableTask is loaded from cache</span><span class="delimiter">&quot;</span></span>() {
    <span class="key">given</span>:
    buildFile &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
        plugins {
            id 'org.gradle.sample.helloworld'
        }
    </span><span class="delimiter">&quot;&quot;&quot;</span></span>

    <span class="key">when</span>:
    <span class="keyword">def</span> result = runner()
        .withArguments( <span class="string"><span class="delimiter">'</span><span class="content">--build-cache</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cacheableTask</span><span class="delimiter">'</span></span>)
        .build()

    <span class="key">then</span>:
    result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:cacheableTask</span><span class="delimiter">&quot;</span></span>).outcome == SUCCESS

    <span class="key">when</span>:
    <span class="keyword">new</span> <span class="predefined-type">File</span>(testProjectDir.root, <span class="string"><span class="delimiter">'</span><span class="content">build</span><span class="delimiter">'</span></span>).deleteDir()
    result = runner()
        .withArguments( <span class="string"><span class="delimiter">'</span><span class="content">--build-cache</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cacheableTask</span><span class="delimiter">'</span></span>)
        .build()

    <span class="key">then</span>:
    result.task(<span class="string"><span class="delimiter">&quot;</span><span class="content">:cacheableTask</span><span class="delimiter">&quot;</span></span>).outcome == FROM_CACHE
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，TestKit在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withTestKitDir-java.io.File-">两次测试之间重用了Gradle用户的主页（请参阅</a><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testkit/runner/GradleRunner.html#withTestKitDir-java.io.File-">GradleRunner.withTestKitDir（java.io。File）</a> ），其中包含本地构建缓存的默认位置。为了使用构建缓存进行测试，应该在测试之间清理构建缓存目录。完成此操作的最简单方法是将本地构建缓存配置为使用临时目录。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_clean_build_cache_between_tests"><a class="anchor" href="#example_clean_build_cache_between_tests"></a> <a class="link" href="#example_clean_build_cache_between_tests">示例：在测试之间清理构建缓存</a></h5>
<div class="listingblock">
<div class="title">BuildLogicFunctionalTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Rule</span> <span class="directive">final</span> TemporaryFolder testProjectDir = <span class="keyword">new</span> TemporaryFolder()
<span class="predefined-type">File</span> buildFile
<span class="predefined-type">File</span> localBuildCacheDirectory

<span class="keyword">def</span> <span class="function">setup</span>() {
    localBuildCacheDirectory = testProjectDir.newFolder(<span class="string"><span class="delimiter">'</span><span class="content">local-cache</span><span class="delimiter">'</span></span>)
    testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">settings.gradle</span><span class="delimiter">'</span></span>) &lt;&lt; <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
        buildCache {
            local {
                directory '</span><span class="inline"><span class="inline-delimiter">${</span>localBuildCacheDirectory.toURI()<span class="inline-delimiter">}</span></span><span class="content">'
            }
        }
    </span><span class="delimiter">&quot;&quot;&quot;</span></span>
    buildFile = testProjectDir.newFile(<span class="string"><span class="delimiter">'</span><span class="content">build.gradle</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ant"><a class="anchor" href="#ant"></a> <a class="link" href="#ant">从Gradle使用Ant</a></h3>
<div class="paragraph">
<p>Gradle提供了与Ant的出色集成。您可以在Gradle构建中使用单个Ant任务或整个Ant构建。实际上，您会发现，在Gradle构建脚本中使用Ant任务比使用Ant的XML格式要容易得多，功能更强大。您甚至可以简单地将Gradle用作强大的Ant任务脚本工具。</p>
</div>
<div class="paragraph">
<p>蚂蚁可以分为两层。第一层是Ant语言。它提供了<code>build.xml</code>文件，目标的处理，特殊构造（例如macrodef）等等。换句话说，除Ant任务和类型以外的所有内容。Gradle理解这种语言，并允许您导入Ant <code>build.xml</code>直接进入Gradle项目。然后，您可以像使用Gradle任务一样使用Ant构建的目标。</p>
</div>
<div class="paragraph">
<p>Ant的第二层是其丰富的Ant任务和类型，例如<code>javac</code> ， <code>copy</code>要么<code>jar</code> 。对于这一层，Gradle只需依靠Groovy即可提供集成， <code>AntBuilder</code> 。</p>
</div>
<div class="paragraph">
<p>最后，由于构建脚本是Groovy脚本，因此您始终可以将Ant构建作为外部进程执行。您的构建脚本可能包含如下语句： <code>"ant clean compile".execute()</code> 。 <sup class="footnote">[ <a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="查看脚注。">8</a> ]</sup></p>
</div>
<div class="paragraph">
<p>您可以使用Gradle的Ant集成作为将构建从Ant迁移到Gradle的路径。例如，您可以从导入现有的Ant构建开始。然后，您可以将依赖项声明从Ant脚本移至构建文件。最后，您可以将任务移到构建文件中，或用Gradle的某些插件替换它们。随着时间的流逝，该过程可以分几步完成，您可以在整个过程中构建一个有效的Gradle构建。</p>
</div>
<div class="sect3">
<h4 id="sec:using_ant_tasks"><a class="anchor" href="#sec:using_ant_tasks"></a> <a class="link" href="#sec:using_ant_tasks">在构建中使用Ant任务和类型</a></h4>
<div class="paragraph">
<p>在您的构建脚本中，一个名为<code>ant</code>由Gradle提供。这是对<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/AntBuilder.html">AntBuilder</a>实例的引用。这个<code>AntBuilder</code>用于从构建脚本访问Ant任务，类型和属性。有一个来自Ant的非常简单的映射<code>build.xml</code>格式转换为Groovy，下面将对此进行说明。</p>
</div>
<div class="paragraph">
<p>您可以通过在<code>AntBuilder</code>实例。您使用任务名称作为方法名称。例如，您执行Ant <code>echo</code>通过调用任务<code>ant.echo()</code>方法。Ant任务的属性作为Map参数传递给方法。以下是一个示例<code>echo</code>任务。注意，我们还可以混合使用Groovy代码和Ant任务标记。这可能非常强大。</p>
</div>
<div class="exampleblock">
<div class="title">示例228使用Ant任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello {
    doLast {
        <span class="predefined-type">String</span> greeting = <span class="string"><span class="delimiter">'</span><span class="content">hello from Ant</span><span class="delimiter">'</span></span>
        ant.echo(<span class="key">message</span>: greeting)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;hello&quot;) {
    doLast {
        val greeting = &quot;hello from Ant&quot;
        ant.withGroovyBuilder {
            &quot;echo&quot;(&quot;message&quot; to greeting)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle hello</code></div>
<div class="content">
<pre>&gt; gradle hello

&gt; Task :hello
[ant:echo] hello from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过将嵌套的文本作为任务方法调用的参数传递给Ant任务。在此示例中，我们将消息传递给<code>echo</code>任务为嵌套文本：</p>
</div>
<div class="exampleblock">
<div class="title">示例229。将嵌套文本传递给Ant任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task hello {
    doLast {
        ant.echo(<span class="string"><span class="delimiter">'</span><span class="content">hello from Ant</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;hello&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;echo&quot;(&quot;message&quot; to &quot;hello from Ant&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle hello</code></div>
<div class="content">
<pre>&gt; gradle hello

&gt; Task :hello
[ant:echo] hello from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您将嵌套元素传递给闭包内部的Ant任务。通过调用与我们要定义的元素同名的方法，以与任务相同的方式定义嵌套元素。</p>
</div>
<div class="exampleblock">
<div class="title">例子230。将嵌套元素传递给Ant任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task zip {
    doLast {
        ant.zip(<span class="key">destfile</span>: <span class="string"><span class="delimiter">'</span><span class="content">archive.zip</span><span class="delimiter">'</span></span>) {
            fileset(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>) {
                include(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">**.xml</span><span class="delimiter">'</span></span>)
                exclude(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">**.java</span><span class="delimiter">'</span></span>)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;zip&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;zip&quot;(&quot;destfile&quot; to &quot;archive.zip&quot;) {
                &quot;fileset&quot;(&quot;dir&quot; to &quot;src&quot;) {
                    &quot;include&quot;(&quot;name&quot; to &quot;**.xml&quot;)
                    &quot;exclude&quot;(&quot;name&quot; to &quot;**.java&quot;)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用与访问任务相同的方式来访问Ant类型，方法是将类型的名称用作方法名称。方法调用返回Ant数据类型，然后可以在构建脚本中直接使用它。在下面的示例中，我们创建一个Ant <code>path</code>对象，然后遍历它的内容。</p>
</div>
<div class="exampleblock">
<div class="title">示例231使用Ant类型</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task list {
    doLast {
        <span class="keyword">def</span> path = ant.path {
            fileset(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">libs</span><span class="delimiter">'</span></span>, <span class="key">includes</span>: <span class="string"><span class="delimiter">'</span><span class="content">*.jar</span><span class="delimiter">'</span></span>)
        }
        path.list().each {
            println <span class="local-variable">it</span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.apache.tools.ant.types.Path

tasks.register(&quot;list&quot;) {
    doLast {
        val path = ant.withGroovyBuilder {
            &quot;path&quot; {
                &quot;fileset&quot;(&quot;dir&quot; to &quot;libs&quot;, &quot;includes&quot; to &quot;*.jar&quot;)
            }
        } as Path
        path.list().forEach {
            println(it)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多信息<code>AntBuilder</code>可以在“ Groovy in Action” 8.4或<a href="https://groovy-lang.org/scripting-ant.html">Groovy Wiki中找到</a> 。</p>
</div>
<div class="sect4">
<h5 id="sec:using_custom_ant_tasks"><a class="anchor" href="#sec:using_custom_ant_tasks"></a> <a class="link" href="#sec:using_custom_ant_tasks">在构建中使用自定义Ant任务</a></h5>
<div class="paragraph">
<p>要使自定义任务在您的版本中可用，您可以使用<code>taskdef</code> （通常比较容易）或<code>typedef</code>蚂蚁任务，就像您在<code>build.xml</code>文件。然后，您可以像内置Ant任务一样引用自定义Ant任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例232。使用自定义Ant任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task check {
    doLast {
        ant.taskdef(<span class="key">resource</span>: <span class="string"><span class="delimiter">'</span><span class="content">checkstyletask.properties</span><span class="delimiter">'</span></span>) {
            classpath {
                fileset(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">libs</span><span class="delimiter">'</span></span>, <span class="key">includes</span>: <span class="string"><span class="delimiter">'</span><span class="content">*.jar</span><span class="delimiter">'</span></span>)
            }
        }
        ant.checkstyle(<span class="key">config</span>: <span class="string"><span class="delimiter">'</span><span class="content">checkstyle.xml</span><span class="delimiter">'</span></span>) {
            fileset(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;check&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;taskdef&quot;(&quot;resource&quot; to &quot;checkstyletask.properties&quot;) {
                &quot;classpath&quot; {
                    &quot;fileset&quot;(&quot;dir&quot; to &quot;libs&quot;, &quot;includes&quot; to &quot;*.jar&quot;)
                }
            }
            &quot;checkstyle&quot;(&quot;config&quot; to &quot;checkstyle.xml&quot;) {
                &quot;fileset&quot;(&quot;dir&quot; to &quot;src&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用Gradle的依赖关系管理来组装用于自定义任务的类路径。为此，您需要为类路径定义一个自定义配置，然后向该配置中添加一些依赖项。这在<a href="declaring_dependencies.html">声明依赖项</a>中有更详细的描述。</p>
</div>
<div class="exampleblock">
<div class="title">示例233。声明自定义Ant任务的类路径</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    pmd
}

dependencies {
    pmd <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">pmd</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">pmd</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">4.2.5</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val pmd = configurations.create(&quot;pmd&quot;)

dependencies {
    pmd(group = &quot;pmd&quot;, name = &quot;pmd&quot;, version = &quot;4.2.5&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用类路径配置，请使用<code>asPath</code>自定义配置的属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例234一起使用定制Ant任务和依赖项管理</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task check {
    doLast {
        ant.taskdef(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">pmd</span><span class="delimiter">'</span></span>,
                    <span class="key">classname</span>: <span class="string"><span class="delimiter">'</span><span class="content">net.sourceforge.pmd.ant.PMDTask</span><span class="delimiter">'</span></span>,
                    <span class="key">classpath</span>: configurations.pmd.asPath)
        ant.pmd(<span class="key">shortFilenames</span>: <span class="string"><span class="delimiter">'</span><span class="content">true</span><span class="delimiter">'</span></span>,
                <span class="key">failonruleviolation</span>: <span class="string"><span class="delimiter">'</span><span class="content">true</span><span class="delimiter">'</span></span>,
                <span class="key">rulesetfiles</span>: file(<span class="string"><span class="delimiter">'</span><span class="content">pmd-rules.xml</span><span class="delimiter">'</span></span>).toURI().toString()) {
            formatter(<span class="key">type</span>: <span class="string"><span class="delimiter">'</span><span class="content">text</span><span class="delimiter">'</span></span>, <span class="key">toConsole</span>: <span class="string"><span class="delimiter">'</span><span class="content">true</span><span class="delimiter">'</span></span>)
            fileset(<span class="key">dir</span>: <span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;check&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;taskdef&quot;(&quot;name&quot; to &quot;pmd&quot;,
                      &quot;classname&quot; to &quot;net.sourceforge.pmd.ant.PMDTask&quot;,
                      &quot;classpath&quot; to pmd.asPath)
            &quot;pmd&quot;(&quot;shortFilenames&quot; to true,
                  &quot;failonruleviolation&quot; to true,
                  &quot;rulesetfiles&quot; to file(&quot;pmd-rules.xml&quot;).toURI().toString()) {
                &quot;formatter&quot;(&quot;type&quot; to &quot;text&quot;, &quot;toConsole&quot; to &quot;true&quot;)
                &quot;fileset&quot;(&quot;dir&quot; to &quot;src&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:import_ant_build"><a class="anchor" href="#sec:import_ant_build"></a> <a class="link" href="#sec:import_ant_build">导入Ant构建</a></h4>
<div class="paragraph">
<p>您可以使用<code>ant.importBuild()</code>将Ant构建导入到Gradle项目中的方法。导入Ant构建时，每个Ant目标都被视为Gradle任务。这意味着您可以按照与Gradle任务完全相同的方式来操纵和执行Ant目标。</p>
</div>
<div class="exampleblock">
<div class="title">示例235导入Ant构建</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild <span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;project&gt;</span>
    <span class="tag">&lt;target</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;echo&gt;</span>Hello, from Ant<span class="tag">&lt;/echo&gt;</span>
    <span class="tag">&lt;/target&gt;</span>
<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle hello</code></div>
<div class="content">
<pre>&gt; gradle hello

&gt; Task :hello
[ant:echo] Hello, from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您可以添加一个依赖于Ant目标的任务：</p>
</div>
<div class="exampleblock">
<div class="title">示例236。取决于Ant目标的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild <span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span>

task intro(<span class="key">dependsOn</span>: hello) {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello, from Gradle</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;)

tasks.register(&quot;intro&quot;) {
    dependsOn(&quot;hello&quot;)
    doLast {
        println(&quot;Hello, from Gradle&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle intro</code></div>
<div class="content">
<pre>&gt; gradle intro

&gt; Task :hello
[ant:echo] Hello, from Ant

&gt; Task :intro
Hello, from Gradle

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以将行为添加到Ant目标：</p>
</div>
<div class="exampleblock">
<div class="title">示例237将行为添加到Ant目标</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild <span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span>

hello {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello, from Gradle</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;)

tasks.named(&quot;hello&quot;) {
    doLast {
        println(&quot;Hello, from Gradle&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle hello</code></div>
<div class="content">
<pre>&gt; gradle hello

&gt; Task :hello
[ant:echo] Hello, from Ant
Hello, from Gradle

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>Ant目标也有可能依赖Gradle任务：</p>
</div>
<div class="exampleblock">
<div class="title">例子238。取决于Gradle任务的Ant目标</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild <span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span>

task intro {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Hello, from Gradle</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;)

tasks.register(&quot;intro&quot;) {
    doLast {
        println(&quot;Hello, from Gradle&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;project&gt;</span>
    <span class="tag">&lt;target</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">depends</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">intro</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;echo&gt;</span>Hello, from Ant<span class="tag">&lt;/echo&gt;</span>
    <span class="tag">&lt;/target&gt;</span>
<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle hello</code></div>
<div class="content">
<pre>&gt; gradle hello

&gt; Task :intro
Hello, from Gradle

&gt; Task :hello
[ant:echo] Hello, from Ant

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="paragraph">
<p>有时可能需要“重命名”为Ant目标生成的任务，以避免与现有Gradle任务发生命名冲突。为此，请使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/AntBuilder.html#importBuild-java.lang.Object-org.gradle.api.Transformer-">AntBuilder.importBuild（java.lang。对象，org.gradle.api。变压器）</a>方法。</p>
</div>
<div class="exampleblock">
<div class="title">示例239重命名导入的Ant目标</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.importBuild(<span class="string"><span class="delimiter">'</span><span class="content">build.xml</span><span class="delimiter">'</span></span>) { antTargetName -&gt;
    <span class="string"><span class="delimiter">'</span><span class="content">a-</span><span class="delimiter">'</span></span> + antTargetName
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.importBuild(&quot;build.xml&quot;) { antTargetName -&gt;
    &quot;a-&quot; + antTargetName
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;project&gt;</span>
    <span class="tag">&lt;target</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;echo&gt;</span>Hello, from Ant<span class="tag">&lt;/echo&gt;</span>
    <span class="tag">&lt;/target&gt;</span>
<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle a-hello</code></div>
<div class="content">
<pre>&gt; gradle a-hello

&gt; Task :a-hello
[ant:echo] Hello, from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，虽然此方法的第二个参数应该是<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Transformer.html">Transformer</a> ，但在Groovy中进行编程时，由于<a href="http://mrhaki.blogspot.ie/2013/11/groovy-goodness-implicit-closure.html">Groovy支持将闭包自动强制转换为单抽象方法类型，因此</a>我们可以简单地使用闭包而不是匿名内部类（或类似的内部类）。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:ant_properties"><a class="anchor" href="#sec:ant_properties"></a> <a class="link" href="#sec:ant_properties">蚂蚁属性和参考</a></h4>
<div class="paragraph">
<p>有几种方法可以设置Ant属性，以便Ant任务可以使用该属性。您可以直接在<code>AntBuilder</code>实例。Ant属性也可以作为Map来使用，您可以对其进行更改。您也可以使用Ant <code>property</code>任务。下面是一些有关如何执行此操作的示例。</p>
</div>
<div class="exampleblock">
<div class="title">例子240。设置一个Ant属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.buildDir = buildDir
ant.properties.buildDir = buildDir
ant.properties[<span class="string"><span class="delimiter">'</span><span class="content">buildDir</span><span class="delimiter">'</span></span>] = buildDir
ant.property(<span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">buildDir</span><span class="delimiter">'</span></span>, <span class="key">location</span>: buildDir)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.setProperty(&quot;buildDir&quot;, buildDir)
ant.properties.set(&quot;buildDir&quot;, buildDir)
ant.properties[&quot;buildDir&quot;] = buildDir
ant.withGroovyBuilder {
    &quot;property&quot;(&quot;name&quot; to &quot;buildDir&quot;, &quot;location&quot; to &quot;buildDir&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>许多Ant任务在执行时都会设置属性。有几种方法可以获取这些属性的值。您可以直接从<code>AntBuilder</code>实例。Ant属性也可以作为Map使用。以下是一些示例。</p>
</div>
<div class="exampleblock">
<div class="title">示例241获取蚂蚁属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">antProp</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">a property defined in an Ant build</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println ant.antProp
println ant.properties.antProp
println ant.properties[<span class="string"><span class="delimiter">'</span><span class="content">antProp</span><span class="delimiter">'</span></span>]</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">println(ant.getProperty(&quot;antProp&quot;))
println(ant.properties.get(&quot;antProp&quot;))
println(ant.properties[&quot;antProp&quot;])</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有几种方法可以设置Ant引用：</p>
</div>
<div class="exampleblock">
<div class="title">示例242。设置蚂蚁参考</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.path(<span class="key">id</span>: <span class="string"><span class="delimiter">'</span><span class="content">classpath</span><span class="delimiter">'</span></span>, <span class="key">location</span>: <span class="string"><span class="delimiter">'</span><span class="content">libs</span><span class="delimiter">'</span></span>)
ant.references.classpath = ant.path(<span class="key">location</span>: <span class="string"><span class="delimiter">'</span><span class="content">libs</span><span class="delimiter">'</span></span>)
ant.references[<span class="string"><span class="delimiter">'</span><span class="content">classpath</span><span class="delimiter">'</span></span>] = ant.path(<span class="key">location</span>: <span class="string"><span class="delimiter">'</span><span class="content">libs</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.withGroovyBuilder { &quot;path&quot;(&quot;id&quot; to &quot;classpath&quot;, &quot;location&quot; to &quot;libs&quot;) }
ant.references.set(&quot;classpath&quot;, ant.withGroovyBuilder { &quot;path&quot;(&quot;location&quot; to &quot;libs&quot;) })
ant.references[&quot;classpath&quot;] = ant.withGroovyBuilder { &quot;path&quot;(&quot;location&quot; to &quot;libs&quot;) }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;path</span> <span class="attribute-name">refid</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有几种获取Ant参考的方法：</p>
</div>
<div class="exampleblock">
<div class="title">例子243。获取Ant参考</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;path</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">antPath</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">libs</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println ant.references.antPath
println ant.references[<span class="string"><span class="delimiter">'</span><span class="content">antPath</span><span class="delimiter">'</span></span>]</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">println(ant.references.get(&quot;antPath&quot;))
println(ant.references[&quot;antPath&quot;])</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:ant_logging"><a class="anchor" href="#sec:ant_logging"></a> <a class="link" href="#sec:ant_logging">蚂蚁记录</a></h4>
<div class="paragraph">
<p>Gradle将Ant消息优先级映射到Gradle日志级别，以便从Ant记录的消息出现在Gradle输出中。默认情况下，这些映射如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表6。蚂蚁消息优先级映射</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">蚂蚁消息优先级</th>
<th class="tableblock halign-left valign-top">摇篮日志级别</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>详细</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DEBUG</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>调试</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DEBUG</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>信息</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INFO</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>警告</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>WARN</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>错误</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>ERROR</code></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="sec:fine_tuning_ant_logging"><a class="anchor" href="#sec:fine_tuning_ant_logging"></a> <a class="link" href="#sec:fine_tuning_ant_logging">微调Ant日志记录</a></h5>
<div class="paragraph">
<p>Ant消息优先级到Gradle日志级别的默认映射有时可能会出现问题。例如，没有消息优先级可以直接映射到<code>LIFECYCLE</code>日志级别，这是Gradle的默认值。许多Ant任务以<em>INFO</em>优先级记录消息，这意味着要从Gradle公开那些消息，必须在日志级别设置为的情况下运行构建。 <code>INFO</code> ，可能会记录比期望更多的输出。</p>
</div>
<div class="paragraph">
<p>相反，如果Ant任务以太高的级别记录消息，则要抑制这些消息，将要求构建以更高的日志级别运行，例如<code>QUIET</code> 。但是，这可能会导致抑制其他期望的输出。</p>
</div>
<div class="paragraph">
<p>为了帮助解决这个问题，Gradle允许用户微调Ant日志并控制消息优先级到Gradle日志级别的映射。这是通过设置应映射到默认Gradle的优先级来完成的<code>LIFECYCLE</code>使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/AntBuilder.html#setLifecycleLogLevel-java.lang.String-">AntBuilder.setLifecycleLogLevel（java.lang。字符串）</a>方法。设置此值后，以配置的优先级或更高优先级记录的任何Ant消息将至少在以下时间记录<code>LIFECYCLE</code> 。在此优先级以下记录的任何Ant消息最多将在以下时间记录<code>INFO</code> 。</p>
</div>
<div class="paragraph">
<p>例如，以下内容更改了映射，以使Ant <em>INFO</em>优先级消息在<code>LIFECYCLE</code>日志级别。</p>
</div>
<div class="exampleblock">
<div class="title">实施例244。微调Ant日志记录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ant.lifecycleLogLevel = <span class="string"><span class="delimiter">&quot;</span><span class="content">INFO</span><span class="delimiter">&quot;</span></span>

task hello {
    doLast {
        ant.echo(<span class="key">level</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">info</span><span class="delimiter">&quot;</span></span>, <span class="key">message</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">hello from info priority!</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">ant.lifecycleLogLevel = AntBuilder.AntMessagePriority.INFO

tasks.register(&quot;hello&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;echo&quot;(&quot;level&quot; to &quot;info&quot;, &quot;message&quot; to &quot;hello from info priority!&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle hello</code></div>
<div class="content">
<pre>&gt; gradle hello

&gt; Task :hello
[ant:echo] hello from info priority!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>另一方面，如果<code>lifecycleLogLevel</code>设置为<em>ERROR</em> ，以<em>WARN</em>优先级记录的Ant消息将不再以<code>WARN</code>日志级别。现在将它们记录在<code>INFO</code>级别，默认情况下会被禁止。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:ant_api"><a class="anchor" href="#sec:ant_api"></a> <a class="link" href="#sec:ant_api">API</a></h4>
<div class="paragraph">
<p>Ant集成由<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/AntBuilder.html">AntBuilder</a>提供。</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="sect1">﻿<div class="sect1">
<h2 id="part:dependency_management"><a class="anchor" href="#part:dependency_management"></a> <a class="link" href="#part:dependency_management">依赖管理</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="learning_the_basics"><a class="anchor" href="#learning_the_basics"></a> <a class="link" href="#learning_the_basics">学习基础</a></h3>
<div class="sect3">
<h4 id="dependency_management_in_gradle"><a class="anchor" href="#dependency_management_in_gradle"></a> <a class="link" href="#dependency_management_in_gradle">Gradle中的依赖管理</a></h4>
<div class="sect4">
<h5 id="what_is_dependency_management"><a class="anchor" href="#what_is_dependency_management"></a> <a class="link" href="#what_is_dependency_management">什么是依赖管理？</a></h5>
<div class="paragraph">
<p>软件项目很少单独工作。在大多数情况下，项目依赖于库形式的可重用功能，或者分解为单个组件以构成模块化系统。依赖性管理是一种用于以自动化方式声明，解决和使用项目所需依赖性的技术。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>有关整个用户指南中使用的术语的一般概述，请参阅“ <a href="#">依赖关系管理术语”</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:dependency-mgmt-in-gradle"><a class="anchor" href="#sec:dependency-mgmt-in-gradle"></a> <a class="link" href="#sec:dependency-mgmt-in-gradle">Gradle中的依赖管理</a></h5>
<div class="paragraph">
<p>Gradle内置了对依赖项管理的支持，并且可以完成现代软件项目中遇到的典型方案。我们将在示例项目的帮助下探索主要概念。下图将为您简要概述所有活动部件。</p>
</div>
<div class="imageblock inset">
<div class="content">
<img src="img/dependency-management-resolution.png" alt="依赖管理解决方案">
</div>
<div class="title">图12。依赖管理大图</div>
</div>
<div class="paragraph">
<p>该示例项目将构建Java源代码。一些Java源文件从<a href="https://github.com/google/guava">Google Guava</a> （一个提供大量实用程序功能的开源库）中导入类。除了Guava，该项目还需要<a href="http://junit.org/junit5/">JUnit</a>库来编译和执行测试代码。</p>
</div>
<div class="paragraph">
<p>Guava和JUnit表示此项目的<em>依赖</em>项。构建脚本开发人员可以<a href="#declaring-dependencies">声明</a>不同范围的<a href="#declaring-dependencies">依赖关系</a> ，例如仅用于源代码的编译或用于执行测试。在Gradle中， <a href="#sec:what-are-dependency-configurations">依赖项</a>的<a href="#sec:what-are-dependency-configurations">范围</a>称为<em>configuration</em> 。有关完整概述，请参见有关<a href="#sec:dependency-types">依赖项类型</a>的参考资料。</p>
</div>
<div class="paragraph">
<p>通常，依赖项以<a href="#sub:terminology_module">模块</a>的形式出现。您需要告诉Gradle在哪里可以找到那些模块，以便构建可以使用它们。用于存储模块的位置称为<em>存储库</em> 。通过为构建<a href="#declaring-repositories">声明存储库</a> ，Gradle将知道如何查找和检索模块。存储库可以采用不同的形式：作为本地目录或远程存储库。有关<a href="#sec:repository-types">存储库类型</a>的参考对此主题进行了广泛介绍。</p>
</div>
<div class="paragraph">
<p>在运行时，如果需要执行特定任务，Gradle将定位声明的依赖项。依赖项可能需要从远程存储库下载，从本地目录检索，或者需要在多项目设置中构建另一个项目。此过程称为<em>依赖关系解析</em> 。您可以在<a href="#sec:how-gradle-downloads-deps">Gradle如何下载依赖项中</a>找到详细的讨论。</p>
</div>
<div class="paragraph">
<p>解决后，解析机制<a href="#sec:dependency_cache">会将依赖项的基础文件存储在本地缓存</a> （也称为<em>依赖项缓存）中</em> 。将来的版本会重复使用存储在缓存中的文件，以避免不必要的网络调用。</p>
</div>
<div class="paragraph">
<p>模块可以提供其他元数据。元数据是更详细地描述模块的数据，例如用于在存储库中找到模块的坐标，有关项目或其作者的信息。作为元数据的一部分，一个模块可以定义需要其他模块才能使其正常工作。例如，JUnit 5平台模块还需要平台公共模块。Gradle会自动解析那些额外的模块，即所谓的<em>传递依赖</em> 。如果需要，您可以<a href="#">自定义行为，</a>以根据您的项目需求来<a href="#">处理传递依赖项</a> 。</p>
</div>
<div class="paragraph">
<p>具有数十个或数百个已声明依赖项的项目很容易遭受依赖地狱之苦。Gradle提供了足够的工具来借助<a href="https://scans.gradle.com/get-started">构建扫描</a>或内置任务来可视化，导航和分析项目的依赖关系图。在<a href="#viewing-debugging-dependencies">查看和调试依赖项中</a>了解更多信息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/gradle-core-test-build-scan-dependencies.png" alt="gradle核心测试构建扫描依赖项">
</div>
<div class="title">图13。构建扫描依赖项报告</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="declaring-repositories"><a class="anchor" href="#declaring-repositories"></a> <a class="link" href="#declaring-repositories">声明存储库</a></h4>
<div class="paragraph">
<p>Gradle可以基于Maven，Ivy或平面目录格式解决来自一个或多个存储库的依赖关系。<a href="#sec:repository-types">有关所有信息</a> ，请查看<a href="#sec:repository-types">所有类型存储库</a>的<a href="#sec:repository-types">完整参考</a> 。</p>
</div>
<div class="sect4">
<h5 id="sec:declaring_public_repository"><a class="anchor" href="#sec:declaring_public_repository"></a> <a class="link" href="#sec:declaring_public_repository">声明一个公开可用的存储库</a></h5>
<div class="paragraph">
<p>构建软件的组织可能希望利用公共二进制存储库来下载和使用开源依赖项。流行的公共存储库包括<a href="#sub:maven_central">Maven Central</a> ， <a href="#sub:maven_jcenter">Bintray JCenter</a>和<a href="#sub:maven_google">Google Android</a>存储库。Gradle为这些广泛使用的存储库提供了内置的速记符号。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-shortcut-repositories.png" alt="依赖管理快捷方式存储库">
</div>
<div class="title">图14。在速记符号的帮助下声明存储库</div>
</div>
<div class="paragraph">
<p>在幕后，Gradle解析了由速记符号定义的公共存储库的相应URL中的依赖性。所有速记符号均可通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html">RepositoryHandler</a> API获得。或者，您可以<a href="#sec:declaring_custom_repository">拼出存储库的URL以</a>进行更细粒度的控制。</p>
</div>
<div class="sect5">
<h6 id="sub:maven_central"><a class="anchor" href="#sub:maven_central"></a> <a class="link" href="#sub:maven_central">Maven Central存储库</a></h6>
<div class="paragraph">
<p>Maven Central是一个流行的存储库，托管开放源代码库供Java项目使用。</p>
</div>
<div class="paragraph">
<p>要为您的构建声明<a href="https://repo.maven.apache.org/maven2/">Maven Central存储库</a> ，请将其添加到脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">例子245。添加中央Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:maven_jcenter"><a class="anchor" href="#sub:maven_jcenter"></a> <a class="link" href="#sub:maven_jcenter">JCenter Maven存储库</a></h6>
<div class="paragraph">
<p><a href="http://bintray.com">Bintray</a>的JCenter是所有流行的Maven OSS工件的最新集合，包括直接发布到Bintray的工件。</p>
</div>
<div class="paragraph">
<p>要声明<a href="https://jcenter.bintray.com">JCenter Maven存储库，</a>请将其添加到您的构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">示例246添加Bintray的JCenter Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:maven_google"><a class="anchor" href="#sub:maven_google"></a> <a class="link" href="#sub:maven_google">Google Maven存储库</a></h6>
<div class="paragraph">
<p>Google存储库托管Android特定的工件，包括Android SDK。有关使用示例，请参阅<a href="https://developer.android.com/studio/build/dependencies.html#google-maven">相关的Android文档</a> 。</p>
</div>
<div class="paragraph">
<p>要声明<a href="https://maven.google.com/">Google Maven存储库，</a>请将其添加到您的构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">例子247。添加Google Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    google()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    google()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:declaring_custom_repository"><a class="anchor" href="#sec:declaring_custom_repository"></a> <a class="link" href="#sec:declaring_custom_repository">通过URL声明自定义存储库</a></h5>
<div class="paragraph">
<p>大多数企业项目都建立了仅在Intranet中可用的二进制存储库。内部存储库使团队可以发布内部二进制文件，设置用户管理和安全措施并确保正常运行时间和可用性。如果要声明一个不太受欢迎但可公开使用的存储库，则指定自定义URL也很有用。</p>
</div>
<div class="paragraph">
<p>通过调用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html">RepositoryHandler</a> API上可用的相应方法，可以将具有自定义URL的存储库指定为Maven或Ivy存储<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html">库</a> 。 Gradle还支持其他协议<code>http</code>要么<code>https</code>作为自定义网址的一部分，例如<code>file</code> ， <code>sftp</code>要么<code>s3</code> 。有关完整信息，请参见<a href="#sec:repository-types">有关支持的存储库类型</a>的<a href="#sec:repository-types">部分</a> 。</p>
</div>
<div class="paragraph">
<p>您还<a href="#sub:defining_custom_pattern_layout_for_an_ivy_repository">可以</a>使用以下方法<a href="#sub:defining_custom_pattern_layout_for_an_ivy_repository">定义自己的存储库布局</a> <code>ivy { }</code>存储库，因为它们在存储库中模块的组织方式方面非常灵活。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:declaring_multiple_repositories"><a class="anchor" href="#sec:declaring_multiple_repositories"></a> <a class="link" href="#sec:declaring_multiple_repositories">声明多个存储库</a></h5>
<div class="paragraph">
<p>您可以定义多个存储库来解决依赖关系。如果某些依赖项仅在一个存储库中可用而在另一个存储库中不可用，则声明多个存储库将很有帮助。您可以混合<a href="#sec:repository-types">参考部分中</a>描述的任何类型的存储库。</p>
</div>
<div class="paragraph">
<p>此示例演示如何为项目声明各种命名和自定义URL存储库：</p>
</div>
<div class="exampleblock">
<div class="title">示例248。声明多个存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    jcenter()
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">https://maven.springframework.org/release</span><span class="delimiter">&quot;</span></span>
    }
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">https://maven.restlet.com</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    jcenter()
    maven {
        url = uri(&quot;https://maven.springframework.org/release&quot;)
    }
    maven {
        url = uri(&quot;https://maven.restlet.com&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>声明的顺序决定了Gradle在运行时如何检查依赖关系。如果Gradle在特定存储库中找到模块描述符，它将尝试从<em>同一存储库</em>下载该模块的所有工件。您可以了解有关<a href="#sec:how-gradle-downloads-deps">依赖项下载</a>的内部工作的更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="strict_limitation_to_declared_repositories"><a class="anchor" href="#strict_limitation_to_declared_repositories"></a> <a class="link" href="#strict_limitation_to_declared_repositories">严格限制已声明的存储库</a></h6>
<div class="paragraph">
<p>Maven POM元数据可以引用其他存储库。这些将被Gradle <em>忽略</em> ，Gradle将仅使用构建本身中声明的存储库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>这是可重现的安全保护措施，也是安全保护措施。没有它，依赖项的更新版本可能会将工件从任何地方拉入构建。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:repository-types"><a class="anchor" href="#sec:repository-types"></a> <a class="link" href="#sec:repository-types">支持的存储库类型</a></h5>
<div class="paragraph">
<p>Gradle在格式和连接性方面都支持多种依赖项源。您可以通过以下方式解决依赖关系：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不同格式</p>
<div class="ulist">
<ul>
<li>
<p>一个与<a href="#sec:maven_repo">Maven兼容的</a>工件存储库（例如：Maven Central，JCenter等）</p>
</li>
<li>
<p><a href="#sec:ivy_repositories">常春藤兼容的</a>工件存储库（包括自定义布局）</p>
</li>
<li>
<p><a href="#sub:flat_dir_resolver">本地（平面）目录</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>具有不同的连接性</p>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:authentication_schemes">认证存储库</a></p>
</li>
<li>
<p>多种<a href="#sec:supported_transport_protocols">远程协议，</a>例如HTTPS，SFTP，AWS S3和Google Cloud Storage</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="sub:flat_dir_resolver"><a class="anchor" href="#sub:flat_dir_resolver"></a> <a class="link" href="#sub:flat_dir_resolver">平面目录存储库</a></h6>
<div class="paragraph">
<p>一些项目可能更喜欢将依赖项存储在共享驱动器上，或者作为项目源代码的一部分存储，而不是二进制存储库产品。如果要将（平面）文件系统目录用作存储库，只需键入：</p>
</div>
<div class="exampleblock">
<div class="title">示例249。平面存储库解析器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    flatDir {
        dirs <span class="string"><span class="delimiter">'</span><span class="content">lib</span><span class="delimiter">'</span></span>
    }
    flatDir {
        dirs <span class="string"><span class="delimiter">'</span><span class="content">lib1</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">lib2</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    flatDir {
        dirs(&quot;lib&quot;)
    }
    flatDir {
        dirs(&quot;lib1&quot;, &quot;lib2&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将添加存储库，这些存储库将查找一个或多个目录以查找依赖项。</p>
</div>
<div class="paragraph">
<p>这种类型的存储库不支持任何元数据格式，例如Ivy XML或Maven POM文件。取而代之的是，Gradle将根据工件的存在情况动态生成模块描述符（不包含任何依赖项信息）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>由于Gradle倾向于使用其描述符是从真实的元数据创建而不是生成的模块，因此无法使用平面目录存储库来覆盖构建中声明的其他存储库中带有真实元数据的工件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，如果Gradle仅找到<code>jmxri-1.2.1.jar</code>在平面目录存储库中，但是<code>jmxri-1.2.1.pom</code>在另一个支持元数据的存储库中，它将使用第二个存储库来提供模块。</p>
</div>
<div class="paragraph">
<p>对于用本地对象覆盖远程工件的用例，请考虑使用Ivy或Maven存储库，而不是其URL指向本地目录。</p>
</div>
<div class="paragraph">
<p>如果仅使用平面目录存储库，则无需设置依赖项的所有属性。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:local-repos"><a class="anchor" href="#sub:local-repos"></a> <a class="link" href="#sub:local-repos">本地存储库</a></h6>
<div class="paragraph">
<p>以下各节描述存储库格式（Maven或Ivy）。可以使用本地文件系统路径将它们声明为本地存储库。</p>
</div>
<div class="paragraph">
<p>平面目录存储库的不同之处在于它们确实遵循一种格式并包含元数据。</p>
</div>
<div class="paragraph">
<p>配置了这样的存储库后，Gradle将完全绕过其<a href="#sec:dependency_cache">依赖项缓存</a> ，因为无法保证内容在两次执行之间不会发生变化。由于该限制，它们可能会对性能产生影响。</p>
</div>
<div class="paragraph">
<p>它们还使构建的可复制性变得更难实现，应将其使用限制为修补或原型制作。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:maven_repo"><a class="anchor" href="#sec:maven_repo"></a> <a class="link" href="#sec:maven_repo">Maven仓库</a></h5>
<div class="paragraph">
<p>许多组织将依赖项托管在内部Maven存储库中，该存储库只能在公司的网络中访问。Gradle可以通过URL声明Maven存储库。</p>
</div>
<div class="paragraph">
<p>要添加自定义Maven存储库，您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例250。添加自定义Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/maven2</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;http://repo.mycompany.com/maven2&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:custom-maven-repo"><a class="anchor" href="#sub:custom-maven-repo"></a> <a class="link" href="#sub:custom-maven-repo">设置复合Maven存储库</a></h6>
<div class="paragraph">
<p>有时，存储库会将POM发布到一个位置，并将JAR和其他工件发布到另一位置。要定义这样的存储库，您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例251。为JAR文件添加其他Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        <span class="comment">// Look for POMs and artifacts, such as JARs, here</span>
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo2.mycompany.com/maven2</span><span class="delimiter">&quot;</span></span>
        <span class="comment">// Look for artifacts here if not found at the above location</span>
        artifactUrls <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/jars</span><span class="delimiter">&quot;</span></span>
        artifactUrls <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/jars2</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        // Look for POMs and artifacts, such as JARs, here
        url = uri(&quot;http://repo2.mycompany.com/maven2&quot;)
        // Look for artifacts here if not found at the above location
        artifactUrls(&quot;http://repo.mycompany.com/jars&quot;)
        artifactUrls(&quot;http://repo.mycompany.com/jars2&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>摇篮将看基地<code>url</code> POM和JAR的位置。如果找不到JAR，则多余的<code>artifactUrls</code>用于查找JAR。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:accessing_secured_maven_repositories"><a class="anchor" href="#sub:accessing_secured_maven_repositories"></a> <a class="link" href="#sub:accessing_secured_maven_repositories">访问经过身份验证的Maven存储库</a></h6>
<div class="paragraph">
<p>您可以为通过不同身份验证类型保护的Maven存储库指定凭据。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#sec:supported_transport_protocols">支持的存储库传输协议</a>以获取认证选项。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:maven_local"><a class="anchor" href="#sub:maven_local"></a> <a class="link" href="#sub:maven_local">本地Maven存储库</a></h6>
<div class="paragraph">
<p>Gradle可以使用<a href="https://maven.apache.org/guides/introduction/introduction-to-repositories.html">本地Maven存储库中</a>可用的依赖项。声明此存储库对于使用一个项目发布到本地Maven存储库并在另一个项目中使用Gradle消耗工件的团队来说是有益的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>Gradle将已解决的依赖性存储在<a href="#sec:dependency_cache">其自己的缓存中</a> 。即使您从基于Maven的远程存储库中解决依赖关系，构建也无需声明本地Maven存储库。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>在将Maven local添加为存储库之前，您应<a href="#sec:case-for-maven-local">确保确实需要这样做</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要将本地Maven缓存声明为存储库，请将其添加到构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">示例252。将本地Maven缓存添加为存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenLocal()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenLocal()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle使用与Maven相同的逻辑来标识本地Maven缓存的位置。如果在<code>settings.xml</code> ，将使用此位置。的<code>settings.xml</code>在<code><em>USER_HOME</em>/.m2</code>优先于<code>settings.xml</code>在<code><em>M2_HOME</em>/conf</code> 。如果不<code>settings.xml</code>可用，Gradle使用默认位置<code><em>USER_HOME</em>/.m2/repository</code> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:case-for-maven-local"><a class="anchor" href="#sec:case-for-maven-local"></a> <a class="link" href="#sec:case-for-maven-local">mavenLocal（）的情况</a></h5>
<div class="paragraph">
<p>作为一般建议，您应避免添加<code>mavenLocal()</code>作为存储库。使用中存在不同的问题<code>mavenLocal()</code>您应该注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maven将其用作缓存而不是存储库，这意味着它可以包含部分模块。</p>
<div class="ulist">
<ul>
<li>
<p>例如，如果Maven从不下载给定模块的源文件或javadoc文件，则Gradle将不会找到它们，因为一旦找到模块，它就会<a href="#sec:how-gradle-downloads-deps">在单个存储库中搜索文件</a> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>作为<a href="#sub:local-repos">本地存储库</a> ，Gradle不信任其内容，因为：</p>
<div class="ulist">
<ul>
<li>
<p>无法追踪工件的来源，这是正确性和安全性问题</p>
</li>
<li>
<p>工件很容易被覆盖，这是一个安全性，正确性和可再现性问题</p>
</li>
</ul>
</div>
</li>
<li>
<p>为了缓解元数据和/或工件可以更改的事实，Gradle不对<a href="#sub:local-repos">本地存储库</a>执行<a href="#sec:dependency_cache">任何缓存</a></p>
<div class="ulist">
<ul>
<li>
<p>因此，您的构建速度较慢</p>
</li>
<li>
<p>鉴于存储库的顺序很重要，因此添加<code>mavenLocal()</code> <em>首先</em>意味着您的所有构建都会变慢</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>在某些情况下，您可能需要使用<code>mavenLocal()</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为了与Maven互操作</p>
<div class="ulist">
<ul>
<li>
<p>例如，项目A是使用Maven构建的，项目B是使用Gradle构建的，并且您需要在开发过程中共享工件</p>
</li>
<li>
<p><em>总是</em>最好使用内部功能齐全的存储库来代替</p>
</li>
<li>
<p>如果无法做到这一点，则应将其限制为<em>仅本地构建</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>与Gradle本身的互操作性</p>
<div class="ulist">
<ul>
<li>
<p>在多存储库环境中，您要检查对项目A的更改是否与项目B一起使用</p>
</li>
<li>
<p>对于此用例，最好使用<a href="#composite_builds">复合构建</a></p>
</li>
<li>
<p>如果由于某种原因，既无法构建复合版本，也不具有功能齐全的存储库，则<code>mavenLocal()</code>是不得已的选择</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>在所有这些警告之后，如果最终使用<code>mavenLocal()</code> ，请考虑将其与<a href="#sec:repository-content-filtering">存储库过滤器</a>结合使用。这将确保它仅提供预期的内容，而不会提供其他任何内容。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:ivy_repositories"><a class="anchor" href="#sec:ivy_repositories"></a> <a class="link" href="#sec:ivy_repositories">常春藤仓库</a></h5>
<div class="paragraph">
<p>组织可能决定将依赖项托管在内部Ivy存储库中。Gradle可以通过URL声明Ivy存储库。</p>
</div>
<div class="sect5">
<h6 id="sub:defining_an_ivy_repository_with_a_standard_layout"><a class="anchor" href="#sub:defining_an_ivy_repository_with_a_standard_layout"></a> <a class="link" href="#sub:defining_an_ivy_repository_with_a_standard_layout">使用标准布局定义常春藤存储库</a></h6>
<div class="paragraph">
<p>要使用标准布局声明常春藤存储库，不需要其他自定义。您只需声明URL。</p>
</div>
<div class="exampleblock">
<div class="title">范例253。常春藤仓库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:defining_a_named_layout_for_an_ivy_repository"><a class="anchor" href="#sub:defining_a_named_layout_for_an_ivy_repository"></a> <a class="link" href="#sub:defining_a_named_layout_for_an_ivy_repository">定义常春藤存储库的命名布局</a></h6>
<div class="paragraph">
<p>您可以使用命名布局来指定存储库符合Ivy或Maven默认布局。</p>
</div>
<div class="exampleblock">
<div class="title">示例254具有命名布局的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
        layout <span class="string"><span class="delimiter">&quot;</span><span class="content">maven</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
        layout(&quot;maven&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有效的命名布局值为<code>'gradle'</code> （默认）， <code>'maven'</code>和<code>'ivy'</code> 。参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html#org.gradle.api.artifacts.repositories.IvyArtifactRepository:layout(java.lang.String)">IvyArtifactRepository.layout（java.lang。API文档中的字符串）</a>以获取这些命名布局的详细信息。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:defining_custom_pattern_layout_for_an_ivy_repository"><a class="anchor" href="#sub:defining_custom_pattern_layout_for_an_ivy_repository"></a> <a class="link" href="#sub:defining_custom_pattern_layout_for_an_ivy_repository">定义常春藤存储库的自定义模式布局</a></h6>
<div class="paragraph">
<p>要使用非标准布局定义常春藤存储库，可以为存储库定义<em>模式</em>布局：</p>
</div>
<div class="exampleblock">
<div class="title">示例255。具有模式布局的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
        patternLayout {
            artifact <span class="string"><span class="delimiter">&quot;</span><span class="content">[module]/[revision]/[type]/[artifact].[ext]</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
        patternLayout {
            artifact(&quot;[module]/[revision]/[type]/[artifact].[ext]&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要定义从不同位置获取Ivy文件和工件的Ivy存储库，可以定义单独的模式以用于定位Ivy文件和工件：</p>
</div>
<div class="paragraph">
<p>每<code>artifact</code>要么<code>ivy</code>为存储库指定的内容会添加<em>其他</em>模式以供使用。模式按照定义的顺序使用。</p>
</div>
<div class="exampleblock">
<div class="title">示例256具有多个自定义模式的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
        patternLayout {
            artifact <span class="string"><span class="delimiter">&quot;</span><span class="content">3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]</span><span class="delimiter">&quot;</span></span>
            artifact <span class="string"><span class="delimiter">&quot;</span><span class="content">company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]</span><span class="delimiter">&quot;</span></span>
            ivy <span class="string"><span class="delimiter">&quot;</span><span class="content">ivy-files/[organisation]/[module]/[revision]/ivy.xml</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
        patternLayout {
            artifact(&quot;3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]&quot;)
            artifact(&quot;company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]&quot;)
            ivy(&quot;ivy-files/[organisation]/[module]/[revision]/ivy.xml&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>（可选）具有模式布局的存储库可以具有其<code>'organisation'</code>零件以Maven样式布置，正斜杠代替点作为分隔符。例如，组织<code>my.company</code>然后将表示为<code>my/company</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例257。具有Maven兼容布局的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
        patternLayout {
            artifact <span class="string"><span class="delimiter">&quot;</span><span class="content">[organisation]/[module]/[revision]/[artifact]-[revision].[ext]</span><span class="delimiter">&quot;</span></span>
            m2compatible = <span class="predefined-constant">true</span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
        patternLayout {
            artifact(&quot;[organisation]/[module]/[revision]/[artifact]-[revision].[ext]&quot;)
            setM2compatible(true)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:accessing_secured_ivy_repositories"><a class="anchor" href="#sub:accessing_secured_ivy_repositories"></a> <a class="link" href="#sub:accessing_secured_ivy_repositories">访问经过身份验证的常春藤存储库</a></h6>
<div class="paragraph">
<p>您可以为通过基本身份验证保护的Ivy存储库指定凭据。</p>
</div>
<div class="exampleblock">
<div class="title">范例258。具有身份验证的常春藤存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com</span><span class="delimiter">&quot;</span></span>
        credentials {
            username <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>
            password <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;http://repo.mycompany.com&quot;)
        credentials {
            username = &quot;user&quot;
            password = &quot;password&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="#sec:supported_transport_protocols">支持的存储库传输协议</a>以获取认证选项。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:repository-content-filtering"><a class="anchor" href="#sec:repository-content-filtering"></a> <a class="link" href="#sec:repository-content-filtering">储存库内容过滤</a></h5>
<div class="paragraph">
<p>Gradle公开了一个API，以声明存储库可能包含或不包含的内容。有不同的用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>性能，当您知道在特定存储库中永远找不到依赖项时</p>
</li>
<li>
<p>通过避免泄漏私有项目中使用的依赖项来确保安全性</p>
</li>
<li>
<p>可靠性，当某些存储库包含损坏的元数据或工件时</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑到存储库的声明顺序很重要，这一点甚至更为重要。</p>
</div>
<div class="sect5">
<h6 id="declaring_a_repository_filter"><a class="anchor" href="#declaring_a_repository_filter"></a> <a class="link" href="#declaring_a_repository_filter">声明存储库过滤器</a></h6>
<div class="exampleblock">
<div class="title">示例259声明存储库内容</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">https://repo.mycompany.com/maven2</span><span class="delimiter">&quot;</span></span>
        content {
            <span class="comment">// this repository *only* contains artifacts with group &quot;my.company&quot;</span>
            includeGroup <span class="string"><span class="delimiter">&quot;</span><span class="content">my.company</span><span class="delimiter">&quot;</span></span>
        }
    }
    jcenter {
        content {
            <span class="comment">// this repository contains everything BUT artifacts with group starting with &quot;my.company&quot;</span>
            excludeGroupByRegex <span class="string"><span class="delimiter">&quot;</span><span class="content">my</span><span class="char">\\</span><span class="content">.company.*</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;https://repo.mycompany.com/maven2&quot;)
        content {
            // this repository *only* contains artifacts with group &quot;my.company&quot;
            includeGroup(&quot;my.company&quot;)
        }
    }
    jcenter {
        content {
            // this repository contains everything BUT artifacts with group starting with &quot;my.company&quot;
            excludeGroupByRegex(&quot;my\\.company.*&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，存储库包含所有内容，不包含任何内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果声明包含，那么它排除了一切<em>，但</em>包含的内容。</p>
</li>
<li>
<p>如果声明一个排除项，则它包括<em>除</em>排除项以外的所有内容。</p>
</li>
<li>
<p>如果声明包含和排除，则它仅包括显式包括但不排除的内容。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过显式<em>group</em> ， <em>module</em>或<em>version</em>严格或使用正则表达式进行过滤。有关详细信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/repositories/RepositoryContentDescriptor.html">RepositoryContentDescriptor</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="maven_repository_filtering"><a class="anchor" href="#maven_repository_filtering"></a> <a class="link" href="#maven_repository_filtering">Maven存储库过滤</a></h6>
<div class="paragraph">
<p>对于<a href="#sec:maven_repo">Maven存储库</a> ，通常情况下，存储库将包含发行版或快照。Gradle允许您声明使用此DSL在存储库中找到哪种工件：</p>
</div>
<div class="exampleblock">
<div class="title">示例260分割快照和发行版</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">https://repo.mycompany.com/releases</span><span class="delimiter">&quot;</span></span>
        mavenContent {
            releasesOnly()
        }
    }
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">https://repo.mycompany.com/snapshots</span><span class="delimiter">&quot;</span></span>
        mavenContent {
            snapshotsOnly()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;https://repo.mycompany.com/releases&quot;)
        mavenContent {
            releasesOnly()
        }
    }
    maven {
        url = uri(&quot;https://repo.mycompany.com/snapshots&quot;)
        mavenContent {
            snapshotsOnly()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:supported_metadata_sources"><a class="anchor" href="#sec:supported_metadata_sources"></a> <a class="link" href="#sec:supported_metadata_sources">支持的元数据源</a></h5>
<div class="paragraph">
<p>在存储库中搜索模块时，默认情况下，Gradle会检查该存储库中<a href="#sec:supported-metadata-formats">受支持的元数据文件格式</a> 。在Maven存储库中，Gradle查找一个<code>.pom</code>文件，在常春藤存储库中查找<code>ivy.xml</code>文件，并在平面目录存储库中直接查找<code>.jar</code>文件，因为它不需要任何元数据。从5.0开始，Gradle还会寻找<code>.module</code> （Gradle模块元数据）文件。</p>
</div>
<div class="paragraph">
<p>但是，如果定义自定义存储库，则可能需要配置此行为。例如，您可以定义一个Maven存储库，而无需<code>.pom</code>文件，但只有jar。为此，您可以为任何存储库配置<em>元数据源</em> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例261支持不带元数据的工件的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
        metadataSources {
            mavenPom()
            artifact()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
        metadataSources {
            mavenPom()
            artifact()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以指定多个源来告诉Gradle继续查找是否找不到文件。在这种情况下，检查源的顺序是预定义的。</p>
</div>
<div class="paragraph">
<p>支持以下元数据源：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表7。储存库传输协议</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">元数据源</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">订购</th>
<th class="tableblock halign-left valign-top">马文</th>
<th class="tableblock halign-left valign-top">常春藤/平目录</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gradleMetadata()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">寻找摇篮<code>.module</code>档案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第一</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mavenPom()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">寻找Maven <code>.pom</code>档案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第二名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ivyDescriptor()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">寻找<code>ivy.xml</code>档案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第二名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>artifact()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">直接寻找伪像</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第三名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ivy和Maven存储库的默认值随Gradle 6.0更改。在6.0之前， <code>artifact()</code>已包含在默认值中。当模块完全丢失时导致效率低下。要恢复此行为，例如，对于Maven Central，可以使用<code>mavenCentral { metadataSources { mavenPom(); artifact() } }</code> 。以类似的方式，您可以使用以下方式选择旧版Gradle中的新行为<code>mavenCentral { metadataSources { mavenPom() } }</code></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从Gradle 5.3开始，在解析元数据文件（无论是Ivy还是Maven）时，Gradle将寻找一个标记，指示存在匹配的Gradle Module元数据文件。如果找到它，它将代替Ivy或Maven文件使用。</p>
</div>
<div class="paragraph">
<p>从Gradle 5.6开始，您可以通过添加来禁用此行为<code>ignoreGradleMetadataRedirection()</code>到metadataSources声明。</p>
</div>
<div class="exampleblock">
<div class="title">示例262不使用Gradle元数据重定向的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
        metadataSources {
            mavenPom()
            artifact()
            ignoreGradleMetadataRedirection()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
        metadataSources {
            mavenPom()
            artifact()
            ignoreGradleMetadataRedirection()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:plugin-vs-build-repos"><a class="anchor" href="#sec:plugin-vs-build-repos"></a> <a class="link" href="#sec:plugin-vs-build-repos">插件存储库与构建存储库</a></h5>
<div class="paragraph">
<p>在构建期间，Gradle将在两个不同的阶段使用存储库。</p>
</div>
<div class="paragraph">
<p>第一阶段是在<a href="#sec:build_phases">配置构建</a>并加载其应用的插件时。为此，Gradle将使用一组特殊的存储库。</p>
</div>
<div class="paragraph">
<p>第二阶段是在依赖关系解析期间。此时，Gradle将使用项目中声明的存储库，如前几节所示。</p>
</div>
<div class="sect5">
<h6 id="sub:plugin-repos"><a class="anchor" href="#sub:plugin-repos"></a> <a class="link" href="#sub:plugin-repos">插件存储库</a></h6>
<div class="paragraph">
<p>默认情况下，Gradle将使用<a href="http://plugins.gradle.org">Gradle插件门户</a>来查找插件。</p>
</div>
<div class="paragraph">
<p>但是，由于不同的原因，在其他公共存储库或非公共存储库中都有可用的插件。当构建需要这些插件之一时，需要指定其他存储库，以便Gradle知道要在哪里搜索。</p>
</div>
<div class="paragraph">
<p>由于声明存储库的方式及其预期包含的内容取决于插件的应用方式，因此最好参考<a href="#sec:custom_plugin_repositories">Custom Plugin Repositories</a> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:supported_transport_protocols"><a class="anchor" href="#sec:supported_transport_protocols"></a> <a class="link" href="#sec:supported_transport_protocols">支持的存储库传输协议</a></h5>
<div class="paragraph">
<p>Maven和Ivy存储库支持使用各种传输协议。目前支持以下协议：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表8。储存库传输协议</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">凭证类型</th>
<th class="tableblock halign-left valign-top">链接</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>file</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户名密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:authentication_schemes">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>https</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户名密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:authentication_schemes">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sftp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户名密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:authentication_schemes">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s3</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问密钥/秘密密钥/会话令牌或环境变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:s3-repositories">文献资料</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gcs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://developers.google.com/identity/protocols/application-default-credentials">默认应用程序凭据</a>来自众所周知的文件，环境变量等。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:gcs-repositories">文献资料</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>用户名和密码绝对不应作为构建文件的一部分以纯文本格式输入版本控制中。您可以将凭据存储在本地<code>gradle.properties</code>文件并使用开源Gradle插件之一来加密和使用凭证，例如<a href="https://plugins.gradle.org/plugin/nu.studer.credentials">凭证插件</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>传输协议是存储库URL定义的一部分。以下构建脚本演示了如何创建基于HTTP的Maven和Ivy存储库：</p>
</div>
<div class="exampleblock">
<div class="title">示例263声明一个Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/maven2</span><span class="delimiter">&quot;</span></span>
    }

    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;http://repo.mycompany.com/maven2&quot;)
    }

    ivy {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何声明SFTP存储库：</p>
</div>
<div class="exampleblock">
<div class="title">示例264对存储库使用SFTP协议</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">sftp://repo.mycompany.com:22/maven2</span><span class="delimiter">&quot;</span></span>
        credentials {
            username <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>
            password <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>
        }
    }

    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">sftp://repo.mycompany.com:22/repo</span><span class="delimiter">&quot;</span></span>
        credentials {
            username <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>
            password <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;sftp://repo.mycompany.com:22/maven2&quot;)
        credentials {
            username = &quot;user&quot;
            password = &quot;password&quot;
        }
    }

    ivy {
        url = uri(&quot;sftp://repo.mycompany.com:22/repo&quot;)
        credentials {
            username = &quot;user&quot;
            password = &quot;password&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关HTTP相关身份验证的详细信息，请参阅“ <a href="#sec:authentication_schemes">HTTP（S）身份验证方案配置”部分</a> 。</p>
</div>
<div class="paragraph">
<p>使用支持AWS S3的存储库时，您需要使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.credentials.AwsCredentials.html">AwsCredentials</a>进行身份验证，并提供访问密钥和私钥。以下示例显示了如何声明S3支持的存储库并提供AWS凭证：</p>
</div>
<div class="exampleblock">
<div class="title">示例265声明一个S3支持的Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">s3://myCompanyBucket/maven2</span><span class="delimiter">&quot;</span></span>
        credentials(AwsCredentials) {
            accessKey <span class="string"><span class="delimiter">&quot;</span><span class="content">someKey</span><span class="delimiter">&quot;</span></span>
            secretKey <span class="string"><span class="delimiter">&quot;</span><span class="content">someSecret</span><span class="delimiter">&quot;</span></span>
            <span class="comment">// optional</span>
            sessionToken <span class="string"><span class="delimiter">&quot;</span><span class="content">someSTSToken</span><span class="delimiter">&quot;</span></span>
        }
    }

    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">s3://myCompanyBucket/ivyrepo</span><span class="delimiter">&quot;</span></span>
        credentials(AwsCredentials) {
            accessKey <span class="string"><span class="delimiter">&quot;</span><span class="content">someKey</span><span class="delimiter">&quot;</span></span>
            secretKey <span class="string"><span class="delimiter">&quot;</span><span class="content">someSecret</span><span class="delimiter">&quot;</span></span>
            <span class="comment">// optional</span>
            sessionToken <span class="string"><span class="delimiter">&quot;</span><span class="content">someSTSToken</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;s3://myCompanyBucket/maven2&quot;)
        credentials(AwsCredentials::class) {
            accessKey = &quot;someKey&quot;
            secretKey = &quot;someSecret&quot;
            // optional
            sessionToken = &quot;someSTSToken&quot;
        }
    }

    ivy {
        url = uri(&quot;s3://myCompanyBucket/ivyrepo&quot;)
        credentials(AwsCredentials::class) {
            accessKey = &quot;someKey&quot;
            secretKey = &quot;someSecret&quot;
            // optional
            sessionToken = &quot;someSTSToken&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用AwsImAuthentication将所有凭证委派给AWS sdk。以下示例显示了如何：</p>
</div>
<div class="exampleblock">
<div class="title">实施例266。使用IAM声明一个S3支持的Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">s3://myCompanyBucket/maven2</span><span class="delimiter">&quot;</span></span>
        authentication {
           awsIm(AwsImAuthentication) <span class="comment">// load from EC2 role or env var</span>
        }
    }

    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">s3://myCompanyBucket/ivyrepo</span><span class="delimiter">&quot;</span></span>
        authentication {
           awsIm(AwsImAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;s3://myCompanyBucket/maven2&quot;)
        authentication {
            create&lt;AwsImAuthentication&gt;(&quot;awsIm&quot;) // load from EC2 role or env var
        }
    }

    ivy {
        url = uri(&quot;s3://myCompanyBucket/ivyrepo&quot;)
        authentication {
            create&lt;AwsImAuthentication&gt;(&quot;awsIm&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关与AWS S3相关的身份验证的详细信息，请参阅“ <a href="#sec:s3-repositories">AWS S3存储库配置</a> ”部分。</p>
</div>
<div class="paragraph">
<p>使用Google Cloud Storage支持的存储库时，将使用默认的应用程序凭据，而无需进一步配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例267。使用默认应用程序凭据声明由Google Cloud Storage支持的Maven和Ivy存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">gcs://myCompanyBucket/maven2</span><span class="delimiter">&quot;</span></span>
    }

    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">gcs://myCompanyBucket/ivyrepo</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;gcs://myCompanyBucket/maven2&quot;)
    }

    ivy {
        url = uri(&quot;gcs://myCompanyBucket/ivyrepo&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关与Google GCS相关的身份验证的详细信息，请参阅“ <a href="#sec:gcs-repositories">Google Cloud Storage存储库配置”部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:authentication_schemes"><a class="anchor" href="#sec:authentication_schemes"></a> <a class="link" href="#sec:authentication_schemes">HTTP（S）身份验证方案配置</a></h5>
<div class="paragraph">
<p>使用HTTP或HTTPS传输协议配置存储库时，可以使用多种身份验证方案。默认情况下，Gradle会尝试使用Apache HttpClient库支持的所有方案（在<a href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/authentication.html#d5e625">此处记录）</a> 。在某些情况下，与远程服务器交换凭据时，最好明确指定应使用哪种身份验证方案。明确声明时，在对远程存储库进行身份验证时仅使用那些方案。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/credentials/PasswordCredentials.html">PasswordCredentials</a>为通过基本身份验证保护的Maven存储库指定凭据。</p>
</div>
<div class="exampleblock">
<div class="title">示例268。访问受密码保护的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/maven2</span><span class="delimiter">&quot;</span></span>
        credentials {
            username <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>
            password <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;http://repo.mycompany.com/maven2&quot;)
        credentials {
            username = &quot;user&quot;
            password = &quot;password&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/artifacts/defineRepository</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示如何将存储库配置为仅使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/authentication/http/DigestAuthentication.html">DigestAuthentication</a> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例269配置存储库以仅使用摘要身份验证</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">'</span><span class="content">https://repo.mycompany.com/maven2</span><span class="delimiter">'</span></span>
        credentials {
            username <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>
            password <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>
        }
        authentication {
            digest(DigestAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;https://repo.mycompany.com/maven2&quot;)
        credentials {
            username = &quot;user&quot;
            password = &quot;password&quot;
        }
        authentication {
            create&lt;DigestAuthentication&gt;(&quot;digest&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当前支持的身份验证方案是：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/authentication/http/BasicAuthentication.html">基本认证</a></dt>
<dd>
<p>通过HTTP的基本访问身份验证。使用此方案时，将抢先发送凭据。</p>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/authentication/http/DigestAuthentication.html">摘要认证</a></dt>
<dd>
<p>通过HTTP的摘要式访问身份验证。</p>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/authentication/http/HttpHeaderAuthentication.html">HttpHeaderAuthentication</a></dt>
<dd>
<p>基于任何自定义HTTP标头的身份验证，例如私有令牌，OAuth令牌等。</p>
</dd>
</dl>
</div>
<div class="sect5">
<h6 id="sub:preemptive_authentication"><a class="anchor" href="#sub:preemptive_authentication"></a> <a class="link" href="#sub:preemptive_authentication">使用抢占式身份验证</a></h6>
<div class="paragraph">
<p>Gradle的默认行为是仅在服务器以HTTP 401响应的形式通过身份验证质询响应时提交凭据。在某些情况下，服务器将以不同的代码响应（例如，对于托管在GitHub上的存储库，返回404），从而导致依赖性解析失败。若要解决此问题，凭据可能会抢先发送到服务器。要启用抢占式身份验证，只需将您的存储库配置为显式使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/authentication/http/BasicAuthentication.html">BasicAuthentication</a>方案：</p>
</div>
<div class="exampleblock">
<div class="title">示例270配置存储库以使用抢占式身份验证</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">'</span><span class="content">https://repo.mycompany.com/maven2</span><span class="delimiter">'</span></span>
        credentials {
            username <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>
            password <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>
        }
        authentication {
            basic(BasicAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;https://repo.mycompany.com/maven2&quot;)
        credentials {
            username = &quot;user&quot;
            password = &quot;password&quot;
        }
        authentication {
            create&lt;BasicAuthentication&gt;(&quot;basic&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:http-header-auth"><a class="anchor" href="#sub:http-header-auth"></a> <a class="link" href="#sub:http-header-auth">使用HTTP标头身份验证</a></h6>
<div class="paragraph">
<p>您可以使用带有<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/authentication/http/HttpHeaderAuthentication.html">HttpHeaderAuthentication的HttpHeaderCredentials</a>为需要令牌，OAuth2或其他基于HTTP头的身份验证的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/credentials/HttpHeaderCredentials.html">受</a>保护的Maven存储库指定任何HTTP头。</p>
</div>
<div class="exampleblock">
<div class="title">示例271访问标头保护的Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/maven2</span><span class="delimiter">&quot;</span></span>
        credentials(HttpHeaderCredentials) {
            name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Private-Token</span><span class="delimiter">&quot;</span></span>
            value = <span class="string"><span class="delimiter">&quot;</span><span class="content">TOKEN</span><span class="delimiter">&quot;</span></span>
        }
        authentication {
            header(HttpHeaderAuthentication)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven {
        url = uri(&quot;http://repo.mycompany.com/maven2&quot;)
        credentials(HttpHeaderCredentials::class) {
            name = &quot;Private-Token&quot;
            value = &quot;TOKEN&quot;
        }
        authentication {
            create&lt;HttpHeaderAuthentication&gt;(&quot;header&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/artifacts/defineRepository</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:s3-repositories"><a class="anchor" href="#sec:s3-repositories"></a> <a class="link" href="#sec:s3-repositories">AWS S3存储库配置</a></h5>
<div class="sect5">
<h6 id="sub:s3_configuration_properties"><a class="anchor" href="#sub:s3_configuration_properties"></a> <a class="link" href="#sub:s3_configuration_properties">S3配置属性</a></h6>
<div class="paragraph">
<p>以下系统属性可用于配置与s3存储库的交互：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.gradle.s3.endpoint</code></dt>
<dd>
<p>使用不兼容AWS，S3 API的存储服务时，用于覆盖AWS S3终端节点。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.s3.maxErrorRetry</code></dt>
<dd>
<p>指定在S3服务器以HTTP 5xx状态代码响应的情况下重试请求的最大次数。如果未指定，则使用默认值3。</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="sub:s3_url_formats"><a class="anchor" href="#sub:s3_url_formats"></a> <a class="link" href="#sub:s3_url_formats">S3 URL格式</a></h6>
<div class="paragraph">
<p>S3 URL是“虚拟主机样式”，并且必须采用以下格式</p>
</div>
<div class="listingblock">
<div class="content">
<pre>s3://&lt;bucketName&gt;[.&lt;regionSpecificEndpoint&gt;]/&lt;s3Key&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>例如<code>s3://myBucket.s3.eu-central-1.amazonaws.com/maven/release</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>myBucket</code>是AWS S3存储桶名称。</p>
</li>
<li>
<p><code>s3.eu-central-1.amazonaws.com</code>是<a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">特定</a>于<a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">区域</a>的<em>可选</em> <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region">端点</a> 。</p>
</li>
<li>
<p><code>/maven/release</code>是AWS S3密钥（存储桶中对象的唯一标识符）</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="sub:s3_proxy_settings"><a class="anchor" href="#sub:s3_proxy_settings"></a> <a class="link" href="#sub:s3_proxy_settings">S3代理设置</a></h6>
<div class="paragraph">
<p>可以使用以下系统属性来配置S3的代理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>https.proxyHost</code></p>
</li>
<li>
<p><code>https.proxyPort</code></p>
</li>
<li>
<p><code>https.proxyUser</code></p>
</li>
<li>
<p><code>https.proxyPassword</code></p>
</li>
<li>
<p><code>http.nonProxyHosts</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果<code>org.gradle.s3.endpoint</code>已使用HTTP（非HTTPS）URI指定属性，可以使用以下系统代理设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>http.proxyHost</code></p>
</li>
<li>
<p><code>http.proxyPort</code></p>
</li>
<li>
<p><code>http.proxyUser</code></p>
</li>
<li>
<p><code>http.proxyPassword</code></p>
</li>
<li>
<p><code>http.nonProxyHosts</code></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="sub:s3_v4_signatures"><a class="anchor" href="#sub:s3_v4_signatures"></a> <a class="link" href="#sub:s3_v4_signatures">AWS S3 V4签名（AWS4-HMAC-SHA256）</a></h6>
<div class="paragraph">
<p>某些AWS S3地区（eu-central-1-Frankfurt）要求所有HTTP请求均根据AWS的<a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">签名版本4进行签名</a> 。当使用需要V4签名的存储桶时，建议指定包含区域特定终结点的S3 URL。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>s3://somebucket.s3.eu-central-1.amazonaws.com/maven/release</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果未为需要V4签名的存储桶指定特定于区域的终结点，则Gradle将使用默认的AWS区域（us-east-1），并且控制台上会出现以下警告：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>尝试将请求重新发送给....使用AWS V4身份验证为避免将来出现此警告，请使用特定于区域的终结点来访问需要V4签名的区域中的存储桶。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>无法为需要V4签名的存储桶指定特定于区域的端点意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每次上传和下载文件时，AWS往返3次，而不是一次。</p>
</li>
<li>
<p>根据位置-网络等待时间增加，构建速度变慢。</p>
</li>
<li>
<p>传输失败的可能性增加。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect6">
<h7 id="sub:s3_cross_account"><a class="anchor" href="#sub:s3_cross_account"></a> <a class="link" href="#sub:s3_cross_account">AWS S3跨账户访问</a></h7>
<div class="paragraph">
<p>一些组织可能有多个AWS账户，例如每个团队一个。存储桶拥有者的AWS账户通常与工件发布者和消费者不同。存储桶拥有者必须能够授予消费者访问权限，否则工件只能由发布者的帐户使用。这是通过添加<code>bucket-owner-full-control</code> <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl">罐头ACL</a>到上载的对象。Gradle将在每次上传中执行此操作。确保发布者具有所需的IAM权限， <code>PutObjectAcl</code> （和<code>PutObjectVersionAcl</code> （如果启用了存储桶版本控制），则直接或通过假定的IAM角色（取决于您的情况）。您可以在<a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html">AWS S3访问权限中</a>阅读更多内容。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:gcs-repositories"><a class="anchor" href="#sec:gcs-repositories"></a> <a class="link" href="#sec:gcs-repositories">Google Cloud Storage储存库配置</a></h5>
<div class="sect5">
<h6 id="sub:gcs_configuration_properties"><a class="anchor" href="#sub:gcs_configuration_properties"></a> <a class="link" href="#sub:gcs_configuration_properties">GCS配置属性</a></h6>
<div class="paragraph">
<p>以下系统属性可用于配置与<a href="https://cloud.google.com/storage/">Google Cloud Storage存储</a>库的交互：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>org.gradle.gcs.endpoint</code></dt>
<dd>
<p>当使用非Google Cloud Platform兼容的Google Cloud Storage API的存储服务时，用于覆盖Google Cloud Storage端点。</p>
</dd>
<dt class="hdlist1"><code>org.gradle.gcs.servicePath</code></dt>
<dd>
<p>用于覆盖Google Cloud Storage客户端从其生成请求的Google Cloud Storage根服务路径，默认为<code>/</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="sub:gcs_url_formats"><a class="anchor" href="#sub:gcs_url_formats"></a> <a class="link" href="#sub:gcs_url_formats">GCS URL格式</a></h6>
<div class="paragraph">
<p>Google Cloud Storage网址为“虚拟托管样式”，并且必须采用以下格式<code>gcs://<bucketName>/<objectKey></code></p>
</div>
<div class="paragraph">
<p>例如<code>gcs://myBucket/maven/release</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>myBucket</code>是Google Cloud Storage存储桶名称。</p>
</li>
<li>
<p><code>/maven/release</code>是Google Cloud Storage密钥（存储桶中对象的唯一标识符）</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="declaring-dependencies"><a class="anchor" href="#declaring-dependencies"></a> <a class="link" href="#declaring-dependencies">声明依赖</a></h4>
<div class="paragraph">
<p>在查看依赖项声明本身之前，需要定义<em>依赖项配置</em>的概念。</p>
</div>
<div class="sect4">
<h5 id="sec:what-are-dependency-configurations"><a class="anchor" href="#sec:what-are-dependency-configurations"></a> <a class="link" href="#sec:what-are-dependency-configurations">什么是依赖项配置</a></h5>
<div class="paragraph">
<p>为Gradle项目声明的每个依赖项都适用于特定范围。例如，某些依赖项应用于编译源代码，而其他依赖项仅需要在运行时可用。Gradle在<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.Configuration.html">Configuration</a>的帮助下表示依赖项的范围。每个配置都可以通过唯一的名称来标识。</p>
</div>
<div class="paragraph">
<p>许多Gradle插件都会向您的项目添加预定义的配置。例如，Java插件添加了一些配置，以表示其用于源代码编译，执行测试等所需的各种类路径。有关示例，请参见<a href="#sec:java_plugin_and_dependency_management">Java插件章节</a> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-configurations.png" alt="依赖管理配置">
</div>
<div class="title">图15。配置将声明的依赖项用于特定目的</div>
</div>
<div class="paragraph">
<p>有关使用配置导航，检查和后处理分配的依赖项的元数据和工件的更多示例，请查看<a href="#sec:programmatic_api">解析结果API</a> 。</p>
</div>
<div class="sect5">
<h6 id="sub:config-inheritance-composition"><a class="anchor" href="#sub:config-inheritance-composition"></a> <a class="link" href="#sub:config-inheritance-composition">配置继承和组合</a></h6>
<div class="paragraph">
<p>一个配置可以扩展其他配置以形成继承层次结构。子配置继承为其任何超配置声明的整个依赖项集。</p>
</div>
<div class="paragraph">
<p>Gradle核心插件（如<a href="#sec:java_plugin_and_dependency_management">Java插件</a> ）大量使用配置继承。例如<code>testImplementation</code>配置扩展了<code>implementation</code>组态。配置层次结构有一个实际目的：编译测试需要在编写测试类所需的依赖之上加上被测试源代码的依赖。如果将其类导入生产源代码中，则使用JUnit编写和执行测试代码的Java项目也需要Guava。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-configuration-inheritance.png" alt="依赖管理配置继承">
</div>
<div class="title">图16。Java插件提供的配置继承</div>
</div>
<div class="paragraph">
<p>在幕后<code>testImplementation</code>和<code>implementation</code>配置通过调用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:extendsFrom(org.gradle.api.artifacts.Configuration[])">Configuration.extendsFrom（org.gradle.api.artifacts方法来形成继承层次结构</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:extendsFrom(org.gradle.api.artifacts.Configuration[])">。配置[]）</a> 。配置可以扩展任何其他配置，无论其在构建脚本或插件中的定义如何。</p>
</div>
<div class="paragraph">
<p>假设您想编写一套烟雾测试。每个冒烟测试都会进行HTTP调用以验证Web服务端点。作为基础测试框架，该项目已使用JUnit。您可以定义一个名为<code>smokeTest</code>从<code>testImplementation</code>配置以重用现有的测试框架依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">示例272从其他配置扩展配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    smokeTest.extendsFrom testImplementation
}

dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
    smokeTest <span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient:4.5.5</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val smokeTest by configurations.creating {
    extendsFrom(configurations.testImplementation.get())
}

dependencies {
    testImplementation(&quot;junit:junit:4.12&quot;)
    smokeTest(&quot;org.apache.httpcomponents:httpclient:4.5.5&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:resolvable-consumable-configs"><a class="anchor" href="#sec:resolvable-consumable-configs"></a> <a class="link" href="#sec:resolvable-consumable-configs">可解析和消耗性配置</a></h5>
<div class="paragraph">
<p>从历史上看，配置一直是Gradle中依赖关系解析的根本。最后，我们要有所作为的是<em>消费者</em>和<em>生产者之间</em> 。为此，配置至少用于三个不同方面：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>声明依赖</p>
</li>
<li>
<p>作为<em>使用者</em> ，解决文件的一系列依赖关系</p>
</li>
<li>
<p>作为<em>生产者</em> ，将工件及其依赖项公开以供其他项目使用（此类<em>消耗性</em>配置通常表示生产者向其消费者提供的<a href="#">变体</a> ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如，如果我想表达我的申请<code>app</code> <em>取决于</em>图书馆<code>lib</code> ，我们<em>至少</em>需要一种配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例273配置用于声明依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    <span class="comment">// declare a &quot;configuration&quot; named &quot;someConfiguration&quot;</span>
    someConfiguration
}
dependencies {
    <span class="comment">// add a project dependency to the &quot;someConfiguration&quot; configuration</span>
    someConfiguration project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:lib</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// declare a &quot;configuration&quot; named &quot;someConfiguration&quot;
val someConfiguration by configurations.creating

dependencies {
    // add a project dependency to the &quot;someConfiguration&quot; configuration
    someConfiguration(project(&quot;:lib&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>配置可以扩展其他配置，以继承其依赖性。但是，上面的代码没有告诉任何有关<em>使用者的信息</em> 。特别是，它没有告诉您配置的<em>用途</em> 。比方说<code>lib</code>是一个Java库：它可以公开不同的内容，例如其API，实现或测试装置。如果我们想解决依赖关系<code>app</code> ，我们需要知道我们正在执行哪种任务（针对的API进行编译<code>lib</code> ，执行应用程序，编译测试...）。为此，您通常会找到伴随的配置，这些配置旨在明确声明其用法：</p>
</div>
<div class="exampleblock">
<div class="title">实施例274。代表具体依赖图的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    <span class="comment">// declare a configuration that is going to resolve the compile classpath of the application</span>
    compileClasspath.extendsFrom(someConfiguration)

    <span class="comment">// declare a configuration that is going to resolve the runtime classpath of the application</span>
    runtimeClasspath.extendsFrom(someConfiguration)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    // declare a configuration that is going to resolve the compile classpath of the application
    compileClasspath.extendsFrom(someConfiguration)

    // declare a configuration that is going to resolve the runtime classpath of the application
    runtimeClasspath.extendsFrom(someConfiguration)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此阶段，我们有3种不同的配置，它们已经有不同的目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>someConfiguration</code>声明我的应用程序的依赖关系。这只是一个我们在其中声明依赖项列表的存储桶。</p>
</li>
<li>
<p><code>compileClasspath</code>和<code>runtimeClasspath</code>是<em>要解决的</em>配置：解决时，它们应分别包含应用程序的编译类路径和运行时类路径。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这实际上是在<code>Configuration</code>键入<code>canBeResolved</code>旗。<em>可以解析</em>的配置是我们可以为其计算依赖关系图的配置，因为它包含实现解析所需的所有必要信息。也就是说，我们将计算一个依赖图，解析图中的组件，并最终获得工件。具有以下配置<code>canBeResolved</code>调成<code>false</code>并不意味着要解决。这样的配置<em>仅用于声明依赖项</em> 。原因是根据用法（编译类路径，运行时类路径），它<em>可以</em>解析为不同的图。尝试解决具有以下问题的配置是错误的<code>canBeResolved</code>调成<code>false</code> 。在某种程度上，这类似于<em>抽象类</em> （ <code>canBeResolved</code> = false）（不应该实例化），以及扩展抽象类的具体类（ <code>canBeResolved</code> = true）。可解析的配置将扩展至少一个不可解析的配置（并且可能会扩展多个）。</p>
</div>
<div class="paragraph">
<p>另一方面，在图书馆项目方面（ <em>生产者</em> ），我们还使用配置来表示可以消耗的东西。例如，该库可能公开一个API或运行时，并且我们会将工件附加到一个或多个。通常，针对<code>lib</code> ，我们需要的API <code>lib</code> ，但我们不需要其运行时依赖项。所以<code>lib</code>项目将公开<code>apiElements</code>配置，面向寻求其API的消费者。这样的配置将是消耗性的，但并不意味着必须解决。通过a的<em>canBeConsumed</em>标志表示<code>Configuration</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例275设置配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    <span class="comment">// A configuration meant for consumers that need the API of this component</span>
    exposedApi {
        <span class="comment">// This configuration is an &quot;outgoing&quot; configuration, it's not meant to be resolved</span>
        canBeResolved = <span class="predefined-constant">false</span>
        <span class="comment">// As an outgoing configuration, explain that consumers may want to consume it</span>
        canBeConsumed = <span class="predefined-constant">true</span>
    }
    <span class="comment">// A configuration meant for consumers that need the implementation of this component</span>
    exposedRuntime {
        canBeResolved = <span class="predefined-constant">false</span>
        canBeConsumed = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    // A configuration meant for consumers that need the API of this component
    create(&quot;exposedApi&quot;) {
        // This configuration is an &quot;outgoing&quot; configuration, it's not meant to be resolved
        isCanBeResolved = false
        // As an outgoing configuration, explain that consumers may want to consume it
        isCanBeConsumed = true
    }
    // A configuration meant for consumers that need the implementation of this component
    create(&quot;exposedRuntime&quot;) {
        isCanBeResolved = false
        isCanBeConsumed = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>简而言之，配置角色由<code>canBeResolved</code>和<code>canBeConsumed</code>标志组合：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表9。配置角色</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置角色</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以解决</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以食用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">依赖桶</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决某些用途</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">暴露给消费者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">旧版，请勿使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>为了向后兼容，这些标志同时具有<code>true</code>作为默认值，但作为插件作者，您应该始终为这些标志确定正确的值，否则可能会意外引入解析错误。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:choosing-configuration"><a class="anchor" href="#sec:choosing-configuration"></a> <a class="link" href="#sec:choosing-configuration">选择正确的依赖项配置</a></h5>
<div class="paragraph">
<p>声明依赖项的配置的选择很重要。但是，没有固定的规则必须将依赖项放入哪个配置中。它主要取决于配置的组织方式，这通常是所应用插件的属性。</p>
</div>
<div class="paragraph">
<p>例如，在<code>java</code>插件，创建的配置已<a href="#tab:configurations">记录在案，</a>并应根据其在代码中的作用，作为确定在哪里声明依赖项的基础。</p>
</div>
<div class="paragraph">
<p>作为建议，插件应明确记录其配置链接在一起的方式，并应尽最大努力隔离其<a href="#sec:resolvable-consumable-configs">角色</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:defining-custom-configurations"><a class="anchor" href="#sec:defining-custom-configurations"></a> <a class="link" href="#sec:defining-custom-configurations">定义自定义配置</a></h5>
<div class="paragraph">
<p>您可以自己定义配置，即所谓的<em>自定义配置</em> 。定制配置对于分离专用目的所需的依赖项范围很有用。</p>
</div>
<div class="paragraph">
<p>比方说，你想声明的依赖<a href="https://tomcat.apache.org/tomcat-9.0-doc/jasper-howto.html">碧玉Ant任务</a>为<em>不</em>应该在classpath最终编译源代码预编译JSP文件的目的。通过引入自定义配置并在任务中使用它来实现该目标相当简单。</p>
</div>
<div class="exampleblock">
<div class="title">示例276。声明和使用自定义配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    jasper
}

repositories {
    mavenCentral()
}

dependencies {
    jasper <span class="string"><span class="delimiter">'</span><span class="content">org.apache.tomcat.embed:tomcat-embed-jasper:9.0.2</span><span class="delimiter">'</span></span>
}

task preCompileJsps {
    doLast {
        ant.taskdef(<span class="key">classname</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.apache.jasper.JspC</span><span class="delimiter">'</span></span>,
                    <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">jasper</span><span class="delimiter">'</span></span>,
                    <span class="key">classpath</span>: configurations.jasper.asPath)
        ant.jasper(<span class="key">validateXml</span>: <span class="predefined-constant">false</span>,
                   <span class="key">uriroot</span>: file(<span class="string"><span class="delimiter">'</span><span class="content">src/main/webapp</span><span class="delimiter">'</span></span>),
                   <span class="key">outputDir</span>: file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/compiled-jsps</span><span class="delimiter">&quot;</span></span>))
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val jasper by configurations.creating

repositories {
    mavenCentral()
}

dependencies {
    jasper(&quot;org.apache.tomcat.embed:tomcat-embed-jasper:9.0.2&quot;)
}

tasks.register(&quot;preCompileJsps&quot;) {
    doLast {
        ant.withGroovyBuilder {
            &quot;taskdef&quot;(&quot;classname&quot; to &quot;org.apache.jasper.JspC&quot;,
                      &quot;name&quot; to &quot;jasper&quot;,
                      &quot;classpath&quot; to jasper.asPath)
            &quot;jasper&quot;(&quot;validateXml&quot; to false,
                     &quot;uriroot&quot; to file(&quot;src/main/webapp&quot;),
                     &quot;outputDir&quot; to file(&quot;$buildDir/compiled-jsps&quot;))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>项目的配置由<code>configurations</code>宾语。配置具有名称，并且可以互相扩展。要了解有关此API的更多信息，请查看<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ConfigurationContainer.html">ConfigurationContainer</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:dependency-types"><a class="anchor" href="#sec:dependency-types"></a> <a class="link" href="#sec:dependency-types">不同种类的依赖</a></h5>
<div class="sect5">
<h6 id="sub:module_dependencies"><a class="anchor" href="#sub:module_dependencies"></a> <a class="link" href="#sub:module_dependencies">模块依赖</a></h6>
<div class="paragraph">
<p>模块依赖性是最常见的依赖性。它们引用存储库中的模块。</p>
</div>
<div class="exampleblock">
<div class="title">实施例277。模块依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    runtimeOnly <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.springframework</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">spring-core</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">2.5</span><span class="delimiter">'</span></span>
    runtimeOnly <span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-core:2.5</span><span class="delimiter">'</span></span>,
            <span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-aop:2.5</span><span class="delimiter">'</span></span>
    runtimeOnly(
        [<span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.springframework</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">spring-core</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">2.5</span><span class="delimiter">'</span></span>],
        [<span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.springframework</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">spring-aop</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">2.5</span><span class="delimiter">'</span></span>]
    )
    runtimeOnly(<span class="string"><span class="delimiter">'</span><span class="content">org.hibernate:hibernate:3.0.5</span><span class="delimiter">'</span></span>) {
        transitive = <span class="predefined-constant">true</span>
    }
    runtimeOnly <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.hibernate</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">hibernate</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">3.0.5</span><span class="delimiter">'</span></span>, <span class="key">transitive</span>: <span class="predefined-constant">true</span>
    runtimeOnly(<span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.hibernate</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">hibernate</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">3.0.5</span><span class="delimiter">'</span></span>) {
        transitive = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    runtimeOnly(group = &quot;org.springframework&quot;, name = &quot;spring-core&quot;, version = &quot;2.5&quot;)
    runtimeOnly(&quot;org.springframework:spring-aop:2.5&quot;)
    runtimeOnly(&quot;org.hibernate:hibernate:3.0.5&quot;) {
        isTransitive = true
    }
    runtimeOnly(group = &quot;org.hibernate&quot;, name = &quot;hibernate&quot;, version = &quot;3.0.5&quot;) {
        isTransitive = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多示例和完整参考，请参阅API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html">DependencyHandler</a>类。</p>
</div>
<div class="paragraph">
<p>Gradle为模块依赖性提供了不同的表示法。有一个字符串符号和一个映射符号。模块依赖性具有允许进一步配置的API。看一看<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html">ExternalModuleDependency，</a>以了解有关API的全部信息。该API提供了属性和配置方法。通过字符串符号，您可以定义属性的子集。使用地图符号，您可以定义所有属性。要使用映射或字符串表示法访问完整的API，可以将单个依赖项与闭包一起分配给配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果您声明模块依赖性，则Gradle会查找模块元数据文件（ <code>.module</code> ， <code>.pom</code>要么<code>ivy.xml</code> ）中。如果存在这样的模块元数据文件，则将对其进行解析以及该模块的工件（例如<code>hibernate-3.0.5.jar</code> ）及其依赖项（例如<code>cglib</code> ）下载。如果不存在这样的模块元数据文件，那么从Gradle 6.0开始，您需要配置<a href="#sec:supported_metadata_sources">元数据源定义</a>以查找名为<code>hibernate-3.0.5.jar</code>直。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在Maven中，一个模块只能有一个工件。</p>
</div>
<div class="paragraph">
<p>在Gradle和Ivy中，一个模块可以具有多个工件。每个工件可以具有不同的依赖关系集。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="sub:file_dependencies"><a class="anchor" href="#sub:file_dependencies"></a> <a class="link" href="#sub:file_dependencies">文件依赖</a></h6>
<div class="paragraph">
<p>项目有时不依赖于二进制存储库产品（例如JFrog Artifactory或Sonatype Nexus）来托管和解决外部依赖项。通常的做法是将这些依赖项托管在共享驱动器上，或者将其与项目源代码一起放入版本控制中。这些依赖关系称为<em>文件依赖关系</em> ，原因是它们表示文件没有附加任何<a href="#sub:terminology_module_metadata">元数据</a> （例如有关传递依赖关系，源或其作者的信息）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-file-dependencies.png" alt="依赖管理文件依赖">
</div>
<div class="title">图17。解决本地文件系统和共享驱动器中的文件依赖关系</div>
</div>
<div class="paragraph">
<p>以下示例从目录解析文件依赖关系<code>ant</code> ， <code>libs</code>和<code>tools</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例278声明多个文件依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    antContrib
    externalLibs
    deploymentTools
}

dependencies {
    antContrib files(<span class="string"><span class="delimiter">'</span><span class="content">ant/antcontrib.jar</span><span class="delimiter">'</span></span>)
    externalLibs files(<span class="string"><span class="delimiter">'</span><span class="content">libs/commons-lang.jar</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">libs/log4j.jar</span><span class="delimiter">'</span></span>)
    deploymentTools(fileTree(<span class="string"><span class="delimiter">'</span><span class="content">tools</span><span class="delimiter">'</span></span>) { include <span class="string"><span class="delimiter">'</span><span class="content">*.exe</span><span class="delimiter">'</span></span> })
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    create(&quot;antContrib&quot;)
    create(&quot;externalLibs&quot;)
    create(&quot;deploymentTools&quot;)
}

dependencies {
    &quot;antContrib&quot;(files(&quot;ant/antcontrib.jar&quot;))
    &quot;externalLibs&quot;(files(&quot;libs/commons-lang.jar&quot;, &quot;libs/log4j.jar&quot;))
    &quot;deploymentTools&quot;(fileTree(&quot;tools&quot;) { include(&quot;*.exe&quot;) })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如代码示例所示，每个依赖项都必须定义其在文件系统中的确切位置。创建文件引用的最主要方法是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])">Project.files（java.lang。对象...）</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html#files-java.lang.Object...-">ProjectLayout.files（java.lang。对象...）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)">Project.fileTree（java.lang。对象），</a>或者，您也可以以<a href="#sub:flat_dir_resolver">平面目录存储库</a>的形式定义一个或多个文件依赖项的源目录。</p>
</div>
<div class="paragraph">
<p>文件依赖性使您可以直接将一组文件添加到配置中，而无需先将它们添加到存储库中。如果您无法或不想将某些文件放置在存储库中，这将很有用。或者，如果您根本不想使用任何存储库来存储依赖项。</p>
</div>
<div class="paragraph">
<p>要将某些文件添加为配置的依赖项，只需将<a href="#sec:file_collections">文件集合</a>作为依赖项传递：</p>
</div>
<div class="exampleblock">
<div class="title">示例279文件依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    runtimeOnly files(<span class="string"><span class="delimiter">'</span><span class="content">libs/a.jar</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">libs/b.jar</span><span class="delimiter">'</span></span>)
    runtimeOnly fileTree(<span class="string"><span class="delimiter">'</span><span class="content">libs</span><span class="delimiter">'</span></span>) { include <span class="string"><span class="delimiter">'</span><span class="content">*.jar</span><span class="delimiter">'</span></span> }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    runtimeOnly(files(&quot;libs/a.jar&quot;, &quot;libs/b.jar&quot;))
    runtimeOnly(fileTree(&quot;libs&quot;) { include(&quot;*.jar&quot;) })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>文件依赖项不包含在项目的已发布依赖项描述符中。但是，文件依赖关系包含在同一构建中的可传递项目依赖关系中。这意味着它们不能在当前版本之外使用，但可以在同一版本内使用。</p>
</div>
<div class="paragraph">
<p>您可以声明产生文件依赖性的任务。例如，当文件是由生成生成的时，您可能会这样做。</p>
</div>
<div class="exampleblock">
<div class="title">示例280生成的文件依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation files(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/classes</span><span class="delimiter">&quot;</span></span>) {
        builtBy <span class="string"><span class="delimiter">'</span><span class="content">compile</span><span class="delimiter">'</span></span>
    }
}

task compile {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">compiling classes</span><span class="delimiter">'</span></span>
    }
}

task list(<span class="key">dependsOn</span>: configurations.compileClasspath) {
    doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">classpath = </span><span class="inline"><span class="inline-delimiter">${</span>configurations.compileClasspath.collect { <span class="predefined-type">File</span> file -&gt; file.name }<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(files(&quot;$buildDir/classes&quot;) {
        builtBy(&quot;compile&quot;)
    })
}

tasks.register(&quot;compile&quot;) {
    doLast {
        println(&quot;compiling classes&quot;)
    }
}

tasks.register(&quot;list&quot;) {
    dependsOn(configurations[&quot;compileClasspath&quot;])
    doLast {
        println(&quot;classpath = ${configurations[&quot;compileClasspath&quot;].map { file: File -&gt; file.name }}&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle -q list
compiling classes
classpath = [classes]</pre>
</div>
</div>
<div class="sect6">
<h7 id="sec:versioning_file_dependencies"><a class="anchor" href="#sec:versioning_file_dependencies"></a> <a class="link" href="#sec:versioning_file_dependencies">文件依赖关系的版本控制</a></h7>
<div class="paragraph">
<p>建议明确表达其意图和文件依赖性的具体版本。Gradle的<a href="#sec:how-gradle-downloads-deps">版本冲突解决方案</a>不考虑文件依赖性。因此，为文件名分配一个版本以指示其附带的不同更改集是非常重要的。例如<code>commons-beanutils-1.3.jar</code>使您可以通过发行说明跟踪库的更改。</p>
</div>
<div class="paragraph">
<p>因此，项目的依存关系更易于维护和组织。通过分配的版本发现潜在的API不兼容要容易得多。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:project_dependencies"><a class="anchor" href="#sub:project_dependencies"></a> <a class="link" href="#sub:project_dependencies">项目依赖</a></h6>
<div class="paragraph">
<p>软件项目通常将软件组件分解为模块，以提高可维护性并防止强耦合。模块可以定义彼此之间的依赖关系，以在同一项目中重用代码。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-project-dependencies.png" alt="依赖管理项目依赖">
</div>
<div class="title">图18。项目之间的依赖</div>
</div>
<div class="paragraph">
<p>Gradle可以对模块之间的依赖关系进行建模。这些依赖项称为<em>项目依赖项，</em>因为每个模块均由Gradle项目表示。</p>
</div>
<div class="exampleblock">
<div class="title">示例281项目依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:shared</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(project(&quot;:shared&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在运行时，该构建会自动确保以正确的顺序构建项目依赖项，并将其添加到类路径中以进行编译。“ <a href="#multi_project_builds">创作多项目构建</a> ”一章讨论了如何设置和配置多项目构建。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ProjectDependency.html">ProjectDependency</a>的API文档。</p>
</div>
<div class="paragraph">
<p>以下示例声明了对<code>utils</code>和<code>api</code>来自的项目<code>web-service</code>项目。方法<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:project(java.lang.String)">Project.project（java.lang。字符串）</a>通过路径创建对特定子项目的引用。</p>
</div>
<div class="exampleblock">
<div class="title">实施例282。声明项目依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">project(<span class="string"><span class="delimiter">'</span><span class="content">:web-service</span><span class="delimiter">'</span></span>) {
    dependencies {
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:utils</span><span class="delimiter">'</span></span>)
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:api</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">project(&quot;:web-service&quot;) {
    dependencies {
        &quot;implementation&quot;(project(&quot;:utils&quot;))
        &quot;implementation&quot;(project(&quot;:api&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="local_forks_of_module_dependencies"><a class="anchor" href="#local_forks_of_module_dependencies"></a> <a class="link" href="#local_forks_of_module_dependencies">模块依赖项的本地分支</a></h6>
<div class="paragraph">
<p>如果模块本身是使用Gradle构建的，则模块依赖性可以由对该模块源的本地fork的依赖性替代。这可以通过使用<a href="#defining_composite_builds">复合构建</a>来完成。例如，这使您可以通过使用并构建本地修补版本而不是已发布的二进制版本来修复在应用程序中使用的库中的问题。有关此内容的详细信息，请参见<a href="#defining_composite_builds">组合构建</a>部分。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:gradle_distribution_dependencies"><a class="anchor" href="#sub:gradle_distribution_dependencies"></a> <a class="link" href="#sub:gradle_distribution_dependencies">Gradle特定于发行版的依赖性</a></h6>
<div class="sect6">
<h7 id="sub:api_dependencies"><a class="anchor" href="#sub:api_dependencies"></a> <a class="link" href="#sub:api_dependencies">Gradle API依赖性</a></h7>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()">DependencyHandler.gradleApi（）</a>方法声明对当前版本的Gradle API的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()">依赖关系</a> 。在开发自定义Gradle任务或插件时，这很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例283Gradle API依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation gradleApi()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(gradleApi())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="sub:testkit_dependencies"><a class="anchor" href="#sub:testkit_dependencies"></a> <a class="link" href="#sub:testkit_dependencies">Gradle TestKit依赖性</a></h7>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleTestKit()">DependencyHandler.gradleTestKit（）</a>方法声明对当前版本的Gradle的TestKit API的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleTestKit()">依赖关系</a> 。这对于编写和执行Gradle插件和构建脚本的功能测试很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例284。Gradle TestKit依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation gradleTestKit()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(gradleTestKit())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#test_kit">TestKit章节</a>通过示例说明了TestKit的用法。</p>
</div>
</div>
<div class="sect6">
<h7 id="sub:groovy_dependencies"><a class="anchor" href="#sub:groovy_dependencies"></a> <a class="link" href="#sub:groovy_dependencies">本地Groovy依赖</a></h7>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()">DependencyHandler.localGroovy（）</a>方法声明与Gradle一起分发的Groovy的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()">依赖关系</a> 。在Groovy中开发自定义Gradle任务或插件时，这很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例285。Gradle的Groovy依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation localGroovy()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(localGroovy())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:documenting-dependencies"><a class="anchor" href="#sec:documenting-dependencies"></a> <a class="link" href="#sec:documenting-dependencies">记录依赖性</a></h5>
<div class="paragraph">
<p>声明依赖项或<a href="#sec:adding-constraints-transitive-deps">依赖项约束时</a> ，可以提供声明的自定义原因。这使构建脚本中的依赖项声明和<a href="#sec:identifying_reason_dependency_selection">依赖项见解报告</a>更易于解释。</p>
</div>
<div class="exampleblock">
<div class="title">示例286给出在依赖性声明中选择特定模块版本的原因</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}

repositories {
    jcenter()
}

dependencies {
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.ow2.asm:asm:7.1</span><span class="delimiter">'</span></span>) {
        because <span class="string"><span class="delimiter">'</span><span class="content">we require a JDK 9 compatible bytecode generator</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}

repositories {
    jcenter()
}

dependencies {
    implementation(&quot;org.ow2.asm:asm:7.1&quot;) {
        because(&quot;we require a JDK 9 compatible bytecode generator&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="example_using_the_dependency_insight_report_with_custom_reasons"><a class="anchor" href="#example_using_the_dependency_insight_report_with_custom_reasons"></a> <a class="link" href="#example_using_the_dependency_insight_report_with_custom_reasons">示例：以自定义原因使用依赖关系洞察报告</a></h6>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q dependencyInsight --dependency asm</code></strong></div>
<div class="content">
<pre>&gt; gradle -q dependencyInsight --dependency asm
org.ow2.asm:asm:7.1
   variant "compile" [
      org.gradle.status              = release (not requested)
      org.gradle.usage               = java-api
      org.gradle.libraryelements     = jar (compatible with: classes)
      org.gradle.category            = library (not requested)

      Requested attributes not found in the selected variant:
         org.gradle.dependency.bundling = external
         org.gradle.jvm.version = 11
   ]
   Selection reasons:
      - Was requested : we require a JDK 9 compatible bytecode generator

org.ow2.asm:asm:7.1
\--- compileClasspath

A web-based, searchable dependency report is available by adding the --scan option.</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:resolve_specific_artifacts_from_dependency"><a class="anchor" href="#sec:resolve_specific_artifacts_from_dependency"></a> <a class="link" href="#sec:resolve_specific_artifacts_from_dependency">通过模块依赖性解决特定工件</a></h5>
<div class="paragraph">
<p>每当Gradle尝试从Maven或Ivy存储库解析模块时，它都会查找元数据文件和默认工件文件JAR。如果这些工件文件都无法解析，则构建将失败。在某些情况下，您可能需要调整Gradle解析依赖项工件的方式。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依赖项仅提供非标准工件，没有任何元数据（例如ZIP文件）。</p>
</li>
<li>
<p>模块元数据声明了多个工件，例如，作为常春藤依赖描述符的一部分。</p>
</li>
<li>
<p>您只想下载特定的工件，而无需在元数据中声明任何传递依赖项。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle是一个多语言构建工具，不仅限于解析Java库。假设您想使用JavaScript作为客户端技术来构建Web应用程序。大多数项目将外部JavaScript库检入版本控制。外部JavaScript库与可重用Java库没有什么不同，那么为什么不从存储库中下载它呢？</p>
</div>
<div class="paragraph">
<p><a href="https://developers.google.com/speed/libraries/">Google托管库</a>是流行的开源JavaScript库的发行平台。借助纯工件符号，您可以下载JavaScript库文件，例如JQuery。的<code>@</code>字符将依赖项的坐标与工件的文件扩展名分开。</p>
</div>
<div class="exampleblock">
<div class="title">示例287为声明的依赖项解析JavaScript工件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">'</span><span class="content">https://ajax.googleapis.com/ajax/libs</span><span class="delimiter">'</span></span>
        patternLayout {
            artifact <span class="string"><span class="delimiter">'</span><span class="content">[organization]/[revision]/[module].[ext]</span><span class="delimiter">'</span></span>
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    js
}

dependencies {
    js <span class="string"><span class="delimiter">'</span><span class="content">jquery:jquery:3.2.1@js</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;https://ajax.googleapis.com/ajax/libs&quot;)
        patternLayout {
            artifact(&quot;[organization]/[revision]/[module].[ext]&quot;)
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    create(&quot;js&quot;)
}

dependencies {
    &quot;js&quot;(&quot;jquery:jquery:3.2.1@js&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>某些模块会运送同一工件的不同“风味”，或者它们会发布属于特定模块版本但目的不同的多个工件。Java库通常会发布带有已编译类文件的工件，另一个库中仅包含源代码，而第三个库中包含Javadocs。</p>
</div>
<div class="paragraph">
<p>在JavaScript中，库可能以未压缩或缩小的工件形式存在。在Gradle中，特定的工件标识符称为<em>分类器</em> ，该术语通常在Maven和Ivy依赖管理中使用。</p>
</div>
<div class="paragraph">
<p>假设我们要下载JQuery库的精简构件，而不是未压缩的文件。您可以提供分类器<code>min</code>作为依赖项声明的一部分。</p>
</div>
<div class="exampleblock">
<div class="title">示例288使用分类器解析JavaScript工件以获得已声明的依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        url <span class="string"><span class="delimiter">'</span><span class="content">https://ajax.googleapis.com/ajax/libs</span><span class="delimiter">'</span></span>
        patternLayout {
            artifact <span class="string"><span class="delimiter">'</span><span class="content">[organization]/[revision]/[module](.[classifier]).[ext]</span><span class="delimiter">'</span></span>
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    js
}

dependencies {
    js <span class="string"><span class="delimiter">'</span><span class="content">jquery:jquery:3.2.1:min@js</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        url = uri(&quot;https://ajax.googleapis.com/ajax/libs&quot;)
        patternLayout {
            artifact(&quot;[organization]/[revision]/[module](.[classifier]).[ext]&quot;)
        }
        metadataSources {
            artifact()
        }
    }
}

configurations {
    create(&quot;js&quot;)
}

dependencies {
    &quot;js&quot;(&quot;jquery:jquery:3.2.1:min@js&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:supported-metadata-formats"><a class="anchor" href="#sec:supported-metadata-formats"></a> <a class="link" href="#sec:supported-metadata-formats">支持的元数据格式</a></h5>
<div class="paragraph">
<p>外部模块依赖项需要模块元数据（因此，Gradle通常可以找出模块的传递依赖项）。为此，Gradle支持不同的元数据格式。</p>
</div>
<div class="paragraph">
<p>您还可以调整将在<a href="#sec:supported_metadata_sources">存储库定义中</a>查找哪种格式。</p>
</div>
<div class="sect5">
<h6 id="sub:supported-md-gradle"><a class="anchor" href="#sub:supported-md-gradle"></a> <a class="link" href="#sub:supported-md-gradle">Gradle模块元数据文件</a></h6>
<div class="paragraph">
<p>Gradle模块元数据经过专门设计，可支持Gradle依赖性管理模型的所有功能，因此是首选格式。您可以<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">在此处</a>找到其<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">规格</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:supported-md-pom"><a class="anchor" href="#sub:supported-md-pom"></a> <a class="link" href="#sub:supported-md-pom">POM文件</a></h6>
<div class="paragraph">
<p>Gradle本机支持<a href="https://maven.apache.org/pom.html">Maven POM文件</a> 。值得注意的是，默认情况下，Gradle将首先查找POM文件，但是如果该文件包含特殊标记，则Gradle将改为使用<a href="#sub:supported-md-gradle">Gradle模块元数据</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:supported-md-ivy"><a class="anchor" href="#sub:supported-md-ivy"></a> <a class="link" href="#sub:supported-md-ivy">常春藤文件</a></h6>
<div class="paragraph">
<p>同样，Gradle支持<a href="http://ant.apache.org/ivy/">Apache Ivy元数据文件</a> 。同样，Gradle会首先寻找<code>ivy.xml</code>文件，但如果此文件包含特殊标记，则Gradle将改为使用<a href="#sub:supported-md-gradle">Gradle模块元数据</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:understanding-diff-libraries-and-apps"><a class="anchor" href="#sec:understanding-diff-libraries-and-apps"></a> <a class="link" href="#sec:understanding-diff-libraries-and-apps">了解库和应用程序之间的区别</a></h4>
<div class="sect4">
<h5 id="sub:producers-vs-consumers"><a class="anchor" href="#sub:producers-vs-consumers"></a> <a class="link" href="#sub:producers-vs-consumers">生产者与消费者</a></h5>
<div class="paragraph">
<p>Gradle依赖管理中的一个关键概念是在消费者和生产者之间产生差异。</p>
</div>
<div class="paragraph">
<p>当你<em>建立</em>一个库，有效地都在<em>制片</em>方：你是生产这些要由别人， <em>消费者</em> <em>消费</em> <em>的文物</em> 。</p>
</div>
<div class="paragraph">
<p>传统构建系统存在许多问题，即它们无法在生产者和消费者之间发挥作用。</p>
</div>
<div class="paragraph">
<p>需要从广义上理解<em>消费者</em> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个依赖于另一个项目的项目是一个<em>消费者</em></p>
</li>
<li>
<p>依赖人工制品的<em>任务</em>是更细粒度的消费者</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在依赖管理中，我们做出的许多决定取决于我们正在构建的项目的类型，即我们是<a href="#sub:being-respectful-consumers">什么样的<em>消费者</em></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:producer-variants"><a class="anchor" href="#sub:producer-variants"></a> <a class="link" href="#sub:producer-variants">生产者变体</a></h5>
<div class="paragraph">
<p>生产者可能想为不同种类的消费者生成不同的工件：对于相同的源代码，会产生不同的<em>二进制文件</em> 。或者，一个项目可能会产生供其他项目（相同存储库）使用但不能供外部使用的工件。</p>
</div>
<div class="paragraph">
<p>Java世界中的一个典型示例是Guava库，它以不同的版本发布：一个用于Java项目，一个用于Android项目。</p>
</div>
<div class="paragraph">
<p>但是，消费者的责任是告知要使用的版本，并且依赖关系管理引擎的责任是确保<em>图的一致性</em> （例如，确保在类路径中没有使用Java和Android版本的Guava两种语言） 。这就是Gradle <a href="#">变体模型</a>发挥作用的地方。</p>
</div>
<div class="paragraph">
<p>在Gradle中， <em>生产者变体</em>通过<a href="#sec:resolvable-consumable-configs">耗材配置</a>公开。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:strong-encapsulation"><a class="anchor" href="#sub:strong-encapsulation"></a> <a class="link" href="#sub:strong-encapsulation">强大的封装</a></h5>
<div class="paragraph">
<p>为了使生产者可以编译库，它需要所有<em>实现依赖</em>于编译类路径。存在仅<em>作为</em>库<em>的实现细节</em>所需的依赖关系，并且某些库实际上是API的一部分。</p>
</div>
<div class="paragraph">
<p>但是， <em>依赖</em>于此生成的库的库仅需要“查看”库的公共API，因此也可以“查看”该API的依赖项。它是生产方的编译类路径的子集：这是对依赖性的强封装。</p>
</div>
<div class="paragraph">
<p>结果是分配给<code>implementation</code>库的配置<em>不会最终在使用者的编译类路径上</em> 。另一方面，分配给<code>api</code>库的配置<em>最终将在使用者的编译类路径上</em> 。但是，在<em>运行时</em> ，需要所有依赖项。即使在单个项目中，Gradle也会在不同类型的使用者之间产生差异：例如，Java编译任务与Java exec任务是不同的使用者。</p>
</div>
<div class="paragraph">
<p>在Java世界<a href="#">中可以找到</a>有关API和运行时依赖项分离的更多详细信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:being-respectful-consumers"><a class="anchor" href="#sub:being-respectful-consumers"></a> <a class="link" href="#sub:being-respectful-consumers">尊重消费者</a></h5>
<div class="paragraph">
<p>无论何时，作为开发人员，您决定包括依赖项时，您都必须了解<em>对消费者有影响</em> 。例如，如果将依赖项添加到项目中，则它将成为使用者的<em>传递性依赖</em>项，因此，如果使用者需要其他版本，则可能会参与冲突解决。</p>
</div>
<div class="paragraph">
<p>Gradle处理的许多问题都与解决消费者和生产者的期望之间的不匹配有关。</p>
</div>
<div class="paragraph">
<p>但是，有些项目比其他项目容易：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果您处于消费链的末端，也就是说您正在构建<em>应用程序</em> ，那么实际上<em>没有</em>项目的<em>使用者</em> （除了最终客户）：添加<a href="#sec:excluding-transitive-deps">排除项</a>只会解决您的问题。</p>
</li>
<li>
<p>但是，如果您是图书馆，则添加<a href="#sec:excluding-transitive-deps">排除项</a>可能会阻止使用者正常工作，因为他们会使用您不喜欢的代码路径</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>始终牢记，您选择解决问题的解决方案可能会“泄漏”给您的消费者。本文档旨在指导您找到正确问题的正确解决方案，更重要的是，制定有助于决策引擎在发生冲突时做出正确决策的决策。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="viewing-debugging-dependencies"><a class="anchor" href="#viewing-debugging-dependencies"></a> <a class="link" href="#viewing-debugging-dependencies">查看和调试依赖项</a></h4>
<div class="paragraph">
<p>Gradle提供了足够的工具来导航较大的依赖图并缓解可能导致<a href="https://en.wikipedia.org/wiki/Dependency_hell">依赖地狱的情况</a> 。用户可以选择呈现完整的依赖关系图，也可以确定选择原因和依赖关系的来源。依赖关系的来源可以是构建脚本中已声明的依赖关系，也可以是图形中的传递性依赖关系及其相应的配置。Gradle通过构建扫描的可视化表示和命令行工具提供了两种功能。</p>
</div>
<div class="sect4">
<h5 id="sec:debugging-build-scans"><a class="anchor" href="#sec:debugging-build-scans"></a> <a class="link" href="#sec:debugging-build-scans">构建扫描</a></h5>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果您不知道什么是<a href="https://scans.gradle.com/">构建扫描</a> ，请确保将其签出！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>构建扫描可以将依赖项可视化为可导航的可搜索树。通过单击图形中的特定依赖项，可以呈现其他上下文信息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-dependencies-report-build-scan.png" alt="依赖性管理依赖性报告构建扫描">
</div>
<div class="title">图19。构建扫描中的依赖树</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:listing_dependencies"><a class="anchor" href="#sec:listing_dependencies"></a> <a class="link" href="#sec:listing_dependencies">列出项目中的依赖项</a></h5>
<div class="paragraph">
<p>Gradle可以可视化项目中每个可用<a href="#sec:what-are-dependency-configurations">配置</a>的整个依赖树。</p>
</div>
<div class="paragraph">
<p>如果您想确定在运行时已解决了哪些依赖关系，则渲染依赖关系树特别有用。它还为您提供有关该过程中发生的任何依赖项冲突解决方案的信息，并清楚地指示所选版本。依赖性报告始终包含已声明和可传递的依赖性。</p>
</div>
<div class="paragraph">
<p>假设您要为使用<a href="https://www.eclipse.org/jgit/">JGit库</a>执行SCM操作（例如，为发布过程建模）的项目创建任务。您可以在<a href="#sec:what-are-dependency-configurations">自定义配置</a>的帮助下声明任何外部工具的依赖关系，这样它就不会污染其他上下文，例如生产源代码的编译类路径。</p>
</div>
<div class="paragraph">
<p>每个Gradle项目都提供任务<code>dependencies</code>从命令行渲染所谓的<em>依赖报告</em> 。默认情况下，相关性报告呈现所有配置的相关性。要专注于有关一种配置的信息，请提供可选参数<code>--configuration</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例289使用自定义配置声明JGit依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    jcenter()
}

configurations {
    scm
}

dependencies {
    scm <span class="string"><span class="delimiter">'</span><span class="content">org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    jcenter()
}

configurations {
    create(&quot;scm&quot;)
}

dependencies {
    &quot;scm&quot;(&quot;org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="example_rendering_the_dependency_report_for_a_custom_configuration"><a class="anchor" href="#example_rendering_the_dependency_report_for_a_custom_configuration"></a> <a class="link" href="#example_rendering_the_dependency_report_for_a_custom_configuration">示例：呈现自定义配置的依赖性报告</a></h6>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q dependencies --configuration scm</code></strong></div>
<div class="content">
<pre>&gt; gradle -q dependencies --configuration scm

------------------------------------------------------------
Root project
------------------------------------------------------------

scm
\--- org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r
     +--- com.jcraft:jsch:0.1.54
     +--- com.googlecode.javaewah:JavaEWAH:1.1.6
     +--- org.apache.httpcomponents:httpclient:4.3.6
     |    +--- org.apache.httpcomponents:httpcore:4.3.3
     |    +--- commons-logging:commons-logging:1.1.3
     |    \--- commons-codec:commons-codec:1.6
     \--- org.slf4j:slf4j-api:1.7.2

A web-based, searchable dependency report is available by adding the --scan option.</pre>
</div>
</div>
<div class="paragraph">
<p>依赖性报告提供了有关图中可用依赖性的详细信息。任何无法解决的依赖项都标有<code>FAILED</code>红色。图表中可能多次出现的具有相同坐标的依赖项被省略，并用星号表示。必须进行冲突解决的依赖项会以右箭头字符分隔请求的版本和选定的版本。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:identifying_reason_dependency_selection"><a class="anchor" href="#sec:identifying_reason_dependency_selection"></a> <a class="link" href="#sec:identifying_reason_dependency_selection">识别选择哪个依赖版本以及为什么</a></h5>
<div class="paragraph">
<p>大型软件项目不可避免地会通过直接或传递依赖关系来处理越来越多的依赖关系。<a href="#sec:listing_dependencies">依存关系报告</a>为您提供了依存关系的原始列表，但没有解释<em>为什么</em>选择了依存关系，或者<em>由哪个</em>依存关系将其拉入图形。</p>
</div>
<div class="paragraph">
<p>让我们看一个具体的例子。一个项目可以请求相同依赖项的两个不同版本，无论是直接依赖项还是传递依赖项。Gradle应用<a href="#sec:version-conflict">版本冲突解决方案</a>来确保依赖关系图中仅存在一个版本的依赖关系。在此示例中，冲突的依赖关系表示为<code>commons-codec:commons-codec</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例290声明JGit依赖项和冲突的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    jcenter()
}

configurations {
    scm
}

dependencies {
    scm <span class="string"><span class="delimiter">'</span><span class="content">org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r</span><span class="delimiter">'</span></span>
    scm <span class="string"><span class="delimiter">'</span><span class="content">commons-codec:commons-codec:1.7</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    jcenter()
}

configurations {
    create(&quot;scm&quot;)
}

dependencies {
    &quot;scm&quot;(&quot;org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r&quot;)
    &quot;scm&quot;(&quot;commons-codec:commons-codec:1.7&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果单击依赖项并选择“ Required By”选项卡，则<a href="https://scans.gradle.com/">构建扫描中</a>的依赖项树将显示选择原因（冲突解决）以及依赖项的来源。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-dependency-insight-report-build-scan.png" alt="依赖项管理依赖项见解报告构建扫描">
</div>
<div class="title">图20。构建扫描中的依赖关系洞察功能</div>
</div>
<div class="paragraph">
<p>每个Gradle项目都提供任务<code>dependencyInsight</code>从命令行呈现所谓的<em>依赖关系洞察报告</em> 。给定依赖关系图中的依赖关系，您可以识别选择原因并跟踪依赖关系选择的来源。您可以将依赖关系洞察报告视为给定依赖关系的依赖关系报告的逆表示。执行任务时，您必须提供必需的参数<code>--dependency</code>指定受检查依赖项的坐标。参数<code>--configuration</code>和<code>--singlepath</code>是可选的，但有助于过滤输出。</p>
</div>
<div class="sect5">
<h6 id="example_using_the_dependency_insight_report_for_a_given_dependency"><a class="anchor" href="#example_using_the_dependency_insight_report_for_a_given_dependency"></a> <a class="link" href="#example_using_the_dependency_insight_report_for_a_given_dependency">示例：对给定依赖项使用依赖关系洞察报告</a></h6>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q dependencyInsight --dependency commons-codec --configuration scm</code></strong></div>
<div class="content">
<pre>&gt; gradle -q dependencyInsight --dependency commons-codec --configuration scm
commons-codec:commons-codec:1.7
   variant "default" [
      org.gradle.status = release (not requested)
   ]
   Selection reasons:
      - By conflict resolution : between versions 1.7 and 1.6

commons-codec:commons-codec:1.7
\--- scm

commons-codec:commons-codec:1.6 -&gt; 1.7
\--- org.apache.httpcomponents:httpclient:4.3.6
     \--- org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r
          \--- scm

A web-based, searchable dependency report is available by adding the --scan option.</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:resolving-version-conflict"><a class="anchor" href="#sec:resolving-version-conflict"></a> <a class="link" href="#sec:resolving-version-conflict">解决版本冲突</a></h5>
<div class="paragraph">
<p>如果所选版本与您的期望不符，则Gradle提供了一系列工具来帮助您<a href="#">控制传递依赖</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:resolving-variant-aware-errors"><a class="anchor" href="#sec:resolving-variant-aware-errors"></a> <a class="link" href="#sec:resolving-variant-aware-errors">解决变量选择错误</a></h5>
<div class="paragraph">
<p>有时会在<a href="#">变体选择级别上</a>发生选择错误。请查看<a href="#sec:variant-select-errors">专用部分</a>以了解这些错误以及如何解决它们。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:resolving-unsafe-configuration-resolution-errors"><a class="anchor" href="#sub:resolving-unsafe-configuration-resolution-errors"></a> <a class="link" href="#sub:resolving-unsafe-configuration-resolution-errors">解决不安全的配置解析错误</a></h5>
<div class="paragraph">
<p>跨项目边界时，必须安全地解决配置问题，因为解决配置问题会对Gradle的项目模型产生副作用。Gradle可以管理此安全访问，但是需要以使Gradle能够进行访问的方式来访问配置。有多种方法可以不安全地解决配置，并且Gradle会针对每个不安全的访问产生弃用警告。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个项目中的任务直接解决另一个项目中的配置。</p>
</li>
<li>
<p>任务将另一个项目中的配置指定为输入文件集合。</p>
</li>
<li>
<p>一个项目的构建脚本在评估期间解析另一个项目中的配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您的构建具有不安全的访问弃用警告，则需要对其进行修复。这是这些不良做法的征兆，可能会导致奇怪且不确定的错误。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，可以通过在另一个项目上创建跨项目的依赖关系来解决此问题。有关更多信息，请参见用于<a href="#cross_project_publications">在项目之间共享输出</a>的文档。如果您发现无法使用这些技术解决的用例，请通过提交遵循我们的发行准则的<a href="https://github.com/gradle/gradle/issues">GitHub Issue</a>来通知我们。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="understanding_dependency_resolution"><a class="anchor" href="#understanding_dependency_resolution"></a> <a class="link" href="#understanding_dependency_resolution">了解依赖性解析</a></h4>
<div class="paragraph">
<p>本章介绍了Gradle <em>内部</em>依赖项解析的工作方式。在介绍了如何声明<a href="#">存储库</a>和<a href="#">依赖项之后</a> ，有必要解释在依赖项解析期间这些声明如何组合在一起。</p>
</div>
<div class="paragraph">
<p>依赖关系解析是一个由两个阶段组成的过程，这些阶段重复进行直到依赖图完成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将新的依赖项添加到图中后，请执行冲突解决方案以确定应将哪个版本添加到图中。</p>
</li>
<li>
<p>当特定的依赖关系（即具有版本的模块）被标识为图的一部分时，请检索其元数据，以便可以依次添加其依赖关系。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下部分将描述Gradle识别为冲突的内容以及如何自动解决冲突。之后，将介绍元数据的检索，解释Gradle如何<a href="#sec:how-gradle-downloads-deps">遵循依赖关系链接</a> 。</p>
</div>
<div class="sect4">
<h5 id="sec:conflict-resolution"><a class="anchor" href="#sec:conflict-resolution"></a> <a class="link" href="#sec:conflict-resolution">Gradle如何处理冲突？</a></h5>
<div class="paragraph">
<p>执行依赖关系解析时，Gradle处理两种类型的冲突：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">版本冲突</dt>
<dd>
<p>那是当两个或多个依赖项需要给定的依赖项但版本不同时。</p>
</dd>
<dt class="hdlist1">实施冲突</dt>
<dd>
<p>那就是当依赖图包含在Gradle术语中提供相同实现或功能的模块时。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下各节将详细说明Gradle如何尝试解决这些冲突。</p>
</div>
<div class="paragraph">
<p>依赖性解析过程可以高度自定义以满足企业需求。有关更多信息，请参见<a href="#">控制传递依赖关系</a>一章。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:version-conflict"><a class="anchor" href="#sec:version-conflict"></a> <a class="link" href="#sec:version-conflict">解决版本冲突</a></h5>
<div class="paragraph">
<p>当两个组件发生版本冲突：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>假设同一个模块<code>com.google.guava:guava</code></p>
</li>
<li>
<p>但是在不同的版本上<code>20.0</code>和<code>25.1-android</code></p>
<div class="ulist">
<ul>
<li>
<p>我们的项目本身取决于<code>com.google.guava:guava:20.0</code></p>
</li>
<li>
<p>我们的项目还取决于<code>com.google.inject:guice:4.2.2</code>这本身取决于<code>com.google.guava:guava:25.1-android</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="sub:resolution-strategy"><a class="anchor" href="#sub:resolution-strategy"></a> <a class="link" href="#sub:resolution-strategy">解决策略</a></h6>
<div class="paragraph">
<p>鉴于上述冲突，可以通过选择版本或通过失败的解决方案来解决它。处理依赖性管理的不同工具具有处理此类冲突的不同方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://maven.apache.org/">Apache Maven</a>使用最接近的优先策略。</p>
</div>
<div class="paragraph">
<p>Maven将采用<em>最短</em>路径获取依赖项并使用该版本。如果有多个相同长度的路径，则第一个获胜。</p>
</div>
<div class="paragraph">
<p>这意味着在上面的示例中， <code>guava</code>将会<code>20.0</code>因为直接依赖比<em>更接近</em> <code>guice</code>依赖性。</p>
</div>
<div class="paragraph">
<p>该方法的主要缺点是依赖于顺序。在很大的图中保持顺序可能是一个挑战。例如，如果新版本的依赖项最终以不同于先前版本的顺序拥有其自己的依赖项声明，该怎么办？</p>
</div>
<div class="paragraph">
<p>使用Maven，这可能会对已解决的版本产生不良影响。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://ant.apache.org/ivy/">Apache Ivy</a>是一种非常灵活的依赖项管理工具。它提供了自定义依赖关系解决方案（包括冲突解决方案）的可能性。</p>
</div>
<div class="paragraph">
<p>这种灵活性伴随着难以推理的代价。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle将考虑<em>所有</em>请求的版本，无论它们出现在依赖关系图中的何处。在这些版本中，它将选择<em>最高的</em>版本。</p>
</div>
<div class="paragraph">
<p>如您所见，Gradle支持<a href="#">丰富版本声明</a>的概念，因此最高版本取决于版本声明的方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果不涉及范围，则将选择不被拒绝的最高版本。</p>
<div class="ulist">
<ul>
<li>
<p>如果严格低于该版本，则选择将失败。</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果涉及范围：</p>
<div class="ulist">
<ul>
<li>
<p>如果某个非范围版本落入指定范围内或高于其上限，则将选择该版本。</p>
</li>
<li>
<p>如果只有范围，则将选择具有最高上限的范围的<em>现有</em>最高版本。</p>
</li>
<li>
<p>如果严格低于该版本，则选择将失败。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，在范围起作用的情况下，Gradle需要元数据来确定对于所考虑范围确实存在哪些版本。这将导致对元数据的中间查找，如<a href="#sec:how-gradle-downloads-deps">Gradle如何检索依赖元数据？</a> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:implementation-conflict"><a class="anchor" href="#sec:implementation-conflict"></a> <a class="link" href="#sec:implementation-conflict">解决实施冲突</a></h5>
<div class="paragraph">
<p>Gradle使用变体和功能来识别模块<em>提供的功能</em> 。</p>
</div>
<div class="paragraph">
<p>这是一个独特的功能，值得<a href="#">一章</a>以了解其含义和功能。</p>
</div>
<div class="paragraph">
<p>两个模块之一发生冲突时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>尝试选择不兼容的变体，</p>
</li>
<li>
<p>声明相同的功能</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在<a href="#sub:selecting-between-candidates">选择候选人之间</a>了解有关处理此类冲突的更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:how-gradle-downloads-deps"><a class="anchor" href="#sec:how-gradle-downloads-deps"></a> <a class="link" href="#sec:how-gradle-downloads-deps">Gradle如何检索依赖元数据？</a></h5>
<div class="paragraph">
<p>Gradle需要有关依赖关系图中包含的模块的元数据。该信息是两点所必需的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当声明的版本是动态的时，确定模块的现有版本。</p>
</li>
<li>
<p>确定给定版本的模块依赖性。</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="discovering_versions"><a class="anchor" href="#discovering_versions"></a> <a class="link" href="#discovering_versions">发现版本</a></h6>
<div class="paragraph">
<p>面对动态版本，Gradle需要确定具体的匹配版本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>检查每个存储库，Gradle不会在第一个返回某些元数据的站点上停止。定义多个时<em>，将按照添加顺序</em>对其进行检查。</p>
</li>
<li>
<p>对于Maven存储库，Gradle将使用<code>maven-metadata.xml</code>提供有关可用版本的信息。</p>
</li>
<li>
<p>对于常春藤存储库，Gradle将诉诸目录列表。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此过程将生成候选版本列表，这些候选版本然后与表示的动态版本匹配。此时，将恢复<a href="#sub:resolution-strategy">版本冲突解决</a> 。</p>
</div>
<div class="paragraph">
<p>请注意，Gradle会缓存版本信息，有关更多信息，请参见<a href="#sec:controlling-dynamic-version-caching">控制动态版本缓存</a>一节。</p>
</div>
</div>
<div class="sect5">
<h6 id="obtaining_module_metadata"><a class="anchor" href="#obtaining_module_metadata"></a> <a class="link" href="#obtaining_module_metadata">获取模块元数据</a></h6>
<div class="paragraph">
<p>给定所需的依赖关系（带有版本），Gradle尝试通过搜索依赖关系指向的模块来解决依赖关系。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依次检查每个存储库。</p>
<div class="ulist">
<ul>
<li>
<p>根据存储库的类型，Gradle会查找描述模块的元数据文件（ <code>.module</code> ， <code>.pom</code>要么<code>ivy.xml</code>文件）或直接用于工件文件。</p>
</li>
<li>
<p>具有模块元数据文件的模块（ <code>.module</code> ， <code>.pom</code>要么<code>ivy.xml</code>文件）优于仅具有工件文件的模块。</p>
</li>
<li>
<p>一旦存储库返回<em>元数据</em>结果，以下存储库将被忽略。</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果找到依赖项的元数据，则将对其进行检索和解析</p>
<div class="ulist">
<ul>
<li>
<p>如果模块元数据是声明了父POM的POM文件，则Gradle将递归地尝试为POM解析每个父模块。</p>
</li>
</ul>
</div>
</li>
<li>
<p>然后，从上述过程中选择的<em>同一存储库</em>中请求模块的所有工件。</p>
</li>
<li>
<p>然后，所有这些数据（包括存储库源和潜在的丢失）都存储在<a href="#sec:dependency_cache">Dependency Cache中</a> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>上面的最后一点是使与<a href="#sec:case-for-maven-local">Maven Local</a>集成的问题。由于它是Maven的缓存，因此有时会错过给定模块的某些工件。如果Gradle从Maven Local采购了这样的模块，它将认为丢失的工件完全丢失。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="repository_blacklisting"><a class="anchor" href="#repository_blacklisting"></a> <a class="link" href="#repository_blacklisting">仓库黑名单</a></h6>
<div class="paragraph">
<p>当Gradle无法从存储库检索信息时，它将在构建期间将其列入黑名单，并且所有依赖项解析都将失败。</p>
</div>
<div class="paragraph">
<p>最后一点对于可重复性很重要。如果允许继续构建而忽略有问题的存储库，则一旦存储库重新联机，后续的构建可能会有不同的结果。</p>
</div>
<div class="sect6">
<h7 id="sub:http-retries"><a class="anchor" href="#sub:http-retries"></a> <a class="link" href="#sub:http-retries">HTTP重试</a></h7>
<div class="paragraph">
<p>在将其列入黑名单之前，Gradle将尝试几次连接到给定的存储库。如果连接失败，Gradle将重试某些可能会被瞬态发生的错误，从而增加每次重试之间的等待时间。</p>
</div>
<div class="paragraph">
<p>当由于永久错误或达到最大重试次数而无法联系存储库时，就会将其列入黑名单。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:dependency_cache"><a class="anchor" href="#sec:dependency_cache"></a> <a class="link" href="#sec:dependency_cache">依赖缓存</a></h5>
<div class="paragraph">
<p>Gradle包含一个高度复杂的依赖项缓存机制，该机制旨在最大程度地减少在依赖项解析中发出的远程请求的数量，同时努力确保依赖项解析的结果正确且可重现。</p>
</div>
<div class="paragraph">
<p>Gradle依赖项缓存由位于以下位置的两种存储类型组成<code>GRADLE_USER_HOME/caches</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基于文件的下载工件的存储，包括二进制文件（如jars）以及原始下载的元数据（如POM文件和Ivy文件）。下载的工件的存储路径包括SHA1校验和，这意味着可以轻松地缓存2个名称相同但内容不同的工件。</p>
</li>
<li>
<p>解析的模块元数据的二进制存储，包括解析动态版本，模块描述符和工件的结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle缓存不允许本地缓存隐藏问题并创建其他神秘且难以调试的行为。Gradle专注于带宽和存储效率，可实现可靠且可复制的企业构建。</p>
</div>
<div class="sect5">
<h6 id="sub:cache_metadata"><a class="anchor" href="#sub:cache_metadata"></a> <a class="link" href="#sub:cache_metadata">独立的元数据缓存</a></h6>
<div class="paragraph">
<p>Gradle在元数据缓存中以二进制格式记录了依赖性解析的各个方面。存储在元数据缓存中的信息包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>解析动态版本的结果（例如， <code>1.+</code> ）到具体版本（例如<code>1.2</code> ）。</p>
</li>
<li>
<p>特定模块的已解析模块元数据，包括模块工件和模块依赖性。</p>
</li>
<li>
<p>特定工件的已解析工件元数据，包括指向下载的工件文件的指针。</p>
</li>
<li>
<p>由于<em>没有</em>在一个特定的存储库中的特定模块或工件，省去重复尝试访问不存在的资源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>元数据缓存中的每个条目都包括提供信息的存储库记录以及可用于缓存过期的时间戳。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:cache_repository_independence"><a class="anchor" href="#sub:cache_repository_independence"></a> <a class="link" href="#sub:cache_repository_independence">存储库缓存是独立的</a></h6>
<div class="paragraph">
<p>如上所述，对于每个存储库，都有一个单独的元数据缓存。存储库由其URL，类型和布局标识。如果以前没有从此<em>存储库</em>解析模块或工件，则Gradle将尝试根据存储库解析模块。这将始终涉及对存储库的远程查找，但是在许多情况下， <a href="#sub:cache_artifact_reuse">不需要下载</a> 。</p>
</div>
<div class="paragraph">
<p>如果所需的构件在构建指定的任何存储库中都不可用，则依赖关系解析将失败，即使本地缓存具有从其他存储库检索到的该构件的副本，也是如此。存储库独立性允许构建以以前没有构建工具完成的高级方式彼此隔离。这是创建可在任何环境下可靠且可复制的内部版本的关键功能。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:cache_artifact_reuse"><a class="anchor" href="#sub:cache_artifact_reuse"></a> <a class="link" href="#sub:cache_artifact_reuse">工件重用</a></h6>
<div class="paragraph">
<p>在下载工件之前，Gradle会尝试通过下载与该工件关联的sha文件来确定所需工件的校验和。如果可以检索校验和，那么如果已经存在具有相同ID和校验和的工件，则不会下载工件。如果无法从远程服务器检索校验和，则将下载工件（如果它与现有工件匹配，则将被忽略）。</p>
</div>
<div class="paragraph">
<p>除了考虑从其他存储库下载的工件外，Gradle还将尝试重用在本地Maven存储库中找到的工件。如果Maven已下载了候选工件，则Gradle将使用此工件，前提是可以对其进行验证以匹配远程服务器声明的校验和。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:cache_checksum_storage"><a class="anchor" href="#sub:cache_checksum_storage"></a> <a class="link" href="#sub:cache_checksum_storage">基于校验和的存储</a></h6>
<div class="paragraph">
<p>响应相同的工件标识符，不同的存储库可能会提供不同的二进制工件。Maven SNAPSHOT工件通常是这种情况，但对于在不更改其标识符的情况下重新发布的任何工件也是如此。通过根据工件的SHA1校验和缓存工件，Gradle能够维护同一工件的多个版本。这意味着在针对一个存储库进行解析时，Gradle绝不会覆盖来自其他存储库的缓存工件文件。无需在每个存储库中单独存放工件文件即可完成此操作。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:cache_locking"><a class="anchor" href="#sub:cache_locking"></a> <a class="link" href="#sub:cache_locking">缓存锁定</a></h6>
<div class="paragraph">
<p>Gradle依赖项缓存使用基于文件的锁定来确保多个Gradle进程可以安全地同时使用它。每当读取或写入二进制元数据存储时，都会保留该锁，但是会为缓慢的操作（例如下载远程工件）而释放该锁。</p>
</div>
<div class="paragraph">
<p>仅当不同的Gradle进程可以一起通信时，才支持此并发访问。对于容器化版本，通常<em>不是这种情况</em> 。</p>
</div>
<div class="sect6">
<h7 id="sub:cache_cleanup"><a class="anchor" href="#sub:cache_cleanup"></a> <a class="link" href="#sub:cache_cleanup">缓存清理</a></h7>
<div class="paragraph">
<p>Gradle跟踪访问依赖项缓存中的哪些工件。使用此信息，定期（最多每24小时）扫描缓存，以查找未使用超过30天的工件。然后删除过时的工件，以确保高速缓存不会无限期增长。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:programmatic_api"><a class="anchor" href="#sec:programmatic_api"></a> <a class="link" href="#sec:programmatic_api">以编程方式访问分辨率结果</a></h5>
<div class="paragraph">
<p>尽管大多数用户只需要访问文件的“固定列表”，但是在某些情况下，在<em>图</em>上进行推理并获得有关分辨率结果的更多信息可能会很有趣：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用于工具集成，其中需要依赖图的模型</p>
</li>
<li>
<p>用于生成视觉表示（图像， <code>.dot</code>文件，……）</p>
</li>
<li>
<p>用于提供诊断的任务（类似于<code>dependencyInsight</code>任务）</p>
</li>
<li>
<p>适用于需要在执行时执行依赖关系解析的任务（例如，按需下载文件）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于这些用例，Gradle提供了惰性的，线程安全的API，可通过调用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/Configuration.html#getIncoming--">Configuration.getIncoming（）</a>方法进行访问：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult--">ResolutionResult API</a>允许访问已解析的依赖关系图，无论解析是否成功。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getArtifacts--">工件API</a>提供了对未转换但未转换的工件的简单访问，但是具有工件的延迟下载（它们只能按需下载）。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#artifactView-org.gradle.api.Action-">工件视图API</a>提供了可能经过<a href="#sec:abm_artifact_transforms">转换</a>的工件的高级筛选视图。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="declaring_versions"><a class="anchor" href="#declaring_versions"></a> <a class="link" href="#declaring_versions">声明版本</a></h3>
<div class="sect3">
<h4 id="single-version-declarations"><a class="anchor" href="#single-version-declarations"></a> <a class="link" href="#single-version-declarations">声明版本和范围</a></h4>
<div class="paragraph">
<p>最简单的版本声明是表示要使用的版本的<em>简单字符串</em> 。Gradle支持不同的方式来声明版本字符串：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确切的版本：例如<code>1.3</code> ， <code>1.3.0-beta3</code> ，<code>1.0-20150201.131010-1</code></p>
</li>
<li>
<p>Maven样式的版本范围：例如<code>[1.0,)</code> ， <code>[1.1, 2.0)</code> ，<code>(1.2, 1.5]</code></p>
<div class="ulist">
<ul>
<li>
<p>的<code>[</code>和<code>]</code>符号表示包含范围； <code>(</code>和<code>)</code>表示排他界限。</p>
</li>
<li>
<p>如果缺少上限或下限，则范围没有上限或下限。</p>
</li>
<li>
<p>符号<code>]</code>可以代替<code>(</code>排他的下限<code>[</code>代替<code>)</code>独家上限。例如<code>]1.0, 2.0[</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><em>前缀</em>版本范围：例如<code>1.+</code> ，<code>1.3.+</code></p>
<div class="ulist">
<ul>
<li>
<p>仅版本完全匹配<code>+</code>被包含在内。</p>
</li>
<li>
<p>范围<code>+</code>它本身将包含任何版本。</p>
</li>
</ul>
</div>
</li>
<li>
<p>一种<code>latest-status</code>版本：例如<code>latest.integration</code> ，<code>latest.release</code></p>
<div class="ulist">
<ul>
<li>
<p>将使版本最高的模块与指定状态匹配。请参阅<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ComponentMetadata.html#getStatus--">ComponentMetadata.getStatus（）</a> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>一个行家<code>SNAPSHOT</code>版本标识符：例如<code>1.0-SNAPSHOT</code> ，<code>1.4.9-beta1-SNAPSHOT</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="version_ordering"><a class="anchor" href="#version_ordering"></a> <a class="link" href="#version_ordering">版本订购</a></h5>
<div class="paragraph">
<p>版本具有隐式排序。版本排序用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确定特定版本是否包含在范围内。</p>
</li>
<li>
<p>解决冲突时，确定哪个版本是“最新的”。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>版本根据以下规则排序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个版本均分为其组成的“部分”：</p>
<div class="ulist">
<ul>
<li>
<p>那些角色<code>[. - _ +]</code>用于分隔版本的不同“部分”。</p>
</li>
<li>
<p>同时包含数字和字母的任何部分都将分为以下各个部分：<code>1a1 == 1.a.1</code></p>
</li>
<li>
<p>仅比较版本的各个部分。实际的分隔符并不重要：<code>1.a.1 == 1-a+1 == 1.a-1 == 1a1</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>使用以下规则比较2个版本的等效部分：</p>
<div class="ulist">
<ul>
<li>
<p>如果两个部分都是数字，则最高数值<strong>较高</strong> ： <code>1.1</code> <<code>1.2</code></p>
</li>
<li>
<p>如果一个部分是数字，它被认为比非数字部分<strong>高</strong> ： <code>1.a</code> <<code>1.1</code></p>
</li>
<li>
<p>如果两者都不是数字，则按<strong>字母顺序</strong>比较各部分<strong>，区分大小写</strong> ： <code>1.A</code> < <code>1.B</code> < <code>1.a</code> <<code>1.b</code></p>
</li>
<li>
<p>具有额外数字部分的版本被认为<strong>高于</strong>没有以下内容的版本： <code>1.1</code> <<code>1.1.0</code></p>
</li>
<li>
<p>具有额外的非数字部分的版本被认为<strong>低于</strong>没有以下内容的版本： <code>1.1.a</code> <<code>1.1</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>某些字符串值出于排序目的具有特殊含义：</p>
<div class="ulist">
<ul>
<li>
<p>字符串<code>dev</code>被认为<strong>低于</strong>任何其他字符串部分： <code>1.0-dev</code> < <code>1.0-alpha</code> < <code>1.0-rc</code> 。</p>
</li>
<li>
<p>琴弦<code>rc</code> ， <code>release</code>和<code>final</code>被认为<strong>高于</strong>其他任何字符串部分（按此顺序排序）： <code>1.0-zeta</code> < <code>1.0-rc</code> < <code>1.0-release</code> < <code>1.0-final</code> < <code>1.0</code> 。</p>
</li>
<li>
<p>字符串<code>SNAPSHOT</code> <strong>没有特殊含义</strong> ，并且像其他字符串部分一样按字母顺序排序： <code>1.0-alpha</code> < <code>1.0-SNAPSHOT</code> < <code>1.0-zeta</code> < <code>1.0-rc</code> < <code>1.0</code> 。</p>
</li>
<li>
<p>数字快照版本<strong>没有特殊含义</strong> ，其排序方式与其他任何数字部分一样： <code>1.0</code> < <code>1.0-20150201.121010-123</code> < <code>1.1</code> 。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="simple_version_declaration_semantics"><a class="anchor" href="#simple_version_declaration_semantics"></a> <a class="link" href="#simple_version_declaration_semantics">简单的版本声明语义</a></h5>
<div class="paragraph">
<p>使用缩写符号声明版本时，例如：</p>
</div>
<div class="exampleblock">
<div class="title">示例291一个简单的声明</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.slf4j:slf4j-api:1.7.15</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.slf4j:slf4j-api:1.7.15&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随后的版本被认为是<a href="#sec:required-version">需要的版本</a> ，这意味着它应该是<em>最低限度</em> <code>1.7.15</code>但可以通过引擎进行升级（乐观升级）。</p>
</div>
<div class="paragraph">
<p>但是，对于<a href="#sec:strict-version">严格版本</a> ，有一种简写<a href="#sec:strict-version">形式</a> <code>!!</code>符号：</p>
</div>
<div class="exampleblock">
<div class="title">示例292严格依赖的简写</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// short-hand notation with !!</span>
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.slf4j:slf4j-api:1.7.15!!</span><span class="delimiter">'</span></span>)
    <span class="comment">// is equivalent to</span>
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.slf4j:slf4j-api</span><span class="delimiter">&quot;</span></span>) {
        version {
           strictly <span class="string"><span class="delimiter">'</span><span class="content">1.7.15</span><span class="delimiter">'</span></span>
        }
    }

    <span class="comment">// or...</span>
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.slf4j:slf4j-api:[1.7, 1.8[!!1.7.25</span><span class="delimiter">'</span></span>)
    <span class="comment">// is equivalent to</span>
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.slf4j:slf4j-api</span><span class="delimiter">'</span></span>) {
        version {
           strictly <span class="string"><span class="delimiter">'</span><span class="content">[1.7, 1.8[</span><span class="delimiter">'</span></span>
           prefer <span class="string"><span class="delimiter">'</span><span class="content">1.7.25</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // short-hand notation with !!
    implementation(&quot;org.slf4j:slf4j-api:1.7.15!!&quot;)
    // is equivalent to
    implementation(&quot;org.slf4j:slf4j-api&quot;) {
        version {
           strictly(&quot;1.7.15&quot;)
        }
    }

    // or...
    implementation(&quot;org.slf4j:slf4j-api:[1.7, 1.8[!!1.7.25&quot;)
    // is equivalent to
    implementation(&quot;org.slf4j:slf4j-api&quot;) {
        version {
           strictly([1.7, 1.8[&quot;)
           prefer(&quot;1.7.25&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>严格版本<em>无法升级，</em>并且会覆盖此依赖关系提供的所有传递依赖关系。建议对严格版本使用范围。</p>
</div>
<div class="paragraph">
<p>记法<code>[1.7, 1.8[!!1.7.25</code>以上等同于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>严格地<code>[1.7, 1.8[</code></p>
</li>
<li>
<p>偏爱<code>1.7.25</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着引擎<strong>必须</strong>在1.7（包括）和1.8（排除）之间选择一个版本，并且如果图中没有其他组件需要其他版本，则它应该<em>优先使用</em> <code>1.7.25</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:declaring_without_version"><a class="anchor" href="#sec:declaring_without_version"></a> <a class="link" href="#sec:declaring_without_version">声明不带版本的依赖</a></h5>
<div class="paragraph">
<p>对于较大的项目，建议的做法是声明没有版本的依赖项，并将<a href="#sec:adding-constraints-transitive-deps">依赖项约束</a>用于版本声明。优点是，依赖关系约束使您可以在一处管理所有依赖关系的版本，包括可传递的依赖关系。</p>
</div>
<div class="exampleblock">
<div class="title">示例293声明不带版本的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-web</span><span class="delimiter">'</span></span>
}

dependencies {
    constraints {
        implementation <span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-web:5.0.2.RELEASE</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.springframework:spring-web&quot;)
}

dependencies {
    constraints {
        implementation(&quot;org.springframework:spring-web:5.0.2.RELEASE&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rich-version-constraints"><a class="anchor" href="#rich-version-constraints"></a> <a class="link" href="#rich-version-constraints">声明丰富版本</a></h4>
<div class="paragraph">
<p>Gradle支持用于声明版本的丰富模型，该模型允许组合不同级别的版本信息。术语及其含义如下（从最强到最弱）：</p>
</div>
<div id="sec:strict-version" class="dlist">
<dl>
<dt class="hdlist1"><code>strictly</code></dt>
<dd>
<p>与该版本符号不匹配的任何版本将被排除。这是最强的版本声明。在声明的依赖项上， <code>strictly</code>可以降级版本。在传递依赖项上，如果无法选择此子句可接受的版本，则将导致依赖项解析失败。有关详细信息，请参见<a href="#sec:enforcing_dependency_version">覆盖依赖项版本</a> 。该术语支持动态版本。</p>
<div class="paragraph">
<p>定义时，覆盖上一个<code>require</code>声明并清除先前的<code>reject</code> 。</p>
</div>
</dd>
</dl>
</div>
<div id="sec:required-version" class="dlist">
<dl>
<dt class="hdlist1"><code>require</code></dt>
<dd>
<p>表示所选版本不能低于<code>require</code>接受，但通过冲突解决可以更高，即使更高具有排他性上限。这就是依赖项上的直接版本所转换的内容。该术语支持动态版本。</p>
<div class="paragraph">
<p>定义时，覆盖上一个<code>strictly</code>声明并清除先前的<code>reject</code> 。</p>
</div>
</dd>
</dl>
</div>
<div id="sec:preferred-version" class="dlist">
<dl>
<dt class="hdlist1"><code>prefer</code></dt>
<dd>
<p>这是一个非常软的版本声明。仅当对该模块的版本没有更强的非动态观点时，才适用。该术语不支持动态版本。</p>
<div class="paragraph">
<p>定义可以补充<code>strictly</code>要么<code>require</code> 。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在级别层次结构之外还有一个附加术语：</p>
</div>
<div id="sec:rejected-version" class="dlist">
<dl>
<dt class="hdlist1"><code>reject</code></dt>
<dd>
<p>声明模块不接受特定版本。如果唯一的可选版本也被拒绝，这将导致依赖项解析失败。该术语支持动态版本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>下表说明了许多用例以及如何组合不同的术语以进行丰富版本声明：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表10。丰富版本的用例</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">可以使用哪个版本的依存关系？</th>
<th class="tableblock halign-left valign-top"><code>strictly</code></th>
<th class="tableblock halign-left valign-top"><code>require</code></th>
<th class="tableblock halign-left valign-top"><code>prefer</code></th>
<th class="tableblock halign-left valign-top"><code>rejects</code></th>
<th class="tableblock halign-left valign-top">选择结果</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">经过版本测试<code>1.5</code> ，请相信所有将来的版本都可以使用。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从以下版本开始<code>1.5</code> ，相当于<code>org:foo:1.5</code> 。升级到<code>2.4</code>被接受。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">经过测试<code>1.5</code> ，软约束会根据语义版本进行升级。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.0，2.0 [</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之间的任何版本<code>1.0</code>和<code>2.0</code> ， <code>1.5</code>如果没有人在乎。升级到<code>2.4</code>被接受。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">经过测试<code>1.5</code> ，但遵循语义版本控制。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.0，2.0 [</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之间的任何版本<code>1.0</code>和<code>2.0</code>排除在外， <code>1.5</code>如果没有人在乎。<br>从传递依赖项覆盖版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">与上述相同， <code>1.4</code>已知坏了。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.0，2.0 [</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之间的任何版本<code>1.0</code>和<code>2.0</code>排除在外<code>1.4</code> ， <code>1.5</code>如果没有人在乎。<br>从传递依赖项覆盖版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没意见，与<code>1.5</code> 。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code>如果没有其他意见，则其他任何意见。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没意见，喜欢最新版本。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>latest.release</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生成时的最新版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在边缘，最新版本，没有降级。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>latest.release</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生成时的最新版本。<br>🔒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有其他版本，只有1.5。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5，否则失败<code>strict</code>或更高<code>require</code>约束不同意。<br>从传递依赖项覆盖版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code>或专门的补丁版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1.5,1.6 [</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最新<code>1.5.x</code>补丁发布，否则失败<code>strict</code>或更高<code>require</code>约束不同意。<br>从传递依赖项覆盖版本。<br>🔒</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>带锁（🔒）的行表示在这种情况下，利用<a href="#">依赖项锁</a>是有意义的。与丰富版本声明相关的另一个概念是能够发布已<a href="#publishing_maven:resolved_dependencies">解析版本</a>而不是已声明版本。</p>
</div>
<div class="paragraph">
<p>使用<code>strictly</code> ，尤其对于图书馆而言，必须是一个经过深思熟虑的过程，因为它会对下游消费者产生影响。同时，如果使用得当，它将有助于消费者了解哪些库组合在其上下文中无法协同工作。有关更多信息，请参见<a href="#sec:enforcing_dependency_version">覆盖依赖项版本</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>丰富的版本信息将以Gradle Module元数据格式保存。但是，转换为Ivy或Maven元数据格式将是有损的。最高级别将被发布，即<code>strictly</code>要么<code>require</code>过度<code>prefer</code> 。此外，任何<code>reject</code>将被忽略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>富版本声明可通过<code>version</code>依赖项或约束声明的DSL方法，可以访问<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/MutableVersionConstraint.html">MutableVersionConstraint</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">实施例294。丰富的版本声明</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.slf4j:slf4j-api</span><span class="delimiter">'</span></span>) {
        version {
            strictly <span class="string"><span class="delimiter">'</span><span class="content">[1.7, 1.8[</span><span class="delimiter">'</span></span>
            prefer <span class="string"><span class="delimiter">'</span><span class="content">1.7.25</span><span class="delimiter">'</span></span>
        }
    }

    constraints {
        implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-core</span><span class="delimiter">'</span></span>) {
            version {
                require <span class="string"><span class="delimiter">'</span><span class="content">4.2.9.RELEASE</span><span class="delimiter">'</span></span>
                reject <span class="string"><span class="delimiter">'</span><span class="content">4.3.16.RELEASE</span><span class="delimiter">'</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.slf4j:slf4j-api&quot;) {
        version {
            strictly(&quot;[1.7, 1.8[&quot;)
            prefer(&quot;1.7.25&quot;)
        }
    }

    constraints {
        add(&quot;implementation&quot;, &quot;org.springframework:spring-core&quot;) {
            version {
                require(&quot;4.2.9.RELEASE&quot;)
                reject(&quot;4.3.16.RELEASE&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:dynamic_versions_and_changing_modules"><a class="anchor" href="#sec:dynamic_versions_and_changing_modules"></a> <a class="link" href="#sec:dynamic_versions_and_changing_modules">处理随时间变化的版本</a></h4>
<div class="paragraph">
<p>在许多情况下，您想使用特定模块依赖项的最新版本或一系列版本中的最新版本。这可能是开发过程中的要求，或者您可能正在开发旨在与一系列依赖版本一起使用的库。您可以使用<em>动态版本</em>轻松地依赖这些不断变化的依赖关系。<a href="#sub:declaring_dependency_with_dynamic_version">动态版本</a>可以是版本范围（例如<code>2.+</code> ），也可以是可用的最新版本的占位符，例如<code>latest.integration</code> 。</p>
</div>
<div class="paragraph">
<p>另外，您请求的模块甚至可以针对同一版本（即所谓的“ <a href="#sub:declaring_dependency_with_changing_version">更改版本”）</a>随时间<a href="#sub:declaring_dependency_with_changing_version">变化</a> 。这种类型的<em>更改模块</em>的示例是Maven <code>SNAPSHOT</code>模块，始终指向最新发布的工件。换句话说，标准的Maven快照是一个不断发展的模块，它是一个“不断变化的模块”。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>使用动态版本和更改模块可能导致无法复制的构建。随着特定模块的新版本发布，其API可能与您的源代码不兼容。请谨慎使用此功能！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="sub:declaring_dependency_with_dynamic_version"><a class="anchor" href="#sub:declaring_dependency_with_dynamic_version"></a> <a class="link" href="#sub:declaring_dependency_with_dynamic_version">声明动态版本</a></h5>
<div class="paragraph">
<p>项目可能会采用更激进的方法来消耗对模块的依赖。例如，您可能希望始终集成最新版本的依赖项，以便在任何给定时间使用最先进的功能。<em>动态版本</em>允许解析给定模块的最新版本或版本范围的最新版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在构建中使用动态版本会承担潜在破坏它的风险。包含不兼容的API更改的依赖关系的新版本发布后，您的源代码可能会停止编译。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例295声明具有动态版本的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}

repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-web:5.+</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}

repositories {
    mavenCentral()
}

dependencies {
    implementation(&quot;org.springframework:spring-web:5.+&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://scans.gradle.com/">构建扫描</a>可以有效地可视化动态依赖项版本及其各自的选定版本。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/dependency-management-dynamic-dependency-build-scan.png" alt="依赖管理动态依赖构建扫描">
</div>
<div class="title">图21。构建扫描中的动态依赖项</div>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将动态版本的依赖项缓存24小时。在此时间范围内，Gradle不会尝试从声明的存储库中解析较新的版本。<a href="#sec:controlling-dynamic-version-caching">可以</a>根据需要<a href="#sec:controlling-dynamic-version-caching">配置阈值</a> ，例如，如果您想更早地解析新版本。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:declaring_dependency_with_changing_version"><a class="anchor" href="#sub:declaring_dependency_with_changing_version"></a> <a class="link" href="#sub:declaring_dependency_with_changing_version">声明版本变更</a></h5>
<div class="paragraph">
<p>在发布应用程序或库的新版本之前，团队可能会决定实施一系列功能。允许消费者尽早且经常集成其未完成版本的一种通用策略是发布具有所谓<em>更改版本</em>的模块。版本更改表示该功能集仍在积极开发中，尚未发布稳定的版本以实现普遍可用性。</p>
</div>
<div class="paragraph">
<p>在Maven存储库中，更改的版本通常称为<a href="https://maven.apache.org/guides/getting-started/index.html#What_is_a_SNAPSHOT_version">快照版本</a> 。快照版本包含后缀<code>-SNAPSHOT</code> 。以下示例演示了如何在Spring依赖项上声明快照版本。</p>
</div>
<div class="exampleblock">
<div class="title">实施例296。声明版本更改的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}

repositories {
    mavenCentral()
    maven {
        url <span class="string"><span class="delimiter">'</span><span class="content">https://repo.spring.io/snapshot/</span><span class="delimiter">'</span></span>
    }
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-web:5.0.3.BUILD-SNAPSHOT</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}

repositories {
    mavenCentral()
    maven {
        url = uri(&quot;https://repo.spring.io/snapshot/&quot;)
    }
}

dependencies {
    implementation(&quot;org.springframework:spring-web:5.0.3.BUILD-SNAPSHOT&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将更改的依赖项版本缓存24小时。在此时间范围内，Gradle不会尝试从声明的存储库中解析较新的版本。<a href="#sec:controlling-dynamic-version-caching">可以</a>根据需要<a href="#sec:controlling-dynamic-version-caching">配置阈值</a> ，例如，如果您想更早地解析新的快照版本。</p>
</div>
<div class="paragraph">
<p>Gradle足够灵活，可以将任何版本视为更改版本，例如，如果您想为Ivy模块的快照行为建模。您需要做的就是将属性<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html#setChanging-boolean-">ExternalModuleDependency.setChanging（boolean）设置</a>为<code>true</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:controlling-dynamic-version-caching"><a class="anchor" href="#sec:controlling-dynamic-version-caching"></a> <a class="link" href="#sec:controlling-dynamic-version-caching">控制动态版本缓存</a></h5>
<div class="paragraph">
<p>默认情况下，Gradle会在24小时内缓存动态版本和更改模块。在这段时间内，Gradle不会与任何已声明的远程存储库联系以获取新版本。如果您想让Gradle更频繁地检查远程存储库或在每次执行构建时检查远程存储库，则需要更改生存时间（TTL）阈值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>由于HTTP（s）调用数量增加，因此对于动态版本或更改版本使用较短的TTL阈值可能会导致构建时间更长。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<a href="#sec:controlling_dependency_caching_command_line">命令行选项</a>覆盖默认的缓存模式。您还可以使用解析策略以<a href="#sec:controlling_dependency_caching_programmatically">编程方式更改构建中的缓存过期时间</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:controlling_dependency_caching_programmatically"><a class="anchor" href="#sec:controlling_dependency_caching_programmatically"></a> <a class="link" href="#sec:controlling_dependency_caching_programmatically">以编程方式控制依赖项缓存</a></h5>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ResolutionStrategy.html">ResolutionStrategy</a>对配置进行编程来微调缓存的某些方面。如果您想永久更改设置，则编程方式非常有用。</p>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将动态版本缓存24小时。要更改Gradle将解析后的版本缓存为动态版本的时间，请使用：</p>
</div>
<div class="exampleblock">
<div class="title">示例297。动态版本缓存控制</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor <span class="integer">10</span>, <span class="string"><span class="delimiter">'</span><span class="content">minutes</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor(10, &quot;minutes&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将更改的模块缓存24小时。要更改Gradle将为更改的模块缓存元数据和工件的时间，请使用：</p>
</div>
<div class="exampleblock">
<div class="title">实施例298。更改模块缓存控制</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    resolutionStrategy.cacheChangingModulesFor <span class="integer">4</span>, <span class="string"><span class="delimiter">'</span><span class="content">hours</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    resolutionStrategy.cacheChangingModulesFor(4, &quot;hours&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:controlling_dependency_caching_command_line"><a class="anchor" href="#sec:controlling_dependency_caching_command_line"></a> <a class="link" href="#sec:controlling_dependency_caching_command_line">从命令行控制依赖项缓存</a></h5>
<div class="sect5">
<h6 id="sec:offline-mode"><a class="anchor" href="#sec:offline-mode"></a> <a class="link" href="#sec:offline-mode">离线模式下避免网络访问</a></h6>
<div class="paragraph">
<p>的<code>--offline</code>命令行开关告诉Gradle始终使用缓存中的依赖项模块，而不管是否要再次检查它们。当离线运行时，Gradle将永远不会尝试访问网络来执行依赖关系解析。如果依赖项缓存中不存在所需的模块，则生成执行将失败。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:refreshing-dependencies"><a class="anchor" href="#sec:refreshing-dependencies"></a> <a class="link" href="#sec:refreshing-dependencies">刷新依赖</a></h6>
<div class="paragraph">
<p>您可以控制依赖项缓存的行为，以从命令行进行不同的构建调用。命令行选项有助于对构建的一次执行做出选择性的临时选择。</p>
</div>
<div class="paragraph">
<p>有时，Gradle Dependency Cache可能与已配置存储库的实际状态不同步。最初可能是错误配置了存储库，或者错误地发布了“不变”模块。要刷新依赖项缓存中的所有依赖项，请使用<code>--refresh-dependencies</code>命令行上的选项。</p>
</div>
<div class="paragraph">
<p>的<code>--refresh-dependencies</code>选项告诉Gradle忽略所有缓存的已解析模块和工件的条目。将对所有已配置的存储库执行全新的解析，并重新计算动态版本，刷新模块并下载工件。但是，在可能的情况下，Gradle将在再次下载之前检查先前下载的工件是否有效。通过将存储库中已发布的SHA1值与现有下载的工件的SHA1值进行比较来完成此操作。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>动态依赖的新版本</p>
</li>
<li>
<p>更改模块的新版本（使用相同版本字符串但可以具有不同内容的模块）</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>刷新依赖关系将导致Gradle使其列表缓存无效。然而：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它将对元数据文件执行HTTP HEAD请求，但如果它们相同<em>则不会重新下载它们</em></p>
</li>
<li>
<p>它将对工件文件执行HTTP HEAD请求，但如果它们相同<em>则不会重新下载它们</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>换句话说，刷新依赖关系<em>仅</em>在您实际使用动态依赖关系<em>或</em>您具有未知的变化依赖关系<em>时才</em>有影响（在这种情况下，您有责任将其正确声明为Gradle作为变化依赖关系）。</p>
</div>
<div class="paragraph">
<p>认为使用<code>--refresh-dependencies</code>将强制下载依赖项。事实<strong>并非</strong>如此：Gradle将仅执行刷新动态依赖项严格要求的操作。这<em>可能</em>涉及下载新的清单或元数据文件，甚至是工件，但是如果没有任何更改，则影响最小。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:component_selection_rules"><a class="anchor" href="#sec:component_selection_rules"></a> <a class="link" href="#sec:component_selection_rules">使用组件选择规则</a></h5>
<div class="paragraph">
<p>当有多个与版本选择器匹配的版本可用时，组件选择规则可能会影响应该选择哪个组件实例。规则适用于每个可用版本，并允许该规则明确拒绝该版本。这允许Gradle忽略不满足规则设置的条件的任何组件实例。示例包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于像这样的动态版本<code>1.+</code>某些版本可能会明确拒绝选择。</p>
</li>
<li>
<p>对于像这样的静态版本<code>1.4</code>可以基于额外的组件元数据（例如Ivy分支属性）拒绝实例，从而允许使用后续存储库中的实例。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ComponentSelectionRules.html">ComponentSelectionRules</a>对象配置规则。将使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ComponentSelection.html">ComponentSelection</a>对象作为参数调用配置的每个规则，该对象包含有关所考虑的候选版本的信息。调用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ComponentSelection.html#org.gradle.api.artifacts.ComponentSelection:reject(java.lang.String)">ComponentSelection.reject（java.lang。字符串）</a>会导致明确拒绝给定的候选版本，在这种情况下，选择器将不考虑候选版本。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个规则，该规则禁止模块的特定版本，但允许动态版本选择下一个最佳候选者。</p>
</div>
<div class="exampleblock">
<div class="title">示例299组件选择规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    rejectConfig {
        resolutionStrategy {
            componentSelection {
                <span class="comment">// Accept the highest version matching the requested version that isn't '1.5'</span>
                all { ComponentSelection selection -&gt;
                    <span class="keyword">if</span> (selection.candidate.group == <span class="string"><span class="delimiter">'</span><span class="content">org.sample</span><span class="delimiter">'</span></span> &amp;&amp; selection.candidate.module == <span class="string"><span class="delimiter">'</span><span class="content">api</span><span class="delimiter">'</span></span> &amp;&amp; selection.candidate.version == <span class="string"><span class="delimiter">'</span><span class="content">1.5</span><span class="delimiter">'</span></span>) {
                        selection.reject(<span class="string"><span class="delimiter">&quot;</span><span class="content">version 1.5 is broken for 'org.sample:api'</span><span class="delimiter">&quot;</span></span>)
                    }
                }
            }
        }
    }
}

dependencies {
    rejectConfig <span class="string"><span class="delimiter">&quot;</span><span class="content">org.sample:api:1.+</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    create(&quot;rejectConfig&quot;) {
        resolutionStrategy {
            componentSelection {
                // Accept the highest version matching the requested version that isn't '1.5'
                all {
                    if (candidate.group == &quot;org.sample&quot; &amp;&amp; candidate.module == &quot;api&quot; &amp;&amp; candidate.version == &quot;1.5&quot;) {
                        reject(&quot;version 1.5 is broken for 'org.sample:api'&quot;)
                    }
                }
            }
        }
    }
}

dependencies {
    &quot;rejectConfig&quot;(&quot;org.sample:api:1.+&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，首先从最高版本开始应用版本选择。选择的版本将是所有组件选择规则都接受的第一个版本。如果没有任何规则明确拒绝该版本，则该版本被视为接受。</p>
</div>
<div class="paragraph">
<p>同样，规则可以针对特定模块。必须以以下形式指定模块<code>group:module</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例300具有模块目标的组件选择规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    targetConfig {
        resolutionStrategy {
            componentSelection {
                withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.sample:api</span><span class="delimiter">&quot;</span></span>) { ComponentSelection selection -&gt;
                    <span class="keyword">if</span> (selection.candidate.version == <span class="string"><span class="delimiter">&quot;</span><span class="content">1.5</span><span class="delimiter">&quot;</span></span>) {
                        selection.reject(<span class="string"><span class="delimiter">&quot;</span><span class="content">version 1.5 is broken for 'org.sample:api'</span><span class="delimiter">&quot;</span></span>)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    create(&quot;targetConfig&quot;) {
        resolutionStrategy {
            componentSelection {
                withModule(&quot;org.sample:api&quot;) {
                    if (candidate.version == &quot;1.5&quot;) {
                        reject(&quot;version 1.5 is broken for 'org.sample:api'&quot;)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>组件选择规则在选择版本时也可以考虑组件元数据。可以考虑的其他可能的元数据是<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ComponentMetadata.html">ComponentMetadata</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html">IvyModuleDescriptor</a> 。请注意，此额外信息可能并不总是可用，因此应检查<code>null</code>价值观。</p>
</div>
<div class="exampleblock">
<div class="title">示例301带有元数据的组件选择规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    metadataRulesConfig {
        resolutionStrategy {
            componentSelection {
                <span class="comment">// Reject any versions with a status of 'experimental'</span>
                all { ComponentSelection selection -&gt;
                    <span class="keyword">if</span> (selection.candidate.group == <span class="string"><span class="delimiter">'</span><span class="content">org.sample</span><span class="delimiter">'</span></span> &amp;&amp; selection.metadata?.status == <span class="string"><span class="delimiter">'</span><span class="content">experimental</span><span class="delimiter">'</span></span>) {
                        selection.reject(<span class="string"><span class="delimiter">&quot;</span><span class="content">don't use experimental candidates from 'org.sample'</span><span class="delimiter">&quot;</span></span>)
                    }
                }
                <span class="comment">// Accept the highest version with either a &quot;release&quot; branch or a status of 'milestone'</span>
                withModule(<span class="string"><span class="delimiter">'</span><span class="content">org.sample:api</span><span class="delimiter">'</span></span>) { ComponentSelection selection -&gt;
                    <span class="keyword">if</span> (selection.getDescriptor(IvyModuleDescriptor)?.branch != <span class="string"><span class="delimiter">&quot;</span><span class="content">release</span><span class="delimiter">&quot;</span></span> &amp;&amp; selection.metadata?.status != <span class="string"><span class="delimiter">'</span><span class="content">milestone</span><span class="delimiter">'</span></span>) {
                        selection.reject(<span class="string"><span class="delimiter">&quot;</span><span class="content">'org.sample:api' must have testing branch or milestone status</span><span class="delimiter">&quot;</span></span>)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    create(&quot;metadataRulesConfig&quot;) {
        resolutionStrategy {
            componentSelection {
                // Reject any versions with a status of 'experimental'
                all {
                    if (candidate.group == &quot;org.sample&quot; &amp;&amp; metadata?.status == &quot;experimental&quot;) {
                        reject(&quot;don't use experimental candidates from 'org.sample'&quot;)
                    }
                }
                // Accept the highest version with either a &quot;release&quot; branch or a status of 'milestone'
                withModule(&quot;org.sample:api&quot;) {
                    if (getDescriptor(IvyModuleDescriptor::class)?.branch != &quot;release&quot; &amp;&amp; metadata?.status != &quot;milestone&quot;) {
                        reject(&quot;'org.sample:api' must have testing branch or milestone status&quot;)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，在声明组件选择规则时， <em>始终</em>需要<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ComponentSelection.html">ComponentSelection</a>参数作为参数。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dependency-locking"><a class="anchor" href="#dependency-locking"></a> <a class="link" href="#dependency-locking">锁定依赖版本</a></h4>
<div class="paragraph">
<p>使用动态依赖版本（例如<code>1.+</code>要么<code>[1.0,2.0)</code> ）使构建不确定。这会导致构建崩溃而没有任何明显的变化，更糟糕的是，可能是由于构建作者无法控制的传递依赖关系所致。</p>
</div>
<div class="paragraph">
<p>为了实现可<a href="https://reproducible-builds.org/">复制的构建</a> ，必须<em>锁定</em>依赖项和传递性依赖项的版本，以便具有相同输入的构建将始终解析相同的模块版本。这称为<em>依赖锁定</em> 。</p>
</div>
<div class="paragraph">
<p>除其他外，它启用以下方案：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理多个存储库的公司不再需要依赖<code>-SNAPSHOT</code>或更改依赖关系，当依赖关系引入错误或不兼容性时，有时会导致级联失败。现在，可以针对主要或次要版本范围声明依赖项，从而可以在CI上测试最新版本，同时利用锁定来稳定开发人员构建。</p>
</li>
<li>
<p>希望始终使用最新依赖关系的团队可以使用动态版本，仅针对发行版锁定其依赖关系。release标签将包含锁定状态，从而在需要开发错误修复程序时可以完全重现该版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与<a href="#publishing_maven:resolved_dependencies">发布解析版本</a>结合使用，您还可以在发布时替换声明的动态版本部件。消费者将看到您的发行版已解决的版本。</p>
</div>
<div class="paragraph">
<p>每个<a href="#sec:what-are-dependency-configurations">依赖项配置</a>均启用锁定。启用后，您必须创建一个初始锁定状态。这将使Gradle验证分辨率结果没有改变，即使生成了新版本，也会导致选择的依赖项相同。对您的构建的修改可能会影响已解决的依赖关系集，将导致其失败。这样可以确保发布的依赖项或构建定义中的更改不会在不调整锁定状态的情况下更改分辨率。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>依赖关系锁定仅对于<a href="#sub:declaring_dependency_with_dynamic_version">动态版本</a>才有意义。不会影响<a href="#sub:declaring_dependency_with_changing_version">版本的更改</a> （例如<code>-SNAPSHOT</code> ），尽管其内容可能会更改，但其坐标保持不变。当持久锁状态和解析结果中存在变化的依赖性时，Gradle甚至会发出警告。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="enabling_locking_on_configurations"><a class="anchor" href="#enabling_locking_on_configurations"></a> <a class="link" href="#enabling_locking_on_configurations">启用配置锁定</a></h5>
<div class="paragraph">
<p>锁定配置是通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ResolutionStrategy.html">ResolutionStrategy进行的</a> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例302锁定特定配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    compileClasspath {
        resolutionStrategy.activateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.compileClasspath {
    resolutionStrategy.activateDependencyLocking()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或以下方法，作为锁定所有配置的一种方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例303锁定所有配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencyLocking {
    lockAllConfigurations()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencyLocking {
    lockAllConfigurations()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>仅可解析的配置将具有锁定状态。在不可解析的配置上应用锁定只是一个禁忌。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>上面的代码将锁定所有<em>项目</em>配置，但不会锁定<em>buildscript</em>的配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以禁用对特定配置的锁定。如果某个插件配置为锁定所有配置，但是您碰巧添加了一个不应锁定的插件，则此功能很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例304解锁特定配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    compileClasspath {
        resolutionStrategy.deactivateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.compileClasspath {
    resolutionStrategy.deactivateDependencyLocking()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="locking_buildscript_classpath_configuration"><a class="anchor" href="#locking_buildscript_classpath_configuration"></a> <a class="link" href="#locking_buildscript_classpath_configuration">锁定buildscript类路径配置</a></h5>
<div class="paragraph">
<p>如果您将插件应用于构建，则可能还希望利用那里的依赖项锁定。为了锁定<a href="#sec:applying_plugins_buildscript"><code>classpath</code></a>用于脚本插件的<a href="#sec:applying_plugins_buildscript">配置</a> ，请执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例305锁定buildscript类路径配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildscript {
    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildscript {
    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="generating_and_updating_dependency_locks"><a class="anchor" href="#generating_and_updating_dependency_locks"></a> <a class="link" href="#generating_and_updating_dependency_locks">生成和更新依赖关系锁</a></h5>
<div class="paragraph">
<p>为了生成或更新锁定状态，您可以指定<code>--write-locks</code>命令行参数以及将触发要解析的配置的常规任务。这将导致在该构建执行中为每个已解析的配置创建锁定状态。请注意，如果先前存在锁定状态，则将其覆盖。</p>
</div>
<div class="sect5">
<h6 id="lock_all_configurations_in_one_build_execution"><a class="anchor" href="#lock_all_configurations_in_one_build_execution"></a> <a class="link" href="#lock_all_configurations_in_one_build_execution">将所有配置锁定在一个构建执行中</a></h6>
<div class="paragraph">
<p>锁定多个配置时，您可能希望在一次构建执行中一次锁定所有配置。</p>
</div>
<div class="paragraph">
<p>为此，您有两个选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跑<code>gradle dependencies --write-locks</code> 。这将有效地锁定所有启用了锁定的可解析配置。请注意，在多项目设置中， <code>dependencies</code>仅在<em>一个</em>项目上执行，在这种情况下是根项目。</p>
</li>
<li>
<p>声明将解决所有配置的自定义任务</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">示例306解决所有配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task resolveAndLockAll {
    doFirst {
        <span class="keyword">assert</span> gradle.startParameter.writeDependencyLocks
    }
    doLast {
        configurations.findAll {
            <span class="comment">// Add any custom filtering on the configurations to be resolved</span>
            <span class="local-variable">it</span>.canBeResolved
        }.each { <span class="local-variable">it</span>.resolve() }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;resolveAndLockAll&quot;) {
    doFirst {
        require(gradle.startParameter.isWriteDependencyLocks)
    }
    doLast {
        configurations.filter {
            // Add any custom filtering on the configurations to be resolved
            it.isCanBeResolved
        }.forEach { it.resolve() }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第二种选择是，通过正确选择配置，可以成为本机环境中的唯一选择，在这种情况下，并非所有配置都可以在单个平台上解决。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="lock_state_location_and_format"><a class="anchor" href="#lock_state_location_and_format"></a> <a class="link" href="#lock_state_location_and_format">锁定状态的位置和格式</a></h5>
<div class="paragraph">
<p>锁定状态将保留在该文件夹中的文件中<code>gradle/dependency-locks</code>在项目或子项目目录中。每个文件均由其锁定的配置命名，并具有<code>lockfile</code>延期。该规则的一个例外是构建<a href="#sec:applying_plugins_buildscript">脚本本身的</a>配置。在这种情况下，配置名称将带有前缀<code>buildscript-</code> 。</p>
</div>
<div class="paragraph">
<p>文件的内容是每行的模块表示法，标题提供了一些上下文。模块符号按字母顺序排序，以简化差异。</p>
</div>
<div class="listingblock">
<div class="title">gradle / dependency-locks / compileClasspath.lockfile</div>
<div class="content">
<pre># This is a Gradle generated file for dependency locking.
# Manual edits can break the build and are not advised.
# This file is expected to be part of source control.
org.springframework:spring-beans:5.0.5.RELEASE
org.springframework:spring-core:5.0.5.RELEASE
org.springframework:spring-jcl:5.0.5.RELEASE</pre>
</div>
</div>
<div class="paragraph">
<p>匹配以下依赖项声明：</p>
</div>
<div class="exampleblock">
<div class="title">示例307动态依赖声明</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.springframework:spring-beans:[5.0,6.0)</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.springframework:spring-beans:[5.0,6.0)&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running_a_build_with_lock_state_present"><a class="anchor" href="#running_a_build_with_lock_state_present"></a> <a class="link" href="#running_a_build_with_lock_state_present">在存在锁定状态的情况下运行构建</a></h5>
<div class="paragraph">
<p>当构建需要解析启用了锁定的配置并找到匹配的锁定状态时，它将使用它来验证给定的配置仍解析相同的版本。</p>
</div>
<div class="paragraph">
<p>成功的构建表示使用了与锁定状态中存储的依赖项相同的依赖项，无论是否已生成与动态选择器匹配的新版本。</p>
</div>
<div class="paragraph">
<p>完整的验证如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处于锁定状态的现有条目必须在构建中匹配</p>
<div class="ulist">
<ul>
<li>
<p>版本不匹配或缺少已解决的模块会导致构建失败</p>
</li>
</ul>
</div>
</li>
<li>
<p>与锁定状态相比，解析结果不得包含其他依赖项</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="selectively_updating_lock_state_entries"><a class="anchor" href="#selectively_updating_lock_state_entries"></a> <a class="link" href="#selectively_updating_lock_state_entries">有选择地更新锁定状态条目</a></h5>
<div class="paragraph">
<p>为了仅更新配置的特定模块，您可以使用<code>--update-locks</code>命令行标志。需要逗号（ <code>,</code> ）分隔的模块符号列表。在这种模式下，现有的锁定状态仍用作解决方案的输入，从而过滤出更新目标模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>❯ gradle classes --update-locks org.apache.commons:commons-lang3,org.slf4j:slf4j-api</pre>
</div>
</div>
<div class="paragraph">
<p>通配符，用表示<code>*</code> ，可以在组或模块名称中使用。它们可以是唯一字符，也可以分别出现在组或模块的末尾。以下通配符表示法示例有效：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.apache.commons:*</code> ：将让所有模块属于组<code>org.apache.commons</code>更新</p>
</li>
<li>
<p><code>*:guava</code> ：将所有模块命名<code>guava</code> ，无论他们的团队是什么，</p>
</li>
<li>
<p><code>org.springframework.spring*:spring*</code> ：将让所有模块所属的组以<code>org.springframework.spring</code>和名称以<code>spring</code>更新</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>分辨率可能会导致其他模块版本更新，这取决于Gradle分辨率规则。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="disabling_dependency_locking"><a class="anchor" href="#disabling_dependency_locking"></a> <a class="link" href="#disabling_dependency_locking">禁用依赖项锁定</a></h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>确保不再需要锁定的配置未配置锁定。</p>
</li>
<li>
<p>删除与不再需要锁定的配置相匹配的文件。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果仅执行上面的第二步，则锁定将不再有效。但是，如果将来在持久保留锁定状态时解决该配置，它将再次被锁定。</p>
</div>
</div>
<div class="sect4">
<h5 id="locking_limitations"><a class="anchor" href="#locking_limitations"></a> <a class="link" href="#locking_limitations">锁定限制</a></h5>
<div class="ulist">
<ul>
<li>
<p>锁定尚不能应用于源依赖项。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="nebula_locking_plugin"><a class="anchor" href="#nebula_locking_plugin"></a> <a class="link" href="#nebula_locking_plugin">星云锁定插件</a></h5>
<div class="paragraph">
<p>此功能受<a href="https://github.com/nebula-plugins/gradle-dependency-lock-plugin">Nebula Gradle依赖项锁定插件的</a>启发。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="controlling_transitive_dependencies"><a class="anchor" href="#controlling_transitive_dependencies"></a> <a class="link" href="#controlling_transitive_dependencies">控制传递依存关系</a></h3>
<div class="sect3">
<h4 id="dependency-constraints"><a class="anchor" href="#dependency-constraints"></a> <a class="link" href="#dependency-constraints">升级传递依赖的版本</a></h4>
<div class="sect4">
<h5 id="sec:direct-vs-transitive-deps"><a class="anchor" href="#sec:direct-vs-transitive-deps"></a> <a class="link" href="#sec:direct-vs-transitive-deps">直接依赖与依赖约束</a></h5>
<div class="paragraph">
<p>组件可能具有两种不同的依赖关系：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>直接依赖关系是<em>组件直接需要的</em> 。直接依赖关系也称为<em>第一级依赖关系</em> 。例如，如果您的项目源代码需要Guava，则应将Guava声明为<em>直接依赖项</em> 。</p>
</li>
<li>
<p>传递依赖关系是组件所需的依赖关系，但这仅是因为另一个依赖关系需要它们。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>依赖管理的问题与<em>传递依赖</em>有关是很常见的。开发人员经常通过添加<em>直接依赖项来</em>错误地解决传递依赖项问题。为了避免这种情况，Gradle提供了<em>依赖约束</em>的概念。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:adding-constraints-transitive-deps"><a class="anchor" href="#sec:adding-constraints-transitive-deps"></a> <a class="link" href="#sec:adding-constraints-transitive-deps">在传递依赖项上添加约束</a></h5>
<div class="paragraph">
<p>依赖关系约束允许您定义在构建脚本中声明的依赖关系和传递性依赖关系的版本或版本范围。表达约束的首选方法是应将约束应用于配置的所有依赖项。当Gradle尝试将对模块版本的依赖项解析时，将考虑该版本的所有<a href="#">依赖项声明</a> ，所有可传递依赖项和所有依赖项约束。选择符合所有条件的最高版本。如果找不到这样的版本，Gradle将失败，并显示一条错误的声明。如果发生这种情况，您可以调整依赖项或依赖项约束声明，或者根据需要对传递性依赖项进行其他调整。与依赖项声明类似，依赖项约束声明<a href="#sec:what-are-dependency-configurations">受配置范围限制，</a>因此可以为构建的某些部分选择性地定义。如果依赖性约束影响了解析结果，则以后仍然可以应用任何类型的<a href="#sec:dependency_resolve_rules">依赖性解析规则</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例308定义依赖关系约束</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient</span><span class="delimiter">'</span></span>
    constraints {
        implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient:4.5.3</span><span class="delimiter">'</span></span>) {
            because <span class="string"><span class="delimiter">'</span><span class="content">previous versions have a bug impacting this application</span><span class="delimiter">'</span></span>
        }
        implementation(<span class="string"><span class="delimiter">'</span><span class="content">commons-codec:commons-codec:1.11</span><span class="delimiter">'</span></span>) {
            because <span class="string"><span class="delimiter">'</span><span class="content">version 1.9 pulled from httpclient has bugs affecting this application</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.apache.httpcomponents:httpclient&quot;)
    constraints {
        implementation(&quot;org.apache.httpcomponents:httpclient:4.5.3&quot;) {
            because(&quot;previous versions have a bug impacting this application&quot;)
        }
        implementation(&quot;commons-codec:commons-codec:1.11&quot;) {
            because(&quot;version 1.9 pulled from httpclient has bugs affecting this application&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在该示例中，所有版本都从依赖声明中省略。而是在约束块中定义版本。的版本定义<code>commons-codec:1.11</code>仅在以下情况下考虑<code>commons-codec</code>被引入为传递依赖，因为<code>commons-codec</code>在项目中未定义为依赖项。否则，约束无效。依赖关系约束还可以定义<a href="#">丰富的版本约束，</a>并支持<a href="#sec:strict-version">严格的版本</a>以强制版本，即使它与传递依赖关系定义的版本相矛盾（例如，如果版本需要降级）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>依赖关系约束仅在使用<a href="#sec:understanding-gradle-module-md">Gradle Module元数据</a>时发布。这意味着当前仅在使用Gradle进行发布和使用时才完全支持它们（即，在使用Maven或Ivy使用模块时它们会“丢失”）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>依赖性约束本身也可以传递地添加。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="downgrading_versions_and_excluding_dependencies"><a class="anchor" href="#downgrading_versions_and_excluding_dependencies"></a> <a class="link" href="#downgrading_versions_and_excluding_dependencies">降级版本并排除依赖项</a></h4>
<div class="sect4">
<h5 id="sec:enforcing_dependency_version"><a class="anchor" href="#sec:enforcing_dependency_version"></a> <a class="link" href="#sec:enforcing_dependency_version">覆盖传递依赖项版本</a></h5>
<div class="paragraph">
<p>Gradle通过选择在依赖关系图中找到的最新版本来解决任何依赖关系版本冲突。某些项目可能需要偏离默认行为，并强制实施较早版本的依赖项，例如，如果项目的源代码依赖于某些外部库中较旧的依赖项API，则此项目是必需的。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>强制版本的依赖项需要有意识的决定。如果外部库没有它们而无法正常运行，则更改可传递依赖项的版本可能会导致运行时错误。考虑将源代码升级为使用库的较新版本作为替代方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，执行强制依赖关系可以降级依赖关系。降级可能会有不同的用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在最新版本中发现了一个错误</p>
</li>
<li>
<p>您的代码取决于与二进制不兼容的较低版本</p>
</li>
<li>
<p>您的代码不依赖于需要更高版本的依赖项的代码路径</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在所有情况下，最好的表述是您的代码<em>严格依赖于</em>可传递代码的版本。使用<a href="#sec:strict-version">严格版本</a> ，即使传递依赖项另有说明，您也将有效地依赖声明的版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>严格的依赖关系在某种程度上类似于Maven <em>最接近的优先</em>策略，但存在细微的差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>严格的依赖</em>关系不会遇到排序问题：它们可传递地应用于子图，并且声明顺序依赖关系也无关紧要。</p>
</li>
<li>
<p>严格的依赖项冲突将触发您必须解决的构建失败</p>
</li>
<li>
<p>严格的依赖项可以与丰富的版本一起使用，这意味着<a href="#sec:strict-version-consequences">最好在<em>严格范围内</em>结合单个<em>首选版本</em>来表达需求</a> 。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>假设一个项目使用<a href="https://hc.apache.org/httpcomponents-client-ga/">HttpClient库</a>执行HTTP调用。HttpClient从1.10版引入<a href="https://commons.apache.org/proper/commons-codec/">Commons Codec</a>作为传递依赖项。但是，该项目的生产源代码需要Commons Codec 1.9中的API，该API在1.10中不再可用。可以通过在构建脚本中将其声明为严格来强制实施依赖项版本：</p>
</div>
<div class="exampleblock">
<div class="title">实施例309。设定严格的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient:4.5.4</span><span class="delimiter">'</span></span>
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">commons-codec:commons-codec</span><span class="delimiter">'</span></span>) {
        version {
            strictly <span class="string"><span class="delimiter">'</span><span class="content">1.9</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.apache.httpcomponents:httpclient:4.5.4&quot;)
    implementation(&quot;commons-codec:commons-codec&quot;) {
        version {
            strictly(&quot;1.9&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:strict-version-consequences"><a class="anchor" href="#sec:strict-version-consequences"></a> <a class="link" href="#sec:strict-version-consequences">使用严格版本的后果</a></h6>
<div class="paragraph">
<p>必须仔细考虑使用严格的版本，尤其是图书馆作者。作为<em>生产者</em> ，严格的版本实际上将表现得像一种<em>力量</em> ：版本声明优先于在传递依赖关系图中找到的任何内容。特别是， <em>严格版本</em>将覆盖可传递地找到的同一模块上的任何其他<em>严格版本</em> 。</p>
</div>
<div class="paragraph">
<p>但是，对于使用者，在图形解析期间仍会严格考虑严格版本，如果使用者不同意，则<em>可能会触发错误</em> 。</p>
</div>
<div class="paragraph">
<p>例如，假设您的项目<code>B</code> <em>严格</em>取决于<code>C:1.0</code> 。现在，一个消费者， <code>A</code> ，取决于两者<code>B</code>和<code>C:1.1</code> 。</p>
</div>
<div class="paragraph">
<p>然后，这将触发解决方案错误，因为<code>A</code>说需要<code>C:1.1</code>但<code>B</code> <em>在其子图</em>中严格要求<code>1.0</code> 。这意味着，如果您在严格的约束条件下选择<em>单个版本</em> ，则该版本将<em>无法再升级</em> ，除非使用者也对同一模块设置了严格的约束条件。</p>
</div>
<div class="paragraph">
<p>在上面的示例中， <code>A</code>不得不说它<em>严格取决于1.1</em> 。</p>
</div>
<div class="paragraph">
<p>因此，一个好的做法是，如果使用<em>严格的版本</em> ，则应使用范围和该范围内的首选版本来表达它们。例如， <code>B</code>可能会说，而不是<code>strictly 1.0</code> ，这<em>完全取决于</em> <code>[1.0, 2.0[</code>范围，但<em>更喜欢</em> <code>1.0</code> 。然后，如果使用者选择1.1（或该范围内的任何其他版本），则构建将<em>不再失败</em> （约束已解决）。</p>
</div>
</div>
<div class="sect5">
<h6 id="forced_dependencies_vs_strict_dependencies"><a class="anchor" href="#forced_dependencies_vs_strict_dependencies"></a> <a class="link" href="#forced_dependencies_vs_strict_dependencies">强制依赖与严格依赖</a></h6>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>不建议使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ExternalDependency.html#setForce-boolean-">ExternalDependency.setForce（boolean）</a>强制依赖，并且不再建议使用：强制依赖存在一个排序问题，该问题可能很难诊断，并且无法与其他丰富版本约束一起很好地工作。您应该选择<a href="#sec:enforcing_dependency_version">严格的版本</a> 。如果要编写和发布<a href="#">库</a> ，还需要注意以下几点： <code>force</code> <strong>未</strong>发布。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果由于某种原因不能使用<a href="#sec:enforcing_dependency_version">严格版本</a> ，则可以强制依赖项执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">例子310。实施依赖版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient:4.5.4</span><span class="delimiter">'</span></span>
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">commons-codec:commons-codec:1.9</span><span class="delimiter">'</span></span>) {
        force = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.apache.httpcomponents:httpclient:4.5.4&quot;)
    implementation(&quot;commons-codec:commons-codec:1.9&quot;) {
        isForce = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果项目要求在配置级别上具有特定版本的依赖关系，则可以通过调用方法<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:force(java.lang.Object[])">ResolutionStrategy.force（java.lang。Object []）</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">实施例311。在配置级别上强制依赖项版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    compileClasspath {
        resolutionStrategy.force <span class="string"><span class="delimiter">'</span><span class="content">commons-codec:commons-codec:1.9</span><span class="delimiter">'</span></span>
    }
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient:4.5.4</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    &quot;compileClasspath&quot; {
        resolutionStrategy.force(&quot;commons-codec:commons-codec:1.9&quot;)
    }
}

dependencies {
    implementation(&quot;org.apache.httpcomponents:httpclient:4.5.4&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:excluding-transitive-deps"><a class="anchor" href="#sec:excluding-transitive-deps"></a> <a class="link" href="#sec:excluding-transitive-deps">排除传递依赖</a></h5>
<div class="paragraph">
<p>虽然上一节显示了如何强制实施某个版本的可传递依赖项，但本节<em>将排除</em>作为完全删除可传递依赖项的一种方式。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>与强制依赖版本相似，完全排除依赖需要有意识的决定。如果外部库没有它们而无法正常运行，则排除传递依赖关系可能会导致运行时错误。如果您使用排除，请确保您没有通过足够的测试覆盖率来利用任何不需要排除依赖的代码路径。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在声明的依赖项级别上排除传递性依赖项。通过属性将排除作为键/值对阐明<code>group</code>和/或<code>module</code>如下例所示。有关更多信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ModuleDependency.html#exclude-java.util.Map-">ModuleDependency.exclude（java.util。地图）</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例312排除特定依赖声明的传递依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">commons-beanutils:commons-beanutils:1.9.4</span><span class="delimiter">'</span></span>) {
        exclude <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>, <span class="key">module</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;commons-beanutils:commons-beanutils:1.9.4&quot;) {
        exclude(group = &quot;commons-collections&quot;, module = &quot;commons-collections&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们向<code>commons-beanutils</code>但排除传递依赖<code>commons-collections</code> 。在下面显示的代码中，我们仅使用beanutils库中的一种方法， <code>PropertyUtils.setSimpleProperty()</code> 。对现有的设置员使用此方法不需要以下功能<code>commons-collections</code>我们通过测试覆盖率进行了验证。</p>
</div>
<div class="exampleblock">
<div class="title">示例313。使用beanutils库中的实用程序</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">src / main / java / Main.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.apache.commons.beanutils.PropertyUtils</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="predefined-type">Object</span> person = <span class="keyword">new</span> Person();
        PropertyUtils.setSimpleProperty(person, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Bart Simpson</span><span class="delimiter">&quot;</span></span>);
        PropertyUtils.setSimpleProperty(person, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, <span class="integer">38</span>);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实际上，我们表示仅使用该库的一个<em>子集</em> ，而无需<code>commons-collection</code>图书馆。这可以看作是隐式定义了一个<a href="#">特征变体</a> ，该<a href="#">变体</a>尚未由<code>commons-beanutils</code>本身。但是，这样做会增加破坏未经测试的代码路径的风险。</p>
</div>
<div class="paragraph">
<p>例如，在这里我们使用<code>setSimpleProperty()</code>修改设置器中定义的属性的方法<code>Person</code>类，效果很好。如果我们将尝试设置属性不存在的类，我们<em>应该</em>得到这样的错误<code>Unknown property on class Person</code> 。但是，由于错误处理路径使用来自<code>commons-collections</code> ，我们现在得到的错误是<code>NoClassDefFoundError: org/apache/commons/collections/FastHashMap</code> 。因此，如果我们的代码更具动态性，而我们忘记了充分涵盖错误情况，则我们库的使用者可能会遇到意外错误。</p>
</div>
<div class="paragraph">
<p>这仅仅是说明潜在陷阱的一个示例。实际上，较大的库或框架会带来大量的依赖关系。如果这些库无法分别声明功能，并且只能以“全有或全无”的方式使用，则排除可能是将库缩减为实际所需功能集的有效方法。</p>
</div>
<div class="paragraph">
<p>从好的方面来说，与Maven相比，Gradle的排除处理考虑了整个依赖关系图。因此，如果库上有多个依赖项，则只有在所有依赖项都对它们都同意的情况下才执行排除。例如，如果我们添加<code>opencsv</code>作为我们上面项目的另一个依赖项，这也取决于<code>commons-beanutils</code> ， <code>commons-collection</code>不再排除为<code>opencsv</code>本身<strong>并不</strong>排除它。</p>
</div>
<div class="exampleblock">
<div class="title">实施例314。仅当所有依赖项声明均同意排除项时，排除项才适用</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    dependencies {
        implementation(<span class="string"><span class="delimiter">'</span><span class="content">commons-beanutils:commons-beanutils:1.9.4</span><span class="delimiter">'</span></span>) {
            exclude <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>, <span class="key">module</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>
        }
        implementation <span class="string"><span class="delimiter">'</span><span class="content">com.opencsv:opencsv:4.6</span><span class="delimiter">'</span></span> <span class="comment">// depends on 'commons-beanutils' without exclude and brings back 'commons-collections'</span>
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;commons-beanutils:commons-beanutils:1.9.4&quot;) {
        exclude(group = &quot;commons-collections&quot;, module = &quot;commons-collections&quot;)
    }
    implementation(&quot;com.opencsv:opencsv:4.6&quot;) // depends on 'commons-beanutils' without exclude and brings back 'commons-collections'
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们仍然想拥有<code>commons-collections</code>排除在外，因为我们的综合使用<code>commons-beanutils</code>和<code>opencsv</code>不需要它，我们需要将其从<code>opencsv</code>也一样</p>
</div>
<div class="exampleblock">
<div class="title">示例315为多个依赖项声明排除传递依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    dependencies {
        implementation(<span class="string"><span class="delimiter">'</span><span class="content">commons-beanutils:commons-beanutils:1.9.4</span><span class="delimiter">'</span></span>) {
            exclude <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>, <span class="key">module</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>
        }
        implementation(<span class="string"><span class="delimiter">'</span><span class="content">com.opencsv:opencsv:4.6</span><span class="delimiter">'</span></span>) {
            exclude <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>, <span class="key">module</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    dependencies {
        implementation(&quot;commons-beanutils:commons-beanutils:1.9.4&quot;) {
            exclude(group = &quot;commons-collections&quot;, module = &quot;commons-collections&quot;)
        }
        implementation(&quot;com.opencsv:opencsv:4.6&quot;) {
            exclude(group = &quot;commons-collections&quot;, module = &quot;commons-collections&quot;)
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从历史上看，排除项还用作解决某些依赖项管理系统不支持的其他问题的工具。但是，Gradle提供了可能更适合解决特定用例的各种功能。您可以考虑研究以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:enforcing_dependency_version">更新</a>或<a href="#sec:enforcing_dependency_version">降级</a>依赖性版本：如果依赖性版本冲突，通常最好通过依赖性约束来调整版本，而不是尝试用不需要的版本排除依赖性。</p>
</li>
<li>
<p><a href="#">组件元数据规则</a> ：如果库的元数据明显错误，例如，如果它包含一个编译时依赖项，而在编译时就不需要，则可能的解决方案是删除组件元数据规则中的依赖项。通过这种方式，你告诉摇篮，它永远不会需要两个模块之间的依赖关系-即元数据是错误的-因此<strong>不</strong>应该被考虑。如果要开发库，则必须注意该信息不会发布，因此有时<em>排除</em>是更好的选择。</p>
</li>
<li>
<p><a href="#">解决互斥的依赖冲突</a> ：您经常看到用exclude解决的另一种情况是，两个依赖不能一起使用，因为它们表示同一事物（相同<a href="#sub:capabilities">功能</a> ）的两个实现。一个流行的示例是冲突日志API的实现（例如<code>log4j</code>和<code>log4j-over-slf4j</code> ）或在不同版本中具有不同坐标的模块（例如<code>com.google.collections</code>和<code>guava</code> ）。在这种情况下，如果Gradle不知道此信息，则建议通过组件元数据规则添加缺失的能力信息，如<a href="#sub:declaring-component-capabilities">声明组件功能</a>部分中所述。即使您正在开发图书馆，而您的消费者也不得不再次解决冲突，将决定权交给图书馆的最终消费者通常是正确的解决方案。也就是说，作为图书馆作者，您最终不必决定消费者使用哪种日志记录实现。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:using-platform-to-control-transitive-deps"><a class="anchor" href="#sec:using-platform-to-control-transitive-deps"></a> <a class="link" href="#sec:using-platform-to-control-transitive-deps">在项目之间共享依赖版本</a></h4>
<div class="sect4">
<h5 id="sub:sharing-dep-versions-between-projects"><a class="anchor" href="#sub:sharing-dep-versions-between-projects"></a> <a class="link" href="#sub:sharing-dep-versions-between-projects">使用平台控制传递版本</a></h5>
<div class="paragraph">
<p><a href="#sub::terminology_platform">平台</a>是一种特殊的软件组件，可用于控制传递依赖项版本。在大多数情况下，它完全由<a href="#sec:adding-constraints-transitive-deps">依赖项约束</a>组成，这将<em>建议</em>依赖项版本或<em>强制执行</em>某些版本。因此，当您需要<em>在项目之间共享依赖版本</em>时，这是一个完美的工具。在这种情况下，通常以这种方式组织项目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>platform</code>该项目为在不同子项目中找到的各种依赖项定义了约束</p>
</li>
<li>
<p>多个子项目，这些子项目<em>依赖于</em>平台并声明<em>不带版本的</em>依赖项</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在Java生态系统中，Gradle为此提供了一个<a href="#java_platform_plugin">插件</a> 。</p>
</div>
<div class="paragraph">
<p>找到发布为<a href="#sub:bom_import">Gradle本地支持的</a> Maven BOM的平台也是很常见的。</p>
</div>
<div class="paragraph">
<p>使用<code>platform</code>关键词：</p>
</div>
<div class="exampleblock">
<div class="title">实施例316。获取平台中声明的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// get recommended versions from the platform project</span>
    api platform(project(<span class="string"><span class="delimiter">'</span><span class="content">:platform</span><span class="delimiter">'</span></span>))
    <span class="comment">// no version required</span>
    api <span class="string"><span class="delimiter">'</span><span class="content">commons-httpclient:commons-httpclient</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // get recommended versions from the platform project
    api(platform(project(&quot;:platform&quot;)))
    // no version required
    api(&quot;commons-httpclient:commons-httpclient&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>这个<code>platform</code>记号是一种简写的记号，实际上在幕后执行了一些操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Category.html">org.gradle.category属性设置</a>为<code>platform</code> ，这意味着Gradle将选择依赖项的<em>平台</em>组件。</p>
</li>
<li>
<p>它默认设置了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ModuleDependency.html#endorseStrictVersions--">endorseStrictVersions</a>行为，这意味着如果平台声明了严格的依赖关系，则将强制执行它们。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着默认情况下，对平台的依赖关系会触发该平台中定义的所有<a href="#sec:strict-version">严格版本</a>的继承，这对于平台作者确保所有使用者在依赖关系的版本方面都遵循自己的决定很有用。可以通过显式调用<code>doNotEndorseStrictVersions</code>方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sub:bom_import"><a class="anchor" href="#sub:bom_import"></a> <a class="link" href="#sub:bom_import">导入Maven BOM</a></h5>
<div class="paragraph">
<p>Gradle为导入<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies">物料清单（BOM）文件</a>提供了支持，这些<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies">文件</a>有效<code>.pom</code>使用的文件<code><dependencyManagement></code>控制直接和传递依赖的依赖版本。Gradle中的BOM支持与使用类似<code><scope>import</scope></code>取决于Maven中的BOM。但是，在Gradle中，这是通过BOM上的常规依赖项声明完成的：</p>
</div>
<div class="exampleblock">
<div class="title">示例317。依靠BOM导入其依赖关系约束</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// import a BOM</span>
    implementation platform(<span class="string"><span class="delimiter">'</span><span class="content">org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE</span><span class="delimiter">'</span></span>)

    <span class="comment">// define dependencies without versions</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">com.google.code.gson:gson</span><span class="delimiter">'</span></span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">dom4j:dom4j</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // import a BOM
    implementation(platform(&quot;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE&quot;))

    // define dependencies without versions
    implementation(&quot;com.google.code.gson:gson&quot;)
    implementation(&quot;dom4j:dom4j&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在示例中， <code>gson</code>和<code>dom4j</code>由Spring Boot BOM提供。这样，如果您正在开发像Spring Boot这样的平台，则不必自己声明任何版本，而可以依赖平台提供的版本。</p>
</div>
<div class="paragraph">
<p>Gradle会处理<code><dependencyManagement></code>类似于<a href="#sec:adding-constraints-transitive-deps">Gradle的依赖关系约束</a>的BOM表块。这意味着， <code><dependencyManagement></code>块可能会影响依赖性解析结果。为了符合BOM的要求， <code>.pom</code>文件需要有<code><packaging>pom</packaging></code>组。</p>
</div>
<div class="paragraph">
<p>但是，BOM常常不仅提供建议的版本，而且还提供一种方法来覆盖图中找到的任何其他版本。您可以使用<code>enforcedPlatform</code>关键字，而不是<code>platform</code> ，在导入BOM时：</p>
</div>
<div class="exampleblock">
<div class="title">实施例318。导入物料清单，确保其定义的版本会覆盖找到的任何其他版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// import a BOM. The versions used in this file will override any other version found in the graph</span>
    implementation enforcedPlatform(<span class="string"><span class="delimiter">'</span><span class="content">org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE</span><span class="delimiter">'</span></span>)

    <span class="comment">// define dependencies without versions</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">com.google.code.gson:gson</span><span class="delimiter">'</span></span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">dom4j:dom4j</span><span class="delimiter">'</span></span>

    <span class="comment">// this version will be overridden by the one found in the BOM</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.codehaus.groovy:groovy:1.8.6</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // import a BOM. The versions used in this file will override any other version found in the graph
    implementation(enforcedPlatform(&quot;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE&quot;))

    // define dependencies without versions
    implementation(&quot;com.google.code.gson:gson&quot;)
    implementation(&quot;dom4j:dom4j&quot;)

    // this version will be overridden by the one found in the BOM
    implementation(&quot;org.codehaus.groovy:groovy:1.8.6&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="version_alignment"><a class="anchor" href="#version_alignment"></a> <a class="link" href="#version_alignment">对齐依赖版本</a></h4>
<div class="paragraph">
<p>依赖关系版本对齐允许依赖于同一逻辑组（ <em>平台</em> ）的不同模块在依赖关系图中具有相同的版本。</p>
</div>
<div class="sect4">
<h5 id="handling_inconsistent_module_versions"><a class="anchor" href="#handling_inconsistent_module_versions"></a> <a class="link" href="#handling_inconsistent_module_versions">处理不一致的模块版本</a></h5>
<div class="paragraph">
<p>Gradle支持对齐属于同一“平台”的模块的版本。例如，通常最好是组件的API和实现模块使用相同的版本。但是，由于传递依赖解析的博弈，属于同一平台的不同模块最终可能使用不同的版本。例如，您的项目可能取决于<code>jackson-databind</code>和<code>vert.x</code>库，如下图所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例319声明依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// a dependency on Jackson Databind</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">com.fasterxml.jackson.core:jackson-databind:2.8.9</span><span class="delimiter">'</span></span>

    <span class="comment">// and a dependency on vert.x</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">io.vertx:vertx-core:3.5.3</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // a dependency on Jackson Databind
    implementation(&quot;com.fasterxml.jackson.core:jackson-databind:2.8.9&quot;)

    // and a dependency on vert.x
    implementation(&quot;io.vertx:vertx-core:3.5.3&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为<code>vert.x</code>依赖于取决于<code>jackson-core</code> ，我们实际上将解决以下依赖项版本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jackson-core</code>版<code>2.9.5</code> （由<code>vertx-core</code> ）</p>
</li>
<li>
<p><code>jackson-databind</code>版<code>2.9.5</code> （通过冲突解决）</p>
</li>
<li>
<p><code>jackson-annotation</code>版<code>2.9.0</code> （依赖项<code>jackson-databind:2.9.5</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最终会出现一组不能很好地协同工作的版本，这很容易。为了解决这个问题，Gradle支持平台版本的概念支持的依赖版本对齐。平台代表了一组“一起工作”的模块。或者是因为它们实际上是作为一个整体发布的（当平台成员之一发布时，所有其他模块也都以相同的版本发布），或者是因为有人测试了模块并指出它们可以很好地协同工作（通常是Spring）平台）。</p>
</div>
</div>
<div class="sect4">
<h5 id="aligning_versions_natively_with_gradle"><a class="anchor" href="#aligning_versions_natively_with_gradle"></a> <a class="link" href="#aligning_versions_natively_with_gradle">将本机版本与Gradle对齐</a></h5>
<div class="paragraph">
<p>Gradle本机支持Gradle生产的模块的对齐。这是<a href="#sec:adding-constraints-transitive-deps">依赖关系约束</a>的可传递<a href="#sec:adding-constraints-transitive-deps">性</a>的直接结果。因此，如果您具有多项目构建，并且希望使用者获得所有模块的相同版本，那么Gradle提供了一种使用<a href="#">Java Platform Plugin</a>进行此操作的简单方法。</p>
</div>
<div class="paragraph">
<p>例如，如果您的项目包含3个模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lib</code></p>
</li>
<li>
<p><code>utils</code></p>
</li>
<li>
<p><code>core</code> ， 取决于<code>lib</code>和<code>utils</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>并声明以下依赖项的使用者：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>core</code>版本1.0</p>
</li>
<li>
<p><code>lib</code>版本1.1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后默认情况下，分辨率会选择<code>core:1.0</code>和<code>lib:1.1</code> ，因为<code>lib</code>不依赖<code>core</code> 。我们可以通过在项目中添加一个新的模块<em>platform</em>来解决此问题，该模块将对项目的所有模块添加约束：</p>
</div>
<div class="exampleblock">
<div class="title">例子320。平台模块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-platform</span><span class="delimiter">'</span></span>
}

dependencies {
    <span class="comment">// The platform declares constraints on all components that</span>
    <span class="comment">// require alignment</span>
    constraints {
        api(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:core</span><span class="delimiter">&quot;</span></span>))
        api(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:lib</span><span class="delimiter">&quot;</span></span>))
        api(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:utils</span><span class="delimiter">&quot;</span></span>))
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-platform`
}

dependencies {
    // The platform declares constraints on all components that
    // require alignment
    constraints {
        api(project(&quot;:core&quot;))
        api(project(&quot;:lib&quot;))
        api(project(&quot;:utils&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>完成此操作后，我们需要确保所有模块现在都<em>依赖于该平台</em> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子321。声明对平台的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// Each project has a dependency on the platform</span>
    api(platform(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:platform</span><span class="delimiter">&quot;</span></span>)))

    <span class="comment">// And any additional dependency required</span>
    implementation(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:lib</span><span class="delimiter">&quot;</span></span>))
    implementation(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:utils</span><span class="delimiter">&quot;</span></span>))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // Each project has a dependency on the platform
    api(platform(project(&quot;:platform&quot;)))

    // And any additional dependency required
    implementation(project(&quot;:lib&quot;))
    implementation(project(&quot;:utils&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>平台对所有组件都包含约束很重要，而且每个组件都对平台具有依赖关系很重要。这样，每当摇篮将增加一个依赖关系图上的平台的模块，它<em>还将</em>包括对平台的其他模块的约束。这意味着，如果看到属于同一平台的另一个模块，我们将自动升级到相同版本。</p>
</div>
<div class="paragraph">
<p>在我们的示例中，这意味着我们首先看到<code>core:1.0</code> ，这带来了一个平台<code>1.0</code>受到限制<code>lib:1.0</code>和<code>lib:1.0</code> 。然后我们添加<code>lib:1.1</code>依赖于<code>platform:1.1</code> 。通过冲突解决，我们选择<code>1.1</code>平台，对<code>core:1.1</code> 。然后我们之间解决冲突<code>core:1.0</code>和<code>core:1.1</code> ， 意思就是<code>core</code>和<code>lib</code>现在已正确对齐。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">仅当您使用Gradle Module元数据时，才对发布的组件强制执行此行为。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:align-versions-virtual"><a class="anchor" href="#sec:align-versions-virtual"></a> <a class="link" href="#sec:align-versions-virtual">对齐未随Gradle发布的模块版本</a></h5>
<div class="paragraph">
<p>每当发布者不使用Gradle时（例如在我们的Jackson例子中），我们都可以向Gradle解释说，所有Jackson模块都“属于”同一平台，并从与本机对齐方式相同的行为中受益：</p>
</div>
<div class="exampleblock">
<div class="title">示例322。依赖版本对齐规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">JacksonAlignmentRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext ctx) {
        ctx.details.with {
            <span class="keyword">if</span> (id.group.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.fasterxml.jackson</span><span class="delimiter">&quot;</span></span>)) {
                <span class="comment">// declare that Jackson modules all belong to the Jackson virtual platform</span>
                belongsTo(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.fasterxml.jackson:jackson-platform:</span><span class="inline"><span class="inline-delimiter">${</span>id.version<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class JacksonAlignmentRule: ComponentMetadataRule {
    override fun execute(ctx: ComponentMetadataContext) {
        ctx.details.run {
            if (id.group.startsWith(&quot;com.fasterxml.jackson&quot;)) {
                // declare that Jackson modules all belong to the Jackson virtual platform
                belongsTo(&quot;com.fasterxml.jackson:jackson-platform:${id.version}&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过使用<code>belongsTo</code>关键字，我们声明所有模块都属于同一个<em>虚拟平台</em> ，该引擎由引擎特别对待，特别是在对齐方面。我们可以通过注册使用刚刚创建的规则：</p>
</div>
<div class="exampleblock">
<div class="title">示例323利用依赖版本对齐规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    components.all(JacksonAlignmentRule)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    components.all(JacksonAlignmentRule::class.java)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，上面示例中的所有版本将与<code>2.9.5</code> 。但是，Gradle将允许您通过在Jackson平台上指定依赖项来覆盖该选择：</p>
</div>
<div class="exampleblock">
<div class="title">示例324平台强制降级</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// Forcefully downgrade the Jackson platform to 2.8.9</span>
    implementation enforcedPlatform(<span class="string"><span class="delimiter">'</span><span class="content">com.fasterxml.jackson:jackson-platform:2.8.9</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // Forcefully downgrade the Jackson platform to 2.8.9
    implementation(enforcedPlatform(&quot;com.fasterxml.jackson:jackson-platform:2.8.9&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:virtual_platform"><a class="anchor" href="#sec:virtual_platform"></a> <a class="link" href="#sec:virtual_platform">虚拟平台与已发布平台</a></h5>
<div class="paragraph">
<p>由组件元数据规则定义的平台， <code>belongsTo</code>目标模块未在存储库上发布称为虚拟平台。引擎特别考虑了虚拟平台，它像已发布的模块一样参与依赖关系解析，但是会触发依赖关系版本对齐。另一方面，我们可以找到在公共资源库上发布的“真实”平台。典型示例包括BOM，例如Spring BOM。它们的不同之处在于，已发布的平台可能引用的模块实际上是不同的模块。例如，Spring BOM声明了对Spring以及Apache Groovy的依赖。显然，这些东西的版本不同，因此在这种情况下对齐是没有意义的。换句话说，如果<em>发布</em>了平台，则Gradle会信任其元数据，并且不会尝试对齐该平台的依赖版本。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:handling-mutually-exclusive-deps"><a class="anchor" href="#sec:handling-mutually-exclusive-deps"></a> <a class="link" href="#sec:handling-mutually-exclusive-deps">处理互斥依赖性</a></h4>
<div class="sect4">
<h5 id="sub:capabilities"><a class="anchor" href="#sub:capabilities"></a> <a class="link" href="#sub:capabilities">组件功能介绍</a></h5>
<div class="paragraph">
<p>依赖图通常会偶然包含同一API的多个实现。这在日志记录框架中尤其常见，在日志记录框架中有多个绑定可用，并且当另一个传递依赖项选择另一个时，一个库选择一个绑定。由于这些实现位于不同的GAV坐标下，因此构建工具通常无法找出这些库之间是否存在冲突。为了解决这个问题，Gradle提供了<em>功能</em>的概念。</p>
</div>
<div class="paragraph">
<p>在单个依赖关系图中找到两个提供相同<em>功能的</em>组件是非法的。直观地讲，这意味着如果Gradle在类路径上找到两个提供相同内容的组件，它将失败并显示一条错误消息，指出哪些模块发生冲突。在我们的示例中，这意味着日志记录框架的不同绑定提供了相同的功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="capability_coordinates"><a class="anchor" href="#capability_coordinates"></a> <a class="link" href="#capability_coordinates">能力座标</a></h5>
<div class="paragraph">
<p><em>能力</em>由<code>(group, module, version)</code>三胞胎。每个组件都定义一个与其GAV坐标（组，工件，版本）相对应的隐式功能。例如， <code>org.apache.commons:commons-lang3:3.8</code>模块具有组的隐式功能<code>org.apache.commons</code> ， 名称<code>commons-lang3</code>和版本<code>3.8</code> 。重要的是要认识到功能是<em>版本化的</em> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:declaring-component-capabilities"><a class="anchor" href="#sub:declaring-component-capabilities"></a> <a class="link" href="#sub:declaring-component-capabilities">声明组件功能</a></h5>
<div class="paragraph">
<p>默认情况下，如果依赖关系图中的两个组件提供相同的功能，则Gradle将失败。因为当前发布的大多数模块都没有Gradle模块元数据，所以Gradle并不总是自动发现功能。但是，使用<em>规则</em>声明组件功能以便在构建而不是运行时尽快发现冲突很有趣。</p>
</div>
<div class="paragraph">
<p>一个典型的例子是在新版本中，只要将组件重新放置在不同的坐标上。例如，ASM库位于<code>asm:asm</code>协调直到版本<code>3.3.1</code> ，然后更改为<code>org.ow2.asm:asm</code>以来<code>4.0</code> 。在类路径上同时具有ASM⇐3.3.1和4.0+是非法的，因为它们提供相同的功能，只是组件已被重定位。由于每个组件都具有与其GAV坐标相对应的隐式功能，因此我们可以通过制定一条规则来声明“ <code>asm:asm</code>模块提供<code>org.ow2.asm:asm</code>能力：</p>
</div>
<div class="exampleblock">
<div class="title">示例325通过能力解决冲突</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@CompileStatic</span>
<span class="type">class</span> <span class="class">AsmCapability</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.with {
            <span class="keyword">if</span> (id.group == <span class="string"><span class="delimiter">&quot;</span><span class="content">asm</span><span class="delimiter">&quot;</span></span> &amp;&amp; id.name == <span class="string"><span class="delimiter">&quot;</span><span class="content">asm</span><span class="delimiter">&quot;</span></span>) {
                allVariants {
                    <span class="local-variable">it</span>.withCapabilities {
                        <span class="comment">// Declare that ASM provides the org.ow2.asm:asm capability, but with an older version</span>
                        <span class="local-variable">it</span>.addCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.ow2.asm</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">asm</span><span class="delimiter">&quot;</span></span>, id.version)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">class AsmCapability : ComponentMetadataRule {
    override
    fun execute(context: ComponentMetadataContext) = context.details.run {
        if (id.group == &quot;asm&quot; &amp;&amp; id.name == &quot;asm&quot;) {
            allVariants {
                withCapabilities {
                    // Declare that ASM provides the org.ow2.asm:asm capability, but with an older version
                    addCapability(&quot;org.ow2.asm&quot;, &quot;asm&quot;, id.version)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，只要在同一依赖图中找到两个组件，构建就将<em>失败</em> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在这个阶段，Gradle <em>只会</em>使更多构建失败。它<strong>不会</strong>自动为您解决问题，但是可以帮助您意识到自己有问题。建议在<em>插件中</em>编写此类规则，然后将其应用于您的构建。然后，用户<em>必须尽可能</em>表达自己的喜好，或者解决类路径上不兼容内容的问题，如下节所述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sub:selecting-between-candidates"><a class="anchor" href="#sub:selecting-between-candidates"></a> <a class="link" href="#sub:selecting-between-candidates">在候选人之间进行选择</a></h5>
<div class="paragraph">
<p>在某个时候，依赖图将包含<em>不兼容的模块</em>或<em>互斥的</em>模块。例如，您可能有不同的记录器实现，并且需要选择一种绑定。
<a href="#sub:capabilities">功能可以</a>帮助您<em>意识到</em>您有冲突，但是Gradle还提供了表达如何解决冲突的工具。</p>
</div>
<div class="sect5">
<h6 id="sub:selecting-preferred-capability-provider"><a class="anchor" href="#sub:selecting-preferred-capability-provider"></a> <a class="link" href="#sub:selecting-preferred-capability-provider">在不同能力的候选人之间进行选择</a></h6>
<div class="paragraph">
<p>在上面的重定位示例中，Gradle能够告诉您在类路径上有两个版本的同一API：一个“旧”模块和一个“重定位”模块。现在，我们可以通过自动选择功能最高的组件来解决冲突：</p>
</div>
<div class="exampleblock">
<div class="title">示例326通过功能版本控制解决冲突</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    resolutionStrategy.capabilitiesResolution.withCapability(<span class="string"><span class="delimiter">'</span><span class="content">org.ow2.asm:asm</span><span class="delimiter">'</span></span>) {
        selectHighestVersion()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    resolutionStrategy.capabilitiesResolution.withCapability(&quot;org.ow2.asm:asm&quot;) {
        selectHighestVersion()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，通过选择最高性能的版本冲突解决方法进行修复并不总是适合的。例如，对于日志记录框架，我们使用什么版本的日志记录框架都没有关系，我们应该始终选择Slf4j。</p>
</div>
<div class="paragraph">
<p>在这种情况下，我们可以通过明确选择slf4j作为赢家来解决此问题：</p>
</div>
<div class="exampleblock">
<div class="title">示例327用slf4j替换log4j</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    configurations.all {
        resolutionStrategy.capabilitiesResolution.withCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">log4j:log4j</span><span class="delimiter">&quot;</span></span>) {
            select(candidates.find { <span class="local-variable">it</span>.id <span class="keyword">instanceof</span> ModuleComponentIdentifier &amp;&amp; <span class="local-variable">it</span>.id.module == <span class="string"><span class="delimiter">'</span><span class="content">log4j-over-slf4j</span><span class="delimiter">'</span></span> } )
            because <span class="string"><span class="delimiter">'</span><span class="content">use slf4j in place of log4j</span><span class="delimiter">'</span></span>
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    configurations.all {
        resolutionStrategy.capabilitiesResolution.withCapability(&quot;log4j:log4j&quot;) {
            select(candidates.first { it.id.let { id -&gt; id is ModuleComponentIdentifier &amp;&amp; id.module == &quot;log4j-over-slf4j&quot; } } )
            because(&quot;use slf4j in place of log4j&quot;)
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，如果您在类路径上具有多个<em>Slf4j绑定</em> ，则此方法也很好用：绑定<em>本质</em>上是不同的记录器实现，并且只需要一个。但是，所选的实现可能取决于要解决的配置。例如，对于测试， <code>slf4j-simple</code>可能就够了，但对于生产来说， <code>slf4-over-log4j</code>可能更好。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请查看<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ResolutionStrategy.html#capabilitiesResolution">功能解析API</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:component_metadata_rules"><a class="anchor" href="#sec:component_metadata_rules"></a> <a class="link" href="#sec:component_metadata_rules">使用组件元数据规则修复元数据</a></h4>
<div class="paragraph">
<p>从存储库中拉出的每个模块都具有与其关联的元数据，例如其组，名称，版本以及它提供的带有工件和依赖项的不同变体。有时，此元数据不完整或不正确。为了从构建脚本中处理这种不完整的元数据，Gradle提供了一个API来编写<em>组件元数据规则</em> 。这些规则在下载模块的元数据之后但在依赖关系解析中使用之前生效。</p>
</div>
<div class="sect4">
<h5 id="basics_of_writing_a_component_metadata_rule"><a class="anchor" href="#basics_of_writing_a_component_metadata_rule"></a> <a class="link" href="#basics_of_writing_a_component_metadata_rule">编写组件元数据规则的基础</a></h5>
<div class="paragraph">
<p>组件元数据规则应用于构建脚本的依赖关系块（ <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html">DependencyHandler</a> ）的组件（ <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.ComponentMetadataHandler.html">ComponentMetadataHandler</a> ）部分中。可以用两种不同的方式定义规则：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>直接在<em>组件</em>部分中应用它们时作为操作</p>
</li>
<li>
<p>作为实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.ComponentMetadataRule.html">ComponentMetadataRule</a>接口的隔离类</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>虽然将规则内联定义为动作可以方便实验，但通常建议将规则定义为单独的类。编写为隔离类的规则可以用注释<code>@CacheableRule</code>缓存其应用程序的结果，以便无需在每次解决依赖项时重新执行它们。</p>
</div>
<div class="exampleblock">
<div class="title">示例328可配置组件元数据规则的示例</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">TargetJvmVersionRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="directive">final</span> <span class="predefined-type">Integer</span> jvmVersion
    <span class="annotation">@Inject</span> TargetJvmVersionRule(<span class="predefined-type">Integer</span> jvmVersion) {
        <span class="local-variable">this</span>.jvmVersion = jvmVersion
    }

    <span class="annotation">@Inject</span> <span class="predefined-type">ObjectFactory</span> getObjects() { }

    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.withVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">compile</span><span class="delimiter">&quot;</span></span>) {
            attributes {
                attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, jvmVersion)
                attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_API))
            }
        }
    }
}
dependencies {
    components {
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">commons-io:commons-io</span><span class="delimiter">&quot;</span></span>, TargetJvmVersionRule) {
            params(<span class="integer">7</span>)
        }
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">commons-collections:commons-collections</span><span class="delimiter">&quot;</span></span>, TargetJvmVersionRule) {
            params(<span class="integer">8</span>)
        }
    }
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">commons-io:commons-io:2.6</span><span class="delimiter">&quot;</span></span>)
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">commons-collections:commons-collections:3.2.2</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class TargetJvmVersionRule @Inject constructor(val jvmVersion: Int) : ComponentMetadataRule {
    @Inject open fun getObjects(): ObjectFactory = throw UnsupportedOperationException()

    override fun execute(context: ComponentMetadataContext) {
        context.details.withVariant(&quot;compile&quot;) {
            attributes {
                attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, jvmVersion)
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_API))
            }
        }
    }
}
dependencies {
    components {
        withModule&lt;TargetJvmVersionRule&gt;(&quot;commons-io:commons-io&quot;) {
            params(7)
        }
        withModule&lt;TargetJvmVersionRule&gt;(&quot;commons-collections:commons-collections&quot;) {
            params(8)
        }
    }
    implementation(&quot;commons-io:commons-io:2.6&quot;)
    implementation(&quot;commons-collections:commons-collections:3.2.2&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从上面的示例可以看出，组件元数据规则是通过实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ComponentMetadataRule.html">ComponentMetadataRule</a>来定义的，该<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ComponentMetadataRule.html">组件</a>具有单个<code>execute</code>接收<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ComponentMetadataContext.html">ComponentMetadataContext</a>实例作为参数的方法。在此示例中，还通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/ActionConfiguration.html">ActionConfiguration</a>进一步配置了规则。通过在您的实现中使用构造函数来支持<code>ComponentMetadataRule</code>接受已配置的参数和需要注入的服务。</p>
</div>
<div class="paragraph">
<p>Gradle强制隔离实例<code>ComponentMetadataRule</code> 。这意味着所有参数必须为<code>Serializable</code>或可以隔离的已知Gradle类型。</p>
</div>
<div class="paragraph">
<p>此外，可以将Gradle服务注入您的<code>ComponentMetadataRule</code> 。因此，一旦有了构造函数，就必须对其进行注释<code>@javax.inject.Inject</code> 。通常需要使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a>服务来创建强类型值对象的实例，例如用于设置<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Attribute.html">Attribute</a>的值。<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/repositories/RepositoryResourceAccessor.html">RepositoryResourceAccessor</a>是一项有助于使用自定义元数据对组件元数据规则进行高级使用的服务。</p>
</div>
<div class="paragraph">
<p>组件元数据规则可以应用于所有模块- <code>all(rule)</code> -或所选模块- <code>withModule(groupAndName, rule)</code> 。通常，专门编写规则以丰富一个特定模块的元数据，因此<code>withModule</code> API应该是首选。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:component_metadata_rules_details"><a class="anchor" href="#sec:component_metadata_rules_details"></a> <a class="link" href="#sec:component_metadata_rules_details">元数据的哪些部分可以修改？</a></h5>
<div class="paragraph">
<p>组件元数据规则API面向<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle Module元数据</a>和构建脚本中的<em>依赖项</em> API支持的功能。编写规则与在构建脚本中定义依赖关系和工件之间的主要区别在于，组件元数据规则遵循Gradle Module元数据的结构，直接对<a href="#understanding-variant-selection">变体</a>进行操作。相反，在构建脚本中，您经常会同时影响多个变量的形状（例如，将<em>api</em>依赖项添加到Java库的<em>api</em>和<em>运行时</em>变量中，由<em>jar</em>任务生成的工件也添加到了这两个变量中） 。</p>
</div>
<div class="paragraph">
<p>变体可以通过以下方法进行修改：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>allVariants</code> ：修改组件的所有变体</p>
</li>
<li>
<p><code>withVariant(name)</code> ：修改由名称标识的单个变体</p>
</li>
<li>
<p><code>addVariant(name)</code>要么<code>addVariant(name, base)</code> ： <em>从头开始</em>或通过<em>复制</em>现有变体（基础）的详细信息向组件添加新变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以调整每个变体的以下详细信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标识变体的<a href="#sec:abm_configuration_attributes">属性</a> - <code>attributes {}</code>块</p>
</li>
<li>
<p>该变体提供的<a href="#declaring-component-capabilities">功能</a> - <code>withCapabilities { }</code>块</p>
</li>
<li>
<p>变体的<a href="#">依赖</a>项，包括<a href="#">丰富的版本</a> - <code>withDependencies {}</code>块</p>
</li>
<li>
<p>变体的<a href="#sec:adding-constraints-transitive-deps">依赖关系约束</a> ，包括<a href="#">丰富版本</a> - <code>withDependencyConstraints {}</code>块</p>
</li>
<li>
<p>构成变体实际内容的已发布文件的位置- <code>withFiles { }</code>块</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>整个组件的一些属性也可以更改：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>组件级属性</em> ，当前唯一有意义的属性是<code>org.gradle.status</code></p>
</li>
<li>
<p>影响<em>方案</em>解释的<em>地位方案</em> <code>org.gradle.status</code>选择版本时的属性</p>
</li>
<li>
<p><a href="#sec:declaring-capabilities-external-modules">通过虚拟平台</a>进行<a href="#sec:declaring-capabilities-external-modules">版本对齐</a>的<em>belongsTo</em>属性</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据模块元数据的格式，它以不同的方式映射到元数据的以变量为中心的表示形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果模块具有Gradle Module Metadata，则规则所基于的数据结构与您在模块的<code>.module</code>文件。</p>
</li>
<li>
<p>如果该模块仅发布于<code>.pom</code>元数据，派生出许多固定的变体，如<a href="#sub:maven-mapping-to-variants">POM文件到变体</a>的<a href="#sub:maven-mapping-to-variants">映射</a>部分中所述。</p>
</li>
<li>
<p>如果该模块仅发布了<code>ivy.xml</code>在文件中，可以访问文件中定义的<em>Ivy配置</em> ，而不是变体。它们的依赖性，依赖性约束和文件可以修改。此外， <code>addVariant(name, baseVariantOrConfiguration) { }</code>如果需要，可以使用API从<em>Ivy配置</em>派生变体（例如，可以使用此定义<a href="#sub:ivy-mapping-to-variants">Java库插件的<em>编译</em>和<em>运行时</em>变体</a> ）。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="when_to_use_component_metadata_rules"><a class="anchor" href="#when_to_use_component_metadata_rules"></a> <a class="link" href="#when_to_use_component_metadata_rules">何时使用组件元数据规则？</a></h5>
<div class="paragraph">
<p>通常，如果您考虑使用组件元数据规则来调整某个模块的元数据，则应首先检查该模块是否与Gradle Module Metadata（Gradle Module Metadata）（ <code>.module</code>文件）或仅传统元数据（ <code>.pom</code>要么<code>ivy.xml</code> ）。</p>
</div>
<div class="paragraph">
<p>如果使用Gradle Module Metadata发布了模块，则尽管有时仍然存在某些明显错误的情况，但元数据可能已完成。对于这些模块，只有在明确确定元数据本身存在问题的情况下，才应使用组件元数据规则。如果您对依赖项解决结果有疑问，则应首先检查是否可以通过声明<a href="#">带有丰富版本的依赖项约束</a>来解决问题。特别是，如果您正在开发要发布的库，则应记住，与组件元数据规则相比，依赖关系约束是作为您自己的库的元数据的一部分发布的。因此，在具有依赖关系约束的情况下，您可以自动与使用者共享依赖关系解决方案的解决方案，而组件元数据规则仅应用于自己的内部版本。</p>
</div>
<div class="paragraph">
<p>如果模块是使用传统元数据发布的（ <code>.pom</code>要么<code>ivy.xml</code>只有，没有<code>.module</code>文件），因为这些格式不支持变体或依赖项约束等功能，因此元数据很可能不完整。仍然，从概念上讲，这样的模块可以包含不同的变体，或者可能具有它们被忽略（或错误地定义为依赖项）的依赖项约束。在接下来的部分中，我们将探讨许多现有的oss模块，这些模块具有不完整的元数据以及添加缺失的元数据信息的规则。</p>
</div>
<div class="paragraph">
<p>根据经验，您应该考虑所编写的规则是否也适用于构建环境。也就是说，如果将规则应用到任何其他使用受其影响的模块的构建中，该规则是否仍会产生正确且有用的结果？</p>
</div>
</div>
<div class="sect4">
<h5 id="fixing_wrong_dependency_details"><a class="anchor" href="#fixing_wrong_dependency_details"></a> <a class="link" href="#fixing_wrong_dependency_details">修复错误的依赖项详细信息</a></h5>
<div class="paragraph">
<p>让我们以<a href="https://repo1.maven.org/maven2/jaxen/jaxen">Maven</a> Central上Jaxen XPath Engine的发布为例。版本1.1.3的pom在编译范围内声明了许多依赖关系，这些依赖关系实际上并不是编译所必需的。这些已在1.1.4 pom中删除。假设由于某种原因需要使用1.1.3，我们可以使用以下规则来修复元数据：</p>
</div>
<div class="exampleblock">
<div class="title">示例329删除未使用的Jaxen元数据依赖性的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">JaxenDependenciesRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.allVariants {
            withDependencies {
                removeAll { <span class="local-variable">it</span>.group <span class="keyword">in</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">dom4j</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">jdom</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">xerces</span><span class="delimiter">&quot;</span></span>,  <span class="string"><span class="delimiter">&quot;</span><span class="content">maven-plugins</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">xml-apis</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">xom</span><span class="delimiter">&quot;</span></span>] }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class JaxenDependenciesRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        context.details.allVariants {
            withDependencies {
                removeAll { it.group in listOf(&quot;dom4j&quot;, &quot;jdom&quot;, &quot;xerces&quot;,  &quot;maven-plugins&quot;, &quot;xml-apis&quot;, &quot;xom&quot;) }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>内<code>withDependencies</code>阻止，您可以访问依赖项的完整列表，并且可以使用Java集合界面上可用的所有方法来检查和修改该列表。此外，还有<code>add(notation, configureAction)</code>接受通常表示法的方法类似于在构建脚本中<a href="#">声明依赖项</a> 。依赖关系约束可以通过以下方式检查和修改<code>withDependencyConstraints</code>块。</p>
</div>
<div class="paragraph">
<p>如果仔细研究Jaxen 1.1.4 pom，我们会发现<em>dom4j</em> ， <em>jdom</em>和<em>xerces</em>依赖项仍然存在，但标记为<em>optional</em> 。podle中的可选依赖项不会由Gradle或Maven自动处理。原因是它们指示Jaxen库提供了一些<a href="#">可选的功能变体</a> ，这些<a href="#">变体</a>需要这些依赖项中的一个或多个，但是缺少这些功能是什么以及哪个依赖项属于哪个的信息。此类信息无法在pom文件中表示，而是通过变体和<a href="#declaring-component-capabilities">功能</a>在Gradle模块元数据中表示。因此，我们也可以在规则中添加此信息。</p>
</div>
<div class="exampleblock">
<div class="title">例子330。将可选功能添加到Jaxen元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">JaxenCapabilitiesRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.addVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">runtime-dom4j</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>) {
            withCapabilities {
                removeCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen</span><span class="delimiter">&quot;</span></span>)
                addCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen-dom4j</span><span class="delimiter">&quot;</span></span>, context.details.id.version)
            }
            withDependencies {
                add(<span class="string"><span class="delimiter">&quot;</span><span class="content">dom4j:dom4j:1.6.1</span><span class="delimiter">&quot;</span></span>)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class JaxenCapabilitiesRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        context.details.addVariant(&quot;runtime-dom4j&quot;, &quot;runtime&quot;) {
            withCapabilities {
                removeCapability(&quot;jaxen&quot;, &quot;jaxen&quot;)
                addCapability(&quot;jaxen&quot;, &quot;jaxen-dom4j&quot;, context.details.id.version)
            }
            withDependencies {
                add(&quot;dom4j:dom4j:1.6.1&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，我们首先使用<code>addVariant(name, baseVariant)</code>创建附加变量的方法，通过定义新功能<em>jaxen-dom4j</em>来表示Jaxen的可选dom4j集成功能，我们将其识别为<em>特征变量</em> 。这类似于在构建脚本中<a href="#sec::declare_feature_variants">定义可选功能变体</a> 。然后，我们使用<code>add</code>添加依赖项以定义此可选功能需要哪些依赖项的方法。</p>
</div>
<div class="paragraph">
<p>然后，在构建脚本中，我们可以将<a href="#sec::consuming_feature_variants">依赖</a>项添加<a href="#sec::consuming_feature_variants">到可选功能中</a> ，Gradle将使用丰富的元数据来发现正确的传递性依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">示例331为Jaxen元数据应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    components {
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen:jaxen</span><span class="delimiter">&quot;</span></span>, JaxenDependenciesRule)
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen:jaxen</span><span class="delimiter">&quot;</span></span>, JaxenCapabilitiesRule)
    }
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen:jaxen:1.1.3</span><span class="delimiter">&quot;</span></span>)
    runtimeOnly(<span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen:jaxen:1.1.3</span><span class="delimiter">&quot;</span></span>) {
        capabilities { requireCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">jaxen:jaxen-dom4j</span><span class="delimiter">&quot;</span></span>) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    components {
        withModule&lt;JaxenDependenciesRule&gt;(&quot;jaxen:jaxen&quot;)
        withModule&lt;JaxenCapabilitiesRule&gt;(&quot;jaxen:jaxen&quot;)
    }
    implementation(&quot;jaxen:jaxen:1.1.3&quot;)
    runtimeOnly(&quot;jaxen:jaxen:1.1.3&quot;) {
        capabilities { requireCapability(&quot;jaxen:jaxen-dom4j&quot;) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="making_variants_published_as_classified_jars_explicit"><a class="anchor" href="#making_variants_published_as_classified_jars_explicit"></a> <a class="link" href="#making_variants_published_as_classified_jars_explicit">使发布为分类罐子的变体明确</a></h5>
<div class="paragraph">
<p>在上一个示例中，所有变体（“主要变体”和可选功能）都打包在一个jar文件中，但通常会将某些变体发布为单独的文件。尤其是，当变体互斥时-即它们<strong>不是</strong>功能变体，而是提供替代选择的不同变体。<strong>所有</strong>基于pom的库都已经存在的一个示例是<em>运行时</em>和<em>编译</em>变体，其中Gradle只能根据手头的任务选择一个。在Java生态系统中经常发现的此类替代方法中的另一个是针对不同Java版本的jar。</p>
</div>
<div class="paragraph">
<p>例如，我们看一下在<a href="https://repo1.maven.org/maven2/co/paralleluniverse/quasar-core/0.7.9">Maven</a> Central上发布的异步编程库Quasar的0.7.9版本。如果我们检查目录列表，我们会发现<code>quasar-core-0.7.9-jdk8.jar</code>除了出版<code>quasar-core-0.7.9.jar</code> 。在Maven存储库中，使用<em>分类器</em> （此处为<em>jdk8</em> ）发布其他jar是很常见的做法。尽管Maven和Gradle都允许您通过分类器引用此类jar，但它们在元数据中根本没有提及。因此，不存在这些罐子存在的信息，以及此类罐子所代表的变体之间是否存在其他差异（如不同的依赖项）。</p>
</div>
<div class="paragraph">
<p>在Gradle模块元数据中，将显示此变体信息，对于已经发布的Quasar库，我们可以使用以下规则添加它：</p>
</div>
<div class="exampleblock">
<div class="title">示例332将Jdk 8变体添加到Quasar元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">QuasarRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        [<span class="string"><span class="delimiter">&quot;</span><span class="content">compile</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>].each { base -&gt;
            context.details.addVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">jdk8</span><span class="inline"><span class="inline-delimiter">${</span>base.capitalize()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>, base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, <span class="integer">8</span>)
                }
                withFiles {
                    removeAllFiles()
                    addFile(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>context.details.id.name<span class="inline-delimiter">}</span></span><span class="content">-</span><span class="inline"><span class="inline-delimiter">${</span>context.details.id.version<span class="inline-delimiter">}</span></span><span class="content">-jdk8.jar</span><span class="delimiter">&quot;</span></span>)
                }
            }
            context.details.withVariant(base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, <span class="integer">7</span>)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class QuasarRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        listOf(&quot;compile&quot;, &quot;runtime&quot;).forEach { base -&gt;
            context.details.addVariant(&quot;jdk8${base.capitalize()}&quot;, base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
                }
                withFiles {
                    removeAllFiles()
                    addFile(&quot;${context.details.id.name}-${context.details.id.version}-jdk8.jar&quot;)
                }
            }
            context.details.withVariant(base) {
                attributes {
                    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 7)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，很明显，分类器代表目标Java版本，这是<a href="#sec:variant-aware-matching">已知的Java生态系统属性</a> 。因为我们还需要Java 8的<em>编译</em>和<em>运行时</em> ，所以我们创建了两个新的变体，但将现有的<em>编译</em>和<em>运行时</em>变体用作<em>base</em> 。这样，所有其他Java生态系统属性已经正确设置，并且所有依赖项都被继承。然后我们设置<code>TARGET_JVM_VERSION_ATTRIBUTE</code>至<code>8</code>对于这两个变体，请使用以下命令从新变体中删除所有现有文件： <code>removeAllFiles()</code> ，然后使用添加jdk8 jar文件<code>addFile()</code> 。的<code>removeAllFiles()</code>是必需的，因为对主jar的引用<code>quasar-core-0.7.5.jar</code>从相应的基本变体复制。</p>
</div>
<div class="paragraph">
<p>我们还将针对Java 7的信息丰富了现有的<em>编译</em>和<em>运行时</em>变体- <code>attribute(TARGET_JVM_VERSION_ATTRIBUTE, 7)</code> 。</p>
</div>
<div class="paragraph">
<p>现在，我们可以为构建脚本中所有依赖于编译类路径的依赖项请求Java 8版本，并且Gradle会自动为每个库选择最合适的变体。对于Quasar，现在是<em>jdk8Compile</em>变体，它公开了<code>quasar-core-0.7.9-jdk8.jar</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例333类星元数据的应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.compileClasspath.attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, <span class="integer">8</span>)
}
dependencies {
    components {
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">co.paralleluniverse:quasar-core</span><span class="delimiter">&quot;</span></span>, QuasarRule)
    }
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">co.paralleluniverse:quasar-core:0.7.9</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations[&quot;compileClasspath&quot;].attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
}
dependencies {
    components {
        withModule&lt;QuasarRule&gt;(&quot;co.paralleluniverse:quasar-core&quot;)
    }
    implementation(&quot;co.paralleluniverse:quasar-core:0.7.9&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="making_variants_encoded_in_versions_explicit"><a class="anchor" href="#making_variants_encoded_in_versions_explicit"></a> <a class="link" href="#making_variants_encoded_in_versions_explicit">明确显示版本中编码的变体</a></h5>
<div class="paragraph">
<p>为同一个库发布多个替代项的另一种解决方案是使用流行的Guava库完成的版本控制模式。在这里，通过将分类器（而不是jar工件）附加到版本，每个新版本都会发布两次。以Guava 28为例，我们可以在<a href="https://repo1.maven.org/maven2/com/google/guava/guava">Maven</a> <em>Central上</em>找到<em>28.0-jre</em> （Java 8）和<em>28.0-android</em> （Java 6）版本。仅在使用pom元数据时使用此模式的优势在于，可以通过版本发现这两种变体。缺点是没有任何信息表明不同版本的后缀在语义上意味着什么。因此，在发生冲突的情况下，Gradle在比较版本字符串时只会选择最高版本。</p>
</div>
<div class="paragraph">
<p>将其转换为适当的变体会比较棘手，因为Gradle首先选择模块的版本，然后选择最合适的变体。因此，不直接支持将变体编码为版本的概念。但是，由于两个变体始终一起发布，因此我们可以假设文件实际上位于同一存储库中。由于它们是按照Maven存储库约定发布的，因此如果知道模块名称和版本，我们就知道每个文件的位置。我们可以编写以下规则：</p>
</div>
<div class="exampleblock">
<div class="title">示例334将Jdk 6和Jdk 8变体添加到Guava元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GuavaRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        <span class="keyword">def</span> variantVersion = context.details.id.version
        <span class="keyword">def</span> version = variantVersion.substring(<span class="integer">0</span>, variantVersion.indexOf(<span class="string"><span class="delimiter">&quot;</span><span class="content">-</span><span class="delimiter">&quot;</span></span>))
        [<span class="string"><span class="delimiter">&quot;</span><span class="content">compile</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>].each { base -&gt;
            [<span class="integer">6</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">android</span><span class="delimiter">&quot;</span></span>, <span class="integer">8</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">jre</span><span class="delimiter">&quot;</span></span>].each { targetJvmVersion, jarName -&gt;
                context.details.addVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">jdk</span><span class="inline"><span class="inline-delimiter">$</span>targetJvmVersion</span><span class="inline"><span class="inline-delimiter">${</span>base.capitalize()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>, base) {
                    attributes {
                        attributes.attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, targetJvmVersion)
                    }
                    withFiles {
                        removeAllFiles()
                        addFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">guava-</span><span class="inline"><span class="inline-delimiter">$</span>version</span><span class="content">-</span><span class="inline"><span class="inline-delimiter">${</span>jarName<span class="inline-delimiter">}</span></span><span class="content">.jar</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">../</span><span class="inline"><span class="inline-delimiter">$</span>version</span><span class="content">-</span><span class="inline"><span class="inline-delimiter">$</span>jarName</span><span class="content">/guava-</span><span class="inline"><span class="inline-delimiter">$</span>version</span><span class="content">-</span><span class="inline"><span class="inline-delimiter">${</span>jarName<span class="inline-delimiter">}</span></span><span class="content">.jar</span><span class="delimiter">&quot;</span></span>)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GuavaRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        val variantVersion = context.details.id.version
        val version = variantVersion.substring(0, variantVersion.indexOf(&quot;-&quot;))
        listOf(&quot;compile&quot;, &quot;runtime&quot;).forEach { base -&gt;
            mapOf(6 to &quot;android&quot;, 8 to &quot;jre&quot;).forEach { (targetJvmVersion, jarName) -&gt;
                context.details.addVariant(&quot;jdk$targetJvmVersion${base.capitalize()}&quot;, base) {
                    attributes {
                        attributes.attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, targetJvmVersion)
                    }
                    withFiles {
                        removeAllFiles()
                        addFile(&quot;guava-$version-$jarName.jar&quot;, &quot;../$version-$jarName/guava-$version-$jarName.jar&quot;)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与前面的示例类似，我们为两个Java版本都添加了运行时和编译变体。在里面<code>withFile</code>但是，我们现在还要为相应的jar文件指定一个相对路径，无论Gradle选择了<em>-jre</em>还是<em>-android</em>版本，它都允许Gradle查找该文件。路径始终相对于元数据的位置（在这种情况下， <code>pom</code> ）选择模块版本的文件。因此，使用此规则，番石榴28个“版本”都携带<em>jdk6</em>和<em>jdk8</em>变体。因此，Gradle解决哪个问题都没有关系。该变体以及正确的jar文件是根据请求确定的<code>TARGET_JVM_VERSION_ATTRIBUTE</code>值。</p>
</div>
<div class="exampleblock">
<div class="title">示例335适用于番石榴元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.compileClasspath.attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, <span class="integer">6</span>)
}
dependencies {
    components {
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.guava:guava</span><span class="delimiter">&quot;</span></span>, GuavaRule)
    }
    <span class="comment">// '23.3-android' and '23.3-jre' are now the same as both offer both variants</span>
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.guava:guava:23.3+</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations[&quot;compileClasspath&quot;].attributes {
    attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 6)
}
dependencies {
    components {
        withModule&lt;GuavaRule&gt;(&quot;com.google.guava:guava&quot;)
    }
    // '23.3-android' and '23.3-jre' are now the same as both offer both variants
    implementation(&quot;com.google.guava:guava:23.3+&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="adding_variants_for_native_jars"><a class="anchor" href="#adding_variants_for_native_jars"></a> <a class="link" href="#adding_variants_for_native_jars">为本地jar添加变体</a></h5>
<div class="paragraph">
<p>带有分类器的jar还用于将库中存在多个替代方案（例如本机代码）的部分与主要工件分离。例如，这是由轻量级Java游戏库（LWGJ）完成的，该库将一些特定于平台的jar发布到<a href="https://repo1.maven.org/maven2/org/lwjgl/lwjgl/3.2.3">Maven</a> Central，在运行时，除了主jar之外，总是需要其中一个。由于没有通过元数据关联多个工件的概念，因此无法在pom元数据中传达此信息。在Gradle模块元数据中，每个变体可以具有任意多个文件，我们可以通过编写以下规则来利用它：</p>
</div>
<div class="exampleblock">
<div class="title">示例336将本地运行时变体添加到LWGJ元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">LwjglRule</span> <span class="directive">implements</span> ComponentMetadataRule { <span class="comment">//val os: String, val arch: String, val classifier: String)</span>
    <span class="directive">private</span> <span class="keyword">def</span> nativeVariants = [
        [<span class="key">os</span>: OperatingSystemFamily.LINUX,   <span class="key">arch</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">arm32</span><span class="delimiter">&quot;</span></span>,  <span class="key">classifier</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">natives-linux-arm32</span><span class="delimiter">&quot;</span></span>],
        [<span class="key">os</span>: OperatingSystemFamily.LINUX,   <span class="key">arch</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">arm64</span><span class="delimiter">&quot;</span></span>,  <span class="key">classifier</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">natives-linux-arm64</span><span class="delimiter">&quot;</span></span>],
        [<span class="key">os</span>: OperatingSystemFamily.WINDOWS, <span class="key">arch</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>,    <span class="key">classifier</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">natives-windows-x86</span><span class="delimiter">&quot;</span></span>],
        [<span class="key">os</span>: OperatingSystemFamily.WINDOWS, <span class="key">arch</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">x86-64</span><span class="delimiter">&quot;</span></span>, <span class="key">classifier</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">natives-windows</span><span class="delimiter">&quot;</span></span>],
        [<span class="key">os</span>: OperatingSystemFamily.MACOS,   <span class="key">arch</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">x86-64</span><span class="delimiter">&quot;</span></span>, <span class="key">classifier</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">natives-macos</span><span class="delimiter">&quot;</span></span>]
    ]

    <span class="annotation">@Inject</span> <span class="predefined-type">ObjectFactory</span> getObjects() { }

    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.withVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>) {
            attributes {
                attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named(OperatingSystemFamily, <span class="string"><span class="delimiter">&quot;</span><span class="content">none</span><span class="delimiter">&quot;</span></span>))
                attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, objects.named(MachineArchitecture, <span class="string"><span class="delimiter">&quot;</span><span class="content">none</span><span class="delimiter">&quot;</span></span>))
            }
        }
        nativeVariants.each { variantDefinition -&gt;
            context.details.addVariant(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>variantDefinition.classifier<span class="inline-delimiter">}</span></span><span class="content">-runtime</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>) {
                attributes {
                    attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named(OperatingSystemFamily, variantDefinition.os))
                    attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, objects.named(MachineArchitecture, variantDefinition.arch))
                }
                withFiles {
                    addFile(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>context.details.id.name<span class="inline-delimiter">}</span></span><span class="content">-</span><span class="inline"><span class="inline-delimiter">${</span>context.details.id.version<span class="inline-delimiter">}</span></span><span class="content">-</span><span class="inline"><span class="inline-delimiter">${</span>variantDefinition.classifier<span class="inline-delimiter">}</span></span><span class="content">.jar</span><span class="delimiter">&quot;</span></span>)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class LwjglRule: ComponentMetadataRule {
    data class NativeVariant(val os: String, val arch: String, val classifier: String)

    private val nativeVariants = listOf(
        NativeVariant(OperatingSystemFamily.LINUX,   &quot;arm32&quot;,  &quot;natives-linux-arm32&quot;),
        NativeVariant(OperatingSystemFamily.LINUX,   &quot;arm64&quot;,  &quot;natives-linux-arm64&quot;),
        NativeVariant(OperatingSystemFamily.WINDOWS, &quot;x86&quot;,    &quot;natives-windows-x86&quot;),
        NativeVariant(OperatingSystemFamily.WINDOWS, &quot;x86-64&quot;, &quot;natives-windows&quot;),
        NativeVariant(OperatingSystemFamily.MACOS,   &quot;x86-64&quot;, &quot;natives-macos&quot;)
    )

    @Inject open fun getObjects(): ObjectFactory = throw UnsupportedOperationException()

    override fun execute(context: ComponentMetadataContext) {
        context.details.withVariant(&quot;runtime&quot;) {
            attributes {
                attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, getObjects().named(&quot;none&quot;))
                attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, getObjects().named(&quot;none&quot;))
            }
        }
        nativeVariants.forEach { variantDefinition -&gt;
            context.details.addVariant(&quot;${variantDefinition.classifier}-runtime&quot;, &quot;runtime&quot;) {
                attributes {
                    attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, getObjects().named(variantDefinition.os))
                    attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, getObjects().named(variantDefinition.arch))
                }
                withFiles {
                    addFile(&quot;${context.details.id.name}-${context.details.id.version}-${variantDefinition.classifier}.jar&quot;)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此规则与上面的Quasar库示例非常相似。仅这次，我们添加了五个不同的运行时变体，而对于编译变体则无需更改。运行时变体全部基于现有的<em>运行时</em>变体，并且我们不更改任何现有信息。所有Java生态系统属性，依赖项和主jar文件都属于每个运行时变体的一部分。我们只设置其他属性<code>OPERATING_SYSTEM_ATTRIBUTE</code>和<code>ARCHITECTURE_ATTRIBUTE</code>定义为Gradle <a href="#">本机支持的一部分</a> 。然后，我们添加相应的本机jar文件，以便每个运行时变体现在都包含两个文件：主jar和本机jar。</p>
</div>
<div class="paragraph">
<p>在构建脚本中，我们现在可以请求特定的变体，如果需要更多信息来做出决定，则Gradle将失败，并出现选择错误。</p>
</div>
<div class="exampleblock">
<div class="title">示例337LWGJ元数据的应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations[<span class="string"><span class="delimiter">&quot;</span><span class="content">runtimeClasspath</span><span class="delimiter">&quot;</span></span>].attributes {
    attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named(OperatingSystemFamily, <span class="string"><span class="delimiter">&quot;</span><span class="content">windows</span><span class="delimiter">&quot;</span></span>))
}
dependencies {
    components {
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.lwjgl:lwjgl</span><span class="delimiter">&quot;</span></span>, LwjglRule)
    }
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.lwjgl:lwjgl:3.2.3</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations[&quot;runtimeClasspath&quot;].attributes {
    attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, objects.named(&quot;windows&quot;))
}
dependencies {
    components {
        withModule&lt;LwjglRule&gt;(&quot;org.lwjgl:lwjgl&quot;)
    }
    implementation(&quot;org.lwjgl:lwjgl:3.2.3&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle无法选择变体，因为需要选择机器架构</div>
<div class="content">
<pre>&gt; Could not resolve all files for configuration ':runtimeClasspath'.
   &gt; Could not resolve org.lwjgl:lwjgl:3.2.3.
     Required by:
         project :
      &gt; Cannot choose between the following variants of org.lwjgl:lwjgl:3.2.3:
          - natives-windows-runtime
          - natives-windows-x86-runtime</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="making_different_flavors_of_a_library_available_through_capabilities"><a class="anchor" href="#making_different_flavors_of_a_library_available_through_capabilities"></a> <a class="link" href="#making_different_flavors_of_a_library_available_through_capabilities">通过功能提供不同风格的库</a></h5>
<div class="paragraph">
<p>由于很难将<a href="#">可选功能变量</a>建模为带有pom元数据的单独jar，因此库有时会组成具有不同功能集的不同jar。也就是说，不是从不同的功能变体中组合出库的风格，而是选择一种预先组合的变体（在一个jar中提供所有内容）。这样的库之一就是著名的依赖注入框架Guice，它在<a href="https://repo1.maven.org/maven2/com/google/inject/guice/4.2.2">Maven</a> Central上发布，提供了完整的风格（主jar）和简化的变体，而没有面向方面的编程支持（ <code>guice-4.2.2-no_aop.jar</code> ）。pom元数据中未提及带有分类器的第二个变体。使用以下规则，我们基于该文件创建编译和运行时变体，并通过名为<code>com.google.inject:guice-no_aop</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例338将no_aop功能变体添加到Guice元数据的规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GuiceRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        [<span class="string"><span class="delimiter">&quot;</span><span class="content">compile</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>].each { base -&gt;
            context.details.addVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">noAop</span><span class="inline"><span class="inline-delimiter">${</span>base.capitalize()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>, base) {
                withCapabilities {
                    addCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.inject</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">guice-no_aop</span><span class="delimiter">&quot;</span></span>, context.details.id.version)
                }
                withFiles {
                    removeAllFiles()
                    addFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">guice-</span><span class="inline"><span class="inline-delimiter">${</span>context.details.id.version<span class="inline-delimiter">}</span></span><span class="content">-no_aop.jar</span><span class="delimiter">&quot;</span></span>)
                }
                withDependencies {
                    removeAll { <span class="local-variable">it</span>.group == <span class="string"><span class="delimiter">&quot;</span><span class="content">aopalliance</span><span class="delimiter">&quot;</span></span> }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GuiceRule: ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        listOf(&quot;compile&quot;, &quot;runtime&quot;).forEach { base -&gt;
            context.details.addVariant(&quot;noAop${base.capitalize()}&quot;, base) {
                withCapabilities {
                    addCapability(&quot;com.google.inject&quot;, &quot;guice-no_aop&quot;, context.details.id.version)
                }
                withFiles {
                    removeAllFiles()
                    addFile(&quot;guice-${context.details.id.version}-no_aop.jar&quot;)
                }
                withDependencies {
                    removeAll { it.group == &quot;aopalliance&quot; }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>新的变体还依赖于标准化的aop接口库<code>aopalliance:aopalliance</code>删除，因为这些变体显然不需要。同样，这是无法在pom元数据中表达的信息。我们现在可以选择一个<code>guice-no_aop</code>变体，将获得正确的jar文件<strong>和</strong>正确的依赖关系。</p>
</div>
<div class="exampleblock">
<div class="title">示例339对Guice元数据应用和利用规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    components {
        withModule(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.inject:guice</span><span class="delimiter">&quot;</span></span>, GuiceRule)
    }
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.inject:guice:4.2.2</span><span class="delimiter">&quot;</span></span>) {
        capabilities { requireCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.inject:guice-no_aop</span><span class="delimiter">&quot;</span></span>) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    components {
        withModule&lt;GuiceRule&gt;(&quot;com.google.inject:guice&quot;)
    }
    implementation(&quot;com.google.inject:guice:4.2.2&quot;) {
        capabilities { requireCapability(&quot;com.google.inject:guice-no_aop&quot;) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="adding_missing_capabilities_to_detect_conflicts"><a class="anchor" href="#adding_missing_capabilities_to_detect_conflicts"></a> <a class="link" href="#adding_missing_capabilities_to_detect_conflicts">添加缺少的功能来检测冲突</a></h5>
<div class="paragraph">
<p>功能的另一种用法是表示两个不同的模块，例如<code>log4j</code>和<code>log4j-over-slf4j</code> ，提供同一事物的替代实现。通过声明两者均提供相同的功能，Gradle在依赖图中仅接受其中之一。此示例以及如何用组件元数据规则解决该示例，在<a href="#sec:declaring-capabilities-external-modules">功能建模</a>部分中进行了详细说明。</p>
</div>
</div>
<div class="sect4">
<h5 id="making_ivy_modules_variant_aware"><a class="anchor" href="#making_ivy_modules_variant_aware"></a> <a class="link" href="#making_ivy_modules_variant_aware">使常春藤模块能够感知变体</a></h5>
<div class="paragraph">
<p>具有常春藤元数据的模块默认情况下不具有变体。但是，可以将<em>常春藤配置</em>映射为变体，因为<code>addVariant(name, baseVariantOrConfiguration)</code>接受任何已发布为基础的Ivy配置。例如，这可用于定义运行时和编译变体。相应规则的示例可以在<a href="#sub:ivy-mapping-to-variants">此处</a>找到。常春藤配置的常春藤详细信息（例如，依赖关系和文件）也可以使用<code>withVariant(configurationName)</code> API。但是，修改Ivy配置上的属性或功能无效。</p>
</div>
<div class="paragraph">
<p>对于非常特定于Ivy的用例，组件元数据规则API还提供对仅在Ivy元数据中找到的其他详细信息的访问。这些可以通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html">IvyModuleDescriptor</a>接口获得，并且可以使用<code>getDescriptor(IvyModuleDescriptor)</code>在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ComponentMetadataContext.html">ComponentMetadataContext上</a> 。（请注意，对于其他类型的元数据，此方法返回null。）</p>
</div>
<div class="exampleblock">
<div class="title">示例340常春藤组件元数据规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">IvyComponentRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        val descriptor = context.getDescriptor(IvyModuleDescriptor)
        <span class="keyword">if</span> (descriptor != <span class="predefined-constant">null</span> &amp;&amp; descriptor.branch == <span class="string"><span class="delimiter">&quot;</span><span class="content">testing</span><span class="delimiter">&quot;</span></span>) {
            context.details.status = <span class="string"><span class="delimiter">&quot;</span><span class="content">rc</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class IvyComponentRule : ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        val descriptor = context.getDescriptor(IvyModuleDescriptor::class)
        if (descriptor != null &amp;&amp; descriptor.branch == &quot;testing&quot;) {
            context.details.status = &quot;rc&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="modifying_metadata_on_the_component_level_for_alignment"><a class="anchor" href="#modifying_metadata_on_the_component_level_for_alignment"></a> <a class="link" href="#modifying_metadata_on_the_component_level_for_alignment">在组件级别修改元数据以进行对齐</a></h5>
<div class="paragraph">
<p>尽管以上所有示例都对组件的变体进行了修改，但也可以对组件本身的元数据进行有限的修改。此信息可能会影响相关性解析期间模块的<a href="#">版本选择</a>过程，该过程在<a href="#">选择</a>组件的一个或多个变体<em>之前</em>执行。</p>
</div>
<div class="paragraph">
<p>组件上可用的第一个API是<code>belongsTo()</code>创建虚拟平台以对齐没有Gradle Module Metadata的多个模块的版本。在<a href="#sec:align-versions-virtual">对齐未随Gradle发行的模块版本</a>的部分中对此进行了详细说明。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:custom_status_scheme"><a class="anchor" href="#sec:custom_status_scheme"></a> <a class="link" href="#sec:custom_status_scheme">在组件级别上修改元数据以根据状态选择版本</a></h5>
<div class="paragraph">
<p>Gradle和Gradle模块元数据还允许在整个组件上设置属性，而不是单个变量。这些属性中的每一个都具有特殊的语义，因为它们影响版本选择，而版本选择是<em>在</em>变量选择<em>之前</em>完成的。尽管变体选择可以处理<a href="#sec:declaring_attributes">任何自定义属性</a> ，但版本选择仅考虑实现了特定语义的属性。目前，这里唯一有意义的属性是<code>org.gradle.status</code> 。因此，建议仅在组件级别修改此属性（如果有）。专用API <code>setStatus(value)</code>可用于此。为组件的所有变体修改另一个属性<code>withAllVariants { attributes {} }</code>应该代替使用。</p>
</div>
<div class="paragraph">
<p>解析<a href="#"><em>最新</em>版本选择器</a>时，将考虑模块的状态。特别， <code>latest.someStatus</code>将解析为具有状态的最高模块版本<code>someStatus</code>或更成熟的地位例如， <code>latest.integration</code>不论其状态如何，都会选择最高的模块版本（因为<code>integration</code>是最不成熟的状态，如下所述），而<code>latest.release</code>将选择状态最高的模块版本<code>release</code> 。</p>
</div>
<div class="paragraph">
<p>通过以下方式更改模块的<em>状态方案，</em>可以影响状态的解释： <code>setStatusScheme(valueList)</code> API。这个概念模拟了模块在不同出版物中随着时间推移而转变的不同成熟度。默认状态方案（从最小状态到最大状态）为<code>integration</code> ， <code>milestone</code> ， <code>release</code> 。的<code>org.gradle.status</code>必须将属性设置为组件状态方案中的值之一。因此，每个组件始终具有从元数据确定的状态，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle模块元数据：为以下项目发布的值<code>org.gradle.status</code>组件上的属性</p>
</li>
<li>
<p>常春藤元数据： <code>status</code>在ivy.xml中定义，默认为<code>integration</code>如果丢失</p>
</li>
<li>
<p>Pom元数据： <code>integration</code>对于SNAPSHOT版本的模块， <code>release</code>对于其他所有人</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例演示<code>latest</code>基于在适用于所有模块的组件元数据规则中声明的自定义状态方案的选择器：</p>
</div>
<div class="exampleblock">
<div class="title">示例341自定义状态方案</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">CustomStatusRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.statusScheme = [<span class="string"><span class="delimiter">&quot;</span><span class="content">nightly</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">milestone</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">rc</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">release</span><span class="delimiter">&quot;</span></span>]
        <span class="keyword">if</span> (context.details.status == <span class="string"><span class="delimiter">&quot;</span><span class="content">integration</span><span class="delimiter">&quot;</span></span>) {
            context.details.status = <span class="string"><span class="delimiter">&quot;</span><span class="content">nightly</span><span class="delimiter">&quot;</span></span>
        }
    }
}

dependencies {
    components {
        all(CustomStatusRule)
    }
    implementation(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons:commons-lang3:latest.rc</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class CustomStatusRule : ComponentMetadataRule {
    override fun execute(context: ComponentMetadataContext) {
        context.details.statusScheme = listOf(&quot;nightly&quot;, &quot;milestone&quot;, &quot;rc&quot;, &quot;release&quot;)
        if (context.details.status == &quot;integration&quot;) {
            context.details.status = &quot;nightly&quot;
        }
    }
}

dependencies {
    components {
        all&lt;CustomStatusRule&gt;()
    }
    implementation(&quot;org.apache.commons:commons-lang3:latest.rc&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与默认方案相比，该规则将插入新状态<code>rc</code>并替换<code>integration</code>与<code>nightly</code> 。现有模块的状态<code>integration</code>映射到<code>nightly</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resolution_rules"><a class="anchor" href="#resolution_rules"></a> <a class="link" href="#resolution_rules">直接自定义依赖项的解析</a></h4>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>本节介绍Gradle提供的直接影响依赖关系解析引擎行为的机制。与本章介绍的其他概念（例如<a href="#">依赖项约束</a>或<a href="#">组件元数据规则）不同</a> ，它们都是解析的<strong>输入</strong> ，以下机制使您可以编写直接注入解析引擎的规则。因此，它们可以看作是<em>蛮力</em>解决方案，可能会隐藏未来的问题（例如，如果添加了新的依赖项）。因此，一般建议仅在其他手段不足的情况下使用以下机制。如果要编写<a href="#">库</a> ，则应始终首选<a href="#">依赖项约束，</a>因为它们是为用户发布的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="sec:dependency_resolve_rules"><a class="anchor" href="#sec:dependency_resolve_rules"></a> <a class="link" href="#sec:dependency_resolve_rules">使用依赖关系解决规则</a></h5>
<div class="paragraph">
<p>为每个已解析的依赖项执行一个依赖项解析规则，并提供了一个强大的api，用于在解析依赖项之前处理请求的依赖项。该功能当前提供了更改请求的依赖项的组，名称和/或版本的功能，从而允许在解析过程中将依赖项替换为完全不同的模块。</p>
</div>
<div class="paragraph">
<p>依赖关系解析规则提供了一种非常强大的方法来控制依赖关系解析过程，并且可用于实现依赖关系管理中的各种高级模式。下面概述了其中一些模式。或更多信息和代码示例，请参阅API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.ResolutionStrategy.html">ResolutionStrategy</a>类。</p>
</div>
<div class="sect5">
<h6 id="sec:custom_versioning_scheme"><a class="anchor" href="#sec:custom_versioning_scheme"></a> <a class="link" href="#sec:custom_versioning_scheme">实施自定义版本控制方案</a></h6>
<div class="paragraph">
<p>在某些公司环境中，可以在Gradle构建中声明的模块版本列表由外部维护和审核。依赖关系解析规则提供了该模式的巧妙实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在构建脚本中，开发人员使用模块组和名称声明依赖关系，但使用占位符版本，例如： <code>default</code> 。</p>
</li>
<li>
<p>的<code>default</code>通过依赖关系解析规则将版本解析为特定版本，该规则在已批准模块的公司目录中查找该版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以将规则实施整齐地封装在公司插件中，并在组织内的所有内部版本之间共享。</p>
</div>
<div class="exampleblock">
<div class="title">示例342使用自定义版本控制方案</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span class="keyword">if</span> (details.requested.version == <span class="string"><span class="delimiter">'</span><span class="content">default</span><span class="delimiter">'</span></span>) {
            <span class="keyword">def</span> version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)
            details.useVersion version.version
            details.because version.because
        }
    }
}

<span class="keyword">def</span> <span class="function">findDefaultVersionInCatalog</span>(<span class="predefined-type">String</span> group, <span class="predefined-type">String</span> name) {
    <span class="comment">//some custom logic that resolves the default version into a specific version</span>
    [<span class="key">version</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">1.0</span><span class="delimiter">&quot;</span></span>, <span class="key">because</span>: <span class="string"><span class="delimiter">'</span><span class="content">tested by QA</span><span class="delimiter">'</span></span>]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    resolutionStrategy.eachDependency {
        if (requested.version == &quot;default&quot;) {
            val version = findDefaultVersionInCatalog(requested.group, requested.name)
            useVersion(version.version)
            because(version.because)
        }
    }
}

data class DefaultVersion(val version: String, val because: String)

fun findDefaultVersionInCatalog(group: String, name: String): DefaultVersion {
    //some custom logic that resolves the default version into a specific version
    return DefaultVersion(version = &quot;1.0&quot;, because = &quot;tested by QA&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:blacklisting_version"><a class="anchor" href="#sec:blacklisting_version"></a> <a class="link" href="#sec:blacklisting_version">将特定版本列入黑名单并进行替换</a></h6>
<div class="paragraph">
<p>依赖关系解析规则提供了一种机制，可以将特定版本的依赖关系列入黑名单并提供替换版本。如果某个依赖项版本已损坏并且不应使用，当依赖项解析规则导致该版本被已知的良好版本替换时，这将很有用。损坏的模块的一个示例是声明对某个库的依赖关系，该依赖关系在任何公共存储库中都找不到，但是还有许多其他原因导致特定模块版本是不需要的，而首选其他版本。</p>
</div>
<div class="paragraph">
<p>在下面的示例中，假设该版本<code>1.2.1</code>包含重要的修复程序，应始终优先使用<code>1.2</code> 。提供的规则将强制执行以下操作：任何时间版本<code>1.2</code>遇到它将被替换为<code>1.2.1</code> 。请注意，这与如上所述的强制版本不同，因为此模块的任何其他版本都不会受到影响。这意味着“最新”冲突解决策略仍会选择版本<code>1.3</code>如果此版本也被移交。</p>
</div>
<div class="exampleblock">
<div class="title">例子343。示例：将替换版本列入黑名单</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span class="keyword">if</span> (details.requested.group == <span class="string"><span class="delimiter">'</span><span class="content">org.software</span><span class="delimiter">'</span></span> &amp;&amp; details.requested.name == <span class="string"><span class="delimiter">'</span><span class="content">some-library</span><span class="delimiter">'</span></span> &amp;&amp; details.requested.version == <span class="string"><span class="delimiter">'</span><span class="content">1.2</span><span class="delimiter">'</span></span>) {
            details.useVersion <span class="string"><span class="delimiter">'</span><span class="content">1.2.1</span><span class="delimiter">'</span></span>
            details.because <span class="string"><span class="delimiter">'</span><span class="content">fixes critical bug in 1.2</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    resolutionStrategy.eachDependency {
        if (requested.group == &quot;org.software&quot; &amp;&amp; requested.name == &quot;some-library&quot; &amp;&amp; requested.version == &quot;1.2&quot;) {
            useVersion(&quot;1.2.1&quot;)
            because(&quot;fixes critical bug in 1.2&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>使用具有<a href="#rich-version-constraints">丰富版本约束</a>的<em>拒绝</em>指令是有区别的：如果在图中找到拒绝的版本，丰富的版本将导致构建失败，或者在使用动态依赖项时选择非拒绝的版本。在这里，我们<em>处理请求的版本</em> ，以便在找到被拒绝的版本时选择其他版本。换句话说，这是针对拒绝版本的<em>解决方案</em> ，而丰富版本限制允许声明<em>意图</em> （您不应使用此版本）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:module_replacement"><a class="anchor" href="#sec:module_replacement"></a> <a class="link" href="#sec:module_replacement">使用模块更换规则</a></h5>
<div class="paragraph">
<p>就<a href="#sub:capabilities">功能冲突</a>而言，最好表达模块<a href="#sub:capabilities">冲突</a> 。但是，如果没有声明这样的规则，或者您正在使用不支持功能的Gradle版本，则Gradle提供了解决这些问题的工具。</p>
</div>
<div class="paragraph">
<p>模块替换规则允许构建声明旧库已被新库替换。新图书馆取代旧图书馆的一个很好的例子是<code>google-collections</code> -> <code>guava</code>移民。创建Google馆藏的团队决定将模块名称从<code>com.google.collections:google-collections</code>进入<code>com.google.guava:guava</code> 。这在业界是一种合法的情况：团队需要能够更改其维护的产品名称，包括模块坐标。重命名模块坐标会影响冲突解决。</p>
</div>
<div class="paragraph">
<p>为了说明对解决冲突的影响，让我们考虑<code>google-collections</code> -> <code>guava</code>场景。这两个库都可能被拉到同一个依赖图中。例如， <em>我们的项目</em>取决于<code>guava</code>但<em>我们的</em>某些<em>依赖项</em>引入了旧版本的<code>google-collections</code> 。这可能会导致运行时错误，例如在测试或应用程序执行期间。Gradle不会自动解决<code>google-collections</code> -> <code>guava</code>冲突，因为它不被视为<em>版本冲突</em> 。这是因为两个库的模块坐标完全不同，并且在解决冲突时激活了冲突解决方案<code>group</code>和<code>module</code>坐标是相同的，但是在依赖关系图中有不同的版本（有关更多信息，请参阅冲突解决部分）。解决此问题的传统方法是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>声明排除规则，以避免引入<code>google-collections</code>图。这可能是最流行的方法。</p>
</li>
<li>
<p>避免引入旧式库的依赖项。</p>
</li>
<li>
<p>如果新版本不再引入旧版库，请升级依赖版本。</p>
</li>
<li>
<p>降级至<code>google-collections</code> 。不建议这样做，只是出于完整性考虑。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>传统方法行之有效，但它们不够笼统。例如，一个组织想要解决<code>google-collections</code> -> <code>guava</code>所有项目中的冲突解决问题。可以声明某些模块已被其他模块替代。这使组织能够将有关模块更换的信息包括在公司插件套件中，并全面解决企业中所有由Gradle支持的项目的问题。</p>
</div>
<div class="exampleblock">
<div class="title">示例344声明更换模块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    modules {
        module(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.collections:google-collections</span><span class="delimiter">&quot;</span></span>) {
            replacedBy(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.guava:guava</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">google-collections is now part of Guava</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    modules {
        module(&quot;com.google.collections:google-collections&quot;) {
            replacedBy(&quot;com.google.guava:guava&quot;, &quot;google-collections is now part of Guava&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多示例和详细API，请参阅DSL参考<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/dsl/ComponentMetadataHandler.html">ComponentMetadataHandler</a> 。</p>
</div>
<div class="paragraph">
<p>当我们声明那会发生什么<code>google-collections</code>被替换为<code>guava</code> ？Gradle可以使用此信息来解决冲突。Gradle会考虑每个版本的<code>guava</code>比任何版本的更新/更好<code>google-collections</code> 。另外，Gradle将确保在类路径/已解析文件列表中仅存在guava jar。请注意，如果仅<code>google-collections</code>出现在依赖关系图中（例如，否<code>guava</code> ）Gradle不会急于将其替换为<code>guava</code> 。模块更换是Gradle用于解决冲突的信息。如果没有冲突（例如<code>google-collections</code>或仅<code>guava</code>在图中）不使用替换信息。</p>
</div>
<div class="paragraph">
<p>当前不可能声明给定的模块被一组模块替换。但是，可以声明多个模块被单个模块替换。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:dependency_substitution_rules"><a class="anchor" href="#sec:dependency_substitution_rules"></a> <a class="link" href="#sec:dependency_substitution_rules">使用依赖替换规则</a></h5>
<div class="paragraph">
<p>依赖关系替换规则的工作方式与依赖关系解决规则相似。实际上，可以使用依赖关系替换规则来实现依赖关系解析规则的许多功能。它们允许将项目和模块依赖项透明地替换为指定的替换项。与依赖关系解析规则不同，依赖关系替换规则允许项目和模块依赖关系可以互换替换。</p>
</div>
<div class="paragraph">
<p><em>在配置中添加依赖项替换规则会更改解析该配置的时间。</em>在构造任务图时，无需解析首次使用的配置，而是解析配置。如果在任务执行期间对配置进行了进一步修改，或者配置依赖于在执行另一任务期间发布的模块，则可能会产生意想不到的后果。</p>
</div>
<div class="paragraph">
<p>解释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>Configuration</code>可以声明为任何Task的输入，并且该配置在解决时可以包括项目依赖项。</p>
</li>
<li>
<p>如果项目依赖项是任务的输入（通过配置），则必须将用于构建项目工件的任务添加到任务依赖项中。</p>
</li>
<li>
<p>为了确定作为任务输入的项目依赖关系，Gradle需要解决<code>Configuration</code>输入。</p>
</li>
<li>
<p>由于Gradle任务图在任务执行开始后便是固定的，因此Gradle需要在执行任何任务之前执行此解决方案。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在没有依赖替换规则的情况下，Gradle知道外部模块依赖永远不会传递引用项目依赖。通过简单的图形遍历，可以轻松确定配置的项目依赖项的完整集合。使用此功能，Gradle不能再进行此假设，并且必须执行完全解析才能确定项目依赖项。</p>
</div>
<div class="sect5">
<h6 id="sub:module_to_project_substitution"><a class="anchor" href="#sub:module_to_project_substitution"></a> <a class="link" href="#sub:module_to_project_substitution">将外部模块依赖项替换为项目依赖项</a></h6>
<div class="paragraph">
<p>一种替代依赖的用例是使用模块的本地开发版本来代替从外部存储库下载的模块。这对于测试依赖项的本地修补版本可能很有用。</p>
</div>
<div class="paragraph">
<p>可以在指定版本或不指定版本的情况下声明要替换的模块。</p>
</div>
<div class="exampleblock">
<div class="title">示例345用项目替换模块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute module(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.utils:api</span><span class="delimiter">&quot;</span></span>) because <span class="string"><span class="delimiter">&quot;</span><span class="content">we work with the unreleased development version</span><span class="delimiter">&quot;</span></span> with project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:api</span><span class="delimiter">&quot;</span></span>)
        substitute module(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.utils:util:2.5</span><span class="delimiter">&quot;</span></span>) with project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:util</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute(module(&quot;org.utils:api&quot;)).apply {
            with(project(&quot;:api&quot;))
            because(&quot;we work with the unreleased development version&quot;)
        }
        substitute(module(&quot;org.utils:util:2.5&quot;)).with(project(&quot;:util&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，替代项目必须包含在多项目构建中（通过<code>settings.gradle</code> ）。依赖关系替换规则负责将模块依赖关系替换为项目依赖关系，并连接所有任务依赖关系，但不将项目隐式包含在构建中。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:project_to_module_substitution"><a class="anchor" href="#sub:project_to_module_substitution"></a> <a class="link" href="#sub:project_to_module_substitution">用模块替换代替项目依赖</a></h6>
<div class="paragraph">
<p>使用替换规则的另一种方法是用多项目构建中的模块替换项目依赖项。通过允许从存储库下载而不是构建项目依赖项的子集，这对于加快大型多项目构建的开发速度很有用。</p>
</div>
<div class="paragraph">
<p>必须使用指定的版本声明要用作替换模块的模块。</p>
</div>
<div class="exampleblock">
<div class="title">实施例346。用模块替换项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:api</span><span class="delimiter">&quot;</span></span>) because <span class="string"><span class="delimiter">&quot;</span><span class="content">we use a stable version of org.utils:api</span><span class="delimiter">&quot;</span></span> with module(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.utils:api:1.3</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute(project(&quot;:api&quot;)).apply {
            with(module(&quot;org.utils:api:1.3&quot;))
            because(&quot;we use a stable version of org.utils:api&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当项目依赖关系已替换为模块依赖关系时，该项目仍将包含在整个多项目构建中。但是，为了解决依赖关系，将不会执行构建替换后的依赖关系的任务<code>Configuration</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:conditional_dependency_substitution"><a class="anchor" href="#sub:conditional_dependency_substitution"></a> <a class="link" href="#sub:conditional_dependency_substitution">有条件地替换依赖</a></h6>
<div class="paragraph">
<p>依赖替换的一个常见用例是允许在多项目构建中更灵活地组装子项目。这对于开发外部依赖的本地修补版本或在大型多项目构建中构建模块的子集很有用。</p>
</div>
<div class="paragraph">
<p>以下示例使用依赖关系替换规则将任何模块依赖关系替换为组<code>org.example</code> ，但前提是必须找到与依赖项名称匹配的本地项目。</p>
</div>
<div class="exampleblock">
<div class="title">示例347有条件地替换依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    configurations.all {
        resolutionStrategy.dependencySubstitution.all { DependencySubstitution dependency -&gt;
            <span class="keyword">if</span> (dependency.requested <span class="keyword">instanceof</span> ModuleComponentSelector &amp;&amp; dependency.requested.group == <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>) {
                <span class="keyword">def</span> targetProject = findProject(<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="inline"><span class="inline-delimiter">${</span>dependency.requested.module<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
                <span class="keyword">if</span> (targetProject != <span class="predefined-constant">null</span>) {
                    dependency.useTarget targetProject
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    configurations.all {
        resolutionStrategy.dependencySubstitution.all {
            requested.let {
                if (it is ModuleComponentSelector &amp;&amp; it.group == &quot;org.example&quot;) {
                    val targetProject = findProject(&quot;:${it.module}&quot;)
                    if (targetProject != null) {
                        useTarget(targetProject)
                    }
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，替代项目必须包含在多项目构建中（通过<code>settings.gradle</code> ）。依赖关系替换规则负责将模块依赖关系替换为项目依赖关系，但不将项目隐式包含在构建中。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:disabling_resolution_transitive_dependencies"><a class="anchor" href="#sec:disabling_resolution_transitive_dependencies"></a> <a class="link" href="#sec:disabling_resolution_transitive_dependencies">禁用传递解析</a></h5>
<div class="paragraph">
<p>默认情况下，Gradle解析依赖项元数据指定的所有传递依赖项。有时，例如，如果元数据不正确或定义了较大的传递依赖关系图，则此行为可能是不希望的。您可以通过将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ModuleDependency.html#setTransitive-boolean-">ModuleDependency.setTransitive（boolean）</a>设置为来告诉Gradle为依赖项禁用传递依赖项管理<code>false</code> 。结果，只有主工件才可以解决声明的依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">示例348。为声明的依赖项禁用传递依赖项解析</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">com.google.guava:guava:23.0</span><span class="delimiter">'</span></span>) {
        transitive = <span class="predefined-constant">false</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;com.google.guava:guava:23.0&quot;) {
        isTransitive = false
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>禁用传递依赖关系解析可能需要您在构建脚本中声明必要的运行时依赖关系，否则将自动解决。否则可能会导致运行时类路径问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>项目可以决定完全禁用传递依赖项解析。您或者不想依赖发布到使用的存储库的元数据，或者想要完全控制图形中的依赖项。有关更多信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/Configuration.html#setTransitive-boolean-">Configuration.setTransitive（boolean）</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例349。在配置级别禁用传递依赖项解析</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations.all {
    transitive = <span class="predefined-constant">false</span>
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">com.google.guava:guava:23.0</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations.all {
    isTransitive = false
}

dependencies {
    implementation(&quot;com.google.guava:guava:23.0&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="changing_configuration_dependencies_prior_to_resolution"><a class="anchor" href="#changing_configuration_dependencies_prior_to_resolution"></a> <a class="link" href="#changing_configuration_dependencies_prior_to_resolution">在解决之前更改配置依赖性</a></h5>
<div class="paragraph">
<p>有时，插件可能要在解析配置之前先修改其相关性。的<code>withDependencies</code>方法允许以编程方式添加，删除或修改依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">示例350修改对配置的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    implementation {
        withDependencies { DependencySet dependencies -&gt;
            ExternalModuleDependency dep = dependencies.find { <span class="local-variable">it</span>.name == <span class="string"><span class="delimiter">'</span><span class="content">to-modify</span><span class="delimiter">'</span></span> } <span class="keyword">as</span> ExternalModuleDependency
            dep.version {
                strictly <span class="string"><span class="delimiter">&quot;</span><span class="content">1.2</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    create(&quot;implementation&quot;) {
        withDependencies {
            val dep = this.find { it.name == &quot;to-modify&quot; } as ExternalModuleDependency
            dep.version {
                strictly(&quot;1.2&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:configuration_defaults"><a class="anchor" href="#sec:configuration_defaults"></a> <a class="link" href="#sec:configuration_defaults">设置默认配置依赖项</a></h5>
<div class="paragraph">
<p>如果未为配置显式设置任何依赖项，则可以使用默认依赖项来配置配置。此功能的主要用例是开发使用用户可能会覆盖的版本控制工具的插件。通过指定默认依赖关系，只有在用户未指定要使用的特定版本时，插件才能使用该工具的默认版本。</p>
</div>
<div class="exampleblock">
<div class="title">示例351指定配置的默认依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    pluginTool {
        defaultDependencies { dependencies -&gt;
            dependencies.add(project.dependencies.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle:my-util:1.0</span><span class="delimiter">&quot;</span></span>))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    create(&quot;pluginTool&quot;) {
        defaultDependencies {
            add(project.dependencies.create(&quot;org.gradle:my-util:1.0&quot;))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="excluding_a_dependency_from_a_configuration_completely"><a class="anchor" href="#excluding_a_dependency_from_a_configuration_completely"></a> <a class="link" href="#excluding_a_dependency_from_a_configuration_completely">从配置中完全排除依赖项</a></h5>
<div class="paragraph">
<p>与<a href="#sec:excluding-transitive-deps">在依赖项声明</a>中排除<a href="#sec:excluding-transitive-deps">依赖项</a>类似，可以通过使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:exclude(java.util.Map)">Configuration.exclude（java.util。来完全排除特定配置的传递性依赖项</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:exclude(java.util.Map)">。地图）</a> 。对于配置上声明的所有依赖关系，这将自动排除传递依赖关系。</p>
</div>
<div class="exampleblock">
<div class="title">示例352排除特定配置的传递依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    implementation {
        exclude <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>, <span class="key">module</span>: <span class="string"><span class="delimiter">'</span><span class="content">commons-collections</span><span class="delimiter">'</span></span>
    }
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">commons-beanutils:commons-beanutils:1.9.4</span><span class="delimiter">'</span></span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">com.opencsv:opencsv:4.6</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    &quot;implementation&quot; {
        exclude(group = &quot;commons-collections&quot;, module = &quot;commons-collections&quot;)
    }
}

dependencies {
    implementation(&quot;commons-beanutils:commons-beanutils:1.9.4&quot;)
    implementation(&quot;com.opencsv:opencsv:4.6&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="matching_dependencies_to_repositories"><a class="anchor" href="#matching_dependencies_to_repositories"></a> <a class="link" href="#matching_dependencies_to_repositories">将依赖项与存储库进行匹配</a></h5>
<div class="paragraph">
<p>Gradle公开了一个API，以声明存储库可能包含或不包含的内容。此功能提供了对哪个存储库提供哪些工件的精细控制，这可以是控制依赖项来源的一种方法。</p>
</div>
<div class="paragraph">
<p>请转至<a href="#sec:repository-content-filtering">有关存储库内容过滤的部分，</a>以了解有关此功能的更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:ivy_dynamic_resolve_mode"><a class="anchor" href="#sec:ivy_dynamic_resolve_mode"></a> <a class="link" href="#sec:ivy_dynamic_resolve_mode">启用常春藤动态解析模式</a></h5>
<div class="paragraph">
<p>Gradle的Ivy存储库实现支持等同于Ivy的动态解析模式。通常，Gradle将使用<code>rev</code>包含在每个依赖项定义中的属性<code>ivy.xml</code>文件。在动态解析模式下，Gradle会更喜欢<code>revConstraint</code>的属性<code>rev</code>给定依赖项定义的属性。如果<code>revConstraint</code>属性不存在， <code>rev</code>改为使用属性。</p>
</div>
<div class="paragraph">
<p>要启用动态解析模式，您需要在存储库定义中设置适当的选项。下面显示了两个示例。请注意，动态解析模式仅适用于Gradle的Ivy存储库。它不适用于Maven存储库或自定义Ivy <code>DependencyResolver</code>实现。</p>
</div>
<div class="exampleblock">
<div class="title">示例353启用动态解析模式</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// Can enable dynamic resolve mode when you define the repository</span>
repositories {
    ivy {
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
        resolve.dynamicMode = <span class="predefined-constant">true</span>
    }
}

<span class="comment">// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories</span>
repositories.withType(IvyArtifactRepository) {
    resolve.dynamicMode = <span class="predefined-constant">true</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// Can enable dynamic resolve mode when you define the repository
repositories {
    ivy {
        url = uri(&quot;http://repo.mycompany.com/repo&quot;)
        resolve.isDynamicMode = true
    }
}

// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories
repositories.withType&lt;IvyArtifactRepository&gt; {
    resolve.isDynamicMode = true
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producing_and_consuming_variants_of_libraries"><a class="anchor" href="#producing_and_consuming_variants_of_libraries"></a> <a class="link" href="#producing_and_consuming_variants_of_libraries">图书馆的生产和消费形式</a></h3>
<div class="sect3">
<h4 id="declaring-component-capabilities"><a class="anchor" href="#declaring-component-capabilities"></a> <a class="link" href="#declaring-component-capabilities">声明图书馆的能力</a></h4>
<div class="sect4">
<h5 id="capabilities_as_first_level_concept"><a class="anchor" href="#capabilities_as_first_level_concept"></a> <a class="link" href="#capabilities_as_first_level_concept">能力是首要概念</a></h5>
<div class="paragraph">
<p>组件提供了许多功能，这些功能通常与用于提供这些功能的软件体系结构正交。例如，一个库可能在单个工件中包含多个功能。但是，这样的库将以单个GAV（组，工件和版本）坐标发布。这意味着，在单个坐标处，可能会共存组件的不同“特征”。</p>
</div>
<div class="paragraph">
<p>使用Gradle，显式声明组件提供的功能变得很有趣。为此，Gradle提供了<a href="#sec:adding-constraints-transitive-deps">功能</a>的概念。</p>
</div>
<div class="paragraph">
<p>通常通过组合不同的<em>功能</em>来构建<em>功能</em> 。</p>
</div>
<div class="paragraph">
<p>在理想情况下，组件不应声明对显式GAV的依赖，而应根据功能来表达其要求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“给我一个提供日志记录的组件”</p>
</li>
<li>
<p>“给我一个脚本引擎”</p>
</li>
<li>
<p>“给我一个支持Groovy的脚本引擎”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过对<em>功能进行</em>建模，依赖关系管理引擎可以更智能，并在依赖关系图中具有<em>不兼容功能</em>时告诉您，或者让您选择何时图中的不同模块提供相同<em>功能</em> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:declaring-capabilities-external-modules"><a class="anchor" href="#sec:declaring-capabilities-external-modules"></a> <a class="link" href="#sec:declaring-capabilities-external-modules">声明外部模块的功能</a></h5>
<div class="paragraph">
<p>值得注意的是，Gradle支持声明的功能可用于构建的组件，也可以声明外部组件的功能。</p>
</div>
<div class="paragraph">
<p>例如，如果您的构建文件包含以下依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">示例354具有日志框架隐式冲突的构建文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// This dependency will bring log4:log4j transitively</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.zookeeper:zookeeper:3.4.9</span><span class="delimiter">'</span></span>

    <span class="comment">// We use log4j over slf4j</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.slf4j:log4j-over-slf4j:1.7.10</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // This dependency will bring log4:log4j transitively
    implementation(&quot;org.apache.zookeeper:zookeeper:3.4.9&quot;)

    // We use log4j over slf4j
    implementation(&quot;org.slf4j:log4j-over-slf4j:1.7.10&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>照原样，很难确定您最终会在类路径上获得两个日志记录框架。事实上， <code>zookeeper</code>会带来<code>log4j</code> ，我们要使用的是<code>log4j-over-slf4j</code> 。我们可以通过添加一条规则来抢先检测冲突，该规则将声明两个日志记录框架提供相同的功能：</p>
</div>
<div class="exampleblock">
<div class="title">示例355具有日志框架隐式冲突的构建文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// Activate the &quot;LoggingCapability&quot; rule</span>
    components.all(LoggingCapability)
}

<span class="annotation">@CompileStatic</span>
<span class="type">class</span> <span class="class">LoggingCapability</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="directive">final</span> <span class="directive">static</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; LOGGING_MODULES = [<span class="string"><span class="delimiter">&quot;</span><span class="content">log4j</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">log4j-over-slf4j</span><span class="delimiter">&quot;</span></span>] <span class="keyword">as</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt;

    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.with {
            <span class="keyword">if</span> (LOGGING_MODULES.contains(id.name)) {
                allVariants {
                    <span class="local-variable">it</span>.withCapabilities {
                        <span class="comment">// Declare that both log4j and log4j-over-slf4j provide the same capability</span>
                        <span class="local-variable">it</span>.addCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">log4j</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">log4j</span><span class="delimiter">&quot;</span></span>, id.version)
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // Activate the &quot;LoggingCapability&quot; rule
    components.all(LoggingCapability::class.java)
}

class LoggingCapability : ComponentMetadataRule {
    val loggingModules = setOf(&quot;log4j&quot;, &quot;log4j-over-slf4j&quot;)

    override
    fun execute(context: ComponentMetadataContext) = context.details.run {
        if (loggingModules.contains(id.name)) {
            allVariants {
                withCapabilities {
                    // Declare that both log4j and log4j-over-slf4j provide the same capability
                    addCapability(&quot;log4j&quot;, &quot;log4j&quot;, id.version)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过添加此规则，我们将确保Gradle <em>将</em>检测到冲突并适当地失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; Could not resolve all files for configuration ':compileClasspath'.
   &gt; Could not resolve org.slf4j:log4j-over-slf4j:1.7.10.
     Required by:
         project :
      &gt; Module 'org.slf4j:log4j-over-slf4j' has been rejected:
           Cannot select module with conflict on capability 'log4j:log4j:1.7.10' also provided by [log4j:log4j:1.2.16(compile)]
   &gt; Could not resolve log4j:log4j:1.2.16.
     Required by:
         project : &gt; org.apache.zookeeper:zookeeper:3.4.9
      &gt; Module 'log4j:log4j' has been rejected:
           Cannot select module with conflict on capability 'log4j:log4j:1.2.16' also provided by [org.slf4j:log4j-over-slf4j:1.7.10(compile)]</pre>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="#sub:selecting-between-candidates">文档</a>的<a href="#sub:selecting-between-candidates">功能部分，</a>以了解如何解决功能冲突。</p>
</div>
</div>
<div class="sect4">
<h5 id="declaring_additional_capabilities_for_a_local_component"><a class="anchor" href="#declaring_additional_capabilities_for_a_local_component"></a> <a class="link" href="#declaring_additional_capabilities_for_a_local_component">声明本地组件的其他功能</a></h5>
<div class="paragraph">
<p>所有组件都具有与该组件相同的GAV坐标对应的<em>隐式功能</em> 。只要在不同GAV坐标处发布的库是同一API的<em>替代实现</em> ，这便很方便。但是，也可以为组件声明其他<em>显式功能</em> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例356声明组件的功能</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    apiElements {
        outgoing {
            capability(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme:my-library:1.0</span><span class="delimiter">&quot;</span></span>)
            capability(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.other:module:1.1</span><span class="delimiter">&quot;</span></span>)
        }
    }
    runtimeElements {
        outgoing {
            capability(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme:my-library:1.0</span><span class="delimiter">&quot;</span></span>)
            capability(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.other:module:1.1</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    apiElements {
        outgoing {
            capability(&quot;com.acme:my-library:1.0&quot;)
            capability(&quot;com.other:module:1.1&quot;)
        }
    }
    runtimeElements {
        outgoing {
            capability(&quot;com.acme:my-library:1.0&quot;)
            capability(&quot;com.other:module:1.1&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>功能必须附加到<em>传出配置</em> ， <em>传出配置</em>是组件的<a href="#sec:resolvable-consumable-configs">消耗性配置</a> 。</p>
</div>
<div class="paragraph">
<p>此示例显示我们声明了两个功能：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>com.acme:my-library:1.0</code> ，它对应于库的<em>隐式功能</em></p>
</li>
<li>
<p><code>com.other:module:1.1</code> ，它对应于此库的另一功能</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>值得注意的是，我们需要执行1.，因为一旦您开始声<em>明显式</em>功能，就需要声明<em>所有</em>功能，包括<em>隐式功能</em> 。</p>
</div>
<div class="paragraph">
<p>第二功能可以特定于此库，也可以对应于外部组件提供的功能。在这种情况下<code>com.other:module</code>如果出现在相同的依赖图中，构建将失败，使用者<a href="#sub:selecting-between-candidates">将必须选择要使用的模块</a> 。</p>
</div>
<div class="paragraph">
<p>功能已发布到Gradle模块元数据。但是，它们在POM或Ivy元数据文件中<em>没有等效项</em> 。因此，发布此类组件时，Gradle将警告您该功能仅适用于Gradle使用者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Maven publication 'maven' contains dependencies that cannot be represented in a published pom file.
  - Declares capability com.acme:my-library:1.0
  - Declares capability com.other:module:1.1</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="feature_variants"><a class="anchor" href="#feature_variants"></a> <a class="link" href="#feature_variants">建模功能变体和可选依赖项</a></h4>
<div class="paragraph">
<p>Gradle支持<em>功能变体</em>的概念：在构建库时，通常只有在存在某些依赖项或使用特殊工件时，某些功能才可用。</p>
</div>
<div class="paragraph">
<p>功能变体使消费者可以选择他们需要的库的哪些<em>功能</em> ：依赖性管理引擎将选择正确的工件和依赖性。</p>
</div>
<div class="paragraph">
<p>这考虑到了许多不同的情况（列表并不详尽）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>（更好）替代<a href="https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html">Maven可选依赖项</a></p>
</li>
<li>
<p>建立一个<em>主</em>库，以支持运行时功能的不同互斥实现； <a href="#sec::incompatible_variants">用户必须为每个这样的功能选择一个，并且只有一个实现</a></p>
</li>
<li>
<p>建立了一个<em>主</em>库，它支持可选的运行时功能，每个功能都需要一组不同的依赖项</p>
</li>
<li>
<p><em>主</em>库随附<em>测试夹具之</em>类的辅助变体</p>
</li>
<li>
<p><em>主</em>库附带一个主工件，而启用附加功能则需要附加工件</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="sec::feature_variant_selection"><a class="anchor" href="#sec::feature_variant_selection"></a> <a class="link" href="#sec::feature_variant_selection">选择功能变体和功能</a></h5>
<div class="paragraph">
<p>声明对组件的依赖性通常是通过提供一组坐标（组，工件，版本也称为GAV坐标）来完成的。这使引擎可以确定我们要寻找的<em>组件</em> ，但是这种组件可能提供不同的<em>变体</em> 。通常根据用途选择一个<em>变体</em> 。例如，我们可以选择其他变体来针对组件进行编译（在这种情况下，我们需要组件的API），或者在执行代码时（在这种情况下，我们需要组件的运行时）。组件的所有变体都提供许多<a href="#sub:capabilities">功能</a> ，这些<a href="#sub:capabilities">功能</a>使用GAV坐标类似地表示。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>功能由GAV坐标表示，但您必须将其视为特征描述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“我提供了SLF4J绑定”</p>
</li>
<li>
<p>“我为MySQL提供运行时支持”</p>
</li>
<li>
<p>“我提供一个Groovy运行时”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，在图中有两个提供<em>相同内容的</em>组件是一个问题（它们相互冲突）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是一个重要的概念，因为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>默认情况下，变体提供与其组件的GAV坐标相对应的功能</p>
</li>
<li>
<p>如果依赖关系图中提供相同的功能，则不允许它们具有不同的组件或组件的不同变体</p>
</li>
<li>
<p>只要它们提供<em>不同的功能</em> ，就可以选择同一组件的两个变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>典型的组件将<strong>仅</strong>提供具有默认功能的变体。例如，Java库公开了提供<em>相同功能的</em>两个变体（API和运行时）。结果，在依赖关系图中同时具有单个组件的<em>API</em>和<em>运行时</em>都是错误的。</p>
</div>
<div class="paragraph">
<p>但是，假设您需要组件的<em>运行时</em>和<em>测试夹具</em> 。然后，只要<em>库的运行时</em>和<em>测试夹具</em>变体声明了不同的功能，就可以允许它。</p>
</div>
<div class="paragraph">
<p>如果这样做，那么使用者将必须声明两个依赖项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个关于“主”变体的库</p>
</li>
<li>
<p>通过<em>要求其功能</em> ，在“测试装置”变体上安装一个</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>尽管引擎支持独立于生态系统的功能变体，但此功能当前仅可通过Java插件使用，并且正在开发中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec::declare_feature_variants"><a class="anchor" href="#sec::declare_feature_variants"></a> <a class="link" href="#sec::declare_feature_variants">声明功能变体</a></h5>
<div class="paragraph">
<p>可以通过应用<code>java</code>要么<code>java-library</code>插件。以下代码说明了如何声明名为<code>mongodbSupport</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例357声明功能变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">group = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo</span><span class="delimiter">'</span></span>
version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>

java {
    registerFeature(<span class="string"><span class="delimiter">'</span><span class="content">mongodbSupport</span><span class="delimiter">'</span></span>) {
        usingSourceSet(sourceSets.main)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">group = &quot;org.gradle.demo&quot;
version = &quot;1.0&quot;

java {
    registerFeature(&quot;mongodbSupport&quot;) {
        usingSourceSet(sourceSets[&quot;main&quot;])
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Gradle将以与<a href="#java_library_plugin">Java库插件</a>设置配置非常相似的方式为您自动设置许多东西：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>配置<code>mongodbSupportApi</code> ，用于<em>声明</em>此功能的<em>API依赖关系</em></p>
</li>
<li>
<p>配置<code>mongodbSupportImplementation</code> ，用于<em>声明</em>此功能的<em>实现依赖项</em></p>
</li>
<li>
<p>配置<code>mongodbSupportApiElements</code> ，供消费者用来获取此功能的工件和API依赖项</p>
</li>
<li>
<p>配置<code>mongodbSupportRuntimeElements</code> ，供消费者使用，以获取此功能的构件和运行时依赖项</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大多数用户只需要关心前两个配置，即可声明此功能的特定依赖性：</p>
</div>
<div class="exampleblock">
<div class="title">示例358。声明功能的依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    mongodbSupportImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.mongodb:mongodb-driver-sync:3.9.1</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    &quot;mongodbSupportImplementation&quot;(&quot;org.mongodb:mongodb-driver-sync:3.9.1&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>按照约定，Gradle会将功能名称映射到功能，其功能组和版本分别与主要组件的组和版本相同，但功能名称是主要组件名称，后跟一个<code>-</code>然后是kebab式功能名称。</p>
</div>
<div class="paragraph">
<p>例如，如果组是<code>org.gradle.demo</code> ，该组件的名称为<code>provider</code> ，其版本为<code>1.0</code>并且该功能被命名为<code>mongodbSupport</code> ，功能变体为<code>org.gradle.demo:provider-mongodb-support:1.0</code> 。</p>
</div>
<div class="paragraph">
<p>如果您自己选择功能名称或向变体添加更多功能，建议遵循相同的约定。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="sec:feature_variant_source_set"><a class="anchor" href="#sec:feature_variant_source_set"></a> <a class="link" href="#sec:feature_variant_source_set">功能变体源集</a></h6>
<div class="paragraph">
<p>在前面的示例中，我们声明了一个使用<em>主源集</em>的功能变体。这是Java生态系统中的典型用例，无论出于何种原因，都无法将项目的源拆分为不同的子项目或不同的源集。因此，Gradle将声明所描述的配置，但还将设置<em>主要源集</em>的编译类路径和运行时类路径，以便其从功能配置中扩展。换句话说，这允许您在其自己的“存储桶”中声明特定于功能的依赖关系，但是所有内容仍被编译为单个源集。也将只有一个工件（组件Jar），包括对所有功能的支持。</p>
</div>
<div class="paragraph">
<p>但是，通常最好为功能<em>设置单独的源集</em> 。然后Gradle将执行类似的映射，但<em>不会</em>使主要组件的编译和运行时类路径从已注册功能的依赖项中扩展。按照惯例，它还将创建一个<code>Jar</code>任务，使用与功能的kebab-case名称相对应的分类器，捆绑从该功能源集构建的类：</p>
</div>
<div class="exampleblock">
<div class="title">示例359。使用单独的源集声明功能变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    mongodbSupport {
        java {
            srcDir <span class="string"><span class="delimiter">'</span><span class="content">src/mongodb/java</span><span class="delimiter">'</span></span>
        }
    }
}

java {
    registerFeature(<span class="string"><span class="delimiter">'</span><span class="content">mongodbSupport</span><span class="delimiter">'</span></span>) {
        usingSourceSet(sourceSets.mongodbSupport)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    create(&quot;mongodbSupport&quot;) {
        java {
            srcDir(&quot;src/mongodb/java&quot;)
        }
    }
}

java {
    registerFeature(&quot;mongodbSupport&quot;) {
        usingSourceSet(sourceSets[&quot;mongodbSupport&quot;])
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec::publishing_feature_variants"><a class="anchor" href="#sec::publishing_feature_variants"></a> <a class="link" href="#sec::publishing_feature_variants">发布功能变体</a></h5>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>根据元数据文件格式，发布功能变体可能是有损的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle Module Metadata</a> ，所有内容都会发布，消费者将获得功能变体的全部好处</p>
</li>
<li>
<p>使用POM元数据（Maven），特征变体作为<strong>可选的依赖项</strong>发布，并且特征变体的工件使用不同的<em>分类器</em>发布</p>
</li>
<li>
<p>使用常春藤元数据，功能变体将作为额外配置发布，但<em>不会被</em>扩展<code>default</code>组态</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用以下功能支持发布功能变体<code>maven-publish</code>和<code>ivy-publish</code>仅插件。Java插件（或Java库插件）将为您注册其他变体，因此不需要其他配置，只需常规出版物即可：</p>
</div>
<div class="exampleblock">
<div class="title">示例360发布具有功能变体的组件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">maven-publish</span><span class="delimiter">'</span></span>
}
<span class="comment">// ...</span>
publishing {
    publications {
        myLibrary(MavenPublication) {
            from components.java
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
    `maven-publish`
}
// ...
publishing {
    publications {
        create(&quot;myLibrary&quot;, MavenPublication::class.java) {
            from(components[&quot;java&quot;])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:javadoc_sources_features_variants"><a class="anchor" href="#sub:javadoc_sources_features_variants"></a> <a class="link" href="#sub:javadoc_sources_features_variants">添加Javadoc和源JAR</a></h6>
<div class="paragraph">
<p>与<a href="#sec:java_packaging">主要Javadoc和源JAR</a>相似，您可以配置添加的功能变量，以便它为Javadoc和源产生JAR。但是，这仅在使用非主要来源集时才有意义。</p>
</div>
<div class="exampleblock">
<div class="title">示例361。生成Javadoc并为功能变体提供源JAR</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    registerFeature(<span class="string"><span class="delimiter">'</span><span class="content">mongodbSupport</span><span class="delimiter">'</span></span>) {
        usingSourceSet(sourceSets.mongodbSupport)
        withJavadocJar()
        withSourcesJar()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    registerFeature(&quot;mongodbSupport&quot;) {
        usingSourceSet(sourceSets[&quot;mongodbSupport&quot;])
        withJavadocJar()
        withSourcesJar()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec::consuming_feature_variants"><a class="anchor" href="#sec::consuming_feature_variants"></a> <a class="link" href="#sec::consuming_feature_variants">对功能变体的依赖</a></h5>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>如前所述，功能变体在发布时可能是有损的。因此，消费者仅在以下情况下才能依赖功能变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有项目依赖项（在多项目构建中）</p>
</li>
<li>
<p>在可用Gradle Module元数据的情况下，即发布者必须已发布它</p>
</li>
<li>
<p>在常春藤世界中，通过声明对与功能匹配的配置的依赖</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>消费者可以通过声明所需的功能来指定它需要生产者的特定功能。例如，如果生产者声明了这样的“ MySQL支持”功能：</p>
</div>
<div class="exampleblock">
<div class="title">示例362声明支持MySQL功能的库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    registerFeature(<span class="string"><span class="delimiter">'</span><span class="content">mysqlSupport</span><span class="delimiter">'</span></span>) {
        usingSourceSet(sourceSets.main)
    }
}

dependencies {
    mysqlSupportImplementation <span class="string"><span class="delimiter">'</span><span class="content">mysql:mysql-connector-java:8.0.14</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    registerFeature(&quot;mysqlSupport&quot;) {
        usingSourceSet(sourceSets[&quot;main&quot;])
    }
}

dependencies {
    &quot;mysqlSupportImplementation&quot;(&quot;mysql:mysql-connector-java:8.0.14&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，使用者可以通过执行以下操作来声明对MySQL支持功能的依赖关系：</p>
</div>
<div class="exampleblock">
<div class="title">示例363在多项目构建中使用特定功能</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// This project requires the main producer component</span>
    implementation(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:producer</span><span class="delimiter">&quot;</span></span>))

    <span class="comment">// But we also want to use its MySQL support</span>
    runtimeOnly(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:producer</span><span class="delimiter">&quot;</span></span>)) {
        capabilities {
            requireCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.demo:producer-mysql-support</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // This project requires the main producer component
    implementation(project(&quot;:producer&quot;))

    // But we also want to use its MySQL support
    runtimeOnly(project(&quot;:producer&quot;)) {
        capabilities {
            requireCapability(&quot;org.gradle.demo:producer-mysql-support&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将自动带来<code>mysql-connector-java</code>对运行时类路径的依赖。如果存在多个依赖关系，则将它们全部带入，这意味着可以使用功能将有助于功能的依赖项组合在一起。</p>
</div>
<div class="paragraph">
<p>同样，如果带有功能变体的外部库是随<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle Module Metadata发布的</a> ，则可能依赖于该库提供的功能：</p>
</div>
<div class="exampleblock">
<div class="title">示例364使用外部存储库中的特定功能</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// This project requires the main producer component</span>
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo:producer:1.0</span><span class="delimiter">'</span></span>)

    <span class="comment">// But we also want to use its MongoDB support</span>
    runtimeOnly(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo:producer:1.0</span><span class="delimiter">'</span></span>) {
        capabilities {
            requireCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.demo:producer-mongodb-support</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // This project requires the main producer component
    implementation(&quot;org.gradle.demo:producer:1.0&quot;)

    // But we also want to use its MongoDB support
    runtimeOnly(&quot;org.gradle.demo:producer:1.0&quot;) {
        capabilities {
            requireCapability(&quot;org.gradle.demo:producer-mongodb-support&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec::incompatible_variants"><a class="anchor" href="#sec::incompatible_variants"></a> <a class="link" href="#sec::incompatible_variants">处理互斥的变体</a></h5>
<div class="paragraph">
<p>使用<em>功能</em>作为处理功能的主要优点是，您可以精确处理变量的兼容性。规则很简单：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>不允许有两个组件变体在单个依赖关系图中提供相同的功能。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们可以利用它来要求Gradle在用户错误配置依赖项时失败。例如，想象一下，您的库支持MySQL，Postgres和MongoDB，但是只能同时选择<em>其中之一</em> 。不允许将其直接转换为“提供相同的功能”，因此所有三个功能都必须提供一个功能：</p>
</div>
<div class="exampleblock">
<div class="title">示例365相互排斥的多种功能的生产者</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    registerFeature(<span class="string"><span class="delimiter">'</span><span class="content">mysqlSupport</span><span class="delimiter">'</span></span>) {
        usingSourceSet(sourceSets.main)
        capability(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">producer-db-support</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>)
        capability(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">producer-mysql-support</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>)
    }
    registerFeature(<span class="string"><span class="delimiter">'</span><span class="content">postgresSupport</span><span class="delimiter">'</span></span>) {
        usingSourceSet(sourceSets.main)
        capability(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">producer-db-support</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>)
        capability(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">producer-postgres-support</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>)
    }
    registerFeature(<span class="string"><span class="delimiter">'</span><span class="content">mongoSupport</span><span class="delimiter">'</span></span>) {
        usingSourceSet(sourceSets.main)
        capability(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">producer-db-support</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>)
        capability(<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.demo</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">producer-mongo-support</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>)
    }
}

dependencies {
    mysqlSupportImplementation <span class="string"><span class="delimiter">'</span><span class="content">mysql:mysql-connector-java:8.0.14</span><span class="delimiter">'</span></span>
    postgresSupportImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.postgresql:postgresql:42.2.5</span><span class="delimiter">'</span></span>
    mongoSupportImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.mongodb:mongodb-driver-sync:3.9.1</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    registerFeature(&quot;mysqlSupport&quot;) {
        usingSourceSet(sourceSets[&quot;main&quot;])
        capability(&quot;org.gradle.demo&quot;, &quot;producer-db-support&quot;, &quot;1.0&quot;)
        capability(&quot;org.gradle.demo&quot;, &quot;producer-mysql-support&quot;, &quot;1.0&quot;)
    }
    registerFeature(&quot;postgresSupport&quot;) {
        usingSourceSet(sourceSets[&quot;main&quot;])
        capability(&quot;org.gradle.demo&quot;, &quot;producer-db-support&quot;, &quot;1.0&quot;)
        capability(&quot;org.gradle.demo&quot;, &quot;producer-postgres-support&quot;, &quot;1.0&quot;)
    }
    registerFeature(&quot;mongoSupport&quot;) {
        usingSourceSet(sourceSets[&quot;main&quot;])
        capability(&quot;org.gradle.demo&quot;, &quot;producer-db-support&quot;, &quot;1.0&quot;)
        capability(&quot;org.gradle.demo&quot;, &quot;producer-mongo-support&quot;, &quot;1.0&quot;)
    }
}

dependencies {
    &quot;mysqlSupportImplementation&quot;(&quot;mysql:mysql-connector-java:8.0.14&quot;)
    &quot;postgresSupportImplementation&quot;(&quot;org.postgresql:postgresql:42.2.5&quot;)
    &quot;mongoSupportImplementation&quot;(&quot;org.mongodb:mongodb-driver-sync:3.9.1&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生产者在这里声明3个变体，每个数据库运行时支持一个变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mysql-support</code>同时提供<code>db-support</code>和<code>mysql-support</code>能力</p>
</li>
<li>
<p><code>postgres-support</code>同时提供<code>db-support</code>和<code>postgres-support</code>能力</p>
</li>
<li>
<p><code>mongo-support</code>同时提供<code>db-support</code>和<code>mongo-support</code>能力</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，如果消费者试图同时获得<code>postgres-support</code>和<code>mysql-support</code>像这样（这也可以传递）：</p>
</div>
<div class="exampleblock">
<div class="title">范例366。消费者尝试同时使用2个不兼容的变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:producer</span><span class="delimiter">&quot;</span></span>))

    <span class="comment">// Let's try to ask for both MySQL and Postgres support</span>
    runtimeOnly(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:producer</span><span class="delimiter">&quot;</span></span>)) {
        capabilities {
            requireCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.demo:producer-mysql-support</span><span class="delimiter">&quot;</span></span>)
        }
    }
    runtimeOnly(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:producer</span><span class="delimiter">&quot;</span></span>)) {
        capabilities {
            requireCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.demo:producer-postgres-support</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // This project requires the main producer component
    implementation(project(&quot;:producer&quot;))

    // Let's try to ask for both MySQL and Postgres support
    runtimeOnly(project(&quot;:producer&quot;)) {
        capabilities {
            requireCapability(&quot;org.gradle.demo:producer-mysql-support&quot;)
        }
    }
    runtimeOnly(project(&quot;:producer&quot;)) {
        capabilities {
            requireCapability(&quot;org.gradle.demo:producer-postgres-support&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>依赖关系解析将失败，并出现以下错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Cannot choose between
   org.gradle.demo:producer:1.0 variant mysqlSupportRuntimeElements and
   org.gradle.demo:producer:1.0 variant postgresSupportRuntimeElements
   because they provide the same capability: org.gradle.demo:producer-db-support:1.0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="understanding-variant-selection"><a class="anchor" href="#understanding-variant-selection"></a> <a class="link" href="#understanding-variant-selection">了解变体选择</a></h4>
<div class="paragraph">
<p>Gradle的依赖管理引擎称为<em>变体感知</em> 。在像Apache Maven™这样的传统依赖管理引擎中，依赖关系绑定到在GAV坐标处发布的组件。这意味着组件的传递依赖项集仅由该组件的GAV坐标确定。实际解决什么<em>工件</em>都没有关系，依赖关系的集合<em>始终是相同的</em> 。此外，为组件选择其他工件（例如，使用<code>jdk7</code>工件）繁琐，因为它需要使用<em>分类器</em> 。该模型的一个问题是它不能保证全局图的一致性，因为没有与<em>分类器</em>关联的通用语义。这意味着没有什么可以阻止<code>jdk7</code>和<code>jdk8</code>类路径上单个模块的版本，因为引擎不知道与分类器名称关联的语义。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/component-model-maven.png" alt="组件模型专家">
</div>
<div class="title">图22。Maven组件模型</div>
</div>
<div class="paragraph">
<p>除了在GAV坐标处发布的<em>模块</em>的概念外，Gradle还介绍了此模块的<em>变体</em>的概念。变体对应于在相同GAV坐标处发布的组件的不同“视图”。在Gradle模型中，工件被附加到<em>变量</em>而不是模块。实际上，这意味着不同的<em>工件</em>可以具有不同的依赖关系集：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/component-model-gradle.png" alt="组件模型gradle">
</div>
<div class="title">图23。Gradle组件模型</div>
</div>
<div class="paragraph">
<p>这个中间级别将工件和依赖项与变量关联，而不是直接与组件相关联，使Gradle可以正确地建模每个工件的用途。</p>
</div>
<div class="paragraph">
<p>但是，这引发了有关如何选择变体的问题：当存在多个变体时，Gradle如何知道要选择哪个变体？实际上，由于使用了<a href="#">属性</a> ，因此选择了变体，这些<a href="#">属性</a>为变体提供了语义，并有助于引擎获得<em>一致的解析结果</em> 。</p>
</div>
<div class="paragraph">
<p>由于历史原因，Gradle区分两种组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从源构建的本地组件，其<a href="#sec:abm_configuration_attributes">变体映射到传出配置</a></p>
</li>
<li>
<p>外部组件（在存储库上发布），在这种情况下，该模块要么通过Gradle Module Metadata发布，并且本机支持变体，要么该模块使用Ivy / Maven元数据，而<a href="#sec:mapping-maven-ivy-to-variants">变体则从元数据派生</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这两种情况下，Gradle都会执行<em>变体感知选择</em> 。</p>
</div>
<div class="sect4">
<h5 id="sec:abm_configuration_attributes"><a class="anchor" href="#sec:abm_configuration_attributes"></a> <a class="link" href="#sec:abm_configuration_attributes">配置和变量属性</a></h5>
<div class="paragraph">
<p>本地组件将变体作为<em>传出配置</em>公开，这是<a href="#sec:resolvable-consumable-configs">消耗性配置</a> 。发生依赖关系解析时，引擎将通过选择其_consumable配置之一来选择传出组件的一种变体。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>此规则有2个明显的例外：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每当生产者<em>不</em>公开任何消耗品配置</p>
</li>
<li>
<p>每当使用者<em>明确选择目标配置时</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这种情况下， <em>绕过变体感知分辨率</em> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在<em>可解析配置</em> （也称为<em>使用者</em> ）和<em>消耗性配置</em> （在<em>生产者</em> ）上都使用属性。将属性添加到其他类型的配置中根本没有效果，因为属性不会在配置之间继承。</p>
</div>
<div class="paragraph">
<p>依赖项解析引擎的作用是在给定<em>消费者</em>表示的约束的情况下，找到<em>生产者</em>的合适<em>变体</em> 。</p>
</div>
<div class="paragraph">
<p>这就是属性发挥作用的地方：它们的作用是执行组件的正确<em>变体</em>的选择。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">变体与配置</div>
<div class="paragraph">
<p>对于外部组件，术语是使用<em>变体</em>一词，而不是<em>配置</em> 。配置是变体的超集。</p>
</div>
<div class="paragraph">
<p>这意味着外部组件提供了<em>variant</em> ，它们也具有属性。但是，有时由于历史原因或由于您使用也具有这种<em>配置</em>概念的Ivy，术语<em>配置</em>可能会泄漏到DSL中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:variant-visual"><a class="anchor" href="#sec:variant-visual"></a> <a class="link" href="#sec:variant-visual">可视化变体信息</a></h5>
<div class="paragraph">
<p>Gradle提供了一个报告任务，称为<code>outgoingVariants</code>显示项目的变体及其功能，属性和工件。它在概念上类似于<code>dependencyInsight</code> <a href="#sec:identifying_reason_dependency_selection">报告任务</a> 。</p>
</div>
<div class="paragraph">
<p>默认， <code>outgoingVariants</code>打印有关所有变体的信息。它提供了可选参数<code>--variant <variantName></code>选择要显示的单个变体。它还接受<code>-all</code>标志以包含有关旧配置和不推荐使用的配置的信息。</p>
</div>
<div class="paragraph">
<p>这是输出<code>outgoingVariants</code>新生成的任务<code>java-library</code>项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; Task :outgoingVariants
--------------------------------------------------
Variant apiElements
--------------------------------------------------
Description = API elements for main.

Capabilities
    - [default capability]
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 8
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-api

Artifacts
    - build/libs/variant-report.jar (artifactType = jar)

Secondary variants (*)
    - Variant : classes
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = classes
          - org.gradle.usage               = java-api
       - Artifacts
          - build/classes/java/main (artifactType = java-classes-directory)

--------------------------------------------------
Variant runtimeElements
--------------------------------------------------
Description = Elements of runtime for main.

Capabilities
    - [default capability]
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 8
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-runtime

Artifacts
    - build/libs/variant-report.jar (artifactType = jar)

Secondary variants (*)
    - Variant : classes
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = classes
          - org.gradle.usage               = java-runtime
       - Artifacts
          - build/classes/java/main (artifactType = java-classes-directory)
    - Variant : resources
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = resources
          - org.gradle.usage               = java-runtime
       - Artifacts
          - build/resources/main (artifactType = java-resources-directory)


(*) Secondary variants are variants created via the Configuration#getOutgoing(): ConfigurationPublications API which also participate in selection, in addition to the configuration itself.</pre>
</div>
</div>
<div class="paragraph">
<p>从中您可以看到Java库公开的两个主要变体， <code>apiElements</code>和<code>runtimeElements</code> 。请注意，主要区别在于<code>org.gradle.usage</code>具有值的属性<code>java-api</code>和<code>java-runtime</code> 。正如他们所指出的，这就是消费者的<em>编译</em>类路径上需要的内容与<em>运行时</em>类路径上需要的内容之间的区别。</p>
</div>
<div class="paragraph">
<p>它还显示了<em>次级</em>变体，这些变体是Gradle项目专有的，未发布。例如，次级变体<code>classes</code>从<code>apiElements</code>是什么允许Gradle在针对.NET进行编译时跳过JAR创建<a href="#sec:java_library_classes_usage"><code>java-library</code>项目</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:variant-aware-matching"><a class="anchor" href="#sec:variant-aware-matching"></a> <a class="link" href="#sec:variant-aware-matching">变体匹配</a></h5>
<div class="paragraph">
<p>让我们以一个<code>lib</code>该库公开了2个变体：其API（通过名为的变体<code>exposedApi</code> ）及其运行时（通过名为的变体<code>exposedRuntime</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">关于生产者变体</div>
<div class="paragraph">
<p>此处存在变体<em>名称</em> ，主要用于调试目的并在错误消息中获得更好的显示。特别是，名称不参与变体的<em>ID</em> ：只有其属性参与。也就是说，要搜索特定的变体， <em>必须</em>依靠其属性<em>而不是</em>其名称。</p>
</div>
<div class="paragraph">
<p>组件可以公开的变体数量没有限制。传统上，一个组件会公开一个API和一个实现，但是例如，我们可能也想公开一个组件的测试装置。也可以为不同的使用者公开<em>不同的API</em> （考虑一下不同的环境，例如Linux与Windows）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>消费者需要解释它需要<em>什么</em>变体，这是通过在<em>消费者</em>上设置<em>属性</em>来完成的。</p>
</div>
<div class="paragraph">
<p>属性由<em>名称</em>和<em>值</em>对组成。例如，Gradle带有一个名为<code>org.gradle.usage</code>专门用于根据使用者的使用情况（编译，运行时...）选择组件的正确变体的概念。但是可以定义任意数量的属性。作为生产者，我们可以通过附加附件来表示消耗性配置代表组件的API。 <code>(org.gradle.usage,JAVA_API)</code>属性的变体。作为使用者，我们可以通过附加以下内容来表达我们需要可解析配置依赖项的API： <code>(org.gradle.usage,JAVA_API)</code>属性。为此，Gradle可以通过查看配置属性来<em>自动选择适当的变体</em> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消费者想要<code>org.gradle.usage=JAVA_API</code></p>
</li>
<li>
<p>生产者， <code>lib</code>展示2种不同的变体。与之一<code>org.gradle.usage=JAVA_API</code> ，另一个<code>org.gradle.usage=JAVA_RUNTIME</code> 。</p>
</li>
<li>
<p>Gradle选择<code>org.gradle.usage=JAVA_API</code>生产者的变体，因为它<em>与消费者属性匹配</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>换句话说：属性用于基于属性的值执行选择。</p>
</div>
<div class="paragraph">
<p>一个更详尽的示例涉及多个属性。通常，Gradle中的Java库项目将涉及4个不同的属性，在生产者和消费者方面都可以找到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.usage</code> ，说明变体是组件的API还是其实现</p>
</li>
<li>
<p><code>org.gradle.dependency.bundling</code> ，它声明了如何捆绑组件的依赖项（例如，如果工件是一个胖子，那么捆绑是<code>EMBEDDED</code> ）</p>
</li>
<li>
<p><code>org.gradle.libraryelements</code> ，用于说明该变体包含库的哪些<em>部分</em> （类，资源或所有内容）</p>
</li>
<li>
<p><code>org.gradle.jvm.version</code> ，用于说明此变体针对的<em>最低</em> Java <em>版本</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，假设我们的库具有两种不同的风格：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个用于JDK 8</p>
</li>
<li>
<p>一个用于JDK 9+</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在Maven中，这通常是通过生成2种不同的工件（“主”工件和“分类”工件）来实现的。但是，在Maven中，使用者无法表达其需要基于运行时的<em>最合适</em>版本的库这一事实。</p>
</div>
<div class="paragraph">
<p>使用Gradle，可以通过让生产者声明两个变体来优雅地解决此问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与之一<code>org.gradle.jvm.version=8</code> ，对于<em>至少在JDK 8上运行的</em>消费者</p>
</li>
<li>
<p>与之一<code>org.gradle.jvm.version=9</code> ，适用于从JDK 9开始的消费者</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，这两个变体的工件会有所不同，但它们的依存关系<em>也可能</em>会有所不同。通常，JDK 8变体可能需要JDK 9+的“反向端口”库才能工作，只有在JDK 8上运行的使用者才能使用。</p>
</div>
<div class="paragraph">
<p>在使用者方面， <em>可解析配置</em>将设置上述所有四个属性，并根据运行时设置其<code>org.gradle.jvm.version</code>到8或更多。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">有关变体兼容性的说明</div>
<div class="paragraph">
<p>如果消费者设置<code>org.gradle.jvm.version</code>到7？</p>
</div>
<div class="paragraph">
<p>然后解析将<em>失败，</em>并显示一条错误消息，说明生产者没有匹配的变体。这是因为Gradle认识到消费者希望使用Java 7兼容库，但是生产者可用的Java的<em>最低</em>版本为8。另一方面，如果消费者需要<em>11</em> ，则Gradle知道<em>8</em>和<em>9</em>变体都可以使用，但是它将选择<em>9，</em>因为它是最高兼容的版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:variant-select-errors"><a class="anchor" href="#sec:variant-select-errors"></a> <a class="link" href="#sec:variant-select-errors">变异选择错误</a></h5>
<div class="paragraph">
<p>在标识组件的正确变体的过程中，两种情况将导致分辨率错误：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>生产者的多个变体与消费者属性相匹配，存在变体歧义</p>
</li>
<li>
<p>生产者的任何变体都不符合消费者属性</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="sub:variant-ambiguity"><a class="anchor" href="#sub:variant-ambiguity"></a> <a class="link" href="#sub:variant-ambiguity">处理模棱两可的变量选择错误</a></h6>
<div class="paragraph">
<p>模棱两可的变量选择看起来如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; Could not resolve all files for configuration ':compileClasspath'.
   &gt; Could not resolve project :lib.
     Required by:
         project :ui
      &gt; Cannot choose between the following variants of project :lib:
          - feature1ApiElements
          - feature2ApiElements
        All of them match the consumer attributes:
          - Variant 'feature1ApiElements' capability org.test:test-capability:1.0:
              - Unmatched attribute:
                  - Found org.gradle.category 'library' but wasn't required.
              - Compatible attributes:
                  - Required org.gradle.dependency.bundling 'external' and found compatible value 'external'.
                  - Required org.gradle.jvm.version '11' and found compatible value '11'.
                  - Required org.gradle.libraryelements 'classes' and found compatible value 'jar'.
                  - Required org.gradle.usage 'java-api' and found compatible value 'java-api'.
          - Variant 'feature2ApiElements' capability org.test:test-capability:1.0:
              - Unmatched attribute:
                  - Found org.gradle.category 'library' but wasn't required.
              - Compatible attributes:
                  - Required org.gradle.dependency.bundling 'external' and found compatible value 'external'.
                  - Required org.gradle.jvm.version '11' and found compatible value '11'.
                  - Required org.gradle.libraryelements 'classes' and found compatible value 'jar'.
                  - Required org.gradle.usage 'java-api' and found compatible value 'java-api'.</pre>
</div>
</div>
<div class="paragraph">
<p>可以看到，显示了所有<em>兼容的</em>候选变体及其属性。然后将它们分为两个部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先介绍不匹配的属性，因为它们可能是选择适当变体时缺少的部分。</p>
</li>
<li>
<p>其次显示兼容的属性，因为它们指示消费者想要什么以及这些变体如何匹配该请求。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>不能有任何不匹配的属性，因为那时变体将不是候选者。同样，显示的变体集也排除了已消除歧义的变体。</p>
</div>
<div class="paragraph">
<p>在上面的示例中，解决方法不在于属性匹配，而在于<a href="#sec:adding-constraints-transitive-deps">功能匹配</a> ，该功能显示在变量名称旁边。因为这两个变体有效地提供了相同的属性和功能，所以它们不会被歧义。因此，在这种情况下，此修复程序最有可能在生产者端提供不同的功能（ <code>project :lib</code> ），并在用户端表示能力选择（ <code>project :ui</code> ）。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:variant-no-match"><a class="anchor" href="#sub:variant-no-match"></a> <a class="link" href="#sub:variant-no-match">处理无匹配的变体错误</a></h6>
<div class="paragraph">
<p>没有匹配的变体错误如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; No variants of project :lib match the consumer attributes:
  - Configuration ':lib:compile':
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other attribute:
          - Required usage 'api' and found compatible value 'api'.
  - Configuration ':lib:compile' variant debug:
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other attributes:
          - Found buildType 'debug' but wasn't required.
          - Required usage 'api' and found compatible value 'api'.
  - Configuration ':lib:compile' variant release:
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other attributes:
          - Found buildType 'release' but wasn't required.
          - Required usage 'api' and found compatible value 'api'.</pre>
</div>
</div>
<div class="paragraph">
<p>可以看出，显示了<em>所有</em>候选变体及其属性。然后将它们分为两个部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先介绍不兼容的属性，因为它们通常是理解为什么无法选择变体的关键。</p>
</li>
<li>
<p>其次显示其他属性，包括<em>必需的</em>和<em>兼容</em>的属性，以及消费者不要求的所有其他<em>生产者</em>属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与模棱两可的变量错误类似，目标是了解要选择哪个变量，并查看可以针对使用者调整哪些属性或功能以实现此目的。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:mapping-maven-ivy-to-variants"><a class="anchor" href="#sec:mapping-maven-ivy-to-variants"></a> <a class="link" href="#sec:mapping-maven-ivy-to-variants">从Maven / Ivy映射到变体</a></h5>
<div class="paragraph">
<p>既不的Maven也不常春藤具有<em>变体</em> ，其仅由本机模块摇篮元数据支持的概念。但是，由于不同的策略，它不会阻止Gradle与他们合作。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">与Gradle模块元数据的关系</div>
<div class="paragraph">
<p>Gradle模块元数据是在Maven，Ivy或其他类型的存储库上发布的模块的元数据格式。它类似于<code>pom.xml</code>要么<code>ivy.xml</code>文件，但是这种格式可以<em>识别变体</em> 。这意味着，如果您的项目产生其他变体，则这些变体将作为模块元数据的一部分提供并发布，从而极大地改善用户体验。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle模块元数据规范</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="sub:maven-mapping-to-variants"><a class="anchor" href="#sub:maven-mapping-to-variants"></a> <a class="link" href="#sub:maven-mapping-to-variants">将POM文件映射到变体</a></h6>
<div class="paragraph">
<p>在Maven存储库中发布的模块将转换为可识别变体的模块。Maven模块的特殊之处在于，无法知道发布了哪种组件。特别是，无法在代表<em>平台</em>的BOM和用作超级POM的BOM之间进行区分。有时，POM文件甚至有可能同时充当平台<em>和</em>库。</p>
</div>
<div class="paragraph">
<p>因此，Maven模块分为6个不同的变体，使Gradle用户可以准确地解释它们所依赖的内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2个“库”变体（属性<code>org.gradle.category</code> = <code>library</code> ）</p>
<div class="ulist">
<ul>
<li>
<p>的<code>compile</code>变体映射<code><scope>compile</scope></code>依赖性。此变体等效于<code>apiElements</code> <a href="#">Java库插件的</a>变体。此范围的所有依赖项均被视为<em>API依赖项</em> 。</p>
</li>
<li>
<p>的<code>runtime</code>变体既映射<code><scope>compile</scope></code>和<code><scope>runtime</scope></code>依赖性。此变体等效于<code>runtimeElements</code> <a href="#">Java库插件的</a>变体。这些作用域的所有依赖关系都被视为<em>运行时依赖关系</em> 。</p>
<div class="ulist">
<ul>
<li>
<p>在这两种情况下， <code><dependencyManagement></code>依赖关系<em>不会转换为约束</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>4个“平台”变体源自<code><dependencyManagement></code>阻止（属性<code>org.gradle.category</code> = <code>platform</code> ）：</p>
<div class="ulist">
<ul>
<li>
<p>的<code>platform-compile</code>变体映射<code><scope>compile</scope></code>依赖管理作为<em>依赖约束的依赖</em> 。</p>
</li>
<li>
<p>的<code>platform-runtime</code>变体既映射<code><scope>compile</scope></code>和<code><scope>runtime</scope></code>依赖管理作为<em>依赖约束的依赖</em> 。</p>
</li>
<li>
<p>的<code>enforced-platform-compile</code>类似于<code>platform-compile</code>但是所有的约束都是<em>强制的</em></p>
</li>
<li>
<p>的<code>enforced-platform-runtime</code>类似于<code>platform-runtime</code>但是所有的约束都是<em>强制的</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过查看手册的“ <a href="#sub:bom_import">导入BOM表”</a>部分，您可以了解有关平台和强制平台变体用法的更多信息。默认情况下，每当您声明对Maven模块的依赖关系时，Gradle都会查找<code>library</code>变体。但是，使用<code>platform</code>要么<code>enforcedPlatform</code>关键字，Gradle现在正在寻找“平台”变体之一，它允许您从POM文件而不是从依赖项中导入约束。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:ivy-mapping-to-variants"><a class="anchor" href="#sub:ivy-mapping-to-variants"></a> <a class="link" href="#sub:ivy-mapping-to-variants">将常春藤文件映射到变体</a></h6>
<div class="paragraph">
<p>与<a href="#sub:maven-mapping-to-variants">Maven</a>相反，默认情况下没有为Ivy文件实现派生策略。这样做的原因是，与pom相反，Ivy是一种灵活的格式，允许您发布任意多个自定义<em>配置</em> 。因此，通常在Ivy中没有编译/运行时范围或编译/运行时变体的概念。仅当您使用<a href="#publishing_ivy">Gravy发行版</a>的<a href="#publishing_ivy">ivy-publish插件</a>发布ivy文件时，您才能获得与pom文件类似的结构。但是，由于不能保证构建所使用的<strong>所有</strong>常春藤元数据文件都遵循此模式，因此Gradle无法基于该模式实施派生策略。</p>
</div>
<div class="paragraph">
<p>但是，如果要为Ivy的<em>编译</em>和<em>运行时</em>变体实现派生策略，则可以使用<a href="#sec:component_metadata_rules">组件元数据rule来实现</a> 。组件元数据规则API允许您<a href="#sec:component_metadata_rules_details">访问ivy配置</a>并基于它们创建变体。如果您知道您使用的所有ivy模块都已在Gradle中发布，而无需进一步自定义<code>ivy.xml</code>文件，您可以在构建中添加以下规则：</p>
</div>
<div class="exampleblock">
<div class="title">示例367导出Ivy元数据的编译和运行时变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">IvyVariantDerivationRule</span> <span class="directive">implements</span> ComponentMetadataRule {
    <span class="annotation">@Inject</span> <span class="predefined-type">ObjectFactory</span> getObjects() { }

    <span class="type">void</span> execute(ComponentMetadataContext context) {
        context.details.addVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">runtimeElements</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">default</span><span class="delimiter">&quot;</span></span>) {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements, LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category, Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage, Usage.JAVA_RUNTIME))
            }
        }
        context.details.addVariant(<span class="string"><span class="delimiter">&quot;</span><span class="content">apiElements</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">compile</span><span class="delimiter">&quot;</span></span>) {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements, LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category, Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage, Usage.JAVA_API))
            }
        }
    }
}

dependencies {
    components { all(IvyVariantDerivationRule) }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class IvyVariantDerivationRule : ComponentMetadataRule {
    @Inject open fun getObjects(): ObjectFactory = throw UnsupportedOperationException()

    override fun execute(context: ComponentMetadataContext) {
        context.details.addVariant(&quot;runtimeElements&quot;, &quot;default&quot;) {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_RUNTIME))
            }
        }
        context.details.addVariant(&quot;apiElements&quot;, &quot;compile&quot;) {
            attributes {
                attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, getObjects().named(LibraryElements.JAR))
                attribute(Category.CATEGORY_ATTRIBUTE, getObjects().named(Category.LIBRARY))
                attribute(Usage.USAGE_ATTRIBUTE, getObjects().named(Usage.JAVA_API))
            }
        }
    }
}

dependencies {
    components { all&lt;IvyVariantDerivationRule&gt;() }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该规则创建一个<code>apiElements</code>基于的变体<code>compile</code>配置和<code>runtimeElements</code>基于的变体<code>default</code>每个常春藤模块的配置。对于每个变体，它都设置了相应的<a href="#sec:variant-aware-matching">Java生态系统属性</a> 。变体的依赖关系和工件来自基础配置。如果不是所有消耗的常春藤模块都遵循此模式，则可以调整规则或仅将规则应用于选定的一组模块。</p>
</div>
<div class="paragraph">
<p>对于没有体都常春藤模块，摇篮回落到原有配置选择（即摇篮<em>不</em>执行这些模块的变体意识到分辨率）。这意味着要么<code>default</code>选择配置或在对相应模块的依赖性中显式定义的配置。（请注意，只有从构建脚本或常春藤元数据中才可以进行显式配置选择，而应避免使用变量选择。）</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="variant_attributes"><a class="anchor" href="#variant_attributes"></a> <a class="link" href="#variant_attributes">使用变体属性</a></h4>
<div class="paragraph">
<p>如有关<a href="#sec:variant-aware-matching">变体感知匹配</a>的部分所述，属性为变体提供语义，并用于在变体之间进行选择。</p>
</div>
<div class="paragraph">
<p>作为Gradle的用户，属性通常被隐藏为实现细节。但是了解Gradle及其核心插件定义的<em>标准属性</em>可能会很有用。</p>
</div>
<div class="paragraph">
<p>作为插件作者，这些属性及其定义方式可以作为在生态系统插件中<a href="#sec:declaring_attributes">构建自己的一组属性</a>的基础。</p>
</div>
<div class="sect4">
<h5 id="sec:standard_attributes"><a class="anchor" href="#sec:standard_attributes"></a> <a class="link" href="#sec:standard_attributes">Gradle定义的标准属性</a></h5>
<div class="paragraph">
<p>Gradle定义了Gradle核心插件使用的标准属性列表。</p>
</div>
<div class="sect5">
<h6 id="ecosystem_independent_standard_attributes"><a class="anchor" href="#ecosystem_independent_standard_attributes"></a> <a class="link" href="#ecosystem_independent_standard_attributes">与生态系统无关的标准属性</a></h6>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表11。与生态系统无关的标准变体属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Usage.html#USAGE_ATTRIBUTE"><code>org.gradle.usage</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示变体的主要目的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Usage</code>根据<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Usage.html">用法中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如<code>java-runtime</code>可以代替<code>java-api</code>但并非相反）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Category.html#CATEGORY_ATTRIBUTE"><code>org.gradle.category</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示此软件组件的类别</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Category</code>从<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Category.html">类别中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如<code>library</code>是JVM上的默认值，否则不兼容）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/LibraryElements.html#LIBRARY_ELEMENTS_ATTRIBUTE"><code>org.gradle.libraryelements</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示内容<code>org.gradle.category=library</code>变体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LibraryElements</code>从<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/LibraryElements.html">LibraryElements中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如，在JVM世界中， <code>jar</code>是默认设置，并且与<code>classes</code> ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/DocsType.html#DOCS_TYPE_ATTRIBUTE"><code>org.gradle.docstype</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示内容<code>org.gradle.category=documentation</code>变体</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocsType</code>根据<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/DocsType.html">DocsType中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有默认值，没有兼容性</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Bundling.html#BUNDLING_ATTRIBUTE"><code>org.gradle.dependency.bundling</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示如何访问变体的依赖项。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Bundling</code>根据<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/Bundling.html">捆绑中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">遵循生态系统语义（例如，在JVM世界中， <code>embedded</code>与...兼容<code>external</code> ）</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表12。与生态系统无关的标准组件属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.gradle.status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组件级别属性，派生</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">基于<a href="#sec:custom_status_scheme">状态方案</a> ，默认情况下基于源存储库。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根据使用的方案</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="sub:jvm_default_attributes"><a class="anchor" href="#sub:jvm_default_attributes"></a> <a class="link" href="#sub:jvm_default_attributes">JVM生态系统特定属性</a></h6>
<div class="paragraph">
<p>除了上面定义的与生态系统无关的属性之外，JVM生态系统还添加了以下属性：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表13。JVM生态系统标准组件属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/java/TargetJvmVersion.html#TARGET_JVM_VERSION_ATTRIBUTE"><code>org.gradle.jvm.version</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示JVM版本兼容性。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数使用后的版本<code>1.</code>适用于Java 1.4及更低版本，是Java 5及更高版本的主要版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认为Gradle使用的JVM版本，低级与高级兼容，更倾向于最高兼容性。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>JVM生态系统还包含许多针对不同属性的兼容性和消歧规则。愿意了解更多信息的读者可以查看以下代码<code>org.gradle.api.internal.artifacts.JavaEcosystemSupport</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="native_ecosystem_specific_attributes"><a class="anchor" href="#native_ecosystem_specific_attributes"></a> <a class="link" href="#native_ecosystem_specific_attributes">原生生态系统特有的属性</a></h6>
<div class="paragraph">
<p>除了上面定义的与生态系统无关的属性之外，本机生态系统还添加了以下属性：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表14。原生生态系统标准组件属性</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">价值观</th>
<th class="tableblock halign-left valign-top">兼容性和消歧规则</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/cpp/CppBinary.html#DEBUGGABLE_ATTRIBUTE"><code>org.gradle.native.debuggable</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件是否使用调试符号构建</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/cpp/CppBinary.html#OPTIMIZED_ATTRIBUTE"><code>org.gradle.native.optimized</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件是否使用优化标志构建</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/MachineArchitecture.html#ARCHITECTURE_ATTRIBUTE"><code>org.gradle.native.architecture</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件的目标体系结构</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MachineArchitecture</code>根据<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/MachineArchitecture.html">MachineArchitecture中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/OperatingSystemFamily.html#OPERATING_SYSTEM_ATTRIBUTE"><code>org.gradle.native.operatingSystem</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示二进制文件的目标操作系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OperatingSystemFamily</code>从<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/OperatingSystemFamily.html">OperatingSystemFamily中</a>定义的常量构建的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="sec:declaring_attributes"><a class="anchor" href="#sec:declaring_attributes"></a> <a class="link" href="#sec:declaring_attributes">声明自定义属性</a></h5>
<div class="paragraph">
<p>如果要扩展Gradle（例如，通过为另一个生态系统编写插件），则要自定义属性，可以在插件中支持变体感知的依赖管理功能。但是，如果您还尝试发布库，则应保持谨慎。新属性的语义通常是通过插件定义的，该插件可以带有<a href="#sec:abm_compatibility_rules">兼容性</a>和<a href="#sec:abm_disambiguation_rules">歧义消除</a>规则。因此，使用消耗为特定生态系统发布的库的构建，也需要应用相应的插件来正确解释属性。如果您的插件面向更广泛的受众，即如果它是公开可用的，并且库已发布到公共存储库，则定义新属性可以有效地扩展Gradle Module元数据的语义并承担责任。例如，对已经发布的属性的支持不应再次删除，或者应在插件的未来版本中以某种兼容性层处理。</p>
</div>
</div>
<div class="sect4">
<h5 id="creating_attributes_in_a_build_script_or_plugin"><a class="anchor" href="#creating_attributes_in_a_build_script_or_plugin"></a> <a class="link" href="#creating_attributes_in_a_build_script_or_plugin">在构建脚本或插件中创建属性</a></h5>
<div class="paragraph">
<p><em>键入</em>属性。可以通过<code>Attribute<T>.of</code>方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例368。定义属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// An attribute of type `String`</span>
<span class="keyword">def</span> myAttribute = <span class="predefined-type">Attribute</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">my.attribute.name</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">String</span>)
<span class="comment">// An attribute of type `Usage`</span>
<span class="keyword">def</span> myUsage = <span class="predefined-type">Attribute</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">my.usage.attribute</span><span class="delimiter">&quot;</span></span>, Usage)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// An attribute of type `String`
val myAttribute = Attribute.of(&quot;my.attribute.name&quot;, String::class.java)
// An attribute of type `Usage`
val myUsage = Attribute.of(&quot;my.usage.attribute&quot;, Usage::class.java)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>目前，只有<code>String</code>或其他扩展名<code>Named</code>支持。必须在位于以下位置的<em>属性架构中</em>声明<em>属性</em> <code>dependencies</code>处理程序：</p>
</div>
<div class="exampleblock">
<div class="title">示例369在属性架构上注册属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies.attributesSchema {
    <span class="comment">// registers this attribute to the attributes schema</span>
    attribute(myAttribute)
    attribute(myUsage)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies.attributesSchema {
    // registers this attribute to the attributes schema
    attribute(myAttribute)
    attribute(myUsage)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后可以配置配置以设置属性值：</p>
</div>
<div class="exampleblock">
<div class="title">示例370在配置上设置属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    myConfiguration {
        attributes {
            attribute(myAttribute, <span class="string"><span class="delimiter">'</span><span class="content">my-value</span><span class="delimiter">'</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    create(&quot;myConfiguration&quot;) {
        attributes {
            attribute(myAttribute, &quot;my-value&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于类型扩展的属性<code>Named</code> ，则<strong>必须</strong>通过<em>对象工厂</em>创建属性的值：</p>
</div>
<div class="exampleblock">
<div class="title">示例371命名属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    myConfiguration {
        attributes {
            attribute(myUsage, project.objects.named(Usage, <span class="string"><span class="delimiter">'</span><span class="content">my-value</span><span class="delimiter">'</span></span>))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    &quot;myConfiguration&quot; {
        attributes {
            attribute(myUsage, project.objects.named(Usage::class.java, &quot;my-value&quot;))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:abm_compatibility_rules"><a class="anchor" href="#sec:abm_compatibility_rules"></a> <a class="link" href="#sec:abm_compatibility_rules">属性兼容性规则</a></h6>
<div class="paragraph">
<p>属性使引擎可以选择<em>兼容的变体</em> 。但是，在某些情况下，提供者可能不<em>完全</em>具有消费者想要的东西，但是仍然可以使用它。例如，如果使用者要求一个库的API，则生产者可能没有这样的变体，而只有<em>运行时</em>变体。这是在外部存储库上发布的库的典型特征。在这种情况下，我们知道即使没有完全匹配（API），我们仍然可以针对运行时变体进行编译（它包含的<em>内容</em>超出了我们需要编译的范围，但仍然可以使用）。为了解决这个问题，Gradle提供了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/AttributeCompatibilityRule.html">属性兼容性规则</a> 。兼容性规则的作用是解释哪些变体与消费者要求的变体<em>兼容</em> 。</p>
</div>
<div class="paragraph">
<p>必须通过可从<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/AttributesSchema.html">属性架构中</a>获取的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/AttributeMatchingStrategy.html">属性匹配策略</a>来注册属性兼容性规则。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:abm_disambiguation_rules"><a class="anchor" href="#sec:abm_disambiguation_rules"></a> <a class="link" href="#sec:abm_disambiguation_rules">属性消歧规则</a></h6>
<div class="paragraph">
<p>因为一个属性的多个值可以与请求的属性<em>兼容</em> ，所以Gradle需要在候选者之间进行选择。这是通过实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/AttributeDisambiguationRule.html">属性消歧规则</a>来完成的。</p>
</div>
<div class="paragraph">
<p>必须通过可从<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/AttributesSchema.html">属性架构中</a>获取的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/attributes/AttributeMatchingStrategy.html">属性匹配策略</a>来注册属性消歧规则。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cross_project_publications"><a class="anchor" href="#cross_project_publications"></a> <a class="link" href="#cross_project_publications">在项目之间共享输出</a></h4>
<div class="paragraph">
<p>在多项目构建中，一个常见的模式是一个项目消耗另一个项目的工件。通常，Java生态系统中最简单的消耗形式是<code>A</code>依赖于取决于<code>B</code> ， 然后<code>A</code>取决于<code>jar</code>按项目生产<code>B</code> 。如本章先前所述，此模型由<code>A</code> <em>取决于</em>一个<em>变种</em> <code>B</code> ，其中根据以下需求选择变体<code>A</code> 。为了进行编译，我们需要<code>B</code> ，由<code>apiElements</code>变体。对于运行时，我们需要<code>B</code> ，由<code>runtimeElements</code>变体。</p>
</div>
<div class="paragraph">
<p>但是，如果您需要与主要工件<em>不同的</em>工件怎么办？例如，Gradle为依赖于另一个项目的<a href="#sec:java_test_fixtures">测试装置</a>提供了内置支持，但是有时候，您需要依赖的工件并没有被公开为变体。</p>
</div>
<div class="paragraph">
<p>为了在项目之间<em>安全共享</em>并允许最大性能（并行度），必须通过<em>传出配置</em>公开此类工件。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="title">不要直接引用其他项目任务</div>
<div class="paragraph">
<p>声明跨项目依赖关系的常见反模式是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
   <span class="comment">// this is unsafe!</span>
   implementation project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:other</span><span class="delimiter">&quot;</span></span>).tasks.someOtherJar
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此发布模型<em>不安全，</em>并且可能导致不可复制且难以并行化内部版本。本节说明如何通过使用<em>变体</em>在项目之间定义“交换”来<em>正确创建跨项目边界</em> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有两个互补的选项可以在项目之间共享工件。仅当您需要共享的是不依赖于使用者的简单工件时， <a href="#sec:simple-sharing-artifacts-between-projects">简化版本</a>才适用。简单的解决方案还限于未将此工件发布到存储库的情况。这也意味着使用者不会发布对此工件的依赖关系。如果使用者在不同的环境（例如，不同的目标平台）中解决不同的工件或需要该出版物，则需要使用<a href="#sec:variant-aware-sharing">高级版本</a> 。</p>
</div>
<div class="sect4">
<h5 id="sec:simple-sharing-artifacts-between-projects"><a class="anchor" href="#sec:simple-sharing-artifacts-between-projects"></a> <a class="link" href="#sec:simple-sharing-artifacts-between-projects">项目之间工件的简单共享</a></h5>
<div class="paragraph">
<p>首先，生产者需要声明将要<em>暴露</em>给消费者的配置。如<a href="#sec:resolvable-consumable-configs">配置章节</a>中所述，这对应于<em>消耗性配置</em> 。</p>
</div>
<div class="paragraph">
<p>让我们想象一下，消费者需要生产者提供的<em>检测类</em> ，但是该工件<em>不是</em>主要工件。生产者可以通过创建将“承载”此工件的配置来公开其检测的类：</p>
</div>
<div class="exampleblock">
<div class="title">示例372声明即将发布的变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    instrumentedJars {
        canBeConsumed = <span class="predefined-constant">true</span>
        canBeResolved = <span class="predefined-constant">false</span>
        <span class="comment">// If you want this configuration to share the same dependencies, otherwise omit this line</span>
        extendsFrom implementation, runtimeOnly
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val instrumentedJars by configurations.creating {
    isCanBeConsumed = true
    isCanBeResolved = false
    // If you want this configuration to share the same dependencies, otherwise omit this line
    extendsFrom(configurations[&quot;implementation&quot;], configurations[&quot;runtimeOnly&quot;])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种配置是<em>可消耗的</em> ，这意味着它是供消费者使用的“交换产品”。现在，我们要向此配置添加工件，消费者在使用它时会得到：</p>
</div>
<div class="exampleblock">
<div class="title">示例373将工件附加到外发配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">artifacts {
    instrumentedJars(instrumentedJar)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">artifacts {
    add(&quot;instrumentedJars&quot;, instrumentedJar)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里，我们要附加的“工件”实际上是一个生成Jar的<em>任务</em> 。这样做，Gradle可以自动跟踪此任务的依赖关系并根据需要构建它们。这是可能的，因为<code>Jar</code>任务扩展<code>AbstractArchiveTask</code> 。如果不是这种情况，则需要显式声明工件的生成方式。</p>
</div>
<div class="exampleblock">
<div class="title">示例374明确工件的任务依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">artifacts {
    instrumentedJars(someTask.outputFile) {
        builtBy(someTask)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">artifacts {
    add(&quot;instrumentedJars&quot;, someTask.outputFile) {
        builtBy(someTask)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在， <em>消费者</em>需要依赖于此配置以获得正确的工件：</p>
</div>
<div class="exampleblock">
<div class="title">示例375明确的配置依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    instrumentedClasspath(project(<span class="key">path</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">:producer</span><span class="delimiter">&quot;</span></span>, <span class="key">configuration</span>: <span class="string"><span class="delimiter">'</span><span class="content">instrumentedJars</span><span class="delimiter">'</span></span>))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    instrumentedClasspath(project(mapOf(
        &quot;path&quot; to &quot;:producer&quot;,
        &quot;configuration&quot; to &quot;instrumentedJars&quot;)))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果计划发布具有此依赖关系的组件， <em>则不建议</em>声明对显式目标配置的依赖关系：这可能会导致元数据损坏。如果需要在远程存储库上发布组件，请遵循可识别<a href="#sec:variant-aware-sharing">变体的交叉发布文档中的说明</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下，我们将依赖项添加到<em>instrumentedClasspath</em>配置中，这是<em>消费者特定的配置</em> 。在Gradle术语中，这称为<a href="#sec:resolvable-consumable-configs">可解析配置</a> ，其定义方式如下：</p>
</div>
<div class="exampleblock">
<div class="title">示例376。在使用者上声明可解析的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    instrumentedClasspath {
        canBeConsumed = <span class="predefined-constant">false</span>
        canBeResolved = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val instrumentedClasspath by configurations.creating {
    isCanBeConsumed = false
    isCanBeResolved = true
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:variant-aware-sharing"><a class="anchor" href="#sec:variant-aware-sharing"></a> <a class="link" href="#sec:variant-aware-sharing">项目之间工件的变体感知共享</a></h5>
<div class="paragraph">
<p>在<a href="#sec:simple-sharing-artifacts-between-projects">简单的共享解决方案中</a> ，我们在生产者端定义了一个配置，用作生产者和消费者之间的工件交换。但是，使用者必须明确指出它所依赖的配置，这是我们在<em>变体感知分辨率下</em>要避免的配置。实际上，我们还<a href="#understanding-variant-selection">解释了</a> ，消费者可以使用<em>属性</em>来表达需求，而生产者也应该使用<em>属性</em>来提供适当的输出变体。这样可以进行更明智的选择，因为使用单个依赖项声明，而无需任何明确的目标配置，使用者可以解决不同的问题。典型的示例是使用单个依赖项声明<code>project(":myLib")</code> ，我们要么选择<code>arm64</code>要么<code>i386</code>版本<code>myLib</code>取决于架构。</p>
</div>
<div class="paragraph">
<p>为此，我们将向消费者和生产者添加属性。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>重要的是要了解，一旦配置具有属性，它们便会参与<em>变体感知的解析</em> ，这意味着只要有<em>任何</em>类似的符号<code>project(":myLib")</code>用来。换句话说，在生产者上设置的属性<em>必须与在同一项目上生产的其他变体一致</em> 。他们尤其不能为现有选择引入歧义。</p>
</div>
<div class="paragraph">
<p>实际上，这意味着在您创建的配置上使用的属性集可能取决于所使用的<em>生态系统</em> （Java，C ++，...），因为这些生态系统的相关插件通常使用不同的属性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>让我们增强前面的示例，它恰好是一个Java库项目。Java库向使用者提供了几种变体， <code>apiElements</code>和<code>runtimeElements</code> 。现在，我们要添加第三个<code>instrumentedJars</code> 。</p>
</div>
<div class="paragraph">
<p>因此，我们需要了解新变体的用途，以便在其上设置适当的属性。让我们看一下我们在<code>runtimeElements</code>组态：</p>
</div>
<div class="listingblock">
<div class="title">gradle OutboundVariants --variant runtimeElements</div>
<div class="content">
<pre class="CodeRay highlight"><code>Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 11
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-runtime</code></pre>
</div>
</div>
<div class="paragraph">
<p>它告诉我们的是Java库插件产生具有5个属性的变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.category</code>告诉我们，此变体代表一个<em>库</em></p>
</li>
<li>
<p><code>org.gradle.dependency.bundling</code>告诉我们，此变体的依赖项以jar形式找到（例如，它们没有在jar中重新包装）</p>
</li>
<li>
<p><code>org.gradle.jvm.version</code>告诉我们该库支持的最低Java版本是Java 11</p>
</li>
<li>
<p><code>org.gradle.libraryelements</code>告诉我们此变体包含在jar中找到的所有元素（类和资源）</p>
</li>
<li>
<p><code>org.gradle.usage</code>表示此变体是Java运行时，因此既适用于Java编译器，也适用于运行时</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，如果我们希望在执行测试时使用我们的工具化类代替此变量，则需要将类似的属性附加到变量中。实际上，我们关心的属性是<code>org.gradle.libraryelements</code>解释<em>了变体包含的内容</em> ，因此我们可以通过以下方式设置变体：</p>
</div>
<div class="exampleblock">
<div class="title">示例377。声明变量属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    instrumentedJars {
        canBeConsumed = <span class="predefined-constant">true</span>
        canBeResolved = <span class="predefined-constant">false</span>
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, JavaVersion.current().majorVersion.toInteger())
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, <span class="string"><span class="delimiter">'</span><span class="content">instrumented-jar</span><span class="delimiter">'</span></span>))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">生产者/ build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val instrumentedJars by configurations.creating {
    isCanBeConsumed = true
    isCanBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, namedAttribute(Category.LIBRARY))
        attribute(Usage.USAGE_ATTRIBUTE, namedAttribute(Usage.JAVA_RUNTIME))
        attribute(Bundling.BUNDLING_ATTRIBUTE, namedAttribute(Bundling.EXTERNAL))
        attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, JavaVersion.current().majorVersion.toInt())
        attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, namedAttribute(&quot;instrumented-jar&quot;))
    }
}

inline fun &lt;reified T: Named&gt; Project.namedAttribute(value: String) = objects.named(T::class.java, value)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>选择正确的属性进行设置是此过程中最困难的事情，因为它们具有变体的语义。因此，在添加<em>新属性</em>之前，您应该始终询问自己是否没有一个可以承载所需语义的属性。如果没有，则可以添加一个新属性。添加新属性时，还必须小心，因为在选择过程中可能会产生歧义。通常，添加属性意味着将其添加到<em>所有</em>现有变体中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们在这里所做的是，我们添加了一个<em>新的</em>变体，可以<em>在运行时</em>使用它，但它包含检测类而不是普通类。但是，现在这意味着对于运行时，使用者必须在两个变体之间进行选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>runtimeElements</code> ，是由<code>java-library</code>插入</p>
</li>
<li>
<p><code>instrumentedJars</code> ，我们创建的变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>特别要说的是，我们要在测试运行时类路径上插入检测后的类。现在，我们可以在使用者上将我们的依赖项声明为常规项目依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">示例378声明项目依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
    testImplementation project(<span class="string"><span class="delimiter">'</span><span class="content">:producer</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;junit:junit:4.12&quot;)
    testImplementation(project(&quot;:producer&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果我们在这里停止，Gradle仍会选择<code>runtimeElements</code>替代我们的变体<code>instrumentedJars</code>变体。这是因为<code>testRuntimeClasspath</code>配置要求配置<code>libraryelements</code>属性是<code>jar</code> ，以及我们的新产品<code>instrumented-jars</code>值<em>不兼容</em> 。</p>
</div>
<div class="paragraph">
<p>因此，我们需要更改请求的属性，以便现在查找已检测的罐子：</p>
</div>
<div class="exampleblock">
<div class="title">示例379更改消费者属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    testRuntimeClasspath {
        attributes {
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, <span class="string"><span class="delimiter">'</span><span class="content">instrumented-jar</span><span class="delimiter">'</span></span>))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">configurations {
    testRuntimeClasspath {
        attributes {
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements::class.java, &quot;instrumented-jar&quot;))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们告诉我们，每当要解析测试运行时类路径时，我们正在寻找的是<em>插补类</em> 。但是，有一个问题：在我们的依赖项列表中，我们有JUnit，很明显，它<em>没有进行</em>检测。因此，如果我们在这里停下来，Gradle将会失败，并说明没有提供已检测类的JUnit变体。这是因为我们没有解释说，如果没有可用的工具版本，则使用常规jar很好。为此，我们需要编写一个<em>兼容性规则</em> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例380相容性规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">InstrumentedJarsRule</span> <span class="directive">implements</span> AttributeCompatibilityRule&lt;LibraryElements&gt; {

    <span class="annotation">@Override</span>
    <span class="type">void</span> execute(CompatibilityCheckDetails&lt;LibraryElements&gt; details) {
        <span class="keyword">if</span> (details.consumerValue.name == <span class="string"><span class="delimiter">'</span><span class="content">instrumented-jar</span><span class="delimiter">'</span></span> &amp;&amp; details.producerValue.name == <span class="string"><span class="delimiter">'</span><span class="content">jar</span><span class="delimiter">'</span></span>) {
            details.compatible()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class InstrumentedJarsRule: AttributeCompatibilityRule&lt;LibraryElements&gt; {

    override fun execute(details: CompatibilityCheckDetails&lt;LibraryElements&gt;) = details.run {
        if (consumerValue?.name == &quot;instrumented-jar&quot; &amp;&amp; producerValue?.name == &quot;jar&quot;) {
            compatible()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们需要在属性模式上声明：</p>
</div>
<div class="exampleblock">
<div class="title">示例381利用兼容性规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    attributesSchema {
        attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE) {
            compatibilityRules.add(InstrumentedJarsRule)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">消费者/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    attributesSchema {
        attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE) {
            compatibilityRules.add(InstrumentedJarsRule::class.java)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就是这样！现在我们有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加了一个提供仪器罐子的变体</p>
</li>
<li>
<p>解释说，此变体可以替代运行时</p>
</li>
<li>
<p>解释说，使用者<em>仅在测试运行时</em>需要此变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，Gradle提供了一种强大的机制，可以根据偏好和兼容性选择正确的变体。可以<a href="#">在文档的“了解变体的插件”部分中</a>找到更多详细信息。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>通过像我们一样向现有属性添加值，或通过定义新属性，我们可以扩展模型。这意味着<em>所有消费者</em>都必须了解此扩展模型。对于本地使用者，这通常不是问题，因为所有项目都理解并共享相同的模式，但是如果您必须将此新变体发布到外部存储库，则意味着外部使用者必须为其构建添加相同的规则他们通过。对于<em>生态系统插件</em> （例如Kotlin插件）而言，这通常不是问题，在任何情况下，如果不应用插件就无法消费，但是如果添加自定义值或属性，则是一个问题。</p>
</div>
<div class="paragraph">
<p>因此， <strong>避免发布</strong>仅用于内部使用的<strong>自定义变体</strong> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="targeting-different-platforms"><a class="anchor" href="#targeting-different-platforms"></a> <a class="link" href="#targeting-different-platforms">定位不同的平台</a></h5>
<div class="paragraph">
<p>库针对不同平台的情况很常见。在Java生态系统中，我们经常看到同一库的不同工件，以不同的<em>分类器进行</em>区分。一个典型的例子是番石榴，其发布方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>guava-jre</code>适用于JDK 8及更高版本</p>
</li>
<li>
<p><code>guava-android</code>对于JDK 7</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种方法的问题是没有与分类器相关的语义。特别是，依赖项解析引擎无法根据用户需求自动确定要使用哪个版本。例如，最好表示您对Guava有依赖性，然后让引擎在<code>jre</code>和<code>android</code>基于什么兼容。</p>
</div>
<div class="paragraph">
<p>Gradle为此提供了一种改进的模型，它没有分类器的弱点：属性。</p>
</div>
<div class="paragraph">
<p>特别是在Java生态系统中，Gradle提供了一个内置属性，库作者可以使用该属性来表达与Java生态系统的兼容性： <code>org.gradle.jvm.version</code> 。此属性表示<em>使用者必须具备</em>的<em>最低版本才能正常工作</em> 。</p>
</div>
<div class="paragraph">
<p>当您应用<code>java</code>要么<code>java-library</code>插件，Gradle会自动将此属性与即将发布的变体相关联。这意味着，所有使用Gradle发布的库都会自动告知它们使用的目标平台。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>org.gradle.jvm.version</code>设置为源集的<em>目标兼容性</em> 。</p>
</div>
<div class="paragraph">
<p>自动设置此属性后，默认情况下，Gradle <em>不会</em>允许您为不同的JVM构建项目。如果需要执行此操作，则需要<a href="#sec:variant-aware-sharing">按照有关变体感知匹配</a>的<a href="#sec:variant-aware-sharing">说明</a>创建其他变体。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">Gradle的未来版本将提供自动为不同Java平台构建的方法。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:abm_artifact_transforms"><a class="anchor" href="#sec:abm_artifact_transforms"></a> <a class="link" href="#sec:abm_artifact_transforms">转换解决方案上的依赖工件</a></h4>
<div class="paragraph">
<p>如在<a href="#sec:resolvable-consumable-configs">不同类型的配置中所述</a> ，对于相同的依赖项可能有不同的变体。例如，外部Maven依赖项具有一个变体，在针对依赖项进行编译时应使用该变体（ <code>java-api</code> ），以及用于运行使用依赖项的应用程序的变体（ <code>java-runtime</code> ）。项目依赖项甚至有更多的变体，例如，用于编译的项目类可作为类目录使用（ <code>org.gradle.usage=java-api, org.gradle.libraryelements=classes</code> ）或JAR（ <code>org.gradle.usage=java-api, org.gradle.libraryelements=jar</code> ）。</p>
</div>
<div class="paragraph">
<p>依赖项的变体在其传递性依赖项或工件本身中可能有所不同。例如， <code>java-api</code>和<code>java-runtime</code> Maven依赖项的变体仅在传递性依赖项上有所不同，并且都使用相同的工件-JAR文件。对于项目依赖性， <code>java-api,classes</code>和<code>java-api,jars</code>变体具有相同的传递依赖关系和不同的工件-分别是class目录和JAR文件。</p>
</div>
<div class="paragraph">
<p>Gradle通过<a href="#sec:abm_configuration_attributes">属性</a>集唯一地识别依赖项的变体。的<code>java-api</code>依赖项的变体是由<code>org.gradle.usage</code>具有价值的属性<code>java-api</code> 。</p>
</div>
<div class="paragraph">
<p>当Gradle解析配置时，解析的配置上的<a href="#sec:abm_configuration_attributes">属性</a>将确定<em>请求的属性</em> 。对于配置中的所有依赖关系，在解析配置时都会选择具有请求属性的变量。例如，当配置请求<code>org.gradle.usage=java-api, org.gradle.libraryelements=classes</code>在项目依赖项上，然后选择classes目录作为工件。</p>
</div>
<div class="paragraph">
<p>如果依赖项没有具有所请求属性的变量，则解析配置失败。有时可以在不更改传递依赖项的情况下将依赖项的工件转换为请求的变体。例如，解压缩JAR会转换<code>java-api,jars</code>变入<code>java-api,classes</code>变体。这种转换称为“ <em>伪影转换”</em> 。Gradle允许注册工件转换，并且当依赖项没有所请求的变体时，Gradle将尝试查找一系列工件转换以创建变体。</p>
</div>
<div class="sect4">
<h5 id="artifact_transform_selection_and_execution"><a class="anchor" href="#artifact_transform_selection_and_execution"></a> <a class="link" href="#artifact_transform_selection_and_execution">工件转换选择和执行</a></h5>
<div class="paragraph">
<p>如上所述，当Gradle解析配置并且配置中的依存关系不具有带有所请求属性的变体时，Gradle会尝试查找一系列工件转换以创建变体。查找伪像变换的匹配链的过程称为<em>伪像变换选择</em> 。每个注册的转换都从一组属性转换为一组属性。例如，解压缩转换可以从<code>org.gradle.usage=java-api, org.gradle.libraryelements=jars</code>至<code>org.gradle.usage=java-api, org.gradle.libraryelements=classes</code> 。</p>
</div>
<div class="paragraph">
<p>为了找到一条链，Gradle从请求的属性开始，然后将所有修改某些请求的属性的转换视为通向那里的可能路径。倒退，Gradle尝试使用转换获取到某些现有变体的路径。</p>
</div>
<div class="paragraph">
<p>例如，考虑一个<code>minified</code>具有两个值的属性： <code>true</code>和<code>false</code> 。minified属性表示依赖项的变体，其中删除了不必要的类文件。已注册了工件转换，可以进行转换<code>minified</code>从<code>false</code>至<code>true</code> 。什么时候<code>minified=true</code>被要求提供依赖性，并且只有带有<code>minified=false</code> ，然后Gradle选择注册的缩小变换。minify转换能够转换依赖项的伪像<code>minified=false</code>与神器<code>minified=true</code> 。</p>
</div>
<div class="paragraph">
<p>在找到的所有变换链中，Gradle尝试选择最佳的变换链：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果只有一个转换链，则选择它。</p>
</li>
<li>
<p>如果有两个变换链，并且一个是另一个的后缀，则将其选中。</p>
</li>
<li>
<p>如果存在最短的变换链，则将其选中。</p>
</li>
<li>
<p>在所有其他情况下，选择将失败并报告错误。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>当已经存在与请求属性匹配的依赖项变体时，Gradle不会尝试选择工件转换。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>artifactType</code>属性是特殊的，因为它仅存在于解析的工件上，而不存在于依赖项上。结果，任何仅变异的变换<code>artifactType</code>仅使用<code>artifactType</code>根据要求的属性。仅在使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/ArtifactView.html">ArtifactView</a>时才考虑使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>选择所需的工件变换后，Gradle会解析链中初始变换所需的依赖项变体。通过下载外部依赖项或执行生成工件的任务，Gradle完成解决变体的工件后，Gradle便开始使用选定的工件转换链来转换变体的工件。Gradle在可能的情况下并行执行变换链。</p>
</div>
<div class="paragraph">
<p>拿起上面的minify示例，考虑具有两个依赖关系的配置，外部<code>guava</code>依赖和项目依赖<code>producer</code>项目。该配置具有属性<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true</code> 。外部<code>guava</code>依赖项有两个变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code>和</p>
</li>
<li>
<p><code>org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用minify变换，Gradle可以转换变体<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code>的<code>guava</code>至<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true</code> ，这是请求的属性。项目依赖项还具有变体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code> ，</p>
</li>
<li>
<p><code>org.gradle.usage=java-runtime,org.gradle.libraryelements=classes,minified=false</code> ，</p>
</li>
<li>
<p><code>org.gradle.usage=java-api,org.gradle.libraryelements=jar,minified=false</code> ，</p>
</li>
<li>
<p><code>org.gradle.usage=java-api,org.gradle.libraryelements=classes,minified=false</code></p>
</li>
<li>
<p>还有一些。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>同样，使用minify变换，Gradle可以转换变体<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=false</code>项目的<code>producer</code>至<code>org.gradle.usage=java-runtime,org.gradle.libraryelements=jar,minified=true</code> ，这是请求的属性。</p>
</div>
<div class="paragraph">
<p>解决配置后，Gradle需要下载<code>guava</code> JAR并将其最小化。Gradle还需要执行<code>producer:jar</code>任务来生成项目的JAR工件，然后将其最小化。下载和缩小<code>guava.jar</code>与执行并行<code>producer:jar</code>任务和生成的JAR的缩小。</p>
</div>
<div class="paragraph">
<p>这是设置方法<code>minified</code>属性，以便上面的作品。您需要在模式中注册新属性，将其添加到所有JAR工件中，并在所有可解析配置中请求它。</p>
</div>
<div class="exampleblock">
<div class="title">示例382工件转换属性设置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> artifactType = <span class="predefined-type">Attribute</span>.of(<span class="string"><span class="delimiter">'</span><span class="content">artifactType</span><span class="delimiter">'</span></span>, <span class="predefined-type">String</span>)
<span class="keyword">def</span> minified = <span class="predefined-type">Attribute</span>.of(<span class="string"><span class="delimiter">'</span><span class="content">minified</span><span class="delimiter">'</span></span>, <span class="predefined-type">Boolean</span>)
dependencies {
    attributesSchema {
        attribute(minified)                      // <b class="conum">(1)</b>
    }
    artifactTypes.getByName(<span class="string"><span class="delimiter">&quot;</span><span class="content">jar</span><span class="delimiter">&quot;</span></span>) {
        attributes.attribute(minified, <span class="predefined-constant">false</span>)    // <b class="conum">(2)</b>
    }
}

configurations.all {
    afterEvaluate {
        <span class="keyword">if</span> (canBeResolved) {
            attributes.attribute(minified, <span class="predefined-constant">true</span>) // <b class="conum">(3)</b>
        }
    }
}

dependencies {
    registerTransform(Minify) {
        from.attribute(minified, <span class="predefined-constant">false</span>).attribute(artifactType, <span class="string"><span class="delimiter">&quot;</span><span class="content">jar</span><span class="delimiter">&quot;</span></span>)
        to.attribute(minified, <span class="predefined-constant">true</span>).attribute(artifactType, <span class="string"><span class="delimiter">&quot;</span><span class="content">jar</span><span class="delimiter">&quot;</span></span>)
    }
}

dependencies {                                 // <b class="conum">(4)</b>
    implementation(<span class="string"><span class="delimiter">'</span><span class="content">com.google.guava:guava:27.1-jre</span><span class="delimiter">'</span></span>)
    implementation(project(<span class="string"><span class="delimiter">'</span><span class="content">:producer</span><span class="delimiter">'</span></span>))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val artifactType = Attribute.of(&quot;artifactType&quot;, String::class.java)
val minified = Attribute.of(&quot;minified&quot;, Boolean::class.javaObjectType)
dependencies {
    attributesSchema {
        attribute(minified)                      // <b class="conum">(1)</b>
    }
    artifactTypes.getByName(&quot;jar&quot;) {
        attributes.attribute(minified, false)    // <b class="conum">(2)</b>
    }
}

configurations.all {
    afterEvaluate {
        if (isCanBeResolved) {
            attributes.attribute(minified, true) // <b class="conum">(3)</b>
        }
    }
}

dependencies {
    registerTransform(Minify::class) {
        from.attribute(minified, false).attribute(artifactType, &quot;jar&quot;)
        to.attribute(minified, true).attribute(artifactType, &quot;jar&quot;)
    }
}

dependencies {                                 // <b class="conum">(4)</b>
    implementation(&quot;com.google.guava:guava:27.1-jre&quot;)
    implementation(project(&quot;:producer&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>将属性添加到架构</p>
</li>
<li>
<p>未缩小所有JAR文件</p>
</li>
<li>
<p>请求<code>minified=true</code>在所有可解析的配置上</p>
</li>
<li>
<p>添加将要转换的依赖项</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在，您可以看到运行我们的<code>resolveRuntimeClasspath</code>解决的任务<code>runtimeClasspath</code>组态。观察到Gradle在转换项目依赖项之前<code>resolveRuntimeClasspath</code>任务开始。Gradle执行以下命令时会转换二进制依赖项<code>resolveRuntimeClasspath</code>任务。</p>
</div>
<div class="listingblock">
<div class="title">解决runtimeClasspath配置时的输出</div>
<div class="content">
<pre>&gt; gradle resolveRuntimeClasspath

&gt; Task :producer:compileJava
&gt; Task :producer:processResources NO-SOURCE
&gt; Task :producer:classes
&gt; Task :producer:jar

&gt; Transform artifact producer.jar (project :producer) with Minify
Nothing to minify - using producer.jar unchanged

&gt; Task :resolveRuntimeClasspath
Minifying guava-27.1-jre.jar
Nothing to minify - using listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar unchanged
Nothing to minify - using jsr305-3.0.2.jar unchanged
Nothing to minify - using checker-qual-2.5.2.jar unchanged
Nothing to minify - using error_prone_annotations-2.2.0.jar unchanged
Nothing to minify - using j2objc-annotations-1.1.jar unchanged
Nothing to minify - using animal-sniffer-annotations-1.17.jar unchanged
Nothing to minify - using failureaccess-1.0.1.jar unchanged

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:implementing-artifact-transforms"><a class="anchor" href="#sec:implementing-artifact-transforms"></a> <a class="link" href="#sec:implementing-artifact-transforms">实现工件转换</a></h5>
<div class="paragraph">
<p>与任务类型类似，工件转换由一个动作和一些参数组成。与自定义任务类型的主要区别在于，操作和参数被实现为两个单独的类。</p>
</div>
<div class="paragraph">
<p>工件转换动作的实现是实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.transform.TransformAction.html">TransformAction</a>的类。您需要实施<code>transform()</code>动作上的方法，它将输入伪像转换为零，一个或多个输出伪像。大多数伪像转换将是一对一的，因此transform方法会将输入伪像转换为恰好一个输出伪像。</p>
</div>
<div class="paragraph">
<p>工件转换动作的实现需要通过调用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:dir(java.lang.Object)">TransformOutputs.dir（）</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.transform.TransformOutputs.html#org.gradle.api.artifacts.transform.TransformOutputs:file(java.lang.Object)">TransformOutputs.file（）</a>来注册每个输出工件。</p>
</div>
<div class="paragraph">
<p>您只能提供两种类型的路径<code>dir</code>要么<code>file</code>方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>输入工件或输入工件中（输入目录）的绝对路径。</p>
</li>
<li>
<p>相对路径。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle使用绝对路径作为输出工件的位置。例如，如果输入工件是爆炸的WAR，则变换动作可以调用<code>TransformOutputs.file()</code>对于中的所有jar文件<code>WEB-INF/lib</code>目录。转换的输出将是Web应用程序的库JAR。</p>
</div>
<div class="paragraph">
<p>对于相对路径， <code>dir()</code>要么<code>file()</code>方法将工作空间返回到变换操作。转换动作的实现需要在提供的工作空间的位置处创建转换后的工件。</p>
</div>
<div class="paragraph">
<p>输出工件按注册顺序替换了转换后的变体中的输入工件。例如，如果配置包含工件<code>lib1.jar</code> ， <code>lib2.jar</code> ， <code>lib3.jar</code> ，并且变换操作会注册一个缩小的输出工件<code><artifact-name>-min.jar</code>对于输入工件，则转换后的配置包含工件<code>lib1-min.jar</code> ， <code>lib2-min.jar</code>和<code>lib3-min.jar</code> 。</p>
</div>
<div class="paragraph">
<p>这是一个<code>Unzip</code> transform通过解压缩将JAR文件转换为类目录。的<code>Unzip</code>转换不需要任何参数。注意实现如何使用<code>@InputArtifact</code>注入工件以转化为动作。它使用来请求解压缩类的目录<code>TransformOutputs.dir()</code>然后将JAR文件解压缩到该目录中。</p>
</div>
<div class="exampleblock">
<div class="title">示例383没有参数的工件转换</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">Unzip</span> <span class="directive">implements</span> TransformAction&lt;TransformParameters.None&gt; { // <b class="conum">(1)</b>
    <span class="annotation">@InputArtifact</span>                                                          // <b class="conum">(2)</b>
    <span class="directive">abstract</span> <span class="predefined-type">Provider</span>&lt;FileSystemLocation&gt; getInputArtifact()

    <span class="annotation">@Override</span>
    <span class="type">void</span> transform(TransformOutputs outputs) {
        <span class="keyword">def</span> input = inputArtifact.get().asFile
        <span class="keyword">def</span> unzipDir = outputs.dir(input.name)                              // <b class="conum">(3)</b>
        unzipTo(input, unzipDir)                                            // <b class="conum">(4)</b>
    }

    <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> unzipTo(<span class="predefined-type">File</span> zipFile, <span class="predefined-type">File</span> unzipDir) {
        <span class="comment">// implementation...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">abstract class Unzip : TransformAction&lt;TransformParameters.None&gt; {          // <b class="conum">(1)</b>
    @get:InputArtifact                                                      // <b class="conum">(2)</b>
    abstract val inputArtifact: Provider&lt;FileSystemLocation&gt;

    override
    fun transform(outputs: TransformOutputs) {
        val input = inputArtifact.get().asFile
        val unzipDir = outputs.dir(input.name)                              // <b class="conum">(3)</b>
        unzipTo(input, unzipDir)                                            // <b class="conum">(4)</b>
    }

    private fun unzipTo(zipFile: File, unzipDir: File) {
        // implementation...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用<code>TransformParameters.None</code>如果转换不使用参数</p>
</li>
<li>
<p>注入输入工件</p>
</li>
<li>
<p>请求解压缩文件的输出位置</p>
</li>
<li>
<p>做转换的实际工作</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>工件转换可能需要参数，例如<code>String</code>确定用于支持输入工件转换的某些过滤器或文件集合。为了将这些参数传递给转换动作，您需要使用所需参数定义一个新类型。该类型需要实现标记接口<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/transform/TransformParameters.html">TransformParameters</a> 。必须使用<a href="#managed_properties">托管属性</a>来表示参数，并且参数类型必须是<a href="#managed_types">托管类型</a> 。您可以使用接口或抽象类声明getter，然后Gradle将生成实现。所有吸气剂都需要具有正确的输入注释，请参阅“ <a href="#table:incremental_build_annotations">增量构建</a> ”部分中的表。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="#custom_gradle_types">开发自定义Gradle类型中</a>找到有关实现工件转换参数的更多信息。</p>
</div>
<div class="paragraph">
<p>这是一个的实现<code>Minify</code>仅保留某些类，从而使JAR变小的转换。的<code>Minify</code> transform需要将类保留为参数。观察如何通过以下方式获取参数<code>TransformAction.getParameters()</code>在里面<code>transform()</code>方法。实施<code>transform()</code>方法通过使用来为缩小的JAR请求位置<code>TransformOutputs.file()</code>然后在此位置创建缩小的JAR。</p>
</div>
<div class="exampleblock">
<div class="title">实施例384。缩小转换实施</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">Minify</span> <span class="directive">implements</span> TransformAction&lt;Parameters&gt; { // <b class="conum">(1)</b>
    <span class="type">interface</span> Parameters <span class="directive">extends</span> TransformParameters {         // <b class="conum">(2)</b>
        <span class="annotation">@Input</span>
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt;&gt; getKeepClassesByArtifact()
        <span class="type">void</span> setKeepClassesByArtifact(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt;&gt; keepClasses)
    }

    <span class="annotation">@PathSensitive</span>(PathSensitivity.NAME_ONLY)
    <span class="annotation">@InputArtifact</span>
    <span class="directive">abstract</span> <span class="predefined-type">Provider</span>&lt;FileSystemLocation&gt; getInputArtifact()

    <span class="annotation">@Override</span>
    <span class="type">void</span> transform(TransformOutputs outputs) {
        <span class="keyword">def</span> fileName = inputArtifact.get().asFile.name
        <span class="keyword">for</span> (entry <span class="keyword">in</span> parameters.keepClassesByArtifact) {      // <b class="conum">(3)</b>
            <span class="keyword">if</span> (fileName.startsWith(entry.key)) {
                <span class="keyword">def</span> nameWithoutExtension = fileName.substring(<span class="integer">0</span>, fileName.length() - <span class="integer">4</span>)
                minify(inputArtifact.get().asFile, entry.value, outputs.file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>nameWithoutExtension<span class="inline-delimiter">}</span></span><span class="content">-min.jar</span><span class="delimiter">&quot;</span></span>))
                <span class="keyword">return</span>
            }
        }
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Nothing to minify - using </span><span class="inline"><span class="inline-delimiter">${</span>fileName<span class="inline-delimiter">}</span></span><span class="content"> unchanged</span><span class="delimiter">&quot;</span></span>
        outputs.file(inputArtifact)                            // <b class="conum">(4)</b>
    }

    <span class="directive">private</span> <span class="type">void</span> minify(<span class="predefined-type">File</span> artifact, <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; keepClasses, <span class="predefined-type">File</span> jarFile) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Minifying </span><span class="inline"><span class="inline-delimiter">${</span>artifact.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
        <span class="comment">// Implementation ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">abstract class Minify : TransformAction&lt;Minify.Parameters&gt; {   // <b class="conum">(1)</b>
    interface Parameters : TransformParameters {               // <b class="conum">(2)</b>
        @get:Input
        var keepClassesByArtifact: Map&lt;String, Set&lt;String&gt;&gt;

    }

    @get:PathSensitive(PathSensitivity.NAME_ONLY)
    @get:InputArtifact
    abstract val inputArtifact: Provider&lt;FileSystemLocation&gt;

    override
    fun transform(outputs: TransformOutputs) {
        val fileName = inputArtifact.get().asFile.name
        for (entry in parameters.keepClassesByArtifact) {      // <b class="conum">(3)</b>
            if (fileName.startsWith(entry.key)) {
                val nameWithoutExtension = fileName.substring(0, fileName.length - 4)
                minify(inputArtifact.get().asFile, entry.value, outputs.file(&quot;${nameWithoutExtension}-min.jar&quot;))
                return
            }
        }
        println(&quot;Nothing to minify - using ${fileName} unchanged&quot;)
        outputs.file(inputArtifact)                            // <b class="conum">(4)</b>
    }

    private fun minify(artifact: File, keepClasses: Set&lt;String&gt;, jarFile: File) {
        println(&quot;Minifying ${artifact.name}&quot;)
        // Implementation ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>声明参数类型</p>
</li>
<li>
<p>转换参数接口</p>
</li>
<li>
<p>使用参数</p>
</li>
<li>
<p>当不需要缩小时使用不变的输入工件</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请记住，输入工件是一个依赖项，它可能具有自己的依赖项。如果您的工件转换需要访问这些传递依赖项，则可以声明一个抽象getter返回一个<code>FileCollection</code>并使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html">@InputArtifactDependencies</a>对其进行<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html">注释</a> 。运行转换时，Gradle会将可传递依赖项注入<code>FileCollection</code>通过实现getter实现属性。请注意，在转换中使用输入工件依赖项会影响性能，只有在确实需要它们时才注入它们。</p>
</div>
<div class="paragraph">
<p>此外，工件转换可以将<a href="#build_cache">构建缓存</a>用于其输出。要为构件转换启用构建缓存，请添加<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/transform/CacheableTransform.html">CacheableTransform</a></code>动作类上的注释。对于可缓存的转换，必须使用规范化注释（例如<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/PathSensitive.html">@PathSensitive）</a>注释其<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/transform/InputArtifact.html">@InputArtifact</a>属性-以及所有标记有<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/transform/InputArtifactDependencies.html">@InputArtifactDependencies的</a>属性。</p>
</div>
<div class="paragraph">
<p>下面的示例显示一个更复杂的转换。它将JAR的某些选定类移动到不同的包，并使用移动的类重写类和所有类的字节码（类重定位）。为了确定要重定位的类，它查看输入工件的包和输入工件的依赖项。它还不会在外部类路径中重新放置JAR文件中包含的包。</p>
</div>
<div class="exampleblock">
<div class="title">示例385用于类重定位的工件转换</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@CacheableTransform</span>                                                          // <b class="conum">(1)</b>
<span class="directive">abstract</span> <span class="type">class</span> <span class="class">ClassRelocator</span> <span class="directive">implements</span> TransformAction&lt;Parameters&gt; {
    <span class="type">interface</span> Parameters <span class="directive">extends</span> TransformParameters {                       // <b class="conum">(2)</b>
        <span class="annotation">@CompileClasspath</span>                                                    // <b class="conum">(3)</b>
        ConfigurableFileCollection getExternalClasspath()
        <span class="annotation">@Input</span>
        Property&lt;<span class="predefined-type">String</span>&gt; getExcludedPackage()
    }

    <span class="annotation">@Classpath</span>                                                               // <b class="conum">(4)</b>
    <span class="annotation">@InputArtifact</span>
    <span class="directive">abstract</span> <span class="predefined-type">Provider</span>&lt;FileSystemLocation&gt; getPrimaryInput()

    <span class="annotation">@CompileClasspath</span>
    <span class="annotation">@InputArtifactDependencies</span>                                               // <b class="conum">(5)</b>
    <span class="directive">abstract</span> FileCollection getDependencies()

    <span class="annotation">@Override</span>
    <span class="type">void</span> transform(TransformOutputs outputs) {
        <span class="keyword">def</span> primaryInputFile = primaryInput.get().asFile
        <span class="keyword">if</span> (parameters.externalClasspath.contains(primaryInput)) {           // <b class="conum">(6)</b>
            outputs.file(primaryInput)
        } <span class="keyword">else</span> {
            <span class="keyword">def</span> baseName = primaryInputFile.name.substring(<span class="integer">0</span>, primaryInputFile.name.length - <span class="integer">4</span>)
            relocateJar(outputs.file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>baseName</span><span class="content">-relocated.jar</span><span class="delimiter">&quot;</span></span>))
        }
    }

    <span class="directive">private</span> relocateJar(<span class="predefined-type">File</span> output) {
        <span class="comment">// implementation...</span>
        <span class="keyword">def</span> relocatedPackages = (dependencies.collectMany { readPackages(<span class="local-variable">it</span>) } + readPackages(primaryInput.get().asFile)) <span class="keyword">as</span> <span class="predefined-type">Set</span>
        <span class="keyword">def</span> nonRelocatedPackages = parameters.externalClasspath.collectMany { readPackages(<span class="local-variable">it</span>) }
        <span class="keyword">def</span> relocations = (relocatedPackages - nonRelocatedPackages).collect { packageName -&gt;
            <span class="keyword">def</span> toPackage = <span class="string"><span class="delimiter">&quot;</span><span class="content">relocated.</span><span class="inline"><span class="inline-delimiter">$</span>packageName</span><span class="delimiter">&quot;</span></span>
            println(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>packageName</span><span class="content"> -&gt; </span><span class="inline"><span class="inline-delimiter">$</span>toPackage</span><span class="delimiter">&quot;</span></span>)
            <span class="keyword">new</span> Relocation(packageName, toPackage)
        }
        <span class="keyword">new</span> JarRelocator(primaryInput.get().asFile, output, relocations).run()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">@CacheableTransform                                                          // <b class="conum">(1)</b>
abstract class ClassRelocator : TransformAction&lt;ClassRelocator.Parameters&gt; {
    interface Parameters : TransformParameters {                             // <b class="conum">(2)</b>
        @get:CompileClasspath                                                // <b class="conum">(3)</b>
        val externalClasspath: ConfigurableFileCollection
        @get:Input
        val excludedPackage: Property&lt;String&gt;
    }

    @get:Classpath                                                           // <b class="conum">(4)</b>
    @get:InputArtifact
    abstract val primaryInput: Provider&lt;FileSystemLocation&gt;

    @get:CompileClasspath
    @get:InputArtifactDependencies                                           // <b class="conum">(5)</b>
    abstract val dependencies: FileCollection

    override
    fun transform(outputs: TransformOutputs) {
        val primaryInputFile = primaryInput.get().asFile
        if (parameters.externalClasspath.contains(primaryInputFile)) {       // <b class="conum">(6)</b>
            outputs.file(primaryInput)
        } else {
            val baseName = primaryInputFile.name.substring(0, primaryInputFile.name.length - 4)
            relocateJar(outputs.file(&quot;$baseName-relocated.jar&quot;))
        }
    }

    private fun relocateJar(output: File) {
        // implementation...
        val relocatedPackages = (dependencies.flatMap { it.readPackages() } + primaryInput.get().asFile.readPackages()).toSet()
        val nonRelocatedPackages = parameters.externalClasspath.flatMap { it.readPackages() }
        val relocations = (relocatedPackages - nonRelocatedPackages).map { packageName -&gt;
            val toPackage = &quot;relocated.$packageName&quot;
            println(&quot;$packageName -&gt; $toPackage&quot;)
            Relocation(packageName, toPackage)
        }
        JarRelocator(primaryInput.get().asFile, output, relocations).run()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>声明可缓存的转换</p>
</li>
<li>
<p>转换参数接口</p>
</li>
<li>
<p>声明每个参数的输入类型</p>
</li>
<li>
<p>声明输入工件的规范化</p>
</li>
<li>
<p>注入输入工件依赖项</p>
</li>
<li>
<p>使用参数</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="registering_artifact_transforms"><a class="anchor" href="#registering_artifact_transforms"></a> <a class="link" href="#registering_artifact_transforms">注册工件转换</a></h5>
<div class="paragraph">
<p>您需要注册工件转换操作，并在必要时提供参数，以便在解析依赖项时可以选择它们。</p>
</div>
<div class="paragraph">
<p>为了注册工件转换，您必须在内部使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:registerTransform(java.lang.Class, org.gradle.api.Action)">registerTransform（）</a> <code>dependencies {}</code>块。</p>
</div>
<div class="paragraph">
<p>使用时有几点要考虑<code>registerTransform()</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>from</code>和<code>to</code>属性是必需的。</p>
</li>
<li>
<p>转换操作本身可以具有配置选项。您可以使用<code>parameters {}</code>块。</p>
</li>
<li>
<p>您必须在具有将要解决的配置的项目上注册转换。</p>
</li>
<li>
<p>您可以提供任何实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.transform.TransformAction.html">TransformAction的</a>类型给<code>registerTransform()</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，假设您想解压缩一些依赖项并将解压缩的目录和文件放在类路径中。您可以通过注册一种类型的工件转换操作来实现<code>Unzip</code> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例386没有参数的伪像转换配准</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> artifactType = <span class="predefined-type">Attribute</span>.of(<span class="string"><span class="delimiter">'</span><span class="content">artifactType</span><span class="delimiter">'</span></span>, <span class="predefined-type">String</span>)

dependencies {
    registerTransform(Unzip) {
        from.attribute(artifactType, <span class="string"><span class="delimiter">'</span><span class="content">jar</span><span class="delimiter">'</span></span>)
        to.attribute(artifactType, <span class="string"><span class="delimiter">'</span><span class="content">java-classes-directory</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val artifactType = Attribute.of(&quot;artifactType&quot;, String::class.java)

dependencies {
    registerTransform(Unzip::class) {
        from.attribute(artifactType, &quot;jar&quot;)
        to.attribute(artifactType, &quot;java-classes-directory&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另一个例子是，您只想保留一些JAR就可以使其最小化<code>class</code>他们的文件。注意使用<code>parameters {}</code>块提供类以保留最小的JAR到<code>Minify</code>转变。</p>
</div>
<div class="exampleblock">
<div class="title">示例387带参数的伪像转换配准</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> artifactType = <span class="predefined-type">Attribute</span>.of(<span class="string"><span class="delimiter">'</span><span class="content">artifactType</span><span class="delimiter">'</span></span>, <span class="predefined-type">String</span>)
<span class="keyword">def</span> minified = <span class="predefined-type">Attribute</span>.of(<span class="string"><span class="delimiter">'</span><span class="content">minified</span><span class="delimiter">'</span></span>, <span class="predefined-type">Boolean</span>)
<span class="keyword">def</span> keepPatterns = [
    <span class="string"><span class="delimiter">&quot;</span><span class="content">guava</span><span class="delimiter">&quot;</span></span>: [
        <span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.common.base.Optional</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.common.base.AbstractIterator</span><span class="delimiter">&quot;</span></span>
    ] <span class="keyword">as</span> <span class="predefined-type">Set</span>
]


dependencies {
    registerTransform(Minify) {
        from.attribute(minified, <span class="predefined-constant">false</span>).attribute(artifactType, <span class="string"><span class="delimiter">&quot;</span><span class="content">jar</span><span class="delimiter">&quot;</span></span>)
        to.attribute(minified, <span class="predefined-constant">true</span>).attribute(artifactType, <span class="string"><span class="delimiter">&quot;</span><span class="content">jar</span><span class="delimiter">&quot;</span></span>)

        parameters {
            keepClassesByArtifact = keepPatterns
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val artifactType = Attribute.of(&quot;artifactType&quot;, String::class.java)
val minified = Attribute.of(&quot;minified&quot;, Boolean::class.javaObjectType)
val keepPatterns = mapOf(
    &quot;guava&quot; to setOf(
        &quot;com.google.common.base.Optional&quot;,
        &quot;com.google.common.base.AbstractIterator&quot;
    )
)


dependencies {
    registerTransform(Minify::class) {
        from.attribute(minified, false).attribute(artifactType, &quot;jar&quot;)
        to.attribute(minified, true).attribute(artifactType, &quot;jar&quot;)

        parameters {
            keepClassesByArtifact = keepPatterns
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="implementing_incremental_artifact_transforms"><a class="anchor" href="#implementing_incremental_artifact_transforms"></a> <a class="link" href="#implementing_incremental_artifact_transforms">实施增量工件转换</a></h5>
<div class="paragraph">
<p>与<a href="#incremental_tasks">增量任务</a>类似，工件转换可以通过仅处理上次执行后更改的文件来避免工作。这是通过使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html">InputChanges</a>接口完成的。对于工件转换，只有输入工件是增量输入，因此转换只能查询那里的更改。为了在转换动作中使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html">InputChanges</a> ，请将其注入到动作中。有关如何使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html">InputChanges的</a>更多信息，请参见有关<a href="#incremental_tasks">增量任务</a>的相应文档。</p>
</div>
<div class="paragraph">
<p>这是一个增量转换的示例，它计算Java源文件中的代码行：</p>
</div>
<div class="exampleblock">
<div class="title">示例388用于代码行计数的工件转换</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">CountLoc</span> <span class="directive">implements</span> TransformAction&lt;TransformParameters.None&gt; {

    <span class="annotation">@Inject</span>
    <span class="directive">abstract</span> InputChanges getInputChanges()

    <span class="annotation">@PathSensitive</span>(PathSensitivity.RELATIVE)
    <span class="annotation">@InputArtifact</span>
    <span class="directive">abstract</span> <span class="predefined-type">Provider</span>&lt;FileSystemLocation&gt; getInput()

    <span class="annotation">@Override</span>
    <span class="type">void</span> transform(TransformOutputs outputs) {                          // <b class="conum">(1)</b>
        <span class="keyword">def</span> outputDir = outputs.dir(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>input.get().asFile.name<span class="inline-delimiter">}</span></span><span class="content">.loc</span><span class="delimiter">&quot;</span></span>)
        println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Running transform on </span><span class="inline"><span class="inline-delimiter">${</span>input.get().asFile.name<span class="inline-delimiter">}</span></span><span class="content">, incremental: </span><span class="inline"><span class="inline-delimiter">${</span>inputChanges.incremental<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
        inputChanges.getFileChanges(input).forEach { change -&gt;          // <b class="conum">(2)</b>
            <span class="keyword">def</span> changedFile = change.file
            <span class="keyword">if</span> (change.fileType != FileType.FILE) {
                <span class="keyword">return</span>
            }
            <span class="keyword">def</span> outputLocation = <span class="keyword">new</span> <span class="predefined-type">File</span>(outputDir, <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>change.normalizedPath<span class="inline-delimiter">}</span></span><span class="content">.loc</span><span class="delimiter">&quot;</span></span>)
            <span class="keyword">switch</span> (change.changeType) {
                <span class="keyword">case</span> <span class="key">ADDED</span>:
                <span class="keyword">case</span> <span class="key">MODIFIED</span>:
                    println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Processing file </span><span class="inline"><span class="inline-delimiter">${</span>changedFile.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
                    outputLocation.parentFile.mkdirs()

                    outputLocation.text = changedFile.readLines().size()

                <span class="keyword">case</span> <span class="key">REMOVED</span>:
                    println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Removing leftover output file </span><span class="inline"><span class="inline-delimiter">${</span>outputLocation.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
                    outputLocation.delete()

            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">abstract class CountLoc : TransformAction&lt;TransformParameters.None&gt; {

    @get:Inject
    abstract val inputChanges: InputChanges

    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:InputArtifact
    abstract val input: Provider&lt;FileSystemLocation&gt;

    override
    fun transform(outputs: TransformOutputs) {                          // <b class="conum">(1)</b>
        val outputDir = outputs.dir(&quot;${input.get().asFile.name}.loc&quot;)
        println(&quot;Running transform on ${input.get().asFile.name}, incremental: ${inputChanges.isIncremental}&quot;)
        inputChanges.getFileChanges(input).forEach { change -&gt;          // <b class="conum">(2)</b>
            val changedFile = change.file
            if (change.fileType != FileType.FILE) {
                return@forEach
            }
            val outputLocation = outputDir.resolve(&quot;${change.normalizedPath}.loc&quot;)
            when (change.changeType) {
                ChangeType.ADDED, ChangeType.MODIFIED -&gt; {

                    println(&quot;Processing file ${changedFile.name}&quot;)
                    outputLocation.parentFile.mkdirs()

                    outputLocation.writeText(changedFile.readLines().size.toString())
                }
                ChangeType.REMOVED -&gt; {
                    println(&quot;Removing leftover output file ${outputLocation.name}&quot;)
                    outputLocation.delete()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>注入<code>InputChanges</code></p>
</li>
<li>
<p>查询输入工件中的更改</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="working_in_a_multi_repo_environment"><a class="anchor" href="#working_in_a_multi_repo_environment"></a> <a class="link" href="#working_in_a_multi_repo_environment">在多仓库环境中工作</a></h3>
<div class="sect3">
<h4 id="composite_builds"><a class="anchor" href="#composite_builds"></a> <a class="link" href="#composite_builds">组成作品</a></h4>
<div class="sect4">
<h5 id="composite_build_intro"><a class="anchor" href="#composite_build_intro"></a> <a class="link" href="#composite_build_intro">什么是复合构建？</a></h5>
<div class="paragraph">
<p>复合构建只是包含其他构建的构建。在许多方面，复合构建类似于Gradle多项目构建，不同之处在于，它不包含单个构建<code>projects</code> ，完成<code>builds</code>被包含在内。</p>
</div>
<div class="paragraph">
<p>复合版本使您能够：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>结合通常独立开发的构建，例如，在应用程序使用的库中尝试错误修复时</p>
</li>
<li>
<p>将大型的多项目构建分解为更小，更孤立的块，可以根据需要独立或一起工作</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>自然包含在复合构建中的构建被称为“包含构建”。包含的构建不与复合构建或其他包含的构建共享任何配置。每个包含的构建都是独立配置和执行的。</p>
</div>
<div class="paragraph">
<p>包含的内部版本通过<a href="#sec:dependency_substitution_rules"><em>依赖替换</em></a>与其他内部版本交互。如果组合中的任何内部版本都具有包含的内部版本可以满足的依赖关系，则该依赖关系将由对包含的内部版本的项目依赖关系代替。
<em>由于依赖于依赖替换，因此在构建任务执行图时，复合构建可能会强制配置早日解析。这可能会对整体构建性能产生负面影响，因为这些配置无法并行解决。</em></p>
</div>
<div class="paragraph">
<p>默认情况下，Gradle将尝试确定可以由包含的内部版本替代的依赖项。但是，为了获得更大的灵活性，如果Gradle确定的默认替换不适用于组合，则可以显式声明这些替换。请参阅<a href="#included_build_declaring_substitutions">声明替代</a> 。</p>
</div>
<div class="paragraph">
<p>除了通过项目依赖项消耗输出外，复合构建还可以直接在包含的构建中声明任务依赖项。包含的构建是隔离的，并且不能声明复合构建或其他包含的构建上的任务依赖性。请参阅<a href="#included_build_task_dependencies">根据包含的构建中的任务</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="defining_composite_builds"><a class="anchor" href="#defining_composite_builds"></a> <a class="link" href="#defining_composite_builds">定义复合构建</a></h5>
<div class="paragraph">
<p>以下示例演示了通常可以单独开发的2个Gradle构建可以组合为复合构建的各种方式。对于这些示例， <code>my-utils</code>多项目构建产生2个不同的Java库（ <code>number-utils</code>和<code>string-utils</code> ），以及<code>my-app</code> build使用这些库中的函数生成可执行文件。</p>
</div>
<div class="paragraph">
<p>的<code>my-app</code>构建没有直接依赖<code>my-utils</code> 。相反，它声明由生成的库的二进制依赖性<code>my-utils</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例389我的应用程序的依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">my-app / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">application</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">idea</span><span class="delimiter">'</span></span>
}

group <span class="string"><span class="delimiter">&quot;</span><span class="content">org.sample</span><span class="delimiter">&quot;</span></span>
version <span class="string"><span class="delimiter">&quot;</span><span class="content">1.0</span><span class="delimiter">&quot;</span></span>

application {
    mainClassName = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.sample.myapp.Main</span><span class="delimiter">&quot;</span></span>
}

dependencies {
    implementation <span class="string"><span class="delimiter">&quot;</span><span class="content">org.sample:number-utils:1.0</span><span class="delimiter">&quot;</span></span>
    implementation <span class="string"><span class="delimiter">&quot;</span><span class="content">org.sample:string-utils:1.0</span><span class="delimiter">&quot;</span></span>
}

repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">my-app / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
    application
    idea
}

group = &quot;org.sample&quot;
version = &quot;1.0&quot;

application {
    mainClassName = &quot;org.sample.myapp.Main&quot;
}

dependencies {
    implementation(&quot;org.sample:number-utils:1.0&quot;)
    implementation(&quot;org.sample:string-utils:1.0&quot;)
}

repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/compositeBuilds/basic</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="command_line_composite"><a class="anchor" href="#command_line_composite"></a> <a class="link" href="#command_line_composite">通过以下方式定义复合构建<code>--include-build</code></a></h6>
<div class="paragraph">
<p>的<code>--include-build</code>命令行参数将执行的构建转换为组合，将包含的构建中的依赖项替换为执行的构建。</p>
</div>
</div>
<div class="sect5">
<h6 id="example_declaring_a_command_line_composite"><a class="anchor" href="#example_declaring_a_command_line_composite"></a> <a class="link" href="#example_declaring_a_command_line_composite">示例：声明命令行复合</a></h6>
<div class="listingblock">
<div class="title">输出<strong><code>gradle --include-build ../my-utils run</code></strong></div>
<div class="content">
<pre>&gt; gradle --include-build ../my-utils run
&gt; Task :processResources NO-SOURCE
&gt; Task :my-utils:string-utils:compileJava
&gt; Task :my-utils:string-utils:processResources NO-SOURCE
&gt; Task :my-utils:string-utils:classes
&gt; Task :my-utils:string-utils:jar
&gt; Task :my-utils:number-utils:compileJava
&gt; Task :my-utils:number-utils:processResources NO-SOURCE
&gt; Task :my-utils:number-utils:classes
&gt; Task :my-utils:number-utils:jar
&gt; Task :compileJava
&gt; Task :classes

&gt; Task :run
The answer is 42


BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="settings_defined_composite"><a class="anchor" href="#settings_defined_composite"></a> <a class="link" href="#settings_defined_composite">通过设置文件定义复合构建</a></h6>
<div class="paragraph">
<p>通过使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:includeBuild(java.lang.Object)">Settings.includeBuild（java.lang。对象）</a>在其中声明包含的内部版本<code>settings.gradle</code> （要么<code>settings.gradle.kts</code>在Kotlin中）文件。设置文件可用于同时添加子项目和包含的内部版本。包含的内部版本按位置添加。有关更多详细信息，请参见下面的示例。</p>
</div>
</div>
<div class="sect5">
<h6 id="separate_composite"><a class="anchor" href="#separate_composite"></a> <a class="link" href="#separate_composite">定义一个单独的复合构建</a></h6>
<div class="paragraph">
<p>上述方法的一个缺点是，它需要您修改现有的内部版本，从而使其作为独立的内部版本不太有用。避免这种情况的一种方法是定义一个单独的复合构建，其唯一目的是合并否则的单独构建。</p>
</div>
<div class="exampleblock">
<div class="title">示例390声明一个单独的组合</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">adhoc</span><span class="delimiter">'</span></span>

includeBuild <span class="string"><span class="delimiter">'</span><span class="content">../my-app</span><span class="delimiter">'</span></span>
includeBuild <span class="string"><span class="delimiter">'</span><span class="content">../my-utils</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;adhoc&quot;

includeBuild(&quot;../my-app&quot;)
includeBuild(&quot;../my-utils&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，执行的“主要”构建是组合，并且没有定义任何有用的任务来执行自身。为了在“ my-app”构建中执行“运行”任务，复合构建必须定义一个委托任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例391根据包含的构建中的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">复合/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task run {
    dependsOn gradle.includedBuild(<span class="string"><span class="delimiter">'</span><span class="content">my-app</span><span class="delimiter">'</span></span>).task(<span class="string"><span class="delimiter">'</span><span class="content">:run</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;run&quot;) {
    dependsOn(gradle.includedBuild(&quot;my-app&quot;).task(&quot;:run&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>更多详细信息任务取决于以下包含的构建任务。</p>
</div>
</div>
<div class="sect5">
<h6 id="included_builds"><a class="anchor" href="#included_builds"></a> <a class="link" href="#included_builds">包含版本的限制</a></h6>
<div class="paragraph">
<p>大多数构建都可以包含在组合中，包括其他组合构建。但是，有一些限制。</p>
</div>
<div class="paragraph">
<p>每个包含的版本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不能有一个<code>rootProject.name</code>与另一个包含的版本相同。</p>
</li>
<li>
<p>不能有一个<code>rootProject.name</code>与复合构建的顶级项目相同。</p>
</li>
<li>
<p>不能有一个<code>rootProject.name</code>与组合版本相同<code>rootProject.name</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="interacting_with_composite_builds"><a class="anchor" href="#interacting_with_composite_builds"></a> <a class="link" href="#interacting_with_composite_builds">与复合构建交互</a></h5>
<div class="paragraph">
<p>通常，与组合构建进行交互与常规多项目构建非常相似。可以执行任务，可以运行测试，并且可以将构建导入到IDE中。</p>
</div>
<div class="sect5">
<h6 id="composite_build_executing_tasks"><a class="anchor" href="#composite_build_executing_tasks"></a> <a class="link" href="#composite_build_executing_tasks">执行任务</a></h6>
<div class="paragraph">
<p>可以从命令行或您的IDE执行复合构建中的任务。执行任务将导致直接任务依赖关系被执行，以及从包含的构建中构建依赖关系工件所需的那些任务。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>还没有任何方法可以通过命令行从包含的内部版本中直接执行任务。包含的构建任务会自动执行以生成所需的依赖工件，或者<a href="#included_build_task_dependencies">包含的构建可以声明包含的构建对任务的依赖</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="composite_build_ide_integration"><a class="anchor" href="#composite_build_ide_integration"></a> <a class="link" href="#composite_build_ide_integration">导入IDE</a></h6>
<div class="paragraph">
<p>集成构建最有用的功能之一就是IDE集成。通过将<a href="#idea_plugin">idea</a>或<a href="#eclipse_plugin">eclipse</a>插件应用于构建，可以生成一个IDEA或Eclipse项目，该项目允许组合中的所有构建一起开发。</p>
</div>
<div class="paragraph">
<p>除了这些Gradle插件之外， <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>和<a href="https://projects.eclipse.org/projects/tools.buildship">Eclipse Buildship的</a>最新版本<a href="https://projects.eclipse.org/projects/tools.buildship">还</a>支持直接导入复合构建。</p>
</div>
<div class="paragraph">
<p>导入复合构建可以使来自单独的Gradle构建的资源易于一起开发。对于每个包含的构建，每个子项目都作为IDEA模块或Eclipse项目包含在内。配置了源依赖关系，提供了跨版本的导航和重构。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="included_build_declaring_substitutions"><a class="anchor" href="#included_build_declaring_substitutions"></a> <a class="link" href="#included_build_declaring_substitutions">声明由包含的构建替换的依赖项</a></h5>
<div class="paragraph">
<p>默认情况下，Gradle将配置每个包含的内部版本，以确定其可以提供的依赖项。这样做的算法非常简单：Gradle将检查包含的构建中项目的组和名称，并将项目依赖项替换为任何外部依赖项匹配<code>${project.group}:${project.name}</code> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，Gradle确定的默认替换不足，或者对于特定组合而言，它们不正确。对于这些情况，可以显式声明所包含构建的替换。以一个单项目构建“ anonymous-library”为例，它生成一个Java实用程序库，但未声明group属性的值：</p>
</div>
<div class="exampleblock">
<div class="title">示例392不声明组属性的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当此构建包含在组合中时，它将尝试替换依赖项模块“ undefined：anonymous-library”（“ undefined”是<code>project.group</code> ，并且“ anonymous-library”是根项目名称）。显然，这在复合构建中不会很有用。要在复合构建中使用未修改的未发布库，组合构建可以显式声明其提供的替换：</p>
</div>
<div class="exampleblock">
<div class="title">示例393。声明包含的构建的替代</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">rootProject.name = <span class="string"><span class="delimiter">'</span><span class="content">app</span><span class="delimiter">'</span></span>

includeBuild(<span class="string"><span class="delimiter">'</span><span class="content">../anonymous-library</span><span class="delimiter">'</span></span>) {
    dependencySubstitution {
        substitute module(<span class="string"><span class="delimiter">'</span><span class="content">org.sample:number-utils</span><span class="delimiter">'</span></span>) with project(<span class="string"><span class="delimiter">'</span><span class="content">:</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;app&quot;

includeBuild(&quot;../anonymous-library&quot;) {
    dependencySubstitution {
        substitute(module(&quot;org.sample:number-utils&quot;)).with(project(&quot;:&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用此配置，“ my-app”复合构建将替换对<code>org.sample:number-utils</code>依赖于“匿名库”的根项目。</p>
</div>
<div class="sect5">
<h6 id="included_build_substitution_requirements"><a class="anchor" href="#included_build_substitution_requirements"></a> <a class="link" href="#included_build_substitution_requirements">必须声明包含的内部替代品的情况</a></h6>
<div class="paragraph">
<p>许多使用<code>uploadArchives</code>发布工件的任务将自动作为包含的内部版本运行，而无需声明替代。以下是一些需要声明替换的常见情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当。。。的时候<code>archivesBaseName</code>属性用于设置发布的工件的名称。</p>
</li>
<li>
<p>当配置不是<code>default</code>发表：这通常意味着除<code>uploadArchives</code>用来。</p>
</li>
<li>
<p>当。。。的时候<code>MavenPom.addFilter()</code>用于发布与项目名称不匹配的工件。</p>
</li>
<li>
<p>当。。。的时候<code>maven-publish</code>要么<code>ivy-publish</code>插件用于发布，发布坐标不匹配<code>${project.group}:${project.name}</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="included_build_substitution_limitations"><a class="anchor" href="#included_build_substitution_limitations"></a> <a class="link" href="#included_build_substitution_limitations">复合建筑替换无效的情况</a></h6>
<div class="paragraph">
<p>某些组合即使包含在显式声明的依赖项替换中，也无法正常运行。此限制是由于以下事实：被替换的项目依赖项将始终指向<code>default</code>目标项目的配置。每当为项目的默认配置指定的工件和依赖项与实际发布到存储库的内容不匹配时，组合构建就可能表现出不同的行为。</p>
</div>
<div class="paragraph">
<p>在某些情况下，发布模块元数据可能与项目默认配置不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当配置不是<code>default</code>已出版。</p>
</li>
<li>
<p>当。。。的时候<code>maven-publish</code>要么<code>ivy-publish</code>使用插件。</p>
</li>
<li>
<p>当。。。的时候<code>POM</code>要么<code>ivy.xml</code>文件已作为发布的一部分进行了调整。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当包含在复合版本中时，使用这些功能的版本将无法正常运行。我们计划在将来对此进行改进。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="included_build_task_dependencies"><a class="anchor" href="#included_build_task_dependencies"></a> <a class="link" href="#included_build_task_dependencies">根据所包含构建中的任务</a></h5>
<div class="paragraph">
<p>虽然包含的内部版本相互隔离并且不能声明直接依赖关系，但是复合内部版本可以对其包含的内部版本声明任务依赖关系。使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuilds">Gradle.getIncludedBuilds（）</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuild(java.lang.String)">Gradle.includedBuild（java.lang。String）</a> ，然后通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.IncludedBuild.html#org.gradle.api.initialization.IncludedBuild:task(java.lang.String)">IncludedBuild.task（java.lang。字符串）</a>方法。</p>
</div>
<div class="paragraph">
<p>使用这些API，可以声明对特定包含的构建中的任务或所有或某些包含的构建中具有特定路径的任务的依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">示例394。取决于包含的内部版本中的单个任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">复合/ build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task run {
    dependsOn gradle.includedBuild(<span class="string"><span class="delimiter">'</span><span class="content">my-app</span><span class="delimiter">'</span></span>).task(<span class="string"><span class="delimiter">'</span><span class="content">:run</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">Composite / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;run&quot;) {
    dependsOn(gradle.includedBuild(&quot;my-app&quot;).task(&quot;:run&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例395取决于所有包含的构建中带有路径的任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task publishDeps {
    dependsOn gradle.includedBuilds*.task(<span class="string"><span class="delimiter">'</span><span class="content">:publishIvyPublicationToIvyRepository</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;publishDeps&quot;) {
    dependsOn(gradle.includedBuilds.map { it.task(&quot;:publishIvyPublicationToIvyRepository&quot;) })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="current_limitations_and_future_work"><a class="anchor" href="#current_limitations_and_future_work"></a> <a class="link" href="#current_limitations_and_future_work">复合材料构建的当前限制和未来计划</a></h5>
<div class="paragraph">
<p>我们认为复合构建已经非常有用。但是，有些事情并没有按照我们希望的方式工作，还有一些我们认为可以使事情做得更好的改进。</p>
</div>
<div class="paragraph">
<p>当前实施的局限性包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不支持包含发布的不反映项目默认配置的内部版本。请参阅<a href="#included_build_substitution_limitations">复合建筑无法使用的案例</a> 。</p>
</li>
<li>
<p>不支持基于软件模型的本机版本。（本机版本尚不支持二进制依赖性）。</p>
</li>
<li>
<p>如果多个复合构建并行运行，则多个复合构建可能会发生冲突。Gradle不会在Gradle调用之间共享共享复合构建的项目锁，以防止并发执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们计划在即将发布的版本中进行的改进包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更好地检测依赖项替换，例如使用自定义坐标发布的生成，生成多个组件的生成等。这将减少需要为包含的生成显式声明依赖项替换的情况。</p>
</li>
<li>
<p>可以直接从命令行定位包含的内部版本中的一个或多个任务的功能。我们目前正在探索允许使用此功能的语法选项，这将消除许多在组合中需要委派任务的情况。</p>
</li>
<li>
<p>使隐式<code>buildSrc</code>计划一个包含的构建。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing_libraries"><a class="anchor" href="#publishing_libraries"></a> <a class="link" href="#publishing_libraries">出版图书馆</a></h3>
<div class="sect3">
<h4 id="publishing_components"><a class="anchor" href="#publishing_components"></a> <a class="link" href="#publishing_components">将项目发布为模块</a></h4>
<div id="publishing_overview" class="paragraph">
<p>绝大多数软件项目都旨在以某种方式使用某种东西。它可以是其他软件项目使用的库，也可以是最终用户的应用程序。
<em>发布</em>是将构建的东西提供给消费者的过程。</p>
</div>
<div class="paragraph">
<p>在Gradle中，该过程如下所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>定义<a href="#publishing_overview:what">什么</a>发布</p>
</li>
<li>
<p>定义<a href="#publishing_overview:where">将</a>其发布到的位置</p>
</li>
<li>
<p><a href="#publishing_overview:how">做</a>出版</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这些步骤中的每一个都取决于要将工件发布到的存储库的类型。两种最常见的类型是Maven兼容和Ivy兼容存储库，或者简称为Maven和Ivy存储库。</p>
</div>
<div class="paragraph">
<p>从Gradle 6.0开始， <a href="#sec:understanding-gradle-module-md">Gradle模块元数据</a>将始终与Ivy XML或Maven POM元数据文件一起发布。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>寻找有关上传任务和<code>archives</code>组态？请参阅“ <a href="artifact_management.html#artifact_management">旧版发布”</a>一章，该功能现已弃用，并计划将其删除。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle通过以<a href="#publishing_maven">Maven Publish插件</a>和<a href="#publishing_ivy">Ivy Publish插件</a>的形式提供一些预打包的基础结构，使发布到这些类型的存储库变得容易。这些插件使您可以配置要发布的内容并以最小的努力执行发布。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/publishing-process.png" alt="发布过程">
</div>
<div class="title">图24。发布过程</div>
</div>
<div class="paragraph">
<p>让我们更详细地看看这些步骤：</p>
</div>
<div id="publishing_overview:what" class="dlist">
<dl>
<dt class="hdlist1">发表什么</dt>
<dd>
<p>Gradle需要知道要发布哪些文件和信息，以便消费者可以使用您的项目。这通常是Gradle称为<a href="#sub:terminology_publication">出版物</a>的<a href="#sub:terminology_artifact">工件</a>和元数据的组合。出版物所包含的内容取决于要发布到的存储库的类型。</p>
<div class="paragraph">
<p>例如，发往Maven存储库的出版物包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个或多个工件（通常由项目构建）</p>
</li>
<li>
<p>Gradle Module元数据文件，将描述已发布组件的变体，</p>
</li>
<li>
<p>Maven POM文件将标识主要工件及其依赖项。主要工件通常是项目的生产JAR，辅助工件可能由“ -sources”和“ -javadoc” JAR组成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，Gradle将发布上述所有内容的校验和，并配置为发布<a href="#">签名</a> 。从Gradle 6.0开始，这包括<code>SHA256</code>和<code>SHA512</code>校验和。</p>
</div>
</dd>
</dl>
</div>
<div id="publishing_overview:where" class="dlist">
<dl>
<dt class="hdlist1">在哪里发布</dt>
<dd>
<p>Gradle需要知道在哪里发布工件，以便消费者可以掌握它们。这是通过<a href="#sub:terminology_repository">存储库</a>完成的，该存储<a href="#sub:terminology_repository">库</a>存储并提供了各种工件。Gradle还需要与存储库进行交互，这就是为什么您必须提供存储库的类型及其位置的原因。</p>
</dd>
</dl>
</div>
<div id="publishing_overview:how" class="dlist">
<dl>
<dt class="hdlist1">发行方式</dt>
<dd>
<p>Gradle会自动为发布和存储库的所有可能组合生成发布任务，从而使您可以将任何工件发布到任何存储库。如果要发布到Maven存储库，则任务的类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html">PublishToMavenRepository</a> ，而对于Ivy存储库，任务的类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html">PublishToIvyRepository</a> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>下面是一个实际的示例，演示了整个发布过程。</p>
</div>
<div class="sect4">
<h5 id="sec:basic_publishing"><a class="anchor" href="#sec:basic_publishing"></a> <a class="link" href="#sec:basic_publishing">设置基本发布</a></h5>
<div class="paragraph">
<p>无论您的项目类型如何，发布的第一步都是应用适当的发布插件。如简介中所述，Gradle通过以下插件支持Maven和Ivy存储库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#publishing_maven">Maven发布插件</a></p>
</li>
<li>
<p><a href="#publishing_ivy">常春藤发布插件</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它们提供了配置相应存储库类型的发布所需的特定发布和存储库类。由于Maven存储库是最常用的存储库，因此它们将成为本示例和本章其他示例的基础。不用担心，我们将解释如何为Ivy存储库调整单个样本。</p>
</div>
<div class="paragraph">
<p>假设我们正在使用一个简单的Java库项目，因此仅应用以下插件：</p>
</div>
<div class="exampleblock">
<div class="title">实施例396。应用必要的插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">maven-publish</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
    `maven-publish`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦应用了适当的插件，就可以配置发布和存储库。在此示例中，我们要发布项目的生产JAR文件-由<code>jar</code>任务-到自定义的Maven存储库。我们通过以下方式做到这一点<code>publishing {}</code>块，由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.PublishingExtension.html">PublishingExtension</a>支持：</p>
</div>
<div class="exampleblock">
<div class="title">示例397配置Java库以进行发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">group = <span class="string"><span class="delimiter">'</span><span class="content">org.example</span><span class="delimiter">'</span></span>
version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>

publishing {
    publications {
        myLibrary(MavenPublication) {
            from components.java
        }
    }

    repositories {
        maven {
            name = <span class="string"><span class="delimiter">'</span><span class="content">myRepo</span><span class="delimiter">'</span></span>
            url = <span class="string"><span class="delimiter">&quot;</span><span class="content">file://</span><span class="inline"><span class="inline-delimiter">${</span>buildDir<span class="inline-delimiter">}</span></span><span class="content">/repo</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">group = &quot;org.example&quot;
version = &quot;1.0&quot;

publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;myLibrary&quot;) {
            from(components[&quot;java&quot;])
        }
    }

    repositories {
        maven {
            name = &quot;myRepo&quot;
            url = uri(&quot;file://${buildDir}/repo&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这定义了一个称为“ myLibrary”的发布，可以通过其类型将其发布到Maven存储库： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">MavenPublication</a> 。该出版物仅包含生产JAR工件及其元数据，两者结合起来由<code>java</code>项目的<a href="#sub:terminology_component">组成部分</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">组件是定义发布的标准方法。它们是由插件提供的，通常是各种语言或平台的插件。例如，Java插件定义了<code>components.java</code>战争插件定义了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/component/SoftwareComponent.html">SoftwareComponent</a> <code>components.web</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该示例还定义了一个名为“ myRepo”的基于文件的Maven存储库。这样的基于文件的存储库对于示例来说很方便，但是实际构建通常可以与基于HTTPS的存储库服务器（例如Maven Central或内部公司服务器）一起使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">您可以定义一个并且只有一个没有名称的存储库。对于Maven存储库，这将转换为隐式名称“ Maven”，对于Ivy存储库，将转换为隐式名称。必须为所有其他存储库定义指定一个明确的名称。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与项目的结合<code>group</code>和<code>version</code> ，发布和存储库定义提供了Gradle发布项目的生产JAR所需的一切。然后Gradle将创建一个专用的<code>publishMyLibraryPublicationToMyRepoRepository</code>就是那样的任务。其名称基于模板<code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code> 。请参阅相应的发布插件的文档，以获取有关此任务的性质以及您可能可用的任何其他任务的更多详细信息。</p>
</div>
<div class="paragraph">
<p>您可以直接执行单个发布任务，也可以执行<code>publish</code> ，它将运行所有可用的发布任务。在这个例子中<code>publish</code>会跑<code>publishMyLibraryPublicationToMavenRepository</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>基本发布到Ivy存储库非常相似：您只需使用Ivy Publish Plugin，替换<code>MavenPublication</code>与<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html">IvyPublication一起</a>使用<code>ivy</code>代替<code>maven</code>在存储库定义中。</p>
</div>
<div class="paragraph">
<p>两种类型的存储库之间存在差异，尤其是每种存储库都支持的额外元数据之间存在差异-例如，Maven存储库需要一个POM文件，而Ivy存储库则具有自己的元数据格式-因此，请参阅插件章节以获取有关如何配置这两种配置的全面信息。您正在使用的任何存储库类型的出版物和存储库。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这就是基本用例的全部内容。但是，许多项目需要对发布的内容进行更多控制，因此我们在以下各节中介绍几种常见方案。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:understanding-gradle-module-md"><a class="anchor" href="#sec:understanding-gradle-module-md"></a> <a class="link" href="#sec:understanding-gradle-module-md">了解Gradle模块元数据</a></h4>
<div class="paragraph">
<p>Gradle模块元数据是用于序列化Gradle组件模型的格式。它类似于<a href="https://maven.apache.org/pom.html">Apache Maven™的POM文件</a>或<a href="http://ant.apache.org/ivy/">Apache Ivy™ivy.xml</a>文件。元数据文件的目标是向<em>消费者</em>提供存储库中发布内容的合理模型。</p>
</div>
<div class="paragraph">
<p>Gradle模块元数据是一种独特的格式，旨在通过使其具有多平台和变体感知功能来改善依赖关系解析。</p>
</div>
<div class="paragraph">
<p>特别是，Gradle模块元数据支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rich-version-constraints">丰富的版本约束</a></p>
</li>
<li>
<p><a href="#sec:adding-constraints-transitive-deps">依赖约束</a></p>
</li>
<li>
<p><a href="#declaring-component-capabilities">组件功能</a></p>
</li>
<li>
<p><a href="#understanding-variant-selection">变体感知分辨率</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>发布Gradle模块元数据将为您的使用者提供更好的依赖关系管理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过检测<a href="#declaring-component-capabilities">不兼容的模块</a>及早发现问题</p>
</li>
<li>
<p>一致选择<a href="#targeting-different-platforms">特定于平台的依赖项</a></p>
</li>
<li>
<p>本机<a href="#version_alignment">依赖版本对齐</a></p>
</li>
<li>
<p>自动获取<a href="#">库</a>特定<a href="#">功能的</a>依赖关系</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用<a href="#">Maven Publish插件</a>或<a href="#">Ivy Publish插件</a>时，Gradle模块元数据会自动<a href="#">发布</a> 。旧版<em>不</em>支持此功能<code>maven</code>和<code>ivy</code>插件。</p>
</div>
<div class="paragraph">
<p>可在<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">此处</a>找到Gradle模块元数据规范的规范。</p>
</div>
<div class="sect4">
<h5 id="sub:mapping-with-other-formats"><a class="anchor" href="#sub:mapping-with-other-formats"></a> <a class="link" href="#sub:mapping-with-other-formats">与其他格式的映射</a></h5>
<div class="paragraph">
<p>Gradle模块元数据会自动发布在Maven或Ivy存储库中。但是，它不会替代<em>pom.xml</em>或<em>ivy.xml</em>文件：它与这些文件一起发布。这样做是为了最大程度地提高与第三方构建工具的兼容性。</p>
</div>
<div class="paragraph">
<p>Gradle尽其所能将Gradle特定的概念映射到Maven或Ivy。当构建文件使用只能在Gradle模块元数据中表示的功能时，Gradle会在发布时警告您。下表总结了如何将某些特定于Gradle的功能映射到Maven和Ivy：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表15。将Gradle特定概念映射到Maven和Ivy</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">摇篮</th>
<th class="tableblock halign-left valign-top">马文</th>
<th class="tableblock halign-left valign-top">常春藤</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:adding-constraints-transitive-deps">依赖约束</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><dependencyManagement></code>依存关系</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未发表</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gradle依赖项约束是可<em>传递的</em> ，而Maven的依赖项管理块<em>不是</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#rich-version-constraints">丰富的版本约束</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布<em>需求</em>版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布了<em>需求</em>版本</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#declaring-component-capabilities">组件功能</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未发表</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未发表</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组件功能是Gradle独有的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#">功能变体</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">上载各种工件，相关性发布为_optional依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">已上传变体工件，未发布依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能变体很好地替代了可选的依赖项</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:publishing-custom-components">自定义组件类型</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工件已上传，依赖项是映射所描述的依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工件已上传，相关性被忽略</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在任何情况下，自定义组件类型都可能无法从Maven或Ivy中使用。它们通常存在于自定义生态系统中。</p></td>
</tr>
</tbody>
</table>
<div class="sect5">
<h6 id="disabling_metadata_compatibility_publication_warnings"><a class="anchor" href="#disabling_metadata_compatibility_publication_warnings"></a> <a class="link" href="#disabling_metadata_compatibility_publication_warnings">禁用元数据兼容性发布警告</a></h6>
<div class="paragraph">
<p>如果要禁止显示警告，则可以使用以下API来禁止显示警告：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Maven，请参见<code>suppress*</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication:suppressAllPomMetadataWarnings()">Maven出版中的</a>方法</p>
</li>
<li>
<p>对于常春藤，请参阅<code>suppress*</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html#org.gradle.api.publish.ivy.IvyPublication:suppressAllIvyMetadataWarnings()">IvyPublication中的</a>方法</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">示例398。禁用发布警告</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    publications {
        maven(MavenPublication) {
            from components.java
            suppressPomMetadataWarningsFor(<span class="string"><span class="delimiter">'</span><span class="content">runtimeElements</span><span class="delimiter">'</span></span>)
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    publications {
        register&lt;MavenPublication&gt;(&quot;maven&quot;) {
            from(components[&quot;java&quot;])
            suppressPomMetadataWarningsFor(&quot;runtimeElements&quot;)
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub:interactions-other-build-tools"><a class="anchor" href="#sub:interactions-other-build-tools"></a> <a class="link" href="#sub:interactions-other-build-tools">与其他构建工具的交互</a></h5>
<div class="paragraph">
<p>由于Gradle模块元数据并未广泛传播，并且其目的是<a href="#sub:mapping-with-other-formats">最大程度地提高与其他工具的兼容性</a> ，因此Gradle可以做两件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle模块元数据会与给定存储库（Maven或Ivy）的常规描述符一起系统发布</p>
</li>
<li>
<p>的<code>pom.xml</code>要么<code>ivy.xml</code>文件将包含一个<em>标记注释</em> ，该<em>标记</em>告诉Gradle该模块存在Gradle模块元数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>标记的目的<em>不是</em>其他工具来解析模块元数据：仅用于Gradle用户。它向Gradle解释说，存在<em>更好的</em>模块元数据文件，应该使用它。这并不意味着Maven或Ivy的消耗也将被打破，而不仅仅是它在<a href="#sub:mapping-with-other-formats">降级模式下工作</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>必须将其视为一项<em>性能优化</em> ：不必执行2个网络请求，而是先获取Gradle模块元数据，然后再获取一个POM / Ivy文件，而Gradle将首先查看该文件中最重要的文件。可能存在，则仅在模块与Gradle Module Metadata实际发布时才执行第二个请求。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您知道依赖的模块始终与Gradle Module Metadata一起发布，则可以优化网络调用，为存储库配置元数据源：</p>
</div>
<div class="exampleblock">
<div class="title">示例399仅解决Gradle模块元数据</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    repositories {
        maven {
            url <span class="string"><span class="delimiter">&quot;</span><span class="content">http://repo.mycompany.com/repo</span><span class="delimiter">&quot;</span></span>
            metadataSources {
                gradleMetadata()
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    repositories {
        maven {
            setUrl(&quot;http://repo.mycompany.com/repo&quot;)
            metadataSources {
                gradleMetadata()
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sub:gmm-validation"><a class="anchor" href="#sub:gmm-validation"></a> <a class="link" href="#sub:gmm-validation">Gradle模块元数据验证</a></h5>
<div class="paragraph">
<p>Gradle模块元数据在发布之前先经过验证。</p>
</div>
<div class="paragraph">
<p>强制执行以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>变体名称必须唯一，</p>
</li>
<li>
<p>每个变体必须至少具有<a href="#">一个属性</a> ，</p>
</li>
<li>
<p>两个变体不能具有<a href="#">完全相同的属性和功能</a> ，</p>
</li>
<li>
<p>如果存在依赖关系，则所有变体中的至少一个必须包含<a href="#">版本信息</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些规则可确保生成的元数据的质量，并有助于确认使用不会有问题。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:disabling-gmm-publication"><a class="anchor" href="#sub:disabling-gmm-publication"></a> <a class="link" href="#sub:disabling-gmm-publication">禁用Gradle模块元数据发布</a></h5>
<div class="paragraph">
<p>在某些情况下，您可能需要禁用Gradle模块元数据的发布：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您要上传到的存储库将拒绝元数据文件（未知格式）</p>
</li>
<li>
<p>您正在使用未正确映射到Gradle模块元数据的Maven或Ivy特定概念</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这种情况下，只需禁用生成元数据文件的任务即可禁用Gradle Module元数据的发布：</p>
</div>
<div class="exampleblock">
<div class="title">例子400。禁用发布Gradle模块元数据</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    tasks.withType(GenerateModuleMetadata) {
        enabled = <span class="predefined-constant">false</span>
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    tasks.withType&lt;GenerateModuleMetadata&gt; {
        enabled = false
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="publishing_maven:signing"><a class="anchor" href="#publishing_maven:signing"></a> <a class="link" href="#publishing_maven:signing">签名文物</a></h4>
<div class="paragraph">
<p><a href="#signing_plugin">签名插件</a>可用于签名构成发布的所有工件和元数据文件，包括Maven POM文件和Ivy模块描述符。为了使用它：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>应用签名插件</p>
</li>
<li>
<p>配置<a href="#sec:signatory_credentials">签名者凭据</a> —单击链接查看如何</p>
</li>
<li>
<p>指定您要签名的出版物</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这是一个配置插件以对其进行签名的示例<code>mavenJava</code>出版物：</p>
</div>
<div class="exampleblock">
<div class="title">例子401。签署出版物</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">signing {
    sign publishing.publications.mavenJava
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">signing {
    sign(publishing.publications[&quot;mavenJava&quot;])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将创建一个<code>Sign</code>您指定的每个出版物的任务，并全部连线<code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code>依赖它的任务。因此，发布任何出版物将自动为其出版物和元数据创建和发布签名，如您从以下输出中可以看到的：</p>
</div>
<div class="sect4">
<h5 id="example_sign_and_publish_a_project"><a class="anchor" href="#example_sign_and_publish_a_project"></a> <a class="link" href="#example_sign_and_publish_a_project">示例：签名并发布项目</a></h5>
<div class="listingblock">
<div class="title">输出<code>gradle publish</code></div>
<div class="content">
<pre>&gt; gradle publish
&gt; Task :compileJava
&gt; Task :processResources
&gt; Task :classes
&gt; Task :jar
&gt; Task :javadoc
&gt; Task :javadocJar
&gt; Task :sourcesJar
&gt; Task :generateMetadataFileForMavenJavaPublication
&gt; Task :generatePomFileForMavenJavaPublication
&gt; Task :signMavenJavaPublication
&gt; Task :publishMavenJavaPublicationToMavenRepository
&gt; Task :publish

BUILD SUCCESSFUL in 0s
10 actionable tasks: 10 executed</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="customizing_publishing"><a class="anchor" href="#customizing_publishing"></a> <a class="link" href="#customizing_publishing">定制发布</a></h4>
<div class="sect4">
<h5 id="sec:adding-variants-to-existing-components"><a class="anchor" href="#sec:adding-variants-to-existing-components"></a> <a class="link" href="#sec:adding-variants-to-existing-components">修改现有变体并将其添加到现有组件以进行发布</a></h5>
<div class="paragraph">
<p>Gradle的发布模型基于<em>组件</em>的概念，该概念由插件定义。例如，Java库插件定义了一个<code>java</code>组件，它对应于一个库，但是Java Platform插件定义了另一种组件，名为<code>javaPlatform</code> ，实际上是另一种软件组件（ <em>平台</em> ）。</p>
</div>
<div class="paragraph">
<p>有时我们想向现有组件添加<em>更多变体</em>或修改现有组件的<em>现有变体</em> 。例如，如果您<a href="#targeting-different-platforms">为其他平台添加了Java库的变体</a> ，则可能只想在<code>java</code>组件本身。通常，声明其他变体通常是发布<em>其他工件</em>的最佳解决方案。</p>
</div>
<div class="paragraph">
<p>要执行此类添加或修改， <code>AdhocComponentWithVariants</code>接口声明了两个方法<code>addVariantsFromConfiguration</code>和<code>withVariantsFromConfiguration</code>接受两个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用作变体源的<a href="#sec:resolvable-consumable-configs">传出配置</a></p>
</li>
<li>
<p>定制操作，使您可以<em>过滤</em>将要发布的变体</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要使用这些方法，您必须确保<code>SoftwareComponent</code>与您合作本身就是<code>AdhocComponentWithVariants</code> ，由Java插件（Java，Java库，Java平台）创建的组件就是这种情况。添加变体非常简单：</p>
</div>
<div class="exampleblock">
<div class="title">例子402。向现有软件组件添加变体</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">        AdhocComponentWithVariants javaComponent = (AdhocComponentWithVariants) project.components.findByName(<span class="string"><span class="delimiter">&quot;</span><span class="content">java</span><span class="delimiter">&quot;</span></span>)
        javaComponent.addVariantsFromConfiguration(outgoing) {
            <span class="comment">// dependencies for this variant are considered runtime dependencies</span>
            <span class="local-variable">it</span>.mapToMavenScope(<span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>)
            <span class="comment">// and also optional dependencies, because we don't want them to leak</span>
            <span class="local-variable">it</span>.mapToOptional()
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">        val javaComponent = components.findByName(&quot;java&quot;) as AdhocComponentWithVariants
        javaComponent.addVariantsFromConfiguration(outgoing) {
            // dependencies for this variant are considered runtime dependencies
            mapToMavenScope(&quot;runtime&quot;)
            // and also optional dependencies, because we don't want them to leak
            mapToOptional()
        }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在其他情况下，您可能想要修改已经由其中一个Java插件添加的变体。例如，如果您激活Javadoc和源代码的发布，则它们将成为Javadoc和源代码的其他变体。 <code>java</code>零件。如果您只想发布其中之一，例如只发布Javadoc而没有发布源，则可以修改<code>sources</code>未发布的变体：</p>
</div>
<div class="exampleblock">
<div class="title">范例403。使用Javadoc发布Java库但没有源代码</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    withJavadocJar()
    withSourcesJar()
}

components.java.withVariantsFromConfiguration(configurations.sourcesElements) {
    skip()
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    withJavadocJar()
    withSourcesJar()
}

val javaComponent = components[&quot;java&quot;] as AdhocComponentWithVariants
javaComponent.withVariantsFromConfiguration(configurations[&quot;sourcesElements&quot;]) {
    skip()
}

publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
            from(components[&quot;java&quot;])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:publishing-custom-components"><a class="anchor" href="#sec:publishing-custom-components"></a> <a class="link" href="#sec:publishing-custom-components">创建和发布自定义组件</a></h5>
<div class="paragraph">
<p>在<a href="#sec:adding-variants-to-existing-components">前面的示例中</a> ，我们演示了如何扩展或修改现有组件，例如Java插件提供的组件。但是Gradle还允许您构建自定义组件（不是Java库，不是Java平台，不是Gradle本身支持的东西）。</p>
</div>
<div class="paragraph">
<p>要创建自定义组件，您首先需要创建一个空的<em>自组织</em>组件。目前，这只能通过插件实现，因为您需要在<a href="https://docs.gradle.org/6.0.1/javadocorg/gradle/api/component/SoftwareComponentFactory.html">SoftwareComponentFactory</a>上获取一个句柄：</p>
</div>
<div class="exampleblock">
<div class="title">示例404注入软件组件工厂</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    <span class="directive">private</span> <span class="directive">final</span> SoftwareComponentFactory softwareComponentFactory

    <span class="annotation">@Inject</span>
    InstrumentedJarsPlugin(SoftwareComponentFactory softwareComponentFactory) {
        <span class="local-variable">this</span>.softwareComponentFactory = softwareComponentFactory
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">class InstrumentedJarsPlugin @Inject constructor(
    private val softwareComponentFactory: SoftwareComponentFactory) : Plugin&lt;Project&gt; {</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>声明自定义组件发布<em>了哪些</em>仍然通过做<a href="https://docs.gradle.org/6.0.1/javadocorg/gradle/api/component/AdhocComponentWithVariants.html">AdhocComponentWithVariants</a> API。对于自定义组件，第一步是按照<a href="#sec:variant-aware-sharing">本章中</a>的说明创建自定义传出变型。在此阶段，您应该拥有可以在跨项目依赖项中使用的变体，但是我们现在将其发布到外部存储库。</p>
</div>
<div class="exampleblock">
<div class="title">示例405创建一个自定义的临时组件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">        <span class="comment">// create an adhoc component</span>
        <span class="keyword">def</span> adhocComponent = softwareComponentFactory.adhoc(<span class="string"><span class="delimiter">&quot;</span><span class="content">myAdhocComponent</span><span class="delimiter">&quot;</span></span>)
        <span class="comment">// add it to the list of components that this project declares</span>
        project.components.add(adhocComponent)
        <span class="comment">// and register a variant for publication</span>
        adhocComponent.addVariantsFromConfiguration(outgoing) {
            <span class="local-variable">it</span>.mapToMavenScope(<span class="string"><span class="delimiter">&quot;</span><span class="content">runtime</span><span class="delimiter">&quot;</span></span>)
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">InstrumentedJarsPlugin.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">        // create an adhoc component
        val adhocComponent = softwareComponentFactory.adhoc(&quot;myAdhocComponent&quot;)
        // add it to the list of components that this project declares
        components.add(adhocComponent)
        // and register a variant for publication
        adhocComponent.addVariantsFromConfiguration(outgoing) {
            mapToMavenScope(&quot;runtime&quot;)
        }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>首先，我们使用工厂创建一个新的临时组件。然后，我们通过<code>addVariantsFromConfiguration</code>方法，在上<a href="#sec:adding-variants-to-existing-components">一节</a>中有更详细的描述。</p>
</div>
<div class="paragraph">
<p>在简单的情况下，一个<code>Configuration</code>和变体，在这种情况下，您可以发布单个发布的所有变体<code>Configuration</code>因为它们实际上是同一件事。但是，在某些情况下<code>Configuration</code>与其他<a href="https://docs.gradle.org/6.0.1/javadocorg/gradle/api/artifacts/ConfigurationPublications.html">配置出版物</a> （我们也称为<em>次要变体）有关</em> 。这样的配置在<a href="#">跨项目发布</a>用例中有意义，但在外部发布时则没有意义。例如，在项目之间共享<em>文件目录</em>的情况就是这种情况，但是您无法直接在Maven存储库中发布<em>目录</em> （仅打包文件，如jar或zip）。查看<a href="https://docs.gradle.org/6.0.1/javadocorg/gradle/api/component/ConfigurationVariantDetails.html">ConfigurationVariantDetails</a>类，以获取有关如何跳过特定变体的发布的详细信息。如果<code>addVariantsFromConfiguration</code>已经被要求进行配置，可以使用<code>withVariantsFromConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>当发布像这样的临时组件时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle模块元数据将<em>完全</em>代表已发布的变体。特别是，所有传出的变体都将继承已发布配置的依赖项，工件和属性。</p>
</li>
<li>
<p>将生成Maven和Ivy元数据文件，但是您需要声明如何通过<a href="https://docs.gradle.org/6.0.1/javadocorg/gradle/api/component/ConfigurationVariantDetails.html">ConfigurationVariantDetails</a>类将依赖项映射到Maven范围。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>实际上，这意味着Gradle可以像使用“本地组件”一样使用这种方式创建的组件。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:publishing_custom_artifacts_to_maven"><a class="anchor" href="#sec:publishing_custom_artifacts_to_maven"></a> <a class="link" href="#sec:publishing_custom_artifacts_to_maven">将自定义工件添加到发布中</a></h5>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>与其考虑工件，不如考虑Gradle的变体感知模型。预期单个模块可能需要多个工件。但是，如果其他工件代表了<a href="#">可选功能</a> ，那么这种情况就很少止于此了，它们可能还具有不同的依存关系，甚至更多。</p>
</div>
<div class="paragraph">
<p>Gradle通过<em>Gradle Module Metadata</em>支持<em>其他变体</em>的发布，这些<em>变体</em>使依赖解析引擎知道这些工件。请参阅文档的<a href="#sec:variant-aware-sharing">变体感知共享</a>部分，以了解如何声明此类变体并<a href="#sec:publishing-custom-components">查看如何发布自定义组件</a> 。</p>
</div>
<div class="paragraph">
<p>如果您将额外的工件直接附加到发布，它们将“脱离上下文”发布。这意味着，它们根本不在元数据中引用，因此只能通过依赖项上的分类器直接解决。与Gradle Module元数据相比，Maven pom元数据将不包含有关其他工件的信息，无论它们是通过变体添加还是直接添加，因为变体无法以pom格式表示。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下部分描述了在确定元数据（例如Gradle或POM元数据）与用例无关的情况下如何直接发布工件。例如，如果您的项目不需要被其他项目占用，并且发布的结果唯一需要的就是工件本身。</p>
</div>
<div class="paragraph">
<p>通常，有两种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅使用工件创建出版物</p>
</li>
<li>
<p>根据带有元数据的组件将工件添加到发布中（不建议使用，而是<a href="#sec:adding-variants-to-existing-components">调整组件</a>或使用<a href="#sec:publishing-custom-components">即席组件发布</a> ，这都会生成适合您工件的元数据）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要基于工件创建发布，请先定义一个自定义工件并将其附加到您选择的Gradle <a href="#sub:terminology_configuration">配置</a> 。以下示例定义了由<code>rpm</code>任务（未显示）并将该工件附加到<code>archives</code>组态：</p>
</div>
<div class="exampleblock">
<div class="title">示例406定义配置的自定义工件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> rpmFile = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/rpms/my-package.rpm</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> rpmArtifact = artifacts.add(<span class="string"><span class="delimiter">'</span><span class="content">archives</span><span class="delimiter">'</span></span>, rpmFile) {
    type <span class="string"><span class="delimiter">'</span><span class="content">rpm</span><span class="delimiter">'</span></span>
    builtBy <span class="string"><span class="delimiter">'</span><span class="content">rpm</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val rpmFile = file(&quot;$buildDir/rpms/my-package.rpm&quot;)
val rpmArtifact = artifacts.add(&quot;archives&quot;, rpmFile) {
    type = &quot;rpm&quot;
    builtBy(&quot;rpm&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>artifacts.add()</code>方法（来自<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.dsl.ArtifactHandler.html">ArtifactHandler）</a> -返回类型为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/PublishArtifact.html">PublishArtifact</a>的工件对象，然后可以将其用于定义发布，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例407将自定义PublishArtifact附加到发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    publications {
        maven(MavenPublication) {
            artifact rpmArtifact
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;maven&quot;) {
            artifact(rpmArtifact)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>artifact()</code>方法接受<em>发布工件</em>作为参数，例如<code>rpmArtifact</code>在示例中-以及<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。对象）</a> ，例如<code>File</code>实例，字符串文件路径或归档任务。</p>
</li>
<li>
<p>发布插件支持不同的工件配置属性，因此请始终查看插件文档以获取更多详细信息。的<code>classifier</code>和<code>extension</code> <a href="#publishing_maven">Maven发布插件</a>和<a href="#publishing_ivy">Ivy发布插件</a>都支持这些属性。</p>
</li>
<li>
<p>自定义工件需要在出版物中有所不同，通常是通过以下方式的唯一组合<code>classifier</code>和<code>extension</code> 。有关确切要求，请参见所用插件的文档。</p>
</li>
<li>
<p>如果您使用<code>artifact()</code>在执行存档任务时，Gradle会自动使用<code>classifier</code>和<code>extension</code>该任务的属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，您可以发布RPM。</p>
</div>
<div class="paragraph">
<p>如果您确实想基于组件将工件添加到发布中，而不是<a href="#sec:adding-variants-to-existing-components">调整组件</a>本身，则可以结合使用<code>from components.someComponent</code>和<code>artifact someArtifact</code>记号。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:publishing_maven:conditional_publishing"><a class="anchor" href="#sec:publishing_maven:conditional_publishing"></a> <a class="link" href="#sec:publishing_maven:conditional_publishing">将出版物限制为特定的存储库</a></h5>
<div class="paragraph">
<p>当定义了多个发布或存储库时，通常需要控制将哪些发布发布到哪个存储库。例如，考虑以下示例，该示例定义了两个发布-一个仅由一个二进制文件组成，另一个包含二进制和相关联的资源-两个存储库-一个供内部使用，一个供外部使用者使用：</p>
</div>
<div class="exampleblock">
<div class="title">示例408添加多个出版物和存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    publications {
        binary(MavenPublication) {
            from components.java
        }
        binaryAndSources(MavenPublication) {
            from components.java
            artifact sourcesJar
        }
    }
    repositories {
        <span class="comment">// change URLs to point to your repos, e.g. http://my.org/repo</span>
        maven {
            name = <span class="string"><span class="delimiter">'</span><span class="content">external</span><span class="delimiter">'</span></span>
            url = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/external</span><span class="delimiter">&quot;</span></span>
        }
        maven {
            name = <span class="string"><span class="delimiter">'</span><span class="content">internal</span><span class="delimiter">'</span></span>
            url = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/internal</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;binary&quot;) {
            from(components[&quot;java&quot;])
        }
        create&lt;MavenPublication&gt;(&quot;binaryAndSources&quot;) {
            from(components[&quot;java&quot;])
            artifact(tasks[&quot;sourcesJar&quot;])
        }
    }
    repositories {
        // change URLs to point to your repos, e.g. http://my.org/repo
        maven {
            name = &quot;external&quot;
            url = uri(&quot;$buildDir/repos/external&quot;)
        }
        maven {
            name = &quot;internal&quot;
            url = uri(&quot;$buildDir/repos/internal&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>发布插件将创建任务，使您可以将两个发布中的任何一个发布到任何一个存储库。他们还将这些任务附加到<code>publish</code>聚合任务。但是，假设您要将仅限二进制的发布限制为外部存储库，将带有源的二进制发布限制为内部存储库。为此，您需要使发布成为<em>条件</em>发布。</p>
</div>
<div class="paragraph">
<p>Gradle允许您通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf(org.gradle.api.specs.Spec)">Task.onlyIf（org.gradle.api.specs）根据条件跳过所需的任何任务</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf(org.gradle.api.specs.Spec)">。Spec）</a>方法。下面的示例演示了如何实现我们刚刚提到的约束：</p>
</div>
<div class="exampleblock">
<div class="title">示例409配置应将哪些工件发布到哪些存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(PublishToMavenRepository) {
    onlyIf {
        (repository == publishing.repositories.external &amp;&amp;
            publication == publishing.publications.binary) ||
        (repository == publishing.repositories.internal &amp;&amp;
            publication == publishing.publications.binaryAndSources)
    }
}
tasks.withType(PublishToMavenLocal) {
    onlyIf {
        publication == publishing.publications.binaryAndSources
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType&lt;PublishToMavenRepository&gt;().configureEach {
    onlyIf {
        (repository == publishing.repositories[&quot;external&quot;] &amp;&amp;
            publication == publishing.publications[&quot;binary&quot;]) ||
        (repository == publishing.repositories[&quot;internal&quot;] &amp;&amp;
            publication == publishing.publications[&quot;binaryAndSources&quot;])
    }
}
tasks.withType&lt;PublishToMavenLocal&gt;().configureEach {
    onlyIf {
        publication == publishing.publications[&quot;binaryAndSources&quot;]
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle publish</code></div>
<div class="content">
<pre>&gt; gradle publish
&gt; Task :compileJava
&gt; Task :processResources
&gt; Task :classes
&gt; Task :jar
&gt; Task :generateMetadataFileForBinaryAndSourcesPublication
&gt; Task :generatePomFileForBinaryAndSourcesPublication
&gt; Task :sourcesJar
&gt; Task :publishBinaryAndSourcesPublicationToExternalRepository SKIPPED
&gt; Task :publishBinaryAndSourcesPublicationToInternalRepository
&gt; Task :generateMetadataFileForBinaryPublication
&gt; Task :generatePomFileForBinaryPublication
&gt; Task :publishBinaryPublicationToExternalRepository
&gt; Task :publishBinaryPublicationToInternalRepository SKIPPED
&gt; Task :publish

BUILD SUCCESSFUL in 0s
10 actionable tasks: 10 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您可能还需要定义自己的聚合任务以帮助您的工作流程。例如，假设您有多个发布应发布到外部存储库。一次发布所有这些而不发布内部的可能非常有用。</p>
</div>
<div class="paragraph">
<p>以下示例演示了如何通过定义聚合任务来做到这一点- <code>publishToExternalRepository</code> -取决于所有相关的发布任务：</p>
</div>
<div class="exampleblock">
<div class="title">示例410定义自己的速记任务以进行发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task publishToExternalRepository {
    group = <span class="string"><span class="delimiter">'</span><span class="content">publishing</span><span class="delimiter">'</span></span>
    description = <span class="string"><span class="delimiter">'</span><span class="content">Publishes all Maven publications to the external Maven repository.</span><span class="delimiter">'</span></span>
    dependsOn tasks.withType(PublishToMavenRepository).matching {
        <span class="local-variable">it</span>.repository == publishing.repositories.external
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;publishToExternalRepository&quot;) {
    group = &quot;publishing&quot;
    description = &quot;Publishes all Maven publications to the external Maven repository.&quot;
    dependsOn(tasks.withType&lt;PublishToMavenRepository&gt;().matching {
        it.repository == publishing.repositories[&quot;external&quot;]
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此特定示例通过使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-">TaskCollection.withType（java.lang。类），</a>具有<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html">PublishToMavenRepository</a>任务类型。如果要发布到兼容Ivy的存储库，则可以对<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html">PublishToIvyRepository</a>进行相同的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html">操作</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:configuring_publishing_tasks"><a class="anchor" href="#sec:configuring_publishing_tasks"></a> <a class="link" href="#sec:configuring_publishing_tasks">配置发布任务</a></h5>
<div class="paragraph">
<p>在评估项目之后，发布插件会创建其非聚合任务，这意味着您无法直接从构建脚本中引用它们。如果要配置这些任务中的任何一个，则应使用延迟任务配置。这可以通过项目的方式以多种方式完成<code>tasks</code>采集。</p>
</div>
<div class="paragraph">
<p>例如，假设您想更改<code>generatePomFileFor<em>PubName</em>Publication</code>任务写入其POM文件。您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-">TaskCollection.withType（java.lang。类）</a>方法，如本示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例411。配置由发布插件创建的动态命名任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(GenerateMavenPom).all {
    <span class="keyword">def</span> matcher = name =~ <span class="regexp"><span class="delimiter">/</span><span class="content">generatePomFileFor(</span><span class="char">\w</span><span class="content">+)Publication</span><span class="delimiter">/</span></span>
    <span class="keyword">def</span> publicationName = matcher[<span class="integer">0</span>][<span class="integer">1</span>]
    destination = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/poms/</span><span class="inline"><span class="inline-delimiter">${</span>publicationName<span class="inline-delimiter">}</span></span><span class="content">-pom.xml</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType&lt;GenerateMavenPom&gt;().configureEach {
    val matcher = Regex(&quot;&quot;&quot;generatePomFileFor(\w+)Publication&quot;&quot;&quot;).matchEntire(name)
    val publicationName = matcher?.let { it.groupValues[1] }
    destination = file(&quot;$buildDir/poms/$publicationName-pom.xml&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例使用正则表达式从任务名称中提取发布的名称。这样可以避免所有可能生成的POM文件的文件路径之间发生冲突。如果只有一个出版物，则不必担心此类冲突，因为只有一个POM文件。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dependency_management_terminology"><a class="anchor" href="#dependency_management_terminology"></a> <a class="link" href="#dependency_management_terminology">依赖管理术语</a></h4>
<div class="paragraph">
<p>依赖性管理带有大量术语。在这里，您可以找到最常用的术语，包括对用户指南的引用，以了解其实际应用。</p>
</div>
<div class="sect4">
<h5 id="sub:terminology_artifact"><a class="anchor" href="#sub:terminology_artifact"></a> <a class="link" href="#sub:terminology_artifact">神器</a></h5>
<div class="paragraph">
<p>生成的文件或目录，例如JAR，ZIP发行版或本机可执行文件。</p>
</div>
<div class="paragraph">
<p>工件通常设计为由用户或其他项目使用或使用，或部署到托管系统。在这种情况下，工件是单个文件。目录在项目间相关性的情况下很常见，以避免产生可发布工件的成本。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_capability"><a class="anchor" href="#sub:terminology_capability"></a> <a class="link" href="#sub:terminology_capability">能力</a></h5>
<div class="paragraph">
<p>功能标识由一个或多个组件提供的功能。通过类似于用于<a href="#sub:terminology_module_version">模块版本</a>的坐标的坐标来标识能力。默认情况下，每个模块版本都提供与其坐标匹配的功能，例如<code>com.google:guava:18.0</code> 。功能可以用来表示一个组件提供了多个<a href="#sub:terminology_feature_variant">功能变体，</a>或者两个不同的组件实现了相同的功能（因此不能一起使用）。有关更多详细信息，请参见<a href="#">功能</a>部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_component"><a class="anchor" href="#sub:terminology_component"></a> <a class="link" href="#sub:terminology_component">零件</a></h5>
<div class="paragraph">
<p><a href="#sub:terminology_module">模块的</a>任何单一版本。</p>
</div>
<div class="paragraph">
<p>对于外部库，术语组件是指该库的一个发行版本。</p>
</div>
<div class="paragraph">
<p>在构建中，组件由插件（例如Java库插件）定义，并提供一种简单的方法来定义要发布的发布。它们包括<a href="#sub:terminology_artifact">工件</a>以及适当的<a href="#sub:terminology_artifact">元数据</a> ，这些<a href="#sub:terminology_artifact">元数据</a>详细描述了组件的<a href="#sub:terminology_variant">变体</a> 。例如， <code>java</code>组件在其默认设置中由JAR组成-由<code>jar</code>任务-以及Java <em>api</em>和<em>运行时</em>变体的依赖项信息。它还可以使用相应的工件定义其他变体，例如<em>源</em>和<em>Javadoc</em> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_configuration"><a class="anchor" href="#sub:terminology_configuration"></a> <a class="link" href="#sub:terminology_configuration">组态</a></h5>
<div class="paragraph">
<p>配置是为特定目标分组在一起的一组命名的<a href="#sub:terminology_dependency">依赖项</a> 。配置提供对基础的，已解析的<a href="#sub:terminology_module">模块</a>及其工件的访问。有关更多信息，请参见有关<a href="#sec:what-are-dependency-configurations">依赖项配置</a>以及<a href="#sec:resolvable-consumable-configs">可解析和易用配置的各节</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>单词“配置”是一个重载术语，在依赖项管理的上下文之外具有不同的含义。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_dependency"><a class="anchor" href="#sub:terminology_dependency"></a> <a class="link" href="#sub:terminology_dependency">相依性</a></h5>
<div class="paragraph">
<p>依赖关系是构建，测试或运行<a href="#sub:terminology_module">模块</a>所需的另一软件的指针。有关更多信息，请参见关于<a href="#">声明依赖项</a>的部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_dependency_constraint"><a class="anchor" href="#sub:terminology_dependency_constraint"></a> <a class="link" href="#sub:terminology_dependency_constraint">依赖约束</a></h5>
<div class="paragraph">
<p>依赖关系约束定义了模块要使其成为依赖关系的有效解决结果所需要满足的要求。例如，依赖性约束可以缩小支持的模块版本的范围。依赖性约束可用于表达对传递性依赖性的此类要求。有关更多信息，请参见有关<a href="#">升级</a>和<a href="#">降级</a>传递依赖项的部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_feature_variant"><a class="anchor" href="#sub:terminology_feature_variant"></a> <a class="link" href="#sub:terminology_feature_variant">功能变体</a></h5>
<div class="paragraph">
<p>特征变体是表示可以单独选择或不能单独选择的组件特征的变<a href="#sub:terminology_variant">体</a> 。功能变体由一个或多个<a href="#sub:terminology_capability">功能</a>标识。有关更多信息，请参见有关<a href="#">模型特征变体和可选依赖项的部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_module"><a class="anchor" href="#sub:terminology_module"></a> <a class="link" href="#sub:terminology_module">模组</a></h5>
<div class="paragraph">
<p>随时间推移而发展的软件，例如<a href="https://github.com/google/guava">Google Guava</a> 。每个模块都有一个名称。模块的每个发行版均以<a href="#sub:terminology_module_version">模块版本</a>为代表。为了方便使用，可以将模块托管在<a href="#sub:terminology_repository">资源库中</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_module_metadata"><a class="anchor" href="#sub:terminology_module_metadata"></a> <a class="link" href="#sub:terminology_module_metadata">模块元数据</a></h5>
<div class="paragraph">
<p><a href="#sub:terminology_module">模块的</a>发行版提供元数据。元数据是更详细地描述模块的数据，例如有关工件位置或所需<a href="#sub:terminology_transitive_dependency">传递依赖项的信息</a> 。Gradle提供了自己的元数据格式，称为<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle模块元数据</a> （ <code>.module</code>文件），但也支持Maven（ <code>.pom</code> ）和常春藤（ <code>ivy.xml</code> ）元数据。有关支持的元数据格式的更多信息，请参见<a href="#">了解Gradle模块元数据</a>的部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="component_metadata_rule"><a class="anchor" href="#component_metadata_rule"></a> <a class="link" href="#component_metadata_rule">组件元数据规则</a></h5>
<div class="paragraph">
<p>组件元数据规则是在从存储库中提取组件的元数据后对其进行修改的规则，例如，添加丢失的信息或纠正错误的信息。与<a href="#sub:terminology_resolution_rule">解析规则</a>相反， <strong>在</strong>解析开始<strong>之前</strong>会应用组件元数据规则。组件元数据规则定义为构建逻辑的一部分，可以通过插件共享。有关更多信息，请参见关于<a href="#">使用组件元数据规则修复元数据的部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_module_version"><a class="anchor" href="#sub:terminology_module_version"></a> <a class="link" href="#sub:terminology_module_version">模块版本</a></h5>
<div class="paragraph">
<p>模块版本表示已发布<a href="#sub:terminology_module">模块</a>的一组不同的更改。例如<code>18.0</code>用坐标表示模块的版本<code>com.google:guava:18.0</code> 。实际上，对模块版本的方案没有限制。时间戳，数字，特殊后缀，例如<code>-GA</code>是所有允许的标识符。最广泛使用的版本控制策略是<a href="https://semver.org/">语义版本控制</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub::terminology_platform"><a class="anchor" href="#sub::terminology_platform"></a> <a class="link" href="#sub::terminology_platform">平台</a></h5>
<div class="paragraph">
<p>平台是旨在一起使用的一组模块。平台有不同类别，对应于不同的用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模块集：通常是作为一个整体发布的一组模块。使用集合中的一个模块通常意味着我们要对集合中的所有模块使用相同的版本。例如，如果使用<code>groovy</code> 1.2，也使用<code>groovy-json</code> 1.2。</p>
</li>
<li>
<p>运行时环境：一组可以很好地协同工作的库。例如，Spring Platform，为Spring和与Spring一起使用的组件推荐了版本。</p>
</li>
<li>
<p>部署环境：Java运行时，应用服务器，...</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另外Gradle定义了<a href="#sec:virtual_platform">虚拟平台</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>Maven的BOM（物料清单）是<a href="#sub:bom_import">Gradle支持的</a>一种流行的平台。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_publication"><a class="anchor" href="#sub:terminology_publication"></a> <a class="link" href="#sub:terminology_publication">出版物</a></h5>
<div class="paragraph">
<p>对文件和元数据的描述，这些文件和元数据应作为单个实体发布给存储库以供使用者使用。</p>
</div>
<div class="paragraph">
<p>出版物具有名称，由一个或多个工件以及有关这些工件的信息（ <a href="#sub:terminology_module_metadata">元数据</a> ）组成。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_repository"><a class="anchor" href="#sub:terminology_repository"></a> <a class="link" href="#sub:terminology_repository">资料库</a></h5>
<div class="paragraph">
<p>存储库托管一组<a href="#sub:terminology_module">模块</a> ，每个<a href="#sub:terminology_module">模块</a>可以提供一个或多个由<a href="#sub:terminology_module_version">模块版本</a>指示的发行版（组件）。该存储库可以基于二进制存储库产品（例如Artifactory或Nexus）或文件系统中的目录结构。有关更多信息，请参见<a href="#">声明存储库</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_resolution_rule"><a class="anchor" href="#sub:terminology_resolution_rule"></a> <a class="link" href="#sub:terminology_resolution_rule">解析规则</a></h5>
<div class="paragraph">
<p>解决规则会影响如何直接解决<a href="#sub:terminology_dependency">依赖项</a>的行为。解析规则定义为构建逻辑的一部分。有关更多信息，请参见有关<a href="#">直接自定义依赖项解析</a>的部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_transitive_dependency"><a class="anchor" href="#sub:terminology_transitive_dependency"></a> <a class="link" href="#sub:terminology_transitive_dependency">传递依存关系</a></h5>
<div class="paragraph">
<p><a href="#sub:terminology_component">组件</a>的变体可以依赖于其他模块才能正常工作，即所谓的传递依赖。托管在<a href="#sub:terminology_repository">存储库</a>中的模块的发行版可以提供<a href="#sub:terminology_module_metadata">元数据</a>来声明这些可传递依赖项。默认情况下，Gradle自动解析传递依赖。声明<a href="#">依赖约束</a>可以影响可传递依赖的版本选择。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_variant"><a class="anchor" href="#sub:terminology_variant"></a> <a class="link" href="#sub:terminology_variant">（组件的）变体</a></h5>
<div class="paragraph">
<p>每个<a href="#sub:terminology_component">组件都</a>包含一个或多个变体。变体由一组工件组成，并定义了一组依赖项。它由一组<a href="#sub:terminology_attribute">属性</a>和<a href="#sub:terminology_capability">功能</a>标识。</p>
</div>
<div class="paragraph">
<p>Gradle的依赖项解决方案可识别变体，并在选择组件（即模块的一个版本）后为每个组件选择一个或多个变体。如果变体选择结果不明确，也可能会失败，这意味着Gradle没有足够的信息来选择多个互斥变体之一。在那种情况下，可以通过<a href="#sub:terminology_attribute">变量属性</a>提供更多信息。每个Java组件通常提供的变体示例是<em>api</em>和<em>运行时</em>变体。其他示例是JDK8和JDK11变体。有关更多信息，请参见<a href="#">变量选择</a>部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:terminology_attribute"><a class="anchor" href="#sub:terminology_attribute"></a> <a class="link" href="#sub:terminology_attribute">变体属性</a></h5>
<div class="paragraph">
<p>属性用于识别和选择<a href="#sub:terminology_variant">变体</a> 。一个变体定义了一个或多个属性，例如<code>org.gradle.usage=java-api</code> ， <code>org.gradle.jvm.version=11</code> 。解决依赖关系后，将请求一组属性，并且Gradle会为依赖关系图中的每个组件找到最合适的变量。可以为属性实现兼容性和消歧规则，以表达值之间的兼容性（例如Java 8与Java 11兼容，但是如果请求的版本为11或更高版本，则应该首选Java 11）。此类规则通常由插件提供。有关更多信息，请参见有关<a href="#">变量选择</a>和<a href="#">声明属性的部分</a> 。</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="sect1">
<h2 id="part:jvm_projects"><a class="anchor" href="#part:jvm_projects"></a> <a class="link" href="#part:jvm_projects">Java和其他JVM项目</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="building_java_projects"><a class="anchor" href="#building_java_projects"></a> <a class="link" href="#building_java_projects">构建Java和JVM项目</a></h3>
<div class="paragraph">
<p>Gradle使用基于配置的约定方法来构建基于JVM的项目，该方法借鉴了Apache Maven的几种约定。特别是，它对源文件和资源使用相同的默认目录结构，并且可与Maven兼容的存储库一起使用。</p>
</div>
<div class="paragraph">
<p>我们将在本章中详细研究Java项目，但是大多数主题也适用于其他受支持的JVM语言，例如<a href="https://guides.gradle.org/building-kotlin-jvm-libraries/">Kotlin</a> ， <a href="#groovy_plugin">Groovy</a>和<a href="#scala_plugin">Scala</a> 。如果您没有使用Gradle构建基于JVM的项目的丰富经验，请查看<a href="https://guides.gradle.org/?q=JVM">Java教程</a> ，以获取有关如何构建各种类型的基本Java项目的逐步说明。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>本节中的示例使用Java库插件。但是，所有JVM插件都共享所描述的功能。不同插件的详细信息可在其专用文档中找到。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="introduction"><a class="anchor" href="#introduction"></a> <a class="link" href="#introduction">介绍</a></h4>
<div class="paragraph">
<p>Java项目的最简单构建脚本将应用<a href="#">Java库插件，</a>并可以选择设置项目版本和Java兼容版本：</p>
</div>
<div class="exampleblock">
<div class="title">示例412应用Java库插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

version = <span class="string"><span class="delimiter">'</span><span class="content">1.2.1</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

version = &quot;1.2.1&quot;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过应用Java库插件，您可以获得许多功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>compileJava</code>编译<em>src / main / java</em>下所有Java源文件的任务</p>
</li>
<li>
<p>一种<code>compileTestJava</code> <em>src / test / java</em>下的源文件任务</p>
</li>
<li>
<p>一种<code>test</code>从<em>src / test / java</em>运行测试的任务</p>
</li>
<li>
<p>一种<code>jar</code>打包任务<code>main</code>将<em>src / main / resources中的</em>类和资源编译为一个名为<em><project><version>-.jar的</version></project></em> JAR</p>
</li>
<li>
<p>一种<code>javadoc</code>为该任务生成Javadoc的任务<code>main</code>类</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这还不足以构建任何重要的Java项目-至少，您可能会具有一些文件依赖性。但它意味着你的构建脚本只需要特定于<em>项目</em>的信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">尽管示例中的属性是可选的，但我们建议您在项目中指定它们。兼容性选项可缓解使用不同Java编译器版本构建的项目的问题，并且版本字符串对于跟踪项目的进度很重要。默认情况下，项目版本也用于归档名称中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Java库插件还将上述任务集成到标准的<a href="#sec:base_tasks">基础插件生命周期任务中</a> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jar</code>连接到<code>assemble</code> <sup class="footnote">[ <a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="查看脚注。">9</a> ]</sup></p>
</li>
<li>
<p><code>test</code>连接到<code>check</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本章的其余部分介绍了根据需要自定义构建的不同方法。稍后，您还将看到如何调整库，应用程序，Web应用程序和企业应用程序的构建。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_source_sets"><a class="anchor" href="#sec:java_source_sets"></a> <a class="link" href="#sec:java_source_sets">通过源集声明源文件</a></h4>
<div class="paragraph">
<p>Gradle对Java的支持是第一个引入用于构建基于源代码的项目的新概念的方法： <em>源代码集</em> 。主要思想是源文件和资源通常按类型进行逻辑分组，例如应用程序代码，单元测试和集成测试。每个逻辑组通常都有其自己的文件依赖项集，类路径等。重要的是，构成源集的文件<em>不必位于同一目录中</em> ！</p>
</div>
<div class="paragraph">
<p>源集是一个强大的概念，将编译的几个方面联系在一起：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>源文件及其位置</p>
</li>
<li>
<p>编译类路径，包括任何必需的依赖项（通过Gradle <a href="#sub:terminology_configuration">配置</a> ）</p>
</li>
<li>
<p>放置已编译的类文件的位置</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在此图中看到它们之间的相互关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/java-sourcesets-compilation.png" alt="Java SourceSets编译">
</div>
<div class="title">图25。源集和Java编译</div>
</div>
<div class="paragraph">
<p>阴影框代表源集本身的属性。最重要的是，Java库插件会自动为您或插件定义的每个源集（称为）创建一个编译任务<code>compile<em>SourceSet</em>Java</code> —以及几个<a href="#java_source_set_configurations">依赖项配置</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">的<code>main</code>源集</div>
<div class="paragraph">
<p>大多数语言插件（包括Java）会自动创建一个名为<code>main</code> ，用于项目的生产代码。此源集的特殊之处在于，其名称不包括在配置和任务的名称中，因此，为什么您只有一个<code>compileJava</code>任务和<code>compileOnly</code>和<code>implementation</code>配置而不是<code>compileMainJava</code> ， <code>mainCompileOnly</code>和<code>mainImplementation</code>分别。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Java项目通常包含源文件以外的资源，例如属性文件，这些资源可能需要处理（例如，通过替换文件中的标记）并打包在最终JAR中。 Java库插件通过自动为每个已定义的源集创建一个专用任务来解决此问题， <code>process<em>SourceSet</em>Resources</code> （要么<code>processResources</code>为了<code>main</code>源集）。下图显示了源集如何适合此任务：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/java-sourcesets-process-resources.png" alt="java资源集处理资源">
</div>
<div class="title">图26。处理源集的非源文件</div>
</div>
<div class="paragraph">
<p>与以前一样，阴影框表示源集的属性，在这种情况下，该属性包括资源文件的位置以及将它们复制到的位置。</p>
</div>
<div class="paragraph">
<p>除了<code>main</code>源集，Java库插件定义了一个<code>test</code>表示项目测试的源集。此来源集由<code>test</code>任务，用于运行测试。您可以在<a href="#java_testing">Java测试</a>一章中了解有关此任务和相关主题的更多信息。</p>
</div>
<div class="paragraph">
<p>项目通常使用此源集进行单元测试，但如果需要，也可以将其用于集成，验收和其他类型的测试。另一种方法是为其他每种测试类型<a href="#sec:custom_java_source_sets">定义一个新的源集</a> ，通常是出于以下两个或两个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您想要使测试彼此分开以保持美观和可管理性</p>
</li>
<li>
<p>不同的测试类型需要不同的编译或运行时类路径或设置上的其他差异</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在Java测试一章中看到这种方法的示例，该示例向您<a href="#sec:configuring_java_integration_tests">展示了如何</a>在项目中<a href="#sec:configuring_java_integration_tests">设置集成测试</a> 。</p>
</div>
<div class="paragraph">
<p>您将了解有关源集及其提供的功能的更多信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:custom_java_source_set_paths">自定义文件和目录位置</a></p>
</li>
<li>
<p><a href="#sec:configuring_java_integration_tests">配置Java集成测试</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_dependency_management_overview"><a class="anchor" href="#sec:java_dependency_management_overview"></a> <a class="link" href="#sec:java_dependency_management_overview">管理你的依赖</a></h4>
<div class="paragraph">
<p>绝大多数Java项目都依赖于库，因此管理项目的依赖关系是构建Java项目的重要组成部分。依赖管理是一个大话题，因此我们将在这里重点介绍Java项目的基础知识。如果您想深入研究细节，请查看<a href="#">依赖管理</a>的<a href="#">介绍</a> 。</p>
</div>
<div class="paragraph">
<p>为Java项目指定依赖项仅需要三点信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您需要哪个依赖项，例如名称和版本</p>
</li>
<li>
<p>它需要什么，例如编译或运行</p>
</li>
<li>
<p>在哪里寻找</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前两个在<code>dependencies {}</code>块和第三个<code>repositories {}</code>块。例如，要告诉Gradle您的项目需要3.6.7版的<a href="http://hibernate.org/">Hibernate</a> Core来编译和运行生产代码，并且您想从Maven Central存储库下载该库，可以使用以下片段：</p>
</div>
<div class="exampleblock">
<div class="title">示例413声明依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.hibernate:hibernate-core:3.6.7.Final</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}

dependencies {
    implementation(&quot;org.hibernate:hibernate-core:3.6.7.Final&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>三个元素的Gradle术语如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>储存库</em> （例如： <code>mavenCentral()</code> ）-在哪里寻找您声明为依赖项的模块</p>
</li>
<li>
<p><em>配置</em> （例如： <code>implementation</code> ）-命名的依赖项集合，针对特定目标（如编译或运行模块）分组在一起-一种更灵活的Maven范围形式</p>
</li>
<li>
<p><em>模块坐标</em> （例如： <code>org.hibernate:hibernate-core-3.6.7.Final</code> ）—依赖项的ID，通常采用“ <em><group></group></em> ： <em><module></module></em> ： <em><version></version></em> ' （要么 ' <em><groupid></groupid></em> ： <em><artifactid></artifactid></em> ： <em><version></version></em> '（在Maven术语中）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以<a href="#">在此处</a>找到更全面的依赖项管理术语表。</p>
</div>
<div class="paragraph">
<p>就配置而言，主要感兴趣的是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>compileOnly</code> —用于编译生产代码所必需的依赖性，但不应该将其作为运行时类路径的一部分</p>
</li>
<li>
<p><code>implementation</code> （取代<code>compile</code> ）-用于编译和运行时</p>
</li>
<li>
<p><code>runtimeOnly</code> （取代<code>runtime</code> ）-仅在运行时使用，不用于编译</p>
</li>
<li>
<p><code>testCompileOnly</code> - 和...一样<code>compileOnly</code>除了用于测试</p>
</li>
<li>
<p><code>testImplementation</code> —测试相当于<code>implementation</code></p>
</li>
<li>
<p><code>testRuntimeOnly</code> —测试相当于<code>runtimeOnly</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在<a href="#sec:java_plugin_and_dependency_management">插件参考章节中</a>了解有关它们的更多信息以及它们之间的关系。</p>
</div>
<div class="paragraph">
<p>请注意， <a href="#java_library_plugin">Java库插件</a>会创建其他配置- <code>api</code> —用于编译模块和依赖该模块的任何模块所需的依赖关系。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="title">为什么不<code>compile</code>组态？</div>
<div class="paragraph">
<p>Java库插件在历史上一直使用<code>compile</code>配置编译和运行项目的生产代码所需的依赖项。现在已弃用它，并且在使用时会发出警告，因为它无法区分影响Java库项目的公共API和不影响Java库项目的公共API的依赖项。您可以在<a href="#sec:building_java_libraries">构建Java库中</a>了解有关此区别的重要性的更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们仅在此处进行了介绍，因此，一旦您熟悉使用Gradle构建Java项目的基础知识，我们建议您阅读专用的依赖管理章节。需要进一步阅读的一些常见方案包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义与<a href="#sec:maven_repo">Maven</a>或<a href="#sec:ivy_repositories">Ivy兼容</a>的自定义存储库</p>
</li>
<li>
<p>使用<a href="#sub:flat_dir_resolver">本地文件系统目录中的</a>依赖项</p>
</li>
<li>
<p>使用<a href="#sub:declaring_dependency_with_changing_version">变化的版本</a> （例如SNAPSHOT）和<a href="#sub:declaring_dependency_with_dynamic_version">动态的</a> （范围）声明依赖项</p>
</li>
<li>
<p>将同级<a href="#sub:project_dependencies">项目</a>声明<a href="#sub:project_dependencies">为依赖项</a></p>
</li>
<li>
<p><a href="#">控制传递依赖及其版本</a></p>
</li>
<li>
<p>通过<a href="#composite_builds">组合构建</a>测试对第三方依赖关系的修复（这是发布到<a href="#sub:maven_local">Maven Local</a>和从<a href="#sub:maven_local">Maven Local</a>消费的更好的替代方法）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您会发现Gradle具有丰富的API用于处理依赖关系-一种需要花费时间才能掌握的API，但对于常见情况却很容易使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:compile"><a class="anchor" href="#sec:compile"></a> <a class="link" href="#sec:compile">编译代码</a></h4>
<div class="paragraph">
<p>如果遵循以下约定，则可以同时轻松地对生产代码和测试代码进行编译：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将生产源代码放在<em>src / main / java</em>目录下</p>
</li>
<li>
<p>将测试源代码放在<em>src / test / java下</em></p>
</li>
<li>
<p>在以下位置声明您的生产编译依赖项： <code>compileOnly</code>要么<code>implementation</code>配置（请参阅上一节）</p>
</li>
<li>
<p>在以下位置声明您的测试编译依赖项<code>testCompileOnly</code>要么<code>testImplementation</code>构型</p>
</li>
<li>
<p>跑过<code>compileJava</code>生产代码任务和<code>compileTestJava</code>用于测试</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>其他JVM语言插件，例如<a href="#groovy_plugin">Groovy的</a>插件，遵循相同的约定模式。我们建议您尽可能遵循这些约定，但不必这样做。有几种自定义选项，您将在下面看到。</p>
</div>
<div class="sect4">
<h5 id="sec:custom_java_source_set_paths"><a class="anchor" href="#sec:custom_java_source_set_paths"></a> <a class="link" href="#sec:custom_java_source_set_paths">自定义文件和目录位置</a></h5>
<div class="paragraph">
<p>假设您有一个旧项目，该项目使用<em>src</em>目录存储生产代码并<em>测试</em>测试代码。传统的目录结构不起作用，因此您需要告诉Gradle在哪里可以找到源文件。您可以通过源集配置来实现。</p>
</div>
<div class="paragraph">
<p>每个源集定义其源代码所在的位置，以及类文件的资源和输出目录。您可以使用以下语法覆盖约定值：</p>
</div>
<div class="exampleblock">
<div class="title">实施例414。声明自定义源目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    main {
         java {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>]
         }
    }

    test {
        java {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">test</span><span class="delimiter">'</span></span>]
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    main {
        java {
            setSrcDirs(listOf(&quot;src&quot;))
        }
    }

    test {
        java {
            setSrcDirs(listOf(&quot;test&quot;))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在Gradle将只在<em>src中</em>直接搜索并<em>测试</em>相应的源代码。如果您不想覆盖约定，而只想<em>添加</em>一个额外的源目录，该目录可能包含一些您想分开的第三方源代码，该怎么办？语法类似：</p>
</div>
<div class="exampleblock">
<div class="title">示例415附加声明自定义源目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    main {
        java {
            srcDir <span class="string"><span class="delimiter">'</span><span class="content">thirdParty/src/main/java</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    main {
        java {
            srcDir(&quot;thirdParty/src/main/java&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最重要的是，我们所使用的<em>方法</em> <code>srcDir()</code>在此处添加目录路径，而设置<code>srcDirs</code>属性将替换任何现有值。这是Gradle中的常见约定：设置属性将替换值，而相应的方法将附加值。</p>
</div>
<div class="paragraph">
<p>您可以在DSL参考中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSet.html">SourceSet</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a>上查看源集上可用的所有属性和方法。注意<code>srcDirs</code>和<code>srcDir()</code>都在<code>SourceDirectorySet</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="changing_compiler_options"><a class="anchor" href="#changing_compiler_options"></a> <a class="link" href="#changing_compiler_options">更改编译器选项</a></h5>
<div class="paragraph">
<p>可通过相应的任务访问大多数编译器选项，例如<code>compileJava</code>和<code>compileTestJava</code> 。这些任务的类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a> ，因此，请阅读任务参考以获取最新，最全面的选项列表。</p>
</div>
<div class="paragraph">
<p>例如，如果要为编译器使用单独的JVM进程并防止编译失败使构建失败，则可以使用以下配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例416。设置Java编译器选项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">compileJava {
    options.incremental = <span class="predefined-constant">true</span>
    options.fork = <span class="predefined-constant">true</span>
    options.failOnError = <span class="predefined-constant">false</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.compileJava {
    options.isIncremental = true
    options.isFork = true
    options.isFailOnError = false
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这也是您可以更改编译器的详细程度，禁用字节码中的调试输出以及配置编译器可以在何处找到注释处理器的方式。</p>
</div>
<div class="paragraph">
<p>在项目级别定义了Java编译器的两个常用选项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>sourceCompatibility</code></dt>
<dd>
<p>定义应将源文件视为Java的语言版本。</p>
</dd>
<dt class="hdlist1"><code>targetCompatibility</code></dt>
<dd>
<p>定义您的代码应在其上运行的最低JVM版本，即，它确定编译器生成的字节码的版本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果出于任何原因需要或想要多个编译任务，则可以<a href="#sec:custom_java_source_sets">创建一个新的源集</a> ，也可以简单地定义一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a>类型的新任务。接下来，我们来看设置新的源集。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:java_cross_compilation"><a class="anchor" href="#sec:java_cross_compilation"></a> <a class="link" href="#sec:java_cross_compilation">编译和测试Java 6/7</a></h5>
<div class="paragraph">
<p>Gradle只能在Java版本8或更高版本上运行。</p>
</div>
<div class="paragraph">
<p>Gradle仍支持Java 6和Java 7的编译，测试，生成Javadoc并执行应用程序。不支持Java 5。</p>
</div>
<div class="paragraph">
<p>要使用Java 6或Java 7，需要配置以下任务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JavaCompile</code>分叉并使用正确的Java主页的任务</p>
</li>
<li>
<p><code>Javadoc</code>使用正确的任务<code>javadoc</code>可执行文件</p>
</li>
<li>
<p><code>Test</code>和<code>JavaExec</code>使用正确的任务<code>java</code>可执行文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了<code>build.gradle</code>需要调整。为了使构建与机器无关，应在以下位置配置旧Java主目录和目标版本的位置： <code>GRADLE_USER_HOME/gradle.properties</code>如示例中所示，位于每个开发人员计算机上用户主目录中的<sup class="footnote">[ <a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="查看脚注。">10</a> ]</sup> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configure_java_7_build"><a class="anchor" href="#example_configure_java_7_build"></a> <a class="link" href="#example_configure_java_7_build">示例：配置Java 7构建</a></h5>
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties"># in $HOME/.gradle/gradle.properties
javaHome=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home
targetJavaVersion=1.7</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">assert</span> hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">javaHome</span><span class="delimiter">'</span></span>): <span class="string"><span class="delimiter">&quot;</span><span class="content">Set the property 'javaHome' in your your gradle.properties pointing to a Java 6 or 7 installation</span><span class="delimiter">&quot;</span></span>
<span class="keyword">assert</span> hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">targetJavaVersion</span><span class="delimiter">'</span></span>): <span class="string"><span class="delimiter">&quot;</span><span class="content">Set the property 'targetJavaVersion' in your your gradle.properties to '1.6' or '1.7'</span><span class="delimiter">&quot;</span></span>

java {
    sourceCompatibility = JavaVersion.toVersion(targetJavaVersion)
}

<span class="keyword">def</span> javaExecutablesPath = <span class="keyword">new</span> <span class="predefined-type">File</span>(javaHome, <span class="string"><span class="delimiter">'</span><span class="content">bin</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> javaExecutables = [:].withDefault { execName -&gt;
    <span class="keyword">def</span> executable = <span class="keyword">new</span> <span class="predefined-type">File</span>(javaExecutablesPath, execName)
    <span class="keyword">assert</span> executable.exists(): <span class="string"><span class="delimiter">&quot;</span><span class="content">There is no </span><span class="inline"><span class="inline-delimiter">${</span>execName<span class="inline-delimiter">}</span></span><span class="content"> executable in </span><span class="inline"><span class="inline-delimiter">${</span>javaExecutablesPath<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    executable
}
tasks.withType(AbstractCompile) {
    options.with {
        fork = <span class="predefined-constant">true</span>
        forkOptions.javaHome = file(javaHome)
    }
}
tasks.withType(Javadoc) {
    executable = javaExecutables.javadoc
}
tasks.withType(Test) {
    executable = javaExecutables.java
}
tasks.withType(JavaExec) {
    executable = javaExecutables.java
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">require(hasProperty(&quot;javaHome&quot;)) { &quot;Set the property 'javaHome' in your your gradle.properties pointing to a Java 6 or 7 installation&quot; }
require(hasProperty(&quot;targetJavaVersion&quot;)) { &quot;Set the property 'targetJavaVersion' in your your gradle.properties to '1.6' or '1.7'&quot; }

val javaHome: String by project
val targetJavaVersion: String by project

java {
    sourceCompatibility = JavaVersion.toVersion(targetJavaVersion)
}

val javaExecutablesPath = File(javaHome, &quot;bin&quot;)
fun javaExecutable(execName: String): String {
    val executable = File(javaExecutablesPath, execName)
    require(executable.exists()) { &quot;There is no ${execName} executable in ${javaExecutablesPath}&quot; }
    return executable.toString()
}
tasks.withType&lt;JavaCompile&gt;().configureEach {
    options.apply {
        isFork = true
        forkOptions.javaHome = file(javaHome)
    }
}
tasks.withType&lt;Javadoc&gt;().configureEach {
    executable = javaExecutable(&quot;javadoc&quot;)
}
tasks.withType&lt;Test&gt;().configureEach {
    executable = javaExecutable(&quot;java&quot;)
}
tasks.withType&lt;JavaExec&gt;().configureEach {
    executable = javaExecutable(&quot;java&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:custom_java_source_sets"><a class="anchor" href="#sec:custom_java_source_sets"></a> <a class="link" href="#sec:custom_java_source_sets">分别编译独立源</a></h5>
<div class="paragraph">
<p>大多数项目至少有两个独立的源集：生产代码和测试代码。Gradle已经将此场景作为其Java约定的一部分，但是如果您有其他来源集怎么办？最常见的情况之一是当您进行某种形式或其他形式的单独集成测试时。在这种情况下，自定义源集可能正是您所需要的。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="#sec:configuring_java_integration_tests">Java测试一章中</a>看到设置集成测试的完整示例。您可以设置以相同方式担当不同角色的其他源集。问题就变成了：什么时候应该定义自定义源集？</p>
</div>
<div class="paragraph">
<p>要回答该问题，请考虑以下来源：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>需要使用唯一的类路径进行编译</p>
</li>
<li>
<p>生成处理方式与<code>main</code>和<code>test</code>那些</p>
</li>
<li>
<p>构成项目的自然组成部分</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果您对3和其他任何一个的回答都是肯定的，那么自定义源集可能是正确的方法。例如，集成测试通常是项目的一部分，因为它们在<code>main</code> 。此外，它们通常具有独立于<code>test</code>源集，或者它们需要与自定义一起运行<code>Test</code>任务。</p>
</div>
<div class="paragraph">
<p>其他常见方案不太明确，可能有更好的解决方案。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单独的API和实现JAR-将它们作为单独的项目可能是有意义的，特别是如果您已经具有多项目构建</p>
</li>
<li>
<p>生成的源-如果生成的源应使用生产代码进行编译，则将其路径添加到<code>main</code>源集，并确保<code>compileJava</code>任务取决于生成源的任务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果不确定是否要创建自定义源集，请继续进行操作。它应该很简单，如果不是，则可能不是适合该工作的工具。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_resources"><a class="anchor" href="#sec:java_resources"></a> <a class="link" href="#sec:java_resources">管理资源</a></h4>
<div class="paragraph">
<p>许多Java项目都使用源文件以外的资源，例如图像，配置文件和本地化数据。有时，这些文件只需要原封不动地打包，有时它们需要作为模板文件或以其他方式进行处理。无论哪种方式，Java库插件都会为处理其相关资源处理的每个源集添加特定的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a>任务。</p>
</div>
<div class="paragraph">
<p>任务的名称遵循以下约定<code>process<em>SourceSet</em>Resources</code> - 要么<code>processResources</code>为了<code>main</code>源集-它将自动将<em>src / [sourceSet] / resources</em>中的所有文件复制到将包含在生产JAR中的目录中。该目标目录也将包含在测试的运行时类路径中。</p>
</div>
<div class="paragraph">
<p>以来<code>processResources</code>是<code>Copy</code>任务，您可以执行“ <a href="#sec:copying_files">使用文件”</a>一章中描述的任何处理。</p>
</div>
<div class="sect4">
<h5 id="sec:properties_files"><a class="anchor" href="#sec:properties_files"></a> <a class="link" href="#sec:properties_files">Java属性文件和可复制的内部版本</a></h5>
<div class="paragraph">
<p>您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.WriteProperties.html">WriteProperties</a>任务轻松创建Java属性文件，该任务解决了一个众所周知的问题<code>Properties.store()</code>这会降低<a href="#sec:up_to_date_checks">增量构建</a>的用处。</p>
</div>
<div class="paragraph">
<p>即使使用相同的属性和值，用于编写属性文件的标准Java API也会每次生成一个唯一的文件，因为注释中包括了时间戳。摇篮的<code>WriteProperties</code>如果所有属性均未更改，则task逐字节生成完全相同的输出。这是通过对属性文件的生成方式进行一些调整来实现的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有时间戳注释添加到输出</p>
</li>
<li>
<p>行分隔符与系统无关，但是可以显式配置（默认为<code>'\n'</code> ）</p>
</li>
<li>
<p>属性按字母顺序排序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有时可能需要在不同的计算机上以字节为单位重新创建归档。您想要确保从源代码构建工件，无论在何时何地构建，都逐字节产生相同的结果。这对于诸如reproducible-builds.org之类的项目是必需的。</p>
</div>
<div class="paragraph">
<p>这些调整不仅可以导致更好的增量构建集成，而且还有助于可<a href="https://reproducible-builds.org">复制的构建</a> 。本质上，可重现的构建可确保您无论在何时何地在什么系统上运行，都可以从构建执行中看到相同的结果，包括测试结果和生产二进制文件。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:running_java_tests"><a class="anchor" href="#sec:running_java_tests"></a> <a class="link" href="#sec:running_java_tests">运行测试</a></h4>
<div class="paragraph">
<p>除了在<em>src / test / java中</em>提供单元测试的自动编译功能外，Java库插件还对运行使用JUnit 3、4和5的测试提供了本机支持（ <a href="https://docs.gradle.org/4.6/release-notes.html#junit-5-support">Gradle 4.6中</a>提供<a href="https://docs.gradle.org/4.6/release-notes.html#junit-5-support">了对</a> JUnit 5的支持）和TestNG。你得到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动<code>test</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">Test</a>类型的任务，使用<code>test</code>源集</p>
</li>
<li>
<p>HTML测试报告，其中包含<em>所有</em>结果<code>Test</code>运行的任务</p>
</li>
<li>
<p>轻松过滤要运行的测试</p>
</li>
<li>
<p>精细控制测试的运行方式</p>
</li>
<li>
<p>有机会创建自己的测试执行和测试报告任务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你<em>没有</em>得到<code>Test</code>您声明的每个源集的任务，因为不是每个源集都代表测试！这就是为什么您通常需要<a href="#sec:custom_java_source_sets">创建自己的<code>Test</code></a>集成和验收测试之类的<a href="#sec:custom_java_source_sets">任务</a> （如果不能包含在其中） <code>test</code>源集。</p>
</div>
<div class="paragraph">
<p>由于涉及测试的内容很多，因此本主题有其<a href="#java_testing">自己的章节</a> ，我们将在其中讨论：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>测试如何运行</p>
</li>
<li>
<p>如何通过过滤运行测试的子集</p>
</li>
<li>
<p>Gradle如何发现测试</p>
</li>
<li>
<p>如何配置测试报告并添加自己的报告任务</p>
</li>
<li>
<p>如何利用特定的JUnit和TestNG功能</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以了解更多关于为DSL参考配置的测试<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">试验</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_packaging"><a class="anchor" href="#sec:java_packaging"></a> <a class="link" href="#sec:java_packaging">包装出版</a></h4>
<div class="paragraph">
<p>如何打包和潜在地发布Java项目取决于它是什么类型的项目。库，应用程序，Web应用程序和企业应用程序都有不同的要求。在本节中，我们将重点介绍Java库插件提供的基础知识。</p>
</div>
<div class="paragraph">
<p>默认情况下，Java库插件提供了<code>jar</code>将所有已编译的生产类和资源打包到单个JAR中的任务。该JAR也会由<code>assemble</code>任务。此外，该插件可以配置为提供<code>javadocJar</code>和<code>sourcesJar</code>打包Javadoc和源代码的任务（如果需要）。如果使用发布插件，这些任务将在发布期间自动运行或可以直接调用。</p>
</div>
<div class="exampleblock">
<div class="title">例子417。配置项目以发布Javadoc和源</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    withJavadocJar()
    withSourcesJar()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    withJavadocJar()
    withSourcesJar()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要创建“超级”（又称“胖”）JAR，则可以使用如下任务定义：</p>
</div>
<div class="exampleblock">
<div class="title">实施例418。创建Java uber或fat JAR</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}

version = <span class="string"><span class="delimiter">'</span><span class="content">1.0.0</span><span class="delimiter">'</span></span>

repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">commons-io:commons-io:2.6</span><span class="delimiter">'</span></span>
}

task uberJar(<span class="key">type</span>: Jar) {
    archiveClassifier = <span class="string"><span class="delimiter">'</span><span class="content">uber</span><span class="delimiter">'</span></span>

    from sourceSets.main.output

    dependsOn configurations.runtimeClasspath
    from {
        configurations.runtimeClasspath.findAll { <span class="local-variable">it</span>.name.endsWith(<span class="string"><span class="delimiter">'</span><span class="content">jar</span><span class="delimiter">'</span></span>) }.collect { zipTree(<span class="local-variable">it</span>) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}

version = &quot;1.0.0&quot;

repositories {
    mavenCentral()
}

dependencies {
    implementation(&quot;commons-io:commons-io:2.6&quot;)
}

tasks.register&lt;Jar&gt;(&quot;uberJar&quot;) {
    archiveClassifier.set(&quot;uber&quot;)

    from(sourceSets.main.get().output)

    dependsOn(configurations.runtimeClasspath)
    from({
        configurations.runtimeClasspath.get().filter { it.name.endsWith(&quot;jar&quot;) }.map { zipTree(it) }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关可用配置选项的更多详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">Jar</a> 。并请注意，您需要使用<code>archiveClassifier</code>而不是<code>archiveAppendix</code>在此处正确发布JAR。</p>
</div>
<div class="paragraph">
<p>您可以使用发布插件之一来发布由Java项目创建的JAR：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#publishing_maven">Maven发布插件</a></p>
</li>
<li>
<p><a href="#publishing_ivy">常春藤发布插件</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="sec:jar_manifest"><a class="anchor" href="#sec:jar_manifest"></a> <a class="link" href="#sec:jar_manifest">修改JAR清单</a></h5>
<div class="paragraph">
<p>每个实例<code>Jar</code> ， <code>War</code>和<code>Ear</code>任务有一个<code>manifest</code>属性，使您可以自定义进入相应归档文件的<em>MANIFEST.MF</em>文件。下面的示例演示如何在JAR清单中设置属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例419。自定义MANIFEST.MF</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jar {
    manifest {
        attributes(<span class="string"><span class="delimiter">&quot;</span><span class="content">Implementation-Title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Gradle</span><span class="delimiter">&quot;</span></span>,
                   <span class="string"><span class="delimiter">&quot;</span><span class="content">Implementation-Version</span><span class="delimiter">&quot;</span></span>: archiveVersion)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.jar {
    manifest {
        attributes(
            &quot;Implementation-Title&quot; to &quot;Gradle&quot;,
            &quot;Implementation-Version&quot; to archiveVersion
        )
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/java/archives/Manifest.html">清单</a>以获取其提供的配置选项。</p>
</div>
<div class="paragraph">
<p>您还可以创建的独立实例<code>Manifest</code> 。这样做的原因之一是在JAR之间共享清单信息。下面的示例演示如何在JAR之间共享通用属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例420创建清单对象。</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ext.sharedManifest = manifest {
    attributes(<span class="string"><span class="delimiter">&quot;</span><span class="content">Implementation-Title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Gradle</span><span class="delimiter">&quot;</span></span>,
               <span class="string"><span class="delimiter">&quot;</span><span class="content">Implementation-Version</span><span class="delimiter">&quot;</span></span>: version)
}
task fooJar(<span class="key">type</span>: Jar) {
    manifest = project.manifest {
        from sharedManifest
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val sharedManifest = the&lt;JavaPluginConvention&gt;().manifest {
    attributes (
        &quot;Implementation-Title&quot; to &quot;Gradle&quot;,
        &quot;Implementation-Version&quot; to version
    )
}

tasks.register&lt;Jar&gt;(&quot;fooJar&quot;) {
    manifest = project.the&lt;JavaPluginConvention&gt;().manifest {
        from(sharedManifest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以选择的另一种选择是将清单合并为一个<code>Manifest</code>宾语。这些源清单可以采用或的文本形式<code>Manifest</code>宾语。在下面的示例中，源清单是除以下内容之外的所有文本文件： <code>sharedManifest</code> ， 哪一个是<code>Manifest</code>上例中的对象：</p>
</div>
<div class="exampleblock">
<div class="title">示例421。单独的MANIFEST.MF用于特定的存档</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task barJar(<span class="key">type</span>: Jar) {
    manifest {
        attributes <span class="key">key1</span>: <span class="string"><span class="delimiter">'</span><span class="content">value1</span><span class="delimiter">'</span></span>
        from sharedManifest, <span class="string"><span class="delimiter">'</span><span class="content">src/config/basemanifest.txt</span><span class="delimiter">'</span></span>
        from([<span class="string"><span class="delimiter">'</span><span class="content">src/config/javabasemanifest.txt</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">src/config/libbasemanifest.txt</span><span class="delimiter">'</span></span>]) {
            eachEntry { details -&gt;
                <span class="keyword">if</span> (details.baseValue != details.mergeValue) {
                    details.value = baseValue
                }
                <span class="keyword">if</span> (details.key == <span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>) {
                    details.exclude()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Jar&gt;(&quot;barJar&quot;) {
    manifest {
        attributes(&quot;key1&quot; to &quot;value1&quot;)
        from(sharedManifest, &quot;src/config/basemanifest.txt&quot;)
        from(listOf(&quot;src/config/javabasemanifest.txt&quot;, &quot;src/config/libbasemanifest.txt&quot;)) {
            eachEntry(Action&lt;ManifestMergeDetails&gt; {
                if (baseValue != mergeValue) {
                    value = baseValue
                }
                if (key == &quot;foo&quot;) {
                    exclude()
                }
            })
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>清单按照它们在声明中的顺序合并<code>from</code>声明。如果基本清单和合并清单都为同一键定义值，则默认情况下合并清单将获胜。您可以通过添加来完全自定义合并行为<code>eachEntry</code>您可以对结果清单的每个条目访问<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/java/archives/ManifestMergeDetails.html">ManifestMergeDetails</a>实例的操作。请注意，合并是在生成JAR时或在<code>Manifest.writeTo()</code>要么<code>Manifest.getEffectiveManifest()</code>被称为。</p>
</div>
<div class="paragraph">
<p>说起<code>writeTo()</code> ，您可以使用它随时轻松地将清单写入磁盘，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例422将MANIFEST.MF保存到磁盘</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jar.manifest.writeTo(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/mymanifest.mf</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;Jar&gt;(&quot;jar&quot;) { manifest.writeTo(&quot;$buildDir/mymanifest.mf&quot;) }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:generating_javadocs"><a class="anchor" href="#sec:generating_javadocs"></a> <a class="link" href="#sec:generating_javadocs">生成API文档</a></h4>
<div class="paragraph">
<p>Java库插件提供了一个<code>javadoc</code>类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.javadoc.Javadoc.html">Javadoc的</a>任务，它将为您的所有生产代码（即， <code>main</code>源集。该任务支持<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html#options">Javadoc参考文档中</a>描述的核心Javadoc和标准doclet选项。有关这些选项的完整列表，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/external/javadoc/CoreJavadocOptions.html">CoreJavadocOptions</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/external/javadoc/StandardJavadocDocletOptions.html">StandardJavadocDocletOptions</a> 。</p>
</div>
<div class="paragraph">
<p>作为您可以执行的操作的示例，假设您想在Javadoc注释中使用Asciidoc语法。为此，您需要将Asciidoclet添加到Javadoc的doclet路径。这是一个执行此操作的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例423在Javadoc中使用自定义doclet</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    asciidoclet
}

dependencies {
    asciidoclet <span class="string"><span class="delimiter">'</span><span class="content">org.asciidoctor:asciidoclet:1.+</span><span class="delimiter">'</span></span>
}

task configureJavadoc {
    doLast {
        javadoc {
            options.doclet = <span class="string"><span class="delimiter">'</span><span class="content">org.asciidoctor.Asciidoclet</span><span class="delimiter">'</span></span>
            options.docletpath = configurations.asciidoclet.files.toList()
        }
    }
}

javadoc {
    dependsOn configureJavadoc
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val asciidoclet by configurations.creating

dependencies {
    asciidoclet(&quot;org.asciidoctor:asciidoclet:1.+&quot;)
}

tasks.register(&quot;configureJavadoc&quot;) {
    doLast {
        tasks.javadoc {
            options.doclet = &quot;org.asciidoctor.Asciidoclet&quot;
            options.docletpath = asciidoclet.files.toList()
        }
    }
}

tasks.javadoc {
    dependsOn(&quot;configureJavadoc&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您不必为此创建配置，但这是一种处理独特目的所需依赖项的绝妙方法。</p>
</div>
<div class="paragraph">
<p>您可能还想创建自己的Javadoc任务，例如为测试生成API文档：</p>
</div>
<div class="exampleblock">
<div class="title">示例424定义自定义Javadoc任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task testJavadoc(<span class="key">type</span>: Javadoc) {
    source = sourceSets.test.allJava
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Javadoc&gt;(&quot;testJavadoc&quot;) {
    source = sourceSets.test.get().allJava
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这些只是您可能会遇到的两个不重要但常见的自定义。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:cleaning_java_build"><a class="anchor" href="#sec:cleaning_java_build"></a> <a class="link" href="#sec:cleaning_java_build">清理构建</a></h4>
<div class="paragraph">
<p>Java库插件添加了一个<code>clean</code>通过应用<a href="#base_plugin">基础插件</a>将任务应用于项目。此任务只是删除了<code>$buildDir</code>目录，因此为什么要始终将构建生成的文件放在其中。该任务是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">Delete的</a>一个实例，您可以通过设置其删除来更改其删除的目录<code>dir</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_jvm_components"><a class="anchor" href="#sec:building_jvm_components"></a> <a class="link" href="#sec:building_jvm_components">构建JVM组件</a></h4>
<div class="paragraph">
<p>所有特定的JVM插件都构建在<a href="#">Java插件</a>之上。上面的示例仅说明了此基本插件提供的概念，并与所有JVM插件共享。</p>
</div>
<div class="paragraph">
<p>继续阅读以了解哪些插件适合哪种项目类型，因为建议选择特定的插件而不是直接应用Java插件。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_java_libraries"><a class="anchor" href="#sec:building_java_libraries"></a> <a class="link" href="#sec:building_java_libraries">构建Java库</a></h4>
<div class="paragraph">
<p>库项目的独特之处在于它们被其他Java项目使用（或“消耗”）。这意味着与JAR文件一起发布的依赖项元数据（通常以Maven POM的形式）至关重要。特别是，您的库的使用者应能够区分两种不同类型的依赖关系：仅依赖于编译库的依赖和也依赖于编译使用者的依赖。</p>
</div>
<div class="paragraph">
<p>Gradle通过<a href="#java_library_plugin">Java库插件</a>来管理这种区别，该<a href="#java_library_plugin">插件</a>除了本章介绍的<em>实现</em>之外，还引入了<em>api</em>配置。如果依赖项的类型出现在库的公共类的公共字段或方法中，则该依赖项将通过库的公共API公开，因此应将其添加到<em>api</em>配置中。否则，依赖项是内部实现细节，应将其添加到<em>Implementation中</em> 。</p>
</div>
<div class="paragraph">
<p>如果不确定API和实现依赖项之间的区别，请参阅<a href="#sec:java_library_recognizing_dependencies">Java库插件一章</a>中的详细说明。此外，您可以在相应的<a href="https://guides.gradle.org/building-java-libraries/"><em>指南中</em></a>看到构建Java库的基本，实际示例。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_java_applications"><a class="anchor" href="#sec:building_java_applications"></a> <a class="link" href="#sec:building_java_applications">构建Java应用程序</a></h4>
<div class="paragraph">
<p>无法将打包为JAR的Java应用程序设置为易于从命令行或桌面环境启动。<a href="#application_plugin">应用程序插件</a>通过创建包含生产JAR，其依赖项以及启动脚本（类似于Unix和Windows系统）的发行版来解决命令行方面的问题。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见插件的章节，但这是您所获得的快速摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>assemble</code>创建应用程序的ZIP和TAR发行版，其中包含运行它所需的一切</p>
</li>
<li>
<p>一种<code>run</code>从构建启动应用程序的任务（以便于测试）</p>
</li>
<li>
<p>Shell和Windows Batch脚本启动应用程序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在相应的<a href="https://guides.gradle.org/building-java-applications/"><em>指南中</em></a>看到构建Java应用程序的基本示例。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_java_webapps"><a class="anchor" href="#sec:building_java_webapps"></a> <a class="link" href="#sec:building_java_webapps">构建Java Web应用程序</a></h4>
<div class="paragraph">
<p>Java Web应用程序可以根据您使用的技术以多种方式打包和部署。例如，您可以将<a href="https://projects.spring.io/spring-boot/">Spring Boot</a>与胖JAR或<a href="https://netty.io/">Netty上</a>运行的基于<a href="https://www.reactivemanifesto.org/">Reactive</a>的系统一起使用。无论您使用什么技术，Gradle及其庞大的插件社区都可以满足您的需求。但是，Core Gradle仅直接支持部署为WAR文件的传统基于Servlet的Web应用程序。</p>
</div>
<div class="paragraph">
<p>该支持来自<a href="#war_plugin">War插件</a> ，该<a href="#war_plugin">插件</a>会自动应用Java插件并添加一个额外的打包步骤，该步骤执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将静态资源从<em>src / main / webapp</em>复制到WAR的根目录中</p>
</li>
<li>
<p>将编译后的生产类复制到WAR的<em>WEB-INF / classes</em>子目录中</p>
</li>
<li>
<p>将库依赖项复制到WAR的<em>WEB-INF / lib</em>子目录中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是由<code>war</code>任务，它有效地替代了<code>jar</code>任务-尽管该任务仍然存在-并且已附加到<code>assemble</code>生命周期任务。有关更多详细信息和配置选项，请参见插件的章节。</p>
</div>
<div class="paragraph">
<p>没有直接从内部版本运行Web应用程序的核心支持，但是我们建议您尝试使用<a href="https://plugins.gradle.org/plugin/org.gretty">Gretty</a>社区插件，该插件提供了嵌入式Servlet容器。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_java_enterprise_apps"><a class="anchor" href="#sec:building_java_enterprise_apps"></a> <a class="link" href="#sec:building_java_enterprise_apps">构建Java EE应用程序</a></h4>
<div class="paragraph">
<p>多年来，Java企业系统已经发生了很大的变化，但是如果您仍要部署到JEE应用服务器，则可以使用<a href="#ear_plugin">Ear Plugin</a> 。这增加了约定和构建EAR文件的任务。插件的章节有更多详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_java_platform"><a class="anchor" href="#sec:building_java_platform"></a> <a class="link" href="#sec:building_java_platform">构建Java平台</a></h4>
<div class="paragraph">
<p>Java平台代表了一组依赖项声明和约束，这些声明和约束形成了要在消费项目上应用的内聚单元。该平台没有来源，也没有自己的工件。它在Maven世界中映射到<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management">BOM</a> 。</p>
</div>
<div class="paragraph">
<p>该支持来自<a href="#">Java Platform插件</a> ，该<a href="#">插件</a>设置了不同的配置和发布组件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>该插件是例外，因为它不应用Java插件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_jvm_lang"><a class="anchor" href="#sec:building_jvm_lang"></a> <a class="link" href="#sec:building_jvm_lang">构建其他JVM语言项目</a></h4>
<div class="paragraph">
<p>如果要利用JVM的多语言方面，此处描述的大多数内容仍然适用。</p>
</div>
<div class="paragraph">
<p>Gradle本身提供了<a href="#">Groovy</a>和<a href="#">Scala</a>插件。请注意，可以通过将它们与<code>java-library</code>插入。</p>
</div>
<div class="paragraph">
<p>除了核心Gradle之外，还有其他<a href="https://plugins.gradle.org/search?term=jvm">很棒的插件可</a>用于更多JVM语言！</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java_testing"><a class="anchor" href="#java_testing"></a> <a class="link" href="#java_testing">在Java和JVM项目中进行测试</a></h3>
<div class="paragraph">
<p>在JVM上进行测试是一个很丰富的主题。有许多不同的测试库和框架，以及许多不同类型的测试。无论它们是频繁执行还是不频繁执行，所有这些都需要成为构建的一部分。本章致力于解释Gradle如何处理内部版本之间以及内部内部的不同需求，并广泛介绍了Gradle如何与两个最常见的测试框架<a href="https://junit.org/">JUnit</a>和<a href="https://testng.org/">TestNG</a>集成。</p>
</div>
<div class="paragraph">
<p>它说明：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>控制测试运行方式的方法（ <a href="#sec:test_execution">测试执行</a> ）</p>
</li>
<li>
<p>如何选择要运行的特定测试（ <a href="#test_filtering">测试过滤</a> ）</p>
</li>
<li>
<p>生成什么测试报告以及如何影响过程（ <a href="#test_reporting">测试报告</a> ）</p>
</li>
<li>
<p>Gradle如何找到要运行的<a href="#sec:test_detection">测试</a> （ <a href="#sec:test_detection">测试检测</a> ）</p>
</li>
<li>
<p>如何利用主要框架的机制将测试分组在一起（ <a href="#test_grouping">测试分组</a> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是首先，我们看一下Gradle中JVM测试的基础。</p>
</div>
<div class="sect3">
<h4 id="sec:java_testing_basics"><a class="anchor" href="#sec:java_testing_basics"></a> <a class="link" href="#sec:java_testing_basics">基础</a></h4>
<div class="paragraph">
<p>所有JVM测试都围绕一种任务类型： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">Test</a> 。这将使用任何受支持的测试库（JUnit，JUnit Platform或TestNG）运行一组测试用例，并整理结果。然后，您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.TestReport.html">TestReport</a>任务类型的实例将这些结果转换为报告。</p>
</div>
<div class="paragraph">
<p>为了操作， <code>Test</code>任务类型仅需要两条信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在哪里可以找到已编译的测试类（属性： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:testClassesDirs">Test.getTestClassesDirs（）</a> ）</p>
</li>
<li>
<p>执行类路径，其中应包括被测类以及您正在使用的测试库（属性： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:classpath">Test.getClasspath（）</a> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当您使用JVM语言插件（例如<a href="#java_plugin">Java插件）时</a> ，您将自动获得以下信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>专用<code>test</code>单元测试的源集</p>
</li>
<li>
<p>一种<code>test</code>任务类型<code>Test</code>运行那些单元测试</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>JVM语言插件使用源集来配置具有适当执行类路径和包含已编译测试类的目录的任务。此外，他们附加了<code>test</code>任务<code>check</code> <a href="#sec:lifecycle_tasks">生命周期任务</a> 。</p>
</div>
<div class="paragraph">
<p>还应牢记<code>test</code>源集自动创建<a href="#java_source_set_configurations">相应的依赖项配置</a> ，其中最有用的是<code>testImplementation</code>和<code>testRuntimeOnly</code> -插件与<code>test</code>任务的类路径。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，您需要做的就是配置适当的编译和运行时依赖项，并将所有必要的配置添加到<code>test</code>任务。以下示例显示了一个简单的设置，该设置使用JUnit 4.x并将测试JVM的最大堆大小更改为1 GB：</p>
</div>
<div class="exampleblock">
<div class="title">示例425“测试”任务的基本配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
}

test {
    useJUnit()

    maxHeapSize = <span class="string"><span class="delimiter">'</span><span class="content">1G</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;junit:junit:4.12&quot;)
}

tasks.test {
    useJUnit()

    maxHeapSize = &quot;1G&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">Test</a>任务具有许多通用配置选项，以及可以在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/junit/JUnitOptions.html">JUnitOptions</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/junitplatform/JUnitPlatformOptions.html">JUnitPlatformOptions</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html">TestNGOptions中</a>找到的几个特定于框架的选项。在本章的其余部分中，我们将讨论其中的许多内容。</p>
</div>
<div class="paragraph">
<p>如果您想设置自己的<code>Test</code>具有自己的测试类集的任务，那么最简单的方法是创建自己的源集并<code>Test</code>任务实例，如<a href="#sec:configuring_java_integration_tests">配置集成测试中</a>所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:test_execution"><a class="anchor" href="#sec:test_execution"></a> <a class="link" href="#sec:test_execution">测试执行</a></h4>
<div class="paragraph">
<p>Gradle在独立于主构建过程的单独（“分叉”）JVM中执行测试。这样可以防止类路径污染和构建过程中过多的内存消耗。它还允许您使用与构建使用的JVM参数不同的JVM参数运行测试。</p>
</div>
<div class="paragraph">
<p>您可以通过上的几个属性来控制如何启动测试过程<code>Test</code>任务，包括以下内容：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>maxParallelForks</code> —默认值：1</dt>
<dd>
<p>通过将此属性设置为大于1的值，可以并行运行测试。这可能会使您的测试套件更快地完成，特别是如果您在多核CPU上运行它们。使用并行测试执行时，请确保您的测试正确地相互隔离。与文件系统交互的测试特别容易发生冲突，从而导致间歇性的测试失败。</p>
<div class="paragraph">
<p>您的测试可以通过使用<code>org.gradle.test.worker</code>属性，对于每个过程来说都是唯一的。您可以将其用于任何所需的内容，但是对于文件名和其他资源标识符特别有用，可以防止我们刚才提到的那种冲突。</p>
</div>
</dd>
<dt class="hdlist1"><code>forkEvery</code> —默认值：0（无最大值）</dt>
<dd>
<p>此属性指定Gradle在处理掉并创建新的测试过程之前应在测试过程中运行的最大测试类数。这主要用作管理泄漏测试或框架的静态状态，这些静态状态无法在测试之间清除或重置的方法。</p>
<div class="paragraph">
<p><strong>警告：较低的值（非0）会严重损害测试的性能</strong></p>
</div>
</dd>
<dt class="hdlist1"><code>ignoreFailures</code> —默认值：false</dt>
<dd>
<p>如果此属性是<code>true</code>测试完成后，即使其中一些失败，Gradle也会继续进行项目的构建。请注意，默认情况下， <code>Test</code>无论此设置如何，任务始终执行它检测到的每个测试。</p>
</dd>
<dt class="hdlist1"><code>failFast</code> —（自Gradle 4.6起）默认值：false</dt>
<dd>
<p>设置为<code>true</code>如果您希望构建失败并在其中一项测试失败后立即完成。当您拥有长期运行的测试套件时，这可以节省大量时间，并且在连续集成服务器上运行构建时特别有用。如果在运行所有测试之前构建失败，则测试报告仅包括已成功完成或未成功完成的测试结果。</p>
<div class="paragraph">
<p>您还可以通过使用<code>--fail-fast</code>命令行选项。</p>
</div>
</dd>
<dt class="hdlist1"><code>testLogging</code> —默认值： <em>未设置</em></dt>
<dd>
<p>此属性表示一组选项，用于控制记录哪些测试事件以及在什么级别进行记录。您还可以通过此属性配置其他日志记录行为。有关更多详细信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/logging/TestLoggingContainer.html">TestLoggingContainer</a> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关所有可用配置选项的详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果配置不正确，测试过程可能会意外退出。例如，如果Java可执行文件不存在或提供了无效的JVM参数，则测试过程将无法启动。同样，如果测试对测试过程进行程序化更改，这也会导致意外失败。</p>
</div>
<div class="paragraph">
<p>例如，如果<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html">SecurityManager</a></code>在测试中对Gradle进行了修改，因为Gradle的内部消息传递依赖于反射和套接字通信，如果安全管理器上的权限发生更改，则可能会中断通信。在这种情况下，您应该还原原始<code>SecurityManager</code>测试后，gradle测试工作程序进程可以继续运行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="test_filtering"><a class="anchor" href="#test_filtering"></a> <a class="link" href="#test_filtering">测试过滤</a></h4>
<div class="paragraph">
<p>运行测试套件的子集是常见的要求，例如，在修复错误或开发新的测试用例时。Gradle提供了两种机制来执行此操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>过滤（首选选项）</p>
</li>
<li>
<p>测试包含/排除</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>过滤取代了包含/排除机制，但您仍可能在野外遇到后者。</p>
</div>
<div class="paragraph">
<p>使用Gradle的测试过滤，您可以根据以下条件选择要运行的测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>完全限定的类名或完全限定的方法名，例如<code>org.gradle.SomeTest</code> ，<code>org.gradle.SomeTest.someMethod</code></p>
</li>
<li>
<p>一个简单的类名或方法名（如果模式以大写字母开头），例如<code>SomeTest</code> ， <code>SomeTest.someMethod</code> （自Gradle 4.7起）</p>
</li>
<li>
<p>'*'通配符匹配</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过构建脚本或通过启用过滤<code>--tests</code>命令行选项。这是每次构建运行时都会应用的一些过滤器的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例426在构建脚本中过滤测试</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    filter {
        <span class="comment">//include specific method in any of the tests</span>
        includeTestsMatching <span class="string"><span class="delimiter">&quot;</span><span class="content">*UiCheck</span><span class="delimiter">&quot;</span></span>

        <span class="comment">//include all tests from package</span>
        includeTestsMatching <span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.internal.*</span><span class="delimiter">&quot;</span></span>

        <span class="comment">//include all integration tests</span>
        includeTestsMatching <span class="string"><span class="delimiter">&quot;</span><span class="content">*IntegTest</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    filter {
        //include specific method in any of the tests
        includeTestsMatching(&quot;*UiCheck&quot;)

        //include all tests from package
        includeTestsMatching(&quot;org.gradle.internal.*&quot;)

        //include all integration tests
        includeTestsMatching(&quot;*IntegTest&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关在构建脚本中声明过滤器的更多详细信息和示例，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/TestFilter.html">TestFilter</a>参考。</p>
</div>
<div class="paragraph">
<p>命令行选项对于执行单个测试方法特别有用。使用时<code>--tests</code> ，请注意仍然尊重构建脚本中声明的包含。也可以提供多个<code>--tests</code>选项，所有模式都会生效。以下各节提供了几个使用命令行选项的示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">并非所有的测试框架都可以很好地与过滤一起使用。某些高级的综合测试可能不完全兼容。但是，绝大多数测试和用例都可以通过Gradle的过滤机制很好地工作。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下两节介绍简单类/方法名称和完全限定名称的特殊情况。</p>
</div>
<div class="sect4">
<h5 id="simple_name_pattern"><a class="anchor" href="#simple_name_pattern"></a> <a class="link" href="#simple_name_pattern">简单名称模式</a></h5>
<div class="paragraph">
<p>从4.7开始，Gradle将以大写字母开头的模式作为简单的类名或类名+方法名。例如，以下命令行可运行或完全测试其中一个测试<code>SomeTestClass</code>测试用例，无论它位于哪个软件包中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code># Executes all tests in SomeTestClass
gradle test --tests SomeTestClass

# Executes a single specified test in SomeTestClass
gradle test --tests SomeTestClass.someSpecificMethod

gradle test --tests SomeTestClass.*someMethod*</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="full_qualified_name_pattern"><a class="anchor" href="#full_qualified_name_pattern"></a> <a class="link" href="#full_qualified_name_pattern">完全限定的名称模式</a></h5>
<div class="paragraph">
<p>在4.7之前，或者如果模式不是以大写字母开头，则Gradle会将模式视为完全合格。因此，如果您想使用测试类名称而不考虑其软件包，则可以使用<code>--tests *.SomeTestClass</code> 。这里还有更多示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code># specific class
gradle test --tests org.gradle.SomeTestClass

# specific class and method
gradle test --tests org.gradle.SomeTestClass.someSpecificMethod

# method name containing spaces
gradle test --tests "org.gradle.SomeTestClass.some method containing spaces"

# all classes at specific package (recursively)
gradle test --tests 'all.in.specific.package*'

# specific method at specific package (recursively)
gradle test --tests 'all.in.specific.package*.someSpecificMethod'

gradle test --tests '*IntegTest'

gradle test --tests '*IntegTest*ui*'

gradle test --tests '*ParameterizedTest.foo*'

# the second iteration of a parameterized test
gradle test --tests '*ParameterizedTest.*[2]'</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，通配符'*'对'。'没有特殊的理解。包装分离器。它是纯粹基于文本的。所以<code>--tests *.SomeTestClass</code>将匹配任何程序包，无论其“深度”如何。</p>
</div>
<div class="paragraph">
<p>您还可以将在命令行中定义的过滤器与<a href="#sec:continuous_build">连续构建结合使用，</a>以在每次对生产或测试源文件进行更改后立即重新执行测试的子集。每当更改触发测试运行时，以下命令将执行“ com.mypackage.foo”包或子包中的所有测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>gradle test --continuous --tests "com.mypackage.foo.*"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test_reporting"><a class="anchor" href="#test_reporting"></a> <a class="link" href="#test_reporting">测试报告</a></h4>
<div class="paragraph">
<p>的<code>Test</code>默认情况下，任务生成以下结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTML测试报告</p>
</li>
<li>
<p>XML测试结果的格式与Ant JUnit报告任务兼容-许多其他工具（例如CI服务器）都支持该格式</p>
</li>
<li>
<p>有效的二进制格式的结果<code>Test</code>生成其他格式的任务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在大多数情况下，您将使用标准HTML报告，该报告会自动包含<em>所有</em>您的结果<code>Test</code>任务，甚至是您自己明确添加到构建中的任务。例如，如果您添加一个<code>Test</code>集成测试任务，如果两个任务都运行，则报告将包含单元测试和集成测试的结果。</p>
</div>
<div class="paragraph">
<p>与许多测试配置选项不同，有一些项目级别的<a href="#sec:java_convention_properties">约定属性会影响测试报告</a> 。例如，您可以像这样更改测试结果和报告的目的地：</p>
</div>
<div class="exampleblock">
<div class="title">示例427更改默认的测试报告和结果目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">reporting.baseDir = <span class="string"><span class="delimiter">&quot;</span><span class="content">my-reports</span><span class="delimiter">&quot;</span></span>
testResultsDirName = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/my-test-results</span><span class="delimiter">&quot;</span></span>

task showDirs {
    doLast {
        logger.quiet(rootDir.toPath().relativize(project.reportsDir.toPath()).toString())
        logger.quiet(rootDir.toPath().relativize(project.testResultsDir.toPath()).toString())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">reporting.baseDir = file(&quot;my-reports&quot;)
project.setProperty(&quot;testResultsDirName&quot;, &quot;$buildDir/my-test-results&quot;)

tasks.register(&quot;showDirs&quot;) {
    doLast {
        logger.quiet(rootDir.toPath().relativize((project.properties[&quot;reportsDir&quot;] as File).toPath()).toString())
        logger.quiet(rootDir.toPath().relativize((project.properties[&quot;testResultsDir&quot;] as File).toPath()).toString())
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q showDirs</code></strong></div>
<div class="content">
<pre>&gt; gradle -q showDirs
my-reports
build/my-test-results</pre>
</div>
</div>
<div class="paragraph">
<p>单击链接到约定属性以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>还有一个独立的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.TestReport.html">TestReport</a>任务类型，可用于生成自定义HTML测试报告。它所需要的只是一个价值<code>destinationDir</code>以及您想要包含在报告中的测试结果。这是一个示例，可为所有子项目的单元测试生成组合报告：</p>
</div>
<div class="exampleblock">
<div class="title">示例428为子项目创建单元测试报告</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>

    <span class="comment">// Disable the test report for the individual test task</span>
    test {
        reports.html.enabled = <span class="predefined-constant">false</span>
    }
}

task testReport(<span class="key">type</span>: TestReport) {
    destinationDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports/allTests</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Include the results from the `test` task in all subprojects</span>
    reportOn subprojects*.test
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    apply(plugin = &quot;java&quot;)

    // Disable the test report for the individual test task
    tasks.named&lt;Test&gt;(&quot;test&quot;) {
        reports.html.isEnabled = false
    }
}

tasks.register&lt;TestReport&gt;(&quot;testReport&quot;) {
    destinationDir = file(&quot;$buildDir/reports/allTests&quot;)
    // Include the results from the `test` task in all subprojects
    reportOn(subprojects.map { it.tasks[&quot;test&quot;] })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您应该注意<code>TestReport</code>类型合并了多个测试任务的结果，并且需要汇总各个测试类的结果。这意味着，如果给定的测试类由多个测试任务执行，则测试报告将包含该类的执行，但是很难区分该类的各个执行及其输出。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:test_detection"><a class="anchor" href="#sec:test_detection"></a> <a class="link" href="#sec:test_detection">测试检测</a></h4>
<div class="paragraph">
<p>默认情况下，Gradle将运行它检测到的所有测试，这是通过检查编译的测试类来完成的。根据所使用的测试框架，此检测使用不同的标准。</p>
</div>
<div class="paragraph">
<p>对于<em>JUnit</em> ，Gradle会扫描JUnit 3和4测试类。如果某个类符合以下条件，则将其视为JUnit测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>最终继承自<code>TestCase</code>要么<code>GroovyTestCase</code></p>
</li>
<li>
<p>带有注释<code>@RunWith</code></p>
</li>
<li>
<p>包含带有注释的方法<code>@Test</code>或超一流</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于<em>TestNG</em> ，Gradle扫描使用注释的方法<code>@Test</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，不执行抽象类。另外，请注意Gradle会将继承树扫描到测试类路径上的jar文件中。因此，如果这些JAR包含测试类，它们也将运行。</p>
</div>
<div class="paragraph">
<p>如果您不想使用测试类别检测，可以通过设置<code>scanForTestClasses</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试的</a>属性<code>false</code> 。当您这样做时，测试任务仅使用<code>includes</code>和<code>excludes</code>查找测试类的属性。</p>
</div>
<div class="paragraph">
<p>如果<code>scanForTestClasses</code>为false并且未指定包含或排除模式，Gradle默认运行任何与模式匹配的类<code>**/*Tests.class</code>和<code>**/*Test.class</code> ，不包括那些匹配的<code>**/Abstract*.class</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>仅使用<a href="http://junit.org/junit5/docs/current/user-guide">JUnit Platform</a> <code>includes</code>和<code>excludes</code>用于过滤测试类- <code>scanForTestClasses</code>没有效果。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="test_grouping"><a class="anchor" href="#test_grouping"></a> <a class="link" href="#test_grouping">测试分组</a></h4>
<div class="paragraph">
<p>JUnit，JUnit Platform和TestNG允许对测试方法进行复杂的分组。</p>
</div>
<div class="paragraph">
<p>JUnit 4.8引入了将JUnit 4测试类和方法分组的类别的概念。 <sup class="footnote">[ <a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="查看脚注。">11</a> ]</sup> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:useJUnit(org.gradle.api.Action)">Test.useJUnit（org.gradle.api。动作）</a>可让您指定要包括和排除的JUnit类别。例如，以下配置包括测试<code>CategoryA</code>并排除那些<code>CategoryB</code>为了<code>test</code>任务：</p>
</div>
<div class="exampleblock">
<div class="title">示例429。JUnit类别</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    useJUnit {
        includeCategories <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.junit.CategoryA</span><span class="delimiter">'</span></span>
        excludeCategories <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.junit.CategoryB</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    useJUnit {
        includeCategories(&quot;org.gradle.junit.CategoryA&quot;)
        excludeCategories(&quot;org.gradle.junit.CategoryB&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="http://junit.org/junit5/docs/current/user-guide">JUnit Platform</a>引入了<a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering">标记</a>来替换类别。您可以通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/Test.html#useJUnitPlatform-org.gradle.api.Action-">Test.useJUnitPlatform（org.gradle.api。指定包含/排除的标签</a><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/Test.html#useJUnitPlatform-org.gradle.api.Action-">。操作）</a> ，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例430JUnit平台标签</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    useJUnitPlatform {
        includeTags <span class="string"><span class="delimiter">'</span><span class="content">fast</span><span class="delimiter">'</span></span>
        excludeTags <span class="string"><span class="delimiter">'</span><span class="content">slow</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    useJUnitPlatform {
        includeTags(&quot;fast&quot;)
        excludeTags(&quot;slow&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>TestNG框架使用测试组的概念来达到类似的效果。 <sup class="footnote">[ <a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="查看脚注。">12</a> ]</sup> 您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:useTestNG(org.gradle.api.Action)">Test.useTestNG（org.gradle.api。）配置在测试执行期间要包括或排除的测试组</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:useTestNG(org.gradle.api.Action)">。操作）</a>设置，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例431将TestNG测试分组</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    useTestNG {
        excludeGroups <span class="string"><span class="delimiter">'</span><span class="content">integrationTests</span><span class="delimiter">'</span></span>
        includeGroups <span class="string"><span class="delimiter">'</span><span class="content">unitTests</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;Test&gt;(&quot;test&quot;) {
    useTestNG {
        val options = this as TestNGOptions
        options.excludeGroups(&quot;integrationTests&quot;)
        options.includeGroups(&quot;unitTests&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using_junit5"><a class="anchor" href="#using_junit5"></a> <a class="link" href="#using_junit5">使用JUnit 5</a></h4>
<div class="paragraph">
<p><a href="http://junit.org/junit5">JUnit 5</a>是著名的JUnit测试框架的最新版本。与之前的版本不同，JUnit 5是模块化的，并且由几个模块组成：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</pre>
</div>
</div>
<div class="paragraph">
<p>JUnit平台是在JVM上启动测试框架的基础。 JUnit Jupiter是新<a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests">编程模型</a>和<a href="http://junit.org/junit5/docs/current/user-guide/#extensions">扩展模型</a>的组合，用于在JUnit 5中编写测试和扩展。JUnit Vintage提供了一个<code>TestEngine</code>用于在平台上运行基于JUnit 3和JUnit 4的测试。</p>
</div>
<div class="paragraph">
<p>以下代码在以下方面启用了JUnit Platform支持： <code>build.gradle</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例432启用JUnit Platform来运行测试</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    useJUnitPlatform()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;Test&gt;(&quot;test&quot;) {
    useJUnitPlatform()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/Test.html#useJUnitPlatform--">Test.useJUnitPlatform（）</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>将JUnit 5与Gradle结合使用存在一些已知的局限性，例如，不会发现静态嵌套类中的测试，并且类仍按其类名而不是其名称显示<code>@DisplayName</code> 。这些将在Gradle的未来版本中修复。如果您发现更多信息，请在<a href="https://github.com/gradle/gradle/issues/new" class="bare">https://github.com/gradle/gradle/issues/new</a>告诉我们</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="compiling_and_executing_junit_jupiter_tests"><a class="anchor" href="#compiling_and_executing_junit_jupiter_tests"></a> <a class="link" href="#compiling_and_executing_junit_jupiter_tests">编译和执行JUnit Jupiter测试</a></h5>
<div class="paragraph">
<p>要在Gradle中启用JUnit Jupiter支持，您需要做的就是添加以下依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">示例433JUnit Jupiter依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.junit.jupiter:junit-jupiter-api:5.1.0</span><span class="delimiter">'</span></span>
    testRuntimeOnly <span class="string"><span class="delimiter">'</span><span class="content">org.junit.jupiter:junit-jupiter-engine:5.1.0</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;org.junit.jupiter:junit-jupiter-api:5.1.0&quot;)
    testRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine:5.1.0&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以正常地将测试用例放入<em>src / test / java</em>并使用<code>gradle test</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="executing_legacy_tests_with_junit_vintage"><a class="anchor" href="#executing_legacy_tests_with_junit_vintage"></a> <a class="link" href="#executing_legacy_tests_with_junit_vintage">使用JUnit Vintage执行旧式测试</a></h5>
<div class="paragraph">
<p>如果要在JUnit Platform上运行JUnit 3/4测试，或者甚至将它们与Jupiter测试混合使用，则应添加额外的JUnit Vintage Engine依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">示例434JUnit Vintage依赖项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.junit.jupiter:junit-jupiter-api:5.1.0</span><span class="delimiter">'</span></span>
    testRuntimeOnly <span class="string"><span class="delimiter">'</span><span class="content">org.junit.jupiter:junit-jupiter-engine:5.1.0</span><span class="delimiter">'</span></span>
    testCompileOnly <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
    testRuntimeOnly <span class="string"><span class="delimiter">'</span><span class="content">org.junit.vintage:junit-vintage-engine:5.1.0</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;org.junit.jupiter:junit-jupiter-api:5.1.0&quot;)
    testRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine:5.1.0&quot;)
    testCompileOnly(&quot;junit:junit:4.12&quot;)
    testRuntimeOnly(&quot;org.junit.vintage:junit-vintage-engine:5.1.0&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，您可以使用<code>gradle test</code>在JUnit平台上测试JUnit 3/4测试，而无需重写它们。</p>
</div>
<div class="paragraph">
<p>可以在以下位置找到混合测试的样本<code>samples/testing/junitplatform/mix</code>在Gradle的“ -all”分布中。</p>
</div>
</div>
<div class="sect4">
<h5 id="filtering_test_engine"><a class="anchor" href="#filtering_test_engine"></a> <a class="link" href="#filtering_test_engine">过滤测试引擎</a></h5>
<div class="paragraph">
<p>JUnit Platform允许您使用不同的测试引擎。JUnit当前提供两个<code>TestEngine</code>开箱即用的实现： <a href="https://junit.org/junit5/docs/current/api/org/junit/jupiter/engine/package-summary.html">junit-jupiter-engine</a>和<a href="https://junit.org/junit5/docs/current/api/org/junit/vintage/engine/package-summary.html">junit-vintage-engine</a> 。您也可以自己编写和插入<code>TestEngine</code> <a href="https://junit.org/junit5/docs/current/user-guide/#launcher-api-engines-custom">此处</a>记录的实现。</p>
</div>
<div class="paragraph">
<p>默认情况下，将使用测试运行时类路径上的所有测试引擎。要显式控制特定的测试引擎实现，可以将以下设置添加到构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">示例435过滤特定引擎</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    useJUnitPlatform {
        includeEngines <span class="string"><span class="delimiter">'</span><span class="content">junit-vintage</span><span class="delimiter">'</span></span>
        <span class="comment">// excludeEngines 'junit-jupiter'</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    useJUnitPlatform {
        includeEngines(&quot;junit-vintage&quot;)
        // excludeEngines(&quot;junit-jupiter&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以在以下位置找到测试引擎过滤样本<code>samples/testing/junitplatform/engine</code>在Gradle的“ -all”分布中。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test_execution_order"><a class="anchor" href="#test_execution_order"></a> <a class="link" href="#test_execution_order">TestNG中的测试执行顺序</a></h4>
<div class="paragraph">
<p>当您使用<em>testng.xml</em>文件时，TestNG允许显式控制测试的执行顺序。没有这样的文件（或由<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html#getSuiteXmlBuilder--">TestNGOptions.getSuiteXmlBuilder（）</a>配置的等效文件<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html#getSuiteXmlBuilder--">）</a> ，您将无法指定测试执行顺序。但是，您<em>可以</em>做的是控制测试的各个方面，包括相关的<code>@BeforeXXX</code>和<code>@AfterXXX</code>方法，例如带有注释的方法<code>@Before/AfterClass</code>和<code>@Before/AfterMethod</code> —在下一个测试开始之前执行。您可以通过将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/testing/testng/TestNGOptions.html#getPreserveOrder--">TestNGOptions.getPreserveOrder（）</a>属性设置为<code>true</code> 。如果设置为<code>false</code> ，您可能会遇到执行顺序类似于以下情形： <code>TestA.doBeforeClass()</code> → <code>TestB.doBeforeClass()</code> → <code>TestA</code>测试。</p>
</div>
<div class="paragraph">
<p>直接使用<em>testng.xml</em>文件时，保留测试顺序是默认行为，而Gradle的TestNG集成所使用的<a href="https://jitpack.io/com/github/cbeust/testng/master/javadoc/org/testng/TestNG.html">TestNG API</a>默认情况下以无法预测的顺序执行测试。 <sup class="footnote">[ <a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="查看脚注。">13</a> ]</sup> TestNG版本5.14.5引入了保留测试执行顺序的功能。设置<code>preserveOrder</code>财产<code>true</code>对于较旧的TestNG版本，将导致构建失败。</p>
</div>
<div class="exampleblock">
<div class="title">示例436保留TestNG测试的顺序</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    useTestNG {
        preserveOrder <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    useTestNG {
        preserveOrder = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>groupByInstance</code>属性控制是否应按实例而不是按类别对测试进行分组。<a href="http://testng.org/doc/documentation-main.html#dependencies-with-annotations">TestNG文档</a>更详细地解释了差异，但是实质上，如果您有测试方法， <code>A()</code>这取决于<code>B()</code> ，按实例分组可确保每个AB配对，例如<code>B(1)</code> -- <code>A(1)</code>在下一个配对之前执行。和班级一起，全部<code>B()</code>方法运行，然后所有<code>A()</code>那些。</p>
</div>
<div class="paragraph">
<p>请注意，如果您使用数据提供程序对其进行参数化，则通常只有一个以上的测试实例。此外，TestNG版本6.1引入了按实例对测试进行分组的功能。设置<code>groupByInstances</code>财产<code>true</code>对于较旧的TestNG版本，将导致构建失败。</p>
</div>
<div class="exampleblock">
<div class="title">示例437按实例对TestNG测试进行分组</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    useTestNG {
        groupByInstances = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    useTestNG {
        groupByInstances = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testNgParameterizedReporting"><a class="anchor" href="#testNgParameterizedReporting"></a> <a class="link" href="#testNgParameterizedReporting">TestNG参数化方法和报告</a></h5>
<div class="paragraph">
<p>TestNG支持<a href="http://testng.org/doc/documentation-main.html#parameters">参数化测试方法</a> ，允许使用不同的输入多次执行特定的测试方法。Gradle在报告测试方法执行情况时将参数值包括在内。</p>
</div>
<div class="paragraph">
<p>给定一个名为的参数化测试方法<code>aTestMethod</code>它带有两个参数，它将以名称报告<code>aTestMethod(toStringValueOfParam1, toStringValueOfParam2)</code> 。这样可以轻松识别特定迭代的参数值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_java_integration_tests"><a class="anchor" href="#sec:configuring_java_integration_tests"></a> <a class="link" href="#sec:configuring_java_integration_tests">配置集成测试</a></h4>
<div class="paragraph">
<p>项目的常见要求是以一种或另一种形式合并集成测试。他们的目的是验证项目的各个部分是否正常工作。与单元测试相比，这通常意味着它们需要特殊的执行设置和依赖性。</p>
</div>
<div class="paragraph">
<p>将集成测试添加到构建中的最简单方法是采取以下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>为他们创建一个新的<a href="#sec:java_source_sets">源集</a></p>
</li>
<li>
<p>将所需的依赖项添加到该源集的适当配置中</p>
</li>
<li>
<p>为该源集配置编译和运行时类路径</p>
</li>
<li>
<p>创建任务以运行集成测试</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您可能还需要执行一些其他配置，具体取决于集成测试采用的形式。我们将讨论这些内容。</p>
</div>
<div class="paragraph">
<p>让我们从一个实际示例开始，该示例以新的源集为中心在构建脚本中实现前三个步骤。 <code>intTest</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例438设置工作集成测试</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    intTest {
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

configurations {
    intTestImplementation.extendsFrom implementation
    intTestRuntimeOnly.extendsFrom runtimeOnly
}

dependencies {
    intTestImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    create(&quot;intTest&quot;) {
        compileClasspath += sourceSets.main.get().output
        runtimeClasspath += sourceSets.main.get().output
    }
}

val intTestImplementation by configurations.getting {
    extendsFrom(configurations.implementation.get())
}

configurations[&quot;intTestRuntimeOnly&quot;].extendsFrom(configurations.runtimeOnly.get())

dependencies {
    intTestImplementation(&quot;junit:junit:4.12&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将设置一个名为<code>intTest</code>自动创建：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>intTestImplementation</code> ， <code>intTestCompileOnly</code> ， <code>intTestRuntimeOnly</code>配置（以及<a href="#java_source_set_configurations">其他</a>一些较不常用的配置）</p>
</li>
<li>
<p>一种<code>compileIntTestJava</code>任务将编译<em>src / intTest / java</em>下的所有源文件</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该示例还执行以下操作，并非特定集成测试可能需要所有这些操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从中添加生产类<code>main</code>源设置为集成测试的编译和运行时类路径- <code>sourceSets.main.output</code>是包含编译的生产类和资源的所有目录的<a href="#sec:file_collections">文件集合</a></p>
</li>
<li>
<p>使<code>intTestImplementation</code>配置从<code>implementation</code> ，这意味着所有声明的生产代码依赖项也将成为集成测试的依赖项</p>
</li>
<li>
<p>相同的<code>intTestRuntimeOnly</code>组态</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在大多数情况下，您希望集成测试可以访问被测类，这就是为什么我们确保在此示例中将它们包括在编译和运行时类路径中的原因。但是某些类型的测试以不同的方式与生产代码交互。例如，您可能具有将应用程序作为可执行文件运行并测试输出的测试。对于Web应用程序，测试可能会通过HTTP与您的应用程序进行交互。由于在这种情况下测试不需要直接访问被测类，因此您无需将生产类添加到测试类路径中。</p>
</div>
<div class="paragraph">
<p>另一个常见步骤是将所有单元测试依赖项也附加到集成测试中-通过<code>intTestImplementation.extendsFrom testImplementation</code> —但是只有在集成测试需要单元测试所具有的<em>全部</em>或几乎所有相同依赖项时，这才有意义。</p>
</div>
<div class="paragraph">
<p>您还应注意该示例的其他两个方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>+=</code>允许您将路径和路径集合附加到<code>compileClasspath</code>和<code>runtimeClasspath</code>而不是覆盖它们</p>
</li>
<li>
<p>如果要使用基于约定的配置，例如<code>intTestImplementation</code> ，您<em>必须</em>在新的源集<em>之后</em>声明依赖项</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>创建和配置源集会自动设置编译阶段，但是对于运行集成测试没有任何作用。因此，最后一个难题是自定义测试任务，该任务使用来自新源集的信息来配置其运行时类路径和测试类：</p>
</div>
<div class="exampleblock">
<div class="title">示例439定义一个有效的集成测试任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task integrationTest(<span class="key">type</span>: Test) {
    description = <span class="string"><span class="delimiter">'</span><span class="content">Runs integration tests.</span><span class="delimiter">'</span></span>
    group = <span class="string"><span class="delimiter">'</span><span class="content">verification</span><span class="delimiter">'</span></span>

    testClassesDirs = sourceSets.intTest.output.classesDirs
    classpath = sourceSets.intTest.runtimeClasspath
    shouldRunAfter test
}

check.dependsOn integrationTest</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val integrationTest = task&lt;Test&gt;(&quot;integrationTest&quot;) {
    description = &quot;Runs integration tests.&quot;
    group = &quot;verification&quot;

    testClassesDirs = sourceSets[&quot;intTest&quot;].output.classesDirs
    classpath = sourceSets[&quot;intTest&quot;].runtimeClasspath
    shouldRunAfter(&quot;test&quot;)
}

tasks.check { dependsOn(integrationTest) }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，我们正在访问源集以获取相关信息，即编译后的测试类在哪里- <code>testClassesDirs</code>属性-运行它们时需要在类路径上- <code>classpath</code> 。</p>
</div>
<div class="paragraph">
<p>用户通常希望在单元测试之后运行集成测试，因为它们通常运行速度较慢，并且您希望构建在单元测试之前失败而不是在集成测试之后失败。这就是为什么上面的示例添加了一个<code>shouldRunAfter()</code>宣言。这是优先于<code>mustRunAfter()</code>因此Gradle在并行执行构建时具有更大的灵活性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:skipping_java_tests"><a class="anchor" href="#sec:skipping_java_tests"></a> <a class="link" href="#sec:skipping_java_tests">跳过测试</a></h4>
<div class="paragraph">
<p>如果要在运行构建时跳过测试，则有几种选择。您可以通过<a href="#sec:excluding_tasks_from_the_command_line">命令行参数</a>或<a href="#sec:skipping_tasks">在构建脚本中进行操作</a> 。要在命令行上执行此操作，可以使用<code>-x</code>要么<code>--exclude-task</code>像这样的选项：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gradle build -x test</pre>
</div>
</div>
<div class="paragraph">
<p>这不包括<code>test</code>任务及其<em>唯一</em>依赖的任何其他任务，即没有其他任务依赖于同一任务。这些任务不会被Gradle标记为“跳过”，而只会出现在已执行任务的列表中。</p>
</div>
<div class="paragraph">
<p>通过构建脚本跳过测试可以通过几种方法完成。一种常见的方法是通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf(org.gradle.api.specs.Spec)">Task.onlyIf（org.gradle.api.specs。Spec）</a>方法。以下示例跳过了<code>test</code>如果项目具有名为以下属性的任务<code>mySkipTests</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例440根据项目属性跳过单元测试</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test.onlyIf { !project.hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">mySkipTests</span><span class="delimiter">'</span></span>) }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test { onlyIf { !project.hasProperty(&quot;mySkipTests&quot;) } }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，Gradle会将跳过的测试标记为“跳过”，而不是将其从构建中排除。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:forcing_java_tests_to_run"><a class="anchor" href="#sec:forcing_java_tests_to_run"></a> <a class="link" href="#sec:forcing_java_tests_to_run">强制测试运行</a></h4>
<div class="paragraph">
<p>在定义良好的版本中，您可以依靠Gradle仅在测试本身或生产代码发生更改时运行测试。但是，您可能会遇到测试依赖第三方服务或可能会更改但无法在构建中建模的其他情况。</p>
</div>
<div class="paragraph">
<p>您可以通过清除相关的输出来强制测试在这种情况下运行<code>Test</code>任务-说<code>test</code> —然后再次运行测试，如下所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gradle cleanTest test</pre>
</div>
</div>
<div class="paragraph">
<p><code>cleanTest</code>基于<a href="#sec:base_tasks">基础插件</a>提供的<a href="#sec:task_rules">任务规则</a> 。您可以将其用于<em>任何</em>任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:debugging_java_tests"><a class="anchor" href="#sec:debugging_java_tests"></a> <a class="link" href="#sec:debugging_java_tests">运行测试时进行调试</a></h4>
<div class="paragraph">
<p>在少数情况下，您想在测试运行时调试代码，如果可以在此时附加调试器，则可能会有所帮助。您可以将<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:debug">Test.getDebug（）</a>属性设置为<code>true</code>或使用<code>--debug-jvm</code>命令行选项。</p>
</div>
<div class="paragraph">
<p>启用测试调试后，Gradle将暂停测试过程并监听端口5005。</p>
</div>
<div class="paragraph">
<p>您还可以在DSL中启用调试，还可以在其中配置其他属性：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>test {
    debugOptions {
        enabled = true
        port = 4455
        server = true
        suspend = true
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>通过这种配置，测试JVM的行为就像通过<code>--debug-jvm</code>参数，但它将侦听端口4455。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_test_fixtures"><a class="anchor" href="#sec:java_test_fixtures"></a> <a class="link" href="#sec:java_test_fixtures">使用测试治具</a></h4>
<div class="sect4">
<h5 id="producing_and_using_test_fixtures_within_a_single_project"><a class="anchor" href="#producing_and_using_test_fixtures_within_a_single_project"></a> <a class="link" href="#producing_and_using_test_fixtures_within_a_single_project">在单个项目中生产和使用测试夹具</a></h5>
<div class="paragraph">
<p>测试装置通常用于设置被测代码，或提供旨在促进组件测试的实用程序。Java项目可以通过应用<code>java-test-fixtures</code>插件，除了<code>java</code>要么<code>java-library</code>插件：</p>
</div>
<div class="exampleblock">
<div class="title">示例441应用Java测试装置插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">lib / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    <span class="comment">// A Java Library</span>
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
    <span class="comment">// which produces test fixtures</span>
    id <span class="string"><span class="delimiter">'</span><span class="content">java-test-fixtures</span><span class="delimiter">'</span></span>
    <span class="comment">// and is published</span>
    id <span class="string"><span class="delimiter">'</span><span class="content">maven-publish</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">lib / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    // A Java Library
    `java-library`
    // which produces test fixtures
    `java-test-fixtures`
    // and is published
    `maven-publish`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将自动创建一个<code>testFixtures</code>源代码集，您可以在其中编写测试装置。测试夹具的配置如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>他们可以看到<em>主要的</em>源集类</p>
</li>
<li>
<p><em>测试</em>源可以看到<em>测试夹具</em>类</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如对于这个主类：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / acme / Person.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> firstName;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> lastName;

    <span class="directive">public</span> Person(<span class="predefined-type">String</span> firstName, <span class="predefined-type">String</span> lastName) {
        <span class="local-variable">this</span>.firstName = firstName;
        <span class="local-variable">this</span>.lastName = lastName;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getFirstName() {
        <span class="keyword">return</span> firstName;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getLastName() {
        <span class="keyword">return</span> lastName;
    }

    <span class="comment">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>测试夹具可以写成<code>src/testFixtures/java</code> ：</p>
</div>
<div class="listingblock">
<div class="title">src / testFixtures / java / com / acme / Simpsons.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Simpsons</span> {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Person HOMER = <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Homer</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Simpson</span><span class="delimiter">&quot;</span></span>);
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Person MARGE = <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Majorie</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Simpson</span><span class="delimiter">&quot;</span></span>);
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Person BART = <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Bartholomew</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Simpson</span><span class="delimiter">&quot;</span></span>);
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Person LISA = <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Elisabeth Marie</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Simpson</span><span class="delimiter">&quot;</span></span>);
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Person MAGGIE = <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Margaret Eve</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Simpson</span><span class="delimiter">&quot;</span></span>);
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;Person&gt; FAMILY = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;Person&gt;() {{
        add(HOMER);
        add(MARGE);
        add(BART);
        add(LISA);
        add(MAGGIE);
    }};

    <span class="directive">public</span> <span class="directive">static</span> Person homer() { <span class="keyword">return</span> HOMER; }

    <span class="directive">public</span> <span class="directive">static</span> Person marge() { <span class="keyword">return</span> MARGE; }

    <span class="directive">public</span> <span class="directive">static</span> Person bart() { <span class="keyword">return</span> BART; }

    <span class="directive">public</span> <span class="directive">static</span> Person lisa() { <span class="keyword">return</span> LISA; }

    <span class="directive">public</span> <span class="directive">static</span> Person maggie() { <span class="keyword">return</span> MAGGIE; }

    <span class="comment">// ...</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="declaring_dependencies_of_test_fixtures"><a class="anchor" href="#declaring_dependencies_of_test_fixtures"></a> <a class="link" href="#declaring_dependencies_of_test_fixtures">声明测试夹具的依赖性</a></h5>
<div class="paragraph">
<p>与<a href="java_library_plugin.html">Java库插件</a>类似，测试装置公开了API和实现配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例442声明测试夹具依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">lib / build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>

    <span class="comment">// API dependencies are visible to consumers when building</span>
    testFixturesApi <span class="string"><span class="delimiter">'</span><span class="content">org.apache.commons:commons-lang3:3.9</span><span class="delimiter">'</span></span>

    <span class="comment">// Implementation dependencies are not leaked to consumers when building</span>
    testFixturesImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.commons:commons-text:1.6</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">lib / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;junit:junit:4.12&quot;)

    // API dependencies are visible to consumers when building
    testFixturesApi(&quot;org.apache.commons:commons-lang3:3.9&quot;)

    // Implementation dependencies are not leaked to consumers when building
    testFixturesImplementation(&quot;org.apache.commons:commons-text:1.6&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，如果依赖性是测试夹具的<em>实现</em>依赖性，那么<em>在编译依赖于那些测试夹具</em>的<em>测试时</em> ，实现依赖性将<em>不会泄漏</em>到编译类路径中。这样可以改善关注点分离并更好地避免编译。</p>
</div>
</div>
<div class="sect4">
<h5 id="consuming_test_fixtures_of_another_project"><a class="anchor" href="#consuming_test_fixtures_of_another_project"></a> <a class="link" href="#consuming_test_fixtures_of_another_project">消耗另一个项目的测试装置</a></h5>
<div class="paragraph">
<p>测试装置不限于单个项目。通常，从属项目测试也需要依赖项的测试装置。使用以下命令可以很容易地实现<code>testFixtures</code>关键词：</p>
</div>
<div class="exampleblock">
<div class="title">示例443添加对另一个项目的测试装置的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:lib</span><span class="delimiter">&quot;</span></span>))

    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
    testImplementation(testFixtures(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:lib</span><span class="delimiter">&quot;</span></span>)))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(project(&quot;:lib&quot;))

    testImplementation(&quot;junit:junit:4.12&quot;)
    testImplementation(testFixtures(project(&quot;:lib&quot;)))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="publishing_test_fixtures"><a class="anchor" href="#publishing_test_fixtures"></a> <a class="link" href="#publishing_test_fixtures">发布测试装置</a></h5>
<div class="paragraph">
<p>使用...的优势之一<code>java-test-fixtures</code>插件是发布测试装置。按照惯例，测试装置将与具有以下特征的工件一起发布： <code>test-fixtures</code>分类器。对于Maven和Ivy，带有该分类器的工件都与常规工件一起简单发布。但是，如果您使用<code>maven-publish</code>要么<code>ivy-publish</code>插件，测试夹具作为<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-1.0-specification.md">Gradle Module元数据中的</a>其他变体发布，您可以直接依赖另一个Gradle项目中外部库的测试夹具：</p>
</div>
<div class="exampleblock">
<div class="title">示例444添加对外部库测试装置的依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// Adds a dependency on the test fixtures of Gson, however this</span>
    <span class="comment">// project doesn't publish such a thing</span>
    functionalTest testFixtures(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.google.code.gson:gson:2.8.5</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // Adds a dependency on the test fixtures of Gson, however this
    // project doesn't publish such a thing
    functionalTest(testFixtures(&quot;com.google.code.gson:gson:2.8.5&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，如果外部项目<em>未</em>发布Gradle Module元数据，则解析将失败，并显示一条错误消息，指出找不到这样的变体：</p>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle dependencyInsight --configuration functionalTestClasspath --dependency gson</code></strong></div>
<div class="content">
<pre>&gt; gradle dependencyInsight --configuration functionalTestClasspath --dependency gson

&gt; Task :dependencyInsight
com.google.code.gson:gson:2.8.5 FAILED
   Failures:
      - Could not resolve com.google.code.gson:gson:2.8.5.
          - Unable to find a variant of com.google.code.gson:gson:2.8.5 providing the requested capability com.google.code.gson:gson-test-fixtures:
               - Variant compile provides com.google.code.gson:gson:2.8.5
               - Variant runtime provides com.google.code.gson:gson:2.8.5
               - Variant platform-compile provides com.google.code.gson:gson-derived-platform:2.8.5
               - Variant platform-runtime provides com.google.code.gson:gson-derived-platform:2.8.5
               - Variant enforced-platform-compile provides com.google.code.gson:gson-derived-enforced-platform:2.8.5
               - Variant enforced-platform-runtime provides com.google.code.gson:gson-derived-enforced-platform:2.8.5

com.google.code.gson:gson:2.8.5 FAILED
\--- functionalTestClasspath

A web-based, searchable dependency report is available by adding the --scan option.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>错误消息中提到缺少<code>com.google.code.gson:gson-test-fixtures</code>功能，实际上并未为此库定义。这是因为按照惯例，对于使用<code>java-test-fixtures</code>插件，Gradle会自动创建具有其名称为主要组件名称的功能的测试夹具变体，并带有附录<code>-test-fixtures</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果您发布库并使用测试夹具，但是不想发布夹具，则可以停用<em>测试夹具变体的</em>发布，如下所示。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例445禁用测试夹具变体的发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">components.java.withVariantsFromConfiguration(configurations.testFixturesApiElements) { skip() }
components.java.withVariantsFromConfiguration(configurations.testFixturesRuntimeElements) { skip() }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val javaComponent = components[&quot;java&quot;] as AdhocComponentWithVariants
javaComponent.withVariantsFromConfiguration(configurations[&quot;testFixturesApiElements&quot;]) { skip() }
javaComponent.withVariantsFromConfiguration(configurations[&quot;testFixturesRuntimeElements&quot;]) { skip() }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dependency_management_for_java_projects"><a class="anchor" href="#dependency_management_for_java_projects"></a> <a class="link" href="#dependency_management_for_java_projects">管理JVM项目的依赖关系</a></h3>
<div class="paragraph">
<p>本章说明如何将基本的依赖管理概念应用于基于JVM的项目。有关依赖管理的详细介绍，请参见<a href="#">Gradle中的依赖管理</a> 。</p>
</div>
<div class="sect3">
<h4 id="sec:setting_up_a_standard_build_script_java_tutorial"><a class="anchor" href="#sec:setting_up_a_standard_build_script_java_tutorial"></a> <a class="link" href="#sec:setting_up_a_standard_build_script_java_tutorial">剖析典型的构建脚本</a></h4>
<div class="paragraph">
<p>让我们看一下基于JVM的项目的非常简单的构建脚本。它应用了<a href="#java_library_plugin">Java库插件</a> ，该<a href="#java_library_plugin">插件</a>会自动引入标准项目布局，提供执行典型工作的任务以及对依赖项管理的充分支持。</p>
</div>
<div class="exampleblock">
<div class="title">示例446基于JVM的项目的依赖项声明</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}

repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.hibernate:hibernate-core:3.6.7.Final</span><span class="delimiter">'</span></span>
    api <span class="string"><span class="delimiter">'</span><span class="content">com.google.guava:guava:23.0</span><span class="delimiter">'</span></span>
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.+</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}

repositories {
    mavenCentral()
}

dependencies {
    implementation(&quot;org.hibernate:hibernate-core:3.6.7.Final&quot;)
    api(&quot;com.google.guava:guava:23.0&quot;)
    testImplementation(&quot;junit:junit:4.+&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure)">Project.dependencies {}</a>代码块声明了Hibernate core 3.6.7。需要Final来编译项目的生产源代码。它还指出，要编译项目的测试，需要junit> = 4.0。所有依赖项都应该在<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)">Project.repositories {}</a>定义的Maven Central存储库中查找。以下各节将更详细地说明每个方面。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:module_dependencies_java_tutorial"><a class="anchor" href="#sec:module_dependencies_java_tutorial"></a> <a class="link" href="#sec:module_dependencies_java_tutorial">声明模块依赖性</a></h4>
<div class="paragraph">
<p>您可以声明<a href="#sec:dependency-types">各种类型的依赖项</a> 。一种这样的类型是<em>模块依赖性</em> 。<a href="#sub:module_dependencies">模块依赖关系</a>表示对具有当前版本之外构建的特定版本的模块的依赖关系。模块通常存储在存储库中，例如Maven Central，公司Maven或Ivy存储库或本地文件系统中的目录。</p>
</div>
<div class="paragraph">
<p>要定义模块依赖项，请将其添加到<a href="#sec:configurations_java_tutorial">依赖项配置中</a> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例447模块依赖关系的定义</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.hibernate:hibernate-core:3.6.7.Final</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;org.hibernate:hibernate-core:3.6.7.Final&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要了解有关定义依赖项的更多信息，请<a href="#">参阅声明依赖项</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:configurations_java_tutorial"><a class="anchor" href="#sec:configurations_java_tutorial"></a> <a class="link" href="#sec:configurations_java_tutorial">使用依赖项配置</a></h4>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.Configuration.html">配置</a>是一组命名的依赖关系和工件。有一个<em>配置的</em>三个主要目的：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">声明依赖</dt>
<dd>
<p>插件使用配置使构建作者可以轻松声明在执行插件定义的任务期间出于各种目的还需要其他哪些子项目或外部工件。例如，一个插件可能需要Spring Web框架依赖项来编译源代码。</p>
</dd>
<dt class="hdlist1">解决依赖性</dt>
<dd>
<p>插件使用配置来查找（可能下载）其定义的任务的输入。例如，Gradle需要从Maven Central下载Spring Web框架JAR文件。</p>
</dd>
<dt class="hdlist1">暴露文物以供消费</dt>
<dd>
<p>插件使用配置来定义它生成供其他项目使用的<em>工件</em> 。例如，该项目希望将其打包在JAR文件中的已编译源代码发布到内部Artifactory存储库中。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>考虑到这三个目的，让我们看一下<a href="#sec:java_library_configurations_graph">Java库插件定义</a>的一些<a href="#sec:java_library_configurations_graph">标准配置</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">实作</dt>
<dd>
<p>编译项目生产源所需的依赖项，这些依赖项<em>不是</em>项目公开的API的一部分。例如，该项目将Hibernate用于其内部持久层实现。</p>
</dd>
<dt class="hdlist1">api</dt>
<dd>
<p>所需要的依赖关系来编译该项目其<em>是</em>由所述项目露出的API的一部分的产生源。例如，该项目使用Guava，并在其方法签名中公开带有Guava类的公共接口。</p>
</dd>
<dt class="hdlist1">测试实施</dt>
<dd>
<p>编译和运行项目的测试源所需的依赖项。例如，项目决定使用测试框架JUnit编写测试代码。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>各种插件添加了进一步的标准配置。您还可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure)">Project.configurations {}</a>在构建中定义自己的自定义配置。有关定义和自定义依赖项配置的详细信息，请参阅<a href="#sec:what-are-dependency-configurations">什么是</a>依赖项配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:repositories_java_tutorial"><a class="anchor" href="#sec:repositories_java_tutorial"></a> <a class="link" href="#sec:repositories_java_tutorial">声明通用Java存储库</a></h4>
<div class="paragraph">
<p>Gradle如何知道在哪里可以找到外部依赖文件？Gradle在<em>存储库中</em>查找它们。存储库是模块的集合，由<code>group</code> ， <code>name</code>和<code>version</code> 。Gradle了解不同的<a href="#sec:repository-types">存储库类型</a> ，例如Maven和Ivy，并支持通过HTTP或其他协议访问存储库的各种方式。</p>
</div>
<div class="paragraph">
<p>默认情况下，Gradle不定义任何存储库。您需要在<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)">Project.repositories {}</a>的帮助下定义至少一个，然后才能使用模块依赖项。一种选择是使用Maven Central存储库：</p>
</div>
<div class="exampleblock">
<div class="title">示例448Maven中央存储库的用法</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以在本地文件系统上拥有存储库。这适用于Maven和Ivy存储库。</p>
</div>
<div class="exampleblock">
<div class="title">示例449。本地Ivy目录的用法</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    ivy {
        <span class="comment">// URL can refer to a local directory</span>
        url <span class="string"><span class="delimiter">&quot;</span><span class="content">../local-repo</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    ivy {
        // URL can refer to a local directory
        url = uri(&quot;../local-repo&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一个项目可以有多个存储库。Gradle将按照指定的顺序在每个存储库中查找依赖项，并在包含所请求模块的第一个存储库处停止。</p>
</div>
<div class="paragraph">
<p>要了解有关定义存储库的更多信息，请<a href="#">参阅声明存储库</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:publishing_artifacts_java_tutorial"><a class="anchor" href="#sec:publishing_artifacts_java_tutorial"></a> <a class="link" href="#sec:publishing_artifacts_java_tutorial">发布工件</a></h4>
<div class="paragraph">
<p>要了解有关发布工件的更多信息，请查看<a href="#">发布插件</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="part:native_projects"><a class="anchor" href="#part:native_projects"></a> <a class="link" href="#part:native_projects">C ++和其他本机项目</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="building_cpp_projects"><a class="anchor" href="#building_cpp_projects"></a> <a class="link" href="#building_cpp_projects">构建C ++项目</a></h3>
<div class="paragraph">
<p>Gradle使用约定优于配置的方法来构建本机项目。如果您来自另一个本机构建系统，那么这些概念起初可能并不陌生，但它们的目的是简化构建脚本的编写。</p>
</div>
<div class="paragraph">
<p>我们将在本章中详细介绍C ++项目，但是大多数主题也将适用于其他受支持的本地语言。如果您没有使用Gradle构建本机项目的丰富经验，请查看C ++教程，以获取有关如何构建各种类型的基本C ++项目以及一些常见用例的分步说明。</p>
</div>
<div class="paragraph">
<p>本章<a href="https://blog.gradle.org/introducing-the-new-cpp-plugins">介绍</a>的C ++插件<a href="https://blog.gradle.org/introducing-the-new-cpp-plugins">于2018年引入</a> ，我们建议用户在您可能会参考<a href="#">的旧版Native插件</a>上使用这些插件。</p>
</div>
<div class="sect3">
<h4 id="sec:cpp_introduction"><a class="anchor" href="#sec:cpp_introduction"></a> <a class="link" href="#sec:cpp_introduction">介绍</a></h4>
<div class="paragraph">
<p>C ++项目的最简单构建脚本应用C ++应用程序插件或C ++库插件，并可以选择设置项目版本：</p>
</div>
<div class="exampleblock">
<div class="title">实施例450。应用C ++插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">cpp-application</span><span class="delimiter">'</span></span> <span class="comment">// or 'cpp-library'</span>
}

version = <span class="string"><span class="delimiter">'</span><span class="content">1.2.1</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `cpp-application` // or `cpp-library`
}

version = &quot;1.2.1&quot;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过应用这两个C ++插件，您可以获得许多功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>compileDebugCpp</code>和<code>compileReleaseCpp</code>这些任务分别编译<em>src / main / cpp</em>下的C ++源文件以获取众所周知的调试和发布构建类型。</p>
</li>
<li>
<p><code>linkDebug</code>和<code>linkRelease</code>将已编译的C ++对象文件链接到应用程序的可执行文件或共享库的库，这些库具有调试和发行版本类型的共享链接。</p>
</li>
<li>
<p><code>createDebug</code>和<code>createRelease</code>将已编译的C ++对象文件组合到静态库中的任务，这些库具有针对调试和发布构建类型的静态链接。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于任何不平凡的C ++项目，你可能有一些文件相关的和额外的配置具体到<em>项目</em>中。</p>
</div>
<div class="paragraph">
<p>C ++插件还将上述任务集成到标准<a href="#sec:base_tasks">生命周期任务中</a> 。产生开发二进制文件的任务附加到<code>assemble</code> 。默认情况下，开发二进制文件是调试变量。</p>
</div>
<div class="paragraph">
<p>本章的其余部分介绍了在构建库和应用程序时根据需要自定义构建的不同方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:introducing_build_variants-cpp"><a class="anchor" href="#sec:introducing_build_variants-cpp"></a> <a class="link" href="#sec:introducing_build_variants-cpp">引入构建变体</a></h4>
<div class="paragraph">
<p>本机项目通常可以产生几种不同的二进制文件，例如调试或发布的二进制文件，或针对特定平台和处理器体系结构的二进制文件。Gradle通过<em>维度</em>和<em>变体</em>的概念来进行管理。</p>
</div>
<div class="paragraph">
<p>维度只是一个类别，其中每个类别都与其他维度正交。例如，“构建类型”维是包括调试和发布的类别。“架构”维度涵盖了x86-64和PowerPC之类的处理器架构。</p>
</div>
<div class="paragraph">
<p>变体是这些维度的值的组合，每个维度恰好由一个值组成。您可能具有“ debug x86-64”或“ release PowerPC”变体。</p>
</div>
<div class="paragraph">
<p>Gradle内置了对多个维度和每个维度内多个值的支持。您可以在本<a href="#native_languages">机插件参考章节中</a>找到它们的列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:cpp_source_sets"><a class="anchor" href="#sec:cpp_source_sets"></a> <a class="link" href="#sec:cpp_source_sets">声明您的源文件</a></h4>
<div class="paragraph">
<p>Gradle的C ++支持使用<code>ConfigurableFileCollection</code>直接从<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.CppApplication.html">应用程序</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.CppLibrary.html">库</a>脚本块配置要编译的源集。</p>
</div>
<div class="paragraph">
<p>库区分私有（实现细节）和公共（导出到消费者）头。</p>
</div>
<div class="paragraph">
<p>对于仅在特定目标计算机上编译源的情况，您还可以为每个二进制版本配置源。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/cpp-sourcesets-compilation.png" alt="cpp资料集汇编">
</div>
<div class="title">图27。源码和C ++编译</div>
</div>
<div class="paragraph">
<p>在每个测试套件脚本块上配置测试源。请参阅<a href="#">测试C ++项目</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:cpp_dependency_management_overview"><a class="anchor" href="#sec:cpp_dependency_management_overview"></a> <a class="link" href="#sec:cpp_dependency_management_overview">管理你的依赖</a></h4>
<div class="paragraph">
<p>绝大多数项目都依赖于其他项目，因此管理项目的依存关系是构建任何项目的重要组成部分。依赖管理是一个大话题，因此我们在这里仅关注C ++项目的基础知识。如果您想深入了解这些细节，请查看<a href="#">依赖管理的简介</a> 。</p>
</div>
<div class="paragraph">
<p>Gradle提供了对使用Gradle <sup class="footnote">[ <a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="查看脚注。">14</a> ]</sup>发布的Maven存储库中的预构建二进制文件的支持。</p>
</div>
<div class="paragraph">
<p>我们将介绍如何在多构建项目中的项目之间添加依赖项。</p>
</div>
<div class="paragraph">
<p>为您的C ++项目指定依赖项需要两条信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标识依赖项的信息（项目路径，Maven GAV）</p>
</li>
<li>
<p>它需要什么，例如编译，链接，运行时或以上所有。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此信息在<code>dependencies {}</code> C ++的块<code>application</code>要么<code>library</code>脚本块。例如，告诉Gradle您的项目需要库<code>common</code>要编译和链接您的生产代码，可以使用以下片段：</p>
</div>
<div class="exampleblock">
<div class="title">示例451声明依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    dependencies {
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:common</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    dependencies {
        implementation(project(&quot;:common&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>三个元素的Gradle术语如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>配置</em> （例如： <code>implementation</code> ）-命名的依赖项集合，针对特定目标（如编译或链接模块）分组在一起</p>
</li>
<li>
<p><em>项目参考</em> （例如： <code>project(':common')</code> ）-指定路径引用的项目</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以<a href="#">在此处</a>找到更全面的依赖项管理术语表。</p>
</div>
<div class="paragraph">
<p>就配置而言，主要感兴趣的是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>implementation</code> -用于编译，链接和运行时</p>
</li>
<li>
<p><code>cppCompile<em>Variant</em></code> -对于编译生产代码所必需的依赖关系，但不应该属于链接或运行时过程的一部分</p>
</li>
<li>
<p><code>nativeLink<em>Variant</em></code> -对于链接代码所必需的依赖关系，但不应该包含在编译或运行时过程中</p>
</li>
<li>
<p><code>nativeRuntime<em>Variant</em></code> -对于运行组件所需的依赖关系，但不应作为编译或链接过程的一部分</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在本<a href="#native_languages">机插件参考章节中</a>了解有关它们的更多信息以及它们之间的关系。</p>
</div>
<div class="paragraph">
<p>请注意， <a href="cpp_library_plugin.html">C ++库插件</a>会创建其他配置- <code>api</code> -对于编译和链接模块以及依赖于该模块的任何模块所需的依赖项。</p>
</div>
<div class="paragraph">
<p>我们仅在此处进行了介绍，因此，一旦您熟悉使用Gradle构建C ++项目的基础知识，我们建议您阅读<a href="#">专用的依赖管理章节</a> 。</p>
</div>
<div class="paragraph">
<p>需要进一步阅读的一些常见方案包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义与<a href="#sec:maven_repo">Maven兼容</a>的自定义存储库</p>
</li>
<li>
<p>使用<a href="#sub:declaring_dependency_with_changing_version">变化的版本</a> （例如SNAPSHOT）和<a href="#sub:declaring_dependency_with_dynamic_version">动态的</a> （范围）声明依赖项</p>
</li>
<li>
<p>将同级<a href="#sub:project_dependencies">项目</a>声明<a href="#sub:project_dependencies">为依赖项</a></p>
</li>
<li>
<p><a href="#">控制传递依赖及其版本</a></p>
</li>
<li>
<p>通过<a href="#composite_builds">组合构建</a>测试对第三方依赖关系的修复（这是发布到<a href="#sub:maven_local">Maven Local</a>和从<a href="#sub:maven_local">Maven Local</a>消费的更好的替代方法）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您会发现Gradle具有丰富的API用于处理依赖关系-一种需要花费时间才能掌握的API，但对于常见情况却很容易使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:cpp_compile_link"><a class="anchor" href="#sec:cpp_compile_link"></a> <a class="link" href="#sec:cpp_compile_link">编译和链接代码</a></h4>
<div class="paragraph">
<p>如果遵循以下约定，则编译两个代码都非常容易：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将您的源代码放在<em>src / main / cpp</em>目录下</p>
</li>
<li>
<p>在中声明您的编译依赖项<code>implementation</code>配置（请参阅上一节）</p>
</li>
<li>
<p>跑过<code>assemble</code>任务</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们建议您尽可能遵循这些约定，但不必这样做。</p>
</div>
<div class="paragraph">
<p>有几种自定义选项，您将在下面看到。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">所有<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.tasks.CppCompile.html">CppCompile</a>任务都是增量的并且可以缓存。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="sec:cpp_supported_tool_chain"><a class="anchor" href="#sec:cpp_supported_tool_chain"></a> <a class="link" href="#sec:cpp_supported_tool_chain">支持的工具链</a></h5>
<div class="paragraph">
<p>Gradle提供了使用不同工具链执行相同构建的功能。当您构建本机二进制文件时，Gradle会尝试找到您的计算机上安装的可以构建二进制文件的工具链。Gradle选择可以为目标操作系统和体系结构构建的第一个工具链。将来，Gradle在选择工具链时将考虑源和ABI兼容性。</p>
</div>
<div class="paragraph">
<p>Gradle对主要操作系统上的三个主要工具链具有普遍支持：Clang <sup class="footnote">[ <a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="查看脚注。">15</a> ]</sup> ，GCC <sup class="footnote">[ <a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="查看脚注。">16</a> ]</sup>和Visual C ++ <sup class="footnote">[ <a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="查看脚注。">17</a> ]</sup> （仅Windows）。据报道，使用Macports和Homebrew安装的GCC和Clang可以正常工作，但是尚未对此进行持续测试。</p>
</div>
<div class="sect5">
<h6 id="windows"><a class="anchor" href="#windows"></a> <a class="link" href="#windows">视窗</a></h6>
<div class="paragraph">
<p>要在Windows上构建，请安装兼容版本的Visual Studio。C ++插件将发现Visual Studio安装并选择最新版本。无需弄乱环境变量或批处理脚本。在Cygwin Shell或Windows命令行中，此方法工作正常。</p>
</div>
<div class="paragraph">
<p>或者，您可以将Cygwin或MinGW与GCC一起安装。目前不支持Clang。</p>
</div>
</div>
<div class="sect5">
<h6 id="macos"><a class="anchor" href="#macos"></a> <a class="link" href="#macos">苹果系统</a></h6>
<div class="paragraph">
<p>要在macOS上构建，您应该安装Xcode。C ++插件将使用系统PATH发现Xcode的安装。</p>
</div>
<div class="paragraph">
<p>C ++插件还可以与Macports或Homebrew <sup class="footnote">[ <a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="查看脚注。">18</a> ]</sup>一起安装的GCC和Clang一起使用。要使用Macports或Homebrew之一，您需要将Macports / Homebrew添加到系统PATH。</p>
</div>
</div>
<div class="sect5">
<h6 id="linux"><a class="anchor" href="#linux"></a> <a class="link" href="#linux">的Linux</a></h6>
<div class="paragraph">
<p>要在Linux上构建，请安装兼容版本的GCC或Clang。C ++插件将使用系统PATH发现GCC或Clang。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:custom_cpp_source_set_paths"><a class="anchor" href="#sec:custom_cpp_source_set_paths"></a> <a class="link" href="#sec:custom_cpp_source_set_paths">自定义文件和目录位置</a></h5>
<div class="paragraph">
<p>假设您有一个旧版库项目，该项目将<em>src</em>目录用于生产代码和专用标头，并<em>包含</em>用于导出标头的目录。传统的目录结构不起作用，因此您需要告诉Gradle在哪里可以找到源文件和头文件。您可以通过<code>application</code>要么<code>library</code>脚本块。</p>
</div>
<div class="paragraph">
<p>每个组件脚本块以及每个二进制文件都定义其源代码所在的位置。您可以使用以下语法覆盖约定值：</p>
</div>
<div class="exampleblock">
<div class="title">示例452设置C ++源集</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    library {
        source.from file(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>)
        privateHeaders.from file(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>)
        publicHeaders.from file(<span class="string"><span class="delimiter">'</span><span class="content">include</span><span class="delimiter">'</span></span>)
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    extensions.configure&lt;CppLibrary&gt; {
        source.from(file(&quot;src&quot;))
        privateHeaders.from(file(&quot;src&quot;))
        publicHeaders.from(file(&quot;include&quot;))
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在Gradle将只在<em>src中</em>直接搜索源和私有头，在<em>include中</em>搜索公共头。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:custom_cpp_compile_link"><a class="anchor" href="#sec:custom_cpp_compile_link"></a> <a class="link" href="#sec:custom_cpp_compile_link">更改编译器和链接器选项</a></h5>
<div class="paragraph">
<p>大多数编译器和链接器选项可通过相应的任务访问，例如<code>compile<em>Variant</em>Cpp</code> ， <code>link<em>Variant</em></code>和<code>create<em>Variant</em></code> 。这些任务分别为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.tasks.CppCompile.html">CppCompile</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.LinkSharedLibrary.html">LinkSharedLibrary</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.CreateStaticLibrary.html">CreateStaticLibrary</a>类型。阅读任务参考以获取最新，最全面的选项列表。</p>
</div>
<div class="paragraph">
<p>例如，如果要更改编译器为所有变体生成的警告级别，则可以使用以下配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例453。为所有变体设置C ++编译器选项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(CppCompile).configureEach {
    <span class="comment">// Define a preprocessor macro for every binary</span>
    macros.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">NDEBUG</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>)

    <span class="comment">// Define a compiler options</span>
    compilerArgs.add <span class="string"><span class="delimiter">'</span><span class="content">-W3</span><span class="delimiter">'</span></span>

    <span class="comment">// Define toolchain-specific compiler options</span>
    compilerArgs.addAll toolChain.map { toolChain -&gt;
        <span class="keyword">if</span> (toolChain <span class="keyword">in</span> [ Gcc, Clang ]) {
            <span class="keyword">return</span> [<span class="string"><span class="delimiter">'</span><span class="content">-O2</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">-fno-access-control</span><span class="delimiter">'</span></span>]
        } <span class="keyword">else</span> <span class="keyword">if</span> (toolChain <span class="keyword">in</span> VisualCpp) {
            <span class="keyword">return</span> [<span class="string"><span class="delimiter">'</span><span class="content">/Zi</span><span class="delimiter">'</span></span>]
        }
        <span class="keyword">return</span> <span class="type">[]</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType(CppCompile::class.java).configureEach {
    // Define a preprocessor macro for every binary
    macros.put(&quot;NDEBUG&quot;, null)

    // Define a compiler options
    compilerArgs.add(&quot;-W3&quot;)

    // Define toolchain-specific compiler options
    compilerArgs.addAll(toolChain.map { toolChain -&gt;
        when (toolChain) {
            is Gcc, is Clang -&gt; listOf(&quot;-O2&quot;, &quot;-fno-access-control&quot;)
            is VisualCpp -&gt; listOf(&quot;/Zi&quot;)
            else -&gt; listOf()
        }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以通过来找到特定变体的实例<code>BinaryCollection</code>在<code>application</code>要么<code>library</code>脚本块：</p>
</div>
<div class="exampleblock">
<div class="title">实施例454。为每个变体设置C ++编译器选项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    binaries.configureEach(CppStaticLibrary) {
        <span class="comment">// Define a preprocessor macro for every binary</span>
        compileTask.get().macros.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">NDEBUG</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>)

        <span class="comment">// Define a compiler options</span>
        compileTask.get().compilerArgs.add <span class="string"><span class="delimiter">'</span><span class="content">-W3</span><span class="delimiter">'</span></span>

        <span class="comment">// Define toolchain-specific compiler options</span>
        <span class="keyword">if</span> (toolChain <span class="keyword">in</span> [ Gcc, Clang ]) {
            compileTask.get().compilerArgs.addAll([<span class="string"><span class="delimiter">'</span><span class="content">-O2</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">-fno-access-control</span><span class="delimiter">'</span></span>])
        } <span class="keyword">else</span> <span class="keyword">if</span> (toolChain <span class="keyword">in</span> VisualCpp) {
            compileTask.get().compilerArgs.add(<span class="string"><span class="delimiter">'</span><span class="content">/Zi</span><span class="delimiter">'</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    binaries.configureEach(CppStaticLibrary::class.java) {
        // Define a preprocessor macro for every binary
        compileTask.get().macros.put(&quot;NDEBUG&quot;, null)

        // Define a compiler options
        compileTask.get().compilerArgs.add(&quot;-W3&quot;)

        // Define toolchain-specific compiler options
        when (toolChain) {
            is Gcc, is Clang -&gt; compileTask.get().compilerArgs.addAll(listOf(&quot;-O2&quot;, &quot;-fno-access-control&quot;))
            is VisualCpp -&gt; compileTask.get().compilerArgs.add(&quot;/Zi&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:select_cpp_target_machines"><a class="anchor" href="#sec:select_cpp_target_machines"></a> <a class="link" href="#sec:select_cpp_target_machines">选择目标机器</a></h5>
<div class="paragraph">
<p>默认情况下，Gradle将尝试为主机操作系统和体系结构创建C ++二进制变体。可以通过指定一组来覆盖此<code>TargetMachine</code>在<code>application</code>要么<code>library</code>脚本块：</p>
</div>
<div class="exampleblock">
<div class="title">示例455设置目标机器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    targetMachines = [
        machines.linux.x86_64,
        machines.windows.x86, machines.windows.x86_64,
        machines.macOS.x86_64
    ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    targetMachines.set(listOf(machines.windows.x86, machines.windows.x86_64, machines.macOS.x86_64, machines.linux.x86_64))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:cpp_packaging"><a class="anchor" href="#sec:cpp_packaging"></a> <a class="link" href="#sec:cpp_packaging">包装出版</a></h4>
<div class="paragraph">
<p>在本地环境中，打包和潜在发布C ++项目的方式差异很大。Gradle具有默认值，但是自定义打包可以实现而没有任何问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可执行文件直接发布到Maven存储库。</p>
</li>
<li>
<p>共享库和静态库文件以及公共标头的压缩文件直接发布到Maven存储库。</p>
</li>
<li>
<p>对于应用程序，Gradle还支持在已知位置安装和运行具有所有共享库依赖项的可执行文件。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:cleaning_cpp_build"><a class="anchor" href="#sec:cleaning_cpp_build"></a> <a class="link" href="#sec:cleaning_cpp_build">清理构建</a></h4>
<div class="paragraph">
<p>C ++应用程序和库插件添加了一个<code>clean</code>使用<a href="#">基本插件进行</a>项目任务。此任务只是删除了<code>$buildDir</code>目录，因此为什么要始终将构建生成的文件放在其中。该任务是Delete的一个实例，您可以通过设置其删除来更改其删除的目录<code>dir</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_cpp_libraries"><a class="anchor" href="#sec:building_cpp_libraries"></a> <a class="link" href="#sec:building_cpp_libraries">构建C ++库</a></h4>
<div class="paragraph">
<p>库项目的独特之处在于它们被其他C ++项目使用（或“消耗”）。这意味着与二进制文件和标头一起发布的依赖项元数据（以Gradle模块元数据的形式）至关重要。特别是，您的库的使用者应能够区分两种不同类型的依赖关系：仅依赖于编译库的依赖和也依赖于编译使用者的依赖。</p>
</div>
<div class="paragraph">
<p>Gradle通过<a href="cpp_library_plugin.html">C ++库插件</a>来管理此区别，该<a href="cpp_library_plugin.html">插件</a>除了本章介绍的<em>实现</em>之外，还引入了<em>api</em>配置。如果依赖项的类型显示为静态库的未解析符号或在公共头文件中，则该依赖项通过库的公共API公开，因此应将其添加到<em>api</em>配置中。否则，依赖项是内部实现细节，应将其添加到<em>Implementation中</em> 。</p>
</div>
<div class="paragraph">
<p>如果不确定API和实现依赖项之间的区别，请参阅<a href="cpp_library_plugin.html#sec:cpp_library_api_vs_implementation">C ++库插件</a>一章的详细说明。此外，您可以在相应的<a href="https://guides.gradle.org/building-cpp-libraries">指南中</a>看到构建C ++库的基本，实际示例。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_cpp_applications"><a class="anchor" href="#sec:building_cpp_applications"></a> <a class="link" href="#sec:building_cpp_applications">构建C ++应用程序</a></h4>
<div class="paragraph">
<p>有关更多详细信息，请参见“ <a href="cpp_application_plugin.html">C ++应用程序插件”</a>一章，但这是您所获得的快速摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>install</code>创建一个目录，其中包含运行该目录所需的一切</p>
</li>
<li>
<p>Shell和Windows Batch脚本启动应用程序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在相应的<a href="https://guides.gradle.org/building-cpp-applications">指南中</a>看到构建C ++应用程序的基本示例。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cpp_testing"><a class="anchor" href="#cpp_testing"></a> <a class="link" href="#cpp_testing">在C ++项目中进行测试</a></h3>
<div class="paragraph">
<p>在原生生态系统中进行测试有多种形式。</p>
</div>
<div class="paragraph">
<p>有不同的测试库和框架，以及许多不同类型的测试。无论它们是频繁执行还是不频繁执行，所有这些都需要成为构建的一部分。本章致力于说明Gradle如何处理内部版本之间以及内部内部的不同要求，并广泛介绍了Gradle如何与基于可执行文件的测试框架（例如<a href="https://github.com/google/googletest">Google Test）</a>集成。</p>
</div>
<div class="paragraph">
<p>与<a href="#java_testing">在Java和JVM项目中</a>进行<a href="#java_testing">测试</a>相比，在Gradle中测试C ++项目非常有限。在本章中，我们将说明控制测试运行方式的方法（ <a href="#sec:cpp_test_execution">测试执行</a> ）。</p>
</div>
<div class="paragraph">
<p>但是首先，我们看一下Gradle中本机测试的基础。</p>
</div>
<div class="sect3">
<h4 id="sec:cpp_testing_basics"><a class="anchor" href="#sec:cpp_testing_basics"></a> <a class="link" href="#sec:cpp_testing_basics">基础</a></h4>
<div class="paragraph">
<p>所有C ++测试都围绕一种任务类型运行： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html">RunTestExecutable</a> 。这将运行使用任何测试框架构建的单个测试可执行文件，并使用可执行文件的退出代码断言执行成功。没有收集测试用例结果，也没有生成报告。</p>
</div>
<div class="paragraph">
<p>为了进行操作， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html">RunTestExecutable</a>任务类型仅需要一条信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在哪里找到构建的测试可执行文件（属性： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html#org.gradle.nativeplatform.test.tasks.RunTestExecutable:executable">RunTestExecutable.getExecutable（）</a> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用<a href="cpp_unit_test_plugin.html">C ++单元测试插件时，</a>您将自动获得以下信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>专用的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cpp.CppTestSuite.html">unitTest</a>扩展，用于配置测试组件及其变体</p>
</li>
<li>
<p>一种<code>run</code>运行测试可执行文件的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html">RunTestExecutable</a>类型的任务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>测试插件会适当配置所需的信息。此外，他们附加了<code>run</code>任务<code>check</code>生命周期任务。它还会创建<code>testImplementation</code>依赖项配置。只能将测试编译，链接和运行时所需的依赖项添加到此配置中。的<code>unitTest</code>脚本块的行为类似于<code>application</code>要么<code>library</code>脚本块。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html">RunTestExecutable</a>任务具有许多配置选项。在本章的其余部分中，我们将介绍其中的一些。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:cpp_test_execution"><a class="anchor" href="#sec:cpp_test_execution"></a> <a class="link" href="#sec:cpp_test_execution">测试执行</a></h4>
<div class="paragraph">
<p>Gradle在单独的（“分叉”）过程中执行测试。</p>
</div>
<div class="paragraph">
<p>您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html">RunTestExecutable</a>任务上的几个属性来控制如何启动测试过程，包括：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ignoreFailures</code> -默认值：false</dt>
<dd>
<p>如果此属性是<code>true</code>测试完成后，即使其中一些失败，Gradle也会继续进行项目的构建。请注意，默认情况下，无论该设置如何， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html">RunTestExecutable</a>任务类型始终执行它检测到的每个测试。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关所有可用配置选项的详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.tasks.RunTestExecutable.html">RunTestExecutable</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="building_swift_projects"><a class="anchor" href="#building_swift_projects"></a> <a class="link" href="#building_swift_projects">建立Swift项目</a></h3>
<div class="paragraph">
<p>Gradle使用约定优于配置的方法来构建本机项目。如果您来自另一个本机构建系统，那么这些概念起初可能并不陌生，但它们的目的是简化构建脚本的编写。</p>
</div>
<div class="paragraph">
<p>我们将在本章中详细介绍Swift项目，但是大多数主题也将适用于其他受支持的本地语言。</p>
</div>
<div class="sect3">
<h4 id="sec:swift_introduction"><a class="anchor" href="#sec:swift_introduction"></a> <a class="link" href="#sec:swift_introduction">介绍</a></h4>
<div class="paragraph">
<p>Swift项目的最简单构建脚本将应用Swift应用程序插件或Swift库插件，并可以选择设置项目版本：</p>
</div>
<div class="exampleblock">
<div class="title">示例456应用Swift插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">swift-application</span><span class="delimiter">'</span></span> <span class="comment">// or 'swift-library'</span>
}

version = <span class="string"><span class="delimiter">'</span><span class="content">1.2.1</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `swift-application` // or `swift-library`
}

version = &quot;1.2.1&quot;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过应用任何一个Swift插件，您将获得大量功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>compileDebugSwift</code>和<code>compileReleaseSwift</code>分别在<em>src / main / swift</em>下编译Swift源文件的任务，分别用于著名的debug和release构建类型。</p>
</li>
<li>
<p><code>linkDebug</code>和<code>linkRelease</code>任务，这些任务将已编译的Swift对象文件链接到应用程序的可执行文件或共享库的库中，并具有调试和发布构建类型的共享链接。</p>
</li>
<li>
<p><code>createDebug</code>和<code>createRelease</code>任务，这些任务将已编译的Swift对象文件组装到一个静态库中，这些库具有针对调试和发布构建类型进行静态链接的库。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于任何不平凡的斯威夫特项目，你可能有一些文件相关的和额外的配置具体到<em>项目</em>中。</p>
</div>
<div class="paragraph">
<p>Swift插件还将上述任务集成到标准<a href="#sec:base_tasks">生命周期任务中</a> 。产生开发二进制文件的任务附加到<code>assemble</code> 。默认情况下，开发二进制文件是调试变量。</p>
</div>
<div class="paragraph">
<p>本章的其余部分介绍了在构建库和应用程序时根据需要自定义构建的不同方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:introducing_build_variants-swift"><a class="anchor" href="#sec:introducing_build_variants-swift"></a> <a class="link" href="#sec:introducing_build_variants-swift">引入构建变体</a></h4>
<div class="paragraph">
<p>本机项目通常可以产生几种不同的二进制文件，例如调试或发布的二进制文件，或针对特定平台和处理器体系结构的二进制文件。Gradle通过<em>维度</em>和<em>变体</em>的概念来进行管理。</p>
</div>
<div class="paragraph">
<p>维度只是一个类别，其中每个类别都与其他维度正交。例如，“构建类型”维是包括调试和发布的类别。“架构”维度涵盖了x86-64和x86之类的处理器架构。</p>
</div>
<div class="paragraph">
<p>变体是这些维度的值的组合，每个维度恰好由一个值组成。您可能具有“ debug x86-64”或“ release x86”变体。</p>
</div>
<div class="paragraph">
<p>Gradle内置了对多个维度和每个维度内多个值的支持。您可以在本<a href="#native_languages">机插件参考章节中</a>找到它们的列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:swift_source_sets"><a class="anchor" href="#sec:swift_source_sets"></a> <a class="link" href="#sec:swift_source_sets">声明您的源文件</a></h4>
<div class="paragraph">
<p>Gradle的Swift支持使用<code>ConfigurableFileCollection</code>直接从<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.swift.SwiftApplication.html">应用程序</a>或<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.swift.SwiftLibrary.html">库</a>脚本块配置要编译的源集。</p>
</div>
<div class="paragraph">
<p>库区分私有（实现细节）和公共（导出到消费者）头。</p>
</div>
<div class="paragraph">
<p>对于仅在特定目标计算机上编译源的情况，您还可以为每个二进制版本配置源。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/swift-sourcesets-compilation.png" alt="快速的资料集汇编">
</div>
<div class="title">图28。源码和Swift编译</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:swift_dependency_management_overview"><a class="anchor" href="#sec:swift_dependency_management_overview"></a> <a class="link" href="#sec:swift_dependency_management_overview">管理你的依赖</a></h4>
<div class="paragraph">
<p>绝大多数项目都依赖于其他项目，因此管理项目的依存关系是构建任何项目的重要组成部分。依赖管理是一个大话题，因此我们在这里仅关注Swift项目的基础知识。如果您想深入了解这些细节，请查看<a href="#">依赖管理的简介</a> 。</p>
</div>
<div class="paragraph">
<p>Gradle提供了对使用Gradle <sup class="footnote">[ <a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="查看脚注。">19</a> ]</sup>发布的Maven存储库中的预构建二进制文件的支持。</p>
</div>
<div class="paragraph">
<p>我们将介绍如何在多构建项目中的项目之间添加依赖项。</p>
</div>
<div class="paragraph">
<p>为您的Swift项目指定依赖项需要两条信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标识依赖项的信息（项目路径，Maven GAV）</p>
</li>
<li>
<p>它需要什么，例如编译，链接，运行时或以上所有。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此信息在<code>dependencies {}</code>迅捷方块<code>application</code>要么<code>library</code>脚本块。例如，告诉Gradle您的项目需要库<code>common</code>要编译和链接您的生产代码，可以使用以下片段：</p>
</div>
<div class="exampleblock">
<div class="title">示例457声明依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    dependencies {
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:common</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    dependencies {
        implementation(project(&quot;:common&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>三个元素的Gradle术语如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>配置</em> （例如： <code>implementation</code> ）-命名的依赖项集合，针对特定目标（如编译或链接模块）分组在一起</p>
</li>
<li>
<p><em>项目参考</em> （例如： <code>project(':common')</code> ）-指定路径引用的项目</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以<a href="#">在此处</a>找到更全面的依赖项管理术语表。</p>
</div>
<div class="paragraph">
<p>就配置而言，主要感兴趣的是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>implementation</code> -用于编译，链接和运行时</p>
</li>
<li>
<p><code>swiftCompile<em>Variant</em></code> -对于编译生产代码所必需的依赖关系，但不应该属于链接或运行时过程的一部分</p>
</li>
<li>
<p><code>nativeLink<em>Variant</em></code> -对于链接代码所必需的依赖关系，但不应该包含在编译或运行时过程中</p>
</li>
<li>
<p><code>nativeRuntime<em>Variant</em></code> -对于运行组件所需的依赖关系，但不应作为编译或链接过程的一部分</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在本<a href="#native_languages">机插件参考章节中</a>了解有关它们的更多信息以及它们之间的关系。</p>
</div>
<div class="paragraph">
<p>请注意， <a href="swift_library_plugin.html">Swift库插件</a>会创建其他配置- <code>api</code> -对于编译和链接模块以及依赖于该模块的任何模块所需的依赖项。</p>
</div>
<div class="paragraph">
<p>我们仅在此处进行了介绍，因此，一旦您熟悉使用Gradle构建Swift项目的基础知识，我们建议您阅读<a href="#">专用的依赖管理章节</a> 。</p>
</div>
<div class="paragraph">
<p>需要进一步阅读的一些常见方案包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义与<a href="#sec:repository-types">Maven兼容</a>的自定义存储库</p>
</li>
<li>
<p>使用<a href="#sub:declaring_dependency_with_changing_version">变化的版本</a> （例如SNAPSHOT）和<a href="#sub:declaring_dependency_with_dynamic_version">动态的</a> （范围）声明依赖项</p>
</li>
<li>
<p>将同级<a href="#sub:project_dependencies">项目</a>声明<a href="#sub:project_dependencies">为依赖项</a></p>
</li>
<li>
<p><a href="#">控制传递依赖及其版本</a></p>
</li>
<li>
<p>通过<a href="#">组合构建</a>测试对第三方依赖关系的修复（这是发布到<a href="#sub:maven_local">Maven Local</a>和从<a href="#sub:maven_local">Maven Local</a>消费的更好的替代方法）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您会发现Gradle具有丰富的API用于处理依赖关系-一种需要花费时间才能掌握的API，但对于常见情况却很容易使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:swift_compile_link"><a class="anchor" href="#sec:swift_compile_link"></a> <a class="link" href="#sec:swift_compile_link">编译和链接代码</a></h4>
<div class="paragraph">
<p>如果遵循以下约定，则编译两个代码都非常容易：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将您的源代码放在<em>src / main / swift</em>目录下</p>
</li>
<li>
<p>在中声明您的编译依赖项<code>implementation</code>配置（请参阅上一节）</p>
</li>
<li>
<p>跑过<code>assemble</code>任务</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们建议您尽可能遵循这些约定，但不必这样做。</p>
</div>
<div class="paragraph">
<p>有几种自定义选项，您将在下面看到。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">所有<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.swift.tasks.SwiftCompile.html">SwiftCompile</a>任务都是增量的且可缓存的。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="sec:swift_supported_tool_chain"><a class="anchor" href="#sec:swift_supported_tool_chain"></a> <a class="link" href="#sec:swift_supported_tool_chain">支持的工具链</a></h5>
<div class="paragraph">
<p>Gradle支持<a href="https://swift.org/download/">适用于macOS和Linux</a>的<a href="https://swift.org/download/">官方Swift工具链</a> 。当您构建本机二进制文件时，Gradle会尝试找到您的计算机上安装的可以构建二进制文件的工具链。Gradle选择可以为目标操作系统，体系结构和Swift语言支持构建的第一个工具链。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">对于Linux用户，Gradle将使用系统PATH发现工具链。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:custom_swift_source_set_paths"><a class="anchor" href="#sec:custom_swift_source_set_paths"></a> <a class="link" href="#sec:custom_swift_source_set_paths">自定义文件和目录位置</a></h5>
<div class="paragraph">
<p>假设您要迁移遵循Swift Package Manager布局的库项目（例如， <code>Sources/<em>ModuleName</em>_</code>生产代码的目录）。传统的目录结构不起作用，因此您需要告诉Gradle在哪里可以找到源文件。您可以通过<code>application</code>要么<code>library</code>脚本块。</p>
</div>
<div class="paragraph">
<p>每个组件脚本块以及每个二进制文件都定义其源代码所在的位置。您可以使用以下语法覆盖约定值：</p>
</div>
<div class="exampleblock">
<div class="title">示例458设置Swift源集</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    library {
        source.from file(<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>)
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    extensions.configure&lt;SwiftLibrary&gt; {
        source.from(file(&quot;Sources/Common&quot;))
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在Gradle将仅在<em>Sources / Common中</em>直接搜索源。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:custom_swift_compile_link"><a class="anchor" href="#sec:custom_swift_compile_link"></a> <a class="link" href="#sec:custom_swift_compile_link">更改编译器和链接器选项</a></h5>
<div class="paragraph">
<p>大多数编译器和链接器选项可通过相应的任务访问，例如<code>compile<em>Variant</em>Swift</code> ， <code>link<em>Variant</em></code>和<code>create<em>Variant</em></code> 。这些任务分别为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.swift.tasks.SwiftCompile.html">SwiftCompile</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.LinkSharedLibrary.html">LinkSharedLibrary</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.tasks.CreateStaticLibrary.html">CreateStaticLibrary</a>类型。阅读任务参考以获取最新，最全面的选项列表。</p>
</div>
<div class="paragraph">
<p>例如，如果要更改编译器为所有变体生成的警告级别，则可以使用以下配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例459为所有变体设置Swift编译器选项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(SwiftCompile).configureEach {
    <span class="comment">// Define a preprocessor macro for every binary</span>
    macros.add(<span class="string"><span class="delimiter">&quot;</span><span class="content">NDEBUG</span><span class="delimiter">&quot;</span></span>)

    <span class="comment">// Define a compiler options</span>
    compilerArgs.add <span class="string"><span class="delimiter">'</span><span class="content">-O</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType(SwiftCompile::class.java).configureEach {
    // Define a preprocessor macro for every binary
    macros.add(&quot;NDEBUG&quot;)

    // Define a compiler options
    compilerArgs.add(&quot;-O&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以通过来找到特定变体的实例<code>BinaryCollection</code>在<code>application</code>要么<code>library</code>脚本块：</p>
</div>
<div class="exampleblock">
<div class="title">示例460为每个变体设置Swift编译器选项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    binaries.configureEach(SwiftStaticLibrary) {
        <span class="comment">// Define a preprocessor macro for every binary</span>
        compileTask.get().macros.add(<span class="string"><span class="delimiter">&quot;</span><span class="content">NDEBUG</span><span class="delimiter">&quot;</span></span>)

        <span class="comment">// Define a compiler options</span>
        compileTask.get().compilerArgs.add <span class="string"><span class="delimiter">'</span><span class="content">-O</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    binaries.configureEach(SwiftStaticLibrary::class.java) {
        // Define a preprocessor macro for every binary
        compileTask.get().macros.add(&quot;NDEBUG&quot;)

        // Define a compiler options
        compileTask.get().compilerArgs.add(&quot;-O&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:select_swift_target_machines"><a class="anchor" href="#sec:select_swift_target_machines"></a> <a class="link" href="#sec:select_swift_target_machines">选择目标机器</a></h5>
<div class="paragraph">
<p>默认情况下，Gradle将尝试为主机操作系统和体系结构创建Swift二进制变体。可以通过指定一组来覆盖此<code>TargetMachine</code>在<code>application</code>要么<code>library</code>脚本块：</p>
</div>
<div class="exampleblock">
<div class="title">示例461设置目标机器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    targetMachines = [
        machines.linux.x86_64,
        machines.macOS.x86_64
    ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    targetMachines.set(listOf(machines.linux.x86_64, machines.macOS.x86_64))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:swift_packaging"><a class="anchor" href="#sec:swift_packaging"></a> <a class="link" href="#sec:swift_packaging">包装出版</a></h4>
<div class="paragraph">
<p>在本地环境中，打包和潜在发布Swift项目的方式差异很大。Gradle具有默认值，但是自定义打包可以实现而没有任何问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可执行文件直接发布到Maven存储库。</p>
</li>
<li>
<p>共享库和静态库文件以及公共标头的压缩文件直接发布到Maven存储库。</p>
</li>
<li>
<p>对于应用程序，Gradle还支持在已知位置安装和运行具有所有共享库依赖项的可执行文件。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:cleaning_swift_build"><a class="anchor" href="#sec:cleaning_swift_build"></a> <a class="link" href="#sec:cleaning_swift_build">清理构建</a></h4>
<div class="paragraph">
<p>Swift应用程序和库插件添加了一个<code>clean</code>使用<a href="#">基本插件进行</a>项目任务。此任务只是删除了<code>$buildDir</code>目录，因此为什么要始终将构建生成的文件放在其中。该任务是Delete的一个实例，您可以通过设置其删除来更改其删除的目录<code>dir</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_swift_libraries"><a class="anchor" href="#sec:building_swift_libraries"></a> <a class="link" href="#sec:building_swift_libraries">构建Swift库</a></h4>
<div class="paragraph">
<p>库项目的独特之处在于它们被其他Swift项目使用（或“消耗”）。这意味着与二进制文件和标头一起发布的依赖项元数据（以Gradle模块元数据的形式）至关重要。特别是，您的库的使用者应能够区分两种不同类型的依赖关系：仅依赖于编译库的依赖和也依赖于编译使用者的依赖。</p>
</div>
<div class="paragraph">
<p>Gradle通过<a href="swift_library_plugin.html">Swift Library Plugin</a>来管理这种区别， <a href="swift_library_plugin.html">Swift Library Plugin</a>在本章中介绍的<em>实现</em>之外，还引入了<em>api</em>配置。如果依赖项的类型显示为静态库的未解析符号或在公共头文件中，则该依赖项通过库的公共API公开，因此应将其添加到<em>api</em>配置中。否则，依赖项是内部实现细节，应将其添加到<em>Implementation中</em> 。</p>
</div>
<div class="paragraph">
<p>如果不确定API和实现依赖项之间的区别，请参阅<a href="swift_library_plugin.html#sec:swift_library_api_vs_implementation">Swift库插件</a>一章中的详细说明。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_swift_applications"><a class="anchor" href="#sec:building_swift_applications"></a> <a class="link" href="#sec:building_swift_applications">构建Swift应用程序</a></h4>
<div class="paragraph">
<p>有关更多详细信息，请参见“ <a href="swift_application_plugin.html">Swift应用程序插件”</a>一章，但这是您所获得的快速摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>install</code>创建一个目录，其中包含运行该目录所需的一切</p>
</li>
<li>
<p>Shell和Windows Batch脚本启动应用程序</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="swift_testing"><a class="anchor" href="#swift_testing"></a> <a class="link" href="#swift_testing">在Swift项目中进行测试</a></h3>
<div class="paragraph">
<p>在原生生态系统中进行测试是一个丰富的主题。有许多不同的测试库和框架，以及许多不同类型的测试。无论它们是频繁执行还是不频繁执行，所有这些都需要成为构建的一部分。本章专门说明Gradle如何处理内部版本之间以及内部版本之间的不同要求，并广泛介绍了Gradle如何与macOS和Linux上的XCTest集成。</p>
</div>
<div class="paragraph">
<p>它解释了：-控制测试运行方式的方法（测试执行）-如何选择要运行的特定测试（测试过滤）-生成了哪些测试报告以及如何影响过程（测试报告）-Gradle如何找到要运行的测试运行（测试检测）</p>
</div>
<div class="paragraph">
<p>但是首先，我们看一下Gradle中本机测试的基础。</p>
</div>
<div class="sect3">
<h4 id="sec:swift_testing_basics"><a class="anchor" href="#sec:swift_testing_basics"></a> <a class="link" href="#sec:swift_testing_basics">基础</a></h4>
<div class="paragraph">
<p>Gradle支持与Swift语言的XCTest测试框架进行深度集成，并围绕<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html">XCTest</a>任务类型展开。这将在macOS上使用<a href="https://developer.apple.com/documentation/xctest">Xcode XCTest</a>或在Linux上使用<a href="https://github.com/apple/swift-corelibs-xctest">开源Swift核心库替代方案</a>运行一系列测试用例，并整理结果。然后，您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.TestReport.html">TestReport</a>任务类型的实例将这些结果转换为报告。</p>
</div>
<div class="paragraph">
<p>为了进行操作， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html">XCTest</a>任务类型需要三条信息：-在哪里找到构建的可测试包（在macOS上）或可执行文件（在Linux上）（属性： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html#org.gradle.nativeplatform.test.xctest.tasks.XCTest:testInstallDirectory">XCTest.getTestInstalledDirectory（）</a> ）-用于执行包的运行脚本或可执行文件（属性： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html#org.gradle.nativeplatform.test.xctest.tasks.XCTest:runScriptFile">XCTest.getRunScriptFile（）</a> ）-执行捆绑或可执行文件的工作目录（属性： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html#org.gradle.nativeplatform.test.xctest.tasks.XCTest:workingDirectory">XCTest.getWorkingDirectory（）</a> ）</p>
</div>
<div class="paragraph">
<p>使用<a href="xctest_plugin.html">XCTest插件时，</a>您将自动获得以下信息：-专用<code>xctest</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.SwiftXCTestSuite.html">SwiftXCTestSuite</a>类型的扩展，用于配置测试组件及其变体-A <code>xcTest</code>运行那些单元测试的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html">XCTest</a>类型的任务-与主要组件的目标文件链接的可测试包或可执行文件</p>
</div>
<div class="paragraph">
<p>测试插件会适当配置所需的信息。此外，他们附加了<code>xcTest</code>要么<code>run</code>任务<code>check</code>生命周期任务。它还会创建<code>testImplementation</code>依赖项配置。只能将测试编译，链接和运行时所需的依赖项添加到此配置中。的<code>xctest</code>脚本块的行为类似于<code>application</code>要么<code>library</code>脚本块。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html">XCTest</a>任务具有许多配置选项。在本章的其余部分中，我们将讨论其中的许多内容。</p>
</div>
</div>
<div class="sect3">
<h4 id="test_execution"><a class="anchor" href="#test_execution"></a> <a class="link" href="#test_execution">测试执行</a></h4>
<div class="paragraph">
<p>Gradle在单独的（“分叉”）过程中执行测试。</p>
</div>
<div class="paragraph">
<p>您可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html">XCTest</a>任务上的几个属性来控制如何启动测试过程，包括以下内容：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ignoreFailures</code> -默认值：false</dt>
<dd>
<p>如果此属性是<code>true</code>测试完成后，即使其中一些失败，Gradle也会继续进行项目的构建。请注意，默认情况下，无论使用哪种设置，这两种任务类型始终执行它检测到的每个测试。</p>
</dd>
<dt class="hdlist1"><code>testLogging</code> -默认：未设置</dt>
<dd>
<p>此属性表示一组选项，用于控制记录哪些测试事件以及在什么级别进行记录。您还可以通过此属性配置其他日志记录行为。设置<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/testing/logging/TestLoggingContainer.html">TestLoggingContainer</a>以获得更多详细信息。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关所有可用配置选项的详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html">XCTest</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:swift_test_filtering"><a class="anchor" href="#sec:swift_test_filtering"></a> <a class="link" href="#sec:swift_test_filtering">测试过滤</a></h4>
<div class="paragraph">
<p>运行测试套件的子集是常见的要求，例如，在修复错误或开发新的测试用例时。Gradle为此提供了过滤。您可以根据以下条件选择要运行的测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个简单的类名或方法名，例如<code>SomeTest</code> ，<code>SomeTest.someMethod</code></p>
</li>
<li>
<p>'*'通配符匹配</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过构建脚本或通过启用过滤<code>--tests</code>命令行选项。这是每次构建运行时都会应用的一些过滤器的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例462筛选每个构建上的测试</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">xctest {
    binaries.configureEach {
        runTask.get().configure {
            <span class="comment">// include all tests from test class</span>
            filter.includeTestsMatching <span class="string"><span class="delimiter">&quot;</span><span class="content">SomeIntegTest.*</span><span class="delimiter">&quot;</span></span> <span class="comment">// or `&quot;Testing.SomeIntegTest.*&quot;` on macOS</span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">xctest {
    binaries.configureEach {
        runTask.get().filter.includeTestsMatching(&quot;SomeIntegTest.*&quot;) // or `&quot;Testing.SomeIntegTest.*&quot;` on macOS
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关在构建脚本中声明过滤器的更多详细信息和示例，请参见TestFilter参考。</p>
</div>
<div class="paragraph">
<p>命令行选项对于执行单个测试方法特别有用。也可以提供多个<code>--tests</code>选项，所有模式都会生效。以下各节提供了几个使用命令行选项的示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">目前，测试过滤仅支持XCTest兼容过滤器。这意味着同一过滤器在macOS和Linux之间会有所不同。在macOS上，捆绑包的基本名称需要添加到过滤器之前，例如<code>TestBundle.SomeTest</code> ， <code>TestBundle.SomeTest.someMethod</code>有关有效过滤模式的更多信息，请参见下面的“ <a href="#sec:swift_test_filtering_simple_name_pattern">简单名称模式”</a>部分。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下部分介绍简单类/方法名称的具体情况。</p>
</div>
<div class="sect4">
<h5 id="sec:swift_test_filtering_simple_name_pattern"><a class="anchor" href="#sec:swift_test_filtering_simple_name_pattern"></a> <a class="link" href="#sec:swift_test_filtering_simple_name_pattern">简单名称模式</a></h5>
<div class="paragraph">
<p>Gradle支持简单的类名，或类名+方法名的测试过滤。例如，以下命令行可运行或完全测试其中一个测试<code>SomeTestClass</code>测试用例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code># Executes all tests in SomeTestClass
gradle xcTest --tests SomeTestClass
# or `gradle xcTest --tests TestBundle.SomeTestClass` on macOS

# Executes a single specified test in SomeTestClass
gradle xcTest --tests TestBundle.SomeTestClass.someSpecificMethod
# or `gradle xcTest --tests TestBundle.SomeTestClass.someSpecificMethod` on macOS</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以将在命令行中定义的过滤器与<a href="https://docs.gradle.org/current/userguide/command_line_interface.html#sec:continuous_build">连续构建结合使用，</a>以在每次对生产或测试源文件进行更改后立即重新执行测试的子集。每当更改触发测试运行时，以下命令将执行“ SomeTestClass”测试类中的所有测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>gradle test --continuous --tests SomeTestClass</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:swift_test_reporting"><a class="anchor" href="#sec:swift_test_reporting"></a> <a class="link" href="#sec:swift_test_reporting">测试报告</a></h4>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.xctest.tasks.XCTest.html">XCTest</a>任务默认情况下会生成以下结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTML测试报告</p>
</li>
<li>
<p>XML测试结果的格式与Ant JUnit报告任务兼容-许多其他工具（例如CI服务器）都支持该格式</p>
</li>
<li>
<p>有效的二进制格式的结果<code>XCTest</code>生成其他格式的任务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在大多数情况下，您将使用标准HTML报告，该报告会自动包含您的结果<code>XCTest</code>任务。</p>
</div>
<div class="paragraph">
<p>还有一个独立的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.TestReport.html">TestReport</a>任务类型，可用于生成自定义HTML测试报告。它所需要的只是一个价值<code>destinationDir</code>以及您想要包含在报告中的测试结果。这是一个示例，可为所有子项目的单元测试生成组合报告：</p>
</div>
<div class="exampleblock">
<div class="title">示例463合并所有子项目的测试报告</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">xctest</span><span class="delimiter">'</span></span>

    xctest {
        binaries.configureEach {
            runTask.get().configure {
                <span class="comment">// Disable the test report for the individual test task</span>
                reports.html.enabled = <span class="predefined-constant">false</span>
            }
        }
    }
}

tasks.register(<span class="string"><span class="delimiter">'</span><span class="content">testReport</span><span class="delimiter">'</span></span>, TestReport) {
    destinationDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/reports/allTests</span><span class="delimiter">&quot;</span></span>)

    <span class="comment">// Include the results from the XCTest tasks in all subprojects</span>
    reportOn subprojects.collect {
        <span class="local-variable">it</span>.tasks.withType(XCTest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    apply(plugin = &quot;xctest&quot;)

    extensions.configure&lt;SwiftXCTestSuite&gt;() {
        binaries.configureEach {
            // Disable the test report for the individual test task
            runTask.get().reports.html.isEnabled = false
        }
    }
}

tasks.register&lt;TestReport&gt;(&quot;testReport&quot;) {
    destinationDir = file(&quot;$buildDir/reports/allTests&quot;)

    // Include the results from the `xcTest` task in all subprojects
    reportOn(subprojects.map { it.tasks.withType&lt;XCTest&gt;() })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您应该注意， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.TestReport.html">TestReport</a>类型组合了多个测试任务的结果，并且需要汇总单个测试类的结果。这意味着如果给定的测试类由多个测试任务执行，则测试报告将包含该类的执行，但是很难区分该类的各个执行及其输出。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="native_projects_using_the_software_model"><a class="anchor" href="#native_projects_using_the_software_model"></a> <a class="link" href="#native_projects_using_the_software_model">使用软件模型的本机项目</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="native_software"><a class="anchor" href="#native_software"></a> <a class="link" href="#native_software">构建本机软件</a></h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>该<a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model">软件模型</a>已淘汰，并且本章中提及的插件最终将被弃用并删除。我们建议新项目希望构建C ++应用程序和库，并使用较新的<a href="#">替换插件</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本机软件插件增加了对以C ++，C和其他语言编写的代码构建本机软件组件（例如可执行文件或共享库）的支持。虽然存在许多用于此软件开发空间的优秀构建工具，但Gradle为开发人员提供了商标功能和灵活性以及更传统的JVM开发空间中的依赖项管理实践。</p>
</div>
<div class="paragraph">
<p>本机软件插件使用Gradle <a href="#software_model">软件模型</a> 。</p>
</div>
<div class="sect3">
<h4 id="sec:native_features"><a class="anchor" href="#sec:native_features"></a> <a class="link" href="#sec:native_features">特征</a></h4>
<div class="paragraph">
<p>本机软件插件提供：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>支持在Windows，Linux，macOS和其他平台上构建本机库和应用程序。</p>
</li>
<li>
<p>支持多种源语言。</p>
</li>
<li>
<p>支持构建同一软件的不同变体，不同的体系结构，操作系统或任何目的。</p>
</li>
<li>
<p>增量并行编译，预编译头文件。</p>
</li>
<li>
<p>本机软件组件之间的依赖关系管理。</p>
</li>
<li>
<p>单元测试执行。</p>
</li>
<li>
<p>生成Visual Studio解决方案和项目文件。</p>
</li>
<li>
<p>与各种工具链的深度集成，包括发现已安装的工具链。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:supported_languages"><a class="anchor" href="#sec:supported_languages"></a> <a class="link" href="#sec:supported_languages">支持的语言</a></h4>
<div class="paragraph">
<p>当前支持以下源语言：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>C</p>
</li>
<li>
<p>C ++</p>
</li>
<li>
<p>目标C</p>
</li>
<li>
<p>目标C ++</p>
</li>
<li>
<p>部件</p>
</li>
<li>
<p>Windows资源</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="native-binaries:tool-chain-support"><a class="anchor" href="#native-binaries:tool-chain-support"></a> <a class="link" href="#native-binaries:tool-chain-support">工具链支持</a></h4>
<div class="paragraph">
<p>Gradle提供了使用不同工具链执行相同构建的功能。当您构建本机二进制文件时，Gradle会尝试找到您的计算机上安装的可以构建二进制文件的工具链。您可以精确调整其工作方式，有关详细信息，请参见<a href="#native_binaries:tool_chain">工具链支持</a> 。</p>
</div>
<div class="paragraph">
<p>支持以下工具链：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作系统</th>
<th class="tableblock halign-left valign-top">工具链</th>
<th class="tableblock halign-left valign-top">笔记</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">的Linux</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://gcc.gnu.org/">海湾合作委员会</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">的Linux</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://clang.llvm.org">铛</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">苹果系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">XCode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用与XCode捆绑在一起的Clang工具链。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">视窗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://visualstudio.microsoft.com/">Visual C ++</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows XP和更高版本，Visual C ++ 2010/2012/2013/2015/2017/2019。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">视窗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有<a href="http://cygwin.com">Cygwin 32和Cygwin 64的</a> <a href="http://gcc.gnu.org/">GCC</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows XP及更高版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">视窗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有<a href="http://www.mingw.org/">MinGW</a>和<a href="https://mingw-w64.org/doku.php">MinGW64的</a> <a href="http://gcc.gnu.org/">GCC</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows XP及更高版本。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>非正式地支持以下工具链。它们通常可以正常工作，但未经持续测试：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作系统</th>
<th class="tableblock halign-left valign-top">工具链</th>
<th class="tableblock halign-left valign-top">笔记</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">苹果系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Macports的<a href="http://gcc.gnu.org/">GCC</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">苹果系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自Macports的<a href="http://clang.llvm.org">Clang</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类UNIX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://gcc.gnu.org/">海湾合作委员会</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类UNIX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://clang.llvm.org">铛</a></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:tool_chain_installation"><a class="anchor" href="#sec:tool_chain_installation"></a> <a class="link" href="#sec:tool_chain_installation">工具链安装</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，如果您使用的是GCC，则即使您不是从C ++源代码构建，当前也需要安装对C ++的支持。在将来的Gradle版本中将删除此限制。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要构建本机软件，您将需要安装兼容的工具链：</p>
</div>
<div class="sect4">
<h5 id="sec:windows"><a class="anchor" href="#sec:windows"></a> <a class="link" href="#sec:windows">视窗</a></h5>
<div class="paragraph">
<p>要在Windows上构建，请安装兼容版本的Visual Studio。本机插件将发现Visual Studio安装并选择最新版本。无需弄乱环境变量或批处理脚本。在Cygwin Shell或Windows命令行中，此方法工作正常。</p>
</div>
<div class="paragraph">
<p>或者，您可以将Cygwin与GCC或MinGW一起安装。目前不支持Clang。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:macOS"><a class="anchor" href="#sec:macOS"></a> <a class="link" href="#sec:macOS">苹果系统</a></h5>
<div class="paragraph">
<p>要在macOS上构建，您应该安装XCode。本机插件将使用系统PATH发现XCode安装。</p>
</div>
<div class="paragraph">
<p>本机插件还可以与Macports捆绑的GCC和Clang一起使用。要使用Macports工具链之一，您需要使用<code>port select</code>命令并将Macports添加到系统PATH。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:linux"><a class="anchor" href="#sec:linux"></a> <a class="link" href="#sec:linux">的Linux</a></h5>
<div class="paragraph">
<p>要在Linux上构建，请安装兼容版本的GCC或Clang。本机插件将使用系统PATH发现GCC或Clang。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:native_software_model"><a class="anchor" href="#sec:native_software_model"></a> <a class="link" href="#sec:native_software_model">本机软件模型</a></h4>
<div class="paragraph">
<p>本机软件模型建立在基本Gradle <a href="#software_model_concepts">软件模型的</a>基础上。</p>
</div>
<div class="paragraph">
<p>要使用Gradle构建本机软件，您的项目应定义一个或多个<em>本机组件</em> 。每个组件代表Gradle应该构建的可执行文件或库。一个项目可以定义任意数量的组件。Gradle默认情况下不定义任何组件。</p>
</div>
<div class="paragraph">
<p>对于每个组件，Gradle定义了可用于构建组件的每种语言的<em>源集</em> 。源集本质上只是包含源文件的一组源目录。例如，当您应用<code>c</code>插件并定义一个名为<code>helloworld</code> ，默认情况下，Gradle将定义一个包含C源文件的源集。 <code>src/helloworld/c</code>目录。它将使用这些源文件来构建<code>helloworld</code>图书馆。这将在下面更详细地描述。</p>
</div>
<div class="paragraph">
<p>对于每个组件，Gradle都将一个或多个<em>二进制文件</em>定义为输出。要生成二进制文件，Gradle将获取为组件定义的源文件，将其编译为适合源语言的文件，然后将结果链接到二进制文件中。对于可执行组件，Gradle可以生成可执行二进制文件。对于库组件，Gradle可以生成静态库文件和共享库二进制文件。例如，当您定义一个名为<code>helloworld</code>并在Linux上构建，默认情况下，Gradle将产生<code>libhelloworld.so</code>和<code>libhelloworld.a</code>二进制文件。</p>
</div>
<div class="paragraph">
<p>在许多情况下，一个组件可以生成多个二进制文件。这些二进制文件可能会根据用于构建的工具链，提供的编译器/链接器标志，提供的依赖项或提供的其他源文件而有所不同。为组件生成的每个本机二进制文件称为“ <em>变体”</em> 。二进制变体将在下面详细讨论。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:parallel_compilation"><a class="anchor" href="#sec:parallel_compilation"></a> <a class="link" href="#sec:parallel_compilation">并行编译</a></h4>
<div class="paragraph">
<p>默认情况下，Gradle使用单个构建工作器池来同时编译和链接本机组件。无需特殊配置即可启用并发构建。</p>
</div>
<div class="paragraph">
<p>默认情况下，工作程序池大小由构建计算机上的可用处理器数确定（报告给构建JVM）。要明确设置工人数量，请使用<code>--max-workers</code>命令行选项或<code>org.gradle.workers.max</code>系统属性。通常，无需更改此设置的默认设置。</p>
</div>
<div class="paragraph">
<p>构建工作池在所有构建任务之间共享。这意味着使用<a href="#sec:parallel_execution">并行项目执行时</a> ，并发单个编译操作的最大数量不会增加。例如，如果构建机器具有4个处理核心，并且10个项目并行编译，那么Gradle将仅使用4个工人，而不是40个工人。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_a_library"><a class="anchor" href="#sec:building_a_library"></a> <a class="link" href="#sec:building_a_library">建立图书馆</a></h4>
<div class="paragraph">
<p>要构建静态或共享的本机库，请在<code>components</code>容器。以下示例定义了一个名为<code>hello</code> ：</p>
</div>
<div class="sect4">
<h5 id="example_defining_a_library_component"><a class="anchor" href="#example_defining_a_library_component"></a> <a class="link" href="#example_defining_a_library_component">示例：定义库组件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        hello(NativeLibrarySpec)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>库组件使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a>表示。每个库组件都可以产生至少一个共享库二进制文件（ <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/SharedLibraryBinarySpec.html">SharedLibraryBinarySpec</a> ）和至少一个静态库二进制文件（ <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/StaticLibraryBinarySpec.html">StaticLibraryBinarySpec</a> ）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:building_an_executable"><a class="anchor" href="#sec:building_an_executable"></a> <a class="link" href="#sec:building_an_executable">生成可执行文件</a></h4>
<div class="paragraph">
<p>要构建本机可执行文件，请在<code>components</code>容器。以下示例定义了一个名为<code>main</code> ：</p>
</div>
<div class="sect4">
<h5 id="example_defining_executable_components"><a class="anchor" href="#example_defining_executable_components"></a> <a class="link" href="#example_defining_executable_components">示例：定义可执行组件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        main(NativeExecutableSpec) {
            sources {
               c.lib <span class="key">library</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可执行组件使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableSpec.html">NativeExecutableSpec</a>表示。每个可执行组件可以产生至少一个可执行二进制文件（ <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableBinarySpec.html">NativeExecutableBinarySpec</a> ）。</p>
</div>
<div class="paragraph">
<p>对于定义的每个组件，Gradle都会添加一个具有相同名称的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/FunctionalSourceSet.html">FunctionalSourceSet</a> 。这些功能源集中的每一个都将包含项目所支持的每种语言的特定于语言的源集。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:dependents"><a class="anchor" href="#sec:dependents"></a> <a class="link" href="#sec:dependents">聚集或建立家属</a></h4>
<div class="paragraph">
<p>有时，您可能需要<em>组装</em> （编译和链接）或<em>构建</em> （编译，链接和测试）组件或二进制文件及其<em>依赖项</em> （取决于组件或二进制文件的事物）。本机软件模型提供了启用此功能的任务。首先， <em>从属组件</em>报告提供有关每个组件之间关系的见解。其次， <em>构建和组装依赖项</em>任务使您可以一步组装或构建组件及其依赖项。</p>
</div>
<div class="paragraph">
<p>在以下示例中，构建文件定义<code>OpenSSL</code>作为...的依赖<code>libUtil</code>和<code>libUtil</code>作为...的依赖<code>LinuxApp</code>和<code>WindowsApp</code> 。测试套件的处理方式类似。依赖可以被视为反向依赖。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/nativeDependents.png" alt="nativeDependents">
</div>
<div class="title">图29。相关组件示例</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>向后跟踪依赖关系，您可以看到<code>LinuxApp</code>和<code>WindowsApp</code> <em>依赖</em>于<code>libUtil</code> 。什么时候<code>libUtil</code>更改后，Gradle将需要重新编译或重新链接<code>LinuxApp</code>和<code>WindowsApp</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><em>组装</em>组件的从属时，将编译和链接该组件及其所有从属，包括任何测试套件二进制文件。Gradle的最新检查仅在发生更改时才用于编译或链接。例如，如果您以不影响项目标头的方式更改了源文件，则Gradle将能够跳过相关组件的编译，而只需重新链接新库即可。组装组件时不会运行测试。</p>
</div>
<div class="paragraph">
<p>在<em>构建</em>组件的从属组件时，将编译，链接<em>和检查</em>该组件及其所有从属二进制文件。检查组件意味着运行任何<a href="#sec:check_tasks">检查任务，</a>包括执行任何测试套件，因此在构建组件时<em>将</em>运行测试。</p>
</div>
<div class="paragraph">
<p>在以下各节中，我们将演示<code>assembleDependents*</code> ， <code>buildDependents*</code>和<code>dependentComponents</code>具有包含CUnit测试套件的示例构建的任务。该示例的构建脚本如下：</p>
</div>
<div class="sect4">
<h5 id="example_sample_build"><a class="anchor" href="#example_sample_build"></a> <a class="link" href="#example_sample_build">示例：示例构建</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>
apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">cunit-test-suite</span><span class="delimiter">'</span></span>

model {
    flavors {
        passing
        failing
    }
    platforms {
        x86 {
            <span class="keyword">if</span> (operatingSystem.macOsX) {
                architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">x64</span><span class="delimiter">&quot;</span></span>
            } <span class="keyword">else</span> {
                architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
    components {
        operators(NativeLibrarySpec) {
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
        }
    }
    testSuites {
        operatorsTest(CUnitTestSuiteSpec) {
            testing <span class="error">$</span>.components.operators
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/native-binaries/cunit</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:dependents_report"><a class="anchor" href="#sec:dependents_report"></a> <a class="link" href="#sec:dependents_report">相关组件报告</a></h5>
<div class="paragraph">
<p>Gradle提供了一个可以从命令行运行的报告，该报告显示了项目中的组件图以及依赖于它们的组件。以下是运行示例<code>gradle dependentComponents</code>在示例项目上：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_dependent_components_report"><a class="anchor" href="#example_dependent_components_report"></a> <a class="link" href="#example_dependent_components_report">示例：相关组件报告</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle dependentComponents</code></strong></div>
<div class="content">
<pre>&gt; gradle dependentComponents

&gt; Task :dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary

Some test suites were not shown, use --test-suites or --all to show them.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.reporting.dependents.DependentComponentsReport.html">DependentComponentsReport</a> API文档。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，不可生成的二进制文件和测试套件从报告中隐藏。的<code>dependentComponents</code>任务提供了一些选项，使您可以使用<code>--all</code>选项：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_dependent_components_report_2"><a class="anchor" href="#example_dependent_components_report_2"></a> <a class="link" href="#example_dependent_components_report_2">示例：相关组件报告</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle dependentComponents --all</code></strong></div>
<div class="content">
<pre>&gt; gradle dependentComponents --all

&gt; Task :dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
|    \--- operatorsTest:failingCUnitExe (t)
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary
     \--- operatorsTest:passingCUnitExe (t)

operatorsTest - Components that depend on Cunit test suite 'operatorsTest'
+--- operatorsTest:failingCUnitExe (t)
\--- operatorsTest:passingCUnitExe (t)

(t) - Test suite binary

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>这是针对<code>operators</code>组件，显示其所有二进制文件的依赖项：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_report_of_components_that_depends_on_the_operators_component"><a class="anchor" href="#example_report_of_components_that_depends_on_the_operators_component"></a> <a class="link" href="#example_report_of_components_that_depends_on_the_operators_component">示例：取决于操作员组件的组件报告</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle dependentComponents --component operators</code></strong></div>
<div class="content">
<pre>&gt; gradle dependentComponents --component operators

&gt; Task :dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary

Some test suites were not shown, use --test-suites or --all to show them.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>这是针对<code>operators</code>组件，显示其所有二进制文件的依赖项，包括测试套件：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_report_of_components_that_depends_on_the_operators_component_including_test_suites"><a class="anchor" href="#example_report_of_components_that_depends_on_the_operators_component_including_test_suites"></a> <a class="link" href="#example_report_of_components_that_depends_on_the_operators_component_including_test_suites">示例：取决于操作员组件的组件的报告，包括测试套件</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle dependentComponents --test-suites --component operators</code></strong></div>
<div class="content">
<pre>&gt; gradle dependentComponents --test-suites --component operators

&gt; Task :dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
|    \--- operatorsTest:failingCUnitExe (t)
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary
     \--- operatorsTest:passingCUnitExe (t)

(t) - Test suite binary

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:assemble_dependents"><a class="anchor" href="#sec:assemble_dependents"></a> <a class="link" href="#sec:assemble_dependents">集合家属</a></h5>
<div class="paragraph">
<p>对于每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a> ，Gradle将创建一个名为<code>assembleDependents<em>${component.name}${binary.variant}</em></code> <em>汇编</em> （编译和链接）二进制文件及其所有相关二进制文件。</p>
</div>
<div class="paragraph">
<p>对于每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeComponentSpec.html">NativeComponentSpec</a> ，Gradle将创建一个名为<code>assembleDependents<em>${component.name}</em></code> <em>汇编</em>组件的所有二进制文件及其所有从属二进制文件。</p>
</div>
<div class="paragraph">
<p>例如，要组装“ operators”组件的“ static”库二进制文件的“ passing”风格的依赖项，您可以运行<code>assembleDependentsOperatorsPassingStaticLibrary</code>任务：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_assemble_components_that_depends_on_the_passingstatic_binary_of_the_operators_component"><a class="anchor" href="#example_assemble_components_that_depends_on_the_passingstatic_binary_of_the_operators_component"></a> <a class="link" href="#example_assemble_components_that_depends_on_the_passingstatic_binary_of_the_operators_component">示例：组装依赖于运算符组件的传递/静态二进制文件的组件</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle assembleDependentsOperatorsPassingStaticLibrary --max-workers=1</code></strong></div>
<div class="content">
<pre>&gt; gradle assembleDependentsOperatorsPassingStaticLibrary --max-workers=1
&gt; Task :compileOperatorsTestPassingCUnitExeOperatorsC
&gt; Task :operatorsTestCUnitLauncher
&gt; Task :compileOperatorsTestPassingCUnitExeOperatorsTestC
&gt; Task :compileOperatorsTestPassingCUnitExeOperatorsTestCunitLauncher
&gt; Task :linkOperatorsTestPassingCUnitExe
&gt; Task :operatorsTestPassingCUnitExe
&gt; Task :assembleDependentsOperatorsTestPassingCUnitExe
&gt; Task :compileOperatorsPassingStaticLibraryOperatorsC
&gt; Task :createOperatorsPassingStaticLibrary
&gt; Task :operatorsPassingStaticLibrary
&gt; Task :assembleDependentsOperatorsPassingStaticLibrary

BUILD SUCCESSFUL in 0s
7 actionable tasks: 7 executed</pre>
</div>
</div>
<div class="paragraph">
<p>在上面的输出中，目标二进制文件以及依赖于它的测试套件二进制文件被组装。</p>
</div>
<div class="paragraph">
<p>您还可以使用相应的组件任务集合<em>所有</em> （/即其所有的二进制文件的变种）组件的家属，例如<code>assembleDependentsOperators</code> 。如果构建类型，风味和平台有很多组合，并且要组装所有这些，这将很有用。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:build_dependents"><a class="anchor" href="#sec:build_dependents"></a> <a class="link" href="#sec:build_dependents">建筑物家属</a></h5>
<div class="paragraph">
<p>对于每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a> ，Gradle将创建一个名为<code>buildDependents<em>${component.name}${binary.variant}</em></code> <em>生成</em> （编译，链接和检查）二进制文件及其所有相关二进制文件。</p>
</div>
<div class="paragraph">
<p>对于每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeComponentSpec.html">NativeComponentSpec</a> ，Gradle将创建一个名为<code>buildDependents<em>${component.name}</em></code>它将<em>构建</em>组件的所有二进制文件及其所有从属二进制文件。</p>
</div>
<div class="paragraph">
<p>例如，要构建“操作员”组件的“静态”库二进制文件的“通过”风格的依赖项，您可以运行<code>buildDependentsOperatorsPassingStaticLibrary</code>任务：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_build_components_that_depends_on_the_passingstatic_binary_of_the_operators_component"><a class="anchor" href="#example_build_components_that_depends_on_the_passingstatic_binary_of_the_operators_component"></a> <a class="link" href="#example_build_components_that_depends_on_the_passingstatic_binary_of_the_operators_component">示例：构建依赖于运算符组件的传递/静态二进制文件的组件</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle buildDependentsOperatorsPassingStaticLibrary --max-workers=1</code></strong></div>
<div class="content">
<pre>&gt; gradle buildDependentsOperatorsPassingStaticLibrary --max-workers=1
&gt; Task :compileOperatorsTestPassingCUnitExeOperatorsC
&gt; Task :operatorsTestCUnitLauncher
&gt; Task :compileOperatorsTestPassingCUnitExeOperatorsTestC
&gt; Task :compileOperatorsTestPassingCUnitExeOperatorsTestCunitLauncher
&gt; Task :linkOperatorsTestPassingCUnitExe
&gt; Task :operatorsTestPassingCUnitExe
&gt; Task :installOperatorsTestPassingCUnitExe
&gt; Task :runOperatorsTestPassingCUnitExe
&gt; Task :checkOperatorsTestPassingCUnitExe
&gt; Task :buildDependentsOperatorsTestPassingCUnitExe
&gt; Task :compileOperatorsPassingStaticLibraryOperatorsC
&gt; Task :createOperatorsPassingStaticLibrary
&gt; Task :operatorsPassingStaticLibrary
&gt; Task :buildDependentsOperatorsPassingStaticLibrary

BUILD SUCCESSFUL in 0s
9 actionable tasks: 9 executed</pre>
</div>
</div>
<div class="paragraph">
<p>在上面的输出中，构建了目标二进制文件以及取决于目标二进制文件的测试套件二进制文件，并且测试套件已运行。</p>
</div>
<div class="paragraph">
<p>您也可以建立<em>所有</em>使用相应的组件任务（/即其所有的二进制文件的变体）的成分，例如受养人<code>buildDependentsOperators</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:native_tasks"><a class="anchor" href="#sec:native_tasks"></a> <a class="link" href="#sec:native_tasks">任务</a></h4>
<div class="paragraph">
<p>对于可通过构建生成的每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a> ，将构造一个可用于创建该二进制文件的<em>生命周期任务</em> ，以及一组其他实际执行编译，链接或组装二进制文件的任务。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><em>${component.name}</em>Executable</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">组件类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableSpec.html">NativeExecutableSpec</a></p>
</dd>
<dt class="hdlist1">本机二进制类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableBinarySpec.html">NativeExecutableBinarySpec</a></p>
</dd>
<dt class="hdlist1">创建的二进制文件的位置</dt>
<dd>
<p><code><em>${project.buildDir}</em>/exe/<em>${component.name}</em>/<em>${component.name}</em></code></p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><em>${component.name}</em>SharedLibrary</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">组件类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a></p>
</dd>
<dt class="hdlist1">本机二进制类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/SharedLibraryBinarySpec.html">共享库二进制规范</a></p>
</dd>
<dt class="hdlist1">创建的二进制文件的位置</dt>
<dd>
<p><code><em>${project.buildDir}</em>/libs/<em>${component.name}</em>/shared/lib<em>${component.name}</em>.so</code></p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code><em>${component.name}</em>StaticLibrary</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">组件类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a></p>
</dd>
<dt class="hdlist1">本机二进制类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/StaticLibraryBinarySpec.html">StaticLibraryBinarySpec</a></p>
</dd>
<dt class="hdlist1">创建的二进制文件的位置</dt>
<dd>
<p><code><em>${project.buildDir}</em>/libs/<em>${component.name}</em>/static/<em>${component.name}</em>.a</code></p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="sec:check_tasks"><a class="anchor" href="#sec:check_tasks"></a> <a class="link" href="#sec:check_tasks">检查任务</a></h5>
<div class="paragraph">
<p>对于可通过构建生成的每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a> ，将构造一个<em>检查任务</em> ，该<em>任务</em>可用于汇编和检查该二进制文件。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>check<em>${component.name}</em>Executable</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">组件类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableSpec.html">NativeExecutableSpec</a></p>
</dd>
<dt class="hdlist1">本机二进制类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableBinarySpec.html">NativeExecutableBinarySpec</a></p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>check<em>${component.name}</em>SharedLibrary</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">组件类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a></p>
</dd>
<dt class="hdlist1">本机二进制类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/SharedLibraryBinarySpec.html">共享库二进制规范</a></p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>check<em>${component.name}</em>StaticLibrary</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">组件类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a></p>
</dd>
<dt class="hdlist1">本机二进制类型</dt>
<dd>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/SharedLibraryBinarySpec.html">共享库二进制规范</a></p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>内建<code>check</code>任务取决于项目中所有二进制文件的<em>检查任务</em> 。没有<a href="#native_binaries:cunit">CUnit</a>或<a href="#native_binaries:google_test">GoogleTest</a>插件，二进制检查任务仅取决于组装二进制文件的<em>生命周期任务</em> ，请参阅本<a href="#sec:native_tasks">机任务</a> 。</p>
</div>
<div class="paragraph">
<p>应用<a href="#native_binaries:cunit">CUnit</a>或<a href="#native_binaries:google_test">GoogleTest</a>插件时，执行组件测试套件的任务会自动连接到相应的<em>check任务</em> 。</p>
</div>
<div class="paragraph">
<p>您还可以添加自定义检查任务，如下所示：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_adding_a_custom_check_task"><a class="anchor" href="#example_adding_a_custom_check_task"></a> <a class="link" href="#example_adding_a_custom_check_task">示例：添加自定义检查任务</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">cpp</span><span class="delimiter">&quot;</span></span>
<span class="comment">// You don't need to apply the plugin below if you're already using CUnit or GoogleTest support</span>
apply <span class="key">plugin</span>: TestingModelBasePlugin

task myCustomCheck {
    doLast {
        println <span class="string"><span class="delimiter">'</span><span class="content">Executing my custom check</span><span class="delimiter">'</span></span>
    }
}

model {
    components {
        hello(NativeLibrarySpec) {
            binaries.all {
                <span class="comment">// Register our custom check task to all binaries of this component</span>
                checkedBy <span class="error">$</span>.tasks.myCustomCheck
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/native-binaries/custom-check</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在，跑步<code>check</code>或任何<em>检查任务</em> <code>hello</code>二进制文件将运行自定义检查任务：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_running_checks_for_a_given_binary"><a class="anchor" href="#example_running_checks_for_a_given_binary"></a> <a class="link" href="#example_running_checks_for_a_given_binary">示例：对给定的二进制文件运行检查</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle checkHelloSharedLibrary</code></strong></div>
<div class="content">
<pre>&gt; gradle checkHelloSharedLibrary

&gt; Task :myCustomCheck
Executing my custom check

&gt; Task :checkHelloSharedLibrary

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:working_with_shared_libraries"><a class="anchor" href="#sec:working_with_shared_libraries"></a> <a class="link" href="#sec:working_with_shared_libraries">使用共享库</a></h5>
<div class="paragraph">
<p>对于产生的每个可执行二进制文件， <code>cpp</code>插件提供了<code>install${binary.name}</code>任务，它将创建可执行文件的开发安装以及所需的共享库。这使您可以运行可执行文件，而无需在共享库的最终位置安装共享库。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:finding_out_more_about_your_project"><a class="anchor" href="#sec:finding_out_more_about_your_project"></a> <a class="link" href="#sec:finding_out_more_about_your_project">详细了解您的项目</a></h4>
<div class="paragraph">
<p>Gradle提供了一个可以从命令行运行的报告，该报告显示了有关项目生成的组件和二进制文件的一些详细信息。要使用此报告，只需运行<code>gradle components</code> 。以下是为其中一个示例项目运行此报告的示例：</p>
</div>
<div class="sect4">
<h5 id="example_the_components_report"><a class="anchor" href="#example_the_components_report"></a> <a class="link" href="#example_the_components_report">示例：组件报告</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle components</code></strong></div>
<div class="content">
<pre>&gt; gradle components

&gt; Task :components

------------------------------------------------------------
Root project
------------------------------------------------------------

Native library 'hello'
----------------------

Source sets
    C++ source 'hello:cpp'
        srcDir: src/hello/cpp

Binaries
    Shared library 'hello:sharedLibrary'
        build using task: :helloSharedLibrary
        build type: build type 'debug'
        flavor: flavor 'default'
        target platform: platform 'current'
        tool chain: Tool chain 'clang' (Clang)
        shared library file: build/libs/hello/shared/libhello.dylib
    Static library 'hello:staticLibrary'
        build using task: :helloStaticLibrary
        build type: build type 'debug'
        flavor: flavor 'default'
        target platform: platform 'current'
        tool chain: Tool chain 'clang' (Clang)
        static library file: build/libs/hello/static/libhello.a

Native executable 'main'
------------------------

Source sets
    C++ source 'main:cpp'
        srcDir: src/main/cpp

Binaries
    Executable 'main:executable'
        build using task: :mainExecutable
        install using task: :installMainExecutable
        build type: build type 'debug'
        flavor: flavor 'default'
        target platform: platform 'current'
        tool chain: Tool chain 'clang' (Clang)
        executable file: build/exe/main/main

Note: currently not all plugins register their components, so some components may not be visible here.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:languages"><a class="anchor" href="#native_binaries:languages"></a> <a class="link" href="#native_binaries:languages">语言支持</a></h4>
<div class="paragraph">
<p>目前，Gradle支持从下面列出的源语言的任何组合构建本机软件。本机二进制项目将包含一个或多个命名为<code>FunctionalSourceSet</code>实例（例如“ main”，“ test”等），每个实例都可以包含<code>LanguageSourceSet</code>包含源文件，每种语言一个。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>C</p>
</li>
<li>
<p>C ++</p>
</li>
<li>
<p>目标C</p>
</li>
<li>
<p>目标C ++</p>
</li>
<li>
<p>部件</p>
</li>
<li>
<p>Windows资源</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="sec:cpp_sources"><a class="anchor" href="#sec:cpp_sources"></a> <a class="link" href="#sec:cpp_sources">C ++来源</a></h5>
<div class="paragraph">
<p>通过以下方式提供C ++语言支持： <code>'cpp'</code>插入。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_the_cpp_plugin"><a class="anchor" href="#example_the_cpp_plugin"></a> <a class="link" href="#example_the_cpp_plugin">示例：“ cpp”插件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">cpp</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.CppSourceSet.html">CppSourceSet</a>提供本机二进制文件中包含的C ++源，它定义了一组C ++源文件和（可选）一组导出的头文件（用于库）。默认情况下，对于任何命名组件， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.CppSourceSet.html">CppSourceSet都</a>包含<code>.cpp</code>源文件在<code>src/${name}/cpp</code>和中的头文件<code>src/${name}/headers</code> 。</p>
</div>
<div class="paragraph">
<p>而<code>cpp</code>插件为每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.CppSourceSet.html">CppSourceSet</a>定义了这些默认位置，可以扩展或覆盖这些默认值以允许不同的项目布局。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_c_source_set"><a class="anchor" href="#example_c_source_set"></a> <a class="link" href="#example_c_source_set">示例：C ++源集</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sources {
    cpp {
        source {
            srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/source</span><span class="delimiter">&quot;</span></span>
            include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.cpp</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于名为“ main”的库，头文件位于<code>src/main/headers</code>被视为“公共”或“导出”标头。不应导出的头文件应放置在<code>src/main/cpp</code>目录（尽管要注意，此类头文件应始终以相对于包含它们的文件的方式进行引用）。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:c_sources"><a class="anchor" href="#sec:c_sources"></a> <a class="link" href="#sec:c_sources">C源</a></h5>
<div class="paragraph">
<p>通过以下方式提供C语言支持<code>'c'</code>插入。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_the_c_plugin"><a class="anchor" href="#example_the_c_plugin"></a> <a class="link" href="#example_the_c_plugin">示例：“ c”插件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.c.CSourceSet.html">CSourceSet</a>提供要包含在本机二进制文件中的C源代码，该源定义了一组C源文件和（可选）一组导出的头文件（用于库）。默认情况下，对于任何命名组件， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.c.CSourceSet.html">CSourceSet都</a>包含<code>.c</code>源文件在<code>src/${name}/c</code>和中的头文件<code>src/${name}/headers</code> 。</p>
</div>
<div class="paragraph">
<p>而<code>c</code>插件为每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.c.CSourceSet.html">CSourceSet</a>定义了这些默认位置，可以扩展或覆盖这些默认值以允许不同的项目布局。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_c_source_set_2"><a class="anchor" href="#example_c_source_set_2"></a> <a class="link" href="#example_c_source_set_2">示例：C源集</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sources {
    c {
        source {
            srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/source</span><span class="delimiter">&quot;</span></span>
            include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.c</span><span class="delimiter">&quot;</span></span>
        }
        exportedHeaders {
            srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/include</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于名为“ main”的库，头文件位于<code>src/main/headers</code>被视为“公共”或“导出”标头。不应导出的头文件应放置在<code>src/main/c</code>目录（尽管要注意，此类头文件应始终以相对于包含它们的文件的方式进行引用）。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:assembler_sources"><a class="anchor" href="#sec:assembler_sources"></a> <a class="link" href="#sec:assembler_sources">汇编程序源</a></h5>
<div class="paragraph">
<p>汇编语言支持通过以下方式提供： <code>'assembler'</code>插入。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_the_assembler_plugin"><a class="anchor" href="#example_the_assembler_plugin"></a> <a class="link" href="#example_the_assembler_plugin">示例：“汇编程序”插件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">assembler</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过AssemblerSourceSet提供要包含在本机二进制文件中的汇编器源，该<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.assembler.AssemblerSourceSet.html">汇编器</a>定义了一组汇编器源文件。默认情况下，对于任何命名组件， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.assembler.AssemblerSourceSet.html">AssemblerSourceSet都</a>包含<code>.s</code>下的源文件<code>src/${name}/asm</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:objectivec_sources"><a class="anchor" href="#sec:objectivec_sources"></a> <a class="link" href="#sec:objectivec_sources">Objective-C资料来源</a></h5>
<div class="paragraph">
<p>通过以下方式提供Objective-C语言支持： <code>'objective-c'</code>插入。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_the_objective_c_plugin"><a class="anchor" href="#example_the_objective_c_plugin"></a> <a class="link" href="#example_the_objective_c_plugin">示例：“ objective-c”插件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">objective-c</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html">ObjectiveCSourceSet</a>提供要包含在本机二进制文件中的Objective-C源，它定义了一组Objective-C源文件。默认情况下，对于任何命名组件， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html">ObjectiveCSourceSet都</a>包含<code>.m</code>下的源文件<code>src/${name}/objectiveC</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:objectivecpp_sources"><a class="anchor" href="#sec:objectivecpp_sources"></a> <a class="link" href="#sec:objectivecpp_sources">Objective-C ++来源</a></h5>
<div class="paragraph">
<p>通过以下方式提供Objective-C ++语言支持： <code>'objective-cpp'</code>插入。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_the_objective_cpp_plugin"><a class="anchor" href="#example_the_objective_cpp_plugin"></a> <a class="link" href="#example_the_objective_cpp_plugin">示例：“ objective-cpp”插件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">objective-cpp</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html">ObjectiveCppSourceSet</a>提供要包含在本机二进制文件中的Objective-C ++源，它定义了一组Objective-C ++源文件。默认情况下，对于任何命名组件， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html">ObjectiveCppSourceSet都</a>包含<code>.mm</code>下的源文件<code>src/${name}/objectiveCpp</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_the_compiler_assembler_and_linker"><a class="anchor" href="#sec:configuring_the_compiler_assembler_and_linker"></a> <a class="link" href="#sec:configuring_the_compiler_assembler_and_linker">配置编译器，汇编器和链接器</a></h4>
<div class="paragraph">
<p>每个要生成的二进制文件都与一组编译器和链接器设置相关联，其中包括命令行参数以及宏定义。这些设置可以应用于所有二进制文件，单个二进制文件，也可以根据某些条件选择性地应用于一组二进制文件。</p>
</div>
<div class="sect4">
<h5 id="example_settings_that_apply_to_all_binaries"><a class="anchor" href="#example_settings_that_apply_to_all_binaries"></a> <a class="link" href="#example_settings_that_apply_to_all_binaries">示例：适用于所有二进制文件的设置</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    binaries {
        all {
            <span class="comment">// Define a preprocessor macro for every binary</span>
            cppCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">NDEBUG</span><span class="delimiter">&quot;</span></span>

            <span class="comment">// Define toolchain-specific compiler and linker options</span>
            <span class="keyword">if</span> (toolChain <span class="keyword">in</span> Gcc) {
                cppCompiler.args <span class="string"><span class="delimiter">&quot;</span><span class="content">-O2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">-fno-access-control</span><span class="delimiter">&quot;</span></span>
                linker.args <span class="string"><span class="delimiter">&quot;</span><span class="content">-Xlinker</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">-S</span><span class="delimiter">&quot;</span></span>
            }
            <span class="keyword">if</span> (toolChain <span class="keyword">in</span> VisualCpp) {
                cppCompiler.args <span class="string"><span class="delimiter">&quot;</span><span class="content">/Zi</span><span class="delimiter">&quot;</span></span>
                linker.args <span class="string"><span class="delimiter">&quot;</span><span class="content">/DEBUG</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个二进制文件都与一个特定的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html">NativeToolChain</a>关联，从而可以基于该值来确定设置。</p>
</div>
<div class="paragraph">
<p>将设置应用于特定类型的所有二进制文件很容易：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_settings_that_apply_to_all_shared_libraries"><a class="anchor" href="#example_settings_that_apply_to_all_shared_libraries"></a> <a class="link" href="#example_settings_that_apply_to_all_shared_libraries">示例：适用于所有共享库的设置</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// For any shared library binaries built with Visual C++,</span>
<span class="comment">// define the DLL_EXPORT macro</span>
model {
    binaries {
        withType(SharedLibraryBinarySpec) {
            <span class="keyword">if</span> (toolChain <span class="keyword">in</span> VisualCpp) {
                cCompiler.args <span class="string"><span class="delimiter">&quot;</span><span class="content">/Zi</span><span class="delimiter">&quot;</span></span>
                cCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">DLL_EXPORT</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，可以指定适用于为特定文件生成的所有二进制文件的设置<code>executable</code>要么<code>library</code>零件：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_settings_that_apply_to_all_binaries_produced_for_the_main_executable_component"><a class="anchor" href="#example_settings_that_apply_to_all_binaries_produced_for_the_main_executable_component"></a> <a class="link" href="#example_settings_that_apply_to_all_binaries_produced_for_the_main_executable_component">示例：适用于为“主要”可执行组件生成的所有二进制文件的设置</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        main(NativeExecutableSpec) {
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
            binaries.all {
                <span class="keyword">if</span> (toolChain <span class="keyword">in</span> VisualCpp) {
                    sources {
                        platformAsm(AssemblerSourceSet) {
                            source.srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/main/asm_i386_masm</span><span class="delimiter">&quot;</span></span>
                        }
                    }
                    assembler.args <span class="string"><span class="delimiter">&quot;</span><span class="content">/Zi</span><span class="delimiter">&quot;</span></span>
                } <span class="keyword">else</span> {
                    sources {
                        platformAsm(AssemblerSourceSet) {
                            source.srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/main/asm_i386_gcc</span><span class="delimiter">&quot;</span></span>
                        }
                    }
                    assembler.args <span class="string"><span class="delimiter">&quot;</span><span class="content">-g</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例将提供的配置应用于所有<code>executable</code>二进制文件。</p>
</div>
<div class="paragraph">
<p>同样，可以将设置指定为针对特定类型组件的二进制文件：例如，主库组件的所有共享库。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_settings_that_apply_only_to_shared_libraries_produced_for_the_main_library_component"><a class="anchor" href="#example_settings_that_apply_only_to_shared_libraries_produced_for_the_main_library_component"></a> <a class="link" href="#example_settings_that_apply_only_to_shared_libraries_produced_for_the_main_library_component">示例：仅适用于为“主”库组件生成的共享库的设置</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        main(NativeLibrarySpec) {
            binaries.withType(SharedLibraryBinarySpec) {
                <span class="comment">// Define a preprocessor macro that only applies to shared libraries</span>
                cppCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">DLL_EXPORT</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:windows-resources"><a class="anchor" href="#native_binaries:windows-resources"></a> <a class="link" href="#native_binaries:windows-resources">Windows资源</a></h4>
<div class="paragraph">
<p>使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html">VisualCpp</a>工具链时，Gradle可以编译Window Resource（ <code>rc</code> ）文件并将其链接到本地二进制文件中。此功能由<code>'windows-resources'</code>插入。</p>
</div>
<div class="sect4">
<h5 id="example_the_windows_resources_plugin"><a class="anchor" href="#example_the_windows_resources_plugin"></a> <a class="link" href="#example_the_windows_resources_plugin">示例：“ windows-resources”插件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">windows-resources</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.rc.WindowsResourceSet.html">WindowsResourceSet</a>提供本机二进制文件中包含的Windows资源，该资源定义了一组Windows资源源文件。默认情况下，对于任何命名的组件， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.rc.WindowsResourceSet.html">WindowsResourceSet都</a>包含<code>.rc</code>下的源文件<code>src/${name}/rc</code> 。</p>
</div>
<div class="paragraph">
<p>与其他源类型一样，您可以配置应包含在二进制文件中的Windows资源的位置。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configuring_the_location_of_windows_resource_sources"><a class="anchor" href="#example_configuring_the_location_of_windows_resource_sources"></a> <a class="link" href="#example_configuring_the_location_of_windows_resource_sources">示例：配置Windows资源源的位置</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build-resource-only-dll.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sources {
    rc {
        source {
            srcDirs <span class="string"><span class="delimiter">&quot;</span><span class="content">src/hello/rc</span><span class="delimiter">&quot;</span></span>
        }
        exportedHeaders {
            srcDirs <span class="string"><span class="delimiter">&quot;</span><span class="content">src/hello/headers</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过不提供其他语言源的Windows资源源来构造纯资源库，并根据需要配置链接器：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_building_a_resource_only_dll"><a class="anchor" href="#example_building_a_resource_only_dll"></a> <a class="link" href="#example_building_a_resource_only_dll">示例：构建仅资源的dll</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build-resource-only-dll.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        helloRes(NativeLibrarySpec) {
            binaries.all {
                rcCompiler.args <span class="string"><span class="delimiter">&quot;</span><span class="content">/v</span><span class="delimiter">&quot;</span></span>
                linker.args <span class="string"><span class="delimiter">&quot;</span><span class="content">/noentry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/machine:x86</span><span class="delimiter">&quot;</span></span>
            }
            sources {
                rc {
                    source {
                        srcDirs <span class="string"><span class="delimiter">&quot;</span><span class="content">src/hello/rc</span><span class="delimiter">&quot;</span></span>
                    }
                    exportedHeaders {
                        srcDirs <span class="string"><span class="delimiter">&quot;</span><span class="content">src/hello/headers</span><span class="delimiter">&quot;</span></span>
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例还演示了将额外的命令行参数传递给资源编译器的机制。的<code>rcCompiler</code>扩展名是<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/PreprocessingTool.html">PreprocessingTool</a>类型。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:library_dependencies"><a class="anchor" href="#sec:library_dependencies"></a> <a class="link" href="#sec:library_dependencies">图书馆依赖</a></h4>
<div class="paragraph">
<p>本机组件的依赖性是导出头文件的二进制库。头文件在编译期间使用，而编译后的二进制依赖项在链接和执行期间使用。头文件应组织到子目录中，以防止通用名称的头发生冲突。例如，如果您的<code>mylib</code>项目有一个<code>logging.h</code>标头，如果您将其包含为以下内容，则会减少使用错误标头的可能性<code>"mylib/logging.h"</code>代替<code>"logging.h"</code> 。</p>
</div>
<div class="sect4">
<h5 id="sec:dependencies_within_the_same_project"><a class="anchor" href="#sec:dependencies_within_the_same_project"></a> <a class="link" href="#sec:dependencies_within_the_same_project">同一项目中的依赖项</a></h5>
<div class="paragraph">
<p>一组源可能取决于同一项目中另一个二进制组件提供的头文件。一个常见的示例是使用由单独的本机库组件提供的功能的本机可执行组件。</p>
</div>
<div class="paragraph">
<p>可以将此类库依赖项添加到与<code>executable</code>零件：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_providing_a_library_dependency_to_the_source_set"><a class="anchor" href="#example_providing_a_library_dependency_to_the_source_set"></a> <a class="link" href="#example_providing_a_library_dependency_to_the_source_set">示例：向源集提供库依赖项</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sources {
    cpp {
        lib <span class="key">library</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以将库依赖项直接提供给<code>NativeExecutableBinarySpec</code>为了<code>executable</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_providing_a_library_dependency_to_the_binary"><a class="anchor" href="#example_providing_a_library_dependency_to_the_binary"></a> <a class="link" href="#example_providing_a_library_dependency_to_the_binary">示例：为二进制文件提供库依赖</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        hello(NativeLibrarySpec) {
            sources {
                c {
                    source {
                        srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/source</span><span class="delimiter">&quot;</span></span>
                        include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.c</span><span class="delimiter">&quot;</span></span>
                    }
                    exportedHeaders {
                        srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/include</span><span class="delimiter">&quot;</span></span>
                    }
                }
            }
        }
        main(NativeExecutableSpec) {
            sources {
                cpp {
                    source {
                        srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/source</span><span class="delimiter">&quot;</span></span>
                        include <span class="string"><span class="delimiter">&quot;</span><span class="content">**/*.cpp</span><span class="delimiter">&quot;</span></span>
                    }
                }
            }
            binaries.all {
                <span class="comment">// Each executable binary produced uses the 'hello' static library binary</span>
                lib <span class="key">library</span>: <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>, <span class="key">linkage</span>: <span class="string"><span class="delimiter">'</span><span class="content">static</span><span class="delimiter">'</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:project_dependencies"><a class="anchor" href="#sec:project_dependencies"></a> <a class="link" href="#sec:project_dependencies">项目依赖</a></h5>
<div class="paragraph">
<p>对于在其他Gradle项目中生产的组件，表示法相似。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_declaring_project_dependencies"><a class="anchor" href="#example_declaring_project_dependencies"></a> <a class="link" href="#example_declaring_project_dependencies">示例：声明项目依赖项</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:lib</span><span class="delimiter">&quot;</span></span>) {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">cpp</span><span class="delimiter">&quot;</span></span>
    model {
        components {
            main(NativeLibrarySpec)
        }

        <span class="comment">// For any shared library binaries built with Visual C++,</span>
        <span class="comment">// define the DLL_EXPORT macro</span>
        binaries {
            withType(SharedLibraryBinarySpec) {
                <span class="keyword">if</span> (toolChain <span class="keyword">in</span> VisualCpp) {
                    cppCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">DLL_EXPORT</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}

project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:exe</span><span class="delimiter">&quot;</span></span>) {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">cpp</span><span class="delimiter">&quot;</span></span>

    model {
        components {
            main(NativeExecutableSpec) {
                sources {
                    cpp {
                        lib <span class="key">project</span>: <span class="string"><span class="delimiter">'</span><span class="content">:lib</span><span class="delimiter">'</span></span>, <span class="key">library</span>: <span class="string"><span class="delimiter">'</span><span class="content">main</span><span class="delimiter">'</span></span>
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:preCompiledHeaders"><a class="anchor" href="#native_binaries:preCompiledHeaders"></a> <a class="link" href="#native_binaries:preCompiledHeaders">预编译头</a></h4>
<div class="paragraph">
<p>预编译头是一项性能优化，可降低多次编译广泛使用的头的成本。此功能可以<em>预编译</em>头，以便在编译每个源文件时可以重新使用已编译的目标文件，而不必每次都重新编译头。此支持可用于C，C ++，Objective-C和Objective-C ++构建。</p>
</div>
<div class="paragraph">
<p>要配置预编译的头文件，首先需要定义一个头文件，其中包括应预编译的所有头文件。必须将其指定为每个应使用预编译头的源文件中第一个包含的头。假定此头文件及其包含的所有头均使用头保护，以便可以以幂等方式包含它们。如果在头文件中未使用头保护，则头可能会被编译多次，并有可能导致构建失败。</p>
</div>
<div class="sect4">
<h5 id="example_creating_a_precompiled_header_file"><a class="anchor" href="#example_creating_a_precompiled_header_file"></a> <a class="link" href="#example_creating_a_precompiled_header_file">示例：创建预编译的头文件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src / hello / headers / pch.h</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="preprocessor">#ifndef</span> PCH_H
<span class="preprocessor">#define</span> PCH_H
<span class="preprocessor">#include</span> <span class="include">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&quot;hello.h&quot;</span>
<span class="preprocessor">#endif</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="example_including_a_precompiled_header_file_in_a_source_file"><a class="anchor" href="#example_including_a_precompiled_header_file_in_a_source_file"></a> <a class="link" href="#example_including_a_precompiled_header_file_in_a_source_file">示例：在源文件中包含预编译的头文件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src /你好/cpp/hello.cpp</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp"><span class="preprocessor">#include</span> <span class="include">&quot;pch.h&quot;</span>

<span class="directive">void</span> LIB_FUNC Greeter::hello () {
    std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello world!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>预编译头在源集上指定。在给定的源集上只能指定一个预编译的头文件，并且将应用于所有将其声明为第一个include的源文件。如果源文件不包括该头文件作为第一个头文件，则将以常规方式编译该文件（不使用预编译的头文件）。提供的字符串应与源文件中“ #include”指令中使用的字符串相同。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configuring_a_precompiled_header"><a class="anchor" href="#example_configuring_a_precompiled_header"></a> <a class="link" href="#example_configuring_a_precompiled_header">示例：配置预编译头</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        hello(NativeLibrarySpec) {
            sources {
                cpp {
                    preCompiledHeader <span class="string"><span class="delimiter">&quot;</span><span class="content">pch.h</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于使用它的所有文件，必须以相同的方式包括预编译的头。通常，这意味着头文件应存在于源集“头”目录中或编译器包含路径中包含的目录中。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:variants"><a class="anchor" href="#native_binaries:variants"></a> <a class="link" href="#native_binaries:variants">本机二进制变体</a></h4>
<div class="paragraph">
<p>对于定义的每个可执行文件或库，Gradle都能构建许多不同的本机二进制变体。不同变体的示例包括调试与发行二进制文件，32位与64位二进制文件以及使用不同的自定义预处理器标志生成的二进制文件。</p>
</div>
<div class="paragraph">
<p>Gradle生成的二进制文件可以根据<a href="#native_binaries:build_type">构建类型</a> ， <a href="#native_binaries:platform">平台</a>和<a href="#native_binaries:flavor">风格</a>进行区分。对于这些“变量维”中的每一个，都可以指定一组可用值，并将每个组件定位为其中一个，一些或全部。例如，一个插件可能定义了一系列支持平台，但是您可以选择仅将Windows-x86作为特定组件的目标。</p>
</div>
<div class="sect4">
<h5 id="native_binaries:build_type"><a class="anchor" href="#native_binaries:build_type"></a> <a class="link" href="#native_binaries:build_type">构建类型</a></h5>
<div class="paragraph">
<p>一种<code>build type</code>确定二进制文件的各种非功能性方面，例如是否包含调试信息，或使用哪种优化级别编译二进制文件。典型的构建类型是“调试”和“发布”，但是项目可以自由定义任何构建类型集。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_defining_build_types"><a class="anchor" href="#example_defining_build_types"></a> <a class="link" href="#example_defining_build_types">示例：定义构建类型</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    buildTypes {
        debug
        release
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在项目中未定义任何构建类型，则将添加一个名为“ debug”的默认默认构建类型。</p>
</div>
<div class="paragraph">
<p>对于构建类型，Gradle项目通常将为每个工具链定义一组编译器/链接器标志。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configuring_debug_binaries"><a class="anchor" href="#example_configuring_debug_binaries"></a> <a class="link" href="#example_configuring_debug_binaries">示例：配置调试二进制文件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    binaries {
        all {
            <span class="keyword">if</span> (toolChain <span class="keyword">in</span> Gcc &amp;&amp; buildType == buildTypes.debug) {
                cppCompiler.args <span class="string"><span class="delimiter">&quot;</span><span class="content">-g</span><span class="delimiter">&quot;</span></span>
            }
            <span class="keyword">if</span> (toolChain <span class="keyword">in</span> VisualCpp &amp;&amp; buildType == buildTypes.debug) {
                cppCompiler.args <span class="string"><span class="delimiter">'</span><span class="content">/Zi</span><span class="delimiter">'</span></span>
                cppCompiler.define <span class="string"><span class="delimiter">'</span><span class="content">DEBUG</span><span class="delimiter">'</span></span>
                linker.args <span class="string"><span class="delimiter">'</span><span class="content">/DEBUG</span><span class="delimiter">'</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在此阶段，完全由构建脚本来配置每种构建类型的相关编译器/链接器标志。Gradle的未来版本将自动包含适用于任何“调试”构建类型的调试标志，并且可能会意识到各种优化级别。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="native_binaries:platform"><a class="anchor" href="#native_binaries:platform"></a> <a class="link" href="#native_binaries:platform">平台</a></h5>
<div class="paragraph">
<p>可执行文件或库可以构建为在不同的操作系统和cpu架构上运行，并为每个平台生成一个变体。Gradle将每个OS /体系结构组合定义为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.platform.NativePlatform.html">NativePlatform</a> ，并且项目可以定义任何数量的平台。如果项目中未定义平台，则添加单个默认平台“当前”。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>目前， <code>Platform</code>由定义的操作系统和体系结构组成。随着我们继续在Gradle中开发本机二进制支持，平台的概念将扩展为包括C运行时版本，Windows SDK，ABI等。复杂的构建可能会使用Gradle的可扩展性将附加属性应用于每个平台，然后可以查询它们，以指定特定的包含，本机二进制文件的预处理器宏或编译器参数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="example_defining_platforms"><a class="anchor" href="#example_defining_platforms"></a> <a class="link" href="#example_defining_platforms">示例：定义平台</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    platforms {
        x86 {
            architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
        }
        x64 {
            architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">x86_64</span><span class="delimiter">&quot;</span></span>
        }
        itanium {
            architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">ia-64</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于给定的变体，Gradle将尝试查找能够为目标平台构建的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html">NativeToolChain</a> 。按照定义的顺序搜索可用的工具链。有关更多详细信息，请参见下面的<a href="#native_binaries:tool_chain">工具链</a>部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="native_binaries:flavor"><a class="anchor" href="#native_binaries:flavor"></a> <a class="link" href="#native_binaries:flavor">味道</a></h5>
<div class="paragraph">
<p>每个组件可以具有一组命名<code>flavors</code> ，并且可以为每种口味生成一个单独的二进制变体。而<code>build type</code>和<code>target platform</code>变体尺寸在Gradle中具有定义的含义，每个项目都可以自由定义任意数量的风味并以任何方式对其应用含义。</p>
</div>
<div class="paragraph">
<p>组件样式的示例可能会在组件的“演示”，“付费”和“企业”版本之间进行区分，在该版本中，使用相同的一组源来生成具有不同功能的二进制文件。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_defining_flavors"><a class="anchor" href="#example_defining_flavors"></a> <a class="link" href="#example_defining_flavors">示例：定义风味</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    flavors {
        english
        french
    }
    components {
        hello(NativeLibrarySpec) {
            binaries.all {
                <span class="keyword">if</span> (flavor == flavors.french) {
                    cppCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">FRENCH</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，定义了具有“英语”和“法语”风味的库。编译“法语”变体时，将定义一个单独的宏，该宏会导致生成另一个二进制文件。</p>
</div>
<div class="paragraph">
<p>如果没有为组件定义口味，则使用一个名为“ default”的默认口味。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:selecting_the_build_types_platforms_and_flavors_for_a_component"><a class="anchor" href="#sec:selecting_the_build_types_platforms_and_flavors_for_a_component"></a> <a class="link" href="#sec:selecting_the_build_types_platforms_and_flavors_for_a_component">选择组件的构建类型，平台和风格</a></h5>
<div class="paragraph">
<p>对于默认组件，Gradle将尝试为以下组件的每种组合创建本机二进制变体<code>buildType</code>和<code>flavor</code>为项目定义。通过指定一组，可以基于每个组件覆盖此设置。 <code>targetBuildTypes</code>和/或<code>targetFlavors</code> 。默认情况下，Gradle将为默认平台构建，请参见<a href="#native_binaries:platform">上文</a> ，除非通过指定一组组件在每个组件的基础上明确指定<code>targetPlatforms</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_targeting_a_component_at_particular_platforms"><a class="anchor" href="#example_targeting_a_component_at_particular_platforms"></a> <a class="link" href="#example_targeting_a_component_at_particular_platforms">示例：在特定平台上定位组件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    components {
        hello(NativeLibrarySpec) {
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">x64</span><span class="delimiter">&quot;</span></span>
        }
        main(NativeExecutableSpec) {
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">x64</span><span class="delimiter">&quot;</span></span>
            sources {
                cpp.lib <span class="key">library</span>: <span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>, <span class="key">linkage</span>: <span class="string"><span class="delimiter">'</span><span class="content">static</span><span class="delimiter">'</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里您可以看到<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetPlatform(java.lang.String)">TargetedNativeComponent.targetPlatform（java.lang。String）</a>方法用于指定平台<code>NativeExecutableSpec</code>命名<code>main</code>应该为。</p>
</div>
<div class="paragraph">
<p>存在用于选择<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetBuildTypes(java.lang.String[])">TargetedNativeComponent.targetBuildTypes（java.lang。字符串...）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetFlavors(java.lang.String[])">TargetedNativeComponent.targetFlavors（java.lang。字符串...</a></p>
</div>
</div>
<div class="sect4">
<h5 id="sec:building_all_possible_variants"><a class="anchor" href="#sec:building_all_possible_variants"></a> <a class="link" href="#sec:building_all_possible_variants">构建所有可能的变体</a></h5>
<div class="paragraph">
<p>当为组件定义了一组构建类型，目标平台和风格时， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">将为</a>它们的每种可能组合创建一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a>模型元素。但是，在许多情况下，不可能构建特定的变体，这可能是因为没有工具链可用于特定平台的构建。</p>
</div>
<div class="paragraph">
<p>如果由于某种原因无法构建二进制变体，则与该变体关联的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a>将不会<code>buildable</code> 。可以使用此属性创建任务以在特定计算机上生成所有可能的变体。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_building_all_possible_variants"><a class="anchor" href="#example_building_all_possible_variants"></a> <a class="link" href="#example_building_all_possible_variants">示例：构建所有可能的变体</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    tasks {
        buildAllExecutables(Task) {
            dependsOn <span class="error">$</span>.binaries.findAll { <span class="local-variable">it</span>.buildable }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:tool_chain"><a class="anchor" href="#native_binaries:tool_chain"></a> <a class="link" href="#native_binaries:tool_chain">工具链</a></h4>
<div class="paragraph">
<p>单个构建可以利用不同的工具链来构建不同平台的变体。为此，核心的“本地二进制”插件将尝试查找并提供支持的工具链。但是，也可以显式定义项目的工具链集，从而可以配置其他交叉编译器，并可以指定安装目录。</p>
</div>
<div class="sect4">
<h5 id="sec:defining_tool_chains"><a class="anchor" href="#sec:defining_tool_chains"></a> <a class="link" href="#sec:defining_tool_chains">定义工具链</a></h5>
<div class="paragraph">
<p>支持的工具链类型为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.toolchain.Gcc.html">海湾合作委员会</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.toolchain.Clang.html">铛</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html">VisualCpp</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="example_defining_tool_chains"><a class="anchor" href="#example_defining_tool_chains"></a> <a class="link" href="#example_defining_tool_chains">示例：定义工具链</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    toolChains {
        visualCpp(VisualCpp) {
            <span class="comment">// Specify the installDir if Visual Studio cannot be located</span>
            <span class="comment">// installDir &quot;C:/Apps/Microsoft Visual Studio 10.0&quot;</span>
        }
        gcc(Gcc) {
            <span class="comment">// Uncomment to use a GCC install that is not in the PATH</span>
            <span class="comment">// path &quot;/usr/bin/gcc&quot;</span>
        }
        clang(Clang)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个工具链实现都允许进行一定程度的配置（有关更多详细信息，请参见API文档）。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_tool_chains"><a class="anchor" href="#sec:using_tool_chains"></a> <a class="link" href="#sec:using_tool_chains">使用工具链</a></h5>
<div class="paragraph">
<p>没有必要或不可能指定应用于构建的工具链。对于给定的变体，Gradle将尝试找到能够为目标平台构建的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html">NativeToolChain</a> 。按照定义的顺序搜索可用的工具链。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>当平台未定义体系结构或操作系统时，将假定工具链为默认目标。因此，如果平台未为<code>operatingSystem</code> ，Gradle会找到第一个可以为指定对象构建的工具链<code>architecture</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle核心工具链能够立即针对以下架构。在每种情况下，工具链都将针对当前操作系统。有关其他操作系统的交叉编译的信息，请参见下一部分。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">工具链</th>
<th class="tableblock halign-left valign-top">建筑学</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>海湾合作委员会</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>x86，x86_64</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>铛</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>x86，x86_64</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Visual C ++</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>x86，x86_64，ia-64</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>因此，对于在Linux上运行的GCC，支持的目标平台是“ linux / x86”和“ linux / x86_64”。对于通过Cygwin在Windows上运行的GCC，支持平台“ windows / x86”和“ windows / x86_64”。（Cygwin POSIX运行时尚未作为平台的一部分进行建模，但将在将来使用。）</p>
</div>
<div class="paragraph">
<p>如果没有为项目定义目标平台，则所有二进制文件都将以默认平台“ current”为目标。此默认平台未指定任何<code>architecture</code>要么<code>operatingSystem</code>值，因此使用第一个可用工具链的默认值。</p>
</div>
<div class="paragraph">
<p>Gradle提供了一个<em>钩子</em> ，允许构建作者控制传递给工具链可执行文件的确切参数集。这使构建作者可以解决Gradle中的任何限制或Gradle所做的假设。参数挂钩应该被视为一种“最后手段”机制，优先考虑对基础领域进行真正的建模。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_reconfigure_tool_arguments"><a class="anchor" href="#example_reconfigure_tool_arguments"></a> <a class="link" href="#example_reconfigure_tool_arguments">示例：重新配置工具参数</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    toolChains {
        visualCpp(VisualCpp) {
            eachPlatform {
                cppCompiler.withArguments { args -&gt;
                    args &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">-DFRENCH</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
        clang(Clang) {
            eachPlatform {
                cCompiler.withArguments { args -&gt;
                    <span class="predefined-type">Collections</span>.replaceAll(args, <span class="string"><span class="delimiter">&quot;</span><span class="content">CUSTOM</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">-DFRENCH</span><span class="delimiter">&quot;</span></span>)
                }
                linker.withArguments { args -&gt;
                    args.remove <span class="string"><span class="delimiter">&quot;</span><span class="content">CUSTOM</span><span class="delimiter">&quot;</span></span>
                }
                staticLibArchiver.withArguments { args -&gt;
                    args.remove <span class="string"><span class="delimiter">&quot;</span><span class="content">CUSTOM</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:crosscompiling_with_gcc"><a class="anchor" href="#sec:crosscompiling_with_gcc"></a> <a class="link" href="#sec:crosscompiling_with_gcc">与GCC交叉编译</a></h5>
<div class="paragraph">
<p>通过添加对其他目标平台的支持，可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.toolchain.Gcc.html">Gcc</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.toolchain.Clang.html">Clang</a>工具链进行交叉编译。这是通过为工具链指定目标平台来完成的。可以为每个目标平台指定自定义配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_defining_target_platforms"><a class="anchor" href="#example_defining_target_platforms"></a> <a class="link" href="#example_defining_target_platforms">示例：定义目标平台</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    toolChains {
        gcc(Gcc) {
            target(<span class="string"><span class="delimiter">&quot;</span><span class="content">arm</span><span class="delimiter">&quot;</span></span>){
                cppCompiler.withArguments { args -&gt;
                    args &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">-m32</span><span class="delimiter">&quot;</span></span>
                }
                linker.withArguments { args -&gt;
                    args &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">-m32</span><span class="delimiter">&quot;</span></span>
                }
            }
            target(<span class="string"><span class="delimiter">&quot;</span><span class="content">sparc</span><span class="delimiter">&quot;</span></span>)
        }
    }
    platforms {
        arm {
            architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">arm</span><span class="delimiter">&quot;</span></span>
        }
        sparc {
            architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">sparc</span><span class="delimiter">&quot;</span></span>
        }
    }
    components {
        main(NativeExecutableSpec) {
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">arm</span><span class="delimiter">&quot;</span></span>
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">sparc</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:visual_studio"><a class="anchor" href="#native_binaries:visual_studio"></a> <a class="link" href="#native_binaries:visual_studio">Visual Studio IDE集成</a></h4>
<div class="paragraph">
<p>Gradle能够为您的构建中定义的本机组件生成Visual Studio项目和解决方案文件。此功能是由<code>visual-studio</code>插入。对于多项目构建，所有具有本机组件的项目（和根项目）都应应用此插件。</p>
</div>
<div class="paragraph">
<p>当。。。的时候<code>visual-studio</code>插件应用于根项目，即名为<code>visualStudio</code>创建后，将生成一个Visual Studio解决方案文件，其中包含构建中的所有组件。该解决方案将包括每个组件的Visual Studio项目，以及配置每个组件以使用Gradle进行构建。</p>
</div>
<div class="paragraph">
<p>名为的任务<code>openVisualStudio</code>也是由<code>visual-studio</code>当项目是根项目时的插件。此任务将生成Visual Studio解决方案，然后在Visual Studio中打开该解决方案。这意味着您可以简单地运行<code>gradlew openVisualStudio</code>在一个便捷的步骤中，从根项目中生成并打开Visual Studio解决方案。</p>
</div>
<div class="paragraph">
<p>可以通过API挂钩修改生成的Visual Studio文件的内容，该挂钩由<code>visualStudio</code>延期。查看“ visual-studio”示例，或查看API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:projects">VisualStudioExtension.getProjects（）</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.ide.visualstudio.VisualStudioRootExtension.html#org.gradle.ide.visualstudio.VisualStudioRootExtension:solution">VisualStudioRootExtension.getSolution（）</a>了解更多详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:cunit"><a class="anchor" href="#native_binaries:cunit"></a> <a class="link" href="#native_binaries:cunit">CUnit支持</a></h4>
<div class="paragraph">
<p>摇篮<code>cunit</code>插件提供对在本机二进制项目中编译和执行CUnit测试的支持。对于项目中定义的每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableSpec.html">NativeExecutableSpec</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a> ，Gradle将创建一个匹配的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html">CUnitTestSuiteSpec</a>组件，名为<code>${component.name}Test</code> 。</p>
</div>
<div class="sect4">
<h5 id="sec:cunit_sources"><a class="anchor" href="#sec:cunit_sources"></a> <a class="link" href="#sec:cunit_sources">CUnit来源</a></h5>
<div class="paragraph">
<p>摇篮将创建一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.c.CSourceSet.html">CSourceSet</a>名为“库尼特”每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html">CUnitTestSuiteSpec</a>项目的组成部分。此源集应包含被测组件的cunit测试文件。源文件可以位于常规位置（ <code>src/${component.name}Test/cunit</code> ），也可以像其他任何来源集一样进行配置。</p>
</div>
<div class="paragraph">
<p>Gradle利用一些生成的CUnit启动器源初始化CUnit测试注册表并执行测试。Gradle将期望并调用带有签名的函数<code>void gradle_cunit_register()</code>您可以用来配置要执行的实际CUnit套件和测试。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_registering_cunit_tests"><a class="anchor" href="#example_registering_cunit_tests"></a> <a class="link" href="#example_registering_cunit_tests">示例：注册CUnit测试</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">suite_operators.c</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="preprocessor">#include</span> <span class="include">&lt;CUnit/Basic.h&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&quot;gradle_cunit_register.h&quot;</span>
<span class="preprocessor">#include</span> <span class="include">&quot;test_operators.h&quot;</span>

<span class="predefined-type">int</span> suite_init(<span class="directive">void</span>) {
    <span class="keyword">return</span> <span class="integer">0</span>;
}

<span class="predefined-type">int</span> suite_clean(<span class="directive">void</span>) {
    <span class="keyword">return</span> <span class="integer">0</span>;
}

<span class="directive">void</span> gradle_cunit_register() {
    CU_pSuite pSuiteMath = CU_add_suite(<span class="string"><span class="delimiter">&quot;</span><span class="content">operator tests</span><span class="delimiter">&quot;</span></span>, suite_init, suite_clean);
    CU_add_test(pSuiteMath, <span class="string"><span class="delimiter">&quot;</span><span class="content">test_plus</span><span class="delimiter">&quot;</span></span>, test_plus);
    CU_add_test(pSuiteMath, <span class="string"><span class="delimiter">&quot;</span><span class="content">test_minus</span><span class="delimiter">&quot;</span></span>, test_minus);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>由于这种机制，您的CUnit源可能不包含<code>main</code>方法，因为这将与Gradle提供的方法冲突。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:building_cunit_executables"><a class="anchor" href="#sec:building_cunit_executables"></a> <a class="link" href="#sec:building_cunit_executables">构建CUnit可执行文件</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html">CUnitTestSuiteSpec</a>组件具有关联的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableSpec.html">NativeExecutableSpec</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a>组件。对于为主要组件配置的每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a> ，将在测试套件组件上配置匹配的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html">CUnitTestSuiteBinarySpec</a> 。这些测试套件二进制文件的配置方式可以与任何其他二进制实例类似：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configuring_cunit_tests"><a class="anchor" href="#example_configuring_cunit_tests"></a> <a class="link" href="#example_configuring_cunit_tests">示例：配置CUnit测试</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    binaries {
        withType(CUnitTestSuiteBinarySpec) {
            lib <span class="key">library</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">cunit</span><span class="delimiter">&quot;</span></span>, <span class="key">linkage</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">static</span><span class="delimiter">&quot;</span></span>

            <span class="keyword">if</span> (flavor == flavors.failing) {
                cCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">PLUS_BROKEN</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>项目提供的CUnit源和生成的启动器都需要核心CUnit标头和库。目前，您的项目必须为每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html">CUnitTestSuiteBinarySpec</a>提供此库依赖<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html">项</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:running_cunit_tests"><a class="anchor" href="#sec:running_cunit_tests"></a> <a class="link" href="#sec:running_cunit_tests">运行CUnit测试</a></h5>
<div class="paragraph">
<p>对于每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html">CUnitTestSuiteBinarySpec</a> ，Gradle将创建一个任务来执行此二进制文件，它将运行所有已注册的CUnit测试。测试结果将在<code><em>${build.dir}</em>/test-results</code>目录。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_running_cunit_tests"><a class="anchor" href="#example_running_cunit_tests"></a> <a class="link" href="#example_running_cunit_tests">示例：运行CUnit测试</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>
apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">cunit-test-suite</span><span class="delimiter">'</span></span>

model {
    flavors {
        passing
        failing
    }
    platforms {
        x86 {
            <span class="keyword">if</span> (operatingSystem.macOsX) {
                architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">x64</span><span class="delimiter">&quot;</span></span>
            } <span class="keyword">else</span> {
                architecture <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
    repositories {
        libs(PrebuiltLibraries) {
            cunit {
                headers.srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">libs/cunit/2.1-2/include</span><span class="delimiter">&quot;</span></span>
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile =
                        file(<span class="string"><span class="delimiter">&quot;</span><span class="content">libs/cunit/2.1-2/lib/</span><span class="delimiter">&quot;</span></span> +
                             findCUnitLibForPlatform(targetPlatform))
                }
            }
        }
    }
    components {
        operators(NativeLibrarySpec) {
            targetPlatform <span class="string"><span class="delimiter">&quot;</span><span class="content">x86</span><span class="delimiter">&quot;</span></span>
        }
    }
    testSuites {
        operatorsTest(CUnitTestSuiteSpec) {
            testing <span class="error">$</span>.components.operators
        }
    }
}
model {
    binaries {
        withType(CUnitTestSuiteBinarySpec) {
            lib <span class="key">library</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">cunit</span><span class="delimiter">&quot;</span></span>, <span class="key">linkage</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">static</span><span class="delimiter">&quot;</span></span>

            <span class="keyword">if</span> (flavor == flavors.failing) {
                cCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">PLUS_BROKEN</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q runOperatorsTestFailingCUnitExe</code></div>
<div class="content">
<pre>&gt; gradle -q runOperatorsTestFailingCUnitExe

There were test failures:
  1. /home/user/gradle/samples/src/operatorsTest/c/test_plus.c:6  - plus(0, -2) == -2
  2. /home/user/gradle/samples/src/operatorsTest/c/test_plus.c:7  - plus(2, 2) == 4


FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':runOperatorsTestFailingCUnitExe'.
&gt; There were failing tests. See the results at: file:///home/user/gradle/samples/build/test-results/operatorsTest/failing/

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 0s</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/native-binaries/cunit</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>当前对CUnit的支持还很初级。未来集成的计划包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>允许使用Javadoc样式的注释声明测试。</p>
</li>
<li>
<p>改进的HTML报告，类似于JUnit可用的报告。</p>
</li>
<li>
<p>实时反馈以执行测试。</p>
</li>
<li>
<p>支持其他测试框架。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="native_binaries:google_test"><a class="anchor" href="#native_binaries:google_test"></a> <a class="link" href="#native_binaries:google_test">GoogleTest支持</a></h4>
<div class="paragraph">
<p>摇篮<code>google-test</code>插件提供了对本机二进制项目中的GoogleTest测试进行编译和执行的支持。对于项目中定义的每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableSpec.html">NativeExecutableSpec</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a> ，Gradle将创建一个匹配的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteSpec.html">GoogleTestTestSuiteSpec</a>组件，名为<code>${component.name}Test</code> 。</p>
</div>
<div class="sect4">
<h5 id="sec:googletest_sources"><a class="anchor" href="#sec:googletest_sources"></a> <a class="link" href="#sec:googletest_sources">GoogleTest来源</a></h5>
<div class="paragraph">
<p>摇篮将创建一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.language.cpp.CppSourceSet.html">CppSourceSet</a>名为“CPP”每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteSpec.html">GoogleTestTestSuiteSpec</a>项目的组成部分。此源集应包含被测组件的GoogleTest测试文件。源文件可以位于常规位置（ <code>src/${component.name}Test/cpp</code> ），也可以像其他任何来源集一样进行配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:building_googletest_executables"><a class="anchor" href="#sec:building_googletest_executables"></a> <a class="link" href="#sec:building_googletest_executables">构建GoogleTest可执行文件</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteSpec.html">GoogleTestTestSuiteSpec</a>组件具有关联的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeExecutableSpec.html">NativeExecutableSpec</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeLibrarySpec.html">NativeLibrarySpec</a>组件。对于为主要组件配置的每个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/nativeplatform/NativeBinarySpec.html">NativeBinarySpec</a> ，将在测试套件组件上配置一个匹配的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html">GoogleTestTestSuiteBinarySpec</a> 。这些测试套件二进制文件的配置方式可以与任何其他二进制实例类似：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_registering_googletest_tests"><a class="anchor" href="#example_registering_googletest_tests"></a> <a class="link" href="#example_registering_googletest_tests">示例：注册GoogleTest测试</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    binaries {
        withType(GoogleTestTestSuiteBinarySpec) {
            lib <span class="key">library</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">googleTest</span><span class="delimiter">&quot;</span></span>, <span class="key">linkage</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">static</span><span class="delimiter">&quot;</span></span>

            <span class="keyword">if</span> (flavor == flavors.failing) {
                cppCompiler.define <span class="string"><span class="delimiter">&quot;</span><span class="content">PLUS_BROKEN</span><span class="delimiter">&quot;</span></span>
            }

            <span class="keyword">if</span> (targetPlatform.operatingSystem.linux) {
                cppCompiler.args <span class="string"><span class="delimiter">'</span><span class="content">-pthread</span><span class="delimiter">'</span></span>
                linker.args <span class="string"><span class="delimiter">'</span><span class="content">-pthread</span><span class="delimiter">'</span></span>

                <span class="keyword">if</span> (toolChain <span class="keyword">instanceof</span> Gcc || toolChain <span class="keyword">instanceof</span> Clang) {
                    <span class="comment">// Use C++03 with the old ABIs, as this is what the googletest binaries were built with</span>
                    cppCompiler.args <span class="string"><span class="delimiter">'</span><span class="content">-std=c++03</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">-D_GLIBCXX_USE_CXX11_ABI=0</span><span class="delimiter">'</span></span>
                    linker.args <span class="string"><span class="delimiter">'</span><span class="content">-std=c++03</span><span class="delimiter">'</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/native-binaries/google-test</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>您的项目提供的GoogleTest源需要核心的GoogleTest标头和库。目前，您的项目必须为每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html">GoogleTestTestSuiteBinarySpec</a>提供此库依赖<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html">项</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:running_googletest_tests"><a class="anchor" href="#sec:running_googletest_tests"></a> <a class="link" href="#sec:running_googletest_tests">运行GoogleTest测试</a></h5>
<div class="paragraph">
<p>对于每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html">GoogleTestTestSuiteBinarySpec</a> ，Gradle将创建一个任务来执行此二进制文件，它将运行所有已注册的GoogleTest测试。测试结果将在<code><em>${build.dir}</em>/test-results</code>目录。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>目前对GoogleTest的支持还很初级。未来集成的计划包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>改进的HTML报告，类似于JUnit可用的报告。</p>
</li>
<li>
<p>实时反馈以执行测试。</p>
</li>
<li>
<p>支持其他测试框架。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="software_model_concepts"><a class="anchor" href="#software_model_concepts"></a> <a class="link" href="#software_model_concepts">软件模型概念</a></h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>基于规则的配置<a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model">将被弃用</a> 。新插件不应使用此概念。相反，请使用“ <a href="#custom_plugins">编写自定义插件”</a>一章中描述的标准方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>软件模型描述了软件的构建方式以及软件的各个组件之间的相互关系。该软件模型围绕一些关键概念进行组织：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>组件</em>是代表一些逻辑软件的一般概念。组件的示例是命令行应用程序，Web应用程序或库。一个组件通常由其他组件组成。大多数Gradle构建将产生至少一个组件。</p>
</li>
<li>
<p><em>库</em>是可重用的组件，已链接到或组合到其他组件中。在Java生态系统中，通常将库构建为Jar文件，然后将其捆绑到某种应用程序中。在本机生态系统中，库可以构建为共享库或静态库，或两者兼而有之。</p>
</li>
<li>
<p><em>源集</em>表示源文件的逻辑组。大多数组件都是从各种语言的源集中构建的。一些源集包含手动编写的源，而某些源集可能包含从其他内容生成的源。</p>
</li>
<li>
<p><em>二进制</em>表示为组件构建的某些输出。一个组件可能会产生多个不同的输出二进制文件。例如，对于C ++库，可以同时生成共享库和静态库二进制文件。每个二进制文件最初都配置为从组件源构建，但是可以将其他源集添加到特定的二进制变量中。</p>
</li>
<li>
<p><em>变体</em>表示组件的某些互斥二进制。例如，一个库可能针对Java 7和Java 8，从而有效地产生两个不同的二进制文件：一个Java 7 Jar和一个Java 8 Jar。这些是库的不同变体。</p>
</li>
<li>
<p>库的<em>API</em>表示针对该库进行编译所需的工件和依赖项。该API通常由二进制文件和一组依赖项组成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#software_model_extend">可以扩展软件模型</a> ，从而通过类型丰富的DSL对特定域进行深度建模。</p>
</div>
</div>
<div class="sect2">
<h3 id="software_model"><a class="anchor" href="#software_model"></a> <a class="link" href="#software_model">基于规则的模型配置</a></h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>基于规则的配置<a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model">将被弃用</a> 。新插件不应使用此概念。相反，请使用“ <a href="#custom_plugins">编写自定义插件”</a>一章中描述的标准方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>基于规则的模型配置使<em>配置逻辑本身可以依赖</em>于配置的其他元素，并在执行自己的配置时利用配置的其他元素的已解析状态。</p>
</div>
<div class="sect3">
<h4 id="sec:background"><a class="anchor" href="#sec:background"></a> <a class="link" href="#sec:background">背景</a></h4>
<div class="paragraph">
<p>简而言之，软件模型是一种非常声明性的方式，用于描述软件的构建方式以及该软件在流程中的依赖关系所需要的其他组件。它还提供了一个新的基于规则的引擎来配置Gradle构建。当我们开始实施软件模型时，我们为自己设定了以下目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>改善配置和执行时间性能。</p>
</li>
<li>
<p>使用复杂的工具链使构建的自定义更加容易。</p>
</li>
<li>
<p>提供一种更丰富，更标准化的方式来建模不同的软件生态系统。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle通过其他措施极大地提高了配置性能。不再需要对Gradle构建的配置进行重大的，不兼容的更改。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:basic_concepts"><a class="anchor" href="#sec:basic_concepts"></a> <a class="link" href="#sec:basic_concepts">基本概念</a></h4>
<div class="sect4">
<h5 id="sec:the_model_space"><a class="anchor" href="#sec:the_model_space"></a> <a class="link" href="#sec:the_model_space">“模型空间”</a></h5>
<div class="paragraph">
<p>术语“模型空间”用于指代形式模型，可以通过规则读取和修改。</p>
</div>
<div class="paragraph">
<p>与模型空间相对应的是“项目空间”，读者应该熟悉它。“项目空间”是对象的图形（例如， <code>project.repositories</code> ， <code>project.tasks</code>等）以<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">项目</a>为根。构建脚本可以有效地添加和配置该图的对象。在大多数情况下，“项目空间”对于Gradle是不透明的。它是Gradle仅能部分理解的任意对象图。</p>
</div>
<div class="paragraph">
<p>每个项目还具有其自己的模型空间，该模型空间不同于项目空间。“模型空间”的一个关键特征是Gradle对它的了解更多（可以充分利用的知识）。与项目空间中的对象相比，对模型空间中的对象进行“管理”的程度更大。模型空间中对象的起源，结构，状态，协作者和关系是一流的构造。实际上，这是在功能上将模型空间与项目空间区分开的特征：模型空间的对象是通过Gradle能够对其进行深入了解的方式定义的，而不是运行相对不透明的代码所导致的对象。“规则”实际上是该定义的基础。</p>
</div>
<div class="paragraph">
<p>模型空间最终将取代项目空间，成为唯一的“空间”。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:rules"><a class="anchor" href="#sec:rules"></a> <a class="link" href="#sec:rules">规则</a></h5>
<div class="paragraph">
<p>模型空间由“规则”定义。规则只是一个产生模型元素或作用于模型元素的函数（抽象意义上）。每个规则都有一个主题和零个或多个输入。规则只能更改主题，而输入实际上是不可变的。</p>
</div>
<div class="paragraph">
<p>Gradle保证在规则执行之前，所有输入都被完全“实现”。“实现”模型元素的过程有效地执行了作为主题的所有规则，并将其转换为最终状态。这里与Gradle的任务图和任务执行模型有很强的类比。正如任务相互依赖，Gradle确保在执行任务之前满足依赖关系一样，规则有效地相互依赖（即规则依赖于主题是输入之一的所有规则），Gradle确保在满足任务之前满足所有依赖关系执行规则。</p>
</div>
<div class="paragraph">
<p>模型元素通常是根据其他模型元素来定义的。例如，可以根据正在编译的源集的配置来定义编译任务的配置。在这种情况下，编译任务将成为规则的主题，而源将设置输入。这样的规则可以基于源集输入来配置任务主题，而无需考虑其配置方式，配置者，配置时间和指定时间。</p>
</div>
<div class="paragraph">
<p>有几种声明规则的方法，并且有几种形式。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:rule_sources"><a class="anchor" href="#sec:rule_sources"></a> <a class="link" href="#sec:rule_sources">规则来源</a></h4>
<div class="paragraph">
<p>定义规则的一种方法是通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>子类。如果对象扩展了RuleSource并包含任何以'@Mutate'注释的方法，则每个此类方法都定义一个规则。对于每种这样的方法，第一个参数是主题，并且可以跟随零个或多个后续参数，它们是规则的输入。</p>
</div>
<div class="sect4">
<h5 id="example_applying_a_rule_source_plugin"><a class="anchor" href="#example_applying_a_rule_source_plugin"></a> <a class="link" href="#example_applying_a_rule_source_plugin">示例：应用规则源插件</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Managed</span>
<span class="type">interface</span> Person {
  <span class="type">void</span> setFirstName(<span class="predefined-type">String</span> name)
  <span class="predefined-type">String</span> getFirstName()

  <span class="type">void</span> setLastName(<span class="predefined-type">String</span> name)
  <span class="predefined-type">String</span> getLastName()
}

<span class="type">class</span> <span class="class">PersonRules</span> <span class="directive">extends</span> RuleSource {
  <span class="annotation">@Model</span> <span class="type">void</span> person(Person p) {}

  <span class="comment">//Create a rule that modifies a Person and takes no other inputs</span>
  <span class="annotation">@Mutate</span> <span class="type">void</span> setFirstName(Person p) {
    p.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>
  }

  <span class="comment">//Create a rule that modifies a ModelMap&lt;Task&gt; and takes as input a Person</span>
  <span class="annotation">@Mutate</span> <span class="type">void</span> createHelloTask(ModelMap&lt;Task&gt; tasks, Person p) {
    tasks.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>) {
      doLast {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">$</span>p</span><span class="content">.firstName </span><span class="inline"><span class="inline-delimiter">$</span>p</span><span class="content">.lastName!</span><span class="delimiter">&quot;</span></span>
      }
    }
  }
}

apply <span class="key">plugin</span>: PersonRules</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle hello</code></strong></div>
<div class="content">
<pre>&gt; gradle hello

&gt; Task :hello
Hello John Smith!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>规则源的每种不同方法都是离散的独立规则。它们的顺序或它们属于同一类的事实不影响其行为。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_a_model_creation_rule"><a class="anchor" href="#example_a_model_creation_rule"></a> <a class="link" href="#example_a_model_creation_rule">示例：模型创建规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Model</span> <span class="type">void</span> person(Person p) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该规则声明路径中有一个模型元素<code>"person"</code> （由方法名称定义），类型<code>Person</code> 。这是<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Managed.html">托管</a>类型的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Model.html">模型</a>类型规则的形式。在此，人对象是规则主体。该方法可能具有使人实例变异的主体。它也可能具有更多参数，这将是规则输入。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_a_model_mutation_rule"><a class="anchor" href="#example_a_model_mutation_rule"></a> <a class="link" href="#example_a_model_mutation_rule">示例：模型突变规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">//Create a rule that modifies a Person and takes no other inputs</span>
<span class="annotation">@Mutate</span> <span class="type">void</span> setFirstName(Person p) {
  p.firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此“ <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Mutate.html">变异”</a>规则会变异人员对象。方法的第一个参数是主题。在此，使用按类型引用，因为参数上不存在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Path.html">路径</a>注释。它也可能具有更多的参数，这将是规则输入。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_creating_a_task"><a class="anchor" href="#example_creating_a_task"></a> <a class="link" href="#example_creating_a_task">示例：创建任务</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">//Create a rule that modifies a ModelMap&lt;Task&gt; and takes as input a Person</span>
<span class="annotation">@Mutate</span> <span class="type">void</span> createHelloTask(ModelMap&lt;Task&gt; tasks, Person p) {
  tasks.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>) {
    doLast {
      println <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">$</span>p</span><span class="content">.firstName </span><span class="inline"><span class="inline-delimiter">$</span>p</span><span class="content">.lastName!</span><span class="delimiter">&quot;</span></span>
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Mutate.html">Mutate</a>规则通过对任务集合进行突变来有效地添加任务。这里的主题是<code>"tasks"</code>节点，可作为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html">Task</a>的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelMap.html">ModelMap</a>使用。唯一的输入是我们的人员元素。由于此处将人用作输入，因此将在执行此规则之前实现该输入。即，任务容器有效地<em>取决于</em>人员元素。如果有可能在构建脚本或其他插件中指定的person元素配置规则，则也将确保已执行它们。</p>
</div>
<div class="paragraph">
<p>如<code>Person</code>在此示例中，如果为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Managed.html">Managed</a>类型，则任何尝试在此方法中修改person参数的操作都会导致引发异常。受管对象在其生命周期的适当时点强制执行不变性。</p>
</div>
<div class="paragraph">
<p>可以使用与其他类型的插件相同的方式来打包和分发规则源插件（请参阅<a href="#custom_plugins">自定义插件</a> ）。它们也可以以与<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">插件</a>实现相同的方式（应用于项目对象）（即通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:apply(java.util.Map)">Project.apply（java.util。地图）</a> ）。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>的文档，以获取有关如何实现规则源的约束以及更多类型的规则的更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:advanced_concepts"><a class="anchor" href="#sec:advanced_concepts"></a> <a class="link" href="#sec:advanced_concepts">先进概念</a></h4>
<div class="sect4">
<h5 id="sec:model_paths"><a class="anchor" href="#sec:model_paths"></a> <a class="link" href="#sec:model_paths">模型路径</a></h5>
<div class="paragraph">
<p>模型路径标识元素相对于其模型空间的根的位置。常见表示形式是一组以句点分隔的名称。例如，模型路径<code>"tasks"</code>是到作为任务容器的元素的路径。假设一个任务的名字是<code>hello</code> ， 路径<code>"tasks.hello"</code>是完成此任务的途径。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:managed_model_elements"><a class="anchor" href="#sec:managed_model_elements"></a> <a class="link" href="#sec:managed_model_elements">托管模型元素</a></h5>
<div class="paragraph">
<p>当前，任何类型的Java对象都可以成为模型空间的一部分。但是，“托管”和“非托管”对象之间存在差异。</p>
</div>
<div class="paragraph">
<p>一个“被管理”的对象是透明的，一旦实现就强制不变性。透明意味着规则基础结构可以理解其结构，因此其每个属性也是模型空间中的各个元素。</p>
</div>
<div class="paragraph">
<p>“非托管”对象对于模型空间是不透明的，并且不强制不可变性。随着时间的流逝，将有更多机制可用于定义托管模型元素，最终以某种方式管理所有模型元素。</p>
</div>
<div class="paragraph">
<p>可以通过附加以下内容来定义托管模型<code>@Managed</code>界面注释：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_a_managed_type"><a class="anchor" href="#example_a_managed_type"></a> <a class="link" href="#example_a_managed_type">示例：托管类型</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Managed</span>
<span class="type">interface</span> Person {
  <span class="type">void</span> setFirstName(<span class="predefined-type">String</span> name)
  <span class="predefined-type">String</span> getFirstName()

  <span class="type">void</span> setLastName(<span class="predefined-type">String</span> name)
  <span class="predefined-type">String</span> getLastName()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过定义一个getter / setter对，可以有效地声明一个托管属性。托管属性是当模型的节点不是规则的主题时，Gradle将为其强制实施语义（如不变性）的属性。因此，此示例在托管类型<em>Person</em>上声明名为<em>firstName</em>和<em>lastName的</em>属性。这些属性仅在视图可变时才可写，即当<em>Person</em>是对象的主题时。 <code>Rule</code> （有关规则，请参见下面的说明）。</p>
</div>
<div class="paragraph">
<p>托管属性可以是任何标量类型。此外，属性还可以是任何本身可以管理的类型：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">财产种类</th>
<th class="tableblock halign-left valign-top">可空</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>String</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>是</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setFirstName(<span class="predefined-type">String</span> name)
<span class="predefined-type">String</span> getFirstName()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>File</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>是</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setHomeDirectory(<span class="predefined-type">File</span> homeDir)
<span class="predefined-type">File</span> getHomeDirectory()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Integer</code> ， <code>Boolean</code> ， <code>Byte</code> ， <code>Short</code> ， <code>Float</code> ， <code>Long</code> ，<code>Double</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>是</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setId(<span class="predefined-type">Long</span> id)
<span class="predefined-type">Long</span> getId()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code> ， <code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>float</code> ， <code>long</code> ，<code>double</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>没有</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setEmployed(<span class="type">boolean</span> isEmployed)
<span class="type">boolean</span> isEmployed()</code></pre>
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setAge(<span class="type">int</span> age)
<span class="type">int</span> getAge()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>另一种<em>托管</em>类型。</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>只有读/写</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setMother(Person mother)
Person getMother()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>枚举</em>类型。</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>是</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setMaritalStatus(MaritalStatus status)
MaritalStatus getMaritalStatus()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>一种<code>ManagedSet</code> 。托管集支持创建新的命名模型元素，但不支持删除它们。</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>只有读/写</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ModelSet&lt;Person&gt; getChildren()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>一种<code>Set</code>要么<code>List</code>标量类型。支持集合上的所有经典操作：添加，删除，清除...</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>只有读/写</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">void</span> setUserGroups(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; groups)
<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; getUserGroups()</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果属性的类型本身是托管类型，则可以仅声明一个getter，在这种情况下，您将声明一个只读属性。只读属性将由Gradle实例化，并且不能用相同类型的另一个对象替换（例如，调用setter）。但是，只有且仅当该属性是规则的主题时，该属性的属性才有可能更改。如果不是这种情况，则该属性是不可变的，就像任何经典的读/写托管属性一样，并且该属性的属性完全不能更改。</p>
</div>
<div class="paragraph">
<p>托管类型可以在接口或抽象类之外定义，并且通常在用Java或Groovy编写的插件中定义。请参阅<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Managed.html">托管</a>注释以获取有关创建托管模型对象的更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:model_element_types"><a class="anchor" href="#sec:model_element_types"></a> <a class="link" href="#sec:model_element_types">模型元素类型</a></h5>
<div class="paragraph">
<p>模型空间支持某些特定类型（语言类型），可以将其概括如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表16。类型定义</caption>
<colgroup>
<col style="width:28.5714%">
<col style="width:71.4286%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">标量</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>标量类型是以下之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>原始类型（例如<code>int</code> ）或其框式（例如<code>Integer</code> ）</p>
</li>
<li>
<p>一种<code>BigInteger</code>要么<code>BigDecimal</code></p>
</li>
<li>
<p>一种<code>String</code></p>
</li>
<li>
<p>一种<code>File</code></p>
</li>
<li>
<p>枚举类型</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">标量集合</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>一个java.util。列表或java.util。包含标量类型之一的集合</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">托管类型</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>任何有效的托管模型的类（即@ @ <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Managed.html">Managed</a>注释）</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">托管集合</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelMap.html">ModelMap</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelSet.html">ModelSet</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在各种情况下都可以使用这些类型：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表17。型号类型支持</caption>
<colgroup>
<col style="width:28.5714%">
<col style="width:71.4286%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">语境</th>
<th class="tableblock halign-left valign-top">支持的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建顶级模型元素</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>任何托管类型</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/FunctionalSourceSet.html">FunctionalSourceSet</a> （已应用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/plugins/LanguageBasePlugin.html">LanguageBasePlugin</a>插件时）</p>
</li>
<li>
<p>已通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentType.html">ComponentType</a>注册的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/LanguageSourceSet.html">LanguageSourceSet的</a>子类型</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">托管模型元素的属性</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>托管模型元素的属性（属性）可以是以下一项或多项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>托管类型</p>
</li>
<li>
<p>用@ <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Unmanaged.html">Unmanaged</a>注释的类型</p>
</li>
<li>
<p>标量集合</p>
</li>
<li>
<p>包含托管类型的托管集合</p>
</li>
<li>
<p>包含<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/FunctionalSourceSet.html">FunctionalSourceSet</a>的托管集合（已应用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/plugins/LanguageBasePlugin.html">LanguageBasePlugin</a>插件时）</p>
</li>
<li>
<p>已通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentType.html">ComponentType</a>注册的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/LanguageSourceSet.html">LanguageSourceSet的</a>子类型</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="sec:language_source_sets"><a class="anchor" href="#sec:language_source_sets"></a> <a class="link" href="#sec:language_source_sets">语言源集</a></h5>
<div class="paragraph">
<p>可以通过规则或通过模型DSL将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/FunctionalSourceSet.html">FunctionalSourceSet</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/LanguageSourceSet.html">LanguageSourceSet的</a>子类型（已通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentType.html">ComponentType</a>注册）添加到模型空间。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_strongly_modelling_sources_sets"><a class="anchor" href="#example_strongly_modelling_sources_sets"></a> <a class="link" href="#example_strongly_modelling_sources_sets">示例：强烈建模源集</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java-lang</span><span class="delimiter">'</span></span>

<span class="comment">//Creating LanguageSourceSets via rules</span>
<span class="type">class</span> <span class="class">LanguageSourceSetRules</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@Model</span>
    <span class="type">void</span> mySourceSet(JavaSourceSet javaSource) {
        javaSource.source.srcDir(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/main/my</span><span class="delimiter">&quot;</span></span>)
    }
}
apply <span class="key">plugin</span>: LanguageSourceSetRules

<span class="comment">//Creating LanguageSourceSets via the model DSL</span>
model {
    another(JavaSourceSet) {
        source {
            srcDir <span class="string"><span class="delimiter">&quot;</span><span class="content">src/main/another</span><span class="delimiter">&quot;</span></span>
        }
    }
}

<span class="comment">//Using FunctionalSourceSets</span>
<span class="annotation">@Managed</span>
<span class="type">interface</span> SourceBundle {
    FunctionalSourceSet getFreeSources()
    FunctionalSourceSet getPaidSources()
}
model {
    sourceBundle(SourceBundle) {
        freeSources.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>, JavaSourceSet)
        freeSources.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">resources</span><span class="delimiter">&quot;</span></span>, JvmResourceSet)
        paidSources.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>, JavaSourceSet)
        paidSources.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">resources</span><span class="delimiter">&quot;</span></span>, JvmResourceSet)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle help</code></div>
<div class="content">
<pre>&gt; gradle help

&gt; Task :help</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/modelRules/language-support</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:references_binding_and_scopes"><a class="anchor" href="#sec:references_binding_and_scopes"></a> <a class="link" href="#sec:references_binding_and_scopes">参考，绑定和范围</a></h5>
<div class="paragraph">
<p>如前所述，规则有一个主题和零个或多个输入。规则的主题和输入被声明为“引用”，并在由Gradle执行之前被“绑定”到模型元素。每个规则必须有效地转发声明主题和输入作为参考。准确地执行此操作的方式取决于规则的形式。例如， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>提供的规则将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">引用</a>声明为方法参数。</p>
</div>
<div class="paragraph">
<p>引用可以是“按路径”或“按类型”。</p>
</div>
<div class="paragraph">
<p>“按类型”引用按类型标识特定的模型元素。例如，对<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskContainer.html">TaskContainer</a>的引用有效地标识了<code>"tasks"</code>项目模型空间中的元素。不会详尽搜索模型空间以查找按类型绑定的候选对象。而是为规则提供了一个范围（稍后讨论），该范围确定按类型绑定的搜索空间。</p>
</div>
<div class="paragraph">
<p>“按路径”引用通过其在模型空间中的路径来标识特定的模型元素。旁路引用始终与规则范围相关；当前没有办法“超出”范围。所有旁路径引用也都具有关联的类型，但这并不影响引用绑定到的对象。但是，由路径标识的元素必须在类型上与引用兼容，否则将发生致命的“绑定失败”。</p>
</div>
<div class="sect5">
<h6 id="sec:binding_scope"><a class="anchor" href="#sec:binding_scope"></a> <a class="link" href="#sec:binding_scope">装订范围</a></h6>
<div class="paragraph">
<p>规则绑定在一个“范围”内，该范围确定引用的绑定方式。大多数规则都约束在项目范围内（即项目模型图的根）。但是，可以将规则的范围限定在图中的节点上。<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelMap.html#named-java.lang.String-java.lang.Class-">ModelMap.named（java.lang。字符串，java.lang。类）</a>方法是应用范围规则的机制的示例。使用以下命令在构建脚本中声明的规则<code>model {}</code>阻止，或通过<code>RuleSource</code>作为插件应用时，请使用模型空间的根作为范围。这可以视为默认范围。</p>
</div>
<div class="paragraph">
<p>旁路引用始终是相对于规则范围的。当范围是根时，这有效地允许绑定到图中的任何元素。如果不是，则只能使用“ by-path”符号来引用作用域的子代。</p>
</div>
<div class="paragraph">
<p>绑定按类型引用时，将考虑以下元素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>范围元素本身。</p>
</li>
<li>
<p>范围元素的直接子级。</p>
</li>
<li>
<p>模型空间（即项目空间）的直接子级是根。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于常见情况，规则实际上是作用于根的，则仅需考虑根的直接子代。</p>
</div>
</div>
<div class="sect5">
<h6 id="binding_all_elements_in_scope"><a class="anchor" href="#binding_all_elements_in_scope"></a> <a class="link" href="#binding_all_elements_in_scope">绑定到范围匹配类型中的所有元素</a></h6>
<div class="paragraph">
<p>在某种范围内，对给定类型的所有元素进行突变或验证是一种常见的用例。为此，可以通过<code>@Each</code>注解。</p>
</div>
<div class="paragraph">
<p>在下面的示例中， <code>@Defaults</code>规则适用于每个<code>FileItem</code>在模型中设置默认文件大小为“ 1024”。另一个规则将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>应用于每个<code>DirectoryItem</code>确保所有文件的大小都是正数并且可以被“ 16”整除。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="example_a_dsl_example_applying_a_rule_to_every_element_in_a_scope"><a class="anchor" href="#example_a_dsl_example_applying_a_rule_to_every_element_in_a_scope"></a> <a class="link" href="#example_a_dsl_example_applying_a_rule_to_every_element_in_a_scope">示例：将规则应用于范围中的每个元素的DSL示例</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Managed</span> <span class="type">interface</span> Item <span class="directive">extends</span> Named {}
<span class="annotation">@Managed</span> <span class="type">interface</span> FileItem <span class="directive">extends</span> Item {
    <span class="type">void</span> setSize(<span class="type">int</span> size)
    <span class="type">int</span> getSize()
}
<span class="annotation">@Managed</span> <span class="type">interface</span> DirectoryItem <span class="directive">extends</span> Item {
    ModelMap&lt;Item&gt; getChildren()
}

<span class="type">class</span> <span class="class">PluginRules</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@Defaults</span> <span class="type">void</span> setDefaultFileSize(<span class="annotation">@Each</span> FileItem file) {
        file.size = <span class="integer">1024</span>
    }

    <span class="annotation">@Rules</span> <span class="type">void</span> applyValidateRules(ValidateRules rules, <span class="annotation">@Each</span> DirectoryItem directory)  {}
}
apply <span class="key">plugin</span>: PluginRules

<span class="directive">abstract</span> <span class="type">class</span> <span class="class">ValidateRules</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@Validate</span>
    <span class="type">void</span> validateSizeIsPositive(ModelMap&lt;FileItem&gt; files) {
        files.each { file -&gt;
            <span class="keyword">assert</span> file.size &gt; <span class="integer">0</span>
        }
    }

    <span class="annotation">@Validate</span>
    <span class="type">void</span> validateSizeDivisibleBySixteen(ModelMap&lt;FileItem&gt; files) {
        files.each { file -&gt;
            <span class="keyword">assert</span> file.size % <span class="integer">16</span> == <span class="integer">0</span>
        }
    }
}

model {
    root(DirectoryItem) {
        children {
            dir(DirectoryItem) {
                children {
                    file1(FileItem)
                    file2(FileItem) { size = <span class="integer">2048</span> }
                }
            }
            file3(FileItem)
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/modelRules/ruleSourcePluginEach</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="model-dsl"><a class="anchor" href="#model-dsl"></a> <a class="link" href="#model-dsl">DSL型号</a></h4>
<div class="paragraph">
<p>除了使用RuleSource外，还可以使用“模型DSL”在构建脚本中直接声明模型和规则。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>DSL模型大量使用了各种Groovy DSL功能。请阅读<a href="#groovy-dsl-basics">Groovy DSL基础知识</a> ，以了解这些Groovy功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>DSL模型的一般形式为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    <span class="error">«</span>rule-definitions<span class="error">»</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有规则都嵌套在<code>model</code>块。每个内部可能有许多规则定义<code>model</code>块，并且可能有任意数量的<code>model</code>构建脚本中的块。您也可以使用<code>model</code>阻止使用<code>apply from: $uri</code> 。</p>
</div>
<div class="paragraph">
<p>当前，您可以使用模型DSL定义两种规则：配置规则和创建规则。</p>
</div>
<div class="sect4">
<h5 id="sec:configuration_rules"><a class="anchor" href="#sec:configuration_rules"></a> <a class="link" href="#sec:configuration_rules">配置规则</a></h5>
<div class="paragraph">
<p>您可以定义配置特定模型元素的规则。配置规则的格式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    <span class="error">«</span>model-path-to-subject<span class="error">»</span> {
        <span class="error">«</span>configuration code<span class="error">»</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>继续到目前为止模型元素的示例<code>"person"</code>类型的<code>Person</code>存在时，以下DSL代码段为设置其内容的人添加了配置规则<code>lastName</code>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_dsl_configuration_rule"><a class="anchor" href="#example_dsl_configuration_rule"></a> <a class="link" href="#example_dsl_configuration_rule">示例：DSL配置规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    person {
        lastName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置规则指定应配置的主题的路径，以及包含配置主题时要运行的代码的闭包。使用传递的主题作为闭包委托来执行闭包。到底可以提供什么代码取决于主题的类型。这将在下面讨论。</p>
</div>
<div class="paragraph">
<p>您应该注意，配置代码不会立即执行，而是仅在需要主题时才执行。这是模型规则的重要行为，并允许Gradle仅配置构建所需的那些元素，这有助于减少构建时间。例如，让我们运行一个使用“人”对象的任务：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configuration_run_when_required"><a class="anchor" href="#example_configuration_run_when_required"></a> <a class="link" href="#example_configuration_run_when_required">示例：在需要时运行配置</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    person {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">configuring person</span><span class="delimiter">&quot;</span></span>
        lastName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle showPerson</code></strong></div>
<div class="content">
<pre>&gt; gradle showPerson
configuring person

&gt; Task :showPerson
Hello John Smith!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到，在运行任务之前，通过运行规则关闭来配置“人”元素。现在，让我们运行不需要“ person”元素的任务：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configuration_not_run_when_not_required"><a class="anchor" href="#example_configuration_not_run_when_not_required"></a> <a class="link" href="#example_configuration_not_run_when_not_required">示例：不需要时配置不运行</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle somethingElse</code></strong></div>
<div class="content">
<pre>&gt; gradle somethingElse

&gt; Task :somethingElse
Not using person

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，您可以看到根本没有配置“ person”元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:creation_rules"><a class="anchor" href="#sec:creation_rules"></a> <a class="link" href="#sec:creation_rules">创作规则</a></h5>
<div class="paragraph">
<p>也可以在根级别创建模型元素。创建规则的一般形式为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    <span class="error">«</span>element-name<span class="error">»</span>(<span class="error">«</span>element-type<span class="error">»</span>) {
        <span class="error">«</span>initialization code<span class="error">»</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下模型规则创建了<code>"person"</code>元件：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_dsl_creation_rule"><a class="anchor" href="#example_dsl_creation_rule"></a> <a class="link" href="#example_dsl_creation_rule">示例：DSL创建规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    person(Person) {
        firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建规则定义指定要创建的元素的路径及其公共类型，以Java接口或类表示。只能创建某些类型的模型元素。</p>
</div>
<div class="paragraph">
<p>创建规则还可以提供一个闭包，其中包含在创建元素时要运行的初始化代码。使用作为闭合委托传递的元素执行闭合。到底可以提供什么代码取决于主题的类型。这将在下面讨论。</p>
</div>
<div class="paragraph">
<p>初始化闭包是可选的，可以省略，例如：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_dsl_creation_rule_without_initialization"><a class="anchor" href="#example_dsl_creation_rule_without_initialization"></a> <a class="link" href="#example_dsl_creation_rule_without_initialization">示例：没有初始化的DSL创建规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    barry(Person)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您应该注意，初始化代码不会立即执行，而是仅在需要元素时才执行。在运行任何配置规则之前，将执行初始化代码。例如：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_initialization_before_configuration"><a class="anchor" href="#example_initialization_before_configuration"></a> <a class="link" href="#example_initialization_before_configuration">示例：配置前初始化</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    person {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">configuring person</span><span class="delimiter">&quot;</span></span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">last name is </span><span class="inline"><span class="inline-delimiter">$</span>lastName</span><span class="content">, should be Smythe</span><span class="delimiter">&quot;</span></span>
        lastName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Smythe</span><span class="delimiter">&quot;</span></span>
    }
    person(Person) {
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">creating person</span><span class="delimiter">&quot;</span></span>
        firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>
        lastName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle showPerson</code></strong></div>
<div class="content">
<pre>&gt; gradle showPerson
creating person
configuring person
last name is Smith, should be Smythe

&gt; Task :showPerson
Hello John Smythe!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，创建规则在配置规则<em>之后</em>出现在构建脚本中，但是其代码在配置规则的代码之前运行。在运行任何规则之前，Gradle会收集特定主题的所有规则，然后以适当的顺序运行规则。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:model_rule_closures"><a class="anchor" href="#sec:model_rule_closures"></a> <a class="link" href="#sec:model_rule_closures">模型规则关闭</a></h5>
<div class="paragraph">
<p>大多数DSL规则都采用闭包形式，其中包含一些可运行以配置主题的代码。您可以在此闭包中使用的代码取决于规则主题的类型。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用<a href="#model-report">模型报告</a>来确定特定模型元素的类型。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，规则关闭可以包含任意代码，并与某些特定于类型的DSL语法混合。</p>
</div>
<div class="sect5">
<h6 id="sec:modelmap_subject"><a class="anchor" href="#sec:modelmap_subject"></a> <a class="link" href="#sec:modelmap_subject"><code>ModelMap<T></code>学科</a></h6>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelMap.html">ModelMap</a>基本上是模型元素的映射，并通过一些名称索引。当一个<code>ModelMap</code>用作DSL规则的主题时，规则闭包可以使用在<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelMap.html">ModelMap</a>接口上定义的任何方法。</p>
</div>
<div class="paragraph">
<p>规则关闭<code>ModelMap</code>主题也可以包括嵌套的创建或配置规则。它们的行为与直接显示在<code>model</code>块。</p>
</div>
<div class="paragraph">
<p>这是嵌套创建规则的示例：</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="example_nested_dsl_creation_rule"><a class="anchor" href="#example_nested_dsl_creation_rule"></a> <a class="link" href="#example_nested_dsl_creation_rule">示例：嵌套的DSL创建规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    people {
        john(Person) {
            firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与以前一样，嵌套的创建规则为元素定义名称和公共类型，还可以选择包含用于初始化元素的代码的闭包。仅在构建中需要元素时才运行代码。</p>
</div>
<div class="paragraph">
<p>这是嵌套配置规则的示例：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_nested_dsl_configuration_rule"><a class="anchor" href="#example_nested_dsl_configuration_rule"></a> <a class="link" href="#example_nested_dsl_configuration_rule">示例：嵌套的DSL配置规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    people {
        john {
            lastName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和以前一样，嵌套的配置规则定义了要配置的元素的名称以及一个包含用于配置元素的代码的闭包。仅在构建中需要元素时才运行代码。</p>
</div>
<div class="paragraph">
<p><code>ModelMap</code>引入其他几种规则。例如，您可以定义一个针对地图中每个元素的规则。需要该元素时，规则关闭中的代码对映射中的每个元素执行一次。让我们运行一个需要“ people”元素的所有子元素的任务：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_dsl_configuration_rule_for_each_element_in_a_map"><a class="anchor" href="#example_dsl_configuration_rule_for_each_element_in_a_map"></a> <a class="link" href="#example_dsl_configuration_rule_for_each_element_in_a_map">示例：映射中每个元素的DSL配置规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    people {
        john(Person) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">creating </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
            firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>
            lastName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>
        }
        all {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">configuring </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
        }
        barry(Person) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">creating </span><span class="inline"><span class="inline-delimiter">$</span><span class="local-variable">it</span></span><span class="delimiter">&quot;</span></span>
            firstName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Barry</span><span class="delimiter">&quot;</span></span>
            lastName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Barry</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle listPeople</code></strong></div>
<div class="content">
<pre>&gt; gradle listPeople
creating Person 'people.barry'
configuring Person 'people.barry'
creating Person 'people.john'
configuring Person 'people.john'

&gt; Task :listPeople
Hello Barry Barry!
Hello John Smith!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelMap.html">ModelMap</a>上接受<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Action.html">Action</a>作为其最后一个参数的任何方法也可以用于定义嵌套规则。</p>
</div>
<div class="sect5">
<h6 id="sec:managed_type_subject"><a class="anchor" href="#sec:managed_type_subject"></a> <a class="link" href="#sec:managed_type_subject"><code>@Managed</code>类型主题</a></h6>
<div class="paragraph">
<p>当将托管类型用作DSL规则的主题时，规则关闭可以使用在托管类型接口上定义的任何方法。</p>
</div>
<div class="paragraph">
<p>规则闭包也可以使用嵌套闭包来配置元素的属性。例如：</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="example_nested_dsl_property_configuration"><a class="anchor" href="#example_nested_dsl_property_configuration"></a> <a class="link" href="#example_nested_dsl_property_configuration">示例：嵌套的DSL属性配置</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    person {
        address {
            city = <span class="string"><span class="delimiter">&quot;</span><span class="content">Melbourne</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>当前，嵌套的闭包不定义规则，而是立即执行。请注意，此行为将在将来的Gradle版本中更改。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="sec:all_other_subjects"><a class="anchor" href="#sec:all_other_subjects"></a> <a class="link" href="#sec:all_other_subjects">所有其他科目</a></h6>
<div class="paragraph">
<p>对于所有其他类型，规则闭包可以使用该类型定义的任何方法。没有为这些元素定义特殊的DSL。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="dsl-type-coercion"><a class="anchor" href="#dsl-type-coercion"></a> <a class="link" href="#dsl-type-coercion">自动类型强制</a></h5>
<div class="paragraph">
<p>可以分配托管类型的标量属性<code>CharSequence</code>值（例如<code>String</code> ， <code>GString</code>等等），它们将为您转换为实际的属性类型。这适用于所有标量类型，包括“文件”，将相对于当前项目进行解析。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_a_dsl_example_showing_type_conversions"><a class="anchor" href="#example_a_dsl_example_showing_type_conversions"></a> <a class="link" href="#example_a_dsl_example_showing_type_conversions">示例：显示类型转换的DSL示例</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">enum</span> Temperature {
   TOO_HOT,
   TOO_COLD,
   JUST_RIGHT
}

<span class="annotation">@Managed</span>
<span class="type">interface</span> Item {
   <span class="type">void</span> setName(<span class="predefined-type">String</span> n); <span class="predefined-type">String</span> getName()

   <span class="type">void</span> setQuantity(<span class="type">int</span> q); <span class="type">int</span> getQuantity()

   <span class="type">void</span> setPrice(<span class="type">float</span> p); <span class="type">float</span> getPrice()

   <span class="type">void</span> setTemperature(Temperature t)
   Temperature getTemperature()

   <span class="type">void</span> setDataFile(<span class="predefined-type">File</span> f); <span class="predefined-type">File</span> getDataFile()
}

<span class="type">class</span> <span class="class">ItemRules</span> <span class="directive">extends</span> RuleSource {
   <span class="annotation">@Model</span>
   <span class="type">void</span> item(Item item) {
      <span class="keyword">def</span> data = item.dataFile.text.trim()
      <span class="keyword">def</span> (name, quantity, price, temp) = data.split(<span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span>)
      item.name = name
      item.quantity = quantity
      item.price = price
      item.temperature = temp
   }

   <span class="annotation">@Defaults</span>
   <span class="type">void</span> setDefaults(Item item) {
      item.dataFile = <span class="string"><span class="delimiter">'</span><span class="content">data.csv</span><span class="delimiter">'</span></span>
   }

   <span class="annotation">@Mutate</span>
   <span class="type">void</span> createDataTask(ModelMap&lt;Task&gt; tasks, Item item) {
      tasks.create(<span class="string"><span class="delimiter">'</span><span class="content">showData</span><span class="delimiter">'</span></span>) {
         doLast {
            println <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
Item '</span><span class="inline"><span class="inline-delimiter">$</span>item</span><span class="content">.name'
   quantity:    </span><span class="inline"><span class="inline-delimiter">$</span>item</span><span class="content">.quantity
   price:       </span><span class="inline"><span class="inline-delimiter">$</span>item</span><span class="content">.price
   temperature: </span><span class="inline"><span class="inline-delimiter">$</span>item</span><span class="content">.temperature</span><span class="delimiter">&quot;&quot;&quot;</span></span>
         }
      }
   }
}

apply <span class="key">plugin</span>: ItemRules

model {
   item {
      price = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>price * (quantity &lt; <span class="integer">10</span> ? <span class="integer">2</span> : <span class="float">0.5</span>)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
   }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/modelRules/modelDslCoercion</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在上面的示例中， <code>Item</code>创建并初始化<code>setDefaults()</code>通过提供数据文件的路径。在里面<code>item()</code>方法解决<code>File</code>被解析以提取和设置数据。最后在DSL块中，根据数量调整价格；如果剩余数量少于10个，则价格会翻倍，否则价格会降低50％。的<code>GString</code>表达式是有效值，因为它可以解析为<code>float</code>字符串形式的值。</p>
</div>
<div class="paragraph">
<p>最后，在<code>createDataTask()</code>我们添加<code>showData</code>任务以显示所有已配置的值。</p>
</div>
</div>
<div class="sect4">
<h5 id="dsl-rule-input-dependencies"><a class="anchor" href="#dsl-rule-input-dependencies"></a> <a class="link" href="#dsl-rule-input-dependencies">声明输入依赖</a></h5>
<div class="paragraph">
<p>DSL中声明的规则可以通过使用特殊语法来<em>依赖</em>于其他模型元素，该特殊语法的形式为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="error">$</span>.<span class="error">«</span>path-to-model-element<span class="error">»</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>路径是句点分隔的标识符列表。直接依赖<code>firstName</code>可以使用以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="error">$</span>.person.firstName</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="example_a_dsl_rule_using_inputs"><a class="anchor" href="#example_a_dsl_rule_using_inputs"></a> <a class="link" href="#example_a_dsl_rule_using_inputs">示例：使用输入的DSL规则</a></h5>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">model {
    tasks {
        hello(Task) {
            <span class="keyword">def</span> p = <span class="error">$</span>.person
            doLast {
                println <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">$</span>p</span><span class="content">.firstName </span><span class="inline"><span class="inline-delimiter">$</span>p</span><span class="content">.lastName!</span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/modelRules/modelDsl</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在以上代码段中， <code>$.person</code>构造是输入参考。构造返回指定路径上的model元素的值作为其默认类型（即<a href="#model-report">Model Report</a>通告的类型）。它可能出现在规则通常可以出现的规则中的任何位置。它不仅限于变量分配的右侧。</p>
</div>
<div class="paragraph">
<p>确保在规则执行之前已完全配置输入元素。也就是说，保证对元素进行变异的所有规则都已预先执行，从而使目标元素处于其最终的，不变的状态。</p>
</div>
<div class="paragraph">
<p>当用作输入时，大多数模型元素会强制不变性。尝试更改此类元素会导致运行时错误。但是，某些遗留类型对象当前未实现此类检查。无论如何，尝试将输入突变为规则始终是无效的。</p>
</div>
<div class="sect5">
<h6 id="sec:using_modelmap_as_an_input"><a class="anchor" href="#sec:using_modelmap_as_an_input"></a> <a class="link" href="#sec:using_modelmap_as_an_input">使用<code>ModelMap<T></code>作为输入</a></h6>
<div class="paragraph">
<p>当您使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/ModelMap.html">ModelMap</a>作为输入时，地图中的每个项目都可以作为属性使用。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="model-report"><a class="anchor" href="#model-report"></a> <a class="link" href="#model-report">模型报告</a></h4>
<div class="paragraph">
<p>内置的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.reporting.model.ModelReport.html">ModelReport</a>任务显示模型空间中元素的层次结构视图。每个项目都有一个前缀<code>+</code>模型报告上的是模型元素，这些元素的视觉嵌套与模型路径相关（例如<code>tasks.help</code> ）。模型报告显示有关每个模型元素的以下详细信息：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表18。模型报告-模型元素详细信息</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">详情</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是模型元素的基础类型，通常是完全限定的类名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当模型元素可以表示为字符串时，有条件地显示在报表上。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">创作者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个模型元素都有一个创建者。创建者表示模型元素的来源（即创建模型元素的来源）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">规则</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是针对给定模型元素执行的规则（不包括创建者规则）的列表。规则的显示顺序反映了规则的执行顺序。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="example_model_task_output"><a class="anchor" href="#example_model_task_output"></a> <a class="link" href="#example_model_task_output">示例：模型任务输出</a></h5>
<div class="listingblock">
<div class="title">输出<code>gradle model</code></div>
<div class="content">
<pre>&gt; gradle model

&gt; Task :model

------------------------------------------------------------
Root project
------------------------------------------------------------

+ person
      | Type:   	Person
      | Creator: 	PersonRules#person(Person)
      | Rules:
         ⤷ person { ... } @ build.gradle line 97, column 3
         ⤷ PersonRules#setFirstName(Person)
    + age
          | Type:   	int
          | Value:  	0
          | Creator: 	PersonRules#person(Person)
    + children
          | Type:   	org.gradle.model.ModelSet&lt;Person&gt;
          | Creator: 	PersonRules#person(Person)
    + employed
          | Type:   	boolean
          | Value:  	false
          | Creator: 	PersonRules#person(Person)
    + father
          | Type:   	Person
          | Value:  	null
          | Creator: 	PersonRules#person(Person)
    + firstName
          | Type:   	java.lang.String
          | Value:  	John
          | Creator: 	PersonRules#person(Person)
    + homeDirectory
          | Type:   	java.io.File
          | Value:  	null
          | Creator: 	PersonRules#person(Person)
    + id
          | Type:   	java.lang.Long
          | Value:  	null
          | Creator: 	PersonRules#person(Person)
    + lastName
          | Type:   	java.lang.String
          | Value:  	Smith
          | Creator: 	PersonRules#person(Person)
    + maritalStatus
          | Type:   	MaritalStatus
          | Creator: 	PersonRules#person(Person)
    + mother
          | Type:   	Person
          | Value:  	null
          | Creator: 	PersonRules#person(Person)
    + userGroups
          | Type:   	java.util.List&lt;java.lang.String&gt;
          | Value:  	null
          | Creator: 	PersonRules#person(Person)
+ tasks
      | Type:   	org.gradle.model.ModelMap&lt;org.gradle.api.Task&gt;
      | Creator: 	Project.&lt;init&gt;.tasks()
      | Rules:
         ⤷ PersonRules#createHelloTask(ModelMap&lt;Task&gt;, Person)
    + buildEnvironment
          | Type:   	org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask
          | Value:  	task ':buildEnvironment'
          | Creator: 	Project.&lt;init&gt;.tasks.buildEnvironment()
          | Rules:
             ⤷ copyToTaskContainer
    + components
          | Type:   	org.gradle.api.reporting.components.ComponentReport
          | Value:  	task ':components'
          | Creator: 	Project.&lt;init&gt;.tasks.components()
          | Rules:
             ⤷ copyToTaskContainer
    + dependencies
          | Type:   	org.gradle.api.tasks.diagnostics.DependencyReportTask
          | Value:  	task ':dependencies'
          | Creator: 	Project.&lt;init&gt;.tasks.dependencies()
          | Rules:
             ⤷ copyToTaskContainer
    + dependencyInsight
          | Type:   	org.gradle.api.tasks.diagnostics.DependencyInsightReportTask
          | Value:  	task ':dependencyInsight'
          | Creator: 	Project.&lt;init&gt;.tasks.dependencyInsight()
          | Rules:
             ⤷ copyToTaskContainer
    + dependentComponents
          | Type:   	org.gradle.api.reporting.dependents.DependentComponentsReport
          | Value:  	task ':dependentComponents'
          | Creator: 	Project.&lt;init&gt;.tasks.dependentComponents()
          | Rules:
             ⤷ copyToTaskContainer
    + hello
          | Type:   	org.gradle.api.Task
          | Value:  	task ':hello'
          | Creator: 	PersonRules#createHelloTask(ModelMap&lt;Task&gt;, Person) &gt; create(hello)
          | Rules:
             ⤷ copyToTaskContainer
    + help
          | Type:   	org.gradle.configuration.Help
          | Value:  	task ':help'
          | Creator: 	Project.&lt;init&gt;.tasks.help()
          | Rules:
             ⤷ copyToTaskContainer
    + init
          | Type:   	org.gradle.buildinit.tasks.InitBuild
          | Value:  	task ':init'
          | Creator: 	Project.&lt;init&gt;.tasks.init()
          | Rules:
             ⤷ copyToTaskContainer
    + model
          | Type:   	org.gradle.api.reporting.model.ModelReport
          | Value:  	task ':model'
          | Creator: 	Project.&lt;init&gt;.tasks.model()
          | Rules:
             ⤷ copyToTaskContainer
    + outgoingVariants
          | Type:   	org.gradle.api.tasks.diagnostics.OutgoingVariantsReportTask
          | Value:  	task ':outgoingVariants'
          | Creator: 	Project.&lt;init&gt;.tasks.outgoingVariants()
          | Rules:
             ⤷ copyToTaskContainer
    + prepareKotlinBuildScriptModel
          | Type:   	org.gradle.api.DefaultTask
          | Value:  	task ':prepareKotlinBuildScriptModel'
          | Creator: 	Project.&lt;init&gt;.tasks.prepareKotlinBuildScriptModel()
          | Rules:
             ⤷ copyToTaskContainer
    + projects
          | Type:   	org.gradle.api.tasks.diagnostics.ProjectReportTask
          | Value:  	task ':projects'
          | Creator: 	Project.&lt;init&gt;.tasks.projects()
          | Rules:
             ⤷ copyToTaskContainer
    + properties
          | Type:   	org.gradle.api.tasks.diagnostics.PropertyReportTask
          | Value:  	task ':properties'
          | Creator: 	Project.&lt;init&gt;.tasks.properties()
          | Rules:
             ⤷ copyToTaskContainer
    + tasks
          | Type:   	org.gradle.api.tasks.diagnostics.TaskReportTask
          | Value:  	task ':tasks'
          | Creator: 	Project.&lt;init&gt;.tasks.tasks()
          | Rules:
             ⤷ copyToTaskContainer
    + wrapper
          | Type:   	org.gradle.api.tasks.wrapper.Wrapper
          | Value:  	task ':wrapper'
          | Creator: 	Project.&lt;init&gt;.tasks.wrapper()
          | Rules:
             ⤷ copyToTaskContainer</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:limitations_and_future_direction"><a class="anchor" href="#sec:limitations_and_future_direction"></a> <a class="link" href="#sec:limitations_and_future_direction">局限性和未来方向</a></h4>
<div class="paragraph">
<p><em>作为软件模型一部分的规则引擎将被弃用。</em> 模型块下的所有内容都将移植为当前模型的扩展。与Gradle社区的其余部分相比，本机用户将不再具有单独的扩展模型，并且他们将能够使用新的变体感知依赖管理。有关更多信息，请参阅有关软件模型的状态和未来的<a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model">博客文章</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rule_source"><a class="anchor" href="#rule_source"></a> <a class="link" href="#rule_source">在插件中实现模型规则</a></h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>基于规则的配置<a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model">将被弃用</a> 。新插件不应使用此概念。相反，请使用“ <a href="#custom_plugins">编写自定义插件”</a>一章中描述的标准方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>插件可以通过扩展<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>并添加定义规则的方法来定义规则。插件类可以直接扩展<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>或可以实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">Plugin</a>并包含嵌套的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>子类。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅API文档中的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a> 。</p>
</div>
<div class="sect3">
<h4 id="sec:applying_additional_rules"><a class="anchor" href="#sec:applying_additional_rules"></a> <a class="link" href="#sec:applying_additional_rules">应用其他规则</a></h4>
<div class="paragraph">
<p>带有<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/Rules.html">规则</a>注释的规则方法可以将<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/model/RuleSource.html">RuleSource</a>应用于目标模型元素。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="software_model_extend"><a class="anchor" href="#software_model_extend"></a> <a class="link" href="#software_model_extend">扩展软件模型</a></h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>基于规则的配置<a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model">将被弃用</a> 。新插件不应使用此概念。相反，请使用“ <a href="#custom_plugins">编写自定义插件”</a>一章中描述的标准方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="introduction_2"><a class="anchor" href="#introduction_2"></a> <a class="link" href="#introduction_2">介绍</a></h4>
<div class="paragraph">
<p>Gradle的优势之一一直是其可扩展性以及对新领域的适应性。该软件模型将这种可扩展性提高到了一个新水平，从而可以通过类型丰富的DSL对特定域进行深度建模。下一章介绍如何扩展模型和相应的DSL以支持不同的域。在阅读本文之前，您应该熟悉Gradle软件模型<a href="#software_model">基于规则的配置</a>和<a href="#software_model_concepts">概念</a> 。</p>
</div>
<div class="paragraph">
<p>以下构建脚本是使用自定义软件模型构建基于Markdown的文档的示例：</p>
</div>
<div class="sect4">
<h5 id="example_an_example_of_using_a_custom_software_model"><a class="anchor" href="#example_an_example_of_using_a_custom_software_model"></a> <a class="link" href="#example_an_example_of_using_a_custom_software_model">示例：使用定制软件模型的示例</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">sample.documentation.DocumentationComponent</span>
<span class="keyword">import</span> <span class="include">sample.documentation.TextSourceSet</span>
<span class="keyword">import</span> <span class="include">sample.markdown.MarkdownSourceSet</span>

apply <span class="key">plugin</span>:sample.documentation.DocumentationPlugin
apply <span class="key">plugin</span>:sample.markdown.MarkdownPlugin

model {
    components {
        docs(DocumentationComponent) {
            sources {
                reference(TextSourceSet)
                userguide(MarkdownSourceSet) {
                    generateIndex = <span class="predefined-constant">true</span>
                    smartQuotes = <span class="predefined-constant">true</span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/customModel/languageType/</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本章的其余部分专用于解释此构建脚本背后的情况。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:concepts"><a class="anchor" href="#sec:concepts"></a> <a class="link" href="#sec:concepts">概念</a></h4>
<div class="paragraph">
<p>定制软件模型类型具有公共类型，基本界面和内部视图。然后，多个此类类型协作以定义自定义软件模型。</p>
</div>
<div class="sect4">
<h5 id="sec:public_type_and_base_interfaces"><a class="anchor" href="#sec:public_type_and_base_interfaces"></a> <a class="link" href="#sec:public_type_and_base_interfaces">公共类型和基本接口</a></h5>
<div class="paragraph">
<p>扩展类型声明了扩展<em>基本接口</em>的<em>公共类型</em> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>组件扩展了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentSpec.html">ComponentSpec</a>基本接口</p>
</li>
<li>
<p>二进制文件扩展了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/BinarySpec.html">BinarySpec</a>基本接口</p>
</li>
<li>
<p>源集扩展了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/LanguageSourceSet.html">LanguageSourceSet</a>基本接口</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>公共类型</em>暴露于构建逻辑。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:internal_views"><a class="anchor" href="#sec:internal_views"></a> <a class="link" href="#sec:internal_views">内部意见</a></h5>
<div class="paragraph">
<p>将内部视图添加到模型类型后，您可以使某些数据可见以通过公共类型构建逻辑，同时将其余数据隐藏在内部视图类型后面。这将在下面的<a href="#software-model-extend-internal-views">专用部分</a>中介绍。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:components_all_the_way_down"><a class="anchor" href="#sec:components_all_the_way_down"></a> <a class="link" href="#sec:components_all_the_way_down">组件一直向下</a></h5>
<div class="paragraph">
<p>组件由其他组件组成。源集只是表示源的一种特殊类型的组件。可能是提供或生成了源。同样，某些组件由不同的二进制文件组成，这些二进制文件由任务构建。所有可构建的组件都是由任务构建的。在软件模型中，您将编写规则以从组件生成二进制文件并从二进制文件生成任务。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:components"><a class="anchor" href="#sec:components"></a> <a class="link" href="#sec:components">组件</a></h4>
<div class="paragraph">
<p>要声明自定义组件类型，必须根据使用情况扩展<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentSpec.html">ComponentSpec</a>或以下之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/SourceComponentSpec.html">SourceComponentSpec</a>表示具有源的组件</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/VariantComponentSpec.html">VariantComponentSpec</a>表示一个组件，该组件根据上下文（目标平台，构建版本等）生成不同的二进制文件。这样的组件通常会产生多个二进制文件。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/GeneralComponentSpec.html">GeneralComponentSpec</a>是方便的基本接口，用于从源和变体感知构建的组件。这是许多软件组件的典型情况，因此在大多数情况下应该是扩展基本类型的基础。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>核心软件模型包含更多可以用作扩展基础的类型。例如： <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/LibrarySpec.html">LibrarySpec</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ApplicationSpec.html">ApplicationSpec</a>也可以以此方式扩展。这些是的无操作扩展<code>GeneralComponentSpec</code>通过区分库和应用程序组件来更好地描述软件模型。<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testing/base/TestSuiteSpec.html">TestSuiteSpec</a>应该用于描述测试套件的所有组件。</p>
</div>
<div class="sect4">
<h5 id="example_declare_a_custom_component"><a class="anchor" href="#example_declare_a_custom_component"></a> <a class="link" href="#example_declare_a_custom_component">示例：声明一个自定义组件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">DocumentationComponent.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Managed</span>
<span class="type">interface</span> DocumentationComponent <span class="directive">extends</span> GeneralComponentSpec {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型扩展<code>ComponentSpec</code>通过使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentType.html">ComponentType</a>注释的规则进行注册：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_register_a_custom_component"><a class="anchor" href="#example_register_a_custom_component"></a> <a class="link" href="#example_register_a_custom_component">示例：注册自定义组件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">DocumentationPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">DocumentationPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@ComponentType</span>
    <span class="type">void</span> registerComponent(TypeBuilder&lt;DocumentationComponent&gt; builder) {}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:binaries"><a class="anchor" href="#sec:binaries"></a> <a class="link" href="#sec:binaries">二进制文件</a></h4>
<div class="paragraph">
<p>要声明自定义二进制类型，必须扩展<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/BinarySpec.html">BinarySpec</a> 。</p>
</div>
<div class="sect4">
<h5 id="example_declare_a_custom_binary"><a class="anchor" href="#example_declare_a_custom_binary"></a> <a class="link" href="#example_declare_a_custom_binary">示例：声明一个自定义二进制文件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">DocumentationBinary.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Managed</span>
<span class="type">interface</span> DocumentationBinary <span class="directive">extends</span> BinarySpec {
    <span class="predefined-type">File</span> getOutputDir()
    <span class="type">void</span> setOutputDir(<span class="predefined-type">File</span> outputDir)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型扩展<code>BinarySpec</code>通过使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentType.html">ComponentType</a>注释的规则进行注册：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_register_a_custom_binary"><a class="anchor" href="#example_register_a_custom_binary"></a> <a class="link" href="#example_register_a_custom_binary">示例：注册自定义二进制文件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">DocumentationPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">DocumentationPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@ComponentType</span>
    <span class="type">void</span> registerBinary(TypeBuilder&lt;DocumentationBinary&gt; builder) {}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:source_sets"><a class="anchor" href="#sec:source_sets"></a> <a class="link" href="#sec:source_sets">源集</a></h4>
<div class="paragraph">
<p>要声明自定义源集类型，必须扩展<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/language/base/LanguageSourceSet.html">LanguageSourceSet</a> 。</p>
</div>
<div class="sect4">
<h5 id="example_declare_a_custom_source_set"><a class="anchor" href="#example_declare_a_custom_source_set"></a> <a class="link" href="#example_declare_a_custom_source_set">示例：声明一个自定义源集</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">MarkdownSourceSet.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Managed</span>
<span class="type">interface</span> MarkdownSourceSet <span class="directive">extends</span> LanguageSourceSet {
    <span class="type">boolean</span> isGenerateIndex()
    <span class="type">void</span> setGenerateIndex(<span class="type">boolean</span> generateIndex)

    <span class="type">boolean</span> isSmartQuotes()
    <span class="type">void</span> setSmartQuotes(<span class="type">boolean</span> smartQuotes)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型扩展<code>LanguageSourceSet</code>通过使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentType.html">ComponentType</a>注释的规则进行注册：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_register_a_custom_source_set"><a class="anchor" href="#example_register_a_custom_source_set"></a> <a class="link" href="#example_register_a_custom_source_set">示例：注册自定义源集</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">MarkdownPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">MarkdownPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@ComponentType</span>
    <span class="type">void</span> registerMarkdownLanguage(TypeBuilder&lt;MarkdownSourceSet&gt; builder) {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>必须设置<em>语言名称</em> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:putting_it_all_together"><a class="anchor" href="#sec:putting_it_all_together"></a> <a class="link" href="#sec:putting_it_all_together">放在一起</a></h4>
<div class="sect4">
<h5 id="sec:generating_binaries_from_components"><a class="anchor" href="#sec:generating_binaries_from_components"></a> <a class="link" href="#sec:generating_binaries_from_components">从组件生成二进制文件</a></h5>
<div class="paragraph">
<p>从组件生成二进制文件是通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/ComponentBinaries.html">ComponentBinaries</a>注释的规则完成的。此规则生成一个<code>DocumentationBinary</code>命名<code>exploded</code>每个<code>DocumentationComponent</code>并设置其<code>outputDir</code>属性：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_generates_documentation_binaries"><a class="anchor" href="#example_generates_documentation_binaries"></a> <a class="link" href="#example_generates_documentation_binaries">示例：生成文档二进制文件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">DocumentationPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">DocumentationPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@ComponentBinaries</span>
    <span class="type">void</span> generateDocBinaries(ModelMap&lt;DocumentationBinary&gt; binaries, VariantComponentSpec component, <span class="annotation">@Path</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">buildDir</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">File</span> buildDir) {
        binaries.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">exploded</span><span class="delimiter">&quot;</span></span>) { binary -&gt;
            outputDir = <span class="keyword">new</span> <span class="predefined-type">File</span>(buildDir, <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>component.name<span class="inline-delimiter">}</span></span><span class="content">/</span><span class="inline"><span class="inline-delimiter">${</span>binary.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:generating_tasks_from_binaries"><a class="anchor" href="#sec:generating_tasks_from_binaries"></a> <a class="link" href="#sec:generating_tasks_from_binaries">从二进制文件生成任务</a></h5>
<div class="paragraph">
<p>从二进制文件生成任务是通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/platform/base/BinaryTasks.html">BinaryTasks</a>注释的规则完成的。此规则生成一个<code>Copy</code>每个任务<code>TextSourceSet</code>每个<code>DocumentationBinary</code> ：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_generates_tasks_for_text_source_sets"><a class="anchor" href="#example_generates_tasks_for_text_source_sets"></a> <a class="link" href="#example_generates_tasks_for_text_source_sets">示例：为文本源集生成任务</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">DocumentationPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">DocumentationPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@BinaryTasks</span>
    <span class="type">void</span> generateTextTasks(ModelMap&lt;Task&gt; tasks, <span class="directive">final</span> DocumentationBinary binary) {
        binary.inputs.withType(TextSourceSet) { textSourceSet -&gt;
            <span class="keyword">def</span> taskName = binary.tasks.taskName(<span class="string"><span class="delimiter">&quot;</span><span class="content">compile</span><span class="delimiter">&quot;</span></span>, textSourceSet.name)
            <span class="keyword">def</span> outputDir = <span class="keyword">new</span> <span class="predefined-type">File</span>(binary.outputDir, textSourceSet.name)
            tasks.create(taskName, Copy) {
                from textSourceSet.source
                destinationDir = outputDir
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此规则生成一个<code>MarkdownCompileTask</code>每个任务<code>MarkdownSourceSet</code>每个<code>DocumentationBinary</code> ：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_register_a_custom_source_set_2"><a class="anchor" href="#example_register_a_custom_source_set_2"></a> <a class="link" href="#example_register_a_custom_source_set_2">示例：注册自定义源集</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">MarkdownPlugin.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">MarkdownPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@BinaryTasks</span>
    <span class="type">void</span> processMarkdownDocumentation(ModelMap&lt;Task&gt; tasks, <span class="directive">final</span> DocumentationBinary binary) {
        binary.inputs.withType(MarkdownSourceSet) { markdownSourceSet -&gt;
            <span class="keyword">def</span> taskName = binary.tasks.taskName(<span class="string"><span class="delimiter">&quot;</span><span class="content">compile</span><span class="delimiter">&quot;</span></span>, markdownSourceSet.name)
            <span class="keyword">def</span> outputDir = <span class="keyword">new</span> <span class="predefined-type">File</span>(binary.outputDir, markdownSourceSet.name)
            tasks.create(taskName, MarkdownHtmlCompile) { compileTask -&gt;
                compileTask.source = markdownSourceSet.source
                compileTask.destinationDir = outputDir
                compileTask.smartQuotes = markdownSourceSet.smartQuotes
                compileTask.generateIndex = markdownSourceSet.generateIndex
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参见示例源。 <code>MarkdownCompileTask</code>任务。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_your_custom_model"><a class="anchor" href="#sec:using_your_custom_model"></a> <a class="link" href="#sec:using_your_custom_model">使用您的自定义模型</a></h5>
<div class="paragraph">
<p>此构建脚本演示了以上各节中定义的自定义模型的用法：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_an_example_of_using_a_custom_software_model_2"><a class="anchor" href="#example_an_example_of_using_a_custom_software_model_2"></a> <a class="link" href="#example_an_example_of_using_a_custom_software_model_2">示例：使用定制软件模型的示例</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">sample.documentation.DocumentationComponent</span>
<span class="keyword">import</span> <span class="include">sample.documentation.TextSourceSet</span>
<span class="keyword">import</span> <span class="include">sample.markdown.MarkdownSourceSet</span>

apply <span class="key">plugin</span>:sample.documentation.DocumentationPlugin
apply <span class="key">plugin</span>:sample.markdown.MarkdownPlugin

model {
    components {
        docs(DocumentationComponent) {
            sources {
                reference(TextSourceSet)
                userguide(MarkdownSourceSet) {
                    generateIndex = <span class="predefined-constant">true</span>
                    smartQuotes = <span class="predefined-constant">true</span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/customModel/languageType/</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在此类构建脚本的组件报告中，我们可以看到正确注册的模型类型：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_components_report"><a class="anchor" href="#example_components_report"></a> <a class="link" href="#example_components_report">示例：组件报告</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q components</code></strong></div>
<div class="content">
<pre>&gt; gradle -q components

------------------------------------------------------------
Root project
------------------------------------------------------------

DocumentationComponent 'docs'
-----------------------------

Source sets
    Markdown source 'docs:userguide'
        srcDir: src/docs/userguide
    Text source 'docs:reference'
        srcDir: src/docs/reference

Binaries
    DocumentationBinary 'docs:exploded'
        build using task: :docsExploded

Note: currently not all plugins register their components, so some components may not be visible here.</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="software-model-extend-internal-views"><a class="anchor" href="#software-model-extend-internal-views"></a> <a class="link" href="#software-model-extend-internal-views">关于内部视图</a></h4>
<div class="paragraph">
<p>内部视图可以添加到已经注册的类型或新的自定义类型。换句话说，使用内部视图，您可以将额外的属性附加到已注册的组件，二进制文件和源集类型，例如<code>JvmLibrarySpec</code> ， <code>JarBinarySpec</code>要么<code>JavaSourceSet</code>以及您编写的自定义类型。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的组件public类型及其内部视图声明开始：</p>
</div>
<div class="sect4">
<h5 id="example_public_type_and_internal_view_declaration"><a class="anchor" href="#example_public_type_and_internal_view_declaration"></a> <a class="link" href="#example_public_type_and_internal_view_declaration">示例：公共类型和内部视图声明</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Managed</span> <span class="type">interface</span> MyComponent <span class="directive">extends</span> ComponentSpec {
    <span class="predefined-type">String</span> getPublicData()
    <span class="type">void</span> setPublicData(<span class="predefined-type">String</span> data)
}
<span class="annotation">@Managed</span> <span class="type">interface</span> MyComponentInternal <span class="directive">extends</span> MyComponent {
    <span class="predefined-type">String</span> getInternalData()
    <span class="type">void</span> setInternalData(<span class="predefined-type">String</span> internal)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型注册如下：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_type_registration"><a class="anchor" href="#example_type_registration"></a> <a class="link" href="#example_type_registration">示例：类型注册</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">MyPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@ComponentType</span>
    <span class="type">void</span> registerMyComponent(TypeBuilder&lt;MyComponent&gt; builder) {
        builder.internalView(MyComponentInternal)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>internalView(type)</code>可以多次调用类型构建器的方法。这是您将几种内部视图添加到类型的方式。</p>
</div>
<div class="paragraph">
<p>现在，让我们使用一些规则对公共数据和内部数据进行突变：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_public_and_internal_data_mutation"><a class="anchor" href="#example_public_and_internal_data_mutation"></a> <a class="link" href="#example_public_and_internal_data_mutation">示例：公共和内部数据突变</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">MyPlugin</span> <span class="directive">extends</span> RuleSource {
    <span class="annotation">@Mutate</span>
    <span class="type">void</span> mutateMyComponents(ModelMap&lt;MyComponentInternal&gt; components) {
        components.all { component -&gt;
            component.publicData = <span class="string"><span class="delimiter">&quot;</span><span class="content">Some PUBLIC data</span><span class="delimiter">&quot;</span></span>
            component.internalData = <span class="string"><span class="delimiter">&quot;</span><span class="content">Some INTERNAL data</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的<code>internalData</code>属性不应暴露给构建逻辑。让我们使用<code>model</code>以下构建文件上的任务：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_build_script_and_model_report_output"><a class="anchor" href="#example_build_script_and_model_report_output"></a> <a class="link" href="#example_build_script_and_model_report_output">示例：构建脚本和模型报告输出</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">apply <span class="key">plugin</span>: MyPlugin
model {
    components {
        my(MyComponent)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q model</code></div>
<div class="content">
<pre>&gt; gradle -q model

------------------------------------------------------------
Root project
------------------------------------------------------------

+ components
      | Type:   	org.gradle.platform.base.ComponentSpecContainer
      | Creator: 	ComponentBasePlugin.PluginRules#components(ComponentSpecContainer)
      | Rules:
         ⤷ components { ... } @ build.gradle line 53, column 5
         ⤷ MyPlugin#mutateMyComponents(ModelMap&lt;MyComponentInternal&gt;)
    + my
          | Type:   	MyComponent
          | Creator: 	components { ... } @ build.gradle line 53, column 5 &gt; create(my)
          | Rules:
             ⤷ MyPlugin#mutateMyComponents(ModelMap&lt;MyComponentInternal&gt;) &gt; all()
        + publicData
              | Type:   	java.lang.String
              | Value:  	Some PUBLIC data
              | Creator: 	components { ... } @ build.gradle line 53, column 5 &gt; create(my)
+ tasks
      | Type:   	org.gradle.model.ModelMap&lt;org.gradle.api.Task&gt;
      | Creator: 	Project.&lt;init&gt;.tasks()
    + assemble
          | Type:   	org.gradle.api.DefaultTask
          | Value:  	task ':assemble'
          | Creator: 	Project.&lt;init&gt;.tasks.assemble()
          | Rules:
             ⤷ copyToTaskContainer
    + build
          | Type:   	org.gradle.api.DefaultTask
          | Value:  	task ':build'
          | Creator: 	Project.&lt;init&gt;.tasks.build()
          | Rules:
             ⤷ copyToTaskContainer
    + buildEnvironment
          | Type:   	org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask
          | Value:  	task ':buildEnvironment'
          | Creator: 	Project.&lt;init&gt;.tasks.buildEnvironment()
          | Rules:
             ⤷ copyToTaskContainer
    + check
          | Type:   	org.gradle.api.DefaultTask
          | Value:  	task ':check'
          | Creator: 	Project.&lt;init&gt;.tasks.check()
          | Rules:
             ⤷ copyToTaskContainer
    + clean
          | Type:   	org.gradle.api.tasks.Delete
          | Value:  	task ':clean'
          | Creator: 	Project.&lt;init&gt;.tasks.clean()
          | Rules:
             ⤷ copyToTaskContainer
    + components
          | Type:   	org.gradle.api.reporting.components.ComponentReport
          | Value:  	task ':components'
          | Creator: 	Project.&lt;init&gt;.tasks.components()
          | Rules:
             ⤷ copyToTaskContainer
    + dependencies
          | Type:   	org.gradle.api.tasks.diagnostics.DependencyReportTask
          | Value:  	task ':dependencies'
          | Creator: 	Project.&lt;init&gt;.tasks.dependencies()
          | Rules:
             ⤷ copyToTaskContainer
    + dependencyInsight
          | Type:   	org.gradle.api.tasks.diagnostics.DependencyInsightReportTask
          | Value:  	task ':dependencyInsight'
          | Creator: 	Project.&lt;init&gt;.tasks.dependencyInsight()
          | Rules:
             ⤷ copyToTaskContainer
    + dependentComponents
          | Type:   	org.gradle.api.reporting.dependents.DependentComponentsReport
          | Value:  	task ':dependentComponents'
          | Creator: 	Project.&lt;init&gt;.tasks.dependentComponents()
          | Rules:
             ⤷ copyToTaskContainer
    + help
          | Type:   	org.gradle.configuration.Help
          | Value:  	task ':help'
          | Creator: 	Project.&lt;init&gt;.tasks.help()
          | Rules:
             ⤷ copyToTaskContainer
    + init
          | Type:   	org.gradle.buildinit.tasks.InitBuild
          | Value:  	task ':init'
          | Creator: 	Project.&lt;init&gt;.tasks.init()
          | Rules:
             ⤷ copyToTaskContainer
    + model
          | Type:   	org.gradle.api.reporting.model.ModelReport
          | Value:  	task ':model'
          | Creator: 	Project.&lt;init&gt;.tasks.model()
          | Rules:
             ⤷ copyToTaskContainer
    + outgoingVariants
          | Type:   	org.gradle.api.tasks.diagnostics.OutgoingVariantsReportTask
          | Value:  	task ':outgoingVariants'
          | Creator: 	Project.&lt;init&gt;.tasks.outgoingVariants()
          | Rules:
             ⤷ copyToTaskContainer
    + prepareKotlinBuildScriptModel
          | Type:   	org.gradle.api.DefaultTask
          | Value:  	task ':prepareKotlinBuildScriptModel'
          | Creator: 	Project.&lt;init&gt;.tasks.prepareKotlinBuildScriptModel()
          | Rules:
             ⤷ copyToTaskContainer
    + projects
          | Type:   	org.gradle.api.tasks.diagnostics.ProjectReportTask
          | Value:  	task ':projects'
          | Creator: 	Project.&lt;init&gt;.tasks.projects()
          | Rules:
             ⤷ copyToTaskContainer
    + properties
          | Type:   	org.gradle.api.tasks.diagnostics.PropertyReportTask
          | Value:  	task ':properties'
          | Creator: 	Project.&lt;init&gt;.tasks.properties()
          | Rules:
             ⤷ copyToTaskContainer
    + tasks
          | Type:   	org.gradle.api.tasks.diagnostics.TaskReportTask
          | Value:  	task ':tasks'
          | Creator: 	Project.&lt;init&gt;.tasks.tasks()
          | Rules:
             ⤷ copyToTaskContainer
    + wrapper
          | Type:   	org.gradle.api.tasks.wrapper.Wrapper
          | Value:  	task ':wrapper'
          | Creator: 	Project.&lt;init&gt;.tasks.wrapper()
          | Rules:
             ⤷ copyToTaskContainer</pre>
</div>
</div>
<div class="paragraph">
<p>我们可以在这份报告中看到<code>publicData</code>存在并且那个<code>internalData</code>不是。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="part:extending_gradle"><a class="anchor" href="#part:extending_gradle"></a> <a class="link" href="#part:extending_gradle">扩展摇篮</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="custom_tasks"><a class="anchor" href="#custom_tasks"></a> <a class="link" href="#custom_tasks">开发自定义Gradle任务类型</a></h3>
<div class="paragraph">
<p>Gradle支持两种类型的任务。一种这样的类型是简单任务，您可以在其中用动作关闭定义任务。我们已经在<a href="#tutorial_using_tasks">Build Script Basics中</a>看到了这些。对于这种类型的任务，动作关闭确定任务的行为。此类任务非常适合在构建脚本中实施一次性任务。</p>
</div>
<div class="paragraph">
<p>任务的另一种类型是增强型任务，其中行为内置于任务中，并且该任务提供了一些可用于配置行为的属性。我们已经在<a href="#more_about_tasks">创作任务中</a>看到了这些。大多数Gradle插件使用增强的任务。使用增强型任务，您不需要像处理简单任务那样实现任务行为。您只需声明任务并使用其属性配置任务。通过这种方式，增强的任务使您可以在许多不同的地方（可能跨不同的构建）重用某种行为。</p>
</div>
<div class="paragraph">
<p>增强型任务的行为和属性由任务的类定义。声明增强的任务时，可以指定任务的类型或类。</p>
</div>
<div class="paragraph">
<p>在Gradle中实现自己的自定义任务类很容易。您可以使用任何您喜欢的语言来实现自定义任务类，只要最终将其编译为JVM字节码即可。在我们的示例中，我们将使用Groovy作为实现语言。Groovy，Java或Kotlin都是用于实现任务类的语言，它们都是不错的选择，因为Gradle API已被设计为与这些语言很好地兼容。通常，使用Java或Kotlin（静态类型）实现的任务将比使用Groovy实现的任务执行得更好。</p>
</div>
<div class="sect3">
<h4 id="sec:packaging_a_task_class"><a class="anchor" href="#sec:packaging_a_task_class"></a> <a class="link" href="#sec:packaging_a_task_class">打包任务类</a></h4>
<div class="paragraph">
<p>您可以在几个地方放置任务类的源代码。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">构建脚本</dt>
<dd>
<p>您可以将任务类直接包含在构建脚本中。这样的好处是，任务类将自动编译并包含在构建脚本的类路径中，而无需执行任何操作。但是，任务类在构建脚本之外不可见，因此您不能在定义该任务的构建脚本之外重用该任务类。</p>
</dd>
<dt class="hdlist1"><code>buildSrc</code>项目</dt>
<dd>
<p>您可以将任务类的源放在<code><em>rootProjectDir</em>/buildSrc/src/main/groovy</code>目录（或<code><em>rootProjectDir</em>/buildSrc/src/main/java</code>要么<code><em>rootProjectDir</em>/buildSrc/src/main/kotlin</code>取决于您喜欢的语言）。Gradle将负责编译和测试任务类，并使其在构建脚本的类路径中可用。任务类对于构建所使用的每个构建脚本都是可见的。但是，它在构建外部不可见，因此您不能在定义该构建的外部重用任务类。使用<code>buildSrc</code>项目方法将任务声明（即任务应执行的操作）与任务实现（即任务的执行方式）分开。</p>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#organizing_gradle_projects">组织Gradle项目</a> 。 <code>buildSrc</code>项目。</p>
</div>
</dd>
<dt class="hdlist1">独立项目</dt>
<dd>
<p>您可以为任务类创建一个单独的项目。这个项目产生并发布了一个JAR，您可以在多个版本中使用它并与他人共享。通常，此JAR可能包含一些自定义插件，或将几个相关的任务类捆绑到一个库中。或两者的某种组合。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在我们的示例中，我们将从构建脚本中的任务类开始，以使事情变得简单。然后，我们将考虑创建一个独立的项目。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:writing_a_simple_task_class"><a class="anchor" href="#sec:writing_a_simple_task_class"></a> <a class="link" href="#sec:writing_a_simple_task_class">编写一个简单的任务类</a></h4>
<div class="paragraph">
<p>要实现自定义任务类，可以扩展<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.DefaultTask.html">DefaultTask</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例464定义自定义任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingTask</span> <span class="directive">extends</span> DefaultTask {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GreetingTask : DefaultTask() {
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该任务没有做任何有用的事情，因此让我们添加一些行为。为此，我们向任务添加一个方法，并使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskAction.html">TaskAction</a>批注对其进行标记。任务执行时，Gradle将调用该方法。您不必使用方法来定义任务的行为。例如，您可以致电<code>doFirst()</code>要么<code>doLast()</code>在任务构造函数中使用闭包来添加行为。</p>
</div>
<div class="exampleblock">
<div class="title">示例465你好，世界任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingTask</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@TaskAction</span>
    <span class="keyword">def</span> <span class="function">greet</span>() {
        println <span class="string"><span class="delimiter">'</span><span class="content">hello from GreetingTask</span><span class="delimiter">'</span></span>
    }
}

<span class="comment">// Create a task using the task type</span>
task hello(<span class="key">type</span>: GreetingTask)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GreetingTask : DefaultTask() {
    @TaskAction
    fun greet() {
        println(&quot;hello from GreetingTask&quot;)
    }
}

// Create a task using the task type
tasks.register&lt;GreetingTask&gt;(&quot;hello&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
hello from GreetingTask</pre>
</div>
</div>
<div class="paragraph">
<p>让我们为任务添加一个属性，以便我们可以对其进行自定义。任务只是POGO，在声明任务时，可以在任务对象上设置属性或调用方法。在这里我们添加一个<code>greeting</code>属性，并在我们声明<code>greeting</code>任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例466可自定义的hello world任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingTask</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@Input</span>
    <span class="predefined-type">String</span> greeting = <span class="string"><span class="delimiter">'</span><span class="content">hello from GreetingTask</span><span class="delimiter">'</span></span>

    <span class="annotation">@TaskAction</span>
    <span class="keyword">def</span> <span class="function">greet</span>() {
        println greeting
    }
}

<span class="comment">// Use the default greeting</span>
task hello(<span class="key">type</span>: GreetingTask)

<span class="comment">// Customize the greeting</span>
task greeting(<span class="key">type</span>: GreetingTask) {
    greeting = <span class="string"><span class="delimiter">'</span><span class="content">greetings from GreetingTask</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GreetingTask : DefaultTask() {
    @get:Input
    var greeting = &quot;hello from GreetingTask&quot;

    @TaskAction
    fun greet() {
        println(greeting)
    }
}

// Use the default greeting
tasks.register&lt;GreetingTask&gt;(&quot;hello&quot;)

// Customize the greeting
tasks.register&lt;GreetingTask&gt;(&quot;greeting&quot;) {
    greeting = &quot;greetings from GreetingTask&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello greeting</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello greeting
hello from GreetingTask
greetings from GreetingTask</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:custom_tasks_standalone_project"><a class="anchor" href="#sec:custom_tasks_standalone_project"></a> <a class="link" href="#sec:custom_tasks_standalone_project">一个独立的项目</a></h4>
<div class="paragraph">
<p>现在，我们将把任务移到一个独立的项目中，以便我们可以发布它并与他人共享它。这个项目只是一个Groovy项目，它产生一个包含任务类的JAR。这是该项目的简单构建脚本。它应用了Groovy插件，并将Gradle API添加为编译时依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">示例467自定义任务的构建</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>
}

dependencies {
    implementation gradleApi()
    implementation localGroovy()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    groovy
}

dependencies {
    implementation(gradleApi())
    implementation(localGroovy())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/customPlugin</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们只是遵循任务类源应该放在哪里的约定。</p>
</div>
<div class="sect4">
<h5 id="example_a_custom_task"><a class="anchor" href="#example_a_custom_task"></a> <a class="link" href="#example_a_custom_task">示例：自定义任务</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src / main / groovy / org / gradle / GreetingTask.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> org.gradle

<span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>

<span class="type">class</span> <span class="class">GreetingTask</span> <span class="directive">extends</span> DefaultTask {
    <span class="predefined-type">String</span> greeting = <span class="string"><span class="delimiter">'</span><span class="content">hello from GreetingTask</span><span class="delimiter">'</span></span>

    <span class="annotation">@TaskAction</span>
    <span class="keyword">def</span> <span class="function">greet</span>() {
        println greeting
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_your_task_class_in_another_project"><a class="anchor" href="#sec:using_your_task_class_in_another_project"></a> <a class="link" href="#sec:using_your_task_class_in_another_project">在另一个项目中使用您的任务类</a></h5>
<div class="paragraph">
<p>要在构建脚本中使用任务类，您需要将该类添加到构建脚本的类路径中。为此，您可以使用<code>buildscript { }</code>块，如<a href="#sec:build_script_external_dependencies">构建脚本的外部依赖项中所述</a> 。以下示例显示了包含任务类的JAR已发布到本地存储库时如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例468。在另一个项目中使用自定义任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildscript {
    repositories {
        maven {
            url = uri(repoLocation)
        }
    }
    dependencies {
        classpath <span class="string"><span class="delimiter">'</span><span class="content">org.gradle:customPlugin:1.0-SNAPSHOT</span><span class="delimiter">'</span></span>
    }
}

task greeting(<span class="key">type</span>: org.gradle.GreetingTask) {
    greeting = <span class="string"><span class="delimiter">'</span><span class="content">howdy!</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildscript {
    repositories {
        maven {
            url = uri(repoLocation)
        }
    }
    dependencies {
        classpath(&quot;org.gradle:customPlugin:1.0-SNAPSHOT&quot;)
    }
}

tasks.register&lt;org.gradle.GreetingTask&gt;(&quot;greeting&quot;) {
    greeting = &quot;howdy!&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:writing_tests_for_your_task_class"><a class="anchor" href="#sec:writing_tests_for_your_task_class"></a> <a class="link" href="#sec:writing_tests_for_your_task_class">为任务类编写测试</a></h5>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testfixtures/ProjectBuilder.html">ProjectBuilder</a>类创建在测试任务类时要使用的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a>实例。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_testing_a_custom_task"><a class="anchor" href="#example_testing_a_custom_task"></a> <a class="link" href="#example_testing_a_custom_task">示例：测试自定义任务</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src / test / groovy / org / gradle / GreetingTaskTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingTaskTest</span> {
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> canAddTaskToProject() {
        Project project = ProjectBuilder.builder().build()
        <span class="keyword">def</span> task = project.task(<span class="string"><span class="delimiter">'</span><span class="content">greeting</span><span class="delimiter">'</span></span>, <span class="key">type</span>: GreetingTask)
        assertTrue(task <span class="keyword">instanceof</span> GreetingTask)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="incremental_tasks"><a class="anchor" href="#incremental_tasks"></a> <a class="link" href="#incremental_tasks">增量任务</a></h4>
<div class="paragraph">
<p>使用Gradle，实现一个在所有输入和输出都是最新的情况下将被跳过的任务非常简单（请参阅<a href="#sec:up_to_date_checks">增量构建</a> ）。但是，自上次执行以来，有时只有少数输入文件已更改，因此您希望避免重新处理所有未更改的输入。这对于将输入文件按1：1转换为输出文件的转换器任务特别有用。</p>
</div>
<div class="paragraph">
<p>如果您想优化构建以仅处理过时的输入文件，则可以使用<em>增量任务来进行处理</em> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>有<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/incremental/IncrementalTaskInputs.html">IncrementalTaskInputs</a> API，在5.4之前的Gradle版本中可用。使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/incremental/IncrementalTaskInputs.html">IncrementalTaskInputs时</a> ，只能查询任务输入的所有文件更改。无法查询各个输入文件属性的更改。此外，旧的API不能区分增量任务输入和非增量任务输入，因此任务本身需要确定更改的来源。因此，不建议使用此API，并最终将其删除。本文记录了新的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html">InputChanges</a> API，它取代了旧的API并解决了其缺点。如果需要使用旧的API，请查看<a href="https://docs.gradle.org/5.3.1/userguide/custom_tasks.html#incremental_tasks">Gradle 5.3.1用户手册</a>中的文档。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="sec:implementing_an_incremental_task"><a class="anchor" href="#sec:implementing_an_incremental_task"></a> <a class="link" href="#sec:implementing_an_incremental_task">实施增量任务</a></h5>
<div class="paragraph">
<p>为了使任务增量处理输入，该任务必须包含<em>增量任务action</em> 。这是一个具有单个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html">InputChanges</a>参数的任务操作方法。该参数告诉Gradle该操作仅想处理更改的输入。另外，任务需要使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/work/Incremental.html">@Incremental</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/SkipWhenEmpty.html">@SkipWhenEmpty</a>声明至少一个增量文件输入属性。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title">重要</div>
</td>
<td class="content">
<div class="paragraph">
<p>要查询输入文件属性的增量更改，该属性始终需要返回相同的实例。完成此操作的最简单方法是对此类属性使用以下类型之一： <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/RegularFileProperty.html">RegularFileProperty</a> ， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/DirectoryProperty.html">DirectoryProperty</a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ConfigurableFileCollection.html">ConfigurableFileCollection</a> 。</p>
</div>
<div class="paragraph">
<p>您可以了解更多有关<code>RegularFileProperty</code>和<code>DirectoryProperty</code>在“ <a href="#lazy_configuration">惰性配置”</a>一章中，特别是在有关<a href="#sec:lazy_properties">使用只读和可配置属性</a>以及<a href="#sec:working_with_files_in_lazy_properties">惰性文件属性的部分中</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>增量任务操作可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges(org.gradle.api.file.FileCollection)">InputChanges.getFileChanges（）</a>来查找给定的基于文件的输入属性的哪些文件已更改，无论其类型如何<code>RegularFileProperty</code> ， <code>DirectoryProperty</code>要么<code>ConfigurableFileCollection</code> 。该方法返回一个<code>Iterable</code>类型为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/work/FileChange.html">FileChanges</a> ，然后可以查询以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/work/FileChange.html#getFile--">受影响的文件</a></p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/work/FileChange.html#getChangeType--">变更类型</a> （ <code>ADDED</code> ， <code>REMOVED</code>要么<code>MODIFIED</code> ）</p>
</li>
<li>
<p>更改文件的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/work/FileChange.html#getNormalizedPath--">规范化路径</a></p>
</li>
<li>
<p>更改文件的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/work/FileChange.html#getFileType--">文件类型</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例演示了具有目录输入的增量任务。假定目录包含文本文件的集合，并将它们复制到输出目录，以反转每个文件中的文本。要注意的关键是<code>inputDir</code>属性，其注释以及操作方式（ <code>execute()</code> ）用途<code>getFileChanges()</code>处理自上次构建以来实际上已更改的文件的子集。您还可以查看如果删除了相应的输入文件，则该操作如何删除目标文件：</p>
</div>
<div id="taskDefinition" class="exampleblock">
<div class="title">示例469定义增量任务操作</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">IncrementalReverseTask</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@Incremental</span>
    <span class="annotation">@PathSensitive</span>(PathSensitivity.NAME_ONLY)
    <span class="annotation">@InputDirectory</span>
    <span class="directive">abstract</span> DirectoryProperty getInputDir()

    <span class="annotation">@OutputDirectory</span>
    <span class="directive">abstract</span> DirectoryProperty getOutputDir()

    <span class="annotation">@Input</span>
    <span class="directive">abstract</span> Property&lt;<span class="predefined-type">String</span>&gt; getInputProperty()

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> execute(InputChanges inputChanges) {
        println(inputChanges.incremental
            ? <span class="string"><span class="delimiter">'</span><span class="content">Executing incrementally</span><span class="delimiter">'</span></span>
            : <span class="string"><span class="delimiter">'</span><span class="content">Executing non-incrementally</span><span class="delimiter">'</span></span>
        )

        inputChanges.getFileChanges(inputDir).each { change -&gt;
            <span class="keyword">if</span> (change.fileType == FileType.DIRECTORY) <span class="keyword">return</span>

            println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>change.changeType<span class="inline-delimiter">}</span></span><span class="content">: </span><span class="inline"><span class="inline-delimiter">${</span>change.normalizedPath<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
            <span class="keyword">def</span> targetFile = outputDir.file(change.normalizedPath).get().asFile
            <span class="keyword">if</span> (change.changeType == ChangeType.REMOVED) {
                targetFile.delete()
            } <span class="keyword">else</span> {
                targetFile.text = change.file.text.reverse()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">abstract class IncrementalReverseTask : DefaultTask() {
    @get:Incremental
    @get:PathSensitive(PathSensitivity.NAME_ONLY)
    @get:InputDirectory
    abstract val inputDir: DirectoryProperty

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @get:Input
    abstract val inputProperty: Property&lt;String&gt;

    @TaskAction
    fun execute(inputChanges: InputChanges) {
        println(
            if (inputChanges.isIncremental) &quot;Executing incrementally&quot;
            else &quot;Executing non-incrementally&quot;
        )

        inputChanges.getFileChanges(inputDir).forEach { change -&gt;
            if (change.fileType == FileType.DIRECTORY) return@forEach

            println(&quot;${change.changeType}: ${change.normalizedPath}&quot;)
            val targetFile = outputDir.file(change.normalizedPath).get().asFile
            if (change.changeType == ChangeType.REMOVED) {
                targetFile.delete()
            } else {
                targetFile.writeText(change.file.readText().reversed())
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/userguide/tasks/incrementalTask</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果由于某种原因该任务非增量执行，例如通过运行<code>--rerun-tasks</code> ，所有文件均报告为<code>ADDED</code> ，无论之前的状态如何。在这种情况下，Gradle自动删除先前的输出，因此增量任务仅需要处理给定的文件。</p>
</div>
<div class="paragraph">
<p>对于像上述示例这样的简单转换器任务，任务操作仅需要为任何过期输入生成输出文件，并为任何已删除输入删除输出文件。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title">重要</div>
</td>
<td class="content">
<div class="paragraph">
<p>一个任务只能包含一个增量任务动作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sec:which_inputs_are_considered_out_of_date"><a class="anchor" href="#sec:which_inputs_are_considered_out_of_date"></a> <a class="link" href="#sec:which_inputs_are_considered_out_of_date">哪些输入被认为是过时的？</a></h5>
<div class="paragraph">
<p>如果先前有任务执行，并且自执行以来唯一的更改就是增量输入文件属性，则Gradle能够确定需要处理哪些输入文件（增量执行）。在这种情况下， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges(org.gradle.api.file.FileCollection)">InputChanges.getFileChanges（）</a>方法返回<em>添加</em> ， <em>修改</em>或<em>删除</em>的给定属性的所有输入文件的详细信息。</p>
</div>
<div class="paragraph">
<p>但是，在许多情况下，Gradle无法确定需要处理哪些输入文件（非增量执行）。示例包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有上一次执行的历史记录。</p>
</li>
<li>
<p>您正在使用其他版本的Gradle进行构建。当前，Gradle不使用其他版本的任务历史记录。</p>
</li>
<li>
<p>一个<a href="{javadocApi}/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-groovy.lang.Closure-"><code>upToDateWhen</code></a>添加到任务返回的条件<code>false</code> 。</p>
</li>
<li>
<p>自上次执行以来，输入属性已更改。</p>
</li>
<li>
<p>自上次执行以来，非增量输入文件属性已更改。</p>
</li>
<li>
<p>自上次执行以来，一个或多个输出文件已更改。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在所有这些情况下，Gradle会将所有输入文件报告为<code>ADDED</code>和<code>getFileChanges()</code>方法将返回组成给定输入属性的所有文件的详细信息。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges.html">InputChanges.isIncremental（）</a>方法检查任务执行是否为增量执行。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:an_incremental_task_in_action"><a class="anchor" href="#sec:an_incremental_task_in_action"></a> <a class="link" href="#sec:an_incremental_task_in_action">增量任务</a></h5>
<div class="paragraph">
<p>给出的例子增量任务执行<a href="#taskDefinition">上面</a> ，通过基于它的一些场景，让我们走。</p>
</div>
<div class="paragraph">
<p>首先，考虑一个实例<code>IncrementalReverseTask</code>第一次针对一组输入执行。在这种情况下，所有输入将被视为已添加，如下所示：</p>
</div>
<div id="ex:incremental_task_definition" class="exampleblock">
<div class="title">示例470首次运行增量任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task incrementalReverse(<span class="key">type</span>: IncrementalReverseTask) {
    inputDir = file(<span class="string"><span class="delimiter">'</span><span class="content">inputs</span><span class="delimiter">'</span></span>)
    outputDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/outputs</span><span class="delimiter">&quot;</span></span>)
    inputProperty = project.properties[<span class="string"><span class="delimiter">'</span><span class="content">taskInputProperty</span><span class="delimiter">'</span></span>] ?: <span class="string"><span class="delimiter">'</span><span class="content">original</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;IncrementalReverseTask&gt;(&quot;incrementalReverse&quot;) {
    inputDir.set(file(&quot;inputs&quot;))
    outputDir.set(file(&quot;$buildDir/outputs&quot;))
    inputProperty.set(project.properties[&quot;taskInputProperty&quot;] as String? ?: &quot;original&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">构建布局</div>
<div class="content">
<pre>.
├── build.gradle
└── inputs
    ├── 1.txt
    ├── 2.txt
    └── 3.txt</pre>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q incrementalReverse</code></div>
<div class="content">
<pre>&gt; gradle -q incrementalReverse
Executing non-incrementally
ADDED: 1.txt
ADDED: 2.txt
ADDED: 3.txt</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>自然地，如果再次执行任务且没有任何更改，则整个任务都是最新的，并且不执行任务动作：</p>
</div>
<div class="exampleblock">
<div class="title">示例471在输入不变的情况下运行增量任务</div>
<div class="content">
<div class="listingblock">
<div class="title">输出<code>gradle incrementalReverse</code></div>
<div class="content">
<pre>&gt; gradle incrementalReverse
&gt; Task :incrementalReverse UP-TO-DATE

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当以某种方式修改输入文件或添加新的输入文件时，然后重新执行任务将导致这些文件由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges(org.gradle.api.file.FileCollection)">InputChanges.getFileChanges（）</a>返回。以下示例在运行增量任务之前修改一个文件的内容并添加另一个文件的内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例472使用更新的输入文件运行增量任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task updateInputs() {
    doLast {
        file(<span class="string"><span class="delimiter">'</span><span class="content">inputs/1.txt</span><span class="delimiter">'</span></span>).text = <span class="string"><span class="delimiter">'</span><span class="content">Changed content for existing file 1.</span><span class="delimiter">'</span></span>
        file(<span class="string"><span class="delimiter">'</span><span class="content">inputs/4.txt</span><span class="delimiter">'</span></span>).text = <span class="string"><span class="delimiter">'</span><span class="content">Content for new file 4.</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;updateInputs&quot;) {
    doLast {
        file(&quot;inputs/1.txt&quot;).writeText(&quot;Changed content for existing file 1.&quot;)
        file(&quot;inputs/4.txt&quot;).writeText(&quot;Content for new file 4.&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q updateInputs incrementalReverse</code></div>
<div class="content">
<pre>&gt; gradle -q updateInputs incrementalReverse
Executing incrementally
MODIFIED: 1.txt
ADDED: 4.txt</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">各种变异任务（ <code>updateInputs</code> ， <code>removeInput</code>等）仅用于演示增量任务的行为。不应将它们视为您应该在自己的构建脚本中拥有的任务或任务实现类型。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>删除现有输入文件后，然后重新执行任务将导致该文件由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges(org.gradle.api.file.FileCollection)">InputChanges.getFileChanges（）</a>返回为<code>REMOVED</code> 。以下示例在执行增量任务之前删除现有文件之一：</p>
</div>
<div class="exampleblock">
<div class="title">示例473在删除输入文件的情况下运行增量任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task removeInput() {
    doLast {
        file(<span class="string"><span class="delimiter">'</span><span class="content">inputs/3.txt</span><span class="delimiter">'</span></span>).delete()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;removeInput&quot;) {
    doLast {
        file(&quot;inputs/3.txt&quot;).delete()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q removeInput incrementalReverse</code></div>
<div class="content">
<pre>&gt; gradle -q removeInput incrementalReverse
Executing incrementally
REMOVED: 3.txt</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当<em>输出</em>文件被删除（或修改）时，Gradle无法确定哪些输入文件已过期。在这种情况下， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges(org.gradle.api.file.FileCollection)">InputChanges.getFileChanges（）</a>返回给定属性的<em>所有</em>输入文件的详细信息。以下示例仅从构建目录中删除输出文件之一，但请注意如何将所有输入文件视为<code>ADDED</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例474在删除输出文件的情况下运行增量任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task removeOutput() {
    doLast {
        file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/outputs/1.txt</span><span class="delimiter">&quot;</span></span>).delete()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;removeOutput&quot;) {
    doLast {
        file(&quot;$buildDir/outputs/1.txt&quot;).delete()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<code>gradle -q removeOutput incrementalReverse</code></div>
<div class="content">
<pre>&gt; gradle -q removeOutput incrementalReverse
Executing non-incrementally
ADDED: 1.txt
ADDED: 2.txt
ADDED: 3.txt</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们要讨论的最后一个场景涉及修改基于非文件的输入属性时发生的情况。在这种情况下，Gradle无法确定属性如何影响任务输出，因此任务将以非增量方式执行。这意味着给定属性的<em>所有</em>输入文件都由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.work.InputChanges.html#org.gradle.work.InputChanges:getFileChanges(org.gradle.api.file.FileCollection)">InputChanges.getFileChanges（）</a>返回，并且都被视为<code>ADDED</code> 。以下示例设置项目属性<code>taskInputProperty</code>运行时将其设置为新值<code>incrementalReverse</code>任务，该项目属性用于初始化任务的<code>inputProperty</code>属性，如您在<a href="#ex:incremental_task_definition">本节</a>的<a href="#ex:incremental_task_definition">第一个示例中</a>所见。在这种情况下，您可以期待以下输出：</p>
</div>
<div class="exampleblock">
<div class="title">示例475使用输入属性运行增量任务</div>
<div class="content">
<div class="listingblock">
<div class="title">输出<code>gradle -q -PtaskInputProperty=changed incrementalReverse</code></div>
<div class="content">
<pre>&gt; gradle -q -PtaskInputProperty=changed incrementalReverse
Executing non-incrementally
ADDED: 1.txt
ADDED: 2.txt
ADDED: 3.txt</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:storing_incremental_task_state"><a class="anchor" href="#sec:storing_incremental_task_state"></a> <a class="link" href="#sec:storing_incremental_task_state">为缓存的任务存储增量状态</a></h5>
<div class="paragraph">
<p>使用Gradle的<code>InputChanges</code>这不是创建自上次执行以来仅对更改起作用的任务的唯一方法。诸如Kotlin编译器之类的工具将增量性作为内置功能提供。通常的实现方式是该工具将有关先前执行状态的分析数据存储在某个文件中。如果此类状态文件可<a href="#sec:task_output_caching_inputs">重定位</a> ，则可以将其声明为任务的输出。这样，当从缓存加载任务的结果时，下一次执行也可以使用从缓存加载的分析数据。</p>
</div>
<div class="paragraph">
<p>但是，如果状态文件不可重定位，则无法通过构建缓存共享它们。实际上，当从缓存加载任务时，必须清除所有此类状态文件，以防止过时的状态在下一次执行期间使工具混乱。如果通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/TaskLocalState.html#register-java.lang.Object...-">task.localState.register（）</a>声明了旧文件，或者使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/LocalState.html">@LocalState</a>批注标记了属性，Gradle可以确保删除这些旧文件。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:declaring_and_using_command_line_options"><a class="anchor" href="#sec:declaring_and_using_command_line_options"></a> <a class="link" href="#sec:declaring_and_using_command_line_options">声明和使用命令行选项</a></h4>
<div class="paragraph">
<p>有时，用户希望在命令行而不是构建脚本上声明公开的任务属性的值。如果更频繁地更改属性值，则在命令行中传递它们特别有用。任务API支持一种用于标记属性的机制，以在运行时自动生成具有特定名称的相应命令行参数。</p>
</div>
<div class="sect4">
<h5 id="sec:declaring_task_option"><a class="anchor" href="#sec:declaring_task_option"></a> <a class="link" href="#sec:declaring_task_option">声明命令行选项</a></h5>
<div class="paragraph">
<p>为任务属性公开新的命令行选项非常简单。您只需要用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/options/Option.html">Option</a>注释属性的相应setter方法即可。一个选项需要一个强制标识符。此外，您可以提供可选的描述。任务可以公开与类中可用属性一样多的命令行选项。</p>
</div>
<div class="paragraph">
<p>让我们看一个示例来说明功能。自定义任务<code>UrlVerify</code>验证是否可以通过发出HTTP调用并检查响应代码来解析给定的URL。可以通过属性配置要验证的URL <code>url</code> 。该属性的setter方法使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/options/Option.html">@Option</a>注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_declaring_a_command_line_option"><a class="anchor" href="#example_declaring_a_command_line_option"></a> <a class="link" href="#example_declaring_a_command_line_option">示例：声明命令行选项</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">UrlVerify.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.api.tasks.options.Option</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">UrlVerify</span> <span class="directive">extends</span> DefaultTask {
    <span class="directive">private</span> <span class="predefined-type">String</span> url;

    <span class="annotation">@Option</span>(option = <span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span>, description = <span class="string"><span class="delimiter">&quot;</span><span class="content">Configures the URL to be verified.</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> setUrl(<span class="predefined-type">String</span> url) {
        <span class="local-variable">this</span>.url = url;
    }

    <span class="annotation">@Input</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getUrl() {
        <span class="keyword">return</span> url;
    }

    <span class="annotation">@TaskAction</span>
    <span class="directive">public</span> <span class="type">void</span> verify() {
        getLogger().quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Verifying URL '{}'</span><span class="delimiter">&quot;</span></span>, url);

        <span class="comment">// verify URL by making a HTTP call</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过运行以下命令，可以将为任务声明的所有选项<a href="#sec:listing_task_options">呈现为控制台输出</a> ： <code>help</code>任务和<code>--task</code>选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_task_option_command_line"><a class="anchor" href="#sec:using_task_option_command_line"></a> <a class="link" href="#sec:using_task_option_command_line">在命令行上使用选项</a></h5>
<div class="paragraph">
<p>在命令行上使用选项必须遵守以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>该选项使用双破折号作为前缀，例如<code>--url</code> 。单破折号不符合任务选项的有效语法。</p>
</li>
<li>
<p>option参数紧跟在任务声明之后，例如<code>verifyUrl --url=http://www.google.com/</code> 。</p>
</li>
<li>
<p>任务名称后，可以在命令行中以任意顺序声明任务的多个选项。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>回到上一个示例，构建脚本将创建一个类型为Task的实例<code>UrlVerify</code>并通过暴露选项从命令行提供一个值。</p>
</div>
<div class="exampleblock">
<div class="title">示例476使用命令行选项</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task verifyUrl(<span class="key">type</span>: UrlVerify)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;UrlVerify&gt;(&quot;verifyUrl&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q verifyUrl --url=http://www.google.com/</code></strong></div>
<div class="content">
<pre>&gt; gradle -q verifyUrl --url=http://www.google.com/
Verifying URL 'http://www.google.com/'</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:supported_task_option_data_types"><a class="anchor" href="#sec:supported_task_option_data_types"></a> <a class="link" href="#sec:supported_task_option_data_types">选项支持的数据类型</a></h5>
<div class="paragraph">
<p>Gradle限制了可用于声明命令行选项的数据类型集。命令行上的用法因类型而异。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>boolean</code> ， <code>Boolean</code> ，<code>Property<Boolean></code></dt>
<dd>
<p>描述带有值的选项<code>true</code>要么<code>false</code> 。在命令行上传递选项会将值视为<code>true</code> 。例如<code>--enabled</code>等于<code>true</code> 。没有该选项将使用该属性的默认值。</p>
</dd>
<dt class="hdlist1"><code>String</code> ，<code>Property<String></code></dt>
<dd>
<p>描述具有任意String值的选项。在命令行上传递选项也需要一个值，例如<code>--container-id=2x94held</code>要么<code>--container-id 2x94held</code> 。</p>
</dd>
<dt class="hdlist1"><code>enum</code> ，<code>Property<enum></code></dt>
<dd>
<p>将选项描述为枚举类型。在命令行上传递选项也需要一个值，例如<code>--log-level=DEBUG</code>要么<code>--log-level debug</code> 。该值不区分大小写。</p>
</dd>
<dt class="hdlist1"><code>List<String></code> ，<code>List<enum></code></dt>
<dd>
<p>描述可以采用给定类型的多个值的选项。该选项的值必须作为多个声明提供，例如<code>--image-id=123 --image-id=456</code> 。当前不支持其他表示法，例如以逗号分隔的列表或由空格字符分隔的多个值。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="sec:documenting_available_task_option_values"><a class="anchor" href="#sec:documenting_available_task_option_values"></a> <a class="link" href="#sec:documenting_available_task_option_values">记录选项的可用值</a></h5>
<div class="paragraph">
<p>理论上，属性类型的选项<code>String</code>要么<code>List<String></code>可以接受任意值。可以在注释<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/options/OptionValues.html">OptionValues</a>的帮助下以编程方式记录此选项的期望值。可以将此注释分配给任何返回a的方法<code>List</code>其中一种受支持的数据类型。另外，您必须提供选项标识符以指示选项和可用值之间的关系。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在选项中不支持的命令行上传递值不会使构建失败或引发异常。您必须在任务动作中为此类行为实现自定义逻辑。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本示例说明了单个任务使用多个选项的情况。任务实现提供了该选项的可用值列表<code>output-type</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_declaring_available_values_for_an_option"><a class="anchor" href="#example_declaring_available_values_for_an_option"></a> <a class="link" href="#example_declaring_available_values_for_an_option">示例：声明选项的可用值</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">UrlProcess.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.api.tasks.options.Option</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.options.OptionValues</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">UrlProcess</span> <span class="directive">extends</span> DefaultTask {
    <span class="directive">private</span> <span class="predefined-type">String</span> url;
    <span class="directive">private</span> OutputType outputType;

    <span class="annotation">@Option</span>(option = <span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span>, description = <span class="string"><span class="delimiter">&quot;</span><span class="content">Configures the URL to be write to the output.</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> setUrl(<span class="predefined-type">String</span> url) {
        <span class="local-variable">this</span>.url = url;
    }

    <span class="annotation">@Input</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getUrl() {
        <span class="keyword">return</span> url;
    }

    <span class="annotation">@Option</span>(option = <span class="string"><span class="delimiter">&quot;</span><span class="content">output-type</span><span class="delimiter">&quot;</span></span>, description = <span class="string"><span class="delimiter">&quot;</span><span class="content">Configures the output type.</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> setOutputType(OutputType outputType) {
        <span class="local-variable">this</span>.outputType = outputType;
    }

    <span class="annotation">@OptionValues</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">output-type</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;OutputType&gt; getAvailableOutputTypes() {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;OutputType&gt;(<span class="predefined-type">Arrays</span>.asList(OutputType.values()));
    }

    <span class="annotation">@Input</span>
    <span class="directive">public</span> OutputType getOutputType() {
        <span class="keyword">return</span> outputType;
    }

    <span class="annotation">@TaskAction</span>
    <span class="directive">public</span> <span class="type">void</span> process() {
        getLogger().quiet(<span class="string"><span class="delimiter">&quot;</span><span class="content">Writing out the URL response from '{}' to '{}'</span><span class="delimiter">&quot;</span></span>, url, outputType);

        <span class="comment">// retrieve content from URL and write to output</span>
    }

    <span class="directive">private</span> <span class="directive">static</span> <span class="type">enum</span> OutputType {
        CONSOLE, FILE
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:listing_task_options"><a class="anchor" href="#sec:listing_task_options"></a> <a class="link" href="#sec:listing_task_options">列出命令行选项</a></h5>
<div class="paragraph">
<p>使用注释<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/options/Option.html">Option</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/options/OptionValues.html">OptionValues的</a>命令行选项是自记录的。您将看到<a href="#sec:declaring_task_option">声明的选项</a>及其<a href="#sec:documenting_available_task_option_values">可用值</a>反映在控制台的输出中。 <code>help</code>任务。输出以字母顺序呈现选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_listing_available_values_for_option"><a class="anchor" href="#example_listing_available_values_for_option"></a> <a class="link" href="#example_listing_available_values_for_option">示例：列出选项的可用值</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q help --task processUrl</code></strong></div>
<div class="content">
<pre>&gt; gradle -q help --task processUrl
Detailed task information for processUrl

Path
     :processUrl

Type
     UrlProcess (UrlProcess)

Options
     --output-type     Configures the output type.
                       Available values are:
                            CONSOLE
                            FILE

     --url     Configures the URL to be write to the output.

Description
     -

Group
     -</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="limitations"><a class="anchor" href="#limitations"></a> <a class="link" href="#limitations">局限性</a></h5>
<div class="paragraph">
<p>当前支持声明命令行选项有一些限制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>只能通过注释为自定义任务声明命令行选项。没有用于定义选项的程序化等效项。</p>
</li>
<li>
<p>选项不能全局声明，例如在项目级别或作为插件的一部分。</p>
</li>
<li>
<p>在命令行上分配选项时，需要明确说明暴露选项的任务，例如<code>gradle check --tests abc</code>即使<code>check</code>任务取决于<code>test</code>任务。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="worker_api"><a class="anchor" href="#worker_api"></a> <a class="link" href="#worker_api">工作者API</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>Worker API是一个<a href="feature_lifecycle.html#feature_lifecycle">孵化</a>功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从对<a href="#incremental_tasks">增量任务</a>的讨论中可以看出，任务执行的工作可以看作是离散的单元（即，将输入的子集转换为特定的输出子集）。很多时候，这些工作单元彼此高度独立，这意味着它们可以以任何顺序执行，并且可以简单地汇总在一起以形成任务的整体动作。在单线程执行中，这些工作单元将按顺序执行，但是，如果我们有多个处理器，则最好同时执行独立的工作单元。这样，我们可以在构建时充分利用可用资源，并更快地完成任务的活动。</p>
</div>
<div class="paragraph">
<p>Worker API提供了一种完成此操作的机制。它允许在任务动作期间安全，并行地执行多项工作。但是，Worker API的好处不仅限于并行处理任务。您还可以配置所需的隔离级别，以便可以在隔离的类加载器中甚至在隔离的进程中执行工作。此外，好处甚至超出了执行单个任务的范围。使用Worker API，Gradle可以默认开始并行执行任务。换句话说，一旦任务提交了要异步执行的工作并退出了任务动作，Gradle便可以并行开始执行其他独立任务，即使这些任务在同一项目中也是如此。</p>
</div>
<div class="sect4">
<h5 id="using-the-worker-api"><a class="anchor" href="#using-the-worker-api"></a> <a class="link" href="#using-the-worker-api">使用Worker API</a></h5>
<div class="paragraph">
<p>为了将工作提交给Worker API，必须提供两件事：工作单元的实现，以及工作单元的参数。</p>
</div>
<div class="paragraph">
<p>工作单元的参数定义为实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkParameters.html">WorkParameters</a>的接口或抽象类。参数类型必须是<a href="#managed_types">托管类型</a> 。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="#custom_gradle_types">开发自定义Gradle类型中</a>找到有关实现工作参数的更多信息。</p>
</div>
<div class="paragraph">
<p>该实现是扩展<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkAction.html">WorkAction</a>的类。此类应为抽象类，并且不应实现<code>getParameters()</code>方法。Gradle将在运行时为每个工作单元的参数对象注入此方法的实现。</p>
</div>
<div class="exampleblock">
<div class="title">示例477定义工作单位参数和实现</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// The parameters for a single unit of work</span>
<span class="type">interface</span> ReverseParameters <span class="directive">extends</span> WorkParameters {
    RegularFileProperty getFileToReverse()
    DirectoryProperty getDestinationDir()
}

<span class="comment">// The implementation of a single unit of work.</span>
<span class="directive">abstract</span> <span class="type">class</span> <span class="class">ReverseFile</span> <span class="directive">implements</span> WorkAction&lt;ReverseParameters&gt; {
    <span class="directive">private</span> <span class="directive">final</span> FileSystemOperations fileSystemOperations

    <span class="annotation">@Inject</span>
    <span class="directive">public</span> ReverseFile(FileSystemOperations fileSystemOperations) {
        <span class="local-variable">this</span>.fileSystemOperations = fileSystemOperations
    }

    <span class="annotation">@Override</span>
    <span class="type">void</span> execute() {
        fileSystemOperations.copy {
            from parameters.fileToReverse
            into parameters.destinationDir
            filter { <span class="predefined-type">String</span> line -&gt; line.reverse() }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import javax.inject.Inject

// The parameters for a single unit of work
interface ReverseParameters : WorkParameters {
    val fileToReverse : RegularFileProperty
    val destinationDir : DirectoryProperty
}

// The implementation of a single unit of work
abstract class ReverseFile @Inject constructor(val fileSystemOperations: FileSystemOperations) : WorkAction&lt;ReverseParameters&gt; {
    override fun execute() {
        fileSystemOperations.copy {
            from(parameters.fileToReverse)
            into(parameters.destinationDir)
            filter { line: String -&gt; line.reversed() }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种<code>WorkAction</code>实现可以注入在工作执行过程中提供功能的服务，例如上例中的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileSystemOperations.html">FileSystemOperations</a>服务。有关注入服务类型的更多信息，请参见<a href="#service_injection">服务注入</a> 。</p>
</div>
<div class="paragraph">
<p>为了提交工作单元，必须首先获得<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html">WorkerExecutor</a> 。为此，一个任务应该有一个带有注释的构造函数<code>javax.inject.Inject</code>接受<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html">WorkerExecutor</a>参数。创建任务时，Gradle将在运行时注入<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html">WorkerExecutor</a>的实例。然后可以创建一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkQueue.html--">WorkQueue</a>对象，并可以提交各个工作项。</p>
</div>
<div class="exampleblock">
<div class="title">示例478提交工作单元以执行</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">ReverseFiles</span> <span class="directive">extends</span> SourceTask {
    <span class="directive">private</span> <span class="directive">final</span> WorkerExecutor workerExecutor

    <span class="annotation">@OutputDirectory</span>
    <span class="predefined-type">File</span> outputDir

    <span class="comment">// The WorkerExecutor will be injected by Gradle at runtime</span>
    <span class="annotation">@Inject</span>
    ReverseFiles(WorkerExecutor workerExecutor) {
        <span class="local-variable">this</span>.workerExecutor = workerExecutor
    }

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> reverseFiles() {
        <span class="comment">// Create a WorkQueue to submit work items</span>
        WorkQueue workQueue = workerExecutor.noIsolation()

        <span class="comment">// Create and submit a unit of work for each file</span>
        source.each { file -&gt;
            workQueue.submit(ReverseFile.class) { ReverseParameters parameters -&gt;
                parameters.fileToReverse = file
                parameters.destinationDir = outputDir
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">// The WorkerExecutor will be injected by Gradle at runtime
open class ReverseFiles @Inject constructor(private val workerExecutor: WorkerExecutor) : SourceTask() {
    @OutputDirectory
    lateinit var outputDir: File

    @TaskAction
    fun reverseFiles() {
        // Create a WorkQueue to submit work items
        val workQueue = workerExecutor.noIsolation()

        // Create and submit a unit of work for each file
        source.forEach { file -&gt;
            workQueue.submit(ReverseFile::class) {
                fileToReverse.set(file)
                destinationDir.set(outputDir)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>提交任务动作的所有工作后，可以安全地退出任务动作。该工作将异步和并行执行（直到<code>max-workers</code> ）。当然，在完成所有异步工作之前，任何依赖于此任务的任务（以及该任务的任何后续任务动作）都不会开始执行。但是，与此任务无关的其他独立任务可以立即开始执行。</p>
</div>
<div class="paragraph">
<p>如果在执行异步工作时发生任何故障，该任务将失败，并且将抛出<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutionException.html">WorkerExecutionException，</a>详细说明每个失败的工作项的故障。这将被视为任务执行期间的任何失败，并且将阻止执行任何从属任务。</p>
</div>
<div class="paragraph">
<p>但是，在某些情况下，可能需要等待工作完成后再退出任务操作。使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkQueue.html#await--">WorkQueue.await（）</a>方法可以实现。如在使工件异步完成的情况下，在执行工作的项目中发生的任何故障将被浮出水面作为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutionException.html">WorkerExecutionException</a>从抛出<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkQueue.html#await--">WorkQueue.await（）</a>方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，当任务退出任务动作并将执行控制权返回给Gradle时，Gradle将仅开始并行运行其他独立任务。使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkQueue.html#await--">WorkQueue.await（）时</a> ，执行不会离开任务动作。这意味着Gradle将不允许其他任务开始执行，并且将等待任务动作完成后再执行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例479等待异步工作完成</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">        <span class="comment">// Create a WorkQueue to submit work items</span>
        WorkQueue workQueue = workerExecutor.noIsolation()

        <span class="comment">// Create and submit a unit of work for each file</span>
        source.each { file -&gt;
            workQueue.submit(ReverseFile.class) { ReverseParameters parameters -&gt;
                parameters.fileToReverse = file
                parameters.destinationDir = outputDir
            }
        }

        <span class="comment">// Wait for all asynchronous work submitted to this queue to complete before continuing</span>
        workQueue.await()
        logger.lifecycle(<span class="string"><span class="delimiter">&quot;</span><span class="content">Created </span><span class="inline"><span class="inline-delimiter">${</span>outputDir.listFiles().size()<span class="inline-delimiter">}</span></span><span class="content"> reversed files in </span><span class="inline"><span class="inline-delimiter">${</span>project.relativePath(outputDir)<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">        // Create a WorkQueue to submit work items
        val workQueue = workerExecutor.noIsolation()

        // Create and submit a unit of work for each file
        source.forEach { file -&gt;
            workQueue.submit(ReverseFile::class) {
                fileToReverse.set(file)
                destinationDir.set(outputDir)
            }
        }

        // Wait for all asynchronous work submitted to this queue to complete before continuing
        workQueue.await()
        logger.lifecycle(&quot;Created ${outputDir.listFiles().size} reversed files in ${project.relativePath(outputDir)}&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="isolation-modes"><a class="anchor" href="#isolation-modes"></a> <a class="link" href="#isolation-modes">隔离模式</a></h5>
<div class="paragraph">
<p>摇篮提供了可以在创建时被配置三种隔离模式<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkQueue.html">工作队列</a>上使用下列方法中的一个被指定和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html">WorkerExecutor</a> ：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html#noIsolation--">WorkerExecutor.noIsolation（）</a></dt>
<dd>
<p>这表明工作应在具有最小隔离度的线程中运行。例如，它将共享从中加载任务的同一类加载器。这是最快的隔离级别。</p>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html#classLoaderIsolation-org.gradle.api.Action-">WorkerExecutor.classLoaderIsolation（）</a></dt>
<dd>
<p>这表明工作应在具有隔离类加载器的线程中运行。类加载器将具有来自加载了工作单元实现类的类加载器的类路径，以及通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/ClassLoaderWorkerSpec.html#getClasspath--">ClassLoaderWorkerSpec.getClasspath（）</a>添加的任何其他类路径条目。</p>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html#processIsolation-org.gradle.api.Action-">WorkerExecutor.processIsolation（）</a></dt>
<dd>
<p>这表明应通过在单独的进程中执行工作来最大程度地隔离工作。流程的类加载器将使用来自加载了工作单元的类加载器的类路径，以及通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/ClassLoaderWorkerSpec.html#getClasspath--">ClassLoaderWorkerSpec.getClasspath（）</a>添加的任何其他类路径条目。此外，该过程将是一个<em>工作守护程序</em> ，该<em>守护程序</em>将保持活动状态，并可以重复用于将来可能具有相同要求的工作项。可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/ProcessWorkerSpec.html#forkOptions-org.gradle.api.Action-">ProcessWorkerSpec.forkOptions（org.gradle.api。动作）</a> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="worker-daemons"><a class="anchor" href="#worker-daemons"></a> <a class="link" href="#worker-daemons">工人守护进程</a></h5>
<div class="paragraph">
<p>使用时<code>processIsolation()</code> ，gradle将启动一个长期存在的<em>Worker Daemon</em>进程，该进程可用于将来的工作项。</p>
</div>
<div class="exampleblock">
<div class="title">示例480提交工作项以在工作程序守护程序中运行</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">        <span class="comment">// Create a WorkQueue with process isolation</span>
        WorkQueue workQueue = workerExecutor.processIsolation() { ProcessWorkerSpec spec -&gt;
            <span class="comment">// Configure the options for the forked process</span>
            forkOptions { JavaForkOptions options -&gt;
                options.maxHeapSize = <span class="string"><span class="delimiter">&quot;</span><span class="content">512m</span><span class="delimiter">&quot;</span></span>
                options.systemProperty <span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.sample.showFileSize</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
            }
        }

        <span class="comment">// Create and submit a unit of work for each file</span>
        source.each { file -&gt;
            workQueue.submit(ReverseFile.class) { ReverseParameters parameters -&gt;
                parameters.fileToReverse = file
                parameters.destinationDir = outputDir
            }
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">        // Create a WorkQueue with process isolation
        val workQueue = workerExecutor.processIsolation() {
            // Configure the options for the forked process
            forkOptions {
                maxHeapSize = &quot;512m&quot;
                systemProperty(&quot;org.gradle.sample.showFileSize&quot;, &quot;true&quot;)
            }
        }

        // Create and submit a unit of work for each file
        source.forEach { file -&gt;
            workQueue.submit(ReverseFile::class) {
                fileToReverse.set(file)
                destinationDir.set(outputDir)
            }
        }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>提交工作程序守护程序的工作单元时，Gradle首先会查看是否存在兼容的空闲守护程序。如果是这样，它将把工作单元发送到空闲守护程序，将其标记为忙。如果没有，它将启动一个新的守护程序。在评估兼容性时，Gradle会考虑许多标准，所有这些标准都可以通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/ProcessWorkerSpec.html#forkOptions-org.gradle.api.Action-">ProcessWorkerSpec.forkOptions（org.gradle.api。动作）</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">可执行文件</dt>
<dd>
<p>守护程序仅在使用相同的Java可执行文件时才被认为是兼容的。</p>
</dd>
<dt class="hdlist1">类路径</dt>
<dd>
<p>如果守护程序的类路径包含所有请求的类路径条目，则该守护程序被认为是兼容的。请注意，只有当类路径与请求的类路径完全匹配时，守护程序才被认为是兼容的。</p>
</dd>
<dt class="hdlist1">堆设置</dt>
<dd>
<p>如果守护程序至少具有与请求相同的堆大小设置，则认为该守护程序是兼容的。换句话说，具有高于请求的堆设置的守护程序将被视为兼容。</p>
</dd>
<dt class="hdlist1">jvm参数</dt>
<dd>
<p>如果守护程序已设置所有请求的jvm参数，则认为该守护程序兼容。请注意，如果守护程序除了请求的参数之外还具有其他jvm参数，则该守护程序被认为是兼容的（除了专门处理的参数，例如堆设置，断言，调试等）。</p>
</dd>
<dt class="hdlist1">系统属性</dt>
<dd>
<p>如果守护程序已将请求的所有系统属性设置为相同的值，则认为该守护程序是兼容的。请注意，如果守护程序具有超出请求的属性的其他系统属性，则该守护程序被认为是兼容的。</p>
</dd>
<dt class="hdlist1">环境变量</dt>
<dd>
<p>如果守护程序已将所有请求的环境变量设置为相同的值，则该守护程序被认为是兼容的。请注意，如果守护程序除请求的环境变量之外还具有更多环境变量，则该守护程序被认为是兼容的。</p>
</dd>
<dt class="hdlist1">引导类路径</dt>
<dd>
<p>如果守护程序包含所有请求的引导类路径条目，则该守护程序被认为是兼容的。请注意，如果守护程序除了所请求的引导类路径条目之外还有更多的引导类路径条目，则该守护程序被认为是兼容的。</p>
</dd>
<dt class="hdlist1">调试</dt>
<dd>
<p>仅当将debug设置为与请求相同的值（真或假）时，守护程序才被视为兼容。</p>
</dd>
<dt class="hdlist1">启用断言</dt>
<dd>
<p>仅当将启用断言设置为与请求相同的值（true或false）时，守护程序才被视为兼容。</p>
</dd>
<dt class="hdlist1">默认字符编码</dt>
<dd>
<p>仅当默认字符编码设置为与请求相同的值时，守护程序才被视为兼容。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>辅助守护程序将保持运行状态，直到启动它们的构建守护程序停止或系统内存不足为止。当可用系统内存不足时，Gradle将开始停止工作程序守护程序，以尽量减少内存消耗。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cancellation_and_timeouts"><a class="anchor" href="#cancellation_and_timeouts"></a> <a class="link" href="#cancellation_and_timeouts">取消和超时</a></h4>
<div class="paragraph">
<p>为了支持取消操作（例如，当用户使用CTRL + C停止构建时）和任务超时，自定义任务应该对被中断的执行线程做出反应。通过工作人员API提交的工作项也是如此。如果任务在10秒内未响应中断，则守护程序将关闭以释放系统资源。</p>
</div>
</div>
<div class="sect3">
<h4 id="more_details"><a class="anchor" href="#more_details"></a> <a class="link" href="#more_details">更多细节</a></h4>
<div class="paragraph">
<p>在自定义Gradle插件中打包自定义任务类型通常是一种好方法。该插件可以为任务类型提供有用的默认值和约定，并提供一种从构建脚本或其他插件中使用任务类型的便捷方法。请参阅<a href="#custom_plugins">开发自定义Gradle插件</a>以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>Gradle提供了许多功能，这些功能在开发Gradle类型（包括任务）时很有用。有关更多详细信息，请参见<a href="#">开发自定义Gradle类型</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom_plugins"><a class="anchor" href="#custom_plugins"></a> <a class="link" href="#custom_plugins">开发自定义Gradle插件</a></h3>
<div class="paragraph">
<p>Gradle插件打包了可重用的构建逻辑，可在许多不同的项目和构建中使用。Gradle允许您实现自己的插件，因此您可以重复使用构建逻辑，并与他人共享。</p>
</div>
<div class="paragraph">
<p>您可以使用任何喜欢的语言来实现Gradle插件，前提是该实现最终被编译为JVM字节码。在我们的示例中，我们将使用Groovy作为实现语言。Groovy，Java或Kotlin都是用于实现插件的语言，都是不错的选择，因为Gradle API旨在与这些语言配合使用。通常，使用Java或Kotlin（静态类型）实现的插件比使用Groovy实施的插件性能更好。</p>
</div>
<div class="sect3">
<h4 id="sec:packaging_a_plugin"><a class="anchor" href="#sec:packaging_a_plugin"></a> <a class="link" href="#sec:packaging_a_plugin">打包插件</a></h4>
<div class="paragraph">
<p>您可以在几个地方放置插件的源代码。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">构建脚本</dt>
<dd>
<p>您可以将插件的源代码直接包含在构建脚本中。这样的好处是，无需执行任何操作即可自动编译插件并将其包含在构建脚本的类路径中。但是，该插件在构建脚本之外不可见，因此您不能在定义该构建脚本的外部重用该插件。</p>
</dd>
<dt class="hdlist1"><code>buildSrc</code>项目</dt>
<dd>
<p>您可以将插件的源代码放在<code><em>rootProjectDir</em>/buildSrc/src/main/groovy</code>目录（或<code><em>rootProjectDir</em>/buildSrc/src/main/java</code>要么<code><em>rootProjectDir</em>/buildSrc/src/main/kotlin</code>取决于您喜欢的语言）。Gradle将负责编译和测试插件，并使其在构建脚本的类路径中可用。该插件对构建使用的每个构建脚本都是可见的。但是，它在构建外部不可见，因此您不能在定义该构建的外部重用该插件。</p>
<div class="paragraph">
<p>有关更多信息，请参见<a href="#organizing_gradle_projects">组织Gradle项目</a> 。 <code>buildSrc</code>项目。</p>
</div>
</dd>
<dt class="hdlist1">独立项目</dt>
<dd>
<p>您可以为插件创建一个单独的项目。这个项目产生并发布了一个JAR，您可以在多个版本中使用它并与他人共享。通常，此JAR可能包含一些插件，或将几个相关的任务类捆绑到一个库中。或两者的某种组合。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在我们的示例中，我们将从构建脚本中的插件开始，以使事情变得简单。然后，我们将考虑创建一个独立的项目。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:writing_a_simple_plugin"><a class="anchor" href="#sec:writing_a_simple_plugin"></a> <a class="link" href="#sec:writing_a_simple_plugin">编写一个简单的插件</a></h4>
<div class="paragraph">
<p>要创建Gradle插件，您需要编写一个实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">Plugin</a>接口的类。将插件应用于项目时，Gradle将创建插件类的实例，并调用该实例的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html#apply-T-">Plugin.apply（）</a>方法。项目对象作为参数传递，插件可以使用该参数配置项目，但需要配置。以下示例包含一个问候插件，其中添加了一个<code>hello</code>项目任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例481自定义插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingPlugin</span> <span class="directive">implements</span> Plugin&lt;Project&gt; {
    <span class="type">void</span> apply(Project project) {
        project.task(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>) {
            doLast {
                println <span class="string"><span class="delimiter">'</span><span class="content">Hello from the GreetingPlugin</span><span class="delimiter">'</span></span>
            }
        }
    }
}

<span class="comment">// Apply the plugin</span>
apply <span class="key">plugin</span>: GreetingPlugin</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">class GreetingPlugin : Plugin&lt;Project&gt; {
    override fun apply(project: Project) {
        project.task(&quot;hello&quot;) {
            doLast {
                println(&quot;Hello from the GreetingPlugin&quot;)
            }
        }
    }
}

// Apply the plugin
apply&lt;GreetingPlugin&gt;()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
Hello from the GreetingPlugin</pre>
</div>
</div>
<div class="paragraph">
<p>要注意的一件事是，将为每个应用插件的项目创建一个插件的新实例。另请注意， <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">Plugin</a>类是泛型类型。此示例接收<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">项目</a>类型作为类型参数。插件可以改为接收类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html">Settings</a>的参数，在这种情况下，该插件可以应用在设置脚本中，或者可以接收类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html">Gradle</a>的参数，在这种情况下，插件可以应用在初始化脚本中。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:getting_input_from_the_build"><a class="anchor" href="#sec:getting_input_from_the_build"></a> <a class="link" href="#sec:getting_input_from_the_build">使插件可配置</a></h4>
<div class="paragraph">
<p>大多数插件为构建脚本提供了一些配置选项，其他插件则用于自定义插件的工作方式。插件使用<em>扩展对象</em>执行此操作。Gradle <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">项目</a>具有一个关联的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/ExtensionContainer.html">ExtensionContainer</a>对象，该对象包含已应用于该项目的插件的所有设置和属性。您可以通过向该容器添加扩展对象来为您的插件提供配置。扩展对象只是具有表示配置的Java Bean属性的对象。</p>
</div>
<div class="paragraph">
<p>让我们向项目添加一个简单的扩展对象。在这里我们添加一个<code>greeting</code>项目的扩展对象，它允许您配置问候语。</p>
</div>
<div class="exampleblock">
<div class="title">示例482自定义插件扩展</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingPluginExtension</span> {
    <span class="predefined-type">String</span> message = <span class="string"><span class="delimiter">'</span><span class="content">Hello from GreetingPlugin</span><span class="delimiter">'</span></span>
}

<span class="type">class</span> <span class="class">GreetingPlugin</span> <span class="directive">implements</span> Plugin&lt;Project&gt; {
    <span class="type">void</span> apply(Project project) {
        <span class="comment">// Add the 'greeting' extension object</span>
        <span class="keyword">def</span> extension = project.extensions.create(<span class="string"><span class="delimiter">'</span><span class="content">greeting</span><span class="delimiter">'</span></span>, GreetingPluginExtension)
        <span class="comment">// Add a task that uses configuration from the extension object</span>
        project.task(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>) {
            doLast {
                println extension.message
            }
        }
    }
}

apply <span class="key">plugin</span>: GreetingPlugin

<span class="comment">// Configure the extension</span>
greeting.message = <span class="string"><span class="delimiter">'</span><span class="content">Hi from Gradle</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GreetingPluginExtension {
    var message = &quot;Hello from GreetingPlugin&quot;
}

class GreetingPlugin : Plugin&lt;Project&gt; {
    override fun apply(project: Project) {
        // Add the 'greeting' extension object
        val extension = project.extensions.create&lt;GreetingPluginExtension&gt;(&quot;greeting&quot;)
        // Add a task that uses configuration from the extension object
        project.task(&quot;hello&quot;) {
            doLast {
                println(extension.message)
            }
        }
    }
}

apply&lt;GreetingPlugin&gt;()

// Configure the extension
the&lt;GreetingPluginExtension&gt;().message = &quot;Hi from Gradle&quot;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
Hi from Gradle</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中<code>GreetingPluginExtension</code>是具有称为属性的对象<code>message</code> 。扩展对象以以下名称添加到项目中<code>greeting</code> 。然后，该对象可用作与扩展对象同名的项目属性。</p>
</div>
<div class="paragraph">
<p>通常，您需要在单个插件上指定几个相关属性。Gradle为每个扩展对象添加一个配置块，因此您可以将设置分组在一起。以下示例向您展示了它是如何工作的。</p>
</div>
<div class="exampleblock">
<div class="title">示例483具有配置块的自定义插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingPluginExtension</span> {
    <span class="predefined-type">String</span> message
    <span class="predefined-type">String</span> greeter
}

<span class="type">class</span> <span class="class">GreetingPlugin</span> <span class="directive">implements</span> Plugin&lt;Project&gt; {
    <span class="type">void</span> apply(Project project) {
        <span class="keyword">def</span> extension = project.extensions.create(<span class="string"><span class="delimiter">'</span><span class="content">greeting</span><span class="delimiter">'</span></span>, GreetingPluginExtension)
        project.task(<span class="string"><span class="delimiter">'</span><span class="content">hello</span><span class="delimiter">'</span></span>) {
            doLast {
                println <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>extension.message<span class="inline-delimiter">}</span></span><span class="content"> from </span><span class="inline"><span class="inline-delimiter">${</span>extension.greeter<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
            }
        }
    }
}

apply <span class="key">plugin</span>: GreetingPlugin

<span class="comment">// Configure the extension using a DSL block</span>
greeting {
    message = <span class="string"><span class="delimiter">'</span><span class="content">Hi</span><span class="delimiter">'</span></span>
    greeter = <span class="string"><span class="delimiter">'</span><span class="content">Gradle</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GreetingPluginExtension {
    var message: String? = null
    var greeter: String? = null
}

class GreetingPlugin : Plugin&lt;Project&gt; {
    override fun apply(project: Project) {
        val extension = project.extensions.create&lt;GreetingPluginExtension&gt;(&quot;greeting&quot;)
        project.task(&quot;hello&quot;) {
            doLast {
                println(&quot;${extension.message} from ${extension.greeter}&quot;)
            }
        }
    }
}

apply&lt;GreetingPlugin&gt;()

// Configure the extension using a DSL block
configure&lt;GreetingPluginExtension&gt; {
    message = &quot;Hi&quot;
    greeter = &quot;Gradle&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q hello</code></strong></div>
<div class="content">
<pre>&gt; gradle -q hello
Hi from Gradle</pre>
</div>
</div>
<div class="paragraph multi-language-text lang-groovy">
<p>在此示例中，几个设置可以在<code>greeting</code>关闭。构建脚本中闭包块的名称（ <code>greeting</code> ）需要匹配扩展名。然后，当执行闭包时，扩展对象上的字段将基于标准Groovy闭包委托功能映射到闭包内的变量。</p>
</div>
<div class="paragraph multi-language-text lang-kotlin">
<p>在此示例中，几个设置可以在<code>configure<GreetingPluginExtension></code>块。所使用的类型<code>configure</code>在构建脚本中的功能（ <code>GreetingPluginExtension</code> ）需要匹配扩展名类型。然后，当执行该块时，该块的接收者就是扩展。</p>
</div>
<div class="paragraph">
<p>这样，使用扩展对象可以<em>扩展</em> Gradle DSL，从而为插件添加项目属性和DSL块。而且由于扩展对象只是一个常规对象，因此可以通过向扩展对象添加属性和方法来提供嵌套在插件块中的自己的DSL。</p>
</div>
<div class="sect4">
<h5 id="developing_project_extensions"><a class="anchor" href="#developing_project_extensions"></a> <a class="link" href="#developing_project_extensions">开发项目扩展</a></h5>
<div class="paragraph">
<p>您可以在<a href="#custom_gradle_types">开发自定义Gradle类型中</a>找到有关实现项目扩展的更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:working_with_files_in_custom_tasks_and_plugins"><a class="anchor" href="#sec:working_with_files_in_custom_tasks_and_plugins"></a> <a class="link" href="#sec:working_with_files_in_custom_tasks_and_plugins">在自定义任务和插件中处理文件</a></h4>
<div class="paragraph">
<p>开发自定义任务和插件时，在接受文件位置的输入配置时非常灵活是一个好主意。为此，您可以利用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。对象）</a>方法，以尽可能晚地将值解析到文件中。</p>
</div>
<div class="exampleblock">
<div class="title">示例484延迟评估文件属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingToFileTask</span> <span class="directive">extends</span> DefaultTask {

    <span class="keyword">def</span> destination

    <span class="annotation">@OutputFile</span>
    <span class="predefined-type">File</span> getDestination() {
        project.file(destination)
    }

    <span class="annotation">@TaskAction</span>
    <span class="keyword">def</span> <span class="function">greet</span>() {
        <span class="keyword">def</span> file = getDestination()
        file.parentFile.mkdirs()
        file.write <span class="string"><span class="delimiter">'</span><span class="content">Hello!</span><span class="delimiter">'</span></span>
    }
}

task greet(<span class="key">type</span>: GreetingToFileTask) {
    destination = { project.greetingFile }
}

task sayGreeting(<span class="key">dependsOn</span>: greet) {
    doLast {
        println file(greetingFile).text
    }
}

ext.greetingFile = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/hello.txt</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">open class GreetingToFileTask : DefaultTask() {

    var destination: Any? = null

    @OutputFile
    fun getDestination(): File {
        return project.file(destination!!)
    }

    @TaskAction
    fun greet() {
        val file = getDestination()
        file.parentFile.mkdirs()
        file.writeText(&quot;Hello!&quot;)
    }
}

tasks.register&lt;GreetingToFileTask&gt;(&quot;greet&quot;) {
    destination = { project.extra[&quot;greetingFile&quot;]!! }
}

tasks.register(&quot;sayGreeting&quot;) {
    dependsOn(&quot;greet&quot;)
    doLast {
        println(file(project.extra[&quot;greetingFile&quot;]!!).readText())
    }
}

extra[&quot;greetingFile&quot;] = &quot;$buildDir/hello.txt&quot;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">输出<strong><code>gradle -q sayGreeting</code></strong></div>
<div class="content">
<pre>&gt; gradle -q sayGreeting
Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们配置了<code>greet</code>任务<code>destination</code>属性作为闭包/提供者，使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)">Project.file（java.lang。Object）</a>方法将闭包/提供者的返回值转换为<code>File</code>对象在最后一分钟。您会注意到，在上面的示例中，我们指定了<code>greetingFile</code>配置为任务使用属性值之后。这种惰性评估的主要好处是在设置文件属性时接受任何值，然后在读取属性时解析该值。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:mapping_extension_properties_to_task_properties"><a class="anchor" href="#sec:mapping_extension_properties_to_task_properties"></a> <a class="link" href="#sec:mapping_extension_properties_to_task_properties">将扩展属性映射到任务属性</a></h4>
<div class="paragraph">
<p>从构建脚本通过扩展捕获用户输入并将其映射到自定义任务的输入/输出属性是一种有用的模式。构建脚本作者仅与扩展定义的DSL交互。命令式逻辑隐藏在插件实现中。</p>
</div>
<div class="paragraph">
<p>Gradle提供了一些类型，您可以在任务实现和扩展中使用这些类型来帮助您。有关更多信息，请参考<a href="#lazy_configuration">惰性配置</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:custom_plugins_standalone_project"><a class="anchor" href="#sec:custom_plugins_standalone_project"></a> <a class="link" href="#sec:custom_plugins_standalone_project">一个独立的项目</a></h4>
<div class="paragraph">
<p>现在，我们将插件移至独立项目，以便我们可以发布它并与他人共享。这个项目只是一个Groovy项目，它产生一个包含插件类的JAR。这是该项目的简单构建脚本。它应用了Groovy插件，并将Gradle API添加为编译时依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">示例485。自定义插件的构建</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>
}

dependencies {
    implementation gradleApi()
    implementation localGroovy()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    groovy
}

dependencies {
    implementation(gradleApi())
    implementation(localGroovy())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/customPlugin</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>那么Gradle如何找到<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">插件</a>实现？答案是您需要在jar的容器中提供属性文件<code>META-INF/gradle-plugins</code>与插件ID相匹配的目录。</p>
</div>
<div class="sect4">
<h5 id="example_wiring_for_a_custom_plugin"><a class="anchor" href="#example_wiring_for_a_custom_plugin"></a> <a class="link" href="#example_wiring_for_a_custom_plugin">示例：接线自定义插件</a></h5>
<div class="listingblock">
<div class="title">src / main / resources / META-INF / gradle-plugins / org.samples.greeting.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">implementation-class=org.gradle.GreetingPlugin</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，属性文件名与插件ID匹配，并放置在资源文件夹中，并且<code>implementation-class</code>属性标识<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Plugin.html">插件</a>实现类。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:creating_a_plugin_id"><a class="anchor" href="#sec:creating_a_plugin_id"></a> <a class="link" href="#sec:creating_a_plugin_id">创建一个插件ID</a></h5>
<div class="paragraph">
<p>插件ID以类似于Java包的方式（即反向域名）完全合格。这有助于避免冲突，并提供了一种将具有相似所有权的插件分组的方法。</p>
</div>
<div class="paragraph">
<p>您的插件ID应该是反映名称空间（指向您或您的组织的合理指针）及其提供的插件名称的组件的组合。例如，如果您有一个名为“ foo”的Github帐户，而您的插件名为“ bar”，则合适的插件ID可能是<code>com.github.foo.bar</code> 。同样，如果插件是由baz组织开发的，则插件ID可能是<code>org.baz.bar</code> 。</p>
</div>
<div class="paragraph">
<p>插件ID应符合以下条件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以包含任何字母数字字符“。”和“-”。</p>
</li>
<li>
<p>必须至少包含一个“。”。分隔命名空间和插件名称的字符。</p>
</li>
<li>
<p>按照惯例，对名称空间使用小写的反向域名约定。</p>
</li>
<li>
<p>通常，名称中仅使用小写字符。</p>
</li>
<li>
<p><code>org.gradle</code>和<code>com.gradleware</code>不能使用名称空间。</p>
</li>
<li>
<p>不能以“。”开头或结尾。字符。</p>
</li>
<li>
<p>不能包含连续的“。”字符（即'..'）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管插件ID与程序包名称之间存在常规的相似之处，但通常包名称比插件ID所需的名称更为详细。例如，将“ gradle”作为插件ID的组件添加似乎是合理的，但是由于插件ID仅用于Gradle插件，因此这是多余的。通常，一个良好的插件ID仅需要一个用于标识所有权和名称的名称空间。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:publishing_your_plugin"><a class="anchor" href="#sec:publishing_your_plugin"></a> <a class="link" href="#sec:publishing_your_plugin">发布插件</a></h5>
<div class="paragraph">
<p>如果要在内部发布插件供组织内部使用，则可以像其他任何代码工件一样发布它。请参阅有关发布工件的<a href="#publishing_ivy">Ivy</a>和<a href="#publishing_maven">Maven</a>章节。</p>
</div>
<div class="paragraph">
<p>如果您有兴趣发布供更广泛的Gradle社区使用的插件，则可以将其发布到<a href="http://plugins.gradle.org">Gradle插件门户</a> 。该站点提供了搜索和收集有关Gradle社区贡献的插件的信息的功能。请参阅相应的<a href="https://guides.gradle.org/publishing-plugins-to-gradle-plugin-portal/">指南，</a>以了解如何在此站点上使用您的插件。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_your_plugin_in_another_project"><a class="anchor" href="#sec:using_your_plugin_in_another_project"></a> <a class="link" href="#sec:using_your_plugin_in_another_project">在另一个项目中使用您的插件</a></h5>
<div class="paragraph">
<p>要在构建脚本中使用插件，您需要将插件类添加到构建脚本的类路径中。为此，请使用“ buildscript {}”块，如参见<a href="#sec:applying_plugins_buildscript">使用buildscript块应用插件中所述</a> 。以下示例显示了包含插件的JAR已发布到本地存储库时如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例486在另一个项目中使用自定义插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">buildscript {
    repositories {
        maven {
            url = uri(repoLocation)
        }
    }
    dependencies {
        classpath <span class="string"><span class="delimiter">'</span><span class="content">org.gradle:customPlugin:1.0-SNAPSHOT</span><span class="delimiter">'</span></span>
    }
}
apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">org.samples.greeting</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildscript {
    repositories {
        maven {
            url = uri(repoLocation)
        }
    }
    dependencies {
        classpath(&quot;org.gradle:customPlugin:1.0-SNAPSHOT&quot;)
    }
}
apply(plugin = &quot;org.samples.greeting&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用插件DSL（请参阅使用插件DSL <a href="#sec:plugins_block">应用插件</a> ）来应用插件：</p>
</div>
<div class="exampleblock">
<div class="title">示例487通过插件DSL应用社区插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">com.jfrog.bintray</span><span class="delimiter">'</span></span> version <span class="string"><span class="delimiter">'</span><span class="content">0.4.1</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;com.jfrog.bintray&quot;) version &quot;0.4.1&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:writing_tests_for_your_plugin"><a class="anchor" href="#sec:writing_tests_for_your_plugin"></a> <a class="link" href="#sec:writing_tests_for_your_plugin">为您的插件编写测试</a></h5>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testfixtures/ProjectBuilder.html">ProjectBuilder</a>类创建在测试插件实现时要使用的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a>实例。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_testing_a_custom_plugin"><a class="anchor" href="#example_testing_a_custom_plugin"></a> <a class="link" href="#example_testing_a_custom_plugin">示例：测试自定义插件</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src / test / groovy / org / gradle / GreetingPluginTest.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">GreetingPluginTest</span> {
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> greeterPluginAddsGreetingTaskToProject() {
        Project project = ProjectBuilder.builder().build()
        project.pluginManager.apply <span class="string"><span class="delimiter">'</span><span class="content">org.samples.greeting</span><span class="delimiter">'</span></span>

        assertTrue(project.tasks.hello <span class="keyword">instanceof</span> GreetingTask)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:using_the_java_gradle_plugin_development_plugin"><a class="anchor" href="#sec:using_the_java_gradle_plugin_development_plugin"></a> <a class="link" href="#sec:using_the_java_gradle_plugin_development_plugin">使用Java Gradle插件开发插件</a></h5>
<div class="paragraph">
<p>您可以使用<a href="#java_gradle_plugin">Java Gradle插件开发插件</a>来消除构建脚本中的一些样板声明，并提供插件元数据的一些基本验证。该插件将自动应用<a href="#java_plugin">Java插件</a> ，添加<code>gradleApi()</code>依赖于编译配置，并在其中执行插件元数据验证<code>jar</code>执行任务，并在生成的JAR文件中生成插件描述符<code>META-INF</code>目录。</p>
</div>
<div class="exampleblock">
<div class="title">示例488使用Java Gradle插件开发插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-gradle-plugin</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>
}

gradlePlugin {
    plugins {
        simplePlugin {
            id = <span class="string"><span class="delimiter">'</span><span class="content">org.samples.greeting</span><span class="delimiter">'</span></span>
            implementationClass = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.GreetingPlugin</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-gradle-plugin`
    groovy
}

gradlePlugin {
    plugins {
        create(&quot;simplePlugin&quot;) {
            id = &quot;org.samples.greeting&quot;
            implementationClass = &quot;org.gradle.GreetingPlugin&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当使用<a href="#publishing_ivy">Ivy</a>或<a href="#publishing_maven">Maven</a>发布插件将插件发布到自定义插件存储库时， <a href="#java_gradle_plugin">Java Gradle插件开发插件</a>还将生成基于插件ID命名的插件标记工件，插件标识工件取决于插件的实现工件。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="more_details_2"><a class="anchor" href="#more_details_2"></a> <a class="link" href="#more_details_2">更多细节</a></h4>
<div class="paragraph">
<p>插件通常还提供自定义任务类型。有关更多详细信息，请参见<a href="#custom_tasks">开发自定义Gradle任务类型</a> 。</p>
</div>
<div class="paragraph">
<p>Gradle提供了许多功能，这些功能在开发Gradle类型（包括插件）时很有用。有关更多详细信息，请参见<a href="#custom_gradle_types">开发自定义Gradle类型</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom_gradle_types"><a class="anchor" href="#custom_gradle_types"></a> <a class="link" href="#custom_gradle_types">开发自定义Gradle类型</a></h3>
<div class="paragraph">
<p>您可以为Gradle开发几种不同类型的“附加组件”，例如<a href="#custom_plugins">插件</a> ， <a href="#custom_tasks">任务</a> ， <a href="#sec:getting_input_from_the_build">项目扩展</a>或<a href="#sec:implementing-artifact-transforms">工件转换</a> ，它们均作为类和可以在JVM上运行的其他类型实现。本章讨论了这些类型共有的一些功能和概念。您可以使用这些功能来帮助实现自定义的Gradle类型，并为用户提供一致的DSL。</p>
</div>
<div class="paragraph">
<p>本章适用于以下类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>插件类型。</p>
</li>
<li>
<p>任务类型。</p>
</li>
<li>
<p>伪影转换参数类型。</p>
</li>
<li>
<p>Worker API工作操作参数类型。</p>
</li>
<li>
<p>使用创建的扩展对象<code>ExtensionContainer.create()</code> ，例如由插件注册的项目扩展。</p>
</li>
<li>
<p>使用创建的对象<code>ObjectFactory.newInstance()</code> 。</p>
</li>
<li>
<p>为托管嵌套属性创建的对象。</p>
</li>
<li>
<p>一个元素<code>NamedDomainObjectContainer</code> 。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="configuration_using_bean_properties"><a class="anchor" href="#configuration_using_bean_properties"></a> <a class="link" href="#configuration_using_bean_properties">使用bean属性进行配置</a></h4>
<div class="paragraph">
<p>您实现的自定义Gradle类型通常包含一些您希望使其可用于构建脚本和其他插件的配置。例如，下载任务可以具有指定要从中下载的URL和将结果写入到的文件系统位置的配置。此配置表示为Java bean属性。</p>
</div>
<div class="paragraph">
<p>Kotlin和Groovy为声明Java bean属性提供了便利，这使它们成为实现Gradle类型的良好语言选择。在下面的示例中演示了这些便利。</p>
</div>
<div class="paragraph">
<p>Gradle还为使用bean属性实现类型提供了一些便利。</p>
</div>
<div class="sect4">
<h5 id="managed_properties"><a class="anchor" href="#managed_properties"></a> <a class="link" href="#managed_properties">托管属性</a></h5>
<div class="paragraph">
<p>Gradle可以提供抽象属性的实现。这称为<em>托管属性</em> ，因为Gradle <em>负责管理属性</em>的状态。属性可以是<em>可变的</em> ，这意味着它既具有getter方法又具有setter方法，或者是<em>只读的</em> ，意味着它仅具有getter方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>托管属性当前是一个<a href="feature_lifecycle.html#feature_lifecycle">孵化</a>功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="mutable_managed_properties"><a class="anchor" href="#mutable_managed_properties"></a> <a class="link" href="#mutable_managed_properties">可变的托管属性</a></h6>
<div class="paragraph">
<p>要声明一个可变的托管属性，请为该类型的属性添加一个抽象的getter方法和一个抽象的setter方法。</p>
</div>
<div class="paragraph">
<p>这是一个带有<code>uri</code>属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例489可变托管财产</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">下载.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.Input</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>;

<span class="keyword">import</span> <span class="include">java.net.URI</span>;

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract getter and setter method</span>
    <span class="annotation">@Input</span>
    <span class="directive">abstract</span> <span class="predefined-type">URI</span> getUri();
    <span class="directive">abstract</span> <span class="type">void</span> setUri(<span class="predefined-type">URI</span> uri);

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// Use the `uri` property</span>
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading </span><span class="delimiter">&quot;</span></span> + getUri());
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.api.DefaultTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import java.net.URI

abstract class Download : DefaultTask() {
    // Use an abstract var
    @get:Input
    abstract var uri: URI

    @TaskAction
    fun run() {
        // Use the `uri` property
        println(&quot;Downloading $uri&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.Input</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>

<span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract property</span>
    <span class="annotation">@Input</span>
    <span class="directive">abstract</span> <span class="predefined-type">URI</span> uri

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// Use the `uri` property</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">downloading </span><span class="inline"><span class="inline-delimiter">${</span>uri<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，要使某个属性被视为可变的托管属性，该属性的<em>所有</em> getter方法和setter方法都必须是<code>abstract</code>并有<code>public</code>要么<code>protected</code>能见度。</p>
</div>
</div>
<div class="sect5">
<h6 id="read_only_managed_properties"><a class="anchor" href="#read_only_managed_properties"></a> <a class="link" href="#read_only_managed_properties">只读托管属性</a></h6>
<div class="paragraph">
<p>要声明只读托管属性，请为该类型添加抽象的getter方法。该属性不应具有任何setter方法。Gradle将提供getter的实现，并为该属性创建一个值。</p>
</div>
<div class="paragraph">
<p>这是与Gradle可配置的<a href="#lazy_configuration">惰性属性</a>或容器类型之一一起使用的有用模式。</p>
</div>
<div class="paragraph">
<p>这是一个带有<code>uri</code>属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例490只读托管属性</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">下载.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.provider.Property</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.Input</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>;

<span class="keyword">import</span> <span class="include">java.net.URI</span>;

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract getter method</span>
    <span class="annotation">@Input</span>
    <span class="directive">abstract</span> Property&lt;<span class="predefined-type">URI</span>&gt; getUri();

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// Use the `uri` property</span>
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading </span><span class="delimiter">&quot;</span></span> + getUri().get());
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.api.DefaultTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import org.gradle.api.provider.Property
import java.net.URI

abstract class Download : DefaultTask() {
    // Use an abstract val
    @get:Input
    abstract val uri: Property&lt;URI&gt;

    @TaskAction
    fun run() {
        // Use the `uri` property
        println(&quot;Downloading ${uri.get()}&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.Input</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.provider.Property</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>

<span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract getter method</span>
    <span class="annotation">@Input</span>
    <span class="directive">abstract</span> Property&lt;<span class="predefined-type">URI</span>&gt; getUri()

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// Use the `uri` property</span>
        println <span class="string"><span class="delimiter">&quot;</span><span class="content">downloading </span><span class="inline"><span class="inline-delimiter">${</span>uri.get()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，对于一个被视为只读托管属性的属性，该属性的<em>所有</em> getter方法都必须是<code>abstract</code>并有<code>public</code>要么<code>protected</code>能见度。该属性不得具有任何setter方法。此外，属性类型必须具有以下之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Property<T></code></p>
</li>
<li>
<p><code>RegularFileProperty</code></p>
</li>
<li>
<p><code>DirectoryProperty</code></p>
</li>
<li>
<p><code>ListProperty<T></code></p>
</li>
<li>
<p><code>SetProperty<T></code></p>
</li>
<li>
<p><code>MapProperty<K, V></code></p>
</li>
<li>
<p><code>ConfigurableFileCollection</code></p>
</li>
<li>
<p><code>ConfigurableFileTree</code></p>
</li>
<li>
<p><code>NamedDomainObjectContainer<T></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle以与<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a>相同的方式为只读托管属性创建值。</p>
</div>
</div>
<div class="sect5">
<h6 id="read_only_managed_nested_properties"><a class="anchor" href="#read_only_managed_nested_properties"></a> <a class="link" href="#read_only_managed_nested_properties">只读托管嵌套属性</a></h6>
<div class="paragraph">
<p>要声明只读托管嵌套属性，请将该属性的抽象getter方法添加到带注释的类型<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code> 。该属性不应具有任何setter方法。Gradle提供了getter方法的实现，还为该属性创建了一个值。嵌套类型也被视为自定义类型，并且可以使用本章中讨论的功能。</p>
</div>
<div class="paragraph">
<p>当自定义类型具有具有相同生命周期的嵌套复杂类型时，此模式很有用。如果生命周期不同，请考虑使用<code>Property<NestedType></code>代替。</p>
</div>
<div class="paragraph">
<p>这是一个带有<code>resource</code>属性。的<code>Resource</code> type也是自定义Gradle类型，并定义了一些托管属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例491只读托管嵌套属性</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">下载.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract getter method annotated with @Nested</span>
    <span class="annotation">@Nested</span>
    <span class="directive">abstract</span> Resource getResource();

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// Use the `resource` property</span>
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading https://</span><span class="delimiter">&quot;</span></span> + getResource().getHostName().get() + <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span> + getResource().getPath().get());
    }
}

<span class="directive">public</span> <span class="type">interface</span> <span class="class">Resource</span> {
    <span class="annotation">@Input</span>
    Property&lt;<span class="predefined-type">String</span>&gt; getHostName();
    <span class="annotation">@Input</span>
    Property&lt;<span class="predefined-type">String</span>&gt; getPath();
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">abstract class Download : DefaultTask() {
    // Use an abstract getter method annotated with @Nested
    @get:Nested
    abstract val resource: Resource

    @TaskAction
    fun run() {
        // Use the `resource` property
        println(&quot;Downloading https://${resource.hostName.get()}/${resource.path.get()}&quot;)
    }
}

interface Resource {
    @get:Input
    val hostName: Property&lt;String&gt;
    @get:Input
    val path: Property&lt;String&gt;
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract getter method annotated with @Nested</span>
    <span class="annotation">@Nested</span>
    <span class="directive">abstract</span> Resource getResource()

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// Use the `resource` property</span>
        println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Downloading https://</span><span class="inline"><span class="inline-delimiter">${</span>resource.hostName.get()<span class="inline-delimiter">}</span></span><span class="content">/</span><span class="inline"><span class="inline-delimiter">${</span>resource.path.get()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

<span class="type">interface</span> Resource {
    <span class="annotation">@Input</span>
    Property&lt;<span class="predefined-type">String</span>&gt; getHostName()
    <span class="annotation">@Input</span>
    Property&lt;<span class="predefined-type">String</span>&gt; getPath()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，对于一个被视为只读托管嵌套属性的属性，该属性的<em>所有</em> getter方法都必须是<code>abstract</code>并有<code>public</code>要么<code>protected</code>能见度。该属性不得具有任何setter方法。此外，属性获取器必须带有以下注释<code>@<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/Nested.html">Nested</a></code> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="managed_types"><a class="anchor" href="#managed_types"></a> <a class="link" href="#managed_types">托管类型</a></h5>
<div class="paragraph">
<p><em>托管类型</em>是没有字段且其属性都被托管的抽象类或接口。也就是说，这是一种其状态完全由Gradle管理的类型。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dsl_support_and_extensibility"><a class="anchor" href="#dsl_support_and_extensibility"></a> <a class="link" href="#dsl_support_and_extensibility">DSL支持和可扩展性</a></h4>
<div class="paragraph">
<p>当Gradle创建自定义类型的实例时，它会将该实例<em>装饰</em>为混入DSL和可扩展性支持。</p>
</div>
<div class="paragraph">
<p>每个装饰的实例都实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/ExtensionAware.html">ExtensionAware</a> ，因此可以将扩展对象附加到它。</p>
</div>
<div class="paragraph">
<p>请注意，由于向后兼容性问题，当前未装饰使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Project.html#container-java.lang.Class-">Project.container（）</a>创建的插件和容器的元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="service_injection"><a class="anchor" href="#service_injection"></a> <a class="link" href="#service_injection">服务注入</a></h4>
<div class="paragraph">
<p>Gradle提供了许多可用于自定义Gradle类型的有用服务。例如，任务可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html">WorkerExecutor</a>服务来并行运行工作，如<a href="#worker_api">worker API</a>部分所示。通过<em>服务注入</em>可以提供<em>服务</em> 。</p>
</div>
<div class="sect4">
<h5 id="services_for_injection"><a class="anchor" href="#services_for_injection"></a> <a class="link" href="#services_for_injection">可用服务</a></h5>
<div class="paragraph">
<p>以下服务可用于注入：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory-</a>允许创建模型对象。有关更多详细信息，请参见<a href="#nested_objects">创建嵌套对象</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/ProjectLayout.html">ProjectLayout-</a>提供对关键项目位置的访问。有关更多详细信息，请参见<a href="#sec:working_with_files_in_lazy_properties">延迟配置</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/provider/ProviderFactory.html">ProviderFactory-</a>创建<code>Provider</code>实例。有关更多详细信息，请参见<a href="#lazy_configuration">延迟配置</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/workers/WorkerExecutor.html">WorkerExecutor-</a>允许任务并行运行工作。有关更多详细信息，请参见<a href="#worker_api">worker API</a> 。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileSystemOperations.html">FileSystemOperations-</a>允许任务在文件系统上运行操作，例如删除文件，复制文件或同步目录。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/process/ExecOperations.html">ExecOperations-</a>允许任务运行外部进程，并为运行外部进程提供专门支持<code>java</code>程式。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="constructor_injection"><a class="anchor" href="#constructor_injection"></a> <a class="link" href="#constructor_injection">构造器注入</a></h5>
<div class="paragraph">
<p>对象可以通过两种方式接收其所需的服务。第一种选择是将服务添加为类构造函数的参数。构造函数必须使用注释<code>javax.inject.Inject</code>注解。Gradle使用每个构造函数参数的声明类型来确定对象所需的服务。构造函数参数及其名称的顺序并不重要，可以随便更改。</p>
</div>
<div class="paragraph">
<p>这是一个示例，显示了接收<code>ObjectFactory</code>通过其构造函数：</p>
</div>
<div class="exampleblock">
<div class="title">示例492构造服务注入</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">下载.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.file.DirectoryProperty</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.OutputDirectory</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>;

<span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="directive">private</span> <span class="directive">final</span> DirectoryProperty outputDirectory;

    <span class="comment">// Inject an ObjectFactory into the constructor</span>
    <span class="annotation">@Inject</span>
    <span class="directive">public</span> Download(<span class="predefined-type">ObjectFactory</span> objectFactory) {
        <span class="comment">// Use the factory</span>
        outputDirectory = objectFactory.directoryProperty();
    }

    <span class="annotation">@OutputDirectory</span>
    <span class="directive">public</span> DirectoryProperty getOutputDirectory() {
        <span class="keyword">return</span> outputDirectory;
    }

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import javax.inject.Inject
import org.gradle.api.model.ObjectFactory
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.OutputDirectory

open class Download
// Inject an ObjectFactory into the constructor
@Inject constructor(objectFactory: ObjectFactory) : DefaultTask() {
    // Use the factory
    @OutputDirectory
    val outputDirectory = objectFactory.directoryProperty()

    @TaskAction
    fun run() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.file.DirectoryProperty</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.OutputDirectory</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>

<span class="keyword">import</span> <span class="include">javax.inject.Inject</span>

<span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="annotation">@OutputDirectory</span>
    <span class="directive">final</span> DirectoryProperty outputDirectory

    <span class="comment">// Inject an ObjectFactory into the constructor</span>
    <span class="annotation">@Inject</span>
    Download(<span class="predefined-type">ObjectFactory</span> objectFactory) {
        <span class="comment">// Use the factory</span>
        outputDirectory = objectFactory.directoryProperty()
    }

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="property_injection"><a class="anchor" href="#property_injection"></a> <a class="link" href="#property_injection">资产注入</a></h5>
<div class="paragraph">
<p>或者，可以通过添加带有注解的属性获取方法来注入服务。 <code>javax.inject.Inject</code>类的注释。例如，当由于向后兼容性约束而无法更改类的构造函数时，这可能会很有用。这种模式还允许Gradle将服务的创建推迟到调用getter方法之前，而不是在创建实例时进行。这可以帮助提高性能。Gradle使用getter方法的声明的返回类型来确定要提供的服务。该属性的名称并不重要，并且可以是您喜欢的任何名称。</p>
</div>
<div class="paragraph">
<p>属性获取方法必须是<code>public</code>要么<code>protected</code> 。该方法可以是<code>abstract</code>或者，在不可能的情况下，可以使用虚拟方法主体。方法主体将被丢弃。</p>
</div>
<div class="paragraph">
<p>这是一个示例，显示了一个通过属性getter方法接收两项服务的任务类型：</p>
</div>
<div class="exampleblock">
<div class="title">示例493。物业服务注入</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">下载.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>;
<span class="keyword">import</span> <span class="include">org.gradle.workers.WorkerExecutor</span>;

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract getter method</span>
    <span class="annotation">@Inject</span>
    <span class="directive">protected</span> <span class="directive">abstract</span> <span class="predefined-type">ObjectFactory</span> getObjectFactory();

    <span class="comment">// Alternatively, use a getter method with a dummy implementation</span>
    <span class="annotation">@Inject</span>
    <span class="directive">protected</span> WorkerExecutor getWorkerExecutor() {
        <span class="comment">// Method body is ignored</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span>();
    }

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        WorkerExecutor workerExecutor = getWorkerExecutor();
        <span class="predefined-type">ObjectFactory</span> objectFactory = getObjectFactory();
        <span class="comment">// Use the executor and factory ...</span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import javax.inject.Inject
import org.gradle.api.model.ObjectFactory
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import org.gradle.workers.WorkerExecutor

abstract class Download : DefaultTask() {
    // Use an abstract property
    // Note that the @Inject annotation must be attached to the getter
    @get:Inject
    abstract val objectFactory: ObjectFactory

    // Alternatively, use a property getter with a dummy implementation
    // Note that the property must be open and the @Inject annotation must be attached to the getter
    @get:Inject
    open val workerExecutor: WorkerExecutor
        get() {
            // Getter body is ignored
            throw UnsupportedOperationException()
        }

    @TaskAction
    fun run() {
        // Use the executor and factory ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">下载.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.api.DefaultTask</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.tasks.TaskAction</span>
<span class="keyword">import</span> <span class="include">org.gradle.workers.WorkerExecutor</span>

<span class="keyword">import</span> <span class="include">javax.inject.Inject</span>

<span class="directive">abstract</span> <span class="type">class</span> <span class="class">Download</span> <span class="directive">extends</span> DefaultTask {
    <span class="comment">// Use an abstract getter method</span>
    <span class="annotation">@Inject</span>
    <span class="directive">protected</span> <span class="directive">abstract</span> <span class="predefined-type">ObjectFactory</span> getObjectFactory()

    <span class="comment">// Alternatively, use a getter method with a dummy implementation</span>
    <span class="annotation">@Inject</span>
    <span class="directive">protected</span> WorkerExecutor getWorkerExecutor() {
        <span class="comment">// Method body is ignored</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span>()
    }

    <span class="annotation">@TaskAction</span>
    <span class="type">void</span> run() {
        <span class="comment">// Use the executor and factory ...</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nested_objects"><a class="anchor" href="#nested_objects"></a> <a class="link" href="#nested_objects">创建嵌套对象</a></h4>
<div class="paragraph">
<p>自定义Gradle类型可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a>服务来创建Gradle类型的实例以用于其属性值。这些实例可以利用本章讨论的功能，使您可以创建“嵌套”对象和嵌套DSL。</p>
</div>
<div class="paragraph">
<p>您还可以让Gradle使用<a href="#read_only_managed_nested_properties">托管的嵌套属性</a>为您创建嵌套对象。</p>
</div>
<div class="paragraph">
<p>在以下示例中，项目扩展收到了<code>ObjectFactory</code>通过其构造函数实例。构造函数使用它来创建一个嵌套<code>Resource</code>对象（也是自定义的Gradle类型），并通过<code>resource</code>属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例494嵌套对象创建</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">DownloadExtension.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>;

<span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">DownloadExtension</span> {
    <span class="comment">// A nested instance</span>
    <span class="directive">private</span> <span class="directive">final</span> Resource resource;

    <span class="annotation">@Inject</span>
    <span class="directive">public</span> DownloadExtension(<span class="predefined-type">ObjectFactory</span> objectFactory) {
        <span class="comment">// Use an injected ObjectFactory to create a Resource object</span>
        resource = objectFactory.newInstance(Resource.class);
    }

    <span class="directive">public</span> Resource getResource() {
        <span class="keyword">return</span> resource;
    }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Resource</span> {
    <span class="directive">private</span> <span class="predefined-type">URI</span> uri;

    <span class="directive">public</span> <span class="predefined-type">URI</span> getUri() {
        <span class="keyword">return</span> uri;
    }
    <span class="directive">public</span> <span class="type">void</span> setUri(<span class="predefined-type">URI</span> uri) {
        <span class="local-variable">this</span>.uri = uri;
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">DownloadExtension.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import javax.inject.Inject
import org.gradle.api.model.ObjectFactory

open class DownloadExtension @Inject constructor(objectFactory: ObjectFactory) {
    // Use an injected ObjectFactory to create a nested Resource object
    val resource: Resource = objectFactory.newInstance(Resource::class.java)
}

open class Resource {
    var uri: URI? = null
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">DownloadExtension.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>

<span class="keyword">import</span> <span class="include">javax.inject.Inject</span>

<span class="type">class</span> <span class="class">DownloadExtension</span> {
    <span class="comment">// A nested instance</span>
    <span class="directive">final</span> Resource resource

    <span class="annotation">@Inject</span>
    DownloadExtension(<span class="predefined-type">ObjectFactory</span> objectFactory) {
        <span class="comment">// Use an injected ObjectFactory to create a Resource object</span>
        resource = objectFactory.newInstance(Resource)
    }
}

<span class="type">class</span> <span class="class">Resource</span> {
    <span class="predefined-type">URI</span> uri
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collection_types"><a class="anchor" href="#collection_types"></a> <a class="link" href="#collection_types">集合类型</a></h4>
<div class="paragraph">
<p>Gradle提供了用于维护对象集合的类型，旨在与Gradle DSL配合使用并提供有用的功能，例如惰性配置。</p>
</div>
<div class="sect4">
<h5 id="nameddomainobjectcontainer"><a class="anchor" href="#nameddomainobjectcontainer"></a> <a class="link" href="#nameddomainobjectcontainer">命名域对象容器</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/NamedDomainObjectContainer.html">NamedDomainObjectContainer</a>管理一组对象，其中每个元素都有一个与之关联的名称。该容器负责创建和配置元素，并提供DSL，构建脚本可用于定义和配置元素。它旨在容纳本身可配置的对象，例如一组自定义Gradle对象。</p>
</div>
<div class="paragraph">
<p>摇篮用途<code>NamedDomainObjectContainer</code>在整个API中广泛键入。例如， <code>project.tasks</code>用于管理项目任务的对象是<code>NamedDomainObjectContainer<Task></code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用提供<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#domainObjectContainer-java.lang.Class-">ObjectFactory.domainObjectContainer（）</a>方法的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html">ObjectFactory</a>服务创建一个容器实例。使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Project.html#container-java.lang.Class-">Project.container（）</a>方法也可以使用此方法，但是在自定义Gradle类型中，通常最好使用注入的<code>ObjectFactory</code>服务而不是绕过<code>Project</code>实例。</p>
</div>
<div class="paragraph">
<p>您还可以使用如上所述的<a href="#read_only_managed_properties">只读托管属性</a>创建容器实例。</p>
</div>
<div class="paragraph">
<p>为了将类型与<code>domainObjectContainer()</code>方法，它必须公开名为“ name”的属性作为对象的唯一且恒定的名称。的<code>domainObjectContainer(Class)</code>该方法的变体通过调用带有字符串参数的类的构造函数来创建新实例，该参数是对象的所需名称。以这种方式创建的对象被视为自定义Gradle类型，因此可以利用本章讨论的功能，例如服务注入或托管属性。</p>
</div>
<div class="paragraph">
<p>见上面的链接<code>domainObjectContainer()</code>允许自定义实例化策略的方法变体。</p>
</div>
<div class="exampleblock">
<div class="title">示例495管理对象集合</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">DownloadExtension.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.gradle.api.NamedDomainObjectContainer</span>;
<span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>;

<span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">DownloadExtension</span> {
    <span class="comment">// A container of `Resource` objects</span>
    <span class="directive">private</span> <span class="directive">final</span> NamedDomainObjectContainer&lt;Resource&gt; resources;

    <span class="annotation">@Inject</span>
    <span class="directive">public</span> DownloadExtension(<span class="predefined-type">ObjectFactory</span> objectFactory) {
        <span class="comment">// Use an injected ObjectFactory to create a container</span>
        resources = objectFactory.domainObjectContainer(Resource.class);
    }

    <span class="directive">public</span> NamedDomainObjectContainer&lt;Resource&gt; getResources() {
        <span class="keyword">return</span> resources;
    }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Resource</span> {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> name;
    <span class="directive">private</span> <span class="predefined-type">URI</span> uri;
    <span class="directive">private</span> <span class="predefined-type">String</span> userName;

    <span class="comment">// Type must have a public constructor that takes the element name as a parameter</span>
    <span class="directive">public</span> Resource(<span class="predefined-type">String</span> name) {
        <span class="local-variable">this</span>.name = name;
    }

    <span class="comment">// Type must have a 'name' property, which should be read-only</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
        <span class="keyword">return</span> name;
    }

    <span class="directive">public</span> <span class="predefined-type">URI</span> getUri() {
        <span class="keyword">return</span> uri;
    }
    <span class="directive">public</span> <span class="type">void</span> setUri(<span class="predefined-type">URI</span> uri) {
        <span class="local-variable">this</span>.uri = uri;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getUserName() {
        <span class="keyword">return</span> userName;
    }
    <span class="directive">public</span> <span class="type">void</span> setUserName(<span class="predefined-type">String</span> userName) {
        <span class="local-variable">this</span>.userName = userName;
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">DownloadExtension.kt</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import javax.inject.Inject
import org.gradle.api.model.ObjectFactory
import org.gradle.api.NamedDomainObjectContainer

open class DownloadExtension @Inject constructor(objectFactory: ObjectFactory) {
    // Use an injected ObjectFactory to create a container of `Resource` objects
    val resources = objectFactory.domainObjectContainer(Resource::class.java)
}

// Type must have a public constructor that takes the element name as a parameter
// Type must have a 'name' property, which should be read-only
open class Resource(val name: String) {
    var uri: URI? = null
    var userName: String? = null
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">DownloadExtension.groovy</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">org.gradle.api.NamedDomainObjectContainer</span>
<span class="keyword">import</span> <span class="include">org.gradle.api.model.ObjectFactory</span>

<span class="keyword">import</span> <span class="include">javax.inject.Inject</span>

<span class="type">class</span> <span class="class">DownloadExtension</span> {
    <span class="comment">// A container of `Resource` instances</span>
    <span class="directive">final</span> NamedDomainObjectContainer&lt;Resource&gt; resources

    <span class="annotation">@Inject</span>
    DownloadExtension(<span class="predefined-type">ObjectFactory</span> objectFactory) {
        <span class="comment">// Use an injected ObjectFactory to create a container</span>
        resources = objectFactory.domainObjectContainer(Resource)
    }
}

<span class="type">class</span> <span class="class">Resource</span> {
    <span class="comment">// Type must have a 'name' property, which should be read-only</span>
    <span class="directive">final</span> <span class="predefined-type">String</span> name
    <span class="predefined-type">URI</span> uri
    <span class="predefined-type">String</span> userName

    <span class="comment">// Type must have a public constructor that takes the element name as a parameter</span>
    Resource(<span class="predefined-type">String</span> name) {
        <span class="local-variable">this</span>.name = name
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于每个容器属性，Gradle会自动向Groovy和Kotlin DSL添加一个块，您可以使用该块来配置容器的内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例496配置块</div>
<div class="content">
<div class="listingblock multi-language-sample">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;org.gradle.sample.download&quot;)
}

download {
    // Can use a block to configure the container contents
    resources {
        register(&quot;gradle&quot;) {
            uri = uri(&quot;https://gradle.org&quot;)
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock multi-language-sample">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.sample.download</span><span class="delimiter">&quot;</span></span>)
}

download {
    <span class="comment">// Can use a block to configure the container contents</span>
    resources {
        gradle {
            uri = uri(<span class="string"><span class="delimiter">'</span><span class="content">https://gradle.org</span><span class="delimiter">'</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="domainobjectset"><a class="anchor" href="#domainobjectset"></a> <a class="link" href="#domainobjectset">DomainObjectSet</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/DomainObjectSet.html">DomainObjectSet</a>仅保存一组对象。相比<code>NamedDomainObjectContainer</code> ， <code>DomainObjectSet</code>不管理集合中的对象。它们需要手动创建和添加。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/model/ObjectFactory.html#domainObjectSet-java.lang.Class-">ObjectFactory.domainObjectSet（）</a>方法创建实例。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java_gradle_plugin"><a class="anchor" href="#java_gradle_plugin"></a> <a class="link" href="#java_gradle_plugin">Gradle插件开发插件</a></h3>
<div class="paragraph">
<p>Java Gradle插件开发插件可用于协助Gradle插件的开发。它会自动应用<a href="#">Java库</a>插件，并添加<code>gradleApi()</code>依赖于<code>api</code>配置并在期间执行插件元数据的验证<code>jar</code>任务执行。</p>
</div>
<div class="paragraph">
<p>该插件还与<a href="#test_kit">TestKit</a>集成在一起， <a href="#test_kit">后者</a>是一个有助于编写和执行插件代码功能测试的库。它会自动添加<code>gradleTestKit()</code>依赖于<code>testImplementation</code>配置并生成由插件消耗的插件类路径清单文件<code>GradleRunner</code>实例（如果找到）。有关其用法，配置选项和示例的更多信息，请参阅<a href="#sub:test-kit-automatic-classpath-injection">带有插件开发插件的自动类路径注入</a> 。</p>
</div>
<div class="sect3">
<h4 id="sec:gradle_plugin_dev_usage"><a class="anchor" href="#sec:gradle_plugin_dev_usage"></a> <a class="link" href="#sec:gradle_plugin_dev_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Java Gradle插件开发插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例497使用Java Gradle插件开发插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-gradle-plugin</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-gradle-plugin`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>应用插件会自动应用<a href="#">Java库</a>插件并添加<code>gradleApi()</code>依赖于<code>api</code>组态。它还向构建添加了一些验证。</p>
</div>
<div class="paragraph">
<p>执行以下验证：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有一个为插件定义的插件描述符。</p>
</li>
<li>
<p>插件描述符包含一个<code>implementation-class</code>属性。</p>
</li>
<li>
<p>的<code>implementation-class</code>属性引用了jar中的有效类文件。</p>
</li>
<li>
<p>每个属性获取器或相应的字段都必须使用属性注释来注释，例如<code>@InputFile</code>和<code>@OutputDirectory</code> 。不参与最新检查的属性应标有<code>@Internal</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>验证失败将导致警告消息。</p>
</div>
<div class="paragraph">
<p>对于您正在开发的每个插件，将一个条目添加到<code>gradlePlugin {}</code>脚本块：</p>
</div>
<div class="exampleblock">
<div class="title">示例498。使用gradlePlugin {}块。</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gradlePlugin {
    plugins {
        simplePlugin {
            id = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.simple-plugin</span><span class="delimiter">'</span></span>
            implementationClass = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.SimplePlugin</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">gradlePlugin {
    plugins {
        create(&quot;simplePlugin&quot;) {
            id = &quot;org.gradle.sample.simple-plugin&quot;
            implementationClass = &quot;org.gradle.sample.SimplePlugin&quot;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>gradlePlugin {}</code>块定义了项目正在构建的插件，包括<code>id</code>和<code>implementationClass</code>的插件。根据有关正在开发的插件的数据，Gradle可以自动：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在中生成插件描述符<code>jar</code>文件的<code>META-INF</code>目录。</p>
</li>
<li>
<p>配置<a href="#publishing_maven">Maven</a>或<a href="#publishing_ivy">Ivy Publish Plugins</a>发布插件，以为每个插件发布<a href="#sec:plugin_markers">插件标记工件</a> 。</p>
</li>
<li>
<p>此外，如果应用了<a href="https://plugins.gradle.org/docs/publish-plugin">插件发布插件</a> ，它将使用相同的名称，插件ID，显示名称和描述将每个插件发布到Gradle插件门户（有关详细信息，请参阅<a href="https://guides.gradle.org/publishing-plugins-to-gradle-plugin-portal/">将插件发布到Gradle插件门户</a> ）。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="part:reference"><a class="anchor" href="#part:reference"></a> <a class="link" href="#part:reference">参考</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="groovy_build_script_primer"><a class="anchor" href="#groovy_build_script_primer"></a> <a class="link" href="#groovy_build_script_primer">Groovy构建脚本入门</a></h3>
<div class="paragraph">
<p>理想情况下，Groovy构建脚本看起来与配置很像：设置项目的某些属性，配置依赖项，声明任务等。该配置基于Groovy语言构造。本入门手册旨在说明这些构造是什么，最重要的是，它们与Gradle的API文档之间的关系。</p>
</div>
<div class="sect3">
<h4 id="groovy:project_object"><a class="anchor" href="#groovy:project_object"></a> <a class="link" href="#groovy:project_object">的<code>Project</code>宾语</a></h4>
<div class="paragraph">
<p>由于Groovy是基于Java的面向对象的语言，因此其属性和方法适用于对象。在某些情况下，对象是隐式的-特别是在构建脚本的顶层，即不嵌套在<code>{}</code>块。</p>
</div>
<div class="paragraph">
<p>考虑以下构建脚本片段，其中包含一个不合格的属性和块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">version = <span class="string"><span class="delimiter">'</span><span class="content">1.0.0.GA</span><span class="delimiter">'</span></span>

configurations {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>都<code>version</code>和<code>configurations {}</code>是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">org.gradle.api的一部分</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">。项目</a> 。</p>
</div>
<div class="paragraph">
<p>此示例反映了每个Groovy构建脚本如何由的隐式实例支持<code>Project</code> 。如果看到不合格的元素并且不知道在哪里定义，请务必检查<code>Project</code> API文档，以查看其来源。</p>
</div>
</div>
<div class="sect3">
<h4 id="groovy:properties"><a class="anchor" href="#groovy:properties"></a> <a class="link" href="#groovy:properties">物产</a></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&lt;obj&gt;.&lt;name&gt;                <span class="comment">// Get a property value</span>
&lt;obj&gt;.&lt;name&gt; = &lt;value&gt;      <span class="comment">// Set a property to a new value</span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">$</span><span class="content">&lt;name&gt;</span><span class="delimiter">&quot;</span></span>                   <span class="comment">// Embed a property value in a string</span>
<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>&lt;obj&gt;.&lt;name&gt;<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>           <span class="comment">// Same as previous (embedded value)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">例子</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">version = <span class="string"><span class="delimiter">'</span><span class="content">1.0.1</span><span class="delimiter">'</span></span>
myCopyTask.description = <span class="string"><span class="delimiter">'</span><span class="content">Copies some files</span><span class="delimiter">'</span></span>

file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/classes</span><span class="delimiter">&quot;</span></span>)
println <span class="string"><span class="delimiter">&quot;</span><span class="content">Destination: </span><span class="inline"><span class="inline-delimiter">${</span>myCopyTask.destinationDir<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>属性表示对象的某种状态。存在<code>=</code>符号清楚地表明您正在寻找房地产。否则，使用限定名称-开头为<code><obj>.</code> -没有任何其他装饰也是财产。</p>
</div>
<div class="paragraph">
<p>如果名称不合格，则可能是以下之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有该名称的任务实例。</p>
</li>
<li>
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project的</a>一个属性。</p>
</li>
<li>
<p>在项目中其他地方定义的<a href="#sec:extra_properties">额外属性</a> 。</p>
</li>
<li>
<p><a href="#groovy:blocks">块</a>内隐式对象的属性。</p>
</li>
<li>
<p>在构建脚本前面定义的<a href="#groovy:local_variables">局部变量</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，插件可以将自己的属性添加到<code>Project</code>宾语。<a href="https://docs.gradle.org/6.0.1/dsl/">API文档</a>列出了核心插件添加的所有属性。如果您很难找到属性的来源，请查看文档以了解构建所使用的插件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">在您的构建脚本中引用由非核心插件添加的项目属性时，请考虑使用前缀<code>project.</code> —显然，该属性属于项目对象。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="properties_in_the_api_documentation"><a class="anchor" href="#properties_in_the_api_documentation"></a> <a class="link" href="#properties_in_the_api_documentation">API文档中的属性</a></h5>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/">Groovy DSL参考</a>显示了在构建脚本中使用的属性，但是Javadocs仅显示方法。这是因为属性是作为幕后方法实现的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果存在名为的方法，则可以<em>读取</em>属性<code>get<PropertyName></code>带有零个参数的参数，返回与属性相同的类型。</p>
</li>
<li>
<p>如果存在名为的方法，则可以<em>修改</em>属性<code>set<PropertyName></code>一个参数与属性具有相同类型，返回类型为<code>void</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，属性名称通常以小写字母开头，但是该字母在方法名称中为大写字母。所以吸气方法<code>getProjectVersion()</code>对应于属性<code>projectVersion</code> 。当名称至少以两个大写字母开头时，该约定不适用，在这种情况下，大小写不变。例如， <code>getRAM()</code>对应于属性<code>RAM</code> 。</p>
</div>
<div class="listingblock">
<div class="title">例子</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">project.getVersion()
project.version

project.setVersion(<span class="string"><span class="delimiter">'</span><span class="content">1.0.1</span><span class="delimiter">'</span></span>)
project.version = <span class="string"><span class="delimiter">'</span><span class="content">1.0.1</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="groovy:methods"><a class="anchor" href="#groovy:methods"></a> <a class="link" href="#groovy:methods">方法</a></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&lt;obj&gt;.&lt;name&gt;()              <span class="comment">// Method call with no arguments</span>
&lt;obj&gt;.&lt;name&gt;(&lt;arg&gt;, &lt;arg&gt;)  <span class="comment">// Method call with multiple arguments</span>
&lt;obj&gt;.&lt;name&gt; &lt;arg&gt;, &lt;arg&gt;   <span class="comment">// Method call with multiple args (no parentheses)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">例子</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">myCopyTask.include <span class="string"><span class="delimiter">'</span><span class="content">**/*.xml</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">**/*.properties</span><span class="delimiter">'</span></span>

ext.resourceSpec = copySpec()   <span class="comment">// `copySpec()` comes from `Project`</span>

file(<span class="string"><span class="delimiter">'</span><span class="content">src/main/java</span><span class="delimiter">'</span></span>)
println <span class="string"><span class="delimiter">'</span><span class="content">Hello, World!</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>方法代表对象的某种行为，尽管Gradle经常也使用方法来配置对象的状态。方法可以通过其参数或空括号来识别。请注意，有时需要使用括号，例如当一个方法的参数为零时，因此始终使用括号最简单。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">Gradle有一个约定，如果一个方法与基于集合的属性具有相同的名称，则该方法<em>会将</em>其值<em>附加</em>到该集合。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="groovy:blocks"><a class="anchor" href="#groovy:blocks"></a> <a class="link" href="#groovy:blocks">积木</a></h4>
<div class="paragraph">
<p>块也是<a href="#groovy:methods">方法</a> ，只是最后一个参数具有特定类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">&lt;obj&gt;.&lt;name&gt; {
     ...
}

&lt;obj&gt;.&lt;name&gt;(&lt;arg&gt;, &lt;arg&gt;) {
     ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">例子</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    assets
}

sourceSets {
    main {
        java {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">src</span><span class="delimiter">'</span></span>]
        }
    }
}

project(<span class="string"><span class="delimiter">'</span><span class="content">:util</span><span class="delimiter">'</span></span>) {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>块是一种用于一次性构造构建元素的多个方面的机制。它们还提供了嵌套配置的方法，从而导致结构化数据的形式。</p>
</div>
<div class="paragraph">
<p>您应该了解块的两个重要方面：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>它们被实现为具有特定签名的方法。</p>
</li>
<li>
<p>他们可以更改不合格方法和属性的目标（“委托”）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>两者均基于Groovy语言功能，我们将在以下各节中进行解释。</p>
</div>
<div class="sect4">
<h5 id="block_method_signatures"><a class="anchor" href="#block_method_signatures"></a> <a class="link" href="#block_method_signatures">块方法签名</a></h5>
<div class="paragraph">
<p>您可以通过其签名（或更具体地说，其参数类型）轻松地将方法标识为块后面的实现。如果方法对应于一个块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它必须至少有一个参数。</p>
</li>
<li>
<p><em>最后一个</em>参数必须是类型<a href="https://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Closure.html"><code>groovy.lang.Closure</code></a>或<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/Action.html">org.gradle.api。行动</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:copy(org.gradle.api.Action)">Project.copy（Action）</a>符合以下要求，因此可以使用以下语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">copy {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/tmp</span><span class="delimiter">&quot;</span></span>
    from <span class="string"><span class="delimiter">'</span><span class="content">custom-resources</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就引出了一个问题<code>into()</code>和<code>from()</code>工作。它们显然是方法，但是您会在API文档中找到它们吗？答案来自对对象<em>委托的</em>理解。</p>
</div>
</div>
<div class="sect4">
<h5 id="delegation"><a class="anchor" href="#delegation"></a> <a class="link" href="#delegation">代表团</a></h5>
<div class="paragraph">
<p><a href="#groovy:properties">属性部分</a>列出了可能会发现不合格属性的地方。一个常见的地方是<code>Project</code>宾语。但是，对于块内的那些不合格的属性和方法，还有另一种来源：块的<em>委托对象</em> 。</p>
</div>
<div class="paragraph">
<p>为了帮助解释这个概念，请考虑上一节中的最后一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">copy {
    into <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/tmp</span><span class="delimiter">&quot;</span></span>
    from <span class="string"><span class="delimiter">'</span><span class="content">custom-resources</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例中的所有方法和属性均不合格。您可以轻松找到<code>copy()</code>和<code>buildDir</code>在里面<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html"><code>Project</code> API文档</a> ，但是呢？ <code>into()</code>和<code>from()</code> ？这些是针对<code>copy {}</code>块。该代表的类型是什么？您需要<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:copy(org.gradle.api.Action)">查看API文档</a> 。</p>
</div>
<div class="paragraph">
<p>有两种方法可以确定委托类型，具体取决于block方法的签名：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于<code>Action</code>参数，请查看类型的参数。</p>
<div class="paragraph">
<p>在上面的示例中，方法签名为<code>copy(Action<? super CopySpec>)</code>正是尖括号内的内容告诉您委托类型-在这种情况下为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html">CopySpec</a> 。</p>
</div>
</li>
<li>
<p>对于<code>Closure</code>自变量，文档将在描述中明确说明正在配置的类型或委托的类型（同一事物的不同术语）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，您可以同时找到in <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#into-java.lang.Object-">（）</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html#from-java.lang.Object...-">from（）</a> <code>CopySpec</code> 。您甚至可能会注意到，这两种方法都具有采用<code>Action</code>作为它们的最后一个参数，这意味着您可以对它们使用块语法。</p>
</div>
<div class="paragraph">
<p>所有新的Gradle API都声明了<code>Action</code>参数类型而不是<code>Closure</code> ，这使得选择委托类型非常容易。甚至更老的API都有<code>Action</code>除了旧版本<code>Closure</code>一。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="groovy:local_variables"><a class="anchor" href="#groovy:local_variables"></a> <a class="link" href="#groovy:local_variables">局部变量</a></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> &lt;name&gt; = &lt;value&gt;        <span class="comment">// Untyped variable</span>
&lt;type&gt; &lt;name&gt; = &lt;value&gt;     <span class="comment">// Typed variable</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">例子</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> i = <span class="integer">1</span>
<span class="predefined-type">String</span> errorMsg = <span class="string"><span class="delimiter">'</span><span class="content">Failed, because reasons</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>局部变量是Groovy构造（与其他<a href="#sec:extra_properties">属性</a>不同），可用于在构建脚本中共享值。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>避免在项目的根目录中使用局部变量，即作为伪项目属性。无法在构建脚本之外读取它们，并且Gradle不了解它们。</p>
</div>
<div class="paragraph">
<p>在狭窄的环境中（例如配置任务），局部变量有时会有所帮助。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kotlin_dsl"><a class="anchor" href="#kotlin_dsl"></a> <a class="link" href="#kotlin_dsl">Gradle Kotlin DSL入门</a></h3>
<div class="paragraph">
<p>Gradle的Kotlin DSL提供了传统Groovy DSL的替代语法，在受支持的IDE中具有增强的编辑体验，并具有出色的内容辅助，重构，文档等功能。本章详细介绍了Kotlin DSL的主要结构，以及如何使用它与Gradle API进行交互。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果您有兴趣将现有的Gradle版本迁移到Kotlin DSL，也请查看专用的<a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/">迁移指南</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="kotdsl:prerequisites"><a class="anchor" href="#kotdsl:prerequisites"></a> <a class="link" href="#kotdsl:prerequisites">先决条件</a></h4>
<div class="ulist">
<ul>
<li>
<p>嵌入式Kotlin编译器可在x86-64体系结构的Linux，macOS，Windows，Cygwin，FreeBSD和Solaris上运行。</p>
</li>
<li>
<p>了解Kotlin语法和基本语言功能非常有帮助。<a href="https://kotlinlang.org/docs/reference/">Kotlin参考文档</a>和<a href="https://kotlinlang.org/docs/tutorials/koans.html">Kotlin Koans</a>将帮助您学习基础知识。</p>
</li>
<li>
<p>使用<a href="#sec:plugins_block">plugins {}</a>块来声明Gradle插件可以显着改善编辑体验，因此强烈建议使用。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:ide_support"><a class="anchor" href="#sec:ide_support"></a> <a class="link" href="#sec:ide_support">IDE支持</a></h4>
<div class="paragraph">
<p>IntelliJ IDEA和Android Studio完全支持Kotlin DSL。其他IDE尚未提供用于编辑Kotlin DSL文件的有用工具，但是您仍然可以导入基于Kotlin-DSL的构建并照常使用它们。</p>
</div>
<table class="tableblock frame-none grid-rows stretch">
<caption class="title">表19。IDE支持矩阵</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-middle"></th>
<th class="tableblock halign-center valign-middle">构建导入</th>
<th class="tableblock halign-center valign-middle">语法突出显示<sup>1</sup></th>
<th class="tableblock halign-center valign-middle">语义编辑器<sup>2</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-middle"><p class="tableblock">IntelliJ IDEA</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-middle"><p class="tableblock">Android Studio</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-middle"><p class="tableblock">Eclipse IDE</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="red">✖</span></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-middle"><p class="tableblock">里昂</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="red">✖</span></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-middle"><p class="tableblock">Apache NetBeans</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="red">✖</span></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-middle"><p class="tableblock">Visual Studio代码<sup>（LSP）</sup></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="red">✖</span></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-middle"><p class="tableblock">视觉工作室</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="green"><strong>✓</strong></span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="red">✖</span></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><span class="red">✖</span></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><sup>1</sup> <sup>科特林</sup> <sup><sup>语法</sup></sup> <sup>摇篮</sup> <sup>科特林</sup> <sup>DSL</sup> <sup>脚本</sup> <sup>高亮</sup><br>
<sup>2</sup> <sup>代码</sup> <sup>完成，</sup> <sup>导航</sup> <sup><sup>消息</sup>人士透露，</sup> <sup>文档，</sup> <sup>重构</sup> <sup>等等......</sup> <sup>在</sup> <sup>摇篮</sup> <sup>科特林</sup> <sup>DSL</sup> <sup>脚本</sup></p>
</div>
<div class="paragraph">
<p>如限制中所述，您必须<a href="https://www.jetbrains.com/help/idea/gradle.html#gradle_import">从Gradle模型导入项目，</a>以获得IntelliJ IDEA中Kotlin DSL脚本的内容辅助和重构工具。</p>
</div>
<div class="paragraph">
<p>另外，在编辑Gradle脚本时，IntelliJ IDEA和Android Studio可能会产生多达3个Gradle守护程序-每种脚本类型一个：构建脚本，设置文件和初始化脚本。配置时间慢的版本可能会影响IDE的响应速度，因此请查看<a href="https://guides.gradle.org/performance/#configuration">性能指南</a>以帮助解决此类问题。</p>
</div>
<div class="sect4">
<h5 id="automatic_build_import_vs_automatic_reloading_of_script_dependencies"><a class="anchor" href="#automatic_build_import_vs_automatic_reloading_of_script_dependencies"></a> <a class="link" href="#automatic_build_import_vs_automatic_reloading_of_script_dependencies">自动生成导入与自动重新加载脚本依赖项</a></h5>
<div class="paragraph">
<p>IntelliJ IDEA和从IntelliJ IDEA派生的Android Studio都将检测您何时对构建逻辑进行更改，并提供两个建议：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>再次导入整个构建</p>
<div class="imageblock">
<div class="content">
<img src="img/intellij-build-import-popup.png" alt="IntelliJ IDEA" width="300">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/android-studio-build-sync-popup.png" alt="IntelliJ IDEA">
</div>
</div>
</li>
<li>
<p>编辑构建脚本时重新加载脚本依赖项</p>
<div class="imageblock">
<div class="content">
<img src="img/intellij-script-dependencies-reload.png" alt="重新加载脚本依赖项">
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们建议您<em>禁用自动生成导入</em> ，但是<em>启用脚本依赖项的自动重新加载</em> 。这样，您可以在编辑Gradle脚本时获得早期反馈，并控制整个构建设置何时与您的IDE同步。</p>
</div>
</div>
<div class="sect4">
<h5 id="troubleshooting_2"><a class="anchor" href="#troubleshooting_2"></a> <a class="link" href="#troubleshooting_2">故障排除</a></h5>
<div class="paragraph">
<p>IDE支持由两个组件提供：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IntelliJ IDEA / Android Studio使用的Kotlin插件</p>
</li>
<li>
<p>摇篮</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>支持级别取决于每个版本。</p>
</div>
<div class="paragraph">
<p>如果遇到麻烦，应该首先尝试运行<code>./gradlew tasks</code>从命令行查看您的问题是否仅限于IDE。如果您在命令行遇到相同的问题，则问题在于构建而不是IDE集成。</p>
</div>
<div class="paragraph">
<p>如果可以从命令行成功运行构建，但是脚本编辑器在抱怨，则应尝试重新启动IDE并使其缓存无效。</p>
</div>
<div class="paragraph">
<p>如果上述方法不起作用，并且您怀疑Kotlin DSL脚本编辑器存在问题，则可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跑<code>./gradle tasks</code>获得更多细节</p>
</li>
<li>
<p>检查以下位置之一中的日志：</p>
<div class="ulist">
<ul>
<li>
<p><code>$HOME/Library/Logs/gradle-kotlin-dsl</code>在Mac OS X上</p>
</li>
<li>
<p><code>$HOME/.gradle-kotlin-dsl/logs</code>在Linux上</p>
</li>
<li>
<p><code>$HOME/AppData/Local/gradle-kotlin-dsl/log</code>在Windows上</p>
</li>
</ul>
</div>
</li>
<li>
<p>在<a href="https://github.com/gradle/gradle/issues/">Gradle问题追踪器</a>上打开问题，包括尽可能多的详细信息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>从5.1版开始，将自动清除日志目录。定期检查（最多每24小时检查一次），如果7天内未使用日志文件，则将其删除。</p>
</div>
<div class="paragraph">
<p>对于Kotlin DSL脚本编辑器之外的IDE问题，请在相应的IDE的问题跟踪器中打开问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="">JetBrains的IDEA问题跟踪器</a> ，</p>
</li>
<li>
<p><a href="">Google的Android Studio问题跟踪器</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后，如果您遇到Gradle本身或Kotlin DSL的问题，请在<a href="https://github.com/gradle/gradle/issues/">Gradle问题跟踪器</a>上打开问题。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:scripts"><a class="anchor" href="#sec:scripts"></a> <a class="link" href="#sec:scripts">Kotlin DSL脚本</a></h4>
<div class="paragraph">
<p>就像基于Groovy的同类产品一样，Kotlin DSL是在Gradle的Java API之上实现的。您在Kotlin DSL脚本中可以读取的所有内容都是Gradle编译和执行的Kotlin代码。您在构建脚本中使用的许多对象，函数和属性都来自Gradle API和所应用插件的API。</p>
</div>
<div class="sect4">
<h5 id="script_file_names"><a class="anchor" href="#script_file_names"></a> <a class="link" href="#script_file_names">脚本文件名</a></h5>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>Groovy DSL脚本文件使用<code>.gradle</code>文件扩展名。</p>
</div>
<div class="paragraph">
<p>Kotlin DSL脚本文件使用<code>.gradle.kts</code>文件扩展名。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要激活Kotlin DSL，只需使用<code>.gradle.kts</code>您的构建脚本扩展名代替<code>.gradle</code> 。这也适用于<a href="#sec:settings_file">设置文件</a> -例如<code>settings.gradle.kts</code> -和<a href="#init_scripts">初始化脚本</a> 。</p>
</div>
<div class="paragraph">
<p>请注意，您可以将Groovy DSL构建脚本与Kotlin DSL脚本混合使用，即Kotlin DSL构建脚本可以应用一个Groovy DSL，而多项目构建中的每个项目都可以使用其中之一。</p>
</div>
<div class="paragraph">
<p>我们建议您应用以下约定以获得更好的IDE支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>名称设置脚本（或由Gradle支持的任何脚本） <code>Settings</code>对象）根据模式<code>*.settings.gradle.kts</code> —包括从设置脚本中应用的脚本插件</p>
</li>
<li>
<p>根据模式命名<a href="#init_scripts">初始化脚本</a> <code>*.init.gradle.kts</code>或简单地<code>init.gradle.kts</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这样，IDE就能知道是哪种类型的对象“支持”脚本，无论是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html">Project</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.initialization.Settings.html">Settings</a>还是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.invocation.Gradle.html">Gradle</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:implicit_imports"><a class="anchor" href="#sec:implicit_imports"></a> <a class="link" href="#sec:implicit_imports">隐式进口</a></h5>
<div class="paragraph">
<p>所有Kotlin DSL构建脚本均具有隐式导入，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#script-default-imports">默认的Gradle API导入</a></p>
</li>
<li>
<p>Kotlin DSL API，它是<code>org.gradle.kotlin.dsl</code>和<code>org.gradle.kotlin.dsl.plugins.dsl</code>当前包</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="title">避免使用内部Kotlin DSL API</div>
<div class="paragraph">
<p>当Gradle或插件更改时，在插件和构建脚本中使用内部Kotlin DSL API可能会破坏构建。<a href="https://gradle.github.io/kotlin-dsl-docs/api/">Kotlin DSL API</a>使用在<a href="https://gradle.github.io/kotlin-dsl-docs/api/">相应API文档</a>中列出的类型扩展了<a href="#sec:avoiding_gradle_internal_apis">Gradle公共API</a> 。 <code>org.gradle.kotlin.dsl</code>要么<code>org.gradle.kotlin.dsl.plugins.dsl</code>包（但不是这些包的子包）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="type-safe-accessors"><a class="anchor" href="#type-safe-accessors"></a> <a class="link" href="#type-safe-accessors">类型安全的模型访问器</a></h4>
<div class="paragraph">
<p>Groovy DSL允许您按名称引用构建模型的许多元素，即使它们是在运行时定义的也是如此。考虑命名配置，命名源集，等等。例如，您可以掌握<code>implementation</code>通过配置<code>configurations.implementation</code> 。</p>
</div>
<div class="paragraph">
<p>Kotlin DSL用类型安全的模型访问器代替了这种动态解析，该类型访问器可处理由插件贡献的模型元素。</p>
</div>
<div class="sect4">
<h5 id="kotdsl:accessor_applicability"><a class="anchor" href="#kotdsl:accessor_applicability"></a> <a class="link" href="#kotdsl:accessor_applicability">了解何时可以使用类型安全的模型访问器</a></h5>
<div class="paragraph">
<p>Kotlin DSL当前支持由插件贡献的以下任何类型的类型安全模型访问器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依赖性和工件配置（例如<code>implementation</code>和<code>runtimeOnly</code>由Java插件贡献）</p>
</li>
<li>
<p>项目扩展名和约定（例如<code>sourceSets</code> ）</p>
</li>
<li>
<p>中的元素<code>tasks</code>和<code>configurations</code>货柜</p>
</li>
<li>
<p><a href="#kotdsl:containers">项目扩展容器中的</a>元素（例如，由Java插件贡献的源集已添加到<code>sourceSets</code>容器）</p>
</li>
<li>
<p>以上每个方面的扩展</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title">重要</div>
</td>
<td class="content">
<div class="paragraph">
<p>只有主项目构建脚本和预编译的项目脚本插件才具有类型安全的模型访问器。初始化脚本，设置脚本，脚本插件没有。这些限制将在将来的Gradle版本中删除。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在评估脚本主体之前，紧接在脚本主体之后计算可用的类型安全模型访问器的集合。 <code>plugins {}</code>块。此后提供的任何模型元素均不适用于类型安全的模型访问器。例如，这包括您可能在自己的构建脚本中定义的任何配置。但是，这种方法的确意味着您可以对<em>父项目应用的</em>插件贡献的任何模型元素使用类型安全的访问器。</p>
</div>
<div class="paragraph">
<p>以下项目构建脚本演示了如何使用类型安全的访问器访问各种配置，扩展名和其他元素：</p>
</div>
<div class="exampleblock">
<div class="title">示例499使用类型安全的模型访问器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}

dependencies {                              // <b class="conum">(1)</b>
    api(&quot;junit:junit:4.12&quot;)
    implementation(&quot;junit:junit:4.12&quot;)
    testImplementation(&quot;junit:junit:4.12&quot;)
}

configurations {                            // <b class="conum">(1)</b>
    implementation {
        resolutionStrategy.failOnVersionConflict()
    }
}

sourceSets {                                // <b class="conum">(2)</b>
    main {                                  // <b class="conum">(3)</b>
        java.srcDir(&quot;src/core/java&quot;)
    }
}

java {                                      // <b class="conum">(4)</b>
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

tasks {
    test {                                  // <b class="conum">(5)</b>
        testLogging.showExceptions = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用类型安全的访问器<code>api</code> ， <code>implementation</code>和<code>testImplementation</code> <a href="#java_library_plugin">Java库插件</a>贡献的依赖项配置</p>
</li>
<li>
<p>使用访问器来配置<code>sourceSets</code>项目扩展</p>
</li>
<li>
<p>使用访问器来配置<code>main</code>源集</p>
</li>
<li>
<p>使用访问器来配置<code>java</code>的来源<code>main</code>源集</p>
</li>
<li>
<p>使用访问器来配置<code>test</code>任务</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>您的IDE知道类型安全访问器，因此它将在建议中包括它们。这将同时在构建脚本的顶层发生-大多数插件扩展都添加到了<code>Project</code>对象-在配置扩展的块内。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，容器元素的访问器，例如<code>configurations</code> ， <code>tasks</code>和<code>sourceSets</code>利用Gradle的<a href="#lazy_configuration">配置避免API</a> 。例如，在<code>tasks</code>他们是类型<code>TaskProvider<T></code>并提供基础任务的惰性参考和惰性配置。以下是一些示例，这些示例说明了避免配置的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    // lazy configuration
}

// Lazy reference
val testProvider: TaskProvider&lt;Test&gt; = tasks.test

testProvider {
    // lazy configuration
}

// Eagerly realized Test task, defeat configuration avoidance if done out of a lazy context
val test: Test = tasks.test.get()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于除以下以外的所有其他容器<code>tasks</code> ，元素的访问器类型<code>NamedDomainObjectProvider<T></code>并提供相同的行为。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:kotlin_using_standard_api"><a class="anchor" href="#sec:kotlin_using_standard_api"></a> <a class="link" href="#sec:kotlin_using_standard_api">了解类型安全模型访问器不可用时的处理方法</a></h5>
<div class="paragraph">
<p>考虑上面显示的样本构建脚本，该脚本演示了类型安全访问器的用法。以下示例完全相同，只是使用了<code>apply()</code>应用插件的方法。在这种情况下，构建脚本不能使用类型安全的访问器，因为<code>apply()</code>调用发生在构建脚本的主体中。您必须改用其他技术，如此处所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例500配置没有类型安全访问器的插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(plugin = &quot;java-library&quot;)

dependencies {
    &quot;api&quot;(&quot;junit:junit:4.12&quot;)
    &quot;implementation&quot;(&quot;junit:junit:4.12&quot;)
    &quot;testImplementation&quot;(&quot;junit:junit:4.12&quot;)
}

configurations {
    &quot;implementation&quot; {
        resolutionStrategy.failOnVersionConflict()
    }
}

configure&lt;SourceSetContainer&gt; {
    named(&quot;main&quot;) {
        java.srcDir(&quot;src/core/java&quot;)
    }
}

configure&lt;JavaPluginConvention&gt; {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

tasks {
    named&lt;Test&gt;(&quot;test&quot;) {
        testLogging.showExceptions = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>类型安全的访问器不适用于以下因素造成的模型元素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过<code>apply(plugin = "id")</code>方法</p>
</li>
<li>
<p>项目构建脚本</p>
</li>
<li>
<p>脚本插件，通过<code>apply(from = "script-plugin.gradle.kts")</code></p>
</li>
<li>
<p>通过<a href="#sec:kotlin_cross_project_configuration">跨项目配置</a>应用的插件</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还不能在Kotlin中实现的Binary Gradle插件中使用类型安全访问器。</p>
</div>
<div class="paragraph">
<p>如果找不到类型安全的访问器，请<em>退回对</em>相应类型<em>使用常规API</em> 。为此，您需要知道已配置模型元素的名称和/或类型。现在，我们将向您展示如何通过仔细查看上述脚本来发现这些内容。</p>
</div>
<div class="sect5">
<h6 id="artifact_configurations"><a class="anchor" href="#artifact_configurations"></a> <a class="link" href="#artifact_configurations">工件配置</a></h6>
<div class="paragraph">
<p>以下样本演示了如何在没有类型访问器的情况下引用和配置工件配置：</p>
</div>
<div class="exampleblock">
<div class="title">例子501。工件配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(plugin = &quot;java-library&quot;)

dependencies {
    &quot;api&quot;(&quot;junit:junit:4.12&quot;)
    &quot;implementation&quot;(&quot;junit:junit:4.12&quot;)
    &quot;testImplementation&quot;(&quot;junit:junit:4.12&quot;)
}

configurations {
    &quot;implementation&quot; {
        resolutionStrategy.failOnVersionConflict()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该代码看起来与类型安全访问器的代码相似，但在这种情况下，配置名称是字符串文字。您可以在依赖项声明中以及内部使用字符串文字作为配置名称。 <code>configurations {}</code>块。</p>
</div>
<div class="paragraph">
<p>在这种情况下，IDE将无法帮助您发现可用的配置，但是您可以在相应插件的文档中找到它们，也可以通过运行<code>gradle dependencies</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="project_extensions_and_conventions"><a class="anchor" href="#project_extensions_and_conventions"></a> <a class="link" href="#project_extensions_and_conventions">项目扩展名和约定</a></h6>
<div class="paragraph">
<p>项目扩展名和<a href="#sec:kotlin_dsl_about_conventions">约定</a>都具有名称和唯一类型，但是Kotlin DSL只需要知道类型即可进行配置。如以下示例所示<code>sourceSets {}</code>和<code>java {}</code>原始示例构建脚本中的块，您可以使用<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/org.gradle.api.-project/configure.html"><code>configure<T>()</code></a>具有相应类型的函数可以做到这一点：</p>
</div>
<div class="exampleblock">
<div class="title">示例502项目扩展名和约定</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(plugin = &quot;java-library&quot;)

configure&lt;SourceSetContainer&gt; {
    named(&quot;main&quot;) {
        java.srcDir(&quot;src/core/java&quot;)
    }
}

configure&lt;JavaPluginConvention&gt; {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意<code>sourceSets</code>是Gradle的扩展<code>Project</code>类型的<code>SourceSetContainer</code>和<code>java</code>是对的扩展<code>Project</code>类型的<code>JavaPluginExtension</code> 。</p>
</div>
<div class="paragraph">
<p>您可以通过查看所应用插件的文档或通过运行来发现可用的扩展名和约定。 <code>gradle kotlinDslAccessorsReport</code> ，它会打印访问所有已应用插件贡献的模型元素所需的Kotlin代码。该报告提供名称和类型。作为最后的选择，您还可以检查插件的源代码，但是在大多数情况下，这不是必需的。</p>
</div>
<div class="paragraph">
<p>请注意，您也可以使用<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/org.gradle.api.-project/the.html"><code>the<T>()</code></a>如果您只需要对扩展名或约定的引用而不进行配置，或者想要执行单行配置，则可以使用该函数，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">the&lt;SourceSetContainer&gt;()[&quot;main&quot;].srcDir(&quot;src/core/java&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码段还演示了一种配置作为容器的项目扩展的元素的方法。</p>
</div>
</div>
<div class="sect5">
<h6 id="elements_in_project_extension_containers"><a class="anchor" href="#elements_in_project_extension_containers"></a> <a class="link" href="#elements_in_project_extension_containers">项目扩展容器中的元素</a></h6>
<div class="paragraph">
<p>基于容器的项目扩展，例如<code>SourceSetContainer</code> ，还允许您配置它们所包含的元素。在我们的示例构建脚本中，我们要配置一个名为<code>main</code>在源集容器中，我们可以通过使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/NamedDomainObjectCollection.html#named-java.lang.String-">named（）</a>方法代替访问器来进行操作，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子503。作为容器的项目扩展的元素</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(plugin = &quot;java-library&quot;)

configure&lt;SourceSetContainer&gt; {
    named(&quot;main&quot;) {
        java.srcDir(&quot;src/core/java&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>基于容器的项目扩展中的所有元素都有一个名称，因此您可以在所有这种情况下使用此技术。</p>
</div>
<div class="paragraph">
<p>至于项目扩展和约定本身，您可以通过查看所应用插件的文档或通过运行来发现任何容器中存在哪些元素。 <code>gradle kotlinDslAccessorsReport</code> 。最后，您也许可以查看插件的源代码以了解其功能，但是在大多数情况下，这不是必需的。</p>
</div>
</div>
<div class="sect5">
<h6 id="tasks"><a class="anchor" href="#tasks"></a> <a class="link" href="#tasks">任务</a></h6>
<div class="paragraph">
<p>任务不是通过基于容器的项目扩展来管理的，但是它们是行为类似的容器的一部分。这意味着您可以按照与源集相同的方式配置任务，如本例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例504。任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">apply(plugin = &quot;java-library&quot;)

tasks {
    named&lt;Test&gt;(&quot;test&quot;) {
        testLogging.showExceptions = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们使用Gradle API通过名称和类型来引用任务，而不是使用访问器。请注意，有必要明确指定任务的类型，否则脚本将无法编译，因为推断的类型将是<code>Task</code> ，不是<code>Test</code>和<code>testLogging</code>属性是特定于<code>Test</code>任务类型。但是，如果您只需要配置属性或调用所有任务通用的方法，即可以在类型上声明它们，则可以省略类型。 <code>Task</code>接口。</p>
</div>
<div class="paragraph">
<p>通过运行可以发现哪些任务可用<code>gradle tasks</code> 。然后，您可以通过运行以下命令找出给定任务的类型<code>gradle help --task <taskName></code> ，如此处所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>❯ ./gradlew help --task test
...
Type
     Test (org.gradle.api.tasks.testing.Test)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，IDE可以帮助您进行所需的导入，因此您只需要类型的简单名称，即不需要包名称部分。在这种情况下，无需导入<code>Test</code>任务类型，因为它是Gradle API的一部分，因此被<a href="#sec:implicit_imports">隐式导入</a> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:kotlin_dsl_about_conventions"><a class="anchor" href="#sec:kotlin_dsl_about_conventions"></a> <a class="link" href="#sec:kotlin_dsl_about_conventions">关于约定</a></h5>
<div class="paragraph">
<p>一些Gradle核心插件借助所谓的<em>Conventional</em>对象公开了可配置性。它们具有与<em>扩展</em>类似的用途，并且现在已被<em>扩展</em>取代。编写新插件时，请避免使用约定对象。长期计划是迁移所有Gradle核心插件以使用扩展并完全删除约定对象。</p>
</div>
<div class="paragraph">
<p>如上所示，Kotlin DSL仅在以下情况下为约定对象提供访问器： <code>Project</code> 。在某些情况下，您需要与使用其他类型约定对象的Gradle插件进行交互。Kotlin DSL提供了<code>withConvention(T::class) {}</code>扩展功能可以做到这一点：</p>
</div>
<div class="exampleblock">
<div class="title">示例505配置源集约定</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    groovy
}

sourceSets {
    main {
        withConvention(GroovySourceSet::class) {
            groovy.srcDir(&quot;src/core/groovy&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于由Java插件以外的其他语言插件（例如Groovy插件和Scala插件）添加的源集，最通常需要此技术。您可以在<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSet.html">SourceSet</a>参考文档中查看哪些插件为源集添加了哪些属性。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:multi_project_builds"><a class="anchor" href="#sec:multi_project_builds"></a> <a class="link" href="#sec:multi_project_builds">多项目构建</a></h4>
<div class="paragraph">
<p>与单项目构建一样，您应尝试使用<code>plugins {}</code>阻止多项目构建中的内容，以便您可以使用类型安全的访问器。多项目构建的另一个考虑因素是，在根构建脚本中配置子项目或在项目之间使用其他形式的交叉配置时，您将无法使用类型安全的访问器。在以下各节中，我们将更详细地讨论这两个主题。</p>
</div>
<div class="sect4">
<h5 id="sec:multi_project_builds_applying_plugins"><a class="anchor" href="#sec:multi_project_builds_applying_plugins"></a> <a class="link" href="#sec:multi_project_builds_applying_plugins">应用插件</a></h5>
<div class="paragraph">
<p>您可以在应用插件的子项目中声明您的插件，但是我们建议您也在根项目构建脚本中声明它们。这样可以更轻松地使构建版本中各个项目的插件版本保持一致。该方法还提高了构建的性能。</p>
</div>
<div class="paragraph">
<p>“ <a href="#sec:subprojects_plugins_dsl">使用Gradle插件”</a>一章介绍了如何在带有版本的根项目构建脚本中声明插件，然后将其应用于适当的子项目的构建脚本。以下是使用三个子项目和三个插件的这种方法的示例。请注意，由于Java库插件与您使用的Gradle版本相关，因此根构建脚本仅声明社区插件。</p>
</div>
<div id="ex:multi_project_ratpack" class="exampleblock">
<div class="title">例子506。使用以下命令在根构建脚本中声明插件依赖性<code>plugins {}</code>块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;multi-project-build&quot;
include(&quot;domain&quot;, &quot;infra&quot;, &quot;http&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;com.github.johnrengelman.shadow&quot;) version &quot;4.0.1&quot; apply false
    id(&quot;io.ratpack.ratpack-java&quot;) version &quot;1.5.4&quot; apply false
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">域/build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}

dependencies {
    api(&quot;javax.measure:unit-api:1.0&quot;)
    implementation(&quot;tec.units:unit-ri:1.0.3&quot;)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">infra / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
    id(&quot;com.github.johnrengelman.shadow&quot;)
}

shadow {
    applicationDistribution.from(&quot;src/dist&quot;)
}

tasks.shadowJar {
    minimize()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">http / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
    id(&quot;io.ratpack.ratpack-java&quot;)
}

dependencies {
    implementation(project(&quot;:domain&quot;))
    implementation(project(&quot;:infra&quot;))
    implementation(ratpack.dependency(&quot;dropwizard-metrics&quot;))
}

application {
    mainClassName = &quot;example.App&quot;
}

ratpack.baseDir = file(&quot;src/ratpack/baseDir&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您的版本在Gradle Plugin Portal顶部需要其他插件存储库，则应在<code>pluginManagement {}</code>封锁你的<code>settings.gradle.kts</code>文件，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例507。声明其他插件存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">pluginManagement {
    repositories {
        jcenter()
        gradlePluginPortal()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从<a href="https://plugins.gradle.org/">Gradle插件门户网站</a>以外的其他来源获取的<a href="https://plugins.gradle.org/">插件</a>只能通过<code>plugins {}</code>如果它们与<a href="#sec:plugin_markers">插件标记工件</a>一起发布，则阻止。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">在撰写本文时，所有适用于Gradle的Android插件3.2.0之前的版本<code>google()</code>存储库缺少插件标记工件。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果缺少这些工件，则不能使用<code>plugins {}</code>块。您必须改为使用来声明插件依赖性<code>buildscript {}</code>阻止根项目构建脚本。这是为Android插件执行此操作的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例508使用以下命令在根构建脚本中声明插件依赖性<code>buildscript {}</code>块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">include(&quot;lib&quot;, &quot;app&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">buildscript {
    repositories {
        google()
        gradlePluginPortal()
    }
    dependencies {
        classpath(&quot;com.android.tools.build:gradle:3.2.0&quot;)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">lib / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;com.android.library&quot;)
}

android {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">app / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;com.android.application&quot;)
}

android {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该技术与创建新版本时Android Studio产生的技术没有什么不同。主要区别在于上述示例中子项目的构建脚本使用来声明其插件。 <code>plugins {}</code>块。这意味着您可以为它们贡献的模型元素使用类型安全的访问器。</p>
</div>
<div class="paragraph">
<p>请注意，如果要将这样的插件应用于多项目构建的根项目构建脚本（而不是仅应用于其子项目）或单项目构建，则不能使用此技术。在我们将在<a href="#sec:plugins_resolution_strategy">另一部分</a>详细介绍的情况下，您将需要使用其他方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:kotlin_cross_project_configuration"><a class="anchor" href="#sec:kotlin_cross_project_configuration"></a> <a class="link" href="#sec:kotlin_cross_project_configuration">交叉配置项目</a></h5>
<div class="paragraph">
<p><a href="#sec:cross_project_configuration">跨项目配置</a>是一种机制，通过该机制可以从另一个项目的构建脚本中配置一个项目。一个常见的示例是在根项目构建脚本中配置子项目时。</p>
</div>
<div class="paragraph">
<p>采用这种方法意味着您将无法对插件贡献的模型元素使用类型安全的访问器。相反，您将不得不依赖字符串文字和标准的Gradle API。</p>
</div>
<div class="paragraph">
<p>作为示例，让我们修改<a href="#ex:multi_project_ratpack">Java / Ratpack示例构建，</a>以从根项目构建脚本中完全配置其子项目：</p>
</div>
<div class="exampleblock">
<div class="title">示例509交叉配置项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">rootProject.name = &quot;multi-project-build&quot;
include(&quot;domain&quot;, &quot;infra&quot;, &quot;http&quot;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import com.github.jengelman.gradle.plugins.shadow.ShadowExtension
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import ratpack.gradle.RatpackExtension

plugins {
    id(&quot;com.github.johnrengelman.shadow&quot;) version &quot;4.0.1&quot; apply false
    id(&quot;io.ratpack.ratpack-java&quot;) version &quot;1.5.4&quot; apply false
}

project(&quot;:domain&quot;) {
    apply(plugin = &quot;java-library&quot;)
    dependencies {
        &quot;api&quot;(&quot;javax.measure:unit-api:1.0&quot;)
        &quot;implementation&quot;(&quot;tec.units:unit-ri:1.0.3&quot;)
    }
}

project(&quot;:infra&quot;) {
    apply(plugin = &quot;java-library&quot;)
    apply(plugin = &quot;com.github.johnrengelman.shadow&quot;)
    configure&lt;ShadowExtension&gt; {
        applicationDistribution.from(&quot;src/dist&quot;)
    }
    tasks.named&lt;ShadowJar&gt;(&quot;shadowJar&quot;) {
        minimize()
    }
}

project(&quot;:http&quot;) {
    apply(plugin = &quot;java&quot;)
    apply(plugin = &quot;io.ratpack.ratpack-java&quot;)
    val ratpack = the&lt;RatpackExtension&gt;()
    dependencies {
        &quot;implementation&quot;(project(&quot;:domain&quot;))
        &quot;implementation&quot;(project(&quot;:infra&quot;))
        &quot;implementation&quot;(ratpack.dependency(&quot;dropwizard-metrics&quot;))
        &quot;runtimeOnly&quot;(&quot;org.slf4j:slf4j-simple:1.7.25&quot;)
    }
    configure&lt;ApplicationPluginConvention&gt; {
        mainClassName = &quot;example.App&quot;
    }
    ratpack.baseDir = file(&quot;src/ratpack/baseDir&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意我们如何使用<code>apply()</code>自从开始以来应用插件的方法<code>plugins {}</code>封锁在这种情况下不起作用。我们还使用标准API代替类型安全的访问器来配置任务，扩展名和约定-我们已在<a href="#sec:kotlin_using_standard_api">其他地方更详细地</a>讨论了这种方法。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:plugins_resolution_strategy"><a class="anchor" href="#sec:plugins_resolution_strategy"></a> <a class="link" href="#sec:plugins_resolution_strategy">当您无法使用<code>plugins {}</code>块</a></h4>
<div class="paragraph">
<p>从<a href="https://plugins.gradle.org/">Gradle插件门户网站</a>以外的其他来源获取的<a href="https://plugins.gradle.org/">插件</a>可能会或可能无法用于<code>plugins {}</code>块。这取决于它们的发布方式，尤其取决于它们是否已使用必要的<a href="#sec:plugin_markers">插件标记工件发布</a> 。</p>
</div>
<div class="paragraph">
<p>例如，未将Gradle的Android插件发布到Gradle插件门户，并且-至少在该插件的3.2.0版之前-解决给定插件标识符的工件所需的元数据没有发布到Google存储库。</p>
</div>
<div class="paragraph">
<p>如果您的构建是一个多项目构建和你不需要这样的插件应用到您的<em>根</em>项目，然后您可以利用该技术克服这个问题， <a href="#sec:multi_project_builds_applying_plugins">如上所述</a> 。对于其他情况，请继续阅读。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>发布插件时，请使用Gradle内置的<a href="#java_gradle_plugin">Gradle插件开发插件</a> 。它会自动发布必要的元数据，以使您的插件可用于<code>plugins {}</code>块。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们将在本节中向您展示如何将Android插件应用于单项目构建或多项目构建的根项目。目的是指导您如何构建地图<code>com.android.application</code>可解决工件的插件标识符。这分两个步骤完成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将插件存储库添加到构建的设置脚本</p>
</li>
<li>
<p>将插件ID映射到相应的工件坐标</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过配置一个<code>pluginManagement {}</code>阻止构建的设置脚本。为了演示，以下示例添加了<code>google()</code>存储库-将Android插件发布到的存储库-到存储库搜索列表，并使用<code>resolutionStrategy {}</code>块来映射<code>com.android.application</code>的插件ID <code>com.android.tools.build:gradle:<version></code>可用的工件<code>google()</code>资料库：</p>
</div>
<div class="exampleblock">
<div class="title">示例510将插件ID映射到依赖项坐标</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">pluginManagement {
    repositories {
        google()
        gradlePluginPortal()
    }
    resolutionStrategy {
        eachPlugin {
            if(requested.id.namespace == &quot;com.android&quot;) {
                useModule(&quot;com.android.tools.build:gradle:${requested.version}&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;com.android.application&quot;) version &quot;3.2.0&quot;
}

android {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实际上，以上示例将适用于所有<code>com.android.*</code>指定模块提供的插件。这是因为打包的模块使用“ <a href="#sec:custom_plugins_standalone_project">编写自定义插件”</a>一章中描述的属性文件机制包含了哪些插件ID映射到哪个插件实现类的详细信息。</p>
</div>
<div class="paragraph">
<p>有关以下内容的更多信息，请参见Gradle用户手册的“ <a href="#sec:plugin_management">插件管理”</a>部分。 <code>pluginManagement {}</code>块及其用途。</p>
</div>
</div>
<div class="sect3">
<h4 id="kotdsl:containers"><a class="anchor" href="#kotdsl:containers"></a> <a class="link" href="#kotdsl:containers">使用容器对象</a></h4>
<div class="paragraph">
<p>Gradle构建模型大量使用了容器对象（或只是“容器”）。例如，两者<code>configurations</code>和<code>tasks</code>是包含以下内容的容器对象<code>Configuration</code>和<code>Task</code>对象。社区插件还提供了容器，例如<code>android.buildTypes</code>容器由Android插件贡献。</p>
</div>
<div class="paragraph">
<p>Kotlin DSL为构建作者与容器交互提供了几种方法。接下来，我们将使用<code>tasks</code>以容器为例。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，如果要在支持的容器上配置现有元素，则可以利用<a href="#kotdsl:accessor_applicability">另一节中</a>描述的类型安全访问器。该部分还描述了哪些容器支持类型安全的访问器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="using_the_container_api"><a class="anchor" href="#using_the_container_api"></a> <a class="link" href="#using_the_container_api">使用容器API</a></h5>
<div class="paragraph">
<p>Gradle中的所有容器都实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.NamedDomainObjectContainer.html#org.gradle.api.NamedDomainObjectContainer">NamedDomainObjectContainer <domainobjecttype></domainobjecttype></a> 。其中一些可以包含不同类型的对象并实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.PolymorphicDomainObjectContainer.html#org.gradle.api.PolymorphicDomainObjectContainer">PolymorphicDomainObjectContainer <basetype></basetype></a> 。与容器交互的最简单方法是通过这些接口。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.NamedDomainObjectContainer.html#org.gradle.api.NamedDomainObjectContainer:named(java.lang.String)">named（）</a>方法配置现有任务，并使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.NamedDomainObjectContainer.html#org.gradle.api.NamedDomainObjectContainer:register(java.lang.String)">register（）</a>方法创建新任务。</p>
</div>
<div class="exampleblock">
<div class="title">示例511。使用容器API</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named(&quot;check&quot;)                    // <b class="conum">(1)</b>
tasks.register(&quot;myTask1&quot;)               // <b class="conum">(2)</b>

tasks.named&lt;JavaCompile&gt;(&quot;compileJava&quot;) // <b class="conum">(3)</b>
tasks.register&lt;Copy&gt;(&quot;myCopy1&quot;)         // <b class="conum">(4)</b>

tasks.named(&quot;assemble&quot;) {               // <b class="conum">(5)</b>
    dependsOn(&quot;:myTask1&quot;)
}
tasks.register(&quot;myTask2&quot;) {             // <b class="conum">(6)</b>
    description = &quot;Some meaningful words&quot;
}

tasks.named&lt;Test&gt;(&quot;test&quot;) {             // <b class="conum">(7)</b>
    testLogging.showStackTraces = true
}
tasks.register&lt;Copy&gt;(&quot;myCopy2&quot;) {       // <b class="conum">(8)</b>
    from(&quot;source&quot;)
    into(&quot;destination&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>获取类型的引用<code>Task</code>到已命名的现有任务<code>check</code></p>
</li>
<li>
<p>注册一个新的无类型任务，名为<code>myTask1</code></p>
</li>
<li>
<p>获取对名为的现有任务的引用<code>compileJava</code>类型的<code>JavaCompile</code></p>
</li>
<li>
<p>注册名为的新任务<code>myCopy1</code>类型的<code>Copy</code></p>
</li>
<li>
<p>获取对名为的现有（无类型）任务的引用<code>assemble</code>并配置它-您只能配置以下属性和方法<code>Task</code>使用这种语法</p>
</li>
<li>
<p>注册一个新的无类型任务，名为<code>myTask2</code>并配置它-您只能配置以下属性和方法<code>Task</code>在这种情况下</p>
</li>
<li>
<p>获取对名为的现有任务的引用<code>test</code>类型的<code>Test</code>并配置它-在这种情况下，您可以访问指定类型的属性和方法</p>
</li>
<li>
<p>注册名为的新任务<code>myCopy2</code>类型的<code>Copy</code>并配置它</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>上面的示例依赖于配置避免API。如果您需要或想急于配置或注册容器元素，只需更换<code>named()</code>与<code>getByName()</code>和<code>register()</code>与<code>create()</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="using_kotlin_delegated_properties"><a class="anchor" href="#using_kotlin_delegated_properties"></a> <a class="link" href="#using_kotlin_delegated_properties">使用Kotlin委托的属性</a></h5>
<div class="paragraph">
<p>与容器交互的另一种方法是通过Kotlin委托的属性。如果您需要引用可在构建中其他位置使用的容器元素，则这些选项特别有用。此外，可以通过IDE重构轻松重命名Kotlin委托的属性。</p>
</div>
<div class="paragraph">
<p>下面的示例执行与上一节完全相同的操作，但是它使用委托的属性并重用这些引用代替字符串字面的任务路径：</p>
</div>
<div class="exampleblock">
<div class="title">示例512使用Kotlin委托的属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val check by tasks.existing
val myTask1 by tasks.registering

val compileJava by tasks.existing(JavaCompile::class)
val myCopy1 by tasks.registering(Copy::class)

val assemble by tasks.existing {
    dependsOn(myTask1)  // <b class="conum">(1)</b>
}
val myTask2 by tasks.registering {
    description = &quot;Some meaningful words&quot;
}

val test by tasks.existing(Test::class) {
    testLogging.showStackTraces = true
}
val myCopy2 by tasks.registering(Copy::class) {
    from(&quot;source&quot;)
    into(&quot;destination&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使用对<code>myTask1</code>任务而不是任务路径</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>以上依赖于配置避免API。如果您需要配置或注册容器元素，只需更换<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/org.gradle.api.-named-domain-object-container/existing.html"><code>existing()</code></a>与<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/org.gradle.api.-named-domain-object-container/getting.html"><code>getting()</code></a>和<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/org.gradle.api.-named-domain-object-container/registering.html"><code>registering()</code></a>与<a href="https://gradle.github.io/kotlin-dsl-docs/api/org.gradle.kotlin.dsl/org.gradle.api.-named-domain-object-container/creating.html"><code>creating()</code></a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="configuring_multiple_container_elements_together"><a class="anchor" href="#configuring_multiple_container_elements_together"></a> <a class="link" href="#configuring_multiple_container_elements_together">一起配置多个容器元素</a></h5>
<div class="paragraph">
<p>在配置容器的多个元素时，可以将交互分组在一个块中，以避免在每次交互时重复容器的名称。以下示例结合使用类型安全访问器，容器API和Kotlin委托属性：</p>
</div>
<div class="exampleblock">
<div class="title">例子513。容器范围</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks {
    test {
        testLogging.showStackTraces = true
    }
    val myCheck by registering {
        doLast { /* assert on something meaningful */ }
    }
    check {
        dependsOn(myCheck)
    }
    register(&quot;myHelp&quot;) {
        doLast { /* do something helpful */ }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotdsl:properties"><a class="anchor" href="#kotdsl:properties"></a> <a class="link" href="#kotdsl:properties">使用运行时属性</a></h4>
<div class="paragraph">
<p>Gradle在运行时定义了两个主要的属性来源： <a href="#sec:project_properties"><em>项目属性</em></a>和<a href="#sec:extra_properties"><em>Extra属性</em></a> 。Kotlin DSL提供了使用这些类型的属性的特定语法，我们将在以下部分中进行介绍。</p>
</div>
<div class="sect4">
<h5 id="project_properties"><a class="anchor" href="#project_properties"></a> <a class="link" href="#project_properties">项目性质</a></h5>
<div class="paragraph">
<p>Kotlin DSL允许您通过Kotlin委托属性绑定项目属性来访问它们。这是一个示例片段，演示了几个项目属性的技术， <em>必须</em>定义其中一个：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val myProperty: String by project  // <b class="conum">(1)</b>
val myNullableProperty: String? by project // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>使<code>myProperty</code>项目属性可通过<code>myProperty</code>委托的属性-在这种情况下，项目属性必须存在，否则当构建脚本尝试使用<code>myProperty</code>值</p>
</li>
<li>
<p>相同的<code>myNullableProperty</code>项目属性，但使用不会失败<code>myNullableProperty</code>只要您检查是否为空，就使用该值（适用<a href="https://kotlinlang.org/docs/reference/null-safety.html">于安全性的</a>标准<a href="https://kotlinlang.org/docs/reference/null-safety.html">Kotlin规则</a> ）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>相同的方法在设置脚本和初始化脚本中均有效，除了您使用<code>by settings</code>和<code>by gradle</code>分别代替<code>by project</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="extra_properties"><a class="anchor" href="#extra_properties"></a> <a class="link" href="#extra_properties">额外的属性</a></h5>
<div class="paragraph">
<p>在实现<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.ExtensionAware.html#org.gradle.api.plugins.ExtensionAware">ExtensionAware</a>接口的任何对象上都可以使用其他属性。Kotlin DSL允许您使用以下任何一种来访问额外的属性并通过委托的属性创建新的属性<code>by extra</code>以下示例中演示的表格：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val myNewProperty by extra(&quot;initial value&quot;)  // <b class="conum">(1)</b>
val myOtherNewProperty by extra { &quot;calculated initial value&quot; }  // <b class="conum">(2)</b>

val myProperty: String by extra  // <b class="conum">(3)</b>
val myNullableProperty: String? by extra  // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建一个新的额外属性，称为<code>myNewProperty</code>在当前上下文（本例中为项目）中，并使用值对其进行初始化<code>"initial value"</code> ，这也决定了属性的<em>类型</em></p>
</li>
<li>
<p>创建一个新的额外属性，其初始值由提供的lambda计算</p>
</li>
<li>
<p>将当前上下文（在本例中为项目）中现有的额外属性绑定到<code>myProperty</code>参考</p>
</li>
<li>
<p>与上一行相同，但允许属性具有空值</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>该方法适用于所有Gradle脚本：项目构建脚本，脚本插件，设置脚本和初始化脚本。</p>
</div>
<div class="paragraph">
<p>您还可以使用以下语法从子项目访问根项目的其他属性：</p>
</div>
<div class="listingblock">
<div class="title">my-sub-project / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val myNewProperty: String by rootProject.extra  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>绑定根项目的<code>myNewProperty</code>具有相同名称引用的额外属性</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>额外的属性不仅限于项目。例如， <code>Task</code>延伸<code>ExtensionAware</code> ，因此您也可以将额外的属性附加到任务。这是一个定义新<code>myNewTaskProperty</code>在<code>test</code>任务，然后使用该属性初始化另一个任务：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks {
    test {
        val reportType by extra(&quot;dev&quot;)  // <b class="conum">(1)</b>
        doLast {
            // Use 'suffix' for post processing of reports
        }
    }

    register&lt;Zip&gt;(&quot;archiveTestReports&quot;) {
        val reportType: String by test.get().extra  // <b class="conum">(2)</b>
        archiveAppendix.set(reportType)
        from(test.get().reports.html.destination)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建一个新的<code>reportType</code>的额外财产<code>test</code>任务</p>
</li>
<li>
<p>使<code>test</code>任务<code>reportType</code>额外的属性可用于配置<code>archiveTestReports</code>任务</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果您很乐意使用紧急配置而不是配置回避API，则可以对报告类型使用单个“全局”属性，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test.doLast { ... }

val testReportType by tasks.test.get().extra(&quot;dev&quot;)  // <b class="conum">(1)</b>

tasks.create&lt;Zip&gt;(&quot;archiveTestReports&quot;) {
    archiveAppendix.set(testReportType)  // <b class="conum">(2)</b>
    from(test.get().reports.html.destination)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>在上创建并初始化一个额外的属性<code>test</code>任务，将其绑定到“全局”属性</p>
</li>
<li>
<p>使用“全局”属性初始化<code>archiveTestReports</code>任务</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们应该涵盖额外属性的最后一种语法，即<code>extra</code>作为地图。我们建议您不要使用此功能，因为这样会失去Kotlin的类型检查的好处，并且会阻止IDE提供尽可能多的支持。但是，它比委派属性语法更简洁，如果您只需要设置额外属性的值而无需稍后引用，则可以合理地使用它。</p>
</div>
<div class="paragraph">
<p>这是一个简单的示例，演示如何使用map语法设置和读取额外的属性：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">extra[&quot;myNewProperty&quot;] = &quot;initial value&quot;  // <b class="conum">(1)</b>

tasks.create(&quot;myTask&quot;) {
    doLast {
        println(&quot;Property: ${project.extra[&quot;myNewProperty&quot;]}&quot;)  // <b class="conum">(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建一个新项目，额外的属性称为<code>myNewProperty</code>并设置其值</p>
</li>
<li>
<p>从我们创建的项目额外属性中读取值-请注意<code>project.</code>预选赛<code>extra[…​]</code> ，否则Gradle会假设我们想从<em>任务中</em>读取额外的属性</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:kotlin-dsl_plugin"><a class="anchor" href="#sec:kotlin-dsl_plugin"></a> <a class="link" href="#sec:kotlin-dsl_plugin">Kotlin DSL插件</a></h4>
<div class="paragraph">
<p>Kotlin DSL插件提供了一种方便的方法来开发基于Kotlin的项目，这些项目有助于构建逻辑。其中包括<a href="#sec:build_sources">buildSrc项目</a> ， <a href="#">包括内部版本</a>和<a href="https://guides.gradle.org/designing-gradle-plugins/">Gradle插件</a> 。</p>
</div>
<div class="paragraph">
<p>该插件通过执行以下操作来实现此目的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>应用<a href="https://kotlinlang.org/docs/reference/using-gradle.html#targeting-the-jvm">Kotlin插件</a> ，该<a href="https://kotlinlang.org/docs/reference/using-gradle.html#targeting-the-jvm">插件</a>增加了对编译Kotlin源文件的支持。</p>
</li>
<li>
<p>添加<code>kotlin-stdlib-jdk8</code> ， <code>kotlin-reflect</code>和<code>gradleKotlinDsl()</code>对的依赖<code>compileOnly</code>和<code>testImplementation</code>配置，可让您在Kotlin代码中使用那些Kotlin库和Gradle API。</p>
</li>
<li>
<p>使用与Kotlin DSL脚本相同的设置来配置Kotlin编译器，以确保构建逻辑和这些脚本之间的一致性。</p>
</li>
<li>
<p>启用对<a href="#kotdsl:precompiled_plugins">预编译脚本插件的</a>支持。</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="title">避免为版本指定版本<code>kotlin-dsl</code>插入</div>
<div class="paragraph">
<p>每个Gradle版本都旨在与特定版本的<code>kotlin-dsl</code>插件和任意Gradle版本之间的兼容性以及<code>kotlin-dsl</code>不保证插件版本。使用意外版本的<code>kotlin-dsl</code>构建中的插件将发出警告，并可能导致难以诊断的问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是使用插件所需的基本配置：</p>
</div>
<div class="exampleblock">
<div class="title">示例514将Kotlin DSL插件应用于<code>buildSrc</code>项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `kotlin-dsl`
}

repositories {
    // The org.jetbrains.kotlin.jvm plugin requires a repository
    // where to download the Kotlin compiler dependencies from.
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，Kotlin DSL插件会启用实验性Kotlin编译器功能。有关更多信息，请参见下面的<a href="#sec:kotlin_compiler_arguments">Kotlin编译器参数</a>部分。</p>
</div>
<div class="paragraph">
<p>默认情况下，该插件会警告您使用Kotlin编译器的实验功能。您可以通过设置<code>experimentalWarning</code>的属性<code>kotlinDslPluginOptions</code>扩展到<code>false</code>如下：</p>
</div>
<div class="exampleblock">
<div class="title">示例515禁用有关使用实验性Kotlin编译器功能的警告</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `kotlin-dsl`
}

kotlinDslPluginOptions {
    experimentalWarning.set(false)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kotdsl:precompiled_plugins"><a class="anchor" href="#kotdsl:precompiled_plugins"></a> <a class="link" href="#kotdsl:precompiled_plugins">预编译脚本插件</a></h5>
<div class="paragraph">
<p>除了普通的Kotlin源文件外<code>src/main/kotlin</code>按照惯例，Kotlin DSL插件还允许您将构建逻辑作为预编译脚本插件提供。您将它们写为<code>*.gradle.kts</code>相同的文件<code>src/main/kotlin</code>目录。</p>
</div>
<div class="paragraph">
<p>预编译脚本插件是Kotlin DSL脚本，它们作为常规Kotlin源集的一部分进行编译，然后放置在构建类路径中或打包为二进制插件，具体取决于它们所处的项目类型。出于所有目的和目的，它们<em>是</em>二进制插件，尤其是可以像常规插件一样通过插件ID进行应用。实际上，由于与<a href="#java_gradle_plugin">Gradle插件开发插件</a>集成，因此Kotlin DSL插件会为其生成插件元数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>Gradle 6.0内置的预编译脚本插件不能与Gradle的早期版本一起使用。在Gradle的未来版本中将取消此限制。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，要应用预编译的脚本插件，您需要知道其ID。那是从它的文件名（减去<code>.gradle.kts</code>扩展名）及其（可选）包声明。</p>
</div>
<div class="paragraph">
<p>例如，脚本<code>src/main/kotlin/java-library-convention.gradle.kts</code>的插件ID为<code>java-library-convention</code> （假设它没有包声明）。同样<code>src/main/kotlin/my/java-library-convention.gradle.kts</code>会导致插件ID为<code>my.java-library-convention</code>只要包声明为<code>my</code> 。</p>
</div>
<div class="paragraph">
<p>为了演示如何实现和使用预编译的脚本插件，让我们来看一个基于<code>buildSrc</code>项目。</p>
</div>
<div class="paragraph">
<p>首先，您需要<code>buildSrc/build.gradle.kts</code>应用Kotlin DSL插件的文件：</p>
</div>
<div class="exampleblock">
<div class="title">示例516。将Kotlin DSL插件应用于<code>buildSrc</code>项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `kotlin-dsl`
}

repositories {
    jcenter()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们建议您还创建一个<code>buildSrc/settings.gradle.kts</code>文件，您可以将其保留为空。</p>
</div>
<div class="paragraph">
<p>接下来，创建一个新的<code>java-library-convention.gradle.kts</code>文件在<code>buildSrc/src/main/kotlin</code>目录并将其内容设置为以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">例子517。创建一个简单的脚本插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">buildSrc / src / main / kotlin / java-library-convention.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
    checkstyle
}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

checkstyle {
    maxWarnings = 0
    // ...
}

tasks.withType&lt;JavaCompile&gt; {
    options.isWarnings = true
    // ...
}

dependencies {
    testImplementation(&quot;junit:junit:4.12&quot;)
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该脚本插件仅应用Java库和Checkstyle插件并对其进行配置。请注意，这实际上会将插件应用于主项目，即，将预编译脚本插件应用于主项目的插件。</p>
</div>
<div class="paragraph">
<p>最后，将脚本插件应用于根项目，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例518将预编译的脚本插件应用于主项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library-convention`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:kotlin"><a class="anchor" href="#sec:kotlin"></a> <a class="link" href="#sec:kotlin">嵌入式Kotlin</a></h4>
<div class="paragraph">
<p>Gradle嵌入Kotlin是为了为基于Kotlin的脚本提供支持。</p>
</div>
<div class="sect4">
<h5 id="kotlin_versions"><a class="anchor" href="#kotlin_versions"></a> <a class="link" href="#kotlin_versions">Kotlin版本</a></h5>
<div class="paragraph">
<p>Gradle随附<code>kotlin-compiler-embeddable</code>加上相符的版本<code>kotlin-stdlib</code>和<code>kotlin-reflect</code>库。例如，Gradle 4.3附带了Kotlin DSL v0.12.1，其中包括这些模块的Kotlin 1.1.51版本。的<code>kotlin</code>这些模块中的包可以通过Gradle类路径看到。</p>
</div>
<div class="paragraph">
<p>Kotlin提供的<a href="https://kotlinlang.org/docs/reference/compatibility.html">兼容性保证</a>适用于向后和向前兼容性。</p>
</div>
<div class="sect5">
<h6 id="backward_compatibility"><a class="anchor" href="#backward_compatibility"></a> <a class="link" href="#backward_compatibility">向后兼容</a></h6>
<div class="paragraph">
<p>我们的方法是仅在主要Gradle版本上进行向后的Kotlin升级。在主要版本发布之前，我们将始终清楚地记录我们所发行的Kotlin版本，并宣布升级计划。</p>
</div>
<div class="paragraph">
<p>想要与较旧的Gradle版本保持兼容的插件作者需要将其API使用限制为与这些旧版本兼容的子集。它与Gradle中的任何其他新API并没有真正的不同。例如，如果我们引入一个新的API来解决依赖关系，而一个插件想使用该API，那么他们要么需要放弃对较旧的Gradle版本的支持，要么需要对它们的代码进行一些巧妙的组织以仅在较新的代码上执行新的代码路径版本。</p>
</div>
</div>
<div class="sect5">
<h6 id="forward_compatibility"><a class="anchor" href="#forward_compatibility"></a> <a class="link" href="#forward_compatibility">前向兼容性</a></h6>
<div class="paragraph">
<p>最大的问题是外部之间的兼容性<code>kotlin-gradle-plugin</code>版本和<code>kotlin-stdlib</code> Gradle随附的版本。更普遍地，任何过渡依赖的插件之间<code>kotlin-stdlib</code>及其Gradle随附的版本。只要组合兼容，一切都应该起作用。随着语言的成熟，这将不再是一个问题。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:kotlin_compiler_arguments"><a class="anchor" href="#sec:kotlin_compiler_arguments"></a> <a class="link" href="#sec:kotlin_compiler_arguments">Kotlin编译器参数</a></h5>
<div class="paragraph">
<p>这些是Kotlin编译器参数，用于在具有以下内容的项目中编译Kotlin DSL脚本以及Kotlin源代码和脚本： <code>kotlin-dsl</code>插件已应用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-jvm-target=1.8</code></dt>
<dd>
<p>将生成的JVM字节码的目标版本设置为<code>1.8</code> 。</p>
</dd>
<dt class="hdlist1"><code>-Xjsr305=strict</code></dt>
<dd>
<p>设置Kotlin的Java互操作性以严格遵循JSR-305注释，以提高null安全性。有关更多信息，请参阅Kotlin文档中的<a href="https://kotlinlang.org/docs/reference/java-interop.html#compiler-configuration">从Kotlin调用Java代码</a> 。</p>
</dd>
<dt class="hdlist1"><code>-XX:NewInference</code></dt>
<dd>
<p>启用实验性Kotlin编译器推理引擎（对于Kotlin函数的SAM转换是必需的）。</p>
</dd>
<dt class="hdlist1"><code>-XX:SamConversionForKotlinFunctions</code></dt>
<dd>
<p>为Kotlin函数启用SAM（单一抽象方法）转换，以允许Kotlin构建逻辑公开和使用<code>org.gradle.api.Action<T></code>基于API。然后可以从Kotlin和Groovy DSL统一使用此类API。</p>
<div class="paragraph">
<p>例如，给定以下带有Java SAM参数类型的假设Kotlin函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">fun kotlinFunctionWithJavaSam(action: org.gradle.api.Action&lt;Any&gt;) = TODO()</code></pre>
</div>
</div>
<div class="paragraph">
<p>SAM转换为Kotlin函数可实现该函数的以下用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">kotlinFunctionWithJavaSam {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有Kotlin函数的SAM转换，则必须显式转换传递的lambda：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">kotlinFunctionWithJavaSam(Action {
    // ...
})</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:interoperability"><a class="anchor" href="#sec:interoperability"></a> <a class="link" href="#sec:interoperability">互通性</a></h4>
<div class="paragraph">
<p>在构建逻辑中混合语言时，可能必须跨越语言边界。一个极端的例子是使用Java和Groovy和Kotlin中实现的任务和插件的构建，同时还使用Kotlin DSL和Groovy DSL构建脚本。</p>
</div>
<div class="paragraph">
<p>引用Kotlin参考文档：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Kotlin在设计时就考虑了Java互操作性。现有的Java代码可以自然地从Kotlin调用，而Kotlin代码也可以从Java相当顺畅地使用。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Kotlin参考文档非常详细地介绍了<a href="https://kotlinlang.org/docs/reference/java-interop.html">从Kotlin调用Java</a>和<a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">从Java调用Kotlin</a> 。</p>
</div>
<div class="paragraph">
<p>这同样适用于与Groovy代码的互操作性。另外，Kotlin DSL提供了几种选择Groovy语义的方法，我们将在后面讨论。</p>
</div>
<div class="sect4">
<h5 id="static_extensions"><a class="anchor" href="#static_extensions"></a> <a class="link" href="#static_extensions">静态扩展</a></h5>
<div class="paragraph">
<p>Groovy和Kotlin语言都支持通过<a href="https://groovy-lang.org/metaprogramming.html#_extension_modules">Groovy Extension模块</a>和<a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin扩展来</a>扩展现有的类。</p>
</div>
<div class="paragraph">
<p>要从Groovy调用Kotlin扩展函数，请将其称为静态函数，并将接收器作为第一个参数传递：</p>
</div>
<div class="exampleblock">
<div class="title">示例519从Groovy调用Kotlin扩展</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">TheTargetTypeKt.kotlinExtensionFunction(receiver, <span class="string"><span class="delimiter">&quot;</span><span class="content">parameters</span><span class="delimiter">&quot;</span></span>, <span class="integer">42</span>, aReference)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Kotlin扩展功能是程序包级功能，您可以在Kotlin参考文档的“ <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#package-level-functions">程序包级功能”</a>部分中学习如何找到声明给定Kotlin扩展名的类型的名称。</p>
</div>
<div class="paragraph">
<p>要从Kotlin调用Groovy扩展方法，可以使用相同的方法：将其作为静态函数调用，并将接收者作为第一个参数。这是一个例子：</p>
</div>
<div class="exampleblock">
<div class="title">示例520从Kotlin调用Groovy扩展</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">TheTargetTypeGroovyExtension.groovyExtensionMethod(receiver, &quot;parameters&quot;, 42, aReference)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="named_parameters_and_default_arguments"><a class="anchor" href="#named_parameters_and_default_arguments"></a> <a class="link" href="#named_parameters_and_default_arguments">命名参数和默认参数</a></h5>
<div class="paragraph">
<p>Groovy和Kotlin语言都支持命名函数参数和默认参数，尽管它们的实现方式非常不同。如Kotlin语言参考中<a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments">命名实</a>参和<a href="https://kotlinlang.org/docs/reference/functions.html#default-arguments">默认实</a>参所述，Kotlin对这两者均提供了完善的支持。Groovy基于一个非类型安全的方式实现<a href="https://groovy-lang.org/objectorientation.html#_named_arguments">命名实参</a> <code>Map<String, ?></code>参数，这意味着它们不能与<a href="https://groovy-lang.org/objectorientation.html#_default_arguments">默认参数</a>组合。换句话说，对于任何给定的方法，您只能在Groovy中使用一个或另一个。</p>
</div>
<div class="sect5">
<h6 id="calling_kotlin_from_groovy"><a class="anchor" href="#calling_kotlin_from_groovy"></a> <a class="link" href="#calling_kotlin_from_groovy">从Groovy致电Kotlin</a></h6>
<div class="paragraph">
<p>要调用已从Groovy命名参数的Kotlin函数，只需使用带有位置参数的常规方法调用即可。无法通过参数名称提供值。</p>
</div>
<div class="paragraph">
<p>要调用具有Groovy的默认参数的Kotlin函数，请始终传递所有函数参数的值。</p>
</div>
</div>
<div class="sect5">
<h6 id="calling_groovy_from_kotlin"><a class="anchor" href="#calling_groovy_from_kotlin"></a> <a class="link" href="#calling_groovy_from_kotlin">从Kotlin调用Groovy</a></h6>
<div class="paragraph">
<p>要使用Kotlin的命名参数调用Groovy函数，您需要传递一个<code>Map<String, ?></code> ，如本例所示：</p>
</div>
<div class="exampleblock multi-language-sample">
<div class="title">示例521。使用Kotlin中的命名参数调用Groovy函数</div>
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">groovyNamedArgumentTakingMethod(mapOf(
    &quot;parameterName&quot; to &quot;value&quot;,
    &quot;other&quot; to 42,
    &quot;and&quot; to aReference))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用Kotlin的默认参数调用Groovy函数，请始终传递所有参数的值。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="groovy_closures_from_kotlin"><a class="anchor" href="#groovy_closures_from_kotlin"></a> <a class="link" href="#groovy_closures_from_kotlin">Kotlin的Groovy闭合</a></h5>
<div class="paragraph">
<p>有时您可能必须调用从Kotlin代码获取<a href="https://groovy-lang.org/closures.html">Closure</a>参数的Groovy方法。例如，一些用Groovy编写的第三方插件需要闭包参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>用任何语言编写的Gradle插件都应该首选该类型<code>Action<T></code>键入代替闭包。Groovy闭包和Kotlin lambda会自动映射到该类型的参数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了提供一种在保留Kotlin强类型的同时构造闭包的方法，存在两种辅助方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>closureOf<T> {}</code></p>
</li>
<li>
<p><code>delegateClosureOf<T> {}</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两种方法在不同的情况下都非常有用，并且取决于您所传递的方法。 <code>Closure</code>实例成。</p>
</div>
<div class="paragraph">
<p>一些插件期望使用简单的闭包，例如<a href="https://plugins.gradle.org/plugin/com.jfrog.bintray">Bintray</a>插件：</p>
</div>
<div class="exampleblock">
<div class="title">示例522使用<code>closureOf<T> {}</code></div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">bintray {
    pkg(closureOf&lt;PackageConfig&gt; {
        // Config for the package here
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在其他情况下，例如在配置服务器场时使用<a href="https://plugins.gradle.org/plugin/org.gretty">Gretty插件</a> ，该插件需要委托关闭：</p>
</div>
<div class="exampleblock">
<div class="title">示例523使用<code>delegateClosureOf<T> {}</code></div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(&quot;group:artifact:1.2.3&quot;) {
        artifact(delegateClosureOf&lt;DependencyArtifact&gt; {
            // configuration for the artifact
            name = &quot;artifact-name&quot;
        })
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过查看源代码，有时没有一个很好的方法来告诉您使用哪个版本。通常，如果您得到<code>NullPointerException</code>与<code>closureOf<T> {}</code> ，使用<code>delegateClosureOf<T> {}</code>将解决问题。</p>
</div>
<div class="paragraph">
<p>这两个实用程序功能对于<em>配置闭包</em>很有用，但是某些插件可能期望Groovy闭包用于其他目的。的<code>KotlinClosure0</code>至<code>KotlinClosure2</code>类型可以使Kotlin函数更灵活地适应Groovy闭包。</p>
</div>
<div class="exampleblock">
<div class="title">示例524使用<code>KotlinClosureX</code>类型</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">somePlugin {

    // Adapt parameter-less function
    takingParameterLessClosure(KotlinClosure0({
        &quot;result&quot;
    }))

    // Adapt unary function
    takingUnaryClosure(KotlinClosure1&lt;String, String&gt;({
        &quot;result from single parameter $this&quot;
    }))

    // Adapt binary function
    takingBinaryClosure(KotlinClosure2&lt;String, String, String&gt;({ a, b -&gt;
        &quot;result from parameters $a and $b&quot;
    }))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请参阅<a href="https://github.com/gradle/kotlin-dsl/tree/master/samples/groovy-interop">groovy-interop</a>示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="the_kotlin_dsl_groovy_builder"><a class="anchor" href="#the_kotlin_dsl_groovy_builder"></a> <a class="link" href="#the_kotlin_dsl_groovy_builder">Kotlin DSL Groovy Builder</a></h5>
<div class="paragraph">
<p>如果某些插件大量使用了<a href="https://groovy-lang.org/metaprogramming.html">Groovy元编程</a> ，那么从Kotlin或Java或任何静态编译的语言中使用它可能会非常麻烦。</p>
</div>
<div class="paragraph">
<p>Kotlin DSL提供了一个<code>withGroovyBuilder {}</code>该实用程序扩展将Groovy元编程语义附加到类型的对象<code>Any</code> 。下面的示例演示了对象上方法的几个功能<code>target</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例525使用<code>withGroovyBuilder {}</code></div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">target.withGroovyBuilder {                                          // <b class="conum">(1)</b>

    // GroovyObject methods available                               // <b class="conum">(2)</b>
    val foo = getProperty(&quot;foo&quot;)
    setProperty(&quot;foo&quot;, &quot;bar&quot;)
    invokeMethod(&quot;name&quot;, arrayOf(&quot;parameters&quot;, 42, aReference))

    // Kotlin DSL utilities
    &quot;name&quot;(&quot;parameters&quot;, 42, aReference)                            // <b class="conum">(3)</b>
        &quot;blockName&quot; {                                               // <b class="conum">(4)</b>
            // Same Groovy Builder semantics on `blockName`
        }
    &quot;another&quot;(&quot;name&quot; to &quot;example&quot;, &quot;url&quot; to &quot;https://example.com/&quot;) // <b class="conum">(5)</b>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>接收器是一个<a href="https://docs.groovy-lang.org/latest/html/api/groovy/lang/GroovyObject.html">GroovyObject，</a>并提供Kotlin帮助器</p>
</li>
<li>
<p>的<code>GroovyObject</code> API可用</p>
</li>
<li>
<p>调用<code>methodName</code>方法，传递一些参数</p>
</li>
<li>
<p>配置<code>blockName</code>属性，映射到<code>Closure</code>采取方法调用</p>
</li>
<li>
<p>调用<code>another</code>带有命名参数的方法，映射到Groovy命名参数<code>Map<String, ?></code>采取方法调用</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="https://github.com/gradle/kotlin-dsl/tree/master/samples/maven-plugin">Maven插件</a>示例演示了如何使用<code>withGroovyBuilder()</code>实用程序扩展，用于配置<code>uploadArchives</code>使用Gradle的核心<a href="#">Maven插件</a>通过自定义POM <a href="#sec:deploying_to_a_maven_repository">部署到Maven存储库的</a>任务。请注意，推荐的<a href="#">Maven Publish插件</a>提供了类型安全且Kotlin友好的DSL，使您可以轻松地执行<a href="#sec:modifying_the_generated_pom">相同的操作，</a>而无需采取任何措施。 <code>withGroovyBuilder()</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="using_a_groovy_script"><a class="anchor" href="#using_a_groovy_script"></a> <a class="link" href="#using_a_groovy_script">使用Groovy脚本</a></h5>
<div class="paragraph">
<p>处理假设Groovy DSL构建脚本的有问题的插件时，另一个选择是在主要Kotlin DSL构建脚本中应用的Groovy DSL构建脚本中配置它们：</p>
</div>
<div class="exampleblock">
<div class="title">示例526使用Groovy脚本</div>
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    id(&quot;dynamic-groovy-plugin&quot;) version &quot;1.0&quot;               <b class="conum">(1)</b>
}
apply(from = &quot;dynamic-groovy-plugin-configuration.gradle&quot;)  <b class="conum">(2)</b></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">dynamic-groovy-plugin-configuration.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">native</span> {                                                    <b class="conum">(3)</b>
    dynamic {
        groovy <span class="keyword">as</span> Usual
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Kotlin构建脚本请求并应用插件</p>
</li>
<li>
<p>Kotlin构建脚本应用Groovy脚本</p>
</li>
<li>
<p>Groovy脚本使用动态Groovy来配置插件</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotdsl:limitations"><a class="anchor" href="#kotdsl:limitations"></a> <a class="link" href="#kotdsl:limitations">局限性</a></h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/gradle/kotlin-dsl/issues/902">众所周知，</a> Kotlin DSL首次使用时<a href="https://github.com/gradle/kotlin-dsl/issues/902">比Groovy DSL慢</a> ，例如使用干净的结帐或临时连续集成代理时。更改<em>buildSrc</em>目录中的内容也会产生影响，因为它会使build-script缓存无效。主要原因是Kotlin DSL的脚本编译速度较慢。</p>
</li>
<li>
<p>在IntelliJ IDEA中，您必须<a href="https://www.jetbrains.com/help/idea/gradle.html#gradle_import">从Gradle模型</a>中<a href="https://www.jetbrains.com/help/idea/gradle.html#gradle_import">导入项目</a> ，以便为Kotlin DSL构建脚本获得内容帮助和重构支持。</p>
</li>
<li>
<p>Kotlin DSL将不支持<code>model {}</code>块，是<a href="https://blog.gradle.org/state-and-future-of-the-gradle-software-model">停产的Gradle Software Model的一部分</a> 。但是，您<em>可以</em>从脚本中应用模型规则-有关更多信息，请参见<a href="https://github.com/gradle/kotlin-dsl/tree/master/samples/model-rules">模型规则</a>示例。</p>
</li>
<li>
<p>我们建议您不要启用<a href="#sec:configuration_on_demand">按需配置</a>的孵化功能，因为它会导致非常难以诊断的问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您遇到麻烦或发现可疑的错误，请在<a href="https://github.com/gradle/gradle/issues/">Gradle问题跟踪器中</a>报告该问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="plugin_reference"><a class="anchor" href="#plugin_reference"></a> <a class="link" href="#plugin_reference">Gradle插件参考</a></h3>
<div class="paragraph">
<p>该页面包含Gradle本身提供的所有核心插件的链接和简短描述。</p>
</div>
<div class="sect3">
<h4 id="jvm_languages_and_frameworks"><a class="anchor" href="#jvm_languages_and_frameworks"></a> <a class="link" href="#jvm_languages_and_frameworks">JVM语言和框架</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#">爪哇</a></dt>
<dd>
<p>提供对构建任何类型的Java项目的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">Java库</a></dt>
<dd>
<p>提供对构建Java库的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">Java平台</a></dt>
<dd>
<p>提供对构建Java平台的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">Groovy</a></dt>
<dd>
<p>为构建任何类型的<a href="https://groovy-lang.org/">Groovy</a>项目提供支持。</p>
</dd>
<dt class="hdlist1"><a href="#">斯卡拉</a></dt>
<dd>
<p>为构建任何类型的<a href="https://www.scala-lang.org/">Scala</a>项目提供支持。</p>
</dd>
<dt class="hdlist1"><a href="#">ANTLR</a></dt>
<dd>
<p>提供对使用<a href="http://www.antlr.org/">ANTLR</a>生成解析器的支持。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="native_languages"><a class="anchor" href="#native_languages"></a> <a class="link" href="#native_languages">母语</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="cpp_application_plugin.html">C ++应用程序</a></dt>
<dd>
<p>提供对在Windows，Linux和macOS上构建C ++应用程序的支持。</p>
</dd>
<dt class="hdlist1"><a href="cpp_library_plugin.html">C ++库</a></dt>
<dd>
<p>提供对在Windows，Linux和macOS上构建C ++库的支持。</p>
</dd>
<dt class="hdlist1"><a href="cpp_unit_test_plugin.html">C ++单元测试</a></dt>
<dd>
<p>提供对在Windows，Linux和macOS上构建和运行基于C ++可执行文件的测试的支持。</p>
</dd>
<dt class="hdlist1"><a href="swift_application_plugin.html">快速申请</a></dt>
<dd>
<p>提供对在Linux和macOS上构建Swift应用程序的支持。</p>
</dd>
<dt class="hdlist1"><a href="swift_library_plugin.html">斯威夫特图书馆</a></dt>
<dd>
<p>提供对在Linux和macOS上构建Swift库的支持。</p>
</dd>
<dt class="hdlist1"><a href="xctest_plugin.html">XC测试</a></dt>
<dd>
<p>提供对在Linux和macOS上构建和运行基于XCTest的测试的支持。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="packaging_and_distribution"><a class="anchor" href="#packaging_and_distribution"></a> <a class="link" href="#packaging_and_distribution">包装与配送</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#">应用</a></dt>
<dd>
<p>提供对构建基于JVM的可运行应用程序的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">战争</a></dt>
<dd>
<p>提供对构建和打包基于WAR的Java Web应用程序的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">耳</a></dt>
<dd>
<p>提供对构建和打包Java EE应用程序的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">Maven发布</a></dt>
<dd>
<p>提供对将<a href="#">工件发布</a>到兼容Maven的存储库的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">常春藤出版</a></dt>
<dd>
<p>提供对将<a href="#">工件发布</a>到兼容Ivy的存储库的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">旧版Maven插件</a></dt>
<dd>
<p>使用<a href="artifact_management.html">旧版机制</a>向与Maven兼容的存储库发布工件提供支持。</p>
</dd>
<dt class="hdlist1"><a href="#">分配</a></dt>
<dd>
<p>轻松创建项目的ZIP和tarball发行版。</p>
</dd>
<dt class="hdlist1"><a href="#">Java库发行</a></dt>
<dd>
<p>提供对创建包含其运行时依赖项的Java库项目的ZIP分发的支持。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="code_analysis"><a class="anchor" href="#code_analysis"></a> <a class="link" href="#code_analysis">代码分析</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#">Checkstyle</a></dt>
<dd>
<p>使用<a href="http://checkstyle.sourceforge.net/index.html">Checkstyle</a>对项目的Java源文件执行质量检查，并生成关联的报告。</p>
</dd>
<dt class="hdlist1"><a href="#">PMD</a></dt>
<dd>
<p>使用<a href="http://pmd.github.io/">PMD</a>对项目的Java源文件执行质量检查，并生成关联的报告。</p>
</dd>
<dt class="hdlist1"><a href="#">JaCoCo</a></dt>
<dd>
<p>使用<a href="http://www.eclemma.org/jacoco/">JaCoCo</a>为您的Java项目提供代码覆盖率指标。</p>
</dd>
<dt class="hdlist1"><a href="#">CodeNarc</a></dt>
<dd>
<p>使用<a href="http://codenarc.sourceforge.net/index.html">CodeNarc</a>对Groovy源文件执行质量检查并生成关联的报告。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="ide_integration"><a class="anchor" href="#ide_integration"></a> <a class="link" href="#ide_integration">IDE整合</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#">日食</a></dt>
<dd>
<p>为可以由IDE打开的构建生成Eclipse项目文件。这套插件还可以用于微调<a href="http://projects.eclipse.org/projects/tools.buildship">Buildship的</a> Gradle构建导入过程。</p>
</dd>
<dt class="hdlist1"><a href="#">IntelliJ IDEA</a></dt>
<dd>
<p>为可以由IDE打开的构建生成IDEA项目文件。它也可以用于微调IDEA的Gradle构建导入过程。</p>
</dd>
<dt class="hdlist1"><a href="visual_studio_plugin.html">视觉工作室</a></dt>
<dd>
<p>生成用于生成的Visual Studio解决方案和项目文件，这些文件可以由IDE打开。</p>
</dd>
<dt class="hdlist1"><a href="xcode_plugin.html">Xcode</a></dt>
<dd>
<p>为可以由IDE打开的内部版本生成Xcode工作区和项目文件。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="utility"><a class="anchor" href="#utility"></a> <a class="link" href="#utility">效用</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#">基础</a></dt>
<dd>
<p>提供常见的生命周期任务，例如<code>clean</code> ，以及大多数内部版本共有的其他功能。</p>
</dd>
<dt class="hdlist1"><a href="#">建立初始化</a></dt>
<dd>
<p>生成指定类型的新Gradle构建，例如Java库。它还可以从Maven POM生成构建脚本-有关更多详细信息，请参见<a href="https://guides.gradle.org/migrating-from-maven/"><em>从Maven迁移到Gradle</em></a> 。</p>
</dd>
<dt class="hdlist1"><a href="#">签收</a></dt>
<dd>
<p>提供对生成的文件和工件进行数字签名的支持。</p>
</dd>
<dt class="hdlist1"><a href="#">插件开发</a></dt>
<dd>
<p>使开发和发布Gradle插件更加容易。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="command_line_interface"><a class="anchor" href="#command_line_interface"></a> <a class="link" href="#command_line_interface">命令行界面</a></h3>
<div class="paragraph lead">
<p>命令行界面是与Gradle交互的主要方法之一。以下内容作为执行和自定义Gradle使用命令行或编写脚本或配置持续集成时的参考。</p>
</div>
<div class="paragraph">
<p>强烈建议使用<a href="#gradle_wrapper">Gradle包装器</a> 。你应该替代<code>./gradlew</code>要么<code>gradlew.bat</code>对于<code>gradle</code>在以下所有使用包装器的示例中。</p>
</div>
<div class="paragraph">
<p>在命令行上执行Gradle符合以下结构。任务名称之前和之后均允许使用选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>gradle [taskName...] [--option-name...]</pre>
</div>
</div>
<div class="paragraph">
<p>如果指定了多个任务，则应以空格分隔。</p>
</div>
<div class="paragraph">
<p>可以选择是否指定接受值的选项<code>=</code>在选项和参数之间；但是，使用<code>=</code>被推荐。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--console=plain</pre>
</div>
</div>
<div class="paragraph">
<p>启用行为的选项具有长形式的选项，并带有用<code>--no-</code> 。以下是相反的情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--build-cache
--no-build-cache</pre>
</div>
</div>
<div class="paragraph">
<p>许多长格式期权具有短期权等价物。以下是等效的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--help
-h</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>可以在以下位置指定许多命令行标志<code>gradle.properties</code>避免需要输入。有关详细信息，请参见《 <a href="#sec:gradle_configuration_properties">配置构建环境指南</a> 》。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下各节介绍了Gradle命令行界面的使用，大致按用户目标分组。一些插件还添加了自己的命令行选项，例如<a href="#test_filtering"><code>--tests</code>用于Java测试过滤</a> 。有关为自己的任务公开命令行选项的更多信息，请参见<a href="#sec:declaring_and_using_command_line_options">声明和使用命令行选项</a> 。</p>
</div>
<div class="sect3">
<h4 id="sec:command_line_executing_tasks"><a class="anchor" href="#sec:command_line_executing_tasks"></a> <a class="link" href="#sec:command_line_executing_tasks">执行任务</a></h4>
<div class="paragraph">
<p>您可以运行任务及其所有<a href="#sec:task_dependencies">依赖项</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle myTask</pre>
</div>
</div>
<div class="paragraph">
<p>您可以在“ <a href="#sec:command_line_project_reporting">项目报告”部分中</a>了解哪些项目和任务可用。</p>
</div>
<div class="paragraph">
<p>大多数构建都支持一组常见的任务，称为<a href="#sec:lifecycle_tasks"><em>生命周期任务</em></a> 。这些包括<code>build</code> ， <code>assemble</code>和<code>check</code>任务。</p>
</div>
<div class="sect4">
<h5 id="executing_tasks_in_multi_project_builds"><a class="anchor" href="#executing_tasks_in_multi_project_builds"></a> <a class="link" href="#executing_tasks_in_multi_project_builds">在多项目构建中执行任务</a></h5>
<div class="paragraph">
<p>在<a href="#intro_multi_project_builds">多项目构建中</a> ，子项目任务可以使用“：”分隔子项目名称和任务名称来执行。<em>从根项目运行时</em> ，以下内容等效。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle :mySubproject:taskName
$ gradle mySubproject:taskName</pre>
</div>
</div>
<div class="paragraph">
<p>您也可以仅使用任务名称为所有子项目运行任务。例如，当从根项目目录中调用时，这将对所有子项目运行“测试”任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle test</pre>
</div>
</div>
<div class="paragraph">
<p>从子项目中调用Gradle时，应省略项目名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd mySubproject
$ gradle taskName</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>从子项目执行Gradle Wrapper时，必须参考<code>gradlew</code>相对。例如： <code>../gradlew taskName</code> 。<a href="http://www.gdub.rocks/">gdub</a>社区<a href="http://www.gdub.rocks/">项目</a>旨在使此操作更加方便。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="executing_multiple_tasks"><a class="anchor" href="#executing_multiple_tasks"></a> <a class="link" href="#executing_multiple_tasks">执行多项任务</a></h5>
<div class="paragraph">
<p>您还可以指定多个任务。例如，以下将执行<code>test</code>和<code>deploy</code>任务按照它们在命令行上列出的顺序排列，并且还将执行每个任务的依赖关系。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle test deploy</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:excluding_tasks_from_the_command_line"><a class="anchor" href="#sec:excluding_tasks_from_the_command_line"></a> <a class="link" href="#sec:excluding_tasks_from_the_command_line">从执行中排除任务</a></h5>
<div class="paragraph">
<p>您可以使用<code>-x</code>要么<code>--exclude-task</code>命令行选项，并提供要排除的任务的名称。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/commandLineTutorialTasks.png" alt="commandLineTutorialTasks">
</div>
<div class="title">图30。简单任务图</div>
</div>
<div class="listingblock">
<div class="title">排除任务</div>
<div class="content">
<pre>$ gradle dist --exclude-task test

&gt; Task :compile
compiling source

&gt; Task :dist
building the distribution

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到<code>test</code>任务不执行，即使它是<code>dist</code>任务。的<code>test</code>任务的依赖项，例如<code>compileTest</code>也不会执行。那些依赖<code>test</code>其他任务所需的，例如<code>compile</code> ，仍然执行。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:rerun_tasks"><a class="anchor" href="#sec:rerun_tasks"></a> <a class="link" href="#sec:rerun_tasks">强制执行任务</a></h5>
<div class="paragraph">
<p>您可以使用以下命令强制Gradle执行所有任务，而忽略<a href="#sec:up_to_date_checks">最新检查</a> <code>--rerun-tasks</code>选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle test --rerun-tasks</pre>
</div>
</div>
<div class="paragraph">
<p>这将迫使<code>test</code>和<em>所有</em>任务相关性<code>test</code>执行。有点像跑步<code>gradle clean test</code> ，但不会删除生成的生成的输出。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:continue_build_on_failure"><a class="anchor" href="#sec:continue_build_on_failure"></a> <a class="link" href="#sec:continue_build_on_failure">发生故障时继续构建</a></h5>
<div class="paragraph">
<p>默认情况下，Gradle将中止执行并在任何任务失败后立即使构建失败。这样可以使构建更快完成，但可以隐藏其他可能发生的故障。为了在一次构建执行中发现尽可能多的故障，您可以使用<code>--continue</code>选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle test --continue</pre>
</div>
</div>
<div class="paragraph">
<p>当执行<code>--continue</code> ，Gradle将执行要执行的<em>所有</em>任务，其中该任务的所有依赖关系均已完成而没有失败，而不是在遇到第一个失败时立即停止。每个遇到的故障将在构建结束时报告。</p>
</div>
<div class="paragraph">
<p>如果任务失败，则将不执行任何依赖于该任务的后续任务。例如，如果被测代码中的编译失败，则测试将不会运行。因为测试任务（直接或间接）取决于编译任务。</p>
</div>
</div>
<div class="sect4">
<h5 id="task_name_abbreviation"><a class="anchor" href="#task_name_abbreviation"></a> <a class="link" href="#task_name_abbreviation">任务名称缩写</a></h5>
<div class="paragraph">
<p>在命令行上指定任务时，不必提供任务的全名。您只需要提供足够的任务名称即可唯一地标识任务。例如，很可能<code>gradle che</code>足以让Gradle识别出<code>check</code>任务。</p>
</div>
<div class="paragraph">
<p>您也可以在驼峰式任务名称中缩写每个单词。例如，您可以执行任务<code>compileTest</code>通过运行<code>gradle compTest</code>甚至<code>gradle cT</code> 。</p>
</div>
<div class="listingblock">
<div class="title">缩写骆驼案例任务名称</div>
<div class="content">
<pre>$ gradle cT

&gt; Task :compile
compiling source

&gt; Task :compileTest
compiling unit tests

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="paragraph">
<p>您也可以将这些缩写与-x命令行选项一起使用。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="common_tasks"><a class="anchor" href="#common_tasks"></a> <a class="link" href="#common_tasks">常见任务</a></h4>
<div class="paragraph">
<p>以下是内置和大多数主要Gradle插件应用的任务约定。</p>
</div>
<div class="sect4">
<h5 id="computing_all_outputs"><a class="anchor" href="#computing_all_outputs"></a> <a class="link" href="#computing_all_outputs">计算所有输出</a></h5>
<div class="paragraph">
<p>在Gradle版本中， <code>build</code>指定组装所有输出并运行所有检查的任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle build</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running_applications"><a class="anchor" href="#running_applications"></a> <a class="link" href="#running_applications">运行应用程序</a></h5>
<div class="paragraph">
<p>应用程序通常与<code>run</code>任务，它组装应用程序并执行一些脚本或二进制文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle run</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running_all_checks"><a class="anchor" href="#running_all_checks"></a> <a class="link" href="#running_all_checks">运行所有检查</a></h5>
<div class="paragraph">
<p>通常， <em>所有</em>验证任务（包括测试和棉绒）都可以使用<code>check</code>任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle check</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cleaning_outputs"><a class="anchor" href="#cleaning_outputs"></a> <a class="link" href="#cleaning_outputs">清洁输出</a></h5>
<div class="paragraph">
<p>您可以使用以下命令删除构建目录的内容<code>clean</code>任务，尽管这样做会导致预先计算的输出丢失，从而导致后续任务执行需要大量额外的构建时间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle clean</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:command_line_project_reporting"><a class="anchor" href="#sec:command_line_project_reporting"></a> <a class="link" href="#sec:command_line_project_reporting">项目报告</a></h4>
<div class="paragraph">
<p>Gradle提供了一些内置任务，这些任务显示了构建的特定细节。这对于理解构建的结构和依赖性以及调试问题很有用。</p>
</div>
<div class="paragraph">
<p>您可以使用以下方法获得有关可用报告选项的基本帮助： <code>gradle help</code> 。</p>
</div>
<div class="sect4">
<h5 id="listing_projects"><a class="anchor" href="#listing_projects"></a> <a class="link" href="#listing_projects">上市项目</a></h5>
<div class="paragraph">
<p>跑步<code>gradle projects</code>为您提供所选项目的子项目列表，以层次结构显示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle projects</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以在构建扫描中获得项目报告。了解有关<a href="https://guides.gradle.org/creating-build-scans/">创建构建扫描的</a>更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:listing_tasks"><a class="anchor" href="#sec:listing_tasks"></a> <a class="link" href="#sec:listing_tasks">上市任务</a></h5>
<div class="paragraph">
<p>跑步<code>gradle tasks</code>为您提供所选项目的主要任务列表。该报告显示项目的默认任务（如果有）以及每个任务的描述。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle tasks</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，此报告仅显示已分配给任务组的那些任务。您可以使用以下命令在任务列表中获取更多信息： <code>--all</code>选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle tasks --all</pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要更加精确，则可以使用<code>--group</code>选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle tasks --group="build setup"</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:show_task_details"><a class="anchor" href="#sec:show_task_details"></a> <a class="link" href="#sec:show_task_details">显示任务使用情况详细信息</a></h5>
<div class="paragraph">
<p>跑步<code>gradle help --task someTask</code>为您提供有关特定任务的详细信息。</p>
</div>
<div class="listingblock">
<div class="title">获取任务的详细帮助</div>
<div class="content">
<pre>$ gradle -q help --task libs
Detailed task information for libs

Paths
     :api:libs
     :webapp:libs

Type
     Task (org.gradle.api.Task)

Description
     Builds the JAR

Group
     build</pre>
</div>
</div>
<div class="paragraph">
<p>此信息包括完整的任务路径，任务类型，可能的命令行选项以及给定任务的描述。</p>
</div>
</div>
<div class="sect4">
<h5 id="reporting_dependencies"><a class="anchor" href="#reporting_dependencies"></a> <a class="link" href="#reporting_dependencies">报告依赖性</a></h5>
<div class="paragraph">
<p>生成扫描会提供完整的可视化报告，说明存在哪些依赖关系，哪些配置，可传递依赖关系以及依赖关系版本选择。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle myTask --scan</pre>
</div>
</div>
<div class="paragraph">
<p>这将为您提供一个基于Web的报告的链接，您可以在其中找到类似的依赖项信息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/gradle-core-test-build-scan-dependencies.png" alt="构建扫描依存关系报告">
</div>
</div>
<div class="paragraph">
<p>在<a href="#">查看和调试依赖项中</a>了解更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="listing_project_dependencies"><a class="anchor" href="#listing_project_dependencies"></a> <a class="link" href="#listing_project_dependencies">列出项目依赖项</a></h5>
<div class="paragraph">
<p>跑步<code>gradle dependencies</code>为您提供所选项目的依赖关系列表，并按配置细分。对于每种配置，该配置的直接和传递依赖性在树中显示。以下是此报告的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle dependencies</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#">查看和调试依赖项中</a>提供了构建脚本和输出的具体示例。</p>
</div>
<div class="paragraph">
<p>跑步<code>gradle buildEnvironment</code>可视化所选项目的buildscript依赖关系，类似于<code>gradle dependencies</code>可视化所构建软件的依赖关系。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle buildEnvironment</pre>
</div>
</div>
<div class="paragraph">
<p>跑步<code>gradle dependencyInsight</code>让您深入了解与指定输入匹配的特定依赖项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle dependencyInsight</pre>
</div>
</div>
<div class="paragraph">
<p>由于依赖性报告可能会很大，因此将报告限制为特定配置可能很有用。这是通过可选的<code>--configuration</code>参数：</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:listing_properties"><a class="anchor" href="#sec:listing_properties"></a> <a class="link" href="#sec:listing_properties">列出项目属性</a></h5>
<div class="paragraph">
<p>跑步<code>gradle properties</code>为您提供所选项目的属性列表。</p>
</div>
<div class="listingblock">
<div class="title">有关属性的信息</div>
<div class="content">
<pre>$ gradle -q api:properties

------------------------------------------------------------
Project :api - The shared API for the application
------------------------------------------------------------

allprojects: [project ':api']
ant: org.gradle.api.internal.project.DefaultAntBuilder@12345
antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@12345
artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@12345
asDynamicObject: DynamicObject for project ':api'
baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@12345</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="software_model_reports"><a class="anchor" href="#software_model_reports"></a> <a class="link" href="#software_model_reports">软件模型报告</a></h5>
<div class="paragraph">
<p>您可以使用来获取<a href="#software_model">软件模型</a>项目元素的层次结构视图<code>model</code>任务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle model</pre>
</div>
</div>
<div class="paragraph">
<p>在软件模型文档中了解有关<a href="#model-report">模型报告的</a>更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:command_line_completion"><a class="anchor" href="#sec:command_line_completion"></a> <a class="link" href="#sec:command_line_completion">命令行完成</a></h4>
<div class="paragraph">
<p>Gradle通过<a href="https://github.com/gradle/gradle-completion">gradle-completion</a> （单独安装）为任务，选项和Gradle属性提供bash和zsh选项卡<a href="https://github.com/gradle/gradle-completion">补全支持</a> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/gradle-completion-4.0.gif" alt="gradle完成4.0">
</div>
<div class="title">图31。摇篮完成</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:command_line_debugging"><a class="anchor" href="#sec:command_line_debugging"></a> <a class="link" href="#sec:command_line_debugging">调试选项</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-?</code> ， <code>-h</code> ，<code>--help</code></dt>
<dd>
<p>显示带有所有可用CLI选项的帮助消息。</p>
</dd>
<dt class="hdlist1"><code>-v</code> ，<code>--version</code></dt>
<dd>
<p>打印Gradle，Groovy，Ant，JVM和操作系统版本信息。</p>
</dd>
<dt class="hdlist1"><code>-S</code> ，<code>--full-stacktrace</code></dt>
<dd>
<p>打印出完整的（非常详细的）堆栈跟踪信息以了解任何异常。另请参阅<a href="#sec:command_line_logging">日志记录选项</a> 。</p>
</dd>
<dt class="hdlist1"><code>-s</code> ，<code>--stacktrace</code></dt>
<dd>
<p>还打印出堆栈跟踪信息以了解用户异常（例如，编译错误）。另请参阅<a href="#sec:command_line_logging">日志记录选项</a> 。</p>
</dd>
<dt class="hdlist1"><code>--scan</code></dt>
<dd>
<p>使用有关Gradle构建各个方面的详细信息创建<a href="https://gradle.com/build-scans">构建扫描</a> 。</p>
</dd>
<dt class="hdlist1"><code>-Dorg.gradle.debug=true</code></dt>
<dd>
<p>调试Gradle客户端（非守护程序）进程。Gradle将等待您在以下位置附加调试器<code>localhost:5005</code>默认。</p>
</dd>
<dt class="hdlist1"><code>-Dorg.gradle.daemon.debug=true</code></dt>
<dd>
<p>调试<a href="#gradle_daemon">Gradle守护</a>进程。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:command_line_performance"><a class="anchor" href="#sec:command_line_performance"></a> <a class="link" href="#sec:command_line_performance">性能选项</a></h4>
<div class="paragraph">
<p>优化构建性能时，请尝试以下选项。<a href="https://guides.gradle.org/performance/">在此处</a>了解有关<a href="https://guides.gradle.org/performance/">提高Gradle构建的性能的</a>更多信息。</p>
</div>
<div class="paragraph">
<p>这些选项中的许多可以在<code>gradle.properties</code>因此不需要命令行标志。请参阅《 <a href="#sec:gradle_configuration_properties">配置构建环境指南》</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>--build-cache</code> ，<code>--no-build-cache</code></dt>
<dd>
<p>切换<a href="#build_cache">Gradle构建缓存</a> 。Gradle将尝试重用以前版本的输出。<em>默认为关闭</em> 。</p>
</dd>
<dt class="hdlist1"><code>--configure-on-demand</code> ，<code>--no-configure-on-demand</code></dt>
<dd>
<p>切换<a href="#sec:configuration_on_demand">按需配置</a> 。在此构建运行中仅配置相关项目。<em>默认为关闭</em> 。</p>
</dd>
<dt class="hdlist1"><code>--max-workers</code></dt>
<dd>
<p>设置Gradle可以使用的最大工人数。<em>默认值为处理器数量</em> 。</p>
</dd>
<dt class="hdlist1"><code>--parallel</code> ，<code>--no-parallel</code></dt>
<dd>
<p>并行构建项目。有关此选项的限制，请参见<a href="#sec:parallel_execution">并行项目执行</a> 。<em>默认为关闭</em> 。</p>
</dd>
<dt class="hdlist1"><code>--priority</code></dt>
<dd>
<p>指定Gradle守护程序及其启动的所有进程的调度优先级。值是<code>normal</code>要么<code>low</code> 。<em>默认为正常</em> 。</p>
</dd>
<dt class="hdlist1"><code>--profile</code></dt>
<dd>
<p>生成高级绩效报告<code>$buildDir/reports/profile</code>目录。 <code>--scan</code>是首选。</p>
</dd>
<dt class="hdlist1"><code>--scan</code></dt>
<dd>
<p>生成带有详细性能诊断的构建扫描。</p>
</dd>
</dl>
</div>
<div class="imageblock">
<div class="content">
<img src="img/gradle-core-test-build-scan-performance.png" alt="构建扫描性能报告">
</div>
</div>
<div class="sect4">
<h5 id="gradle_daemon_options"><a class="anchor" href="#gradle_daemon_options"></a> <a class="link" href="#gradle_daemon_options">Gradle守护程序选项</a></h5>
<div class="paragraph">
<p>您可以通过以下命令行选项管理<a href="#gradle_daemon">Gradle守护程序</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>--daemon</code> ，<code>--no-daemon</code></dt>
<dd>
<p>使用<a href="#gradle_daemon">Gradle守护程序</a>运行构建。如果守护程序未运行或现有守护程序繁忙，则启动该守护程序。<em>默认为on</em> 。</p>
</dd>
<dt class="hdlist1"><code>--foreground</code></dt>
<dd>
<p>在前台进程中启动Gradle守护程序。</p>
</dd>
<dt class="hdlist1"><code>--status</code> （独立命令）</dt>
<dd>
<p>跑<code>gradle --status</code>列出正在运行的和最近停止的Gradle守护进程。仅显示相同Gradle版本的守护程序。</p>
</dd>
<dt class="hdlist1"><code>--stop</code> （独立命令）</dt>
<dd>
<p>跑<code>gradle --stop</code>停止所有相同版本的Gradle守护进程。</p>
</dd>
<dt class="hdlist1"><code>-Dorg.gradle.daemon.idletimeout=(number of milliseconds)</code></dt>
<dd>
<p>在这段毫秒的空闲时间后，Gradle守护程序将自行停止。<em>默认值为10800000</em> （3小时）。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:command_line_logging"><a class="anchor" href="#sec:command_line_logging"></a> <a class="link" href="#sec:command_line_logging">记录选项</a></h4>
<div class="sect4">
<h5 id="setting_log_level"><a class="anchor" href="#setting_log_level"></a> <a class="link" href="#setting_log_level">设置日志级别</a></h5>
<div class="paragraph">
<p>您可以使用以下选项自定义Gradle日志记录的详细程度，顺序从最小详细到最大详细。在<a href="#logging">日志记录文档中</a>了解更多<a href="#logging">信息</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-Dorg.gradle.logging.level=(quiet,warn,lifecycle,info,debug)</code></dt>
<dd>
<p>通过Gradle属性设置日志记录级别。</p>
</dd>
<dt class="hdlist1"><code>-q</code> ，<code>--quiet</code></dt>
<dd>
<p>仅记录错误。</p>
</dd>
<dt class="hdlist1"><code>-w</code> ，<code>--warn</code></dt>
<dd>
<p>将日志级别设置为警告。</p>
</dd>
<dt class="hdlist1"><code>-i</code> ，<code>--info</code></dt>
<dd>
<p>将日志级别设置为info。</p>
</dd>
<dt class="hdlist1"><code>-d</code> ，<code>--debug</code></dt>
<dd>
<p>登录调试模式（包括正常的stacktrace）。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>生命周期是默认的日志级别。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:command_line_customizing_log_format"><a class="anchor" href="#sec:command_line_customizing_log_format"></a> <a class="link" href="#sec:command_line_customizing_log_format">自定义日志格式</a></h5>
<div class="paragraph">
<p>您可以通过以下方式指定“控制台”模式来控制丰富输出（颜色和字体变体）的使用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-Dorg.gradle.console=(auto,plain,rich,verbose)</code></dt>
<dd>
<p>通过Gradle属性指定控制台模式。下文将介绍不同的模式。</p>
</dd>
<dt class="hdlist1"><code>--console=(auto,plain,rich,verbose)</code></dt>
<dd>
<p>指定要生成的控制台输出的类型。</p>
<div class="paragraph">
<p>调成<code>plain</code>仅生成纯文本。此选项禁用控制台输出中的所有颜色和其他丰富输出。当Gradle <em>未</em>连接到终端时，这是默认设置。</p>
</div>
<div class="paragraph">
<p>调成<code>auto</code> （默认值）以在将构建过程附加到控制台时在控制台输出中启用颜色和其他格式的输出，或者仅在未附加到控制台时才生成纯文本。<em>当Gradle连接到终端时，这是默认设置。</em></p>
</div>
<div class="paragraph">
<p>调成<code>rich</code>无论构建过程是否未附加到控制台，都可以在控制台输出中启用颜色和其他丰富的输出。如果未附加到控制台，则构建输出将使用ANSI控制字符来生成丰富的输出。</p>
</div>
<div class="paragraph">
<p>调成<code>verbose</code>启用颜色和其他丰富的输出，例如<code>rich</code> ，但会在生命周期日志级别输出任务名称和结果，这在Gradle 3.5和更早版本中是默认设置。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="sec:command_line_warnings"><a class="anchor" href="#sec:command_line_warnings"></a> <a class="link" href="#sec:command_line_warnings">显示或隐藏警告</a></h5>
<div class="paragraph">
<p>默认情况下，Gradle不会显示所有警告（例如，弃用警告）。相反，Gradle将收集它们并在构建结束时呈现摘要，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Deprecated Gradle features were used in this build, making it incompatible with Gradle 5.0.</pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下选项在控制台上控制警告的详细程度：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-Dorg.gradle.warning.mode=(all,fail,none,summary)</code></dt>
<dd>
<p>通过<a href="#sec:gradle_configuration_properties">Gradle属性</a>指定警告模式。下文将介绍不同的模式。</p>
</dd>
<dt class="hdlist1"><code>--warning-mode=(all,fail,none,summary)</code></dt>
<dd>
<p>指定如何记录警告。默认为<code>summary</code> 。</p>
<div class="paragraph">
<p>调成<code>all</code>记录所有警告。</p>
</div>
<div class="paragraph">
<p>调成<code>fail</code>记录所有警告，如果有警告，则构建失败。</p>
</div>
<div class="paragraph">
<p>调成<code>summary</code>禁止显示所有警告，并在构建结束时记录摘要。</p>
</div>
<div class="paragraph">
<p>调成<code>none</code>禁止显示所有警告，包括构建结束时的摘要。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="rich_console"><a class="anchor" href="#rich_console"></a> <a class="link" href="#rich_console">丰富控制台</a></h5>
<div class="paragraph">
<p>运行构建时，Gradle的丰富控制台会显示更多信息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/rich-cli.png" alt="Gradle Rich Console">
</div>
</div>
<div class="paragraph">
<p>特征：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>进度条和计时器直观地描述了总体状态</p>
</li>
<li>
<p>下面的并行工作行描述了现在正在发生的事情</p>
</li>
<li>
<p>颜色和字体用于突出显示重要的输出和错误</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:command_line_execution_options"><a class="anchor" href="#sec:command_line_execution_options"></a> <a class="link" href="#sec:command_line_execution_options">执行选项</a></h4>
<div class="paragraph">
<p>以下选项通过更改生成的内容或解决依赖关系的方式来影响生成的执行方式。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>--include-build</code></dt>
<dd>
<p>将构建作为组合运行，包括指定的构建。参见<a href="#composite_builds">Composite Builds</a> 。</p>
</dd>
<dt class="hdlist1"><code>--offline</code></dt>
<dd>
<p>指定该构建应在不访问网络资源的情况下运行。了解有关<a href="#sec:controlling_dependency_caching_command_line">覆盖依赖项缓存的选项的</a>更多信息。</p>
</dd>
<dt class="hdlist1"><code>--refresh-dependencies</code></dt>
<dd>
<p>刷新依赖关系的状态。在<a href="#sec:controlling_dependency_caching_command_line">依赖管理文档中</a>了解有关如何使用它的更多信息。</p>
</dd>
<dt class="hdlist1"><code>--dry-run</code></dt>
<dd>
<p>在禁用所有任务操作的情况下运行Gradle。使用它来显示将要执行的任务。</p>
</dd>
<dt class="hdlist1"><code>--write-locks</code></dt>
<dd>
<p>表示所有<em>可锁定的</em>已解析配置都应<em>保留</em>其锁定状态。了解更多有关<a href="#dependency-locking">依赖锁定的信息</a> 。</p>
</dd>
<dt class="hdlist1"><code>--update-locks <group:name>[,<group:name>]*</code></dt>
<dd>
<p>指示必须在锁定文件中更新指定模块的版本。该标志还暗示<code>--write-locks</code> 。了解更多有关<a href="#dependency-locking">依赖锁定的信息</a> 。</p>
</dd>
<dt class="hdlist1"><code>---no-rebuild</code></dt>
<dd>
<p>不要重建项目依赖项。对于<a href="#sec:build_sources">调试和微调</a>很有用<a href="#sec:build_sources"><code>buildSrc</code></a> ，但可能导致错误的结果。请谨慎使用！</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="environment_options"><a class="anchor" href="#environment_options"></a> <a class="link" href="#environment_options">环境选项</a></h4>
<div class="paragraph">
<p>您可以通过以下选项自定义有关构建脚本，设置，缓存等位置的许多方面。了解有关自定义<a href="#build_environment">构建环境的</a>更多信息。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-b</code> ，<code>--build-file</code></dt>
<dd>
<p>指定构建文件。例如： <code>gradle --build-file=foo.gradle</code> 。默认是<code>build.gradle</code> ， 然后<code>build.gradle.kts</code> ， 然后<code>myProjectName.gradle</code> 。</p>
</dd>
<dt class="hdlist1"><code>-c</code> ，<code>--settings-file</code></dt>
<dd>
<p>指定设置文件。例如：<code>gradle --settings-file=somewhere/else/settings.gradle</code></p>
</dd>
<dt class="hdlist1"><code>-g</code> ，<code>--gradle-user-home</code></dt>
<dd>
<p>指定Gradle用户的主目录。默认为<code>.gradle</code>用户主目录中的目录。</p>
</dd>
<dt class="hdlist1"><code>-p</code> ，<code>--project-dir</code></dt>
<dd>
<p>指定Gradle的起始目录。默认为当前目录。</p>
</dd>
<dt class="hdlist1"><code>--project-cache-dir</code></dt>
<dd>
<p>指定项目特定的缓存目录。默认值为<code>.gradle</code>在根项目目录中。</p>
</dd>
<dt class="hdlist1"><code>-D</code> ，<code>--system-prop</code></dt>
<dd>
<p>设置JVM的系统属性，例如<code>-Dmyprop=myvalue</code> 。请参阅<a href="#sec:gradle_system_properties">系统属性</a> 。</p>
</dd>
<dt class="hdlist1"><code>-I</code> ，<code>--init-script</code></dt>
<dd>
<p>指定初始化脚本。请参阅<a href="#init_scripts">初始化脚本</a> 。</p>
</dd>
<dt class="hdlist1"><code>-P</code> ，<code>--project-prop</code></dt>
<dd>
<p>设置根项目的项目属性，例如<code>-Pmyprop=myvalue</code> 。请参阅<a href="#sec:project_properties">系统属性</a> 。</p>
</dd>
<dt class="hdlist1"><code>-Dorg.gradle.jvmargs</code></dt>
<dd>
<p>设置JVM参数。</p>
</dd>
<dt class="hdlist1"><code>-Dorg.gradle.java.home</code></dt>
<dd>
<p>设置JDK主目录。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:command_line_bootstrapping_projects"><a class="anchor" href="#sec:command_line_bootstrapping_projects"></a> <a class="link" href="#sec:command_line_bootstrapping_projects">引导新项目</a></h4>
<div class="sect4">
<h5 id="creating_new_gradle_builds"><a class="anchor" href="#creating_new_gradle_builds"></a> <a class="link" href="#creating_new_gradle_builds">创建新的Gradle版本</a></h5>
<div class="paragraph">
<p>使用内置<code>gradle init</code>创建带有新项目或现有项目的新Gradle构建的任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle init</pre>
</div>
</div>
<div class="paragraph">
<p>大多数情况下，您需要指定项目类型。可用的类型包括<code>basic</code> （默认）， <code>java-library</code> ， <code>java-application</code> ， 和更多。有关详细信息，请参见<a href="#build_init_plugin">init插件文档</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle init --type java-library</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="standardize_and_provision_gradle"><a class="anchor" href="#standardize_and_provision_gradle"></a> <a class="link" href="#standardize_and_provision_gradle">标准化和配置Gradle</a></h5>
<div class="paragraph">
<p>内建<code>gradle wrapper</code>任务生成一个脚本， <code>gradlew</code> ，它将调用Gradle的声明版本，并在必要时事先下载它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle wrapper --gradle-version=4.4</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以指定<code>--distribution-type=(bin|all)</code> ， <code>--gradle-distribution-url</code> ， <code>--gradle-distribution-sha256-sum</code>此外<code>--gradle-version</code> 。有关如何使用这些选项的完整详细信息，请参见<a href="#gradle_wrapper">Gradle包装器部分</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:continuous_build"><a class="anchor" href="#sec:continuous_build"></a> <a class="link" href="#sec:continuous_build">持续构建</a></h4>
<div class="paragraph">
<p>连续构建允许您在任务输入更改时自动重新执行所请求的任务。</p>
</div>
<div class="paragraph">
<p>例如，您可以连续运行<code>test</code>任务和所有相关任务，方法是运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle test --continuous</pre>
</div>
</div>
<div class="paragraph">
<p>摇篮的行为就像您跑步<code>gradle test</code>在更改有助于请求的任务的源或测试之后。这意味着无关的更改（例如，对构建脚本的更改）将不会触发重建。为了合并构建逻辑更改，必须手动重新启动连续构建。</p>
</div>
<div class="sect4">
<h5 id="terminating_continuous_build"><a class="anchor" href="#terminating_continuous_build"></a> <a class="link" href="#terminating_continuous_build">终止连续构建</a></h5>
<div class="paragraph">
<p>如果Gradle连接到交互式输入源（例如终端），则可以通过按退出连续构建<code>CTRL-D</code> （在Microsoft Windows上，还需要按<code>ENTER</code>要么<code>RETURN</code>后<code>CTRL-D</code> ）。如果Gradle未附加到交互式输入源（例如，作为脚本的一部分运行），则必须终止构建过程（例如，使用<code>kill</code>命令或类似命令）。如果构建是通过Tooling API执行的，则可以使用Tooling API的取消机制来取消构建。</p>
</div>
</div>
<div class="sect4">
<h5 id="continuous_build_limitations"><a class="anchor" href="#continuous_build_limitations"></a> <a class="link" href="#continuous_build_limitations">局限性和怪癖</a></h5>
<div class="paragraph">
<p>当前连续构建的实现要注意几个问题。这些可能会在将来的Gradle版本中解决。</p>
</div>
<div class="sect5">
<h6 id="sec:build_cycles"><a class="anchor" href="#sec:build_cycles"></a> <a class="link" href="#sec:build_cycles">构建周期</a></h6>
<div class="paragraph">
<p>Gradle在任务执行之前就开始监视更改。如果任务在执行时修改了自己的输入，Gradle将检测到更改并触发新的构建。如果每次执行任务时都再次修改输入，则构建将再次触发。这对于连续构建不是唯一的。如果没有连续构建而“正常”运行任务，则修改其自身输入的任务将永远不会被视为最新任务。</p>
</div>
<div class="paragraph">
<p>如果您的构建进入这样的构建周期，则可以通过查看Gradle报告的已更改文件列表来跟踪任务。在确定每次构建过程中更改的文件后，您应该寻找一个以该文件为输入的任务。在某些情况下，这可能是显而易见的（例如，使用<code>compileJava</code> ）。在其他情况下，您可以使用<code>--info</code>记录日志以查找由于标识的文件而过时的任务。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:continuous_build_limitations_jdk9"><a class="anchor" href="#sec:continuous_build_limitations_jdk9"></a> <a class="link" href="#sec:continuous_build_limitations_jdk9">Java 9的限制</a></h6>
<div class="paragraph">
<p>由于与Java 9相关的类访问限制，Gradle无法设置某些特定于操作系统的选项，这意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在macOS上，Gradle会每10秒而不是每2秒轮询一次文件更改。</p>
</li>
<li>
<p>在Windows上，Gradle必须使用单独的文件监视程序（例如在Linux / Mac OS上），这可能会导致连续构建不再适用于大型项目。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="sec:performance_and_stability"><a class="anchor" href="#sec:performance_and_stability"></a> <a class="link" href="#sec:performance_and_stability">性能稳定</a></h6>
<div class="paragraph">
<p>JDK文件监视功能依赖于macOS上低效的文件系统轮询（请参阅： <a href="https://bugs.openjdk.java.net/browse/JDK-7133447">JDK-7133447</a> ）。这会大大延迟具有许多源文件的大型项目的更改通知。</p>
</div>
<div class="paragraph">
<p>此外，监视机制可能会在macOS上的<em>高</em>负载下死锁（请参阅： <a href="https://bugs.openjdk.java.net/browse/JDK-8079620">JDK-8079620</a> ）。这将显示为Gradle似乎没有注意到文件更改。如果您怀疑发生这种情况，请退出连续构建并重新开始。</p>
</div>
<div class="paragraph">
<p>在Linux上，OpenJDK的文件监视服务实现有时会丢失文件系统事件（请参阅： <a href="https://bugs.openjdk.java.net/browse/JDK-8145981">JDK-8145981</a> ）。</p>
</div>
</div>
<div class="sect5">
<h6 id="sec:changes_to_symbolic_links"><a class="anchor" href="#sec:changes_to_symbolic_links"></a> <a class="link" href="#sec:changes_to_symbolic_links">更改符号链接</a></h6>
<div class="ulist">
<ul>
<li>
<p>创建或删除文件的符号链接将启动构建。</p>
</li>
<li>
<p>修改符号链接的目标不会导致重建。</p>
</li>
<li>
<p>创建或删除目录的符号链接不会导致重建。</p>
</li>
<li>
<p>在符号链接的目标目录中创建新文件不会导致重建。</p>
</li>
<li>
<p>删除目标目录不会导致重建。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="sec:changes_to_build_logic_are_not_considered"><a class="anchor" href="#sec:changes_to_build_logic_are_not_considered"></a> <a class="link" href="#sec:changes_to_build_logic_are_not_considered">不考虑更改构建逻辑</a></h6>
<div class="paragraph">
<p>当前的实现不会在以后的构建中重新计算构建模型。这意味着有效地忽略对任务配置的更改或对构建模型的任何其他更改。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="third_party_integration"><a class="anchor" href="#third_party_integration"></a> <a class="link" href="#third_party_integration">Gradle和第三方工具</a></h3>
<div class="paragraph">
<p>Gradle可以与许多不同的第三方工具集成，例如IDE和持续集成平台。在这里，我们看一些更常见的工具，以及如何将自己的工具与Gradle集成。</p>
</div>
<div class="sect3">
<h4 id="ides"><a class="anchor" href="#ides"></a> <a class="link" href="#ides">集成开发环境</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1">Android Studio</dt>
<dd>
<p>作为IntelliJ IDEA的变体， <a href="https://developer.android.com/studio/">Android Studio</a>内置了对导入和构建Gradle项目的支持。如果需要，您也可以使用<a href="#">IDEA Gradle插件来</a>微调导入过程。</p>
<div class="paragraph">
<p>该IDE还具有<a href="https://developer.android.com/studio/intro/">广泛的用户指南</a> ，可帮助您充分利用IDE和Gradle。</p>
</div>
</dd>
<dt class="hdlist1">日食</dt>
<dd>
<p>如果要在Eclipse中具有Gradle构建的项目上工作，则应使用<a href="https://projects.eclipse.org/projects/tools.buildship">Eclipse Buildship插件</a> 。这将允许您导入和运行Gradle构建。如果需要微调导入过程，以便正确加载项目，则可以使用<a href="#">Eclipse Plugins for Gradle</a> 。有关可以执行的微调的详细信息，请参阅<a href="https://discuss.gradle.org/t/buildship-1-0-18-is-now-available/19012">相关的发行公告</a> 。</p>
</dd>
<dt class="hdlist1">IntelliJ IDEA</dt>
<dd>
<p>IDEA具有导入Gradle项目的内置支持。如果您需要微调导入过程以正确加载项目，则可以使用<a href="#">IDEA Plugin for Gradle</a> 。</p>
</dd>
<dt class="hdlist1">NetBeans</dt>
<dd>
<p>将<a href="http://plugins.netbeans.org/plugin/44510/gradle-support">Gradle支持</a>插件添加到NetBeans中，以便使用Gradle构建导入和运行项目。</p>
</dd>
<dt class="hdlist1">视觉工作室</dt>
<dd>
<p>为了开发C ++项目，Gradle附带了<a href="visual_studio_plugin.html">Visual Studio插件</a> 。</p>
</dd>
<dt class="hdlist1">Xcode</dt>
<dd>
<p>为了开发C ++项目，Gradle附带了<a href="xcode_plugin.html">Xcode插件</a> 。</p>
</dd>
<dt class="hdlist1">里昂</dt>
<dd>
<p>JetBrains支持<a href="https://blog.jetbrains.com/clion/2018/05/clion-starts-2018-2-eap-sanitizers-gradle-db-performance/">使用Gradle</a>构建<a href="https://blog.jetbrains.com/clion/2018/05/clion-starts-2018-2-eap-sanitizers-gradle-db-performance/">C ++项目</a> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="continuous_integration"><a class="anchor" href="#continuous_integration"></a> <a class="link" href="#continuous_integration">持续集成</a></h4>
<div class="paragraph">
<p>我们有专门的指南，向您展示如何将Gradle项目与以下CI平台集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://guides.gradle.org/executing-gradle-builds-on-jenkins">詹金斯</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/executing-gradle-builds-on-teamcity">团队城市</a></p>
</li>
<li>
<p><a href="https://guides.gradle.org/executing-gradle-builds-on-travisci">特拉维斯CI</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>即使您不使用上述方法之一，您也几乎可以确定将CI平台配置为使用<a href="#">Gradle Wrapper</a>脚本。</p>
</div>
</div>
<div class="sect3">
<h4 id="how_to_integrate_with_gradle"><a class="anchor" href="#how_to_integrate_with_gradle"></a> <a class="link" href="#how_to_integrate_with_gradle">如何与Gradle集成</a></h4>
<div class="paragraph">
<p>将工具与Gradle集成的主要方法有两种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle构建使用该工具</p>
</li>
<li>
<p>该工具执行Gradle构建</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前一种情况通常<a href="#">实现为Gradle插件</a> 。后者可以通过在Tooling API中嵌入Gradle来实现，如下所述。</p>
</div>
</div>
<div class="sect3">
<h4 id="embedding"><a class="anchor" href="#embedding"></a> <a class="link" href="#embedding">使用Tooling API嵌入Gradle</a></h4>
<div class="sect4">
<h5 id="sec:embedding_introduction"><a class="anchor" href="#sec:embedding_introduction"></a> <a class="link" href="#sec:embedding_introduction">工具API简介</a></h5>
<div class="paragraph">
<p>Gradle提供了一个称为Tooling API的编程API，可用于将Gradle嵌入到自己的软件中。该API允许您执行和监视构建，并向Gradle查询构建的详细信息。该API的主要受众是IDE，CI服务器和其他UI作者；但是，该API对需要将Gradle嵌入其应用程序的任何人都是开放的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#test_kit">Gradle TestKit</a>使用Tooling API对Gradle插件进行功能测试。</p>
</li>
<li>
<p><a href="http://projects.eclipse.org/projects/tools.buildship">Eclipse Buildship</a>使用Tooling API导入Gradle项目并运行任务。</p>
</li>
<li>
<p><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>使用Tooling API导入Gradle项目并运行任务。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:embedding_features"><a class="anchor" href="#sec:embedding_features"></a> <a class="link" href="#sec:embedding_features">工具API功能</a></h5>
<div class="paragraph">
<p>Tooling API的基本特征是它以与版本无关的方式运行。这意味着您可以使用相同的API来处理使用不同版本的Gradle的版本，包括比所使用的Tooling API版本新或旧的版本。Tooling API支持Gradle包装器，默认情况下，使用与由包装器支持的版本使用的Gradle版本相同的Gradle版本。</p>
</div>
<div class="paragraph">
<p>工具API提供的一些功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>查询构建的详细信息，包括项目层次结构和项目依赖关系，外部依赖关系（包括源和Javadoc jar），每个项目的源目录和任务。</p>
</li>
<li>
<p>执行构建并收听stdout和stderr日志记录和进度消息（例如，在命令行上运行时，“状态栏”中显示的消息）。</p>
</li>
<li>
<p>执行特定的测试类或测试方法。</p>
</li>
<li>
<p>在执行构建时接收有趣的事件，例如项目配置，任务执行或测试执行。</p>
</li>
<li>
<p>取消正在运行的生成。</p>
</li>
<li>
<p>将多个单独的Gradle构建合并到一个复合构建中。</p>
</li>
<li>
<p>Tooling API可以下载并安装适当的Gradle版本，类似于包装程序。</p>
</li>
<li>
<p>该实现是轻量级的，仅具有少量依赖性。它也是一个行为良好的库，并且不对您的类加载器结构或日志记录配置进行任何假设。这使API易于嵌入到您的应用程序中。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:embedding_daemon"><a class="anchor" href="#sec:embedding_daemon"></a> <a class="link" href="#sec:embedding_daemon">工具API和Gradle Build守护进程</a></h5>
<div class="paragraph">
<p>工具API始终使用Gradle守护程序。这意味着随后对Tooling API的调用，无论是模型构建请求还是任务执行请求，都将在相同的长期过程中执行。<a href="#gradle_daemon">Gradle守护程序</a>包含有关该守护程序的更多详细信息，尤其是有关新守护程序被派生时的情况的信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:embedding_quickstart"><a class="anchor" href="#sec:embedding_quickstart"></a> <a class="link" href="#sec:embedding_quickstart">快速开始</a></h5>
<div class="paragraph">
<p>由于Tooling API是开发人员的接口，因此Javadoc是其主要文档。我们提供了一些<em>样例</em> <code>samples/toolingApi</code>在您的Gradle发行版中。这些示例指定了Tooling API所需的所有依赖项，并提供了示例，这些示例用于从Gradle构建中查询信息并从Tooling API执行任务。</p>
</div>
<div class="paragraph">
<p>要使用Tooling API，请将以下存储库和依赖项声明添加到构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">示例527使用工具API</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    maven { url <span class="string"><span class="delimiter">'</span><span class="content">https://repo.gradle.org/gradle/libs-releases</span><span class="delimiter">'</span></span> }
}

dependencies {
    implementation <span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle:gradle-tooling-api:</span><span class="inline"><span class="inline-delimiter">$</span>toolingApiVersion</span><span class="delimiter">&quot;</span></span>
    <span class="comment">// The tooling API need an SLF4J implementation available at runtime, replace this with any other implementation</span>
    runtimeOnly <span class="string"><span class="delimiter">'</span><span class="content">org.slf4j:slf4j-simple:1.7.10</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    maven { url = uri(&quot;https://repo.gradle.org/gradle/libs-releases&quot;) }
}

dependencies {
    implementation(&quot;org.gradle:gradle-tooling-api:$toolingApiVersion&quot;)
    // The tooling API need an SLF4J implementation available at runtime, replace this with any other implementation
    runtimeOnly(&quot;org.slf4j:slf4j-simple:1.7.10&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Tooling API的主要入口点是<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/tooling/GradleConnector.html">GradleConnector</a> 。您可以从那里导航以找到代码示例，并浏览可用的Tooling API模型。您可以使用<a href="https://docs.gradle.org/nightly/javadoc/org/gradle/tooling/GradleConnector.html#connect--">GradleConnector.connect（）</a>创建一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/tooling/ProjectConnection.html">ProjectConnection</a> 。一种<code>ProjectConnection</code>连接到单个Gradle项目。使用该连接，您可以执行任务，测试并检索与该项目相关的模型。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:embedding_compatibility"><a class="anchor" href="#sec:embedding_compatibility"></a> <a class="link" href="#sec:embedding_compatibility">Gradle版本和Java版本兼容性</a></h5>
<div class="sect5">
<h6 id="provider_side"><a class="anchor" href="#provider_side"></a> <a class="link" href="#provider_side">提供方</a></h6>
<div class="paragraph">
<p>当前版本的Tooling API支持使用Gradle 2.6及更高版本运行构建。</p>
</div>
</div>
<div class="sect5">
<h6 id="consumer_side"><a class="anchor" href="#consumer_side"></a> <a class="link" href="#consumer_side">消费方</a></h6>
<div class="paragraph">
<p>当前版本的Gradle支持通过Tooling API版本3.0及更高版本运行构建。</p>
</div>
<div class="paragraph">
<p>您应该注意，并非Tooling API的所有功能都适用于所有版本的Gradle。有关更多详细信息，请参阅每个类和方法的文档。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="java_version"><a class="anchor" href="#java_version"></a> <a class="link" href="#java_version">Java版本</a></h5>
<div class="paragraph">
<p>工具API需要Java 8或更高版本。内部版本使用的Gradle版本可能还有其他Java版本要求。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gradle_wrapper"><a class="anchor" href="#gradle_wrapper"></a> <a class="link" href="#gradle_wrapper">摇篮包装</a></h3>
<div class="paragraph">
<p>建议执行任何Gradle构建的方法是在Gradle Wrapper（简称为“ Wrapper”）的帮助下。Wrapper是一个脚本，它调用已声明版本的Gradle，并在必要时事先下载它。因此，开发人员可以快速启动并运行Gradle项目，而无需遵循手动安装过程，从而节省了公司的时间和金钱。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/wrapper-workflow.png" alt="包装器工作流程">
</div>
<div class="title">图32。包装器工作流程</div>
</div>
<div class="paragraph">
<p><strong>简而言之，您将获得以下好处：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>在给定的Gradle版本上标准化项目，从而导致更可靠，更可靠的构建。</p>
</li>
<li>
<p>向不同的用户和执行环境（例如IDE或Continuous Integration服务器）提供新的Gradle版本就像更改包装器定义一样简单。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>那么它是怎样工作的？对于用户而言，通常有三种不同的工作流程：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>您设置了一个新的Gradle项目，并希望<a href="#sec:adding_wrapper">将包装器添加</a>到其中。</p>
</li>
<li>
<p>您想<a href="#sec:using_wrapper">使用</a>已经提供<a href="#sec:using_wrapper">了包装</a>程序<a href="#sec:using_wrapper">的项目</a>来<a href="#sec:using_wrapper">运行该项目</a> 。</p>
</li>
<li>
<p>您想<a href="#sec:upgrading_wrapper">将包装器升级</a>到新版本的Gradle。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下各节将更详细地说明这些用例。</p>
</div>
<div class="sect3">
<h4 id="sec:adding_wrapper"><a class="anchor" href="#sec:adding_wrapper"></a> <a class="link" href="#sec:adding_wrapper">添加Gradle包装器</a></h4>
<div class="paragraph">
<p>生成Wrapper文件需要在计算机上安装Gradle运行时的安装版本，如<a href="#installation">Installation中所述</a> 。幸运的是，生成初始Wrapper文件是一次过程。</p>
</div>
<div class="paragraph">
<p>每个Vanilla Gradle构建都带有一个内置任务，称为<code>wrapper</code> 。列出任务时，您将可以在“构建安装程序任务”组下找到列出<a href="#sec:listing_tasks">的任务</a> 。执行<code>wrapper</code>任务在项目目录中生成必要的Wrapper文件。</p>
</div>
<div class="listingblock">
<div class="title">运行包装器任务</div>
<div class="content">
<pre>$ gradle wrapper
&gt; Task :wrapper

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>为了使包装器文件可用于其他开发人员和执行环境，您需要将其检入版本控制。包括JAR文件在内的所有包装程序文件都非常小。期望将JAR文件添加到版本控制中。一些组织不允许项目将二进制文件提交给版本控制。目前，该方法没有其他选择。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>生成的包装器属性文件， <code>gradle/wrapper/gradle-wrapper.properties</code> ，存储有关Gradle分布的信息。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>托管Gradle发行版的服务器。</p>
</li>
<li>
<p>Gradle分布的类型。默认情况下<code>-bin</code>仅包含运行时但不包含示例代码和文档的发行版。</p>
</li>
<li>
<p>用于执行构建的Gradle版本。默认情况下<code>wrapper</code>任务将选择与用于生成包装器文件完全相同的Gradle版本。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title"><code>gradle/wrapper/gradle-wrapper.properties</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">distributionUrl=https\://services.gradle.org/distributions/gradle-6.0.1-bin.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有这些方面都可以在以下命令行选项的帮助下在配置包装文件时进行配置。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>--gradle-version</code></dt>
<dd>
<p>用于下载和执行包装器的Gradle版本。</p>
</dd>
<dt class="hdlist1"><code>--distribution-type</code></dt>
<dd>
<p>包装器使用的Gradle分布类型。可用的选项是<code>bin</code>和<code>all</code> 。默认值为<code>bin</code> 。</p>
</dd>
<dt class="hdlist1"><code>--gradle-distribution-url</code></dt>
<dd>
<p>指向Gradle分发ZIP文件的完整URL。使用此选项使<code>--gradle-version</code>和<code>--distribution-type</code> URL已包含此信息，因此已过时。如果要在公司网络中托管Gradle发行版，则此选项非常有价值。</p>
</dd>
<dt class="hdlist1"><code>--gradle-distribution-sha256-sum</code></dt>
<dd>
<p>SHA256哈希和用于<a href="#sec:verification">验证下载的Gradle分布</a> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>让我们假设以下用例说明了命令行选项的用法。您想使用6.0.1版生成包装器，并使用<code>-all</code>分发以使您的IDE能够启用代码补全功能，并能够导航到Gradle源代码。这些要求由以下命令行执行捕获：</p>
</div>
<div class="listingblock">
<div class="title">提供包装任务的选项</div>
<div class="content">
<pre>$ gradle wrapper --gradle-version 6.0.1 --distribution-type all
&gt; Task :wrapper

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>结果，您可以在包装器属性文件中找到所需的信息。</p>
</div>
<div class="listingblock">
<div class="title">示例：生成的分发URL</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">distributionUrl=https\://services.gradle.org/distributions/gradle-6.0.1-all.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看一下以下项目布局，以说明预期的Wrapper文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.
├── build.gradle
├── settings.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
└── gradlew.bat</pre>
</div>
</div>
<div class="paragraph">
<p>Gradle项目通常会提供<code>build.gradle</code>和一个<code>settings.gradle</code>文件。包装器文件与<code>gradle</code>目录和项目的根目录。以下列表说明了它们的用途。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>gradle-wrapper.jar</code></dt>
<dd>
<p>包装器JAR文件，其中包含用于下载Gradle发行版的代码。</p>
</dd>
<dt class="hdlist1"><code>gradle-wrapper.properties</code></dt>
<dd>
<p>负责配置包装程序运行时行为的属性文件，例如与此版本兼容的Gradle版本。请注意，更多常规设置（例如， <a href="#sec:accessing_the_web_via_a_proxy">将包装器配置为使用代理</a> ）需要进入<a href="#sec:gradle_configuration_properties">其他文件</a> 。</p>
</dd>
<dt class="hdlist1"><code>gradlew</code> ，<code>gradlew.bat</code></dt>
<dd>
<p>一个外壳脚本和一个Windows批处理脚本，用于使用包装程序执行构建。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>您可以继续<a href="#sec:using_wrapper">使用包装程序执行构建，</a>而不必安装Gradle运行时。如果您正在处理的项目不包含那些包装文件，则需要<a href="#sec:adding_wrapper">生成它们</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:using_wrapper"><a class="anchor" href="#sec:using_wrapper"></a> <a class="link" href="#sec:using_wrapper">使用Gradle包装器</a></h4>
<div class="paragraph">
<p>建议始终使用包装器执行构建，以确保可靠，受控和标准化地执行构建。使用Wrapper看起来几乎就像通过Gradle安装运行构建。根据您运行的操作系统<code>gradlew</code>要么<code>gradlew.bat</code>而不是<code>gradle</code>命令。以下控制台输出演示了Windows机器上包装程序在基于Java的项目中的使用。</p>
</div>
<div class="listingblock">
<div class="title">使用包装程序批处理文件执行构建</div>
<div class="content">
<pre>$ gradlew.bat build
Downloading https://services.gradle.org/distributions/gradle-5.0-all.zip
.....................................................................................
Unzipping C:\Documents and Settings\Claudia\.gradle\wrapper\dists\gradle-5.0-all\ac27o8rbd0ic8ih41or9l32mv\gradle-5.0-all.zip to C:\Documents and Settings\Claudia\.gradle\wrapper\dists\gradle-5.0-al\ac27o8rbd0ic8ih41or9l32mv
Set executable permissions for: C:\Documents and Settings\Claudia\.gradle\wrapper\dists\gradle-5.0-all\ac27o8rbd0ic8ih41or9l32mv\gradle-5.0\bin\gradle

BUILD SUCCESSFUL in 12s
1 actionable task: 1 executed</pre>
</div>
</div>
<div class="paragraph">
<p>如果Gradle发行版在计算机上不可用，包装程序将下载它并存储在本地文件系统中。只要Gradle属性中的分发URL不变，任何后续的构建调用都将重用现有的本地分发。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>包装程序外壳程序脚本和批处理文件位于单项目或多项目Gradle构建的根目录中。如果要从子项目目录执行构建，则需要引用这些文件的正确路径。 <code>../../gradlew tasks</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:upgrading_wrapper"><a class="anchor" href="#sec:upgrading_wrapper"></a> <a class="link" href="#sec:upgrading_wrapper">升级Gradle包装器</a></h4>
<div class="paragraph">
<p>项目通常会希望与时俱进并升级其Gradle版本，以从新功能和改进中受益。升级Gradle版本的一种方法是手动更改<code>distributionUrl</code>包装属性文件中的属性。更好的建议选项是运行<code>wrapper</code>任务并提供目标Gradle版本，如<a href="#sec:adding_wrapper">添加Gradle包装器中所述</a> 。使用<code>wrapper</code>任务确保将对具有该特定Gradle版本的Wrapper Shell脚本或批处理文件所做的任何优化都应用于项目。像往常一样，您需要将对Wrapper文件的更改提交给版本控制。</p>
</div>
<div class="paragraph">
<p>使用摇篮<code>wrapper</code>任务以生成包装器，指定版本。默认为当前版本。升级包装程序后，可以通过执行以下命令检查其是否为所需版本<code>./gradlew --version</code> 。</p>
</div>
<div class="listingblock">
<div class="title">示例：升级包装器版本</div>
<div class="content">
<pre>$ ./gradlew wrapper --gradle-version 6.0.1

BUILD SUCCESSFUL in 4s
1 actionable task: 1 executed</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="customizing_wrapper"><a class="anchor" href="#customizing_wrapper"></a> <a class="link" href="#customizing_wrapper">自定义Gradle包装器</a></h4>
<div class="paragraph">
<p>Gradle的大多数用户对Wrapper的默认运行时行为感到满意。但是，组织策略，安全性约束或个人喜好可能会要求您更深入地定制包装器。幸运的是，内置<code>wrapper</code>任务提供了许多选项，可以使运行时行为符合您的需求。大多数配置选项由基础任务类型<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.wrapper.Wrapper.html">Wrapper</a>公开。</p>
</div>
<div class="paragraph">
<p>假设您已经厌倦了定义<code>-all</code>每次升级包装程序时，在命令行上选择分发类型。您可以通过重新配置键盘来节省一些键盘击键<code>wrapper</code>任务。</p>
</div>
<div class="exampleblock">
<div class="title">例子528。自定义包装任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">wrapper {
    distributionType = Wrapper.DistributionType.ALL
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.wrapper {
    distributionType = Wrapper.DistributionType.ALL
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在适当的配置下运行<code>./gradlew wrapper --gradle-version 6.0.1</code>足以产生一个<code>distributionUrl</code>包装器属性文件中的值，该值将请求<code>-all</code>分配。</p>
</div>
<div class="listingblock">
<div class="title">生成的分发URL</div>
<div class="content">
<pre>distributionUrl=https\://services.gradle.org/distributions/gradle-6.0.1-all.zip</pre>
</div>
</div>
<div class="paragraph">
<p>请查阅API文档，以获取有关可用配置选项的更多详细说明。您还可以在Gradle发行版中找到用于配置包装器的各种示例。</p>
</div>
<div class="sect4">
<h5 id="sec:authenticated_download"><a class="anchor" href="#sec:authenticated_download"></a> <a class="link" href="#sec:authenticated_download">经过身份验证的Gradle发行版下载</a></h5>
<div class="paragraph">
<p>摇篮<code>Wrapper</code>可以使用HTTP基本身份验证从服务器下载Gradle发行版。这使您可以将Gradle分发托管在受保护的私有服务器上。您可以根据使用情况以两种不同的方式指定用户名和密码：作为系统属性或直接嵌入到用户名和密码中。 <code>distributionUrl</code> 。系统属性中的凭据优先于嵌入在其中的凭据<code>distributionUrl</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="title">安全警告</div>
<div class="paragraph">
<p>HTTP基本身份验证仅应与<code>HTTPS</code>网址，而不是简单的<code>HTTP</code>那些。使用基本身份验证，用户凭据以明文形式发送。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用系统属性可以在<code>.gradle/gradle.properties</code>用户主目录中的文件（或通过其他方式），请参阅<a href="#sec:gradle_configuration_properties">Gradle配置属性</a> 。</p>
</div>
<div class="listingblock">
<div class="title">使用系统属性指定HTTP基本身份验证凭据</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">systemProp.gradle.wrapperUser=username
systemProp.gradle.wrapperPassword=password</code></pre>
</div>
</div>
<div class="paragraph">
<p>将凭证嵌入到<code>distributionUrl</code>在里面<code>gradle/wrapper/gradle-wrapper.properties</code>文件也可以。请注意，此文件将提交到您的源代码管理系统中。嵌入的共享凭证<code>distributionUrl</code>仅应在受控环境中使用。</p>
</div>
<div class="listingblock">
<div class="title">在中指定HTTP基本身份验证凭据<code>distributionUrl</code></div>
<div class="content">
<pre>distributionUrl=https://username:password@somehost/path/to/gradle-distribution.zip</pre>
</div>
</div>
<div class="paragraph">
<p>可以与已认证的代理或未认证的代理一起使用。有关如何配置<a href="#sec:accessing_the_web_via_a_proxy">代理服务器</a>的更多信息，请参见<a href="#sec:accessing_the_web_via_a_proxy">通过代理访问网络。</a> <code>Wrapper</code>使用代理。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:verification"><a class="anchor" href="#sec:verification"></a> <a class="link" href="#sec:verification">验证下载的Gradle发行版</a></h5>
<div class="paragraph">
<p>Gradle包装器可通过SHA-256哈希和比较来验证下载的Gradle分发。通过防止中间人攻击者篡改下载的Gradle发行版，提高了针对目标攻击的安全性。</p>
</div>
<div class="paragraph">
<p>要启用此功能，请下载<code>.sha256</code>与您要验证的Gradle发行版关联的文件。</p>
</div>
<div class="sect5">
<h6 id="downloading_the_sha_256_file"><a class="anchor" href="#downloading_the_sha_256_file"></a> <a class="link" href="#downloading_the_sha_256_file">下载SHA-256文件</a></h6>
<div class="paragraph">
<p>您可以下载<code>.sha256</code> <a href="https://services.gradle.org/distributions/">稳定版本</a>或<a href="https://services.gradle.org/distributions-snapshots/">候选版本以及每晚版本的文件</a> 。文件的格式是一行文本，它是相应zip文件的SHA-256哈希。</p>
</div>
<div class="paragraph">
<p>您还可以参考<a href="https://gradle.org/release-checksums/">Gradle分发校验和列表</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="configuring_checksum_verification"><a class="anchor" href="#configuring_checksum_verification"></a> <a class="link" href="#configuring_checksum_verification">配置校验和验证</a></h6>
<div class="paragraph">
<p>将下载的哈希值加到<code>gradle-wrapper.properties</code>使用<code>distributionSha256Sum</code>财产或用途<code>--gradle-distribution-sha256-sum</code>在命令行上。</p>
</div>
<div class="listingblock">
<div class="title">配置SHA-256校验和验证</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">distributionSha256Sum=371cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果配置的校验和与在托管发行版的服务器上找到的校验和不匹配，则Gradle将报告构建失败。仅当尚未下载已配置的包装器发行版时才执行校验和验证。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="wrapper_checksum_verification"><a class="anchor" href="#wrapper_checksum_verification"></a> <a class="link" href="#wrapper_checksum_verification">验证Gradle Wrapper JAR的校验和</a></h4>
<div class="paragraph">
<p>包装JAR是一个二进制文件，将在开发人员和构建服务器的计算机上执行。与所有此类文件一样，在执行文件之前，应确保它是可信任的。例如，由于通常将Wrapper JAR检查到项目的版本控制系统中，因此恶意行为者有可能通过提交或提交貌似仅升级Gradle版本的拉取请求来用修改后的JAR替换原始JAR。</p>
</div>
<div class="paragraph">
<p>为了检查Wrapper JAR的完整性，Gradle在<a href="https://services.gradle.org/" class="bare">https：//services.gradle</a>上与<a href="https://gradle.org/release-checksums/">所有</a> Gradle发行<a href="https://gradle.org/release-checksums/">版一起发布了所有发行版</a>的<a href="https://gradle.org/release-checksums/">校验和</a> （3.3至4.0.2版除外，该版本未生成可再现的JAR） <a href="https://services.gradle.org/" class="bare">。 org /</a> 。您可以通过在主要操作系统之一上运行以下命令来手动验证Wrapper JAR的校验和，以确保未被篡改：</p>
</div>
<div class="listingblock">
<div class="title">在Linux上手动验证Wrapper JAR的校验和</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ cd gradle/wrapper
$ curl --location --output gradle-wrapper.jar.sha256 \
       https://services.gradle.org/distributions/gradle-6.0.1-wrapper.jar.sha256
$ echo &quot;  gradle-wrapper.jar&quot; &gt;&gt; gradle-wrapper.jar.sha256
$ sha256sum --check gradle-wrapper.jar.sha256
gradle-wrapper.jar: OK</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">在macOS上手动验证Wrapper JAR的校验和</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ cd gradle/wrapper
$ curl --location --output gradle-wrapper.jar.sha256 \
       https://services.gradle.org/distributions/gradle-6.0.1-wrapper.jar.sha256
$ echo &quot;  gradle-wrapper.jar&quot; &gt;&gt; gradle-wrapper.jar.sha256
$ shasum --check gradle-wrapper.jar.sha256
gradle-wrapper.jar: OK</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">在Windows上手动验证Wrapper JAR的校验和（使用PowerShell）</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="powershell">&gt; $expected = Invoke-RestMethod -Uri https://services.gradle.org/distributions/gradle-6.0.1-wrapper.jar.sha256
&gt; $actual = (Get-FileHash gradle\wrapper\gradle-wrapper.jar -Algorithm SHA256).Hash.ToLower()
&gt; @{$true = 'OK: Checksum match'; $false = &quot;ERROR: Checksum mismatch!`nExpected: $expected`nActual:   $actual&quot;}[$actual -eq $expected]
OK: Checksum match</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="troubleshooting_a_checksum_mismatch"><a class="anchor" href="#troubleshooting_a_checksum_mismatch"></a> <a class="link" href="#troubleshooting_a_checksum_mismatch">对校验和不匹配进行故障排除</a></h5>
<div class="paragraph">
<p>如果校验和与您期望的不匹配，则很可能是<code>wrapper</code>升级的Gradle发行版未执行任务。因此，您应该首先检查实际校验和是否与其他Gradle版本之一匹配。您可以在主要操作系统上运行以下命令来生成Wrapper JAR的实际校验和：</p>
</div>
<div class="listingblock">
<div class="title">在Linux上生成包装器JAR的实际校验和</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ sha256sum gradle/wrapper/gradle-wrapper.jar
d81e0f23ade952b35e55333dd5f1821585e887c6d24305aeea2fbc8dad564b95  gradle/wrapper/gradle-wrapper.jar</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">在macOS上生成包装器JAR的实际校验和</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">$ shasum --algorithm=256 gradle/wrapper/gradle-wrapper.jar
d81e0f23ade952b35e55333dd5f1821585e887c6d24305aeea2fbc8dad564b95  gradle/wrapper/gradle-wrapper.jar</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">在Windows上生成包装器JAR的实际校验和（使用PowerShell）</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="powershell">&gt; (Get-FileHash gradle\wrapper\gradle-wrapper.jar -Algorithm SHA256).Hash.ToLower()
d81e0f23ade952b35e55333dd5f1821585e887c6d24305aeea2fbc8dad564b95</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦知道了实际的校验和，请检查它是否在<a href="https://gradle.org/release-checksums/" class="bare">https://gradle.org/release-checksums/</a>上列出。如果已列出，则您已验证包装JAR的完整性。但是，它属于不同的-可能是较旧的-Gradle版本。在这种情况下，运行<code>wrapper</code>再次执行任务以更新包装JAR，使其与Google的Gradle版本匹配<code>gradle/wrapper/gradle-wrapper.properties</code> 。</p>
</div>
<div class="paragraph">
<p>如果该页面上未列出校验和，则包装JAR可能来自里程碑，候选发布版本或每晚生成的版本，或者可能确实不合法。您应该尝试找出它是如何生成的，但是除非有其他证明，否则应将其视为不可信的。如果您认为该文件已被篡改，请发送电子邮件至<a href="mailto:security@gradle.com">security@gradle.com</a>告知Gradle团队。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="directory_layout"><a class="anchor" href="#directory_layout"></a> <a class="link" href="#directory_layout">目录和文件Gradle的使用</a></h3>
<div class="paragraph">
<p>Gradle使用两个主要目录来执行和管理其工作： <a href="#dir:gradle_user_home">Gradle用户主目录</a>和<a href="#dir:project_root">Project根目录</a> 。以下两节描述了每个文件中存储的内容以及如何清理临时文件和目录。</p>
</div>
<div class="sect3">
<h4 id="dir:gradle_user_home"><a class="anchor" href="#dir:gradle_user_home"></a> <a class="link" href="#dir:gradle_user_home">Gradle用户主目录</a></h4>
<div class="paragraph">
<p>Gradle用户主目录（ <code>$USER_HOME/.gradle</code>默认情况下）用于存储全局配置属性和初始化脚本以及缓存和日志文件。它的大致结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>├── caches // <b class="conum">(1)</b>
│   ├── 4.8 // <b class="conum">(2)</b>
│   ├── 4.9 // <b class="conum">(2)</b>
│   ├── ⋮
│   ├── jars-3 // <b class="conum">(3)</b>
│   └── modules-2 // <b class="conum">(3)</b>
├── daemon // <b class="conum">(4)</b>
│   ├── ⋮
│   ├── 4.8
│   └── 4.9
├── init.d // <b class="conum">(5)</b>
│   └── my-setup.gradle
├── wrapper
│   └── dists // <b class="conum">(6)</b>
│       ├── ⋮
│       ├── gradle-4.8-bin
│       ├── gradle-4.9-all
│       └── gradle-4.9-bin
└── gradle.properties // <b class="conum">(7)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>全局缓存目录（适用于所有非项目专用的目录）</p>
</li>
<li>
<p>特定于版本的缓存（例如，支持增量构建）</p>
</li>
<li>
<p>共享缓存（例如，依赖项的工件）</p>
</li>
<li>
<p><a href="#gradle_daemon">Gradle守护程序的</a>注册表和日志</p>
</li>
<li>
<p>全局<a href="#init_scripts">初始化脚本</a></p>
</li>
<li>
<p><a href="#gradle_wrapper">Gradle Wrapper</a>下载的发行版</p>
</li>
<li>
<p>全局<a href="#sec:gradle_configuration_properties">Gradle配置属性</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="dir:gradle_user_home:cache_cleanup"><a class="anchor" href="#dir:gradle_user_home:cache_cleanup"></a> <a class="link" href="#dir:gradle_user_home:cache_cleanup">清理缓存和分发</a></h5>
<div class="paragraph">
<p>从版本4.10开始，Gradle会自动清除其用户主目录。当Gradle守护程序停止或关闭时，清理将在后台运行。如果使用<code>--no-daemon</code> ，它在构建会话后以可视进度指示器在前台运行。</p>
</div>
<div class="paragraph">
<p>定期（最多每24小时）应用以下清理策略：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>中特定于版本的缓存<code>caches/<gradle-version>/</code>检查它们是否仍在使用中。如果不是，则在闲置30天后删除发布版本的目录，在闲置7天后删除快照版本。</p>
</li>
<li>
<p>共享缓存<code>caches/</code> （例如<code>jars-*</code> ），检查它们是否仍在使用中。如果没有Gradle版本仍在使用它们，则会将其删除。</p>
</li>
<li>
<p>当前Gradle版本使用的共享缓存中的文件<code>caches/</code> （例如<code>jars-3</code>要么<code>modules-2</code> ）进行检查，以了解它们的最后访问时间。根据是可以在本地重新创建文件，还是必须再次从远程存储库下载文件，将分别在不访问7天或30天后将其删除。</p>
</li>
<li>
<p>中的Gradle分布<code>wrapper/dists/</code>检查它们是否仍在使用，即是否存在相应的特定于版本的缓存目录。未使用的发行版将被删除。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dir:project_root"><a class="anchor" href="#dir:project_root"></a> <a class="link" href="#dir:project_root">项目根目录</a></h4>
<div class="paragraph">
<p>项目根目录包含项目中所有的源文件。此外，它还包含Gradle生成的文件和目录，例如<code>.gradle</code>和<code>build</code> 。通常，前者通常签入到源代码管理中，而后者是Gradle用于支持增量构建等功能的临时文件。总体而言，典型项目根目录的结构大致如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>├── .gradle // <b class="conum">(1)</b>
│   ├── 4.8 // <b class="conum">(2)</b>
│   ├── 4.9 // <b class="conum">(2)</b>
│   └── ⋮
├── build // <b class="conum">(3)</b>
├── gradle
│   └── wrapper  // <b class="conum">(4)</b>
├── build.gradle <em>or</em> build.gradle.kts // <b class="conum">(5)</b>
├── gradle.properties // <b class="conum">(6)</b>
├── gradlew // <b class="conum">(7)</b>
├── gradlew.bat // <b class="conum">(7)</b>
└── settings.gradle <em>or</em> settings.gradle.kts // <b class="conum">(8)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Gradle生成的特定于项目的缓存目录</p>
</li>
<li>
<p>特定于版本的缓存（例如，支持增量构建）</p>
</li>
<li>
<p>Gradle在其中生成所有构建工件的该项目的构建目录。</p>
</li>
<li>
<p>包含JAR文件和<a href="#gradle_wrapper">Gradle包装器的</a>配置</p>
</li>
<li>
<p>项目的Gradle构建脚本</p>
</li>
<li>
<p>项目特定的<a href="#sec:gradle_configuration_properties">Gradle配置属性</a></p>
</li>
<li>
<p>使用<a href="#gradle_wrapper">Gradle Wrapper</a>执行构建的脚本</p>
</li>
<li>
<p>项目的<a href="#sec:settings_file">设置文件</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="dir:project_root:cache_cleanup"><a class="anchor" href="#dir:project_root:cache_cleanup"></a> <a class="link" href="#dir:project_root:cache_cleanup">项目缓存清理</a></h5>
<div class="paragraph">
<p>从版本4.10开始，Gradle会自动清除特定于项目的缓存目录。构建项目后，特定版本的缓存目录位于<code>.gradle/<gradle-version>/</code>定期（最多每24小时）检查一次它们是否仍在使用中。如果7天未使用它们，则将其删除。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">﻿<div class="sect1">
<h2 id="part:plugins"><a class="anchor" href="#part:plugins"></a> <a class="link" href="#part:plugins">外挂程式</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="antlr_plugin"><a class="anchor" href="#antlr_plugin"></a> <a class="link" href="#antlr_plugin">ANTLR插件</a></h3>
<div class="paragraph">
<p>ANTLR插件扩展了Java插件，以增加对使用<a href="http://www.antlr.org/">ANTLR</a>生成解析器的支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">ANTLR插件支持ANTLR版本2、3和4。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="sec:antlr_usage"><a class="anchor" href="#sec:antlr_usage"></a> <a class="link" href="#sec:antlr_usage">用法</a></h4>
<div class="paragraph">
<p>要使用ANTLR插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例529。使用ANTLR插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">antlr</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    antlr
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:antlr_tasks"><a class="anchor" href="#sec:antlr_tasks"></a> <a class="link" href="#sec:antlr_tasks">任务</a></h4>
<div class="paragraph">
<p>ANTLR插件将许多任务添加到您的项目中，如下所示。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>generateGrammarSource</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.antlr.AntlrTask.html">AntlrTask</a></dt>
<dd>
<p>生成所有生产ANTLR语法的源文件。</p>
</dd>
<dt class="hdlist1"><code>generateTestGrammarSource</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.antlr.AntlrTask.html">AntlrTask</a></dt>
<dd>
<p>生成所有测试ANTLR语法的源文件。</p>
</dd>
<dt class="hdlist1"><code>generate<em>SourceSet</em>GrammarSource</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.antlr.AntlrTask.html">AntlrTask</a></dt>
<dd>
<p>为给定源集的所有ANTLR语法生成源文件。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>ANTLR插件将以下依赖项添加到Java插件添加的任务中。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表20。ANTLR插件-其他任务依赖项</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">任务名称</th>
<th class="tableblock halign-left valign-top">依赖于取决于</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>compileJava</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>generateGrammarSource</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>compileTestJava</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>generateTestGrammarSource</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>compile<em>SourceSet</em>Java</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>generate<em>SourceSet</em>GrammarSource</code></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:antlr_project_layout"><a class="anchor" href="#sec:antlr_project_layout"></a> <a class="link" href="#sec:antlr_project_layout">项目布局</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/main/antlr</code></dt>
<dd>
<p>生产ANTLR语法文件。如果ANTLR语法以包形式组织，则antlr文件夹中的结构应反映包的结构。这样可以确保生成的源最终位于正确的目标子文件夹中。</p>
</dd>
<dt class="hdlist1"><code>src/test/antlr</code></dt>
<dd>
<p>测试ANTLR语法文件。</p>
</dd>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/antlr</code></dt>
<dd>
<p>给定源集的ANTLR语法文件。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:antlr_dependency_management"><a class="anchor" href="#sec:antlr_dependency_management"></a> <a class="link" href="#sec:antlr_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>ANTLR插件添加了一个<code>antlr</code>依赖性配置，提供要使用的ANTLR实现。以下示例显示了如何使用ANTLR版本3。</p>
</div>
<div class="exampleblock">
<div class="title">示例530声明ANTLR版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}

dependencies {
    antlr <span class="string"><span class="delimiter">&quot;</span><span class="content">org.antlr:antlr:3.5.2</span><span class="delimiter">&quot;</span></span> <span class="comment">// use ANTLR version 3</span>
    <span class="comment">// antlr &quot;org.antlr:antlr4:4.5&quot; // use ANTLR version 4</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}

dependencies {
    antlr(&quot;org.antlr:antlr:3.5.2&quot;)   // use ANTLR version 3
    // antlr(&quot;org.antlr:antlr4:4.5&quot;) // use ANTLR version 4
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有声明依赖项， <code>antlr:antlr:2.7.7</code>将用作默认值。要使用其他ANTLR版本，请将适当的依赖项添加到<code>antlr</code>依赖项配置如上。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:antlr_convention_properties"><a class="anchor" href="#sec:antlr_convention_properties"></a> <a class="link" href="#sec:antlr_convention_properties">公约属性</a></h4>
<div class="paragraph">
<p>ANTLR插件不添加任何约定属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:antlr_source_set_properties"><a class="anchor" href="#sec:antlr_source_set_properties"></a> <a class="link" href="#sec:antlr_source_set_properties">源集属性</a></h4>
<div class="paragraph">
<p>ANTLR插件将以下属性添加到项目中的每个源集。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>antlr</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a></dt>
<dd>
<p>此源集的ANTLR语法文件。包含所有<code>.g</code>要么<code>.g4</code> ANTLR源目录中找到的文件，不包括所有其他类型的文件。<em>默认值为非空。</em></p>
</dd>
<dt class="hdlist1"><code>antlr.srcDirs</code> -<code>Set<File></code></dt>
<dd>
<p>包含此源集的ANTLR语法文件的源目录。可以使用任何<a href="#sec:specifying_multiple_files">隐式转换为文件集合的方法进行设置</a> 。默认值为<code>[<em>projectDir</em>/src/<em>name</em>/antlr]</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:controlling_the_antlr_generator_process"><a class="anchor" href="#sec:controlling_the_antlr_generator_process"></a> <a class="link" href="#sec:controlling_the_antlr_generator_process">控制ANTLR生成器过程</a></h4>
<div class="paragraph">
<p>ANTLR工具在分支过程中执行。这样可以对ANTLR进程的内存设置进行精细控制。要设置ANTLR进程的堆大小，请<code>maxHeapSize</code>可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.antlr.AntlrTask.html">AntlrTask的</a>属性。要传递其他命令行参数，请附加到<code>arguments</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.antlr.AntlrTask.html">AntlrTask的</a>属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例531设置ANTLR的自定义最大堆大小和额外参数</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">generateGrammarSource {
    maxHeapSize = <span class="string"><span class="delimiter">&quot;</span><span class="content">64m</span><span class="delimiter">&quot;</span></span>
    arguments += [<span class="string"><span class="delimiter">&quot;</span><span class="content">-visitor</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">-long-messages</span><span class="delimiter">&quot;</span></span>]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.generateGrammarSource {
    maxHeapSize = &quot;64m&quot;
    arguments = arguments + listOf(&quot;-visitor&quot;, &quot;-long-messages&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="application_plugin"><a class="anchor" href="#application_plugin"></a> <a class="link" href="#application_plugin">应用插件</a></h3>
<div class="paragraph">
<p>应用程序插件有助于创建可执行的JVM应用程序。它使在开发过程中本地启动应用程序变得容易，并且可以将应用程序打包为TAR和/或ZIP，包括特定于操作系统的启动脚本。</p>
</div>
<div class="paragraph">
<p>应用Application插件也隐式应用<a href="#java_plugin">Java插件</a> 。的<code>main</code>源集实际上是“应用程序”。</p>
</div>
<div class="paragraph">
<p>应用Application插件还隐式应用<a href="#distribution_plugin">Distribution插件</a> 。一种<code>main</code>创建的分发包将应用程序打包，包括代码依赖性和生成的启动脚本。</p>
</div>
<div class="sect3">
<h4 id="sec:application_usage"><a class="anchor" href="#sec:application_usage"></a> <a class="link" href="#sec:application_usage">用法</a></h4>
<div class="paragraph">
<p>要使用应用程序插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例532使用应用程序插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">application</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    application
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>插件的唯一必需配置是应用程序的主类（即入口点）的规范。</p>
</div>
<div class="exampleblock">
<div class="title">示例533配置应用程序主类</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    mainClassName = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample.Main</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    mainClassName = &quot;org.gradle.sample.Main&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过执行<code>run</code>任务（类型： <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/JavaExec.html">JavaExec</a> ）。这将编译主源集，并使用指定的主类启动一个新的JVM，并将其类（以及所有运行时依赖项）作为类路径。您可以使用以下命令在调试模式下启动应用程序： <code>gradle run --debug-jvm</code> （请参阅<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/JavaExec.html#setDebug-boolean-">JavaExec.setDebug（boolean）</a> ）。</p>
</div>
<div class="paragraph">
<p>从Gradle 4.9开始，命令行参数可以与<code>--args</code> 。例如，如果要使用命令行参数启动应用程序<code>foo --bar</code> ， 您可以使用<code>gradle run --args="foo --bar"</code> （请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/JavaExec.html#setArgsString-java.lang.String-">JavaExec.setArgsString（java.lang。字符串）</a> 。</p>
</div>
<div class="paragraph">
<p>如果您的应用程序需要一组特定的JVM设置或系统属性，则可以配置<code>applicationDefaultJvmArgs</code>属性。这些JVM参数适用于<code>run</code>任务，并已在您的发行版的生成的启动脚本中考虑。</p>
</div>
<div class="exampleblock">
<div class="title">示例534配置默认的JVM设置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    applicationDefaultJvmArgs = [<span class="string"><span class="delimiter">'</span><span class="content">-Dgreeting.language=en</span><span class="delimiter">'</span></span>]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    applicationDefaultJvmArgs = listOf(&quot;-Dgreeting.language=en&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序的启动脚本应位于与以下目录不同的目录中<code>bin</code> ，您可以配置<code>executableDir</code>属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例535配置启动脚本的自定义目录</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    executableDir = <span class="string"><span class="delimiter">'</span><span class="content">custom_bin_dir</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    executableDir = &quot;custom_bin_dir&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:the_distribution"><a class="anchor" href="#sec:the_distribution"></a> <a class="link" href="#sec:the_distribution">分布</a></h5>
<div class="paragraph">
<p>可以通过<a href="#distribution_plugin">Distribution插件</a> （自动应用）创建应用程序的<a href="#distribution_plugin">发行版</a> 。一种<code>main</code>使用以下内容创建发行版：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表21。发行内容</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">地点</th>
<th class="tableblock halign-left valign-top">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（根目录）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>src/dist</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lib</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有运行时依赖项和主要的源集类文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bin</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启动脚本（由<code>startScripts</code>任务）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要添加到分发中的静态文件可以简单地添加到<code>src/dist</code> 。通过配置主发行版提供的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/CopySpec.html">CopySpec，</a>可以完成更高级的自定义。</p>
</div>
<div class="exampleblock">
<div class="title">示例536在应用程序分发中包括其他任务的输出</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task createDocs {
    <span class="keyword">def</span> docs = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/docs</span><span class="delimiter">&quot;</span></span>)
    outputs.dir docs
    doLast {
        docs.mkdirs()
        <span class="keyword">new</span> <span class="predefined-type">File</span>(docs, <span class="string"><span class="delimiter">'</span><span class="content">readme.txt</span><span class="delimiter">'</span></span>).write(<span class="string"><span class="delimiter">'</span><span class="content">Read me!</span><span class="delimiter">'</span></span>)
    }
}

distributions {
    main {
        contents {
            from(createDocs) {
                into <span class="string"><span class="delimiter">'</span><span class="content">docs</span><span class="delimiter">'</span></span>
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val createDocs by tasks.registering {
    val docs = file(&quot;$buildDir/docs&quot;)
    outputs.dir(docs)
    doLast {
        docs.mkdirs()
        File(docs, &quot;readme.txt&quot;).writeText(&quot;Read me!&quot;)
    }
}

distributions {
    main {
        contents {
            from(createDocs) {
                into(&quot;docs&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过指定发行版应包含任务的输出文件（请参阅<a href="#sec:task_inputs_outputs">关于</a> task的<a href="#sec:task_inputs_outputs">更多信息</a> ），Gradle知道在组装发行版之前必须先调用生成文件的任务，并将为您解决这一问题。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_automatically_creating_files_for_distribution"><a class="anchor" href="#example_automatically_creating_files_for_distribution"></a> <a class="link" href="#example_automatically_creating_files_for_distribution">示例：自动创建要分发的文件</a></h5>
<div class="listingblock">
<div class="title">输出<code>gradle distZip</code></div>
<div class="content">
<pre>&gt; gradle distZip
&gt; Task :createDocs
&gt; Task :compileJava
&gt; Task :processResources NO-SOURCE
&gt; Task :classes
&gt; Task :jar
&gt; Task :startScripts
&gt; Task :distZip

BUILD SUCCESSFUL in 0s
5 actionable tasks: 5 executed</pre>
</div>
</div>
<div class="paragraph">
<p>你可以跑<code>gradle installDist</code>在中创建应用程序的映像<code>build/install/<em>projectName</em></code> 。你可以跑<code>gradle distZip</code>创建一个包含发行版的ZIP， <code>gradle distTar</code>创建应用程序TAR或<code>gradle assemble</code>建立两者。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:customizing_start_script_generation"><a class="anchor" href="#sec:customizing_start_script_generation"></a> <a class="link" href="#sec:customizing_start_script_generation">自定义启动脚本生成</a></h5>
<div class="paragraph">
<p>该应用程序插件可以立即生成Unix（适用于Linux，macOS等）和Windows启动脚本。启动脚本使用定义为原始构建和运行时环境一部分的指定设置启动JVM（例如<code>JAVA_OPTS</code> env var）。默认脚本模板基于用于启动Gradle本身的相同脚本，这些脚本作为Gradle发行版的一部分提供。</p>
</div>
<div class="paragraph">
<p>启动脚本是完全可定制的。请参阅<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.jvm.application.tasks.CreateStartScripts.html">CreateStartScripts</a>文档以获取更多详细信息和自定义示例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:application_tasks"><a class="anchor" href="#sec:application_tasks"></a> <a class="link" href="#sec:application_tasks">任务</a></h4>
<div class="paragraph">
<p>Application插件将以下任务添加到项目中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>run</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.JavaExec.html">JavaExec</a></dt>
<dd>
<p><em>取决于</em> ：<code>classes</code></p>
<div class="paragraph">
<p>启动应用程序。</p>
</div>
</dd>
<dt class="hdlist1"><code>startScripts</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.jvm.application.tasks.CreateStartScripts.html">CreateStartScripts</a></dt>
<dd>
<p><em>取决于</em> ：<code>jar</code></p>
<div class="paragraph">
<p>创建特定于OS的脚本以将项目作为JVM应用程序运行。</p>
</div>
</dd>
<dt class="hdlist1"><code>installDist</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Sync.html">同步</a></dt>
<dd>
<p><em>取决于</em> ： <code>jar</code> ，<code>startScripts</code></p>
<div class="paragraph">
<p>将应用程序安装到指定目录。</p>
</div>
</dd>
<dt class="hdlist1"><code>distZip</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">邮编</a></dt>
<dd>
<p><em>取决于</em> ： <code>jar</code> ，<code>startScripts</code></p>
<div class="paragraph">
<p>创建完整的分发ZIP存档，包括运行时库和特定于操作系统的脚本。</p>
</div>
</dd>
<dt class="hdlist1"><code>distTar</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Tar.html">焦油</a></dt>
<dd>
<p><em>取决于</em> ： <code>jar</code> ，<code>startScripts</code></p>
<div class="paragraph">
<p>创建完整的发行版TAR归档文件，包括运行时库和特定于OS的脚本。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:application_extension"><a class="anchor" href="#sec:application_extension"></a> <a class="link" href="#sec:application_extension">应用扩展</a></h4>
<div class="paragraph">
<p>应用程序插件将扩展添加到项目中，您可以使用它来配置其行为。有关扩展中可用属性的更多信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.JavaApplication.html">JavaApplication</a> DSL文档。</p>
</div>
<div class="paragraph">
<p>您可以通过<code>application {}</code>前面显示的块，例如在构建脚本中使用以下代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">application {
    executableDir = <span class="string"><span class="delimiter">'</span><span class="content">custom_bin_dir</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application {
    executableDir = &quot;custom_bin_dir&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:application_licensing"><a class="anchor" href="#sec:application_licensing"></a> <a class="link" href="#sec:application_licensing">发牌</a></h4>
<div class="paragraph">
<p>与您的应用程序捆绑在一起的Gradle启动脚本已获得<a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0软件许可的许可</a> 。这不会影响您的应用程序，您可以选择许可该应用程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:application_convention_properties"><a class="anchor" href="#sec:application_convention_properties"></a> <a class="link" href="#sec:application_convention_properties">约定属性（已弃用）</a></h4>
<div class="paragraph">
<p>该插件还向项目添加了一些约定属性，您可以使用它们来配置其行为。这些<strong>已</strong>被上述扩展<strong>弃用</strong>并被其取代。请参阅<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#N14FED">Project</a> DSL文档以获取有关它们的信息。</p>
</div>
<div class="paragraph">
<p>与扩展属性不同，这些属性在构建脚本中显示为顶级项目属性。例如，要更改应用程序名称，您可以将以下内容添加到构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">applicationName = <span class="string"><span class="delimiter">'</span><span class="content">my-app</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">application.applicationName = &quot;my-app&quot;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="base_plugin"><a class="anchor" href="#base_plugin"></a> <a class="link" href="#base_plugin">基础插件</a></h3>
<div class="paragraph">
<p>基本插件提供了大多数构建中共有的一些任务和约定，并向构建中添加了一个结构，以提高其运行方式的一致性。它最重要的贡献是一组<a href="#sec:lifecycle_tasks"><em>生命周期</em>任务</a> ，这些<a href="#sec:lifecycle_tasks">任务</a>充当其他插件和构建作者提供的更具体任务的保护伞。</p>
</div>
<div class="sect3">
<h4 id="sec:base_plugin_usage"><a class="anchor" href="#sec:base_plugin_usage"></a> <a class="link" href="#sec:base_plugin_usage">用法</a></h4>
<div class="exampleblock">
<div class="title">示例537。应用基础插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">base</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    base
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:base_tasks"><a class="anchor" href="#sec:base_tasks"></a> <a class="link" href="#sec:base_tasks">任务</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>clean</code> -<code>Delete</code></dt>
<dd>
<p>删除构建目录及其中的所有内容，即由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildDir">Project.getBuildDir（）</a>项目属性指定的路径。</p>
</dd>
<dt class="hdlist1"><code>check</code> — <em>生命周期任务</em></dt>
<dd>
<p>插件和构建作者应使用以下方法将此生命周期任务附加其验证任务（例如运行测试的任务） <code>check.dependsOn(<em>task</em>)</code> 。</p>
</dd>
<dt class="hdlist1"><code>assemble</code> — <em>生命周期任务</em></dt>
<dd>
<p>插件和构建作者应将产生发行版和其他易用工件的任务附加到此生命周期任务。例如， <code>jar</code>产生Java库的消耗品。使用以下命令将任务附加到此生命周期任务<code>assemble.dependsOn(<em>task</em>)</code> 。</p>
</dd>
<dt class="hdlist1"><code>build</code> — <em>生命周期任务</em></dt>
<dd>
<p><em>取决于</em> ： <code>check</code> ，<code>assemble</code></p>
<div class="paragraph">
<p>旨在构建所有内容，包括运行所有测试，生成生产工件和生成文档。您可能很少会直接将具体任务附加到<code>build</code>如<code>assemble</code>和<code>check</code>通常更合适。</p>
</div>
</dd>
<dt class="hdlist1"><code>build<em>Configuration</em></code> —任务规则</dt>
<dd>
<p>组装那些附加到指定配置的工件。例如， <code>buildArchives</code>将执行创建附加到工件的任何工件所需的任何任务。 <code>archives</code>组态。</p>
</dd>
<dt class="hdlist1"><code>upload<em>Configuration</em></code> —任务规则</dt>
<dd>
<p>与...相同<code>build<em>Configuration</em></code> ，但还会上传附加到给定配置的所有工件。</p>
</dd>
<dt class="hdlist1"><code>clean<em>Task</em></code> —任务规则</dt>
<dd>
<p>删除任务的已<a href="#sec:task_inputs_outputs">定义输出</a> ，例如<code>cleanJar</code>将删除由<code>jar</code> Java插件的任务。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:base_plugin_configurations"><a class="anchor" href="#sec:base_plugin_configurations"></a> <a class="link" href="#sec:base_plugin_configurations">依赖管理</a></h4>
<div class="paragraph">
<p>基本插件未添加任何<a href="#sec:what-are-dependency-configurations">依赖项配置</a> ，但确实为<a href="artifact_management.html#sec:artifacts_and_configurations">工件</a>添加了以下配置：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>default</code></dt>
<dd>
<p>消费者项目使用的后备配置。假设您有一个项目B，该<a href="#sub:project_dependencies">项目</a>对项目A具有<a href="#sub:project_dependencies">项目依赖性</a> 。Gradle使用一些内部逻辑来确定将项目A的工件和依赖性添加到项目B的指定配置中。如果没有其他因素适用，那么您不需要担心这些是什么-然后Gradle退回到使用项目A的所有内容<code>default</code>组态。</p>
<div class="paragraph">
<p><strong>新的版本和插件不应该使用<code>default</code>组态！</strong> 保留它是为了向后兼容。</p>
</div>
</dd>
<dt class="hdlist1"><code>archives</code></dt>
<dd>
<p>项目生产工件的标准配置。这导致<code>uploadArchives</code>发布附加到工件的工件的任务<code>archives</code>组态。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>请注意<code>assemble</code>任务会生成所有附加到<code>archives</code>组态。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:base_plugin_conventions"><a class="anchor" href="#sec:base_plugin_conventions"></a> <a class="link" href="#sec:base_plugin_conventions">约定</a></h4>
<div class="paragraph">
<p>基本插件仅添加与创建档案有关的约定，例如ZIP，TAR和JAR。具体来说，它提供了可以设置的以下项目属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>archivesBaseName</code> —默认值：<code>$project.name</code></dt>
<dd>
<p>为存档任务提供默认的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html#org.gradle.api.tasks.bundling.AbstractArchiveTask:archiveBaseName">AbstractArchiveTask.getArchiveBaseName（）</a> 。</p>
</dd>
<dt class="hdlist1"><code>distsDirName</code> —默认值： <em>分布</em></dt>
<dd>
<p>创建分发归档文件（即非JAR）的目录的默认名称。</p>
</dd>
<dt class="hdlist1"><code>libsDirName</code> —默认值： <em>libs</em></dt>
<dd>
<p>创建库归档文件（即JAR）的目录的默认名称。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>该插件还为扩展<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html">AbstractArchiveTask的</a>任何任务提供以下属性的默认值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>destinationDirectory</code></dt>
<dd>
<p>默认为<em><code>$buildDir</code> / <code>$distsDirName</code></em>对于非JAR档案，以及<em><code>$buildDir</code> / <code>$libsDirName</code></em>适用于JAR和JAR派生产品，例如WAR。</p>
</dd>
<dt class="hdlist1"><code>archiveVersion</code></dt>
<dd>
<p>默认为<code>$project.version</code>如果项目没有版本，则为“未指定”。</p>
</dd>
<dt class="hdlist1"><code>archiveBaseName</code></dt>
<dd>
<p>默认为<code>$archivesBaseName</code> 。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build_init_plugin"><a class="anchor" href="#build_init_plugin"></a> <a class="link" href="#build_init_plugin">构建初始化插件</a></h3>
<div class="paragraph">
<p>Build Init插件可用于创建新的Gradle构建。它支持创建各种类型的全新Gradle构建，以及将现有的Apache Maven构建转换为Gradle。</p>
</div>
<div class="sect3">
<h4 id="supported_gradle_build_types"><a class="anchor" href="#supported_gradle_build_types"></a> <a class="link" href="#supported_gradle_build_types">受支持的Gradle构建类型</a></h4>
<div class="paragraph">
<p>Build Init插件支持生成各种构建<em>类型</em> 。下面列出了这些内容，以下<a href="#sec:build_init_types">部分</a>提供了有关每种类型的更多详细信息。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表22。建立初始化类型</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:pom_maven_conversion">绒球</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将现有的Apache Maven构建转换为Gradle</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:basic">基本的</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">基本的，空的Gradle构建</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:java_application">Java应用程序</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用Java实现的命令行应用程序</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:java_gradle_plugin">java-gradle-plugin</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用Java实现的Gradle插件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:java_library">Java库</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:kotlin_application">Kotlin应用</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Kotlin / JVM中实现的命令行应用程序</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:kotlin_gradle_plugin">kotlin-gradle-plugin</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Kotlin / JVM中实现的Gradle插件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:kotlin_library">科特林图书馆</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kotlin / JVM库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:groovy_application">常规应用</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Groovy中实现的命令行应用程序</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:groovy_gradle_plugin">groovy-gradle-plugin</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Groovy中实现的Gradle插件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:groovy_library">常规库</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Groovy库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:scala_library">标量图书馆</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个Scala库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:cpp_application">cpp应用</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用C ++实现的命令行应用程序</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sec:cpp_library">cpp库</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个C ++库</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:build_init_tasks"><a class="anchor" href="#sec:build_init_tasks"></a> <a class="link" href="#sec:build_init_tasks">任务</a></h4>
<div class="paragraph">
<p>该插件将以下任务添加到项目中：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>init</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.buildinit.tasks.InitBuild.html">InitBuild</a></dt>
<dd>
<p><em>取决于</em> ：<code>wrapper</code></p>
<div class="paragraph">
<p>生成Gradle构建。</p>
</div>
</dd>
<dt class="hdlist1"><code>wrapper</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.wrapper.Wrapper.html">包装</a></dt>
<dd>
<p>生成Gradle包装器文件。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>通常，必须先将Gradle插件<em>应用于</em>项目，然后才能使用它们（请参阅<a href="#sec:using_plugins">使用插件</a> ）。但是，Build Init插件会自动应用于每个构建的根项目，这意味着您无需显式应用它即可使用它。您可以简单地执行名为<code>init</code>在您要创建Gradle构建的目录中。无需创建“存根” <code>build.gradle</code>文件以应用插件。</p>
</div>
<div class="paragraph">
<p>Build Init插件还使用<code>wrapper</code>任务来<a href="#sec:adding_wrapper">生成</a>用于构建<a href="#sec:adding_wrapper">的Gradle Wrapper文件</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:what_to_set_up"><a class="anchor" href="#sec:what_to_set_up"></a> <a class="link" href="#sec:what_to_set_up">创建什么</a></h4>
<div class="paragraph">
<p>推荐使用的最简单方法<code>init</code>任务是运行<code>gradle init</code>从交互式控制台。Gradle将列出可用的构建类型，并要求您选择一种。然后，它将询问一些其他问题，以使您可以微调结果。</p>
</div>
<div class="paragraph">
<p>有几个命令行选项可用于<code>init</code>控制它将生成什么的任务。当Gradle不在交互式控制台上运行时，您可以使用它们。</p>
</div>
<div class="paragraph">
<p>可以使用<code>--type</code>命令行选项。例如，要创建一个Java库项目，请运行： <code>gradle init --type java-library</code> 。</p>
</div>
<div class="paragraph">
<p>如果一个<code>--type</code>选项未提供，Gradle将尝试从环境中推断类型。例如，它将推断出“ <code>pom</code> ”，如果找到<code>pom.xml</code>文件转换为Gradle版本。如果无法推断出类型，则“ <code>basic</code> “ 将会被使用。</p>
</div>
<div class="paragraph">
<p>的<code>init</code>该任务还支持使用Gradle Groovy DSL或Gradle Kotlin DSL生成构建脚本。对于大多数构建类型，构建脚本DSL默认为Groovy DSL，对于Kotlin构建类型，默认为Kotlin DSL。DSL可以通过使用<code>--dsl</code>命令行选项。例如，要使用Kotlin DSL构建脚本创建Java库项目，请运行： <code>gradle init --type java-library --dsl kotlin</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用来更改生成的项目的名称<code>--project-name</code>选项。它默认为目录名称， <code>init</code>任务运行。</p>
</div>
<div class="paragraph">
<p>您可以使用以下命令更改用于生成的源文件的软件包<code>--package</code>选项。默认为项目名称。</p>
</div>
<div class="paragraph">
<p>所有构建类型也都设置了Gradle包装器。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:build_init_types"><a class="anchor" href="#sec:build_init_types"></a> <a class="link" href="#sec:build_init_types">建立初始化类型</a></h4>
<div class="sect4">
<h5 id="sec:pom_maven_conversion"><a class="anchor" href="#sec:pom_maven_conversion"></a> <a class="link" href="#sec:pom_maven_conversion"><code>pom</code>构建类型（Maven转换）</a></h5>
<div class="paragraph">
<p>“ <code>pom</code> ”类型可用于将Apache Maven构建转换为Gradle构建。通过将POM转换为一个或多个Gradle文件来工作。只有在有效的“ <code>pom.xml</code> ”目录中的“ <code>init</code>在指定的项目目录中，或者通过“ -p” <a href="#command_line_interface">命令行选项</a>调用该任务。这个 ” <code>pom</code>如果存在这样的文件，则会自动推断出“”类型。</p>
</div>
<div class="paragraph">
<p>Maven转换实现的灵感来自最初由Gradle社区成员开发的<a href="https://github.com/jbaruch/maven2gradle">maven2gradle工具</a> 。</p>
</div>
<div class="paragraph">
<p>请注意，从Maven构建进行的迁移当前仅支持Groovy DSL用于生成的构建脚本。</p>
</div>
<div class="paragraph">
<p>转换过程具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用有效的POM和有效的设置（支持POM继承，依赖性管理，属性）</p>
</li>
<li>
<p>支持单模块和多模块项目</p>
</li>
<li>
<p>支持自定义模块名称（与目录名称不同）</p>
</li>
<li>
<p>生成常规元数据-ID，描述和版本</p>
</li>
<li>
<p>根据需要应用<a href="#">Maven Publish</a> ， <a href="#">Java</a>和<a href="#">War</a>插件</p>
</li>
<li>
<p>如果需要，将战争项目打包成罐子</p>
</li>
<li>
<p>生成依赖关系（外部和模块间）</p>
</li>
<li>
<p>生成下载存储库（包括本地Maven存储库）</p>
</li>
<li>
<p>调整Java编译器设置</p>
</li>
<li>
<p>支持源，测试和javadocs的打包</p>
</li>
<li>
<p>支持TestNG运行器</p>
</li>
<li>
<p>从Maven强制实施器插件设置生成全局排除</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:java_application"><a class="anchor" href="#sec:java_application"></a> <a class="link" href="#sec:java_application"><code>java-application</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>java-application</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>application</code> ”插件，以生成用Java实现的命令行应用程序</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用<a href="https://junit.org/junit4/">JUnit 4</a>进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含样本类和单元测试</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过提供一个替代测试框架来指定<code>--test-framework</code>参数值。要使用其他测试框架，请执行以下命令之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>gradle init --type java-application --test-framework junit-jupiter</code> ：使用<a href="https://junit.org">JUnit Jupiter</a>代替JUnit 4进行测试</p>
</li>
<li>
<p><code>gradle init --type java-application --test-framework spock</code> ：使用<a href="http://code.google.com/p/spock/">Spock</a>代替JUnit 4进行测试</p>
</li>
<li>
<p><code>gradle init --type java-application --test-framework testng</code> ：使用<a href="http://testng.org/doc/index.html">TestNG</a>代替JUnit 4进行测试</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:java_library"><a class="anchor" href="#sec:java_library"></a> <a class="link" href="#sec:java_library"><code>java-library</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>java-library</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>java</code> ”插件，以产生用Java实现的库</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用<a href="https://junit.org/junit4/">JUnit 4</a>进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含样本类和单元测试</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过提供一个替代测试框架来指定<code>--test-framework</code>参数值。要使用其他测试框架，请执行以下命令之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>gradle init --type java-library --test-framework junit-jupiter</code> ：使用<a href="https://junit.org">JUnit Jupiter</a>代替JUnit 4进行测试</p>
</li>
<li>
<p><code>gradle init --type java-library --test-framework spock</code> ：使用<a href="http://code.google.com/p/spock/">Spock</a>代替JUnit 4进行测试</p>
</li>
<li>
<p><code>gradle init --type java-library --test-framework testng</code> ：使用<a href="http://testng.org/doc/index.html">TestNG</a>代替JUnit 4进行测试</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:java_gradle_plugin"><a class="anchor" href="#sec:java_gradle_plugin"></a> <a class="link" href="#sec:java_gradle_plugin"><code>java-gradle-plugin</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>java-gradle-plugin</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>java-gradle-plugin</code> ”插件，以生成用Java实现的Gradle插件</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用<a href="https://junit.org/junit4/">JUnit 4</a>和TestKit进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含样本类和单元测试</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:kotlin_application"><a class="anchor" href="#sec:kotlin_application"></a> <a class="link" href="#sec:kotlin_application"><code>kotlin-application</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>kotlin-application</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>org.jetbrains.kotlin.jvm</code> ”和“ <code>application</code> “插件以生成在Kotlin中实现的命令行应用程序</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用Kotlin 1.x</p>
</li>
<li>
<p>使用<a href="https://kotlinlang.org/api/latest/kotlin.test/index.html">Kotlin测试库</a>进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含样本Kotlin类和关联的Kotlin测试类</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:kotlin_library"><a class="anchor" href="#sec:kotlin_library"></a> <a class="link" href="#sec:kotlin_library"><code>kotlin-library</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>kotlin-library</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>org.jetbrains.kotlin.jvm</code> ”插件，以产生在Kotlin中实现的库</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用Kotlin 1.x</p>
</li>
<li>
<p>使用<a href="https://kotlinlang.org/api/latest/kotlin.test/index.html">Kotlin测试库</a>进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含样本Kotlin类和关联的Kotlin测试类</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:kotlin_gradle_plugin"><a class="anchor" href="#sec:kotlin_gradle_plugin"></a> <a class="link" href="#sec:kotlin_gradle_plugin"><code>kotlin-gradle-plugin</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>kotlin-gradle-plugin</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>java-gradle-plugin</code> ”和“ <code>org.jetbrains.kotlin.jvm</code> ”插件，以产生在Kotlin中实现的Gradle插件</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用Kotlin 1.x</p>
</li>
<li>
<p>使用<a href="https://kotlinlang.org/api/latest/kotlin.test/index.html">Kotlin测试库</a>和TestKit进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含样本类和单元测试</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:scala_library"><a class="anchor" href="#sec:scala_library"></a> <a class="link" href="#sec:scala_library"><code>scala-library</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>scala-library</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>scala</code> ”插件以生成在Scala中实现的库</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用Scala 2.11</p>
</li>
<li>
<p>使用<a href="http://www.scalatest.org">ScalaTest</a>进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含一个示例Scala类和一个关联的ScalaTest测试套件</p>
</li>
<li>
<p>默认使用Zinc Scala编译器</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:groovy_library"><a class="anchor" href="#sec:groovy_library"></a> <a class="link" href="#sec:groovy_library"><code>groovy-library</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>groovy-library</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>groovy</code> ”插件以生成在Groovy中实现的库</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用Groovy 2.x</p>
</li>
<li>
<p>使用<a href="http://spockframework.org">Spock测试框架</a>进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含一个示例Groovy类和一个关联的Spock规范</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:groovy_application"><a class="anchor" href="#sec:groovy_application"></a> <a class="link" href="#sec:groovy_application"><code>groovy-application</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>groovy-application</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>application</code> ”和“ <code>groovy</code> ”插件以生成在Groovy中实现的命令行应用程序</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用Groovy 2.x</p>
</li>
<li>
<p>使用<a href="http://spockframework.org">Spock测试框架</a>进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含一个示例Groovy类和一个关联的Spock规范</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:groovy_gradle_plugin"><a class="anchor" href="#sec:groovy_gradle_plugin"></a> <a class="link" href="#sec:groovy_gradle_plugin"><code>groovy-gradle-plugin</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>groovy-gradle-plugin</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>java-gradle-plugin</code> ”和“ <code>groovy</code> ”插件以生成在Groovy中实现的Gradle插件</p>
</li>
<li>
<p>使用“ <code>jcenter</code> ”依赖库</p>
</li>
<li>
<p>使用Groovy 2.x</p>
</li>
<li>
<p>使用<a href="http://spockframework.org">Spock测试框架</a>和TestKit进行测试</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含样本类和单元测试</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:cpp_application"><a class="anchor" href="#sec:cpp_application"></a> <a class="link" href="#sec:cpp_application"><code>cpp-application</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>cpp-application</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>cpp-application</code> ”插件，以生成以C ++实现的命令行应用程序</p>
</li>
<li>
<p>使用“ <code>cpp-unit-test</code>用于构建和运行简单单元测试的插件</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含一个示例C ++类，一个私有头文件和一个相关的测试类</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:cpp_library"><a class="anchor" href="#sec:cpp_library"></a> <a class="link" href="#sec:cpp_library"><code>cpp-library</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>cpp-library</code> ”“构建类型不可推断。必须明确指定。</p>
</div>
<div class="paragraph">
<p>它具有以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用“ <code>cpp-library</code> ”产生C ++库的插件</p>
</li>
<li>
<p>使用“ <code>cpp-unit-test</code>用于构建和运行简单单元测试的插件</p>
</li>
<li>
<p>在常规位置具有目录以获取源代码</p>
</li>
<li>
<p>如果没有现有的源文件或测试文件，则包含一个示例C ++类，一个公共头文件和一个相关的测试类</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sec:basic"><a class="anchor" href="#sec:basic"></a> <a class="link" href="#sec:basic"><code>basic</code>构建类型</a></h5>
<div class="paragraph">
<p>“ <code>basic</code> ”构建类型对于创建新的Gradle构建很有用。它创建示例设置和构建文件，并带有注释和链接以帮助上手。</p>
</div>
<div class="paragraph">
<p>如果未明确指定任何类型，并且无法推断出任何类型，则使用此类型。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="checkstyle_plugin"><a class="anchor" href="#checkstyle_plugin"></a> <a class="link" href="#checkstyle_plugin">Checkstyle插件</a></h3>
<div class="paragraph">
<p>Checkstyle插件使用<a href="http://checkstyle.sourceforge.net/index.html">Checkstyle</a>对项目的Java源文件执行质量检查，并从这些检查生成报告。</p>
</div>
<div class="sect3">
<h4 id="sec:checkstyle_usage"><a class="anchor" href="#sec:checkstyle_usage"></a> <a class="link" href="#sec:checkstyle_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Checkstyle插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例538使用Checkstyle插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">checkstyle</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    checkstyle
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该插件向项目添加了许多执行质量检查的任务。您可以通过运行来执行检查<code>gradle check</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，Checkstyle将以与运行Gradle相同的Java版本运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:checkstyle_tasks"><a class="anchor" href="#sec:checkstyle_tasks"></a> <a class="link" href="#sec:checkstyle_tasks">任务</a></h4>
<div class="paragraph">
<p>Checkstyle插件将以下任务添加到项目中：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>checkstyleMain</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Checkstyle.html">Checkstyle</a></dt>
<dd>
<p><em>取决于</em> ：<code>classes</code></p>
<div class="paragraph">
<p>针对生产Java源文件运行Checkstyle。</p>
</div>
</dd>
<dt class="hdlist1"><code>checkstyleTest</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Checkstyle.html">Checkstyle</a></dt>
<dd>
<p><em>取决于</em> ：<code>testClasses</code></p>
<div class="paragraph">
<p>针对测试Java源文件运行Checkstyle。</p>
</div>
</dd>
<dt class="hdlist1"><code>checkstyle<em>SourceSet</em></code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Checkstyle.html">Checkstyle</a></dt>
<dd>
<p><em>取决于</em> ：<code><em>sourceSet</em>Classes</code></p>
<div class="paragraph">
<p>针对给定的源集的Java源文件运行Checkstyle。</p>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="dependencies_added_to_other_tasks"><a class="anchor" href="#dependencies_added_to_other_tasks"></a> <a class="link" href="#dependencies_added_to_other_tasks">依赖关系已添加到其他任务</a></h5>
<div class="paragraph">
<p>Checkstyle插件将以下依赖项添加到Java插件定义的任务中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>check</code></dt>
<dd>
<p><em>取决于</em> ：所有Checkstyle任务，包括<code>checkstyleMain</code>和<code>checkstyleTest</code> 。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:checkstyle_project_layout"><a class="anchor" href="#sec:checkstyle_project_layout"></a> <a class="link" href="#sec:checkstyle_project_layout">项目布局</a></h4>
<div class="paragraph">
<p>默认情况下，Checkstyle插件期望将配置文件放置在根项目中，但是可以更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;root&gt;
└── config
    └── checkstyle           // <b class="conum">(1)</b>
        └── checkstyle.xml   // <b class="conum">(2)</b>
        └── suppressions.xml</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Checkstyle配置文件转到此处</p>
</li>
<li>
<p>主要Checkstyle配置文件</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="sec:checkstyle_dependency_management"><a class="anchor" href="#sec:checkstyle_dependency_management"></a> <a class="link" href="#sec:checkstyle_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>Checkstyle插件添加了以下依赖项配置：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表23。Checkstyle插件-依赖项配置</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>checkstyle</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>要使用的Checkstyle库</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:checkstyle_configuration"><a class="anchor" href="#sec:checkstyle_configuration"></a> <a class="link" href="#sec:checkstyle_configuration">组态</a></h4>
<div class="paragraph">
<p>请参阅API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CheckstyleExtension.html">CheckstyleExtension</a>类。</p>
</div>
<div class="sect4">
<h5 id="sec:checkstyle_built_in_variables"><a class="anchor" href="#sec:checkstyle_built_in_variables"></a> <a class="link" href="#sec:checkstyle_built_in_variables">内置变量</a></h5>
<div class="paragraph">
<p>Checkstyle插件定义了一个<code>config_loc</code>可在Checkstyle配置文件中使用的属性来定义其他配置文件（如<code>suppressions.xml</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子539。使用config_loc属性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">checkstyle.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">SuppressionFilter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">file</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${config_loc}/suppressions.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/module&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:checkstyle_customize_xsl"><a class="anchor" href="#sec:checkstyle_customize_xsl"></a> <a class="link" href="#sec:checkstyle_customize_xsl">自定义HTML报告</a></h4>
<div class="paragraph">
<p>可以使用XSLT样式表自定义<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Checkstyle.html">Checkstyle</a>任务生成的HTML报告，例如突出显示特定错误或更改其外观：</p>
</div>
<div class="exampleblock">
<div class="title">示例540自定义HTML报告</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(Checkstyle) {
    reports {
        xml.enabled <span class="predefined-constant">false</span>
        html.enabled <span class="predefined-constant">true</span>
        html.stylesheet resources.text.fromFile(<span class="string"><span class="delimiter">'</span><span class="content">config/xsl/checkstyle-custom.xsl</span><span class="delimiter">'</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType&lt;Checkstyle&gt;().configureEach {
    reports {
        xml.isEnabled = false
        html.isEnabled = true
        html.stylesheet = resources.text.fromFile(&quot;config/xsl/checkstyle-custom.xsl&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/checkstyle/contribution/tree/master/xsl">查看示例Checkstyle样式表。</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="codenarc_plugin"><a class="anchor" href="#codenarc_plugin"></a> <a class="link" href="#codenarc_plugin">CodeNarc插件</a></h3>
<div class="paragraph">
<p>CodeNarc插件使用<a href="http://codenarc.sourceforge.net/index.html">CodeNarc</a>对项目的Groovy源文件执行质量检查，并从这些检查生成报告。</p>
</div>
<div class="sect3">
<h4 id="sec:codenarc_usage"><a class="anchor" href="#sec:codenarc_usage"></a> <a class="link" href="#sec:codenarc_usage">用法</a></h4>
<div class="paragraph">
<p>要使用CodeNarc插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例541使用CodeNarc插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">codenarc</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    codenarc
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该插件将一些任务添加到项目中，这些任务与<a href="#groovy_plugin">Groovy插件</a>一起使用时会执行质量检查。您可以通过运行来执行检查<code>gradle check</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:codenarc_tasks"><a class="anchor" href="#sec:codenarc_tasks"></a> <a class="link" href="#sec:codenarc_tasks">任务</a></h4>
<div class="paragraph">
<p>CodeNarc插件将以下任务添加到项目中：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>codenarcMain</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CodeNarc.html">CodeNarc</a></dt>
<dd>
<div class="paragraph">
<p>针对生产Java源文件运行CodeNarc。</p>
</div>
</dd>
<dt class="hdlist1"><code>codenarcTest</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CodeNarc.html">CodeNarc</a></dt>
<dd>
<div class="paragraph">
<p>针对测试Java源文件运行CodeNarc。</p>
</div>
</dd>
<dt class="hdlist1"><code>codenarc<em>SourceSet</em></code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CodeNarc.html">CodeNarc</a></dt>
<dd>
<div class="paragraph">
<p>针对给定的源集的Java源文件运行CodeNarc。</p>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="dependencies_added_to_other_tasks_2"><a class="anchor" href="#dependencies_added_to_other_tasks_2"></a> <a class="link" href="#dependencies_added_to_other_tasks_2">依赖关系已添加到其他任务</a></h5>
<div class="paragraph">
<p>CodeNarc插件将以下依赖项添加到Groovy插件定义的任务中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>check</code></dt>
<dd>
<p><em>取决于</em> ：所有CodeNarc任务，包括<code>codenarcMain</code>和<code>codenarcTest</code> 。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:codenarc_project_layout"><a class="anchor" href="#sec:codenarc_project_layout"></a> <a class="link" href="#sec:codenarc_project_layout">项目布局</a></h4>
<div class="paragraph">
<p>CodeNarc插件需要以下项目布局：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;root&gt;
└── config
    └── codenarc           // <b class="conum">(1)</b>
        └── codenarc.xml   // <b class="conum">(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>CodeNarc配置文件转到此处</p>
</li>
<li>
<p>主要CodeNarc配置文件</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="sec:codenarc_dependency_management"><a class="anchor" href="#sec:codenarc_dependency_management"></a> <a class="link" href="#sec:codenarc_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>CodeNarc插件添加了以下依赖项配置：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表24。CodeNarc插件-依赖项配置</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>codenarc</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>使用的CodeNarc库</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:codenarc_configuration"><a class="anchor" href="#sec:codenarc_configuration"></a> <a class="link" href="#sec:codenarc_configuration">组态</a></h4>
<div class="paragraph">
<p>请参阅API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.CodeNarcExtension.html">CodeNarcExtension</a>类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="distribution_plugin"><a class="anchor" href="#distribution_plugin"></a> <a class="link" href="#distribution_plugin">发行插件</a></h3>
<div class="paragraph">
<p>分发插件有助于构建用作项目分发的存档。发行档案通常包含可执行应用程序和其他支持文件，例如文档。</p>
</div>
<div class="sect3">
<h4 id="sec:distribution_usage"><a class="anchor" href="#sec:distribution_usage"></a> <a class="link" href="#sec:distribution_usage">用法</a></h4>
<div class="paragraph">
<p>要使用分发插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例542使用分发插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">distribution</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    distribution
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该插件添加了一个扩展名为<code>distributions</code>类型为项目的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.distribution.DistributionContainer.html">DistributionContainer</a> 。它还在名为的分发容器扩展中创建了一个分发<code>main</code> 。如果您的构建仅生成一个发行版，则只需配置此发行版（或使用默认设置）。</p>
</div>
<div class="paragraph">
<p>你可以跑<code>gradle distZip</code>将主发行版打包为ZIP，或者<code>gradle distTar</code>创建一个TAR文件。要构建两种类型的档案，只需运行<code>gradle assembleDist</code> 。文件将在以下位置创建<code><em>$buildDir</em>/distributions/<em>${project.name}</em>-<em>${project.version}</em>.<em>«ext»</em></code> 。</p>
</div>
<div class="paragraph">
<p>你可以跑<code>gradle installDist</code>将未压缩的发行版组装成<code><em>$buildDir</em>/install/<em>${project.name}</em></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:distribution_tasks"><a class="anchor" href="#sec:distribution_tasks"></a> <a class="link" href="#sec:distribution_tasks">任务</a></h4>
<div class="paragraph">
<p>分发插件将许多任务添加到您的项目中，如下所示。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>distZip</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">邮编</a></dt>
<dd>
<p>创建分发内容的ZIP存档。</p>
</dd>
<dt class="hdlist1"><code>distTar</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html">任务</a></dt>
<dd>
<p>创建分发内容的TAR归档。</p>
</dd>
<dt class="hdlist1"><code>assembleDist</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html">任务</a></dt>
<dd>
<p><em>取决于</em> ： <code>distTar</code> ，<code>distZip</code></p>
<div class="paragraph">
<p>创建分发内容的ZIP和TAR存档。</p>
</div>
</dd>
<dt class="hdlist1"><code>installDist</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Sync.html">同步</a></dt>
<dd>
<p>组装分发内容并将其安装在当前计算机上。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>对于添加到项目中的每个其他分发，分发插件都会添加以下任务，其中<em>distributionName</em>来自<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/distribution/Distribution.html#getName--">Distribution.getName（）</a> ：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><em>distributionName</em>DistZip</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">邮编</a></dt>
<dd>
<p>创建分发内容的ZIP存档。</p>
</dd>
<dt class="hdlist1"><code><em>distributionName</em>DistTar</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Tar.html">焦油</a></dt>
<dd>
<p>创建分发内容的TAR归档。</p>
</dd>
<dt class="hdlist1"><code>assemble<em>DistributionName</em>Dist</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html">任务</a></dt>
<dd>
<p><em>取决于</em> ： <code><em>distributionName</em>DistTar</code> ，<code><em>distributionName</em>DistZip</code></p>
<div class="paragraph">
<p>创建分发内容的ZIP和TAR存档。</p>
</div>
</dd>
<dt class="hdlist1"><code>install<em>DistributionName</em>Dist</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Sync.html">同步</a></dt>
<dd>
<p>组装分发内容并将其安装在当前计算机上。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下示例创建了一个<code>custom</code>分发，这将导致将四个其他任务添加到项目中： <code>customDistZip</code> ， <code>customDistTar</code> ， <code>assembleCustomDist</code>和<code>installCustomDist</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例543添加额外的发行版</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">distributions {
    custom {
        <span class="comment">// configure custom distribution</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">distributions {
    create(&quot;custom&quot;) {
        // configure custom distribution
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>鉴于项目名称为<code>myproject</code>和版本<code>1.2</code> ，正在运行<code>gradle customDistZip</code>将产生一个名为<code>myproject-custom-1.2.zip</code> 。</p>
</div>
<div class="paragraph">
<p>跑步<code>gradle installCustomDist</code>将分发内容安装到<code><em>$buildDir</em>/install/custom</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:distribution_contents"><a class="anchor" href="#sec:distribution_contents"></a> <a class="link" href="#sec:distribution_contents">发行内容</a></h4>
<div class="paragraph">
<p>的所有文件<code>src/<em>$distribution.name</em>/dist</code>目录将自动包含在分发中。您可以通过配置容器中的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/distribution/Distribution.html">分发</a>对象来添加其他文件。</p>
</div>
<div class="exampleblock">
<div class="title">示例544配置主发行版</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">distributions {
    main {
        distributionBaseName = <span class="string"><span class="delimiter">'</span><span class="content">someName</span><span class="delimiter">'</span></span>
        contents {
            from <span class="string"><span class="delimiter">'</span><span class="content">src/readme</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">distributions {
    main {
        distributionBaseName.set(&quot;someName&quot;)
        contents {
            from(&quot;src/readme&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中， <code>src/readme</code>目录将包含在分发中（以及<code>src/main/dist</code>目录（默认情况下添加）。</p>
</div>
<div class="paragraph">
<p>的<code>baseName</code>属性也已更改。这将导致使用不同的名称创建分发存档。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:publishing_distributions"><a class="anchor" href="#sec:publishing_distributions"></a> <a class="link" href="#sec:publishing_distributions">出版</a></h4>
<div class="paragraph">
<p>发行版可以使用<a href="#publishing_ivy">Ivy Publish Plugin</a>或<a href="#publishing_maven">Maven Publish Plugin进行发布</a> ，也可以使用<em>原始</em>发布机制使用<code>uploadArchives</code>任务。</p>
</div>
<div class="sect4">
<h5 id="sec:publishing_distributions_publish_plugins"><a class="anchor" href="#sec:publishing_distributions_publish_plugins"></a> <a class="link" href="#sec:publishing_distributions_publish_plugins">使用Ivy / Maven发布插件</a></h5>
<div class="paragraph">
<p>要使用<a href="#publishing_ivy">Ivy Publish插件</a>将发行版发布到Ivy存储库，只需将其一个或两个存档任务添加到<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html">IvyPublication</a> 。以下示例演示了如何添加<code>main</code>的发行和TAR档案<code>custom</code>分配给<code>myDistribution</code>出版物：</p>
</div>
<div class="exampleblock">
<div class="title">示例545将发行档案添加到常春藤出版物中</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">ivy-publish</span><span class="delimiter">'</span></span>
}

publishing {
    publications {
        myDistribution(IvyPublication) {
            artifact distZip
            artifact customDistTar
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `ivy-publish`
}

publishing {
    publications {
        create&lt;IvyPublication&gt;(&quot;myDistribution&quot;) {
            artifact(tasks.distZip.get())
            artifact(tasks[&quot;customDistTar&quot;])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，要使用<a href="#publishing_maven">Maven Publish Plugin</a>将发行版本发布到Maven存储库， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">请</a>按如下所示将其一个或两个存档任务添加到<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">MavenPublication</a>中：</p>
</div>
<div class="exampleblock">
<div class="title">示例546将分发存档添加到Maven发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">maven-publish</span><span class="delimiter">'</span></span>
}

publishing {
    publications {
        myDistribution(MavenPublication) {
            artifact distZip
            artifact customDistTar
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `maven-publish`
}

publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;myDistribution&quot;) {
            artifact(tasks.distZip.get())
            artifact(tasks[&quot;customDistTar&quot;])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:publishing_distributions_upload"><a class="anchor" href="#sec:publishing_distributions_upload"></a> <a class="link" href="#sec:publishing_distributions_upload">使用<code>uploadArchives</code>任务</a></h5>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>uploadArchives</code>和<code>maven</code>插件已弃用。您应该使用<code>ivy-publish</code>要么<code>maven-publish</code>插件代替。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>发行插件将发行档案添加为默认发布工件候选。应用<a href="#maven_plugin">Maven插件后</a> ，运行时将发布分发ZIP文件<code>uploadArchives</code>如果未配置其他默认工件。</p>
</div>
<div class="exampleblock">
<div class="title">示例547使用Maven插件发布发行版ZIP</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">maven</span><span class="delimiter">'</span></span>
}

uploadArchives {
    repositories {
        mavenDeployer {
            repository(<span class="key">url</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">file://some/repo</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    maven
}

tasks.named&lt;Upload&gt;(&quot;uploadArchives&quot;) {
    repositories.withGroovyBuilder {
        &quot;mavenDeployer&quot; {
            &quot;repository&quot;(&quot;url&quot; to &quot;file://some/repo&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ear_plugin"><a class="anchor" href="#ear_plugin"></a> <a class="link" href="#ear_plugin">耳塞</a></h3>
<div class="paragraph">
<p>Ear插件增加了对组装Web应用程序EAR文件的支持。它添加了一个默认的EAR归档任务。它不需要<a href="#">Java插件</a> ，但是对于也使用Java插件的项目，它将禁用默认的JAR存档生成。</p>
</div>
<div class="sect3">
<h4 id="sec:ear_usage"><a class="anchor" href="#sec:ear_usage"></a> <a class="link" href="#sec:ear_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Ear插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例548使用Ear插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">ear</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    ear
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:ear_tasks"><a class="anchor" href="#sec:ear_tasks"></a> <a class="link" href="#sec:ear_tasks">任务</a></h4>
<div class="paragraph">
<p>Ear插件将以下任务添加到项目中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ear</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ear.Ear.html">耳朵</a></dt>
<dd>
<p><em>取决于</em> ： <code>compile</code> （仅当还应用了Java插件时）</p>
<div class="paragraph">
<p>组装应用程序EAR文件。</p>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="dependencies_added_to_other_tasks_3"><a class="anchor" href="#dependencies_added_to_other_tasks_3"></a> <a class="link" href="#dependencies_added_to_other_tasks_3">依赖关系已添加到其他任务</a></h5>
<div class="paragraph">
<p>Ear插件将以下依赖项添加到<a href="#base_plugin">基本插件</a>添加的任务中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>assemble</code></dt>
<dd>
<p><em>取决于</em> ： <code>ear</code> 。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:ear_project_layout"><a class="anchor" href="#sec:ear_project_layout"></a> <a class="link" href="#sec:ear_project_layout">项目布局</a></h4>
<div class="listingblock">
<div class="content">
<pre>.
└── src
    └── main
        └── application // <b class="conum">(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>耳朵资源，例如META-INF目录</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="sec:ear_dependency_management"><a class="anchor" href="#sec:ear_dependency_management"></a> <a class="link" href="#sec:ear_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>Ear插件添加了两个依赖项配置： <code>deploy</code>和<code>earlib</code> 。中的所有依赖项<code>deploy</code>配置被放置在EAR归档文件的根目录中，并且<em>不能</em>传递。中的所有依赖项<code>earlib</code>配置放置在EAR归档文件的“ lib”目录中，并且<em>是可</em>传递的。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:ear_convention_properties"><a class="anchor" href="#sec:ear_convention_properties"></a> <a class="link" href="#sec:ear_convention_properties">公约属性</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>appDirName</code> -<code>String</code></dt>
<dd>
<p>应用程序源目录的名称，相对于项目目录。<em>默认值：`src / main / application`</em> 。</p>
</dd>
<dt class="hdlist1"><code>libDirName</code> -<code>String</code></dt>
<dd>
<p>生成的EAR中的lib目录的名称。 <em>默认值：`lib`</em> 。</p>
</dd>
<dt class="hdlist1"><code>deploymentDescriptor</code> — <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ear/descriptor/DeploymentDescriptor.html">DeploymentDescriptor</a></dt>
<dd>
<p>用于生成部署描述符文件的元数据，例如<code>application.xml</code> 。<em>缺省值：名为明智的缺省值的部署描述符<code>application.xml`</code></em> <code>. If this file already exists in the `appDirName/META-INF</code>那么将使用现有文件内容，并在<code>ear.deploymentDescriptor</code>将被忽略。</p>
</dd>
<dt class="hdlist1"><code>generateDeploymentDescriptor</code> -<code>Boolean</code></dt>
<dd>
<p>指定是否应生成DeploymentDescriptor。<em>默认值：true</em> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这些属性由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ear.EarPluginConvention.html">EarPluginConvention</a>约定对象提供。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:ear_default_settings"><a class="anchor" href="#sec:ear_default_settings"></a> <a class="link" href="#sec:ear_default_settings">耳</a></h4>
<div class="paragraph">
<p>Ear任务的默认行为是复制以下内容： <code>src/main/application</code>到档案的根目录。如果你的<code>application</code>目录不包含<code>META-INF/application.xml</code>部署描述符，然后将为您生成一个。</p>
</div>
<div class="paragraph">
<p>API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ear.Ear.html">Ear</a>类具有其他有用的信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:ear_customizing"><a class="anchor" href="#sec:ear_customizing"></a> <a class="link" href="#sec:ear_customizing">客制化</a></h4>
<div class="paragraph">
<p>这是最重要的自定义选项的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例549定制耳塞</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">ear</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}

repositories { mavenCentral() }

dependencies {
    <span class="comment">// The following dependencies will be the ear modules and</span>
    <span class="comment">// will be placed in the ear root</span>
    deploy project(<span class="key">path</span>: <span class="string"><span class="delimiter">'</span><span class="content">:war</span><span class="delimiter">'</span></span>, <span class="key">configuration</span>: <span class="string"><span class="delimiter">'</span><span class="content">archives</span><span class="delimiter">'</span></span>)

    <span class="comment">// The following dependencies will become ear libs and will</span>
    <span class="comment">// be placed in a dir configured via the libDirName property</span>
    earlib <span class="key">group</span>: <span class="string"><span class="delimiter">'</span><span class="content">log4j</span><span class="delimiter">'</span></span>, <span class="key">name</span>: <span class="string"><span class="delimiter">'</span><span class="content">log4j</span><span class="delimiter">'</span></span>, <span class="key">version</span>: <span class="string"><span class="delimiter">'</span><span class="content">1.2.15</span><span class="delimiter">'</span></span>, <span class="key">ext</span>: <span class="string"><span class="delimiter">'</span><span class="content">jar</span><span class="delimiter">'</span></span>
}

ear {
    appDirName <span class="string"><span class="delimiter">'</span><span class="content">src/main/app</span><span class="delimiter">'</span></span>  <span class="comment">// use application metadata found in this folder</span>
    <span class="comment">// put dependent libraries into APP-INF/lib inside the generated EAR</span>
    libDirName <span class="string"><span class="delimiter">'</span><span class="content">APP-INF/lib</span><span class="delimiter">'</span></span>
    deploymentDescriptor {  <span class="comment">// custom entries for application.xml:</span>
<span class="comment">//      fileName = &quot;application.xml&quot;  // same as the default value</span>
<span class="comment">//      version = &quot;6&quot;  // same as the default value</span>
        applicationName = <span class="string"><span class="delimiter">&quot;</span><span class="content">customear</span><span class="delimiter">&quot;</span></span>
        initializeInOrder = <span class="predefined-constant">true</span>
        displayName = <span class="string"><span class="delimiter">&quot;</span><span class="content">Custom Ear</span><span class="delimiter">&quot;</span></span>  <span class="comment">// defaults to project.name</span>
        <span class="comment">// defaults to project.description if not set</span>
        description = <span class="string"><span class="delimiter">&quot;</span><span class="content">My customized EAR for the Gradle documentation</span><span class="delimiter">&quot;</span></span>
<span class="comment">//      libraryDirectory = &quot;APP-INF/lib&quot;  // not needed, above libDirName setting does this</span>
<span class="comment">//      module(&quot;my.jar&quot;, &quot;java&quot;)  // won't deploy as my.jar isn't deploy dependency</span>
<span class="comment">//      webModule(&quot;my.war&quot;, &quot;/&quot;)  // won't deploy as my.war isn't deploy dependency</span>
        securityRole <span class="string"><span class="delimiter">&quot;</span><span class="content">admin</span><span class="delimiter">&quot;</span></span>
        securityRole <span class="string"><span class="delimiter">&quot;</span><span class="content">superadmin</span><span class="delimiter">&quot;</span></span>
        withXml { provider -&gt; <span class="comment">// add a custom node to the XML</span>
            provider.asNode().appendNode(<span class="string"><span class="delimiter">&quot;</span><span class="content">data-source</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">my/data/source</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins  {
    ear
    java
}

repositories { mavenCentral() }

dependencies {
    // The following dependencies will be the ear modules and
    // will be placed in the ear root
    deploy(project(path = &quot;:war&quot;, configuration = &quot;archives&quot;))

    // The following dependencies will become ear libs and will
    // be placed in a dir configured via the libDirName property
    earlib(group = &quot;log4j&quot;, name = &quot;log4j&quot;, version = &quot;1.2.15&quot;, ext = &quot;jar&quot;)
}

ear {
    appDirName = &quot;src/main/app&quot;  // use application metadata found in this folder
    // put dependent libraries into APP-INF/lib inside the generated EAR
    libDirName = &quot;APP-INF/lib&quot;
    deploymentDescriptor {  // custom entries for application.xml:
//      fileName = &quot;application.xml&quot;  // same as the default value
//      version = &quot;6&quot;  // same as the default value
        applicationName = &quot;customear&quot;
        initializeInOrder = true
        displayName = &quot;Custom Ear&quot;  // defaults to project.name
        // defaults to project.description if not set
        description = &quot;My customized EAR for the Gradle documentation&quot;
//      libraryDirectory = &quot;APP-INF/lib&quot;  // not needed, above libDirName setting does this
//      module(&quot;my.jar&quot;, &quot;java&quot;)  // won't deploy as my.jar isn't deploy dependency
//      webModule(&quot;my.war&quot;, &quot;/&quot;)  // won't deploy as my.war isn't deploy dependency
        securityRole(&quot;admin&quot;)
        securityRole(&quot;superadmin&quot;)
        withXml { // add a custom node to the XML
            asElement().apply {
                appendChild(ownerDocument.createElement(&quot;data-source&quot;).apply { textContent = &quot;my/data/source&quot; })
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ear.Ear.html">Ear</a>任务提供的自定义选项，例如<code>from</code>和<code>metaInf</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:using_custom_app_xml"><a class="anchor" href="#sec:using_custom_app_xml"></a> <a class="link" href="#sec:using_custom_app_xml">使用自定义描述符文件</a></h4>
<div class="paragraph">
<p>您可能已经在<code>application.xml</code>文件，并希望使用该文件而不是配置<code>ear.deploymentDescriptor</code>构建脚本部分。为了实现该目标，请将<code>META-INF/application.xml</code>在源文件夹内的正确位置（请参见<code>appDirName</code>属性）。将使用文件内容，并且将使用文件中的显式配置<code>ear.deploymentDescriptor</code>将被忽略。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="eclipse_plugin"><a class="anchor" href="#eclipse_plugin"></a> <a class="link" href="#eclipse_plugin">Eclipse插件</a></h3>
<div class="paragraph">
<p>Eclipse插件生成<a href="http://eclipse.org">Eclipse IDE</a>使用的文件，从而可以将项目导入Eclipse（ <code>File</code> -- <code>Import…​</code> -- <code>Existing Projects into Workspace</code> ）。</p>
</div>
<div class="paragraph">
<p>的<code>eclipse-wtp</code>每当<code>eclipse</code>该插件已应用于<a href="#war_plugin">War</a>或<a href="#ear_plugin">Ear</a>项目。对于实用程序项目（即其他Web项目使用的<a href="#java_plugin">Java</a>项目），您需要应用<code>eclipse-wtp</code>显式插件。</p>
</div>
<div class="paragraph">
<p>到底是什么<code>eclipse</code>插件生成取决于所使用的其他插件：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表25。Eclipse插件行为</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">插入</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">产生最少<code>.project</code>文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#java_plugin">爪哇</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Java配置添加到<code>.project</code> 。产生<code>.classpath</code>和JDT设置文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#groovy_plugin">Groovy</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Groovy配置添加到<code>.project</code>文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#scala_plugin">斯卡拉</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Scala支持添加到<code>.project</code>和<code>.classpath</code>文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#war_plugin">战争</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Web应用程序支持添加到<code>.project</code>文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#ear_plugin">耳</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">增加了对耳朵应用程序的支持<code>.project</code>文件。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>的<code>eclipse-wtp</code>插件会生成所有WTP设置文件，并增强<code>.project</code>文件。如果应用<a href="#java_plugin">Java</a>或<a href="#war_plugin">War</a> ， <code>.classpath</code>将被扩展以获得该实用程序库或Web应用程序项目的正确包装结构。</p>
</div>
<div class="paragraph">
<p>这两个Eclipse插件都可以接受自定义，并提供了一组标准化的挂钩，用于在生成的文件中添加和删除内容。</p>
</div>
<div class="sect3">
<h4 id="sec:eclipse_usage"><a class="anchor" href="#sec:eclipse_usage"></a> <a class="link" href="#sec:eclipse_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Eclipse或Eclipse WTP插件，请在构建脚本中包括以下几行：</p>
</div>
<div class="exampleblock">
<div class="title">示例550使用Eclipse插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">eclipse</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    eclipse
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例551使用Eclipse WTP插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">eclipse-wtp</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `eclipse-wtp`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><em>注意：在</em>内部， <code>eclipse-wtp</code>插件也适用<code>eclipse</code>插件，因此您无需同时应用两者。</p>
</div>
<div class="paragraph">
<p>这两个Eclipse插件都向您的项目添加了许多任务。您将使用的主要任务是<code>eclipse</code>和<code>cleanEclipse</code>任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:eclipse_tasks"><a class="anchor" href="#sec:eclipse_tasks"></a> <a class="link" href="#sec:eclipse_tasks">任务</a></h4>
<div class="paragraph">
<p>Eclipse插件将下面显示的任务添加到项目中。</p>
</div>
<div class="sect4">
<h5 id="eclipsetasks"><a class="anchor" href="#eclipsetasks"></a> <a class="link" href="#eclipsetasks">Eclipse插件任务</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>eclipse</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html">任务</a></dt>
<dd>
<p><em>取决于</em> ：所有Eclipse配置文件生成任务</p>
<div class="paragraph">
<p>生成所有Eclipse配置文件</p>
</div>
</dd>
<dt class="hdlist1"><code>cleanEclipse</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<p><em>取决于</em> ：所有Eclipse配置文件清除任务</p>
<div class="paragraph">
<p>除去所有Eclipse配置文件</p>
</div>
</dd>
<dt class="hdlist1"><code>cleanEclipseProject</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<div class="paragraph">
<p>删除<code>.project</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>cleanEclipseClasspath</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<div class="paragraph">
<p>删除<code>.classpath</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>cleanEclipseJdt</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<div class="paragraph">
<p>删除<code>.settings/org.eclipse.jdt.core.prefs</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>eclipseProject</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseProject.html">GenerateEclipseProject</a></dt>
<dd>
<div class="paragraph">
<p>产生<code>.project</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>eclipseClasspath</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseClasspath.html">GenerateEclipseClasspath</a></dt>
<dd>
<div class="paragraph">
<p>产生<code>.classpath</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>eclipseJdt</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseJdt.html">GenerateEclipseJdt</a></dt>
<dd>
<div class="paragraph">
<p>产生<code>.settings/org.eclipse.jdt.core.prefs</code>文件。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="eclipsewtptasks"><a class="anchor" href="#eclipsewtptasks"></a> <a class="link" href="#eclipsewtptasks">Eclipse WTP插件-其他任务</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>cleanEclipseWtpComponent</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<div class="paragraph">
<p>删除<code>.settings/org.eclipse.wst.common.component</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>cleanEclipseWtpFacet</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<div class="paragraph">
<p>删除<code>.settings/org.eclipse.wst.common.project.facet.core.xml</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>eclipseWtpComponent</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpComponent.html">GenerateEclipseWtpComponent</a></dt>
<dd>
<div class="paragraph">
<p>产生<code>.settings/org.eclipse.wst.common.component</code>文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>eclipseWtpFacet</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpFacet.html">GenerateEclipseWtpFacet</a></dt>
<dd>
<div class="paragraph">
<p>产生<code>.settings/org.eclipse.wst.common.project.facet.core.xml</code>文件。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:eclipse_configuration"><a class="anchor" href="#sec:eclipse_configuration"></a> <a class="link" href="#sec:eclipse_configuration">组态</a></h4>
<table id="eclipse-configuration" class="tableblock frame-all grid-all fit-content">
<caption class="title">表26。Eclipse插件的配置</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">模型</th>
<th class="tableblock halign-left valign-top">参考名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseModel.html">Eclipse模型</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eclipse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">顶级元素，以DSL友好的方式启用Eclipse插件的配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseProject.html">Eclipse项目</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eclipse.project</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许配置项目信息</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html">EclipseClasspath</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eclipse.classpath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许配置类路径信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseJdt.html">EclipseJdt</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eclipse.jdt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许配置jdt信息（源/目标Java兼容性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent.html">EclipseWtpComponent</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eclipse.wtp.component</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅在以下情况下才允许配置wtp组件信息<code>eclipse-wtp</code>插件已应用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet.html">EclipseWtpFacet</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eclipse.wtp.facet</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅在以下情况下才允许配置wtp构面信息<code>eclipse-wtp</code>插件已应用。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:eclipse_customizing_the_generated_files"><a class="anchor" href="#sec:eclipse_customizing_the_generated_files"></a> <a class="link" href="#sec:eclipse_customizing_the_generated_files">自定义生成的文件</a></h4>
<div class="paragraph">
<p>Eclipse插件使您可以自定义生成的元数据文件。插件提供了DSL，用于配置为项目的Eclipse视图建模的模型对象。然后将这些模型对象与现有的Eclipse XML元数据合并，以最终生成新的元数据。模型对象提供了较低级别的挂钩，用于在与模型配置合并之前和之后使用表示文件内容的域对象。它们还提供了一个非常低级的挂钩，可以直接与原始XML一起使用，以便在持久化之前进行调整，以进行Eclipse和Eclipse WTP插件无法建模的微调和配置。</p>
</div>
<div class="sect4">
<h5 id="sec:merging_with_eclipse_files"><a class="anchor" href="#sec:merging_with_eclipse_files"></a> <a class="link" href="#sec:merging_with_eclipse_files">合并中</a></h5>
<div class="paragraph">
<p>根据特定部分的不同，现有Eclipse文件中也将作为生成内容目标的部分将被修改或覆盖。其余部分将保持不变。</p>
</div>
<div class="sect5">
<h6 id="sec:complete_rewrite_of_eclipse_files"><a class="anchor" href="#sec:complete_rewrite_of_eclipse_files"></a> <a class="link" href="#sec:complete_rewrite_of_eclipse_files">禁用合并并完全重写</a></h6>
<div class="paragraph">
<p>要完全重写现有的Eclipse文件，请执行清理任务及其相应的生成任务，例如“ <code>gradle cleanEclipse eclipse</code> “ （以该顺序）。如果要将其设为默认行为，请添加“ <code>tasks.eclipse.dependsOn(cleanEclipse)</code> ”添加到您的构建脚本中。这使得不必显式执行清理任务。</p>
</div>
<div class="paragraph">
<p>此策略还可用于插件将生成的单个文件。例如，可以针对“ <code>.classpath</code>带有“ <code>gradle cleanEclipseClasspath eclipseClasspath</code> ”。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:hooking_into_the_eclipse_generation_lifecycle"><a class="anchor" href="#sec:hooking_into_the_eclipse_generation_lifecycle"></a> <a class="link" href="#sec:hooking_into_the_eclipse_generation_lifecycle">融入一代生命周期</a></h5>
<div class="paragraph">
<p>Eclipse插件提供了对Gradle生成的Eclipse文件的各个部分进行建模的对象。生成生命周期如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>读取文件；或使用Gradle提供的默认版本（如果不存在）</p>
</li>
<li>
<p>的<code>beforeMerged</code>挂钩是使用代表现有文件的域对象执行的</p>
</li>
<li>
<p>现有内容与从Gradle构建推断的配置合并或在Eclipse DSL中明确定义</p>
</li>
<li>
<p>的<code>whenMerged</code>钩子是使用域对象执行的，该域对象表示要持久保存的文件的内容</p>
</li>
<li>
<p>的<code>withXml</code>使用将保留的XML的原始表示执行钩子</p>
</li>
<li>
<p>最终的XML被保留</p>
</li>
</ol>
</div>
<div class="sect5">
<h6 id="eclipse-plugin-hooks"><a class="anchor" href="#eclipse-plugin-hooks"></a> <a class="link" href="#eclipse-plugin-hooks">高级配置挂钩</a></h6>
<div class="paragraph">
<p>下表涵盖了用于每种Eclipse模型类型的域对象：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseProject.html">Eclipse项目</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/Project.html">Project</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/Project.html">Project</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withXml { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/XmlProvider.html">XmlProvider</a> arg -> …​ }</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html">EclipseClasspath</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/Classpath.html">Classpath</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/Classpath.html">Classpath</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withXml { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/XmlProvider.html">XmlProvider</a> arg -> …​ }</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent.html">EclipseWtpComponent</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/WtpComponent.html">WtpComponent</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/WtpComponent.html">WtpComponent</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withXml { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/XmlProvider.html">XmlProvider</a> arg -> …​ }</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet.html">EclipseWtpFacet</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/WtpFacet.html">WtpFacet</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/WtpFacet.html">WtpFacet</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withXml { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/XmlProvider.html">XmlProvider</a> arg -> …​ }</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.eclipse.model.EclipseJdt.html">EclipseJdt</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/Jdt.html">Jdt</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/eclipse/model/Jdt.html">Jdt</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withProperties { arg -> }</code>参数类型⇒<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html"><code>java.util.Properties</code></a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="sec:partial-overwrite"><a class="anchor" href="#sec:partial-overwrite"></a> <a class="link" href="#sec:partial-overwrite">部分覆盖现有内容</a></h6>
<div class="paragraph">
<p>完全覆盖会导致所有现有内容被丢弃，从而丢失直接在IDE中所做的任何更改。或者， <code>beforeMerged</code>钩子使得仅覆盖现有内容的某些部分成为可能。以下示例从<code>Classpath</code>域对象：</p>
</div>
<div class="exampleblock">
<div class="title">示例552类路径的部分覆盖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">eclipse.classpath.file {
    beforeMerged { classpath -&gt;
        classpath.entries.removeAll { entry -&gt; entry.kind == <span class="string"><span class="delimiter">'</span><span class="content">lib</span><span class="delimiter">'</span></span> || entry.kind == <span class="string"><span class="delimiter">'</span><span class="content">var</span><span class="delimiter">'</span></span> }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.plugins.ide.eclipse.model.Classpath

eclipse.classpath.file {
    beforeMerged(Action&lt;Classpath&gt; {
        entries.removeAll { entry -&gt; entry.kind == &quot;lib&quot; || entry.kind == &quot;var&quot; }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>所结果的<code>.classpath</code>文件将仅包含Gradle生成的依赖项，但不包含原始文件中可能存在的任何其他依赖项。（对于依赖项，这也是默认行为。）其他部分<code>.classpath</code>文件将保持原样或合并。对于自然界中的自然也可以这样做。 <code>.project</code>文件：</p>
</div>
<div class="exampleblock">
<div class="title">示例553项目的部分覆盖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">eclipse.project.file.beforeMerged { project -&gt;
    project.natures.clear()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.plugins.ide.eclipse.model.Project

eclipse.project.file.beforeMerged(Action&lt;Project&gt; {
    natures.clear()
})</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:eclipse_modify_domain_objects"><a class="anchor" href="#sec:eclipse_modify_domain_objects"></a> <a class="link" href="#sec:eclipse_modify_domain_objects">修改完全填充的域对象</a></h6>
<div class="paragraph">
<p>的<code>whenMerged</code>钩子允许操作完全填充的域对象。通常，这是定制Eclipse文件的首选方法。这是导出Eclipse项目的所有依赖项的方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例554。导出类路径条目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">eclipse.classpath.file {
    whenMerged { classpath -&gt;
        classpath.entries.findAll { entry -&gt; entry.kind == <span class="string"><span class="delimiter">'</span><span class="content">lib</span><span class="delimiter">'</span></span> }*.exported = <span class="predefined-constant">false</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry
import org.gradle.plugins.ide.eclipse.model.Classpath

eclipse.classpath.file {
    whenMerged(Action&lt;Classpath&gt; { -&gt;
        entries.filter { entry -&gt; entry.kind == &quot;lib&quot; }
            .forEach { (it as AbstractClasspathEntry).isExported = false }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:eclipse_modify_xml"><a class="anchor" href="#sec:eclipse_modify_xml"></a> <a class="link" href="#sec:eclipse_modify_xml">修改XML表示</a></h6>
<div class="paragraph">
<p>的<code>withXml</code>钩子允许在将文件写入磁盘之前操作内存中的XML表示形式。尽管Groovy的XML支持和Kotlin的扩展功能弥补了很多，但这种方法比操作域对象要方便得多。作为回报，您可以完全控制所生成的文件，包括未由域对象建模的部分。</p>
</div>
<div class="exampleblock">
<div class="title">示例555自定义XML</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">eclipse.wtp.facet.file.withXml { provider -&gt;
    provider.asNode().fixed.find { <span class="local-variable">it</span>.@facet == <span class="string"><span class="delimiter">'</span><span class="content">jst.java</span><span class="delimiter">'</span></span> }.@facet = <span class="string"><span class="delimiter">'</span><span class="content">jst2.java</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.w3c.dom.Element

eclipse.wtp.facet.file.withXml(Action&lt;XmlProvider&gt; {
    fun Element.firstElement(predicate: Element.() -&gt; Boolean) =
        childNodes
            .run { (0 until length).map(::item) }
            .filterIsInstance&lt;Element&gt;()
            .first { it.predicate() }

    asElement()
        .firstElement { tagName === &quot;fixed&quot; &amp;&amp; getAttribute(&quot;facet&quot;) == &quot;jst.java&quot; }
        .setAttribute(&quot;facet&quot;, &quot;jst2.java&quot;)
})</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="groovy_plugin"><a class="anchor" href="#groovy_plugin"></a> <a class="link" href="#groovy_plugin">Groovy插件</a></h3>
<div class="paragraph">
<p>Groovy插件扩展了<a href="#">Java插件，</a>以添加对<a href="https://groovy-lang.org/">Groovy</a>项目的支持。它可以处理Groovy代码，混合的Groovy和Java代码，甚至是纯Java代码（尽管我们不一定建议将其用于后者）。该插件支持<em>联合编译</em> ，可让您自由混合并匹配Groovy和Java代码，并具有双向依赖性。例如，Groovy类可以扩展Java类，而Java类又可以扩展Groovy类。这样就可以为作业使用最佳语言，并在需要时用其他语言重写任何类。</p>
</div>
<div class="paragraph">
<p>请注意，如果您想从<a href="#sec:java_library_separation">API /实现分离中</a>受益，还可以应用<code>java-library</code> Groovy项目的插件。</p>
</div>
<div class="sect3">
<h4 id="sec:groovy_usage"><a class="anchor" href="#sec:groovy_usage"></a> <a class="link" href="#sec:groovy_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Groovy插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例556使用Groovy插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">groovy</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    groovy
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:groovy_tasks"><a class="anchor" href="#sec:groovy_tasks"></a> <a class="link" href="#sec:groovy_tasks">任务</a></h4>
<div class="paragraph">
<p>Groovy插件将以下任务添加到项目中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>compileGroovy</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.GroovyCompile.html">GroovyCompile</a></dt>
<dd>
<p><em>取决于</em> ：<code>compileJava</code></p>
<div class="paragraph">
<p>编译生产Groovy源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>compileTestGroovy</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.GroovyCompile.html">GroovyCompile</a></dt>
<dd>
<p><em>取决于</em> ：<code>compileTestJava</code></p>
<div class="paragraph">
<p>编译测试Groovy源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>compile<em>SourceSet</em>Groovy</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.GroovyCompile.html">GroovyCompile</a></dt>
<dd>
<p><em>取决于</em> ：<code>compile<em>SourceSet</em>Java</code></p>
<div class="paragraph">
<p>编译给定源集的Groovy源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>groovydoc</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.javadoc.Groovydoc.html">Groovydoc</a></dt>
<dd>
<div class="paragraph">
<p>为生产Groovy源文件生成API文档。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Groovy插件将以下依赖项添加到Java插件添加的任务中。</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表27。Groovy插件-其他任务依赖项</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">任务名称</th>
<th class="tableblock halign-left valign-top">依赖于取决于</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>compileGroovy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>testClasses</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>compileTestGroovy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>sourceSet</em>Classes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>compile<em>SourceSet</em>Groovy</code></p></td>
</tr>
</tbody>
</table>
<div class="imageblock">
<div class="content">
<img src="img/groovyPluginTasks.png" alt="groovyPluginTasks">
</div>
<div class="title">图33。Groovy插件-任务</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:groovy_project_layout"><a class="anchor" href="#sec:groovy_project_layout"></a> <a class="link" href="#sec:groovy_project_layout">项目布局</a></h4>
<div class="paragraph">
<p>Groovy插件采用了<a href="#groovylayout">Groovy Layout中</a>所示的项目<a href="#groovylayout">布局</a> 。所有Groovy源目录都可以包含Groovy <em>和</em> Java代码。Java源目录只能包含Java源代码。 <sup class="footnote">[ <a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="查看脚注。">20</a> ]</sup> 这些目录都不需要存在或包含任何内容。 Groovy插件将简单地编译找到的任何内容。</p>
</div>
<div id="groovylayout" class="dlist">
<dl>
<dt class="hdlist1"><code>src/main/java</code></dt>
<dd>
<p>生产Java源代码。</p>
</dd>
<dt class="hdlist1"><code>src/main/resources</code></dt>
<dd>
<p>生产资源，例如XML和属性文件。</p>
</dd>
<dt class="hdlist1"><code>src/main/groovy</code></dt>
<dd>
<p>生产Groovy源。也可能包含Java源文件以进行联合编译。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/test/java</code></dt>
<dd>
<p>测试Java源代码。</p>
</dd>
<dt class="hdlist1"><code>src/test/resources</code></dt>
<dd>
<p>测试资源。</p>
</dd>
<dt class="hdlist1"><code>src/test/groovy</code></dt>
<dd>
<p>测试Groovy源。也可能包含Java源文件以进行联合编译。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/java</code></dt>
<dd>
<p>名为<em>sourceSet</em>的源集的Java源。</p>
</dd>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/resources</code></dt>
<dd>
<p>名为<em>sourceSet</em>的源集的资源。</p>
</dd>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/groovy</code></dt>
<dd>
<p>给定源集的Groovy源文件。也可能包含Java源文件以进行联合编译。</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="sec:changing_groovy_project_layout"><a class="anchor" href="#sec:changing_groovy_project_layout"></a> <a class="link" href="#sec:changing_groovy_project_layout">更改项目布局</a></h5>
<div class="paragraph">
<p>就像Java插件一样，Groovy插件允许您配置Groovy生产和测试源文件的自定义位置。</p>
</div>
<div class="exampleblock">
<div class="title">示例557。自定义Groovy源布局</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    main {
        groovy {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">src/groovy</span><span class="delimiter">'</span></span>]
        }
    }

    test {
        groovy {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">test/groovy</span><span class="delimiter">'</span></span>]
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    main {
        withConvention(GroovySourceSet::class) {
            groovy {
                setSrcDirs(listOf(&quot;src/groovy&quot;))
            }
        }
    }

    test {
        withConvention(GroovySourceSet::class) {
            groovy {
                setSrcDirs(listOf(&quot;test/groovy&quot;))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:groovy_dependency_management"><a class="anchor" href="#sec:groovy_dependency_management"></a> <a class="link" href="#sec:groovy_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>因为Gradle的构建语言是基于Groovy的，并且Gradle的某些部分是在Groovy中实现的，所以Gradle已经附带了Groovy库。尽管如此，Groovy项目仍需要显式声明一个Groovy依赖项。然后，将在编译和运行时类路径上使用此依赖项。它还将分别用于获取Groovy编译器和Groovydoc工具。</p>
</div>
<div class="paragraph">
<p>如果将Groovy用于生产代码，则应将Groovy依赖项添加到<code>implementation</code>组态：</p>
</div>
<div class="exampleblock">
<div class="title">示例558Groovy依赖项的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.codehaus.groovy:groovy-all:2.4.15</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}

dependencies {
    implementation(&quot;org.codehaus.groovy:groovy-all:2.4.15&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果Groovy仅用于测试代码，则应将Groovy依赖项添加到<code>testImplementation</code>组态：</p>
</div>
<div class="exampleblock">
<div class="title">示例559Groovy测试依赖项的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.codehaus.groovy:groovy-all:2.4.15</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;org.codehaus.groovy:groovy-all:2.4.15&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用Gradle随附的Groovy库，请声明一个<code>localGroovy()</code>依赖性。请注意，不同的Gradle版本附带了不同的Groovy版本。因此，使用<code>localGroovy()</code>声明常规Groovy依赖项的安全性较低。</p>
</div>
<div class="exampleblock">
<div class="title">示例560Groovy捆绑依赖项的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    implementation localGroovy()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    implementation(localGroovy())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Groovy库不一定必须来自远程存储库。也可能来自本地<code>lib</code>目录，可能已签到源代码管理：</p>
</div>
<div class="exampleblock">
<div class="title">示例561Groovy文件依赖项的配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    flatDir { dirs <span class="string"><span class="delimiter">'</span><span class="content">lib</span><span class="delimiter">'</span></span> }
}

dependencies {
    implementation module(<span class="string"><span class="delimiter">'</span><span class="content">org.codehaus.groovy:groovy:2.4.15</span><span class="delimiter">'</span></span>) {
        dependency(<span class="string"><span class="delimiter">'</span><span class="content">org.ow2.asm:asm-all:5.0.3</span><span class="delimiter">'</span></span>)
        dependency(<span class="string"><span class="delimiter">'</span><span class="content">antlr:antlr:2.7.7</span><span class="delimiter">'</span></span>)
        dependency(<span class="string"><span class="delimiter">'</span><span class="content">commons-cli:commons-cli:1.2</span><span class="delimiter">'</span></span>)
        module(<span class="string"><span class="delimiter">'</span><span class="content">org.apache.ant:ant:1.9.4</span><span class="delimiter">'</span></span>) {
            dependencies(<span class="string"><span class="delimiter">'</span><span class="content">org.apache.ant:ant-junit:1.9.4@jar</span><span class="delimiter">'</span></span>,
                         <span class="string"><span class="delimiter">'</span><span class="content">org.apache.ant:ant-launcher:1.9.4</span><span class="delimiter">'</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    flatDir { dirs(&quot;lib&quot;) }
}

dependencies {
    implementation(module(&quot;org.codehaus.groovy:groovy:2.4.15&quot;) {
        dependency(&quot;org.ow2.asm:asm-all:5.0.3&quot;)
        dependency(&quot;antlr:antlr:2.7.7&quot;)
        dependency(&quot;commons-cli:commons-cli:1.2&quot;)
        module(&quot;org.apache.ant:ant:1.9.4&quot;) {
            dependencies(&quot;org.apache.ant:ant-junit:1.9.4@jar&quot;,
                         &quot;org.apache.ant:ant-launcher:1.9.4&quot;)
        }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:automatic_configuration_of_groovyclasspath"><a class="anchor" href="#sec:automatic_configuration_of_groovyclasspath"></a> <a class="link" href="#sec:automatic_configuration_of_groovyclasspath">groovyClasspath的自动配置</a></h4>
<div class="paragraph">
<p>的<code>GroovyCompile</code>和<code>Groovydoc</code>任务以两种方式消耗Groovy代码： <code>classpath</code> ，并在他们的<code>groovyClasspath</code> 。前者用于查找源代码引用的类，通常将包含Groovy库以及其他库。后者分别用于加载和执行Groovy编译器和Groovydoc工具，并且应仅包含Groovy库及其依赖项。</p>
</div>
<div class="paragraph">
<p>除非有任务<code>groovyClasspath</code>已明确配置，Groovy（基本）插件将尝试从任务的<code>classpath</code> 。这样做如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果一个<code>groovy-all(-indy)</code>找到了Jar <code>classpath</code> ，该jar将添加到<code>groovyClasspath</code> 。</p>
</li>
<li>
<p>如果一个<code>groovy(-indy)</code>找到罐子<code>classpath</code> ，并且该项目至少声明了一个存储库，相应的<code>groovy(-indy)</code>存储库依赖项将添加到<code>groovyClasspath</code> 。</p>
</li>
<li>
<p>否则，任务执行将失败，并显示一条消息，指出<code>groovyClasspath</code>无法推断。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意， <code>-indy</code>每个jar的变体指的是带有<code>invokedynamic</code>支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:groovy_convention_properties"><a class="anchor" href="#sec:groovy_convention_properties"></a> <a class="link" href="#sec:groovy_convention_properties">公约属性</a></h4>
<div class="paragraph">
<p>Groovy插件不会向项目添加任何约定属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:groovy_source_set_properties"><a class="anchor" href="#sec:groovy_source_set_properties"></a> <a class="link" href="#sec:groovy_source_set_properties">源集属性</a></h4>
<div class="paragraph">
<p>Groovy插件将以下约定属性添加到项目中的每个源集。您可以在构建脚本中使用这些属性，就像它们是源集对象的属性一样。</p>
</div>
<div class="sect4">
<h5 id="groovy_plugin_source_set_properties"><a class="anchor" href="#groovy_plugin_source_set_properties"></a> <a class="link" href="#groovy_plugin_source_set_properties">Groovy插件—源集属性</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>groovy</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a> （只读）</dt>
<dd>
<p><em>默认值</em> ：不为空</p>
<div class="paragraph">
<p>此源集的Groovy源文件。包含所有<code>.groovy</code>和<code>.java</code>在Groovy源目录中找到的文件，不包括所有其他类型的文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>groovy.srcDirs</code> -<code>Set<File></code></dt>
<dd>
<p><em>预设值</em> ：<code>[<em>projectDir</em>/src/<em>name</em>/groovy]</code></p>
<div class="paragraph">
<p>包含此源集的Groovy源文件的源目录。也可能包含Java源文件以进行联合编译。可以使用“ <a href="#sec:specifying_multiple_files">指定多个文件”中</a>所述的任何内容进行设置。</p>
</div>
</dd>
<dt class="hdlist1"><code>allGroovy</code> — <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">FileTree</a> （只读）</dt>
<dd>
<p><em>默认值</em> ：不为空</p>
<div class="paragraph">
<p>该源集的所有Groovy源文件。仅包含<code>.groovy</code> Groovy源目录中找到的文件。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这些属性由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.GroovySourceSet.html">GroovySourceSet</a>类型的约定对象提供。</p>
</div>
<div class="paragraph">
<p>Groovy插件还修改了一些源集属性：</p>
</div>
</div>
<div class="sect4">
<h5 id="groovy_plugin_modified_source_set_properties"><a class="anchor" href="#groovy_plugin_modified_source_set_properties"></a> <a class="link" href="#groovy_plugin_modified_source_set_properties">Groovy插件-修改的源集属性</a></h5>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">物业名称</th>
<th class="tableblock halign-left valign-top">更改</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>allJava</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全部添加<code>.java</code> Groovy源目录中找到的文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>allSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加在Groovy源目录中找到的所有源文件。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sec:groovyCompile"><a class="anchor" href="#sec:groovyCompile"></a> <a class="link" href="#sec:groovyCompile">Groovy编译</a></h4>
<div class="paragraph">
<p>Groovy插件为项目中的每个源集添加了一个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.GroovyCompile.html">GroovyCompile</a>任务。任务类型扩展了<code>JavaCompile</code>任务（请参阅<a href="#sec:compile">相关的Java插件一节</a> ）。的<code>GroovyCompile</code>该任务支持官方Groovy编译器的大多数配置选项。</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表28。Groovy插件-GroovyCompile属性</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">任务属性</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classpath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">文件集</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>sourceSet</em>.compileClasspath</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>source</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">FileTree</a> 。可以使用“ <a href="#sec:specifying_multiple_files">指定多个文件”中</a>所述的任何内容进行设置。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>sourceSet</em>.groovy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destinationDir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>File</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>sourceSet</em>.groovy.outputDir</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>groovyClasspath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">文件集</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>groovy</code>非空配置；上的Groovy库<code>classpath</code>除此以外</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="sec:groovy_compilation_avoidance"><a class="anchor" href="#sec:groovy_compilation_avoidance"></a> <a class="link" href="#sec:groovy_compilation_avoidance">避免编译</a></h5>
<div class="paragraph">
<p><em>注意：自Gradle 5.6起，避免Groovy编译是一个令人振奋的功能。存在已知的错误，因此请自行承担风险。</em></p>
</div>
<div class="paragraph">
<p>要启用避免Groovy编译的孵化支持，请添加一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/initialization/Settings.html#enableFeaturePreview-java.lang.String-"><code>enableFeaturePreview</code></a>到您的设置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">enableFeaturePreview(<span class="string"><span class="delimiter">'</span><span class="content">GROOVY_COMPILATION_AVOIDANCE</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">settings.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">enableFeaturePreview(&quot;GROOVY_COMPILATION_AVOIDANCE&quot;)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果从属项目以与<a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>兼容的方式进行了更改（仅更改了其专用API），那么Groovy编译任务将是最新的。这意味着如果项目<code>A</code>取决于项目<code>B</code>和一个班<code>B</code>以与ABI兼容的方式进行更改（通常仅更改方法的主体），则Gradle将不会重新编译<code>A</code> 。</p>
</div>
<div class="paragraph">
<p>有关不影响ABI且被忽略的更改类型的详细列表，请参见<a href="#sec:java_compile_avoidance">Java避免编译</a> 。</p>
</div>
<div class="paragraph">
<p>但是，类似于Java的注释处理，有多种方法可以<a href="https://melix.github.io/blog/2011/05/12/customizing_groovy_compilation_process.html">定制Groovy编译过程</a> ，而实现细节很重要。一些著名的例子是<a href="https://groovy-lang.org/metaprogramming.html#_code_generation_transformations">Groovy AST转换</a> 。在这些情况下，必须在称为<code>astTransformationClasspath</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">实施例562。声明AST转换</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    configurations { astTransformation }
    dependencies {
        astTransformation(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:astTransformation</span><span class="delimiter">&quot;</span></span>))
    }
    tasks.withType(GroovyCompile).configureEach {
        astTranformationClasspath.from(configurations.astTransformation)
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    val astTransformation by configurations.creating
    dependencies {
        astTransformation(project(&quot;:astTransformation&quot;))
    }
    tasks.withType&lt;GroovyCompile&gt;().configureEach {
        astTranformationClasspath.from(astTransformation)
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:incremental_groovy_compilation"><a class="anchor" href="#sec:incremental_groovy_compilation"></a> <a class="link" href="#sec:incremental_groovy_compilation">Groovy增量编译</a></h4>
<div class="paragraph">
<p>从5.6开始，Gradle引入了实验性的Groovy增量编译器。要为Groovy启用增量编译，您需要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>启用<a href="#sec:groovy_compilation_avoidance">Groovy避免编译</a> 。</p>
</li>
<li>
<p>在构建脚本中明确启用增量Groovy编译：</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">示例563。启用增量Groovy编译</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    tasks.withType(GroovyCompile).configureEach {
        options.incremental = <span class="predefined-constant">true</span>
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    tasks.withType&lt;GroovyCompile&gt;().configureEach {
        options.isIncremental = true
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这为您带来以下好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>增量构建要快得多。</p>
</li>
<li>
<p>如果只更改了少量Groovy源文件，则仅重新编译受影响的源文件。不需要重新编译的类在输出目录中保持不变。例如，如果仅更改几个Groovy测试类，则无需重新编译所有Groovy测试源文件-仅需要重新编译更改的源文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要了解增量编译的工作原理，请参见<a href="#sec:incremental_compile">增量Java编译</a>以获取详细概述。请注意，与Java增量编译有一些区别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与Java不同，Groovy编译器不内联常量，因此对常量的更改不会触发完整的重新编译。</p>
</li>
<li>
<p>Groovy编译器无法保留<code>@Retention</code>在生成的注释类字节码（ <a href="https://issues.apache.org/jira/browse/GROOVY-9185">GROOVY-9185</a> ）中，因此所有注释都是<code>RUNTIME</code> 。这意味着对源保留批注的更改将不会触发完全重新编译。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="sec:incremental_groovy_compilation_known_issues"><a class="anchor" href="#sec:incremental_groovy_compilation_known_issues"></a> <a class="link" href="#sec:incremental_groovy_compilation_known_issues">已知的问题</a></h5>
<div class="paragraph">
<p>另请参阅<a href="#sec:incremental_compilation_known_issues">增量Java编译的已知问题</a> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对资源的更改不会触发重新编译，这可能会导致某些不正确的情况，例如<a href="https://mrhaki.blogspot.com/2013/01/groovy-goodness-adding-extra-methods.html">扩展模块</a> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:groovy_cross_compilation"><a class="anchor" href="#sec:groovy_cross_compilation"></a> <a class="link" href="#sec:groovy_cross_compilation">针对Java 6或Java 7进行编译和测试</a></h4>
<div class="paragraph">
<p>Groovy编译器将始终与用于启动Gradle的Java版本一起执行。你应该设置<code>sourceCompatibility</code>和<code>targetCompatibility</code>至<code>1.6</code>要么<code>1.7</code> 。如果您还具有Java源文件，则可以按照与<a href="#sec:java_cross_compilation">Java插件</a>相同的步骤进行操作，以确保使用正确的Java编译器。</p>
</div>
<div class="sect4">
<h5 id="example_configure_java_6_build_for_groovy"><a class="anchor" href="#example_configure_java_6_build_for_groovy"></a> <a class="link" href="#example_configure_java_6_build_for_groovy">示例：为Groovy配置Java 6构建</a></h5>
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code># in $HOME/.gradle/gradle.properties
java6Home=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    sourceCompatibility = JavaVersion.VERSION_1_6
    targetCompatibility = JavaVersion.VERSION_1_6
}

<span class="keyword">assert</span> hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">java6Home</span><span class="delimiter">'</span></span>) : <span class="string"><span class="delimiter">&quot;</span><span class="content">Set the property 'java6Home' in your your gradle.properties pointing to a Java 6 installation</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> javaExecutablesPath = <span class="keyword">new</span> <span class="predefined-type">File</span>(java6Home, <span class="string"><span class="delimiter">'</span><span class="content">bin</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> javaExecutables = [:].withDefault { execName -&gt;
    <span class="keyword">def</span> executable = <span class="keyword">new</span> <span class="predefined-type">File</span>(javaExecutablesPath, execName)
    <span class="keyword">assert</span> executable.exists() : <span class="string"><span class="delimiter">&quot;</span><span class="content">There is no </span><span class="inline"><span class="inline-delimiter">$</span>execName</span><span class="content"> executable in </span><span class="inline"><span class="inline-delimiter">$</span>javaExecutablesPath</span><span class="delimiter">&quot;</span></span>
    executable
}
tasks.withType(AbstractCompile) {
    options.with {
        fork = <span class="predefined-constant">true</span>
        forkOptions.javaHome = file(java6Home)
    }
}
tasks.withType(Javadoc) {
    executable = javaExecutables.javadoc
}
tasks.withType(Test) {
    executable = javaExecutables.java
}
tasks.withType(JavaExec) {
    executable = javaExecutables.java
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    sourceCompatibility = JavaVersion.VERSION_1_6
    targetCompatibility = JavaVersion.VERSION_1_6
}

require(hasProperty(&quot;java6Home&quot;)) { &quot;Set the property 'java6Home' in your your gradle.properties pointing to a Java 6 installation&quot; }
val java6Home: String by project
val javaExecutablesPath = File(java6Home, &quot;bin&quot;)
fun javaExecutable(execName: String): String {
    val executable = File(javaExecutablesPath, execName)
    require(executable.exists()) { &quot;There is no $execName executable in $javaExecutablesPath&quot; }
    return executable.toString()
}
tasks.withType&lt;JavaCompile&gt;().configureEach {
    options.apply {
        isFork = true
        forkOptions.javaHome = file(java6Home)
    }
}
tasks.withType&lt;Javadoc&gt;().configureEach {
    executable = javaExecutable(&quot;javadoc&quot;)
}
tasks.withType&lt;Test&gt;().configureEach {
    executable = javaExecutable(&quot;java&quot;)
}
tasks.withType&lt;JavaExec&gt;.configureEach {
    executable = javaExecutable(&quot;java&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="idea_plugin"><a class="anchor" href="#idea_plugin"></a> <a class="link" href="#idea_plugin">IDEA插件</a></h3>
<div class="paragraph">
<p>IDEA插件会生成<a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>所使用的文件，从而可以从IDEA打开项目（ <code>File</code> -- <code>Open Project</code> ）。外部依赖项（包括关联的源文件和Javadoc文件）和项目依赖项均被考虑。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果仅要将Gradle项目加载到IntelliJ IDEA中，请使用IDE的<a href="https://www.jetbrains.com/help/idea/gradle.html#gradle_import">导入工具</a> 。您不需要应用此插件即可将项目导入IDEA，尽管如果这样做，导入将考虑您具有的任何其他IDEA配置，这些配置不会直接修改生成的文件-有关更多详细信息，请参见“ <a href="#sec:idea_configuration">配置”</a>部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>IDEA插件生成的确切内容取决于所使用的其他插件：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>总是</strong></dt>
<dd>
<p>生成一个IDEA模块文件。如果项目是根项目，还将生成一个IDEA项目和工作区文件。</p>
</dd>
<dt class="hdlist1"><strong><a href="#java_plugin">Java插件</a></strong></dt>
<dd>
<p>另外，将Java配置添加到IDEA模块和项目文件中。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>IDEA插件的一个重点是开放定制。该插件提供了一组标准的挂钩，用于在生成的文件中添加和删除内容。</p>
</div>
<div class="sect3">
<h4 id="sec:idea_usage"><a class="anchor" href="#sec:idea_usage"></a> <a class="link" href="#sec:idea_usage">用法</a></h4>
<div class="paragraph">
<p>要使用IDEA插件，请将其包含在您的构建脚本中：</p>
</div>
<div class="exampleblock">
<div class="title">示例564。使用IDEA插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">idea</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    idea
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>IDEA插件为您的项目添加了许多任务。的<code>idea</code>任务为项目生成一个IDEA模块文件。当项目是根项目时， <code>idea</code>任务还会生成一个IDEA项目和工作区。IDEA项目包含Gradle构建中每个项目的模块。</p>
</div>
<div class="paragraph">
<p>IDEA插件还添加了一个<code>openIdea</code>项目是根项目时的任务。此任务将生成IDEA配置文件，并在IDEA中打开结果。这意味着您可以简单地运行<code>./gradlew openIdea</code>从根项目开始，只需一个方便的步骤即可生成并打开IDEA项目。</p>
</div>
<div class="paragraph">
<p>IDEA插件还添加了一个<code>cleanIdea</code>项目任务。如果存在，此任务将删除生成的文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:idea_tasks"><a class="anchor" href="#sec:idea_tasks"></a> <a class="link" href="#sec:idea_tasks">任务</a></h4>
<div class="paragraph">
<p>IDEA插件将以下所示的任务添加到项目中。请注意<code>clean</code>任务不取决于<code>cleanIdeaWorkspace</code>任务。这是因为工作区通常包含许多用户特定的临时数据，因此不希望在IDEA外部对其进行操作。</p>
</div>
<div id="ideatasks" class="dlist">
<dl>
<dt class="hdlist1"><code>idea</code></dt>
<dd>
<p><em>取决于</em> ： <code>ideaProject</code> ， <code>ideaModule</code> ，<code>ideaWorkspace</code></p>
<div class="paragraph">
<p>生成所有IDEA配置文件</p>
</div>
</dd>
<dt class="hdlist1"><code>openIdea</code></dt>
<dd>
<p><em>取决于</em> ：<code>idea</code></p>
<div class="paragraph">
<p>生成所有IDEA配置文件并在IDEA中打开项目</p>
</div>
</dd>
<dt class="hdlist1"><code>cleanIdea</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<p><em>取决于</em> ： <code>cleanIdeaProject</code> ，<code>cleanIdeaModule</code></p>
<div class="paragraph">
<p>删除所有IDEA配置文件</p>
</div>
</dd>
<dt class="hdlist1"><code>cleanIdeaProject</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<p>删除IDEA项目文件</p>
</dd>
<dt class="hdlist1"><code>cleanIdeaModule</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<p>删除IDEA模块文件</p>
</dd>
<dt class="hdlist1"><code>cleanIdeaWorkspace</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<p>删除IDEA工作区文件</p>
</dd>
<dt class="hdlist1"><code>ideaProject</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.GenerateIdeaProject.html">GenerateIdeaProject</a></dt>
<dd>
<p>产生<code>.ipr</code>文件。该任务仅添加到根项目中。</p>
</dd>
<dt class="hdlist1"><code>ideaModule</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.GenerateIdeaModule.html">GenerateIdeaModule</a></dt>
<dd>
<p>产生<code>.iml</code>文件</p>
</dd>
<dt class="hdlist1"><code>ideaWorkspace</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.GenerateIdeaWorkspace.html">GenerateIdeaWorkspace</a></dt>
<dd>
<p>产生<code>.iws</code>文件。该任务仅添加到根项目中。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:idea_configuration"><a class="anchor" href="#sec:idea_configuration"></a> <a class="link" href="#sec:idea_configuration">组态</a></h4>
<div class="paragraph">
<p>该插件添加了一些配置选项，允许自定义其生成的IDEA项目和模块文件。这些采用模型属性和直接修改所生成文件的低级机制的形式。例如，您可以添加源目录和资源目录，以及注入自己的XML片段。 IDEA的导入工具支持前一种配置，而后者则不支持。</p>
</div>
<div class="paragraph">
<p>这是您可以使用的配置属性：</p>
</div>
<div id="idea-configuration" class="dlist">
<dl>
<dt class="hdlist1"><code>idea</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.model.IdeaModel.html">IdeaModel</a></dt>
<dd>
<p>顶级元素，可通过DSL友好方式配置想法插件</p>
</dd>
<dt class="hdlist1"><code>idea.project</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.model.IdeaProject.html">创意计划</a></dt>
<dd>
<p>允许配置项目信息</p>
</dd>
<dt class="hdlist1"><code>idea.module</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html">IdeaModule</a></dt>
<dd>
<p>允许配置模块信息</p>
</dd>
<dt class="hdlist1"><code>idea.workspace</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.model.IdeaWorkspace.html">IdeaWorkspace</a></dt>
<dd>
<p>允许配置工作区XML</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>单击类型的链接，以获取使用这些配置属性的示例。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:idea_customizing_the_generated_files"><a class="anchor" href="#sec:idea_customizing_the_generated_files"></a> <a class="link" href="#sec:idea_customizing_the_generated_files">自定义生成的文件</a></h4>
<div class="paragraph">
<p>IDEA插件提供了钩子和行为，以更加可控和详细的方式自定义生成的内容。除此之外<code>withXml</code>钩子是修改工作空间文件的唯一实用方法，因为其对应的域对象实际上是空的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">我们在本节中讨论的技术不适用于IDEA的导入工具</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这些任务将识别现有的IDEA文件并将其与生成的内容合并。</p>
</div>
<div class="sect4">
<h5 id="sec:merging_with_idea_files"><a class="anchor" href="#sec:merging_with_idea_files"></a> <a class="link" href="#sec:merging_with_idea_files">合并中</a></h5>
<div class="paragraph">
<p>根据特定的部分，将修改或覆盖既是生成内容又是目标的现有IDEA文件的部分。其余部分将保持不变。</p>
</div>
<div class="sect5">
<h6 id="sec:complete_overwrite_of_idea_files"><a class="anchor" href="#sec:complete_overwrite_of_idea_files"></a> <a class="link" href="#sec:complete_overwrite_of_idea_files">禁用合并并覆盖完整内容</a></h6>
<div class="paragraph">
<p>要完全重写现有的IDEA文件，请执行清理任务及其相应的生成任务，例如“ <code>gradle cleanIdea idea</code> “ （以该顺序）。如果要将其设为默认行为，请添加“ <code>tasks.idea.dependsOn(cleanIdea)</code> ”添加到您的构建脚本中。这使得不必显式执行清理任务。</p>
</div>
<div class="paragraph">
<p>此策略还可用于插件将生成的单个文件。例如，可以针对“ <code>.iml</code>带有“ <code>gradle cleanIdeaModule ideaModule</code> ”。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:hooking_into_the_idea_generation_lifecycle"><a class="anchor" href="#sec:hooking_into_the_idea_generation_lifecycle"></a> <a class="link" href="#sec:hooking_into_the_idea_generation_lifecycle">融入一代生命周期</a></h5>
<div class="paragraph">
<p>该插件提供了对Gradle生成的元数据文件的各个部分进行建模的对象。生成生命周期如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>读取文件；或使用Gradle提供的默认版本（如果不存在）</p>
</li>
<li>
<p>的<code>beforeMerged</code>挂钩是使用代表现有文件的域对象执行的</p>
</li>
<li>
<p>现有内容与从Gradle构建推断的配置合并或在Eclipse DSL中明确定义</p>
</li>
<li>
<p>的<code>whenMerged</code>钩子是使用域对象执行的，该域对象表示要持久保存的文件的内容</p>
</li>
<li>
<p>的<code>withXml</code>使用将保留的XML的原始表示执行钩子</p>
</li>
<li>
<p>最终的XML被保留</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下是用于每种模型类型的域对象：</p>
</div>
<div id="idea-hooks" class="dlist">
<dl>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.model.IdeaProject.html">创意计划</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/Project.html">Project</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/Project.html">Project</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withXml { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/XmlProvider.html">XmlProvider</a> arg -> …​ }</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/IdeaModule.html">IdeaModule</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/Module.html">Module</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/Module.html">Module</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withXml { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/XmlProvider.html">XmlProvider</a> arg -> …​ }</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/IdeaWorkspace.html">IdeaWorkspace</a></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>beforeMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/Workspace.html">Workspace</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>whenMerged { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/ide/idea/model/Workspace.html">Workspace</a> arg -> …​ }</code></p>
</li>
<li>
<p><code>withXml { <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/XmlProvider.html">XmlProvider</a> arg -> …​ }</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="sect5">
<h6 id="sec:partial-rewrite"><a class="anchor" href="#sec:partial-rewrite"></a> <a class="link" href="#sec:partial-rewrite">部分重写现有内容</a></h6>
<div class="paragraph">
<p>“完全重写”会导致所有现有内容被丢弃，从而丢失直接在IDE中所做的任何更改。的<code>beforeMerged</code>钩子使得仅覆盖现有内容的某些部分成为可能。以下示例从<code>Module</code>域对象：</p>
</div>
<div class="exampleblock">
<div class="title">实施例565。模块的部分重写</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">idea.module.iml {
    beforeMerged { module -&gt;
        module.dependencies.clear()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.plugins.ide.idea.model.Module

idea.module.iml {
    beforeMerged(Action&lt;Module&gt; {
        dependencies.clear()
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生成的模块文件将仅包含Gradle生成的依赖项，而不包含原始文件中可能存在的任何其他依赖项。（对于依赖项，这也是默认行为。）模块文件的其他部分将保持不变或合并。可以对项目文件中的模块路径执行相同的操作：</p>
</div>
<div class="exampleblock">
<div class="title">实施例566。部分重写项目</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">idea.project.ipr {
    beforeMerged { project -&gt;
        project.modulePaths.clear()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.plugins.ide.idea.model.Project

idea.project.ipr {
    beforeMerged(Action&lt;Project&gt; {
        modulePaths.clear()
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:idea_modify_domain_objects"><a class="anchor" href="#sec:idea_modify_domain_objects"></a> <a class="link" href="#sec:idea_modify_domain_objects">修改完全填充的域对象</a></h6>
<div class="paragraph">
<p>的<code>whenMerged</code>钩子允许您操纵完全填充的域对象。通常，这是自定义IDEA文件的首选方法。这是导出IDEA模块的所有依赖项的方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例567出口依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">idea.module.iml {
    whenMerged { module -&gt;
        module.dependencies*.exported = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.gradle.plugins.ide.idea.model.Module
import org.gradle.plugins.ide.idea.model.ModuleDependency

idea.module.iml {
    whenMerged(Action&lt;Module&gt; {
        dependencies.forEach {
            (it as ModuleDependency).isExported = true
        }
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sec:idea_modify_xml"><a class="anchor" href="#sec:idea_modify_xml"></a> <a class="link" href="#sec:idea_modify_xml">修改XML表示</a></h6>
<div class="paragraph">
<p>的<code>withXml</code>钩子使您可以在将文件写入磁盘之前操作内存中的XML表示形式。尽管Groovy的XML支持和Kotlin的扩展功能弥补了很多，但这种方法比操作域对象要方便得多。作为回报，您可以完全控制所生成的文件，包括未由域对象建模的部分。</p>
</div>
<div class="exampleblock">
<div class="title">示例568自定义XML</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">idea.project.ipr {
    withXml { provider -&gt;
        provider.node.component
                .find { <span class="local-variable">it</span>.@name == <span class="string"><span class="delimiter">'</span><span class="content">VcsDirectoryMappings</span><span class="delimiter">'</span></span> }
                .mapping.@vcs = <span class="string"><span class="delimiter">'</span><span class="content">Git</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">import org.w3c.dom.Element

idea.project.ipr {
    withXml(Action&lt;XmlProvider&gt; {
        fun Element.firstElement(predicate: (Element.() -&gt; Boolean)) =
            childNodes
                .run { (0 until length).map(::item) }
                .filterIsInstance&lt;Element&gt;()
                .first { it.predicate() }

        asElement()
            .firstElement { tagName == &quot;component&quot; &amp;&amp; getAttribute(&quot;name&quot;) == &quot;VcsDirectoryMappings&quot; }
            .firstElement { tagName == &quot;mapping&quot; }
            .setAttribute(&quot;vcs&quot;, &quot;Git&quot;)
    })
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:further_things_to_consider"><a class="anchor" href="#sec:further_things_to_consider"></a> <a class="link" href="#sec:further_things_to_consider">需要考虑的其他事项</a></h4>
<div class="paragraph">
<p>生成的IDEA文件中依赖项的路径是绝对的。如果您手动定义指向Gradle依赖项缓存的路径变量，则IDEA将自动用此路径变量替换绝对依赖项路径。您可以通过“ <code>idea.pathVariables</code> ”属性，这样它就可以进行正确的合并而不会创建重复项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing_ivy"><a class="anchor" href="#publishing_ivy"></a> <a class="link" href="#publishing_ivy">常春藤发布插件</a></h3>
<div class="paragraph">
<p>Ivy Publish插件提供了以<a href="http://ant.apache.org/ivy/">Apache Ivy</a>格式发布构建工件的功能，通常将其发布到存储库以供其他构建或项目使用。发布的内容是由构建创建的一个或多个工件，以及一个Ivy <em>模块描述符</em> （通常是<code>ivy.xml</code> ），以描述工件和工件的依赖关系（如果有）。</p>
</div>
<div class="paragraph">
<p>Gradle（请参阅<a href="#declaring-dependencies">声明依赖项</a> ）和其他了解Ivy格式的工具可以使用已发布的Ivy模块。您可以在<a href="#publishing_overview">发布概述中</a>了解发布的基础知识。</p>
</div>
<div class="sect3">
<h4 id="publishing_ivy:usage"><a class="anchor" href="#publishing_ivy:usage"></a> <a class="link" href="#publishing_ivy:usage">用法</a></h4>
<div class="paragraph">
<p>要使用Ivy Publish插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例569。应用常春藤发布插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">ivy-publish</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `ivy-publish`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ivy Publish Plugin使用名为项目的扩展<code>publishing</code>类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.PublishingExtension.html">PublishingExtension</a> 。此扩展提供了一个命名出版物的容器和一个命名存储库的容器。Ivy Publish插件可与<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html">IvyPublication</a>出版物和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html">IvyArtifactRepository</a>仓库一起使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="publishing_ivy:tasks"><a class="anchor" href="#publishing_ivy:tasks"></a> <a class="link" href="#publishing_ivy:tasks">任务</a></h4>
<div id="publishing_ivy:descriptor" class="dlist">
<dl>
<dt class="hdlist1"><code>generateDescriptorFileFor<em>PubName</em>Publication</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.tasks.GenerateIvyDescriptor.html">GenerateIvyDescriptor</a></dt>
<dd>
<p>为名为<em>PubName</em>的发布创建一个Ivy描述符文件，填充已知的元数据，例如项目名称，项目版本和依赖项。描述符文件的默认位置是<em>build / publications / $ pubName / ivy.xml</em> 。</p>
</dd>
<dt class="hdlist1"><code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html">PublishToIvyRepository</a></dt>
<dd>
<p>将<em>PubName</em>发布发布到名为<em>RepoName</em>的存储库。如果您的存储库定义中没有明确的名称，则<em>RepoName</em>将为“ Ivy”。</p>
</dd>
<dt class="hdlist1"><code>publish</code></dt>
<dd>
<p><em>取决于</em> ：全部<code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code>任务</p>
<div class="paragraph">
<p>将所有定义的发布发布到所有定义的存储库的聚合任务。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="publishing_ivy:publications"><a class="anchor" href="#publishing_ivy:publications"></a> <a class="link" href="#publishing_ivy:publications">刊物</a></h4>
<div class="paragraph">
<p>此插件提供<a href="#sub:terminology_publication">出版物</a>类型的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html">IvyPublication</a> 。要了解如何定义和使用出版物，请参见<a href="#sec:basic_publishing">基本出版</a>部分。</p>
</div>
<div class="paragraph">
<p>您可以在Ivy发布中配置以下四项主要内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个<a href="#sub:terminology_component">组件</a> —通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html#org.gradle.api.publish.ivy.IvyPublication:from(org.gradle.api.component.SoftwareComponent)">IvyPublication.from（org.gradle.api.component。软件组件）</a> 。</p>
</li>
<li>
<p><a href="#sec:publishing_custom_artifacts_to_maven">自定义工件</a> -通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html#org.gradle.api.publish.ivy.IvyPublication:artifact(java.lang.Object)">IvyPublication.artifact（java.lang。对象）</a>方法。有关自定义Ivy工件的可用配置选项，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyArtifact.html">IvyArtifact</a> 。</p>
</li>
<li>
<p>标准元数据，例如<code>module</code> ， <code>organisation</code>和<code>revision</code> 。</p>
</li>
<li>
<p>模块描述符的其他内容-通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html#org.gradle.api.publish.ivy.IvyPublication:descriptor(org.gradle.api.Action)">IvyPublication.descriptor（org.gradle.api。动作）</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在<a href="#publishing_ivy:example">完整的发布示例中</a>看到所有这些内容。的API文档<code>IvyPublication</code>有其他代码示例。</p>
</div>
<div class="sect4">
<h5 id="sec:identity_values_for_the_published_project"><a class="anchor" href="#sec:identity_values_for_the_published_project"></a> <a class="link" href="#sec:identity_values_for_the_published_project">已发布项目的标识值</a></h5>
<div class="paragraph">
<p>生成的Ivy模块描述符文件包含一个<code><info></code>标识模块的元素。默认标识值从以下派生：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>organisation</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:group">-Project.getGroup（）</a></p>
</li>
<li>
<p><code>module</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:name">-Project.getName（）</a></p>
</li>
<li>
<p><code>revision</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:version">-Project.getVersion（）</a></p>
</li>
<li>
<p><code>status</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:status">-Project.getStatus（）</a></p>
</li>
<li>
<p><code>branch</code> - （没有设置）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>覆盖默认身份值很容易：只需指定<code>organisation</code> ， <code>module</code>要么<code>revision</code>配置<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html">IvyPublication</a>时的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyPublication.html">属性</a> 。 <code>status</code>和<code>branch</code>可以通过设置<code>descriptor</code>属性—请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html">IvyModuleDescriptorSpec</a> 。</p>
</div>
<div class="paragraph">
<p>的<code>descriptor</code>属性也可以用于添加其他自定义元素作为<code><info></code>元素，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">例子570.自定义发布身份</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    publications {
        ivy(IvyPublication) {
            organisation = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>
            module = <span class="string"><span class="delimiter">'</span><span class="content">project1-sample</span><span class="delimiter">'</span></span>
            revision = <span class="string"><span class="delimiter">'</span><span class="content">1.1</span><span class="delimiter">'</span></span>
            descriptor.status = <span class="string"><span class="delimiter">'</span><span class="content">milestone</span><span class="delimiter">'</span></span>
            descriptor.branch = <span class="string"><span class="delimiter">'</span><span class="content">testing</span><span class="delimiter">'</span></span>
            descriptor.extraInfo <span class="string"><span class="delimiter">'</span><span class="content">http://my.namespace</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">myElement</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Some value</span><span class="delimiter">'</span></span>

            from components.java
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    publications {
        create&lt;IvyPublication&gt;(&quot;ivy&quot;) {
            organisation = &quot;org.gradle.sample&quot;
            module = &quot;project1-sample&quot;
            revision = &quot;1.1&quot;
            descriptor.status = &quot;milestone&quot;
            descriptor.branch = &quot;testing&quot;
            descriptor.extraInfo(&quot;http://my.namespace&quot;, &quot;myElement&quot;, &quot;Some value&quot;)

            from(components[&quot;java&quot;])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>某些存储库无法处理所有受支持的字符。例如， <code>:</code>在Windows上发布到支持文件系统的存储库时，不能将该字符用作标识符。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Gradle将处理以下任何有效的Unicode字符<code>organisation</code> ， <code>module</code>和<code>revision</code> （以及工件的<code>name</code> ， <code>extension</code>和<code>classifier</code> ）。明确禁止的唯一值是<code>\</code> ， <code>/</code>以及任何ISO控制字符。提供的值在发布过程的早期就得到了验证。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:modifying_the_generated_module_descriptor"><a class="anchor" href="#sec:modifying_the_generated_module_descriptor"></a> <a class="link" href="#sec:modifying_the_generated_module_descriptor">自定义生成的模块描述符</a></h5>
<div class="paragraph">
<p>有时，需要在发布之前对从项目信息生成的模块描述符文件进行调整。Ivy Publish Plugin为此提供了DSL。请参阅《 DSL参考》中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html">IvyModuleDescriptorSpec</a> ，以获取可用属性和方法的完整文档。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用DSL最常见的方面：</p>
</div>
<div class="exampleblock">
<div class="title">示例571定制模块描述符文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    publications {
        ivyCustom(IvyPublication) {
            descriptor {
                license {
                    name = <span class="string"><span class="delimiter">'</span><span class="content">The Apache License, Version 2.0</span><span class="delimiter">'</span></span>
                    url = <span class="string"><span class="delimiter">'</span><span class="content">http://www.apache.org/licenses/LICENSE-2.0.txt</span><span class="delimiter">'</span></span>
                }
                author {
                    name = <span class="string"><span class="delimiter">'</span><span class="content">Jane Doe</span><span class="delimiter">'</span></span>
                    url = <span class="string"><span class="delimiter">'</span><span class="content">http://example.com/users/jane</span><span class="delimiter">'</span></span>
                }
                description {
                    text = <span class="string"><span class="delimiter">'</span><span class="content">A concise description of my library</span><span class="delimiter">'</span></span>
                    homepage = <span class="string"><span class="delimiter">'</span><span class="content">http://www.example.com/library</span><span class="delimiter">'</span></span>
                }
            }
            versionMapping {
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-api</span><span class="delimiter">'</span></span>) {
                    fromResolutionOf(<span class="string"><span class="delimiter">'</span><span class="content">runtimeClasspath</span><span class="delimiter">'</span></span>)
                }
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-runtime</span><span class="delimiter">'</span></span>) {
                    fromResolutionResult()
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    publications {
        create&lt;IvyPublication&gt;(&quot;ivyCustom&quot;) {
            descriptor {
                license {
                    name.set(&quot;The Apache License, Version 2.0&quot;)
                    url.set(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)
                }
                author {
                    name.set(&quot;Jane Doe&quot;)
                    url.set(&quot;http://example.com/users/jane&quot;)
                }
                description {
                    text.set(&quot;A concise description of my library&quot;)
                    homepage.set(&quot;http://www.example.com/library&quot;)
                }
            }
            versionMapping {
                usage(&quot;java-api&quot;) {
                    fromResolutionOf(&quot;runtimeClasspath&quot;)
                }
                usage(&quot;java-runtime&quot;) {
                    fromResolutionResult()
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们只是在生成的Ivy依赖项描述符中添加了一个'description'元素，但是该钩子允许您修改生成的描述符的任何方面。例如，您可以将用于依赖项的版本范围替换为用于生成内部版本的实际版本。</p>
</div>
<div class="paragraph">
<p>您还可以通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html#org.gradle.api.publish.ivy.IvyModuleDescriptorSpec:withXml(org.gradle.api.Action)">IvyModuleDescriptorSpec.withXml（org.gradle.api将任意XML添加到描述符文件</a><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html#org.gradle.api.publish.ivy.IvyModuleDescriptorSpec:withXml(org.gradle.api.Action)">。操作）</a> ，但您不能使用它来修改模块标识符的任何部分（组织，模块，修订版）。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">可以以不再是有效的Ivy模块描述符的方式修改描述符，因此在使用此功能时必须小心。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="publishing_ivy:resolved_dependencies"><a class="anchor" href="#publishing_ivy:resolved_dependencies"></a> <a class="link" href="#publishing_ivy:resolved_dependencies">自定义依赖项版本</a></h5>
<div class="paragraph">
<p>支持两种策略来发布依赖项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">声明的版本（默认）</dt>
<dd>
<p>该策略会发布构建脚本作者定义的版本，并在其中声明依赖项。 <code>dependencies</code>块。发布不会考虑任何其他类型的处理，例如通过<a href="#">更改已解决版本的规则</a>进行的处理。</p>
</dd>
<dt class="hdlist1">解决的版本</dt>
<dd>
<p>此策略可能会通过应用解决方案规则和自动冲突解决方案来发布在构建期间已解决的版本。这样做的好处是，发布的版本对应于测试发布的工件的版本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>解析版本的示例用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>项目将动态版本用于依赖项，但更喜欢将给定版本的已解析版本公开给其使用者。</p>
</li>
<li>
<p>与<a href="#">依赖项锁定</a>结合使用，您要发布锁定的版本。</p>
</li>
<li>
<p>一个项目利用了Gradle的丰富版本约束，这些约束对Ivy进行了有损转换。它不依赖转换，而是发布已解决的版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是通过使用<code>versionMapping</code>允许配置<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/publish/VersionMappingStrategy.html">VersionMappingStrategy的</a> DSL方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例572使用已解决的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    publications {
        ivyCustom(IvyPublication) {
            versionMapping {
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-api</span><span class="delimiter">'</span></span>) {
                    fromResolutionOf(<span class="string"><span class="delimiter">'</span><span class="content">runtimeClasspath</span><span class="delimiter">'</span></span>)
                }
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-runtime</span><span class="delimiter">'</span></span>) {
                    fromResolutionResult()
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    publications {
        create&lt;IvyPublication&gt;(&quot;ivyCustom&quot;) {
            versionMapping {
                usage(&quot;java-api&quot;) {
                    fromResolutionOf(&quot;runtimeClasspath&quot;)
                }
                usage(&quot;java-runtime&quot;) {
                    fromResolutionResult()
                }
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，Gradle将使用在<code>runtimeClasspath</code>对于在中声明的依赖项<code>api</code> ，它们映射到<code>compile</code>常春藤的配置。Gradle还将使用在<code>runtimeClasspath</code>对于在中声明的依赖项<code>implementation</code> ，它们映射到<code>runtime</code>常春藤的配置。
<code>fromResolutionResult()</code>指示Gradle应该使用变体的默认类路径，并且<code>runtimeClasspath</code>是的默认类路径<code>java-runtime</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="publishing_ivy:repositories"><a class="anchor" href="#publishing_ivy:repositories"></a> <a class="link" href="#publishing_ivy:repositories">储存库</a></h4>
<div class="paragraph">
<p>该插件提供了<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html">IvyArtifactRepository</a>类型的<a href="#sub:terminology_repository">存储库</a> 。要了解如何定义和使用存储库进行发布，请参见“ <a href="#sec:basic_publishing">基本发布</a> ”部分。</p>
</div>
<div class="paragraph">
<p>这是定义发布存储库的简单示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例573声明要发布到的存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    repositories {
        ivy {
            <span class="comment">// change to point to your repo, e.g. http://my.org/repo</span>
            url = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repo</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    repositories {
        ivy {
            // change to point to your repo, e.g. http://my.org/repo
            url = uri(&quot;$buildDir/repo&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您将要配置的两件事是存储库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网址（必填）</p>
</li>
<li>
<p>名称（可选）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以定义多个存储库，只要它们在构建脚本中具有唯一的名称即可。您也可以声明一个（只有一个）没有名称的存储库。该存储库将采用隐式名称“ Ivy”。</p>
</div>
<div class="paragraph">
<p>您还可以配置连接到存储库所需的任何身份验证详细信息。有关更多详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html">IvyArtifactRepository</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="publishing_ivy:example"><a class="anchor" href="#publishing_ivy:example"></a> <a class="link" href="#publishing_ivy:example">完整的例子</a></h4>
<div class="paragraph">
<p>下面的示例演示了使用多项目构建的发布。每个项目都发布一个Java组件，该Java组件配置为还构建和发布Javadoc和源代码工件。定制描述符文件以包括每个项目的项目描述。</p>
</div>
<div class="exampleblock">
<div class="title">示例574发布Java模块</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
    apply <span class="key">plugin</span>: <span class="string"><span class="delimiter">'</span><span class="content">ivy-publish</span><span class="delimiter">'</span></span>

    version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>
    group = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>

    repositories {
        mavenCentral()
    }
    java {
        withJavadocJar()
        withSourcesJar()
    }
}

project(<span class="string"><span class="delimiter">'</span><span class="content">:project1</span><span class="delimiter">'</span></span>) {
    description = <span class="string"><span class="delimiter">'</span><span class="content">The first project</span><span class="delimiter">'</span></span>

    dependencies {
        implementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
        implementation project(<span class="string"><span class="delimiter">'</span><span class="content">:project2</span><span class="delimiter">'</span></span>)
    }
}

project(<span class="string"><span class="delimiter">'</span><span class="content">:project2</span><span class="delimiter">'</span></span>) {
    description = <span class="string"><span class="delimiter">'</span><span class="content">The second project</span><span class="delimiter">'</span></span>

    dependencies {
        implementation <span class="string"><span class="delimiter">'</span><span class="content">commons-collections:commons-collections:3.2.2</span><span class="delimiter">'</span></span>
    }
}

subprojects {
    publishing {
        repositories {
            ivy {
                <span class="comment">// change to point to your repo, e.g. http://my.org/repo</span>
                url = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>rootProject.buildDir<span class="inline-delimiter">}</span></span><span class="content">/repo</span><span class="delimiter">&quot;</span></span>
            }
        }
        publications {
            ivy(IvyPublication) {
                from components.java
                descriptor.description {
                    text = description
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    apply(plugin = &quot;java&quot;)
    apply(plugin = &quot;ivy-publish&quot;)

    version = &quot;1.0&quot;
    group = &quot;org.gradle.sample&quot;

    repositories {
        mavenCentral()
    }
    val java = extensions.getByType&lt;JavaPluginExtension&gt;()
    java.withJavadocJar()
    java.withSourcesJar()
}

project(&quot;:project1&quot;) {
    description = &quot;The first project&quot;

    dependencies {
        &quot;implementation&quot;(&quot;junit:junit:4.12&quot;)
        &quot;implementation&quot;(project(&quot;:project2&quot;))
    }
}

project(&quot;:project2&quot;) {
    description = &quot;The second project&quot;

    dependencies {
        &quot;implementation&quot;(&quot;commons-collections:commons-collections:3.2.2&quot;)
    }
}

subprojects {
    configure&lt;PublishingExtension&gt;() {
        repositories {
            ivy {
                // change to point to your repo, e.g. http://my.org/repo
                url = uri(&quot;${rootProject.buildDir}/repo&quot;)
            }
        }
        publications {
            create&lt;IvyPublication&gt;(&quot;ivy&quot;) {
                from(components[&quot;java&quot;])
                descriptor.description {
                    text.set(description)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>结果是将为每个项目发布以下工件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle模块元数据文件： <code>project1-1.0.module</code> 。</p>
</li>
<li>
<p>常春藤模块元数据文件： <code>ivy-1.0.xml</code> 。</p>
</li>
<li>
<p>Java组件的主要JAR工件： <code>project1-1.0.jar</code> 。</p>
</li>
<li>
<p>Javadoc和Java组件的源JAR工件（因为我们已配置<code>withJavadocJar()</code>和<code>withSourcesJar()</code> ）： <code>project1-1.0-javadoc.jar</code> ， <code>project1-1.0-source.jar</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:pub_ivy:legacy_migration"><a class="anchor" href="#sec:pub_ivy:legacy_migration"></a> <a class="link" href="#sec:pub_ivy:legacy_migration">从旧版Ivy出版物迁移</a></h4>
<div class="paragraph">
<p>如果要迁移以前依赖于<a href="artifact_management.html">旧版发布</a>支持的项目，则会发现以下两种解决方案之间的差异。</p>
</div>
<div class="sect4">
<h5 id="configurations_marked_as_non_transitive"><a class="anchor" href="#configurations_marked_as_non_transitive"></a> <a class="link" href="#configurations_marked_as_non_transitive">标记为不可传递的配置</a></h5>
<div class="paragraph">
<p>当配置标记为<code>transitive = false</code> ，这没有映射到常春藤。</p>
</div>
<div class="paragraph">
<p>Gradle将发出警告，指出已发布此类配置。如果确实需要发布此建议，则建议使用依赖级别<code>transitive = false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="forced_dependencies_are_not_mapped"><a class="anchor" href="#forced_dependencies_are_not_mapped"></a> <a class="link" href="#forced_dependencies_are_not_mapped">强制依赖关系未映射</a></h5>
<div class="paragraph">
<p>虽然常春藤支持<a href="https://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependency.html#_forcing_revision"><code>force</code>在依赖项上</a> ，Gradle不会映射其自身已弃用的<code>force</code>声明。</p>
</div>
<div class="paragraph">
<p>相反，建议更换Gradle <code>force</code>与一个<a href="#sec:strict-version"><code>strictly</code>版本</a> ，它提供了<a href="#sec:enforcing_dependency_version">更好的语义</a> ，并且受Gradle模块元数据格式的支持。</p>
</div>
<div class="paragraph">
<p>请注意，如果您绝对需要发布力量，仍然可以<a href="#sec:modifying_the_generated_module_descriptor">修改生成的<code>ivy.xml</code></a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jacoco_plugin"><a class="anchor" href="#jacoco_plugin"></a> <a class="link" href="#jacoco_plugin">JaCoCo插件</a></h3>
<div class="paragraph">
<p>JaCoCo插件通过与<a href="http://www.eclemma.org/jacoco/">JaCoCo</a>集成提供Java代码的代码覆盖率指标。</p>
</div>
<div class="sect3">
<h4 id="sec:jacoco_getting_started"><a class="anchor" href="#sec:jacoco_getting_started"></a> <a class="link" href="#sec:jacoco_getting_started">入门</a></h4>
<div class="paragraph">
<p>首先，将JaCoCo插件应用于您要为其计算代码覆盖率的项目。</p>
</div>
<div class="exampleblock">
<div class="title">示例575应用JaCoCo插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">jacoco</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    jacoco
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果Java插件也应用于您的项目，则一个名为<code>jacocoTestReport</code>被建造。请注意，虽然应该在生成报告之前执行测试， <code>jacocoTestReport</code>任务不取决于<code>test</code>任务。默认情况下，将在以下位置生成HTML报告<code><em>$buildDir</em>/reports/jacoco/test</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:configuring_the_jacoco_plugin"><a class="anchor" href="#sec:configuring_the_jacoco_plugin"></a> <a class="link" href="#sec:configuring_the_jacoco_plugin">配置JaCoCo插件</a></h4>
<div class="paragraph">
<p>JaCoCo插件添加了一个项目扩展名为<code>jacoco</code>类型<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.plugins.JacocoPluginExtension.html">JacocoPluginExtension</a> ，它允许在构建中配置JaCoCo使用的默认值。</p>
</div>
<div class="exampleblock">
<div class="title">范例576。配置JaCoCo插件设置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jacoco {
    toolVersion = <span class="string"><span class="delimiter">&quot;</span><span class="content">0.8.5</span><span class="delimiter">&quot;</span></span>
    reportsDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/customJacocoReportDir</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">jacoco {
    toolVersion = &quot;0.8.5&quot;
    reportsDir = file(&quot;$buildDir/customJacocoReportDir&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表29。JaCoCo属性的Gradle默认值</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">Gradle默认</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">报告目录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>$buildDir</em>/reports/jacoco</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:jacoco_report_configuration"><a class="anchor" href="#sec:jacoco_report_configuration"></a> <a class="link" href="#sec:jacoco_report_configuration">JaCoCo报告配置</a></h4>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html">JacocoReport</a>任务可用于生成不同格式的代码覆盖率报告。它实现了标准的Gradle类型<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.reporting.Reporting.html">Reporting</a>并公开了<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testing/jacoco/tasks/JacocoReportsContainer.html">JacocoReportsContainer</a>类型的报告容器。</p>
</div>
<div class="exampleblock">
<div class="title">示例577配置测试任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jacocoTestReport {
    reports {
        xml.enabled <span class="predefined-constant">false</span>
        csv.enabled <span class="predefined-constant">false</span>
        html.destination file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>buildDir<span class="inline-delimiter">}</span></span><span class="content">/jacocoHtml</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.jacocoTestReport {
    reports {
        xml.isEnabled = false
        csv.isEnabled = false
        html.destination = file(&quot;${buildDir}/jacocoHtml&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/jacocoHtmlReport.png" alt="JaCoCo HTML报告" width="903" height="277">
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:jacoco_report_violation_rules"><a class="anchor" href="#sec:jacoco_report_violation_rules"></a> <a class="link" href="#sec:jacoco_report_violation_rules">实施代码覆盖率指标</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>此功能要求使用JaCoCo 0.6.3或更高版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html">JacocoCoverageVerification</a>任务可用于根据配置的规则来验证是否满足代码覆盖率指标。其API公开方法<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testing/jacoco/tasks/JacocoCoverageVerification.html#violationRules-org.gradle.api.Action-">JacocoCoverageVerification.violationRules（org.gradle.api。操作）</a> ，用作配置规则的主要入口点。调用这些方法中的任何一个都将返回<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/testing/jacoco/tasks/rules/JacocoViolationRulesContainer.html">JacocoViolationRulesContainer</a>的实例，该实例提供了广泛的配置选项。如果不满足任何配置的规则，则构建将失败。JaCoCo仅报告第一个违反的规则。</p>
</div>
<div class="paragraph">
<p>可以为整个项目，单个文件以及特定JaCoCo特定类型的覆盖范围（例如，覆盖的行或覆盖的分支）指定代码覆盖范围要求。以下示例描述了语法。</p>
</div>
<div class="exampleblock">
<div class="title">示例578配置违反规则</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = <span class="float">0.5</span>
            }
        }

        rule {
            enabled = <span class="predefined-constant">false</span>
            element = <span class="string"><span class="delimiter">'</span><span class="content">CLASS</span><span class="delimiter">'</span></span>
            includes = [<span class="string"><span class="delimiter">'</span><span class="content">org.gradle.*</span><span class="delimiter">'</span></span>]

            limit {
                counter = <span class="string"><span class="delimiter">'</span><span class="content">LINE</span><span class="delimiter">'</span></span>
                value = <span class="string"><span class="delimiter">'</span><span class="content">TOTALCOUNT</span><span class="delimiter">'</span></span>
                maximum = <span class="float">0.3</span>
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = &quot;0.5&quot;.toBigDecimal()
            }
        }

        rule {
            enabled = false
            element = &quot;CLASS&quot;
            includes = listOf(&quot;org.gradle.*&quot;)

            limit {
                counter = &quot;LINE&quot;
                value = &quot;TOTALCOUNT&quot;
                maximum = &quot;0.3&quot;.toBigDecimal()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testing/jacoco/quickstart</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html">JacocoCoverageVerification</a>任务不是任务的依赖项<code>check</code> Java插件提供的任务。有充分的理由。该任务当前未递增，因为它没有声明任何输出。执行以下命令时，任何违反声明规则的行为都会自动导致构建失败<code>check</code>任务。对于所有用户，此行为可能并不理想。Gradle的未来版本可能会改变行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:jacoco_specific_task_configuration"><a class="anchor" href="#sec:jacoco_specific_task_configuration"></a> <a class="link" href="#sec:jacoco_specific_task_configuration">JaCoCo特定任务配置</a></h4>
<div class="paragraph">
<p>JaCoCo插件将<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.plugins.JacocoTaskExtension.html">JacocoTaskExtension</a>扩展添加到<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">Test</a>类型的所有任务。此扩展允许配置测试任务的JaCoCo特定属性。</p>
</div>
<div class="exampleblock">
<div class="title">范例579。配置测试任务</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test {
    jacoco {
        destinationFile = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/jacoco/jacocoTest.exec</span><span class="delimiter">&quot;</span></span>)
        classDumpDir = file(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/jacoco/classpathdumps</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.test {
    extensions.configure(JacocoTaskExtension::class) {
        destinationFile = file(&quot;$buildDir/jacoco/jacocoTest.exec&quot;)
        classDumpDir = file(&quot;$buildDir/jacoco/classpathdumps&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>当任务开始执行时，配置为与JaCoCo代理一起运行的任务将删除执行数据的目标文件。这确保了执行数据中不存在过时的coverage数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="default_values_of_the_jacoco_task_extension"><a class="anchor" href="#default_values_of_the_jacoco_task_extension"></a> <a class="link" href="#default_values_of_the_jacoco_task_extension">JaCoCo Task扩展的默认值</a></h5>
<div class="listingblock multi-language-text lang-groovy">
<div class="content">
<pre>test {
    jacoco {
        enabled = true
        destinationFile = file("$buildDir/jacoco/$name.exec")
        includes = []
        excludes = []
        excludeClassLoaders = []
        includeNoLocationClasses = false
        sessionId = "&lt;auto-generated value&gt;"
        dumpOnExit = true
        classDumpDir = null
        output = Output.FILE
        address = "localhost"
        port = 6300
        jmx = false
    }
}</pre>
</div>
</div>
<div class="listingblock multi-language-text lang-kotlin">
<div class="content">
<pre>tasks.getByName&lt;Test&gt;("test") {
    extensions.configure(JacocoTaskExtension::class) {
        isEnabled = true
        destinationFile = file("$buildDir/jacoco/$name.exec")
        includes = listOf()
        excludes = listOf()
        excludeClassLoaders = listOf()
        isIncludeNoLocationClasses = false
        sessionId = "&lt;auto-generated value&gt;"
        isDumpOnExit = true
        classDumpDir = null
        output = JacocoTaskExtension.Output.FILE
        address = "localhost"
        port = 6300
        isJmx = false
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>尽管“ <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试</a> ”类型的所有任务会自动增强，以在<code>java</code>插件已应用，JaCoCo插件可以增强实现<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/process/JavaForkOptions.html">JavaForkOptions的</a>任何任务。也就是说，任何派生Java进程的任务都可以用来生成coverage信息。</p>
</div>
<div class="paragraph">
<p>例如，您可以使用以下命令配置构建以生成代码覆盖率： <code>application</code>插入。</p>
</div>
<div class="exampleblock">
<div class="title">示例580使用应用程序插件生成代码覆盖率数据</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">application</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">jacoco</span><span class="delimiter">'</span></span>
}

application {
    mainClassName = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.MyMain</span><span class="delimiter">'</span></span>
}

jacoco {
    applyTo run
}

task applicationCodeCoverageReport(<span class="key">type</span>:JacocoReport) {
    executionData run
    sourceSets sourceSets.main
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    application
    jacoco
}

application {
    mainClassName = &quot;org.gradle.MyMain&quot;
}

jacoco {
    applyTo(tasks.run.get())
}

tasks.register&lt;JacocoReport&gt;(&quot;applicationCodeCoverageReport&quot;) {
    executionData(tasks.run.get())
    sourceSets(sourceSets.main.get())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">该示例的代码可以在以下位置找到<strong><code>samples/testing/jacoco/application</code></strong>在Gradle的“ -all”分布中。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">applicationCodeCoverageReport生成的覆盖率报告</div>
<div class="content">
<pre>.
└── build
    ├── jacoco
    │   └── run.exec
    └── reports
        └── jacoco
            └── applicationCodeCoverageReport
                └── html
                    └── index.html</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:jacoco_tasks"><a class="anchor" href="#sec:jacoco_tasks"></a> <a class="link" href="#sec:jacoco_tasks">任务</a></h4>
<div class="paragraph">
<p>对于也应用Java插件的项目，JaCoCo插件会自动添加以下任务：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>jacocoTestReport</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html">JacocoReport</a></dt>
<dd>
<div class="paragraph">
<p>生成测试任务的代码覆盖率报告。</p>
</div>
</dd>
<dt class="hdlist1"><code>jacocoTestCoverageVerification</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html">JacocoCoverageVerification</a></dt>
<dd>
<div class="paragraph">
<p>根据指定的测试任务规则，验证代码覆盖率指标。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:jacoco_dependency_management"><a class="anchor" href="#sec:jacoco_dependency_management"></a> <a class="link" href="#sec:jacoco_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>JaCoCo插件添加了以下依赖项配置：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表30。JaCoCo插件-依赖项配置</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jacocoAnt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JaCoCo Ant库用于运行<code>JacocoReport</code> ， <code>JacocoMerge</code>和<code>JacocoCoverageVerification</code>任务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jacocoAgent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JaCoCo代理库，用于检测被测代码。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java_plugin"><a class="anchor" href="#java_plugin"></a> <a class="link" href="#java_plugin">Java插件</a></h3>
<div class="paragraph">
<p>Java插件将Java编译以及测试和捆绑功能添加到项目中。它是许多其他JVM语言Gradle插件的基础。您可以在“ <a href="#building_java_projects">构建Java项目”</a>一章中找到Java插件的全面介绍和概述。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>如上所述，此插件添加了用于JVM项目的基本构建块。它的功能集已被其他插件取代，可以根据您的项目类型提供更多功能。与其直接将其应用到您的项目中，不如查看<code>java-library</code>要么<code>java-application</code>插件或受支持的替代JVM语言之一。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="sec:java_usage"><a class="anchor" href="#sec:java_usage"></a> <a class="link" href="#sec:java_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Java插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例581使用Java插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    java
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_tasks"><a class="anchor" href="#sec:java_tasks"></a> <a class="link" href="#sec:java_tasks">任务</a></h4>
<div class="paragraph">
<p>Java插件将许多任务添加到您的项目中，如下所示。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>compileJava</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a></dt>
<dd>
<p><em>取决于</em> ：有助于编译类路径的所有任务，包括<code>jar</code>通过项目依赖项从类路径中的项目执行任务</p>
<div class="paragraph">
<p>使用JDK编译器编译生产Java源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>processResources</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a></dt>
<dd>
<p>将生产资源复制到生产资源目录中。</p>
</dd>
<dt class="hdlist1"><code>classes</code></dt>
<dd>
<p><em>取决于</em> ： <code>compileJava</code> ，<code>processResources</code></p>
<div class="paragraph">
<p>这是一个聚合任务，仅取决于其他任务。其他插件可能会附加其他编译任务。</p>
</div>
</dd>
<dt class="hdlist1"><code>compileTestJava</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a></dt>
<dd>
<p><em>取决于</em> ： <code>classes</code> ，以及所有有助于测试编译类路径的任务</p>
<div class="paragraph">
<p>使用JDK编译器编译测试Java源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>processTestResources</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a></dt>
<dd>
<p>将测试资源复制到测试资源目录中。</p>
</dd>
<dt class="hdlist1"><code>testClasses</code></dt>
<dd>
<p><em>取决于</em> ： <code>compileTestJava</code> ，<code>processTestResources</code></p>
<div class="paragraph">
<p>这是一个聚合任务，仅取决于其他任务。其他插件可能会附加其他测试编译任务。</p>
</div>
</dd>
<dt class="hdlist1"><code>jar</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">罐子</a></dt>
<dd>
<p><em>取决于</em> ：<code>classes</code></p>
<div class="paragraph">
<p>根据附加到该文件的类和资源，组装生产JAR文件。 <code>main</code>源集。</p>
</div>
</dd>
<dt class="hdlist1"><code>javadoc</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.javadoc.Javadoc.html">Javadoc</a></dt>
<dd>
<p><em>取决于</em> ：<code>classes</code></p>
<div class="paragraph">
<p>使用Javadoc为生产Java源代码生成API文档。</p>
</div>
</dd>
<dt class="hdlist1"><code>test</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.testing.Test.html">测试</a></dt>
<dd>
<p><em>取决于</em> ： <code>testClasses</code> ，以及产生测试运行时类路径的所有任务</p>
<div class="paragraph">
<p>使用JUnit或TestNG运行单元测试。</p>
</div>
</dd>
<dt class="hdlist1"><code>uploadArchives</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Upload.html">上传</a></dt>
<dd>
<p><em>取决于</em> ： <code>jar</code> ，以及产生附加到工件的工件的任何其他任务<code>archives</code>组态</p>
<div class="paragraph">
<p>将工件上传到<code>archives</code>配置-包括生产JAR文件-已配置的存储库。<em>不</em>建议使用此任务，而应使用<a href="#publishing_ivy">Ivy</a>或<a href="#publishing_maven">Maven</a>发布插件之一。</p>
</div>
</dd>
<dt class="hdlist1"><code>clean</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<p>删除项目构建目录。</p>
</dd>
<dt class="hdlist1"><code>clean<em>TaskName</em></code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Delete.html">删除</a></dt>
<dd>
<p>删除由指定任务创建的文件。例如， <code>cleanJar</code>将删除由<code>jar</code>任务和<code>cleanTest</code>将删除由<code>test</code>任务。</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="java_source_set_tasks"><a class="anchor" href="#java_source_set_tasks"></a> <a class="link" href="#java_source_set_tasks">SourceSet任务</a></h5>
<div class="paragraph">
<p>对于您添加到项目中的每个源集，Java插件都会添加以下任务：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>compile<em>SourceSet</em>Java</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.compile.JavaCompile.html">JavaCompile</a></dt>
<dd>
<p><em>取决于</em> ：有助于源集的编译类路径的所有任务</p>
<div class="paragraph">
<p>使用JDK编译器编译给定源集的Java源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>process<em>SourceSet</em>Resources</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Copy.html">复制</a></dt>
<dd>
<p>将给定的源集的资源复制到resources目录中。</p>
</dd>
<dt class="hdlist1"><code><em>sourceSet</em>Classes</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Task.html">任务</a></dt>
<dd>
<p><em>取决于</em> ： <code>compile<em>SourceSet</em>Java</code> ，<code>process<em>SourceSet</em>Resources</code></p>
<div class="paragraph">
<p>准备给定源集的类和资源以进行打包和执行。一些插件可能会为源集添加其他编译任务。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="lifecycle_tasks"><a class="anchor" href="#lifecycle_tasks"></a> <a class="link" href="#lifecycle_tasks">生命周期任务</a></h5>
<div class="paragraph">
<p>Java插件将其某些任务附加到<a href="#sec:base_tasks">基本插件</a>定义的生命周期任务（Java插件自动应用该任务），并且还添加了一些其他生命周期任务：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>assemble</code></dt>
<dd>
<p><em>取决于</em> ： <code>jar</code> ，以及创建附加到<code>archives</code>组态</p>
<div class="paragraph">
<p>聚合任务，用于组装项目中的所有档案。此任务由基本插件添加。</p>
</div>
</dd>
<dt class="hdlist1"><code>check</code></dt>
<dd>
<p><em>取决于</em> ：<code>test</code></p>
<div class="paragraph">
<p>聚集执行验证任务的任务，例如运行测试。一些插件将自己的验证任务添加到<code>check</code> 。您还应该附加任何自定义<code>Test</code>如果希望它们执行完整构建，请执行此生命周期任务中的任务。此任务由基本插件添加。</p>
</div>
</dd>
<dt class="hdlist1"><code>build</code></dt>
<dd>
<p><em>取决于</em> ： <code>check</code> ，<code>assemble</code></p>
<div class="paragraph">
<p>汇总执行项目完整构建的任务。此任务由基本插件添加。</p>
</div>
</dd>
<dt class="hdlist1"><code>buildNeeded</code></dt>
<dd>
<p><em>取决于</em> ： <code>build</code>和<code>buildNeeded</code>是所有项目中依赖项的任务<code>testRuntimeClasspath</code>组态。</p>
<div class="paragraph">
<p>执行项目及其依赖的所有项目的完整构建。</p>
</div>
</dd>
<dt class="hdlist1"><code>buildDependents</code></dt>
<dd>
<p><em>取决于</em> ： <code>build</code>和<code>buildDependents</code>在该项目中有依赖项的所有项目中的任务<code>testRuntimeClasspath</code>构型</p>
<div class="paragraph">
<p>对项目和依赖它的所有项目执行完整的构建。</p>
</div>
</dd>
<dt class="hdlist1"><code>build<em>ConfigName</em></code> — <em>任务规则</em></dt>
<dd>
<p><em>取决于</em> ：生成附加到名为<em>ConfigName的</em>配置的工件的所有任务</p>
<div class="paragraph">
<p>组装指定配置的工件。此规则由基本插件添加。</p>
</div>
</dd>
<dt class="hdlist1"><code>upload<em>ConfigName</em></code> — <em>任务规则</em> ，类型： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Upload.html">Upload</a></dt>
<dd>
<p><em>取决于</em> ：生成附加到名为<em>ConfigName的</em>配置的工件的所有任务</p>
<div class="paragraph">
<p>以指定的配置组装并上传工件。此规则由基本插件添加。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>下图显示了这些任务之间的关系。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/javaPluginTasks.png" alt="javaPluginTasks">
</div>
<div class="title">图34。Java插件-任务</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_project_layout"><a class="anchor" href="#sec:java_project_layout"></a> <a class="link" href="#sec:java_project_layout">项目布局</a></h4>
<div class="paragraph">
<p>Java插件采用如下所示的项目布局。这些目录都不需要存在或包含任何内容。Java插件将编译找到的所有内容，并处理所有丢失的内容。</p>
</div>
<div id="javalayout" class="dlist">
<dl>
<dt class="hdlist1"><code>src/main/java</code></dt>
<dd>
<p>生产Java源代码。</p>
</dd>
<dt class="hdlist1"><code>src/main/resources</code></dt>
<dd>
<p>生产资源，例如XML和属性文件。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/test/java</code></dt>
<dd>
<p>测试Java源代码。</p>
</dd>
<dt class="hdlist1"><code>src/test/resources</code></dt>
<dd>
<p>测试资源。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/java</code></dt>
<dd>
<p>名为<em>sourceSet</em>的源集的Java源。</p>
</dd>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/resources</code></dt>
<dd>
<p>名为<em>sourceSet</em>的源集的资源。</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="sec:changing_java_project_layout"><a class="anchor" href="#sec:changing_java_project_layout"></a> <a class="link" href="#sec:changing_java_project_layout">更改项目布局</a></h5>
<div class="paragraph">
<p>您可以通过配置适当的源集来配置项目布局。以下各节将对此进行详细讨论。这是一个简短的示例，该示例更改了主要Java和资源源目录。</p>
</div>
<div class="exampleblock">
<div class="title">示例582自定义Java源布局</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    main {
        java {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">src/java</span><span class="delimiter">'</span></span>]
        }
        resources {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">src/resources</span><span class="delimiter">'</span></span>]
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    main {
        java {
            setSrcDirs(listOf(&quot;src/java&quot;))
        }
        resources {
            setSrcDirs(listOf(&quot;src/resources&quot;))
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="source_sets"><a class="anchor" href="#source_sets"></a> <a class="link" href="#source_sets">源集</a></h4>
<div class="paragraph">
<p>该插件添加了以下<a href="#sec:java_source_sets">源集</a> ：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>main</code></dt>
<dd>
<p>包含项目的生产源代码，该源代码被编译并组装为JAR。</p>
</dd>
<dt class="hdlist1"><code>test</code></dt>
<dd>
<p>包含您的测试源代码，该源代码是使用JUnit或TestNG编译和执行的。这些通常是单元测试，但是您可以在此源集中包括任何测试，只要它们共享相同的编译和运行时类路径即可。</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="sec:source_set_properties"><a class="anchor" href="#sec:source_set_properties"></a> <a class="link" href="#sec:source_set_properties">源集属性</a></h5>
<div class="paragraph">
<p>下表列出了源集的一些重要属性。您可以在<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSet.html">SourceSet</a>的API文档中找到更多详细信息。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>name</code> - （只读）<code>String</code></dt>
<dd>
<p>源集的名称，用于标识它。</p>
</dd>
<dt class="hdlist1"><code>output</code> —（只读） <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.SourceSetOutput.html">SourceSetOutput</a></dt>
<dd>
<p>源集的输出文件，包含其已编译的类和资源。</p>
</dd>
<dt class="hdlist1"><code>output.classesDirs</code> —（只读） <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">FileCollection</a></dt>
<dd>
<p><em>预设值</em> ： <code>$buildDir/classes/java/$name</code> ，例如<em>build / classes / java / main</em></p>
<div class="paragraph">
<p>生成此源集的类的目录。可能包含其他JVM语言的目录，例如<em>build / classes / kotlin / main</em> 。</p>
</div>
</dd>
<dt class="hdlist1"><code>output.resourcesDir</code> -<code>File</code></dt>
<dd>
<p><em>预设值</em> ： <code>$buildDir/resources/$name</code> ，例如<em>build / resources / main</em></p>
<div class="paragraph">
<p>生成此源集资源的目录。</p>
</div>
</dd>
<dt class="hdlist1"><code>compileClasspath</code> — <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">FileCollection</a></dt>
<dd>
<p><em>预设值</em> ： <code>${name}CompileClasspath</code>组态</p>
<div class="paragraph">
<p>编译此源集的源文件时要使用的类路径。</p>
</div>
</dd>
<dt class="hdlist1"><code>annotationProcessorPath</code> — <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">FileCollection</a></dt>
<dd>
<p><em>预设值</em> ： <code>${name}AnnotationProcessor</code>组态</p>
<div class="paragraph">
<p>编译此源集的源文件时要使用的处理器路径。</p>
</div>
</dd>
<dt class="hdlist1"><code>runtimeClasspath</code> — <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileCollection.html">FileCollection</a></dt>
<dd>
<p><em>预设值</em> ： <code>$output</code> ， <code>${name}RuntimeClasspath</code>组态</p>
<div class="paragraph">
<p>执行此源集的类时要使用的类路径。</p>
</div>
</dd>
<dt class="hdlist1"><code>java</code> —（只读） <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a></dt>
<dd>
<p>此源集的Java源文件。仅包含<code>.java</code>在Java源目录中找到的文件，不包括所有其他文件。</p>
</dd>
<dt class="hdlist1"><code>java.srcDirs</code> -<code>Set<File></code></dt>
<dd>
<p><em>预设值</em> ： <code>src/$name/java</code> ，例如<em>src / main / java</em></p>
<div class="paragraph">
<p>包含此源集的Java源文件的源目录。您可以将其设置为sec：specifying_multiple_files <a href="#sec:specifying_multiple_files">本节中</a>描述的任何值。</p>
</div>
</dd>
<dt class="hdlist1"><code>java.outputDir</code> -<code>File</code></dt>
<dd>
<p><em>预设值</em> ： <code>$buildDir/classes/java/$name</code> ，例如<em>build / classes / java / main</em></p>
<div class="paragraph">
<p>生成编译后的Java源代码的目录。您可以将其设置<a href="#sec:single_file_paths">为本节中</a>描述的任何值。</p>
</div>
</dd>
<dt class="hdlist1"><code>resources</code> —（只读） <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a></dt>
<dd>
<p>此源集的资源。仅包含资源，不包括任何资源<code>.java</code>在资源目录中找到的文件。其他插件，例如<a href="#groovy_plugin">Groovy插件</a> ，从此集合中排除其他类型的文件。</p>
</dd>
<dt class="hdlist1"><code>resources.srcDirs</code> -<code>Set<File></code></dt>
<dd>
<p><em>预设值</em> ：<code>[src/$name/resources]</code></p>
<div class="paragraph">
<p>包含此源集资源的目录。您可以将其设置<a href="#sec:specifying_multiple_files">为本节中</a>描述的任何类型的值。</p>
</div>
</dd>
<dt class="hdlist1"><code>allJava</code> —（只读） <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a></dt>
<dd>
<p><em>默认值</em> ：与<code>java</code>属性</p>
<div class="paragraph">
<p>此源集的所有Java文件。某些插件（例如Groovy插件）将其他Java源文件添加到此集合中。</p>
</div>
</dd>
<dt class="hdlist1"><code>allSource</code> —（只读） <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a></dt>
<dd>
<p><em>默认值</em> ： <code>resources</code>和<code>java</code>属性</p>
<div class="paragraph">
<p>任何语言的此源集的所有源文件。这包括所有资源文件和所有Java源文件。一些插件（例如Groovy插件）将其他源文件添加到此集合。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="sec:defining_new_source_sets"><a class="anchor" href="#sec:defining_new_source_sets"></a> <a class="link" href="#sec:defining_new_source_sets">定义新的源集</a></h5>
<div class="paragraph">
<p>请参阅<em>在Java和JVM中测试项目</em>一章中的<a href="#sec:configuring_java_integration_tests">集成测试示例</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:some_source_set_examples"><a class="anchor" href="#sec:some_source_set_examples"></a> <a class="link" href="#sec:some_source_set_examples">其他一些简单的源集示例</a></h5>
<div class="paragraph">
<p>添加一个包含源集类的JAR：</p>
</div>
<div class="exampleblock">
<div class="title">示例583组装源集的JAR</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task intTestJar(<span class="key">type</span>: Jar) {
    from sourceSets.intTest.output
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Jar&gt;(&quot;intTestJar&quot;) {
    from(sourceSets[&quot;intTest&quot;].output)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为源集生成Javadoc：</p>
</div>
<div class="exampleblock">
<div class="title">示例584为源集生成Javadoc</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task intTestJavadoc(<span class="key">type</span>: Javadoc) {
    source sourceSets.intTest.allJava
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Javadoc&gt;(&quot;intTestJavadoc&quot;) {
    source(sourceSets[&quot;intTest&quot;].allJava)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>添加测试套件以在源集中运行测试：</p>
</div>
<div class="exampleblock">
<div class="title">示例585在源集中运行测试</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task intTest(<span class="key">type</span>: Test) {
    testClassesDirs = sourceSets.intTest.output.classesDirs
    classpath = sourceSets.intTest.runtimeClasspath
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Test&gt;(&quot;intTest&quot;) {
    testClassesDirs = sourceSets[&quot;intTest&quot;].output.classesDirs
    classpath = sourceSets[&quot;intTest&quot;].runtimeClasspath
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_plugin_and_dependency_management"><a class="anchor" href="#sec:java_plugin_and_dependency_management"></a> <a class="link" href="#sec:java_plugin_and_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>Java插件将许多<a href="#sec:what-are-dependency-configurations">依赖项配置添加</a>到您的项目中，如下所示。诸如<code>compileJava</code>和<code>test</code>然后使用这些配置中的一个或多个来获取相应的文件并使用它们，例如，将它们放在编译或运行时类路径中。</p>
</div>
<div class="sect4">
<h5 id="tab:configurations"><a class="anchor" href="#tab:configurations"></a> <a class="link" href="#tab:configurations">依赖配置</a></h5>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>要查找有关的信息<code>api</code>配置，请查阅<a href="#sec:java_library_separation">Java库插件</a>参考文档和<a href="#dependency_management_for_java_projects">Java项目的依赖管理</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><span class="line-through"><code>compile</code></span> （已弃用）</dt>
<dd>
<p>编译时间依赖性。被取代<code>implementation</code> 。</p>
</dd>
<dt class="hdlist1"><code>implementation</code>延伸<code>compile</code></dt>
<dd>
<p>仅实现依赖。</p>
</dd>
<dt class="hdlist1"><code>compileOnly</code></dt>
<dd>
<p>仅编译时依赖项，在运行时不使用。</p>
</dd>
<dt class="hdlist1"><code>compileClasspath</code>延伸<code>compile, compileOnly, implementation</code></dt>
<dd>
<p>编译类路径，在编译源代码时使用。由任务使用<code>compileJava</code> 。</p>
</dd>
<dt class="hdlist1"><code>annotationProcessor</code></dt>
<dd>
<p>编译期间使用的注释处理器。</p>
</dd>
<dt class="hdlist1"><span class="line-through"><code>runtime</code></span> （不建议使用）扩展<code>compile</code></dt>
<dd>
<p>运行时依赖项。被取代<code>runtimeOnly</code> 。</p>
</dd>
<dt class="hdlist1"><code>runtimeOnly</code></dt>
<dd>
<p>仅运行时依赖项。</p>
</dd>
<dt class="hdlist1"><code>runtimeClasspath</code>延伸<code>runtimeOnly, runtime, implementation</code></dt>
<dd>
<p>运行时类路径包含实现的元素以及仅运行时元素。</p>
</dd>
<dt class="hdlist1"><span class="line-through"><code>testCompile</code></span> （不建议使用）扩展<code>compile</code></dt>
<dd>
<p>编译测试的其他依赖项。被取代<code>testImplementation</code> 。</p>
</dd>
<dt class="hdlist1"><code>testImplementation</code>延伸<code>testCompile, implementation</code></dt>
<dd>
<p>仅实现测试的依赖项。</p>
</dd>
<dt class="hdlist1"><code>testCompileOnly</code></dt>
<dd>
<p>其他依赖项仅用于编译测试，在运行时不使用。</p>
</dd>
<dt class="hdlist1"><code>testCompileClasspath</code>延伸<code>testCompile, testCompileOnly, testImplementation</code></dt>
<dd>
<p>测试编译类路径，在编译测试源时使用。由任务使用<code>compileTestJava</code> 。</p>
</dd>
<dt class="hdlist1"><span class="line-through"><code>testRuntime</code></span> （不建议使用）扩展<code>runtime, testCompile</code></dt>
<dd>
<p>仅用于运行测试的其他依赖项。被取代<code>testRuntimeOnly</code> 。</p>
</dd>
<dt class="hdlist1"><code>testRuntimeOnly</code>延伸<code>runtimeOnly</code></dt>
<dd>
<p>运行时仅运行测试的依赖项。</p>
</dd>
<dt class="hdlist1"><code>testRuntimeClasspath</code>延伸<code>testRuntimeOnly, testRuntime, testImplementation</code></dt>
<dd>
<p>用于运行测试的运行时类路径。由任务使用<code>test</code> 。</p>
</dd>
<dt class="hdlist1"><code>archives</code></dt>
<dd>
<p>该项目生产的人工制品（例如罐子）。由任务使用<code>uploadArchives</code> 。</p>
</dd>
<dt class="hdlist1"><code>default</code>延伸<code>runtime</code></dt>
<dd>
<p>项目依赖于此项目的默认配置。包含此项目在运行时所需的工件和依赖项。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>下图分别显示了<em>主要</em>和<em>测试</em>源集的依赖项配置。您可以使用此图例解释颜色：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>灰色文本-已<em>弃用</em>配置。</p>
</li>
<li>
<p>绿色背景-您可以声明对配置的依赖性。</p>
</li>
<li>
<p>蓝灰色背景-配置供任务使用，而不供您声明依赖项。</p>
</li>
<li>
<p>浅蓝色背景与等宽线文本—一个任务。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="img/java-main-configurations.png" alt="Java主要配置">
</div>
<div class="title">图35。Java插件- <em>主要</em>源集依赖项配置</div>
</div>
<div class="imageblock">
<div class="content">
<img src="img/java-test-configurations.png" alt="Java测试配置">
</div>
<div class="title">图36。Java插件- <em>测试</em>源集依赖项配置</div>
</div>
<div class="paragraph">
<p>对于您添加到项目中的每个源集，Java插件都会添加以下依赖项配置：</p>
</div>
</div>
<div class="sect4">
<h5 id="java_source_set_configurations"><a class="anchor" href="#java_source_set_configurations"></a> <a class="link" href="#java_source_set_configurations">SourceSet依赖项配置</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><span class="line-through"><code><em>sourceSet</em>Compile</code></span> （已弃用）</dt>
<dd>
<p>给定源集的编译时间依赖性。被取代<code><em>sourceSet</em>Implementation</code> 。</p>
</dd>
<dt class="hdlist1"><code><em>sourceSet</em>Implementation</code>延伸<code><em>sourceSet</em>Compile</code></dt>
<dd>
<p>给定源集的编译时间依赖性。使用者<code><em>sourceSet</em>CompileClasspath, <em>sourceSet</em>RuntimeClasspath</code> 。</p>
</dd>
<dt class="hdlist1"><code><em>sourceSet</em>CompileOnly</code></dt>
<dd>
<p>给定源集的编译时依赖项仅在运行时不使用。</p>
</dd>
<dt class="hdlist1"><code><em>sourceSet</em>CompileClasspath</code>延伸<code>compile<em>SourceSet</em>Java</code></dt>
<dd>
<p>编译类路径，在编译源代码时使用。使用者<code><em>sourceSet</em>Compile, <em>sourceSet</em>CompileOnly, <em>sourceSet</em>Implementation</code> 。</p>
</dd>
<dt class="hdlist1"><code><em>sourceSet</em>AnnotationProcessor</code></dt>
<dd>
<p>在此源集的编译期间使用的注释处理器。</p>
</dd>
<dt class="hdlist1"><span class="line-through"><code><em>sourceSet</em>Runtime</code></span> （已弃用）</dt>
<dd>
<p>给定源集的运行时依赖关系。使用者<code><em>sourceSet</em>Compile</code> 。被取代<code><em>sourceSet</em>RuntimeOnly</code> 。</p>
</dd>
<dt class="hdlist1"><code><em>sourceSet</em>RuntimeOnly</code></dt>
<dd>
<p>给定源集的仅运行时依赖项。</p>
</dd>
<dt class="hdlist1"><code><em>sourceSet</em>RuntimeClasspath</code>延伸<code><em>sourceSet</em>RuntimeOnly, <em>sourceSet</em>Runtime, <em>sourceSet</em>Implementation</code></dt>
<dd>
<p>运行时类路径包含实现的元素以及仅运行时元素。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java-extension"><a class="anchor" href="#sec:java-extension"></a> <a class="link" href="#sec:java-extension">贡献扩展</a></h4>
<div class="paragraph">
<p>Java插件添加了<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.JavaPluginExtension.html"><code>java</code></a>项目<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.JavaPluginExtension.html">扩展</a> 。这允许在专用DSL块内配置许多与Java相关的属性。</p>
</div>
<div class="exampleblock">
<div class="title">示例586使用<code>java</code>延期</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/JavaVersion.html">JavaVersion</a> sourceCompatibility</code></dt>
<dd>
<p>编译Java源代码时使用的Java版本兼容性。默认值：正在使用<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/JavaVersion.html">JavaVersion</a>的当前JVM的版本。</p>
</dd>
<dt class="hdlist1"><code><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/JavaVersion.html">JavaVersion</a> targetCompatibility</code></dt>
<dd>
<p>为其生成类的Java版本。默认值： <code><em>sourceCompatibility</em></code> 。</p>
</dd>
<dt class="hdlist1"><code>withJavadocJar()</code></dt>
<dd>
<p>自动打包Javadoc并创建变体<code>javadocElements</code>带有神器<code>-javadoc.jar</code> ，它将成为出版物的一部分。</p>
</dd>
<dt class="hdlist1"><code>withSourcesJar()</code></dt>
<dd>
<p>自动打包源代码并创建变体<code>sourceElements</code>带有神器<code>-sources.jar</code> ，它将成为出版物的一部分。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="convention_properties"><a class="anchor" href="#convention_properties"></a> <a class="link" href="#convention_properties">公约属性</a></h4>
<div class="paragraph">
<p>Java插件向项目添加了许多约定属性，如下所示。您可以在构建脚本中使用这些属性，就像它们是项目对象的属性一样。</p>
</div>
<div class="sect4">
<h5 id="directory_properties"><a class="anchor" href="#directory_properties"></a> <a class="link" href="#directory_properties">目录属性</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>String reporting.baseDir</code></dt>
<dd>
<p>相对于构建目录，要生成报告的目录名称。默认值：<code>reports</code></p>
</dd>
<dt class="hdlist1"><code>(read-only) File reportsDir</code></dt>
<dd>
<p>生成报告的目录。默认值：<code><em>buildDir</em>/<em>reporting.baseDir</em></code></p>
</dd>
<dt class="hdlist1"><code>String testResultsDirName</code></dt>
<dd>
<p>用于将测试结果.xml文件生成到的目录的名称，相对于构建目录。默认值：<code>test-results</code></p>
</dd>
<dt class="hdlist1"><code>(read-only) File testResultsDir</code></dt>
<dd>
<p>生成测试结果.xml文件的目录。默认值：<code><em>buildDir</em>/<em>testResultsDirName</em></code></p>
</dd>
<dt class="hdlist1"><code>String testReportDirName</code></dt>
<dd>
<p>用于将测试报告生成到的目录的名称，相对于reports目录。默认值：<code>tests</code></p>
</dd>
<dt class="hdlist1"><code>(read-only) File testReportDir</code></dt>
<dd>
<p>生成测试报告的目录。默认值：<code><em>reportsDir</em>/testReportDirName</code></p>
</dd>
<dt class="hdlist1"><code>String libsDirName</code></dt>
<dd>
<p>相对于build目录，要生成库的目录的名称。默认值：<code>libs</code></p>
</dd>
<dt class="hdlist1"><code>(read-only) File libsDir</code></dt>
<dd>
<p>生成库的目录。默认值：<code><em>buildDir</em>/<em>libsDirName</em></code></p>
</dd>
<dt class="hdlist1"><code>String distsDirName</code></dt>
<dd>
<p>相对于构建目录而言，用于生成发行版本的目录的名称。默认值：<code>distributions</code></p>
</dd>
<dt class="hdlist1"><code>(read-only) File distsDir</code></dt>
<dd>
<p>要生成发行版的目录。默认值：<code><em>buildDir</em>/<em>distsDirName</em></code></p>
</dd>
<dt class="hdlist1"><code>String docsDirName</code></dt>
<dd>
<p>生成文档的目录名称，相对于构建目录。默认值：<code>docs</code></p>
</dd>
<dt class="hdlist1"><code>(read-only) File docsDir</code></dt>
<dd>
<p>要生成文档的目录。默认值：<code><em>buildDir</em>/<em>docsDirName</em></code></p>
</dd>
<dt class="hdlist1"><code>String dependencyCacheDirName</code></dt>
<dd>
<p>相对于构建目录，用于缓存源依赖项信息的目录的名称。默认值：<code>dependency-cache</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="other_convention_properties"><a class="anchor" href="#other_convention_properties"></a> <a class="link" href="#other_convention_properties">其他约定属性</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>(read-only) <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/SourceSetContainer.html">SourceSetContainer</a> sourceSets</code></dt>
<dd>
<p>包含项目的源集。默认值：非null <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/tasks/SourceSetContainer.html">SourceSetContainer</a></p>
</dd>
<dt class="hdlist1"><code>String archivesBaseName</code></dt>
<dd>
<p>用于存档的基本名称，例如JAR或ZIP文件。默认值：<code><em>projectName</em></code></p>
</dd>
<dt class="hdlist1"><code><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/java/archives/Manifest.html">Manifest</a> manifest</code></dt>
<dd>
<p>要包含在所有JAR文件中的清单。默认值：空清单。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这些属性由类型为<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/JavaPluginConvention.html">JavaPluginConvention</a>和<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/plugins/BasePluginConvention.html">BasePluginConvention的</a>约定对象提供。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_test"><a class="anchor" href="#sec:java_test"></a> <a class="link" href="#sec:java_test">测试中</a></h4>
<div class="paragraph">
<p>有关更多详细信息，请参见“ <a href="#java_testing">在Java和JVM项目中测试”</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_plugin_publishing"><a class="anchor" href="#sec:java_plugin_publishing"></a> <a class="link" href="#sec:java_plugin_publishing">出版</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>components.java</code></dt>
<dd>
<p>一个<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/component/SoftwareComponent.html">软件组件，</a>用于<a href="#publishing_overview">发布</a>由<code>jar</code>任务。该组件包括JAR的运行时依赖项信息。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>另请参阅<a href="#sec:java-extension"><code>java</code>扩展</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:incremental_compile"><a class="anchor" href="#sec:incremental_compile"></a> <a class="link" href="#sec:incremental_compile">增量Java编译</a></h4>
<div class="paragraph">
<p>Gradle带有一个复杂的增量Java编译器，该编译器默认情况下处于活动状态。</p>
</div>
<div class="paragraph">
<p>这为您带来以下好处</p>
</div>
<div class="ulist">
<ul>
<li>
<p>增量构建要快得多。</p>
</li>
<li>
<p>最小数量的类文件被更改。不需要重新编译的类在输出目录中保持不变。一个真正有用的示例场景是使用JRebel-更改的输出类越少，JVM可以越快地使用刷新的类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了帮助您了解增量编译的工作原理，以下内容提供了高级概述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gradle将重新编译<em>受</em>更改<em>影响</em>的所有类。</p>
</li>
<li>
<p>如果它已经改变或A类<em>受到影响</em> ，如果它依赖于另一个受影响的类。无论是否在同一个项目，另一个项目甚至是外部库中定义了其他类，此方法都有效。</p>
</li>
<li>
<p>类的依赖关系由其字节码中的类型引用确定。</p>
</li>
<li>
<p>由于常量可以内联，因此对常量的任何更改都将导致Gradle重新编译所有源文件。因此，您应尽量减少在源代码中使用常量，并在可能的情况下将其替换为静态方法。</p>
</li>
<li>
<p>由于源保留注释在字节码中不可见，因此对源保留注释的更改将导致完全重新编译。</p>
</li>
<li>
<p>您可以通过应用良好的软件设计原则（例如，松耦合）来提高增量编译性能。例如，如果将接口放置在具体类与其依赖项之间，则仅当接口更改时，才重新编译依赖类，而实现更改时，则不会重新编译。</p>
</li>
<li>
<p>类分析存储在项目目录中，因此干净签出后的首次构建可能会变慢。考虑关闭构建服务器上的增量编译器。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="sec:incremental_compilation_known_issues"><a class="anchor" href="#sec:incremental_compilation_known_issues"></a> <a class="link" href="#sec:incremental_compilation_known_issues">已知的问题</a></h5>
<div class="ulist">
<ul>
<li>
<p>如果编译任务由于编译错误而失败，它将在下次调用时再次进行完全编译。</p>
</li>
<li>
<p>如果使用的注释处理器读取资源（例如配置文件），则需要将这些资源声明为编译任务的输入。</p>
</li>
<li>
<p>如果资源文件被更改，Gradle将触发完全重新编译。</p>
</li>
<li>
<p>如果程序包声明和源文件的目录结构不匹配（例如， <code>package foo</code>与位置<code>bar/MyClass.java</code> ），则增量编译会产生错误的输出。错误的类可能会重新编译，并且输出中可能有剩余的类文件。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:incremental_annotation_processing"><a class="anchor" href="#sec:incremental_annotation_processing"></a> <a class="link" href="#sec:incremental_annotation_processing">增量注释处理</a></h4>
<div class="paragraph">
<p>从Gradle 4.7开始，增量编译器还支持增量注释处理。所有注释处理器都需要选择使用此功能，否则它们将触发完全重新编译。</p>
</div>
<div class="paragraph">
<p>作为用户，您可以在其中查看哪些注释处理器正在触发完全重新编译。 <code>--info</code>日志。如果自定义，增量注释处理将被停用<code>executable</code>要么<code>javaHome</code>在编译任务上配置。</p>
</div>
<div class="sect4">
<h5 id="making_an_annotation_processor_incremental"><a class="anchor" href="#making_an_annotation_processor_incremental"></a> <a class="link" href="#making_an_annotation_processor_incremental">使注释处理器递增</a></h5>
<div class="paragraph">
<p>首先请看一下<a href="#sec:incremental_compile">增量Java编译</a> ，因为增量注释处理是基于<a href="#sec:incremental_compile">增量Java编译</a>的。</p>
</div>
<div class="paragraph">
<p>Gradle支持对注释处理器的两个常见类别进行增量编译：“隔离”和“聚合”。请查阅以下信息，确定适合您的处理器的类别。</p>
</div>
<div class="paragraph">
<p>然后，您可以使用处理器的META-INF目录中的文件注册处理器以进行增量编译。格式是每个处理器一行，并以逗号分隔处理器类别及其类别的完全限定名称。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_registering_incremental_annotation_processors"><a class="anchor" href="#example_registering_incremental_annotation_processors"></a> <a class="link" href="#example_registering_incremental_annotation_processors">示例：注册增量注释处理器</a></h5>
<div class="listingblock">
<div class="title">处理器/ src /主/资源/META-INF/gradle/incremental.annotation.processors</div>
<div class="content">
<pre>EntityProcessor,isolating
ServiceRegistryProcessor,dynamic</pre>
</div>
</div>
<div class="paragraph">
<p>如果您的处理器只能在运行时确定它是否是增量的，则可以在META-INF描述符中将其声明为“动态”，并在运行时使用<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions--">Processor＃getSupportedOptions（）</a>方法返回其真实类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_registering_incremental_annotation_processors_dynamically"><a class="anchor" href="#example_registering_incremental_annotation_processors_dynamically"></a> <a class="link" href="#example_registering_incremental_annotation_processors_dynamically">示例：动态注册增量注释处理器</a></h5>
<div class="listingblock">
<div class="title">处理器/src/main/java/ServiceRegistryProcessor.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; getSupportedOptions() {
    <span class="keyword">return</span> <span class="predefined-type">Collections</span>.singleton(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.gradle.annotation.processing.aggregating</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>两种类别都有以下限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>他们必须使用<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Filer.html">Filer API</a>生成文件。任何其他方式写入文件都将导致以后出现静默故障，因为这些文件将无法正确清理。如果您的处理器执行此操作，则它不能是增量的。</p>
</li>
<li>
<p>它们不得依赖于特定于编译器的API，例如<code>com.sun.source.util.Trees</code> 。Gradle包装了处理API，因此尝试转换为特定于编译器的类型的尝试将失败。如果您的处理器执行此操作，则除非您具有某种后备机制，否则它不能是增量的。</p>
</li>
<li>
<p>如果他们使用<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Filer.html#createResource(javax.tools.JavaFileManager.Location,java.lang.CharSequence,java.lang.CharSequence,javax.lang.model.element.Element...)">Filer＃createResource</a> ，则<code>location</code>参数必须是<a href="https://docs.oracle.com/javase/8/docs/api/javax/tools/StandardLocation.html">StandardLocation中</a>的以下值之一： <code>CLASS_OUTPUT</code> ， <code>SOURCE_OUTPUT</code> ， 要么<code>NATIVE_HEADER_OUTPUT</code> 。任何其他参数将禁用增量处理。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="isolating_annotation_processors"><a class="anchor" href="#isolating_annotation_processors"></a> <a class="link" href="#isolating_annotation_processors">“隔离”注释处理器</a></h5>
<div class="paragraph">
<p>最快的类别，它们隔离地查看每个带注释的元素，并为其创建生成的文件或验证消息。例如一个<code>EntityProcessor</code>可以创建一个<code><TypeName>Repository</code>对于带有注释的每种类型<code>@Entity</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_an_isolated_annotation_processor"><a class="anchor" href="#example_an_isolated_annotation_processor"></a> <a class="link" href="#example_an_isolated_annotation_processor">示例：隔离的注释处理器</a></h5>
<div class="listingblock">
<div class="title">处理器/src/main/java/EntityProcessor.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Set</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Element</span>&gt; entities = roundEnv.getElementsAnnotatedWith(entityAnnotation);
<span class="keyword">for</span> (<span class="predefined-type">Element</span> entity : entities) {
    createRepository((TypeElement) entity);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>“隔离”处理器具有以下限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>他们必须根据可从其AST获得的信息，为带注释的类型做出所有决策（代码生成，验证消息）。这意味着您可以甚至可传递地分析类型的超类，方法返回类型，注释等。但是您不能基于RoundEnvironment中不相关的元素进行决策。这样做将导致无提示失败，因为以后将重新编译的文件太少。如果您的处理器需要根据其他不相关元素的组合做出决策，则将其标记为“聚合”。</p>
</li>
<li>
<p>它们必须为使用生成的每个文件提供一个恰好一个原始元素。 <code>Filer</code> API。如果提供了零个或多个原始元素，Gradle将重新编译所有源文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>重新编译源文件时，Gradle将重新编译由此生成的所有文件。删除源文件时，将从其生成的文件也删除。</p>
</div>
</div>
<div class="sect4">
<h5 id="aggregating_annotation_processors"><a class="anchor" href="#aggregating_annotation_processors"></a> <a class="link" href="#aggregating_annotation_processors">“聚合”注释处理器</a></h5>
<div class="paragraph">
<p>这些可以将多个源文件聚合到一个或多个输出文件或验证消息中。例如，一个<code>ServiceRegistryProcessor</code>可以创建一个<code>ServiceRegistry</code>用一种方法为每种类型加上注释<code>@Service</code></p>
</div>
</div>
<div class="sect4">
<h5 id="example_an_aggregating_annotation_processor"><a class="anchor" href="#example_an_aggregating_annotation_processor"></a> <a class="link" href="#example_an_aggregating_annotation_processor">示例：聚合注释处理器</a></h5>
<div class="listingblock">
<div class="title">处理器/src/main/java/ServiceRegistryProcessor.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">JavaFileObject serviceRegistry = filer.createSourceFile(<span class="string"><span class="delimiter">&quot;</span><span class="content">ServiceRegistry</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">Writer</span> writer = serviceRegistry.openWriter();
writer.write(<span class="string"><span class="delimiter">&quot;</span><span class="content">public class ServiceRegistry {</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">for</span> (<span class="predefined-type">Element</span> service : roundEnv.getElementsAnnotatedWith(serviceAnnotation)) {
    addServiceCreationMethod(writer, (TypeElement) service);
}
writer.write(<span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>);
writer.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>“聚合”处理器具有以下限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>他们只能读<code>CLASS</code>要么<code>RUNTIME</code>保留注释</p>
</li>
<li>
<p>如果用户通过了，他们只能读取参数名称。 <code>-parameters</code>编译器参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gradle将始终重新处理（但不会重新编译）处理器已为其注册的所有带注释的文件。Gradle将始终重新编译处理器生成的任何文件。</p>
</div>
</div>
<div class="sect4">
<h5 id="state_of_support_in_popular_annotation_processors"><a class="anchor" href="#state_of_support_in_popular_annotation_processors"></a> <a class="link" href="#state_of_support_in_popular_annotation_processors">流行注释处理器的支持状态</a></h5>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>许多流行的注释处理器支持增量注释处理（请参见下表）。直接与注释处理器项目联系以获取最新信息和文档。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注释处理器</th>
<th class="tableblock halign-left valign-top">自支持以来</th>
<th class="tableblock halign-left valign-top">细节</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/google/auto">自动值</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/google/auto/releases/tag/auto-value-1.6.3">1.6.3</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/google/auto">汽车服务</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/google/auto/releases/tag/auto-value-1.6.3">1.6.3</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/google/auto">自动增值</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>部分支持。</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/google/auto/issues/673">发行细节</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/JakeWharton/butterknife">牛油刀</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不支持。</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/stephanenicolas/butterknife">社区派生支持增量注释处理</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/rzwitserloot/lombok">龙目岛</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/rzwitserloot/lombok/releases/tag/v1.16.22">1.16.22</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>数据绑定</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://issuetracker.google.com/issues/110061530#comment28">AGP 3.5.0-alpha5</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>隐藏在功能切换背后</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>匕首</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/google/dagger/issues/1120">2.18</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>隐藏在功能切换背后</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>卡普</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://youtrack.jetbrains.com/issue/KT-23880">1.3.30</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>隐藏在功能切换背后</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>牙签</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/stephanenicolas/toothpick/pull/320">2.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>滑行</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/bumptech/glide/releases/tag/v4.9.0">4.9.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>牙签</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/stephanenicolas/toothpick/pull/320">2.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Android状态</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/evernote/android-state/releases/tag/v1.3.0">1.3.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>包裹箱</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/johncarl81/parceler/releases/tag/parceler-project-1.1.11">1.1.11</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>达特和亨森</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/f2prateek/dart/releases/tag/3.1.0">3.1.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>MapStruct</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/mapstruct/mapstruct/issues/1420">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/square/AssistedInject">辅助注射</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/square/AssistedInject/blob/master/CHANGELOG.md#version-050-2019-08-08">0.5.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>领域</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/realm/realm-java/issues/5906">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>重新查询</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/requery/requery/issues/773">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>事件总线</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/greenrobot/EventBus/issues/528">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>EclipseLink</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=535985">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">权限分配器</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/releases/tag/4.2.0">4.2.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不可变的</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/immutables/immutables/issues/804">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://developer.android.com/topic/libraries/architecture/room">房间</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://developer.android.com/jetpack/androidx/releases/room#2.2.0">2.2.0</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>隐藏在功能切换背后</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://developer.android.com/jetpack/androidx/releases/lifecycle">生命周期</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://issuetracker.google.com/issues/129115778">公开发行</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Android注释</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/androidannotations/androidannotations/issues/2193">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>数据库流</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/agrosner/DBFlow/issues/1648">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>服务器</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/yanzhenjie/AndServer/issues/152">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>平版印刷</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/facebook/litho/issues/482">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>莫西</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/Arello-Mobile/Moxy/issues/240">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>环氧胶</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://github.com/airbnb/epoxy/issues/423">公开的问题</a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>不适用</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_compile_avoidance"><a class="anchor" href="#sec:java_compile_avoidance"></a> <a class="link" href="#sec:java_compile_avoidance">避免编译</a></h4>
<div class="paragraph">
<p>如果从属项目以与<a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>兼容的方式进行了更改（仅更改了其专用API），则Java编译任务将是最新的。这意味着如果项目<code>A</code>取决于项目<code>B</code>和一个班<code>B</code>以与ABI兼容的方式进行更改（通常仅更改方法的主体），则Gradle将不会重新编译<code>A</code> 。</p>
</div>
<div class="paragraph">
<p>某些不影响公共API且被忽略的更改类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更改方法主体</p>
</li>
<li>
<p>更改评论</p>
</li>
<li>
<p>添加，删除或更改私有方法，字段或内部类</p>
</li>
<li>
<p>添加，删除或更改资源</p>
</li>
<li>
<p>更改类路径中的jar或目录的名称</p>
</li>
<li>
<p>重命名参数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于实现细节对注释处理器至关重要，因此必须在注释处理器路径上分别声明它们。Gradle忽略编译类路径上的注释处理器。</p>
</div>
<div class="exampleblock">
<div class="title">示例587声明注释处理器</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// The dagger compiler and its transitive dependencies will only be found on annotation processing classpath</span>
    annotationProcessor <span class="string"><span class="delimiter">'</span><span class="content">com.google.dagger:dagger-compiler:2.8</span><span class="delimiter">'</span></span>

    <span class="comment">// And we still need the Dagger library on the compile classpath itself</span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">com.google.dagger:dagger:2.8</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // The dagger compiler and its transitive dependencies will only be found on annotation processing classpath
    annotationProcessor(&quot;com.google.dagger:dagger-compiler:2.8&quot;)

    // And we still need the Dagger library on the compile classpath itself
    implementation(&quot;com.google.dagger:dagger:2.8&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="variant_aware_selection"><a class="anchor" href="#variant_aware_selection"></a> <a class="link" href="#variant_aware_selection">变体选择</a></h4>
<div class="paragraph">
<p>整个JVM插件集将<a href="#">变体感知分辨率</a>用于所使用的依赖项。他们还安装了一组属性兼容性和消除歧义规则，以针对JVM生态系统的特定<a href="#sub:jvm_default_attributes">特性配置Gradle属性</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java_library_plugin"><a class="anchor" href="#java_library_plugin"></a> <a class="link" href="#java_library_plugin">Java库插件</a></h3>
<div class="paragraph">
<p>Java库插件扩展的功能<a href="#">的Java插件，</a>通过提供有关Java库的具体知识。特别是，Java库向使用者（即使用Java或Java库插件的其他项目）公开API。使用此插件时，隐含地提供了Java插件公开的所有源集，任务和配置。</p>
</div>
<div class="sect3">
<h4 id="sec:java_library_usage"><a class="anchor" href="#sec:java_library_usage"></a> <a class="link" href="#sec:java_library_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Java库插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例588使用Java库插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_library_separation"><a class="anchor" href="#sec:java_library_separation"></a> <a class="link" href="#sec:java_library_separation">API和实现分离</a></h4>
<div class="paragraph">
<p>标准Java插件和Java库插件之间的主要区别在于，后者引入了向消费者公开的<em>API</em>的概念。库是一个Java组件，打算由其他组件使用。在多项目构建中，这是一个非常常见的用例，但在您具有外部依赖关系时也是如此。</p>
</div>
<div class="paragraph">
<p>该插件公开了两个<a href="#sec:what-are-dependency-configurations">配置</a>可用于声明依赖性： <code>api</code>和<code>implementation</code> 。的<code>api</code>配置应用于声明由库API导出的依赖项，而<code>implementation</code>应该使用配置声明组件内部的依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">示例589声明API和实现依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    api <span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient:4.5.7</span><span class="delimiter">'</span></span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.commons:commons-lang3:3.5</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    api(&quot;org.apache.httpcomponents:httpclient:4.5.7&quot;)
    implementation(&quot;org.apache.commons:commons-lang3:3.5&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>依赖项出现在<code>api</code>配置将可传递给库的使用者，因此将出现在使用者的编译类路径中。在<code>implementation</code>另一方面，配置不会暴露给使用者，因此不会泄漏到使用者的编译类路径中。这有几个好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依赖项不会再泄漏到使用者的编译类路径中，因此您永远不会意外地依赖于传递性依赖项</p>
</li>
<li>
<p>减少类路径大小，加快了编译速度</p>
</li>
<li>
<p>实施依赖项发生更改时，重新编译次数更少：无需重新编译使用者</p>
</li>
<li>
<p>清洁发布：与新发布一起使用<code>maven-publish</code>插件，Java库会生成POM文件，这些文件可以准确地区分针对库进行编译所需的内容和在运行时使用库所需的内容（换句话说，不要混合编译库本身所需的内容和所需的内容）以针对库进行编译）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>compile</code>配置仍然存在，但不应使用，因为它将无法保证<code>api</code>和<code>implementation</code>配置提供。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您的构建使用带有POM元数据的已发布模块，则Java和Java库插件会通过pom中使用的作用域来实现api和实现分离。意味着编译类路径仅包含<code>compile</code>范围内的依赖项，而运行时类路径添加<code>runtime</code>范围依赖。</p>
</div>
<div class="paragraph">
<p>这通常对用Maven发布的模块没有影响，在Maven中，定义项目的POM直接作为元数据发布。在那里，编译范围既包括编译项目所需的依赖关系（即实现依赖关系），又包括针对已发布库进行编译所需的依赖关系（即API依赖关系）。对于大多数已发布的库，这意味着所有依赖项都属于编译范围。如果现有库遇到此类问题，则可以考虑使用<a href="#sec:component_metadata_rules">组件元数据规则</a>来修复构建中不正确的元数据。但是，如上所述，如果库是与Gradle一起发布的，则生成的POM文件仅放入<code>api</code>依赖关系到编译范围和其余<code>implementation</code>依赖关系到运行时范围。</p>
</div>
<div class="paragraph">
<p>如果您的构建使用带有Ivy元数据的模块，则如果所有模块都遵循特定的结构，则可以按<a href="#sub:ivy-mapping-to-variants">此处</a>所述激活api和实现分离。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>在Gradle 5.0+中，默认情况下，将模块的编译和运行时范围分开是活动的。在Gradle 4.6+中，您需要通过添加来激活它<code>enableFeaturePreview('IMPROVED_POM_SUPPORT')</code>在<em>settings.gradle中</em> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_library_recognizing_dependencies"><a class="anchor" href="#sec:java_library_recognizing_dependencies"></a> <a class="link" href="#sec:java_library_recognizing_dependencies">识别API和实现依赖性</a></h4>
<div class="paragraph">
<p>本节将帮助您使用简单的经验法则来识别代码中的API和实现依赖性。第一个是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更喜欢<code>implementation</code>配置结束<code>api</code>若有可能</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这使依赖项脱离使用者的编译类路径。此外，如果任何实现类型意外泄漏到公共API中，使用者将立即无法编译。</p>
</div>
<div class="paragraph">
<p>所以什么时候应该使用<code>api</code>组态？API依赖关系是至少包含一种在库二进制接口（通常称为ABI（应用程序二进制接口））中公开的类型。这包括但不限于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>超类或接口中使用的类型</p>
</li>
<li>
<p>公共方法参数中使用的类型，包括通用参数类型（其中<em>public</em>是编译器可见的内容。即Java世界中的<em>public</em> ， <em>protected</em>和<em>package private</em>成员）</p>
</li>
<li>
<p>公共领域中使用的类型</p>
</li>
<li>
<p>公开注释类型</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>相比之下，以下列表中使用的任何类型均与ABI不相关，因此应将其声明为<code>implementation</code>依赖关系：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法主体中专门使用的类型</p>
</li>
<li>
<p>专用于私人会员的类型</p>
</li>
<li>
<p>内部类中专有的类型（将来的Gradle版本将允许您声明哪些包属于公共API）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的类使用了几个第三方库，其中一个在类的公共API中公开，另一个仅在内部使用。import语句不能帮助我们确定哪个是哪个，因此我们必须查看字段，构造函数和方法：</p>
</div>
<div class="sect4">
<h5 id="example_making_the_difference_between_api_and_implementation"><a class="anchor" href="#example_making_the_difference_between_api_and_implementation"></a> <a class="link" href="#example_making_the_difference_between_api_and_implementation">示例：区分API和实现</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">src / main / java / org / gradle / HttpClientWrapper.java</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// The following types can appear anywhere in the code</span>
<span class="comment">// but say nothing about API or implementation usage</span>
<span class="keyword">import</span> <span class="include">org.apache.commons.lang3.exception.ExceptionUtils</span>;
<span class="keyword">import</span> <span class="include">org.apache.http.HttpEntity</span>;
<span class="keyword">import</span> <span class="include">org.apache.http.HttpResponse</span>;
<span class="keyword">import</span> <span class="include">org.apache.http.HttpStatus</span>;
<span class="keyword">import</span> <span class="include">org.apache.http.client.HttpClient</span>;
<span class="keyword">import</span> <span class="include">org.apache.http.client.methods.HttpGet</span>;

<span class="keyword">import</span> <span class="include">java.io.ByteArrayOutputStream</span>;
<span class="keyword">import</span> <span class="include">java.io.IOException</span>;
<span class="keyword">import</span> <span class="include">java.io.UnsupportedEncodingException</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">HttpClientWrapper</span> {

    <span class="directive">private</span> <span class="directive">final</span> HttpClient client; <span class="comment">// private member: implementation details</span>

    <span class="comment">// HttpClient is used as a parameter of a public method</span>
    <span class="comment">// so &quot;leaks&quot; into the public API of this component</span>
    <span class="directive">public</span> HttpClientWrapper(HttpClient client) {
        <span class="local-variable">this</span>.client = client;
    }

    <span class="comment">// public methods belongs to your API</span>
    <span class="directive">public</span> <span class="type">byte</span><span class="type">[]</span> doRawGet(<span class="predefined-type">String</span> url) {
        HttpGet request = <span class="keyword">new</span> HttpGet(url);
        <span class="keyword">try</span> {
            HttpEntity entity = doGet(request);
            <span class="predefined-type">ByteArrayOutputStream</span> baos = <span class="keyword">new</span> <span class="predefined-type">ByteArrayOutputStream</span>();
            entity.writeTo(baos);
            <span class="keyword">return</span> baos.toByteArray();
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            ExceptionUtils.rethrow(e); <span class="comment">// this dependency is internal only</span>
        } <span class="keyword">finally</span> {
            request.releaseConnection();
        }
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="comment">// HttpGet and HttpEntity are used in a private method, so they don't belong to the API</span>
    <span class="directive">private</span> HttpEntity doGet(HttpGet get) <span class="directive">throws</span> <span class="exception">Exception</span> {
        HttpResponse response = client.execute(get);
        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Method failed: </span><span class="delimiter">&quot;</span></span> + response.getStatusLine());
        }
        <span class="keyword">return</span> response.getEntity();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<em>公共</em>构造函数<code>HttpClientWrapper</code>用途<code>HttpClient</code>作为参数，因此它向使用者公开，因此属于API。注意<code>HttpGet</code>和<code>HttpEntity</code>用于<em>私有</em>方法的签名，因此它们不计入使HttpClient成为API依赖项。</p>
</div>
<div class="paragraph">
<p>另一方面， <code>ExceptionUtils</code>类型，来自<code>commons-lang</code>库，仅用于方法主体（而不用于其签名），因此它是实现依赖项。</p>
</div>
<div class="paragraph">
<p>因此，我们可以推断出<code>httpclient</code>是API依赖项，而<code>commons-lang</code>是实现依赖项。该结论转化为构建脚本中的以下声明：</p>
</div>
<div class="exampleblock">
<div class="title">示例590声明API和实现依赖性</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    api <span class="string"><span class="delimiter">'</span><span class="content">org.apache.httpcomponents:httpclient:4.5.7</span><span class="delimiter">'</span></span>
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.apache.commons:commons-lang3:3.5</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    api(&quot;org.apache.httpcomponents:httpclient:4.5.7&quot;)
    implementation(&quot;org.apache.commons:commons-lang3:3.5&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_library_configurations_graph"><a class="anchor" href="#sec:java_library_configurations_graph"></a> <a class="link" href="#sec:java_library_configurations_graph">Java库插件配置</a></h4>
<div class="paragraph">
<p>下图描述了使用Java库插件时的主要配置设置。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/java-library-ignore-deprecated-main.png" alt="java库忽略不推荐使用的main">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>绿色</em>的配置是用户应用来声明依赖项的配置</p>
</li>
<li>
<p><em>粉红色</em>的配置是组件编译或针对库运行时使用的配置</p>
</li>
<li>
<p><em>蓝色</em>的配置在组件内部，供其自己使用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下图描述了测试配置设置：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/java-library-ignore-deprecated-test.png" alt="Java库忽略不推荐使用的测试">
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>从Java插件继承的<em>compile</em> ， <em>testCompile</em> ， <em>runtime</em>和<em>testRuntime</em>配置仍然可用，但已弃用。您应该避免使用它们，因为仅保留它们是为了向后兼容。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下表描述了每种配置的作用：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表31。Java库插件-用于声明依赖项的配置</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">配置名称</th>
<th class="tableblock halign-left valign-top">角色</th>
<th class="tableblock halign-left valign-top">消耗品？</th>
<th class="tableblock halign-left valign-top">可解决的？</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明API依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这里，您应该声明依赖关系，这些依赖关系将传递给使用者，以进行编译。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>implementation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明实现依赖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这里，您应该声明依赖关系，这些依赖关系完全是内部的，并且不打算向消费者公开。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>compileOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明仅编译依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这里，您应该声明仅在编译时需要的依赖项，而不应泄漏到运行时。这通常包括在运行时找到时会被阴影化的依赖项。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>runtimeOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明运行时依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这里，您应该声明仅在运行时才需要的依赖项，而在编译时则不需要。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>testImplementation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">测试依赖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这里您应该声明用于编译测试的依赖项。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>testCompileOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明测试仅编译依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这里，您应该声明仅在测试编译时需要的依赖项，而不应泄漏到运行时。这通常包括在运行时找到时会被阴影化的依赖项。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>testRuntimeOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明测试运行时依赖项</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这里，您应该声明仅在测试运行时才需要的依赖项，而在测试编译时则不需要。</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表32。Java库插件-使用者使用的配置</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">配置名称</th>
<th class="tableblock halign-left valign-top">角色</th>
<th class="tableblock halign-left valign-top">消耗品？</th>
<th class="tableblock halign-left valign-top">可解决的？</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>apiElements</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于针对该库进行编译</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用者将使用此配置来检索对该库进行编译所需的所有元素。不像<code>default</code>配置，这不会泄漏实现或运行时依赖项。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>runtimeElements</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于执行此库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用者将使用此配置来检索对该库运行所需的所有元素。</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表33。Java库插件-库本身使用的配置</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">配置名称</th>
<th class="tableblock halign-left valign-top">角色</th>
<th class="tableblock halign-left valign-top">消耗品？</th>
<th class="tableblock halign-left valign-top">可解决的？</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">compileClasspath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于编译该库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此配置包含此库的编译类路径，因此在调用java编译器进行编译时使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">runtimeClasspath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于执行此库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此配置包含此库的运行时类路径</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">testCompileClasspath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于编译该库的测试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此配置包含此库的测试编译类路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">testRuntimeClasspath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于执行此库的测试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此配置包含此库的测试运行时类路径</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:java_library_classes_usage"><a class="anchor" href="#sec:java_library_classes_usage"></a> <a class="link" href="#sec:java_library_classes_usage">使用类而不是jar进行编译</a></h4>
<div class="paragraph">
<p>的功能<code>java-library</code>插件是使用该库的项目仅需要classes文件夹进行编译，而不是完整的JAR。这样可以简化项目间的资源依赖关系（ <code>processResources</code>任务）和档案建设（ <code>jar</code>在开发过程中仅执行Java代码编译时，不再执行该任务。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>班输出，而不是JAR中的使用与否是<em>消费者</em>决定。例如，Groovy使用者将请求类<em>和已</em>处理资源，因为在编译过程中执行AST转换可能需要这些类<em>和已</em>处理资源。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="sub:java_library_known_issues_memory"><a class="anchor" href="#sub:java_library_known_issues_memory"></a> <a class="link" href="#sub:java_library_known_issues_memory">消费者使用的内存增加</a></h5>
<div class="paragraph">
<p>间接的结果是，最新的检查将需要更多的内存，因为Gradle会快照单个类文件而不是单个jar。这可能会导致大型项目的内存消耗增加，其好处是<code>compileJava</code>在更多情况下，任务是最新的（例如，更改资源不再更改输入<code>compileJava</code>上游项目的任务）</p>
</div>
</div>
<div class="sect4">
<h5 id="sub:java_library_known_issues_windows_performance"><a class="anchor" href="#sub:java_library_known_issues_windows_performance"></a> <a class="link" href="#sub:java_library_known_issues_windows_performance">Windows上大型项目的构建性能显着下降</a></h5>
<div class="paragraph">
<p>对单个类文件进行快照的另一个副作用，仅影响Windows系统，是在编译类路径上处理大量类文件时，性能可能会大大下降。这仅涉及非常大的多项目，其中，通过使用许多<code>api</code>或（已弃用） <code>compile</code>依赖性。为了减轻这种情况，您可以设置<code>org.gradle.java.compile-classpath-packaging</code>系统属性<code>true</code>更改Java库插件的行为，以对编译类路径上的所有内容使用jar而不是类文件夹。请注意，由于这会带来其他性能影响和潜在的副作用，因此通过在编译时触发所有jar任务，仅当您遇到Windows上描述的性能问题时才建议将其激活。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:library_distribution"><a class="anchor" href="#sec:library_distribution"></a> <a class="link" href="#sec:library_distribution">分发图书馆</a></h4>
<div class="paragraph">
<p>除了将库<a href="#">发布</a>到组件存储库之外，有时您可能还需要将库及其依赖项打包在可分发的交付物中。<a href="#">Java库分发插件</a>可以帮助您做到这一点。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java_library_distribution_plugin"><a class="anchor" href="#java_library_distribution_plugin"></a> <a class="link" href="#java_library_distribution_plugin">Java库发行插件</a></h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>Java库分布插件目前正在<a href="feature_lifecycle.html#feature_lifecycle">孵化</a> 。请注意，在更高的Gradle版本中，DSL和其他配置可能会更改。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Java库分发插件增加了对为Java库构建分发ZIP的支持。该发行版包含该库及其依赖项的JAR文件。</p>
</div>
<div class="sect3">
<h4 id="sec:java_library_distribution_usage"><a class="anchor" href="#sec:java_library_distribution_usage"></a> <a class="link" href="#sec:java_library_distribution_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Java库分发插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例591。使用Java库分发插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library-distribution</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library-distribution`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要定义发行版的名称，您必须设置<code>baseName</code>属性如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">范例592。配置发行名称</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">distributions {
    main {
        distributionBaseName = <span class="string"><span class="delimiter">'</span><span class="content">my-name</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">distributions {
    main {
        distributionBaseName.set(&quot;my-name&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该插件将为您的库建立一个发行版。该发行版将打包该库的运行时依赖项。所有文件存储在<code>src/main/dist</code>将被添加到存档分发的根目录中。您可以运行“ <code>gradle distZip</code> ”以创建包含发行版的ZIP文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_library_distribution_tasks"><a class="anchor" href="#sec:java_library_distribution_tasks"></a> <a class="link" href="#sec:java_library_distribution_tasks">任务</a></h4>
<div class="paragraph">
<p>Java库分发插件将以下任务添加到项目中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>distZip</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">邮编</a></dt>
<dd>
<p><em>取决于</em> ：<code>jar</code></p>
<div class="paragraph">
<p>创建完整的分发ZIP归档文件，包括运行时库。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="java_library_distribution_resources"><a class="anchor" href="#java_library_distribution_resources"></a> <a class="link" href="#java_library_distribution_resources">在分发中包括其他资源</a></h4>
<div class="paragraph">
<p>来自的所有文件<code>src/dist</code>目录被复制。要将任何静态文件包括在发行版中，只需将它们放在<code>src/dist</code>目录，或将它们添加到分发的内容中。</p>
</div>
<div class="exampleblock">
<div class="title">示例593。在分发中包含文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">distributions {
    main {
        distributionBaseName = <span class="string"><span class="delimiter">'</span><span class="content">my-name</span><span class="delimiter">'</span></span>
        contents {
            from <span class="string"><span class="delimiter">'</span><span class="content">src/dist</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">distributions {
    main {
        distributionBaseName.set(&quot;my-name&quot;)
        contents {
            from(&quot;src/dist&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java_platform_plugin"><a class="anchor" href="#java_platform_plugin"></a> <a class="link" href="#java_platform_plugin">Java平台插件</a></h3>
<div class="paragraph">
<p>Java Platform插件带来了声明Java生态系统平台的功能。平台可用于不同目的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一起发布的模块的描述（例如，共享相同的版本）</p>
</li>
<li>
<p>异构库的一组推荐版本。一个典型的例子包括<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-build-systems.html#using-boot-dependency-management">Spring Boot BOM</a></p>
</li>
<li>
<p>在子项目之间<a href="#sec:java_platform_consumption">共享一组依赖版本</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>平台是一种特殊的软件组件，不包含任何资源：它仅用于引用其他库，因此它们在依赖关系解析期间可以很好地协同工作。</p>
</div>
<div class="paragraph">
<p>平台可以发布为<a href="https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md">Gradle模块元数据</a>和<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management">Maven BOM</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>java-platform</code>插件不能与<code>java</code>要么<code>java-library</code>给定项目中的插件。从概念上一个项目或者是一个平台，没有程序， <em>或</em>产生二进制文件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="sec:java_platform_usage"><a class="anchor" href="#sec:java_platform_usage"></a> <a class="link" href="#sec:java_platform_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Java Platform插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例594使用Java平台插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-platform</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-platform`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_platform_separation"><a class="anchor" href="#sec:java_platform_separation"></a> <a class="link" href="#sec:java_platform_separation">API和运行时分离</a></h4>
<div class="paragraph">
<p>Maven BOM和Java平台之间的主要区别在于，在Gradle中，依赖项和<a href="#sub:terminology_dependency_constraint">约束</a>被声明并确定范围为配置以及扩展配置的范围。尽管许多用户只关心声明<em>编译时</em>相关性的约束，这样才可以由运行时和测试继承，但它允许声明依赖项或仅适用于运行时或测试的约束。</p>
</div>
<div class="paragraph">
<p>为了这个目的，该插件公开了两个<a href="#sec:what-are-dependency-configurations">配置</a>可用于声明依赖性： <code>api</code>和<code>runtime</code> 。的<code>api</code>应该使用配置来声明在针对平台进行编译时应使用的约束和依赖关系，而<code>runtime</code>应该使用配置声明运行时可见的约束或依赖项。</p>
</div>
<div class="exampleblock">
<div class="title">示例595。声明API和运行时约束</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    constraints {
        api <span class="string"><span class="delimiter">'</span><span class="content">commons-httpclient:commons-httpclient:3.1</span><span class="delimiter">'</span></span>
        runtime <span class="string"><span class="delimiter">'</span><span class="content">org.postgresql:postgresql:42.2.5</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    constraints {
        api(&quot;commons-httpclient:commons-httpclient:3.1&quot;)
        runtime(&quot;org.postgresql:postgresql:42.2.5&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，此示例使用<em>约束</em>而非依赖关系。通常，这就是您要执行的操作：仅当将这样的组件直接或传递地添加到依赖关系图时，约束才适用。这意味着平台中列出的所有约束都不会添加依赖项，除非另一个组件将其引入：它们可以被视为<em>建议</em> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>例如，如果平台声明对<code>org:foo:1.1</code> ，并且没有其他因素导致对<code>foo</code> ， <code>foo</code> <em>不会</em>出现在图表中。但是，如果<code>foo</code>出现，则通常的冲突解决方案将开始。如果有依赖性<code>org:foo:1.0</code> ，那么我们将选择<code>org:foo:1.1</code>满足平台约束。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，为了避免在平台中添加依赖而不是约束的常见错误，如果尝试这样做，Gradle将失败。如果由于某种原因，除了约束之外，您还想添加<em>依赖项</em> ，则需要显式启用它：</p>
</div>
<div class="exampleblock">
<div class="title">示例596允许声明依赖</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">javaPlatform {
    allowDependencies()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">javaPlatform {
    allowDependencies()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_platform_project_constraints"><a class="anchor" href="#sec:java_platform_project_constraints"></a> <a class="link" href="#sec:java_platform_project_constraints">本地项目约束</a></h4>
<div class="paragraph">
<p>如果您具有多项目构建，并且想要发布链接到子项目的平台，则可以通过声明属于该平台的子项目的约束来做到这一点，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例597声明子项目的约束</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    constraints {
        api project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:core</span><span class="delimiter">&quot;</span></span>)
        api project(<span class="string"><span class="delimiter">&quot;</span><span class="content">:lib</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    constraints {
        api(project(&quot;:core&quot;))
        api(project(&quot;:lib&quot;))
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>项目符号将成为经典<code>group:name:version</code>发布的元数据中的符号。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_platform_bom_import"><a class="anchor" href="#sec:java_platform_bom_import"></a> <a class="link" href="#sec:java_platform_bom_import">来自另一个平台的采购约束</a></h4>
<div class="paragraph">
<p>有时，您定义的平台是另一个现有平台的扩展。</p>
</div>
<div class="paragraph">
<p>为了使您的平台包含来自该第三方平台的限制，需要将其作为<code>platform</code> <em>依赖关系</em> ：</p>
</div>
<div class="exampleblock">
<div class="title">实施例598。导入平台</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">javaPlatform {
    allowDependencies()
}

dependencies {
    api platform(<span class="string"><span class="delimiter">'</span><span class="content">com.fasterxml.jackson:jackson-bom:2.9.8</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">javaPlatform {
    allowDependencies()
}

dependencies {
    api(platform(&quot;com.fasterxml.jackson:jackson-bom:2.9.8&quot;))
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_platform_publishing"><a class="anchor" href="#sec:java_platform_publishing"></a> <a class="link" href="#sec:java_platform_publishing">发布平台</a></h4>
<div class="paragraph">
<p>发布Java平台是通过应用<code>maven-publish</code>插件并配置使用<code>javaPlatform</code>零件：</p>
</div>
<div class="exampleblock">
<div class="title">示例599。作为物料清单发布</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    publications {
        myPlatform(MavenPublication) {
            from components.javaPlatform
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;myPlatform&quot;) {
            from(components[&quot;javaPlatform&quot;])
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将为平台生成BOM表文件，其中包含<code><dependencyManagement></code>阻止其<code><dependencies></code>对应于平台模块中定义的约束。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:java_platform_consumption"><a class="anchor" href="#sec:java_platform_consumption"></a> <a class="link" href="#sec:java_platform_consumption">消费平台</a></h4>
<div class="paragraph">
<p>因为Java平台是一种特殊的组件，所以必须使用Java声明对Java平台的依赖。 <code>platform</code>要么<code>enforcedPlatform</code>关键字，如<a href="#sub:bom_import">管理传递相关性</a>部分中所述。例如，如果要在子项目之间共享依赖版本，则可以定义一个平台模块，该模块将声明所有版本：</p>
</div>
<div class="exampleblock">
<div class="title">示例600在平台模块中推荐版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    constraints {
        <span class="comment">// Platform declares some versions of libraries used in subprojects</span>
        api <span class="string"><span class="delimiter">'</span><span class="content">commons-httpclient:commons-httpclient:3.1</span><span class="delimiter">'</span></span>
        api <span class="string"><span class="delimiter">'</span><span class="content">org.apache.commons:commons-lang3:3.8.1</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    constraints {
        // Platform declares some versions of libraries used in subprojects
        api(&quot;commons-httpclient:commons-httpclient:3.1&quot;)
        api(&quot;org.apache.commons:commons-lang3:3.8.1&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后让子项目依赖平台来获取建议：</p>
</div>
<div class="exampleblock">
<div class="title">示例601从平台获取建议</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    <span class="comment">// get recommended versions from the platform project</span>
    api platform(project(<span class="string"><span class="delimiter">'</span><span class="content">:platform</span><span class="delimiter">'</span></span>))
    <span class="comment">// no version required</span>
    api <span class="string"><span class="delimiter">'</span><span class="content">commons-httpclient:commons-httpclient</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    // get recommended versions from the platform project
    api(platform(project(&quot;:platform&quot;)))
    // no version required
    api(&quot;commons-httpclient:commons-httpclient&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing_maven"><a class="anchor" href="#publishing_maven"></a> <a class="link" href="#publishing_maven">Maven发布插件</a></h3>
<div class="paragraph">
<p>Maven发布插件提供了将构建工件发布到<a href="http://maven.apache.org/">Apache Maven</a>存储库的功能。发布到Maven存储库的模块可由Maven，Gradle（请参阅<a href="#">声明依赖项</a> ）和其他了解Maven存储库格式的工具使用。您可以在<a href="#publishing_overview">发布概述中</a>了解发布的基础知识。</p>
</div>
<div class="sect3">
<h4 id="publishing_maven:usage"><a class="anchor" href="#publishing_maven:usage"></a> <a class="link" href="#publishing_maven:usage">用法</a></h4>
<div class="paragraph">
<p>要使用Maven发布插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">范例602。应用Maven发布插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">maven-publish</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `maven-publish`
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Maven发布插件在项目上使用了扩展名<code>publishing</code>类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.PublishingExtension.html">PublishingExtension</a> 。此扩展提供了一个命名出版物的容器和一个命名存储库的容器。Maven Publish插件可与<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">MavenPublication</a>出版物和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html">MavenArtifactRepository</a>存储库一起使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="publishing_maven:tasks"><a class="anchor" href="#publishing_maven:tasks"></a> <a class="link" href="#publishing_maven:tasks">任务</a></h4>
<div id="publishing_maven:generate-pom" class="dlist">
<dl>
<dt class="hdlist1"><code>generatePomFileFor<em>PubName</em>Publication</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.tasks.GenerateMavenPom.html">GenerateMavenPom</a></dt>
<dd>
<p>为名为<em>PubName</em>的发布创建一个POM文件，填充已知的元数据，例如项目名称，项目版本和依赖项。POM文件的默认位置是<em>build / publications / $ pubName / pom-default.xml</em> 。</p>
</dd>
<dt class="hdlist1"><code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html">PublishToMaven资源库</a></dt>
<dd>
<p>将<em>PubName</em>发布发布到名为<em>RepoName</em>的存储库。如果您有没有明确名称的存储库定义，则<em>RepoName</em>将为“ Maven”。</p>
</dd>
<dt class="hdlist1"><code>publish<em>PubName</em>PublicationToMavenLocal</code> — <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/publish/maven/tasks/PublishToMavenLocal.html">PublishToMavenLocal</a></dt>
<dd>
<p>将<em>PubName</em>发布以及本地发布的POM文件和其他元数据复制到本地Maven缓存中（通常<em>为$ USER_HOME / .m2 / repository）</em> 。</p>
</dd>
<dt class="hdlist1"><code>publish</code></dt>
<dd>
<p><em>取决于</em> ：全部<code>publish<em>PubName</em>PublicationTo<em>RepoName</em>Repository</code>任务</p>
<div class="paragraph">
<p>将所有定义的发布发布到所有定义的存储库的聚合任务。它<em>不</em>包括复制出版物本地Maven缓存。</p>
</div>
</dd>
<dt class="hdlist1"><code>publishToMavenLocal</code></dt>
<dd>
<p><em>取决于</em> ：全部<code>publish<em>PubName</em>PublicationToMavenLocal</code>任务</p>
<div class="paragraph">
<p>将所有已定义的发布（包括其元数据（POM文件等））复制到本地Maven缓存中。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="publishing_maven:publications"><a class="anchor" href="#publishing_maven:publications"></a> <a class="link" href="#publishing_maven:publications">刊物</a></h4>
<div class="paragraph">
<p>此插件提供<a href="#sub:terminology_publication">出版物</a>类型的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">MavenPublication</a> 。要了解如何定义和使用出版物，请参见<a href="#sec:basic_publishing">基本出版</a>部分。</p>
</div>
<div class="paragraph">
<p>您可以在Maven发布中配置以下四项主要内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个<a href="#sub:terminology_component">组件</a> —通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication:from(org.gradle.api.component.SoftwareComponent)">MavenPublication.from（org.gradle.api.component。软件组件）</a> 。</p>
</li>
<li>
<p><a href="#sec:publishing_custom_artifacts_to_maven">自定义工件</a> -通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication:artifact(java.lang.Object)">MavenPublication.artifact（java.lang。对象）</a>方法。有关自定义Maven工件的可用配置选项，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenArtifact.html">MavenArtifact</a> 。</p>
</li>
<li>
<p>标准元数据，例如<code>artifactId</code> ， <code>groupId</code>和<code>version</code> 。</p>
</li>
<li>
<p>POM文件的其他内容-通过<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication:pom(org.gradle.api.Action)">MavenPublication.pom（org.gradle.api。动作）</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在<a href="#publishing_maven:complete_example">完整的发布示例中</a>看到所有这些内容。的API文档<code>MavenPublication</code>有其他代码示例。</p>
</div>
<div class="sect4">
<h5 id="sec:identity_values_in_the_generated_pom"><a class="anchor" href="#sec:identity_values_in_the_generated_pom"></a> <a class="link" href="#sec:identity_values_in_the_generated_pom">生成的POM中的标识值</a></h5>
<div class="paragraph">
<p>生成的POM文件的属性将包含从以下项目属性派生的标识值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>groupId</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:group">-Project.getGroup（）</a></p>
</li>
<li>
<p><code>artifactId</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:name">-Project.getName（）</a></p>
</li>
<li>
<p><code>version</code> <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.Project.html#org.gradle.api.Project:version">-Project.getVersion（）</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>覆盖默认身份值很容易：只需指定<code>groupId</code> ， <code>artifactId</code>要么<code>version</code>配置<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">MavenPublication</a>时的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">属性</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例603自定义发布标识</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    publishing {
        publications {
            maven(MavenPublication) {
                groupId = <span class="string"><span class="delimiter">'</span><span class="content">org.gradle.sample</span><span class="delimiter">'</span></span>
                artifactId = <span class="string"><span class="delimiter">'</span><span class="content">project1-sample</span><span class="delimiter">'</span></span>
                version = <span class="string"><span class="delimiter">'</span><span class="content">1.1</span><span class="delimiter">'</span></span>

                from components.java
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">    publishing {
        publications {
            create&lt;MavenPublication&gt;(&quot;maven&quot;) {
                groupId = &quot;org.gradle.sample&quot;
                artifactId = &quot;project1-sample&quot;
                version = &quot;1.1&quot;

                from(components[&quot;java&quot;])
            }
        }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title">小费</div>
</td>
<td class="content">
<div class="paragraph">
<p>某些存储库将无法处理所有受支持的字符。例如， <code>:</code>在Windows上发布到支持文件系统的存储库时，不能将该字符用作标识符。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Maven的限制<code>groupId</code>和<code>artifactId</code>限定字符集（ <code>[A-Za-z0-9_\\-.]+</code> ），Gradle会强制执行此限制。对于<code>version</code> （以及工件<code>extension</code>和<code>classifier</code>属性），Gradle将处理任何有效的Unicode字符。</p>
</div>
<div class="paragraph">
<p>明确禁止的唯一Unicode值是<code>\</code> ， <code>/</code>以及任何ISO控制字符。提供的值在发布早期就得到了验证。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:modifying_the_generated_pom"><a class="anchor" href="#sec:modifying_the_generated_pom"></a> <a class="link" href="#sec:modifying_the_generated_pom">自定义生成的POM</a></h5>
<div class="paragraph">
<p>可以在发布之前自定义生成的POM文件。例如，将库发布到Maven Central时，您需要设置某些元数据。Maven发布插件为此提供了DSL。请参阅DSL参考中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPom.html">MavenPom</a> ，以获取可用属性和方法的完整文档。下面的示例演示如何使用最常见的方法：</p>
</div>
<div class="exampleblock">
<div class="title">例子604。自定义POM文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    publications {
        mavenJava(MavenPublication) {
            pom {
                name = <span class="string"><span class="delimiter">'</span><span class="content">My Library</span><span class="delimiter">'</span></span>
                description = <span class="string"><span class="delimiter">'</span><span class="content">A concise description of my library</span><span class="delimiter">'</span></span>
                url = <span class="string"><span class="delimiter">'</span><span class="content">http://www.example.com/library</span><span class="delimiter">'</span></span>
                properties = [
                    <span class="key">myProp</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>,
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">prop.with.dots</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">anotherValue</span><span class="delimiter">&quot;</span></span>
                ]
                licenses {
                    license {
                        name = <span class="string"><span class="delimiter">'</span><span class="content">The Apache License, Version 2.0</span><span class="delimiter">'</span></span>
                        url = <span class="string"><span class="delimiter">'</span><span class="content">http://www.apache.org/licenses/LICENSE-2.0.txt</span><span class="delimiter">'</span></span>
                    }
                }
                developers {
                    developer {
                        id = <span class="string"><span class="delimiter">'</span><span class="content">johnd</span><span class="delimiter">'</span></span>
                        name = <span class="string"><span class="delimiter">'</span><span class="content">John Doe</span><span class="delimiter">'</span></span>
                        email = <span class="string"><span class="delimiter">'</span><span class="content">john.doe@example.com</span><span class="delimiter">'</span></span>
                    }
                }
                scm {
                    connection = <span class="string"><span class="delimiter">'</span><span class="content">scm:git:git://example.com/my-library.git</span><span class="delimiter">'</span></span>
                    developerConnection = <span class="string"><span class="delimiter">'</span><span class="content">scm:git:ssh://example.com/my-library.git</span><span class="delimiter">'</span></span>
                    url = <span class="string"><span class="delimiter">'</span><span class="content">http://example.com/my-library/</span><span class="delimiter">'</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
            pom {
                name.set(&quot;My Library&quot;)
                description.set(&quot;A concise description of my library&quot;)
                url.set(&quot;http://www.example.com/library&quot;)
                properties.set(mapOf(
                    &quot;myProp&quot; to &quot;value&quot;,
                    &quot;prop.with.dots&quot; to &quot;anotherValue&quot;
                ))
                licenses {
                    license {
                        name.set(&quot;The Apache License, Version 2.0&quot;)
                        url.set(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)
                    }
                }
                developers {
                    developer {
                        id.set(&quot;johnd&quot;)
                        name.set(&quot;John Doe&quot;)
                        email.set(&quot;john.doe@example.com&quot;)
                    }
                }
                scm {
                    connection.set(&quot;scm:git:git://example.com/my-library.git&quot;)
                    developerConnection.set(&quot;scm:git:ssh://example.com/my-library.git&quot;)
                    url.set(&quot;http://example.com/my-library/&quot;)
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="publishing_maven:resolved_dependencies"><a class="anchor" href="#publishing_maven:resolved_dependencies"></a> <a class="link" href="#publishing_maven:resolved_dependencies">自定义依赖项版本</a></h5>
<div class="paragraph">
<p>支持两种策略来发布依赖项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">声明的版本（默认）</dt>
<dd>
<p>该策略会发布构建脚本作者定义的版本，并在其中声明依赖项。 <code>dependencies</code>块。发布不会考虑任何其他类型的处理，例如通过<a href="#">更改已解决版本的规则</a>进行的处理。</p>
</dd>
<dt class="hdlist1">解决的版本</dt>
<dd>
<p>此策略可能会通过应用解决方案规则和自动冲突解决方案来发布在构建期间已解决的版本。这样做的好处是，发布的版本对应于测试发布的工件的版本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>解析版本的示例用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>项目将动态版本用于依赖项，但更喜欢将给定版本的已解析版本公开给其使用者。</p>
</li>
<li>
<p>与<a href="#">依赖项锁定</a>结合使用，您要发布锁定的版本。</p>
</li>
<li>
<p>一个项目利用了Gradle的丰富版本约束，这些约束对Maven的转换是有损的。它不依赖转换，而是发布已解决的版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是通过使用<code>versionMapping</code>允许配置<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/publish/VersionMappingStrategy.html">VersionMappingStrategy的</a> DSL方法：</p>
</div>
<div class="exampleblock">
<div class="title">示例605使用已解决的版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    publications {
        mavenJava(MavenPublication) {
            versionMapping {
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-api</span><span class="delimiter">'</span></span>) {
                    fromResolutionOf(<span class="string"><span class="delimiter">'</span><span class="content">runtimeClasspath</span><span class="delimiter">'</span></span>)
                }
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-runtime</span><span class="delimiter">'</span></span>) {
                    fromResolutionResult()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
            versionMapping {
                usage(&quot;java-api&quot;) {
                    fromResolutionOf(&quot;runtimeClasspath&quot;)
                }
                usage(&quot;java-runtime&quot;) {
                    fromResolutionResult()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，Gradle将使用在<code>runtimeClasspath</code>对于在中声明的依赖项<code>api</code> ，它们映射到<code>compile</code> Maven的范围。Gradle还将使用在<code>runtimeClasspath</code>对于在中声明的依赖项<code>implementation</code> ，它们映射到<code>runtime</code> Maven的范围。
<code>fromResolutionResult()</code>指示Gradle应该使用变体的默认类路径，并且<code>runtimeClasspath</code>是的默认类路径<code>java-runtime</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="publishing_maven:repositories"><a class="anchor" href="#publishing_maven:repositories"></a> <a class="link" href="#publishing_maven:repositories">储存库</a></h4>
<div class="paragraph">
<p>该插件提供了<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html">MavenArtifactRepository</a>类型的<a href="#sub:terminology_repository">存储库</a> 。要了解如何定义和使用存储库进行发布，请参见“ <a href="#sec:basic_publishing">基本发布</a> ”部分。</p>
</div>
<div class="paragraph">
<p>这是定义发布存储库的简单示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例606声明要发布到的存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    repositories {
        maven {
            <span class="comment">// change to point to your repo, e.g. http://my.org/repo</span>
            url = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repo</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    repositories {
        maven {
            // change to point to your repo, e.g. http://my.org/repo
            url = uri(&quot;$buildDir/repo&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您将要配置的两件事是存储库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网址（必填）</p>
</li>
<li>
<p>名称（可选）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以定义多个存储库，只要它们在构建脚本中具有唯一的名称即可。您也可以声明一个（只有一个）没有名称的存储库。该存储库将采用隐式名称“ Maven”。</p>
</div>
<div class="paragraph">
<p>您还可以配置连接到存储库所需的任何身份验证详细信息。有关更多详细信息，请参见<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html">MavenArtifactRepository</a> 。</p>
</div>
<div class="sect4">
<h5 id="publishing_maven:snapshot_and_release_repositories"><a class="anchor" href="#publishing_maven:snapshot_and_release_repositories"></a> <a class="link" href="#publishing_maven:snapshot_and_release_repositories">快照和发布存储库</a></h5>
<div class="paragraph">
<p>将快照和发行版发布到不同的Maven存储库是一种常见的做法。一种简单的方法是根据项目版本配置存储库URL。下面的示例对以“ SNAPSHOT”结尾的版本使用一个URL，对其余版本使用不同的URL：</p>
</div>
<div class="exampleblock">
<div class="title">示例607根据项目版本配置存储库URL</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    repositories {
        maven {
            <span class="keyword">def</span> releasesRepoUrl = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/releases</span><span class="delimiter">&quot;</span></span>
            <span class="keyword">def</span> snapshotsRepoUrl = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/snapshots</span><span class="delimiter">&quot;</span></span>
            url = version.endsWith(<span class="string"><span class="delimiter">'</span><span class="content">SNAPSHOT</span><span class="delimiter">'</span></span>) ? snapshotsRepoUrl : releasesRepoUrl
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    repositories {
        maven {
            val releasesRepoUrl = &quot;$buildDir/repos/releases&quot;
            val snapshotsRepoUrl = &quot;$buildDir/repos/snapshots&quot;
            url = uri(if (version.toString().endsWith(&quot;SNAPSHOT&quot;)) snapshotsRepoUrl else releasesRepoUrl)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，您可以使用<a href="#build_environment">项目或系统属性</a>来决定发布到哪个存储库。如果项目属性，以下示例使用发行版存储库<code>release</code>设置，例如当用户运行时<code>gradle -Prelease publish</code> ：</p>
</div>
<div class="exampleblock">
<div class="title">示例608根据项目属性配置存储库URL</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">publishing {
    repositories {
        maven {
            <span class="keyword">def</span> releasesRepoUrl = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/releases</span><span class="delimiter">&quot;</span></span>
            <span class="keyword">def</span> snapshotsRepoUrl = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/snapshots</span><span class="delimiter">&quot;</span></span>
            url = project.hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">release</span><span class="delimiter">'</span></span>) ? releasesRepoUrl : snapshotsRepoUrl
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">publishing {
    repositories {
        maven {
            val releasesRepoUrl = &quot;$buildDir/repos/releases&quot;
            val snapshotsRepoUrl = &quot;$buildDir/repos/snapshots&quot;
            url = uri(if (project.hasProperty(&quot;release&quot;)) releasesRepoUrl else snapshotsRepoUrl)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="publishing_maven:install"><a class="anchor" href="#publishing_maven:install"></a> <a class="link" href="#publishing_maven:install">发布到Maven Local</a></h4>
<div class="paragraph">
<p>为了与本地Maven安装集成，有时将模块及其POM文件和其他元数据发布到Maven本地存储库（通常位于<em>$ USER_HOME / .m2 / repository中</em> ） <em>很有</em>用。用Maven的话来说，这就是“安装”模块。</p>
</div>
<div class="paragraph">
<p>Maven发布插件可通过自动为每个<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">MavenPublication</a>创建<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/publish/maven/tasks/PublishToMavenLocal.html">PublishToMavenLocal</a>任务来<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.publish.maven.MavenPublication.html">简化</a>此操作。 <code>publishing.publications</code>容器。任务名称遵循以下格式<code>publish<em>PubName</em>PublicationToMavenLocal</code> 。这些任务中的每一个都连接到<code>publishToMavenLocal</code>聚合任务。您不需要<code>mavenLocal()</code>在你的<code>publishing.repositories</code>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="publishing_maven:complete_example"><a class="anchor" href="#publishing_maven:complete_example"></a> <a class="link" href="#publishing_maven:complete_example">完整的例子</a></h4>
<div class="paragraph">
<p>以下示例演示如何签名和发布Java库，包括源，Javadoc和自定义的POM：</p>
</div>
<div class="exampleblock">
<div class="title">示例609发布Java库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">java-library</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">maven-publish</span><span class="delimiter">'</span></span>
    id <span class="string"><span class="delimiter">'</span><span class="content">signing</span><span class="delimiter">'</span></span>
}

group = <span class="string"><span class="delimiter">'</span><span class="content">com.example</span><span class="delimiter">'</span></span>
version = <span class="string"><span class="delimiter">'</span><span class="content">1.0</span><span class="delimiter">'</span></span>

java {
    withJavadocJar()
    withSourcesJar()
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifactId = <span class="string"><span class="delimiter">'</span><span class="content">my-library</span><span class="delimiter">'</span></span>
            from components.java
            versionMapping {
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-api</span><span class="delimiter">'</span></span>) {
                    fromResolutionOf(<span class="string"><span class="delimiter">'</span><span class="content">runtimeClasspath</span><span class="delimiter">'</span></span>)
                }
                usage(<span class="string"><span class="delimiter">'</span><span class="content">java-runtime</span><span class="delimiter">'</span></span>) {
                    fromResolutionResult()
                }
            }
            pom {
                name = <span class="string"><span class="delimiter">'</span><span class="content">My Library</span><span class="delimiter">'</span></span>
                description = <span class="string"><span class="delimiter">'</span><span class="content">A concise description of my library</span><span class="delimiter">'</span></span>
                url = <span class="string"><span class="delimiter">'</span><span class="content">http://www.example.com/library</span><span class="delimiter">'</span></span>
                properties = [
                    <span class="key">myProp</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>,
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">prop.with.dots</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">anotherValue</span><span class="delimiter">&quot;</span></span>
                ]
                licenses {
                    license {
                        name = <span class="string"><span class="delimiter">'</span><span class="content">The Apache License, Version 2.0</span><span class="delimiter">'</span></span>
                        url = <span class="string"><span class="delimiter">'</span><span class="content">http://www.apache.org/licenses/LICENSE-2.0.txt</span><span class="delimiter">'</span></span>
                    }
                }
                developers {
                    developer {
                        id = <span class="string"><span class="delimiter">'</span><span class="content">johnd</span><span class="delimiter">'</span></span>
                        name = <span class="string"><span class="delimiter">'</span><span class="content">John Doe</span><span class="delimiter">'</span></span>
                        email = <span class="string"><span class="delimiter">'</span><span class="content">john.doe@example.com</span><span class="delimiter">'</span></span>
                    }
                }
                scm {
                    connection = <span class="string"><span class="delimiter">'</span><span class="content">scm:git:git://example.com/my-library.git</span><span class="delimiter">'</span></span>
                    developerConnection = <span class="string"><span class="delimiter">'</span><span class="content">scm:git:ssh://example.com/my-library.git</span><span class="delimiter">'</span></span>
                    url = <span class="string"><span class="delimiter">'</span><span class="content">http://example.com/my-library/</span><span class="delimiter">'</span></span>
                }
            }
        }
    }
    repositories {
        maven {
            <span class="comment">// change URLs to point to your repos, e.g. http://my.org/repo</span>
            <span class="keyword">def</span> releasesRepoUrl = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/releases</span><span class="delimiter">&quot;</span></span>
            <span class="keyword">def</span> snapshotsRepoUrl = <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/repos/snapshots</span><span class="delimiter">&quot;</span></span>
            url = version.endsWith(<span class="string"><span class="delimiter">'</span><span class="content">SNAPSHOT</span><span class="delimiter">'</span></span>) ? snapshotsRepoUrl : releasesRepoUrl
        }
    }
}

signing {
    sign publishing.publications.mavenJava
}


javadoc {
    <span class="keyword">if</span>(JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption(<span class="string"><span class="delimiter">'</span><span class="content">html5</span><span class="delimiter">'</span></span>, <span class="predefined-constant">true</span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    `java-library`
    `maven-publish`
    signing
}

group = &quot;com.example&quot;
version = &quot;1.0&quot;

java {
    withJavadocJar()
    withSourcesJar()
}

publishing {
    publications {
        create&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
            artifactId = &quot;my-library&quot;
            from(components[&quot;java&quot;])
            versionMapping {
                usage(&quot;java-api&quot;) {
                    fromResolutionOf(&quot;runtimeClasspath&quot;)
                }
                usage(&quot;java-runtime&quot;) {
                    fromResolutionResult()
                }
            }
            pom {
                name.set(&quot;My Library&quot;)
                description.set(&quot;A concise description of my library&quot;)
                url.set(&quot;http://www.example.com/library&quot;)
                properties.set(mapOf(
                    &quot;myProp&quot; to &quot;value&quot;,
                    &quot;prop.with.dots&quot; to &quot;anotherValue&quot;
                ))
                licenses {
                    license {
                        name.set(&quot;The Apache License, Version 2.0&quot;)
                        url.set(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)
                    }
                }
                developers {
                    developer {
                        id.set(&quot;johnd&quot;)
                        name.set(&quot;John Doe&quot;)
                        email.set(&quot;john.doe@example.com&quot;)
                    }
                }
                scm {
                    connection.set(&quot;scm:git:git://example.com/my-library.git&quot;)
                    developerConnection.set(&quot;scm:git:ssh://example.com/my-library.git&quot;)
                    url.set(&quot;http://example.com/my-library/&quot;)
                }
            }
        }
    }
    repositories {
        maven {
            // change URLs to point to your repos, e.g. http://my.org/repo
            val releasesRepoUrl = uri(&quot;$buildDir/repos/releases&quot;)
            val snapshotsRepoUrl = uri(&quot;$buildDir/repos/snapshots&quot;)
            url = if (version.toString().endsWith(&quot;SNAPSHOT&quot;)) snapshotsRepoUrl else releasesRepoUrl
        }
    }
}

signing {
    sign(publishing.publications[&quot;mavenJava&quot;])
}

tasks.javadoc {
    if (JavaVersion.current().isJava9Compatible) {
        (options as StandardJavadocDocletOptions).addBooleanOption(&quot;html5&quot;, true)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>结果是将发布以下工件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POM：<code>my-library-1.0.pom</code></p>
</li>
<li>
<p>Java组件的主要JAR工件：<code>my-library-1.0.jar</code></p>
</li>
<li>
<p>已明确配置的源JAR工件：<code>my-library-1.0-sources.jar</code></p>
</li>
<li>
<p>已明确配置的Javadoc JAR工件：<code>my-library-1.0-javadoc.jar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#signing_plugin">签名插件</a>用于为每个工件生成签名文件。此外，还将为所有工件和签名文件生成校验和文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="publishing_maven:deferred_configuration"><a class="anchor" href="#publishing_maven:deferred_configuration"></a> <a class="link" href="#publishing_maven:deferred_configuration">删除延迟的配置行为</a></h4>
<div class="paragraph">
<p>在Gradle 5.0之前， <code>publishing {}</code> （默认情况下）隐式地将block视为在评估项目后执行了其中的所有逻辑。此行为引起了很多混乱，在Gradle 4.8中已弃用，因为它是唯一以这种方式运行的块。</p>
</div>
<div class="paragraph">
<p>您的发布块中或插件中可能有一些逻辑，具体取决于延迟的配置行为。例如，以下逻辑假定在设置artifactId时将评估子项目：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    publishing {
        publications {
            mavenJava(MavenPublication) {
                from components.java
                artifactId = jar.archiveBaseName
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    publishing {
        publications {
            create&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
                from(components[&quot;java&quot;])
                artifactId = tasks.jar.get().archiveBaseName.get()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在必须将这种逻辑包装在<code>afterEvaluate {}</code>块。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">subprojects {
    publishing {
        publications {
            mavenJava(MavenPublication) {
                from components.java
                afterEvaluate {
                    artifactId = jar.archiveBaseName
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">subprojects {
    publishing {
        publications {
            create&lt;MavenPublication&gt;(&quot;mavenJava&quot;) {
                from(components[&quot;java&quot;])
                afterEvaluate {
                    artifactId = tasks.jar.get().archiveBaseName.get()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="maven_plugin"><a class="anchor" href="#maven_plugin"></a> <a class="link" href="#maven_plugin">Maven插件</a></h3>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">
<div class="paragraph">
<p>本章描述了使用Gradle 1.0中提供的<em>原始的</em> ， <em>不推荐使用的</em>发布机制将工件部署到Maven存储库：在Gradle 1.3中，引入了一种新的发布机制。这种新机制引入了一些新概念和功能，这些功能使Gradle发布变得更加强大，现在已成为发布工件的首选选项。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="#publishing_ivy">Publishing Ivy</a>和<a href="#publishing_maven">Publishing Maven中</a>了解有关新发布插件的信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Maven插件增加了将工件部署到Maven存储库的支持。</p>
</div>
<div class="sect3">
<h4 id="sec:maven_usage"><a class="anchor" href="#sec:maven_usage"></a> <a class="link" href="#sec:maven_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Maven插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例610使用Maven插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">maven</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    maven
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:maven_tasks"><a class="anchor" href="#sec:maven_tasks"></a> <a class="link" href="#sec:maven_tasks">任务</a></h4>
<div class="paragraph">
<p>Maven插件定义了以下任务：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>install</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.Upload.html">上传</a></dt>
<dd>
<p><em>取决于</em> ：构建关联档案的所有任务。</p>
<div class="paragraph">
<p>将关联的工件安装到本地Maven缓存，包括Maven元数据生成。默认情况下，安装任务与<code>archives</code>组态。默认情况下，此配置仅将默认jar作为元素。要了解有关安装到本地存储库的更多信息，请参阅<a href="#sub:installing_to_the_local_repository">安装到本地存储库。</a></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:maven_dependency_management"><a class="anchor" href="#sec:maven_dependency_management"></a> <a class="link" href="#sec:maven_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>Maven插件未定义任何依赖项配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:maven_convention_properties"><a class="anchor" href="#sec:maven_convention_properties"></a> <a class="link" href="#sec:maven_convention_properties">公约属性</a></h4>
<div class="paragraph">
<p>Maven插件定义了以下约定属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mavenPomDir</code> -<code>File</code></dt>
<dd>
<p>生成的POM写入的目录。<em>预设值</em> ：<code><em>${project.buildDir}</em>/poms</code></p>
</dd>
<dt class="hdlist1"><code>conf2ScopeMappings</code> -<code><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/maven/Conf2ScopeMappingContainer.html">Conf2ScopeMappingContainer</a></code></dt>
<dd>
<p>将Gradle配置映射到Maven范围的说明。请参阅<a href="#sub:dependency_mapping">依赖性映射</a> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这些属性由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.MavenPluginConvention.html">MavenPluginConvention</a>约定对象提供。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:maven_convention_methods"><a class="anchor" href="#sec:maven_convention_methods"></a> <a class="link" href="#sec:maven_convention_methods">约定方法</a></h4>
<div class="paragraph">
<p>Maven插件提供了一种用于创建POM的工厂方法。如果您需要一个没有上载到Maven仓库的上下文的POM，这将很有用。</p>
</div>
<div class="exampleblock">
<div class="title">示例611创建一个独立的pom。</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task writeNewPom {
    doLast {
        pom {
            project {
                inceptionYear <span class="string"><span class="delimiter">'</span><span class="content">2008</span><span class="delimiter">'</span></span>
                licenses {
                    license {
                        name <span class="string"><span class="delimiter">'</span><span class="content">The Apache Software License, Version 2.0</span><span class="delimiter">'</span></span>
                        url <span class="string"><span class="delimiter">'</span><span class="content">http://www.apache.org/licenses/LICENSE-2.0.txt</span><span class="delimiter">'</span></span>
                        distribution <span class="string"><span class="delimiter">'</span><span class="content">repo</span><span class="delimiter">'</span></span>
                    }
                }
            }
        }.writeTo(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>buildDir</span><span class="content">/newpom.xml</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">task(&quot;writeNewPom&quot;) {
    doLast {
        maven.pom {
            withGroovyBuilder {
                &quot;project&quot; {
                    setProperty(&quot;inceptionYear&quot;, &quot;2008&quot;)
                    &quot;licenses&quot; {
                        &quot;license&quot; {
                            setProperty(&quot;name&quot;, &quot;The Apache Software License, Version 2.0&quot;)
                            setProperty(&quot;url&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)
                            setProperty(&quot;distribution&quot;, &quot;repo&quot;)
                        }
                    }
                }
            }
        }.writeTo(&quot;$buildDir/newpom.xml&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>其中，Gradle支持与多语言Maven相同的构建器语法。要了解有关Gradle Maven POM对象的更多信息，请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/maven/MavenPom.html">MavenPom</a> 。另请参阅： <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.MavenPluginConvention.html">MavenPluginConvention</a></p>
</div>
</div>
<div class="sect3">
<h4 id="uploading_to_maven_repositories"><a class="anchor" href="#uploading_to_maven_repositories"></a> <a class="link" href="#uploading_to_maven_repositories">与Maven仓库交互</a></h4>
<div class="sect4">
<h5 id="sec:maven_upload_intro"><a class="anchor" href="#sec:maven_upload_intro"></a> <a class="link" href="#sec:maven_upload_intro">介绍</a></h5>
<div class="paragraph">
<p>使用Gradle，您可以部署到远程Maven存储库或安装到本地Maven存储库。这包括所有Maven元数据操作，并且还适用于Maven快照。实际上，Gradle的部署是100％与Maven兼容的，因为我们在后台使用了本机Maven Ant任务。</p>
</div>
<div class="paragraph">
<p>如果没有POM，则部署到Maven存储库只是一半的乐趣。幸运的是，Gradle可以使用其拥有的依赖项信息为您生成此POM。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:deploying_to_a_maven_repository"><a class="anchor" href="#sec:deploying_to_a_maven_repository"></a> <a class="link" href="#sec:deploying_to_a_maven_repository">部署到Maven存储库</a></h5>
<div class="paragraph">
<p>假设您的项目仅生成默认的jar文件。现在，您想将此jar文件部署到远程Maven存储库。</p>
</div>
<div class="exampleblock">
<div class="title">示例612。将文件上传到远程Maven存储库</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">maven</span><span class="delimiter">'</span></span>
}

uploadArchives {
    repositories {
        mavenDeployer {
            repository(<span class="key">url</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">file://localhost/tmp/myRepo/</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    maven
}

tasks.named&lt;Upload&gt;(&quot;uploadArchives&quot;) {
    repositories.withGroovyBuilder {
        &quot;mavenDeployer&quot; {
            &quot;repository&quot;(&quot;url&quot; to &quot;file://localhost/tmp/myRepo/&quot;)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就这些。呼叫<code>uploadArchives</code>任务将生成POM并将工件和POM部署到指定的存储库。</p>
</div>
<div class="paragraph">
<p>如果您需要其他协议的支持，则还有更多工作要做<code>file</code> 。在这种情况下，我们委托的本机Maven代码需要其他库。需要哪些库取决于您计划使用哪种协议。适用<a href="#wagonLibs">于Maven部署的协议JAR</a>中列出了可用的协议和相应的库（这些库具有传递性依赖关系，而传递性依赖关系具有传递性依赖关系）。 <sup class="footnote">[ <a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="查看脚注。">21</a> ]</sup> 例如，要使用ssh协议，您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例613通过SSH上传文件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
    deployerJars
}

repositories {
    mavenCentral()
}

dependencies {
    deployerJars <span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.maven.wagon:wagon-ssh:2.2</span><span class="delimiter">&quot;</span></span>
}

uploadArchives {
    repositories.mavenDeployer {
        configuration = configurations.deployerJars
        repository(<span class="key">url</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">scp://repos.mycompany.com/releases</span><span class="delimiter">&quot;</span></span>) {
            authentication(<span class="key">userName</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">me</span><span class="delimiter">&quot;</span></span>, <span class="key">password</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">myPassword</span><span class="delimiter">&quot;</span></span>)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val deployerJars by configurations.creating

repositories {
    mavenCentral()
}

dependencies {
    deployerJars(&quot;org.apache.maven.wagon:wagon-ssh:2.2&quot;)
}

tasks.named&lt;Upload&gt;(&quot;uploadArchives&quot;) {
    repositories.withGroovyBuilder {
        &quot;mavenDeployer&quot; {
            setProperty(&quot;configuration&quot;, deployerJars)
            &quot;repository&quot;(&quot;url&quot; to &quot;scp://repos.mycompany.com/releases&quot;) {
                &quot;authentication&quot;(&quot;userName&quot; to &quot;me&quot;, &quot;password&quot; to &quot;myPassword&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Maven部署程序有许多配置选项。通过Groovy构建器完成配置。该树的所有元素都是Java bean。要配置简单属性，请将映射传递给bean元素。要将bean元素添加到其父元素，请使用闭包。在上面的示例中， <em>存储库</em>和<em>身份验证</em>就是这样的bean元素。<a href="#deployerConfig">Maven部署程序的配置元素</a>列出了可用的bean元素以及到相应类的Javadoc的链接。在Javadoc中，您可以看到可以为特定元素设置的可能属性。</p>
</div>
<div class="paragraph">
<p>在Maven中，您可以定义存储库，也可以定义快照存储库。如果未定义快照存储库，则版本和快照都将部署到<code>repository</code>元件。否则，快照将部署到<code>snapshotRepository</code>元件。</p>
</div>
<table id="wagonLibs" class="tableblock frame-all grid-all fit-content">
<caption class="title">表34。用于Maven部署的协议jar</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">协议</th>
<th class="tableblock halign-left valign-top">图书馆</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.maven.wagon：wagon-http：2.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ssh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.maven.wagon：wagon-ssh：2.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSH外部</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.maven.wagon：wagon-ssh-external：2.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.maven.wagon：wagon-ftp：2.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">webdav</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.maven.wagon：wagon-webdav：1.0-beta-2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
</tr>
</tbody>
</table>
<table id="deployerConfig" class="tableblock frame-all grid-all fit-content">
<caption class="title">表35。MavenDeployer的配置元素</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">元件</th>
<th class="tableblock halign-left valign-top">Java文档</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html">MavenDeployer</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">资料库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RemoteRepository.html">org.apache.maven.artifact.ant。远程仓库</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">认证方式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/Authentication.html">org.apache.maven.artifact.ant。认证方式</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RepositoryPolicy.html">org.apache.maven.artifact.ant。仓库政策</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">快照</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RepositoryPolicy.html">org.apache.maven.artifact.ant。仓库政策</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">代理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/Proxy.html">org.apache.maven.artifact.ant。代理</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">快照存储库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RemoteRepository.html">org.apache.maven.artifact.ant。远程仓库</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="sub:installing_to_the_local_repository"><a class="anchor" href="#sub:installing_to_the_local_repository"></a> <a class="link" href="#sub:installing_to_the_local_repository">安装到本地存储库</a></h5>
<div class="paragraph">
<p>Maven插件添加了一个<code>install</code>项目任务。此任务取决于以下任务的所有存档任务： <code>archives</code>组态。它将那些存档安装到本地Maven存储库。如果在Maven中重新定义了本地存储库的默认位置<code>settings.xml</code> ，这是此任务考虑的。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:maven_pom_generation"><a class="anchor" href="#sec:maven_pom_generation"></a> <a class="link" href="#sec:maven_pom_generation">Maven POM生成</a></h5>
<div class="paragraph">
<p>将工件部署到Maven存储库时，Gradle会自动为其生成POM。的<code>groupId</code> ， <code>artifactId</code> ， <code>version</code>和<code>packaging</code>用于POM的元素默认为下表中显示的值。的<code>dependency</code>元素是从项目的依赖项声明中创建的。</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表36。Maven POM生成的默认值</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Maven元素</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">groupId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目组</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">artifactId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uploadTask.repositories.mavenDeployer.pom.artifactId（如果已设置）或archiveTask.archiveBaseName。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">版</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">打包</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">archiveTask.archiveExtension</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这里， <code>uploadTask</code>和<code>archiveTask</code>分别参考用于上传和生成档案的任务（例如<code>uploadArchives</code>和<code>jar</code> ）。
<code>archiveTask.archiveBaseName</code>默认为<code>project.archivesBaseName</code>依次默认为<code>project.name</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>当您设置“ <code>archiveTask.archiveBaseName</code> ”属性设置为默认值以外的其他值，您还必须设置<code>uploadTask.repositories.mavenDeployer.pom.artifactId</code>值相同否则，可能会使用同一构建中其他项目的生成的POM中引用的项目ID错误的工件ID。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在以下位置找到生成的POM <code><buildDir>/poms</code> 。可以通过<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/maven/MavenPom.html">MavenPom</a> API进一步自定义它们。例如，您可能希望部署到Maven存储库的工件具有与Gradle生成的工件不同的版本或名称。要自定义这些，您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例614pom的定制</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">uploadArchives {
    repositories {
        mavenDeployer {
            repository(<span class="key">url</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">file://localhost/tmp/myRepo/</span><span class="delimiter">&quot;</span></span>)
            pom.version = <span class="string"><span class="delimiter">'</span><span class="content">1.0Maven</span><span class="delimiter">'</span></span>
            pom.artifactId = <span class="string"><span class="delimiter">'</span><span class="content">myMavenName</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;Upload&gt;(&quot;uploadArchives&quot;) {
    repositories.withGroovyBuilder {
        &quot;mavenDeployer&quot; {
            &quot;repository&quot;(&quot;url&quot; to &quot;file://localhost/tmp/myRepo/&quot;)
            &quot;pom&quot; {
                setProperty(&quot;version&quot;, &quot;1.0Maven&quot;)
                setProperty(&quot;artifactId&quot;, &quot;myMavenName&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要将其他内容添加到POM， <code>pom.project</code>可以使用生成器。使用此构建器，可以添加<a href="http://maven.apache.org/pom.html">Maven POM参考中</a>列出的任何元素。</p>
</div>
<div class="exampleblock">
<div class="title">示例615。pom的生成器样式定制</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">uploadArchives {
    repositories {
        mavenDeployer {
            repository(<span class="key">url</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">file://localhost/tmp/myRepo/</span><span class="delimiter">&quot;</span></span>)
            pom.project {
                licenses {
                    license {
                        name <span class="string"><span class="delimiter">'</span><span class="content">The Apache Software License, Version 2.0</span><span class="delimiter">'</span></span>
                        url <span class="string"><span class="delimiter">'</span><span class="content">http://www.apache.org/licenses/LICENSE-2.0.txt</span><span class="delimiter">'</span></span>
                        distribution <span class="string"><span class="delimiter">'</span><span class="content">repo</span><span class="delimiter">'</span></span>
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;Upload&gt;(&quot;uploadArchives&quot;) {
    repositories.withGroovyBuilder {
        &quot;mavenDeployer&quot; {
            &quot;repository&quot;(&quot;url&quot; to &quot;file://localhost/tmp/myRepo/&quot;)
            &quot;pom&quot; {
                &quot;project&quot; {
                    &quot;licenses&quot; {
                        &quot;license&quot; {
                            setProperty(&quot;name&quot;, &quot;The Apache Software License, Version 2.0&quot;)
                            setProperty(&quot;url&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)
                            setProperty(&quot;distribution&quot;, &quot;repo&quot;)
                        }
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意： <code>groupId</code> ， <code>artifactId</code> ， <code>version</code>和<code>packaging</code>应该始终直接设置在<code>pom</code>宾语。</p>
</div>
<div class="exampleblock">
<div class="title">示例616修改自动生成的内容</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> installer = install.repositories.mavenInstaller
<span class="keyword">def</span> deployer = uploadArchives.repositories.mavenDeployer

[installer, deployer]*.pom*.whenConfigured {pom -&gt;
    pom.dependencies.find {dep -&gt; dep.groupId == <span class="string"><span class="delimiter">'</span><span class="content">group3</span><span class="delimiter">'</span></span> &amp;&amp; dep.artifactId == <span class="string"><span class="delimiter">'</span><span class="content">runtime</span><span class="delimiter">'</span></span> }.optional = <span class="predefined-constant">true</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val uploadArchives by tasks.getting(Upload::class)
val installer = tasks.install.get().repositories.withGroovyBuilder { getProperty(&quot;mavenInstaller&quot;) as MavenResolver }
val deployer = uploadArchives.repositories.withGroovyBuilder { getProperty(&quot;mavenDeployer&quot;) as MavenResolver }

listOf(installer, deployer).forEach {
    it.pom.whenConfigured {
        dependencies.firstOrNull { dep -&gt;
            dep!!.withGroovyBuilder {
                getProperty(&quot;groupId&quot;) == &quot;group3&quot; &amp;&amp; getProperty(&quot;artifactId&quot;) == &quot;runtime&quot;
            }
        }?.withGroovyBuilder {
            setProperty(&quot;optional&quot;, true)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您要发布多个工件，则工作原理会有所不同。请参见<a href="#sub:multiple_artifacts_per_project">每个项目中的多个工件</a> 。</p>
</div>
<div class="paragraph">
<p>要自定义Maven安装程序的设置（请参阅<a href="#sub:installing_to_the_local_repository">安装到本地存储库</a> ），您可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="title">示例617自定义Maven安装程序</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">install {
    repositories.mavenInstaller {
        pom.version = <span class="string"><span class="delimiter">'</span><span class="content">1.0Maven</span><span class="delimiter">'</span></span>
        pom.artifactId = <span class="string"><span class="delimiter">'</span><span class="content">myName</span><span class="delimiter">'</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.install {
    repositories.withGroovyBuilder {
        &quot;mavenInstaller&quot; {
            &quot;pom&quot; {
                setProperty(&quot;version&quot;, &quot;1.0Maven&quot;)
                setProperty(&quot;artifactId&quot;, &quot;myName&quot;)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="sub:multiple_artifacts_per_project"><a class="anchor" href="#sub:multiple_artifacts_per_project"></a> <a class="link" href="#sub:multiple_artifacts_per_project">每个项目有多个工件</a></h6>
<div class="paragraph">
<p>Maven每个项目只能处理一个工件。这反映在Maven POM的结构中。我们认为在许多情况下，每个项目具有多个工件是有意义的。在这种情况下，您需要生成多个POM。在这种情况下，您必须明确声明要发布到Maven存储库的每个工件。<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html">MavenDeployer</a>和MavenInstaller都为此提供了一个API：</p>
</div>
<div class="exampleblock">
<div class="title">示例618生成多种绒球</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">uploadArchives {
    repositories {
        mavenDeployer {
            repository(<span class="key">url</span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">file://localhost/tmp/myRepo/</span><span class="delimiter">&quot;</span></span>)
            addFilter(<span class="string"><span class="delimiter">'</span><span class="content">api</span><span class="delimiter">'</span></span>) {artifact, file -&gt;
                artifact.name == <span class="string"><span class="delimiter">'</span><span class="content">api</span><span class="delimiter">'</span></span>
            }
            addFilter(<span class="string"><span class="delimiter">'</span><span class="content">service</span><span class="delimiter">'</span></span>) {artifact, file -&gt;
                artifact.name == <span class="string"><span class="delimiter">'</span><span class="content">service</span><span class="delimiter">'</span></span>
            }
            pom(<span class="string"><span class="delimiter">'</span><span class="content">api</span><span class="delimiter">'</span></span>).version = <span class="string"><span class="delimiter">'</span><span class="content">mySpecialMavenVersion</span><span class="delimiter">'</span></span>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;Upload&gt;(&quot;uploadArchives&quot;) {
    repositories.withGroovyBuilder {
        &quot;mavenDeployer&quot; {
            &quot;repository&quot;(&quot;url&quot; to &quot;file://localhost/tmp/myRepo/&quot;)
            &quot;addFilter&quot;(&quot;api&quot;) {
                getProperty(&quot;artifact&quot;).withGroovyBuilder { setProperty(&quot;name&quot;, &quot;api&quot;) }
            }
            &quot;addFilter&quot;(&quot;service&quot;) {
                getProperty(&quot;artifact&quot;).withGroovyBuilder { setProperty(&quot;name&quot;, &quot;service&quot;) }
            }
            &quot;pom&quot;(&quot;api&quot;)?.withGroovyBuilder { setProperty(&quot;version&quot;, &quot;mySpecialMavenVersion&quot;) }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您需要为每个要发布的工件声明一个过滤器。这个过滤器定义了一个布尔表达式，它接受Gradle工件。每个过滤器都有一个与之关联的POM，您可以对其进行配置。要了解更多信息，请查看<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/maven/PomFilterContainer.html">PomFilterContainer</a>及其关联的类。</p>
</div>
</div>
<div class="sect5">
<h6 id="sub:dependency_mapping"><a class="anchor" href="#sub:dependency_mapping"></a> <a class="link" href="#sub:dependency_mapping">依赖关系映射</a></h6>
<div class="paragraph">
<p>Maven插件配置Java和War插件添加的Gradle配置与Maven范围之间的默认映射。在大多数情况下，您无需触摸此部分，就可以安全地跳过此部分。映射如下所示。您可以将配置映射到一个且只有一个作用域。可以将不同的配置映射到一个或不同的范围。您还可以为特定的配置到范围的映射分配优先级。看看<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/artifacts/maven/Conf2ScopeMappingContainer.html">Conf2ScopeMappingContainer</a>可以了解更多信息。要访问映射配置，您可以说：</p>
</div>
<div class="exampleblock">
<div class="title">示例619访问映射配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task mappings {
    doLast {
        println conf2ScopeMappings.mappings
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register(&quot;mappings&quot;) {
    doLast {
        println(maven.conf2ScopeMappings.mappings)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果可能，将Gradle排除规则转换为Maven排除。如果在Gradle排除规则中指定了组和模块名称，则这种转换是可能的（因为Maven与Ivy都需要）。如果每个配置的排除项都是可转换的，则它们也包含在Maven POM中。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pmd_plugin"><a class="anchor" href="#pmd_plugin"></a> <a class="link" href="#pmd_plugin">PMD插件</a></h3>
<div class="paragraph">
<p>PMD插件使用<a href="http://pmd.sourceforge.net">PMD</a>对项目的Java源文件执行质量检查，并从这些检查生成报告。</p>
</div>
<div class="sect3">
<h4 id="sec:pmd_usage"><a class="anchor" href="#sec:pmd_usage"></a> <a class="link" href="#sec:pmd_usage">用法</a></h4>
<div class="paragraph">
<p>要使用PMD插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">范例620。使用PMD插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">pmd</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    pmd
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该插件向项目添加了许多执行质量检查的任务。您可以通过运行来执行检查<code>gradle check</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，PMD将与用于运行Gradle的Java版本一起运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:pmd_tasks"><a class="anchor" href="#sec:pmd_tasks"></a> <a class="link" href="#sec:pmd_tasks">任务</a></h4>
<div class="paragraph">
<p>PMD插件将以下任务添加到项目中：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pmdMain</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Pmd.html">Pmd</a></dt>
<dd>
<div class="paragraph">
<p>针对生产Java源文件运行PMD。</p>
</div>
</dd>
<dt class="hdlist1"><code>pmdTest</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Pmd.html">Pmd</a></dt>
<dd>
<div class="paragraph">
<p>针对测试Java源文件运行PMD。</p>
</div>
</dd>
<dt class="hdlist1"><code>pmd<em>SourceSet</em></code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.Pmd.html">Pmd</a></dt>
<dd>
<div class="paragraph">
<p>针对给定源集的Java源文件运行PMD。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>PMD插件将以下依赖项添加到Java插件定义的任务中。</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表37。PMD插件-其他任务依赖项</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">任务名称</th>
<th class="tableblock halign-left valign-top">依赖于取决于</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>check</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有PMD任务，包括<code>pmdMain</code>和<code>pmdTest</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:pmd_dependency_management"><a class="anchor" href="#sec:pmd_dependency_management"></a> <a class="link" href="#sec:pmd_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>PMD插件添加了以下依赖项配置：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表38。PMD插件-依赖项配置</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pmd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的PMD库</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:pmd_configuration"><a class="anchor" href="#sec:pmd_configuration"></a> <a class="link" href="#sec:pmd_configuration">组态</a></h4>
<div class="paragraph">
<p>请参阅API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.quality.PmdExtension.html">PmdExtension</a>类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scala_plugin"><a class="anchor" href="#scala_plugin"></a> <a class="link" href="#scala_plugin">Scala插件</a></h3>
<div class="paragraph">
<p>Scala插件扩展了<a href="#">Java插件，</a>以添加对<a href="https://www.scala-lang.org/">Scala</a>项目的支持。它可以处理Scala代码，Scala和Java混合代码，甚至是纯Java代码（尽管我们不一定建议将其用于后者）。该插件支持<em>联合编译</em> ，可让您自由混合和匹配Scala和Java代码，并在两个方向上都具有依赖性。例如，Scala类可以扩展Java类，而Java类又可以扩展Scala类。这样就可以为作业使用最佳语言，并在需要时用其他语言重写任何类。</p>
</div>
<div class="paragraph">
<p>请注意，如果您想从<a href="#sec:java_library_separation">API /实现分离中</a>受益，还可以应用<code>java-library</code> Scala项目的插件。</p>
</div>
<div class="sect3">
<h4 id="sec:scala_usage"><a class="anchor" href="#sec:scala_usage"></a> <a class="link" href="#sec:scala_usage">用法</a></h4>
<div class="paragraph">
<p>要使用Scala插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例621使用Scala插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">scala</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    scala
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:scala_tasks"><a class="anchor" href="#sec:scala_tasks"></a> <a class="link" href="#sec:scala_tasks">任务</a></h4>
<div class="paragraph">
<p>Scala插件将以下任务添加到项目中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>compileScala</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.scala.ScalaCompile.html">ScalaCompile</a></dt>
<dd>
<p><em>取决于</em> ：<code>compileJava</code></p>
<div class="paragraph">
<p>编译生产Scala源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>compileTestScala</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.scala.ScalaCompile.html">ScalaCompile</a></dt>
<dd>
<p><em>取决于</em> ：<code>compileTestJava</code></p>
<div class="paragraph">
<p>编译测试Scala源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>compile<em>SourceSet</em>Scala</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.scala.ScalaCompile.html">ScalaCompile</a></dt>
<dd>
<p><em>取决于</em> ：<code>compile<em>SourceSet</em>Java</code></p>
<div class="paragraph">
<p>编译给定源集的Scala源文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>scaladoc</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.scala.ScalaDoc.html">ScalaDoc</a></dt>
<dd>
<div class="paragraph">
<p>为生产Scala源文件生成API文档。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Scala插件向Java插件添加的任务添加以下依赖项。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表39。Scala插件-其他任务依赖项</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">任务名称</th>
<th class="tableblock halign-left valign-top">依赖于取决于</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>classes</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>compileScala</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>testClasses</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>compileTestScala</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code><em>sourceSet</em>Classes</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>compile<em>SourceSet</em>Scala</code></p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="imageblock">
<div class="content">
<img src="img/scalaPluginTasks.png" alt="scalaPluginTasks">
</div>
<div class="title">图37。Scala插件-任务</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:scala_project_layout"><a class="anchor" href="#sec:scala_project_layout"></a> <a class="link" href="#sec:scala_project_layout">项目布局</a></h4>
<div class="paragraph">
<p>Scala插件采用如下所示的项目布局。所有的Scala源目录都可以包含Scala <em>和</em> Java代码。Java源目录只能包含Java源代码。这些目录都不需要存在或包含任何内容。 Scala插件将简单地编译找到的任何内容。</p>
</div>
<div id="scalalayout" class="dlist">
<dl>
<dt class="hdlist1"><code>src/main/java</code></dt>
<dd>
<p>生产Java源代码。</p>
</dd>
<dt class="hdlist1"><code>src/main/resources</code></dt>
<dd>
<p>生产资源，例如XML和属性文件。</p>
</dd>
<dt class="hdlist1"><code>src/main/scala</code></dt>
<dd>
<p>生产Scala源。也可能包含Java源文件以进行联合编译。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/test/java</code></dt>
<dd>
<p>测试Java源代码。</p>
</dd>
<dt class="hdlist1"><code>src/test/resources</code></dt>
<dd>
<p>测试资源。</p>
</dd>
<dt class="hdlist1"><code>src/test/scala</code></dt>
<dd>
<p>测试Scala源。也可能包含Java源文件以进行联合编译。</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/java</code></dt>
<dd>
<p>名为<em>sourceSet</em>的源集的Java源。</p>
</dd>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/resources</code></dt>
<dd>
<p>名为<em>sourceSet</em>的源集的资源。</p>
</dd>
<dt class="hdlist1"><code>src/<em>sourceSet</em>/scala</code></dt>
<dd>
<p>给定源集的Scala源文件。也可能包含Java源文件以进行联合编译。</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="sec:changing_scala_project_layout"><a class="anchor" href="#sec:changing_scala_project_layout"></a> <a class="link" href="#sec:changing_scala_project_layout">更改项目布局</a></h5>
<div class="paragraph">
<p>就像Java插件一样，Scala插件允许您配置Scala生产和测试源文件的自定义位置。</p>
</div>
<div class="exampleblock">
<div class="title">示例622。自定义Scala源布局</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">sourceSets {
    main {
        scala {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">src/scala</span><span class="delimiter">'</span></span>]
        }
    }
    test {
        scala {
            srcDirs = [<span class="string"><span class="delimiter">'</span><span class="content">test/scala</span><span class="delimiter">'</span></span>]
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">sourceSets {
    main {
        withConvention(ScalaSourceSet::class) {
            scala {
                setSrcDirs(listOf(&quot;src/scala&quot;))
            }
        }
    }
    test {
        withConvention(ScalaSourceSet::class) {
            scala {
                setSrcDirs(listOf(&quot;test/scala&quot;))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:scala_dependency_management"><a class="anchor" href="#sec:scala_dependency_management"></a> <a class="link" href="#sec:scala_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>Scala项目需要声明一个<code>scala-library</code>依赖性。然后，将在编译和运行时类路径上使用此依赖项。它还将分别用于获取Scala编译器和Scaladoc工具。 <sup class="footnote">[ <a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="查看脚注。">22</a> ]</sup></p>
</div>
<div class="paragraph">
<p>如果将Scala用于生产代码，则<code>scala-library</code>依赖项应添加到<code>compile</code>组态：</p>
</div>
<div class="exampleblock">
<div class="title">示例623。声明生产代码的Scala依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="string"><span class="delimiter">'</span><span class="content">org.scala-lang:scala-library:2.11.12</span><span class="delimiter">'</span></span>
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.scalatest:scalatest_2.11:3.0.0</span><span class="delimiter">'</span></span>
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">junit:junit:4.12</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">repositories {
    mavenCentral()
}

dependencies {
    implementation(&quot;org.scala-lang:scala-library:2.11.12&quot;)
    testImplementation(&quot;org.scalatest:scalatest_2.11:3.0.0&quot;)
    testImplementation(&quot;junit:junit:4.12&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果Scala仅用于测试代码，则<code>scala-library</code>依赖项应添加到<code>testCompile</code>组态：</p>
</div>
<div class="exampleblock">
<div class="title">示例624声明测试代码的Scala依赖关系</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
    testImplementation <span class="string"><span class="delimiter">'</span><span class="content">org.scala-lang:scala-library:2.11.1</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">dependencies {
    testImplementation(&quot;org.scala-lang:scala-library:2.11.1&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:configure_scala_classpath"><a class="anchor" href="#sec:configure_scala_classpath"></a> <a class="link" href="#sec:configure_scala_classpath">自动配置scalaClasspath</a></h4>
<div class="paragraph">
<p>的<code>ScalaCompile</code>和<code>ScalaDoc</code>任务以两种方式使用Scala代码： <code>classpath</code> ，并在他们的<code>scalaClasspath</code> 。前者用于查找源代码引用的类，通常包含<code>scala-library</code>以及其他库。后者用于分别加载和执行Scala编译器和Scaladoc工具，并且应仅包含<code>scala-compiler</code>库及其依赖项。</p>
</div>
<div class="paragraph">
<p>除非有任务<code>scalaClasspath</code>是经过明确配置的，Scala（基本）插件将尝试从任务的<code>classpath</code> 。这样做如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果一个<code>scala-library</code>找到罐子<code>classpath</code> ，并且该项目至少声明了一个存储库，相应的<code>scala-compiler</code>存储库依赖项将添加到<code>scalaClasspath</code> 。</p>
</li>
<li>
<p>否则，任务执行将失败，并显示一条消息，指出<code>scalaClasspath</code>无法推断。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sec:configure_zinc_compiler"><a class="anchor" href="#sec:configure_zinc_compiler"></a> <a class="link" href="#sec:configure_zinc_compiler">配置Zinc编译器</a></h4>
<div class="paragraph">
<p>Scala插件使用名为<code>zinc</code>解决<a href="https://github.com/typesafehub/zinc">Zinc编译器</a>及其依赖项。Gradle将提供Zinc的默认版本，但是如果您需要使用特定的Zinc版本，则可以对其进行更改。Gradle支持Zinc及更高版本的1.2.0。</p>
</div>
<div class="exampleblock">
<div class="title">示例625声明要使用的Zinc编译器版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">scala {
    zincVersion = <span class="string"><span class="delimiter">&quot;</span><span class="content">1.2.1</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">scala {
    zincVersion.set(&quot;1.2.1&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Zinc编译器本身需要兼容版本的<code>scala-library</code>可能与您的应用程序所需的版本不同。Gradle负责指定兼容版本<code>scala-library</code>为了你。
<sup class="footnote">[ <a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="查看脚注。">23</a> ]</sup></p>
</div>
<div class="paragraph">
<p>您可以通过运行<a href="#">dependencyInsight</a>来诊断所选的Zinc编译器版本的问题。 <code>zinc</code>组态。</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表40。锌兼容性表</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">摇篮版本</th>
<th class="tableblock halign-left valign-top">支持的锌版本</th>
<th class="tableblock halign-left valign-top">锌坐标</th>
<th class="tableblock halign-left valign-top">所需的Scala版本</th>
<th class="tableblock halign-left valign-top">支持的Scala编译版本</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6.0及更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sbt/zinc">SBT锌</a> 。1.2.0及更高版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.scala-sbt:zinc_2.12</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">斯卡拉<code>2.12.x</code> <em>运行</em> Zinc是必需的。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">斯卡拉<code>2.10.x</code>通过<code>2.13.x</code>可以编译。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.x槽5.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/typesafehub/zinc"><strong>不推荐使用的</strong> Typesafe Zinc编译器。</a> 版本0.3.0及更高版本，但0.3.2至0.3.5.2除外。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.typesafe.zinc:zinc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">斯卡拉<code>2.10.x</code> <em>运行</em> Zinc是必需的。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">斯卡拉<code>2.9.x</code>通过<code>2.12.x</code>可以编译。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:scala_convention_properties"><a class="anchor" href="#sec:scala_convention_properties"></a> <a class="link" href="#sec:scala_convention_properties">公约属性</a></h4>
<div class="paragraph">
<p>Scala插件不会向项目添加任何约定属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:scala_source_set_properties"><a class="anchor" href="#sec:scala_source_set_properties"></a> <a class="link" href="#sec:scala_source_set_properties">源集属性</a></h4>
<div class="paragraph">
<p>Scala插件将以下约定属性添加到项目中的每个源集。您可以在构建脚本中使用这些属性，就像它们是源集对象的属性一样。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>scala</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.file.SourceDirectorySet.html">SourceDirectorySet</a> （只读）</dt>
<dd>
<p>此源集的Scala源文件。包含所有<code>.scala</code>和<code>.java</code>在Scala源目录中找到的文件，不包括所有其他类型的文件。<em>默认值：</em>非空。</p>
</dd>
<dt class="hdlist1"><code>scala.srcDirs</code> -<code>Set<File></code></dt>
<dd>
<p>包含此源集的Scala源文件的源目录。也可能包含Java源文件以进行联合编译。可以使用“ <a href="#sec:specifying_multiple_files">了解对文件集合的隐式转换”中</a>所述的任何内容进行设置。
<em>默认值：</em> <code>[<em>projectDir</em>/src/<em>name</em>/scala]</code> 。</p>
</dd>
<dt class="hdlist1"><code>allScala</code> — <a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/file/FileTree.html">FileTree</a> （只读）</dt>
<dd>
<p>此源集的所有Scala源文件。仅包含<code>.scala</code>在Scala源目录中找到的文件。<em>默认值：</em>非空。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这些约定属性由类型为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.ScalaSourceSet.html">ScalaSourceSet</a>的约定对象提供。</p>
</div>
<div class="paragraph">
<p>Scala插件还修改了一些源集属性：</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">表41。Scala插件-源集属性</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">物业名称</th>
<th class="tableblock halign-left valign-top">更改</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>allJava</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全部添加<code>.java</code>在Scala源目录中找到的文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>allSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加在Scala源目录中找到的所有源文件。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sec:scala_compiling_in_external_process"><a class="anchor" href="#sec:scala_compiling_in_external_process"></a> <a class="link" href="#sec:scala_compiling_in_external_process">在外部过程中进行编译</a></h4>
<div class="paragraph">
<p>Scala编译在外部过程中进行。</p>
</div>
<div class="paragraph">
<p>外部进程的内存设置默认为JVM的默认值。要调整内存设置，请配置<code>scalaCompileOptions.forkOptions</code>需要的属性：</p>
</div>
<div class="exampleblock">
<div class="title">示例626。调整内存设定</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(ScalaCompile) {
    scalaCompileOptions.forkOptions.with {
        memoryMaximumSize = <span class="string"><span class="delimiter">'</span><span class="content">1g</span><span class="delimiter">'</span></span>
        jvmArgs = [<span class="string"><span class="delimiter">'</span><span class="content">-XX:MaxPermSize=512m</span><span class="delimiter">'</span></span>]
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType&lt;ScalaCompile&gt;().configureEach {
    scalaCompileOptions.forkOptions.apply {
        memoryMaximumSize = &quot;1g&quot;
        jvmArgs = listOf(&quot;-XX:MaxPermSize=512m&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:scala_incremental_compilation"><a class="anchor" href="#sec:scala_incremental_compilation"></a> <a class="link" href="#sec:scala_incremental_compilation">增量编译</a></h4>
<div class="paragraph">
<p>通过仅编译自上次编译以来其源代码已更改的类以及受这些更改影响的类，增量编译可以显着减少Scala编译时间。当频繁地编译较小的代码增量时（如在开发时经常这样做），它特别有效。</p>
</div>
<div class="paragraph">
<p>Scala插件默认通过与<a href="https://github.com/typesafehub/zinc">Zinc</a>集成进行增量编译，而<a href="https://github.com/typesafehub/zinc">Zinc</a>是<a href="https://github.com/harrah/xsbt">sbt</a>增量Scala编译器的独立版本。如果要禁用增量编译，请设置<code>force = true</code>在您的构建文件中：</p>
</div>
<div class="exampleblock">
<div class="title">示例627。强制所有代码进行编译</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(ScalaCompile) {
    scalaCompileOptions.with {
        force = <span class="predefined-constant">true</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType&lt;ScalaCompile&gt;().configureEach {
    scalaCompileOptions.apply {
        isForce = true
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><em>注意：</em>仅当至少一个输入源文件已更改时，这才会导致重新编译所有类。如果源文件没有更改，则<code>compileScala</code>任务仍将被考虑<code>UP-TO-DATE</code>照常。</p>
</div>
<div class="paragraph">
<p>基于Zinc的Scala编译器支持Java和Scala代码的联合编译。默认情况下，所有Java和Scala代码<code>src/main/scala</code>将参加联合编译。甚至Java代码也将以增量方式编译。</p>
</div>
<div class="paragraph">
<p>增量编译需要对源代码进行依赖性分析。分析的结果存储在由指定的文件中<code>scalaCompileOptions.incrementalOptions.analysisFile</code> （具有明智的默认设置）。在多项目构建中，分析文件将传递到下游<code>ScalaCompile</code>跨项目边界进行增量编译的任务。对于<code>ScalaCompile</code>由Scala插件添加的任务，无需进行配置即可完成此工作。对于他人<code>ScalaCompile</code>您可能添加的任务，属性<code>scalaCompileOptions.incrementalOptions.publishedCode</code>需要配置为指向class文件夹或Jar存档，通过该文件夹传递代码以编译下游的类路径<code>ScalaCompile</code>任务。请注意，如果<code>publishedCode</code>如果设置不正确，下游任务可能无法重新编译受上游更改影响的代码，从而导致错误的编译结果。</p>
</div>
<div class="paragraph">
<p>请注意，不支持Zinc基于Nailgun的守护程序模式。取而代之的是，我们计划增强Gradle自己的编译器守护进程，以在Gradle调用中保持活动状态，并重用相同的Scala编译器。预计这将为Scala编译带来另一个显着的加速。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:scala_cross_compilation"><a class="anchor" href="#sec:scala_cross_compilation"></a> <a class="link" href="#sec:scala_cross_compilation">针对Java 6或Java 7进行编译和测试</a></h4>
<div class="paragraph">
<p>Scala编译器忽略Gradle的<code>targetCompatibility</code>和<code>sourceCompatibility</code>设置。在Scala 2.11中，Scala编译器始终将其编译为与Java 6兼容的字节码。在Scala 2.12中，Scala编译器始终将其编译为Java 8兼容的字节码。如果您也有Java源代码，则可以按照与<a href="#sec:java_cross_compilation">Java插件</a>相同的步骤操作，以确保使用正确的Java编译器。</p>
</div>
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties"># in $HOME/.gradle/gradle.properties
java6Home=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">java {
    sourceCompatibility = JavaVersion.VERSION_1_6
}

<span class="keyword">assert</span> hasProperty(<span class="string"><span class="delimiter">'</span><span class="content">java6Home</span><span class="delimiter">'</span></span>) : <span class="string"><span class="delimiter">&quot;</span><span class="content">Set the property 'java6Home' in your your gradle.properties pointing to a Java 6 installation</span><span class="delimiter">&quot;</span></span>
<span class="keyword">def</span> javaExecutablesPath = <span class="keyword">new</span> <span class="predefined-type">File</span>(java6Home, <span class="string"><span class="delimiter">'</span><span class="content">bin</span><span class="delimiter">'</span></span>)
<span class="keyword">def</span> javaExecutables = [:].withDefault { execName -&gt;
    <span class="keyword">def</span> executable = <span class="keyword">new</span> <span class="predefined-type">File</span>(javaExecutablesPath, execName)
    <span class="keyword">assert</span> executable.exists() : <span class="string"><span class="delimiter">&quot;</span><span class="content">There is no </span><span class="inline"><span class="inline-delimiter">${</span>execName<span class="inline-delimiter">}</span></span><span class="content"> executable in </span><span class="inline"><span class="inline-delimiter">${</span>javaExecutablesPath<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    executable
}

tasks.withType(AbstractCompile) {
    options.with {
        fork = <span class="predefined-constant">true</span>
        forkOptions.javaHome = file(java6Home)
    }
}
tasks.withType(Test) {
    executable = javaExecutables.java
}
tasks.withType(JavaExec) {
    executable = javaExecutables.java
}
tasks.withType(Javadoc) {
    executable = javaExecutables.javadoc
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">java {
    sourceCompatibility = JavaVersion.VERSION_1_6
}

require(hasProperty(&quot;java6Home&quot;)) { &quot;Set the property 'java6Home' in your your gradle.properties pointing to a Java 6 installation&quot; }
val java6Home: String by project
val javaExecutablesPath = File(java6Home, &quot;bin&quot;)
fun javaExecutable(execName: String): String {
    val executable = File(javaExecutablesPath, execName)
    require(executable.exists()) { &quot;There is no ${execName} executable in ${javaExecutablesPath}&quot; }
    return executable.toString()
}

tasks.withType&lt;ScalaCompile&gt;().configureEach {
    options.apply {
        isFork = true
        forkOptions.javaHome = file(java6Home)
    }
}
tasks.withType&lt;Test&gt;().configureEach {
    executable = javaExecutable(&quot;java&quot;)
}
tasks.withType&lt;JavaExec&gt;().configureEach {
    executable = javaExecutable(&quot;java&quot;)
}
tasks.withType&lt;Javadoc&gt;().configureEach {
    executable = javaExecutable(&quot;javadoc&quot;)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:eclipse_integration"><a class="anchor" href="#sec:eclipse_integration"></a> <a class="link" href="#sec:eclipse_integration">Eclipse整合</a></h4>
<div class="paragraph">
<p>当Eclipse插件遇到Scala项目时，它会添加其他配置，以使该项目可以立即使用Scala IDE。具体来说，该插件添加了Scala性质和依赖项容器。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:intellij_idea_integration"><a class="anchor" href="#sec:intellij_idea_integration"></a> <a class="link" href="#sec:intellij_idea_integration">IntelliJ IDEA集成</a></h4>
<div class="paragraph">
<p>当IDEA插件遇到Scala项目时，它会添加其他配置，以使该项目可以立即使用IDEA。具体来说，该插件添加了一个Scala SDK（IntelliJ IDEA 14+）和一个Scala编译器库，该库与项目的类路径上的Scala版本相匹配。Scala插件与IntelliJ IDEA的早期版本向后兼容，并且可以通过配置来添加Scala构面而不是默认的Scala SDK。 <code>targetVersion</code>在<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ide.idea.model.IdeaModel.html">IdeaModel上</a> 。</p>
</div>
<div class="exampleblock">
<div class="title">示例628。明确指定目标IntelliJ IDEA版本</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">idea {
    targetVersion = <span class="string"><span class="delimiter">'</span><span class="content">13</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">idea {
    targetVersion = &quot;13&quot;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="signing_plugin"><a class="anchor" href="#signing_plugin"></a> <a class="link" href="#signing_plugin">签名插件</a></h3>
<div class="paragraph">
<p>签名插件增加了对构建文件和工件进行数字签名的功能。然后可以使用这些数字签名来证明签名所附加的工件是谁构建的，以及诸如签名何时生成的其他信息。</p>
</div>
<div class="paragraph">
<p>签名插件当前仅支持生成<a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP">OpenPGP签名</a> （这是<a href="http://central.sonatype.org/pages/requirements.html#sign-files-with-gpgpgp">发布到Maven Central Repository所需</a>的签名格式）。</p>
</div>
<div class="sect3">
<h4 id="sec:signing_usage"><a class="anchor" href="#sec:signing_usage"></a> <a class="link" href="#sec:signing_usage">用法</a></h4>
<div class="paragraph">
<p>要使用签名插件，请在构建脚本中包括以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例629。使用签名插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">signing</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    signing
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:signatory_credentials"><a class="anchor" href="#sec:signatory_credentials"></a> <a class="link" href="#sec:signatory_credentials">签名凭证</a></h4>
<div class="paragraph">
<p>为了创建OpenPGP签名，您将需要一个密钥对（有关使用<a href="https://www.gnupg.org/">GnuPG工具</a>创建密钥对的说明，请参见<a href="https://www.gnupg.org/documentation/howtos.html">GnuPG HOWTOs</a> ）。您需要向签名插件提供密钥信息，这意味着三件事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>公钥ID（keyId的后8个符号。您可以使用<code>gpg -K</code>为拿到它，为实现它）。</p>
</li>
<li>
<p>包含您的私钥的密钥环文件的绝对路径。（从gpg 2.1开始，您需要使用以下命令导出密钥<code>gpg --keyring secring.gpg --export-secret-keys > ~/.gnupg/secring.gpg</code> ）。</p>
</li>
<li>
<p>用于保护您的私钥的密码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些项目必须作为<code>signing.keyId</code> ， <code>signing.secretKeyRingFile</code>和<code>signing.password</code>属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">鉴于这些价值的个人和私人性质，一种好的做法是将它们存储在<code>gradle.properties</code>文件位于用户的Gradle主目录中（在<a href="#sec:gradle_system_properties">系统属性</a>中进行了描述），而不是项目目录本身中的文件。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">signing.keyId=24875D73
signing.password=secret
signing.secretKeyRingFile=/Users/me/.gnupg/secring.gpg</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果指定此信息（尤其是<code>signing.password</code> ）在用户中<code>gradle.properties</code>文件对于您的环境不可行，您可以根据需要提供信息并手动设置项目属性。</p>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gradle.taskGraph.whenReady { taskGraph -&gt;
    <span class="keyword">if</span> (taskGraph.allTasks.any { <span class="local-variable">it</span> <span class="keyword">instanceof</span> Sign }) {
        <span class="comment">// Use Java's console to read from the console (no good for</span>
        <span class="comment">// a CI environment)</span>
        <span class="keyword">def</span> console = <span class="predefined-type">System</span>.console()
        console.printf <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="char">\n</span><span class="content">We have to sign some things in this build.</span><span class="delimiter">&quot;</span></span> +
                       <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="char">\n</span><span class="content">Please enter your signing details.</span><span class="char">\n</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>

        <span class="keyword">def</span> id = console.readLine(<span class="string"><span class="delimiter">&quot;</span><span class="content">PGP Key Id: </span><span class="delimiter">&quot;</span></span>)
        <span class="keyword">def</span> file = console.readLine(<span class="string"><span class="delimiter">&quot;</span><span class="content">PGP Secret Key Ring File (absolute path): </span><span class="delimiter">&quot;</span></span>)
        <span class="keyword">def</span> password = console.readPassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">PGP Private Key Password: </span><span class="delimiter">&quot;</span></span>)

        allprojects {
            ext.<span class="string"><span class="delimiter">&quot;</span><span class="content">signing.keyId</span><span class="delimiter">&quot;</span></span> = id
            ext.<span class="string"><span class="delimiter">&quot;</span><span class="content">signing.secretKeyRingFile</span><span class="delimiter">&quot;</span></span> = file
            ext.<span class="string"><span class="delimiter">&quot;</span><span class="content">signing.password</span><span class="delimiter">&quot;</span></span> = password
        }

        console.printf <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="content">Thanks.</span><span class="char">\n</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">gradle.taskGraph.whenReady {
    if (allTasks.any { it is Sign }) {
        // Use Java's console to read from the console (no good for
        // a CI environment)
        val console = System.console()
        console.printf(&quot;\n\nWe have to sign some things in this build.&quot; +
                       &quot;\n\nPlease enter your signing details.\n\n&quot;)

        val id = console.readLine(&quot;PGP Key Id: &quot;)
        val file = console.readLine(&quot;PGP Secret Key Ring File (absolute path): &quot;)
        val password = console.readPassword(&quot;PGP Private Key Password: &quot;)

        allprojects {
            extra[&quot;signing.keyId&quot;] = id
            extra[&quot;signing.secretKeyRingFile&quot;] = file
            extra[&quot;signing.password&quot;] = password
        }

        console.printf(&quot;\nThanks.\n\n&quot;)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，这三个属性中的任何一个都存在null值将导致异常。</p>
</div>
<div class="sect4">
<h5 id="sec:in-memory-keys"><a class="anchor" href="#sec:in-memory-keys"></a> <a class="link" href="#sec:in-memory-keys">使用内存Ascii防盗键</a></h5>
<div class="paragraph">
<p>在某些设置中，使用环境变量来传递用于签名的密钥和密码会更容易。例如，当使用CI服务器对工件进行签名时，安全地提供密钥环文件通常很麻烦。另一方面，大多数CI服务器都提供了安全存储环境变量并将其提供给构建的方法。使用以下设置，您可以使用以下命令传递密钥（ASCII装甲格式）和密码。 <code>ORG_GRADLE_PROJECT_signingKey</code>和<code>ORG_GRADLE_PROJECT_signingPassword</code>环境变量分别为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">signing {
    <span class="keyword">def</span> signingKey = findProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">signingKey</span><span class="delimiter">&quot;</span></span>)
    <span class="keyword">def</span> signingPassword = findProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">signingPassword</span><span class="delimiter">&quot;</span></span>)
    useInMemoryPgpKeys(signingKey, signingPassword)
    sign stuffZip
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">signing {
    val signingKey: String? by project
    val signingPassword: String? by project
    useInMemoryPgpKeys(signingKey, signingPassword)
    sign(tasks[&quot;stuffZip&quot;])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using_in_memory_ascii_armored_openpgp_subkeys"><a class="anchor" href="#using_in_memory_ascii_armored_openpgp_subkeys"></a> <a class="link" href="#using_in_memory_ascii_armored_openpgp_subkeys">使用内存Ascii铠装OpenPGP子项</a></h5>
<div class="paragraph">
<p>为了防止共享主密钥并确保其安全性，还可以使用内存中的ascii-armed子密钥。使用内存ascii铠装密钥和子密钥之间的主要区别在于，还必须指定密钥标识符。使用以下设置，您可以使用以下命令传递密钥标识符，秘密密钥（ASCII装甲格式）和密码<code>ORG_GRADLE_PROJECT_signingKeyId</code> ， <code>ORG_GRADLE_PROJECT_signingKey</code>和<code>ORG_GRADLE_PROJECT_signingPassword</code>环境变量分别为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">signing {
    <span class="keyword">def</span> signingKeyId = findProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">signingKeyId</span><span class="delimiter">&quot;</span></span>)
    <span class="keyword">def</span> signingKey = findProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">signingKey</span><span class="delimiter">&quot;</span></span>)
    <span class="keyword">def</span> signingPassword = findProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">signingPassword</span><span class="delimiter">&quot;</span></span>)
    useInMemoryPgpKeys(signingKeyId, signingKey, signingPassword)
    sign stuffZip
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">signing {
    val signingKeyId: String? by project
    val signingKey: String? by project
    val signingPassword: String? by project
    useInMemoryPgpKeys(signingKeyId, signingKey, signingPassword)
    sign(tasks[&quot;stuffZip&quot;])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:subkeys"><a class="anchor" href="#sec:subkeys"></a> <a class="link" href="#sec:subkeys">使用OpenPGP子项</a></h5>
<div class="paragraph">
<p>OpenPGP支持子密钥，这些子密钥与普通密钥一样，只不过它们绑定到主密钥对。OpenPGP子密钥的一项功能是可以独立于主密钥撤销它们，这使密钥管理更加容易。关于如何在软件开发中利用子键的实际案例研究可以在<a href="https://wiki.debian.org/Subkeys">Debian Wiki</a>上阅读。</p>
</div>
<div class="paragraph">
<p>开箱即用的签名插件支持OpenPGP子项。只需指定一个子项ID作为<code>signing.keyId</code>属性。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:using_gpg_agent"><a class="anchor" href="#sec:using_gpg_agent"></a> <a class="link" href="#sec:using_gpg_agent">使用gpg-agent</a></h4>
<div class="paragraph">
<p>默认情况下，签名插件使用基于Java的PGP实现进行签名。但是，此实现不能使用gpg-agent程序来管理私钥。如果要使用gpg-agent，则可以更改签名插件使用的签名实现：</p>
</div>
<div class="exampleblock">
<div class="title">示例630用GnuPG签名</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">signing {
    useGpgCmd()
    sign configurations.archives
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">signing {
    useGpgCmd()
    sign(configurations.archives.get())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这告诉签名插件使用<code>GnupgSignatory</code>而不是默认的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/signing/signatory/pgp/PgpSignatory.html">PgpSignatory</a> 。的<code>GnupgSignatory</code>依靠gpg2程序对工件进行签名。当然，这需要安装GnuPG。</p>
</div>
<div class="paragraph">
<p>无需任何进一步配置<code>gpg2</code> （在Windows上： <code>gpg2.exe</code> ）在<code>PATH</code>将会被使用。密码由<code>gpg-agent</code>并且默认密钥用于签名。</p>
</div>
<div class="sect4">
<h5 id="sec:sec:gnupg_signatory_configuration"><a class="anchor" href="#sec:sec:gnupg_signatory_configuration"></a> <a class="link" href="#sec:sec:gnupg_signatory_configuration">Gnupg签名者配置</a></h5>
<div class="paragraph">
<p>的<code>GnupgSignatory</code>支持许多配置选项，用于控制gpg的调用方式。这些通常在gradle.properties中设置：</p>
</div>
</div>
<div class="sect4">
<h5 id="example_configure_the_gnupgsignatory"><a class="anchor" href="#example_configure_the_gnupgsignatory"></a> <a class="link" href="#example_configure_the_gnupgsignatory">示例：配置GnupgSignatory</a></h5>
<div class="listingblock multi-language-sample">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">signing.gnupg.executable=gpg
signing.gnupg.useLegacyGpg=true
signing.gnupg.homeDir=gnupg-home
signing.gnupg.optionsFile=gnupg-home/gpg.conf
signing.gnupg.keyName=24875D73
signing.gnupg.passphrase=gradle</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>signing.gnupg.executable</code></dt>
<dd>
<p>用于签名的gpg可执行文件。此属性的默认值取决于<code>useLegacyGpg</code> 。如果那是<code>true</code>那么可执行文件的默认值为“ gpg”，否则为“ gpg2”。</p>
</dd>
<dt class="hdlist1"><code>signing.gnupg.useLegacyGpg</code></dt>
<dd>
<p>一定是<code>true</code>如果使用了GnuPG版本1，并且<code>false</code>除此以外。该属性的默认值为<code>false</code> 。</p>
</dd>
<dt class="hdlist1"><code>signing.gnupg.homeDir</code></dt>
<dd>
<p>设置GnuPG的主目录。如果未提供，则使用GnuPG的默认主目录。</p>
</dd>
<dt class="hdlist1"><code>signing.gnupg.optionsFile</code></dt>
<dd>
<p>为GnuPG设置自定义选项文件。如果未给出，则使用GnuPG的默认配置文件。</p>
</dd>
<dt class="hdlist1"><code>signing.gnupg.keyName</code></dt>
<dd>
<p>应该用于签名的密钥的ID。如果未给出，则将使用GnuPG中配置的默认密钥。</p>
</dd>
<dt class="hdlist1"><code>signing.gnupg.passphrase</code></dt>
<dd>
<p>用于解锁密钥的密码。如果未给出，则使用gpg-agent程序获取密码。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>所有配置属性都是可选的。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:specifying_what_to_sign"><a class="anchor" href="#sec:specifying_what_to_sign"></a> <a class="link" href="#sec:specifying_what_to_sign">指定要签名的内容</a></h4>
<div class="paragraph">
<p>在配置事物签名方式（即签名者配置）的同时，还必须指定要签名的内容。签名插件提供了一个DSL，可让您指定应签名的任务和/或配置。</p>
</div>
<div class="sect4">
<h5 id="sec:signing_publications"><a class="anchor" href="#sec:signing_publications"></a> <a class="link" href="#sec:signing_publications">签署出版物</a></h5>
<div class="paragraph">
<p>发布工件时，您通常希望对其进行签名，以便工件的使用者可以验证其签名。例如， <a href="#java_plugin">Java插件</a>定义了一个组件，您可以使用该组件使用<a href="#publishing_maven">Maven Publish插件</a> （或分别为<a href="#publishing_ivy">Ivy Publish插件</a> ）来定义向Maven（或Ivy）存储库的<a href="#publishing_maven">发布</a> 。使用“签名DSL”，您可以指定应对该出版物的所有工件进行签名。</p>
</div>
<div class="exampleblock">
<div class="title">示例631签署出版物</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">signing {
    sign publishing.publications.mavenJava
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">signing {
    sign(publishing.publications[&quot;mavenJava&quot;])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将在您的项目中创建一个名为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.signing.Sign.html">Sign</a>的任务。 <code>signMavenJavaPublication</code>它将构建属于出版物一部分的所有工件（如果需要），然后为其生成签名。签名文件将放置在要签名的工件旁边。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_signing_a_publication_output"><a class="anchor" href="#example_signing_a_publication_output"></a> <a class="link" href="#example_signing_a_publication_output">示例：对发布输出进行签名</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle signMavenJavaPublication</code></strong></div>
<div class="content">
<pre>&gt; gradle signMavenJavaPublication
&gt; Task :compileJava
&gt; Task :processResources
&gt; Task :classes
&gt; Task :jar
&gt; Task :javadoc
&gt; Task :javadocJar
&gt; Task :sourcesJar
&gt; Task :generateMetadataFileForMavenJavaPublication
&gt; Task :generatePomFileForMavenJavaPublication
&gt; Task :signMavenJavaPublication

BUILD SUCCESSFUL in 0s
9 actionable tasks: 9 executed</pre>
</div>
</div>
<div class="paragraph">
<p>此外，上述DSL允许<code>sign</code>多个逗号分隔的出版物。或者，您可以指定<code>publishing.publications</code>签署所有出版物或使用<code>publishing.publications.matching { … }</code>对所有与指定谓词匹配的出版物进行签名。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:signing_configurations"><a class="anchor" href="#sec:signing_configurations"></a> <a class="link" href="#sec:signing_configurations">签名配置</a></h5>
<div class="paragraph">
<p>通常要对配置的构件进行签名。例如， <a href="#java_plugin">Java插件</a>配置要构建的jar，并将此jar工件添加到<code>archives</code>组态。使用签名DSL，您可以指定此配置的所有构件都应签名。</p>
</div>
<div class="exampleblock">
<div class="title">示例632签署配置</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">signing {
    sign configurations.archives
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">signing {
    sign(configurations.archives.get())
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将在您的项目中创建一个名为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.signing.Sign.html">Sign</a>的任务。 <code>signArchives</code> ，这将建立任何<code>archives</code>工件（如果需要），然后为其生成签名。签名文件将放置在要签名的工件旁边。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_signing_a_configuration_output"><a class="anchor" href="#example_signing_a_configuration_output"></a> <a class="link" href="#example_signing_a_configuration_output">示例：对配置输出进行签名</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle signArchives</code></strong></div>
<div class="content">
<pre>&gt; gradle signArchives
&gt; Task :compileJava
&gt; Task :processResources
&gt; Task :classes
&gt; Task :jar
&gt; Task :signArchives

BUILD SUCCESSFUL in 0s
4 actionable tasks: 4 executed</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sec:signing_tasks"><a class="anchor" href="#sec:signing_tasks"></a> <a class="link" href="#sec:signing_tasks">签名任务输出</a></h5>
<div class="paragraph">
<p>在某些情况下，您需要签名的工件可能不是配置的一部分。在这种情况下，您可以直接对生成要签名的工件的任务进行签名。</p>
</div>
<div class="exampleblock">
<div class="title">示例633签署任务输出</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task stuffZip(<span class="key">type</span>: Zip) {
    archiveBaseName = <span class="string"><span class="delimiter">'</span><span class="content">stuff</span><span class="delimiter">'</span></span>
    from <span class="string"><span class="delimiter">'</span><span class="content">src/stuff</span><span class="delimiter">'</span></span>
}

signing {
    sign stuffZip
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.register&lt;Zip&gt;(&quot;stuffZip&quot;) {
    archiveBaseName.set(&quot;stuff&quot;)
    from(&quot;src/stuff&quot;)
}

signing {
    sign(tasks[&quot;stuffZip&quot;])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将在您的项目中创建一个名为<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.signing.Sign.html">Sign</a>的任务。 <code>signStuffZip</code> ，它将建立输入任务的档案（如果需要），然后对其进行签名。签名文件将放置在要签名的工件旁边。</p>
</div>
</div>
<div class="sect4">
<h5 id="example_signing_a_task_output"><a class="anchor" href="#example_signing_a_task_output"></a> <a class="link" href="#example_signing_a_task_output">示例：对任务输出进行签名</a></h5>
<div class="listingblock">
<div class="title">输出<strong><code>gradle signStuffZip</code></strong></div>
<div class="content">
<pre>&gt; gradle signStuffZip
&gt; Task :stuffZip
&gt; Task :signStuffZip

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre>
</div>
</div>
<div class="paragraph">
<p>为了使任务可<em>签名</em> ，它必须产生某种类型的存档，即必须扩展<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html">AbstractArchiveTask</a> 。完成此任务的任务是<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Tar.html">Tar</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Zip.html">Zip</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.Jar.html">Jar</a> ， <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.War.html">War</a>和<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.ear.Ear.html">Ear</a>任务。</p>
</div>
</div>
<div class="sect4">
<h5 id="sec:conditional_signing"><a class="anchor" href="#sec:conditional_signing"></a> <a class="link" href="#sec:conditional_signing">有条件的签名</a></h5>
<div class="paragraph">
<p>常见的使用模式是仅在某些条件下才需要对构建工件进行签名。例如，对于非发行版，您可能不需要签名工件。为此，您可以将条件指定为<code>required()</code>方法。</p>
</div>
<div class="exampleblock">
<div class="title">示例634指定何时需要签名</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">version = <span class="string"><span class="delimiter">'</span><span class="content">1.0-SNAPSHOT</span><span class="delimiter">'</span></span>
ext.isReleaseVersion = !version.endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">SNAPSHOT</span><span class="delimiter">&quot;</span></span>)

signing {
    required { isReleaseVersion &amp;&amp; gradle.taskGraph.hasTask(<span class="string"><span class="delimiter">&quot;</span><span class="content">publish</span><span class="delimiter">&quot;</span></span>) }
    sign publishing.publications.main
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">version = &quot;1.0-SNAPSHOT&quot;
extra[&quot;isReleaseVersion&quot;] = !version.toString().endsWith(&quot;SNAPSHOT&quot;)

signing {
    setRequired({
        (project.extra[&quot;isReleaseVersion&quot;] as Boolean) &amp;&amp; gradle.taskGraph.hasTask(&quot;publish&quot;)
    })
    sign(publishing.publications[&quot;main&quot;])
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在此示例中，仅当我们要构建发行版本并打算发布它时才需要签名。由于我们正在检查任务图以确定是否要发布，因此必须设置<code>signing.required</code>属性关闭以延迟评估。请参见<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/plugins/signing/SigningExtension.html#setRequired-java.lang.Object-">SigningExtension.setRequired（java.lang。对象）</a>以获取更多信息。</p>
</div>
<div class="paragraph">
<p>如果<code>required</code>条件不成立，则仅当配置了签名者凭证时，才会对工件进行签名。或者，您可能希望完全跳过签名，无论签名凭据是否可用。如果是这样，您可以将<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.signing.Sign.html">Sign</a>任务配置为跳过，例如，通过使用<code>onlyIf()</code>方法如下例所示：</p>
</div>
<div class="exampleblock">
<div class="title">示例635指定何时跳过签名</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(Sign) {
    onlyIf { isReleaseVersion }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.withType&lt;Sign&gt;().configureEach {
    onlyIf { project.extra[&quot;isReleaseVersion&quot;] as Boolean }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:publishing_the_signatures"><a class="anchor" href="#sec:publishing_the_signatures"></a> <a class="link" href="#sec:publishing_the_signatures">发布签名</a></h4>
<div class="paragraph">
<p>在对<a href="#sec:signing_publications">发布</a>进行签名时，生成的签名工件会自动添加到相应的发布中。因此，当发布到存储库时，例如通过执行<code>publish</code>任务，您的签名将与其他工件一起分发，而无需任何其他配置。</p>
</div>
<div class="paragraph">
<p>对<a href="#sec:signing_configurations">配置</a>和<a href="#sec:signing_tasks">任务</a>进行签名时，生成的签名工件会自动添加到<code>signatures</code>和<code>archives</code>依赖项配置。这意味着，如果您要将签名和工件一起上载到分发存储库，则只需执行<code>uploadArchives</code>任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:signing_pom_files"><a class="anchor" href="#sec:signing_pom_files"></a> <a class="link" href="#sec:signing_pom_files">签名POM文件</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<div class="paragraph">
<p>本节介绍了Gradle 1.0中可用的<em>旧版</em>发布机制的POM文件签名。如果<a href="#sec:signing_publications">指定</a>了相应的发布，则由<a href="#publishing_maven">Maven Publishing插件</a>提供的<em>新</em> Maven发布支持生成的POM文件将自动<a href="#sec:signing_publications">签名</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>将工件的签名部署到Maven存储库时，您还需要对已发布的POM文件进行签名。签名插件添加了一个<code>signing.signPom()</code> （请参阅<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.plugins.signing.SigningExtension.html#org.gradle.plugins.signing.SigningExtension:signPom(org.gradle.api.artifacts.maven.MavenDeployment, groovy.lang.Closure)">SigningExtension.signPom（org.gradle.api.artifacts.maven。MavenDeployment，groovy.lang。闭合）</a> ，可以在使用）方法<code>beforeDeployment()</code>阻止您的上传任务配置。</p>
</div>
<div class="exampleblock">
<div class="title">示例636签署用于部署的POM</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment { MavenDeployment deployment -&gt; signing.signPom(deployment) }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">tasks.named&lt;Upload&gt;(&quot;uploadArchives&quot;) {
    repositories {
        withConvention(MavenRepositoryHandlerConvention::class) {
            mavenDeployer {
                beforeDeployment { signing.signPom(this) }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当不需要签名并且由于配置不足（即没有用于签名的凭据）而无法对POM进行签名时， <code>signPom()</code>方法将无声无息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="war_plugin"><a class="anchor" href="#war_plugin"></a> <a class="link" href="#war_plugin">战争插件</a></h3>
<div class="paragraph">
<p>War插件扩展了<a href="#">Java插件，</a>以添加对组装Web应用程序WAR文件的支持。它禁用Java插件的默认JAR存档生成，并添加默认的WAR存档任务。</p>
</div>
<div class="sect3">
<h4 id="sec:war_usage"><a class="anchor" href="#sec:war_usage"></a> <a class="link" href="#sec:war_usage">用法</a></h4>
<div class="paragraph">
<p>要使用War插件，请在构建脚本中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">示例637使用War插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">plugins {
    id <span class="string"><span class="delimiter">'</span><span class="content">war</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">plugins {
    war
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:war_project_layout"><a class="anchor" href="#sec:war_project_layout"></a> <a class="link" href="#sec:war_project_layout">项目布局</a></h4>
<div class="paragraph">
<p>除了<a href="#sec:java_project_layout">标准的Java项目布局外</a> ，War插件还添加了：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>src/main/webapp</code></dt>
<dd>
<p>Web应用程序源</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:war_tasks"><a class="anchor" href="#sec:war_tasks"></a> <a class="link" href="#sec:war_tasks">任务</a></h4>
<div class="paragraph">
<p>War插件添加并修改了以下任务：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>war</code> — <a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.War.html">战争</a></dt>
<dd>
<p><em>取决于</em> ：<code>compile</code></p>
<div class="paragraph">
<p>组装应用程序WAR文件。</p>
</div>
</dd>
<dt class="hdlist1"><code>assemble</code> - <em>生命周期任务</em></dt>
<dd>
<p><em>取决于</em> ：<code>war</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>War插件向Java插件添加的任务添加了以下依赖关系；</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/warPluginTasks.png" alt="warPluginTasks">
</div>
<div class="title">图38。战争插件-任务</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:war_dependency_management"><a class="anchor" href="#sec:war_dependency_management"></a> <a class="link" href="#sec:war_dependency_management">依赖管理</a></h4>
<div class="paragraph">
<p>War插件添加了两个依赖项配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>providedCompile</code></p>
</li>
<li>
<p><code>providedRuntime</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两种配置与各自的范围相同<code>compile</code>和<code>runtime</code>配置，但不将其添加到WAR存档中。</p>
</div>
<div class="paragraph">
<p>重要的是要注意这些<code>provided</code>配置可传递。假设您添加<code>commons-httpclient:commons-httpclient:3.0</code>到任何提供的配置。这种依赖关系<code>commons-codec</code> 。因为这是“提供的”配置，所以这意味着这些依赖项都不会添加到您的WAR中，即使<code>commons-codec</code>库是您的显式依赖项<code>compile</code>组态。如果您不希望这种传递行为，只需声明您的<code>provided</code>像这样的依赖<code>commons-httpclient:commons-httpclient:3.0@jar</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:war_plugin_publishing"><a class="anchor" href="#sec:war_plugin_publishing"></a> <a class="link" href="#sec:war_plugin_publishing">出版</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>components.web</code></dt>
<dd>
<p>一个用于<a href="#publishing_overview">发布</a>由生产商创建的生产WAR的<a href="https://docs.gradle.org/6.0.1/javadoc/org/gradle/api/component/SoftwareComponent.html">SoftwareComponent</a> <code>war</code>任务。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="sec:war_convention_properties"><a class="anchor" href="#sec:war_convention_properties"></a> <a class="link" href="#sec:war_convention_properties">公约属性</a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>webAppDirName</code> -<code>String</code></dt>
<dd>
<p><em>预设值</em> ：<code>src/main/webapp</code></p>
<div class="paragraph">
<p>Web应用程序源目录的名称，相对于项目目录。</p>
</div>
</dd>
<dt class="hdlist1"><code>webAppDir</code> - （只读）<code>File</code></dt>
<dd>
<p><em>预设值</em> ： <code>$webAppDirName</code> ，例如<em>src / main / webapp</em></p>
<div class="paragraph">
<p>Web应用程序源目录的路径。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这些属性由<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.plugins.WarPluginConvention.html">WarPluginConvention</a>对象提供。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:war_default_settings"><a class="anchor" href="#sec:war_default_settings"></a> <a class="link" href="#sec:war_default_settings">战争</a></h4>
<div class="paragraph">
<p>的默认行为<code>War</code>任务是复制内容<code>src/main/webapp</code>到档案的根目录。你的<code>webapp</code>目录当然可以包含一个<code>WEB-INF</code>子目录，其中可能包含<code>web.xml</code>文件。您编译的类被编译为<code>WEB-INF/classes</code> 。所有的依赖<code>runtime</code> <sup class="footnote">[ <a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="查看脚注。">24</a> ]</sup>配置复制到<code>WEB-INF/lib</code> 。</p>
</div>
<div class="paragraph">
<p>API文档中的<a href="https://docs.gradle.org/6.0.1/dsl/org.gradle.api.tasks.bundling.War.html">War</a>类具有其他有用的信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:war_customizing"><a class="anchor" href="#sec:war_customizing"></a> <a class="link" href="#sec:war_customizing">客制化</a></h4>
<div class="paragraph">
<p>这是最重要的自定义选项的示例：</p>
</div>
<div class="exampleblock">
<div class="title">示例638定制战争插件</div>
<div class="content">
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">configurations {
   moreLibs
}

repositories {
   flatDir { dirs <span class="string"><span class="delimiter">&quot;</span><span class="content">lib</span><span class="delimiter">&quot;</span></span> }
   jcenter()
}

dependencies {
    implementation module(<span class="string"><span class="delimiter">&quot;</span><span class="content">:compile:1.0</span><span class="delimiter">&quot;</span></span>) {
        dependency <span class="string"><span class="delimiter">&quot;</span><span class="content">:compile-transitive-1.0@jar</span><span class="delimiter">&quot;</span></span>
        dependency <span class="string"><span class="delimiter">&quot;</span><span class="content">:providedCompile-transitive:1.0@jar</span><span class="delimiter">&quot;</span></span>
    }
    providedCompile <span class="string"><span class="delimiter">&quot;</span><span class="content">javax.servlet:servlet-api:2.5</span><span class="delimiter">&quot;</span></span>
    providedCompile module(<span class="string"><span class="delimiter">&quot;</span><span class="content">:providedCompile:1.0</span><span class="delimiter">&quot;</span></span>) {
        dependency <span class="string"><span class="delimiter">&quot;</span><span class="content">:providedCompile-transitive:1.0@jar</span><span class="delimiter">&quot;</span></span>
    }
    runtimeOnly <span class="string"><span class="delimiter">&quot;</span><span class="content">:runtime:1.0</span><span class="delimiter">&quot;</span></span>
    providedRuntime <span class="string"><span class="delimiter">&quot;</span><span class="content">:providedRuntime:1.0@jar</span><span class="delimiter">&quot;</span></span>
    testImplementation <span class="string"><span class="delimiter">&quot;</span><span class="content">junit:junit:4.12</span><span class="delimiter">&quot;</span></span>
    moreLibs <span class="string"><span class="delimiter">&quot;</span><span class="content">:otherLib:1.0</span><span class="delimiter">&quot;</span></span>
}

war {
    from <span class="string"><span class="delimiter">'</span><span class="content">src/rootContent</span><span class="delimiter">'</span></span> <span class="comment">// adds a file-set to the root of the archive</span>
    webInf { from <span class="string"><span class="delimiter">'</span><span class="content">src/additionalWebInf</span><span class="delimiter">'</span></span> } <span class="comment">// adds a file-set to the WEB-INF dir.</span>
    classpath fileTree(<span class="string"><span class="delimiter">'</span><span class="content">additionalLibs</span><span class="delimiter">'</span></span>) <span class="comment">// adds a file-set to the WEB-INF/lib dir.</span>
    classpath configurations.moreLibs <span class="comment">// adds a configuration to the WEB-INF/lib dir.</span>
    webXml = file(<span class="string"><span class="delimiter">'</span><span class="content">src/someWeb.xml</span><span class="delimiter">'</span></span>) <span class="comment">// copies a file to WEB-INF/web.xml</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock testable-sample multi-language-sample">
<div class="content">
<div class="listingblock">
<div class="title">build.gradle.kts</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">val moreLibs = configurations.create(&quot;moreLibs&quot;)

repositories {
    flatDir { dir(&quot;lib&quot;) }
    jcenter()
}

dependencies {
    implementation(module(&quot;:compile:1.0&quot;) {
        dependency(&quot;:compile-transitive-1.0@jar&quot;)
        dependency( &quot;:providedCompile-transitive:1.0@jar&quot;)
    })
    providedCompile(&quot;javax.servlet:servlet-api:2.5&quot;)
    providedCompile(module(&quot;:providedCompile:1.0&quot;) {
        dependency(&quot;:providedCompile-transitive:1.0@jar&quot;)
    })
    runtimeOnly(&quot;:runtime:1.0&quot;)
    providedRuntime(&quot;:providedRuntime:1.0@jar&quot;)
    testImplementation(&quot;junit:junit:4.12&quot;)
    moreLibs(&quot;:otherLib:1.0&quot;)
}

tasks.war {
    from(&quot;src/rootContent&quot;) // adds a file-set to the root of the archive
    webInf { from(&quot;src/additionalWebInf&quot;) } // adds a file-set to the WEB-INF dir.
    classpath(fileTree(&quot;additionalLibs&quot;)) // adds a file-set to the WEB-INF/lib dir.
    classpath(moreLibs) // adds a configuration to the WEB-INF/lib dir.
    webXml = file(&quot;src/someWeb.xml&quot;) // copies a file to WEB-INF/web.xml
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当然，可以使用闭包配置不同的文件集，以定义排除和包含。</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="sect1">
<h2 id="license_information"><a class="anchor" href="#license_information"></a> <a class="link" href="#license_information">许可证信息</a></h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="licenses"><a class="anchor" href="#licenses"></a> <a class="link" href="#licenses">许可证信息</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sec:gradle_documentation"><a class="anchor" href="#sec:gradle_documentation"></a> <a class="link" href="#sec:gradle_documentation">Gradle文档</a></h3>
<div class="paragraph">
<p><em>版权所有©2007-2019 Gradle，Inc.</em></p>
</div>
<div class="paragraph">
<p>Gradle构建工具的源代码是开源的，并根据<a href="https://github.com/gradle/gradle/blob/master/LICENSE">Apache License 2.0</a>获得<a href="https://github.com/gradle/gradle/blob/master/LICENSE">许可</a> 。</p>
</div>
<div class="paragraph">
<p>Gradle用户手册和DSL参考已获得<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License的许可</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="licenses:build_scan_plugin"><a class="anchor" href="#licenses:build_scan_plugin"></a> <a class="link" href="#licenses:build_scan_plugin">Gradle Build扫描插件</a></h3>
<div class="paragraph">
<p>使用<a href="https://scans.gradle.com/plugin/">构建扫描插件必须</a>遵守<a href="https://gradle.com/legal/terms-of-service/">Gradle的服务条款</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a> 。有命令行开关可以更改此行为。请参阅<a href="#command_line_interface">命令行界面</a> ）</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a> 。有命令行开关可以更改此行为。请参阅<a href="#command_line_interface">命令行界面</a> ）</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a> 。您可能想知道为什么既没有导入<code>StopExecutionException</code>我们也不能通过其完全限定的名称来访问它。原因是，Gradle向您的脚本添加了一组默认导入（请参阅<a href="#script-default-imports">默认导入</a> ）。
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a> 。除语句标签外的任何语言元素。
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a> 。Gradle支持部分多项目构建（请参阅<a href="#multi_project_builds">创作多项目构建</a> ）。
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a> 。我们拥有的实际用例是使用<a href="http://lucene.apache.org/solr" class="bare">http://lucene.apache.org/solr</a> ，在这里您需要为要访问的每个索引单独进行战争。这就是为什么我们创建了Webapp发行版的原因之一。Resin servlet容器使我们可以将这种分发指向servlet容器的基本安装。
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a> 。我们在这里执行此操作，因为它使布局更加容易。我们通常将项目特定的内容放入各个项目的构建脚本中。
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a> 。在Groovy中，您可以执行字符串。要了解有关使用Groovy执行外部流程的更多信息，请参阅“ Groovy in Action” 9.3.2或Groovy Wiki。</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a> 。实际上，添加到<code>archives</code>配置将由<code>assemble</code>
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a> 。有关更多详细信息<code>gradle.properties</code>请参阅<a href="#sec:gradle_configuration_properties">Gradle配置属性</a>
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a> 。JUnit Wiki包含有关如何使用JUnit类别的详细说明： <a href="https://github.com/junit-team/junit/wiki/Categories" class="bare">https</a> : <a href="https://github.com/junit-team/junit/wiki/Categories" class="bare">//github.com/junit-team/junit/wiki/Categories</a> 。</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a> 。TestNG文档包含有关测试组的更多详细信息： <a href="http://testng.org/doc/documentation-main.html#test-groups" class="bare">http</a> : <a href="http://testng.org/doc/documentation-main.html#test-groups" class="bare">//testng.org/doc/documentation-main.html#test-groups</a> 。</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a> 。TestNG文档包含有关使用时的测试顺序的更多详细信息<code>testng.xml</code>文件： <a href="http://testng.org/doc/documentation-main.html#testng-xml" class="bare">http</a> : <a href="http://testng.org/doc/documentation-main.html#testng-xml" class="bare">//testng.org/doc/documentation-main.html#testng-xml</a> 。</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a> 。不幸的是，Conan和Nuget存储库尚不支持作为核心功能</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a> 。在MacOS上随Xcode一起安装</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a> 。通过Cygwin和MinGW在Windows上安装了32位和64位体系结构</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a> 。与Visual Studio 2010一起安装到2019</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a> 。GCC和Clang的Macports和Homebrew安装不受官方支持</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a> 。不幸的是，Cocoapods仓库还没有被支持为核心功能</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a> 。Gradle使用与Russel Winder的<a href="https://gant.github.io/">Gant工具</a>引入的约定相同的约定。
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a> 。计划在将来的发行版中为此提供现成的支持</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a> 。请参阅<a href="#sec:configure_scala_classpath">自动配置Scala类路径</a> 。
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a> 。Gradle不支持在Scala 2.11中运行Zinc编译器v1.2.0。
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a> 。的<code>runtime</code>配置扩展了<code>compile</code>组态。
</div>
</div>
</div>
<!-- end div class="chapter" -->
<aside class="secondary-navigation"></aside>
</main>

<footer class="site-layout__footer site-footer" itemscope itemtype="https://schema.org/WPFooter">
    <nav class="site-footer__navigation" itemtype="https://schema.org/SiteNavigationElement">
        <section class="site-footer__links">
            <div class="site-footer__link-group">
                <header><strong>文件</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="/userguide/userguide.html" itemprop="url">用户手册</a></li>
                    <li itemprop="name"><a href="/dsl/" itemprop="url">DSL参考</a></li>
                    <li itemprop="name"><a href="/release-notes.html" itemprop="url">发行说明</a></li>
                    <li itemprop="name"><a href="/javadoc/" itemprop="url">Java文档</a></li>
                </ul>
            </div>
            <div class="site-footer__link-group">
                <header><strong>新闻</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="https://blog.gradle.org/" itemprop="url">博客</a></li>
                    <li itemprop="name"><a href="https://newsletter.gradle.com/" itemprop="url">通讯</a></li>
                    <li itemprop="name"><a href="https://twitter.com/gradle" itemprop="url">推特</a></li>
                </ul>
            </div>
            <div class="site-footer__link-group">
                <header><strong>产品展示</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="https://gradle.com/build-scans/" itemprop="url">构建扫描</a></li>
                    <li itemprop="name"><a href="https://gradle.com/build-cache/" itemprop="url">构建缓存</a></li>
                    <li itemprop="name"><a href="https://gradle.com/enterprise/resources/" itemprop="url">企业文件</a></li>
                </ul>
            </div>
            <div class="site-footer__link-group">
                <header><strong>得到帮助</strong></header>
                <ul class="site-footer__links-list">
                    <li itemprop="name"><a href="https://discuss.gradle.org/c/help-discuss" itemprop="url">论坛</a></li>
                    <li itemprop="name"><a href="https://github.com/gradle/" itemprop="url">的GitHub</a></li>
                    <li itemprop="name"><a href="https://gradle.com/training/" itemprop="url">训练</a></li>
                    <li itemprop="name"><a href="https://gradle.org/services/" itemprop="url">服务</a></li>
                </ul>
            </div>
        </section>
        <section class="site-footer__subscribe-newsletter" id="newsletter-form-container">
            <header class="newsletter-form__header"><h5>留<code>UP-TO-DATE</code>关于新功能和新闻</h5></header>
            <p class="disclaimer">输入您的电子邮件，即表示您同意我们的<a href="https://gradle.com/legal/terms-of-service/">条款</a>和<a href="https://gradle.com/legal/privacy/">隐私政策</a> ，包括接收电子邮件。您可以随时取消订阅。</p>
            <div class="newsletter-form__container">
                <form id="newsletter-form" class="newsletter-form" action="https://go.gradle.com/l/68052/2018-09-07/bk6wml" method="post">
                    <input id="email" class="email" name="email" type="email" placeholder="name@email.com" pattern="[^@\s]+@[^@\s]+\.[^@\s]+" maxlength="255" required>
                    <button id="submit" class="submit" type="submit">订阅</button>
                </form>
            </div>
        </section>
    </nav>
    <div class="site-footer-secondary">
        <div class="site-footer-secondary__contents">
            <div class="site-footer__copy">© <a href="https://gradle.com">Gradle Inc.</a> <time> 2018年</time>版权所有。
            </div>
            <div class="site-footer__logo"><a href="/">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 90 66.06">
                    <defs>
                        <style>.cls-1 {
                            fill: #02303a;
                        }</style>
                    </defs>
                    <title>摇动</title>
                    <path class="cls-1" d="M85.11,4.18a14.27,14.27,0,0,0-19.83-.34,1.38,1.38,0,0,0,0,2L67,7.6a1.36,1.36,0,0,0,1.78.12A8.18,8.18,0,0,1,79.5,20.06C68.17,31.38,53.05-.36,18.73,16a4.65,4.65,0,0,0-2,6.54l5.89,10.17a4.64,4.64,0,0,0,6.3,1.73l.14-.08-.11.08L31.53,33a60.29,60.29,0,0,0,8.22-6.13,1.44,1.44,0,0,1,1.87-.06h0a1.34,1.34,0,0,1,.06,2A61.61,61.61,0,0,1,33,35.34l-.09,0-2.61,1.46a7.34,7.34,0,0,1-3.61.94,7.45,7.45,0,0,1-6.47-3.71l-5.57-9.61C4,32-2.54,46.56,1,65a1.36,1.36,0,0,0,1.33,1.11H8.61A1.36,1.36,0,0,0,10,64.87a9.29,9.29,0,0,1,18.42,0,1.35,1.35,0,0,0,1.34,1.19H35.9a1.36,1.36,0,0,0,1.34-1.19,9.29,9.29,0,0,1,18.42,0A1.36,1.36,0,0,0,57,66.06H63.1a1.36,1.36,0,0,0,1.36-1.34c.14-8.6,2.46-18.48,9.07-23.43C96.43,24.16,90.41,9.48,85.11,4.18ZM61.76,30.05l-4.37-2.19h0a2.74,2.74,0,1,1,4.37,2.2Z"></path>
                </svg>
            </a></div>
            <div class="site-footer-secondary__links">
                <a href="https://gradle.com/careers/">招贤纳士</a> | <a href="https://gradle.com/legal/privacy/">隐私</a> | <a href="https://gradle.com/legal/terms-of-service/">服务条款</a> | <a href="https://gradle.org/contact/">联系</a>
            </div>
        </div>
    </div>
</footer>

<script type="text/javascript">
    // Polyfill Element.matches()
    if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }
    // Polyfill Element.closest()
    if (!Element.prototype.closest) {
        Element.prototype.closest = function (s) {
            var el = this;
            if (!document.documentElement.contains(el)) return null;
            do {
                if (typeof el.matches === "function" && el.matches(s)) return el;
                el = el.parentElement || el.parentNode;
            } while (el !== null);
            return null;
        };
    }

    var currentChapterFileName = window.location.pathname.substr(window.location.pathname.lastIndexOf("/") + 1);
    [].forEach.call(document.querySelectorAll(".docs-navigation a[href$='" + currentChapterFileName + "']"), function (link) {
        // Add "active" to all links same as current URL
        link.classList.add("active");

        // Expand all parent navigation
        var parentListEl = link.closest("li");
        while (parentListEl !== null) {
            var dropDownEl = parentListEl.querySelector(".nav-dropdown");
            if (dropDownEl !== null) {
                dropDownEl.classList.add("expanded");
            }
            parentListEl = parentListEl.parentNode.closest("li");
        }
    });

    // Expand/contract multi-level side navigation
    [].forEach.call(document.querySelectorAll(".docs-navigation .nav-dropdown"), function registerSideNavActions(collapsibleElement) {
        collapsibleElement.addEventListener("click", function toggleExpandedSideNav(evt) {
            evt.preventDefault();
            evt.target.classList.toggle("expanded");
            evt.target.setAttribute("aria-expanded", evt.target.classList.contains("expanded").toString());
            return false;
        }, false);
    });

    function postProcessCodeBlocks() {
        // Assumptions:
        //  1) All siblings that are marked with class="multi-language-sample" should be grouped
        //  2) Only one language can be selected per domain (to allow selection to persist across all docs pages)
        //  3) There is exactly 1 small set of languages to choose from. This does not allow for multiple language preferences. For example, users cannot prefer both Kotlin and ZSH.
        //  4) Only 1 sample of each language can exist in the same collection.

        var GRADLE_DSLs = ["groovy", "kotlin"];
        var preferredBuildScriptLanguage = initPreferredBuildScriptLanguage();

        // Ensure preferred DSL is valid, defaulting to Groovy DSL
        function initPreferredBuildScriptLanguage() {
            var lang = window.localStorage.getItem("preferred-gradle-dsl");
            if (GRADLE_DSLs.indexOf(lang) === -1) {
                window.localStorage.setItem("preferred-gradle-dsl", "groovy");
                lang = "groovy";
            }
            return lang;
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function processSampleEl(sampleEl, prefLangId) {
            var codeEl = sampleEl.querySelector("code[data-lang]");
            if (codeEl != null) {
                sampleEl.setAttribute("data-lang", codeEl.getAttribute("data-lang"));
                if (codeEl.getAttribute("data-lang") !== prefLangId) {
                    sampleEl.classList.add("hidden");
                } else {
                    sampleEl.classList.remove("hidden");
                }
            }
        }

        function switchSampleLanguage(languageId) {
            var multiLanguageSampleElements = [].slice.call(document.querySelectorAll(".multi-language-sample"));

            // Array of Arrays, each top-level array representing a single collection of samples
            var multiLanguageSets = [];
            for (var i = 0; i < multiLanguageSampleElements.length; i++) {
                var currentCollection = [multiLanguageSampleElements[i]];
                var currentSampleElement = multiLanguageSampleElements[i];
                processSampleEl(currentSampleElement, languageId);
                while (currentSampleElement.nextElementSibling != null && currentSampleElement.nextElementSibling.classList.contains("multi-language-sample")) {
                    currentCollection.push(currentSampleElement.nextElementSibling);
                    currentSampleElement = currentSampleElement.nextElementSibling;
                    processSampleEl(currentSampleElement, languageId);
                    i++;
                }

                multiLanguageSets.push(currentCollection);
            }

            multiLanguageSets.forEach(function (sampleCollection) {
                // Create selector element if not existing
                if (sampleCollection.length > 1 &&
                    (sampleCollection[0].previousElementSibling == null ||
                        !sampleCollection[0].previousElementSibling.classList.contains("multi-language-selector"))) {
                    var languageSelectorFragment = document.createDocumentFragment();
                    var multiLanguageSelectorElement = document.createElement("div");
                    multiLanguageSelectorElement.classList.add("multi-language-selector");
                    languageSelectorFragment.appendChild(multiLanguageSelectorElement);


                    sampleCollection.forEach(function (sampleEl) {
                        var optionEl = document.createElement("code");
                        var sampleLanguage = sampleEl.getAttribute("data-lang");
                        optionEl.setAttribute("data-lang", sampleLanguage);
                        optionEl.setAttribute("role", "button");
                        optionEl.classList.add("language-option");

                        optionEl.innerText = capitalizeFirstLetter(sampleLanguage);

                        optionEl.addEventListener("click", function updatePreferredLanguage(evt) {
                            var preferredLanguageId = optionEl.getAttribute("data-lang");
                            window.localStorage.setItem("preferred-gradle-dsl", preferredLanguageId);

                            // Record how far down the page the clicked element is before switching all samples
                            var beforeOffset = evt.target.offsetTop;

                            switchSampleLanguage(preferredLanguageId);

                            // Scroll the window to account for content height differences between different sample languages
                            window.scrollBy(0, evt.target.offsetTop - beforeOffset);
                        });
                        multiLanguageSelectorElement.appendChild(optionEl);
                    });
                    sampleCollection[0].parentNode.insertBefore(languageSelectorFragment, sampleCollection[0]);
                }
            });

            [].slice.call(document.querySelectorAll(".multi-language-selector .language-option")).forEach(function (optionEl) {
                if (optionEl.getAttribute("data-lang") === languageId) {
                    optionEl.classList.add("selected");
                } else {
                    optionEl.classList.remove("selected");
                }
            });

            [].slice.call(document.querySelectorAll(".multi-language-text")).forEach(function (el) {
                if (!el.classList.contains("lang-" + languageId)) {
                    el.classList.add("hidden");
                } else {
                    el.classList.remove("hidden");
                }
            });
        }

        switchSampleLanguage(preferredBuildScriptLanguage);
    }

    document.addEventListener("DOMContentLoaded", postProcessCodeBlocks);
</script>


</body></html>