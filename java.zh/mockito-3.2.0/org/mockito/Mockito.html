<html lang="zh-Hans" ><head></head><body >﻿
<!-- Generated by javadoc (1.8.0_141) on Fri Nov 29 16:14:39 UTC 2019 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Mockito（Mockito 3.2.0 API）</title>
<meta name="date" content="2019-11-29">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>


<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Mockito (Mockito 3.2.0 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":41,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":41,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":41,"i41":9,"i42":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器禁用了JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../overview-summary.html">总览</a></li>
<li><a href="package-summary.html">包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Mockito.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../deprecated-list.html">不推荐使用</a></li>
<li><a href="../../index-files/index-1.html">指数</a></li>
<li><a href="../../help-doc.html">救命</a></li>
</ul>
<div class="aboutLanguage"><em id="mockito-version-header-javadoc7-header"><strong>Mockito 3.2.0 API</strong></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/mockito/MockingDetails.html" title="org.mockito中的接口"><span class="typeNameLink">上一课</span></a></li>
<li><a href="../../org/mockito/MockitoAnnotations.html" title="org.mockito中的类"><span class="typeNameLink">下一班</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/mockito/Mockito.html" target="_top">镜框</a></li>
<li><a href="Mockito.html" target="_top">没有框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">所有课程</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>摘要：</li>
<li>嵌套|</li>
<li><a href="#field.summary">领域</a></li>
<li><a href="#constructor.summary">建设</a> |</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详情：</li>
<li><a href="#field.detail">领域</a></li>
<li><a href="#constructor.detail">建设</a> |</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.mockito</div>
<h2 title="Mockito类" class="title">Mockito类</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="java.lang中的类或接口">java.lang。宾语</a></li>
<li>
<ul class="inheritance">
<li><a href="../../org/mockito/ArgumentMatchers.html" title="org.mockito中的类">org.mockito。参数匹配器</a></li>
<li>
<ul class="inheritance">
<li>org.mockito。莫基托</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>直接已知子类：</dt>
<dd><a href="../../org/mockito/BDDMockito.html" title="org.mockito中的类">BDDMockito</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">Mockito</span>
extends <a href="../../org/mockito/ArgumentMatchers.html" title="class in org.mockito">ArgumentMatchers</a></pre>
<div class="block"><p align="left"><img src="logo.png" alt="Mockito徽标" srcset="logo@2x.png 2x"></p>Mockito库支持模拟创建，验证和存根。

 <p>也可以在<a href="http://mockito.org">http://mockito.org</a>网页上获得此javadoc内容。所有文档都保存在javadocs中，因为它可以保证Web内容和源代码之间的一致性。即使您离线工作，它也允许直接从IDE访问文档。它激励Mockito开发人员使他们每天，每次提交的代码都保持最新。

 </p><h1>内容</h1>

 <b>
      <a href="#0">0。迁移到Mockito 2</a><br>
      <a href="#0.1">0.1 Mockito Android支持</a><br>
      <a href="#0.2">0.2无需配置的在线模拟制作</a><br>
      <a href="#1">1。让我们验证一些行为！</a><br>
      <a href="#2">2。存根怎么样？</a><br>
      <a href="#3">3。参数匹配器</a><br>
      <a href="#4">4。验证确切的调用次数/至少一次/永不</a><br>
      <a href="#5">5，异常处理无效方法</a><br>
      <a href="#6">6。验证顺序</a><br>
      <a href="#7">7。确保模拟中从未发生过互动</a><br>
      <a href="#8">8。查找多余的调用</a><br>
      <a href="#9">9。模拟创作的简写- <code>@Mock</code>注解</a><br>
      <a href="#10">10。存根连续的呼叫（迭代器式存根）</a><br>
      <a href="#11">11。回调回调</a><br>
      <a href="#12">12 <code>doReturn()</code> | <code>doThrow()</code> | <code>doAnswer()</code> | <code>doNothing()</code> | <code>doCallRealMethod()</code>方法族</a><br>
      <a href="#13">13监视真实物体</a><br>
      <a href="#14">14。更改未存根调用的默认返回值（从1.7开始）</a><br>
      <a href="#15">15为进一步的断言捕获参数（自1.8.0开始）</a><br>
      <a href="#16">16。真正的部分模拟（自1.8.0开始）</a><br>
      <a href="#17">17。重置模拟（自1.8.0开始）</a><br>
      <a href="#18">18岁故障排除和验证框架的使用（自1.8.0开始）</a><br>
      <a href="#19">19行为驱动开发的别名（自1.8.0开始）</a><br>
      <a href="#20">20可序列化的模拟（自1.8.1开始）</a><br>
      <a href="#21">21新注释： <code>@Captor</code> ， <code>@Spy</code> ， <code>@InjectMocks</code> （从1.8.3版开始）</a><br>
      <a href="#22">22超时验证（自1.8.5开始）</a><br>
      <a href="#23">23。自动实例化<code>@Spies</code> ， <code>@InjectMocks</code>和构造函数注入优度（自1.9.0开始）</a><br>
      <a href="#24">24单线存根（自1.9.0起）</a><br>
      <a href="#25">25忽略存根的验证（自1.9.0开始）</a><br>
      <a href="#26">26模拟详细信息（在2.2.x中已改进）</a><br>
      <a href="#27">27。将调用委托给真实实例（自1.9.5开始）</a><br>
      <a href="#28">28。 <code>MockMaker</code> API（自1.9.5开始）</a><br>
      <a href="#29">29。BDD样式验证（自1.10.0开始）</a><br>
      <a href="#30">30岁监视或嘲笑抽象类（自1.10.12开始，在2.7.13和2.7.14中进一步增强）</a><br>
      <a href="#31">31。Mockito模拟可以在类加载器中<em>序列化</em> / <em>反</em> <em>序列化</em> （自1.10.0开始）</a><br>
      <a href="#32">32。带有深层存根的更好的通用支持（自1.10.0开始）</a><br>
      <a href="#33">33。Mockito JUnit规则（自1.10.17开始）</a><br>
      <a href="#34">34。<em>打开</em>或<em>关闭</em>插件（自1.10.15开始）</a><br>
      <a href="#35">35岁自定义验证失败消息（自2.1.0开始）</a><br>
      <a href="#36">36。Java 8 Lambda Matcher支持（自2.1.0开始）</a><br>
      <a href="#37">37。Java 8自定义答案支持（自2.1.0开始）</a><br>
      <a href="#38">38。元数据和通用类型保留（自2.1.0开始）</a><br>
      <a href="#39">39。模拟最终类型，枚举和最终方法（自2.1.0开始）</a><br>
      <a href="#40">40使用“更严格”的Mockito（从2开始，提高了生产率和更清洁的测试）。+）</a><br>
      <a href="#41">41。用于框架集成的高级公共API（自2.10开始。+）</a><br>
      <a href="#42">42。集成的新API：监听验证开始事件（自2.11开始。+）</a><br>
      <a href="#43">43。新的集成API： <code>MockitoSession</code>可用于测试框架（自2.15开始。+）</a><br>
      <a href="#44">44。不推荐使用<code>org.mockito.plugins.InstantiatorProvider</code>因为它泄漏了内部API。它被替换为<code>org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)</code></a><br>
      <a href="#45">45。新的JUnit Jupiter（JUnit5 +）扩展</a><br>
      <a href="#46">46。新<code>Mockito.lenient()</code>和<code>MockSettings.lenient()</code>方法（自2.20.0开始）</a><br>
      <a href="#47">47。用于清除内联模拟中的模拟状态的新API（自2.25.0开始）</a><br>
 </b>

 <h3 id="0">0。<a class="meaningful_link" href="#mockito2" name="mockito2">迁移到Mockito 2</a></h3>为了继续改进Mockito并进一步改善单元测试体验，我们希望您升级到2.1.0！Mockito遵循<a href="http://semver.org/">语义版本控制，</a>并且仅在主要版本升级中包含重大更改。在库的生命周期中，必须进行重大更改以推出一组全新的功能，这些功能可以更改现有行为甚至更改API。有关新版本的全面指南，包括不兼容的更改，请参阅“ <a href="https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2">Mockito 2中的新增功能</a> ”维基页面。我们希望您喜欢Mockito 2！

 <h3 id="0.1">0.1。<a class="meaningful_link" href="#mockito-android" name="mockito-android">Mockito Android支持</a></h3>在Mockito 2.6.1版中，我们提供了“本机” Android支持。要启用Android支持，请将`mockito-android`库作为依赖项添加到您的项目中。该工件已发布到同一Mockito组织，并且可以如下导入Android：<pre class="code"><code>
 repositories {
   jcenter()
 }
 dependencies {
   testCompile "org.mockito:mockito-core:+"
   androidTestCompile "org.mockito:mockito-android:+"
 }
 </code></pre>您可以通过在“ testCompile”作用域中使用“ mockito-core”构件来继续在常规VM上运行相同的单元测试，如上所示。请注意，由于Android VM中的限制，您不能在Android上使用<a href="#39">内联模拟程序制作器</a> 。如果您在Android上遇到有关模拟的问题，请<a href="https://github.com/mockito/mockito/issues/new">在官方问题跟踪器上</a>打开<a href="https://github.com/mockito/mockito/issues/new">问题</a> 。请提供您正在使用的Android版本以及项目的依赖项。

 <h3 id="0.2">0.2。<a class="meaningful_link" href="#mockito-inline" name="mockito-inline">无需配置的在线模拟制作</a></h3>从版本2.7.6开始，我们提供了“ mockito-inline”构件，该构件可进行<a href="#39">内联模拟</a>而无需配置MockMaker扩展文件。要使用它，请添加`mockito-inline`而不是`mockito-core`构件，如下所示：<pre class="code"><code>
 repositories {
   jcenter()
 }
 dependencies {
   testCompile "org.mockito:mockito-inline:+"
 }
 </code></pre>请注意，当将内置模拟制作功能集成到默认的模拟制作器中时，可能会消除此工件。

 <p>有关内联模拟制作的更多信息，请参见<a href="#39">第39节</a> 。

 </p><h3 id="1">1。<a class="meaningful_link" href="#verification" name="verification">让我们验证一些行为！</a></h3>以下示例模拟了一个List，因为大多数人都熟悉该界面（例如<code>add()</code> ， <code>get()</code> ， <code>clear()</code>方法）。<br>实际上，请不要嘲笑List类。而是使用真实实例。

 <pre class="code"><code class="java">
 //Let's import Mockito statically so that the code looks clearer
 import static org.mockito.Mockito.*;

 //mock creation
 List mockedList = mock(List.class);

 //using mock object
 mockedList.add("one");
 mockedList.clear();

 //verification
 verify(mockedList).add("one");
 verify(mockedList).clear();
 </code></pre>

 <p>一旦创建，模拟程序将记住所有交互。然后，您可以有选择地验证您感兴趣的任何交互。
 </p>



 <h3 id="2">2。<a class="meaningful_link" href="#stubbing" name="stubbing">存根怎么样？</a></h3>

 <pre class="code"><code class="java">
 //You can mock concrete classes, not just interfaces
 LinkedList mockedList = mock(LinkedList.class);

 //stubbing
 when(mockedList.get(0)).thenReturn("first");
 when(mockedList.get(1)).thenThrow(new RuntimeException());

 //following prints "first"
 System.out.println(mockedList.get(0));

 //following throws runtime exception
 System.out.println(mockedList.get(1));

 //following prints "null" because get(999) was not stubbed
 System.out.println(mockedList.get(999));

 //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
 //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).
 //If your code doesn't care what get(0) returns, then it should not be stubbed.
 verify(mockedList).get(0);
 </code></pre>

 <ul>
 <li>默认情况下，对于所有返回值的方法，模拟将根据需要返回null，原始/原始包装器值或空集合。例如，对于int / Integer为0，对于boolean / Boolean为false。</li>

 <li>存根可以被覆盖：例如，通用存根可以进入夹具设置，但是测试方法可以覆盖它。请注意，过多的存根是潜在的代码异味，表明存在过多的存根</li>

 <li>一旦存根，该方法将始终返回存根值，而不管其被调用了多少次。</li>

 <li>最后一次存根更为重要-当您多次对具有相同参数的相同方法进行存根时。换句话说： <b>存根的顺序</b>很<b>重要，</b>但仅在很少意义上有意义，例如，存根完全相同的方法调用时或有时使用参数匹配器时，等等。</li>

 </ul>



 <h3 id="3">3。<a class="meaningful_link" href="#argument_matchers" name="argument_matchers">参数匹配器</a></h3>Mockito以自然的Java样式验证参数值：通过使用<code>equals()</code>方法。有时，当需要额外的灵活性时，您可以使用参数匹配器：<pre class="code"><code class="java">
 //stubbing using built-in anyInt() argument matcher
 when(mockedList.get(anyInt())).thenReturn("element");

 //stubbing using custom matcher (let's say isValid() returns your own matcher implementation):
 when(mockedList.contains(argThat(isValid()))).thenReturn(true);

 //following prints "element"
 System.out.println(mockedList.get(999));

 //<b>you can also verify using an argument matcher</b>
 verify(mockedList).get(anyInt());

 //<b>argument matchers can also be written as Java 8 Lambdas</b>
 verify(mockedList).add(argThat(someString -> someString.length() > 5));

 </code></pre>

 <p>参数匹配器允许灵活的验证或存根。
 <a href="../../org/mockito/ArgumentMatchers.html" title="org.mockito中的类"><code>Click here</code></a> <a href="../../org/mockito/hamcrest/MockitoHamcrest.html" title="org.mockito.hamcrest中的类"><code>or here</code></a>查看更多内置匹配器以及<b>自定义参数匹配器/ hamcrest匹配器的</b>示例。
 </p><p>有关仅<b>自定义参数匹配器的信息，</b>请查看javadoc以获取相关信息。 <a href="../../org/mockito/ArgumentMatcher.html" title="org.mockito中的接口"><code>ArgumentMatcher</code></a>类。
 </p><p>使用复杂的参数匹配是合理的。自然搭配风格使用<code>equals()</code>偶尔<code>anyX()</code>匹配器往往会提供干净简单的测试。有时最好重构代码以允许<code>equals()</code>匹配甚至实现<code>equals()</code>帮助测试的方法。
 </p><p>另外，请阅读<a href="#15">第15节</a>或javadoc以获取相关信息<a href="../../org/mockito/ArgumentCaptor.html" title="org.mockito中的类"><code>ArgumentCaptor</code></a>类。
 <a href="../../org/mockito/ArgumentCaptor.html" title="org.mockito中的类"><code>ArgumentCaptor</code></a>是参数匹配器的一种特殊实现，它捕获参数值以用于进一步的声明。
 </p><p>
 <b>警告参数匹配器：</b>
 </p><p>如果使用参数匹配器，则必须由匹配器提供<b>所有参数</b> 。
 </p><p>以下示例显示了验证，但对存根也是如此：</p><pre class="code"><code class="java">
   verify(mock).someMethod(anyInt(), anyString(), <b>eq("third argument")</b>);
   //above is correct - eq() is also an argument matcher

   verify(mock).someMethod(anyInt(), anyString(), <b>"third argument"</b>);
   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
 </code></pre>

 <p>匹配器方法如<code>anyObject()</code> ， <code>eq()</code> <b>不</b>返回匹配器。在内部，它们在堆栈上记录一个匹配器，并返回一个虚拟值（通常为null）。此实现归因于Java编译器施加的静态类型安全性。结果是您不能使用<code>anyObject()</code> ， <code>eq()</code>已验证/存根方法之外的方法。




 </p><h3 id="4">4。<a class="meaningful_link" href="#exact_verification" name="exact_verification">验证确切的调用次数</a> / <a class="meaningful_link" href="#at_least_verification" name="at_least_verification">至少x</a> /从不</h3>

 <pre class="code"><code class="java">
 //using mock
 mockedList.add("once");

 mockedList.add("twice");
 mockedList.add("twice");

 mockedList.add("three times");
 mockedList.add("three times");
 mockedList.add("three times");

 //following two verifications work exactly the same - times(1) is used by default
 verify(mockedList).add("once");
 verify(mockedList, times(1)).add("once");

 //exact number of invocations verification
 verify(mockedList, times(2)).add("twice");
 verify(mockedList, times(3)).add("three times");

 //verification using never(). never() is an alias to times(0)
 verify(mockedList, never()).add("never happened");

 //verification using atLeast()/atMost()
 verify(mockedList, atMostOnce()).add("once");
 verify(mockedList, atLeastOnce()).add("three times");
 verify(mockedList, atLeast(2)).add("three times");
 verify(mockedList, atMost(5)).add("three times");

 </code></pre>

 <p>
 <b>默认为times（1）。</b> 因此，可以显式地省略使用times（1）。




 </p><h3 id="5">5，<a class="meaningful_link" href="#stubbing_with_exceptions" name="stubbing_with_exceptions">异常处理无效方法</a></h3>

 <pre class="code"><code class="java">
   doThrow(new RuntimeException()).when(mockedList).clear();

   //following throws RuntimeException:
   mockedList.clear();
 </code></pre>进一步了解<code>doThrow()</code> | <code>doAnswer()</code> <a href="#12">第12节中</a>的方法系列。
 <p>

 </p><h3 id="6">6。<a class="meaningful_link" href="#in_order_verification" name="in_order_verification">验证顺序</a></h3>

 <pre class="code"><code class="java">
 // A. Single mock whose methods must be invoked in a particular order
 List singleMock = mock(List.class);

 //using a single mock
 singleMock.add("was added first");
 singleMock.add("was added second");

 //create an inOrder verifier for a single mock
 InOrder inOrder = inOrder(singleMock);

 //following will make sure that add is first called with "was added first", then with "was added second"
 inOrder.verify(singleMock).add("was added first");
 inOrder.verify(singleMock).add("was added second");

 // B. Multiple mocks that must be used in a particular order
 List firstMock = mock(List.class);
 List secondMock = mock(List.class);

 //using mocks
 firstMock.add("was called first");
 secondMock.add("was called second");

 //create inOrder object passing any mocks that need to be verified in order
 InOrder inOrder = inOrder(firstMock, secondMock);

 //following will make sure that firstMock was called before secondMock
 inOrder.verify(firstMock).add("was called first");
 inOrder.verify(secondMock).add("was called second");

 // Oh, and A + B can be mixed together at will
 </code></pre>按顺序进行验证是灵活的- <b>您不必</b>一一<b>验证所有交互</b> ，而只需依次验证您感兴趣的<b>交互即可</b> 。
 <p>同样，您可以创建一个InOrder对象，该对象仅传递与顺序验证相关的模拟。




 </p><h3 id="7">7。<a class="meaningful_link" href="#never_verification" name="never_verification">确保模拟中从未发生过互动</a></h3>

 <pre class="code"><code class="java">
 //using mocks - only mockOne is interacted
 mockOne.add("one");

 //ordinary verification
 verify(mockOne).add("one");

 //verify that method was never called on a mock
 verify(mockOne, never()).add("two");

 //verify that other mocks were not interacted
 verifyZeroInteractions(mockTwo, mockThree);

 </code></pre>




 <h3 id="8">8。<a class="meaningful_link" href="#finding_redundant_invocations" name="finding_redundant_invocations">查找多余的调用</a></h3>

 <pre class="code"><code class="java">
 //using mocks
 mockedList.add("one");
 mockedList.add("two");

 verify(mockedList).add("one");

 //following verification will fail
 verifyNoMoreInteractions(mockedList);
 </code></pre>一个<b>警告</b> ：一些做过很多经典的，期望运行验证的模拟的用户倾向于使用<code>verifyNoMoreInteractions()</code>甚至在每种测试方法中都非常常见。
 <code>verifyNoMoreInteractions()</code>不建议在每种测试方法中都使用。
 <code>verifyNoMoreInteractions()</code>是交互测试工具包中的一个方便断言。仅在相关时使用。滥用它会导致<strong>过度指定</strong> ， <strong>难以维护的</strong>测试。

 <p>也可以看看<a href="../../org/mockito/Mockito.html#never--"><code>never()</code></a> -更明确，传达意图。
 </p><p>




 </p><h3 id="9">9。<a class="meaningful_link" href="#mock_annotation" name="mock_annotation">模拟创作的简写- <code>@Mock</code>注解</a></h3>

 <ul>
 <li>最小化重复的模拟创建代码。</li>
 <li>使测试类更具可读性。</li>
 <li>因为<b>字段名称</b>用于标识模拟，所以使验证错误更易于阅读。</li>
 </ul>

 <pre class="code"><code class="java">
   public class ArticleManagerTest {

       &#064;Mock private ArticleCalculator calculator;
       &#064;Mock private ArticleDatabase database;
       &#064;Mock private UserProvider userProvider;

       private ArticleManager manager;
 </code></pre>

 <b>重要！</b> 这需要在基类中或测试运行器中：<pre class="code"><code class="java">
 MockitoAnnotations.initMocks(testClass);
 </code></pre>您可以使用内置的运行器： <a href="../../org/mockito/junit/MockitoJUnitRunner.html" title="org.mockito.junit中的类"><code>MockitoJUnitRunner</code></a>或规则： <a href="../../org/mockito/junit/MockitoRule.html" title="org.mockito.junit中的接口"><code>MockitoRule</code></a> 。对于JUnit5测试，请参阅<a href="#45">第45节中</a>描述的JUnit5扩展。
 <p>在这里阅读更多： <a href="../../org/mockito/MockitoAnnotations.html" title="org.mockito中的类"><code>MockitoAnnotations</code></a>




 </p><h3 id="10">10。<a class="meaningful_link" href="#stubbing_consecutive_calls" name="stubbing_consecutive_calls">存根连续的呼叫</a> （迭代器式存根）</h3>有时，对于同一方法调用，我们需要对不同的返回值/异常进行存根。典型的用例可能是模拟迭代器。Mockito的原始版本没有此功能来促进简单的模拟。例如，可以使用迭代器代替迭代器<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="java.lang中的类或接口"><code>Iterable</code></a>或只是收藏。这些提供了自然的存根方式（例如使用真实集合）。但是，在极少数情况下，对连续调用进行存根可能会很有用：<p>

 </p><pre class="code"><code class="java">
 when(mock.someMethod("some arg"))
   .thenThrow(new RuntimeException())
   .thenReturn("foo");

 //First call: throws runtime exception:
 mock.someMethod("some arg");

 //Second call: prints "foo"
 System.out.println(mock.someMethod("some arg"));

 //Any consecutive call: prints "foo" as well (last stubbing wins).
 System.out.println(mock.someMethod("some arg"));
 </code></pre>可选的，较短版本的连续存根：<pre class="code"><code class="java">
 when(mock.someMethod("some arg"))
   .thenReturn("one", "two", "three");
 </code></pre>

 <strong>警告</strong> ：如果不是链接<code>.thenReturn()</code>调用，使用具有相同匹配器或参数的多个存根，则每个存根将覆盖前一个存根：<pre class="code"><code class="java">
 //All mock.someMethod("some arg") calls will return "two"
 when(mock.someMethod("some arg"))
   .thenReturn("one")
 when(mock.someMethod("some arg"))
   .thenReturn("two")
 </code></pre>



 <h3 id="11">11。<a class="meaningful_link" href="#answer_stubs" name="answer_stubs">回调回调</a></h3>允许使用泛型进行存根<a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a>接口。
 <p>另一个有争议的功能最初并未包含在Mockito中。我们建议您仅使用<code>thenReturn()</code>要么<code>thenThrow()</code> ，它应该足以测试/测试驱动任何简洁的代码。但是，如果您确实需要使用通用的Answer接口进行存根（stub），请参考以下示例：</p><pre class="code"><code class="java">
 when(mock.someMethod(anyString())).thenAnswer(
     new Answer() {
         public Object answer(InvocationOnMock invocation) {
             Object[] args = invocation.getArguments();
             Object mock = invocation.getMock();
             return "called with arguments: " + Arrays.toString(args);
         }
 });

 //Following prints "called with arguments: [foo]"
 System.out.println(mock.someMethod("foo"));
 </code></pre>




 <h3 id="12">12<a class="meaningful_link" href="#do_family_methods_stubs" name="do_family_methods_stubs"><code>doReturn()</code> | <code>doThrow()</code> | <code>doAnswer()</code> | <code>doNothing()</code> | <code>doCallRealMethod()</code>方法族</a></h3>无效方法的存根与<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>因为编译器不喜欢方括号内的void方法...
 <p>使用<code>doThrow()</code>当您想对带有异常的void方法进行存根时：</p><pre class="code"><code class="java">
   doThrow(new RuntimeException()).when(mockedList).clear();

   //following throws RuntimeException:
   mockedList.clear();
 </code></pre>
 <p></p>

 <p>您可以使用<code>doThrow()</code> ， <code>doAnswer()</code> ， <code>doNothing()</code> ， <code>doReturn()</code>和<code>doCallRealMethod()</code>代替与<code>when()</code> ，适用于任何方法。当你有必要</p><ul>
     <li>存根无效方法</li>
     <li>间谍对象的存根方法（请参见下文）</li>
     <li>多次对同一方法进行存根测试，以在测试过程中更改模拟的行为。</li>
 </ul>但您可能更喜欢使用这些方法来代替<code>when()</code> ，用于您的所有存根电话。
 <p>阅读有关这些方法的更多信息：</p><p>
 <a href="../../org/mockito/Mockito.html#doReturn-java.lang.Object-"><code>doReturn(Object)</code></a>
 </p><p>
 <a href="../../org/mockito/Mockito.html#doThrow-java.lang.Throwable...-"><code>doThrow(Throwable...)</code></a>
 </p><p>
 <a href="../../org/mockito/Mockito.html#doThrow-java.lang.Class-"><code>doThrow(Class)</code></a>
 </p><p>
 <a href="../../org/mockito/Mockito.html#doAnswer-org.mockito.stubbing.Answer-"><code>doAnswer(Answer)</code></a>
 </p><p>
 <a href="../../org/mockito/Mockito.html#doNothing--"><code>doNothing()</code></a>
 </p><p>
 <a href="../../org/mockito/Mockito.html#doCallRealMethod--"><code>doCallRealMethod()</code></a>




 </p><h3 id="13">13<a class="meaningful_link" href="#spy" name="spy">监视真实物体</a></h3>您可以创建真实对象的间谍。当您使用间谍时，将调用<b>实际</b>方法（除非对方法进行了加注）。
 <p>真正的间谍应该<b>小心谨慎</b>地使用，例如在处理遗留代码时。

 </p><p>监视真实对象可以与“部分模拟”概念相关联。
 <b>在1.8版之前</b> ，Mockito间谍不是真正的部分模拟。原因是我们认为部分模拟是一种代码味道。在某个时候，我们发现了部分模拟的合法用例（第三方接口，对遗留代码的临时重构）。
 </p><p>

 </p><pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //optionally, you can stub out some methods:
   when(spy.size()).thenReturn(100);

   //using the spy calls <b>*real*</b> methods
   spy.add("one");
   spy.add("two");

   //prints "one" - the first element of a list
   System.out.println(spy.get(0));

   //size() method was stubbed - 100 is printed
   System.out.println(spy.size());

   //optionally, you can verify
   verify(spy).add("one");
   verify(spy).add("two");
 </code></pre>

 <h4>从事间谍活动的重要陷阱！</h4>
 <ol>
 <li>有时使用是不可能或不切实际的<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>侦探间谍。因此，使用间谍时请考虑<code>doReturn</code> | <code>Answer</code> | <code>Throw()</code>系列的存根方法。例：<pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   when(spy.get(0)).thenReturn("foo");

   //You have to use doReturn() for stubbing
   doReturn("foo").when(spy).get(0);
 </code></pre>
 </li>

 <li>Mockito <b>*不会*</b>将调用委托给传递的真实实例，而是实际上创建它的副本。因此，如果保留真实实例并与之交互，请不要期望间谍知道这些交互及其对真实实例状态的影响。必然的结果是，当<b>在间谍*上</b>调用<b>* unstubbed *</b>方法<b>而在真实实例上*不</b>调用<b>*</b>方法时，您将看不到任何对真实实例的影响。
 </li>

 <li>注意最终方法。Mockito不模拟最终方法，因此最重要的是：当您监视真实对象时+尝试对最终方法进行存根=麻烦。另外，您也将无法验证这些方法。
 </li>
 </ol>




 <h3 id="14">14。更改未<a class="meaningful_link" href="#defaultreturn" name="defaultreturn">存根调用的默认返回值</a> （从1.7开始）</h3>您可以使用指定策略为其返回值创建模拟。这是一项高级功能，通常您不需要它来编写不错的测试。但是，这对于使用<b>遗留系统</b>可能会有所帮助。
 <p>这是默认答案，因此<b>仅当您不</b>存根方法调用<b>时</b>才会使用它。

 </p><pre class="code"><code class="java">
   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
 </code></pre>

 <p>阅读有关<i>Answer的</i>有趣实现的更多信息： <a href="../../org/mockito/Mockito.html#RETURNS_SMART_NULLS"><code>RETURNS_SMART_NULLS</code></a>




 </p><h3 id="15">15为进一步的断言<a class="meaningful_link" href="#captors" name="captors">捕获参数</a> （自1.8.0开始）</h3>Mockito以自然的Java样式验证参数值：通过使用<code>equals()</code>方法。这也是推荐的匹配参数的方法，因为它使测试简洁明了。但是，在某些情况下，在实际验证之后对某些参数进行断言是有帮助的。例如：<pre class="code"><code class="java">
   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);
   verify(mock).doSomething(argument.capture());
   assertEquals("John", argument.getValue().getName());
 </code></pre>

 <b>警告：</b>建议对验证使用ArgumentCaptor， <b>但不要</b>对存根使用。结合存根使用ArgumentCaptor可能会降低测试的可读性，因为captor是在assert（aka verify或'then'）块之外创建的。同样，它可以减少缺陷的定位，因为如果未调用存根方法，则不会捕获任何参数。
 <p>在某种程度上，ArgumentCaptor与自定义参数匹配器相关（请参见javadoc <a href="../../org/mockito/ArgumentMatcher.html" title="org.mockito中的接口"><code>ArgumentMatcher</code></a>类）。两种技术都可用于确保将某些参数传递给模拟。但是，如果满足以下条件，则ArgumentCaptor可能更合适：</p><ul>
 <li>自定义参数匹配器不太可能被重用</li>
 <li>您只需要用它来声明参数值即可完成验证</li>
 </ul>自定义参数匹配器通过<a href="../../org/mockito/ArgumentMatcher.html" title="org.mockito中的接口"><code>ArgumentMatcher</code></a>通常更适合存根。




 <h3 id="16">16。<a class="meaningful_link" href="#partial_mocks" name="partial_mocks">真正的部分模拟</a> （自1.8.0开始）</h3>最后，在邮件列表上进行了许多内部辩论和讨论之后，Mockito添加了部分模拟支持。以前我们认为部分模拟是代码的味道。但是，我们发现了部分模拟的合法用例。
  <p>
  <b>版本1.8之前</b> <code>spy()</code>并没有产生真正的部分模拟，这对于一些用户来说是令人困惑的。阅读更多有关间谍的信息： <a href="#13">此处</a>或在javadoc中<a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a>方法。
  </p><p>
  </p><pre class="code"><code class="java">
    //you can create partial mock with spy() method:
    List list = spy(new LinkedList());

    //you can enable partial mock capabilities selectively on mocks:
    Foo mock = mock(Foo.class);
    //Be sure the real implementation is 'safe'.
    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
    when(mock.someMethod()).thenCallRealMethod();
  </code></pre>像往常一样，您将阅读<b>部分模拟警告</b> ：面向对象的编程通过将复杂度划分为单独的，特定的SRPy对象来解决复杂度问题。部分模拟如何适应这种范例？好吧，只是没有...部分模拟通常意味着复杂性已移至同一对象的不同方法。在大多数情况下，这不是您设计应用程序的方式。
 <p>但是，在少数情况下，局部模拟会派上用场：处理您无法轻松更改的代码（第三方接口，对遗留代码的临时重构等）但是，对于新的，测试驱动的和精心设计的代码，我不会使用局部模拟。




 </p><h3 id="17">17。<a class="meaningful_link" href="#resetting_mocks" name="resetting_mocks">重置模拟</a> （自1.8.0开始）</h3>聪明的Mockito用户几乎不使用此功能，因为他们知道这可能是测试不佳的迹象。通常，您无需重置模拟，只需为每个测试方法创建新的模拟即可。
 <p>代替<code>reset()</code>请考虑在冗长，过度指定的测试中编写简单，小型且重点突出的测试方法。
 <b>第一种潜在的代码气味是<code>reset()</code>在测试方法的中间。</b> 这可能意味着您正在测试太多。请遵循您的测试方法的耳语：“请保持我们的注意力小，并专注于单一行为”。在嘲笑邮件列表中有几个关于它的主题。
 </p><p>我们添加的唯一原因<code>reset()</code>方法是使处理容器注入的模拟成为可能。有关更多信息，请参见FAQ（ <a href="https://github.com/mockito/mockito/wiki/FAQ">此处</a> ）。
 </p><p>
 <b>不要伤害自己。</b> <code>reset()</code>测试方法的中间是代码异味（您可能测试得太多）。
 </p><pre class="code"><code class="java">
   List mock = mock(List.class);
   when(mock.size()).thenReturn(10);
   mock.add(1);

   reset(mock);
   //at this point the mock forgot any interactions & stubbing
 </code></pre>




 <h3 id="18">18岁<a class="meaningful_link" href="#framework_validation" name="framework_validation">故障排除和验证框架的使用</a> （自1.8.0开始）</h3>首先，如果有任何麻烦，我鼓励您阅读Mockito FAQ： <a href="https://github.com/mockito/mockito/wiki/FAQ">https</a> : <a href="https://github.com/mockito/mockito/wiki/FAQ">//github.com/mockito/mockito/wiki/FAQ</a>
 <p>如有疑问，您也可以张贴到模仿邮件列表： <a href="http://groups.google.com/group/mockito">http</a> : <a href="http://groups.google.com/group/mockito">//groups.google.com/group/mockito</a>
 </p><p>接下来，你应该知道，如果你正确地使用它<b>所有的时间</b>验证的Mockito。但是，有一个陷阱，所以请阅读javadoc <a href="../../org/mockito/Mockito.html#validateMockitoUsage--"><code>validateMockitoUsage()</code></a>




 </p><h3 id="19">19<a class="meaningful_link" href="#bdd_mockito" name="bdd_mockito">行为驱动开发的别名</a> （自1.8.0开始）</h3>行为驱动开发测试的风格使用<b>//给予//</b>注释， <b>然后将</b>注释作为测试方法的基本组成部分。这正是我们编写测试的方式，我们热烈鼓励您这样做！
 <p>从此处开始了解BDD： <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">http</a> ： <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">//en.wikipedia.org/wiki/Behavior_Driven_Development</a>
 </p><p>问题在于，当前的stub api具有规范的作用， <b>即</b> word不能与<b>// then / then / then</b>注释很好地集成在一起。这是因为存根属于测试的<b>给定</b>组件，而不属于测试的<b>when</b>组件。因此<a href="../../org/mockito/BDDMockito.html" title="org.mockito中的类"><code>BDDMockito</code></a>类引入了一个别名，以便您对方法调用进行存根<a href="../../org/mockito/BDDMockito.html#given-T-"><code>BDDMockito.given(Object)</code></a>方法。现在，它可以很好地与BDD样式测试的<b>给定</b>组件集成！
 </p><p>这是测试的样子：</p><pre class="code"><code class="java">
 import static org.mockito.BDDMockito.*;

 Seller seller = mock(Seller.class);
 Shop shop = new Shop(seller);

 public void shouldBuyBread() throws Exception {
   //given
   given(seller.askForBread()).willReturn(new Bread());

   //when
   Goods goods = shop.buyBread();

   //then
   assertThat(goods, containBread());
 }
 </code></pre>




 <h3 id="20">20<a class="meaningful_link" href="#serializable_mocks" name="serializable_mocks">可序列化的模拟</a> （自1.8.1开始）</h3>可以使模拟序列化。使用此功能，您可以在需要依赖项可序列化的地方使用模拟。
 <p>警告：这在单元测试中应该很少使用。
 </p><p>该行为是针对具有不可靠外部依赖关系的BDD规范的特定用例实现的。这是在Web环境中，来自外部依赖项的对象被序列化以在层之间传递。
 </p><p>创建可序列化的模拟使用<a href="../../org/mockito/MockSettings.html#serializable--"><code>MockSettings.serializable()</code></a> ：</p><pre class="code"><code class="java">
   List serializableMock = mock(List.class, withSettings().serializable());
 </code></pre>
 <p>假定类满足所有常规<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html">序列化要求，</a>则可以对模拟进行序列<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html">化</a> 。
 </p><p>使实际对象间谍程序可序列化会比较费力，因为spy（...）方法没有接受MockSettings的重载版本。不用担心，您几乎不会使用它。

 </p><pre class="code"><code class="java">
 List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
 List&lt;Object&gt; spy = mock(ArrayList.class, withSettings()
                 .spiedInstance(list)
                 .defaultAnswer(CALLS_REAL_METHODS)
                 .serializable());
 </code></pre>




 <h3 id="21">21新注释： <a class="meaningful_link" href="#captor_annotation" name="captor_annotation"><code>@Captor</code></a> ， <a class="meaningful_link" href="#spy_annotation" name="spy_annotation"><code>@Spy</code></a> ， <a class="meaningful_link" href="#injectmocks_annotation" name="injectmocks_annotation"><code>@InjectMocks</code></a> （从1.8.3版开始）</h3>

 <p>1.8.3版引入了新的注释，有时可能会有所帮助：</p><ul>
 <li>@ <a href="../../org/mockito/Captor.html" title="org.mockito中的注释"><code>Captor</code></a>简化了<a href="../../org/mockito/ArgumentCaptor.html" title="org.mockito中的类"><code>ArgumentCaptor</code></a> -当要捕获的参数是一个讨厌的泛型类并且您想要避免编译器警告时很有用</li><li>@ <a href="../../org/mockito/Spy.html" title="org.mockito中的注释"><code>Spy</code></a> -您可以改用它<a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a> 。
 </li><li>@ <a href="../../org/mockito/InjectMocks.html" title="org.mockito中的注释"><code>InjectMocks</code></a> -自动将模拟或间谍字段注入测试对象。
 </li></ul>

 <p>注意 @ <a href="../../org/mockito/InjectMocks.html" title="org.mockito中的注释"><code>InjectMocks</code></a>也可以与@结合使用<a href="../../org/mockito/Spy.html" title="org.mockito中的注释"><code>Spy</code></a>批注，这意味着Mockito将把模拟注入被测的部分模拟中。这种复杂性是为什么只应将部分模拟作为最后的选择的另一个很好的理由。有关部分模拟的信息，请参见第16点。

 </p><p>所有新注解<b>仅在*上</b>处理<a href="../../org/mockito/MockitoAnnotations.html#initMocks-java.lang.Object-"><code>MockitoAnnotations.initMocks(Object)</code></a> 。就像@ <a href="../../org/mockito/Mock.html" title="org.mockito中的注释"><code>Mock</code></a>注释，您可以使用内置的运行器： <a href="../../org/mockito/junit/MockitoJUnitRunner.html" title="org.mockito.junit中的类"><code>MockitoJUnitRunner</code></a>或规则： <a href="../../org/mockito/junit/MockitoRule.html" title="org.mockito.junit中的接口"><code>MockitoRule</code></a> 。
 </p><p>




 </p><h3 id="22">22<a class="meaningful_link" href="#verification_timeout" name="verification_timeout">超时验证</a> （自1.8.5开始）</h3>
 <p>允许验证超时。它使验证等待指定的时间段以进行所需的交互，而不是如果尚未发生则立即失败。在并发条件下进行测试可能有用。
 </p><p>很少使用此功能-找出测试多线程系统的更好方法。
 </p><p>尚未实现与InOrder验证一起使用。
 </p><p>例子：</p><p>
 </p><pre class="code"><code class="java">
   //passes when someMethod() is called no later than within 100 ms
   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
   verify(mock, timeout(Duration.ofMillis(100))).someMethod();
   //above is an alias to:
   verify(mock, timeout(Duration.ofMillis(100)).times(1)).someMethod();

   //passes as soon as someMethod() has been called 2 times under 100 ms
   verify(mock, timeout(Duration.ofMillis(100)).times(2)).someMethod();

   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
   verify(mock, timeout(Duration.ofMillis(100)).atLeast(2)).someMethod();
 </code></pre>




 <h3 id="23">23。<a class="meaningful_link" href="#automatic_instantiation" name="automatic_instantiation">自动实例化<code>@Spies</code> ， <code>@InjectMocks</code></a>和<a class="meaningful_link" href="#constructor_injection" name="constructor_injection">构造函数注入优度</a> （自1.9.0开始）</h3>

 <p>Mockito现在将尝试实例化@ <a href="../../org/mockito/Spy.html" title="org.mockito中的注释"><code>Spy</code></a>并实例化@ <a href="../../org/mockito/InjectMocks.html" title="org.mockito中的注释"><code>InjectMocks</code></a>使用<b>构造函数</b>注入， <b>setter</b>注入或<b>字段</b>注入的<b>字段</b> 。
 </p><p>要利用此功能，您需要使用<a href="../../org/mockito/MockitoAnnotations.html#initMocks-java.lang.Object-"><code>MockitoAnnotations.initMocks(Object)</code></a> ， <a href="../../org/mockito/junit/MockitoJUnitRunner.html" title="org.mockito.junit中的类"><code>MockitoJUnitRunner</code></a>要么<a href="../../org/mockito/junit/MockitoRule.html" title="org.mockito.junit中的接口"><code>MockitoRule</code></a> 。
 </p><p>在javadoc中阅读有关可用技巧和注入规则的更多信息，以了解<a href="../../org/mockito/InjectMocks.html" title="org.mockito中的注释"><code>InjectMocks</code></a>
 </p><pre class="code"><code class="java">
 //instead:
 &#064;Spy BeerDrinker drinker = new BeerDrinker();
 //you can write:
 &#064;Spy BeerDrinker drinker;

 //same applies to &#064;InjectMocks annotation:
 &#064;InjectMocks LocalPub;
 </code></pre>




 <h3 id="24">24单线<a class="meaningful_link" href="#one_liner_stub" name="one_liner_stub">存根</a> （自1.9.0起）</h3>
 <p>Mockito现在将允许您在存根时创建模拟。基本上，它允许在一行代码中创建存根。这有助于保持测试代码的清洁。例如，一些无聊的存根可以在测试中的字段初始化时创建和存根：</p><pre class="code"><code class="java">
 public class CarTest {
   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();

   &#064;Test public void should... {}
 </code></pre>




 <h3 id="25">25<a class="meaningful_link" href="#ignore_stubs_verification" name="ignore_stubs_verification">忽略存根的验证</a> （自1.9.0开始）</h3>
 <p>为了进行验证，Mockito现在将允许忽略存根。有时与<code>verifyNoMoreInteractions()</code>或验证<code>inOrder()</code> 。帮助避免对存根调用进行冗余验证-通常我们对验证存根不感兴趣。
 </p><p>
 <b>警告</b> ， <code>ignoreStubs()</code>可能导致滥用verifyNoMoreInteractions（ignoreStubs（...））;请记住，Mockito建议不要使用<code>verifyNoMoreInteractions()</code>由于javadoc中概述的原因<a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions-java.lang.Object...-"><code>verifyNoMoreInteractions(Object...)</code></a>
 </p><p>一些例子：</p><pre class="code"><code class="java">
 verify(mock).foo();
 verify(mockTwo).bar();

 //ignores all stubbed methods:
 verifyNoMoreInteractions(ignoreStubs(mock, mockTwo));

 //creates InOrder that will ignore stubbed
 InOrder inOrder = inOrder(ignoreStubs(mock, mockTwo));
 inOrder.verify(mock).foo();
 inOrder.verify(mockTwo).bar();
 inOrder.verifyNoMoreInteractions();
 </code></pre>
 <p>可以在javadoc中找到高级示例和更多详细信息，以获取更多信息。 <a href="../../org/mockito/Mockito.html#ignoreStubs-java.lang.Object...-"><code>ignoreStubs(Object...)</code></a>




 </p><h3 id="26">26<a class="meaningful_link" href="#mocking_details" name="mocking_details">模拟详细信息</a> （在2.2.x中已改进）</h3>
 <p>Mockito提供API来检查模拟对象的详细信息。该API对高级用户和模拟框架集成商很有用。

 </p><pre class="code"><code class="java">
   //To identify whether a particular object is a mock or a spy:
   Mockito.mockingDetails(someObject).isMock();
   Mockito.mockingDetails(someObject).isSpy();

   //Getting details like type to mock or default answer:
   MockingDetails details = mockingDetails(mock);
   details.getMockCreationSettings().getTypeToMock();
   details.getMockCreationSettings().getDefaultAnswer();

   //Getting invocations and stubbings of the mock:
   MockingDetails details = mockingDetails(mock);
   details.getInvocations();
   details.getStubbings();

   //Printing all interactions (including stubbing, unused stubs)
   System.out.println(mockingDetails(mock).printInvocations());
 </code></pre>有关更多信息，请参见javadoc。 <a href="../../org/mockito/MockingDetails.html" title="org.mockito中的接口"><code>MockingDetails</code></a> 。

 <h3 id="27">27。<a class="meaningful_link" href="#delegating_call_to_real_instance" name="delegating_call_to_real_instance">将调用委托给真实实例</a> （自1.9.5开始）</h3>

 <p>对于<strong>无法</strong>使用常规间谍API <strong>进行模拟或间谍</strong>的对象的间谍或部分<strong>模拟</strong>很有用。从Mockito 1.10.11开始，委托的类型可以与模拟的类型相同或不相同。如果类型不同，则需要在委托类型上找到匹配的方法，否则将引发异常。此功能可能的用例：</p><ul>
     <li>期末课程但有接口</li>
     <li>已经自定义的代理对象</li>
     <li>带有finalize方法的特殊对象，即避免执行两次</li>
 </ul>

 <p>与常规间谍的区别：</p><ul>
   <li>常规间谍（ <a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a> ）包含间谍实例的<strong>所有</strong>状态，并且在间谍程序上调用方法。间谍实例仅在模拟创建时用于从中复制状态。如果您在常规间谍上调用一个方法，并且在内部在此间谍上调用其他方法，则这些调用将被记住以进行验证，并且可以有效地对它们进行打桩。
   </li>
   <li>委托的模拟仅将所有方法委托给委托。由于将方法委托给它，因此一直使用委托。如果您在委托的模拟对象上调用一个方法，并且在内部对该模拟对象调用其他方法，则这些调用将<strong>不会被</strong>记住以进行验证，存根对其也不会产生影响。委托的模拟功能不如常规间谍强大，但在无法创建常规间谍时很有用。
   </li>
 </ul>

 <p>在docs中查看更多信息<a href="../../org/mockito/AdditionalAnswers.html#delegatesTo-java.lang.Object-"><code>AdditionalAnswers.delegatesTo(Object)</code></a> 。




 </p><h3 id="28">28。 <a class="meaningful_link" href="#mock_maker_plugin" name="mock_maker_plugin"><code>MockMaker</code>API</a> （自1.9.5开始）</h3>
 <p>在Google Android专家的要求和补丁的推动下，Mockito现在提供了一个扩展点，可以替换代理生成引擎。默认情况下，Mockito使用<a href="https://github.com/raphw/byte-buddy">Byte Buddy</a>创建动态代理。
 </p><p>扩展点适用于想要扩展Mockito的高级用户。例如，现在可以使用针对的Mockito Android版的帮助测试<a href="https://github.com/crittercism/dexmaker">dexmaker</a> 。
 </p><p>有关更多详细信息，动机和示例，请参阅文档以获取更多信息。 <a href="../../org/mockito/plugins/MockMaker.html" title="org.mockito.plugins中的接口"><code>MockMaker</code></a> 。




 </p><h3 id="29">29。<a class="meaningful_link" href="#BDD_behavior_verification" name="BDD_behavior_verification">BDD样式验证</a> （自1.10.0开始）</h3>通过使用BDD <b>then</b>关键字开始验证来启用行为驱动开发（BDD）样式验证。

 <pre class="code"><code class="java">
 given(dog.bark()).willReturn(2);

 // when
 ...

 then(person).should(times(2)).ride(bike);
 </code></pre>有关更多信息和示例，请参见<a href="../../org/mockito/BDDMockito.html#then-T-"><code>BDDMockito.then(Object)</code></a>




 <h3 id="30">30岁<a class="meaningful_link" href="#spying_abstract_classes" name="spying_abstract_classes">监视或嘲笑抽象类（自1.10.12开始，在2.7.13和2.7.14中进一步增强）</a></h3>现在可以方便地监视抽象类。请注意，过度使用间谍会暗示代码设计的气味（请参阅<a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a> ）。
 <p>以前，只能在对象实例上进行间谍活动。新的API可以在创建模拟实例时使用构造函数。这对于模拟抽象类特别有用，因为不再需要用户提供抽象类的实例。目前，仅支持无参数构造函数，如果不够的话，请通知我们。

 </p><pre class="code"><code class="java">
 //convenience API, new overloaded spy() method:
 SomeAbstract spy = spy(SomeAbstract.class);

 //Mocking abstract methods, spying default methods of an interface (only available since 2.7.13)
 Function<Foo, Bar> function = spy(Function.class);

 //Robust API, via settings builder:
 OtherAbstract spy = mock(OtherAbstract.class, withSettings()
    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));

 //Mocking an abstract class with constructor arguments (only available since 2.7.14)
 SomeAbstract spy = mock(SomeAbstract.class, withSettings()
   .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));

 //Mocking a non-static inner abstract class:
 InnerAbstract spy = mock(InnerAbstract.class, withSettings()
    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
 </code></pre>有关更多信息，请参见<a href="../../org/mockito/MockSettings.html#useConstructor-java.lang.Object...-"><code>MockSettings.useConstructor(Object...)</code></a> 。




 <h3 id="31">31。<a class="meaningful_link" href="#serilization_across_classloader" name="serilization_across_classloader">Mockito模拟可以在类加载器中<em>序列化</em> / <em>反</em> <em>序列化</em> （自1.10.0开始）</a></h3>Mockito引入了跨类加载器的序列化。像任何其他形式的序列化一样，模拟层次结构中的所有类型都必须可序列化，包括答案。由于此序列化模式需要大量工作，因此这是一个启用设置。

 <pre class="code"><code class="java">
 // use regular serialization
 mock(Book.class, withSettings().serializable());

 // use serialization across classloaders
 mock(Book.class, withSettings().serializable(ACROSS_CLASSLOADERS));
 </code></pre>有关更多详细信息，请参见<a href="../../org/mockito/MockSettings.html#serializable-org.mockito.mock.SerializableMode-"><code>MockSettings.serializable(SerializableMode)</code></a> 。




 <h3 id="32">32。<a class="meaningful_link" href="#better_generic_support_with_deep_stubs" name="better_generic_support_with_deep_stubs">带有深层存根的更好的通用支持（自1.10.0开始）</a></h3>深度桩技术已得到改进，可以在该类中找到通用信息。这意味着可以使用这样的类而不必模拟行为。

 <pre class="code"><code class="java">
 class Lines extends List&lt;Line&gt; {
     // ...
 }

 lines = mock(Lines.class, RETURNS_DEEP_STUBS);

 // Now Mockito understand this is not an Object but a Line
 Line line = lines.iterator().next();
 </code></pre>请注意，在大多数情况下，将模拟返回模拟是错误的。




 <h3 id="33">33。<a class="meaningful_link" href="#mockito_junit_rule" name="mockito_junit_rule">Mockito JUnit规则（自1.10.17开始）</a></h3>Mockito现在提供了一个JUnit规则。到目前为止，在JUnit中，有两种方法可以初始化由Mockito注释注释的字段，例如<code>@<a href="../../org/mockito/Mock.html" title="annotation in org.mockito"><code>Mock</code></a></code> ， <code>@<a href="../../org/mockito/Spy.html" title="annotation in org.mockito"><code>Spy</code></a></code> ， <code>@<a href="../../org/mockito/InjectMocks.html" title="annotation in org.mockito"><code>InjectMocks</code></a></code>等<ul>
     <li>用一个注解JUnit测试类<code>@<code>RunWith</code>(<a href="../../org/mockito/junit/MockitoJUnitRunner.html" title="class in org.mockito.junit"><code>MockitoJUnitRunner</code></a>.class)</code></li>
     <li>调用中<code><a href="../../org/mockito/MockitoAnnotations.html#initMocks-java.lang.Object-"><code>MockitoAnnotations.initMocks(Object)</code></a></code>在里面<code>@<code>Before</code></code>方法</li>
 </ul>现在您可以选择使用规则：<pre class="code"><code class="java">
 &#064;RunWith(YetAnotherRunner.class)
 public class TheTest {
     &#064;Rule public MockitoRule mockito = MockitoJUnit.rule();
     // ...
 }
 </code></pre>有关更多信息，请参见<a href="../../org/mockito/junit/MockitoJUnit.html#rule--"><code>MockitoJUnit.rule()</code></a> 。




 <h3 id="34">34。<a class="meaningful_link" href="#plugin_switch" name="plugin_switch"><em>打开</em>或<em>关闭</em>插件（自1.10.15开始）</a></h3>孵化功能使它成为了模仿者，可以切换模仿者插件。更多信息在这里<a href="../../org/mockito/plugins/PluginSwitch.html" title="org.mockito.plugins中的接口"><code>PluginSwitch</code></a> 。


 <h3 id="35">35岁<a class="meaningful_link" href="#Custom_verification_failure_message" name="Custom_verification_failure_message">自定义验证失败消息</a> （自2.1.0开始）</h3>
 <p>如果验证失败，则允许指定要打印的自定义消息。
 </p><p>例子：</p><p>
 </p><pre class="code"><code class="java">

 // will print a custom message on verification failure
 verify(mock, description("This will print on failure")).someMethod();

 // will work with any verification mode
 verify(mock, times(2).description("someMethod should be called twice")).someMethod();
 </code></pre>

 <h3 id="36">36。<a class="meaningful_link" href="#Java_8_Lambda_Matching" name="Java_8_Lambda_Matching">Java 8 Lambda Matcher支持</a> （自2.1.0开始）</h3>
 <p>您可以将Java 8 lambda表达式与<a href="../../org/mockito/ArgumentMatcher.html" title="org.mockito中的接口"><code>ArgumentMatcher</code></a>减少对<a href="../../org/mockito/ArgumentCaptor.html" title="org.mockito中的类"><code>ArgumentCaptor</code></a> 。如果您需要验证对模拟函数调用的输入是否正确，则通常可以使用<a href="../../org/mockito/ArgumentCaptor.html" title="org.mockito中的类"><code>ArgumentCaptor</code></a>查找所使用的操作数，然后对其进行后续声明。虽然对于复杂的示例来说这可能是有用的，但也很费劲。</p><p>编写lambda表示比赛很容易。与argThat一起使用时，函数的参数将作为强类型对象传递给ArgumentMatcher，因此可以执行任何操作。
 </p><p>例子：</p><p>
 </p><pre class="code"><code class="java">

 // verify a list only had strings of a certain length added to it
 // note - this will only compile under Java 8
 verify(list, times(2)).add(argThat(string -> string.length() < 5));

 // Java 7 equivalent - not as neat
 verify(list, times(2)).add(argThat(new ArgumentMatcher<String>(){
     public boolean matches(String arg) {
         return arg.length() < 5;
     }
 }));

 // more complex Java 8 example - where you can specify complex verification behaviour functionally
 verify(target, times(1)).receiveComplexObject(argThat(obj -> obj.getSubObject().get(0).equals("expected")));

 // this can also be used when defining the behaviour of a mock under different inputs
 // in this case if the input list was fewer than 3 items the mock returns null
 when(mock.someMethod(argThat(list -> list.size()<3))).thenReturn(null);
 </code></pre>

 <h3 id="37">37。<a class="meaningful_link" href="#Java_8_Custom_Answers" name="Java_8_Custom_Answers">Java 8自定义答案支持</a> （自2.1.0开始）</h3>
 <p>作为<a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a>接口只有一种方法，对于非常简单的情况，已经可以使用lambda表达式在Java 8中实现它。您需要使用方法调用的参数的次数越多，则从中键入参数的次数就越多。 <a href="../../org/mockito/invocation/InvocationOnMock.html" title="org.mockito.invocation中的接口"><code>InvocationOnMock</code></a> 。

 </p><p>例子：</p><p>
 </p><pre class="code"><code class="java">
 // answer by returning 12 every time
 doAnswer(invocation -> 12).when(mock).doSomething();

 // answer by using one of the parameters - converting into the right
 // type as your go - in this case, returning the length of the second string parameter
 // as the answer. This gets long-winded quickly, with casting of parameters.
 doAnswer(invocation -> ((String)invocation.getArgument(1)).length())
     .when(mock).doSomething(anyString(), anyString(), anyString());
 </code></pre>为方便起见，可以将自定义答案/操作编写为Java 8 lambda，使用方法调用的参数。即使在Java 7和更低版本中，这些基于类型化接口的自定义答案也可以减少样板。特别是，这种方法将使测试使用回调的函数更加容易。方法<a href="../../org/mockito/AdditionalAnswers.html#answer-org.mockito.stubbing.Answer1-"><code>answer</code></a>和<a href="../../org/mockito/AdditionalAnswers.html#answerVoid-org.mockito.stubbing.VoidAnswer1-"><code>answerVoid</code></a>可用于创建答案。他们依赖于相关的答案界面<code>org.mockito.stubbing</code>支持最多5个参数。

 <p>例子：</p><p>
 </p><pre class="code"><code class="java">

 // Example interface to be mocked has a function like:
 void execute(String operand, Callback callback);

 // the example callback has a function and the class under test
 // will depend on the callback being invoked
 void receive(String item);

 // Java 8 - style 1
 doAnswer(AdditionalAnswers.<String,Callback>answerVoid((operand, callback) -> callback.receive("dummy"))
     .when(mock).execute(anyString(), any(Callback.class));

 // Java 8 - style 2 - assuming static import of AdditionalAnswers
 doAnswer(answerVoid((String operand, Callback callback) -> callback.receive("dummy"))
     .when(mock).execute(anyString(), any(Callback.class));

 // Java 8 - style 3 - where mocking function to is a static member of test class
 private static void dummyCallbackImpl(String operation, Callback callback) {
     callback.receive("dummy");
 }

 doAnswer(answerVoid(TestClass::dummyCallbackImpl)
     .when(mock).execute(anyString(), any(Callback.class));

 // Java 7
 doAnswer(answerVoid(new VoidAnswer2<String, Callback>() {
     public void answer(String operation, Callback callback) {
         callback.receive("dummy");
     }})).when(mock).execute(anyString(), any(Callback.class));

 // returning a value is possible with the answer() function
 // and the non-void version of the functional interfaces
 // so if the mock interface had a method like
 boolean isSameString(String input1, String input2);

 // this could be mocked
 // Java 8
 doAnswer(AdditionalAnswers.<Boolean,String,String>answer((input1, input2) -> input1.equals(input2))))
     .when(mock).execute(anyString(), anyString());

 // Java 7
 doAnswer(answer(new Answer2<String, String, String>() {
     public String answer(String input1, String input2) {
         return input1 + input2;
     }})).when(mock).execute(anyString(), anyString());
 </code></pre>

 <h3 id="38">38。<a class="meaningful_link" href="#Meta_Data_And_Generics" name="Meta_Data_And_Generics">元数据和通用类型保留</a> （自2.1.0开始）</h3>

 <p>现在，Mockito保留关于模拟方法和类型以及通用元数据的注释。以前，模拟类型不会保留类型的注释，除非它们被显式继承并且永远不会在方法上保留注释。因此，现在满足以下条件：</p><pre class="code"><code class="java">
 @<code>MyAnnotation
  class Foo {
    List&lt;String&gt; bar() { ... }
  }

  Class&lt;?&gt; mockType = mock(Foo.class).getClass();
  assert mockType.isAnnotationPresent(MyAnnotation.class);
  assert mockType.getDeclaredMethod("bar").getGenericReturnType() instanceof ParameterizedType;
 </code></code></pre>

 <p>使用Java 8时，Mockito现在还保留类型注释。这是默认行为， <a href="#28">如果替代方法</a>可能不成立<a href="../../org/mockito/plugins/MockMaker.html" title="org.mockito.plugins中的接口"><code>MockMaker</code></a>用来。

 </p><h3 id="39">39。<a class="meaningful_link" href="#Mocking_Final" name="Mocking_Final">模拟最终类型，枚举和最终方法</a> （自2.1.0开始）</h3>Mockito现在提供了<a href="../../org/mockito/Incubating.html" title="org.mockito中的注释"><code>Incubating</code></a> ，对模拟最终类和方法的可选支持。这是一个了不起的改进，表明了Mockito不断追求改善测试体验的追求。我们的目标是使Mockito与最终的类和方法“兼容”。以前，它们被认为是<em>不可模仿的</em> ，可以防止用户嘲笑。我们已经开始讨论如何默认启用此功能。目前，该功能仍然是可选功能，因为我们等待社区提供更多反馈。

 <p>这种替代的模拟制作器，它结合使用Java工具API和子类，而不是创建一个新类来表示模拟。这样，就有可能模拟最终类型和方法。

 </p><p><strong>默认情况下，</strong>此模拟生成器<strong>处于关闭状态，</strong>因为它基于完全不同的模拟机制，需要社区提供更多反馈。可以通过模仿扩展机制显式激活它，只需在类路径中创建一个文件<code>/mockito-extensions/org.mockito.plugins.MockMaker</code>包含价值<code>mock-maker-inline</code> 。

 </p><p>为方便起见，Mockito团队提供了一个工件，在此工件中已预先配置了该模拟设备。不要在您的项目中包含<i>模仿嵌入式内在</i>工件，而不必使用<i>模仿核心</i>工件。请注意，一旦将最终类和方法的模拟集成到默认的模拟生成器中，则该工件可能会中断。

 </p><p>关于此模拟制作器的一些值得注意的注意事项：</p><ul>
     <li>模拟最终类型和枚举与模拟设置不兼容：<ul>
         <li>明确的序列化支持<code>withSettings().serializable()</code></li>
         <li>额外接口<code>withSettings().extraInterfaces()</code></li>
     </ul>
     </li>
     <li>某些方法无法模拟<ul>
              <li>包可见的方法<code>java.*</code></li>
              <li><code>native</code>方法</li>
         </ul>
     </li>
     <li>这个模拟制造器是围绕Java Agent运行时附件设计的;这需要兼容的JVM，它是JDK（或Java 9 VM）的一部分。在Java 9之前的非JDK VM上运行时，可以使用以下命令手动添加<a href="http://bytebuddy.net">Byte Buddy Java代理jar</a> <code>-javaagent</code>启动JVM时的参数。</li>
 </ul>

 <p>如果您对此功能的更多详细信息感兴趣，请阅读<code>org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker</code>

 </p><h3 id="40">40<a class="meaningful_link" href="#strict_mockito" name="strict_mockito">使用“更严格”的Mockito</a> （从2开始， <a class="meaningful_link" href="#strict_mockito" name="strict_mockito">提高了生产率和更清洁的测试）</a> 。+）</h3>要快速了解“更严格”的Mockito如何使您生产率更高并使测试更清洁，请参阅：<ul>
     <li>使用JUnit规则进行严格的存根- <a href="../../org/mockito/junit/MockitoRule.html#strictness-org.mockito.quality.Strictness-"><code>MockitoRule.strictness(Strictness)</code></a>与<a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a></li>
     <li>使用JUnit Runner进行严格的存根-<code>MockitoJUnitRunner.StrictStubs</code></li>
     <li>如果您无法使用流道/规则，则进行严格的存根（例如TestNG）-<a href="../../org/mockito/MockitoSession.html" title="org.mockito中的接口"><code>MockitoSession</code></a></li>
     <li>不必要的存根检测<a href="../../org/mockito/junit/MockitoJUnitRunner.html" title="org.mockito.junit中的类"><code>MockitoJUnitRunner</code></a></li>
     <li>存根参数不匹配警告，记录在<a href="../../org/mockito/quality/MockitoHint.html" title="org.mockito.quality中的接口"><code>MockitoHint</code></a></li>
 </ul>默认情况下，Mockito是一个“松散”的模拟框架。无需事先设定任何期望就可以与人互动。这是有意的，它通过强制用户明确表示要存根/验证的内容，从而提高了测试质量。它也非常直观，易于使用，并与干净的测试代码的“给定”，“何时”，“然后”模板很好地融合在一起。这也与过去的经典模拟框架不同，默认情况下它们是“严格的”。
 <p>默认情况下处于“宽松”状态会使Mockito测试有时难以调试。在某些情况下，配置错误的存根（例如使用错误的参数）会迫使用户使用调试器运行测试。理想情况下，测试失败是立即显而易见的，不需要调试器来确定根本原因。从2.1版开始，Mockito已获得使框架趋向“严格”的新功能。我们希望Mockito提供出色的可调试性，同时又不失其核心的模拟风格，为直观，明确和干净的测试代码进行了优化。
 </p><p>帮助Mockito！尝试新功能，给我们反馈，并加入有关GitHub <a href="https://github.com/mockito/mockito/issues/769">第769期</a>有关Mockito严格性的讨论。

 </p><h3 id="41">41。<a class="meaningful_link" href="#framework_integrations_api" name="framework_integrations_api">用于框架集成的高级公共API（自2.10开始。+）</a></h3>在2017年夏季，我们决定Mockito <a href="https://www.linkedin.com/pulse/mockito-vs-powermock-opinionated-dogmatic-static-mocking-faber">应该</a>为高级框架集成<a href="https://www.linkedin.com/pulse/mockito-vs-powermock-opinionated-dogmatic-static-mocking-faber">提供更好的API</a> 。新的API不适合想要编写单元测试的用户。它用于需要使用某些自定义逻辑扩展或包装Mockito的其他测试工具和模拟框架。在设计和实施过程中（ <a href="https://github.com/mockito/mockito/issues/1110">问题1110</a> ），我们开发并更改了以下公共API元素：<ul>
     <li>新<a href="../../org/mockito/plugins/MockitoPlugins.html" title="org.mockito.plugins中的接口"><code>MockitoPlugins</code></a> -使框架集成商可以访问默认的Mockito插件。当需要实现自定义插件时很有用<a href="../../org/mockito/plugins/MockMaker.html" title="org.mockito.plugins中的接口"><code>MockMaker</code></a>并将某些行为委派给默认的Mockito实现。
     </li>
     <li>新<a href="../../org/mockito/MockSettings.html#build-java.lang.Class-"><code>MockSettings.build(Class)</code></a> -创建稍后由Mockito使用的模拟设置的不变视图。对于创建调用非常有用<a href="../../org/mockito/invocation/InvocationFactory.html" title="org.mockito.invocation中的接口"><code>InvocationFactory</code></a>或实施自定义时<a href="../../org/mockito/invocation/MockHandler.html" title="org.mockito.invocation中的接口"><code>MockHandler</code></a> 。
     </li>
     <li>新<a href="../../org/mockito/MockingDetails.html#getMockHandler--"><code>MockingDetails.getMockHandler()</code></a> -其他框架可能使用模拟处理程序以编程方式模拟对模拟对象的调用。
     </li>
     <li>新<a href="../../org/mockito/invocation/MockHandler.html#getMockSettings--"><code>MockHandler.getMockSettings()</code></a> -有助于掌握创建模拟对象的设置。
     </li>
     <li>新<a href="../../org/mockito/invocation/InvocationFactory.html" title="org.mockito.invocation中的接口"><code>InvocationFactory</code></a> -提供创建实例的方法<a href="../../org/mockito/invocation/Invocation.html" title="org.mockito.invocation中的接口"><code>Invocation</code></a>对象。对于需要以编程方式模拟模拟对象上的方法调用的框架集成很有用。
     </li>
     <li>新<a href="../../org/mockito/invocation/MockHandler.html#getInvocationContainer--"><code>MockHandler.getInvocationContainer()</code></a> -提供对没有方法的调用容器对象的访问（标记接口）。需要容器来隐藏内部实现，并避免将其泄漏给公共API。</li>
     <li>已变更<a href="../../org/mockito/stubbing/Stubbing.html" title="org.mockito.stubbing中的接口"><code>Stubbing</code></a> -现在扩展<a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a>接口。它是向后兼容的，因为Stubbing接口是不可扩展的（请参见<a href="../../org/mockito/NotExtensible.html" title="org.mockito中的注释"><code>NotExtensible</code></a> ）。更改对我们的用户应该是无缝的。
     </li>
     <li>不推荐使用<code>InternalMockHandler</code> -为了适应API的更改，我们需要弃用此接口。该接口始终被记录为内部接口，我们没有证据表明该接口已被社区使用。对于我们的用户，弃用应该是完全无缝的。
     </li>
     <li><a href="../../org/mockito/NotExtensible.html" title="org.mockito中的注释"><code>NotExtensible</code></a> -公共注释，向用户指示她不应该提供给定类型的自定义实现。帮助框架集成商和我们的用户了解如何安全地使用Mockito API。
     </li>
 </ul>您有意见吗？请在<a href="https://github.com/mockito/mockito/issues/1110">问题1110中</a>发表评论。

 <h3 id="42">42。<a class="meaningful_link" href="#verifiation_started_listener" name="verifiation_started_listener">集成的新API：监听验证开始事件（自2.11开始。+）</a></h3>诸如<a href="https://projects.spring.io/spring-boot">Spring Boot之</a>类的框架集成需要公共API才能解决双重代理用例（ <a href="https://github.com/mockito/mockito/issues/1191">问题1191</a> ）。我们添加了：<ul>
     <li>新<a href="../../org/mockito/listeners/VerificationStartedListener.html" title="org.mockito.listeners中的接口"><code>VerificationStartedListener</code></a>和<a href="../../org/mockito/listeners/VerificationStartedEvent.html" title="org.mockito.listeners中的接口"><code>VerificationStartedEvent</code></a>使框架集成商可以替换模拟对象进行验证。主要的驱动用例是<a href="https://projects.spring.io/spring-boot/">Spring Boot</a>集成。有关详细信息，请参见Javadoc。 <a href="../../org/mockito/listeners/VerificationStartedListener.html" title="org.mockito.listeners中的接口"><code>VerificationStartedListener</code></a> 。
     </li>
     <li>新的公开方法<a href="../../org/mockito/MockSettings.html#verificationStartedListeners-org.mockito.listeners.VerificationStartedListener...-"><code>MockSettings.verificationStartedListeners(VerificationStartedListener...)</code></a>允许在模拟创建时提供验证开始的侦听器。
     </li>
     <li>方便的新方法<a href="../../org/mockito/MockingDetails.html#getMock--"><code>MockingDetails.getMock()</code></a>被添加以使<code>MockingDetails</code> API更完整。我们发现此方法在实施过程中很有用。
     </li>
 </ul>

 <h3 id="43">43。<a class="meaningful_link" href="#mockito_session_testing_frameworks" name="mockito_session_testing_frameworks">新的集成API： <code>MockitoSession</code>可用于测试框架（自2.15开始。+）</a></h3>

 <p><a href="../../org/mockito/session/MockitoSessionBuilder.html" title="org.mockito.session中的接口"><code>MockitoSessionBuilder</code></a>和<a href="../../org/mockito/MockitoSession.html" title="org.mockito中的接口"><code>MockitoSession</code></a>通过测试框架集成进行了增强以实现重用（例如， <a href="../../org/mockito/junit/MockitoRule.html" title="org.mockito.junit中的接口"><code>MockitoRule</code></a>对于JUnit）：</p>
 <ul>
     <li><a href="../../org/mockito/session/MockitoSessionBuilder.html#initMocks-java.lang.Object...-"><code>MockitoSessionBuilder.initMocks(Object...)</code></a>允许传入多个测试类实例以初始化带有Mockito批注的批注字段，例如<a href="../../org/mockito/Mock.html" title="org.mockito中的注释"><code>Mock</code></a> 。当测试使用多个（例如嵌套的）测试类实例时，此方法对于高级框架集成（例如JUnit Jupiter）很有用。
     </li>
     <li><a href="../../org/mockito/session/MockitoSessionBuilder.html#name-java.lang.String-"><code>MockitoSessionBuilder.name(String)</code></a>允许将名称从测试框架传递给<a href="../../org/mockito/MockitoSession.html" title="org.mockito中的接口"><code>MockitoSession</code></a>在以下情况下将用于打印警告<a href="../../org/mockito/quality/Strictness.html#WARN"><code>Strictness.WARN</code></a>用来。
     </li>
     <li><a href="../../org/mockito/session/MockitoSessionBuilder.html#logger-org.mockito.session.MockitoSessionLogger-"><code>MockitoSessionBuilder.logger(MockitoSessionLogger)</code></a>可以自定义用于完成模拟时产生的提示/警告的记录器（用于测试，并连接测试框架（如JUnit Jupiter）提供的报告功能）。
     </li>
     <li><a href="../../org/mockito/MockitoSession.html#setStrictness-org.mockito.quality.Strictness-"><code>MockitoSession.setStrictness(Strictness)</code></a>允许改变一个的严格性<a href="../../org/mockito/MockitoSession.html" title="org.mockito中的接口"><code>MockitoSession</code></a>对于一次性场景，例如，它可以为一个类中的所有测试配置默认严格度，但可以更改单个或几个测试的严格度。
     </li>
     <li><a href="../../org/mockito/MockitoSession.html#finishMocking-java.lang.Throwable-"><code>MockitoSession.finishMocking(Throwable)</code></a>为了避免由于多个竞争性失败而引起的混乱，我们添加了。当提供的<em>故障</em>不存在时，它将禁用某些检查<code>null</code> 。
     </li>
 </ul>

 <h3 id="44">44。<a class="meaningful_link" href="#mockito_instantiator_provider_deprecation" name="mockito_instantiator_provider_deprecation">不推荐使用<code>org.mockito.plugins.InstantiatorProvider</code>因为它泄漏了内部API。它被替换为<code>org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)</code></a></h3>

 <p><a href="../../org/mockito/plugins/InstantiatorProvider.html" title="org.mockito.plugins中的接口"><code>InstantiatorProvider</code></a>返回内部API。因此，它已被弃用并替换为<a href="../../org/mockito/plugins/InstantiatorProvider2.html" title="org.mockito.plugins中的接口"><code>InstantiatorProvider2</code></a> 。旧<a href="../../org/mockito/plugins/InstantiatorProvider.html" title="org.mockito.plugins中的接口"><code>instantiator providers</code></a>将继续工作，但建议切换到新的API。</p>

 <h3 id="45">45。<a class="meaningful_link" href="#junit5_mockito" name="junit5_mockito">新的JUnit Jupiter（JUnit5 +）扩展</a></h3>为了与JUnit Jupiter（JUnit5 +）集成，请使用org.mockito：mockito-junit-jupiter工件。有关整合的用法的详细信息，请参阅<a href="http://javadoc.io/doc/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html">的的JavaDoc <code>MockitoExtension</code></a> 。

 <h3 id="46">46。<a class="meaningful_link" href="#mockito_lenient" name="mockito_lenient">新<code>Mockito.lenient()</code>和<code>MockSettings.lenient()</code>方法（自2.20.0开始）</a></h3>从Mockito 2早期开始就提供了严格的存根功能。它非常有用，因为它可以推动更清洁的测试并提高生产率。严格存根报告不必要的存根，检测存根参数不匹配，并使测试更加干燥（ <a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a> ）。这需要权衡：在某些情况下，严格的存根可能会导致误报。为了解决这些情况，您现在可以将特定的存根配置为宽松，而所有其他存根和模拟都使用严格存根：<pre class="code"><code class="java">
   lenient().when(mock.foo()).thenReturn("ok");
 </code></pre>如果希望给定模拟的所有存根都宽松，则可以相应地配置模拟：<pre class="code"><code class="java">
   Foo mock = Mockito.mock(Foo.class, withSettings().lenient());
 </code></pre>有关更多信息，请参阅<a href="../../org/mockito/Mockito.html#lenient--"><code>lenient()</code></a> 。通过打开GitHub问题进行讨论，让我们知道您如何找到新功能！

 <h3 id="47">47。<a class="meaningful_link" href="#clear_inline_mocks" name="clear_inline_mocks">用于清除内联模拟中的模拟状态的新API（自2.25.0开始）</a></h3>在某些特定的罕见情况下（issue <a href="https://github.com/mockito/mockito/pull/1619">＃1619</a> ），内联模拟会导致内存泄漏。没有干净的方法可以完全缓解此问题。因此，我们引入了一个新的API来明确清除模拟状态（仅在内联模拟中有意义！）。参见示例用法<a href="../../org/mockito/MockitoFramework.html#clearInlineMocks--"><code>MockitoFramework.clearInlineMocks()</code></a> 。如果您有任何反馈或更好的想法来解决问题，请联系。</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>领域摘要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>领域</span> <span class="tabEnd"> </span></caption>
<tbody><tr>
<th class="colFirst" scope="col">修饰符和类型</th>
<th class="colLast" scope="col">栏位及说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a><<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#CALLS_REAL_METHODS">CALLS_REAL_METHODS</a></span></code>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a><<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#RETURNS_DEEP_STUBS">RETURNS_DEEP_STUBS</a></span></code>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a> 。</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a><<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#RETURNS_DEFAULTS">RETURNS_DEFAULTS</a></span></code>
<div class="block">默认值<code>Answer</code> <b>如果未</b>对模拟进行打桩，则每个模拟。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a><<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#RETURNS_MOCKS">RETURNS_MOCKS</a></span></code>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a><<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#RETURNS_SELF">RETURNS_SELF</a></span></code>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a> 。</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a><<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#RETURNS_SMART_NULLS">RETURNS_SMART_NULLS</a></span></code>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a> 。</div>
</td>
</tr>
</tbody></table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>构造器摘要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>建设者</span> <span class="tabEnd"> </span></caption>
<tbody><tr>
<th class="colOne" scope="col">构造函数和描述</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#Mockito--">Mockito</a></span>()</code> </td>
</tr>
</tbody></table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法总结</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span> <span class="tabEnd"> </span></span> <span id="t1" class="tableTab"><span><a href="javascript:void(0);">静态方法</a></span> <span class="tabEnd"> </span></span> <span id="t4" class="tableTab"><span><a href="javascript:void(0);">具体方法</a></span> <span class="tabEnd"> </span></span> <span id="t6" class="tableTab"><span><a href="javascript:void(0);">不推荐使用的方法</a></span> <span class="tabEnd"> </span></span></caption>
<tbody><tr>
<th class="colFirst" scope="col">修饰符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationAfterDelay.html" title="interface in org.mockito.verification">VerificationAfterDelay</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#after-java.time.Duration-">after</a></span>(java.time.Duration delay)</code>
<div class="block">验证将在给定的时间后触发，从而允许测试异步代码。</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationAfterDelay.html" title="interface in org.mockito.verification">VerificationAfterDelay</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#after-long-">after</a></span>(long millis)</code>
<div class="block"><span class="deprecatedLabel">不推荐使用。</span> 
<div class="block"><span class="deprecationComment">使用<a href="../../org/mockito/Mockito.html#after-java.time.Duration-"><code>after(Duration)</code></a>代替。</span></div>
</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#atLeast-int-">atLeast</a></span>(int minNumberOfInvocations)</code>
<div class="block">允许至少x验证。</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#atLeastOnce--">atLeastOnce</a></span>()</code>
<div class="block">允许至少一次验证。</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#atMost-int-">atMost</a></span>(int maxNumberOfInvocations)</code>
<div class="block">允许最多x验证。</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#atMostOnce--">atMostOnce</a></span>()</code>
<div class="block">允许最多一次验证。</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#calls-int-">calls</a></span>(int wantedNumberOfInvocations)</code>
<div class="block">允许顺序进行非贪婪验证。</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static <T> void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#clearInvocations-T...-">clearInvocations</a></span>(T... mocks)</code>
<div class="block">当存根是不平凡的时，请使用此方法仅清除调用。</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#description-java.lang.String-">description</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> description)</code>
<div class="block">添加验证失败时要打印的描述。</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doAnswer-org.mockito.stubbing.Answer-">doAnswer</a></span>(<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a> answer)</code>
<div class="block">使用<code>doAnswer()</code>当您想使用泛型对无效方法进行存根时<a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a> 。</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doCallRealMethod--">doCallRealMethod</a></span>()</code>
<div class="block">使用<code>doCallRealMethod()</code>当您要调用方法的实际实现时。</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doNothing--">doNothing</a></span>()</code>
<div class="block">使用<code>doNothing()</code>设置void方法不执行任何操作。</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doReturn-java.lang.Object-">doReturn</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a> toBeReturned)</code>
<div class="block">使用<code>doReturn()</code>在那些您无法使用的罕见情况下<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a> 。</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doReturn-java.lang.Object-java.lang.Object...-">doReturn</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a> toBeReturned, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>... toBeReturnedNext)</code>
<div class="block">和...一样<a href="../../org/mockito/Mockito.html#doReturn-java.lang.Object-"><code>doReturn(Object)</code></a>但设置要返回的连续值。</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doThrow-java.lang.Class-">doThrow</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><? extends <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>> toBeThrown)</code>
<div class="block">使用<code>doThrow()</code>当您想将void方法存入一个异常时。</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doThrow-java.lang.Class-java.lang.Class...-">doThrow</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><? extends <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>> toBeThrown, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><? extends <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>>... toBeThrownNext)</code>
<div class="block">和...一样<a href="../../org/mockito/Mockito.html#doThrow-java.lang.Class-"><code>doThrow(Class)</code></a>但设置要抛出的连续异常类。</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#doThrow-java.lang.Throwable...-">doThrow</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>... toBeThrown)</code>
<div class="block">使用<code>doThrow()</code>当您想将void方法存入一个异常时。</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/MockitoFramework.html" title="interface in org.mockito">MockitoFramework</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#framework--">framework</a></span>()</code>
<div class="block">适用于高级用户或框架集成商。</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#ignoreStubs-java.lang.Object...-">ignoreStubs</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>... mocks)</code>
<div class="block">为了验证，忽略给定模拟的存根方法。</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/InOrder.html" title="interface in org.mockito">InOrder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#inOrder-java.lang.Object...-">inOrder</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>... mocks)</code>
<div class="block">创造<a href="../../org/mockito/InOrder.html" title="org.mockito中的接口"><code>InOrder</code></a>允许按顺序验证模拟的对象。</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/LenientStubber.html" title="interface in org.mockito.stubbing">LenientStubber</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#lenient--">lenient</a></span>()</code>
<div class="block">宽大的存根绕过“严格存根”验证（请参阅<a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a> ）。</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#mock-java.lang.Class-">mock</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><T> classToMock)</code>
<div class="block">创建给定类或接口的模拟对象。</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-">mock</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><T> classToMock, <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a> defaultAnswer)</code>
<div class="block">创建具有指定策略的模拟，以解决交互问题。</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.MockSettings-">mock</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><T> classToMock, <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a> mockSettings)</code>
<div class="block">使用一些非标准设置创建模拟。</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#mock-java.lang.Class-java.lang.String-">mock</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><T> classToMock, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> name)</code>
<div class="block">指定模拟名称。</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/MockingDetails.html" title="interface in org.mockito">MockingDetails</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#mockingDetails-java.lang.Object-">mockingDetails</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a> toInspect)</code>
<div class="block">返回一个MockingDetails实例，该实例使您能够检查特定对象中与Mockito相关的信息。</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/session/MockitoSessionBuilder.html" title="interface in org.mockito.session">MockitoSessionBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#mockitoSession--">mockitoSession</a></span>()</code>
<div class="block"><code>MockitoSession</code>是一项强烈推荐的可选功能，它通过消除样板代码并增加额外的验证来帮助进行更清洁的测试。</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#never--">never</a></span>()</code>
<div class="block">别名<code>times(0)</code> ，请参阅<a href="../../org/mockito/Mockito.html#times-int-"><code>times(int)</code></a></div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#only--">only</a></span>()</code>
<div class="block">允许检查给定方法是否是唯一调用的方法。</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static <T> void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#reset-T...-">reset</a></span>(T... mocks)</code>
<div class="block">聪明的Mockito用户几乎不使用此功能，因为他们知道这可能是测试不佳的迹象。</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#spy-java.lang.Class-">spy</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a><T> classToSpy)</code>
<div class="block">请参考以下文件<a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a> 。</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#spy-T-">spy</a></span>(T object)</code>
<div class="block">创建真实对象的间谍。</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationWithTimeout.html" title="interface in org.mockito.verification">VerificationWithTimeout</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#timeout-java.time.Duration-">timeout</a></span>(java.time.Duration timeout)</code>
<div class="block">验证将反复触发直到给定的时间，从而允许测试异步代码。</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationWithTimeout.html" title="interface in org.mockito.verification">VerificationWithTimeout</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#timeout-long-">timeout</a></span>(long millis)</code>
<div class="block"><span class="deprecatedLabel">不推荐使用。</span> 
<div class="block"><span class="deprecationComment">使用<a href="../../org/mockito/Mockito.html#timeout-java.time.Duration-"><code>timeout(Duration)</code></a>代替。</span></div>
</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#times-int-">times</a></span>(int wantedNumberOfInvocations)</code>
<div class="block">允许验证确切的调用次数。</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#validateMockitoUsage--">validateMockitoUsage</a></span>()</code>
<div class="block">首先，如果有任何麻烦，我鼓励您阅读Mockito FAQ： <a href="https://github.com/mockito/mockito/wiki/FAQ">https</a> : <a href="https://github.com/mockito/mockito/wiki/FAQ">//github.com/mockito/mockito/wiki/FAQ</a></div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#verify-T-">verify</a></span>(T mock)</code>
<div class="block">验证某些行为<b>曾经发生过一次</b> 。</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static <T> T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#verify-T-org.mockito.verification.VerificationMode-">verify</a></span>(T mock, <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a> mode)</code>
<div class="block">验证某些行为至少发生一次/确切次数/永不发生。</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#verifyNoInteractions-java.lang.Object...-">verifyNoInteractions</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>... mocks)</code>
<div class="block">验证给定的模拟是否发生任何交互。</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions-java.lang.Object...-">verifyNoMoreInteractions</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>... mocks)</code>
<div class="block">检查给定的模拟是否有未验证的交互。</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#verifyZeroInteractions-java.lang.Object...-">verifyZeroInteractions</a></span>(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>... mocks)</code>
<div class="block"><span class="deprecatedLabel">不推荐使用。</span> 
<div class="block"><span class="deprecationComment">自3.0.1。请将您的代码迁移到<a href="../../org/mockito/Mockito.html#verifyNoInteractions-java.lang.Object...-"><code>verifyNoInteractions(Object...)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static <T> <a href="../../org/mockito/stubbing/OngoingStubbing.html" title="interface in org.mockito.stubbing">OngoingStubbing</a><T></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#when-T-">when</a></span>(T methodCall)</code>
<div class="block">启用存根方法。</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/mockito/Mockito.html#withSettings--">withSettings</a></span>()</code>
<div class="block">允许使用其他模拟设置进行模拟创建。</div>
</td>
</tr>
</tbody></table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.org.mockito.ArgumentMatchers">
<!--   -->
</a>
<h3>从类org.mockito继承的方法。<a href="../../org/mockito/ArgumentMatchers.html" title="org.mockito中的类">参数匹配器</a></h3>
<code><a href="../../org/mockito/ArgumentMatchers.html#any--">any</a>, <a href="../../org/mockito/ArgumentMatchers.html#any-java.lang.Class-">any</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyBoolean--">anyBoolean</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyByte--">anyByte</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyChar--">anyChar</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyCollection--">anyCollection</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyCollectionOf-java.lang.Class-">anyCollectionOf</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyDouble--">anyDouble</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyFloat--">anyFloat</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyInt--">anyInt</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyIterable--">anyIterable</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyIterableOf-java.lang.Class-">anyIterableOf</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyList--">anyList</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyListOf-java.lang.Class-">anyListOf</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyLong--">anyLong</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyMap--">anyMap</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyMapOf-java.lang.Class-java.lang.Class-">anyMapOf</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyObject--">anyObject</a>, <a href="../../org/mockito/ArgumentMatchers.html#anySet--">anySet</a>, <a href="../../org/mockito/ArgumentMatchers.html#anySetOf-java.lang.Class-">anySetOf</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyShort--">anyShort</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyString--">anyString</a>, <a href="../../org/mockito/ArgumentMatchers.html#anyVararg--">anyVararg</a>, <a href="../../org/mockito/ArgumentMatchers.html#argThat-org.mockito.ArgumentMatcher-">argThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#booleanThat-org.mockito.ArgumentMatcher-">booleanThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#byteThat-org.mockito.ArgumentMatcher-">byteThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#charThat-org.mockito.ArgumentMatcher-">charThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#contains-java.lang.String-">contains</a>, <a href="../../org/mockito/ArgumentMatchers.html#doubleThat-org.mockito.ArgumentMatcher-">doubleThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#endsWith-java.lang.String-">endsWith</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-boolean-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-byte-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-char-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-double-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-float-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-int-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-long-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-short-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#eq-T-">eq</a>, <a href="../../org/mockito/ArgumentMatchers.html#floatThat-org.mockito.ArgumentMatcher-">floatThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#intThat-org.mockito.ArgumentMatcher-">intThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#isA-java.lang.Class-">isA</a>, <a href="../../org/mockito/ArgumentMatchers.html#isNotNull--">isNotNull</a>, <a href="../../org/mockito/ArgumentMatchers.html#isNotNull-java.lang.Class-">isNotNull</a>, <a href="../../org/mockito/ArgumentMatchers.html#isNull--">isNull</a>, <a href="../../org/mockito/ArgumentMatchers.html#isNull-java.lang.Class-">isNull</a>, <a href="../../org/mockito/ArgumentMatchers.html#longThat-org.mockito.ArgumentMatcher-">longThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#matches-java.util.regex.Pattern-">matches</a>, <a href="../../org/mockito/ArgumentMatchers.html#matches-java.lang.String-">matches</a>, <a href="../../org/mockito/ArgumentMatchers.html#notNull--">notNull</a>, <a href="../../org/mockito/ArgumentMatchers.html#notNull-java.lang.Class-">notNull</a>, <a href="../../org/mockito/ArgumentMatchers.html#nullable-java.lang.Class-">nullable</a>, <a href="../../org/mockito/ArgumentMatchers.html#refEq-T-java.lang.String...-">refEq</a>, <a href="../../org/mockito/ArgumentMatchers.html#same-T-">same</a>, <a href="../../org/mockito/ArgumentMatchers.html#shortThat-org.mockito.ArgumentMatcher-">shortThat</a>, <a href="../../org/mockito/ArgumentMatchers.html#startsWith-java.lang.String-">startsWith</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>从类java.lang继承的方法。<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="java.lang中的类或接口">宾语</a></h3>
<code><a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#clone--" title="class or interface in java.lang">clone</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang">equals</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#finalize--" title="class or interface in java.lang">finalize</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass--" title="class or interface in java.lang">getClass</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang">hashCode</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify--" title="class or interface in java.lang">notify</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="class or interface in java.lang">notifyAll</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#toString--" title="class or interface in java.lang">toString</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait--" title="class or interface in java.lang">wait</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="class or interface in java.lang">wait</a>, <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>领域细节</h3>
<a name="RETURNS_DEFAULTS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_DEFAULTS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_DEFAULTS</pre>
<div class="block">默认值<code>Answer</code> <b>如果未</b>对模拟进行打桩，则每个模拟。通常，它只返回一些空值。
 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a>可用于定义未存根调用的返回值。
 </p><p>此实现首先尝试全局配置，如果没有全局配置，则它将使用默认答案，该答案返回零，空集合，空值等。</p></div>
</li>
</ul>
<a name="RETURNS_SMART_NULLS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_SMART_NULLS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_SMART_NULLS</pre>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a> 。
 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a>可用于定义未存根调用的返回值。
 </p><p>使用旧代码时，此实现可能会有所帮助。未存根的方法通常返回null。如果您的代码使用未存根调用返回的对象，则将收到NullPointerException。Answer的此实现<b>返回SmartNull而不是null</b> 。
 <code>SmartNull</code>给出比NPE更好的异常消息，因为它指出了调用未存根方法的行。您只需单击堆栈跟踪。
 </p><p>
 <code>ReturnsSmartNulls</code>首先尝试返回普通值（零，空集合，空字符串等）然后它将尝试返回SmartNull。如果返回类型为final，则为普通类型<code>null</code>返回。
 </p><p>
 <code>ReturnsSmartNulls</code>将可能是Mockito 4.0.0中的默认返回值策略</p><p>例：</p><pre class="code"><code class="java">
   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);

   //calling unstubbed method here:
   Stuff stuff = mock.getStuff();

   //using object returned by unstubbed call:
   stuff.doSomething();

   //Above doesn't yield NullPointerException this time!
   //Instead, SmartNullPointerException is thrown.
   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.
 </code></pre></div>
</li>
</ul>
<a name="RETURNS_MOCKS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_MOCKS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_MOCKS</pre>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a>
 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a>可用于定义未存根调用的返回值。
 </p><p>使用旧代码时，此实现可能会有所帮助。
 </p><p>ReturnMocks首先尝试返回普通值（零，空集合，空字符串等）。然后它尝试返回模拟。如果不能模拟返回类型（例如，最终类型），则为普通类型<code>null</code>返回。
 </p><p></p></div>
</li>
</ul>
<a name="RETURNS_DEEP_STUBS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_DEEP_STUBS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_DEEP_STUBS</pre>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a> 。
 <p>显示深层存根如何工作的示例：</p><pre class="code"><code class="java">
   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);

   // note that we're stubbing a chain of methods here: getBar().getName()
   when(mock.getBar().getName()).thenReturn("deep");

   // note that we're chaining method calls: getBar().getName()
   assertEquals("deep", mock.getBar().getName());
 </code></pre>
 <p></p>

 <p>
 <strong>警告：</strong>常规清洁代码很少需要使用此功能！留给旧代码。模拟一个模拟返回一个模拟，返回一个模拟，（...），返回一些有意义的暗示，以违反Demeter法则或模拟一个值对象（一个众所周知的反模式）。
 </p>

 <p>我在网上看到过的好报价： <strong>每次模拟返回模拟时，仙女都会死去</strong> 。
 </p>

 <p>请注意，此答案将返回与存根匹配的现有模拟。深度存根可以解决此问题，并且可以在链的最后一个模拟中进行验证。
 </p><pre class="code"><code class="java">
   when(mock.getBar(anyString()).getThingy().getName()).thenReturn("deep");

   mock.getBar("candy bar").getThingy().getName();

   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());
   verify(mock.getBar("candy bar").getThingy()).getName();
   verify(mock.getBar(anyString()).getThingy()).getName();
 </code></pre>
 <p></p>

 <p>验证仅适用于链中的最后一个模拟。您可以使用验证模式。
 </p><pre class="code"><code class="java">
   when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn("deep");
   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn("deep");

   person.getAddress("the docks").getStreet().getName();
   person.getAddress("the docks").getStreet().getLongName();
   person.getAddress("the docks").getStreet(Locale.ITALIAN).getName();
   person.getAddress("the docks").getStreet(Locale.CHINESE).getName();

   // note that we are actually referring to the very last mock in the stubbing chain.
   InOrder inOrder = inOrder(
       person.getAddress("the docks").getStreet(),
       person.getAddress("the docks").getStreet(Locale.CHINESE),
       person.getAddress("the docks").getStreet(Locale.ITALIAN)
   );
   inOrder.verify(person.getAddress("the docks").getStreet(), times(1)).getName();
   inOrder.verify(person.getAddress("the docks").getStreet()).getLongName();
   inOrder.verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atLeast(1)).getName();
   inOrder.verify(person.getAddress("the docks").getStreet(Locale.CHINESE)).getName();
 </code></pre>
 <p></p>

 <p>深度存根在内部如何工作？
 </p><pre class="code"><code class="java">
   //this:
   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
   when(mock.getBar().getName(), "deep");

   //is equivalent of
   Foo foo = mock(Foo.class);
   Bar bar = mock(Bar.class);
   when(foo.getBar()).thenReturn(bar);
   when(bar.getName()).thenReturn("deep");
 </code></pre>
 <p></p>

 <p>当无法模拟链中包含的任何返回类型的方法时，此功能将不起作用（例如：是原始或最终类）。这是由于java类型系统。
 </p></div>
</li>
</ul>
<a name="CALLS_REAL_METHODS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CALLS_REAL_METHODS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; CALLS_REAL_METHODS</pre>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a>

 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a>可用于定义未存根调用的返回值。
 </p><p>使用旧代码时，此实现可能会有所帮助。使用此实现时，未打桩的方法将委托给实际实现。这是一种创建部分模拟对象的方法，该对象默认情况下会调用真实方法。
 </p><p>像往常一样，您将阅读<b>部分模拟警告</b> ：面向对象的编程通过将复杂度划分为单独的，特定的SRPy对象来解决复杂度问题。部分模拟如何适应这种范例？好吧，只是没有...部分模拟通常意味着复杂性已移至同一对象的不同方法。在大多数情况下，这不是您设计应用程序的方式。
 </p><p>但是，在少数情况下，局部模拟会派上用场：处理您无法轻松更改的代码（第三方接口，对遗留代码的临时重构等）但是，对于新的，测试驱动的和精心设计的代码，我不会使用局部模拟。
 </p><p>例：</p><pre class="code"><code class="java">
 Foo mock = mock(Foo.class, CALLS_REAL_METHODS);

 // this calls the real implementation of Foo.getSomething()
 value = mock.getSomething();

 doReturn(fakeValue).when(mock).getSomething();

 // now fakeValue is returned
 value = mock.getSomething();
 </code></pre>

 <p>
 <u>注意1：</u>使用存根部分模拟<code>when(mock.getSomething()).thenReturn(fakeValue)</code>语法将调用real方法。对于部分模拟，建议使用<code>doReturn</code>句法。
 </p><p>
 <u>注意2：</u>如果将模拟序列化然后反序列化，则此答案将无法理解泛型元数据。</p></div>
</li>
</ul>
<a name="RETURNS_SELF">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>RETURNS_SELF</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_SELF</pre>
<div class="block">可选的<code>Answer</code>用于<a href="../../org/mockito/Mockito.html#mock-java.lang.Class-org.mockito.stubbing.Answer-"><code>mock(Class, Answer)</code></a> 。每当调用返回等于类或超类的Type的方法时，允许Builder模拟程序返回自身。

 <p><b>请记住，此答案使用方法的返回类型。如果此类型可分配给模拟的类，则它将返回模拟。因此，如果您有一个返回超类的方法（例如<code>Object</code> ），它将匹配并返回该模拟。</b></p>考虑在HttpRequesterWithHeaders中使用的HttpBuilder。

 <pre class="code"><code class="java">
 public class HttpRequesterWithHeaders {

      private HttpBuilder builder;

      public HttpRequesterWithHeaders(HttpBuilder builder) {
          this.builder = builder;
      }

      public String request(String uri) {
          return builder.withUrl(uri)
                  .withHeader("Content-type: application/json")
                  .withHeader("Authorization: Bearer")
                  .request();
      }
  }

  private static class HttpBuilder {

      private String uri;
      private List&lt;String&gt; headers;

      public HttpBuilder() {
          this.headers = new ArrayList&lt;String&gt;();
      }

       public HttpBuilder withUrl(String uri) {
           this.uri = uri;
           return this;
       }

       public HttpBuilder withHeader(String header) {
           this.headers.add(header);
           return this;
       }

       public String request() {
          return uri + headers.toString();
       }
  }
 </code></pre>以下测试将成功<pre><code>
 &#064;Test
  public void use_full_builder_with_terminating_method() {
      HttpBuilder builder = mock(HttpBuilder.class, RETURNS_SELF);
      HttpRequesterWithHeaders requester = new HttpRequesterWithHeaders(builder);
      String response = "StatusCode: 200";

      when(builder.request()).thenReturn(response);

      assertThat(requester.request("URI")).isEqualTo(response);
  }
 </code></pre></div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>构造器详细信息</h3>
<a name="Mockito--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>莫基托</h4>
<pre>public&nbsp;Mockito()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法细节</h3>
<a name="mock-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>嘲笑</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock)</pre>
<div class="block">创建给定类或接口的模拟对象。
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>classToMock</code> -模拟类或接口</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>模拟对象</dd>
</dl>
</li>
</ul>
<a name="mock-java.lang.Class-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>嘲笑</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
                         <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;name)</pre>
<div class="block">指定模拟名称。命名模拟对于调试很有帮助-该名称用于所有验证错误。
 <p>注意，命名模拟不是解决使用太多模拟或协作者的复杂代码的解决方案。
 <b>如果您有太多的模拟程序，则可以重构代码，</b>以便无需命名模拟程序即可轻松进行测试/调试。
 </p><p>
 <b>如果您使用<code>@Mock</code>注释，那么您就可以免费命名模拟了！</b> <code>@Mock</code> 使用字段名称作为模拟名称。<a href="../../org/mockito/Mock.html" title="org.mockito中的注释"><code>Read more.</code></a>
 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>classToMock</code> -模拟类或接口</dd>
<dd><code>name</code> -的模拟</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>模拟对象</dd>
</dl>
</li>
</ul>
<a name="mockingDetails-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>模拟细节</h4>
<pre>public static&nbsp;<a href="../../org/mockito/MockingDetails.html" title="interface in org.mockito">MockingDetails</a>&nbsp;mockingDetails(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;toInspect)</pre>
<div class="block">返回一个MockingDetails实例，该实例使您能够检查特定对象中与Mockito相关的信息。可以用来确定给定对象是Mockito模拟还是给定模拟是间谍或模拟。
 <p>在将来的Mockito版本中，MockingDetails可能会增长并提供有关该模拟的其他有用信息，例如调用，存根信息等。</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>toInspect</code> --检查对象。允许输入空值。</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>一种<a href="../../org/mockito/MockingDetails.html" title="org.mockito中的接口"><code>MockingDetails</code></a>实例。</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>1.9.5</dd>
</dl>
</li>
</ul>
<a name="mock-java.lang.Class-org.mockito.stubbing.Answer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>嘲笑</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
                         <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&nbsp;defaultAnswer)</pre>
<div class="block">创建具有指定策略的模拟，以解决交互问题。这是一项高级功能，通常您不需要它来编写不错的测试。但是，在使用旧系统时可能会有帮助。
 <p>这是默认答案，因此<b>仅当您不</b>存根方法调用<b>时</b>才会使用它。

 </p><pre class="code"><code class="java">
   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
 </code></pre>

 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>classToMock</code> -模拟类或接口</dd>
<dd><code>defaultAnswer</code> -未存根方法的默认答案</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>模拟对象</dd>
</dl>
</li>
</ul>
<a name="mock-java.lang.Class-org.mockito.MockSettings-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>嘲笑</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
                         <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a>&nbsp;mockSettings)</pre>
<div class="block">使用一些非标准设置创建模拟。
 <p>模拟的配置点数量在增加，因此我们需要一种流畅的方法来引入新的配置，而无需添加越来越多的重载Mockito.mock（）方法。因此<a href="../../org/mockito/MockSettings.html" title="org.mockito中的接口"><code>MockSettings</code></a> 。
 </p><pre class="code"><code class="java">
   Listener mock = mock(Listener.class, withSettings()
     .name("firstListner").defaultBehavior(RETURNS_SMART_NULLS));
   );
 </code></pre>
 <b>偶尔小心使用它</b> 。您的测试需要非标准模拟的原因可能是什么？被测试的代码是否如此复杂，以至于需要非标准的模拟？您是否不愿意重构被测代码，以便以一种简单的方式对其进行测试？
 <p>也可以看看<a href="../../org/mockito/Mockito.html#withSettings--"><code>withSettings()</code></a>
 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>classToMock</code> -模拟类或接口</dd>
<dd><code>mockSettings</code> -其他模拟设置</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>模拟对象</dd>
</dl>
</li>
</ul>
<a name="spy-java.lang.Object-">
<!--   -->
</a><a name="spy-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>间谍</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;spy(T&nbsp;object)</pre>
<div class="block">创建真实对象的间谍。除非调用它们，否则间谍会调用<b>真实</b>方法。
 <p>真正的间谍应该<b>小心谨慎</b>地使用，例如在处理遗留代码时。
 </p><p>像往常一样，您将阅读<b>部分模拟警告</b> ：面向对象的编程通过将复杂度划分为单独的特定SRPy对象来解决复杂度。部分模拟如何适应这种范例？好吧，只是没有...部分模拟通常意味着复杂性已移至同一对象的不同方法。在大多数情况下，这不是您设计应用程序的方式。
 </p><p>但是，在少数情况下，局部模拟会派上用场：处理您无法轻松更改的代码（第三方接口，对遗留代码的临时重构等）但是，对于新的，测试驱动的和精心设计的代码，我不会使用局部模拟。
 </p><p>例：</p><pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //optionally, you can stub out some methods:
   when(spy.size()).thenReturn(100);

   //using the spy calls <b>real</b> methods
   spy.add("one");
   spy.add("two");

   //prints "one" - the first element of a list
   System.out.println(spy.get(0));

   //size() method was stubbed - 100 is printed
   System.out.println(spy.size());

   //optionally, you can verify
   verify(spy).add("one");
   verify(spy).add("two");
 </code></pre>

 <h4>从事间谍活动的重要陷阱！</h4>
 <ol>
 <li>有时使用是不可能或不切实际的<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>侦探间谍。因此，对于间谍，建议始终使用<code>doReturn</code> | <code>Answer</code> | <code>Throw()</code> | <code>CallRealMethod</code>系列的存根方法。例：<pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   when(spy.get(0)).thenReturn("foo");

   //You have to use doReturn() for stubbing
   doReturn("foo").when(spy).get(0);
 </code></pre>
 </li>

 <li>Mockito <b>*不会*</b>将调用委托给传递的真实实例，而是实际上创建它的副本。因此，如果保留真实实例并与之交互，请不要期望间谍知道这些交互及其对真实实例状态的影响。必然的结果是，当<b>在间谍*上</b>调用<b>* unstubbed *</b>方法<b>而在真实实例上*不</b>调用<b>*</b>方法时，您将看不到任何对真实实例的影响。</li>

 <li>注意最终方法。Mockito不模拟最终方法，因此最重要的是：当您监视真实对象时+尝试对最终方法进行存根=麻烦。另外，您也将无法验证这些方法。
 </li>
 </ol>
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p><p>请注意，间谍不会包含任何间谍类型的注释，因为CGLIB不会重写它们。对于依赖间谍的代码进行这些注释可能会很麻烦。</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>object</code> -监视</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>真实物体的间谍</dd>
</dl>
</li>
</ul>
<a name="spy-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>间谍</h4>
<pre><a href="../../org/mockito/Incubating.html" title="annotation in org.mockito">@Incubating</a>
public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;spy(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToSpy)</pre>
<div class="block">请参考以下文件<a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a> 。过度使用间谍会暗示代码设计的气味。
 <p>此方法与原始方法相反<a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a> ，根据类而不是对象创建间谍。有时，根据类创建间谍程序更方便，并且避免提供间谍对象的实例。这对于侦听抽象类特别有用，因为它们无法实例化。也可以看看<a href="../../org/mockito/MockSettings.html#useConstructor-java.lang.Object...-"><code>MockSettings.useConstructor(Object...)</code></a> 。
 </p><p>例子：</p><pre class="code"><code class="java">
   SomeAbstract spy = spy(SomeAbstract.class);

   //Robust API, via settings builder:
   OtherAbstract spy = mock(OtherAbstract.class, withSettings()
      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));

   //Mocking a non-static inner abstract class:
   InnerAbstract spy = mock(InnerAbstract.class, withSettings()
      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
 </code></pre></div>
<dl>
<dt><span class="paramLabel">类型参数：</span></dt>
<dd><code>T</code> -间谍的类型</dd>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>classToSpy</code> -间谍班</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>提供班级的间谍</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>1.10.12</dd>
</dl>
</li>
</ul>
<a name="when-java.lang.Object-">
<!--   -->
</a><a name="when-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>什么时候</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../org/mockito/stubbing/OngoingStubbing.html" title="interface in org.mockito.stubbing">OngoingStubbing</a>&lt;T&gt;&nbsp;when(T&nbsp;methodCall)</pre>
<div class="block">启用存根方法。当您希望模拟在调用特定方法时返回特定值时，请使用它。
 <p>简单地说：“ <b>当</b> X方法被调用<b>，然后</b>返回Y”。

 </p><p>例子：</p><pre class="code"><code class="java">
 <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);

 //you can use flexible argument matchers, e.g:
 when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);

 //setting exception to be thrown:
 when(mock.someMethod("some arg")).thenThrow(new RuntimeException());

 //you can set different behavior for consecutive method calls.
 //Last stubbing (e.g: thenReturn("foo")) determines the behavior of further consecutive calls.
 when(mock.someMethod("some arg"))
  .thenThrow(new RuntimeException())
  .thenReturn("foo");

 //Alternative, shorter version for consecutive stubbing:
 when(mock.someMethod("some arg"))
  .thenReturn("one", "two");
 //is the same as:
 when(mock.someMethod("some arg"))
  .thenReturn("one")
  .thenReturn("two");

 //shorter version for consecutive method calls throwing exceptions:
 when(mock.someMethod("some arg"))
  .thenThrow(new RuntimeException(), new NullPointerException();

 </code></pre>对于将无效方法与throwables结合使用，请参见： <a href="../../org/mockito/Mockito.html#doThrow-java.lang.Throwable...-"><code>doThrow(Throwable...)</code></a>
 <p>存根可以被覆盖：例如，通用存根可以进入夹具设置，但是测试方法可以覆盖它。请注意，过多的存根是一种潜在的代码异味，表明存在过多的存根。
 </p><p>一旦存根，该方法将始终返回存根值，而不管它被调用了多少次。
 </p><p>最后一次存根更为重要-当您多次对具有相同参数的相同方法进行存根时。
 </p><p>尽管可以验证存根调用，但通常<b>只是多余的</b> 。假设您已经s了<code>foo.bar()</code> 。如果您的代码在乎什么<code>foo.bar()</code>返回然后有其他中断（通常甚至在<code>verify()</code>被执行）。如果您的代码不在乎<code>get(0)</code>返回，则不应将其存根。

 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>methodCall</code> -要存根的方法</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>OngoingStubbing对象用于流利地进行存根。
         <strong>不要</strong>创建对此返回对象的引用。</dd>
</dl>
</li>
</ul>
<a name="verify-java.lang.Object-">
<!--   -->
</a><a name="verify-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>校验</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;verify(T&nbsp;mock)</pre>
<div class="block">验证某些行为<b>曾经发生过一次</b> 。
 <p>别名<code>verify(mock, times(1))</code>例如：</p><pre class="code"><code class="java">
   verify(mock).someMethod("some arg");
 </code></pre>以上相当于：<pre class="code"><code class="java">
   verify(mock, times(1)).someMethod("some arg");
 </code></pre>
 <p>通过比较传递的参数<code>equals()</code>方法。阅读<a href="../../org/mockito/ArgumentCaptor.html" title="org.mockito中的类"><code>ArgumentCaptor</code></a>要么<a href="../../org/mockito/ArgumentMatcher.html" title="org.mockito中的接口"><code>ArgumentMatcher</code></a>找出匹配/声明传递的参数的其他方式。
 </p><p>尽管可以验证存根调用，但通常<b>只是多余的</b> 。假设您已经s了<code>foo.bar()</code> 。如果您的代码在乎什么<code>foo.bar()</code>返回然后有其他中断（通常甚至在<code>verify()</code>被执行）。如果您的代码不在乎<code>get(0)</code>返回，则不应将其存根。

 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mock</code> -待验证</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>模拟对象本身</dd>
</dl>
</li>
</ul>
<a name="verify-java.lang.Object-org.mockito.verification.VerificationMode-">
<!--   -->
</a><a name="verify-T-org.mockito.verification.VerificationMode-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>校验</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;verify(T&nbsp;mock,
                           <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;mode)</pre>
<div class="block">验证某些行为至少发生一次/确切次数/永不发生。例如：<pre class="code"><code class="java">
   verify(mock, times(5)).someMethod("was called five times");

   verify(mock, atLeast(2)).someMethod("was called at least two times");

   //you can use flexible argument matchers, e.g:
   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);
 </code></pre>

 <b>默认为times（1）</b> ，可以省略<p>通过比较传递的参数<code>equals()</code>方法。阅读<a href="../../org/mockito/ArgumentCaptor.html" title="org.mockito中的类"><code>ArgumentCaptor</code></a>要么<a href="../../org/mockito/ArgumentMatcher.html" title="org.mockito中的接口"><code>ArgumentMatcher</code></a>找出匹配/声明传递的参数的其他方式。
 </p><p></p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mock</code> -待验证</dd>
<dd><code>mode</code> -次（x），atLeastOnce（）或never（）</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>模拟对象本身</dd>
</dl>
</li>
</ul>
<a name="reset-java.lang.Object:A-">
<!--   -->
</a><a name="reset-T...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>重启</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;void&nbsp;reset(T...&nbsp;mocks)</pre>
<div class="block">聪明的Mockito用户几乎不使用此功能，因为他们知道这可能是测试不佳的迹象。通常，您无需重置模拟，只需为每个测试方法创建新的模拟即可。
 <p>代替<code>#reset()</code>请考虑在冗长，过度指定的测试中编写简单，小型且重点突出的测试方法。
 <b>第一种潜在的代码气味是<code>reset()</code>在测试方法的中间。</b> 这可能意味着您正在测试太多。请遵循您的测试方法的耳语：“请保持我们的注意力小，并专注于单一行为”。在嘲笑邮件列表中有几个关于它的主题。
 </p><p>我们添加的唯一原因<code>reset()</code>方法是使处理容器注入的模拟成为可能。有关更多信息，请参见FAQ（ <a href="https://github.com/mockito/mockito/wiki/FAQ">此处</a> ）。
 </p><p>
 <b>不要伤害自己。</b> <code>reset()</code>测试方法的中间是代码异味（您可能测试得太多）。
 </p><pre class="code"><code class="java">
   List mock = mock(List.class);
   when(mock.size()).thenReturn(10);
   mock.add(1);

   reset(mock);
   //at this point the mock forgot any interactions & stubbing
 </code></pre></div>
<dl>
<dt><span class="paramLabel">类型参数：</span></dt>
<dd><code>T</code> -模拟的类型</dd>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mocks</code> -要重置</dd>
</dl>
</li>
</ul>
<a name="clearInvocations-java.lang.Object:A-">
<!--   -->
</a><a name="clearInvocations-T...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearInvocations</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;void&nbsp;clearInvocations(T...&nbsp;mocks)</pre>
<div class="block">当存根是不平凡的时，请使用此方法仅清除调用。用例可以是：<ul>
     <li>您正在使用依赖项注入框架来注入模拟。</li>
     <li>该模拟用于有状态场景。例如，一个类是Singleton，它取决于您的模拟。</li>
 </ul>

 <b>设法不惜一切代价避免这种方法。仅当无法有效测试程序时才清除调用。</b></div>
<dl>
<dt><span class="paramLabel">类型参数：</span></dt>
<dd><code>T</code> -模拟的类型</dd>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mocks</code> -模拟清除调用</dd>
</dl>
</li>
</ul>
<a name="verifyNoMoreInteractions-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verifyNoMoreInteractions</h4>
<pre>public static&nbsp;void&nbsp;verifyNoMoreInteractions(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">检查给定的模拟是否有未验证的交互。
 <p>在验证了模拟之后，可以使用此方法-确保没有在模拟上调用其他任何东西。
 </p><p>也可以看看<a href="../../org/mockito/Mockito.html#never--"><code>never()</code></a> -更明确，传达意图。
 </p><p>存根调用（如果调用）也被视为交互。如果要自动验证存根调用，请签出<a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a> Mockito 2.3.0中引入的功能。如果要忽略存根进行验证，请参阅<a href="../../org/mockito/Mockito.html#ignoreStubs-java.lang.Object...-"><code>ignoreStubs(Object...)</code></a> 。
 </p><p>一个<b>警告</b> ：一些做过很多经典的，期望运行验证的模拟的用户倾向于使用<code>verifyNoMoreInteractions()</code>甚至在每种测试方法中都非常常见。
 <code>verifyNoMoreInteractions()</code>不建议在每种测试方法中都使用。
 <code>verifyNoMoreInteractions()</code>是交互测试工具包中的一个方便断言。仅在相关时使用。滥用它会导致规范过度，难以维护的测试。
 </p><p>此方法还将检测在测试方法之前发生的未验证的调用，例如： <code>setUp()</code> ， <code>@Before</code>方法或在构造函数中。考虑编写仅在测试方法中进行交互的漂亮代码。

 </p><p>例：</p><pre class="code"><code class="java">
 //interactions
 mock.doSomething();
 mock.doSomethingUnexpected();

 //verification
 verify(mock).doSomething();

 //following will fail because 'doSomethingUnexpected()' is unexpected
 verifyNoMoreInteractions(mock);

 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mocks</code> -待验证</dd>
</dl>
</li>
</ul>
<a name="verifyZeroInteractions-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verifyZeroInteractions</h4>
<pre><a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Deprecated.html?is-external=true" title="class or interface in java.lang">@Deprecated</a>
public static&nbsp;void&nbsp;verifyZeroInteractions(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block"><span class="deprecatedLabel">不推荐使用。</span> <span class="deprecationComment">自3.0.1。请将您的代码迁移到<a href="../../org/mockito/Mockito.html#verifyNoInteractions-java.lang.Object...-"><code>verifyNoInteractions(Object...)</code></a></span></div>
<div class="block">验证除先前验证的交互之外，给定的模拟没有发生交互。<br>此方法的行为与<a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions-java.lang.Object...-"><code>verifyNoMoreInteractions(Object...)</code></a> 。</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mocks</code> -待验证</dd>
</dl>
</li>
</ul>
<a name="verifyNoInteractions-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verifyNoInteractions</h4>
<pre>public static&nbsp;void&nbsp;verifyNoInteractions(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">验证给定的模拟是否发生任何交互。
 <pre class="code"><code class="java">
   verifyNoInteractions(mockOne, mockTwo);
 </code></pre>此方法还将检测在测试方法之前发生的调用，例如：in <code>setUp()</code> ， <code>@Before</code>方法或在构造函数中。考虑编写仅在测试方法中进行交互的漂亮代码。
 <p>也可以看看<a href="../../org/mockito/Mockito.html#never--"><code>never()</code></a> -更明确，传达意图。
 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mocks</code> -待验证</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>3.0.1</dd>
</dl>
</li>
</ul>
<a name="doThrow-java.lang.Throwable...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>抛掷</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doThrow(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>...&nbsp;toBeThrown)</pre>
<div class="block">使用<code>doThrow()</code>当您想将void方法存入一个异常时。
 <p>消除空隙需要与以下方法不同的方法<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>因为编译器不喜欢方括号内的void方法...
 </p><p>例：</p><pre class="code"><code class="java">
   doThrow(new RuntimeException()).when(mock).someVoidMethod();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>toBeThrown</code> -调用存根方法时抛出</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
</dl>
</li>
</ul>
<a name="doThrow-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>抛掷</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doThrow(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;? extends <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>&gt;&nbsp;toBeThrown)</pre>
<div class="block">使用<code>doThrow()</code>当您想将void方法存入一个异常时。
 <p>将为每个方法调用创建一个新的异常实例。
 </p><p>消除空隙需要与以下方法不同的方法<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>因为编译器不喜欢方括号内的void方法...
 </p><p>例：</p><pre class="code"><code class="java">
   doThrow(RuntimeException.class).when(mock).someVoidMethod();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>toBeThrown</code> -调用存根方法时抛出</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>2.1.0</dd>
</dl>
</li>
</ul>
<a name="doThrow-java.lang.Class-java.lang.Class...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>抛掷</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doThrow(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;? extends <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>&gt;&nbsp;toBeThrown,
                              <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;? extends <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>&gt;...&nbsp;toBeThrownNext)</pre>
<div class="block">和...一样<a href="../../org/mockito/Mockito.html#doThrow-java.lang.Class-"><code>doThrow(Class)</code></a>但设置要抛出的连续异常类。切记使用<code>doThrow()</code>当您想对void方法存根时，抛出指定类的多个异常。
 <p>将为每个方法调用创建一个新的异常实例。
 </p><p>消除空隙需要与以下方法不同的方法<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>因为编译器不喜欢方括号内的void方法...
 </p><p>例：</p><pre class="code"><code class="java">
   doThrow(RuntimeException.class, BigFailure.class).when(mock).someVoidMethod();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>toBeThrown</code> -调用存根方法时抛出</dd>
<dd><code>toBeThrownNext</code> -调用存根方法时将抛出的下一个</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>2.1.0</dd>
</dl>
</li>
</ul>
<a name="doCallRealMethod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doCallRealMethod</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doCallRealMethod()</pre>
<div class="block">使用<code>doCallRealMethod()</code>当您要调用方法的实际实现时。
 <p>像往常一样，您将阅读<b>部分模拟警告</b> ：面向对象的编程通过将复杂度划分为单独的，特定的SRPy对象来解决复杂度问题。部分模拟如何适应这种范例？好吧，只是没有...部分模拟通常意味着复杂性已移至同一对象的不同方法。在大多数情况下，这不是您设计应用程序的方式。
 </p><p>但是，在少数情况下，局部模拟会派上用场：处理您无法轻松更改的代码（第三方接口，对遗留代码的临时重构等）但是，对于新的，测试驱动的和精心设计的代码，我不会使用局部模拟。
 </p><p>另请参见javadoc <a href="../../org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a>进一步了解部分模拟。
 <b>Mockito.spy（）是创建部分模拟的推荐方法。</b>原因是它保证针对正确构造的对象调用真实方法，因为您负责构造传递给spy（）方法的对象。
 </p><p>例：</p><pre class="code"><code class="java">
   Foo mock = mock(Foo.class);
   doCallRealMethod().when(mock).someVoidMethod();

   // this will call the real implementation of Foo.someVoidMethod()
   mock.someVoidMethod();
 </code></pre>
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>1.9.5</dd>
</dl>
</li>
</ul>
<a name="doAnswer-org.mockito.stubbing.Answer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>回答</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doAnswer(<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&nbsp;answer)</pre>
<div class="block">使用<code>doAnswer()</code>当您想使用泛型对无效方法进行存根时<a href="../../org/mockito/stubbing/Answer.html" title="org.mockito.stubbing中的接口"><code>Answer</code></a> 。
 <p>消除空隙需要与以下方法不同的方法<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>因为编译器不喜欢方括号内的void方法...
 </p><p>例：</p><pre class="code"><code class="java">
  doAnswer(new Answer() {
      public Object answer(InvocationOnMock invocation) {
          Object[] args = invocation.getArguments();
          Mock mock = invocation.getMock();
          return null;
      }})
  .when(mock).someMethod();
 </code></pre>
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>answer</code> -在调用存根方法时回答</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
</dl>
</li>
</ul>
<a name="doNothing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>没做什么</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doNothing()</pre>
<div class="block">使用<code>doNothing()</code>设置void方法不执行任何操作。<b>注意，默认情况下，模拟上的void方法什么也不做！</b>但是，在少数情况下，doNothing（）会派上用场：<p>
 </p><ol>
 <li>取消对void方法的连续调用：<pre class="code"><code class="java">
   doNothing().
   doThrow(new RuntimeException())
   .when(mock).someVoidMethod();

   //does nothing the first time:
   mock.someVoidMethod();

   //throws RuntimeException the next time:
   mock.someVoidMethod();
 </code></pre>
 </li>
 <li>当您监视真实对象并且您希望void方法不执行任何操作时：<pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //let's make clear() do nothing
   doNothing().when(spy).clear();

   spy.add("one");

   //clear() does nothing, so the list still contains "one"
   spy.clear();
 </code></pre>
 </li>
 </ol>
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
</dl>
</li>
</ul>
<a name="doReturn-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doReturn</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doReturn(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;toBeReturned)</pre>
<div class="block">使用<code>doReturn()</code>在那些您无法使用的罕见情况下<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a> 。
 <p>
 <b>当心<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>始终建议使用Stub进行存根，因为它是参数类型安全的，并且更具可读性</b> （尤其是在存续连续调用时）。
 </p><p>以下是doReturn（）派上用场的那些罕见情况：</p><p>

 </p><ol>
 <li>监视真实对象并在间谍上调用真实方法时会带来副作用<pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   when(spy.get(0)).thenReturn("foo");

   //You have to use doReturn() for stubbing:
   doReturn("foo").when(spy).get(0);
 </code></pre>
 </li>

 <li>覆盖以前的异常处理：<pre class="code"><code class="java">
   when(mock.foo()).thenThrow(new RuntimeException());

   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
   when(mock.foo()).thenReturn("bar");

   //You have to use doReturn() for stubbing:
   doReturn("bar").when(mock).foo();
 </code></pre>
 </li>
 </ol>以上方案显示了Mockito优雅语法的折衷方案。请注意，这种情况很少见。间谍活动应该是零星的，并且覆盖异常例外非常罕见。更不用说总的来说，过多的存根是一种潜在的代码气味，指出了太多的存根。
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>toBeReturned</code> -调用存根方法时返回</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
</dl>
</li>
</ul>
<a name="doReturn-java.lang.Object-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doReturn</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doReturn(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;toBeReturned,
                               <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;toBeReturnedNext)</pre>
<div class="block">和...一样<a href="../../org/mockito/Mockito.html#doReturn-java.lang.Object-"><code>doReturn(Object)</code></a>但设置要返回的连续值。切记使用<code>doReturn()</code>在那些您无法使用的罕见情况下<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a> 。
 <p>
 <b>当心<a href="../../org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>始终建议使用Stub进行存根，因为它是参数类型安全的，并且更具可读性</b> （尤其是在存续连续调用时）。
 </p><p>以下是doReturn（）派上用场的那些罕见情况：</p><p>

 </p><ol>
 <li>监视真实对象并在间谍上调用真实方法时会带来副作用<pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   when(spy.get(0)).thenReturn("foo", "bar", "qix");

   //You have to use doReturn() for stubbing:
   doReturn("foo", "bar", "qix").when(spy).get(0);
 </code></pre>
 </li>

 <li>覆盖以前的异常处理：<pre class="code"><code class="java">
   when(mock.foo()).thenThrow(new RuntimeException());

   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
   when(mock.foo()).thenReturn("bar", "foo", "qix");

   //You have to use doReturn() for stubbing:
   doReturn("bar", "foo", "qix").when(mock).foo();
 </code></pre>
 </li>
 </ol>以上方案显示了Mockito优雅语法的折衷方案。请注意，这种情况很少见。间谍活动应该是零星的，并且覆盖异常例外非常罕见。更不用说总的来说，过多的存根是一种潜在的代码气味，指出了太多的存根。
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>toBeReturned</code> -调用存根方法时返回</dd>
<dd><code>toBeReturnedNext</code> -在调用存根方法时在连续调用中返回</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>存根-选择存根方法</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>2.1.0</dd>
</dl>
</li>
</ul>
<a name="inOrder-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>为了</h4>
<pre>public static&nbsp;<a href="../../org/mockito/InOrder.html" title="interface in org.mockito">InOrder</a>&nbsp;inOrder(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">创造<a href="../../org/mockito/InOrder.html" title="org.mockito中的接口"><code>InOrder</code></a>允许按顺序验证模拟的对象。

 <pre class="code"><code class="java">
   InOrder inOrder = inOrder(firstMock, secondMock);

   inOrder.verify(firstMock).add("was called first");
   inOrder.verify(secondMock).add("was called second");
 </code></pre>按顺序进行验证是灵活的- <b>您不必</b>一一<b>验证所有交互</b> ，而只需依次验证您感兴趣的<b>交互即可</b> 。
 <p>同样，您可以创建仅传递与有序验证相关的模拟的InOrder对象。
 </p><p>
 <code>InOrder</code>验证是“贪婪的”，但您几乎不会注意到它。如果您想了解更多信息，请阅读<a href="https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verification-InOrder">此Wiki页面</a> 。
 </p><p>从Mockito 1.8.4开始，您可以按顺序敏感的方式验证NoMoreInteractions（）。阅读更多： <a href="../../org/mockito/InOrder.html#verifyNoMoreInteractions--"><code>InOrder.verifyNoMoreInteractions()</code></a>
 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mocks</code> -有待验证</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>用于验证订单的InOrder对象</dd>
</dl>
</li>
</ul>
<a name="ignoreStubs-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignoreStubs</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;ignoreStubs(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">为了验证，忽略给定模拟的存根方法。请考虑使用<a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a>该功能消除了对<code>ignoreStubs()</code>并提供其他好处。
 <p>
 <code>ignoreStubs()</code>有时与<code>verifyNoMoreInteractions()</code>或验证<code>inOrder()</code> 。帮助避免对存根调用进行冗余验证-通常我们对验证存根不感兴趣。
 </p><p>
 <b>警告</b> ， <code>ignoreStubs()</code>可能导致过度使用<code>verifyNoMoreInteractions(ignoreStubs(...));</code>请记住，Mockito建议不要使用<code>verifyNoMoreInteractions()</code>由于javadoc中概述的原因<a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions-java.lang.Object...-"><code>verifyNoMoreInteractions(Object...)</code></a>换句话说：给定模拟的所有<b>* stubbed *</b>方法都标记为<b>* verified *，</b>以便在verifyNoMoreInteractions（）期间不会造成任何干扰。
 </p><p>此方法<b>更改输入模拟</b> ！该方法返回输入模拟只是为了方便。
 </p><p>对于订单中的验证，忽略的存根也将被忽略，包括<a href="../../org/mockito/InOrder.html#verifyNoMoreInteractions--"><code>InOrder.verifyNoMoreInteractions()</code></a> 。请参阅第二个示例。
 </p><p>例：</p><pre class="code"><code class="java">
  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)
  List mock1 = mock(List.class), mock2 = mock(List.class);

  //stubbing mocks:
  when(mock1.get(0)).thenReturn(10);
  when(mock2.get(0)).thenReturn(20);

  //using mocks by calling stubbed get(0) methods:
  System.out.println(mock1.get(0)); //prints 10
  System.out.println(mock2.get(0)); //prints 20

  //using mocks by calling clear() methods:
  mock1.clear();
  mock2.clear();

  //verification:
  verify(mock1).clear();
  verify(mock2).clear();

  //verifyNoMoreInteractions() fails because get() methods were not accounted for.
  try { verifyNoMoreInteractions(mock1, mock2); } catch (NoInteractionsWanted e);

  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()
  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));

  //Remember that ignoreStubs() <b>*changes*</b> the input mocks and returns them for convenience.
 </code></pre>忽略存根可以按<b>顺序</b>用于<b>验证</b> ：<pre class="code"><code class="java">
  List list = mock(List.class);
  when(list.get(0)).thenReturn("foo");

  list.add(0);
  list.clear();
  System.out.println(list.get(0)); //we don't want to verify this

  InOrder inOrder = inOrder(ignoreStubs(list));
  inOrder.verify(list).add(0);
  inOrder.verify(list).clear();
  inOrder.verifyNoMoreInteractions();
 </code></pre>存根调用将使用进行自动验证<a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a>功能，它消除了对<code>ignoreStubs()</code> 。下面的示例使用JUnit规则：<pre class="code"><code class="java">
  &#064;Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

  List list = mock(List.class);
  when(list.get(0)).thenReturn("foo");

  list.size();
  verify(list).size();

  list.get(0); // Automatically verified by STRICT_STUBS
  verifyNoMoreInteractions(list); // No need of ignoreStubs()
 </code></pre></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>mocks</code> -将要更改的输入模拟</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>作为参数传递的相同模拟</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>1.9.0</dd>
</dl>
</li>
</ul>
<a name="times-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>次</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;times(int&nbsp;wantedNumberOfInvocations)</pre>
<div class="block">允许验证确切的调用次数。例如：<pre class="code"><code class="java">
   verify(mock, times(2)).someMethod("some arg");
 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>wantedNumberOfInvocations</code> -想要的调用次数</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="never--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>决不</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;never()</pre>
<div class="block">别名<code>times(0)</code> ，请参阅<a href="../../org/mockito/Mockito.html#times-int-"><code>times(int)</code></a>
 <p>验证没有发生交互。例如：</p><pre class="code"><code class="java">
   verify(mock, never()).someMethod();
 </code></pre>

 <p>如果您想验证模拟签出没有互动<a href="../../org/mockito/Mockito.html#verifyZeroInteractions-java.lang.Object...-"><code>verifyZeroInteractions(Object...)</code></a>要么<a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions-java.lang.Object...-"><code>verifyNoMoreInteractions(Object...)</code></a>
 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="atLeastOnce--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>至少一次</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;atLeastOnce()</pre>
<div class="block">允许至少一次验证。例如：<pre class="code"><code class="java">
   verify(mock, atLeastOnce()).someMethod("some arg");
 </code></pre>别名<code>atLeast(1)</code> 。
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="atLeast-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>至少</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;atLeast(int&nbsp;minNumberOfInvocations)</pre>
<div class="block">允许至少x验证。例如：<pre class="code"><code class="java">
   verify(mock, atLeast(3)).someMethod("some arg");
 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>minNumberOfInvocations</code> -最小调用次数</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="atMostOnce--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atMostOnce</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;atMostOnce()</pre>
<div class="block">允许最多一次验证。例如：<pre class="code"><code class="java">
   verify(mock, atMostOnce()).someMethod("some arg");
 </code></pre>别名<code>atMost(1)</code> 。
 <p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="atMost-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>最多</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;atMost(int&nbsp;maxNumberOfInvocations)</pre>
<div class="block">允许最多x验证。例如：<pre class="code"><code class="java">
   verify(mock, atMost(3)).someMethod("some arg");
 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>maxNumberOfInvocations</code> -最大调用次数</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="calls-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>来电</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;calls(int&nbsp;wantedNumberOfInvocations)</pre>
<div class="block">允许顺序进行非贪婪验证。例如<pre class="code"><code class="java">
   inOrder.verify( mock, calls( 2 )).someMethod( "some arg" );
 </code></pre>
 <ul>
 <li>如果该方法被调用3次，则不会失败，与times（2）不同</li>
 <li>不会将第三次调用标记为已验证，这与atLeast（2）不同</li>
 </ul>此验证模式只能与订单验证一起使用。</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>wantedNumberOfInvocations</code> -要验证的调用次数</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="only--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>只要</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;only()</pre>
<div class="block">允许检查给定方法是否是唯一调用的方法。例如：<pre class="code"><code class="java">
   verify(mock, only()).someMethod();
   //above is a shorthand for following 2 lines of code:
   verify(mock).someMethod();
   verifyNoMoreInteractions(mock);
 </code></pre>

 <p>也可以看看<a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions-java.lang.Object...-"><code>verifyNoMoreInteractions(Object...)</code></a>
 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
<dl>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
</dl>
</li>
</ul>
<a name="timeout-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>超时</h4>
<pre><a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Deprecated.html?is-external=true" title="class or interface in java.lang">@Deprecated</a>
public static&nbsp;<a href="../../org/mockito/verification/VerificationWithTimeout.html" title="interface in org.mockito.verification">VerificationWithTimeout</a>&nbsp;timeout(long&nbsp;millis)</pre>
<div class="block"><span class="deprecatedLabel">不推荐使用。</span> <span class="deprecationComment">使用<a href="../../org/mockito/Mockito.html#timeout-java.time.Duration-"><code>timeout(Duration)</code></a>代替。</span></div>
<div class="block">验证将反复触发，直到给定的毫秒数为止，从而允许测试异步代码。与模拟对象的交互尚未发生时很有用。广泛使用<code>timeout()</code>方法可能是代码异味-有更好的测试并发代码的方法。
 <p>也可以看看<a href="../../org/mockito/Mockito.html#after-long-"><code>after(long)</code></a>测试异步代码的方法。之间的差异<code>timeout()</code>和<code>after</code>在Javadoc中进行了解释<a href="../../org/mockito/Mockito.html#after-long-"><code>after(long)</code></a> 。

 </p><pre class="code"><code class="java">
   //passes when someMethod() is called no later than within 100 ms
   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
   verify(mock, timeout(100)).someMethod();
   //above is an alias to:
   verify(mock, timeout(100).times(1)).someMethod();

   //passes as soon as someMethod() has been called 2 times under 100 ms
   verify(mock, timeout(100).times(2)).someMethod();

   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
   verify(mock, timeout(100).atLeast(2)).someMethod();
 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>millis</code> --持续时间（以毫秒为单位）</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>允许流畅地指定验证的对象（times（x），atLeast（y）等）</dd>
</dl>
</li>
</ul>
<a name="timeout-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>超时</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationWithTimeout.html" title="interface in org.mockito.verification">VerificationWithTimeout</a>&nbsp;timeout(java.time.Duration&nbsp;timeout)</pre>
<div class="block">验证将反复触发直到给定的时间，从而允许测试异步代码。与模拟对象的交互尚未发生时很有用。广泛使用<code>timeout()</code>方法可能是代码异味-有更好的测试并发代码的方法。
 <p>也可以看看<a href="../../org/mockito/Mockito.html#after-java.time.Duration-"><code>after(Duration)</code></a>测试异步代码的方法。之间的差异<code>timeout()</code>和<code>after</code>在Javadoc中进行了解释<a href="../../org/mockito/Mockito.html#after-java.time.Duration-"><code>after(Duration)</code></a> 。

 </p><pre class="code"><code class="java">
   //passes when someMethod() is called no later than within 100 ms
   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
   verify(mock, timeout(Duration.ofMillis(100))).someMethod();
   //above is an alias to:
   verify(mock, timeout(Duration.ofMillis(100)).times(1)).someMethod();

   //passes as soon as someMethod() has been called 2 times under 100 ms
   verify(mock, timeout(Duration.ofMillis(100)).times(2)).someMethod();

   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
   verify(mock, timeout(Duration.ofMillis(100)).atLeast(2)).someMethod();
 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>timeout</code> -超时前要等待多长时间</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>允许流畅地指定验证的对象（times（x），atLeast（y）等）</dd>
</dl>
</li>
</ul>
<a name="after-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>后</h4>
<pre><a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Deprecated.html?is-external=true" title="class or interface in java.lang">@Deprecated</a>
public static&nbsp;<a href="../../org/mockito/verification/VerificationAfterDelay.html" title="interface in org.mockito.verification">VerificationAfterDelay</a>&nbsp;after(long&nbsp;millis)</pre>
<div class="block"><span class="deprecatedLabel">不推荐使用。</span> <span class="deprecationComment">使用<a href="../../org/mockito/Mockito.html#after-java.time.Duration-"><code>after(Duration)</code></a>代替。</span></div>
<div class="block">给定的毫秒数后，将触发验证，从而可以测试异步代码。与模拟对象的交互尚未发生时很有用。广泛使用<code>after()</code>方法可能是代码异味-有更好的测试并发代码的方法。
 <p>尚未实现与InOrder验证一起使用。
 </p><p>也可以看看<a href="../../org/mockito/Mockito.html#timeout-long-"><code>timeout(long)</code></a>测试异步代码的方法。之间的差异<code>timeout()</code>和<code>after()</code>下面说明。

 </p><pre class="code"><code class="java">
   //passes after 100ms, if someMethod() has only been called once at that time.
   verify(mock, after(100)).someMethod();
   //above is an alias to:
   verify(mock, after(100).times(1)).someMethod();

   //passes if someMethod() is called <b>*exactly*</b> 2 times, as tested after 100 millis
   verify(mock, after(100).times(2)).someMethod();

   //passes if someMethod() has not been called, as tested after 100 millis
   verify(mock, after(100).never()).someMethod();

   //verifies someMethod() after a given time span using given verification mode
   //useful only if you have your own custom verification modes.
   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();
 </code></pre>

 <strong>timeout（）与after（）</strong>
 <ul>
     <li>验证通过时，timeout（）会立即成功退出</li>
     <li>after（）等待整个持续时间以检查验证是否通过</li>
 </ul>例子：<pre class="code"><code class="java">
   //1.
   mock.foo();
   verify(mock, after(1000)).foo();
   //waits 1 second and succeeds

   //2.
   mock.foo();
   verify(mock, timeout(1000)).foo();
   //succeeds immediately
 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>millis</code> --持续时间（以毫秒为单位）</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>可以流畅地进行验证的对象</dd>
</dl>
</li>
</ul>
<a name="after-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>后</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationAfterDelay.html" title="interface in org.mockito.verification">VerificationAfterDelay</a>&nbsp;after(java.time.Duration&nbsp;delay)</pre>
<div class="block">验证将在给定的时间后触发，从而允许测试异步代码。与模拟对象的交互尚未发生时很有用。广泛使用<code>after()</code>方法可能是代码异味-有更好的测试并发代码的方法。
 <p>尚未实现与InOrder验证一起使用。
 </p><p>也可以看看<a href="../../org/mockito/Mockito.html#timeout-java.time.Duration-"><code>timeout(Duration)</code></a>测试异步代码的方法。之间的差异<code>timeout()</code>和<code>after()</code>下面说明。

 </p><pre class="code"><code class="java">
   //passes after 100ms, if someMethod() has only been called once at that time.
   verify(mock, after(Duration.ofMillis(100))).someMethod();
   //above is an alias to:
   verify(mock, after(Duration.ofMillis(100)).times(1)).someMethod();

   //passes if someMethod() is called <b>*exactly*</b> 2 times, as tested after 100 millis
   verify(mock, after(Duration.ofMillis(100)).times(2)).someMethod();

   //passes if someMethod() has not been called, as tested after 100 millis
   verify(mock, after(Duration.ofMillis(100)).never()).someMethod();

   //verifies someMethod() after a given time span using given verification mode
   //useful only if you have your own custom verification modes.
   verify(mock, new After(Duration.ofMillis(100), yourOwnVerificationMode)).someMethod();
 </code></pre>

 <strong>timeout（）与after（）</strong>
 <ul>
     <li>验证通过时，timeout（）会立即成功退出</li>
     <li>after（）等待整个持续时间以检查验证是否通过</li>
 </ul>例子：<pre class="code"><code class="java">
   //1.
   mock.foo();
   verify(mock, after(Duration.ofSeconds(1))).foo();
   //waits 1 second and succeeds

   //2.
   mock.foo();
   verify(mock, timeout(Duration.ofSeconds(1))).foo();
   //succeeds immediately
 </code></pre>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>delay</code> -如何等待触发验证</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>可以流畅地进行验证的对象</dd>
</dl>
</li>
</ul>
<a name="validateMockitoUsage--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validateMockitoUsage</h4>
<pre>public static&nbsp;void&nbsp;validateMockitoUsage()</pre>
<div class="block">首先，如果有任何麻烦，我鼓励您阅读Mockito FAQ： <a href="https://github.com/mockito/mockito/wiki/FAQ">https</a> : <a href="https://github.com/mockito/mockito/wiki/FAQ">//github.com/mockito/mockito/wiki/FAQ</a>
 <p>如有疑问，您也可以张贴到模仿邮件列表： <a href="http://groups.google.com/group/mockito">http</a> : <a href="http://groups.google.com/group/mockito">//groups.google.com/group/mockito</a>
 </p><p>
 <code>validateMockitoUsage()</code> <b>明确验证</b>框架状态以检测对Mockito的无效使用。但是，此功能是可选的， <b>因为Mockito始终会验证使用情况……</b>但是有一个陷阱需要继续阅读。
 </p><p>错误使用的示例：</p><pre class="code"><code class="java">
 //Oops, thenReturn() part is missing:
 when(mock.get());

 //Oops, verified method call is inside verify() where it should be on the outside:
 verify(mock.execute());

 //Oops, missing method to verify:
 verify(mock);
 </code></pre>如果您滥用Mockito，它将抛出异常，以便您知道测试是否正确编写。问题在于，Mockito在您<b>下次</b>使用框架时进行验证（例如，下次验证，存根，调用模拟等）。但是，即使在下一个测试中可能抛出异常，该异常<b>消息仍包含具有</b>缺陷位置的<b>可导航堆栈跟踪元素</b> 。因此，您可以单击并找到滥用Mockito的地方。
 <p>但是有时候，您可能希望显式地验证框架的使用。例如，其中一位用户想放<code>validateMockitoUsage()</code>在他的<code>@After</code>这样他就可以立即知道滥用Mockito的时间。没有它，他早在<b>下次</b>使用该框架<b>时</b>就会知道。拥有的另一个好处<code>validateMockitoUsage()</code>在<code>@After</code>是jUnit运行器和规则将始终在有缺陷的测试方法中失败，而普通的“下次”验证可能会使<b>下一个</b>测试方法失败。但是，即使JUnit可能将下一个测试报告为红色，也不必担心，只需单击异常消息中的可导航堆栈跟踪元素即可立即找到您滥用Mockito的位置。
 </p><p>
 <b>两者内置的亚军： <a href="../../org/mockito/junit/MockitoJUnitRunner.html" title="org.mockito.junit中的类"><code>MockitoJUnitRunner</code></a>和规则： <a href="../../org/mockito/junit/MockitoRule.html" title="org.mockito.junit中的接口"><code>MockitoRule</code></a></b>在每种测试方法之后执行validateMockitoUsage（）。
 </p><p>请记住， <b>通常您不必<code>validateMockitoUsage()</code></b>并且下次触发的框架验证应该足够，主要是因为增强了异常消息以及可单击的缺陷位置。但是，如果您已经具有足够的测试基础结构（例如，您自己的运行程序或所有测试的基类），我建议您使用validateMockitoUsage（），因为在<code>@After</code>零成本。
 </p><p>请参阅javadoc中的示例以获取<a href="../../org/mockito/Mockito.html" title="org.mockito中的类"><code>Mockito</code></a>类</p></div>
</li>
</ul>
<a name="withSettings--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withSettings</h4>
<pre>public static&nbsp;<a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a>&nbsp;withSettings()</pre>
<div class="block">允许使用其他模拟设置进行模拟创建。
 <p>不要经常使用它。考虑编写使用简单模拟的简单测试。跟我重复：简单的测试会推送简单，吻合，可读和可维护的代码。如果您不能以简单的方式编写测试，请重构测试代码。</p><p>模拟设置的示例：</p><pre class="code"><code class="java">
   //Creates mock with different default answer & name
   Foo mock = mock(Foo.class, withSettings()
       .defaultAnswer(RETURNS_SMART_NULLS)
       .name("cool mockie"));

   //Creates mock with different default answer, descriptive name and extra interfaces
   Foo mock = mock(Foo.class, withSettings()
       .defaultAnswer(RETURNS_SMART_NULLS)
       .name("cool mockie")
       .extraInterfaces(Bar.class));
 </code></pre>
 <a href="../../org/mockito/MockSettings.html" title="org.mockito中的接口"><code>MockSettings</code></a>之所以被介绍有两个原因。首先，为了在需求到来时轻松添加其他模拟设置。其次，启用组合不同的模拟设置而无需引入成千上万的重载模拟（）方法。
 <p>参见javadoc <a href="../../org/mockito/MockSettings.html" title="org.mockito中的接口"><code>MockSettings</code></a>了解可能的模拟设置。
 </p><p></p></div>
<dl>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>具有默认值的模拟设置实例。</dd>
</dl>
</li>
</ul>
<a name="description-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>描述</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;description(<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;description)</pre>
<div class="block">添加验证失败时要打印的描述。
 <pre class="code"><code class="java">
 verify(mock, description("This will print on failure")).someMethod("some arg");
 </code></pre></div>
<dl>
<dt><span class="paramLabel">参数：</span></dt>
<dd><code>description</code> -失败时打印的说明。</dd>
<dt><span class="returnLabel">返回值：</span></dt>
<dd>验证方式</dd>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>2.1.0</dd>
</dl>
</li>
</ul>
<a name="framework--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>构架</h4>
<pre><a href="../../org/mockito/Incubating.html" title="annotation in org.mockito">@Incubating</a>
public static&nbsp;<a href="../../org/mockito/MockitoFramework.html" title="interface in org.mockito">MockitoFramework</a>&nbsp;framework()</pre>
<div class="block">适用于高级用户或框架集成商。看到<a href="../../org/mockito/MockitoFramework.html" title="org.mockito中的接口"><code>MockitoFramework</code></a>类。</div>
<dl>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>2.1.0</dd>
</dl>
</li>
</ul>
<a name="mockitoSession--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>模拟会话</h4>
<pre><a href="../../org/mockito/Incubating.html" title="annotation in org.mockito">@Incubating</a>
public static&nbsp;<a href="../../org/mockito/session/MockitoSessionBuilder.html" title="interface in org.mockito.session">MockitoSessionBuilder</a>&nbsp;mockitoSession()</pre>
<div class="block"><code>MockitoSession</code>是一项强烈推荐的可选功能，它通过消除样板代码并增加额外的验证来帮助进行更清洁的测试。
 <p>有关更多信息，包括用例和示例代码，请参见javadoc以获取更多信息。 <a href="../../org/mockito/MockitoSession.html" title="org.mockito中的接口"><code>MockitoSession</code></a> 。</p></div>
<dl>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>2.7.0</dd>
</dl>
</li>
</ul>
<a name="lenient--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>宽容</h4>
<pre><a href="../../org/mockito/Incubating.html" title="annotation in org.mockito">@Incubating</a>
public static&nbsp;<a href="../../org/mockito/stubbing/LenientStubber.html" title="interface in org.mockito.stubbing">LenientStubber</a>&nbsp;lenient()</pre>
<div class="block">宽大的存根绕过“严格存根”验证（请参阅<a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a> ）。当存根声明为宽松时，将不会检查是否存在潜在的存根问题，例如“不必要的存根”（ <a href="../../org/mockito/exceptions/misusing/UnnecessaryStubbingException.html" title="org.mockito.exceptions.misusing中的类"><code>UnnecessaryStubbingException</code></a> ）或“存根参数不匹配” <a href="../../org/mockito/exceptions/misusing/PotentialStubbingProblem.html" title="org.mockito.exceptions.misusing中的类"><code>PotentialStubbingProblem</code></a> 。

 <pre class="code"><code class="java">
   lenient().when(mock.foo()).thenReturn("ok");
 </code></pre>大多数测试中的大多数模拟不需要宽大处理，并且应该愉快地与<a href="../../org/mockito/quality/Strictness.html#STRICT_STUBS"><code>Strictness.STRICT_STUBS</code></a> 。
 <ul>
     <li>如果特定的存根需要宽大，请使用此方法</li>
     <li>如果特定的模拟游戏需要宽大，请使用<a href="../../org/mockito/MockSettings.html#lenient--"><code>MockSettings.lenient()</code></a></li>
     <li>如果特定的测试方法/测试类需要使所有的测试表都宽松，请使用我们的JUnit支持配置严格性（ <a href="../../org/mockito/junit/MockitoJUnit.html" title="org.mockito.junit中的类"><code>MockitoJUnit</code></a>或Mockito会话（ <a href="../../org/mockito/MockitoSession.html" title="org.mockito中的接口"><code>MockitoSession</code></a> ）</li>

 <h3>详尽的例子</h3>在下面的示例中，“ foo.foo（）”是一个存根，已移至“ before（）”方法中以避免重复。这样做会使其中一种测试方法（'test3（）'）失败，并出现“不必要的存根”。为了解决这个问题，我们可以将'before（）'方法中的'foo.foo（）'存根配置为宽松。或者，我们可以将整个“ foo”模拟配置为宽松。
 <p>此示例是简化的，并不现实。将存根推送到“ before（）”方法可能会导致测试的可读性降低。在测试中重复一些是可以的，使用您自己的判断来编写出色的测试！不需要从测试代码中消除所有可能的重复，因为这可能会增加复杂性并隐藏重要的测试信息。

 </p><pre class="code"><code class="java">
 public class SomeTest {

     &#064;Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(STRICT_STUBS);

     &#064;Mock Foo foo;
     &#064;Mock Bar bar;

     &#064;Before public void before() {
         when(foo.foo()).thenReturn("ok");

         // it is better to configure the stubbing to be lenient:
         // lenient().when(foo.foo()).thenReturn("ok");

         // or the entire mock to be lenient:
         // foo = mock(Foo.class, withSettings().lenient());
     }

     &#064;Test public void test1() {
         foo.foo();
     }

     &#064;Test public void test2() {
         foo.foo();
     }

     &#064;Test public void test3() {
         bar.bar();
     }
 }
 </code></pre></ul></div>
<dl>
<dt><span class="simpleTagLabel">以来：</span></dt>
<dd>2.20.0</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../overview-summary.html">总览</a></li>
<li><a href="package-summary.html">包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Mockito.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../deprecated-list.html">不推荐使用</a></li>
<li><a href="../../index-files/index-1.html">指数</a></li>
<li><a href="../../help-doc.html">救命</a></li>
</ul>
<div class="aboutLanguage"><em id="mockito-version-header-javadoc7-footer"><strong>Mockito 3.2.0 API</strong></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/mockito/MockingDetails.html" title="org.mockito中的接口"><span class="typeNameLink">上一课</span></a></li>
<li><a href="../../org/mockito/MockitoAnnotations.html" title="org.mockito中的类"><span class="typeNameLink">下一班</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/mockito/Mockito.html" target="_top">镜框</a></li>
<li><a href="Mockito.html" target="_top">没有框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">所有课程</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>摘要：</li>
<li>嵌套|</li>
<li><a href="#field.summary">领域</a></li>
<li><a href="#constructor.summary">建设</a> |</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详情：</li>
<li><a href="#field.detail">领域</a></li>
<li><a href="#constructor.detail">建设</a> |</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><script type="text/javascript" src="../../js/jdk6-project-version-insert.min.js"></script><script type="text/javascript" src="../../js/jquery-1.7.min.js"></script><script type="text/javascript" src="../../js/highlight-8.6-java/highlight.pack.js"></script><link rel="stylesheet" type="text/css" href="../../js/highlight-8.6-java/styles/obsidian.css"><script type="text/javascript" src="../../js/index.js" async defer></script>    </small></p>


</body></html>