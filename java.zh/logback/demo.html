<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>登入示范</title>
    <link rel="stylesheet" type="text/css" href="css/common.css">
    <link rel="stylesheet" type="text/css" href="css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/_print.css" media="print">
  </head>
  <body >
    <script type="text/javascript">prefix=''; </script>

    <script src="templates/header.js" type="text/javascript"></script>
    <div id="left">
      <script src="templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="templates/right.js" type="text/javascript"></script>
    </div>

    <div id="content">
      
	
    <h2>登入示范</h2>

    <p>欢迎使用logback演示！本文档将带您浏览Logback的一些主要功能。
    </p>
    
    <h3>安装</h3>

    <p>首先，请下载logback演示。您将需要安装<a href="http://git-scm.com/">git</a>客户端并在控制台上发出以下命令：</p>
  
    <p class="source">git clone git：//github.com/qos-ch/logback-demo.git logback-demo</p>

    <p>这会将logback演示Web应用程序的副本检索到名为<em>logback-demo</em>的目录中。可以将logback演示打包为<em>war</em>文件并将其部署到应用程序服务器。我们强烈建议使用<a href="http://maven.apache.org/">Maven</a>完成此任务，因为它只需一个命令即可编译，打包和运行此演示。
    </p>

    <p>使用Maven，让我们打包文件并首次运行演示。从<em>logback-demo</em>目录中，发出以下命令：</p>

    <div class="source"><pre>mvn package jetty:run</pre></div>
    
    <p>然后，访问<a href="http://localhost:8080/">http：// localhost：8080 /</a>以查看登录示例的主页。
    </p>

    <h3>经典的Logback</h3>

    <p>默认情况下（或打包时），logback-demo使用两个附加程序配置logback-classic： <code>ConsoleAppender</code>和一个<code>RollingFileAppender</code> 。的<code>RollingFileAppender</code>将记录事件发送到名为<em>logFile.log</em>的文件，并将每分钟翻转活动文件。旧文件将被重命名并压缩为<em>zip</em>文件。的<code>ConsoleAppender</code>会将日志记录请求输出到控制台，并缩短日志记录器名称以在控制台窗口上获得空间，而不会失去可读性。例如， <code>ch.qos.logback.demo.prime.NumberCruncherImpl</code>将缩写为<code>c.q.l.d.prime.NumberCruncherImpl</code> 。
    </p>

  <p>我们强烈建议您研究<em>src / main / resources /</em>文件夹下的<em>logback.xml</em>配置文件。您可能想在编辑器窗口中保持此文件的打开状态，因为我们将在演示过程中修改其内容。
  </p>

  <p>现在，让我们通过浏览器窗口左侧的导航菜单访问<em>ViewStatii</em>页面。此页面包含<code>Status</code>到目前为止创建的对象。 <code>Status</code>对象是logback内部报告框架的一部分。它们使您可以查看回发内发生的事情，并检查配置文件是否已正确解析，或者是否按预期发生了翻转。
  </p>

  <p>您应该看到控制台上打印的日志消息，并且每分钟都会滚动显示“ logFile.log”文件的内容。
  </p>

  <p>如果访问“ <em>查看日志”</em>页面（通过单击左侧菜单中的链接），您应该看到它没有内容。让我们通过取消注释配置文件中的<strong>两个</strong>部分来更改它。</p>

  <p>删除周围的评论</p>

  <p class="source"><!-- Basic Cyclic buffer
<appender name="CYCLIC" class="ch.qos.logback.core.read.CyclicBufferAppender">
  <MaxSize>512</MaxSize>
</appender>
--></p>
  <p>和周围</p>

  <p class="source"><!-- Part I: Basic Cyclic buffer
<appender-ref ref="CYCLIC" />
--></p>

  <p>的<code><appender-ref></code>在配置文件末尾找到的元素会将附加程序链接到给定的记录器，在这种情况下，是指根记录器。
  </p>

  <p>一种<code>CyclicBuffer</code>在<a href="http://en.wikipedia.org/wiki/Circular_buffer">循环缓冲区中</a>跟踪传入的日志事件流，以供以后显示。在除去上面显示的两个元素周围的注释之后，通过使用<em>CTRL-C</em>退出先前的“ mvn”命令并再次发出来重新加载logback-demo Web应用程序：</p>

  <p class="source">mvn package jetty：run</p>

  <p>这次，“ <em>查看日志”</em>页面应包含内容。</p>

  <img src="images/cyclicView.png" alt="查看日志">


  <p>凭借<code>CyclicBufferAppender</code> ，此页面可以获取最后的事件并通过servlet呈现它们。我们看到每十秒钟就有一行添加到日志中。该页面的格式是通过<code>HTMLLayout</code> 。该组件根据描述您希望在表中看到的信息的模式创建一个包含日志事件的表。
  </p>

  <p>使日志混乱<em>不堪</em> ，重复重复的“ <em>Howdydy-diddly-ho”</em>消息非常浪费。我们可以使用适当的过滤器摆脱它们。<em>用Evaluator</em>取消注释名为<em>Cyclic buffer</em>的块。然后，您应该注释我们前面未注释的标题为“基本循环缓冲区”的块。</p>

  <p>让我们看一下刚刚添加的过滤器：</p>

<p class="source"><filter class="ch.qos.logback.core.filter.EvaluatorFilter">
  <evaluator name="loggingTaskEval"><expression><b>logger.getName（）。contains（“ LoggingTask”）&& message.contains（“ Howdydy-diddly-ho”）&&（timeStamp-event.getStartTime（））> = 20000</b></expression></evaluator> <onmatch>DENY</onmatch>
</filter></p>

  <p>的<code><expression></code>元素使用熟悉的Java语言语法。它检查记录器的名称是否包含String <em>LoggingTask</em> ，还检查其消息是否包含字符串<em>Howdydy-diddly-ho</em> 。此外，为了确保<em>Howdydy-diddly-ho</em>任务确实有效，我们添加了最后一个条件，该条件检查应用程序启动后至少经过20秒。表达式中的变量引用，即（ <code>logger</code> ， <code>message</code>和<code>event</code> ）通过登录隐式提供。的<code><OnMatch></code>元素使用户可以在表达式匹配（评估为true）后指定过滤器的行为。
  </p>

  <p>重新启动后，“ <em>查看日志”</em>页面将显示<em>Howdydy-diddly-ho</em>日志，但仅在前20秒钟。如果希望看到新的日志记录事件显示在“查看日志”页面上，请访问“ Prime号”页面。
  </p>

  <h4>涡轮过滤器</h4>

  <p>Logback支持称为TurboFilters的特殊过滤器类别。 <code>TurboFilter</code>对象是超快速的上下文范围过滤器。通过设置上下文范围（即全局）条件来启用或禁用日志记录事件，它们可能非常有用。
  </p>

  <p>删除标题为“ TurboFilter：MDC值”的块周围的注释。</p>

  <p class="source"><turbofilter class="ch.qos.logback.classic.turbo.MDCFilter">
  <mdckey>用户名</mdckey> <value>sebastien</value> <onmatch>接受</onmatch>
</turbofilter></p>


  <p>这个<code><turboFilter></code>元素添加一个<code>TurboFilter</code>如果MDC包含名为“用户名”的键，并将其设置为值“ sebastien”，则该日志上下文将启用事件。logback-demo应用程序包含一个<a href="http://java.sun.com/products/servlet/Filters.html">servlet过滤器</a> ，该<a href="http://java.sun.com/products/servlet/Filters.html">过滤器</a>将MDC密钥“ username”设置为当前登录用户的名称。</p>


  <p>就本演示而言，让我们通过将根记录器的级别设置为来禁用所有记录<code>OFF</code> 。
  </p>

  <p class="source"><root>
  <level><b="">value =“ OFF” /> ...
</b=""></level></root></p>

  <p>现在像以前一样重新启动服务器。</p>

  <p>再次进入主演示网页后，执行许多操作（例如，计算一些质数）并访问“ <em>查看日志”</em>页面。该表应为空。
  </p>

  <p>现在，使用用户名<em>sebastien</em>登录到logback-demo Web应用程序，并执行一些主要计算。“ <em>查看日志”</em>页面应显示生成的日志事件。此外，每个日志记录事件将具有一个MDC字段，该字段与登录用户的名称（在本例中为sebastien）相关联。在继续演示之前，请使用左侧的<em>注销</em>按钮<em>注销</em> 。</p>

 <img src="images/turboFilterForMDC.png" alt="直流滤波器">

 <h4>参数化记录</h4>

 <p><a href="http://www.slf4j.org/faq.html#logging_performance">参数化日志记录</a>本质上不是回溯功能。它是SLF4J的一部分。通常，发出日志记录请求如下：</p>

<div class="source"><pre>logger.debug("Hello, my name is" + username + ", I am " + age + " years old.");</pre></div>

  <p>在上述调用中，即使禁用了日志请求，也要承担构造String类型消息的成本。
  </p>

  <p>SLF4J提供以下替代方案：</p>

<div class="source"><pre>logger.debug("Hello, my name is {}, I am {} years old", username, age);</pre></div>

  <p>在这种替代方法中，仅在启用log语句后，才会格式化最终日志消息。
  </p>

  <p>目前，让我们看看我们可以从这种替代方法中获得什么样的收益。首先，转到质<em>数</em>页，然后为您选择的整数计算因数。检查计算结果所需的时间。若要查看两种格式方法之间更明显的区别，您可能需要尝试在质数文本框下方列出的两个大整数。记下计算结果所需的时间。
  </p>

  <p>现在让我们编辑<code>NumberCruncherImpl</code>类以使用参数化日志记录。您可以在<em>src / main / java / ch / qos / logback / demo / prime /</em>目录中找到此类。注释行54（执行无条件消息串联）和注释不行55（参数化日志记录）。使用<em>mvn软件包jetty：run</em>重新启动服务器，然后重新运行您之前尝试过的分解。
  </p>

  <p>完成计算所需的时间应该大大减少。请记住，在本演示的上一步中，我们已关闭了所有日志记录。在初始版本中，每次测试一个因素时，我们都在构造消息（ <em>“尝试将“ + i +”作为一个因素。”</em> ）。使用参数化日志记录，消息的构造被推迟，并且由于关闭了日志记录，因此从未完成。因此，参数化日志记录可以显着降低禁用的日志语句的成本。
  </p>

  <h4>标记物</h4>

  <p>您可以使用<em>标记为</em>日志语句添加颜色。标记是SLF4J API的一部分。如果查看包含<em>Howdydy-diddly-ho</em> log语句的LoggingTask类（logback-demo的一部分），您应该看到它已绑定到名为<code>HOWDY</code>标记。如果您希望删除带有以下内容的日志语句： <code>HOWDY</code>标记，您可以使用此<code>TurboFilter</code>这样做：</p>

  <p class="source"><turbofilter class="ch.qos.logback.classic.turbo.MarkerFilter">
    <name>HOWDY_FILTER</name> <marker>HOWDY</marker> <onmatch>DENY</onmatch>
</turbofilter> </p>
  
  <p>你已经设置了根记录的水平回<em>调试</em>和注释掉在<em>logback.xml</em>的MarkerFilter块后，重新启动服务器。
  </p>


  <p>带有<em>Howdydy-diddly-ho</em>消息的日志应不再出现，因为它们与HOWDY标记关联。您可以通过访问“ <em>查看日志”</em>页面进行检查。
  </p>

  <h2>登录回访</h2>

  <p>访问日志记录是logback提供的另一个重要功能。默认情况下，配置了logback-demo Web应用程序，以便每次访问它时，都会在控制台上打印访问日志。访问日志的详细信息由位于<em>src / etc /</em>目录下的<em>logback-access.xml</em>文件配置。
  </p>

  <p>这是用于注销访问的相当简单的配置：</p>

<div class="source"><pre>&lt;configuration>
 
  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout class="ch.qos.logback.access.PatternLayout">
      &lt;Pattern>%h %l %u %t \"%r\" %s %b&lt;/Pattern>
    &lt;/layout>
  &lt;/appender>
  
  &lt;appender-ref ref="STDOUT" />
  
&lt;/configuration></pre></div>

  <p>请注意，经典的logback和logback-access是通过不同的文件配置的：分别为<em>logback.xml</em>和<em>logback-access.xml</em> 。如果您想通过将根记录器的级别设置为OFF来关闭经典的logback日志记录，则此更改不会影响logback-access。
  </p>

  <p>要查看由logback-access生成的日志，只需访问几页并查看您的控制台。每行中包含的信息已在配置文件中指定。的<code>ConsoleAppender</code>名为<em>STDOUT</em>的<code>PatternLayout</code>零件。此布局组件在经典的logback中用于显示消息，记录器名称或请求级别，而在logback-access中则用于显示请求方法，请求的页面，状态代码和许多其他字段。
  </p>

<p>这是此附加程序的示例输出。</p>

<div class="source"><pre>127.0.0.1 - - 22/Jan/2007:14:35:40 +0100 GET /logback-demo/ViewStatii.do HTTP/1.1 200 3660
127.0.0.1 - - 22/Jan/2007:14:35:41 +0100 GET /logback-demo/index.jsp HTTP/1.1 200 2389
127.0.0.1 - - 22/Jan/2007:14:35:42 +0100 GET /logback-demo/lastLog/ HTTP/1.1 200 948
127.0.0.1 - - 22/Jan/2007:14:35:42 +0100 GET /logback-demo/index.jsp HTTP/1.1 200 2389
127.0.0.1 - - 22/Jan/2007:14:35:43 +0100 GET /logback-demo/prime.jsp HTTP/1.1 200 1296
127.0.0.1 - - 22/Jan/2007:14:35:44 +0100 GET /logback-demo/index.jsp HTTP/1.1 200 2389
127.0.0.1 - - 22/Jan/2007:14:35:45 +0100 GET /logback-demo/lottery.jsp HTTP/1.1 200 1209
127.0.0.1 - - 22/Jan/2007:14:35:46 +0100 GET /logback-demo/index.jsp HTTP/1.1 200 2389
127.0.0.1 - - 22/Jan/2007:14:35:48 +0100 GET /logback-demo/reload.jsp HTTP/1.1 200 1335
127.0.0.1 - - 22/Jan/2007:14:35:49 +0100 GET /logback-demo/index.jsp HTTP/1.1 200 2389
127.0.0.1 - - 22/Jan/2007:14:35:54 +0100 GET /logback-demo/login.jsp HTTP/1.1 200 1214
127.0.0.1 - - 22/Jan/2007:14:35:55 +0100 GET /logback-demo/Logout.do HTTP/1.1 200 1000</pre></div>

  <h4>筛选</h4>

  <p>在下一部分中，我们将向控制台添加一些信息。让我们想象一下，我们想要记录在“ <em>彩票”</em>页面上尝试过的数字。我们需要一秒钟<code>ConsoleAppender</code>只会打印给定的信息（例如，猜中的数字以及有关播放器的一些提示）。仅当访问特定页面时，附加程序还必须打印该信息。
  </p>

  <p>必要的配置行在下面列出。
  </p>

  <p class="source"><appender name="STDOUT_LOTTERY" class="ch.qos.logback.core.ConsoleAppender">
  <filter class="ch.qos.logback.core.filter.EvaluatorFilter"><evaluator name="lotto_eval"><expression>url.matches（event.getRequestURL（）。toString（））</expression> <matcher name="url"><regex>Lottery.do</regex> <casesensitive>false</casesensitive></matcher></evaluator> <onmatch>接受</onmatch> <onmismatch>拒绝</onmismatch> <evaluator name="lotto_eval"><matcher name="url"><regex>彩票</regex></matcher></evaluator></filter> <layout class="ch.qos.logback.access.PatternLayout"><pattern>：％A [％r] Guess =％reqParameter {guessed_number}</pattern></layout>
</appender></p>

  <p>此追加程序将使用<code>PatternLayout</code>格式化其输出。<em>％reqParameter</em>转换字用于从请求中提取猜测的数字并进行打印。
  </p>

  <p>它还使用<code>EvaluatorFilter</code>当访问的请求网址与给定表达式不匹配时，这将阻止追加程序显示任何内容。您可以看到，很容易指定一个RegExp，对其进行命名并在将要计算的表达式中使用它。在这种情况下，我们仅输入<em>lottery.do</em>操作的名称。
  </p>

  <p>让我们用“ <em>彩票到控制台”</em>注释取消注释这两个元素，然后重新启动服务器。现在，尝试玩彩票。到目前为止，您将在控制台中看到更多行。在每次尝试时，logback都会生成如下所示的日志：</p>

  <p class="source">彩票：192.168.1.6 [POST /logback-demo/Lottery.do HTTP / 1.1] Guess = 321</p>

  <h4>发送邮件</h4>

  <p>Logback访问提供了经典模块通常使用的几个组件。例如，一个<code>SMTPAppender</code>可用于在发生特定事件时发送电子邮件。在此，我们将在每次检测到中奖者时与彩票管理员联系。为此，我们将添加一个<code>SMTPAppender</code>到现有配置。请将<em>logback-access.xml中</em>名为<em>Lottery</em>的部分取消注释<em>为Email</em> 。不要忘记在引用<em>SMTP</em>附加程序的配置文件末尾取消注释<em>appender-ref</em>元素。在appender元素中，请注意使用了<code>URLEvaluator</code> 。该评估程序使我们可以指定一个或多个要监视的URL。当其中之一被访问时，将发送一封电子邮件。
  </p>

  <p>在测试新组件之前，必须重新配置。完成后，尝试用数字<em>99</em>玩彩票。您应该看到“祝贺”消息，但最重要的是，指定的收件人的邮箱中应该有一封新邮件。电子邮件的内容是格式良好的HTML表，其中包含有关触发事件之前发生的访问的信息。
  </p>

  <h3>JMX</h3>

  <p>Logback通过JMX发布了几个组件。这使您可以查看某些对象的状态，并更改几个配置参数。Jetty和Tomcat可以通过JMX发布logback的组件。有关JMXConfigurator的更多信息，请参考手册中的<a href="manual/jmxConfig.html">相关章节</a> 。
  </p>

  <p>让我们使用配置器测试设置级别。“质<em>数”</em>页面请求两种类型的日志。当计算检查数字是否为因数时，将显示<em>DEBUG</em>日志。当计算找到一个因数时，将显示一个<em>INFO</em>日志。
  </p>

  <p>让我们首先将名为<em>ch.qos.logback.demo.prime</em>的记录器的级别设置为<em>DEBUG</em> 。直接运行素数计算，而无需重新启动服务器。“ <em>查看日志”</em>页面应显示<em>DEBUG</em>和<em>INFO</em>日志。
  </p>
  
  <p>现在，如果将<em>ch.qos.logback.demo.prime</em>记录器的级别设置为<em>INFO</em> ，然后再次运行初始计算，则应该再也看不到<em>DEBUG</em>级别日志。
  </p>
  
  <p>现在，该注销示例已结束。不要犹豫，玩转配置文件。您可能需要查看“回发<a href="http://logback.qos.ch/documentation.html">文档”页面</a> ，以获取有关要测试的任何组件的更多信息。</p>
	
  <script src="templates/footer.js" type="text/javascript"></script>
</div>


</body></html>