<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第3章logbackの设定</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content" class="chapter">
      
      <h1>第3章logbackの设定</h1>
      
    <div class="quote">
      <p><em>物事の本质を正确に表现するときは，记号を使うのが最も适している。，记号によって表现されたものがあれば，思考に费やす労力が惊くほど軽减されるのだ。</em>
      </p>
      <p>—盖特里·威廉·莱伯尼兹</p>
    </div>


    <script src="../templates/creative.js" type="text/javascript"></script>


    <p>设定スクリプトの例を示しながら，登录の设定方法を说明していきます。logbackはJoranという设定フレームワークを利用しています。Joranについては<a href="./11-onJoran.html">后の章</a>で绍介します。
    </p>


    <h2 class="doAnchor" name="auto_configuration">logbackの设定</h2>
    
    <p>アプリケーションコードにロギング要求を埋め込むには，かなりの计画と作业が必要です。调查したところ，だいたいコード全体の4％ほどがロギングのために使われていました。数千，そこそこの规模のアプリケーションであっても，千行のロギング行が含まれることになるのです。をの数を考えれば，私たちにロギンギ式グ管理するためのツールが必要となる理由が理解できるのではないでしょうか。
    </p>

    <p>logbackはプログラム的ム设定することもできるし，XMLやGroovyで记述された设定スクリプトで设定することもできます。なお，log4jユーザーのために， <em>log4j.propertiesファイル</em>を<em>logback.xml</em>に変换する<a href="http://logback.qos.ch/translator/">PropertiesTranslator</a>を用意しています。

    </p>

    <p>log，logbackが设定するところを顺番に见ていきましょう。</p>

    <ol>
      <li>
        <p>logbackは<a href="./faq.html#configFileLocation">クラスパス</a>上で<em>logback.groovy</em>というファイルを探します。</p>
      </li>

      <li>
        <p>见つからなかったら，今度は<a href="./faq.html#configFileLocation">クラスパス</a>上で<em>logback-test.xml</em>というファイルを探します。</p>
      </li>

      <li><p>见つからなかったら，今度は<a href="./faq.html#configFileLocation">クラスパス</a>上で<em>logback.xml</em>というファイルを探します。</p>
      </li>
      
      <li><p>何も见つからなかったら，自动的に<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/BasicConfigurator.html"><code>BasicConfigurator</code></a>を使って设定します。ロギング出力は直接コンソールに出力されるようになります。
      </p> 
      </li> 

    </ol>

    <p>四番目のステップは，设定ファイルが见つからなかった场合デフォルトの（ごく基本的な）设定をする，ということです。
    </p>


    <p>もしMavenを使用しているなら， <em>src / test / resources</em>フォルダの下に<em>logback-test.xml</em>を放置いている场合でも，それがアーティファクトに入り込まないことはMavenによって保证されます。したがって，テスト用と実际の环境用で， <em>logback-test.xml</em>と<em>logback.xml</em>を使い分けることができます。Antでも原则的に同じことができます。
    </p>


    <h3 class="doAnchor" name="automaticConf">logbackの自动设定</h3>

    <p>logbackを设定する一番简単な方法は，デフォルト设定を使わせることです。仮に<code>MyApp1</code>というアプリケーションがあるつもりで，これがどのように行われるのか详しく见てみましょう。
    </p>

    <p class="example">例： <code>BasicConfigurator</code>の使用例（ <a href="http://logback.qos.ch/xref/chapters/configuration/MyApp1.html">logback-examples / src / main / java / chapters / configuration / MyApp1.java</a> ）</p>

    <pre class="prettyprint source">package manual.configuration;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyApp1 {
  final static Logger logger = LoggerFactory.getLogger(MyApp1.class);

  public static void main(String[] args) {
    logger.info("Entering application.");

    Foo foo = new Foo();
    foo.doIt();
    logger.info("Exiting application.");
  }
}</pre>

  <p>このクラスでは，ロガーを静的クラスメンバ変数として定义しています。その后， <code>Foo</code>クラスのオブジェクトを生成します。<code>Foo</code>クラスの定义は次のとおりです。</p>

  <p class="example">例：ロギングするクラスの例（ <a href="http://logback.qos.ch/xref/chapters/configuration/Foo.html">logback-examples / src / main / java / chapters / configuration / Foo.java</a> ）</p>

  <pre class="prettyprint source">package chapters.configuration;
  
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
   
public class Foo {
  static final Logger logger = LoggerFactory.getLogger(Foo.class);
  
  public void doIt() {
    logger.debug("Did it again!");
  }
}</pre>


    <p>での章で绍介しているサンプルプログラグラムを実行するには，クラスパスに所定のjarファイルを置いておかなければなりません。详しくは<a href="http://logback.qos.ch/setup.html">セットアップ</a>の说明をを参照してください。
    </p>

    <p><em>logback-test.xml</em>も<em>logback.xml</em>も无い<em>场合</em> ，logbackは<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/BasicConfigurator.html"><code>BasicConfigurator</code></a>によって最小限の设定を行います。最小限の设定としてやることは，ルートロガーに<code>ConsoleAppender</code>を割り当てることだけです。出力は<code>PatternLayoutEncoder</code>式书式化されます。<code>PatternLayoutEncoder</code>には， <em>％d {HH：mm：ss。SSS} [％thread]％-5level％logger {36}-％msg％n</em>という书式化パターンが设定されています。また，ルートロガーにはデフォルトで<code>DEBUG</code>レベルが割り当てられます。
    </p>

    <p><em>Java章节配置MyApp1</em>を実行すると次のような出力が得られます。</p>

    <p class="source">16：06：09.031 [main] INFO章节。配置。MyApp1-输入应用程序。16：06：09.046 [main] DEBUG章节。配置。Foo-再来一次！16：06：09.046 [main] INFO章节。配置。MyApp1-退出应用程序。</p>


   <p class="highlight">（あるとしたら）logbackを设置するコード其他に，クライアントコードは一切logbackに依存しません。ロギングフレームワークとしてlogbackを使用するアプリケーションがコンパイル时に依存するのはSLF4Jであって，logbackではありません。
   </p>

   <p><code>MyApp1</code>アプリケーションとlogbackのリンクは，アプリケーションが呼び出した<code>org.slf4j.LoggerFactory</code>クラスと<code>org.slf4j.Logger</code>クラスによって行われます。これらのクラスは，使用するロガーを（クラスローダーから？）取得し，つなぎあわせます。<code>Foo</code>クラスからlogbackへの依存は， <code>org.slf4j.LoggerFactory</code>と<code>org.slf4j.Logger</code>の进口を介した间接的なものであることに注意しましょう。SLF4Jはあらゆるロギングフレームワークーから利用するための抽象层を备えています。おかで，ほとんどのコードをあるロギンギフレームワークムワ别のロギングフレームワーにークに移行するのがとても简単になっています。
   </p>

   <h3><em>logback-test.xml</em>または<em>logback.xml</em>による自动设置</h3>

   <p>向前したとおり，logbackはクラスパス上で<em>logback-test.xml</em>や<em>logback.xml</em>を探して自分を设定しようとします。次に示す设定ファイルは， <code>BasicConfigurator</code>によって行われるのとまったく同じ内容の设定です。
   </p>

   <p class="example">例：基本的な设定ファイル（ <a href="http://logback.qos.ch/xref/chapters/configuration/sample0.xml">logback-examples / src / main / java / chapters / configuration / sample0.xml</a> ）</p>
   <span class="asGroovy" onclick="return asGroovy('sample0');">Groovyで见る</span>


  <pre id="sample0" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

   <p>ファイル名を<em>sample0.xml</em>から<em>logback.xml</em> （または<em>logback-test.xml</em> ）に変更して，クラスパスに含まれるフォルダに置きましょう。<em>AppMyApp1</em>アプリケーションを実行すると，前の実行例と同じ出力结果が得られるはずです。</p>

   <h4 class="doAnchor" name="automaticStatusPrinting">警告やエラーが発生した际，ステータスメッセージを自动的に出力する</h4>

   <p class="highlight">设定ファイルを解析している间に警告やエラーが発生した场合，登录は内部状态を表すメッセージを自动的にコンソールに出力します。</p>
 
   <p>出力が重复することを避けるため，利用者が明示的にステータスリスナーを登录していた场合（后で例を示します）ステータスの自动出力は无效になります。</p>

   <p>警告やエラーが起きていなくてもlogbackの内部状态を出力させたければ， <code>StatusPrinter</code>クラスの<code>print()</code>メソッドを使えばよいです。次の<em>MyApp2</em>アプリケーションは，内部状态を出力するためのコードが二行追加されていることを除いて<em>MyApp1</em>とまったく同じです。</p>

    <p class="example">例：logbackの内部状态を出力する（ <a href="http://logback.qos.ch/xref/chapters/configuration/MyApp2.html">logback-examples / src / main / java / chapters / configuration / MyApp2.java</a> ）</p>

  
<pre class="prettyprint lang-java source">
  public static void main(String[] args) {
    // SLF4J が logback を使うようになっていると想定
    <b>LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
    // logback の内部状態を出力
    <b>StatusPrinter.print(lc);</b>
    ...
  }</pre>

  <p>何も问题が无ければ，コンソールに次のような出力が表示されます。</p>

   <div class="source longline"><pre>17:44:58,578 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback-test.xml]
17:44:58,671 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - debug attribute not set
17:44:58,671 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.ConsoleAppender]
17:44:58,687 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [STDOUT]
17:44:58,812 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Popping appender named [STDOUT] from the object stack
17:44:58,812 |-INFO in ch.qos.logback.classic.joran.action.LevelAction - root level set to DEBUG
17:44:58,812 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [STDOUT] to Logger[root]

17:44:58.828 [main] INFO  chapters.configuration.MyApp2 - Entering application.
17:44:58.828 [main] DEBUG chapters.configuration.Foo - Did it again!
17:44:58.828 [main] INFO  chapters.configuration.MyApp2 - Exiting application.
</pre></div>

  <p>出力结果の最后の方に，前の例で出力されたものと同じ行があることが分かるでしょう。logbackの内部メッセージには気をつけるようにしてください。<code>Status</code>オブジェクトを使うと内部状态に简単にアクセスできます。
  </p>

   <p>コード中で<code>StatusPrinter</code>をプログラム的に呼び出す代わりに，设定ファイルで内部ステータスを出力するように指定することができます。警告やエラーが起きなくてもです。要素のためには<em>配置</em>要素の<span class="attr">debug</span>属性を设定します。はの要素はXML形式の设定ファイルにおける最上位要素です。后で例を示します。<span class="attr">调试</span>属性はステータス情报にだけしか影响しないことは覚えておいてください。返しますが，logbackの他の设定には<em>影响しません</em> 。ロガーレベルについても同様です。（たとえそうなっていて欲しくても，ルートロガーのログレベルは<code>DEBUG</code>に<em>なりません</em> 。）
   </p>


   <p class="example">例：基本的な设定ファイルをデバッグモードにする（ <a href="http://logback.qos.ch/xref/chapters/configuration/sample1.xml">logbackexamples / src / main / java / chapters / configuration / sample1.xml</a> ）</p>
   <span class="asGroovy" onclick="return asGroovy('sample1');">Groovyで见る</span>

   <pre id="sample1" class="prettyprint source">
&lt;configuration <span class="big bold">debug="true"</span>&gt; 

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; 
    &lt;!-- encoders are  by default assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>
  
   <p>配置要素の<code>debug</code>属性が设定されていると，次のような内部ステータスが出力されます。</p>
   <ol>
     <li>设定ファイルが见つかったかどうか</li>
     <li>设定ファイルのXML文法が适格かどうか</li>
   </ol>
     
   <p>でのいずれかの条件が満たされなかった场合，设定ファイルを読み込むことができないので，Joranには<span class="attr">debug</span>属性を理解することができません。见つかった设定ファイルがXMLとして不适格な场合，logbackはエラーと判断し，自动的に内部状态をコンソールに出力します。ですが，设定ファイルが见つからなかった场合，logbackは内部状态を自动的に出力することはありません。それだけではエラーと见做すには不十分だからです。<a href="http://logback.qos.ch/xref/chapters/configuration/MyApp2.html"><em>MyApp2</em></a>アプリケーションの例で示したように， <code>StatusPrinter.print()</code>をプログラム的に呼び出していれば，どんな偶尔でも内部ステータス情报を确実に出力するようになります。</p>

 
   <p>ステータスメッセージが无くても<span class="label">强制的に</span>内部ステータス情报を出力させていると，不正な<em>logback.xml</em>がどこにあるのか突き止めるのが难しくなります。アプリケーションのソースコードを简単に変更できない商业环境においては特にそうです。不正な设定ファイルの场所を见つけやすくするには，システムプロパティの“ logback.statusListenerClass”（ <a href="./03-configuration.html#logback.statusLC">すぐ后で说明します</a> ）に<code>StatusListener</code>を指定するとよいでしょう。强制，强制的にステータスメッセージを出力させることができます。“ logback.statusListenerClass”システムプロパティを使うと，エラーが発生したときに自动的に出力されるメッセージを抑止することもできます。
   </p>

   <h3 class="doAnchor" name="configFileProperty">设定ステムプロパティでデフォルトの设定ファイルの场所を指定する</h3>

   <p>システムプロパティの<code>"logback.configurationFile"</code>を使えば，デフォルトの设定ファイルの场所を指定することができます。形式のプロパティにはURL形式の値を指定します。クラスパス上のリソースやアプリプーションの外部のファイルを指定することができます。
   </p>

   <p class="source">java <b>-Dlogback.configurationFile = / path / to / config.xml</b>章节配置。MyApp1</p>

   <p>ファイルの拡张子は“ .xml”か“ .groovy”でなければならないので注意してください。他の拡张子の场合は无视します。<a href="./03-configuration.html#logback.statusLC">ステータスリスナーを明示的に登录</a>しておくと，设定ファイルの场所を突き止めるのに役立つでしょう。</p>


   <h3 class="doAnchor" name="autoScan">设定ファイルが変更されたら自动的に再読み込みする</h3>

   <p class="highlight">logback-classicは定义フはイルの変更を监视することができます。そして，なんらか変更があった场合は自动的に再読み込みすることができます。</p>

   <p><code>configuration</code>要素の<span class="attr">扫描</span>属性を设定すると，设定ファイルの监视と自动的な再読み込みができるようになります。

   </p>
  
   <p class="example">例：设定ファイルの変更の监视と自动的な再読み込み（ <a href="http://logback.qos.ch/xref/chapters/configuration/scan1.xml">logback-examples / src / main / java / chapters / configuration / scan1.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('scan1');">Groovyで见る</span>
<pre id="scan1" class="prettyprint source">
&lt;configuration <b>scan="true"</b>&gt; 
  ... 
&lt;/configuration&gt; </pre>


   <p>デフォルトでは，设定ファイルを一分毎に监视します。<code>configuration</code>要素の<span class="attr">scanPeriod</span>属性に，监视周期を设定することができます。设定値はミリ秒，秒，分または时间単位で指定することができます。以下に例を示します。</p>

  <p class="example">例：デフォルトとは异なる监视周期を指定する（ <a href="http://logback.qos.ch/xref/chapters/configuration/scan2.xml">logback-examples / src / main / java / chapters / configuration / scan2.xml</a> ）</p>
  <span class="asGroovy" onclick="return asGroovy('scan2');">Groovyで见る</span>
  <pre id="scan2" class="prettyprint source">
&lt;configuration scan="true" <b>scanPeriod="30 seconds"</b> &gt; 
  ...
&lt;/configuration&gt; </pre>

   <p>时间の単位を指定しなかった场合ミリ秒として扱われますが，たいていの偶然偶然切だと思いますので<span class="label">注意</span>してください。时间単位を指定することを忘れないでください。
   </p>

   <p>舞台里で起きていることを说明しましょう。scan属性にtrueを指定すると， <a href="http://logback.qos.ch/xref/ch/qos/logback/classic/turbo/ReconfigureOnChangeFilter.html">ReconfigureOnChangeFilter</a>という<code>TurboFilter</code>の派生クラスがインストールされます。TurboFiltersについては<a href="./filters.html#TurboFilter">后の章</a>で说明します。设定ファイルのスキャンは「内部スレッド」で行います。ロガーの出力メソッドが呼び出されるときは常にスキャンされるということです。（で注：正确には，出力メソッドが呼び出されるたびにフィルタが评タがので，その都度logbackのコンテキストに指定された。Thread，ThreadExecutorの管理するスレッドによって実行されます。）例えば，scan属性にtrueが设定されている场合， <code>myLogger</code>というロガーを使った「myLoger.debug（“ hello”）;」というロガンを式があったら，このロギング式が実行されるたびに<code>ReconfigureOnChangeFilter</code>が呼び出されることになります。さらに言うと， <code>myLogger</code>でDEBUGレベルが无效になっているとしてもフィルターはその都度呼び出されることになります。
   </p>

   <p class="highlight">设定ファイルを変更すると，何回かロギンギ处理を実行した后で，かつ，监视周期に基いて决定した遅延时间が経过したら，自动的に再読み込みします。
   </p>

   <p><em>どんな</em>ロガーであれ，ロガーレベルがどうであれ，出力メソッドを呼び出すと<code>ReconfigureOnChangeFilter</code>も呼び出すことになるので，间违いなく致命的な性能影响があります。监视，监视周期が経过していようともいまいとも，とてもコストの高い处理になります。性能を改善するため，実际に<code>ReconfigureOnChangeFilter</code>有效になるのは， <em>N</em>回のロギングごとに一回だけです。あなたのアプリケーションがどれくらいの频度でロギングするのかにもよるのですが，的logbackは<em>Ñ</em>の値を実行している环境に合わせて调整します。Nのデフォルト値は16です。CPUを占有するアプリケーションの场合最大で2 ^ 16（= 65536）にまで増えます。
   </p>
   
   <p>简単に言うとこうなります。设定ファイルを変更すると，何回かロギンギ处理を実行した后で，かつ，监视周期に基いて决定した遅延时间が経过したら，自动的に再読み込みします。
   </p>

   

   <h3 class="doAnchor" name="joranDirectly"><code>JoranConfigurator</code>直接呼び出す</h3>

   <p>logbackは，logbac-coreに含まれるJoranという设定用ライブラリを利用しています。logbackのデフォルトの设定の仕组みでは， <code>JoranConfigurator</code>を呼び出して，クラスパス上で见つけたデフォルトの设定ファイルを渡すようになっています。何か理由があってデフォルトの设定の仕组みを上书きしたい场合， <code>JoranConfigurator</code>を直接呼び出すことができます。次に示す<em>MyApp3</em>アプリケーションでは，设定ファイルを引数としてJoranConfiguratorを呼び出しています。</p>
   
   <p class="example">例： <code>JoranConfigurator</code>び直接呼び出す（ <a href="http://logback.qos.ch/xref/chapters/configuration/MyApp3.html">logback-examples / src / mian / java / chapters / configuration / MyApp3.java</a> ）</p>

<pre class="prettyprint source">package chapters.configuration;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class MyApp3 {
  final static Logger logger = LoggerFactory.getLogger(MyApp3.class);

  public static void main(String[] args) {
    // SLF4J が logback を使うようになっていると想定
    <b>LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
    
    <b>try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(context);
      // デフォルト設定を取り消すために context.reset() を呼び出す
      // 複数の設定を積み重ねる場合は呼ばないようにする
      context.reset(); 
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
      // StatusPrinter will handle this
    }
    StatusPrinter.printInCaseOfErrorsOrWarnings(context);</b>

    logger.info("Entering application.");

    Foo foo = new Foo();
    foo.doIt();
    logger.info("Exiting application.");
  }
}</pre>

   <p>アプリケーションは，新しく生成した<code>JoranConfigurator</code>な，有效な<code>LoggerContext</code>を设定してから，ロガーコンテキストを初期化します。そして，アプリケーションの引数として渡された设定ファイルを使ってconfiguratorに设定させています。警告やエラーが発生した场合，内部ステータスが出力されます。复数の设定を积み重ねる场合は， <code>context.reset()</code>を呼び出さないようにしなければなりません。</p>

   <h3 class="doAnchor" name="viewingStatusMessages">ステータスメッセージの内容</h3>

   <p>登录back <code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/status/StatusManager.html">StatusManager</a></code>をクトに内部ステータス情报を蓄积しています。このオブジェクトは<code>LoggerContext</code>ますアクセスすることができます。
   </p>

   <p><code>StatusManager</code> log，logbackのコンテキストに关连付けられた全てのステータス情报にアクセスすることができます。メモリ使用量を妥当なレベルで抑えるため， <code>StatusManager</code>のデフォルト実装ではステータスメッセージを先头と末尾に分けて格纳しています。先头には最初の<em>H</em>个のステータスメッセージを格纳し，末尾には最后の<em>T</em>个のステータスメッセージを格纳します。今のところ<em>H</em>も<em>T</em>も150になっていますが，将来的にこの値は変更されるかもしれません。</p>

   <p>logback-classicの配布物には，ViewStatusMessagesServletというサーブレットが含まれています。このサーブレットは， <code>LoggerContext</code>に关连付けられた<code>StatusManager</code>の持つステータスメッセージを，HTMLの表で描画します。出力サンプルは次のようになります。
   </p>
   
   <a href="./lbClassicStatus.jpg">
     <img src="images/chapters/configuration/lbClassicStatus.jpg" alt="クリックすると拡大します" width="90%">
   </a>

   <p>Webアプリケーションにこのサーブレットを追加するには， <em>WEB-INF / web.xml</em>に次の行を追加します。</p>

   <pre class="prettyprint source">  &lt;servlet&gt;
    &lt;servlet-name&gt;ViewStatusMessages&lt;/servlet-name&gt;
    &lt;servlet-class&gt;ch.qos.logback.classic.ViewStatusMessagesServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ViewStatusMessages&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/lbClassicStatus&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</pre>
   
   <p><code>ViewStatusMessages</code>はーブレットにアクセスするためのURLは次のようになります。
<code>http://host/yourWebapp/lbClassicStatus</code>
   </p>

   <h3 class="doAnchor" name="statusListener">ステータスメッセージの待ち受け</h3>

   <p><code>StatusManager</code>に<code>StatusListener</code>を割り当てて，ステータスメッセージを受け取った応答として直ちに何らかの处理を実行させることができます。は，ステータスメッセージを受け取ることができるのはlogbackの设定が完了した后になります。ステータスリスナーを登录しておくと，人间が介入しなくてもlogbackの内部状态を监视できるようになるので便利です。
   </p>

   <p>logbackの配布物には<code>StatusListener</code>を実装した<code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/status/OnConsoleStatusListener.html">OnConsoleStatusListener</a></code>というクラスが含まれています。名前が表すとおり， <em>到着した</em>ステータスメッセージを全てコンソールに出力します。
   </p>

   <p>これは，状态管理器に<code>OnConsoleStatusListenerを登録する<a href="http://logback.qos.ch/xref/chapters/configuration/AddStatusListenerApp.html">サンプルコード</a>です。</code>
   </p>

   <pre class="prettyprint source">   LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory(); 
   StatusManager statusManager = lc.getStatusManager();
   OnConsoleStatusListener onConsoleListener = new OnConsoleStatusListener();
   statusManager.add(onConsoleListener);</pre>

   <p>ステータスリスナーは，登录された后に発生したステータスメッセージだけしか受け取らないので気をつけてください。ジは前のステータスメッセージは受け取りません。ので，ステータスリスナーの登录を设定ファイルの一番最初の方に置いて，他のディレクティブよりも先に评価されるようにするとよいでしょう。</p>

   <p>，これは一つ以上のステータスリスナーを登录できるということでもあります。例を示します。</p>

   <p class="example">例：ステータスリスナーの登录（ <a href="http://logback.qos.ch/xref/chapters/configuration/onConsoleStatusListener.xml">logback-examples / src / main / java / chapters / configuration / onConsoleStatusListener.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('onConsoleStatusListener');">Groovyで见る</span>
   <pre id="onConsoleStatusListener" class="prettyprint source">&lt;configuration&gt;
  <b>&lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /&gt;</b>  

  ... the rest of the configuration file  
&lt;/configuration&gt;</pre>

   <h3 class="doAnchor" name="logback.statusLC">パティステムプロパティ“ logback.statusListenerClass”</h3>

   <p>ステータスリスナーを登录するには，システムプロパティの“ logback.statusListenerClass”に，リスナークラス名を设定する方法もあります。例を示します。</p>

   <p class="source">java <b>-Dlogback.statusListenerClass</b> = ch.qos.logback.core.status。OnConsoleStatusListener ...</p>
   
   <p>logbackの配布物にはいくつかのステータスリスナー実装が含まれています。<a href="http://logback.qos.ch/xref/ch/qos/logback/core/status/OnConsoleStatusListener.html">OnConsoleStatusListener</a>は，受け取ったステータスメッセージを，コンソール（例えばSystem.out）に出力します。<a href="http://logback.qos.ch/xref/ch/qos/logback/core/status/OnErrorConsoleStatusListener.html">OnErrorConsoleStatusListener</a>は，受け取ったステータスメッセージをSystem.errに出力します。<a href="http://logback.qos.ch/xref/ch/qos/logback/core/status/NopStatusListener.html">NopStatusListener</a>は，受け取ったステータスメッセージをそのまま舍ててしまいます。</p>
   

   <p>设定の途中でステータスリスナーを登录を，システムプロパティの“ logback.statusListenerClass”でステータスリスナーを指定した场所は， <a href="./03-configuration.html#automaticStatusPrinting">メッセージステータスの自动出力（エラー発生时）</a>が无效になるので気をつけてください。つまり， <code>NopStatusListener</code>を使うように设定すると，内部ステータスの出力を完全に止めることが出来るのです。</p>
   
   <p class="source">java <b>-Dlogback.statusListenerClass</b> = ch.qos.logback.core.status。NopStatusListener ...</p>


   <h3 class="doAnchor" name="stopContext">经典的logbackを止める</h3>

   <p>logback-classicが用法しているリソースを解放するには，どんな偶尔でもlogbackコンテキストを停止することをお勧めします。をンテキストを停止すると，コンテキストに定义にロガーに割り当てられている全てのアペンダーを闭じて，すべてのアクティブなスレッドを停止ドを。
   </p>

<pre class="prettyprint lang-java source">
import org.sflf4j.LoggerFactory;
import ch.qos.logback.classic.LoggerContext;
...

// SLF4J が logback を使うようになっていると想定
<b>LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
<b>loggerContext.stop();</b></pre>

   <p>Webアプリケーションの场合，logback-classicを停止してリソースを开放するために， <code>ServletContextListener</code>の<a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletContextListener.html#contextDestroyed(javax.servlet.ServletContextEvent)">contextDestroyed</a>メソッドから上记のようなコードを実行します。

   </p><h2 class="doAnchor" name="syntax">设定ファイルの构文</h2>

   <p>log，たくさんのわかりやすい例を见てきてお分かりのとおり，登录はコードを再コンコイルすること无く，ロギングの振る舞いを変えることができます。アプリケーションの特定の部分でロギングを无效グを，UNIX Syslogデーモンに直接出力する，データベースに出力する，ログの可视化化ツールに出力する，别のlogbackサーバにロギンギイグイベンを転トトベ送こう，こういった色んな设定が実に简単にできるようになっています。ロギングイベントの転送について补足すると，ログの転送はローカルサーバーのポリシーに従って行われます。例えば，ロギングイベントを二つ目のリモートlogbackサーバーに転送する，というようなものです。
   </p>
	
   <p>设定のセクションの残りの部分では，设定ファイルの构文を绍介します。
   </p>

   <p>log何度か読んできたとおり，登录の设定ファイル构文はとても柔软になっています。DTのため，DTDやXMLスキーマによって定义することができません。そうは言っても设定ファイルの基本的な构成要素について说明しないと始まらないでしょう。次のように定义されています。<code>configuration</code>要素は，0以上の<code>appender</code>要素，0以上の<code>logger</code>要素，1つの<code>root</code>要素によって构成されています。次の図は，この基本构造を図示したものです。</p>

  
  <p align="left">
    <img src="images/chapters/configuration/basicSyntax.png" alt="基本的な构文" title="基本构成ファイルの构造">
  </p>


    <p class="highlight">タグ名に大文字と小文字のどちらを使うべきなのかわからないときは， <a href="http://en.wikipedia.org/wiki/CamelCase">キャメルケース规约</a>に従ってもらえれば，ほとんどの场合は合っていると思います。</p>

    <h4 class="doAnchor" name="caseSensitivity">名の大文字小文字の区别</h4>
   
    <p>logback 0.9.17以降のリリースから，タグ名の大文字小文字は区别しないと明记されるようになりました。例えば， <code><logger></code>と<code><Logger></code>と<code><LOGGER></code>はどれも配置要素の子要素として正しく，同じように解釈されます。XMLとしての适格性ルールは有效なままなので，开きタグを<code><xyz></code>として书いたら，闭じタグは<code></xyz></code>でなければなりません。<code></XyZ></code>ではダメです。<a href="./onJoran.html#implicit">暗黙的なルール</a>として，タグ名については最初の一文字以外は大文字小文字を区别するようになっています。したがって， <code><xyz></code>と<code><Xyz></code>は同じものとみなされますが， <code><xYz></code>はダメです。暗黙のルールとは言っても大体は<a href="http://en.wikipedia.org/wiki/CamelCase">キャメルケース</a>に従っています。Javaの世界では一般的な规则です。タグが明示的なアクションと暗黙的なアクションのどちらにも关连付けられていると，それを说明するのは决して简単なことではありません。XMLので，XMLタグ名の最初の一文字が大文字小文字を区别するかどうかについて言及しておくことはとても重要なのです。
    </p>

    <h4 class="doAnchor" name="loggerElement">ロガーの设定について，あるいは， <code>logger</code>要素について</h4>

    <p>ここでは，少なくとも<a href="./architecture.html#effectiveLevel">レベルの継承</a>と<a href="./architecture.html#basic_selection">基本的な选択ルール</a>についてある程度理解しておかなければなりません。そうでなければ，あなたがエジブト语の语でも学者でも无い限り，logbackの设定ファイルはヒエログラフよりも意味の无いものでしかないでしょう。
    </p>

    <p>ロガーは<code>logger</code>要素で设定します。<code>logger</code>要素には少なくとも一つの<span class="attr">name属性</span>が必要です。<span class="attr">level属性</span> ，そして<em>true</em>または<em>false</em>を指定できる可<span class="attr">加性属性</span>は任意です。<span class="attr">level属性</span>にはTRACE，DEBUG，INFO，WARN，ERROR，ALLまたはOFFのいずれかの文字列を指定できます。大文字小文字は区别しません。大文字小文字を区别しない特别な値として<em>INHERITED</em>またはその同义语として<em>NULL</em>を指定すると，祖先から継承したロガーのレベルを强制的に使用することができます。ロガーのレベルを设定した后で，祖先ロガーのレベルを継承するべきだったことがわかった偶尔に便利です。
    </p>

    <p class="highlight">log4jとは违って，logback-classicはロガーを设定を时に割り当てたどんなアペンダーもくクローズ<em>しない</em>し削除もしないので注意してください。
    </p>

    <p><code>logger要素</code>には任意个の<code>appender-ref要素</code>を含めることができます。参照しているアペンダーがロガーに割り当てられます。log4jとは违って，logback-classicはロガーを设定を时に割り当てたどんなアペンダーもくクローズ<em>しない</em>し削除もしないので注意してください。
    </p>



   <h4 class="doAnchor" name="rootElement">ルートロガー，あるいは， <code>root</code>要素について</h4>

   <p>ルートロガーは<code>root</code>要素で设定します。たった一つ， <span class="attr">level属性</span>だけを指定できます。ルートロガーには添加性属性などの他の属性を指定することはできません。さらに，ルートロガーの名前は予め“ ROOT”になっているので，名称属性も指定することはできません。level属性にはTRACE，DEBUG，INFO，WARN，ERROR，ALLまたはOFFのいずれかの文字列を指定できます。大文字小文字は区别しません。ルートロガーにはINHERITEDまたはその同义语であるNULLを指定することはできません。</p>

   <p class="highlight">log4jとは违って，经典的-ルートロガーを设定した时した割に当てたどんなアてたどんなンダーもくクローズ<em>しない</em>し削除もしないので注意してください。</p>

   <p><code>logger要素</code>と同じく， <code>root要素</code>には任意个の<code>appender-ref要素</code>を含めることができます。参照しているアペンダーがロガーに割り当てられます。log4jとは违って，经典的-ルートロガーを设定した时した割に当てたどんなアてたどんなンダーもくクローズ<em>しない</em>し削除もしないので注意してください。
</p>

   <h4>例</h4>

   <p>ロガーあるいはルートロガーにレベルを设定するのは非常に简単です。例を示します。“章节。配置” configurationッたージのコンポーネントから出力されていたDEBUGメッセージが不要になったとしましょう。次の设定ファイルはそれを実现するための例です。
   </p>

   <p class="example">例：ロガーのレベルを设定する（ <a href="http://logback.qos.ch/xref/chapters/configuration/sample2.xml">logback-examples / src / main / java / chapters / configuration / sample2.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('sample2');">Groovyで见る</span>
   <pre id="sample2" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  <b>&lt;logger name="chapters.configuration" level="INFO"/&gt;</b>

  &lt;!-- 厳密にはここでルートロガーのlevel要素を設定する必要はありません --&gt;
  &lt;!-- デフォルトでDEBUGが指定されるからです       --&gt;
  &lt;root level="DEBUG"&gt;		
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;  
  
&lt;/configuration&gt;</pre>

  <p><em>App</em>の设定ファイルを<em>MyApp3</em>アプリケーションの引数として渡すと，次のような出力が得られます。</p>

<pre class="source">17:34:07.578 [main] INFO  chapters.configuration.MyApp3 - Entering application.
17:34:07.578 [main] INFO  chapters.configuration.MyApp3 - Exiting application.</pre>

  <p><a href="http://logback.qos.ch/xref/chapters/configuration/Foo.html">“章节。配置。Foo</a> “のロガーが出力していたDEBUGメッセージが抑止されていることに気づきましたか。ooFooクラスを见なおしてください。</p>

  <p>あらゆるロガーのレベルを思った通りに设定することができます。次の设定ファイルでは， <em>chapters.configurationro</em>ガーのレベルをINFOに设定していますが，同时に<em>章 .configuration <em>。富</em>のレベルを<code>DEBUG</code>に设定しています。</em></p><em>

  <p class="example">例：复数のロガーのレベルを设定する（ <a href="http://logback.qos.ch/xref/chapters/configuration/sample3.xml">logback-examples / src / main / java / chapters / configuration / sample3.xml</a> ）</p>
  
  <span class="asGroovy" onclick="return asGroovy('sample3');">Groovyで见る</span>
  <pre id="sample3" class="source prettyprint">&lt;configuration&gt;

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
     &lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  <b>&lt;logger name="chapters.configuration" level="INFO" /&gt;</b>
  <b>&lt;logger name="chapters.configuration.Foo" level="DEBUG" /&gt;</b>

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;

&lt;/configuration&gt;</pre>

  <p><code>MyApp3</code>アプリケーションの引数にこの设定ファイルを指定して実行すると，コンソールには次のように出力されます。</p>

<p class="prettyprint source">17：39：27.593 [main] INFO章节。配置。MyApp3-输入应用程序。17：39：27.593 [main] DEBUG的章。配置。Foo-再来一次！17：39：27.593 [main] INFO章节。配置。MyApp3-退出应用程序。</p>

   <p><code>JoranConfiguration</code>が<em>sample3.xml</em>を设置した后のロガーとそのレベルを表にまとめました。
   </p>

   <table class="bodyTable">
     <tbody><tr>
       <th>ロガー名</th>
       <th>割り当てられたレベル</th>
       <th>有效レベル</th>
     </tr>
     <tr>
       <td>根</td>
       <td><code>DEBUG</code></td>
       <td><code>DEBUG</code></td>
     </tr>
     <tr class="alt">
       <td>章节配置</td>
       <td><code>INFO</code></td>
       <td><code>INFO</code></td>
     </tr>
     <tr>
       <td>章节配置MyApp3</td>
       <td><code>null</code></td>
       <td><code>INFO</code></td>
     </tr>
     <tr class="alt">
       <td>章节配置oo</td>
       <td><code>DEBUG</code></td>
       <td><code>DEBUG</code></td>
     </tr>
   </tbody></table>

  <p>これは， <code>MyApp3</code>クラスの<code>INFO</code>レベルのロギング式2つと， <code>Foo</code>クラスのdoIt（）メソッドにあるDEBUGレベルのロギング式がいずれも有效であるということです。ルートロガーのレベルは常に非null値が指定されること，デフォルトではDEBUGが指定されていることに注意しましょう。
  </p>

  <p><a href="./architecture.html#basic_selection">基本的な选択ルール</a>についても考えてみましょう。ロギング要求が呼び出されるかどうかは，アペンダーを割を当てられたロガーに指定されたレベルそのものではなく，ロガーの有效レベルによって决定されるというものです。logbackはまず最初にロギング式が有效かどうかを确定します。有效な场合は，ロガーのレベルに依らず，ロガーCLASSで见つかったアペンダーを呼び出します。设定ファイル<em>sample4.xml</em>でその点を确认しましょう。</p>

  <p class="example">例：ロガーレベルのサンプル（ <a href="http://logback.qos.ch/xref/chapters/configuration/sample4.xml">logback-examples / src / main / java / chapters / configuration / sample4.xml</a> ）</p>
  <span class="asGroovy" onclick="return asGroovy('sample4');">Groovyで见る</span>
  <pre id="sample4" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="STDOUT"
   class="ch.qos.logback.core.ConsoleAppender"&gt;
   &lt;encoder&gt;
     &lt;pattern&gt;
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
      &lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  <b>&lt;logger name="chapters.configuration" level="INFO" /&gt;</b>

  &lt;!-- turn OFF all logging (children can override) --&gt;
  &lt;root <b>level="OFF"</b>&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;

&lt;/configuration&gt;</pre>

  <p><em>sample4.xml</em>を设置した后のロガーとそのレベルを表にまとめました。
  </p>

  <table class="bodyTable">
    <tbody><tr>
      <th>ロガー名</th>
      <th>割り当てられたレベル</th>
      <th>有效レベル</th>
    </tr>
    <tr>
      <td>根</td>
      <td><code>OFF</code></td>
      <td><code>OFF</code></td>
    </tr>
    <tr class="alt">
      <td>章节配置</td>
      <td><code>INFO</code></td>
      <td><code>INFO</code></td>
    </tr>
    <tr>
      <td>章节配置MyApp3</td>
      <td><code>null</code></td>
      <td><code>INFO</code></td>
    </tr>
    <tr class="alt">
      <td>章节配置oo</td>
      <td><code>null</code></td>
      <td><code>INFO</code></td>
    </tr>
  </tbody></table>

  <p><em>sample4.xml</em>では，ConsoleAppenderに<em>STDOUT</em>という名前を付けて，ルートロガーに割に当てています。ルートロガーのレベルは<code>OFF</code>です。<em>App</em> ， <em>MyApp3</em>の引数として<em>sample4.xml</em>を指定して実行すると次のような出力になってしまいます。</p>

  <div class="source"><pre>17:52:23.609 [main] INFO chapters.configuration.MyApp3 - Entering application.
17:52:23.609 [main] INFO chapters.configuration.MyApp3 - Exiting application.</pre></div>

  <p>つまり， <code>INFO</code>がルが有效レベルとなっているロガーである<code>chapters.configuration.MyApp3</code>と<code>chapters.configuration.Foo</code>のどちらも，ルートロガーのレベルによる影响を受けていないのです。蛇足ですが，Java実装の中では<em>章。配置</em> roガーを直接参照しているところはありませんが，実际に存在しています。设定ファイルで宣言されいるからです。
  </p>

  <h4 class="doAnchor" name="configuringAppenders">アペンダーの设定</h4>

  <p>アペンダーの设定は<code>appender要素</code>で行います。の要素には<span class="attr">name属性</span>と<span class="attr">类属性</span>という二つの必须属性があります。<span class="attr">名称属性</span>にはアペンダーの名前を， <span class="attr">类属性</span>にはアペンダーのクラスの完全名を指定します。<code>appender要素</code>には任意个の<code>layout要素</code>と<code>encoder要素</code>と<code>filter要素</code>を含めることができます。<code>appender要素</code> Java，これらの一般的な要素とは别に，アペンダークラスのJavaBean规约に従ったプロパティを任意の数だけ含めることができます。logbackのコンポーネントのどんなプロパティでも违和感无く设定できるのは， <a href="./onJoran.html">Joran设定フレームワーク</a>の主な长所です。详しくは后の章で说明します。一般的な构造を図示したのが次の図です。JavaBeanプロパティをサポートしているようには见えないことがわかるでしょう。
  </p>

  <p align="left">
    <img src="images/chapters/configuration/appenderSyntax.png" alt="アペンダの构文" title="アペンダー要素构文">
  </p>

  <p><code>layout要素</code>にはclass属性が必须です。完全イアウトクラスの完全名を指定します。<code>appender要素</code>と同じく， <code>layout要素</code>にはレイアウトクラスのプロパティを含めることができます。レイアウトクラスとして<code>PatternLayout</code>を指定するのが一般的なので，その场合类属性は省略できるようになっています。これは<a href="./onJoran.html#defaultClassMapping">デフォルトのクラスマッピングルール</a>で定义されています。
  </p>

  <p><code>encoder要素</code>にはclass属性が必须です。完全ンコーダクラスの完全名を指定します。エンコーダクラスとして<code>PaternLayoutEncoder</code>を指定するのが一般的なので，その场合类属性を省略できるようになっています。これは<a href="./onJoran.html#defaultClassMapping">デフォルトのクラスマッピングルール</a>で定义されています。
  </p>

  <p>复数のアペンダーにロに出力するのも，さまざまなアペンダーを定义してロガーから参照するのも简単です。设定ファイルの例を示しましょう。</p>

  <p class="example">例：复数のロガー（ <a href="http://logback.qos.ch/xref/chapters/configuration/multiple.xml">logback-examples / src / main / java / chapters / configuration / multiple.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('multiple');">Groovyで见る</span>
  <pre id="multiple" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="<b>FILE</b>" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;file&gt;myApp.log&lt;/file&gt;

    &lt;encoder&gt;
      &lt;pattern&gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;appender name="<b>STDOUT</b>" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    <b>&lt;appender-ref ref="FILE" /&gt;</b>
    <b>&lt;appender-ref ref="STDOUT" /&gt;</b>
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  <p>设定の设定スクリプトでは， <em>FILE</em>と<em>STDOUT</em>というアペンダーを定义しています。<em>FILE</em>は<em>myApp.log</em>というファイルへログをログを出力するアペンダーです。このアペンダーのエンコーダーは<code>PatternLayoutEncoder</code>日，日付，ログレベル，スレッド名，ロガー名，ソースコードファイル名，ロギング式の书かれたソースコードファイル中の行番号，号ッメージ，改行文字を出力します。二つ目のアペンダーは<code></code> STDOUT [/ 0}という名前です。ですンソールにログを出力するアペンダーです。はのアペンダーのエンコーダーは，メッセージと改行文字だけを出力します。
  </p>

  <p>二つのアペンダーはルートロガーに割り当てられています。それぞれ<em>appender-ref要素</em>から名前で<em>参照</em>されています。ましたかのアペンダーにエンコーダーダーを指定していることに気づきましたか。普通エンコーダーは复数のアペンダーから共有できるように设计されていません。レイアウトにも同じことが言えます。このように，logbackの设定ファイルは，エンコーダーやレイアウトを共有をのいかなる构文上の手段も提供しません。
  </p>

  <h4 class="doAnchor" name="cumulative">アペンダーの积み重ね</h4>

  <p>デフォルトでは<b>アペンダーは积み重ねられていきます</b> 。つまり，ロガーに割り当てられたアペンペーにログを出力するのとまったく同様に，祖先ロガーに割に当てられたアペンダーにもログが出力されます。じ，同じアペンダーを复数のロガーに割り当てると，ログ出力が重复することになります。
  </p>

  <p class="example">例：アペンダーの重复（ <a href="http://logback.qos.ch/xref/chapters/configuration/duplicate.xml">logback-examples / src / main / java / chapters / configuration / duplicate.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('duplicate');">Groovyで见る</span>
  <pre id="duplicate" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;logger name="chapters.configuration"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/logger&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  <p><code>MyApp3</code>アプリケーションの引数に<em>duplicate.xml</em>を指定して実行すると，次のような出力が得られます。</p>

<p class="source">14：25：36.343 [main] INFO章节。配置。MyApp3-输入应用程序。14：25：36.343 [main] INFO章节。配置。MyApp3-输入应用程序。14：25：36.359 [main]调试Chapters.configuration。Foo-再来一次！14：25：36.359 [main]调试Chapters.configuration。Foo-再来一次！14：25：36.359 [main] INFO章节。配置。MyApp3-退出应用程序。14：25：36.359 [main] INFO章节。配置。MyApp3-退出应用程序。</p>

  <p>ログ出力の重复には気をつけましょう。<em>STDOUT</em>という名前のアペンダーは，ルートロガーと<em>章章。配置</em>ロガーに割り当てられています。ルートロガーは全てのロガーの祖先ロガーです。<em>章节配置</em> <em>章节配置MyApp3ro</em>ガーと<em>chapters.configuration。Foo</em>ロガーの亲ロガーです。子孙にあたるこれら二つのロガーによるロギング要求は二重に出力されます。なぜなら， <em>STDOUT</em>アペンダーが， <em>章节。配置</em> roガーと<em>ルート</em>ロガーの両方に割り当てられているからです。
  </p>

  <p>アペンダーが积み重ねられるようになっているのは，决して新しい利用者を罠にかけるためではありません。これは非常に便利なフィーチャなのです。例えば，システム中の全てのロガーによるメッによるメージをコンソールに出力させつつ，特定のロガーのメッメージだけを特别なアペンダーに出力させるように设定することができるのです。
  </p>

  <p class="example">例：复数のアペンダー（ <a href="http://logback.qos.ch/xref/chapters/configuration/restricted.xml">logback-examples / src / main / java / chapters / configuration / restricted.xml</a> ）</p>
  <span class="asGroovy" onclick="return asGroovy('restricted');">Groovyで见る</span>
  <pre id="restricted" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;file&gt;myApp.log&lt;/file&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;logger name="chapters.configuration"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/logger&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  <p>ではの例では，システム中の全てのロガーのメッセージはコンソールアペンペーダ出力されます。そして， <em>章节配置</em> <em>。myApp.log</em>ファイルにも出力されます。
  </p>
	
  <h4 class="doAnchor" name="overrridingCumulativity">デフォルトの积み重ねを止める</h4>

  <p>はフォルトの积み重ねがニーズに合わない场合は，亲和性フラグにfalseを设定して止めることができます。そうすれば，ロガーツリーのある枝から下の部分では，ツリーの他の部分と违って，ロガーに割り当てられたアペンダーにだけ出力するようになります。
  </p>

  <p class="example">例：aditivityフラグ（ <a href="http://logback.qos.ch/xref/chapters/configuration/aditivityFlag.xml">logback-examples / src / main / java / chapters / configuration / aditivityFlag.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('additivityFlag');">Groovyで见る</span>
  <pre id="additivityFlag" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;file&gt;foo.log&lt;/file&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%date %level [%thread] %logger{10} [%file : %line] %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;logger name="chapters.configuration.Foo" <b>additivity="false"</b>&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/logger&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  <p>ではの例では<em>章节。配置。Foo</em>ロガーに<em>FILE</em>というアペンペーが割り当てられています。また， <em>章节配置。Foo</em>ロガーの亲和力フラグに假が指定されているので，ログは<em>FILE</em>アペンダーにだけ出力されて，ログCLASSの先祖に割り当てられているアペンペーには出には力されません。他のロガーが<em>章节。配置。富</em>ロガーのaditivityフラグの设定に気づくことはありません。<code>MyApp3</code>アプリケーションを<em>aditivityFlag.xml</em>を引数として実行すると，コンソールに<em>第章。MyApp3</em>ロガーからの出力が表示されます。しかし， <em>章节配置。Foo</em>ロガーの出力が<em>foo.log其他</em>に表れることはありません。
  </p>

  <h3 class="doAnchor" name="contextName">コンテキスト名の设定</h3>

  <p><a href="./architecture.html#LoggerContext">前の章</a>で述べたように，全てのロガーはロガーコンテキストに割り当てられます。ロガーコンテキストのデフォルトの名前は「default」です。しかし， <code>contextNameディレクティブ</code>を使えば别の名前を付けることが出来ます。ロガーコンテキストの名前は一度设定したら<a href="http://logback.qos.ch/apidocs/ch/qos/logback/core/ContextBase.html#setName(java.lang.String)">変更できない</a>ので注意してください。复数のアプリケーションショ同が象にロギングする场合，アプリケーションショ区别を，コンテキストに名前を付けるのが简単でわかりやすい方法です。
  </p>
  
  <p class="example">例：コンテキスト名を设定して表示する（ <a href="http://logback.qos.ch/xref/chapters/configuration/contextName.xml">logback-examples / src / main / java / chapters / configuration / contextName.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('contextName');">Groovyで见る</span>
  <pre id="contextName" class="prettyprint source">&lt;configuration&gt;
  <b>&lt;contextName&gt;myAppName&lt;/contextName&gt;</b>
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d <b>%contextName</b> [%t] %level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  <p>これはロガーコンテキストに名前を付ける例です。をイアトトのパターンに変换指示语として<a href="./layouts.html#conversionWord">contextName</a>を指定すると，コンテキスト名が出力されます。</p>
  
  <!-- =============================================================== -->
 
  <h3 class="doAnchor" name="variableSubstitution">数の置换</h3>

  <p>ではのドキュメントの以前のバージョンでは，「変数の置换」ではなく「プロパティの置换」と呼んでいました。<span class="label"></span>どちらも相互に置き换えられるくらい同じ意味の言葉ですが，前者のほうが明确に意味を表していると思います。
  </p>

  <p>logスクリプト言语のように，logbackの设定ファイルは変数を定义して，値と置き换えられるようになっています。外部数は设定ファイルの中で定义することもできるし，外部のファイルで定义することもできます。そして外部リソースでも定义することもできるし，何らか计算することさえできます。， <a href="./03-configuration.html#definingPropsOnTheFly">実行时に定义する</a>こともできます。
  </p>

  <p class="highlight">指定できるところなら设定ファイル中のどこでも変数を置换することができます。</p>

  <p>指定できるところなら设定ファイル中のどこでも変数を置换することができます。変数の置换をする构文はUnixシェルとよく似ています。<em>$ {</em>から始まり<em>}</em>で终わる文字列は， <em>プロパティの値</em>への指と见做されます。<em>aName</em>というプロパティの场合文字列の“ $ {aName}”は，その値に置き换えられます。<em></em>
  </p>

  <p>で数には<a href="./03-configuration.html#scopes">スコープ</a>があります（后で说明します）。</p>

  <p>HOSTNAME変数とCONTEXT_NAME変数はよく使われるので，コンテキストスコープを持つ変数として自动的に定义されます。</p>

   <h4 class="doAnchor" name="definingProps">変数の定义</h4>

  <p>変数は，设定ファイルや外部のプロパティファイル，あるいは外部リソースを読み込むとき，それぞれで一度だけ定义することができます。歴史的な理由により， <code>property</code> XML要素を使って変数を定义することになっていますが，logback 1.0.7以降では<code>variable要素</code>使うことも出来ます。これらの要素は完全に互换性があります。</p>

  <p>设定ファイルの先头で変数を定义する例を见てみましょう。定义された変数は，设定ファイルの后半のほうでログ出力用ファイルの位置を指定するために使われています。
  </p>

  <p class="example">例：変数の置换（ <a href="http://logback.qos.ch/xref/chapters/configuration/variableSubstitution1.xml">logback-examples / src / main / java / chapters / configuration / variableSubstitution1.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('variableSubstitution1');">Groovyで见る</span>
  <pre id="variableSubstitution1" class="prettyprint source">&lt;configuration&gt;

  <b>&lt;property name="USER_HOME" value="/home/sebastien" /&gt;</b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    <b>&lt;file&gt;${USER_HOME}/myApp.log&lt;/file&gt;</b>
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  <p>次は，システムプロパティを使って同じことをしてみましょう。设定ファイル中に属性要素が宣言されていないので，logbackはそれをシステムプロパティから探します。Javaのシステムプロパティはコマンドラインで次のように指定します。</p>
  
  <p class="source">java -DUSER_HOME =“ / home / sebastien” MyApp2</p>

  <p class="example">例：システム変数の置换（ <a href="http://logback.qos.ch/xref/chapters/configuration/variableSubstitution2.xml">logback-examples / src / main / java / chapters / configuration / variableSubstitution2.xml</a> ）</p>
  <span class="asGroovy" onclick="return asGroovy('variableSubstitution2');">Groovyで见る</span>
  <pre id="variableSubstitution2" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    <b>&lt;file&gt;${USER_HOME}/myApp.log&lt;/file&gt;</b>
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  
  <p>复数の変数が必要なときは，変数の定义だけを含むファイルを别に用意したほうが便利な场合もあります。构成例を示します。
  </p>

  <p class="example">例：别ファイルを使用する変数の替换（ <a href="http://logback.qos.ch/xref/chapters/configuration/variableSubstitution3.xml">logback-examples / src / main / java / chapters / configuration / variableSubstitution3.xml</a> ）</p>
  <span class="asGroovy" onclick="return asGroovy('variableSubstitution3');">Groovyで见る</span>
  <pre id="variableSubstitution3" class="prettyprint source">&lt;configuration&gt;

  <b>&lt;property file="src/main/java/chapters/configuration/variables1.properties" /&gt;</b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
     <b>&lt;file&gt;${USER_HOME}/myApp.log&lt;/file&gt;</b>
     &lt;encoder&gt;
       &lt;pattern&gt;%msg%n&lt;/pattern&gt;
     &lt;/encoder&gt;
   &lt;/appender&gt;

   &lt;root level="debug"&gt;
     &lt;appender-ref ref="FILE" /&gt;
   &lt;/root&gt;
&lt;/configuration&gt;</pre>

   <p>propertiesの设定ファイルでは<em>variables1.properties</em>という名前のファイルを参照しています。指定されたファイルで定义された変数がローカルスコープに定义されます。<em>variable.properties</em>の内容は次のようなものです。
   </p>

   <em>例：変数定义ファイル（logback-examples / src / main / java / chapters / configuration / variables1.properties）</em>

   <pre class="source">USER_HOME=/home/sebastien</pre>

   <p>ファイルの代わりにクラスパス上のリソースを指定することもできます。</p>

  <pre class="prettyprint source">&lt;configuration&gt;

  <b>&lt;property resource="resource1.properties" /&gt;</b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
     <b>&lt;file&gt;${USER_HOME}/myApp.log&lt;/file&gt;</b>
     &lt;encoder&gt;
       &lt;pattern&gt;%msg%n&lt;/pattern&gt;
     &lt;/encoder&gt;
   &lt;/appender&gt;

   &lt;root level="debug"&gt;
     &lt;appender-ref ref="FILE" /&gt;
   &lt;/root&gt;
&lt;/configuration&gt;</pre>


   <h4 class="doAnchor" name="scopes">スコープ</h4>

   <p><em>ローカルスコープ</em> ， <em>コンテキストスコープ</em> ， <em>システムスコープ</em>のそれぞれで変数を定义することができます。プですフォルトのスコープはローカルスコープです。OSの提供する环境変数の読み込みはできますが，书き込みは出来ません。</p>


   <p><span class="label">ローカルスコープ</span> 。ローカルスコープで定义された変数は，その変数が定义されている设定ファイルの解釈，実行が终了するまで有效です。当然ながら，设定ファイルを解釈，実行するたびに，ローカルスコープの変数は新しく定义されることになります。</p>

   <p><span class="label">プンテキストスコープ</span> 。コンテキストスコープで定义された変数は，コンテキストに登录に。がンテキストが破弃されるまで，あるいは，コンテキストが初期化されるまで有效です。コ，一度コンテキストスコープで定义された変数はコンテキストの一部となるのです。ますしので，全てのロギングイベントベ利用からきますし，そのイベントをシリアライズして送信した先のリモートホストでも利用できます。
   </p>

   <p><span class="label">プステムスコープ</span> 。JVMステムスコープで定义された変数は，JVMのシステムプロパティに登录されます。JVMが停止するか，初期化されるまで有效です。
   </p>
 
   <p class="highlight">最初是にローカルスコープで変数を検索します。そしてコンテキストスコープ，システムスコープの顺に検索し，最后に<a href="http://docs.oracle.com/javase/tutorial/essential/environment/env.html">OSの环境変数</a>を検索します。
   </p>

   <p>変数を替换する际，最初にローカルスコープで変数を検索します。そしてコンテキストスコープ，システムスコープの顺に検索し，最后に<a href="http://docs.oracle.com/javase/tutorial/essential/environment/env.html">OSの环境変数</a>を検索します。

   </p>

   <p>変数のスコープは， <code>property要素</code> ， <code>define要素</code> ， <code>insertFromJNDI要素</code>の<span class="attr">scope属性</span>で指定します。<span class="attr">scope属性</span>に指定できるのは，“ local”，“ context”，“ system”のいずれかの文字列です。scope属性を指定しなかった场合，スコープは常に“ local”と见做されます。
   </p>

   <p class="example">例：変数をコンテキストスコープで定义プで（ <a href="http://logback.qos.ch/xref/chapters/configuration/contextScopedVariable.xml">logback-examples / src / main / java / chapters / configuration / contextScopedVariable.xml</a> ）</p>

  <span class="asGroovy" onclick="return
  asGroovy('contextScopedVariable');">Groovyで见る</span>
  <pre id="contextScopedVariable" class="prettyprint source">&lt;configuration&gt;

  &lt;property <b class="big">scope="context"</b> name="nodeId" value="firstNode" /&gt;

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    <b>&lt;file&gt;/opt/${nodeId}/myApp.log&lt;/file&gt;</b>
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

   <p><em>変</em>の例では<em>nodeId変数</em>をコンテキストスコープで定义しています。の変数は全てのロギングイベントで有效で，シリアライズ化して送信した先のリモートホストでも利用できます。</p>


  <h3 class="doAnchor" name="defaultValuesForVariables">変数のデフォルト値</h3>

  <p>特定の状况では，変数が宣言されていなかったり，値がnullの场合，デフォルト値が使えるようになっているほうが望ましいことがあります。<a href="http://tldp.org/LDP/abs/html/parameter-substitution.html">Bash</a>と同じく， <b>“：-”</b>演算子を使ってデフォルト値を指定することができます。例えば， <em>aName</em>という名前の変数が定义されていない场合， <code>"${aName <b>:-golden</b> }"</code>という文字列を変数置换した结果は“ goleden”になります。</p>

   <h3 class="doAnchor" name="nestedSubst">変数のネスト</h3>

   <p>変数はネストすることができます。変数の名前として，デフォルト値として，値として，他の変数を指定することができます。</p>


   <h4>値のネスト</h4>
   <p>変数の値を定义するとき，他の変数を指定することができます。例えば，宛先のディレクトリだけでなく，ファイル名も変数で指定したい场合，それぞれの変数をまとめた第三の変数“目的地”を定义して，それを利用できるのです。プロパティファイルの例を示します。
   </p>

   <p class="example">例：変数のネスト（ <a href="http://logback.qos.ch/xref/chapters/configuration/variables2.properties">logback-examples / src / main / java / chapters / configuration / variables2.properties</a> ）</p>

   <pre class="source">USER_HOME=/home/sebastien
fileName=myApp.log
<b>destination=${USER_HOME}/${fileName}</b></pre>

    <p>“ destination”変数の定义で，“ USER_HOME”変数と“ fileName”変数を组み合わせていることが分かりますか。
    </p>
    
    <em>例：别のファイルを使用した変数の替换（logback-examples / src / main / java / chapters / configuration / variableSubstitution4.xml）</em>

    <pre class="prettyprint source">&lt;configuration&gt;

  &lt;property file="variables2.properties" /&gt;

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    <b>&lt;file&gt;${destination}&lt;/file&gt;</b>
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>


   <h4>名前のネスト</h4>

   <p>数を参照するとき，変数の名前として，他の変数を指定することができます。たとえば，“ uesrid”変数に“ alice”という文字列が指定されていることにしましょう。そうすると，“ $ {$ {userid} .password}”という文字列は，“ alice.password”変数を参照することになるのです。</p>

   <h4>デフォルト値のネスト</h4>

   <p>変数のデフォルト値に他の変数を指定することができます。たとえば，'id'変数に値が割り当てられておらず，'userid'変数には“ alice”という文字列が指定されていることにしましょう。そうすると，“ $ {id <b>：-</b> $ {userid}}”という文字列は“ alice”という文字列になるのです。
   </p>


  <!-- ==============================================================
       -->
  <h3 class="doAnchor" name="hostname">HOSTNAME変数</h3>

  <p>あると便利なので， <code>HOSTNAME</code>変数は自动的にコンテキストスコープに定义されるようになっています。</p>

  <!-- ============================================================== -->
  <h3 class="doAnchor" name="context_name">CONTEXT_NAME変数</h3>

  <p>変数名のとおり， <code>CONTEXT_NAME</code>数には，现在のロギングコングコストの名前が设定されています。</p>

  <!-- ============================================================== -->
  
  <h3 class="doAnchor" name="timestamp">タイムスタンプを设定する</h3>

  <p><em>timestamp要素</em>を使うと，现在の日付と时刻に応じた値を持つプロパティを定义することができます。<em>timestamp要素</em>については<a href="./appenders.html#uniquelyNamed">后続の章</a>で说明します。</p>

  <!-- ============================================================== -->
  <h3 class="doAnchor" name="definingPropsOnTheFly">実行时に変数を定义する</h3>

  <p><code>define要素</code>を使うと动的に変数を定义できます。define要素には二つの必须属性<span class="attr">名称属性</span>と<span class="attr">类属性</span>があります。<span class="attr">名称属性</span>には変数の名前を指定します。<span class="attr">class属性</span>には<a href="http://logback.qos.ch/xref/ch/qos/logback/core/spi/PropertyDefiner.html">PropertyDefiner</a>インターフェイスを実装したクラスの完全名を指定します。<code>PropertyDefiner</code>の<code>getPropertyValue()</code>メソッドの返す値が，変数の値になります。<span class="attr">范围属性</span>で<a href="./03-configuration.html#scopes">スコープ</a>を指定することもできます。
  </p>

  <p>以下に例を示します。</p>

  <pre class="prettyprint source">&lt;configuration&gt;

  &lt;define name="rootLevel" class="a.class.implementing.PropertyDefiner"&gt;
    &lt;shape&gt;round&lt;/shape&gt;
    &lt;color&gt;brown&lt;/color&gt;
    &lt;size&gt;24&lt;/size&gt;
  &lt;/define&gt;
 
  &lt;root level="${rootLevel}"/&gt;
&lt;/configuration&gt;</pre>

  <p>ではの例では，“ a.class.implementation”。PropertyDefiner“クラスのプロパティとして，形状，颜色，大小を指定しています。指定したプロパティのセッターメソッドが<code>PropertyDefiner</code>クラスに定义されていれば，logbackは设定ファイルで指定されたプロパティの値をインスタンスに设定することができます。</p>

 

  <p>logbackの配布物には现在のところ非常に単纯な二つの<code>PropertyDefiner</code>実装クラスが含まれてます。
  </p>

  <table class="bodyTable striped">
    <tbody><tr>
      <th>実装クラス名</th>
      <th>说明</th>
    </tr>

    <tr>
      <td><a href="http://logback.qos.ch/apidocs/ch/qos/logback/core/property/FileExistsPropertyDefiner.html"><code>FileExistsPropertyDefiner</code></a>
      </td>
      <td><span class="prop">path</span>プロパティに指定したファイルが存在していれば“ true”を，そうでなければ“ false”を返します。
      </td>
    </tr>
    <tr>
      <td><a href="http://logback.qos.ch/apidocs/ch/qos/logback/core/property/FileExistsPropertyDefiner.html"><code>ResourceExistsPropertyDefiner</code></a>
      </td>
      <td>クラスパス上に指定された<span class="prop">リソース</span>が存在すれば“ true”を，そうでなければ“ false”を返します。
      </td>
    </tr>
  </tbody></table>

  <!-- ============================================================== -->

  <h3 class="doAnchor" name="conditional">设定ファイル内の条件分岐</h3>
  
  <p>开発环境，テスト环境，本番环境のような环境ごとに用意されたlogback设定ファイルと格闘しなければならないことがよくあります。设定の设定ファイルの内容はほとんど同じですが，少しだけ异なる箇所があります。同じような设定ファイルの重复を避けるため，logbackは设定ファイル中で条件分岐できでいます。 <code>if要素</code> ， <code>then要素</code> ， <code>else要素</code>使えば，さまざまな环境用のファイルを一つにまとめることができるのです。条件分岐できるようにするため， <a href="http://logback.qos.ch/setup.html#janino">Jainoライブラリ</a>を使用しています。
  </p>

  <p>条件分岐式の一般的な形式を次に示します。</p>

  <pre class="prettyprint source">
   &lt;!-- if-then form --&gt;
   &lt;if condition="some conditional expression"&gt;
    &lt;then&gt;
      ...
    &lt;/then&gt;
  &lt;/if&gt;
  
  &lt;!-- if-then-else form --&gt;
  &lt;if condition="some conditional expression"&gt;
    &lt;then&gt;
      ...
    &lt;/then&gt;
    &lt;else&gt;
      ...
    &lt;/else&gt;    
  &lt;/if&gt;</pre>  

  <p>条件属性に指定するのはJavaの条件式です。コンテキストスコープとシステムスコーコの変数が利用できます。<code>property()</code>省略ッドか，その省略形である<code>p()</code>ッドの引数としてヘンス名を渡すと，その値を文字列として返します。たとえば，“ k”という値の変数の値にアクセスするには， <code>property("k")</code>あるいは<code>p("k")</code>という书き方をします。数“ k”が未定义ならproperty（）メソッドは空文字列を返します。空ではありません。チェ，nullチェックは不要です。</p>

  <p><code>isDefined()</code>メソッドを使うと，変数が定义されているかどうかを确かめることが出来ます。たとえば，変数“ k”が定义されているかどうかをチェックするには<code>isDefined("k")</code>と书けばよいです。他にも，nullチェックをするための<code>isNull()</code>メソッドが用意されています。例：<code>isNull("k")</code></p>

  <pre class="prettyprint source">&lt;configuration debug="true"&gt;

  <b>&lt;if condition='property("HOSTNAME").contains("torino")'&gt;</b>
    <b>&lt;then&gt;</b>
      &lt;appender name="CON" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder&gt;
          &lt;pattern&gt;%d %-5level %logger{35} - %msg %n&lt;/pattern&gt;
        &lt;/encoder&gt;
      &lt;/appender&gt;
      &lt;root&gt;
        &lt;appender-ref ref="CON" /&gt;
      &lt;/root&gt;
    <b>&lt;/then&gt;</b>
  <b>&lt;/if&gt;</b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;file&gt;${randomOutputDir}/conditional.log&lt;/file&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d %-5level %logger{35} - %msg %n&lt;/pattern&gt;
   &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="ERROR"&gt;
     &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  
  <p><code>configuratoin要素</code>の中なら<em>どこにでも</em>条件分岐岐を置くことが出来ます。if-then-else式をネストすることもできます。XML，XML文法は非常に面倒ですし，泛用プログラグンミ言语の基盘には不适切です。条件，条件分岐岐が多すぎると，设定ファイルはあっという间に他の人には理解できないものになってしまいます。，后で自分が読み返しても理解できないでしょう。
  </p>


  <!-- ============================================================== -->

   <h3 class="doAnchor" name="insertFromJNDI">JNDIから変数を取得する</h3>

   <p>特定の状况下では，JNDIに格纳されたenvの内容を参照したいこともあるでしょう。<code>insertFromJNDIディレクティブ</code>を使うと，JNDIに格纳されたenvを取得して，ローカルスコープの変数<span class="attr">として</span>取り込むことができます。他の変数と同じく， <em>作用域属性</em>に指定した<a href="./03-configuration.html#scopes">别のスコープ</a>に新しい変数を登录することができます。
   </p>

   <p class="example">例：JNDI経由で取得したenvを変数として登录する（ <a href="http://logback.qos.ch/xref/chapters/configuration/insertFromJNDI.xml">logback-examples / src / main / java / chapters / configuration / insertFromJNDI.xml</a> ）</p>

   <pre class="prettyprint source">&lt;configuration&gt;
  <b>&lt;insertFromJNDI env-entry-name="java:comp/env/appName" as="<span class="green">appName"</span> /&gt;</b>
  <b>&lt;contextName&gt;<span class="green">${appName}</span>&lt;/contextName&gt;</b>

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d ${CONTEXT_NAME} %level %msg %logger{50}%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="CONSOLE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

  <p>この例は，envの“ java：comp / env / appName”を<span class="variable">appName</span>という名前の変数として登录するものです。<code>contextNameディレクティブ</code>で指定しているコンテキスト名には，その前に定义されている<code>insertFromJNDIディレクティブ</code>で登录した変数を使用していることがわかりますか。
  </p>

  <h3 class="doAnchor" name="fileInclusion">ファイルの取り込み</h3>

  <p>Joranは，设定ファイルの一部として别のファイルを読み込むことができます。そのためには， <code>include要素</code>として宣言します。</p>

  <p class="example">例：ファイルの取り込み（ <a href="http://logback.qos.ch/xref/chapters/configuration/containingConfig.xml">logback-examples / src / main / java / chapters / configuration / containsConfig.xml</a> ）</p>

  <pre class="prettyprint source">&lt;configuration&gt;
  <b>&lt;include file="src/main/java/chapters/configuration/includedConfig.xml"/&gt;</b>

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="includedConsole" /&gt;
  &lt;/root&gt;

&lt;/configuration&gt;</pre>

  <p>取り込まれるファイルでは，全ての要素が<code>included要素</code>の中に入っていなければなりません。<code>ConsoleAppender</code>を宣言する例を示します。</p>

  <p class="example">例：ファイルの取り込み（ <a href="http://logback.qos.ch/xref/chapters/configuration/includedConfig.xml">logback-examples / src / main / java / chapters / configuration / includedConfig.xml</a> ）</p>

  <pre class="source"><b class="green big">&lt;included&gt;</b>
  &lt;appender name="includedConsole" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;"%d - %m%n"&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
<b class="green big">&lt;/included&gt;</b></pre>


  <p>缲り返しになりますが，取り込まれるファイルでは， <code class="big green">included要素</code>が必须です。</p>

  <p>包括する対象として指定するのは，外部ファイルだけではなく，クラスパス上のリソースでも，URLでもよいです。</p>

  <ul>

    <li><b>ファイルの场合：</b><br>ファイルを取り込むには<span class="attr">文件属性</span>を使用します。相対パスを指定できますが，カレントディレクトリとして使われるのはアプリケーションショ设定したものになります。设定ファイルのパスとは无关系なので注意してください。</li>

    <li><p><b>リソースの场合：</b><br>クラスパス上のファイルなどのリソースを取り込むには<span class="attr">资源属性</span>を使用します。</p>

    <pre class="prettyprint source">&lt;include resource="includedConfig.xml"/&gt;</pre>
    
    </li>

    <li><p><b>URLの场合：</b><br>URLから取得できるコンテンツをンツを取り込むには<span class="attr">URL属性</span>を使用します。</p>

    <pre class="prettyprint source">&lt;include url="http://some.host.com/includedConfig.xml"/&gt;</pre>

    </li>
  </ul>

  <p>指定されたファイルが存在しなかった场合，登录はステータスメッセージを出力してそのことを报告します。取り込もうとしているファイルが<span class="attr">任意の</span>ものである场合，<code>include要素のoptional属性に<code>true</code>を指定しておけば、エラーメッセージを抑止することができます。</code></p>


  <pre class="prettyprint source">&lt;include optional="true" ..../&gt;</pre>

  <!-- ==================== ContextListener =================== -->
  <h2 class="doAnchor" name="contextListener">をンテキストリスナーを追加する</h2>

  <p><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/spi/LoggerContextListener.html">LoggerContextListener，，，，、、、、、、、、、、、、、、、、、、、、、</a>
  </p>


  <p><code>JMXConfigurator</code>は<code>LoggerContextListener</code>インターフェイスの実装の一つです。详しくは<a href="./jmxConfig.html">后の章</a>で说明します。
  </p>

  <h3 class="doAnchor" name="LevelChangePropagator">LevelChangePropagator</h3>

  <p>0.9ージョン0.9.25から，logback-classicの配布物には<code>LoggerContextListener</code>インターフェイスの実装である<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/jul/LevelChangePropagator.html">LevelChangePropagator</a>が含まれるようになりました。log，logback-classicのあらゆるロガーのレベルの変更を捉えて，java.util.loggingフレームワークに伝播に伝。ログレベルの変化を伝播するのはコストが高いので，ロギング式を无效にすることで改善されたはずの性能が台无しになってしまいます。<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/logging/LogRecord.html?is-external=true">LogRecord</a>のインスタンスはロギンギ式グ有效な场合にだけ，SLF4Jを介してlogbackに渡されます。<a href="http://www.slf4j.org/legacy.html#jul-to-slf4j">ul</a> ，実际のアプリケーションショ<a href="http://www.slf4j.org/legacy.html#jul-to-slf4j">jul-to-slf4j</a>ブリッジを使うのが合理的です。
  </p>


  <p>contextListener要素に<code>LevelChangePropagator</code>を登录するには次のようにします。</p>
  
  <pre class="prettyprint source">&lt;configuration debug="true"&gt;
  <b>&lt;contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator"/&gt;</b>
  .... 
&lt;/configuration&gt;</pre>

  <p>LevelChangePropagatorのプロパティ<span class="option">resetJUL</span>を指定すると，julloggersに指定されていたレベルがすべて初期化されます。，ハンドラーはそのまま残ります。</p>

  <pre class="prettyprint source">&lt;configuration debug="true"&gt;
  &lt;contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator"&gt;
    <b>&lt;resetJUL&gt;true&lt;/resetJUL&gt;</b>
  &lt;/contextListener&gt;
  ....
&lt;/configuration&gt;</pre>
  <p>
  </p>
  


  <script src="../templates/footer.js" type="text/javascript"></script>
</em></div><em>

</em></body></html>