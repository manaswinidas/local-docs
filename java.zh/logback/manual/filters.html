<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第7章：过滤器</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen"> 

  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">
	
    <h1>第7章：过滤器</h1>

   <a href="filters_ja.html">和訳（日语翻译）</a>

    <div class="quote">
      <p><em>有很多想法，丢掉坏主意。除非您有很多想法和某种选择原则，否则您将不会有好的想法。</em></p>
      
      <p>—莱纳斯·鲍林</p>
    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>

		
		<p>在前面的章节中，介绍了<a href="architecture.html#basic_selection">基本选择规则</a> ，它是经典的logback的核心。在本章中，将介绍其他过滤方法。
    </p>
	

    <p>Logback过滤器基于三元逻辑，允许将它们组装或链接在一起以构成任意复杂的过滤策略。它们很大程度上受到Linux iptables的启发。
		</p>

    <script src="../templates/setup.js" type="text/javascript"></script>

		<h2>经典的logback</h2>


		<p>Logback-classic提供两种类型的过滤器，常规过滤器和涡轮过滤器。
		</p>
		
    <h3 class="doAnchor" name="filter">常规过滤器</h3>

		<p>常规的logback-classic过滤器扩展了<a href="../xref/ch/qos/logback/core/filter/Filter.html"><code>Filter</code></a>抽象类，基本上由单个<code>decide()</code>采取的方法<code>ILoggingEvent</code>实例作为其参数。
		</p>
		

		<p>过滤器被组织成一个有序列表，并基于三元逻辑。的<code>decide(ILoggingEvent event)</code>每个过滤器的方法被依次调用。此方法返回其中之一<a href="../xref/ch/qos/logback/core/spi/FilterReply.html"><code>FilterReply</code></a>枚举值，即以下之一<code>DENY</code> ， <code>NEUTRAL</code>要么<code>ACCEPT</code> 。如果返回的值<code>decide</code> （）是<code>DENY</code> ，则无需查看其余过滤器即可立即删除日志事件。如果返回的值是<code>NEUTRAL</code> ，然后查询列表中的下一个过滤器。如果没有其他过滤器可参考，则将正常处理日志记录事件。如果返回的值是<code>ACCEPT</code> ，则记录事件将立即处理，跳过其余过滤器的调用。
    </p>
    
    <p>在经典的logback中，可以将过滤器添加到<code>Appender</code>实例。通过将一个或多个过滤器添加到附加程序，可以按任意条件过滤事件，例如日志消息的内容，MDC的内容，一天中的时间或日志事件的任何其他部分。
    </p>
    
		<h3 class="doAnchor" name="yourOwnFilter">实施自己的过滤器</h3>
		
		<p>创建自己的过滤器很容易。您要做的就是扩展<code>Filter</code>抽象类并实现<code>decide()</code>方法。
		</p>
		
		<p>下面显示的SampleFilter类提供了一个示例。它的<code>decide</code>方法返回ACCEPT以记录其消息字段中包含字符串“ sample”的事件。对于其他事件，返回值NEUTRAL。
		</p>
		
    <em>示例：基本的自定义过滤器（ <a href="../xref/chapters/filters/SampleFilter.html">logback-examples / src / main / java / chapters / filters / SampleFilter.java</a> ）</em>
    <pre class="prettyprint source">package chapters.filters;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.filter.Filter;
import ch.qos.logback.core.spi.FilterReply;

public class SampleFilter extends Filter&lt;ILoggingEvent> {

  @Override
  public FilterReply decide(ILoggingEvent event) {    
    if (event.getMessage().contains("sample")) {
      return FilterReply.ACCEPT;
    } else {
      return FilterReply.NEUTRAL;
    }
  }
}</pre>

		<p>接下来显示的配置文件附加一个<code>SampleFilter</code>到一个<code>ConsoleAppender</code> 。
		</p>

    <em>示例：SampleFilter配置（logback-examples / src / main / resources / chapters / filters / SampleFilterConfig.xml）</em> <span class="asGroovy" onclick="return asGroovy('SampleFilterConfig');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('SampleFilterConfig');">查看</span>
    <pre id="SampleFilterConfig" class="prettyprint source">&lt;configuration>
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">

    <b>&lt;filter class="chapters.filters.SampleFilter" /></b>

    &lt;encoder>
      &lt;pattern>
        %-4relative [%thread] %-5level %logger - %msg%n
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
	
  &lt;root>
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

		<p>借助Logback的配置框架Joran的帮助，指定属性或要过滤的子组件也很容易。在过滤器类中添加相应的setter方法后，在以该属性命名的xml元素中指定该属性的值，然后将其嵌套在<code><filter></code>元件。
		</p>
		
		<p>通常，所需的滤波器逻辑由两个正交部分组成，一个匹配/不匹配测试和一个取决于匹配/不匹配的响应。例如，对于给定的测试（例如，消息等于“ foobar”），一个过滤器可能在匹配时响应ACCEPT而在不匹配时响应NEUTRAL，而另一个过滤器可能在匹配时响应NEUTRAL而在不匹配时响应DENY。
    </p>

    <p>注意此正交性，logback随<a href="../xref/ch/qos/logback/core/filter/AbstractMatcherFilter.html"><code>AbstractMatcherFilter</code></a>类提供了一个有用的框架，借助两个名为<em>OnMatch</em>和<em>OnMismatch的</em>属性，可以指定对匹配和不匹配的适当响应。logback中包含的大多数常规过滤器均源自<code>AbstractMatcherFilter</code> 。
    </p>
		
		<h3 class="doAnchor" name="levelFilter">级别过滤器</h3>
		
		<p><a href="../xref/ch/qos/logback/classic/filter/LevelFilter.html"><code>LevelFilter</code></a>根据精确的级别匹配过滤事件。如果事件的级别等于已配置的级别，则过滤器将接受或拒绝事件，具体取决于<span class="option">onMatch</span>和<span class="option">onMismatch</span>属性的配置。这是一个示例配置文件。
		</p>
		
    <em>示例：示例LevelFilter配置（logback-examples / src / main / resources / chapters / filters / levelFilterConfig.xml）</em> <span class="asGroovy" onclick="return asGroovy('levelFilterConfig');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('levelFilterConfig');">查看</span>
    <pre id="levelFilterConfig" class="prettyprint source">&lt;configuration>
  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.classic.filter.LevelFilter">
      &lt;level>INFO&lt;/level>
      &lt;onMatch>ACCEPT&lt;/onMatch>
      &lt;onMismatch>DENY&lt;/onMismatch>
    &lt;/filter></b>
    &lt;encoder>
      &lt;pattern>
        %-4relative [%thread] %-5level %logger{30} - %msg%n
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>
&lt;/configuration></pre>

    <h3 class="doAnchor" name="thresholdFilter">阈值过滤器</h3>

		<p>的<a href="../xref/ch/qos/logback/classic/filter/ThresholdFilter.html"><code>ThresholdFilter</code></a>过滤低于指定阈值的事件。对于等于或高于阈值的事件， <code>ThresholdFilter</code>当它<code>decide</code> （）方法被调用。但是，级别低于阈值的事件将被拒绝。这是一个示例配置文件。
		</p>

    <em>示例：示例ThresholdFilter配置（logback-examples / src / main / resources / chapters / filters / thresholdFilterConfig.xml）</em> <span class="asGroovy" onclick="return asGroovy('thresholdFilterConfig');">作为.groovy查看</span>
    <pre id="thresholdFilterConfig"  class="prettyprint source">&lt;configuration>
  &lt;appender name="CONSOLE"
    class="ch.qos.logback.core.ConsoleAppender">
    &lt;!-- deny all events with a level below INFO, that is TRACE and DEBUG -->
    <b>&lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      &lt;level>INFO&lt;/level>
    &lt;/filter></b>
    &lt;encoder>
      &lt;pattern>
        %-4relative [%thread] %-5level %logger{30} - %msg%n
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>
&lt;/configuration></pre>


    <h2 class="doAnchor" name="evalutatorFilter">EvaluatorFilter</h2>

    <p><a href="../xref/ch/qos/logback/core/filter/EvaluatorFilter.html"><code>EvaluatorFilter</code></a>是封装了<code>EventEvaluator</code> 。顾名思义， <a href="../xref/ch/qos/logback/core/boolex/EventEvaluator.html"><code>EventEvaluator</code></a>评估给定事件是否满足给定条件。在匹配和不匹配时，托管<code>EvaluatorFilter</code>将分别返回由<span class="option">onMatch</span>或<span class="option">onMismatch</span>属性指定的值。
    </p>


    <p>注意<code>EventEvaluator</code>是一个抽象类。您可以通过子类实现自己的事件评估逻辑<code>EventEvaluator</code> 。
    </p>
    

    <!-- ======================== GEventEvaluator ========================= -->

    <h3 class="doAnchor" name="GEventEvaluator">GEventEvaluator</h3>
    
    <p><a href="../xref/ch/qos/logback/classic/boolex/GEventEvaluator.html">GEventEvaluator</a>是一个具体的<a href="../xref/ch/qos/logback/core/boolex/EventEvaluator.html"><code>EventEvaluator</code></a>以任意Groovy语言布尔表达式为评估标准的实现。我们将此类Groovy语言布尔表达式称为“ groovy评估表达式”。Groovy评估表达式为事件过滤提供了前所未有的灵活性。 <code>GEventEvaluator</code>需要Groovy运行时。请参阅安装文档的<a href="../setup.html#groovy">相应部分</a> ，以将Groovy运行时添加到您的类路径中。
    </p>

    <p>评估表达式是在解释配置文件时动态编译的。作为用户，您不必担心实际的管道问题。但是，您有责任确保groovy语言表达式有效。
    </p>

    <p>评估表达式作用于当前的日志事件。Logback会自动将类型为<a href="../apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">ILoggingEvent</a>的当前日志记录事件插入为称为“ <em>事件</em> ”的变量，并将其简写称为“ <em>e</em> ”。变量TRACE，DEBUG，INFO，WARN和ERROR也会导出到表达式的范围内。因此，“ event.level == DEBUG”和“ e.level == DEBUG”是等效且有效的常规表达式，它们将返回<code>true</code>仅当当前日志记录事件的级别与DEBUG相同时。对于级别上的其他比较运算符，级别字段应使用<code>toInt()</code>操作员。
    </p>

    <p>这是一个更完整的示例。</p>

    <span class="asGroovy" onclick="return asGroovy('GEventEvaluator');">观看为.groovy</span>
    <pre id="GEventEvaluator"  class="prettyprint source">&lt;configuration>
    
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">      
      &lt;evaluator class="ch.qos.logback.classic.boolex.GEventEvaluator"> 
        &lt;expression>
           e.level.toInt() >= WARN.toInt() &amp;amp;&amp;amp;  &lt;!-- Stands for &amp;&amp; in XML -->
           !(e.mdc?.get("req.userAgent") =~ /Googlebot|msnbot|Yahoo/ )
        &lt;/expression>
      &lt;/evaluator>
      &lt;OnMismatch>DENY&lt;/OnMismatch>
      &lt;OnMatch>NEUTRAL&lt;/OnMatch>
    &lt;/filter></b>
    &lt;encoder>
      &lt;pattern>
        %-4relative [%thread] %-5level %logger - %msg%n
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>


    <p>除非错误是由与Google，MSN或Yahoo关联的Web爬网程序生成的，否则上述过滤器将使WARN级及更高级别的事件通过控制台。通过检查与事件关联的MDC是否包含与以下内容匹配的“ req.userAgent”的值来实现此目的： <code>/Googlebot|msnbot|Yahoo/</code>正则表达式。请注意，由于MDC映射可以为null，因此我们还使用了Groovy的<a href="http://groovy.codehaus.org/Null+Object+Pattern">安全解引用运算符</a> ，即？。操作员。如果用Java表示，等效逻辑将更长。
    </p>
    
    <p>如果您想知道用户代理的标识符是如何在“ req.userAgent”键下插入到MDC中的，那么我们值得一提的是，logback附带了一个名为servlet过滤器<a href="mdc.html#mis"><code>MDCInsertingServletFilter</code></a>为此目的而设计。将在下一章中进行描述。
    </p>

    <!-- ==================== JaninoEventEvaluator ======================== -->
    
    <h3 class="doAnchor" name="JaninoEventEvaluator">JaninoEventEvaluator</h3>
    

    <p>经典的Logback船用另一种混凝土<code>EventEvaluator</code>名为<a href="../xref/ch/qos/logback/classic/boolex/JaninoEventEvaluator.html">JaninoEventEvaluator的</a>实现， <a href="../xref/ch/qos/logback/classic/boolex/JaninoEventEvaluator.html">它</a>采用返回Java值的任意Java语言块作为评估标准。我们将此类Java语言布尔表达式称为“ <em>评估表达式</em> ”。评估表达式使事件过滤具有极大的灵活性。 <code>JaninoEventEvaluator</code>需要<a href="http://docs.codehaus.org/display/JANINO/Home">Janino库</a> 。请参阅安装文档的<a href="../setup.html#janino">相应部分</a> 。相比<code>JaninoEventEvaluator</code> ， <code>GEventEvaluator</code>借助Groovy语言，使用起来更加方便，但是<code>JaninoEventEvaluator</code>对于同等的表达式，通常运行（快得多）。
    </p>

    <p>评估表达式是在解释配置文件时动态编译的。作为用户，您不必担心实际的管道问题。但是，您有责任确保Java语言表达式返回一个布尔值，即它的计算结果为true或false。</p>


    <p>评估表达式是在当前日志记录事件上评估的。Logback-classic自动将日志记录事件的各个字段导出为可从评估表达式访问的变量。这些导出变量的区分大小写的名称如下所示。
    </p>

		<table class="bodyTable">
      <tbody><tr>
        <th>名称</th>
        <th>类型</th>
        <th>描述</th>
			</tr>
      <tr>
				<td>事件</td>
				<td><code>LoggingEvent</code></td>

        <td>与日志记录请求关联的原始日志记录事件。事件中还提供以下所有变量。例如， <code>event.getMessage()</code>返回与下面描述的<em>消息</em>变量相同的String值。
        </td>
			</tr>

      <tr class="alt">
				<td>信息</td>
        <td><code>String</code></td>
        <td>日志记录请求的原始消息。对于某些记录器<em>l</em> ，当您编写l.info（“ Hello {}”，name）;时。如果名称被分配了值“ Alice”，则消息“ Hello {}”。</td> </tr>
		
      <tr>
				<td>格式化的消息</td>
        <td><code>String</code></td>
        <td>日志记录请求中的格式化消息。对于某些记录器<em>l</em> ，当您编写l.info（“ Hello {}”，name）;时。如果名称被分配了值“ Alice”，则“ Hello Alice”是格式化的消息。</td>
			</tr>
		
      <tr class="alt">
				<td>记录器</td>
				<td><code>String</code></td>
				<td>记录器的名称。
        </td>
			</tr>

      <tr>
        <td>loggerContext</td>
				<td><a href="../xref/ch/qos/logback/classic/spi/LoggerContextVO.html"><code>LoggerContextVO</code></a></td>
				<td>记录事件所属的记录器上下文的受限（值对象）视图。
        </td>
			</tr>


			<tr class="alt">
				<td>水平</td>
				<td><code>int</code></td>
				<td>对应于级别的int值。为了帮助轻松创建涉及级别的表达式，还提供了默认值<em>DEBUG</em> ， <em>INFO</em> ， <em>WARN</em>和<em>ERROR</em> 。因此，使用<em>level> INFO</em>是正确的表达。
				</td>
			</tr>

			<tr>
				<td>时间戳记</td>
				<td><code>long</code></td>
				<td>与记录事件的创建相对应的时间戳。
				</td>
			</tr>
			<tr class="alt">
				<td>记号笔</td>
				<td><code>Marker</code></td>
        <td>的<code>Marker</code>与日志记录请求关联的对象。请注意，标记可以为空，您有责任检查此条件，以避免<code>NullPointerException</code> 。
				</td>
			</tr>
			<tr>
				<td>多媒体广告</td>
				<td><code>Map</code></td>
				<td>在创建日志记录事件时包含所有MDC值的映射。可以使用以下表达式访问值： <em>mdc.get（“ myKey”）</em> 。从经典logback版本0.9.30开始，“ mdc”变量将永远不会为null。

        <p>的<code>java.util.Map</code>类型是非参数化的，因为Janino不支持泛型。因此，返回的类型<code>mdc.get()</code>是<code>Object</code>并不是<code>String</code> 。调用<code>String</code>返回值的方法，必须将其强制转换为<code>String</code> 。例如， <code>((String) mdc.get("k")).contains("val")</code> 。
        </p>
				</td>
			</tr>

      <tr class="alt">
				<td>抛出</td>
        <td>java.lang。可投掷</td>
				<td>如果没有异常与事件关联，则“ throwable”变量的值将为null。不幸的是，“ throwable”无法在序列化中幸免。因此，在远程系统上，其值将始终为null。对于位置无关的表达式，请使用<code>throwableProxy</code>接下来说明变量。
				</td>
			</tr>

			<tr>
				<td>throwableProxy</td>
				<td><a href="../xref/ch/qos/logback/classic/spi/IThrowableProxy.html"><code>IThrowableProxy</code></a></td>
				<td>与日志记录事件关联的异常的代理。如果没有异常与事件关联，则“ throwableProxy”变量的值将为null。与“ throwable”相反，当异常与事件相关联时，即使在远程系统上（即在序列化之后），“ throwableProxy”的值也不会为空。
				</td>
			</tr>

    

		</tbody></table>

    <p>这是一个具体的例子。</p>

    <em>示例：基本事件评估程序的用法（logback-examples / src / main / resources / chapters / filters / basicEventEvaluator.xml）</em> <span class="asGroovy" onclick="return asGroovy('basicEventEvaluator');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('basicEventEvaluator');">查看</span>
    <pre id="basicEventEvaluator" class="prettyprint source longline">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">      
      &lt;evaluator> &lt;!-- defaults to type ch.qos.logback.classic.boolex.JaninoEventEvaluator -->
        &lt;expression><span class="green">return message.contains("billing");</span>&lt;/expression>
      &lt;/evaluator>
      &lt;OnMismatch>NEUTRAL&lt;/OnMismatch>
      &lt;OnMatch>DENY&lt;/OnMatch>
    &lt;/filter></b>
    &lt;encoder>
      &lt;pattern>
        %-4relative [%thread] %-5level %logger - %msg%n
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="INFO">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

		<p>上述配置文件中的粗体部分添加了<code>EvaluatorFilter</code>到一个<code>ConsoleAppender</code> 。类型的评估者<code>JaninoEventEvaluator</code>然后注入<code>EvaluatorFilter</code> 。在没有<span class="attr">class</span>属性的情况下<code><evaluator></code>用户指定的元素，Joran将推断默认类型为<code>JaninoEventEvaluator</code>对于评估者。这是Joran隐式推断组件类型的<a href="onJoran.html#defaultClassMapping">少数情况</a>之一。
    </p>

    <p><em>表达式</em>元素对应于刚刚讨论的评估表达式。表达方式<code>return message.contains("billing");</code>返回一个布尔值。请注意， <em>消息</em>变量由<code>JaninoEventEvaluator</code> 。
    </p>

		<p>假定<span class="option">OnMismatch</span>属性设置为NEUTRAL且<span class="option">OnMatch</span>属性设置为DENY，则此评估程序过滤器将删除其消息包含字符串“ billing”的所有日志记录事件。
    </p>

    <p>的<a href="../xref/chapters/filters/FilterEvents.html"><code>FilterEvents</code></a>应用程序发出10个日志记录请求，编号为0到9。让我们先跑<code>FilterEvents</code>没有任何过滤器的类：</p>
		
<div class="source"><pre>
java chapters.filters.FilterEvents src/main/java/chapters/filters/basicConfiguration.xml
</pre></div>
		
		<p>将显示所有请求，如下所示：</p>

<div class="source"><pre>0    [main] INFO  chapters.filters.FilterEvents - logging statement 0
0    [main] INFO  chapters.filters.FilterEvents - logging statement 1
0    [main] INFO  chapters.filters.FilterEvents - logging statement 2
0    [main] DEBUG chapters.filters.FilterEvents - logging statement 3
0    [main] INFO  chapters.filters.FilterEvents - logging statement 4
0    [main] INFO  chapters.filters.FilterEvents - logging statement 5
0    [main] ERROR chapters.filters.FilterEvents - <b>billing statement 6</b>
0    [main] INFO  chapters.filters.FilterEvents - logging statement 7
0    [main] INFO  chapters.filters.FilterEvents - logging statement 8
0    [main] INFO  chapters.filters.FilterEvents - logging statement 9</pre></div>



		<p>假设我们要摆脱“账单声明”。上面列出的<em>basicEventEvaluator.xml</em>配置文件过滤包含字符串“ billing”的消息，而这恰好是所需的结果。</p>

    <p>使用<em>basicEventEvaluator.xml</em>运行：</p>
    <p class="source">Java Chapters.Filters。FilterEvents src / main / java / chapters / filters / basicEventEvaluator.xml</p>
    <p>我们获得：</p>
		
    <p class="source">0 [主要] INFO章节。FilterEvents-日志记录语句0 0 [main] INFO章节。FilterEvents-日志记录语句1 0 [main] INFO章节。FilterEvents-记录语句2 0 [main] DEBUG的Chapters.filters。FilterEvents-日志记录语句3 0 [main] INFO章节。FilterEvents-记录语句4 0 [main] INFO章节。FilterEvents-日志记录语句5 0 [main] INFO章节。FilterEvents-记录语句7 0 [main] INFO章节。FilterEvents-记录语句8 0 [main] INFO章节。FilterEvents-日志记录语句9</p>
		

    <p>评估表达式可以是Java块。例如，以下是有效的表达式。</p>

    <pre class="prettyprint source">&lt;evaluator>
  &lt;expression>
    if(logger.startsWith("org.apache.http"))
      return true;

    if(mdc == null || mdc.get("entity") == null)
      return false;

    String payee = (String) mdc.get("entity");

    if(logger.equals("org.apache.http.wire") &amp;amp;&amp;amp; &lt;!-- &amp; encoded as &amp;amp; -->
        payee.contains("someSpecialValue") &amp;amp;&amp;amp;
        !message.contains("someSecret")) {
      return true;
    }

    return false;
  &lt;/expression>
&lt;/evaluator></pre>


 	  <h2 class="doAnchor" name="matcher">匹配器</h2>

    <p>虽然可以通过调用做图案匹配<a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html#matches%28java.lang.String%29">的匹配（）</a>中所述方法<code>String</code>类，这会产生全新的编译成本<code>Pattern</code>每次调用过滤器时的对象。为了消除这种开销，您可以预定义一个或多个<a href="../xref/ch/qos/logback/core/boolex/Matcher.html">Matcher</a>对象。定义匹配器后，可以在评估器表达式中按名称重复引用它。</p>

    <p>一个例子应该阐明这一点：</p>

    <em>示例：在事件评估器中定义匹配器（logback-examples / src / main / resources / chapters / filters / evaluatorWithMatcher.xml）</em> <span class="asGroovy" onclick="return asGroovy('evaluatorWithMatcher');">以.groovy视图</span>

    <pre id="evaluatorWithMatcher" class="prettyprint source">&lt;configuration debug="true">

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">
      &lt;evaluator>        
        <b>&lt;matcher>
          &lt;Name>odd&lt;/Name>
          &lt;!-- filter out odd numbered statements -->
          &lt;regex>statement [13579]&lt;/regex>
        &lt;/matcher>
        
        &lt;expression>odd.matches(formattedMessage)&lt;/expression></b>
      &lt;/evaluator>
      &lt;OnMismatch>NEUTRAL&lt;/OnMismatch>
      &lt;OnMatch>DENY&lt;/OnMatch>
    &lt;/filter>
    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

    <p>使用<em>evaluatorWithMatcher.xml</em>运行：</p>
    <p class="source">Java Chapters.Filters。FilterEvents src / main / java / chapters / filters / evaluatorWithMatcher.xml</p>
    <p>我们获得：</p>
		
    <p class="source">260 [主要] INFO章节。FilterEvents-记录语句0 264 [main] INFO章节。FilterEvents-记录语句2 264 [main] INFO章节。FilterEvents-记录语句4 266 [main]错误的Chapters.filters。FilterEvents-帐单6 266 [main] INFO章节。FilterEvents-日志记录语句8</p>

    <p>如果您需要定义其他匹配器，则可以通过添加更多内容来实现<code><matcher></code>元素。</p>





    <!-- ================================================================ -->
    <!-- ===================== TURBO FILTER ============================= -->
    <!-- ================================================================ -->

    <h2 class="doAnchor" name="TurboFilter">涡轮过滤器</h2>
    
    <p><code>TurboFilter</code>所有对象都扩展了<a href="../xref/ch/qos/logback/classic/turbo/TurboFilter.html"><code>TurboFilter</code></a>抽象类。像常规过滤器一样，它们使用三元逻辑返回对日志记录事件的评估。
    </p>
    
    <p>总体而言，它们的工作方式与前面提到的过滤器非常相似。但是，两者之间有两个主要区别<code>Filter</code>和<code>TurboFilter</code>对象。
    </p>
    
   	<p><code>TurboFilter</code>对象绑定到日志记录上下文。因此，它们不仅在使用给定的附加程序时被调用，而且在每次发出日志记录请求时都被调用。它们的范围比附加附加过滤器的范围大。
   	</p>
   	
   	<p>更重要的是，它们在<code>LoggingEvent</code>对象创建。
   	<code>TurboFilter</code>对象不需要实例化日志记录事件即可过滤日志记录请求。这样，即使在事件创建之前，turbo过滤器也旨在对日志事件进行高性能过滤。
    </p>

   	
   	<h3 class="doAnchor" name="yourOwnTurboFilter">实现自己的TurboFilter</h3>
    
    <p>创造自己的<code>TurboFilter</code>组件，只需扩展<code>TurboFilter</code>抽象类。如前所述，在实现自定义过滤器对象时，开发自定义<code>TurboFilter</code>只要求一个工具<code>decide()</code>方法。在下一个示例中，我们创建一个稍微复杂一些的过滤器：</p>
    
<em>示例：基本习惯<code>TurboFilter</code> （ <a href="../xref/chapters/filters/SampleTurboFilter.html">logback-examples / src / main / java / chapters / filters / SampleTurboFilter.java</a> ）</em>		
<pre class="prettyprint source">package chapters.filters;

import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.turbo.TurboFilter;
import ch.qos.logback.core.spi.FilterReply;

public class SampleTurboFilter extends TurboFilter {

  String marker;
  Marker markerToAccept;

  @Override
  public FilterReply decide(Marker marker, Logger logger, Level level,
      String format, Object[] params, Throwable t) {

    if (!isStarted()) {
      return FilterReply.NEUTRAL;
    }

    if ((markerToAccept.equals(marker))) {
      return FilterReply.ACCEPT;
    } else {
      return FilterReply.NEUTRAL;
    }
  }

  public String getMarker() {
    return marker;
  }

  public void setMarker(String markerStr) {
    this.marker = markerStr;
  }

  @Override
  public void start() {
    if (marker != null &amp;&amp; marker.trim().length() > 0) {
      markerToAccept = MarkerFactory.getMarker(marker);
      super.start(); 
    }
  }
}
</pre>

		<p>的<code>TurboFilter</code>上面的事件接受包含特定标记的事件。如果找不到所述标记，则过滤器将责任传递给链中的下一个过滤器。
		</p>
		
		<p>为了提供更大的灵活性，可以在配置文件中指定要测试的标记，因此可以指定getter和setter方法。我们还实施了<code>start()</code>方法，以检查是否在配置过程中指定了该选项。
		</p>
		
		<p>这是一个利用我们新创建的示例配置<code>TurboFilter</code> 。
		</p>
		
    <em>示例：基本习惯<code>TurboFilter</code>配置（logback-examples / src / main / resources / chapters / filters / sampleTurboFilterConfig.xml）</em> <span class="asGroovy" onclick="return asGroovy('sampleTurboFilterConfig');">查看为.groovy</span>

    <pre id="sampleTurboFilterConfig"  class="prettyprint source">&lt;configuration>
  <b>&lt;turboFilter class="chapters.filters.SampleTurboFilter">
    &lt;Marker>sample&lt;/Marker>
  &lt;/turboFilter></b>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>
        %-4relative [%thread] %-5level %logger - %msg%n
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root>
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>  

   	<p>经典的Logback附带以下几种<code>TurboFilter</code>类可供使用。的<a href="../xref/ch/qos/logback/classic/turbo/MDCFilter.html"><code>MDCFilter</code></a>检查MDC中是否存在给定值，而<a href="../apidocs/ch/qos/logback/classic/turbo/DynamicThresholdFilter.html"><code>DynamicThresholdFilter</code></a>允许基于MDC密钥/级别阈值关联进行过滤。另一方面， <a href="../xref/ch/qos/logback/classic/turbo/MarkerFilter.html"><code>MarkerFilter</code></a>检查是否存在与日志记录请求关联的特定标记。</p>
   	
   	<p>这是一个示例配置，同时使用<code>MDCFilter</code>和<code>MarkerFilter</code> 。
   	</p>
   	
    <em>例： <code>MDCFilter</code>和<code>MarkerFilter</code>配置（logback-examples / src / main / resources / chapters / filters / turboFilters.xml）</em> <span class="asGroovy" onclick="return asGroovy('turboFilters');">查看为.groovy</span>
    <pre id="turboFilters" class="prettyprint source">&lt;configuration>

  &lt;turboFilter class="ch.qos.logback.classic.turbo.MDCFilter">
    &lt;MDCKey>username&lt;/MDCKey>
    &lt;Value>sebastien&lt;/Value>
    &lt;OnMatch>ACCEPT&lt;/OnMatch>
  &lt;/turboFilter>
	
  &lt;turboFilter class="ch.qos.logback.classic.turbo.MarkerFilter">
    &lt;Marker>billing&lt;/Marker>
    &lt;OnMatch>DENY&lt;/OnMatch>
  &lt;/turboFilter>

  &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%date [%thread] %-5level %logger - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="INFO">
    &lt;appender-ref ref="console" />
  &lt;/root>  
&lt;/configuration></pre>

		<p>您可以通过发出以下命令来查看此配置的运行情况：</p>
    
    <p class="source">Java Chapters.Filters。FilterEvents src / main / java / chapters / filters / turboFilters.xml</p>

		<p>如我们先前所见， <a href="../xref/chapters/filters/FilterEvents.html"><code>FilterEvents</code></a>应用程序发出10个日志记录请求，编号为0到9。除请求3和6外，所有请求的级别均为<em>INFO</em> ，与分配给根记录器的级别相同。第三请求以<em>DEBUG</em>级别发出，该级别低于有效级别。但是，由于MDC密钥“用户名”在第三个请求之前被设置为“ sebastien”，而在此之后被删除，因此<code>MDCFilter</code>专门接受请求（并且仅接受该请求）。在<em>错误</em>级别发出的第六个请求被标记为“计费”。因此，它被MarkerFilter（配置中的第二个涡轮过滤器）拒绝。
		</p>
		
		<p>因此，输出<code>FilterEvents</code>使用上面显示的<em>turboFilters.xml</em>文件配置的应用程序是：</p>

    <p class="source">2006-12-04 15：17：22,859 [main] INFO pages.filters。FilterEvents-记录语句0 2006-12-04 15：17：22,875 [main] INFO章节。FilterEvents-日志记录语句1 2006-12-04 15：17：22,875 [main] INFO章节。FilterEvents-记录语句2 2006-12-04 15：17：22,875 [main]调试Chapters.filters。FilterEvents-记录语句3 2006-12-04 15：17：22,875 [main] INFO的章节。FilterEvents-日志记录语句4 2006-12-04 15：17：22,875 [main] INFO章节。FilterEvents-记录语句5 2006-12-04 15：17：22,875 [main] INFO的章节。FilterEvents-日志记录语句7 2006-12-04 15：17：22,875 [main] INFO章节。FilterEvents-日志记录语句8 2006-12-04 15：17：22,875 [main] INFO章节。FilterEvents-日志记录语句9</p>
			
			
		<p>可以看到，无论如何，如果我们仅遵循整体<em>INFO</em>级别，则不应显示第三个请求，因为它与第一个请求匹配<code>TurboFilter</code>要求并被接受。
		</p>    
		
		<p>另一方面，应该已经显示了第六个请求，即<em>ERROR</em>级别请求。但它满足了第二<code>TurboFilter</code>其<span class="option">OnMatch</span>选项设置为<em>DENY</em> 。因此，没有显示第6个请求。
		</p>
		


		  
    <h3 class="doAnchor" name="DuplicateMessageFilter">DuplicateMessageFilter</h3>

    <p>的<code>DuplicateMessageFilter</code>值得单独介绍。该过滤器检测重复的消息，并在超过一定重复次数后丢弃重复的消息。
    </p>

    <p>为了检测重复，此过滤器在消息之间使用简单的字符串相等性。它不会检测非常相似的消息（仅相差几个字符）。例如，如果您编写：</p>

    <pre class="prettyprint source">logger.debug("Hello "+name0);
logger.debug("Hello "+name1);</pre>
  
    <p>假设<code>name0</code>和<code>name1</code>具有不同的值，则两个“ Hello”消息将被视为无关。根据用户需求，将来的发行版可能会检查字符串的相似性，从而消除相似但不相同的消息的重复。
    </p>

    <p>请注意，在参数化日志记录的情况下，仅考虑原始消息。例如，在接下来的两个请求中，原始消息（即“ Hello {}。”）是相同的，因此被视为重复。
    </p>

    <pre class="prettyprint source">logger.debug("Hello {}.", name0);
logger.debug("Hello {}.", name1);</pre>
  
    <p>允许的重复次数可以由<span class="option">AllowedRepetitions</span>属性指定。例如，如果该属性设置为1，则将删除同一消息的第二次及其后出现。同样，如果将该属性设置为2，则将删除同一消息的第3次及其后续出现。默认情况下， <span class="option">AllowedRepetitions</span>属性设置为5。
    </p>

    <p>为了检测重复，此过滤器需要在内部缓存中保留对旧消息的引用。此缓存的大小由<span class="option">CacheSize</span>属性确定。默认情况下，它设置为100。
    </p>

    
    <em>例： <code>DuplicateMessageFilter</code>配置（logback-examples / src / main / resources / chapters / filters / duplicateMessage.xml）</em> <span class="asGroovy" onclick="return asGroovy('duplicateMessage');">查看为.groovy</span>
    <pre id="duplicateMessage" class="prettyprint source">&lt;configuration>

  <b>&lt;turboFilter class="ch.qos.logback.classic.turbo.DuplicateMessageFilter"/></b>

  &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%date [%thread] %-5level %logger - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="INFO">
    &lt;appender-ref ref="console" />
  &lt;/root>  
&lt;/configuration></pre>

  <p>因此，输出为<code>FilterEvents</code>使用<em>plicateMessage.xml</em>配置的应用程序是：</p>

    <p class="source">2008-12-19 15：04：26,156 [main] INFO的Chapters.filters。FilterEvents-日志记录语句0 2008-12-19 15：04：26,156 [main] INFO的Chapters.filters。FilterEvents-记录语句1 2008-12-19 15：04：26,156 [main] INFO的Chapters.filters。FilterEvents-记录语句2 2008-12-19 15：04：26,156 [main] INFO的Chapters.filters。FilterEvents-记录语句4 2008-12-19 15：04：26,156 [main] INFO的Chapters.filters。FilterEvents-记录语句5 2008-12-19 15：04：26,171 [main]错误chapters.filters。FilterEvents-帐单6</p>

    <p>“ logging statement 0”是消息“ logging statement {}”的首次<em>出现</em> 。 “日志记录语句1”是第一个<em>重复</em> ，“日志记录语句2”是第二个重复。有趣的是，级别DEBUG的“记录语句3”是<em>第三次</em>重复，即使后来由于<a href="architecture.html#basic_selection">基本选择规则</a>而被删除。这可以通过以下事实来解释：turbo过滤器先于其他类型的过滤器（包括基本选择规则）被调用。从而， <code>DuplicateMessageFilter</code>认为“记录语句3”是重复的，而忽略了它将在处理链中进一步下降的事实。 “日志记录语句4”是第四重复，“日志记录语句5”是第五重复。因为默认情况下只允许重复5次，所以删除了语句6和更高的语句。
    </p>

    <h1 class="doAnchor" name="logbac-access">在logback访问中</h1>
    
    <p>Logback-access提供了经典logback可用的大多数功能。特别是， <code>Filter</code>对象是可用的，并且以与经典日志对象相同的方式工作，但有一个明显的区别。代替<code>LoggingEvent</code>实例logback-access过滤器起作用<a href="../xref/ch/qos/logback/access/spi/AccessEvent.html"><code>AccessEvent</code></a>实例。目前，logback-access附带有限数量的以下所述过滤器。如果您想建议其他过滤器，请联系logback-dev邮件列表。
    </p>

		<h2 class="doAnchor" name="countingFilter"><code>CountingFilter</code></h2>
		
		<p>在...的帮助下<a href="xref/ch/qos/logback/access/filter/CountingFilter.html"><code>CountingFilter</code></a>在类中，logback-access可以提供有关对Web服务器访问的统计数据。初始化后， <code>CountingFilter</code>将自己作为MBean注册到平台的JMX服务器上。然后，您可以查询该MBean以获取统计数据，例如按分钟，小时，天，周或月的平均值。还可以提供其他统计信息，例如前一周，天，小时或月的计数以及总数。
		</p>
		
		<p>以下<em>logback-access.xml</em>配置文件声明了一个<code>CountingFilter</code> 。</p>

    <pre class="prettyprint source">&lt;configuration>
  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" />

  <b>&lt;filter class="ch.qos.logback.access.filter.CountingFilter">
    &lt;name>countingFilter&lt;/name>
  &lt;/filter></b>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%h %l %u %t \"%r\" %s %b&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;appender-ref ref="STDOUT" />
&lt;/configuration></pre>

    <p>您可以检查维护的各种统计信息<code>CountingFilter</code>通过平台上的JMX服务器<code>jconsole</code>应用。</p>


    <img alt="通过jconsole进行CountingFilter" src="images/chapters/filters/countingFilter.png">
	

    <h3 class="doAnchor" name="access_EvalutorFilter">EvaluatorFilter</h3>

    
    <p><a href="../xref/ch/qos/logback/core/filter/EvaluatorFilter.html"><code>EvaluatorFilter</code></a>是封装了<code>EventEvaluator</code> 。顾名思义， <a href="../xref/ch/qos/logback/core/boolex/EventEvaluator.html"><code>EventEvaluator</code></a>评估给定事件是否满足给定条件。在匹配和不匹配时，托管<code>EvaluatorFilter</code>将分别返回由<span class="option">onMatch</span>或<span class="option">onMismatch</span>属性指定的值。注意<code>EvaluatorFilter</code>先前已经在logback-classic的上下文中进行了讨论（ <a href="#evalutatorFilter">请参见上文</a> ）。本文主要是先前讨论的重复。</p>


    <p>注意<code>EventEvaluator</code>是一个抽象类。您可以通过子类实现自己的事件评估逻辑<code>EventEvaluator</code> 。Logback-access附带了一个名为<a href="../xref/ch/qos/logback/access/boolex/JaninoEventEvaluator.html">JaninoEventEvaluator</a>的具体实现。它采用任意Java语言布尔表达式作为评估标准。我们将此类Java语言块称为“ <em>评估表达式</em> ”。评估表达式使事件过滤具有极大的灵活性。 <code>JaninoEventEvaluator</code>需要<a href="http://docs.codehaus.org/display/JANINO/Home">Janino库</a> 。请参阅安装文档的<a href="../setup.html#janino">相应部分</a> 。
    </p>

    <p>评估表达式是在解释配置文件时动态编译的。作为用户，您不必担心实际的管道问题。但是，您有责任确保Java语言表达式返回一个布尔值，即它的计算结果为true或false。</p>


    <p>评估表达式是在当前访问事件上评估的。Logback-access自动导出当前<code>AccessEvent</code>变量名下的实例<b><code>event</code></b> 。您可以通过读取与HTTP请求以及HTTP响应相关的各种数据<code>event</code>变量。请参考<a href="../xref/ch/qos/logback/access/spi/AccessEvent.html"><code>AccessEvent</code></a>确切列表的<a href="../xref/ch/qos/logback/access/spi/AccessEvent.html">类源代码</a> 。
    </p>
    
    <p>下一个logback-access配置文件说明了基于<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.5">404（未找到）</a> HTTP响应代码的过滤。导致404的每个请求都将打印在控制台上。</p>
   	
<em>示例：访问评估器（logback-examples / src / main / resources / chapters / filters / accessEventEvaluator.xml）</em>
<pre class="prettyprint source">&lt;configuration>
  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" />

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">
      &lt;evaluator>
        &lt;expression>event.getStatusCode() == 404&lt;/expression>
      &lt;/evaluator>
      &lt;onMismatch>DENY&lt;/onMismatch>
    &lt;/filter></b>
   &lt;encoder>&lt;pattern>%h %l %u %t %r %s %b&lt;/pattern>&lt;/encoder>
  &lt;/appender>

  &lt;appender-ref ref="STDOUT" />
&lt;/configuration></pre>

		<p>在下一个示例中，我们仍然记录导致404错误的请求，但那些请求CSS文件的请求除外。
		</p>	


    <em>示例6.10：访问评估程序（logback-examples / src / main / resources / chapters / filters / accessEventEvaluator2.xml）</em>
    <pre class="prettyprint source">&lt;configuration>
  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" />
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter">
      &lt;evaluator name="Eval404">
        &lt;expression>
         <b>(event.getStatusCode() == 404)</b>
           <b>&amp;amp;&amp;amp;</b>  &lt;!-- ampersand characters need to be escaped -->
         <b>!(event.getRequestURI().contains(".css"))</b>
        &lt;/expression>
      &lt;/evaluator>
      &lt;onMismatch>DENY&lt;/onMismatch>
    &lt;/filter>

   &lt;encoder>&lt;pattern>%h %l %u %t %r %s %b&lt;/pattern>&lt;/encoder>
  &lt;/appender>

  &lt;appender-ref ref="STDOUT" />
&lt;/configuration>
    </pre>
	
    <script src="../templates/footer.js" type="text/javascript"></script>

  </div>


</body></html>