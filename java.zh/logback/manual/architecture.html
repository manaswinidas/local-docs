<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第二章：架构</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">

   <h1>第二章：架构</h1>

   <a href="architecture_ja.html">和訳（日语翻译）</a>

   <div class="quote">
      <p><em>所有真正的分类都是家谱。</em></p>
      <p>-查尔斯·达尔文， <em>物种起源</em></p>

      <p><em>如果不是不可能的话，任何人都很难仅通过阅读该主题来学习该主题，而不将信息应用于特定问题，从而迫使他自己思考所阅读的内容。此外，我们都最好地了解自己发现的东西。</em>
      </p>
      <p>—DONALD KNUTH， <em>计算机编程艺术</em></p>
   </div>


   <script src="../templates/creative.js" type="text/javascript"></script>

    <h2>Logback的架构</h2>

    <p>Logback的基本体系结构足够通用，可以应用在不同的情况下。目前，logback分为三个模块：logback-core，logback-classic和logback-access。
    </p>

    <p><em>核心</em>模块为其他两个模块奠定了基础。<em>经典</em>模块扩展了<em>核心</em> 。经典模块对应于log4j的显着改进版本。经典的Logback原生实现了<a href="http://www.slf4j.org">SLF4J API，</a>因此您可以轻松地在logback和JDK 1.4中引入的其他日志系统（例如log4j或java.util.logging（JUL））之间来回切换。第三个模块称为<em>访问，</em>与Servlet容器集成在一起，以提供HTTP访问日志功能。单独的文档涵盖了<a href="../access.html">访问模块文档</a> 。
    </p>

    <p>在本文档的其余部分，我们将编写“ logback”来引用经典的logback模块。
    </p>
    
		<h2>记录器，附加器和布局</h2>
		
		<p>Logback建立在三个主要类上： <code>Logger</code> ， <code>Appender</code>和<code>Layout</code> 。这三种类型的组件一起工作，以使开发人员能够根据消息类型和级别记录消息，并在运行时控制这些消息的格式和报告位置。
		</p>

		<p>的<code>Logger</code> class是logback-classic模块的一部分。另一方面， <code>Appender</code>和<code>Layout</code>接口是logback-core的一部分。作为通用模块，logback-core没有记录器的概念。
		</p>
    
    <h3 class="doAnchor" name="LoggerContext">记录器上下文</h3>

		<p>与纯日志记录相比，任何日志记录API的首要优势<code>System.out.println</code>它具有禁用某些日志语句而允许其他语句不受阻碍地打印的能力。此功能假定根据某些开发人员选择的标准对日志记录空间（即所有可能的日志记录语句的空间）进行了分类。在经典的logback中，此分类是记录器的固有部分。每个记录器都附加到一个<code>LoggerContext</code>它负责制造记录器，并将它们按树状排列。
		</p>
			
		<p>记录器是命名实体。它们的名称区分大小写，并且遵循分层命名规则：</p>

		<div class="definition">
			<div class="deftitle">命名层次结构</div>
			<p>如果一个记录器的名称后跟一个点，则该记录器是另一个记录器的祖先，该后跟点的名称是该子记录器名称的前缀。如果记录器与子记录器之间没有祖先，则称该记录器为子记录器的父级。
			</p>
		</div>

		<p>例如，记录器名为<code>"com.foo"</code>是名为logger的父母<code>"com.foo.Bar"</code> 。同样， <code>"java"</code>是...的父母<code>"java.util"</code>和一个祖先<code>"java.util.Vector"</code> 。大多数开发人员都应该熟悉这种命名方案。
		</p>

		<p>根记录器位于记录器层次结构的顶部。这是一个例外，因为它从一开始就是每个层次结构的一部分。像每个记录器一样，可以按其名称检索它，如下所示：</p>
		
    <pre class="prettyprint source">Logger rootLogger = LoggerFactory.getLogger(<a
    href="http://www.slf4j.org/apidocs/constant-values.html#org.slf4j.Logger.ROOT_LOGGER_NAME">org.slf4j.Logger.ROOT_LOGGER_NAME</a>);</pre>

		<p>所有其他记录器也都使用static类检索<code>getLogger</code> <a href="http://www.slf4j.org/api/org/slf4j/Logger.html">org.slf4j中找到的</a><a href="http://www.slf4j.org/api/org/slf4j/Logger.html">方法。LoggerFactory</a>类。此方法将所需记录器的名称作为参数。某些基本方法<code>Logger</code>界面如下。
		</p>

		<pre class="prettyprint source">package org.slf4j; 
public interface Logger {

  // Printing methods: 
  public void trace(String message);
  public void debug(String message);
  public void info(String message); 
  public void warn(String message); 
  public void error(String message); 
}</pre>



    <h3 class="doAnchor" name="effectiveLevel">有效级别又称级别继承</h3>

		<p>可以为记录器分配级别。可能级别的集合（TRACE，DEBUG，INFO，WARN和ERROR）在<code>ch.qos.logback.classic.Level</code>类。请注意，在logback中， <code>Level</code>类是最终的，不能被子类化，因为存在一种更灵活的方法，形式为<code>Marker</code>对象。
		</p>

		<p>如果未为给定的记录器分配一个级别，则它会从其最接近的祖先那里继承一个已分配的级别。更正式地：</p>

		<div class="definition">
		
      
			<p>给定记录器<em>L</em>的有效级别等于其层次结构中的第一个非空级别，从<em>L</em>本身开始，然后在层次结构中向上扩展到根记录器。
			</p>
		</div>
	
		<p>为了确保所有记录器最终都可以继承级别，根记录器始终具有分配的级别。默认情况下，此级别是DEBUG。</p>

		<p>以下是四个示例，这些示例具有各种分配的级别值以及根据级别继承规则得出的有效（继承）级别。
		</p>

		<em>例子1</em>
		<table class="bodyTable">
			<tbody><tr>
				<th>记录仪名称</th>
				<th>分配级别</th>
				<th>有效水平</th>
			</tr>
			<tr class="alt">
				<td>根</td>
				<td>调试</td>
				<td>调试</td>
		  </tr>
			<tr>
				<td>X</td>
				<td>没有</td>
				<td>调试</td>
		  </tr>

			<tr class="alt">
				<td>XY</td>
				<td>没有</td>
				<td>调试</td>
		  </tr>
			<tr>
				<td>XYZ</td>
				<td>没有</td>
				<td>调试</td>
		  </tr>
  </tbody></table>

		<p>在上面的示例1中，仅为根记录器分配了一个级别。这个水平值， <code>DEBUG</code> ，由其他记录器继承<code>X</code> ， <code>X.Y</code>和<code>X.Y.Z</code>
		</p>

		<em>例子2</em>
		<table class="bodyTable">
			<tbody><tr>
				<th>记录仪名称</th>
				<th>分配级别</th>
				<th>有效水平</th>
			</tr>
			<tr class="alt" align="left">
				<td>根</td>
				<td>错误</td>
				<td>错误</td>
			</tr>
			<tr align="left">
				<td>X</td>
				<td>信息</td>
				<td>信息</td>
			</tr>

			<tr class="alt" align="left">
				<td>XY</td>
				<td>调试</td>
				<td>调试</td>
			</tr>
			<tr align="left">
				<td>XYZ</td>
				<td>警告</td>
				<td>警告</td>
			</tr>
		</tbody></table>

		<p>在上面的示例2中，所有记录器都有一个分配的级别值。级别继承不起作用。
		</p>

		<em>例子3</em>
		<table class="bodyTable">
			<tbody><tr>
				<th>记录仪名称</th>
				<th>分配级别</th>
				<th>有效水平</th>
			</tr>
			<tr class="alt" align="left">
				<td>根</td>
				<td>调试</td>
				<td>调试</td>
			</tr>

			<tr align="left">
				<td>X</td>
				<td>信息</td>
				<td>信息</td>
			</tr>
			<tr class="alt" align="left">
				<td>XY</td>
				<td>没有</td>
				<td>信息</td>
			</tr>
			<tr align="left">
				<td>XYZ</td>
				<td>错误</td>
				<td>错误</td>
			</tr>
		</tbody></table>

		<p>在上面的示例3中，记录器<code>root</code> ， <code>X</code>和<code>X.Y.Z</code>被分配级别<code>DEBUG</code> ， <code>INFO</code>和<code>ERROR</code>分别。记录仪<code>X.Y</code>从其父级继承其级别值<code>X</code> 。
		</p>

		<em>例子4</em>
		<table class="bodyTable">

			<tbody><tr>
				<th>记录仪名称</th>
				<th>分配级别</th>
				<th>有效水平</th>
			</tr>
			<tr class="alt" align="left">
				<td>根</td>
				<td>调试</td>
				<td>调试</td>
			</tr>

			<tr align="left">
				<td>X</td>
				<td>信息</td>
				<td>信息</td>
			</tr>
			<tr class="alt" align="left">
				<td>XY</td>
				<td>没有</td>
				<td>信息</td>
			</tr>
			<tr align="left">
				<td>XYZ</td>
				<td>没有</td>
				<td>信息</td>
			</tr>
		</tbody></table>

   
		<p>在上面的示例4中，记录器<code>root</code>和<code>X</code>并被分配级别<code>DEBUG</code>和<code>INFO</code>分别。记录器<code>X.Y</code>和<code>X.Y.Z</code>从最近的父级继承其级别值<code>X</code> ，已分配一个级别。
		</p>

    <h3 class="doAnchor" name="basic_selection">打印方法和基本选择规则</h3>

		<p>根据定义，打印方法确定记录请求的级别。例如，如果<code>L</code>是一个记录器实例，然后该语句<code>L.info("..")</code>是INFO级别的日志记录语句。</p>
		
    
    <p>如果日志记录请求的级别高于或等于记录器的有效级别，则认为该记录请求已<em>启用</em> 。否则，该请求被称为已<em>禁用</em> 。如前所述，没有分配级别的记录器将从其最近的祖先那里继承一个。该规则总结如下。
  </p>

     
		<div class="definition">
			<div class="deftitle">基本选择规则</div>

			<p>如果<em>p> = q</em> ，则向具有有效级别<em>q</em>的记录器发出级别<em>p的</em>日志请求。
			</p>
		</div>

		<p>此规则是注销的核心。假定级别按以下顺序排序： <code>TRACE < DEBUG < INFO <  WARN < ERROR</code> 。
		</p>
				
		<p>以更图形化的方式，这是选择规则的工作方式。在下表中，垂直标题显示记录请求的级别，由<em>p表示</em> ，而水平标题显示记录器的有效级别，由<em>q表示</em> 。行（级别请求）和列（有效级别）的交集是基本选择规则产生的布尔值。
		</p>
		
		<table width="80%">
      <tbody><tr> 
        <td class="lgray_bg" rowspan="2">水平<br>请求<em>p</em></td>
				<td align="center" colspan="6" style="border-top:1px solid #dddddd">有效水平<em>q</em></td>
			</tr>
			<tr align="left">
				<th style="border-bottom:1px solid #dddddd">跟踪</th>
				<th style="border-bottom:1px solid #dddddd">调试</th>
				<th style="border-bottom:1px solid #dddddd">信息</th>
				<th style="border-bottom:1px solid #dddddd">警告</th>
				<th style="border-bottom:1px solid #dddddd">错误</th>	
        <th style="border-bottom:1px solid #dddddd">关</th>    			
			</tr>
			<tr align="left">
				<th class="lgray_bg">跟踪</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>

			<tr align="left">
				<th class="lgray_bg">调试</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>
			<tr align="left">
				<th class="lgray_bg">信息</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>
			<tr align="left">
				<th class="lgray_bg">警告</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>
			<tr align="left">
				<th class="lgray_bg">错误</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>		
		</tbody></table>
		
		<p>这是基本选择规则的示例。</p>

		<pre class="prettyprint source">import ch.qos.logback.classic.Level;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
....

// get a logger instance named "com.foo". Let us further assume that the
// logger is of type  ch.qos.logback.classic.Logger so that we can
// set its level
ch.qos.logback.classic.Logger logger = 
        (ch.qos.logback.classic.Logger) LoggerFactory.getLogger("com.foo");
//set its Level to <span class="blue">INFO</span>. The setLevel() method requires a logback logger
logger.setLevel(Level. <span class="blue">INFO</span>);

Logger barlogger = LoggerFactory.getLogger("com.foo.Bar");

// This request is enabled, because <span class="green bold">WARN</span> &gt;= <span class="blue">INFO</span>
logger.<span class="green bold">warn</span>("Low fuel level.");

// This request is disabled, because <span class="green bold">DEBUG</span> &lt; <span class="blue">INFO</span>. 
logger.<span class="green bold">debug</span>("Starting search for nearest gas station.");

// The logger instance barlogger, named "com.foo.Bar", 
// will inherit its level from the logger named 
// "com.foo" Thus, the following request is enabled 
// because <span class="green bold">INFO</span> &gt;= <span class="blue">INFO</span>. 
barlogger.<span class="green bold">info</span>("Located nearest gas station.");

// This request is disabled, because <span class="green bold">DEBUG</span> &lt; <span class="blue">INFO</span>. 
barlogger.<span class="green bold">debug</span>("Exiting gas station search");</pre>

    <a name="RetrievingLoggers"></a>
		<h3>检索记录器</h3>
		<p>呼叫<code><a href="../apidocs/org/slf4j/LoggerFactory.html#getLogger(java.lang.String)">LoggerFactory.getLogger</a></code>具有相同名称的方法将始终返回对完全相同的记录器对象的引用。
		</p>

		<p>例如，在</p>
		<pre class="prettyprint source">Logger x = LoggerFactory.getLogger("wombat"); 
Logger y = LoggerFactory.getLogger("wombat");</pre>

		<p>
			<code>x</code>和<code>y</code>引用<em>完全相同</em>的记录器对象。
		</p>

		<p>因此，可以配置记录器，然后在代码中其他地方检索相同实例而无需传递引用。与亲生父母制（父母总是先于子女）的根本矛盾是，可以以任何顺序创建和配置logback记录器。特别是，“父”记录器将找到并链接到其后代，即使在其后代实例化之后也是如此。
		</p>
		<p>通常在应用程序初始化时完成对logback环境的配置。首选方法是读取配置文件。稍后将讨论这种方法。
		</p>
		<p>通过Logback，可以轻松按<em>软件组件</em>命名记录器。这可以通过实例化每个类中的记录器来实现，记录器名称等于该类的完全限定名称。这是定义记录器的有用且直接的方法。由于日志输出带有生成记录器的名称，因此这种命名策略使识别日志消息的来源变得容易。但是，这只是命名记录器的一种可能的策略，尽管很常见。Logback不限制可能的记录器集。作为开发人员，您可以随意命名记录器。
		</p>

		<p>尽管如此，在他们所在的班级之后命名记录器似乎是迄今为止已知的最佳常规策略。
		</p>

    <a name="AppendersAndLayouts"></a>
    <h3>追加者和布局</h3>

		<p>根据记录器有选择地启用或禁用日志记录请求的功能只是图片的一部分。Logback允许日志记录请求打印到多个目标。用logback说，输出目标称为追加器。当前，存在用于控制台，文件，远程套接字服务器，MySQL，PostgreSQL，Oracle和其他数据库，JMS和远程UNIX Syslog守护程序的附加程序。

      <!--It is also possible to log asynchronously. -->
		</p>

		<p>一个记录器可以附加多个附加程序。</p>

    <p>的<code><a href="../apidocs/ch/qos/logback/classic/Logger.html#addAppender(ch.qos.logback.core.Appender)">addAppender</a></code>方法将附加器添加到给定的记录器。给定记录器的每个启用的日志记录请求都将转发给该记录器中的所有附加程序以及层次结构中较高的附加程序。换句话说，追加器是从记录器层次结构中继承而来的。例如，如果将控制台附加程序添加到根记录器，则所有已启用的记录请求将至少在控制台上打印。如果另外将文件追加器添加到记录器中，例如<em>L</em> ，则对<em>L</em>和<em>L</em>的子级启用的日志记录请求将打印在文件<em>和</em>控制台上。可以覆盖此默认行为，以便通过将记录器的可加性标志设置为false，不再增加附加器累积。
		</p>

		<p>下面概述了控制追加程序可加性的规则。
		</p>
		<div class="definition">

			<h4 class="deftitle"><a name="additivity" href="#additivity"><span class="anchor"></span></a> Appender可加性</h4>

			<p>记录器<em>L</em>的日志语句的输出将在<em>L</em>和其祖先的所有追加程序。这就是术语“附加剂可加性”的含义。
			</p>

			<p>但是，如果记录器<em>L</em>的祖先（例如<em>P</em> ）的可加性标志设置为false，则<em>L</em>的输出将定向到<em>L中的</em>所有追加器及其直到<em>P</em> （包括<em>P）的</em>祖先，但不指向任何<em>L中</em>的追加器。 <em>P的</em>祖先。</p>

			<p>记录器默认将其可加性标志设置为true。
			</p>

		</div>下表显示了一个示例：<table class="bodyTable">
			<tbody><tr>
				<th>记录仪名称</th>
				<th>附加的附加者</th>
				<th>可加性标志</th>
				<th>输出目标</th>
				<th>评论</th>
			</tr>
			<tr>
				<td>根</td>
				<td>A1</td>
				<td>不适用</td>
				<td>A1</td>

				<td>由于根记录器位于记录器层次结构的顶部，因此可加性标志不适用于它。
				</td>
			</tr>
			<tr class="alt">
				<td>X</td>
				<td>A-x1，A-x2</td>
				<td>真正</td>
				<td>A1，A-x1，A-x2</td>
				<td>“ x”和根的附加词。</td>
			</tr>
			<tr>
				<td>y</td>
				<td>没有</td>
				<td>真正</td>
				<td>A1，A-x1，A-x2</td>
				<td>“ x”和根的附加词。</td>
			</tr>
			<tr class="alt">
				<td>y</td>
				<td>a-xyz1</td>
				<td>真正</td>
				<td>A1，A-x1，A-x2，A-xyz1</td>
				<td>“ xyz”，“ x”和词根的出现。</td>
			</tr>
			<tr>
				<td>安全</td>
				<td>一秒</td>
				<td class="blue"><span class="blue">假</span></td>
				<td>一秒</td>

				<td>由于将可加性标志设置为<code>false</code> 。仅使用附加器A-sec。
				</td>
			</tr>
			<tr class="alt">
				<td>安全访问</td>
				<td>没有</td>
				<td>真正</td>				
        <td>一秒</td>
				<td>仅添加“安全性”的附加项，因为“安全性”中的可加性标志设置为<code>false</code> 。
				</td>
			</tr>
		</tbody></table>


		<p>通常，用户不仅希望自定义输出目标，还希望自定义输出格式。这是通过将<em>布局</em>与附加程序相关联来实现的。布局负责根据用户的需求格式化日志记录请求，而附加程序负责将格式化后的输出发送到其目的地。的<code>PatternLayout</code> ，是标准logback分发的一部分，使用户可以根据类似于C语言的转换模式来指定输出格式<code>printf</code>功能。
		</p>

		<p>例如，带有转换模式“％-4relative [％thread]％-5level％logger {32}-％msg％n”的PatternLayout将输出类似于：</p>

		<div class="prettyprint source"><pre>176  [main] DEBUG manual.architecture.HelloWorld2 - Hello world.</pre></div>

		<p>第一个字段是自程序启动以来经过的毫秒数。第二个字段是发出日志请求的线程。第三个字段是日志请求的级别。第四个字段是与日志请求关联的记录器的名称。 “-”之后的文本是请求的消息。</p>


		<h3 class="doAnchor" name="parametrized">参数化记录</h3>

		<p>鉴于经典logback <a href="http://www.slf4j.org/api/org/slf4j/Logger.html">的记录器</a>实现了<a href="http://www.slf4j.org/api/org/slf4j/Logger.html">SLF4J的Logger接口</a> ，某些打印方法允许使用多个参数。这些打印方法变体主要用于提高性能，同时最大程度地减少对代码可读性的影响。
		</p>

		<p>对于一些记录仪<code>logger</code> ， 写作，</p>

		<pre class="prettyprint source">logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));</pre>

		<p>产生了构造message参数的成本，即转换两个整数<code>i</code>和<code>entry[i]</code>到一个字符串，并连接中间字符串。这与是否将记录消息无关。
		</p>

		<p>避免参数构造成本的一种可能方法是，将log语句包含在测试中。这是一个例子。
		</p>

		<pre class="prettyprint source">if(logger.isDebugEnabled()) { 
  logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));
}</pre>


		<p>这样，如果禁用了调试功能，则不会产生参数构造的成本<code>logger</code> 。另一方面，如果为记录器启用了DEBUG级别，则将产生两次评估该记录器是否已启用的成本：一次<code>debugEnabled</code>然后进入<code>debug</code> 。实际上，此开销微不足道，因为评估记录器所花费的时间不到实际记录请求所花费的时间的1％。</p>

		<h4>更好的选择</h4>

		<p>存在一种基于消息格式的便捷替代方法。假设<code>entry</code>是一个对象，可以这样写：</p>


		<pre class="prettyprint source">Object entry = new SomeObject(); 
logger.debug("The entry is {}.", entry);</pre>

		<p>只有在评估是否要记录日志之后，并且只有在决定是肯定的情况下，记录器实现才会格式化消息，并将“ {}”对替换为字符串值“ <code>entry</code> 。换句话说，禁用log语句后，此格式不会产生参数构造的开销。
		</p>


		<p>以下两行将产生完全相同的输出。但是，在<em>禁用</em>日志记录语句的情况下，第二个变体将比第一个变体好至少30倍。
		</p>

		<pre class="prettyprint source">logger.debug("The new entry is "+entry+".");
logger.debug("The new entry is {}.", entry);</pre>


		<p>也可以使用两个参数的变体。例如，您可以编写：</p>

		<pre class="prettyprint source">logger.debug("The new entry is {}. It replaces {}.", entry, oldEntry);</pre>

		<p>如果需要传递三个或更多参数，则<code>Object[]</code>也提供变体。例如，您可以编写：</p>


		<pre class="prettyprint source">Object[] paramArray = {newVal, below, above};
logger.debug("Value {} was inserted between {} and {}.", paramArray);</pre>

  
  <a name="UnderTheHood"></a>
  <h3>偷看之下</h3>

  <p>在介绍了基本的logback组件之后，我们现在可以描述用户调用记录器的打印方法时logback框架要采取的步骤。现在，让我们分析用户调用<code>info()</code>名为<em>com.wombat</em>的记录器的方法。
  </p>

  <h4>1。获取过滤器链决策</h4>

  <p>如果存在，则<code>TurboFilter</code>链被调用。Turbo过滤器可以设置上下文范围的阈值，或根据以下信息过滤掉某些事件，例如<code>Marker</code> ， <code>Level</code> ， <code>Logger</code> ，消息或<code>Throwable</code>与每个日志记录请求相关联。如果过滤器链的答复是<code>FilterReply.DENY</code> ，然后删除日志记录请求。如果是<code>FilterReply.NEUTRAL</code> ，然后继续下一步，即步骤2。如果答复是<code>FilterReply.ACCEPT</code> ，我们跳过下一个，直接跳到步骤3。
  </p>

  <h4>2。应用<a href="#basic_selection">基本选择规则</a></h4>

  <p>在此步骤中，logback将记录器的有效级别与请求级别进行比较。如果根据该测试禁用了日志记录请求，则logback将丢弃该请求，而无需进一步处理。否则，将继续进行下一步。
  </p>

  <h4>3。创建一个<code>LoggingEvent</code>宾语</h4>

  <p>如果请求在先前的过滤器中仍然有效，则logback将创建一个<code>ch.qos.logback.classic.LoggingEvent</code>包含请求的所有相关参数的对象，例如请求的记录器，请求级别，消息本身，可能已随请求一起传递的异常，当前时间，当前线程以及有关请求的各种数据发出日志记录请求的类和<code>MDC</code> 。请注意，其中某些字段是仅在实际需要时才进行延迟初始化的。的<code>MDC</code>用于用其他上下文信息修饰日志记录请求。MDC将在<a href="mdc.html">下一章中</a>讨论。</p>

  <h4>4。调用附加器</h4>

  <p>创建后<code>LoggingEvent</code>对象，logback将调用<code>doAppend()</code>所有适用附加程序的方法，即从记录器上下文继承的附加程序。
  </p>

  <p>logback分发附带的所有追加程序都扩展了<code>AppenderBase</code>实现<code>doAppend</code>确保线程安全的同步块中的方法。的<code>doAppend()</code>的方法<code>AppenderBase</code>如果存在任何此类过滤器，还将调用附加到附加程序的自定义过滤器。可以动态附加到任何附加程序的自定义过滤器将在<a href="filters.html">单独的章节中介绍</a> 。
  </p>

  <h4>5，格式化输出</h4>

  <p>被调用的附加程序负责格式化日志记录事件。但是，一些（但不是全部）附加程序将格式化日志记录事件的任务委托给布局。布局格式化<code>LoggingEvent</code>实例并以字符串形式返回结果。请注意，某些附加程序，例如<code>SocketAppender</code> ，请勿将日志记录事件转换为字符串，而是对其进行序列化。因此，它们没有布局，也不需要布局。
  </p>

  <h4>6。发出<code>LoggingEvent</code></h4>

  <p>日志记录事件完全格式化后，每个附加程序将其发送到其目的地。
  </p>
  
  <p>这是一个序列UML图，以显示一切工作原理。您可能要单击该图像以显示其较大版本。
  </p>

  <a href="underTheHood.html">
    <img src="images/chapters/architecture/underTheHoodSequence2_small.gif" alt="underTheHoodSequence2_small.gif">
  </a>

  
  <h3 class="doAnchor" name="performance">性能</h3>

  <p>经常提到的反对日志记录的论点之一是其计算成本。这是一个合理的问题，因为即使大小适中的应用程序也可以生成数千个日志请求。我们的大部分开发工作都花在了衡量和调整logback的性能上。与这些工作无关，用户仍应注意以下性能问题。
  </p>

  <h4>1。完全关闭日志记录时的日志记录性能</h4>

  <p>您可以通过将根记录器的级别设置为来完全关闭记录<code>Level.OFF</code> ，最高级别。完全关闭日志记录后，日志请求的成本包括方法调用和整数比较。在3.2Ghz的Pentium D机器上，此成本通常约为20纳秒。
  </p>

  <p>但是，任何方法调用都涉及参数构造的“隐藏”成本。例如，对于一些logger <em>x</em>编写，</p>
  
  <pre class="prettyprint source">x.debug("Entry number: " + i + "is " + entry[i]);</pre>

  <p>产生了构造message参数的成本，即将两个整数都转换为<code>i</code>和<code>entry[i]</code>到一个字符串，并连接中间字符串，无论是否记录该消息。
  </p>

  <p>参数构造的成本可能很高，并且取决于所涉及参数的大小。为了避免参数构造的开销，您可以利用SLF4J的参数化日志记录：</p>

  <pre class="prettyprint source">x.debug("Entry number: {} is {}", i, entry[i]);</pre>

  <p>此变体不会产生参数构造的成本。与之前的调用相比<code>debug()</code>方法，它将大大加快速度。仅当将日志记录请求发送到附加的附加程序时，消息才会被格式化。此外，格式化消息的组件得到了高度优化。
  </p>

  <p>尽管上述将日志语句置于紧密的循环中（即，经常调用的代码）是一种失败的提议，但很可能会导致性能下降。即使关闭日志记录，紧密循环的日志记录也会使您的应用程序变慢，并且即使打开了日志记录，也会生成大量的（因此无用的）输出。
  </p>

  <h4>2。启用日志记录后决定是否记录的性能。</h4>

  <p>在logback中，无需遍历记录器层次结构。记录器在创建时便知道其有效级别（即，一旦考虑了级别继承，它的级别）。如果更改了父记录器的级别，则将与所有子记录器联系以通知更改。因此，在基于有效级别接受或拒绝请求之前，记录器可以做出准即时的决定，而无需咨询其祖先。
  </p>


  <h4>3。实际记录（格式化和写入输出设备）</h4>

  <p>这是格式化日志输出并将其发送到目标目的地的成本。再次在这里，我们付出了巨大的努力，以使布局（格式器）尽快执行。追加者也是如此。当记录到本地计算机上的文件时，实际记录的典型成本约为9到12微秒。登录到远程服务器上的数据库时，最多需要几毫秒的时间。
  </p>

  <p>尽管功能丰富，但回滚的首要设计目标之一是执行速度，这是仅次于可靠性的要求。一些logback组件已被重写多次，以提高性能。
  </p>

    
  <script src="../templates/footer.js" type="text/javascript"></script>
</div>


</body></html>