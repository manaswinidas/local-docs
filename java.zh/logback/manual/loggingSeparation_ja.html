<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第9章ログの分离</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  </head>
  <body dir="ltr" onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content">	
	
    <h1>第9章ログの分离</h1>
      
    <div class="quote">
      <p><em>知识ではなくそれを学ぼうとする行为，所持することではなく得ようとする行为，それこそが最上の娯楽なのです。私は证を研究し尽くしてしまうと，谁にも见つからないようにそこから离れてしまいます。私という决して満足できない人间は，何かを成し遂げた后平和里に过ごすのではなく，すぐに违うことを始めてしまう奇人なのです。1つの国を征服したそばから，次の国に手を出そうとする，世界を征服するというのはこういうことなんだという确信があります。</em></p>

      <p>-カール・フレデリッヒ・ガウス，1808年に记されたboヨイへの手纸</p>

      <p><em>薄い绢のような洋服であってもほとんどの湿疹は隠れてしまう。</em></p>
      
      <p>-アルベール・カミュ， <em>秋</em></p>

    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>
    <script src="../templates/setup.js" type="text/javascript"></script>

    <h2>问题：ログの分离</h2>

    <p>本章では，同じWebコンテナあるいはEJBコンテナ上で稼働する复数のアプリケーションショ，ログを分离するにはどうすればいいのか検讨します。文中で“应用程序”という言葉を使う时は，WebアプリケーションかJ2EEアプリケーションのどちらかを表しています。分离されたログ环境では，それぞれのアプリケーションショ独立はlogback环境になります。log，アプリケーションのlogbackの设定は，他の设定には影响しません。技术的な言葉で言うと，それぞれのWebアプリケーションは専用の独立した<code>LoggerContext</code>を使用します。logbackに话を戻します。<code>LoggerContext</code>に生成されたロガーオブジェクトは，メモリ上に残っている间はLoggerContextに割り当てられたままです。类似の问题として，アプリケーションのロギングとコンテナのロギングの分离，というものがあります。
    </p>

    <h2 class="doAnchor" name="easy">一番简単でわかりやすい方法</h2>

    <p>ンテナが子孙优先クラスローディングをサポートしていることにしましょう。场合の场合slf4jとlogbackのjarファイルをアプリケーション自体に含めるようにすればログを分离することができます。Webアプリケーションなら<em>WEB-INF / lib</em>ディレクトリの下に置くだけで，アプリケーションショとのロギングを分离するには十分です。logbackがメモリにロードされるとき， <em>WEB-INF / classes</em>に置かれた<em>logback.xml</em>のコピーが选ばれます。
    </p>

    <p>でンテナがクラスローダーを别々にしてくれるので，Webアプリケーションは自分の<code>LoggerContext</code>に自分の<em>logback.xml</em>を选ばせることができます。</p>
    
    <p>朝饭前です。</p>

    <p>少し正确さにかけますね・ ・ ・ SLF4Jとlogbackを全てのアプリケーションからアクセスできる场所に置かなければならないこともあるでしょう。共有ライブラリがSLF4Jを使っている场合などです。じと，全てのアプリケーションは同はlogback环境を共有することになってしまいます。他にも，全てのアプリケーションから参照できる场所にSLF4Jとlogbackを放置かなければならないような状况はあるでしょう。に，それはクラスローダー分离に基づくログの分离を不可能にしてしまいます。绝望しなくてもいいですよ。まだ希望は残されています。読み进めてください。
    </p>

    <h2 class="doAnchor" name="contextSelectors">コンテキストセレクタ</h2>

    <p>logbackにはメモリにロードされている単一のインスタンスによって复数のLoggerContextを扱う仕组みがあります。次のように书いたとしましょう。</p>

    <pre class="prettyprint source">Logger logger = LoggerFactory.getLogger("foo");</pre>

    <p><code>LoggerFactory</code>の<code>getLogger()</code>メソッドは，SLF4Jのバインディングに<code>ILoggerFactory</code>を问い合わせます。SLF4Jがlogbackにバインドされているときは， <code>ILoggerFactory</code>が返すというタスクが， <a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/selector/ContextSelector.html">ContextSelector</a>に委譲されるのです。<code>ContextSelector</code>は常に<code>LoggerContext</code>のインスタンスを返すので気をつけておきましょう。ContextSelectorは， <code>ILoggerFactory</code>インターフェイスを実装しています。言い换えると，コンテキストセレクタは独自の基准に従って<code>LoggerContext</code>のインスタンスを返すことができるのです。だから<em>コンテキストセレクタ</em>という名前なのです。
    </p>

    <p>デフォルトでは，登录バインディングは<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/selector/DefaultContextSelector.html">DefaultContextSelector</a>を使います。これは，デフォルトのロガーコンコストと呼ばれる常に同じ<code>LoggerContext</code>を返します。</p>

    <p>logステムプロパティの<em>logback。ContextSelector</em>を使うと，别のコンテキストセレクタを指定することができます。コンテキストセレクタに<code>myPackage.myContextSelector</code>を指定したければ，次のように指定すればよいのです。</p>

    <p class="source">-Dlogback。ContextSelector = myPackage.myContextSelector</p>

    <p>コンテキストセレクタは， <code>ContextSelector</code>インターフェイスを実装しなければなりません。そして， <code>LoggerContext</code>タが唯一の引数とするコンストラクタが必要です。
    </p>


    <h3 class="doAnchor" name="ContextJNDISelector">上下文JNDISelector</h3>

    <p>经典回弹の配布物には<code>ContextJNDISelector</code>というコンテキストセレクタが含まれています。N JNDIを介して参照できるロガーコンコストを选択できるようにするものです。2 J2EEの仕様にあるJNDIのデータ分离に基づいています。じ，同じ环境変数を使って，アプリケーションショとに异なる値を渡すことが出来るようになります。言い换えると，単独のLoggerFactoryを全てのアプリケーションで共有している状态でも，それぞれのアプリケーションによる<code>LoggerFactory.getLogger()</code>の呼び出しに対して，独立したロガーコンテキストに割り当てられたロガーを返すようになるのです。これでログを分离することができるでしょう。
    </p>

    <p><code>ContextJNDISelector</code> log有效化するには，システムプロパティの<em>登录。ContextSelector</em>に“ JNDI”を指定します。</p>

    <p class="source">-Dlogback。ContextSelector = JNDI</p>

    <p><code>JNDI</code>という値は， <code>ch.qos.logback.classic.selector.ContextJNDISelector</code>の省略形です。</p>

    <h3 class="doAnchor" name="settingJNDIVariables">JNDI変数の设定</h3>
    
    <p>専のアプリケーションが，専用のコンテキスト名を设定しなければなりません。Webアプリケーションの场合，JNDI环境変数は<em>web.xml</em>で指定します。アプリケーション名が“ knobi”なら，web.xmlに次のような设定を追加すればよいでしょう。</p>

    <pre class="prettyprint source">&lt;env-entry&gt;
  &lt;env-entry-name&gt;logback/context-name&lt;/env-entry-name&gt;
  &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;
  &lt;env-entry-value&gt;kenobi&lt;/env-entry-value&gt;
&lt;/env-entry&gt;</pre>

    <p><code>ContextJNDISelector</code>が有效になっているとしたら，kenobiアプリケーションのロガーは“ kenobi”ロガーコンテキストに割り当てられたものになっているでしょう。ken，“ kenobi” roガーコンテキストの设定ファイルは， <em>命名规约</em>にしたがって<em>logback-kenobi.xml</em>という名前になります。スレッドコンテキストクラスローダーの<em>リソース</em>から见つけて初期化に使われます。WE，kenobiアプリケーションの<em>WEB-INF / classes</em>の下に<em>logback-kenobi.xml</em>を配置しておかなければなりません。
    </p>

    <p>“ logback / configuration-resource”というJNDI环境変数を使えば，命名规约に关わらず他の名前の设定ファイルを使うこともできます。例えば，克诺アプリケーションで命名规约に従った<em>的logback-kenobi.xml</em>ではなく<em>aFolder / my_config.xml</em>を使うとしたら，次のような设定をweb.xml中に追加することになります。</p>


   <pre class="prettyprint source">&lt;env-entry&gt;
  &lt;env-entry-name&gt;logback/configuration-resource&lt;/env-entry-name&gt;
  &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;
  &lt;env-entry-value&gt;aFolder/my_config.xml&lt;/env-entry-value&gt;
&lt;/env-entry&gt;</pre> 

    <p><em>my_config.xml</em>は， <em>WEB-INF / classes / aFolder /</em>の下に置かなければなりません。设定ファイルは，现在のスレッドのドンテキストクラスローダーによってJavaのリソースと同じように探索されるということを覚えておいてください。
    </p>
    

    <h3 class="doAnchor" name="jndiTomcat">上下文JNDISelectorを使うためのTomcatの设定</h3>

    <p>まず，logback.jar（logback-classic-1.1.2.jar logback-core-1.1.1.jar slf4j-api-1.7.6.jar）をTomcatのグローバルな共有クラスフォルダ（共享）に置きましょう。Tomcat 6.xの场合は， <em>$ TOMCAT_HOME / lib</em>の下に置いてください。
    </p>

    <p>そして， <em>$ TOMCAT_HOME / bin / catalina.sh（Windowsの场合はcatalina.bat）</em>の适切な场所で，次のようにシステムプロパティの<em>logback。ContextSelector</em>を设置してください。</p>

    <p class="source">JAVA_OPTS =“ $ JAVA_OPTS-回送。ContextSelector = JNDI“</p>


    <h3 class="doAnchor" name="hotDeploy">ホットデプロイ</h3>

    <p>アプリケーションがリサイクルされるとき，あるいは，シャットダウンするとき，利用中の<code>LoggerContext</code>はクローズしましょう。确实実にガベージコレクションされるためには欠かせません。声を大にしておすすめします。logbackの配布物には<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/selector/servlet/ContextDetachingSCL.html"><code>ContextDetachingSCL</code></a>という<code>ServletContextListener</code>が含まれています。これは古いアプリケーションのインスタンスに关连付けられている<code>ContextSelector</code>をデタッチするためだけに用意されたものです。<em>web.xml</em>に次のような设定を追加すれば有效になります。</p>

    <pre class="prettyprint source">&lt;listener&gt;
  &lt;listener-class&gt;ch.qos.logback.classic.selector.servlet.ContextDetachingSCL&lt;/listener-class&gt;
&lt;/listener&gt;</pre>

    <p>ほぼ全てのコンテナ実装は，web.xmlに记された顺番でリスナーの<code>contextInitialized()</code>メソッドを呼び出します。ですが， <code>contextDestroyed()</code>メソッドの呼び出される顺番は记载された顺番の<span class="label notice">逆顺</span>です。， <em>web.xml</em>に复数の<code>ServletContextListener</code>を宣言している场合は， <code>ContextDetachingSCL</code>を<em>先头</em>で宣言しなければならないということです。そうすれば， <code>contextDestroyed()</code>メソッドは<em>一番最后</em>に呼び出されるようになります。</p>

    <h3 class="doAnchor" name="betterPerf">パフォーマンスの改善</h3>

    <p><code>ContextJNDISelector</code>が有效になっていると，ロガーを取得するたびにJNDIの検索が行われるようになります。このことが，性能に悪影响を及ぼす可能性があります。特に静的変数ではない（インスタンス変数の）ロガーを使っている偶尔はその可能は高まります。logbackの配布物には<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/selector/servlet/LoggerContextFilter.html">LoggerContextFilter</a>というサーブレットフィルターが含まれています。NJNDIの検索にかかるコストを解消するために设计されたものです。web.xmlに次のような设定を追加すれば有效になります。
</p>

 <pre class="prettyprint source">&lt;filter&gt;
  &lt;filter-name&gt;LoggerContextFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;ch.qos.logback.classic.selector.servlet.LoggerContextFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;LoggerContextFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</pre>

   <p>HTTPリクエストを受け付けたら，まず初めに<code>LoggerContextFilter</code>はアプリケーションショ关连付けられたロガーコンテキストを取得して， <code>ThreadLocal</code>に保存します。<code>ContextJNDISelector</code>に，最初に<code>ThreadLocal</code>数が设定されているかどうかをチェックします。设定されているときは，JNDIの検索をスキップします。HTTPリクエストの处理の最后に， <code>ThreadLocal</code>変数はnullにされるので気をつけてください。<code>LoggerContextFilter</code>は使うようにすると，ロギングの性能は显着改善に。
   </p>

   <p><code>ThreadLocal</code>の変数はnullになるので，アプリケーションショリサイクルされるときや停止するときのガベージコレクションでちゃんと回收されます。</p>


   <h2 class="doAnchor" name="tamingStaticRefs">共有ライブラリ内部の静的参照を饲いならす</h2>

   <p>全てのアプリケーションショSLF4Jとlogbackを共有しているとき， <code>ContextJNDISelector</code>使うとうまくログを分离できます。<code>ContextJNDISelector</code>が有效なら，それぞれのアプリケーションの<code>LoggerFactory.getLogger()</code>メソッドの呼び出しは，アプリケーションショ关连付にロガーコンテキストテキ割り当てられたロガーを返してくれます。</p>

   <p>静的変数としてロガーを参照するのが一般的なイディオムです。</p>

   <pre class="prettyprint source">public class Foo {
  <b>static</b> Logger logger = LoggerFactory.getLogger(Foo.class);
  ...
}</pre>

    <p>静的変数でロガーを参照するのは，メモリとCPUのどちらにとっても效率的です。はのクラスの全てのインスタンスは，ただ一つの参照を使いまわせるからです。また，ロガーのインスタンスを取得するのは，クラスがメモリにロードされたときだけです。ロガー静的変数を持っているクラスがkenobiアプリケーションに含まれているなら，そのロガーのインスタンスは<code>ContextJNDISelector</code>から取得したkenobi用のロガーコンコストに割り当てられることになります。同様に，别のアプリケーションyodaに含まれているクラスのロガーインスタンスは，やはり<code>ContextJNDISelector</code>から取得したyoda用のロガーコンテキストに割り当てられることになります。
    </p>
    
    <p>で<em>kenobi</em>アプリケーションと<em>yoda</em>アプリケーションの両方で共有しているライブラリに含に<code>Mustafar</code>クラスだったら，ただし<code>Mustafar</code>クラスではインスタンス変数やローカル変数でロガーを参照していたらどうなるでしょうか。<code>LoggerFactory.getLogger()</code>メソッドは，それが呼ばれたアプリケーションションに关连付けられたロガーコンテキストに割り当てられたロガーを返してくれるでしょう。しかし， <code>Mustafar</code>クラスが静的変数でロガーを参照していたらどうなるでしょう。场合の场合，最初にそのクラスを参照をアプリケーションに关连付けられたロガーコンコストに割り当てられたロガーになってしまいます。つまり， <code>ContextJNDISelector</code>は，共有ライブラリのクラスが保持する静的変数のロガーについては，ログの分离ができないのです。このような状况は特に限定的なもので，长い间解方法が望まれつつも今に至ります。</p>


    <p>をの问题を文句のつけようもないくらいに完全に解决するには，别の観点でロガーの内部事情に切り込まなければなりません。たとえば，ロガーは実际の仕事をするロガーを内包するものとして，ロガーに対するメッに対するメージは内包するロガーに委譲するようにします。内，内包されたロガーは适切なロガーコンテキストを参照するようにするのです。ドがのアプローチは実装が大変だし，オーバーヘッドが非常に高くなってしまうでしょう。取りかかる気にはなれません。
    </p>

    <p>クラスの共有を止めて，アプリケーションの内部に移动してしまうのが，“共有クラスの静的ロガー”问题に対するお手軽な解决方法の1つであることは言うまでもありません。共有しないようにするのが不可能なら， <a href="http://logback.qos.ch/manual/appenders.html#SiftingAppender"><code>SiftingAppender</code></a>の魔法を使ってログの分离を実现するしかないでしょう。
    </p>

    <p>logbackの配布物には<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/sift/JNDIBasedContextDiscriminator.html">JNDIBasedContextDiscriminator</a>という弁别器が含まれています。これは<code>ContextJNDISelector</code>の返すロガーコンコストの名前を返すものです。<code>SiftingAppender</code>と<code>JNDIBasedContextDiscriminator</code>を组み合わせると，アプリケーションショとに别々のアペンダーインスタンスを生成することができます。
    </p>

    <pre class="prettyprint source">&lt;configuration&gt;

  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /&gt;  

  &lt;appender name="SIFT" class="ch.qos.logback.classic.sift.SiftingAppender"&gt;
    &lt;discriminator class="ch.qos.logback.classic.sift.JNDIBasedContextDiscriminator"&gt;
      &lt;defaultValue&gt;unknown&lt;/defaultValue&gt;
    &lt;/discriminator&gt;
    &lt;sift&gt;
      &lt;appender name="FILE-${contextName}" class="ch.qos.logback.core.FileAppender"&gt;
        &lt;file&gt;<b>${contextName}.log</b>&lt;/file&gt;
        &lt;encoder&gt;
          &lt;pattern&gt;%-50(%level %logger{35}) cn=%contextName - %msg%n&lt;/pattern&gt;
         &lt;/encoder&gt;
      &lt;/appender&gt;
     &lt;/sift&gt;
    &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="SIFT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>


   <p>kenobiとyodaというWebアプリケーションがあるとして，この设定ファイルを使うとyodaのログは<em>yoda.log</em>に，kenobiのログは<em>kenobi.log</em>に出力されるようになります。これは共有クラスの静的ロガーでも有效です。</p>
 
   <p><a href="http://github.com/ceki/logback-starwars">logback-starwars</a>プロジェクトを使えば，ここで说明したテクニックを実际に试してみることができます。
   </p>
 
 
   <p>上记のアプローチは，ログの分离问题を解决できますがかなり复雑です。适切な<code>ContextJNDISelector</code>の设定や，アペンダーを<code>SiftingAppender</code>でラップするこは，手伤を负った猛獣のように手が付けられません。
   </p>
 
   <p>じのロギングコンテキストは，同じ设定ファイルでも，それぞれ别の设定ファイルでも设定できることを忘れないようにしましょう。选ぶのはあなたです。するよりはンテキストごとに设定ファイルをメンテナンスするよりは，全て同じ设定ファイルを使うようにするほうが简単です。アプリケーションごとに设定ファイルをメンテナンスするのは大変ですが，柔软性はあります。</p>
 
   <p>これで终わりでしょうか？胜どきを上げて，気持ちよく我が家に帰れるのでしょうか？実はまだ続くんです。</p>
 
   <p><code>yoda</code>が<code>kenobi</code>より前に初期化されるとしましょう。<code>yoda</code>を初期化するため， <code>http://localhost:port/yoda/servlet</code>を参照して<code>YodaServlet</code>を呼び出します。このサーブレットは単に挨は単に返すだけです。ただし，ログを取得してから<code>Mustafar</code>の<code>foo()</code>メソッドを呼び出します。するだけのメソッドは単纯にログを取得するだけのものです。
   </p>
 
   <p><code>YodaServlet</code>が呼び出された后， <em>yoda.log</em>の内容は次のようになります。</p>
 
   <pre class="source">DEBUG ch.qos.starwars.yoda.YodaServlet             cn=yoda - in doGet()
DEBUG ch.qos.starwars.shared.Mustafar              cn=yoda - in foo()</pre>
 
   <p>グものログも，“ yoda”アプリケーションショ关连付けられたロガーコンテキストによるものであることが分かりますか。がーバーが停止するまで， <code>ch.qos.starwars.shared.Mustafar</code>のロガーは，“ yoda”コンテキストに割り当てられたものになります。
   </p>

   <p><code>http://localhost:port/kenobi/servlet</code>はアクセスした后の<em>kenobi.log</em>の内容は次のようになります。</p>

   <pre class="source">DEBUG ch.qos.starwars.kenobi.KenobiServlet          <b>cn=kenobi</b> - in doGet()
DEBUG ch.qos.starwars.shared.Mustafar               <b>cn=yoda</b> - in foo()</pre>

   <p>なんと， <code>ch.qos.starwars.shared.Mustafar</code>のロガーは<em>kenobi.log</em>に出力しているのに，“ yoda”コンテキストに割り当てられているロガーのままです。つまり，别のロガーコンテキストに割り当てられたロガーが同じファイル（この<em>场合</em>は<em>kenobi.log</em> ）に出力してしまうのです。それぞれのコンテキストが参照している<code>FileAppender</code>のインスタンスは，别々の<code>SiftingAppender</code>のインスタンスに内包されたもので，同じファイルにログをログを出力しています。ログの分离は思った通りに机能しているように见えますが， <span class="option">prudent</span>モードを有效化しない限り，FileAppenderは同じファイルへのログの书き込みを安全に行うことができません。そうしないとファイルの内容が壊れてしまいます。</p>
   
   <p>谨慎的ーードを有效にした设定ファイルを见てください。</p>

    <pre class="prettyprint source">&lt;configuration&gt;

  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /&gt;  

  &lt;appender name="SIFT" class="ch.qos.logback.classic.sift.SiftingAppender"&gt;
    &lt;discriminator class="ch.qos.logback.classic.sift.JNDIBasedContextDiscriminator"&gt;
      &lt;defaultValue&gt;unknown&lt;/defaultValue&gt;
    &lt;/discriminator&gt;
    &lt;sift&gt;
      &lt;appender name="FILE-${contextName}" class="ch.qos.logback.core.FileAppender"&gt;
        &lt;file&gt;${contextName}.log&lt;/file&gt;
        <b>&lt;prudent&gt;true&lt;/prudent&gt;</b>
        &lt;encoder&gt;
          &lt;pattern&gt;%-50(%level %logger{35}) cn=%contextName - %msg%n&lt;/pattern&gt;
         &lt;/encoder&gt;
      &lt;/appender&gt;
     &lt;/sift&gt;
    &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="SIFT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>


   <p>での议论を読み解いてきて，その上でlogback-starwarsプロジェクトを试してみたのなら，きっともうロギングのことが头から离れなくなっていると思います。これ以上のことは<a href="http://www.qos.ch/shop/products/professionalSupport">専门家の助け</a>を借りるしかないでしょう。</p>



    <script src="../templates/footer.js" type="text/javascript"></script>
   
    
</div></body></html>