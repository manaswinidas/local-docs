<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();">﻿</ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第4章アペンダー</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content" class="chapter">

    <h1>第4章アペンダー</h1>

    <div class="quote">

      <p><em>西部について教えたいことが多すぎるのでどこから始めたらいいのかわからないよ。1つを选べば残りの100を舍てることになってしまう。最初の1つを决めるにはどうしたいいんだろう？</em></p>
  
      <p>—伊恩<em>以东的</em>约翰·斯坦贝克</p>
    </div>


    <script src="../templates/creative.js" type="text/javascript"></script>
    <script src="../templates/setup.js" type="text/javascript"></script>
    
    <h2 class="doAnchor" name="whatIsAnAppender">アペンダーについて</h2>
    
		<p>logbackはロギングイベントを出力する仕事を，アペンダーと呼ばれるコンポーネントに任せています。<a href="http://logback.qos.ch/xref/ch/qos/logback/core/Appender.html"><code>ch.qos.logback.core.Appender</code></a>インターフェイスを実装したものがアペンダーとして利用できます。にのインターフェイスに宣言された重要なメソッドは次のとおりです。</p>
		<pre class="prettyprint source">package ch.qos.logback.core;
  
import ch.qos.logback.core.spi.ContextAware;
import ch.qos.logback.core.spi.FilterAttachable;
import ch.qos.logback.core.spi.LifeCycle;
  

public interface Appender&lt;E&gt; extends LifeCycle, ContextAware, FilterAttachable {

  public String getName();
  public void setName(String name);
  <b>void doAppend(E event);</b>
  
}</pre>

	<p><code>Appender</code>インターフェイスのほとんどのメソッドはゲッター，あるいはセッターです。<code>doAppend()</code>ッドだけは特别で，唯一の引数として型<em>E</em>のオブジェクトを取ります。<em>E</em>の実际の型は，logbackモジュールによって异なります。logback-classic <a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">mo</a>ジュールの<a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">场合</a> ， <em>E</em>は<a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">ILoggingEvent</a>になるでしょうし，logback-access <a href="http://logback.qos.ch/apidocs/ch/qos/logback/access/spi/AccessEvent.html">mo</a>ジュールでは<a href="http://logback.qos.ch/apidocs/ch/qos/logback/access/spi/AccessEvent.html">AccessEvent</a>になるでしょう。<code>doAppend()</code>メソッドは，おそらくlogbackフレームワークの中で最も重要なメソッドです。ロギングイベントを，适切な书式で，适切な出力デバイスに出力する役目があります。
  </p>

  <p>アペンダーには名前を付けられます。设定ファイル中で参照しやすいようにするためです。<code>Appender</code>インターフェイスは<code>FilterAttachable</code>インターフェイスを継承しています。つまり，アペンダーのインスタンスタンスには一つ以上のフィルターを割り当てられるのです。フィルターについては，后の章で详しく说明します。
	</p>
	
	<p>アペンダーには，ロギングイベントを出力することについて最终的な责任があります。しかし，アペンダー自体が书式化をするのではなく， <code>Layout</code>あるいは<code>Encoder</code>オブジェクトに处理を委譲します。はイアトトやエンコーダーは，ただ一つのアペンダーにだけ关连付けられ，そのアペンダーだけが参照することになります。アペンダーによっては，组み込みの，あるいは固定の书式が指定されています。にはいうアペンダーには，レイアウトもエンコーダーも不要です。たとえば， <code>SocketAppender</code>は，ロギングイベントを接続したリモートホストに転送する前に単纯にシリアライズするだけです。
	</p>
	
	
	<h2 class="doAnchor" name="AppenderBase">AppenderBase</h2>
	
	<p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/AppenderBase.html">ch.qos.logback.core.AppenderBase</a></code>は， <code>Appender</code>インターフェイスを実装した抽象クラスです。にものクラスは，どんなアペンダーにも必要な共通の机能として，名前や活性化状态やレイアウト，フィルターに対するゲッに対するゲーおよびセッターメソッメソーメソッドが実装されています。logbackの配布物に含まれるアペンダーはすべてこのクラスの派生クラスです。<code>AppenderBase</code>は抽象クラスですが， <code>Append</code>インターフェイスの<code>doAppend()</code>メソッドを実装しています。<code>AppenderBase</code>クラスの话は，実际にソースコードの抜粋を见ながら进めるのが一番わかりやすいと思います。
	</p>
	
<pre class="prettyprint source">public synchronized void doAppend(E eventObject) {

  // prevent re-entry.
  if (guard) {
    return;
  }

  try {
    guard = true;

    if (!this.started) {
      if (statusRepeatCount++ &lt; ALLOWED_REPEATS) {
        addStatus(new WarnStatus(
            "Attempted to append to non started appender [" + name + "].",this));
      }
      return;
    }

    if (getFilterChainDecision(eventObject) == FilterReply.DENY) {
      return;
    }
    
    // ok, we now invoke the derived class's implementation of append
    this.append(eventObject);

  } finally {
    guard = false;
  }
}</pre>
	
	<p><code>doAppend()</code>メソッドは同步メソッドになっています。つまり，别のスレッドから同じアペンペーに安全にロギングできるのです。スレッド<em>T</em>が<code>doAppend()</code>メソッドを実行している间は， <em>T</em>だけが排他的にアペンダーにアクセスできるので，他のスレッドからの呼び出しはキューイングされます。
	</p>

  <p>同步が不适切な场合もあります。いうときのために，logbackの配布物には<a href="http://logback.qos.ch/xref/ch/qos/logback/core/AppenderBase.html"><code>AppenderBase</code></a>とよく似た<a href="http://logback.qos.ch/xref/ch/qos/logback/core/UnsynchronizedAppenderBase.html"><code>ch.qos.logback.core.UnsynchronizedAppenderBase</code></a>も含まれています。ややこしくなるので， <code>UnsynchronizedAppenderBase</code>については本章の后半で说明します。
  </p>


  <p><code>doAppend()</code>まずッドでは，まず最初にguard変数にtrueが设定されているかどうかをチェックします。真的だったら，ただちに终了します。まず，まずguard変数にtrueを设定してから次の处理に进みます。守卫変数によって， <code>doAppend()</code>メソッドを再帰的に呼び出してしまうことを防いでいるのです。あるコンポーネントが，ログを取得するために<code>append()</code>というメソッドを呼び出したとしましょう。びと，今呼び出したアペンペーと同じアペンダーを直接呼び出すことになってしまうので，无限ループした结果スタックオーバーフローが発生してしまいます。
	</p>
	
	<p>次の式では<code>started</code>フィールドにtrueが设定されているかどうかをチェックします。trueでなければ，警告メッセージを出力して<code>doAppend()</code>メソッドは终了します。これは，クローズされたアペンダーには何も书き込めなくなるということです。<code>Appender</code>オブジェクトは<code>LifeCycle</code>インターフェイスを実装しているので，つまり<code>start()</code>メソッド， <code>stop()</code>メソッド， <code>isStarted()</code>メソッドを実装しています。Joran设定フレームワークは，アペンダーの全てのプロパティを设定してから，アペンダーを开始して活性化状态をアクティブにするため<code>start()</code>メソッドを呼び出します。アペンダーにもよりますが，指定されていないプロパティがあったり，プロパティに指定した値の影响で，开始できないことがあります。たとえば， <code>FIleAppender</code>の场合ファイルを作成するかどうかは指定された切り舍てモードに依存しています。ですので， <code>File</code>オプションが指定されていたとしても，追加オプションに正しい値が指定されていなければ，正常に动作しません。开始するまでの处理顺序が明确なので，アペンダーは自身のプロパティがちゃんと设定されていることを<em>替换として</em>动作することができます。
	</p>
	
	<p>アペンダーが开始できなかったとき，あるいは，停止してしまったときは，logbackの内部状态管理システムによって警告メッセージが出力されます。何度か（ロギングを？）试みたあと，同じ内容の警告メッセージで溢れかえってしまうのを避けるため， <code>doAppend()</code>メソッドは警告メッセージを出力しないようになります。
  </p>

	<p>次の次の<code>if</code>文では割り当てられたフィルターの応答をチェックします。フィルターチェインの応答によって，ロギングイベントを拒否するか受け入れるかが决まります。フィルターチェインが何も决めなかったら，デフォルトでロギングイグントは受け入れられるようになっています。
	</p>
	
	<p>その后は，派生クラスで実装されてた<code>append()</code>メソッドを呼び出します。ドはのメソッドは，実际に适切なデバイスへロギングイベントを出力します。
	</p>
	
  <p>最后にguard変数が开放され，キューイングされた<code>doAppend()</code>メソッドの呼び出しが处理できるようになります。
  </p>

	<p>ではの说明では“プロパティ”という言葉の代わりに“オプション”という言葉を使いました。Java，JavaBeanの规约に従ったゲッターおよびセッターメソッドが用意された属性のことです。</p>
	
	<h1>logback-coreモジュール</h1>
	
	<p>logback-coreモジュールは，他のモジュールを构筑する基盘となるモジュールです。一般的に，logbac-coreジュールのコンポーネントは，ある程度の（少なくとも最小限の）カスタマイズが必要です。以降の节では，カスタマイズしないでもすぐに利用できるアペンダーを绍介していきます。
  </p>


	
	<h2 class="doAnchor" name="OutputStreamAppender">OutputStreamAppender</h2>
	
	<p><a href="http://logback.qos.ch/xref/ch/qos/logback/core/OutputStreamAppender.html"><code>OutputStreamAppender</code></a>は<code>java.io.OutputStream</code>にロギングイベントを出力します。このクラスは他のアペンダーを构筑するための基本的なサービスを提供するものです。普通なら，利用者が<code>OutputStreamAppender</code>を直接インスタンス化することはありません。<code>java.io.OutputStream</code>を文字列で表现することはできないので，设定ファイルから<code>OutputStream</code>オブジェクトを指定することはできないのです。简単に言うと，设定ファイルでは<code>OutputStreamAppender</code>を设定することはできません。しかし， <code>OutputStreamAppender</code>に设定できるプロパティが无いという意味ではありません。次のようなプロパティがあります。
	</p>
	
  <table class="bodyTable striped">
    <tbody><tr>
      <th>プロパティ名</th>
      <th>型</th>
      <th>说明</th>
    </tr>
    
    <tr>
      <td><span class="prop" name="osaEncoder">编码器</span></td>

      <td><a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a></td>

      <td><code>OutputStreamAppender</code>への出力を书式化する。エンコーダについては<a href="./05-encoders.html">别の章</a>で说明しています。
			</td>
		</tr>
	
	</tbody></table>
    
  <p><code>OutputStreamAppender</code>は<code>ConsoleAppender</code> ， <code>FileAppender</code>の基底クラスです。<code>RollingFileAppender</code>の基底クラスはFileAppenderなので，これも含めておきます。次の図は<code>OutputStreamAppender</code>とそのサブクラスの关系を図示したものです。
	</p>
	
	<img src="images/chapters/appenders/appenderClassDiagram.jpg" alt="OutputStreamAppenderとサブクラスを示すUML図">
	

	<h2 class="doAnchor" name="ConsoleAppender">ConsoleAppender</h2>
	
  <p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/ConsoleAppender.html">ConsoleAppender</a></code>は名前のとおり，ロギングイベントをコンソールに出力します。正确に言うと， <em>System.out</em>あるいは<em>System.err</em>に出力します。デフォルトではSystem.outが使われます。<code>ConsoleAppender</code>利用，利用者が指定したエンコーダーを使ってロギングイベントを书式化します。ンコーダーについては别の章で说明します。<em>System.out</em>と<em>System.err</em>の型は<code>java.io.PrintStream</code>です。ァ，いずれもバッファIO操作のための<code>OutputStreamWriter</code>にラップされているということです。
	</p>
	
	<table class="bodyTable striped">
			<tbody><tr>
			<th>プロパティ名</th>
			<th>型</th>
			<th>说明</th>
		</tr>
		<tr>
			<td><span class="prop" container="conApp">编码器</span></td>
      <td>
        <a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a>
      </td>
			<td><code>OutputStreamAppender</code>と同じです。</td>
		</tr>
		<tr>
			<td><span class="prop" container="conApp">目标</span></td>
			<td><code>String</code></td>
			<td>文字列で， <em>System.out</em>か<em>System.err</em>を指定します。デフォルトは<em>System.outに</em>です。
			</td>
		</tr>

		<tr>
			<td><span class="prop" container="conApp">与简思</span></td>
			<td><code>boolean</code></td>
			<td><span class="prop">与Jansi</span>プロパティの値にはデフォルトで<code>false</code>が设定されています。<span class="prop">与Jansi</span>プロパティに<code>true</code>を指定すると， <a href="http://jansi.fusesource.org/">Jansi</a>ライブラリが有效化され，Windowsマシン上でANSIカラーコードがサポートされるようになります。Windowsのホスト上でこのプロパティに真パティに指定する场合，クラスパス上にjansiライブラリリリjarファイルを置かなければなりません。ベ，UnixベースのOSであるLinuxやMac OS Xのターミナルは，デフォルトでANSIカラーコードをサポートしています。

      <p>Eclipse <a href="http://www.mihai-nita.net/eclipse/">控制台中的</a> Eclipse IDEから利用する偶然は， <a href="http://www.mihai-nita.net/eclipse/">ANSI</a>プラプインをインストールしてみましょう。
      </p>
			</td>
		</tr>

	</tbody></table>
	
	<p><code>ConsoleAppender</code>の设定サンプルを见てください。
	</p>



  <p class="example">例：ConsoleAppenderの设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-Console.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-Console.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('logback_Console');">Groovyで表示</span>

  <pre id="logback_Console" class="prettyprint source">&lt;configuration&gt;

  <b>&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg %n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;</b>

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

   <p><em>logback-examples</em>ディレクトリに移动して， <a href="http://logback.qos.ch/setup.html">クラスパスを设定</a>すれば，次のコマンドで上の设定ファイルを使って実行できます。</p>

   <p class="source">Java <a href="http://logback.qos.ch/xref/chapters/appenders/ConfigurationTester.html">chapters.appenders。ConfigurationTester</a> src / main / java / chapters / appenders / conf / logback-Console.xml</p>
	
	
   <h2 class="doAnchor" name="FileAppender">FileAppender</h2>
	
   <p><a href="http://logback.qos.ch/xref/ch/qos/logback/core/FileAppender.html"><code>FileAppender</code></a>は<code>OutputStreamAppender</code>の派生クラスで，ファイルにロギンギイベントを出力します。<span class="prop">文件</span>オプションで対象のファイルを指定します。既にファイルが存在するとき，ファイル内容を切り舍てるか，追加するかどうかは， <span class="prop">append</span>プロパティの値に応じて决まります。
   </p>
	
   <table class="bodyTable properties striped">
     <tbody><tr>
       <th>プロパティ名</th>
       <th>型</th>
       <th>说明</th>
     </tr>
     <tr>
       <td><span class="prop" container="fileApppender">附加</span></td>
       <td><code>boolean</code></td>
       <td>trueの场合，既存のファイルの末尾にロギングイベントを追加します。<span class="prop">追加</span>プロパティがfalseの场合，既存のファイルの内容は舍てられてしまいます。デフォルトは<span class="option">true</span>です。
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="fileApppender">编码器</span></td>
       <td>
         <a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a>
       </td>
       <td><code>OutputStreamAppender</code>と同じです。</td>
     </tr>
    
   
     <tr>
       <td><span class="prop" container="fileApppender">文件</span></td>
       <td><code>String</code></td>
       <td>书き込み先のファイル名です。ファイルが存在しない场合，新しく作成します。Windowsプラットフォームの利用者は，バックスラッシュをエスケープするの忘れがちなので注意してください。たとえば， <em>c：\ temp \ test.log</em>という文字列は意図したように解釈されません。<em>'\ t'</em>はエスケープシーケンスの<em>タブ文字{\ u0009}</em>として解釈されるでしょう。<em>c：/temp/test.log</em>と书くか， <em>c：\\ temp \\ test.log</em>のように书けばよいでしょう。デフォルト値はありません。

       <p>指定したファイルの亲ディレクトリが存在がい场合， <code>FileAppender</code>は途中の全てのディレクトリを作成します。
       </p>
       </td>
     </tr>
   

     <tr>
       <td><span class="prop" name="prudent">谨慎</span></td>
       <td><code>boolean</code></td>

       <td>prudentモードでは，指定されたファイルに安全に书き込むようになります。同じファイルを対象にした他の<code>FileAppender</code>でいるとしても，それが别のJVMで动いているとしても，ましてや别のホストで动いているとしても，です。デフォルト値は<code>false</code>です。

         <p>谨慎ーードは， <a href="./appenders.html#prudentWithRolling">多少の制限</a>はあるものの， <code>RollingFileAppender</code>と组み合わせて利用することもできます。</p>

         <p>谨慎的ーードがtrueなら， <span class="prop">append</span>プロパティも自动的にtrueになります。
         </p>

         <p>prudentモードは排他的なファイルロックを使用を。ファイルロックを使うと，ロギングイベントの出力にかかるコストがおよそ3倍程度になることが分かっています。标准的なPCで， <b>ローカル</b>のハードディスク上のファイルへ一つロギンギイベントン出力をするとき，prudentモーモフの场合はおよそ10マイクロ秒かかります。prudentモードをオンにすると，30マイクロ秒になります。言い换えると，prudentモードがオフの场合は毎秒100,000回のロギングイベントが处理できるのに対して，prudentモードがオンの场合は毎秒33,000回しか处理できなくなるということです。
         </p>

         <p>prudentモードでは，复数のJVMから同じファイルに行うIO操作を效果的にシリアライズします。JVM，JVMの数が多くなればなるほど，IO操作ごとの待ち时间が长くなります。IO操作の合计<em>时间</em>が，毎秒20回オーダーのロギング要求が处理できる程度であれば，性能への影响は无视してもよいでしょう。アプリケーションが毎秒100回以上のIO操作をするようであれば，きっと性能影响があるので<span class="prop">prudent</span>モードを使うのはやめてください。
         </p>

         <p><span class="label">ネットワークファイルロック</span>ネットワークファイルシステム上のログファイルを対象にすると非常にコストが高くなります。はットワークファイルシステム越しのファイルロックは，プロセスがすでに所有しているロックをリリースする前に再取得する，という振る舞いに强く依存していることも同じくらい重要です。したがって1つのプロセスがログファイルを占有していると，他のプロセスからはデッドロックしているように见えるので，ロックを待ち続けることになってしまいます。
         </p>
         
         <p>prudentモードは，ネットワークの速度と同じくらいの影响をOSの実装からも受けます。私たちの提供をいるとても小さいアプリケーションの<a href="https://gist.github.com/2794241">FileLockSimulator</a>を使えば，あなたの环境でprudentモードがどのように振る舞うかシミュレートできます。
         </p>


       </td>
       
     </tr>
   </tbody></table>
	
   <p><span class="label notice">即时フラッシュ</span>デフォルトでは，それぞれのロギングイベントは，最终的な出力ストリームに即时にフラッシュされます。场合，あなたのアプリケーションショアがンペーをちゃんとクローズしていない场合，ロギングイベントベ失がいようにするためのより安全な方法です。しかし，ロギング要求のスループットが重大に増加してしまう场合には， <code>Encorder</code>の<span class="prop">立即</span>冲洗<code>false</code>を指定することもできます。エンコーダー，特に<a href="./encoders.html#LayoutWrappingEncoder"><code>LayoutWrappingEncoder</code></a>については别の章で说明します。</p>

   <p><code>FileAppender</code>の设定例を见てください。</p>

   <p class="example">例：FileAppenderの设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-fileAppender.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-fileAppender.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-fileAppender');">Groovyとして表示</span>
   <pre id="logback-fileAppender" class="prettyprint source">&lt;configuration&gt;

  <b>&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;file&gt;testFile.log&lt;/file&gt;
    &lt;append&gt;true&lt;/append&gt;
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;</b>
	
  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

   <p><em>logback-examples</em>ディレクトリに移动すれば，次のコマンドで上の设定ファイルを使って実行できます。
</p>
	
   <p class="source">Java chapters.appenders。ConfigurationTester src / main / java / chapters / appenders / conf / logback-fileAppender.xml</p>
	
	
   <h3 class="doAnchor" name="uniquelyNamed">ファイル名を一意にする（タイムスタンプを使う）</h3>
   
   <p>アプリケーションの开発フェーズのズ间や，アプリケーションショ行している时间が短い（たとえば，バッチアプリプーション）场合は，アプリケーションを実行するたびに新しいログファイルを作るほうがよいるほうがよ。<code>timestamp要素</code>を使えば简単に実现できます。以下に例を示します。</p>


   <p class="example">例：タイムスタンプを使ってファイル名を一意にするFileAppenderの设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-timestamp.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-timestamp.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-timestamp');">Groovyとして表示</span>
   <pre id="logback-timestamp" class="prettyprint source">&lt;configuration&gt;

  &lt;!-- Insert the current time formatted as "yyyyMMdd'T'HHmmss" under
       the key "bySecond" into the logger context. This value will be
       available to all subsequent configuration elements. --&gt;
  <b>&lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/&gt;</b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;!-- use the previously created timestamp to create a uniquely
         named log file --&gt;
    &lt;file&gt;<b>log-${bySecond}.txt</b>&lt;/file&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%logger{35} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>


   <p>timestamp要素には， <span class="attr">键属性</span>および<span class="attr">datePattern属性</span>という2つの必须属性と， <span class="attr">timeReference属性</span>という任意属性があります。<span class="attr">键属性</span>には， <a href="./configuration.html#variableSubstitution">変数</a>と同じく，他の设定要素からタイムスタンプを参照するときの名前を指定します。<span class="attr">datePattern</span>属性には，设定ファイルを解釈した时点の日时を文字列に変换するための日付パターン文字列を指定します。日付パターン文字列に指定できるのは， <a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a>で利用できるものと同じです。<span class="attr">timeReference属性</span>には，タイムスタンプの基准时间を指定します。フォルトでは，现在の日时，つまり，设定ファイルを解析，解釈した时点の日时になります。ですが，コンテキストを生成した时间を基准时间としたほうが便利な场合もあるでしょう。いう<span class="attr">场合</span>は， <span class="attr">timeReference属性</span>に<code>"contextBirth"</code>を指定すればよいです。
   </p>

   <p>次のコマンドを実行して， <code>timestamp要素</code>がどうなるのか试してみましょう。</p>

   <p class="command">Java chapters.appenders。ConfigurationTester src / main / java / chapters / appenders / conf / logback-timestamp.xml</p>

   <p>ロガーコンテキストを生成した日时を基准时间として使う<span class="attr">场合</span> ， <span class="attr">timeReference属性</span>に“ contextBirth”を指定します。</p>


   <p class="example">例：タイムスタンプの基准时间にロガーコンコストを生成した日时を使用する（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/blogback-timestamp-contextBirth.xml">logback-examples / src / main / java / chapters / appenders / conf / blogback-timestamp-contextBirth.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-timestamp-contextBirth');">Groovyとして表示</span>   
   <pre id="logback-timestamp-contextBirth" class="prettyprint source">&lt;configuration&gt;
  &lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss" 
             <b>timeReference="contextBirth"</b>/&gt;
  ...
&lt;/configuration&gt;</pre>

   <h2 class="doAnchor" name="RollingFileAppender">RollingFileAppender</h2>
   
   <p><a href="http://logback.qos.ch/xref/ch/qos/logback/core/rolling/RollingFileAppender.html"><code>RollingFileAppender</code></a>は<code>FileAppender</code>张して，ログファイルを切り替えられるようにしたものです。たとえば， <code>RollingFileAppender</code>では， <em>log.txt</em>という名前のファイルにログを出力するようにした上で，一定の条件が満たされたら，出力先を别のファイルに変えることができます。
   </p>
     
   <p><code>RollingFileAppender</code>と连携する2つの重要なサブコンポーネントがあります。一つは<code>RollingPolicy</code>です。これはファイルを切り替えるために必要な处理を行います。<a href="./appenders.html#onRollingPolicies">详しくは后述します</a> 。もう一つは<code>TriggeringPolicy</code>です。いつ切り替えるのか决定するものです。こちらも<a href="./appenders.html#TriggeringPolicy">详しくは后述します</a> 。つまり， <code>RollingPolicy</code>を<em>什么</em>を， <code>TriggeringPolicy</code>が<em>when</em>を表しているのです。</p>
	
   <p>どんな使い方をするにしても， <code>RollingFileAppender</code>には<code>RollingPolicy</code>と<code>TriggeringPolicy</code>の両方を设定しなければなりません。<code>RollingPolicy</code>は<code>TriggeringPolicy</code>インターフェイスを実装しているので，少なくともRollingPolicyだけは明示的に设定しなければなりません。
   </p>
	
   <p><code>RollingFileAppender</code>で利用出来るプロパティは次のとおりです。</p>
	
   <table class="bodyTable striped">
     <tbody><tr>
       <th>プロパティ名</th>
       <th>型</th>
       <th>说明</th>
     </tr>
     <tr>
       <td><span class="prop" container="rfa">文件</span></td>
       <td><code>String</code></td>
       <td><code>FileAppender</code>と同じです。</td>
     </tr>	
     <tr>
       <td><span class="prop" container="rfa">附加</span></td>
       <td><code>boolean</code></td>
       <td><code>FileAppender</code>と同じです。</td>
     </tr>	
     <tr>
       <td><span class="prop" container="rfa">编码器</span></td>
       <td>
         <a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a>
       </td>
       <td><code>OutputStreamAppender</code>と同じです。</td>
     </tr>
     <tr>
       <td><span class="prop" container="rfa">滚动政策</span></td>
       <td><code>RollingPolicy</code></td>
       <td>このオプションに指定するのは， <code>RollingFileAppender</code>がファイルを切り替える际に处理を委譲するコンポーネントです。详细は后述します。
       </td>
     </tr>	
     <tr>
       <td><span class="prop" container="rfa">触发政策</span></td>
       <td><code>TriggeringPolicy</code></td>
       <td>このオプションに指定するのは， <code>RollingFileAppender</code>にファイルを切り替えるタイミングを通知するコンポーネントです。详细は后述します。
       </td>
     </tr>	
     <tr>
       <td valign="top"><span class="prop" name="prudentWithRolling">谨慎</span></td>

       <td valign="top"><code>boolean</code></td>

       <td valign="top">谨慎， <a href="./appenders.html#FixedWindowRollingPolicy"><code>FixedWindowRollingPolicy</code></a>はサポートされていません。

         <p> <a href="./appenders.html#TimeBasedRollingPolicy"><code>TimeBasedRollingPolicy</code></a>を使えば<code>RollingFileAppender</code> ruprudentモードを利用できますが，二つの制限があります。
         </p>

         <ol>
           <li>purudentモードでは，ファイル圧缩オプションをサポートしていませんし，利用することもできません。（他のJVMがログファイルを圧缩している间，书き込むことはできません）</li>
           
           <li><code>FileAppender</code>の<span class="prop">文件</span>プロパティを指定することはできません。空のままにしておかなければなりません。ではとんどのOSでは，他のプロセスが开いているファイルの名前を変えることはできません。
           </li>
           
         </ol>文件プロパティについては<code>FileAppender</code>の说明を参照してください。
       </td>
     </tr>
   </tbody></table>
	
   <h3 class="doAnchor" name="onRollingPolicies">ローリングポリシーの概要</h3>
	
   <p><a href="http://logback.qos.ch/xref/ch/qos/logback/core/rolling/RollingPolicy.html"><code>RollingPolicy</code></a>ァ，ファイルの切り替えに伴う移动や名前の変更を行います。</p>
	
   <p><code>RollingPolicy</code>インターフェイスは次のようなものです。</p>
   
   <pre class="prettyprint source">package ch.qos.logback.core.rolling;  

import ch.qos.logback.core.FileAppender;
import ch.qos.logback.core.spi.LifeCycle;

public interface RollingPolicy extends LifeCycle {

  <b>public void rollover() throws RolloverFailure;</b>
  public String getActiveFileName();
  public CompressionMode getCompressionMode();
  public void setParent(FileAppender appender);
}</pre>

   <p><code>rollover</code>メソッドによって，现在のログファイルのアーカイブ处理を行います。<code>getActiveFileName()</code>メソッドは，今まさにログを出力しているはずのログファイル名を算出するために呼び出されます。<code>getCompressionMode</code>メソッドの名前が示すとおり，RollingPolicyにはファイル圧缩モードを决める役割もあります。<code>RollingPolicy</code>から亲となるアペンダーへの参照は， <code>setParent()</code>メソッドによって设定します。
   </p>

   <!-- =================
        ================= -->

	
   <h4 class="doAnchor" name="TimeBasedRollingPolicy">时基滚动策略</h4>

   <p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/rolling/TimeBasedRollingPolicy.html">TimeBasedRollingPolicy</a></code>番一番人気のあるポリシーです。ァ，ファイル切り替えポリシーを日付や月などの日时に基いて定义するものです。
   <code>TimeBasedRollingPolicy</code>グをファイルを切り替えるタイミングを通知する役割もあります。実际に， <code>TimeBasedTriggeringPolicy</code>は<code>RollingPolicy</code>と<code>TriggeringPolicy</code>の<em>両方</em>のインターフェイスを実装しています。
   </p>

   <p><code>TimeBasedRollingPolicy</code> file，必须プロパティの<span class="prop">文件名</span> Patternと，いくつかの任意のプロパティが设定できます。
   </p>

   <table class="bodyTable striped">
     <tbody><tr>
       <th>プロパティ名</th>
       <th>型</th>
       <th>说明</th>
     </tr>
     <tr>
       <td><span class="prop" container="tbrp">fileNamePattern</span></td>
       <td><code>String</code></td>
       <td><span class="prop">fileNamePattern</span>プロパティは必须プロパティで，切り替えるときのログファイル名を指定します。指定する値には，ファイル名と<em>％d変换指示子</em>が含まれます。<em>％d変换指示子</em>には， <code>java.text.SimpleDateFormat</code>クラスで定义された日付时刻のパターン文字列を指定します。日付时刻パターンが省略された场合，パターン文字列として<em>yyyy-MM-dd</em>が使われます。<b>ファイルの切り替え周期は， <span class="prop">fileNamePattern</span>に指定された値から假设されます。</b>


         <p><code>TimeBasedRollingPolicyの親アペンダーである<code>RollingFileAppender</code>の<span class="prop">file</span>プロパティは、指定することもできるし省略することもできます。</code> <span class="prop">文件</span>プロパティにファイル名を指定した场合，ログを出力するファイルとアーカカイブファイルの场所を别々にすることができます。ログは常に<span class="prop">文件</span>プロパティで指定されたファイルに出力されます。と，有效なログファイルを常に同じ名前にしておくことができます。<span class="prop">file</span>プロパティを省略した场合，有效なログファイル名は， <span class="prop">fileNamePattern</span>プロパティに指定した値に基いて定期的に新しい名前になります。るの振る舞いを明确に说明する例を以降に示します。
         </p>

         <p>％d {}変换指示子の构成に书かれる日付と时刻のパターン文字列は，java.text。SimpleDateFormatの规约にしたがったものです。<span class="option">fileNamePattern</span>プロパティの中であれば，日付と时刻のパターン文字列の中でも外でも，スラッシュ'/'およびバックスラッシュ'\'はディレクトリの区切り文字として扱われます。
         </p>

         <p>％dトークンはいくつでも指定することができますが，ファイル切り替え周期を假设するために使われるのは最初のものだけです。他のすべてのトークンには，'aux'パラメータを指定して补助であるという印を<em>付けなければなりません</em> 。</p>
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="tbrp">maxHistory</span></td>
       <td>整型</td>
       <td><span class="prop">maxHistory</span>プロパティは，任意プロパティです。削除せずに保持しておくアーカイブファイルの最大数を指定します。Hとえば毎月切り替えるつもりでmaxHistoryに6を指定した场合，过去6ヶ月以内のアーカイブファイルは保持され，过去6ヶ月より古いファイルは削除されるでしょう。古くなったファイルだけが削除されるので，logbackが作成したディレクトリは削除されないので注意してください。
       </td>
     </tr>

     <tr>
       <td><span class="prop" container="tbrp">cleanHistoryOnStart</span></td>
       <td>布尔值</td>
       <td>
         <p>trueを指定した场合，アペンダーの开始时に古いアーカイブを削除します。デフォルトではfalseが设定されています。</p>

         <p>通常は，ファイルを切り替えるタイミングで古いアーカイブも削除されます。しかし，アプリケーションショ切り替えのタイミングが来るまで実行し続けないことがあります。ではいう短命なアプリケーションでは，古いアーカイブを削除するタイミングが来ない可能があるのです。<span class="prop">cleanHistoryOnStart</span>プロパティにtrueを指定しておけば，アペンダーの开始时に古いアーカイブを削除することができます。</p>
       </td>
     </tr>
   </tbody></table>


   <p><code>fileNamePattern</code>の値とその效果について具体例を示します。</p>

  
   
   <table class="bodyTable striped">
     <tbody><tr>
       <th>
         <span class="prop">fileNamePattern</span>
       </th>
       <th>切り替えタイミング</th>
       <th>具体例</th>
     </tr>
     <tr>
       <td class="small">
         <em>/wombat/foo.%d</em>
       </td>
       <td>毎日深夜に切り替え。<em>％d変换指示子</em>に日付时刻パターンが省略されているので，デフォルトの<em>yyyy-MM-dd</em>が指定されたことになります。はのパターン文字列の场合は，毎日切り替えることになります。
       </td>

       <td>
         <p><span class="prop">文件</span>プロパティを指定しない场合：2006年11月23日中は<em>/wombat/foo.2006-11-23</em>に出力されます。23日の24时（24日の0时）以降，24日中は<em>/wombat/foo.2006-11-24</em>に出力されます。
       </p>

         <p><span class="prop">文件</span>プロパティに<em>/wombat/foo.txt的</em>指定时间：2006年11月23日中は<em>/wombat/foo.txt</em>に出力されます。23日24时（24日0时）に<em>foo.txt</em>は<em>/wombat/foo.2006-11-23</em>に変更されます。24日中は，新しく作成された<em>/wombat/foo.txt</em>に出力されます。
       </p>

       </td>
     </tr>
     

     <tr>
       <td class="small">
         <em>/wombat/%d{yyyy/MM}/foo.txt</em>
       </td>
       <td>月初めに切り替え。</td>
       <td>
         <p><span class="prop">文件</span>プロパティを指定しない场合：2006年10月中は，/ <em>wombat</em> /2006/10/ <em>foo.txt</em>に出力されます。10月31日の24时（つまり11月1日の0时）以降，11月中は<em>/wombat/2006/11/foo.txt</em>に出力されます。
         </p>

         <p><span class="prop">file</span>プロパティに<em>/wombat/foo.txt</em>を指定した场合：出力先は常に<em>/wombat/foo.txt</em>です。2006年10月中は，/ <em>wombat/foo.txt</em>に出力されます。10月31日の24时（つまり11月1日の0时）に<em>/wombat/foo.txt</em>は<em>/wombat/2006/10/foo.txt</em>に変更されます。11月中は，新しく作成された<em>/wombat/foo.txt</em>に出力されます。11月30日の24时（つまり12月1日の0时）に<em>/wombat/foo.txt</em>は<em>/wombat/2006/11/foo.txt</em>に変更されます。
         </p>
       </td>
     </tr>
     <tr>
       <td class="small">
         <em>/wombat/foo.%d{yyyy-ww}.log</em>
       </td>
       
       <td>周初めに切り替え。周の最初の日は，ロケールに依存するので注意してください。</td>
       
       <td>前の例と同じですが，切り替えが発生するのは周の初日です。
       </td>     
     </tr>	
     <tr>
       <td class="small">
         <em>/wombat/foo%d{yyyy-MM-dd_HH}.log</em>
       </td>
       <td>毎时0分に切り替え。</td>
       <td>前の例と同じですが，切り替えが発生するのは毎时0分です。
       </td>
     </tr>
     <tr>
       <td class="small">
         <em>/wombat/foo%d{yyyy-MM-dd_HH-mm}.log</em>
       </td>
       <td>毎分0秒に切り替え。</td>
       <td>前の例と同じですが，切り替えが発生するのは毎分0秒です。

       </td>     
     </tr>


     <tr>
       <td class="small">
         <em>/ foo /％d {yyyy-MM， <b>aux</b> } /％d.log</em>
       </td>
       <td>毎日深夜に切り替え。年と月からなる名前のフォルダにアーカイブを作成する。
       </td>
       <td>の例では，最初の％トトククンは补助（ <b>aux</b> iliary）であるという印が付いています。d，日付时刻パターンの省略された二つ目の％dトークンが最初のものとして使われます。り，切り替えタイミングは日次（％dのデフォルトパターン）になり，アーカイブするフォルダ名はそのときの年と月になります。例えば，2006年11月中にアーカイブされたファイルはすべて<em>/ foo / 2006-11</em>というフォルダに置かれます。例えば<em>/foo/2006-11/2006-11-14.log</em>のようになります。
       </td>     
       
     </tr>
   </tbody></table>
   
   <p>スラッシュまたはバックスラッシュ文字はフォルダ（ディレクトリ）の区切り文字として扱われます。存在しないフォルダは必要に応じて作成されるので，别々のフォルダにログファイルを作るのは简単です。
   </p>


 	 <p><code>TimeBasedRollingPolicy</code>は， <code>FixedWindowRollingPolicy</code>のように自动ファイル圧缩をサポートしています。<span class="prop">fileNamePattern</span>オプションの値が<em>.gz</em>または<em>.zip</em>で终わっている场合，このフィーチャが有效になります。
   </p>

   <table class="bodyTable striped">
     <tbody><tr class="a">
       <th><span class="prop">fileNamePattern</span></th>
       <th>切り替えタイミング</th>
       <th>具体例</th>
     </tr>
     <tr>
       <td><em>/wombat/foo.%d.gz</em></td>
       <td>毎日深夜に切り替え。アーカイブファイルは自动的にgz圧缩する。</td>
       <td>
         <p><span class="prop">文件</span>プロパティを指定しない场合：2009年11月23日中は<em>/wombat/foo.2009-11-23</em>に出力します。23日24时（24日0时）になったら，それまでログを出力していたファイルはgz圧缩されて<em>/wombat/foo.2009-11-23.gz</em>になります。11月24日中は<em>/wombat/folder/foo.2009-11-24</em>に出力されます。
         </p>
         
         <p><span class="prop">文件</span>プロパティに<em>/wombat/foo.txt的</em>指定时间：2009年11月23中は<em>/wombat/foo.txt</em>に出力されます。23日24时（24日0时）にgz圧缩されて<em>/wombat/foo.2009-11-23.gz</em>になります。11月24日中は新しく作られた<em>/wombat/foo.txt</em>に出力されます。24日24时（25日0时）に<em>/wombat/foo.txt</em>はgz圧缩されて<em>/wombat/foo.2009-11-24.gz</em>になります。
         </p>
       </td>
     </tr>
   </tbody></table>
   
   <p><span class="prop">fileNamePattern</span>には2つの目的があります。1つは，パターン文字列を处理して，logbackに切り替えタイミングを指示することです。もう1つはアーカイブファイル名を决めることです。ーン文字列の形が违っても切り替えタイミングが同じになることがあるので気をつけてください。文字ーン文字列が<em>yyyy @ MM</em>でも<em>yyyy-MM</em>でも，切り替えタイミングは毎ングは毎月ですが，アーカイブファイル名は异なります。
   </p>

	 <p><span class="prop">文件</span>プロパティを设定すると，アクティブなログファイルの场所とアーカイブファイルの场所を别々にすることができます。ログは<span class="prop">文件</span>プロパティで指定したファイルに出力されます。名，アクティブなログファイルの名前は常に同じになるのです。ただし， <span class="prop">file</span>プロパティを省略した场合，アクティブなログファイルの名前は<span class="prop">fileNamePattern</span>に基づいたものになります。<span class="prop">文件</span>オプションを设定しなければ， <a href="http://logback.qos.ch/codes.html#renamingError">ログファイルの名前変更エラー</a>を割けられます。これは外部からログファイルを参照している间に切り替えようとすると発生するエラーです。存在するときに発生する。
   </p>
	
   <p><span class="prop">maxHistory</span>プロパティは，削除せずに保持しておくアーカイブファイルの最大数を指定します。Hとえば，切り替えタイミングが毎月グが毎， <span class="prop">maxHistory</span>に6を指定していたら，6ヶ月以内のアーカイブは保持されますが，6ヶ月を超える古いアーカイブは削除されます。古いアーカイブは削除されてしまうので注意しましょう。logbackによって作られたフォルダも必要に応じて削除されてしまいます。
   </p>

   <p>技术的な都合により，ファイルの切り替えは时间ベースではなくロギングイベントの到着ベースで行われます。例えば，2002年3月8日时点で<span class="prop">fileNamePattern</span>に<em>YYYY-MM-DD</em> （毎日切り替え）が指定されていることにしましょう。と，8日24时（9日0时）を过ぎてから最初のロギングイベントが到着した际にファイルの切り替えが行われます。しなかったロギングイベントが発生しなかった场合，たとえば0时を过ぎてから23分47秒后にロギングイベントベ生した场合，3月9日0时0分ではなく，0时23分47秒にファイルの切り替えが行われることになります。ァ，ファイル切り替えにはロギングイベントの频度に応じた遅延が伴います。どれくらいの遅延があろうとも，切り替えアルゴリズムは常に正しく动作します。したがってあらゆるロギングイベントはそれが発生した时刻に基いて适切なファイルに出力されます。
   </p>
	
   <p><code>RollingFileAppender</code>と<code>TimeBasedRollingPolicy</code>の设定例を见てください。
   </p>
	
   <p class="example">例： <code>RollingFileAppender</code>と<code>TimeBasedRollingPolicy</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-RollingTimeBased.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-RollingTimeBased.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-RollingTimeBased');">Groovyとして表示</span>
   <pre id="logback-RollingTimeBased" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
    &lt;file&gt;logFile.log&lt;/file&gt;
    <b>&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
      &lt;!-- daily rollover --&gt;
      &lt;fileNamePattern&gt;logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;

      &lt;!-- keep 30 days' worth of history --&gt;
      &lt;maxHistory&gt;30&lt;/maxHistory&gt;
    &lt;/rollingPolicy&gt;</b>

    &lt;encoder&gt;
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt; 

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

    <p>次の例はprudentモードの例です。
    </p>

   <p class="example">例：谨慎<code>RollingFileAppender</code>と<code>TimeBasedRollingPolicy</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-PrudentTimeBasedRolling.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-PrudentTimeBasedRolling.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('logback-PrudentTimeBasedRolling');">Groovyとして表示</span>
  <pre id="logback-PrudentTimeBasedRolling" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
    <b>&lt;!-- Support multiple-JVM writing to the same log file --&gt;</b>
    <b>&lt;prudent&gt;true&lt;/prudent&gt;</b>
    &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
      &lt;fileNamePattern&gt;logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
      &lt;maxHistory&gt;30&lt;/maxHistory&gt; 
    &lt;/rollingPolicy&gt;

    &lt;encoder&gt;
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt; 

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>


   <h4 class="doAnchor" name="FixedWindowRollingPolicy">FixedWindowRollingPolicy</h4>

   <p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/rolling/FixedWindowRollingPolicy.html">FixedWindowRollingPolicy</a></code>使うと，固定幅アルゴリズムに従ってファイルの名前を変更することができます。
   </p>

   <p><span class="prop">fileNamePattern</span>オプションには，アーカイブファイル名のパターンを指定します。このオプションは必须<em>で</em> ，パターン文字列中のどこかに双重トークンの<em>％i</em>を含めなければなりません。
   </p>
	
   <p><code>FixedWindowRollingPolicy</code>のプロパティは次のとおりです。
   </p>
	
   <table class="bodyTable striped">
     <tbody><tr>
       <th>プロパティ名</th>
       <th>型</th>
       <th>说明</th>
     </tr>
     <tr>
       <td><span class="prop" container="fwrp">minIndex</span></td>
       <td><code>int</code></td>
       <td>
         <p>このオプションには固定幅の添字の下限値を指定します。
         </p>
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="fwrp">maxIndex</span></td>
       <td><code>int</code></td>
       <td>
         <p>このオプションには固定幅の添字の上限値を指定します。
         </p>
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="fwrp">fileNamePattern</span></td>
       <td><code>String</code></td>
       <td>
         <p>このオプションには<code>FixedWindowRollingPolicy</code>がログファイルをアーカイブするファイル名のパターン文字列を指定します。パターン文字列には<em>％i</em>を含めなければなりません。これは，现在の幅に追加する位置の添字になります。
         </p>
         <p>例えば，パターン文字列が<em>MyLogFile％i.log</em> ， <em>minIndex</em>が1， <em>maxIndex</em>が3だとしたら，アーカイブファイル名は<em>MyLogFile1.log</em> ， <em>MyLogFile2.log</em> ， <em>MyLogFile3.log</em>のいずれかになります。
         </p>
         <p>自动ファイル圧缩を有效にする场合もこのプロパティで指定することになります。例えば， <span class="prop">fileNamePattern</span>に<em>MyLogFile％i.log.zip</em>が指定されている场合，アーカイブされたファイルは<em>zip形式</em>で圧缩されることになります。<em>gz形式</em>も有效です。
         </p>
       </td>
     </tr>			
   </tbody></table>
   
   <p>固定幅切り替えポリシーでは，指定した窓の大きさによってはたくさんのファイル名を変更しなければなりません。ですので，あまりに大きな値を指定することは极力避けるようにしてください。利用者が指定した窓が大きすぎる场合，现在の実装は窓の大きさを自动的に20にしてします。
   </p>

   <p>固定幅切り替えポリシーの具体的な例を见ていきましょう。それぞれ， <span class="prop">minIndex</span>が<em>1</em> ， <span class="prop">maxIndex</span>が<em>3</em> ， <span class="prop">fileNamePattern</span>が<em>foo％i.log</em> ， <span class="prop">file</span>プロパティが<em>foo.log</em>となっていることを想定しています。；</p>
	
   <table class="bodyTable striped">
     <tbody><tr>
       <th>切り替え回数</th>
       <th>现在の出力対象</th>
       <th>アーカイブファイル</th>
       <th>说明</th>
     </tr>
		<tr>
			<td>0</td>
			<td>foo.log</td>
			<td>--</td>
			<td>まだ切り替えは発生していません。logbackは最初に指定されたファイルにログをログを出力しています。
			</td>
     </tr>		
     <tr>
       <td>1个</td>
       <td>foo.log</td>
       <td>foo1.log</td>
       <td>切り替えが発生しました。<em>foo.log</em>が<em>foo1.log</em>という名前に変更されました。新しく<em>foo.log</em>が作成され，现在の出力対象になりました。
       </td>
     </tr>
     <tr>
       <td>2</td>
       <td>foo.log</td>
       <td>foo1.log，foo2.log</td>
       <td>切り替えが発生しました。<em>foo1.log</em>が<em>foo2.log</em>という名前に変更され， <em>foo.log</em>が<em>foo1.log</em>という名前に変更されました。新しく<em>foo.log</em>が作成され，现在の出力対象になりました。
       </td>
     </tr>
     <tr>
       <td>3</td>
       <td>foo.log</td>
       <td>foo1.log，foo2.log，foo3.log</td>
       <td>切り替えが発生しました。<em>foo2.log</em>が<em>foo3.log</em>という名前に変更され， <em>foo1.log</em>が<em>foo2.log</em>という名前に変更され， <em>foo.log</em>が<em>foo1.log</em>という名前に変更されました。新しく<em>foo.log</em>が作成され，现在の出力対象になりました。

       </td>
     </tr>
     <tr>
       <td>4</td>
       <td>foo.log</td>
       <td>foo1.log，foo2.log，foo3.log</td>
       <td>以降の切り替えでは，最初にアーカイブ<em>foo3.log</em>を削除します。その他のファイルは，前のステップと同じように，添字を増やした名前に変更されます。以降は，常に1つのログファイル，3つのアーカイブファイルが存在することになります。
       </td>
     </tr>
   </tbody></table>
	
   <p><code>RollingFileAppender</code>と<code>FixedWindowRollingPolicy</code>の设定例を次に示します。<span class="prop">fileNamePattern</span>オプションに同じ情报が含まれているとはいえ， <span class="prop">File</span>オプションは必须なので注意してください。
   </p>
	
   <p class="example">例： <code>RollingFileAppender</code>と<code>FixedWindowRollingPolicy</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-RollingFixedWindow.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-RollingFixedWindow.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-RollingFixedWindow');">Groovyとして表示</span>
   <pre id="logback-RollingFixedWindow" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
    <b>&lt;file&gt;test.log&lt;/file&gt;</b>

    <b>&lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt;
      &lt;fileNamePattern&gt;tests.%i.log.zip&lt;/fileNamePattern&gt;
      &lt;minIndex&gt;1&lt;/minIndex&gt;
      &lt;maxIndex&gt;3&lt;/maxIndex&gt;
    &lt;/rollingPolicy&gt;</b>

    &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt;
      &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt;
    &lt;/triggeringPolicy&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
	
  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>


    <h3 class="doAnchor" name="SizeAndTimeBasedFNATP">日时<b>と</b>サイズに基づいたログファイルのアーカイブ</h3>

    <p>基本的には日付でファイァイルをアーカイブしたいけど，后続处理ツールに指定できるログファイルにサイズ制限があるので，ログファイルのサイズも制限したいことがあるでしょう。そんなときは，logbackの配布物に含まれる<code>TimeBasedRollingPolicy</code>のサブコンポーネントである<code>SizeAndTimeBasedFNATP</code>を使うとよいでしょう。FNATPは文件命名和触发策略の略です。</p>

    <p>日时とサイズに基づいてログファイルをアーカイブする设定ファイルの例を示します。</p>
    
  <p class="example">例： <code>SizeAndTimeBasedFNATP</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-sizeAndTime.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-sizeAndTime.xml</a> ）</p>

  <span class="asGroovy" onclick="return asGroovy('logback-sizeAndTime');">Groovyとして表示</span>
  <pre id="logback-sizeAndTime" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="ROLLING" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
    &lt;file&gt;mylog.txt&lt;/file&gt;
    &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
      &lt;!-- rollover daily --&gt;
      &lt;fileNamePattern&gt;<b>mylog-%d{yyyy-MM-dd}.<span class="big">%i</span>.txt</b>&lt;/fileNamePattern&gt;
      <b>&lt;timeBasedFileNamingAndTriggeringPolicy</b>
            <b>class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;</b>
        &lt;!-- or whenever the file size reaches 100MB --&gt;
        <b>&lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;</b>
      <b>&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</b>
    &lt;/rollingPolicy&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;


  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="ROLLING" /&gt;
  &lt;/root&gt;

&lt;/configuration&gt;</pre>
    
    <p>“％d”トークンに加えて，“％i”トークンにとに気づきましたか。次の切り替えタイミンミのグがくるまで间に，现在のログファイルが<span class="prop">maxFileSize</span>に指定したサイズを越えたら，添字を加算してアーカイブします。添字は0から始まります。</p>

    <p>日时とサイズに基づいたログファイルのアーカイブをしていても，古いアーカイブを削除することができます。残しておくアーカイブの数を<span class="prop">maxHistory</span>プロパティで指定しなければなりません。アプリケーションが停止してその后再起动した场合でも，正しい添字のファイルにログを出力します。
    </p>

		<h2>
      <a name="TriggeringPolicy" href="./appenders.html#TriggeringPolicy">トリガーポリシーについて</a>
    </h2>
		
		<p><code>RollingFileAppender</code>にファイルを切り替えるタイミングを通知するのが<a href="http://logback.qos.ch/xref/ch/qos/logback/core/rolling/TriggeringPolicy.html"><code>TriggeringPolicy</code></a>です。</p>
		
		<p><code>TriggeringPolicy</code>インターフェイスには1つだけメソッドが宣言されています。</p>
	
    <pre class="prettyprint source">package ch.qos.logback.core.rolling;

import java.io.File;
import ch.qos.logback.core.spi.LifeCycle;

public interface TriggeringPolicy&lt;E&gt; extends LifeCycle {

  <b>public boolean isTriggeringEvent(final File activeFile, final &lt;E&gt; event);</b>
}</pre>

		<p><code>isTriggeringEvent()</code>メソッドには，二つの引数があります。1つは现在有效なファイル，もう1つは处理中のロギングイベントです。てのパラメータに基タにいて，ファイルの切り替えをするべきかどうかを判断します。
		</p>

    <p>最もよく使われているトリガーポリシーは<code>TimeBasedRollingPolicy</code>です。ですローリングポリシーの别名です。他のローリングポリシーの说明と合わせて<a href="./appenders.html#TimeBasedRollingPolicy">说明</a>したとおりです。</p>
		
		<h4><a name="SizeBasedTriggeringPolicy" href="./appenders.html#SizeBasedTriggeringPolicy">基于大小的触发政策</a></h4>

		<p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/rolling/SizeBasedTriggeringPolicy.html">SizeBasedTriggeringPolicy</a></code>な现在有效なファイルのサイズを判断します。指定したサイズより大きくなった场合， <code>RollingFileAppender</code>の现在のファイルを切り替えるよう通知します。
		</p>

		<p><code>SizeBasedTriggeringPolicy</code> <span class="prop">FilemaxFileSize</span>パラメータだけを受け付けます。ですフォルトは10MBです。</p>

		<p><span class="prop">maxFileSize</span>オプションはバイト，キロバイト，メガバイト，ギガバイト単位で指定できます。それぞれ<em>KB</em> ， <em>MB</em> ， <em>GB</em>という接尾辞を使うこともできます。たとえば<em>，5000000</em> <em><em><em>5000KB，5MB，2GB</em></em></em>はすべて正しい値です。最初の三つは同じ値になります。
		</p>

		<p>ファイルサイズが5MBを越えたら切り替える场合の<code>RollingFileAppender</code>と<code>SizeBasedTriggeringPolicy</code>の设定例を见てみましょう。
		</p>

    <p class="example">例： <code>RollingFileAppender</code>と<code>SizeBasedTriggeringPolicy</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-RollingSizeBased.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-RollingSizeBased.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('logback-RollingSizeBased');">Groovyとして表示</span>
    <pre id="logback-RollingSizeBased" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
    &lt;file&gt;test.log&lt;/file&gt;
    &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt;
      &lt;fileNamePattern&gt;test.%i.log.zip&lt;/fileNamePattern&gt;
      &lt;minIndex&gt;1&lt;/minIndex&gt;
      &lt;maxIndex&gt;3&lt;/maxIndex&gt;
    &lt;/rollingPolicy&gt;

    <b>&lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt;
      &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt;
    &lt;/triggeringPolicy&gt;</b>
    &lt;encoder&gt;
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
	
  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

	
    <!-- XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx -->
		<a name="Classic"></a>
		<h2>logback-classicモジュール</h2>
				
    
		<p>ロギングイベントはlogback-coremoジュールの中ではジェネリック型ですが，logback-classicでは<code>ILoggingEvent</code>のインスタンスになります。经典的logbackでは， <code>ILoggingEvent</code>のインスタンスの具体的なパイプライン处理を行います。

    </p>

		<h3 class="doAnchor" name="SocketAppender">SocketAppenderとSSLSocketAppender</h3>
		
		<p>は绍介してきたアペンダーは，ローカルリソースだけにログを出力するものでした。対照的に， <code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/SocketAppender.html">SocketAppender</a></code>はログをシリアライズした<code>ILoggingEvent</code>のインスタンスとしてリモートホストに送信するものとして设计されています。<code>SocketAppender</code>ギ，ロギングイベントを平文で送信します。<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/SSLSocketAppender.html">SSLSocketAppender</a></code>暗，暗号化された安全なチャネルを介してロギングイベントを送信します。</p>

    <p>リアライズされたロギングイベントの実际の型は， <code>ILoggingEvent</code>インターフェイスを実装した<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/spi/LoggingEventVO.html"><code>LoggingEventVO</code></a>です。ロギングイベントがどれだけ心配なのはわかりますが，リモートロギングが盗聴されることはありません。★受信したロギングイベントをデシリアライズしたら，ローカルで生成されたものとまったく同じように扱われます。それぞれのマシンで実行されている<code>SocketAppender</code>のインスタンスの出力书式がどれも同じになっていれば，中央ログサーバに直接ロギング出力を送りつけることができます。<code>SocketAppender</code>に割り当てられたレイアウトをリモートサーバに送ることはありません。シリアライズされたイベントを送信するからです。<code>SocketAppender</code>は<em>传输控制协议（TCP）</em>レイヤーで动作します。TCPレイヤーは，信頼性，顺序性，フロー制御を备えた端末间のオクテットストリームによる通信を提供するものです。から，リモートサーバがネットワークから到达可能的场合，ロギングイベントは确実に到着します。リモートサーバーがダウンがダウいして到达不能である场合，ロギングイベントは単纯に破弃されてしまいます。リモートサーバが复旧した场合，ロギングイベントの送信は透过的に再开されます。透过の透过的な再接続は，定期的にサーバへの接続を试みるコネクタースレッドによって行われます。
		</p>
		
		<p>ロギングイベントはネイティブのTCP実装によって自动的にバッファへ保存されます。通信，リモートサーバへの通信速度がクライアントでロギングイグントを生成する速度より遅かったとしても，クライアントアプリケーションショ通信速度に影响を受けることはない，ということです。通信速度がロギングイベントを生成する速度よりも遅ければ，クライアントは通信速度に合わせた速度でしか处理を进めることができません。极端な具体例ですが，リモートサーバへのバへットワーク接続がダウンしている场合，最终的にクライアントはブロックしてしまいます。、、、
		</p>
		
		<p>あらゆるロガーに<code>SocketAppender</code>が割り当てられていなかったとしても，コネクタースレッドが生きているかぎりGCに回收されることはありません。はクタースレッドが死ぬのは，リモートサーバへの接続がダウンしたときだけです。にのGCに伴う问题を回避するには， <code>SocketAppender</code>を明示的にクローズしなければなりません。长期稼働するアプリケーションでは，非常に多くの<code>SocketAppender</code>のインスタンスを生成，破弃することになるので，このGCに伴う问题には注意してください。ほとんどのアプリケーションショ无视してもたいして问题になりません。<code>SocketAppender</code>るストしているJVMが， <code>SocketAppender</code>をクローズする前に终了してしまうとしたら，それが明示的に行われるとしても，あるいは，GCの后であろうとも，通信用のパイプの中に残っていた未送信のデータは失われてしまうでしょう。これはWindowsベースのシステムに共通する问题です。ならータの消失を避けるには，普通ならアプリケーションを终するする前に<code>SocketAppender</code>の<code>close()</code>メソッドを明示的に呼び出すか， <code>LoggerContext</code>の<code>stop()</code>メソッドを介して呼び出すようにするだけで十分です。
		</p>
		
		<p><span class="prop">远程主机</span>プロパティと<span class="prop">port</span>プロパティで指定します。
		<code>SocketAppender</code>のプロパティを表にまとめました。<code>SSLSocketAppender</code>パティが多くのプロパティが追加されています。详しくは<a href="./usingSSL.html">SSLを使用する</a>の章を参照してください。</p>

    <table class="bodyTable striped">
      <tbody><tr>
			<th>プロパティ名</th>
			<th>型</th>
			<th>说明</th>
      </tr>
      <tr>
        <td><span class="prop" container="socket">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>
          <p><span class="prop" container="socket">includeCallerDataオプション</span>には真伪値を指定します。trueの场合，リモートホストでログの送信者情报が利用できるようになります。デフォルトでは発信者情报をサーバに送信しません。
          </p>
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="socket">港口</span></td>
        <td><code>int</code></td>
        <td>
          <p>リモートサーバのポート番号です。
          </p>
        </td>
      </tr>	
      <tr>
        <td><span class="prop" container="socket">重新连接延迟</span></td>
        <td><code><a href="http://logback.qos.ch/apidocs/ch/qos/logback/core/util/Duration.html">Duration</a></code></td>
        <td><span class="prop">reconnectionDelay</span>オプションには，待ち时间を表す文字列を指定します。たとえば，“ 10 seconds”と指定した场合，サーバへの接続が失败するたびに10秒间待ってから，再接続を试みます。秒のオプションのデフォルト値は30秒​​。0を指定すると再接続机能が无效になります。続がーバへの接続が成功した场合，コネクタースレッドは存在しないはずなので注意してください。
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="socket">queueSize</span></td>
        <td><code>int</code></td>
        <td>
          <p><span class="prop">queueSize</span>プロパティには，受信侧に配信するために积累えておくロギングイベントの数を，非负の整体で指定します。ズがーサイズが0の场合，イベントの配信は同时になります。ズがーサイズが0より大きい场合，キューに空きがあれば新しいロギングイベントはキューはキュ入れられるようになります。キューの长さを0其他にすると，一时的なネットワークの遅延によって発生する配信の遅れを排除することができるので，性能が向上します。
          </p>

          <p><span class="prop">eventDelayLimit</span>プロパティのことも参照してください。</p>

        </td>
      </tr>	

      <tr>
        <td><span class="prop" container="socket">eventDelayLimit</span></td>
        <td><code><a href="http://logback.qos.ch/apidocs/ch/qos/logback/core/util/Duration.html">Duration</a></code></td>
        <td><span class="prop">eventDelayLimit</span>オプションには，“ 10秒”のような待ち时间を表す文字列を指定します。ロ，ローカルキューが満杯になった际，蓄积されたロギングイベントを削除する前に待机する时间を表しています。リモートホストがロギングイグンをンを受信するのが継続的に遅い场合に発生する可能があります。値はのオプションのデフォルト値は100ミリ秒です。
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="socket">远程主机</span></td>
        <td><code>String</code></td>
        <td>リモートサーバのホスト名です。
        </td>
      </tr>		
      <tr>
        <td><span class="prop" container="socket">ssl</span></td>
        <td><code>SSLConfiguration</code></td>
        <td><code>SSLSocketAppender</code>だけがサポートするプロパティです。アペンダーから利用されるSSL设定を指定します。详しくは<a href="./usingSSL.html">SSLを使用する</a>を参照してください。</td>
      </tr>
    </tbody></table>
    
    <h4>サーバ用のオプション</h4>
    <p>标准的なlogback-classicの配布物には， <code>SocketAppender</code>あるいは<code>SSLSocketAppender</code>からロギングイベントを受け取るための2つのサーバ用オプションが含まれています。</p>
    <ul>
      <li><code>ServerSocketReceiver</code>とそのSSL対応版の<code>SSLServerSocketReceiver</code>は，リーートホストのソケットアペンダーからロギングイベントを受け取るための受信用コンポーネントです。<em>logback.xml</em>で设置できるようになっています。设置内容については使用例と<a href="./receivers.html">レシーバーの章</a>を参照してください。
      </li>
      <li><code>SimpleSocketServer</code>とそのSSL対応版の<code>SimpleSSLSocketServer</code> Java，スタンドアローンJavaアプリケーションショ简単に使うために用意されたものです。UnixシェルのCUI（コマンドラインインターフェイス）で设定できるようになっています。をのアペンダーを设定したアプリケーションは，単纯に<code>SocketAppender</code>または<code>SSLSocketAppender</code>のクライアントからロギングイベントが送信されてくるのを待ちます。受信したロギングイベントは，自身の设定に従ってロギングされます。使用例は次のとおりです。
      </li>
    </ul>
    
    <h4><a name="simpleSocketServer"></a> SimpleSocketServerの使い方</h4>
    <p><code>SimpleSocketServer</code>アプリケーションはコマンドライン引数を2つ取ります。<em>port</em>と<em>configFile</em>です。<em>port</em>には待ち受けるポート番号を， <em>configFile</em>にはXML形式の设定ファイルを指定します。
    </p>
	
    <p><em>logback-examples</em>ディレクトリに移动してから，次のコマンドを実行すると<code>SimpleSocketServer</code>を开始できます。</p>
    
    <p class="source">java ch.qos.logback.classic.net。SimpleSocketServer 6000 \ src / main / java / chapters / appenders / socket / server1.xml</p>

    <p>待ち受けるポート番号として6000，设定ファイルとして<em>server1.xml</em>を指定しています。设定の设定ファイルでは，ルートロガーに<code>ConsoleAppender</code>と<code>RollingFileAppender</code>を割り当てています。<code>SimpleSocketServer</code>开始すれば，复数のロギングクライアントから<code>SocketAppender</code>を使ってロギングイベントを送信できるようになります。ではのマニュアルでは2つのクライアントを用意しています。<code>chapters.appenders.SocketClient1</code>と<code>chapters.appenders.SocketClient2</code>です。ンソールで利用者が何かキー入力するのを待つようになっています。利用者がキー入力したテキストはログレベルがDEBUGのロギングイベントに包まれてリモートサーバに送信されます。それぞれのクライアントの<code>SocketAppender</code>の设定は异なります。<code>SocketClient1</code>をログラムでアペンダーを设定しているのに対して， <code>SocketClient2</code>には设定ファイルが必要です。
    </p>
	
    <p><code>SimpleSocketServer</code>るならローカルホスト上で実行しているなら，次のようなコマンドで接続することができます。</p>
	
    <p class="source">Java chapters.appenders.socket。SocketClient1本地主机6000</p>

		<p>クライアントのコンソールに入力したテキストは，前の手顺で开始した<code>SimpleSocketServer</code>のコンソールに1行ずつ出力されます。<code>SimpleSocketServer</code>を再次停止してから再び开始しても，クライアント侧では何もなかったかのように透过的に新しいサーバインスタンスに再接続します。切断，切断中に発生したロギングイベンは単ントは単纯に破弃されてしまい，取り返すことができません。
		</p>

		<p><code>SocketClient1</code>と违って， <code>SocketClient2</code>でアプリケーション自体でlogbackを设定していません。XML形式の设定ファイルが必要です。设定ファイル<em>client1.xml</em>の内容は次のとおりです。<code>SocketAppender</code>を定义して，ルートロガーに割に当てています。
		</p>

		<p class="example">例：SocketAppenderの设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/socket/client1.xml">logback-examples / src / main / java / chapters / appenders / socket / client1.xml</a> ）</p>
    <span class="asGroovy" onclick="return asGroovy('client1');">Groovyとして表示</span>
<pre id="client1" class="prettyprint source">&lt;configuration&gt;
	  
  &lt;appender name="SOCKET" class="ch.qos.logback.classic.net.SocketAppender"&gt;
    &lt;remoteHost&gt;${host}&lt;/remoteHost&gt;
    &lt;port&gt;${port}&lt;/port&gt;
    &lt;reconnectionDelay&gt;10000&lt;/reconnectionDelay&gt;
    &lt;includeCallerData&gt;${includeCallerData}&lt;/includeCallerData&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="SOCKET" /&gt;
  &lt;/root&gt;  

&lt;/configuration&gt;</pre>
	
<p>上记の设定スクリプトでは， <span class="prop">remoteHost</span> ， <span class="prop">port</span> ， <span class="prop">includeCallerData</span>の値が変数で指定されているのがわかりますか。これらの変数の値は，システムプロパティとして指定することができます。</p>
	
    <p class="source">java -Dhost = localhost -Dport = 6000 -DincludeCallerData = false \ chapters.appenders.socket。SocketClient2 src / main / java / chapters / appenders / socket / client1.xml</p>

		<p>このコマンドを実行すると，前の<code>SocketClient1</code>と同じ设定になります。
		</p>
		
		<p>ロギングイベントのシリアライズは非侵入型であることをもう一度アピールさせていただきます。はリアライズされたロギンギイベントは，普通のロギングイベントと全く同じ情报を持っています。自，自分が生成したロギングイベントであるかのように扱うことができるのです。には，デフォルトではシリアライズされたロズされたンギイベントには送信者情报が含まれていません。この点を说明する例を示します。まず<code>SimpleSocketServer</code>を准备しましょう。</p>

    <p class="source">java ch.qos.logback.classic.net。SimpleSocketServer 6000 \ src / main / java / chapters / appenders / socket / server2.xml</p>

   <p>设定ファイル<em>server2.xml</em>では<code>ConsoleAppender</code>を定义しています。レイアウトには，他の情报と合わせて送信元のファイル名と行番号を指定しています。前のように设定ファイル<em>client1.xml</em>を引数として<code>SocketClient2</code>を起动します。グにはーバ横向のコンソールに出力されたログには，送信元のファイル名と行番号の代わりに2つのクエスチョンマークが出力されているはずです。</p>

    <p class="source">2006-11-06 17：37：30,968调试[Thread-0] [？：？]章.appenders.socket。SocketClient2-嗨</p>

		<p>この出力は简単に変更できます。<code>SocketAppender</code>が送信者情报を含めるように设定するには， <span class="prop">includeCallerDataオプションに真を指定するだけです。</span>次のように実行すればよいです。</p>

   <pre class="source">java -Dhost=localhost -Dport=6000 -DincludeCallerData=true \
  chapters.appenders.socket.SocketClient2 src/main/java/chapters/appenders/socket/client1.xml</pre>

		<p>はリアライズされたロギングイベントは，ローカルで生成されたロギングイベントと同じように扱うことができます。で，追加で何か处理するためにさらに别のリモートサーバに送信することができるのです。バをーバを2つ用意して，最初のサーバがクライアントから受け取ったロギングイベントントベトンをルのようにそのまま二つ目のサーバに転送するところを确认するのは，読者の演习习俗にしておきにしてお。
		</p>
		
		<h4><a name="simpleSSLSocketServer"></a> SimpleSSLSocketServerの使い方</h4>

    <p><code>SimpleSSLSocketServer</code>では， <code>SimpleSocketServer</code>と同様にコマンドライン引数で<em>port</em>と<em>configFile</em>を指定します。。加えて，ロギングサーバのX.509证明书ファイルの场所とパスワードをシステムパラメータで指定タで。
    </p>
    
    <p><em>logback-examples</em>ディレクトリに移动してから，次のコマンドを実行すると<code>SimpleSSLSocketServer</code>を开始できます。</p>

    <p class="source">java -Djavax.net.ssl.keyStore = src / main / java / chapters / appenders / socket / ssl / keystore.jks \ -Djavax.net.ssl.keyStorePassword = changeit \ ch.qos.logback.classic.net。SimpleSSLSocketServer 6000 \ src / main / java / chapters / appenders / socket / ssl / server.xml</p>
	
    <p>。の例では，テストや検证で使う用のX.509证明书ファイルを指定して<code>SimpleSSLSocketServer</code>を実行しています。<strong>本番环境で<code>SimpleSSLSocketServer</code>な使う前に，ロギングサーバを识别するための正式なX.509证明书を手に入れなければなりません</strong> 。详しくは<a href="./usingSSL.html">SSLを使用する</a>を参照してください。
    </p>
    
    <p>するーバの使用する设定ファイルのルート要素に<code>debug="true"</code>を指定しているので，サーバの开始ログを见ればSSLを设定していることがわかるでしょう。リティポリシーが正しく设定されていることを确认するのに便利です。
    </p>

    <p>実行中の<code>SimpleSSLSocketServer</code>には， <code>SSLSocketAppender</code>を使って接続することができます。アペンダーの设定例は次のとおりです。</p>
      
   	<p class="example">例：SSLSocketAppenderの设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/socket/ssl/client.xml">logback-examples / src / main / java / chapters / appenders / socket / ssl / client.xml</a> ）</p>
    <span class="asGroovy" onclick="return asGroovy('sslclient');">Groovyとして表示</span>
<pre id="sslclient" class="prettyprint source">&lt;configuration debug="true"&gt;
	  
  &lt;appender name="SOCKET" class="ch.qos.logback.classic.net.SSLSocketAppender"&gt;
    &lt;remoteHost&gt;${host}&lt;/remoteHost&gt;
    &lt;port&gt;${port}&lt;/port&gt;
    &lt;reconnectionDelay&gt;10000&lt;/reconnectionDelay&gt;
    &lt;ssl&gt;
      &lt;trustStore&gt;
        &lt;location&gt;${truststore}&lt;/location&gt;
        &lt;password&gt;${password}&lt;/password&gt;
      &lt;/trustStore&gt;
    &lt;/ssl&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="SOCKET" /&gt;
  &lt;/root&gt;  

&lt;/configuration&gt;</pre>
	  
	  <p>前の例と同じく， <span class="prop">remoteHost</span>と<span class="prop">port</span>の<span class="prop">値</span>は変数になっています。また， <span class="prop">ssl</span>プロパティとネストしている<span class="prop">trustStore</span>プロパティが増えているので注意してください。位置と密码も変数になっています。例として用意したサーバが自己署名证明书を使っているので，これらの设定は必须です。<code>SSLSocketAppender</code>のSSL设定について，详しくは<a href="./usingSSL.html">SSLを使用する</a>を参照してください。
	  </p>

    <p>设定ンドラインから，设定ファイルで使用している変数をシステムプロパティとして指定すれば，クライアントアプリケーションを実行することができます。</p>
    	  	
    <p class="source">java -Dhost = localhost -Dport = 6000 \ -Dtruststore = file：src / main / java / chapters / appenders / socket / ssl / truststore.jks \ -Dpassword = changeit \ chapters.appenders.socket。SocketClient2 src / main / java / chapters / appenders / socket / ssl / client.xml</p>
 	  
 	  <p>前の例と同じく，クライアントアプリケーションのコンソールにメッにメージを入力することができます。なと，メッセージは（安全な通信路上で）ロギングサーバに送信されます。，サーバ侧のコンソールにログがログが出力されます。
 	  </p>
 	  
 	  <p>したンドラインで指定した<em>truststore</em>プロパティには，信頼できるキーストアのURLを指定することに注意しましょう。<a href="./usingSSL.html">SSLを使用する</a>でも说明していますが，URLでクラスパス上のリソースを指定することもできます。</p>
 
    <p>前の例でサーバの起动时にいろいろと出力されているのと同じように，クライアントの设定ファイルのルート要素に<code>debug="true"</code>と指定しているので，クライアントの起动时にもSSL设定に关する情报が出力されています。ローカルポリシーの适合性の监查に役立つでしょう。
    </p>
 	  
 	  
    <h3 class="doAnchor" name="serverSocketAppender">ServerSocketAppender和SSLServerSocketAppender</h3>
    
    <p>前に说明した<code>SocketAppender</code>対応ンポーネントとSSL対応版のSSLSocketAppenderは，ネットワークの向こう侧のサーバにロギンギイベントを配信するためのものです。アプリケーションがリモートロギングサーバに接続するために设计されています。偶尔によりますが，アプリケーションから特定のリモートロギンギーバへの接続を建立するのが不便だったり不可能だったりすることがあります。そういう场合のためにlogbackでは<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/server/ServerSocketAppender">ServerSocketAppender</a></code>が用意されています。
    </p>
    
    <p><code>ServerSocketAppender</code>特定，特定のリモートロギンギーバとの接続を重置する代わりに，リモートクライアントからのTCPソケット接続を待ち受けます。アペンダーに送信されたロギンギイベントは，接続しているクライアントに配布されます。接続しているクライアントがいなければ，ロギングイベントは<em>すぐに破弃されます</em> 。
    </p>
    
    <p>logbackは，普通の<code>ServerSocketAppender</code>だけでなく，SSL対応版の<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/server/SSLServerSocketAppender"><code>SSLServerSocketAppender</code></a>も用意しています。安全な，暗号化された通信路で接続したクライアントにロギングイベントを配布します。対応，SSL対応版のアペンダーは，完全な相互认证をサポートしています。つまり，认证されたクライアントだけがロギンギイベントを受信するためにアペンダーに接続できることが保证されるのです。
    </p>
   
    <p>通信路上でのロギングイベントの符号化方法は使用している<code>SocketAppender</code>に关わらず同一です。ロギングイベントは<code>ILoggingEvent</code>のインスタンスがシリアライズされたものです。接続を建立する方向だけが逆転しています。<code>SocketAppender</code>が特定のロギングサーバに対して接続を连接しようとする活性ピアとして振る舞うのに対して， <code>ServerSocketAppender</code>は受动的にクライアントからの接続を待ち受けます。</p>  

    <p><code>ServerSocketAppender</code>の派生タイプは，logbackの他の<em>レシーバーコンポーネント</em>とは排他的に利用されることを想定しています。コンポーネントタイプに关する详细については<a href="./receivers.html">レシーバー</a>を参照してください。</p>
    
    <p><code>ServerSocketAppender</code>の设定可能なプロパティを表にまとめました。</p>
    
    <table class="bodyTable striped">
      <tbody><tr>
      <th>プロパティ名</th>
      <th>型</th>
      <th>说明</th>
      </tr>
      <tr>
        <td><span class="prop" container="serverSocketAppender">地址</span></td>
        <td><code>String</code></td>
        <td>アペンダーが待ち受けるためのローカルネットワークインターフェイスに割り当てられたIPアドレス。场合のプロパティが指定されていない场合，アペンダーはすべてのネットワークインターフェイスで待ち受けます。</td>
      </tr>
      <tr>
        <td><span class="prop" container="serverSocketAppender">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>
          <p>trueの场合，リモートホスト侧で送信者情报が利用できるようになります。デフォルトでは，送信者情报はクライアントに送信されません。
          </p>
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="serverSocketAppender">港口</span></td>
        <td><code>int</code></td>
        <td>
          <p>アペンダーが待ち受けるポート番号。
          </p>
        </td>
      </tr> 
      <tr>
        <td><span class="prop" container="serverSocketAppender">ssl</span></td>
        <td><code>SSLConfiguration</code></td>
        <td><code>SSLServerSocketAppender</code>でのみ使用出来るプロパティ。<a href="./usingSSL.html">SSLを使用する</a>で说明したように，アペンダーの使用するSSLの设定を指定します。</td>
      </tr>
    </tbody></table>
    
    <p><code>ServerSocketAppender</code>の使用例を次に示します。</p>

    <p class="example">例：ServerSocketAppenderの基本的な设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/socket/server4.xml">logback-examples / src / main / java / chapters / appenders / socket / server4.xml</a> ）</p>
<pre id="SocketReceiver" class="prettyprint source">&lt;configuration debug="true"&gt;
  &lt;appender name="SERVER" 
    class="ch.qos.logback.classic.net.server.ServerSocketAppender"&gt;
    &lt;port&gt;${port}&lt;/port&gt;
    &lt;includeCallerData&gt;${includeCallerData}&lt;/includeCallerData&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="SERVER" /&gt;
  &lt;/root&gt;  

&lt;/configuration&gt;
</pre>
    <p>前の例との违いは， <em>类属性</em>に指定しているのが<code>SocketAppender</code>プいこと， <span class="prop">remoteHost</span>プロパティが无いことだけなのがわかりましたか。バにのアペンダーはリモートロギングサーバに接続するのではなく，リモートホストからの接続を受动的に待ち受けます。
    </p>
    
    <p><code>SSLServerSocketAppender</code>の设定例は次のとおりです。</p>
        
    <p class="example">例：SSLServerSocketAppenderの基本的な设置（ <a href="http://logback.qos.ch/xref/chapters/appenders/socket/server3.xml">logback-examples / src / main / java / chapters / appenders / socket / server3.xml</a> ）</p>
<pre id="SocketReceiver" class="prettyprint source">&lt;configuration debug="true"&gt;
  &lt;appender name="SERVER" 
    class="ch.qos.logback.classic.net.server.SSLServerSocketAppender"&gt;
    &lt;port&gt;${port}&lt;/port&gt;
    &lt;includeCallerData&gt;${includeCallerData}&lt;/includeCallerData&gt;
    &lt;ssl&gt;
      &lt;keyStore&gt;
        &lt;location&gt;${keystore}&lt;/location&gt;
        &lt;password&gt;${password}&lt;/password&gt;
      &lt;/keyStore&gt;
    &lt;/ssl&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="SERVER" /&gt;
  &lt;/root&gt;  

&lt;/configuration&gt;
</pre>
   
    <p>前の例との主な违いは， <em>类属性</em>に<code>SSLServerSocketAppender</code> sl指定していることと，ネストしている<span class="prop">ssl要素</span>があることです。。の例ではアがンダー用のX.509证明书が置かれたキーストアが指定されています。SSLの设定について详细は<a href="./usingSSL.html">SSLを使用する</a>を参照してください。
    </p>
    
    <p></p>
    
   <h3 class="doAnchor">SMTPAppender</h3>
   
   <p><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/SMTPAppender.html"><code>SMTPAppender</code></a>は，一つ以上の固定サイズのバッファにロギンギイベントを蓄积し，利用者が指定したイベントが発生したら适切なバッファを选んで内容をメールで送信します。SMTPによるメール送信は非同期で実行されます。デフォルトでは，ERRORレベルのロギングイベントがトリがとなってメールが送信されます。つ，1つのバッファがすべてのロギングイベントから使用されます。
   </p>
		
   <p><code>SMTPAppender</code>の设定可能なプロパティを表にまとめました。
	 </p>
		
		<table class="bodyTable striped">
      <tbody><tr>
        <th>プロパティ名</th>
        <th>型</th>
        <th>说明</th>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">smtpHost</span></td>
        <td><code>String</code></td>
        <td>SMTPサーバのホスト名。タです必须パラメータです。</td>
      </tr>
      
      <tr>
        <td><span class="prop" container="smtp">smtpPort</span></td>
        <td><code>int</code></td>
        <td>SMTPサーバーの待ち受けポート番号。デフォルトでは25です。</td>
      </tr>
      
      <tr>
        <td><span class="prop" name="smtpTo">至</span></td>
        <td><code>String</code></td>
        <td>收件人のメールアドレスの<em>パターン</em>を指定します。指定したパターンは，送信されるメールそれぞれに対して，トリガとなったロギングイベントと共に评価されます。复数の收件人を指定するときは，宛先アドレスをカンマ区切りにします。また， <code>to要素</code>を复数并べることもできます。
        </td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">从</span></td>
        <td><code>String</code></td>
        <td><code>SMTPAppender</code>の发信するメールメッセージの创始者を<a href="http://en.wikipedia.org/wiki/Email_address">一般的なメールアドレス形式</a>で指定します。送信者名を含めたい场合は“ Adam Smith <smith@moral.org>”のようにします（XML形式の设定ファイルではブラケットを文字実态参照にします）。そうすると，メールでは“ Adam Smith <smith@moral.org>”のようになります。
        </smith@moral.org></td>
      </tr>
      <tr>
        <td><span class="prop">学科</span></td>
        <td><code>String</code></td>
        <td> 
          <p>メールの件名。<a href="./layouts.html#ClassicPatternLayout">PatternLayout</a>で利用できる全ての値を指定できます。レイアトトについては次の章で说明します。
          </p>
          
          <p>送信されるメールメッセージの件名には，メール送信をトリガしたロギングイベントベ适用したパターンが指定されます。
          </p>

          <p><span class="prop">subject</span>オプションに指定されたパターンが“登录：％logger-％msg”で，“ com.foo。Bar“ロガーが” Hello World“となったッギージのロギングイベントを発生して，このロギングイベントがトリガとなった场合，送信されるメールの件名は” Log：com.foo。酒吧-Hello World”“。
          </p>

          <p>デフォルトでは，“％logger {20}-％m”が设定されています。</p>
        </td>
        
      </tr>
      <tr>
        <td><span class="prop" container="smtp">判别器</span></td>
        <td><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/sift/Discriminator.html">Discriminator</a></code></td>
        <td>
          <p><code>SMTPAppender</code>は， <span class="prop">弁别器</span>の返す値に基す値にいてバッファを选択して，発生したロギングイベントを振り分けます。デフォルトの弁别器は常に同じ値を返すので，全てのロギングイグントベ常に同じバッファに振り分けられます。
          </p>

          <p>特定フォルト以外の弁别器を指定すれば，特定のユーザー，ユーザーセッション，クライアントのIPアドレスに关连するロギングイグントグ含むメールだけを送信することもできます。
          </p>
        </td>
      </tr>
      <tr>
        <td><span class="prop" name="smtpAppender_Evaluator">评估者</span></td>
        <td><code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/boolex/IEvaluator.html">IEvaluator</a></code></td>
        <td>
          <p>のオプションを指定するには，新しく<code>EventEvaluator要素</code>を宣言します。<code>SMTPAppender</code>の<code>Evaluator</code>として使いたいクラスの完全クラス名を， <span class="attr">类属性</span>に指定します。
          </p>
          
          
          <p>このオプションを指定しなかった场合， <code>SMTPAppender</code> <a href="http://logback.qos.ch/xref/ch/qos/logback/classic/boolex/OnErrorEvaluator.html">ErrorOnErrorEvaluator</a>のインスタンスを使用します。これは<em>ERROR</em>以上のロギングイベントが発生したらメール送信をトリガします。
          </p>

          <!--
          <p><code>EventEvaluator</code> objects are subclasses of the
          <code>JaninoEventEvaluatorBase</code> which depends on
          Janino. See the <a href="../dependencies.html">dependencies
          page</a> for more information.
          </p>
          -->

          <p>logbackの配布物には他の评価器もいくつか含まれています。 <a href="http://logback.qos.ch/xref/ch/qos/logback/classic/boolex/OnMarkerEvaluator.html"><code>OnMarkerEvaluator</code></a> （详しくは后述します）と，より强力な评価器の<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/boolex/JaninoEventEvaluator.html"><code>JaninoEventEvaluator</code></a>です。上方については<a href="./filters.html#evalutatorFilter">别の章</a>で绍介します。最新バージョンの配布物にはさらに强力な评価器である<a href="./filters.html#GEventEvaluator"><code>GEventEvaluator</code></a>が含まれます。
          </p>

        </td>
      </tr>

      <tr>
        <td valign="top"><span class="prop" container="smtp">cyclicBufferTracker</span></td>
        <td><a href="http://logback.qos.ch/xref/ch/qos/logback/core/spi/CyclicBufferTracker.html"><code>CyclicBufferTracker</code></a>
        </td>
        <td>
          <p>名前が示す通り， <code>CyclicBufferTracker</code>クラスは循环バッファを追迹します。追迹は，前に说明した<span class="prop">弁别器</span>の返すキーに基にいて行われます。
          </p>
          <p><span class="prop">cyclicBufferTracker</span>指定しなかった场合，自动的に<a href="http://logback.qos.ch/xref/ch/qos/logback/core/spi/CyclicBufferTrackerImpl.html">CyclicBufferTrackerImpl</a>のインスタンスを生成して使用します。でフォルトで256个のロギングイベントを循环バッファに保持します。<span class="prop">bufferSize</span>オプションを指定してサイズを変更することもできます（下记参照）。</p>
        </td>        
      </tr>
      <tr>
        <td><span class="prop" container="smtp">用户名</span></td>
        <td><code>String</code></td> <td>平文のパスワード认证をするときに使用するユーザー名。デフォルトではnullです。</td> 
      </tr> 
      <tr class="alt">
        <td><span class="prop" container="smtp">密码</span></td>
        <td><code>String</code></td>
        <td>平文のパスワード认证をするときに使用するパスワード。デフォルトではnullです。

        </td>
      </tr>
      <tr> 
        <td><span class="prop" container="smtp">STARTTLS</span> </td>
        <td><code>boolean</code></td> 
        <td>trueを指定すると，サーバがサポートしているならSSL接続に切り替えるため，STARTTLSコマンドを発行します。接続が建立した时点では暗号化されていないので注意してください。デフォルトではfalseに设定されています。
        </td> 
      </tr>
      <tr>
        <td><span class="prop" container="smtp">SSL协议</span></td>
        <td><code>boolean</code></td> <td>trueを指定するとサーバにSSL接続をします。デフォルトでは假です。</td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">charsetEncoding</span></td>
        <td><code>String</code></td>
        <td>送信されるメッセージは指定された<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">文字セット</a>でエンコードされます。UTフォルトの文字セットは“ UTF-8”ですが，ほとんどの场合十分でしょう。
        </td>
      </tr>


      <tr>
        <td><span class="prop" container="smtp">本地主机</span></td>
        <td><code>String</code></td>
        <td>SMTPクライアントのホスト名が正しく设定しくいない场合（例えば，ホスト名が完全修饰名ではない场合），SMTPサーバの中にはそういうクライアントから送信されたHELO / EHLOコマンドを拒绝否することがあります。をの问题を解决するには，クライアントのホスト名として， <span class="prop">localhost</span>に完全修饰名を指定することができます。<a href="http://javamail.kenai.com/nonav/javadocs/com/sun/mail/smtp/package-summary.html">com.sun.mail.smtp</a>パッケージのドキュメントで说明されている“ mail.smtp.localhost”パラメータも参考にしてください。</td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">异步发送</span></td>
        <td><code>boolean</code></td>
        <td>でール送信を非同期で行うかどうかを指定します。デフォルトはtrueです。しかし，非同时送信が不适切な场合な。たとえば，あなたのアプリケーションで致命的なエラーが発生した际， <code>SMTPAppender</code>でアラートメールを送信してから终了するとしても，その仕事を任されたスレッドにはメールを送信する时间が残されていないからです。そういう场合は同时的にメール送信をするためfalseを指定しましょう。
        </td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>デフォルトは<code>false</code>です。<span class="prop">异步发送</span>が有效でログに送信者情报を含めたいときは<code>true</code>を指定しなければなりません。</td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">sessionViaJNDI</span></td>
        <td><code>boolean</code></td>
        <td><code>javax.mail.Session</code>を使用してメールを送信します。デフォルトは<code>false</code>なので， <code>SMTPAppender</code>は利用者の指定した设定に従って<code>javax.mail.Session</code>インスタンスを构筑します。<code>true</code>を指定するとJNDIから<code>javax.mail.Session</code>インスタンスを取得します。<span class="prop">jndiLocation</span>プロパティも参照してください。

        <p><span class="label">注意</span> JNDIから<code>Session</code>を取得すれば，设定する场所は减るし，同じ情报をあちこちで指定しなくてもよくなります。そうすると，アプリケーションはより<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>になります。TomcatでJNDIリソースを设定する方法については<a href="http://tomcat.apache.org/tomcat-6.0-doc/jndi-resources-howto.html#JavaMail_Sessions">JNDIリソースハウツー</a>を参照してください。JNDIから<code>Session</code>オブジェクトを取得する场合は，ドキュメントに记にいるように， <em>mail.jar</em>と<em>activation.jar</em>をWebアプリケーションの<em>WEB-INF / lib</em>フォルダから取り除いてください。</p>
        </td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">jndi位置</span></td>
        <td><code>String</code></td>
        <td>JNDIのjavax.mail。会话の位置を指定します。<span style="white-space:nowrap">java</span>フォルトは<span style="white-space:nowrap">“ java：comp / env / mail / Session”</span>です。
        </td>
      </tr>

		</tbody></table>		
		
		<p><code>SMTPAppender</code> 256循环バッファで最新の256个のロギングイベントだけを保持します。バッファが一杯になったら古いロギングイベントを舍てます。したがって， <code>SMTPAppender</code>ールで送信するロギングイベントの最大値は256个になります。つまり，アプリケーションションコストに妥当なメモリ量を割り当てられるよう，メモリ要件に合わせて制限できるということです。
		</p>
		
		<p><code>SMTPAppender</code> MailJavaMail APIにも依存しています。MailストされているJavaMail APIのバージョンは1.4です。JavaMail APIにはJavaBeans激活フレームワークが必要です。<a href="http://java.sun.com/products/javamail/">JavaMail API</a>と<a href="http://java.sun.com/beans/glasgow/jaf.html">JavaBeans Activationフレームワーク</a>はそれぞれのウェブサイトからダウンロードすることができます。以降の例を试す前に，クラスパス上にこれらのjarファイルが配置されていることを确かめてください。
		</p>
		
		<p>ではンプルアプリケーションでは， <a href="http://logback.qos.ch/xref/chapters/appenders/mail/EMail.html"><code>chapters.appenders.mail.EMail</code></a>ジをいくつかのログメッセージを生成したあとで，エラーメッセージを1つ生成しています。引のアプリケーションの引数は二つあります。一つ目のパラメータは生成するロギングイベントの数となる一体値です。二つ目のパラメータはlogbackの设定ファイルです。<em>通过电子邮件发送电子邮件给</em>プリケーションションが最后に生成するロギングイベントのログレベルはERRORERRORなので，メール送信をトリガします。
		</p>

		<p><code>Email</code>アプリケーションから使う设定ファイルは次のとおりです。</p>	
		
    <p class="example">例： <code>SMTPAppender</code>の设定例（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/mail1.xml">logback-examples / src / main / java / chapters / appenders / mail / mail1.xml</a> ）</p>	
    <span class="asGroovy" onclick="return asGroovy('mail1');">Groovyとして表示</span>	
    <pre id="mail1" class="prettyprint source">&lt;configuration&gt;	  
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    &lt;smtpHost&gt;ADDRESS-OF-YOUR-SMTP-HOST&lt;/smtpHost&gt;
    &lt;to&gt;EMAIL-DESTINATION&lt;/to&gt;
    &lt;to&gt;ANOTHER_EMAIL_DESTINATION&lt;/to&gt; &lt;!-- additional destinations are possible --&gt;
    &lt;from&gt;SENDER-EMAIL&lt;/from&gt;
    &lt;subject&gt;TESTING: %logger{20} - %m&lt;/subject&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;pattern&gt;%date %-5level %logger{35} - %message%n&lt;/pattern&gt;
    &lt;/layout&gt;	    
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="EMAIL" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>

		<p>上记の设定ファイルで<code>chapters.appenders.mail.Email</code>アプリケーションを动かしてみる前に，smtpHostや<span class="prop"><span class="prop">从</span></span>へや，あなたの环境に适した値を指定しなければなりません。设定ファイルに正しい値を指定したら次のコマンドを実行しましょう。</p>
		
<div class="source"><pre>java chapters.appenders.mail.EMail 100 src/main/java/chapters/appenders/mail/mail1.xml</pre></div>

		<p>指定した收件人には<code>PatternLayout</code>指定したとおりに书式化された100个のロギングイベントが含まれたメールが届が。Mozilla Thunderbirdで受信したメールを开いたところを示します。
		</p>
    
    <p><img src="images/chapters/appenders/smtpAppender1.jpg" alt="结果の电子メール"></p>
		
		<p>设置ファイル<em>mail2.xml</em>では， <span class="prop">smtpHost</span>や<span class="prop">到</span>や<span class="prop">来自</span>で数で指定されています。<em>mail2.xml</em>の<em>大事</em>な部分を次に示します。
		</p>		

    <pre class="prettyprint source">&lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
  &lt;smtpHost&gt;${smtpHost}&lt;/smtpHost&gt;
  &lt;to&gt;${to}&lt;/to&gt;
  &lt;from&gt;${from}&lt;/from&gt;
  &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/&gt;
&lt;/appender&gt;</pre>
		
		<p>でンドラインで必要なパラメータを指定します。</p>
		
<div class="source"><pre>java -Dfrom=source@xyz.com -Dto=recipient@xyz.com -DsmtpHost=some_smtp_host \
  chapters.appenders.mail.EMail 10000 src/main/java/chapters/appenders/mail/mail2.xml
</pre></div>

		<p>での环境で利用できるものに置き换えてください。
		</p>
		
		<p>最后の例では， <code>PatternLayout</code>が<code>HTMLLayout</code>になっていました。テログの内容をHTMLのテーブルとして书式化します。列の并びと顺番は変更することができます。CSSも変更できます。<a href="./layouts.html#ClassicHTMLLayout">HTMLLayout</a>について详てントを参照してください。
    </p>
    
    <p>256个循环，收件人256个受助人，一个受助人，一个受助人，一个受助人和一个受助人。<code>chapters.appenders.mail.Email</code>アプリケーションを実行して10000件のロギングイベントを生成しても，送信されるメールには最新の256件しか含まれないことになるので気をつけてください。
		</p>
		
    <p><img src="images/chapters/appenders/smtpAppender2.jpg" alt="第2回のメール"></p>

    <p>Mozilla ThunderbirdやEudoraやMS OutlookとHTMLのメールでもCSSをわりと上手く处理します。胜，胜手にHTMLを平文テキストにダウングレードすることがあります。例えば，ThunderbirdでHTMLメールを表示するには，“表示→メッセージ此处→オリジナルのHTML”でオプションを指定しなければなりません。Yahoo!メールはHTMLメールをサポートしており，CSSの対応具合はピカ一です。一方，Gmailは普通のHTMLテーブルはそのまま表示してくれますが，内部CSSによる整形はしてくれません。GmailはインラインCSSをサポートしていますが，インラインCSSを使うとHTMLソースコードが膨れ上がってしまうので， <code>HTMLLayout</code>をインラインCSSを使用しません。</p>

    <h3 class="doAnchor" name="cyclicBufferSize">カスタムバッファサイズ</h3>

    <p>デフォルトでは， <code>SMTPAppender</code>から送信されるメッセージには最大で256件のロギングメッセージが含まれています。次の例に示すように，别のバッファサイズを指定することができます。
    </p>

    <p class="example">例：バッファサイズを変更した<code>SMTPAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/customBufferSize.xml">logback-examples / src / main / java / chapters / appender / mail / customBufferSize.xml</a> ）</p>	
    <pre class="prettyprint source">&lt;configuration&gt;   
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    &lt;smtpHost&gt;${smtpHost}&lt;/smtpHost&gt;
    &lt;to&gt;${to}&lt;/to&gt;
    &lt;from&gt;${from}&lt;/from&gt;
    &lt;subject&gt;%logger{20} - %m&lt;/subject&gt;
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/&gt;

    <b>&lt;cyclicBufferTracker class="ch.qos.logback.core.spi.CyclicBufferTracker"&gt;</b>
      <b>&lt;!-- send just one log entry per email --&gt;</b>
      <b>&lt;bufferSize&gt;1&lt;/bufferSize&gt;</b>
    <b>&lt;/cyclicBufferTracker&gt;</b>
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="EMAIL" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;    </pre>
    

    <h3 class="doAnchor">トリガイベント</h3>

    <p>评估员プロパティが指定されなかったら， <code>SMTPAppender</code> Errorフォルトで<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/boolex/OnErrorEvaluator.html">OnErrorEvaluator</a>を使用して，ERRORレベルのロギングイベントの発生をトリガとしてメールを送信する。エラーの発生に応じて，メール送信をトリガするのはそれなりに合理的ですが， <code>EventEvaluator</code>インターフェイスの别の実装を指定すればデフォルトの振る舞いを上书きすることができます。
    </p>
		
		<p><code>SMTPAppender</code>は<code>evaluate()</code>メソッドを呼び出すことで，受け取ったロギングイベントを评価器に渡します。送のロギングイベントがメール送信をトリガするものなのか，単に循环バッファに入ァにいいのかを判定するためです。评価器が评価した结果が真なら，メールを送信します。<code>SMTPAppender</code>の保持する评価器オブジェクトは1つだけです。このオブジェクトは，自身の内部状态を管理することができます。わかりにくいので， <code>CounterBasedEvaluator</code>クラスのコードで说明します。発ロギングイベントが1024件発生するたびにメール送信をトリガします。
		</p>

    <p class="example">例：1024件ごとに评価値<code>true</code>を返す<code>EventEvaluator</code>インターフェイスの実装（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/CounterBasedEvaluator.java">logback-examples / src / main / java / chapters / appenders / mail / CounterBasedEvaluator.java</a> ）</p>
   
   <pre class="prettyprint source">package chapters.appenders.mail;

import ch.qos.logback.core.boolex.EvaluationException;
import ch.qos.logback.core.boolex.EventEvaluator;
import ch.qos.logback.core.spi.ContextAwareBase;

public class CounterBasedEvaluator extends ContextAwareBase implements EventEvaluator {

  static int LIMIT = 1024;
  int counter = 0;
  String name;

  <b>public boolean evaluate(Object event) throws NullPointerException,
      EvaluationException {
    counter++;

    if (counter == LIMIT) {
      counter = 0;

      return true;
    } else {
      return false;
    }
  }</b>

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}</pre>

		<p>クのクラスは<code>ContextAwareBase</code>を継承して， <code>EventEvaluator</code>インターフェイスを実装しているのがわかるでしょうか。利用，利用者は<code>EventEvaluator</code>としての中心机能に集中することができるし，基底クラスを使って共通する机能を提供できるようになります。
		</p>

		<p><code>SMTPAppender</code>の<span class="prop">评价者</span>オプションを指定をということは，カスタム评タム器価使うということです。次の设定ファイルではルートロガーに<code>SMTPAppender</code>を割り当てています。SMTPAppenderでは， <code>CounterBasedEvaluator</code>を评価器として指定しています。
		</p>

    <p class="example">例： <code>SMTPAppender</code>とカスタム<code>評価器</code>とバッファサイズの设定例（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/mail3.xml">logback-examples / src / main / java / chapters / appenders / mail / mail3.xml</a> ）</p>
    <span class="asGroovy" onclick="return asGroovy('mail3');">Groovyとして表示</span>	
    <pre id="mail3" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    <b>&lt;evaluator class="chapters.appenders.mail.CounterBasedEvaluator" /&gt;</b>
    &lt;smtpHost&gt;${smtpHost}&lt;/smtpHost&gt;
    &lt;to&gt;${to}&lt;/to&gt;
    &lt;from&gt;${from}&lt;/from&gt;
    &lt;subject&gt;%logger{20} - %m&lt;/subject&gt;

    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="EMAIL" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>
    

    <h3 class="doAnchor" name="OnMarkerEvaluator">カーカーに基づくトリガ</h3>

    <p>全てのERRORレベルのロギングイベンベントをトリガとしてメールを送信logbackの配布物には<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/boolex/OnMarkerEvaluator.html">OnMarkerEvaluator</a>というトリガポリシーも含まれています。カーカーに基づいてトリガするものです。原则として，利用者が指定したマーカーのロギングイベントが発生したときだけメール送信がトリガされます。次の例を见ればどういう动き方をするのかはっきりするでしょう。
    </p>

    <p><a href="http://logback.qos.ch/xref/chapters/appenders/mail/Marked_EMail.html">Marked_EMailの</a>アプリケーションには，ERRORレベルを含むいくつものロギング式があります。そのうちで，一つのロギング式にだけマーカーが指定されています。该当するコードは次のとおりです。
    </p>

    <pre class="prettyprint source">Marker notifyAdmin = MarkerFactory.getMarker("NOTIFY_ADMIN");
logger.error(<b>notifyAdmin</b>,
  "This is a serious an error requiring the admin's attention",
   new Exception("Just testing"));</pre>

   <p>次の设定ファイルは，マーカーとしてNOTIFY_ADMINあるいはTRANSACTION_FAILUREを指定されたロギングイベントが発生したときだけメール送信をトリガするものです。
   </p>

   <p class="example">例： <code>OnMarkerEvaluator</code>を指定した<code>SMTPAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/mailWithMarker.xml">logback-examples / src / main / java / chapters / appenders / mail / mailWithMarker.xml</a> ）</p>

   <span class="asGroovy" onclick="return asGroovy('mailWithMarker');">Groovyとして表示</span>	
   <pre id="mailWithMarker" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    <b>&lt;evaluator class="ch.qos.logback.classic.boolex.OnMarkerEvaluator"&gt;
      &lt;marker&gt;NOTIFY_ADMIN&lt;/marker&gt;
      &lt;!-- you specify add as many markers as you want --&gt;
      &lt;marker&gt;TRANSACTION_FAILURE&lt;/marker&gt;
    &lt;/evaluator&gt;</b>
    &lt;smtpHost&gt;${smtpHost}&lt;/smtpHost&gt;
    &lt;to&gt;${to}&lt;/to&gt;
    &lt;from&gt;${from}&lt;/from&gt;
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/&gt;
  &lt;/appender&gt;

  &lt;root&gt;
    &lt;level value ="debug"/&gt;
    &lt;appender-ref ref="EMAIL" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>
    
    <p>次のコマンドを実行してみましょう。</p>

    <pre class="source">java -Dfrom=source@xyz.com -Dto=recipient@xyz.com -DsmtpHost=some_smtp_host \
  chapters.appenders.mail.Marked_EMail src/main/java/chapters/appenders/mail/mailWithMarker.xml</pre>


  <h4 class="doAnchor" name="marker_JaninoEventEvaluator">JaninoEventEvaluatorを使ったマーカーに基づくトリガ</h4>

    <p>カーカーだけを対象にした<code>OnMarkerEvaluator</code>の代わりに，より泛用的な<a href="./filters.html#JaninoEventEvaluator"><code>JaninoEventEvaluator</code></a>を使うことができますし，それ以上に强力な<a href="./filters.html#GEventEvaluator"><code>GEventEvaluator</code></a>使うことも出来ます。とえば，次の设定ファイルは<code>OnMarkerEvaluator</code>の代わりに<code>JaninoEventEvaluator</code>指定した以外は前の设定ファイルとまったく同じ内容になります。
    </p>

    <p class="example">例： <code>JaninoEventEvaluator</code>を指定した<code>SMTPAppender</code>の设定（logback-examples / src / main / java / chapters / appenders / mail / mailWithMarker_Janino.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('mailWithMarker_Janino');">Groovyとして表示</span>	
    <pre id="mailWithMarker_Janino" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    &lt;evaluator class="ch.qos.logback.classic.boolex.JaninoEventEvaluator"&gt;
      &lt;expression&gt;
        (marker != null) &amp;&amp;
        (marker.contains("NOTIFY_ADMIN") || marker.contains("TRANSACTION_FAILURE"))
      &lt;/expression&gt;
    &lt;/evaluator&gt;    
    ... same as above
  &lt;/appender&gt;
&lt;/configuration&gt;</pre>

    <h4 class="doAnchor" name="marker_GEventEvaluator">GEventEvaluatorを使ったマーカーに基づくトリガ</h4>

    <p><a href="./filters.html#GEventEvaluator">GEventEvaluator</a>を使っている以外は前の例と同じ内容です。</p>

    <p class="example">例： <code>GEventEvaluator</code>した指定したSMTPAppenderの设置（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/mailWithMarker_GEvent.xml">logback-examples / src / main / java / chapters / appenders / mail / mailWithMarker_GEvent.xml</a> ）</p>
   <span class="asGroovy" onclick="return asGroovy('mailWithMarker_GEventEvaluator');">Groovyとして表示</span>	

   <pre id="mailWithMarker_GEventEvaluator" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    &lt;evaluator class="ch.qos.logback.classic.boolex.GEventEvaluator"&gt;
      &lt;expression&gt;
        e.marker?.contains("NOTIFY_ADMIN") || e.marker?.contains("TRANSACTION_FAILURE")
      &lt;/expression&gt;
    &lt;/evaluator&gt;    
    ... same as above
  &lt;/appender&gt;
&lt;/configuration&gt;</pre>

    <p>场合ーカーを指定されなかったロギングイベントの场合，e.markerはnullになるので注意してください。の例ではGroovyの<a href="http://groovy.codehaus.org/Null+Object+Pattern">安全なデリファレンス演算子</a>である。？演算子を使っています。
    </p>


    <h3 class="doAnchor" name="smtpAuthentication">认证/ STARTTLS / SSL</h3>

    <p><code>SMTPAppender</code>では，平文のユーザーパスワード认证だけでなく，STARTTLSとSSLプロトコルの両方をサポートしています。STARTTLSとSSLの违いは，STARTTLSでは接続を重置続をときは暗号化されないこと，そして，クライアントがSTARTTLSコマンドを発行してサーバがサポートーいして场合はSSL接続に切り替えることです。SSLでは始めから通信が暗号化されます。
    </p>

    <h3>GmailにSSLで接続するSMTPAppenderの设定</h3>

    <p>次の例はGmailにSSLプロトコルで接続する<code>SMTPAppender</code>の设定です。</p>
    
    <p class="example">例：GmailにSSLで接続する<code>SMTPAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/gmaliSSL.xml">logback-examples / src / main / java / chapters / appenders / mail / gmaliSSL.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('gmailSSLExample');">Groovyとして表示</span>	
    <pre id="gmailSSLExample" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    <b>&lt;smtpHost&gt;smtp.gmail.com&lt;/smtpHost&gt;</b>
    <b>&lt;smtpPort&gt;465&lt;/smtpPort&gt;</b>
    <b>&lt;SSL&gt;true&lt;/SSL&gt;</b>
    <b>&lt;username&gt;YOUR_USERNAME@gmail.com&lt;/username&gt;</b>
    <b>&lt;password&gt;YOUR_GMAIL_PASSWORD&lt;/password&gt;</b>

    &lt;to&gt;EMAIL-DESTINATION&lt;/to&gt;
    &lt;to&gt;ANOTHER_EMAIL_DESTINATION&lt;/to&gt; &lt;!-- additional destinations are possible --&gt;
    &lt;from&gt;YOUR_USERNAME@gmail.com&lt;/from&gt;
    &lt;subject&gt;TESTING: %logger{20} - %m&lt;/subject&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;pattern&gt;%date %-5level %logger{35} - %message%n&lt;/pattern&gt;
    &lt;/layout&gt;	    
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="EMAIL" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>


    <h3 class="doAnchor" name="gmailSTARTTLS">STARTTLSでGmailに接続するSMTPAppenderの设定</h3>

    <p>次の例はGmailにSTARTTLSで接続する<code>SMTPAppender</code>の设定です。
</p>

    <p class="example">例：GmailにSTARTTLSで接続する<code>SMTPAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/gmailSTARTTLS.xml">logback-examples / src / main / java / chapters / appenders / mail / gmailSTARTTLS.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('gmailSTARTTLSExample');">Groovyとして表示</span>	
    <pre id="gmailSTARTTLSExample" class="prettyprint source">&lt;configuration&gt;	  
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    &lt;smtpHost&gt;smtp.gmail.com&lt;/smtpHost&gt;
    &lt;smtpPort&gt;587&lt;/smtpPort&gt;
    &lt;STARTTLS&gt;true&lt;/STARTTLS&gt;
    &lt;username&gt;YOUR_USERNAME@gmail.com&lt;/username&gt;
    &lt;password&gt;YOUR_GMAIL_xPASSWORD&lt;/password&gt;
    
    &lt;to&gt;EMAIL-DESTINATION&lt;/to&gt;
    &lt;to&gt;ANOTHER_EMAIL_DESTINATION&lt;/to&gt; &lt;!-- additional destinations are possible --&gt;
    &lt;from&gt;YOUR_USERNAME@gmail.com&lt;/from&gt;
    &lt;subject&gt;TESTING: %logger{20} - %m&lt;/subject&gt;
    &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;
      &lt;pattern&gt;%date %-5level %logger - %message%n&lt;/pattern&gt;
    &lt;/layout&gt;	    
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="EMAIL" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>


    <h3 class="doAnchor" name="smtpDiscriminator">MDCDiscriminatorを指定したSMTPAppenderの设定</h3>


    <p>优点したように， <code>SMTPAppender</code>にデフォルト以外の弁别器を指定すれば，特定のユーザ，ユーザセッション，送信元のIPアドレスを含むロギングイベントが発生が発场合にだけメールメッセージを生成することができます。
    </p>

    <p>次の例は<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/sift/MDCBasedDiscriminator.html">MDCBasedDiscriminator</a>に“ req.remoteHost”というキーを指定したものです。架として，架空のWebアプリケーションショアにクセスしてきたクライアントのリモートトストのIPアドレスが设定されることを想定しています。Webアプリケーションなら<a href="./mdc.html#mis">MDCInsertingServletFilter</a>使ってMDCに値を设置することができます。
    </p>

    <p class="example">例：MDCDiscriminatorを指定した<code>SMTPAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/mail/mailWithMDCBasedDiscriminator.xml">logback-examples / src / main / java / chapters / appenders / mail / mailWithMDCBasedDiscriminator.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('mailWithMDCBasedDiscriminator');">Groovyとして表示</span>	
    <pre id="mailWithMDCBasedDiscriminator" class="prettyprint source">&lt;configuration&gt;	  
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender"&gt;
    &lt;smtpHost&gt;ADDRESS-OF-YOUR-SMTP-HOST&lt;/smtpHost&gt;
    &lt;to&gt;EMAIL-DESTINATION&lt;/to&gt;
    &lt;from&gt;SENDER-EMAIL&lt;/from&gt;

    <b>&lt;discriminator class="ch.qos.logback.classic.sift.MDCBasedDiscriminator"&gt;</b>
      <b>&lt;key&gt;req.remoteHost&lt;/key&gt;</b>
      <b>&lt;defaultValue&gt;default&lt;/defaultValue&gt;</b>
    <b>&lt;/discriminator&gt;</b>

    &lt;subject&gt;${HOSTNAME} -- %X{req.remoteHost} %msg"&lt;/subject&gt;
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"&gt;
      &lt;pattern&gt;%date%level%thread%X{req.remoteHost}%X{req.requestURL}%logger%msg&lt;/pattern&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;root&gt;
    &lt;level level="DEBUG"/&gt;
    &lt;appender-ref ref="EMAIL" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>

    <p>こうすると， <code>SMTPAppender</code>の送信するメールそれぞれに<em>固有</em>のIPアドレスが记录されるようになるので，问题解决に役立ちます。
    </p>
    
    <h4 class="doAnchor" name="bufferManagement">高负荷システムにおけるバッファ管理（★要见直し）</h4>

    <p>内部的な事情ですが，弁别器が返す値ごとに循环バッファが作成されます。<span class="prop">场合</span> ，ほとんどの<span class="prop">场合maxNumberOfBuffers</span> （デフォルト値は64）はそのままです。<span class="prop">Number</span>ッファの数が<span class="prop">maxNumberOfBufferes</span>を越えてしまうと，一番最近更新されたバッファはすぐに自动的に破弃されてしまいます。もう一つの予防策として，直近の30分间に更新されなかったバッファはやはり自动的に破弃されてしまいます。</p>

    <p>毎分大量のトランザクションを处理するシステムでは， <span class="prop">maxNumberOfBuffers</span> （デフォルト値は64）が小さいと送信するメールに含まれるロギングイグントイトンのの数がとても少なくなってしまいます。大量のトランザクションが発生する场合，同じトランザクションには1つ以上のバッファが关连付けられてしまいます。で别器が同じトじンラクションには同じ値を返すので，バッファの破弃と生成が缲り返されてしまうからです。高负荷システムであっても，循环バッファの上限は<span class="prop">maxNumberOfBufferes</span>によって制御されてしまうので注意してください。
    </p>

    <p>ヨーヨー效果を避けるため， <code>SMTPAppender</code>は“ FINALIZE_SESSION”というマーカーの指定されたロギングイベントを见つけたら，そのロギングイベントに対して弁别器の返す値に关连付けられたバッファを直ちに开放するようになっています。终，トランザクションの终了时に适切にバッファを廃弃できるようになります。そうすれば， <span class="prop">maxNumberOfBuffers</span>には，安全のためより大きな値の512や1024を指定することができます。メモリ不足の危険性はありません。
    </p>

    <p>循环バッファを管理するために协调的に机能する，3つの相补的な仕组みがあります。仕の仕组みが，高负荷システムであっても常に有效なバッファが利用できることを保证するのです。</p>

    <!-- =========================================================== -->
    <!-- =========================================================== -->


    <h3 class="doAnchor" name="DBAppender">DBAppender</h3>
		
		<p><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/db/DBAppender.html"><code>DBAppender</code></a>つータベース上の3つのテーブルに，Javaプログラミンミ言语に依存しない形式のロギングイベントを登录を。
		</p>

		<p>3つのテーブルとは， <em>logging_event</em> ， <em>logging_event_property</em> ， <em>logging_event_exception</em>です。<code>DBAppender</code>を使う前に事前に用意しておかなければなりません。logackの配布物にテーブルを作成するSQLスクリプトが含まれています。フォルダの场所は<em>logback-classic / src / main / java / ch / qos / logback / classic / db / script</em>です。一般的なデータベースそれぞれのスクリプトが用意されています。既の使用するデータベース用のスクリプトが无かったとしても，既存のスクリプトを参考にすれば自分で作るのは简単です。logbackの开発メンバーに教えてくれれば，喜んで先前のリリースに含めるようにします。
		</p>

		<p>あなたが使用しているJDBCドライバが，JDBC3.0で导入された<code>getGeneratedKeys()</code>るならッドをサポートしているなら，绍介したスクリプトでテーブルを作ることに必要に作业はありません。そうはいっても，データベースに対応する<code>SQLDialect</code>を指定しなければなりません。今のところlogbackが対応しているSQL方言は，H2，HSQL，MS SQLServer，MySQL，Oracle，PostgreSQL，SQLite，Sybaseです。</p>

		<p>データベースの种类と， <code>getGeneratedKeys()</code>メソッドの対応状况を表にまとめました。
		</p>

		<table class="bodyTable striped" border="0" cellpadding="4">
			<tbody><tr>
				<th>ータベースの种类</th>
        <th>テストしたバージョン</th>
        <th>したストしたJDBCしたライバのバージョン</th>
        <th>{0} getGeneratedKeys（）{/ 0}メソッドの対応状况<br>
					</th>		

        <th>logbackがSQL方言を提供しているかどうか<br></th>
			</tr>

      <tr>
				<td>DB2</td>
        <td>未テスト</td>
				<td>未テスト</td>
				<td>不明</td>
        <td>无し</td>
			</tr>

      <tr>
        <td>H2</td>
        <td>1.2.132</td>
        <td>--</td>
				<td>不明</td>
        <td>提供している</td>
			</tr>

      <tr>
        <td>HSQL</td>
        <td>1.8.0.7</td>
        <td>--</td>
				<td>未対応</td>
        <td>提供している</td>
			</tr>

      <tr>
        <td>Microsoft SQL服务器</td>
        <td>2005年</td>
        <td>2.0.1008.2（sqljdbc.jar）</td>
				<td>対応済み</td>
        <td>提供している</td>
			</tr>

      <tr>
				<td>的MySQL</td>
        <td>5.0.22</td>
        <td>5.0.8（mysql-connector.jar）</td>        
				<td>対応済み</td>
        <td>提供している</td>
			</tr>

			<tr>
				<td>PostgreSQL的</td>
        <td>8.x</td>
        <td>8.4-701.jdbc4</td>
				<td>未対応</td>
        <td>提供している</td>

			</tr>
		
			<tr>
				<td>甲骨文</td>
        <td>10克</td>
        <td>10.2.0.1（ojdbc14.jar）</td>
				<td>対応済み</td>
        <td>提供している</td>
			</tr>
	
      <tr>
        <td>SQLLite</td>
        <td>3.7.4</td>
        <td>--</td>
        <td>不明</td>
        <td>提供している</td>
      </tr>
	
			
      <tr>
        <td>Sybase SQLAnywhere</td>
        <td>10.0.1</td>
        <td>--</td>
        <td>不明</td>
        <td>提供している</td>
      </tr>

		</tbody></table>
		
		<p>検证したところ，“标准的”なPCでは1つのロギングイベントをデータベースー书き込むのにおよそ10ミリ秒かかるようです。コネクションプールを使えば1ミリ秒くらいは速くなるでしょう。一般的に利用できるほとんどのJDBCドライバではコネクションプールを使うことができるので，ぜひそうしてください。
		</p>
		
		<p><code>DBAppender</code>の设定方法はいろいろありますが，データベースに接続するツールや，データベース自体によって异なります。<code>DBAppender</code>の设定で重要なのは， <code>ConnectionSource</code>です。どういうものか简単に说明しましょう。
		</p>
		
		<p><code>DBAppender</code>たらータベースに接続できたら，ロギングイベントは指定されたデータベースに送信されます。共振したとおり，logbackはロギングイベントを3をのテーブルに格纳します。
		</p>
		
		<p><em>logging_event</em>テーブルには次のようなカラムがあります。</p>
		<table class="bodyTable striped">
			<tbody><tr>
				<th>カラム名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td><b>时间戳记</b></td>
				<td><code>big int</code></td>
				<td>ロギングイベントが作成された时のタイムスタンプ。</td>
			</tr>
			<tr>
				<td><b>formatted_message</b></td>
				<td><code>text</code></td>

				<td><code>org.slf4j.impl.MessageFormatter</code>式书式化されてからロギングイベントに设定されたメッセージ。引数のオブジェクトはメッセージにくっついています。</td>
			</tr>
			<tr>
				<td><b>logger_name</b></td>
				<td><code>varchar</code></td>
				<td>ロギング要求を発行したロガーの名前。</td>
			</tr>
			<tr>
				<td><b>level_string</b></td>
				<td><code>varchar</code></td>
				<td>ロギングイベントのレベル。</td>
			</tr>
			<tr>
				<td><b>reference_flag</b></td>
				<td><code>smallint</code></td>
				<td>
					<p>このフィールドは，ロギングイベントに例外オブジェクトが含まれているか，もしくは， <code>MDC</code>に关连する値が设定されていないかどうかを判定するため，logbackが使用します。
					</p>

					<p>値は<code>ch.qos.logback.classic.db.DBHelper</code>が算出します。ロギングイベントに<code>MDC</code>あるいは<code>Context</code>プロパティが含まれるバア爱，このフラグ値は<em>1</em>になります。例外オブジェクトが含まれる场合は<em>2</em>になります。両方の要素が含まれている场合は<em>3</em>になります。
					</p>
				</td>
			</tr>
			<tr>
				<td><b>呼叫者档案名称</b></td>
				<td><code>varchar</code></td>
				<td>ロギング要求を発行した场所が含まれるファイル名。</td>
			</tr>
			<tr>
				<td><b>caller_class</b></td>
				<td><code>varchar</code></td>
				<td>ロギング要求を発行したクラス名。</td>
			</tr>
			<tr>
				<td><b>caller_method</b></td>
				<td><code>varchar</code></td>
				<td>ロギング要求を発行したメソッド名。</td>
			</tr>
			<tr>
				<td><b>caller_line</b></td>
				<td><code>char</code></td>
				<td>ロギング要求を発行した场所の行番号。</td>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>IDータベースが払いだしたロギングイベントのID。</td>
			</tr>
		</tbody></table>
		
		<p><em>logging_event_property</em>には， <code>MDC</code>または<code>Context</code>に含まれるキーと値を格纳します。次のようなカラムがあります。</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>カラム名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>IDータベースが払いだしたロギングイベントのID。</td>
			</tr>
			<tr>
				<td><b>映射键</b></td>
				<td><code>varchar</code></td>
				<td><code>MDC</code>のキー値。</td>
			</tr>		
			<tr>
				<td><b>映射值</b></td>
				<td><code>text</code></td>
				<td><code>MDC</code>の値。</td>
			</tr>				
		</tbody></table>
		
		<p><em>logging_event_exception</em>テーブルには，次のようなカラムがあります。</p>
		
		<table class="bodyTable striped">
			<tbody><tr>
				<th>カラム名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>IDータベースが払いだしたロギングイベントのID。</td>
			</tr>
			<tr>
				<td><b>一世</b></td>
				<td><code>smallint</code></td>
				<td>完全なスタックトレースを文字列化した际の各行の添字。</td>
			</tr>		
			<tr>
				<td><b>trace_line</b></td>
				<td><code>varchar</code></td>
				<td>スタックトレースの文字列中の1行。</td>
			</tr>				
		</tbody></table>
		
		<p><code>DBAppender</code>を使用した结果をもっと视覚的にわかりやすくお见せしましょう。次に示すのは， <code>DBAppender</code>がMySQLデータベースを使用した场合のスクリーンショットです。
		</p>
		
		<p><em>logging_event</em>テーブル</p>

		<img src="images/chapters/appenders/dbAppenderLE.gif" alt="ロギングイベントテーブル">

		<p><em>logging_event_exception</em>テーブル</p>
		
		<img src="images/chapters/appenders/dbAppenderLEException.gif" alt="ロギングイベント例外テーブル">

		<p><em>logging_event_property</em>テーブル</p>
		
		<img src="images/chapters/appenders/dbAppenderLEProperty.gif" alt="イベントログ记录属性Proーブル">

		
		<h4>连接源</h4>
		
		<p><code>ConnectionSource</code>インターフェイスは，logbackが<code>java.sql.Connection</code> JDBC取得するためのJDBC接続を透过的に取得するためのプラグイン可能な机能を提供するものです。<code>ConnectionSource</code>の実装クラスは3つあります。 <code>DataSourceConnectionSource</code> ， <code>DriverManagerConnectionSource</code> ， <code>JNDIConnectionSource</code>です。
		</p>
		
		<p>最初に， <code>DriverManagerConnectionSource</code>を使ってMySQLデータベースに接続する例を见てみましょう。次の设定ファイルを见てください。
		</p>
		
    <p class="example">例： <code>DBAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/db/append-toMySQL-with-driveManger.xml">logback-examples / src / main / java / chapters / appenders / db / append-toMySQL-with-driveManger.xml</a> ）</p>
    <span class="asGroovy" onclick="return asGroovy('append-toMySQL-with-driverManager');">Groovyとして表示</span>	
    <pre id="append-toMySQL-with-driverManager" class="prettyprint source">&lt;configuration&gt;

  <b>&lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender"&gt;
    &lt;connectionSource class="ch.qos.logback.core.db.DriverManagerConnectionSource"&gt;
      &lt;driverClass&gt;com.mysql.jdbc.Driver&lt;/driverClass&gt;
      &lt;url&gt;jdbc:mysql://host_name:3306/datebase_name&lt;/url&gt;
      &lt;user&gt;username&lt;/user&gt;
      &lt;password&gt;password&lt;/password&gt;
    &lt;/connectionSource&gt;
  &lt;/appender&gt;</b>
  
  &lt;root level="DEBUG" &gt;
    &lt;appender-ref ref="DB" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

		<p>正しいJDBCドライバクラス名を指定してください。ではの例では<code>com.mysql.jdbc.Driver</code>です。<span class="prop">url</span>は<em>jdbc：mysql：//</em>で始まらなければなりません。
		</p>
		
		<p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/db/DriverManagerConnectionSource.html">DriverManagerConnectionSource</a></code>は<code>ConnectionSource</code>の実装クラスで，JDBCの伝统的なやり方（接続用URLに基づくやり方）でデータベース接続を取得します。</p>
		<p>クのクラスは<code>getConnection()</code>メソッドが呼ばれるたびに新しい<code>Connection</code>生成することに注意してください。るクションプーリングをサポートしているJDBCドライバーを使うか，コネクションプーリングを利用する<code>ConnectionSource</code>を自分で実装することをおすすめします。Java EEアプリケーションサーバの上で， <code>javax.sql.DataSource</code> NートしたJNDI実装を利用する场合は，后述する<a href="./appenders.html#JNDIConnectionSource"><code>JNDIConnectionSource</code></a>を参照してください。
		</p>
<!-- 
		
		HAS TO BE TESTED

		<p>
			If you do not have another connection pooling mechanism built
			into your application, you can use the
			<a href="http://jakarta.apache.org/commons/dbcp/index.html">
		  commons-dbcp </a> package from Apache:
		</p>

<pre class="prettyprint source">
  &lt;connectionSource
    class="ch.qos.logback.core.db.DriverManagerConnectionSource"&gt;
    &lt;param name="driver" value="org.apache.commons.dbcp.PoolingDriver"/&gt; 
    &lt;param name="url" value="jdbc:apache:commons:dbcp:/myPoolingDriver"/&gt; 
  &lt;/connectionSource&gt;
</pre>
		
		<p>
			Then the configuration information for the commons-dbcp
			package goes into the file <em>myPoolingDriver.jocl</em> and is
			placed in the classpath. See the
			<a href="http://jakarta.apache.org/commons/dbcp/index.html"> commons-dbcp </a>
			documentation for details.
		</p>
 -->
 
		<p><code>DataSource</code>を使ってデータベースに接続する场合もだいたい同じです。设定ファイルでは<code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/db/DataSourceConnectionSource.html">DataSourceConnectionSource</a></code>を指定してください。JDBCの推奨するやり方（ <code>javax.sql.DataSource</code>に基づくやり方）でデータベース接続（ <code>Connection</code> ）を取得します。
		</p>
	
    <p class="example">例： <code>DBAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/db/append-with-datasource.xml">logback-examples / src / main / java / chapters / appenders / db / append-with-datasource.xml</a> ）</p>	


    <span class="asGroovy" onclick="return asGroovy('append-with-datasource');">Groovyとして表示</span>	
    <pre id="append-with-datasource" class="prettyprint source">&lt;configuration  debug="true"&gt;

  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender"&gt;
     <b>&lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource"&gt;
       
       &lt;dataSource class="${dataSourceClass}"&gt;
       	 </b>&lt;!-- Joran cannot substitute variables
       	 that are not attribute values. Therefore, we cannot
       	 declare the next parameter like the others. 
       	 --&gt;
         <b>&lt;param name="${url-key:-url}" value="${url_value}"/&gt;
         &lt;serverName&gt;${serverName}&lt;/serverName&gt;
         &lt;databaseName&gt;${databaseName}&lt;/databaseName&gt;
       &lt;/dataSource&gt;</b>
       
       &lt;user&gt;${user}&lt;/user&gt;
       &lt;password&gt;${password}&lt;/password&gt;
     &lt;/connectionSource&gt;
  &lt;/appender&gt;

  &lt;root level="INFO"&gt;
    &lt;appender-ref ref="DB" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>

		<p>この设定例ではたくさん変数を使っているので気をつけてください。1つの设定ファイルに接続情报の详细をまとめておくと，logatoと他のフレームワークで设定内容を共有できるので便利です。
		</p>	
		
<!-- TO BE TESTED 

     <p>The connection created by
     <code>DataSourceConnectionSource</code> can be placed in a JNDI
     context by using <code>BindDataSourceToJNDIAction</code>. In that
     case, one has to specify the use of this class by adding a new
     rule to Joran, logback's configuration framework. Here is an
     excerpt of such a configuration file.  </p>
		
<div class="source"><pre>&lt;configuration>
  ..
  <b>&lt;newRule pattern="configuration/bindDataSourceToJNDI" 
           actionClass="ch.qos.logback.core.db.BindDataSourceToJNDIAction"/>
  	    
  &lt;bindDataSourceToJNDI /></b>
  ..
&lt;/configuration></pre></div>

		<p> The <em>newRule</em> element teaches Joran to use specified
		action class with the given pattern.  Then, we simply declare the
		given element. The action class will be called and our connection
		source will be bound to a JNDI context.  </p>

		<p>This is a very powerful capability of Joran. If you'd like to
		read more about Joran, please see the <a
		href="onJoran.html">chapter to Joran</a>.  </p>
		
		-->

    <h4 class="doAnchor" name="JNDIConnectionSource">JNDIConnectionSource</h4>

		<p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/db/JNDIConnectionSource.html">JNDIConnectionSource</a></code>もlogbackの配布物に含まれる<code>ConnectionSource</code>の実装クラスです。名前のとおり，JNDIから<code>javax.sql.DataSource</code>取得し，そこから<code>java.sql.Connection</code>を取得します。<code>JNDIConnectionSource</code> Java，Java EEアプリケーションサーバの内部か，アプリケーションショーバのクライアント（アプリケーションサーバのの） <code>javax.sql.DataSource</code>でリモートアクセスできることを想定しています）で使用することを念头に设计されています。，他にどんな便利机能を提供しているかはともかくとして，少なくともコネクションプーリングを利用することができるはずです。もっと重要なのは， <em>logback.xml</em>で<code>DataSource</code>を定义しなくてもよくなるので，アプリケーションショ<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>にできることです。</p>

    <p>次の例はTomcat用の设定ファイルから抜粋したものです。PostgreSQLで使うための设定ですが，サポートしているデータベースならどれでも同じように动くはずです。</p>

<pre class="prettyprint source">&lt;Context docBase="/path/to/app.war" path="/myapp"&gt;
  ...
  &lt;Resource <b>name="jdbc/logging"</b>
               auth="Container"
               type="javax.sql.DataSource"
               username="..."
               password="..."
               driverClassName="org.postgresql.Driver"
               url="jdbc:postgresql://localhost/..."
               maxActive="8"
               maxIdle="4"/&gt;
  ...
&lt;/Context&gt;</pre>
		
   <p>Java EEアプリケーションサーバでーバで定义した<code>DataSource</code>をlogbackの设定ファイルから参照するのは简単です。</p>
   
   <p class="example">例： <code>JNDIConnectionSource</code>を使った<code>DBAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/db/append-via-jndi.xml">logback-examples / src / main / java / chapters / appenders / db / append-via-jndi.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('append-via-jndi');">Groovyとして表示</span>	
 

<pre id="append-via-jndi" class="prettyprint source">&lt;configuration debug="true"&gt;
  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender"&gt;
    &lt;connectionSource class="ch.qos.logback.core.db.JNDIConnectionSource"&gt;
      <b>&lt;!-- please note the "java:comp/env/" prefix --&gt;</b>
      <b>&lt;jndiLocation&gt;java:comp/env/jdbc/logging&lt;/jndiLocation&gt;</b>
    &lt;/connectionSource&gt;
  &lt;/appender&gt;
  &lt;root level="INFO"&gt;
    &lt;appender-ref ref="DB" /&gt;
  &lt;/root&gt;  
&lt;/configuration&gt;</pre>

		<p>数のクラスは引数无しのコンストラクタで<code>javax.naming.InitialContext</code>のインスタンスを生成するので注意してください。JavaとんどのJava EEコンテナで正常に动作します。Java EEコンテナ以外で动かすときは，JNDIプロバイダのドキュメントで说明されたとおりに<em>jndi.properties</em>を用意してください。
		</p>
		
		<h4 class="doAnchor">コネクションプーリング</h4>
		
		<p>ロギングイベントはかなり高い频度で生成されることがあります。ロギングイベントが生成されるのに合わせてデータベースに登录していなければなりません。そのためには， <code>DBAppender</code>でコネクションプーリングを利用するとよいでしょう。
		</p>
		
		<p><code>DBAppender</code>グをクションプーリングを利用すると，着しく性能が改善することが実证されています。次の设定ファイルは，コネクションプーリング无しでMySQLデータベースにロギングイベントン登录をのです。
		</p>
    
    <p class="example">例：コネクションプーリング无しの<code>DBAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/db/append-toMySQL-with-datasource.xml">logback-examples / src / main / java / chapters / appenders / db / append-toMySQL-with-datasource.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('append-toMySQL-with-datasource');">Groovyとして表示</span>	
    <pre id="append-toMySQL-with-datasource" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender"&gt;
    &lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource"&gt;
      &lt;dataSource class="com.mysql.jdbc.jdbc2.optional.MysqlDataSource"&gt;
        &lt;serverName&gt;${serverName}&lt;/serverName&gt;
        &lt;port&gt;${port$&lt;/port&gt;
        &lt;databaseName&gt;${dbName}&lt;/databaseName&gt;
        &lt;user&gt;${user}&lt;/user&gt;
        &lt;password&gt;${pass}&lt;/password&gt;
      &lt;/dataSource&gt;
    &lt;/connectionSource&gt;
  &lt;/appender&gt;
    
  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="DB" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

		<p>设定の设定ファイルでは，MySQLデータベースに500件のロギングイベントを送信するのになんと5秒もかかりました。あたり，1件あたり10ミリ秒もかかるのです。大规模なアプリケーションショ使いものにならないことがよくわかると思います。
		</p>

		<p><code>DBAppender</code>するにはクションプーリングを利用するには，外部ライブラリが必要です。次の例は<a href="http://sourceforge.net/projects/c3p0">c3p0</a>を使っています。c3p0を利用するには，まずダウンロードして， <em>c3p0-VERSION.jar</em>をクラスパス上に配置しなければなりません。
		</p>

    <p class="example">例： <code>DBAppender</code>グをクションプーリングを利用设置（ <a href="http://logback.qos.ch/xref/chapters/appenders/db/append-toMySQL-with-datasource-and-pooling.xml">logback-examples / src / main / java / chapters / appenders / db / append-toMySQL-with-datasource-and-pooling.xml</a> ）</p>
    <span class="asGroovy" onclick="return asGroovy('append-toMySQL-with-datasource-and-pooling');">Groovyとして表示</span>	
    <pre id="append-toMySQL-with-datasource-and-pooling" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender"&gt;
    &lt;connectionSource
      class="ch.qos.logback.core.db.DataSourceConnectionSource"&gt;
      <b>&lt;dataSource
        class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
        &lt;driverClass&gt;com.mysql.jdbc.Driver&lt;/driverClass&gt;
        &lt;jdbcUrl&gt;jdbc:mysql://${serverName}:${port}/${dbName}&lt;/jdbcUrl&gt;
        &lt;user&gt;${user}&lt;/user&gt;
        &lt;password&gt;${password}&lt;/password&gt;
      &lt;/dataSource&gt;</b>
    &lt;/connectionSource&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="DB" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

		<p>设定の设定ファイルを使った场合，MySQLデータベースに500件のロギングイベントを送信するのにかかった时间は约0.5秒でした。1件あたりの所要时间は1ミリ秒です。10、10倍高速化できたことになります。
		</p>

		<h3 class="doAnchor" name="SyslogAppender">SyslogAppender</h3>

		<p>syslogプロトコルは非常に単纯なプロトコルです。syslogの送信者は小さなメッセージをsyslogの受信者に送信します。一般的に受信者は<em>syslogデーモン</em>や<em>syslogサーバ</em>と呼ばれます。登录は， <a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/SyslogAppender.html"><code>SyslogAppender</code></a> sys使ってリモートのsyslogデーモンにメッセージを送信することができます。
		</p>
		
		<p>SyslogAppenderの设定可能なプロパティは次のとおりです。</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>プロパティ名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td><span class="prop" container="syslog">syslogHost</span></td>
				<td><code>String</code></td>
				<td>syslogサーバのホスト名。</td>
			</tr>
			<tr>
				<td><span class="prop" container="syslog">港口</span></td>
				<td><code>String</code></td>
				<td>syslogサーバーのポート番号。をとんどの场合はデフォルト値の<em>514</em>を使うでしょう。
				</td>
			</tr>
			<tr>
				<td><span class="prop" container="syslog">设施</span></td>
				<td><code>String</code></td>
				<td>
					<p><span class="prop">设施</span>は，メッセージの送信元を区别するためのものです。</p>
					<p><span class="prop">设施</span>オプションには，次のいずれかの文字列を指定しなければなりません。<em>KERN，USER，MAIL，DAEMON，AUTH，SYSLOG，LPR，NEWS，UUCP，CRON，AUTHPRIV，FTP，NTP，AUDIT，ALERT，CLOCK，LOCAL0，LOCAL1，LOCAL2，LOCAL3，LOCAL4，のlocal5，LOCAL6，LOCAL7。</em>大文字小文字は区别されません。</p>
				</td>
			</tr>
      <tr>
        <td><span class="prop" container="syslog">后缀模式</span></td>
				<td><code>String</code></td>
				<td><p><span class="prop">suffixPattern</span>オプションには，syslogサーバに送信されるメッセージ中の任意部分の书式を指定します。<em>[</em>フォルトは<em>” [[thread]％logger％msg”</em>です。<code>PatternLayout</code>で使用できるものは，全て<span class="prop">后缀Pattern</span>に指定することができます。
					</p>
				</td>
			</tr>

      <tr>
        <td><span class="prop" container="syslog">stackTracePattern</span></td>
				<td><code>String</code></td>
				<td><p><span class="prop">stackTracePattern</span>プロパティには，スタックトレースの各行の先头に表示する文字列を指定します。フォルトはタブ文字，つまり“ \ t”です。<code>PatternLayout</code> race使用できるものは，全て<span class="prop">stackTracePattern</span>に指定することができます。</p>
				</td>
			</tr>

			<tr>
				<td><span class="prop" container="syslog">throwable排除</span></td>
				<td><code>boolean</code></td>
				<td><code>true</code> Th指定すると，Throwableに关连付けられているスタックトレースの情报を省略するようになります。デフォルトは<code>falese</code>です。sysので，syslogサーバにはスタックトレースの情报が送信されます。</td>
			</tr>


		</tbody></table>
		
		<p>ロギングイベントに対するsyslogの严重性（重要度）は，ロギングレベルを変换を変のになります。<em>DEBUG</em>は<em>7</em> ， <em>INFO</em>は6， <em>WARN</em>は<em>4</em> ， <em>ERROR</em>は<em>3</em>に変换されます。
		</p>
		
		<p>syslog要求の书式には厳密なルールがあるので， <code>SyslogAppender</code>はレイアウトを使用しません。しかし， <span class="prop">suffixPattern</span>オプションを使えば思った通りの内容を表示することができます。
		</p>
		
		<p><code>SyslogAppender</code>の设定例を见てみましょう。</p>
		
    <p class="example">例： <code>SyslogAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/logback-syslog.xml">logback-examples / src / main / java / chapters / appenders / conf / logback-syslog.xml</a> ）</p>	
    <span class="asGroovy" onclick="return asGroovy('logback-syslog');">Groovyとして表示</span>	
    <pre id="logback-syslog" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="SYSLOG" class="ch.qos.logback.classic.net.SyslogAppender"&gt;
    &lt;syslogHost&gt;remote_home&lt;/syslogHost&gt;
    &lt;facility&gt;AUTH&lt;/facility&gt;
    &lt;suffixPattern&gt;[%thread] %logger %msg&lt;/suffixPattern&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="SYSLOG" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

		<p>がの设定ファイルを试してみるときは，リモートsyslogデーモンが外部からのリクエストを受け付けるようになっていることを先に确认しておいてください。では上，デフォルトではsyslogデーモンはネットワークからのリクエストを拒绝否するようになっていることが多いです。
		</p>
		

    <h3 class="doAnchor" name="SiftingAppender">SiftingAppender</h3>

    <p>名前のとおり， <code>SiftingAppender</code>は设定に基づいてロギングイベントを分配（あるいはふるいにかける）ことができます。例えば， <code>SiftingAppender</code>をユーザーセッションショ基にいてロギングイベントを分配するようになっていれば，ユーザーごとにログファイルを生成するようになるでしょう。
    </p>


    
    <table class="bodyTable striped">
			<tbody><tr>
				<th>プロパティ名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td><span class="prop" container="sift">超时</span></td>
				<td><code><a href="http://logback.qos.ch/apidocs/ch/qos/logback/core/util/Duration.html">Duration</a></code></td>
				<td>は<span class="prop">イムアウト时间</span>を経过してもアクセスされなかったアペンダーは，古くなったものと判断されます。古くなったアペンダーは闭じられて， <code>SiftingAppender</code>から切り离されます。ですフォルトは30分です。</td>
			</tr>
			<tr>
				<td><span class="prop" container="sift">maxAppenderCount</span></td>
				<td><code>integer</code></td>
				<td><code>SiftingAppender</code>最大作成して管理できるアペンダーの最大数を指定します。デフォルトは整数。MAX_VALUEです。</td>
			</tr>
  </tbody></table>

    <p><code>SiftingAppender</code>は実行时にアペンダーを作成します。<code>SiftingAppender</code>の设定で指定された设定テンプレート（ <code>sift要素</code>で囲まれた部分です。后で例を示します）に従って作成します。<code>SiftingAppender</code>子，子アペンダーのライフサイクルを管理する责任があります。たとえば， <code>SiftingAppender</code>は古くなったアペンダー自动的に闭じて削除します。<span class="prop">タイムアウト时间</span>で指定された时间を过ぎてもアクセスの无かったアペンダーを无效とみなすのです。
    </p>

    <p>ロギングイベントが発生したら， <code>SiftingAppender</code>は委譲する子アペンダーを选択します。选択条件は弁别器によって実行时に计算されます。利用者は<code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/sift/Discriminator.html">Discriminator</a></code>で选択条件を指定することができます。例を见てみましょう。
    </p>
 
    <h4>例</h4>

    <p><a href="http://logback.qos.ch/xref/chapters/appenders/sift/SiftExample.html">SiftExample</a>アプリケーションは，アプリケーションが起动したことを表すメッセージをロギングします。后の后，MDCのキー“ uesrid”に“ Alice”を设定して，メッセージをロギングします。该当するコードは次のとおりです。</p>
   
    <p class="source">logger.debug（“应用程序已启动”）; MDC.put（“ userid”，“ Alice”）; logger.debug（“爱丽丝问好”）;</p>

    <p><code>SiftingAppender</code>使う设定ファイルのテンプレートは次のようになっています。</p>


    <p class="example">例： <code>SiftingAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/sift/byUserid.xml">logback-examples / src / main / java / chapters / appenders / sift / byUserid.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('byUserid');">Groovyとして表示</span>

    <pre id="byUserid" class="prettyprint source">&lt;configuration&gt;

  <b>&lt;appender name="SIFT" class="ch.qos.logback.classic.sift.SiftingAppender"&gt;</b>
    &lt;!-- in the absence of the class attribute, it is assumed that the
         desired discriminator type is
         ch.qos.logback.classic.sift.MDCBasedDiscriminator --&gt;
    <b>&lt;discriminator&gt;</b>
      <b>&lt;key&gt;<span class="green">userid</span>&lt;/key&gt;</b>
      <b>&lt;defaultValue&gt;unknown&lt;/defaultValue&gt;</b>
    <b>&lt;/discriminator&gt;</b>
    <b>&lt;sift&gt;</b>
      <b>&lt;appender name="FILE-<span class="green">${userid}</span>" class="ch.qos.logback.core.FileAppender"&gt;</b>
        <b>&lt;file&gt;<span class="green">${userid}</span>.log&lt;/file&gt;</b>
        <b>&lt;append&gt;false&lt;/append&gt;</b>
        <b>&lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;</b>
          <b>&lt;pattern&gt;%d [%thread] %level %mdc %logger{35} - %msg%n&lt;/pattern&gt;</b>
        <b>&lt;/layout&gt;</b>
      <b>&lt;/appender&gt;</b>
    <b>&lt;/sift&gt;</b>
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="SIFT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>
    
    
    <p>discriminator要素に类属性がない<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/sift/MDCBasedDiscriminator.html">场合</a> ， <a href="http://logback.qos.ch/xref/ch/qos/logback/classic/sift/MDCBasedDiscriminator.html">MDCBasedDiscriminator</a>が设定されます。値を别器は， <span class="prop">key</span>プロパティで指定されたキーのMDC値を返します。MDC値がnullの场合は， <span class="prop">defaultValue</span>プロパティで指定した値を返します。
    </p>

    <p><code>SiftingAppender</code>管理子アペンダーの管理机能は独特なものです。上记の例では， <code>SiftingAppender</code>によって复数の<code>FileAppender</code>が作られます。それぞれの<code>FileAppender</code> userー“ userid”でMDCに登录された値によって区别されます。ueー“ uesrid”のMDC値が新しい値のときは，新しい<code>FileAppender</code>インスタンスをゼロから作ります。<code>SiftingAppender</code>は自分が作ったアペンダーを追迹し続けます。30分间使われなかったアペンダーは自动的に闭じられ，破弃されます。
    </p>

    <p><span class="label notice">変数の公开</span>出力先リソースが别々な复数のアペンダーのインスタンスを利用するにはどうしたらいいでしょうか？弁别器のキーが<a href="./configuration.html#variableSubstitution">変数</a>として公开されるので，上记の例の场合は，アペンダーの设定テンプレート内で“ userid”を指定しています。と，子アペンダーに别々の出力先を设定できるようになります。
    </p>

    <p><code>SiftExample</code>アプリケーションの引数に设定ファイル“ byUserid.xml”を指定して実行すると，“ unknown.log”と“ Alice.log”という2つのログファイルが作成されます。
		</p>

    <p><span class="label">ローカルスコープのプ数</span>登录1.0.12から，ネストされたアペンダーからローカルスコープの変数が利用できるようになりました。また， <em><code>sift要素</code>内</em>で<a href="./configuration.html#definingProps">変数を定义</a>したり，変数の<a href="./configuration.html#definingPropsOnTheFly">値</a>を<a href="./configuration.html#definingPropsOnTheFly">実行时に算出</a>できるようになりました。<code>sift要素</code>の外侧で定义された変数の値を组み合わせることもできます。
    </p>

    <h4 class="doAnchor" name="siftGettingTimeoutRight">适切な<span class="prop">タイムアウトウ</span>设定する</h4>

    <p>アプリケーションによっては，适切な<span class="prop">タイムアウト时间</span>を决めるのが难しいことがあります。<span class="prop">タイムアウト时间</span>が短すぎると，ネストされたアペンダーが削除された直后に新しく生成されるようになってしまいます。これは<em>ゴミ渔り</em>と呼ばれる事象です。<span class="prop">タイムアウト时间</span>が长すぎると，立て続けにアペンダーが生成されるとリソース不足になってしまうかもしれません。<span class="prop">maxAppenderCount</span>が小さすぎても同じようにゴミ渔りが発生するかもしれません。
    </p>

    <p>どんな场合でも，ネストされたアペンダーが不要になる箇所を特定するのは简単でしょう。そういう场所が特定できたら，あるいはほぼ确実にそうだと言える场所が特定できたら，そこに书かれているロギンギ式グ<a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/ClassicConstants.html#FINALIZE_SESSION_MARKER">FINALIZE_SESSION</a>マーカーを指定を。SiftingAppenderは<code>FINALIZE_SESSION</code>つけたらーカーを指定されたロギングイベントを见つけたら，关连付けられたアペンダーはもう破弃していいいものと判断します。破弃されることになったアペンダーは，数秒间到着するであろうロギングイベントに备えて活性化した后，何も到着しなければそのままクローズします。
    </p>
    
    <pre class="prettyprint source">import org.slf4j.Logger;
import static ch.qos.logback.classic.ClassicConstants.FINALIZE_SESSION_MARKER;

  void job(String jobId) {
   
    MDC.put("jobId", jobId);
    logger.info("Starting job.");

    ... do whather the job needs to do
    
    // will cause the nested appender reach end-of-life. It will
    // linger for a few seconds.
    logger.info(FINALIZE_SESSION_MARKER, "About to end the job");

    try {
      .. perform clean up
    } catch(Exception e);  
      // This log statement will be handled by the lingering appender. 
      // No new appender will be created.
      logger.error("unexpected error while cleaning up", e);
    }
  }

</pre>

    <h3 class="doAnchor" name="AsyncAppender">AsyncAppender</h3>

    <p>AsyncAppenderは<a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">ILoggingEvent</a>を非同时的にロギングします。してイベントディスパッチャとして机能するので，意味のある仕事をさせるには他のアペンダーを参照させなければなりません。</p>

    <p><span class="label notice">80％を越えると消えてしまう</span> AsyncAppenderはロギングイベントを<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue</a>に蓄积します。<code>AsyncAppender</code>のワーカースレッドは，キューの先头からロギングイベントを取り出して， <code>AsyncAppender</code>に割り当てられたアペンダーに振り分けます。るーの使用量が80％を超えている场合，デフォルトではTRACE，DEBUG，および，INFOレベルのログを舍ててしまいます。これは，ロギングイベントを失ってしまうリスクに见合うだけの性能影响があります。
    </p>

    <p><span class="label">アプリケーションの停止と再デプロイ</span>アプリケーションを停止，あるいは<code>再デプロイ</code>する前に，AsyncAppenderを停止しなければなりません。全てのロギングイベントをキューから吐き出すためです。そのためには， <a href="./configuration.html#stopContext">LoggerContextを停止</a>すればよいです。<code>AsyncAppender</code>を含む全てのアペンダーを闭じます。</p>


    <p><code>AsyncAppender</code>の设定可能なプロパティは次のとおりです。</p>

		<table class="bodyTable striped">
      <tbody><tr>
        <th>プロパティ名</th>
        <th>型</th>
        <th>说明</th>
      </tr>
			<tr>
        <td><span class="prop" container="async">queueSize</span></td>
        <td><code>int</code></td>
        <td>キューの最大容量。はフォルトは256です。
				</td>
			</tr>
      <tr>
        <td><span class="prop" container="async">丢弃阈值</span></td>
        <td><code>int</code></td>
        <td>デフォルトは20％です。使用ーの使用量が阈値を越えたら，INFO以下のロギングイベントは破弃，WARN以上のロギングイベントだけをキューイングするようになります。0を指定するとロギングイベントを破弃しないようになります。
			</td>
			</tr>
      <tr>
        <td><span class="prop" container="async">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>送信者情报の抽出自体に时间がかかることがあります。性能上の兼ね合いにより，デフォルトではロギングイベントをキューに追加するとき，关连する送信者情报を抽出しないようになっています。代わりに，スレッド名などが“軽い”情报だけを<a href="./mdc.html">MDC</a>にコピーします。trueを指定した场合，完全な送信者情报を含めるようになります。
        </td>
      </tr>
    </tbody></table>

    <p>デフォルトでは，イベントキューに登录可能な件数は256件になっています。がーが一杯になると，新しくロギングイベンをントを登录しようとしていたアプリケーションショスショッドは，ワーカースレッドによってキューのロギングイがンがントが处理されるまで，ブロックします。キューの使用量が最大使用量を下回るまで，アプリケーションスレッドはロギング要求を発行できなくなります。したがって，ロギングイベントのバッファ使用量が最大値付近で放置しているとき，このアペンダーはほぼ同时的なロギングをすることになります。これは必ずしも悪いことではありません。はのアペンダーは，ロギングイベントのバッファ使用量が阈値を超えるほどに増加するまでは，ロギング处理よりもアプリケーションの実行时间が长くなるように设计されています。
    </p>

    <p>アをリケーションのスループットを最大化を，アペンダーのイのントキューの大きを最适化ペ必要くつも，それはいくつもの要因が络んでいます。次に示す要因のいずれか，あるいは全てが，拟似的な同时的动作をさせる可能があります。</p>
  
    <ul>
      <li>アプリケーションスレッドが多すぎる</li>
      <li>アプリケーションの呼び出しごとのロギング要求が多すぎる</li>
      <li>ロギングイベントごとに付随する情报が多すぎる</li>
      <li>子アペンダーのレイテンシが遅すぎる</li>
    </ul>

    <p>一般的には，アプリケーションの使用するヒープを减らして，ロギングイベントのキューを大きくすればよいでしょう。
    </p>

    
    <p><span class="label notice">非可逆な振る舞い</span>上记の议论を踏まえながらブロックするする可能を减らすため，AsyncAppenderはデフォルトでは利用可能なキューが最大がの20％未満になったらTRACE，DEBUG，INFOレベルのロギングイグントを破弃し，WARNとERRORレベルのロギングイベントだけを残すようになっています。そうすると，TRACE，DEBUG，INFOレベルのロギングイベントにコストをかけなくてもよくなるので，非同时处理を妨碍げず，高い性能を维持することができます。値きい値<span class="prop">丢弃</span>阈值を0にすればロギングイベントを破弃しないようにすることもできます。
    </p>

    <p class="example">例： <code>AsyncAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conc/logback-async.xml">logback-examples / src / main / java / chapters / appenders / conc / logback-async.xml</a> ）</p>

    <span class="asGroovy" onclick="return asGroovy('asyncAppender');">Groovyとして表示</span>

    <pre id="asyncAppender" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="<b>FILE</b>" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;file&gt;myapp.log&lt;/file&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%logger{35} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  <b>&lt;appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender"&gt;</b>
    <b>&lt;appender-ref ref="FILE" /&gt;</b>
  <b>&lt;/appender&gt;</b>

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="<b>ASYNC</b>" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>
  

		<h3 class="doAnchor" name="WriteYourOwnAppender">アペンダーを自作する</h3>


    <p><code>AppenderBase</code>を使えば简単にアペンダーを自作することができます。基底の衬底クラスでは，フィルターやステータスメッセージの管理などほとんどのアペンダーが备えている机能を提供するものです。派生クラスでやることと言えば， <code>append(Object eventObject)</code>メソッドを実装するだけです。
    </p>

    <p>次に示す<code>CountingConsoleAppender</code>られた，限られた数のロギングイベンをコントをコンソールに出力する自作アペンペーです。指定された数のロギングイベントを处理したらシャットダウンします。ロギングイベントを书式化するために<code>PatternLayoutEncoder</code>を使用します。そして， <code>limit</code>というプロパティを设定することができます。また， <code>append(Object eventObject)</code>メソッド以外にもいくつかメソッドを用意しなければなりません。例を见ればわかりますが，これらのパラメータはlogbackのさまざまな设定の仕组みによって自动的に设定されます。
    </p>
    
    <em>例4 <span class="autoExec"></span> ： <code>CountingConsoleAppender</code> （ <a href="http://logback.qos.ch/xref/chapters/appenders/CountingConsoleAppender.java">logback-examples / src / main / java / chapters / appenders / CountingConsoleAppender.java</a> ）</em>
    <pre class="prettyprint source">package chapters.appenders;

import java.io.IOException;

import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.AppenderBase;


public class CountingConsoleAppender extends AppenderBase&lt;ILoggingEvent&gt; {
  static int DEFAULT_LIMIT = 10;
  int counter = 0;
  int limit = DEFAULT_LIMIT;
  
  PatternLayoutEncoder encoder;
  
  public void setLimit(int limit) {
    this.limit = limit;
  }

  public int getLimit() {
    return limit;
  }
  
  @Override
  public void start() {
    if (this.encoder == null) {
      addError("No encoder set for the appender named ["+ name +"].");
      return;
    }
    
    try {
      encoder.init(System.out);
    } catch (IOException e) {
    }
    super.start();
  }

  public void append(ILoggingEvent event) {
    if (counter &gt;= limit) {
      return;
    }
    // output the events as formatted by our layout
    try {
      this.encoder.doEncode(event);
    } catch (IOException e) {
    }

    // prepare for next event
    counter++;
  }

  public PatternLayoutEncoder getEncoder() {
    return encoder;
  }

  public void setEncoder(PatternLayoutEncoder encoder) {
    this.encoder = encoder;
  }
}</pre>

		<p><code>start()</code>メソッドでは， <code>PatternLayoutEncoder</code>设定されているかチェックしています。がンコーダーが设定されなかった场合，アペンダーの起动は失败となり，エラーメッセージを出力します。
		</p>
		
		<p>この自作アペンダーの见どころは次の2点です。</p>
		
		<ul>

      <li>JavaBeansの规约通りにアクセサを定义したプロパティは，logbackの他の设定と同じように处理されます。<code>start()</code>ドはッドはlogbackの设定处理から自动的に呼び出されるようになっています。アペンダーのさまざまなプロパティの设定と，一贯性を整える役割があります。
			</li>

			<li><code>AppenderBase.doAppend()</code> appッドは派生クラスのappend（）メソッドを呼び出します。実际の出力は<code>append()</code>が行います。式イアウトによってロギンギイグンをントを书式化するのもこのメソッドです。
			</li>
		</ul>
		
		<p><a href="http://logback.qos.ch/xref/chapters/appenders/CountingConsoleAppender.html"><code>CountingConsoleAppender</code></a>は他のアペンダーと同じように定义することができます。设置ファイルの例として<a href="http://logback.qos.ch/xref/chapters/appenders/countingConsole.xml"><em>logback-examples / src / main / java / chapters / appenders / countingConsole.xml</em></a>も见てください。
		</p>
  

		<h2 class="doAnchor" name="logback_access">登录回访</h2>
		
		<p>logback-classicのほとんどのアペンダーと同じものがlogback-accessにもあります。基本的には同じように动きます。以降の节ではそれらの使い方を说明します。
		</p>
		
		<h3 class="doAnchor" name="AccessSocketAppender">SocketAppenderとSSLSocketAppender</h3>
		
		<p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/access/net/SocketAppender.html">SocketAppender</a></code>は，シリアライズした<code>AccessEvent</code>ットワーク上のリモートホストに送信するために设计されています。リモートロギングは，アクセスイベントが重要であろうとなかろうと盗聴できないようになっています。受信したイベントをデシリアライズした后は，自分で生成したロギングイベントと同じように扱うことができます。
		</p>
		
		<p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/access/net/SSLSocketAppender.html">SSLSocketAppender</a></code>基本的な<code>SocketAppender</code>を拡张したもので，安全套接字层（SSL）を介してリモートホストにログを転送します。
    </p>
    
		<p>登录后进入の<code>SocketAppender</code>で设定可能なプロパティは，logback-classicの<code>SocketAppender</code>と同じです。
		</p>

    <h3 class="doAnchor" name="AccessServerSocketAppender">ServerSocketAppender和SSLServerSocketAppender</h3>
    
    <p><code>SocketAppender</code>と同様に， <a href="http://logback.qos.ch/xref/ch/qos/logback/access/net/server/ServerSocketAppender.html"><code>ServerSocketAppender</code></a>はシリアライズした<code>AccessEvent</code>ットワーク上のリモートホストに送信するために设计されています。<code>ServerSocketAppender</code>はサーバとして动作します。外部，外部のクライアントがTCP接続してくるのを待ち受けます。アペンダーに渡されたロギングイベントは，接続している全てのクライアントに配布されます。
    </p>
    
    <p><code><a href="http://logback.qos.ch/xref/ch/qos/logback/access/net/server/SSLServerSocketAppender.html">SSLSocketAppender</a></code>基本的な<code>ServerSocketAppender</code>を拡张したもので，安全套接字层（SSL）を介してリモートホストにログを転送します。
    </p>
    
    <p>登录后进入の<code>ServerSocketAppender</code>で设定可能なプロパティは，logback-classicの<code>ServerSocketAppender</code>と同じです。
    </p>
    
	 	
		<h3 class="doAnchor" name="AccessSMTPAppender">SMTPAppender</h3>
		
		<p>登录后进入の<code><a href="http://logback.qos.ch/xref/ch/qos/logback/access/net/SMTPAppender.html">SMTPAppender</a></code> log，logback-classicと同じように动作します。tだ， <span class="prop">评価器</span>の设定はだいぶ违います。デフォルトでは， <code>URLEvaluator</code>オブジェクトが使用されます。との评価器はロギング要求のURLと突き合わせるURLのリストを持っています。いずれかのURLにマッチするロギング要求が発生したら， <code>SMTPAppender</code>はメールを送信します。
		</p>
		
		<p>登录后进入の<code>SMTPAppender</code>の设定例を见てみましょう。
		</p>
    <p class="example">例： <code>SMTPAppender</code>の设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/access/logback-smtp.xml">logback-examples / src / main / java / chapters / appenders / conf / access / logback-smtp.xml</a> ）</p>

<pre class="prettyprint source">&lt;appender name="SMTP"
  class="ch.qos.logback.access.net.SMTPAppender"&gt;
  &lt;layout class="ch.qos.logback.access.html.HTMLLayout"&gt;
    &lt;pattern&gt;%h%l%u%t%r%s%b&lt;/pattern&gt;
  &lt;/layout&gt;
    
  <b>&lt;Evaluator class="ch.qos.logback.access.net.URLEvaluator"&gt;
    &lt;URL&gt;url1.jsp&lt;/URL&gt;
    &lt;URL&gt;directory/url2.html&lt;/URL&gt;
  &lt;/Evaluator&gt;</b>
  &lt;from&gt;sender_email@host.com&lt;/from&gt;
  &lt;smtpHost&gt;mail.domain.com&lt;/smtpHost&gt;
  &lt;to&gt;recipient_email@host.com&lt;/to&gt;
&lt;/appender&gt;</pre>

		<p>のやり方では，特别な处理プロセスの中で重要な手顺を通ったときにメールを送信するようなことができます。なったールには，トリガとなったWebページにアクセスする一つ前のWebページが含まれます。他の情报を含めることもできます。
		</p>

		<h3 class="doAnchor" name="AccessDBAppender">DBAppender</h3>
		
		<p><a href="http://logback.qos.ch/xref/ch/qos/logback/access/db/DBAppender.html"><code>DBAppender</code></a>アクセスイベントをデータベースに登录するために使用します。
		</p>

		<p><code>DBAppender</code>は<em>access_event</em>テーブルと<em>access_event_header</em>テーブルを使います。いずれも<code>DBAppender</code>を使用する前に准备しなければなりません。はーブルを作成するSQLスクリプトはlogbackの配布物に含まれています。<em>logback-access / src / main / java / ch / qos / logback / access / db / script</em>ディレクトリにあるはずです。一般的なデータベースそれぞれの専用スクリプトがあります。しての使用しているデータベース用のスクリプトが无かったとしても，他のスクリプトを参考にすれば简単に作成できます。っての使っているデータベース用のスクリプトが无かった时は，作成したスクリプトをlogbackプロジェクトに送ってください。
		</p>
		
		<p><em>access_event</em>テーブルのカラムは次のとおりです。</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>カラム名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td><b>时间戳记</b></td>
				<td><code>big int</code></td>
				<td>アクセスイベントの作成时のタイムスタンプ。</td>
			</tr>
			<tr>
				<td><b>requestURI</b></td>
				<td><code>varchar</code></td>
				<td>要求されたURI。</td>
			</tr>
			<tr>
				<td><b>requestURL</b></td>
				<td><code>varchar</code></td>
				<td>要求されたURL。リクエストメソッド，リクエストURI，リクエストプロトコルを组み合わせた文字列です。
				</td>
			</tr>
			<tr>
				<td><b>远程主机</b></td>
				<td><code>varchar</code></td>
				<td>リモートホストの名前。</td>
			</tr>
			<tr>
				<td><b>remoteUser</b></td>
				<td><code>varchar</code></td>
				<td>リモートユーザの名前。
				</td>
			</tr>
			<tr>
				<td><b>remoteAddr</b></td>
				<td><code>varchar</code></td>
				<td>リモートIPアドレス。</td>
			</tr>
			<tr>
				<td><b>协议</b></td>
				<td><code>varchar</code></td>
				<td><em>HTTP</em>または<em>HTTPS</em>などのリクエストプロトコル，。</td>
			</tr>
			<tr>
				<td><b>方法</b></td>
				<td><code>varchar</code></td>
				<td>リクエストメソッド， <em>GET</em>か<em>POST</em>になるでしょう。</td>
			</tr>
			<tr>
				<td><b>服务器名称</b></td>
				<td><code>varchar</code></td>
				<td>リクエストを受け付けたサーバーの名前。</td>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>アクセスイベントのデータベース上のID。</td>
			</tr>
		</tbody></table>
		
		<p><em>access_event_header</em>テーブルには，リクエストのヘッダ情报が登录されます。次のようなものです。</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>カラム名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>アクセスイベントのデータベース上のID。</td>
			</tr>
			<tr>
				<td><b>header_key</b></td>
				<td><code>varchar</code></td>
				<td><em>User-Agent</em>などのリクエストヘッダー名。</td>
			</tr>
			<tr>
				<td><b>header_value</b></td>
				<td><code>varchar</code></td>
				<td><em>Mozilla / 5.0（Windows; U; Windows NT 5.1; fr; rv：1.8.1）Gecko / 20061010 Firefox / 2.0</em></td>
			</tr>
			</tbody></table>

		<p>登录后进入の<code>DBAppender</code>に设定可能なプロパティは，logback-classicの<code>DBAppender</code>でも利用できます。logback-access成为DBAppenderでだけ设置可能なプロパティは次のとおりです。
		</p>
		
		<table class="bodyTable striped">
			<tbody><tr>
				<th>プロパティ名</th>
				<th>型</th>
				<th>说明</th>
			</tr>
			<tr>
				<td>
					<b>
						<span class="prop">insertHeaders</span>
					</b>
				</td>
				<td>
					<code>boolean</code>
				</td>
				<td>trueの场合，ロギング要求に含まれる全てのヘッダ情报を登录するようになります。
				</td>
			</tr>
		</tbody></table>

		<p><code>DBAppender</code>の设定例を见てください。</p>

    <p class="example">例：DBAppenderの设定（ <em><a href="javascript:void(0);">logback-examples / src / main / java / chapters / appenders / conf / access / logback-DB.xml</a></em> ）</p>
    
    <pre class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="DB" class="ch.qos.logback.access.db.DBAppender"&gt;
    &lt;connectionSource class="ch.qos.logback.core.db.DriverManagerConnectionSource"&gt;
      &lt;driverClass&gt;com.mysql.jdbc.Driver&lt;/driverClass&gt;
      &lt;url&gt;jdbc:mysql://localhost:3306/logbackdb&lt;/url&gt;
      &lt;user&gt;logback&lt;/user&gt;
      &lt;password&gt;logback&lt;/password&gt;
    &lt;/connectionSource&gt;
    &lt;insertHeaders&gt;true&lt;/insertHeaders&gt;
  &lt;/appender&gt;

  &lt;appender-ref ref="DB" /&gt;
&lt;/configuration&gt;</pre>


    <h3 class="doAnchor" name="AccessSiftingAppender">SiftingAppender</h3>
   
    <p>logback-accessのSiftingAppenderは，logback-classicのSiftingAppenderとほとんど同じです。主な违いは，デフォルトの弁别器がMDCを参照するものではなく， <a href="http://logback.qos.ch/xref/ch/qos/logback/access/sift/AccessEventDiscriminator.html">AccessEventDiscriminator</a>になっていることです。AccessEventDiscriminatorは，その名のとおり，ネストされたアペンダーを选択するために，AccessEventのフィールドを使用します。指定されたフィールドの値がnullの场合<span class="prop">DefaultValue</span>プロパティの値が使用されます。
    </p>

    <p>AccessEventのフィールドとして指定できるのはCOOKIE，REQUEST_ATTRIBUTE，SESSION_ATTRIBUTE，REMOTE_ADDRESS，LOCAL_PORT，REQUEST_URIです。最初是3つのフィールドは単独で指定することはできません。<span class="prop">AdditionalKey基本要素</span>が必要なので注意してください。</p>
    
    <p>设定ファイルの例を示します。</p>

    <p class="example">例：SiftingAppenderの设定（ <a href="http://logback.qos.ch/xref/chapters/appenders/conf/sift/access-siftingFile.xml">logback-examples / src / main / java / chapters / appenders / conf / sift / access-siftingFile.xml</a> ）</p>
    
    <pre class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="SIFTING" class="ch.qos.logback.access.sift.SiftingAppender"&gt;
    &lt;Discriminator class="ch.qos.logback.access.sift.AccessEventDiscriminator"&gt;
      &lt;Key&gt;id&lt;/Key&gt;
      &lt;FieldName&gt;SESSION_ATTRIBUTE&lt;/FieldName&gt;
      &lt;AdditionalKey&gt;username&lt;/AdditionalKey&gt;
      &lt;defaultValue&gt;NA&lt;/defaultValue&gt;
    &lt;/Discriminator&gt;
    &lt;sift&gt;
       &lt;appender name="access-$id-$username" class="ch.qos.logback.core.FileAppender"&gt;
        &lt;file&gt;byUser/access-$id-$username.log&lt;/file&gt;
        &lt;layout class="ch.qos.logback.access.PatternLayout"&gt;
          &lt;pattern&gt;%h %l %u %t \"%r\" %s %b&lt;/pattern&gt;
        &lt;/layout&gt;
      &lt;/appender&gt;
    &lt;/sift&gt;
  &lt;/appender&gt;
  &lt;appender-ref ref="SIFTING" /&gt;
&lt;/configuration&gt;</pre>


    <p>ではの例では<code>SiftingAppender</code>が<code>FileAppender</code>をネストしています。キー要素の値“ id”は，ネストされた<code>FileAppender</code>で変数として使用することができます。フォルトの弁别器でもある<code>AccessEventDiscriminator</code>はAdditionalKey要素で指定した“用户名”を<code>AccessEvent</code>のセッション属性から探します。指定した属性が无かったら，defaultValue要素の値“ NA”を使用します。userッション属性の“用户名”には，アプリケーションのログインユーザー名が含まれていることを想定しています。ユーザーごとのアクセスログは，由<em>User</em>フォルダの下にユーザー名入りのファイル名で出力されます。
    </p>


    <script src="http://logback.qos.ch/templates/footer.js" type="text/javascript"></script>


  </div>
  

</body></html>