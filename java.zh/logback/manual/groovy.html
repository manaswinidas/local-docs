<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第12章：Groovy配置</title>
    
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">

  </head>
  <body  onload="prettyPrint(); decorate();">

    <script type="text/javascript">prefix='../'</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content" class="chapter">
      
    <h1>第12章：Groovy配置</h1>

    <a href="groovy_ja.html">和訳（日语翻译）</a>
      

    <div class="quote">
      <p><em>做一个不满意的人总比养猪满意。成为一个不满意的苏格拉底总比一个傻瓜满意。如果傻瓜或猪有其他想法，那是因为他们没有更好的经验。
      </em>
      </p>
      <p>-约翰·斯图尔·米尔， <em>功利主义</em></p>
    </div>
    <script src="../templates/creative.js" type="text/javascript"></script>


    <p>特定领域的语言或DSL普遍存在。基于XML的logback配置可以视为DSL实例。由于XML的本质，基于XML的配置文件非常冗长且庞大。此外，logback中相对大量的代码（即Joran）专用于处理这些基于XML的配置文件。Joran支持精美的功能，例如变量替换，条件处理和动态扩展。但是，乔兰不仅是复杂的野兽，而且它提供的用户体验也可以描述为不令人满意或至少是不直观的。
    </p>

    <p>本章描述的基于Groovy的DSL旨在保持一致，直观和强大。您可以在配置文件中使用XML进行的所有操作，也可以使用更短的语法在Groovy中进行。为了帮助您迁移到Groovy样式配置，我们开发了一种<a href="http://logback.qos.ch/translator/asGroovy.html">工具，可以将现有的<em>logback.xml</em>文件自动迁移到<em>logback.groovy</em></a> 。
    </p>


    <h2 class="doAnchor">一般哲学</h2>
    
    <p>通常， <em>logback.groovy</em>文件是Groovy程序。而且，由于Groovy是Java的超集，因此无论您可以在Java中执行什么配置操作，都可以在<em>logback.groovy</em>文件中执行相同的操作。但是，由于使用Java语法以编程方式配置回日志可能很麻烦，因此我们添加了一些特定于回日志的扩展，以使您的生活更轻松。我们努力将特定于Logback的语法扩展的数量限制为绝对最小。如果您已经熟悉Groovy，则应该能够轻松阅读，理解甚至编写自己的<em>logback.groovy</em>文件。那些不熟悉Groovy的人应该仍然发现<em>logback.groovy</em>语法比<em>logback.xml</em>更容易使用。
    </p>

    <p>鉴于<em>logback.groovy</em>文件是具有最少logback特定扩展名的Groovy程序， <em>所有</em>常见的groovy构造（例如类导入，变量定义，字符串（GStrings）中包含的$ {..}表达式的求值和if-else语句）都是在<em>logback.groovy</em>文件中可用。</p>

    <h2 class="doAnchor">自动导入</h2>

    <p><span class="label">从1.0.10开始，</span>为了减少不必要的样板，会自动导入几种常见的类型和包。因此，只要您仅配置内置的附加程序，布局等，就不需要在脚本中添加相应的import语句。当然，对于默认导入未涵盖的类型，您将需要它们。</p>

    <p>这是默认导入的列表：</p>

    <ul>
      <li><span class="code">导入ch.qos.logback.core。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.encoder。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.read。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.rolling。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.status。*;</span></li>
      <li><span class="code">导入ch.qos.logback.classic.net。*;</span></li>
      <li><span class="code">导入ch.qos.logback.classic.encoder。PatternLayoutEncoder;</span></li>
    </ul>

    <p>此外， <span class="code">ch.qos.logback.classic中的所有常量<span class="code">。级别</span>按原样（大写）和小写别名被静态导入。因此，您的脚本可以在没有静态import语句的情况下引用<em>INFO</em>或<em>info</em> 。</span></p>


    <h2 class="doAnchor" name="sift">不再支持SiftingAppender</h2>

    <p><span class="label">从1.0.12版本开始</span> <code>SiftingAppender</code> groovy配置文件不再支持它。但是，如果有需求，则可以重新引入。</p>

    <h2 class="doAnchor" name="entensions">特定于<em>logback.groovy的</em>扩展</h2>

    <p><span class="green">本质上， <em>Logback.groovy</em>语法由下面介绍的六种方法组成。按照其惯常外观的相反顺序。</span>严格来说，这些方法的调用顺序无关紧要，只有一个例外：必须在将附加程序附加到记录器之前对其进行定义。</p>

    

    <!-- ========================================================== -->

    <h3>• <span class="code">root（级别，列表<string>appenderNames = []）</string></span></h3>

    <p>的<code>root</code>方法可用于设置根记录器的级别。作为类型的可选第二个参数<code>List<String></code> ，可用于按名称附加先前定义的追加程序。如果未指定附加名称列表，则假定为空列表。在Groovy中，空列表表示为<code>[]</code> 。</p>

    <p>要将根记录程序的级别设置为WARN，您应编写：</p>

    <pre class="prettyprint source">root(WARN)</pre>

    <p>要将根记录器的级别设置为INFO，并将名为“ CONSOLE”和“ FILE”的附加程序附加到根，您应编写：</p>

    <pre class="prettyprint source">root(INFO, ["CONSOLE", "FILE"])</pre>

    <p>在前面的示例中，假定已经定义了名为“ CONSOLE”和“ FILE”的附加程序。定义附加程序将在稍后讨论。
    </p>

    <!-- ========================================================== -->

    <h3>• <span class="code">logger（字符串名称，级别，列表<string>appenderNames = []，<br>布尔可加性= null）</string></span></h3>

    <p>的<code>logger()</code>方法采用四个参数，其中最后两个是可选的。第一个参数是要配置的记录器的名称。第二个参数是指定记录器的级别。将记录器的级别设置为<code>null</code>强制<a href="architecture.html#effectiveLevel">其</a>从最近的祖先那里<a href="architecture.html#effectiveLevel">继承其级别</a>并分配一个级别。类型的第三个参数<code>List<String></code>是可选的，如果省略则默认为空列表。列表中的附加程序名称将附加到指定的记录器。类型的第四个参数<code>Boolean</code>也是可选的，它控制<a href="architecture.html#additivity">加性标志</a> 。如果省略，则默认为<code>null</code> 。
    </p> 

    <p>例如，以下脚本将“ com.foo”记录器的级别设置为INFO。</p>

       <pre class="prettyprint source">logger("com.foo", INFO)</pre>

    <p>下一个脚本将“ com.foo”记录器的级别设置为DEBUG，并向其附加名为“ CONSOLE”的附加程序。</p>

  <pre class="prettyprint source">logger("com.foo", DEBUG, ["CONSOLE"])</pre>
    
   <p>下一个脚本与上一个脚本相似，不同之处在于，它还将“ com.foo”记录器的可加性标志设置为false。</p>

  <pre class="prettyprint source">logger("com.foo", DEBUG, ["CONSOLE"], false)</pre>


    <!-- ========================================================== -->
    <h3>• <span class="code">appender（字符串名称，类clazz，闭包闭包= null）</span></h3>

    <p>appender方法采用被配置为第一个参数的appender的名称。第二个强制参数是要实例化的附加程序的类。第三个参数是一个包含其他配置指令的闭包。如果省略，则默认为null。</p>

    <p>大多数附加程序需要设置属性并注入子组件才能正常运行。使用“ =”运算符（分配）设置属性。通过调用以该属性命名的方法并将该方法传递给该类以实例化为参数来注入子组件。可以递归地应用此约定，以配置属性以及任何追加程序子组件的子组件。这种方法是<em>logback.groovy</em>脚本的核心，并且可能是唯一需要学习的约定。</p>
    
    <p>例如，以下脚本实例化一个<code>FileAppender</code>名为“ FILE”的<span class="option">文件</span> ，将其<span class="option">文件</span>属性设置为“ testFile.log”，并将其<span class="option">append</span>属性设置为false。类型的编码器<code>PatternLayoutEncoder</code>被注入到appender。编码器的pattern属性设置为“％level％logger-％msg％n”。然后将附加程序附加到根记录器。</p>

    <pre class="prettyprint source">appender("FILE", FileAppender) {
  file = "testFile.log"
  append = true
  encoder(PatternLayoutEncoder) {
    pattern = "%level %logger - %msg%n"
  }
}

root(DEBUG, ["FILE"])</pre>

    <p>
    </p>

    
    <!-- ========================================================== -->        
    <h3>• <span class="code">timestamp（String datePattern，long timeReference = -1）</span></h3>

    <p>的<code>timestamp()</code> method方法返回对应于<code>timeReference</code>参数根据<code>datePattern</code>参数。的<code>datePattern</code>参数应遵循<a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a>定义的约定。如果<code>timeReference</code>值未指定，默认为-1，在这种情况下，将当前时间（即解析配置文件的时间）用作时间参考。根据具体情况，您可能希望使用<code>context.birthTime</code>作为时间参考。
    </p>

    <p>在下一个示例中， <code>bySecond</code>变量以“ yyyyMMdd'T'HHmmss”格式分配给当前时间。然后使用“ bySecond”变量来定义<span class="option">文件</span>属性的值。
    </p>

<pre class="prettyprint source"><b>def bySecond = timestamp("yyyyMMdd'T'HHmmss")</b>

appender("FILE", FileAppender) {
  <b>file = "log-${bySecond}.txt"</b>
  encoder(PatternLayoutEncoder) {
    pattern = "%logger{35} - %msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>

    <!-- ========================================================== -->        
    <h3>• <span class="code">conversionRule（字符串conversionWord，class converterClass类）</span></h3>

    <p>创建自己的<a href="layouts.html#customConversionSpecifier">转换说明符后</a> ，您需要通知logback它的存在。这是一个示例logback.groovy文件，该文件指示logback在以下情况下使用MySampleConverter： <code>%sample</code>遇到转换字。
    </p>

    <pre class="prettyprint source">
import chapters.layouts.MySampleConverter

conversionRule("sample", MySampleConverter)
appender("STDOUT", ConsoleAppender) {
  encoder(PatternLayoutEncoder) {
    pattern = "%-4relative [%thread] %<b>sample</b> - %msg%n"
  }
}
root(DEBUG, ["STDOUT"])</pre>

   <!-- ========================================================== -->
   <h3>• <span class="code">scan（String scanPeriod = null）</span></h3>

    <p>调用scan（）方法将指示logback定期扫描logback.groovy文件以进行更改。每当检测到更改时， <em>都会</em>重新加载<em>logback.groovy</em>文件。</p>

    <pre class="prettyprint source">scan()</pre>

    <p>默认情况下，每分钟扫描一次配置文件是否有更改。您可以通过传递“ scanPeriod”字符串值来指定其他扫描周期。可以以毫秒，秒，分钟或小时为单位指定值。这是一个例子：</p>

    <pre class="prettyprint source">scan("30 seconds")</pre>
    
    <p>如果未指定时间单位，则将时间单位假定为毫秒，这通常是不合适的。如果更改默认扫描周期，请不要忘记指定时间单位。有关扫描如何工作的其他详细信息，请参阅<a href="configuration.html#autoScan">“自动重新加载</a> ” <a href="configuration.html#autoScan">部分</a> 。
    </p>
    
    <!-- ========================================================== -->
  
    <h3>• <span class="code">statusListener（Class listenerClass）</span></h3>

    <p>您可以通过以下方式添加状态监听器： <code>statusListener</code>方法，并将侦听器类作为参数传递。这是一个例子：</p>

    <pre class="prettyprint source">import chapters.layouts.MySampleConverter

<b>// We highly recommended that you always add a status listener just</b>
<b>// after the last import statement and before all other statements</b>
<b>statusListener(OnConsoleStatusListener)</b></pre>
 
    <p><a href="configuration.html#statusListener">状态侦听器</a>在前面的章节中进行了介绍。</p>

    <h3>• <span class="code">jmxConfigurator（字符串名称）</span></h3>

    <p>您可以注册一个<a href="jmxConfig.html"><code>JMXConfigurator</code></a> MBean使用此方法。不带任何参数调用即可使用Logback的默认ObjectName（ <code>ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator</code> ）（对于已注册的MBean）：</p>

    <pre class="prettyprint source">jmxConfigurator()</pre>

    <p>更改值<code>Name</code>键，而不是“默认”键，只需传入一个不同的名称作为<code>jmxConfigurator</code>方法：</p>

    <pre class="prettyprint source">jmxConfigurator('MyName')</pre>

    <p>如果要完全定义ObjectName，请使用相同的语法，但将有效的ObjectName字符串表示形式作为参数传递：</p>

    <pre class="prettyprint source">jmxConfigurator('myApp:type=LoggerManager')</pre>

    <p>该方法将首先尝试将参数用作ObjectName，然后退回到将其视为“ Name”键的值（如果它不表示有效的ObjectName）。</p>

    <!-- ========================================================== -->

    <h2 class="doAnchor" name="internalDSL">内部DSL，也就是说，这一切都很古怪！</h2>

    <p><em>logback.groovy</em>是内部DSL，这意味着其内容作为Groovy脚本执行。因此，所有常规的Groovy构造（例如类导入，GString，变量定义，字符串（GStrings）中包含的$ {..}表达式的求值，if-else语句）都可以在logback.groovy文件中使用。在下面的讨论中，我们将在<em>logback.groovy</em>文件中介绍这些Groovy构造的典型用法。
    </p>


    <h3 class="doAnchor" name="varedef">变量定义和GString</h3>

    <p>您可以在<em>logback.groovy</em>文件中的任何位置定义变量，然后在GString中使用该变量。这是一个例子。</p>

    <pre class="prettyprint source">// define the USER_HOME variable setting its value 
// to that of the "user.home" system property
<b>def USER_HOME = System.getProperty("user.home")</b>

appender("FILE", FileAppender) {
  // make use of the USER_HOME variable
  <b>file = "${USER_HOME}/myApp.log"</b>
  encoder(PatternLayoutEncoder) {
    pattern = "%msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>


    <h3 class="doAnchor" name="printing">在控制台上打印</h3>

    <p>您可以调用Groovy的<code>println</code>在控制台上打印的方法。这是一个例子。</p>

    <pre class="prettyprint source">def USER_HOME = System.getProperty("user.home");
<b>println "USER_HOME=${USER_HOME}"</b>

appender("FILE", FileAppender) {
  <b>println "Setting [file] property to [${USER_HOME}/myApp.log]"</b>
  file = "${USER_HOME}/myApp.log"  
  encoder(PatternLayoutEncoder) {
    pattern = "%msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>


   <h3 class="doAnchor" name="automaticallyExported">自动导出的字段</h3>

   <h4 class="doAnchor" name="hostname">“主机名”变量</h4>

   <p>“主机名”变量包含当前主机的名称。但是，由于作者无法完全解释的作用域规则，“主机名”变量仅在最高范围内可用，而在嵌套范围内不可用。下一个例子应该说明这一点。
   </p>

 <pre class="prettyprint source">// will print "hostname is x" where x is the current host's name
println "Hostname is ${hostname}"

appender("STDOUT", ConsoleAppender) {
  <b>// will print "hostname is null"</b>
  <b>println "Hostname is ${hostname}" </b>
}</pre>

   <p>如果希望在所有作用域中都能看到hostname变量，则需要定义另一个变量，并为其分配'hostname'值，如下所示。</p>

 <pre class="prettyprint source">// define HOSTNAME by assigning it hostname
def HOSTNAME=hostname
// will print "hostname is x" where x is the current host's name
println "Hostname is ${HOSTNAME}"

appender("STDOUT", ConsoleAppender) {
  // will print "hostname is x" where x is the current host's name
  println "Hostname is ${HOSTNAME}" 
}</pre>


   <h3 class="doAnchor" name="everythingIsContext">一切都具有上下文意识，并引用了当前上下文</h3>

   <p><em>logback.groovy</em>脚本的执行在<a href="../xref/ch/qos/logback/core/spi/ContextAware.html">ContextAware</a>对象的范围内完成。因此，始终可以使用“ <code>context</code> '变量，您可以调用<code>addInfo</code> （）， <code>addWarn</code> （）和<code>addError</code> （）将状态消息发送到上下文的方法<code>StatusManager</code> 。</p>

   <pre class="prettyprint source">// always a good idea to add an on console status listener
statusListener(OnConsoleStatusListener)

// set the context's name to wombat
<b>context.name = "wombat"</b>
// add a status message regarding context's name
<b>addInfo("Context name has been set to ${context.name}")</b>

def USER_HOME = System.getProperty("user.home");
// add a status message regarding USER_HOME
<b>addInfo("USER_HOME=${USER_HOME}")</b>

appender("FILE", FileAppender) {
  // add a status message regarding the file property
  <b>addInfo("Setting [file] property to [${USER_HOME}/myApp.log]")</b>
  file = "${USER_HOME}/myApp.log"  
  encoder(PatternLayoutEncoder) {
    pattern = "%msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>


   <h3 class="doAnchor">条件配置</h3>
   
   <p>鉴于Groovy是一种成熟的编程语言，条件语句允许单个<em>logback.groovy</em>文件适应各种环境，例如开发，测试或生产。</p>

   <p>在下一个脚本中，在我们的生产机器pixie或orion之外的主机上激活了控制台附加程序。请注意，滚动文件附加程序的输出目录也取决于主机。</p>
   
   <pre class="prettyprint source">// always a good idea to add an on console status listener
statusListener(OnConsoleStatusListener)

def appenderList = ["ROLLING"]
def WEBAPP_DIR = "."
def consoleAppender = true;

// does hostname match pixie or orion?
if (hostname =~ /pixie|orion/) {
  WEBAPP_DIR = "/opt/myapp"     
  consoleAppender = false   
} else {
  appenderList.add("CONSOLE")
}

if (consoleAppender) {
  appender("CONSOLE", ConsoleAppender) {
    encoder(PatternLayoutEncoder) {
      pattern = "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    }
  }
}

appender("ROLLING", RollingFileAppender) {
  encoder(PatternLayoutEncoder) {
    Pattern = "%d %level %thread %mdc %logger - %m%n"
  }
  rollingPolicy(TimeBasedRollingPolicy) {
    FileNamePattern = "${WEBAPP_DIR}/log/translator-%d{yyyy-MM}.zip"
  }
}

root(INFO, appenderList)</pre>




    <script src="../templates/footer.js" type="text/javascript"></script>

    </div>
  

</body></html>