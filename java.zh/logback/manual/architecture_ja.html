<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第2章アーキテクチャ</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content">

   <h1>第2章アーキテクチャ</h1>

   <div class="quote">
      <p><em>本物の分类学とは，系统学のことなのだ。</em></p>
      <p>-查尔斯·达尔文， <em>物种起源</em></p>

      <p><em>文字で书かれたものを読むだけで，得られた情报を具体的な问题に适用し，読んだことを自分のものとして考えること无しには，问题そのものを学ぶことは，不可能ではないが困难だ。たちは，私たちは自ら発见した时にこそ最も良い学びを得るのだ。</em>
      </p>
      <p>—DONALD KNUTH， <em>计算机编程艺术</em></p>
   </div>


    <script src="../templates/creative.js" type="text/javascript"></script>

    <h2>Logbackのアーキテクチャ</h2>

    <p>logbackの基本的なアーキテクチャは，さまざまな状况に対応できるよう，十分に泛用的になっています。今のところ，logbackは三つのモジュールに分割にいます（logback-core，logback-classic，logback-access）。
    </p>

    <p><em>coreモジュール</em>は，他の二つのモジュールの足回りとして使用されています。<em>classic</em>モジュールは， <em>核心</em>を拡张するものです。classicモジュールは，着しく改善されたバージョンのlog4jとも考えられます。logback-classicは<a href="http://www.slf4j.org">SLF4J API</a>を直接実装しているので，log4jやjava.util.logging（JUL）などの他のロギング実装と切り替えることができます。三つ目の<em>访问</em>と呼ばれるモジュールは，HTTPのアクセスログ机能を提供するため，サーブレットコンテナと统合しています。进入モジュールについては<a href="http://logback.qos.ch/access.html">别のドキュメント</a>に记载されています。
    </p>

    <p>logのドキュメントの残りの部分では，logback-classicモジュールのことを“ logback”と表记しています。
    </p>
    
		<h2>ロガー，アペンダー，レイアウト</h2>
		
		<p>logbackは三つの主要なクラス（ <code>Logger</code> ，0} Appender， <code>Layout</code> ）で成り立っています。つの三つのコンポーネントが协调することで，开発者はメッセージを适切な种类，レベルでロギングできるようになっています。また，书式化や出力先を実行中に変更できるようにもなっています。
		</p>

		<p><code>Logger</code>クラスは，logback-classicモジュールに含まれています。一方， <code>Appender</code>と<code>Layout</code>インタフェイスは，logback-coreモジュールに含まれています。logback-coreモジュールは共通モジュールなので，loggerの责务を含まないのです。
		</p>
    
    <h3 class="doAnchor" name="LoggerContext">ロガーコンテキスト</h3>

		<p>グロギングAPIであっても単纯な<code>System.out.println</code>に胜る第一の，そして最大の利点があります。それは，特定のロギング式を无效にしつつ，他のロギング式には一切影响を与えない机能です。机の机能は，ロギング空间，すなわち，すべてのロギング式からなる空间が，开発者の选択した基准に基いて分类されていることを设定としています。logback-classicモジュールにおいて，この分类はloggerに固有のものです。全てのロガーは<code>LoggerContext</code>に接続します。 <code>LoggerContext</code> 続して，接続してきたロガーを阶层的な木构造として配置する责务があります。
		</p>
			
		<p>ロガーは名前を持ったエンティティです。名前は大文字と小文字が区别され，阶层的な命名规则に従うようになっています。</p>

		<div class="definition">
			<div class="deftitle">名前の阶层</div>
			<p>あるロガーの名前が，他のロガーの名前の中で「。」（ドット）で区切られた初始词となっているとき，それぞれが先祖と子孙となります。自分自身や，自分の子にも祖先がいない场合，そのロガーは亲になります。
			</p>
		</div>

		<p>たとえば， <code>"com.foo"</code>という名前のロガーは， <code>"com.foo.Bar"</code>というロガーの亲になります。同様に， <code>"java"</code>は<code>"java.util"</code>の亲であると同时に， <code>"java.util.Vector"</code>の祖先になります。命名の命名スキームは，ほとんどの开発者がきちんと理解しなければならないものです。
		</p>

		<p>ルートロガーは，ロガーCLASSの最上位に存在するものです。复数の阶层构造すべてに含まれるという意味で，例外的な存在です。他のロガーと同じように，名前で取得することができます。こんな风に。</p>
		
    <pre class="prettyprint source">Logger rootLogger = LoggerFactory.getLogger(<a href="http://www.slf4j.org/apidocs/constant-values.html#org.slf4j.Logger.ROOT_LOGGER_NAME">org.slf4j.Logger.ROOT_LOGGER_NAME</a>);</pre>

		<p>他のロガーも，org.slf4j。LoggerFactoryクラスの静的クラスメソッドである<code>getLogger</code>によって取得することができます。名のメソッドは，パラメータとして欲しいロガーの名前を受け付けます。<code>Logger</code>インタフェイスの基本的なメソッドをいくつか以下に示します。
		

		</p><pre class="prettyprint source">package org.slf4j; 
public interface Logger {

  // Printing methods: 
  public void trace(String message);
  public void debug(String message);
  public void info(String message); 
  public void warn(String message); 
  public void error(String message); 
}</pre>



    <h3 class="doAnchor" name="effectiveLevel">有效レベル（别名レベルの継承）</h3>

		<p>ロガーにはレベルを割り当てることができます。利用できるレベル（TRACE，DEBUG，INFO，WARNおよびERROR）は<code>ch.qos.logback.classic.Level</code>クラスに定义されています。logbackではLevelクラスはfinalとして宣言されており，サブクラス化出来ないことに注意してください。より柔软性のあるアプローチは<code>Marker</code>オブジェクトとして利用可能です。
		</p>

		<p>はルの割り当てられていないロガーは，直近の祖先に割り当てられたレベルを継承します。より正确に言うと次のようになります。</p>

		<div class="definition">
		
      
			<p>与えられたロガー<em>L</em>の有效なレベルは，ロガーCLASSにおいて最初に见つかったロガーのレベルに等しい。等级は<em>L</em>から始まり，ロートロガーに向かって进んでいく。
			</p>
		</div>
	
		<p>最终的に全てのロガーがレベルを継承できるように，ルートロガーには必ずレベルが割り当てられています。デフォルトではDEBUGになっています。</p>

		<p>以下は，レベル継承ルールに従ってロガーに割に当てられた有效レベルの例です。
		</p>

		<em>例1</em>
		<table class="bodyTable">
			<tbody><tr>
				<th>ロガー名</th>
				<th>割り当てられたレベル</th>
				<th>有效レベル</th>
			</tr>
			<tr class="alt">
				<td>ルートロガー</td>
				<td>调试</td>
				<td>调试</td>
		  </tr>
			<tr>
				<td>X</td>
				<td>なし</td>
				<td>调试</td>
		  </tr>

			<tr class="alt">
				<td>XY</td>
				<td>なし</td>
				<td>调试</td>
		  </tr>
			<tr>
				<td>XYZ</td>
				<td>なし</td>
				<td>调试</td>
		  </tr>
  </tbody></table>

		<p>上记の例では，ルートロガーにだけレベルにだけレベ割が当てられています。レベルは<code>DEBUG</code> ，，他の全てのロガーに継承されています。
		</p>

		<em>例2</em>
		<table class="bodyTable">
			<tbody><tr>
				<th>ロガー名</th>
				<th>割り当てられたレベル</th>
				<th>有效レベル</th>
			</tr>
			<tr class="alt" align="left">
				<td>ルート</td>
				<td>错误</td>
				<td>错误</td>
			</tr>
			<tr align="left">
				<td>X</td>
				<td>信息</td>
				<td>信息</td>
			</tr>

			<tr class="alt" align="left">
				<td>XY</td>
				<td>调试</td>
				<td>调试</td>
			</tr>
			<tr align="left">
				<td>XYZ</td>
				<td>警告</td>
				<td>警告</td>
			</tr>
		</tbody></table>

		<p>上记の例では，のロガーにレベルが割り当てられています。レベルの継承は何も仕事をしていません。
		</p>

		<em>例3</em>
		<table class="bodyTable">
			<tbody><tr>
				<th>ロガー名</th>
				<th>割り当てられたレベル</th>
				<th>有效レベル</th>
			</tr>
			<tr class="alt" align="left">
				<td>ルート</td>
				<td>调试</td>
				<td>调试</td>
			</tr>

			<tr align="left">
				<td>X</td>
				<td>信息</td>
				<td>信息</td>
			</tr>
			<tr class="alt" align="left">
				<td>XY</td>
				<td>なし</td>
				<td>信息</td>
			</tr>
			<tr align="left">
				<td>XYZ</td>
				<td>错误</td>
				<td>错误</td>
			</tr>
		</tbody></table>

		<p>上记の例では，ルーロロガーにDEBUG， <code>X</code>にINFO， <code>X.Y.Z</code>にERRORが割り当てられています。<code>X.Y</code>は亲である<code>X</code>からレベルを継承しています。</p>

		<em>例4</em>
		<table class="bodyTable">

			<tbody><tr>
				<th>ロガー名</th>
				<th>割り当てられたレベル</th>
				<th>有效レベル</th>
			</tr>
			<tr class="alt" align="left">
				<td>ルート</td>
				<td>调试</td>
				<td>调试</td>
			</tr>

			<tr align="left">
				<td>X</td>
				<td>信息</td>
				<td>信息</td>
			</tr>
			<tr class="alt" align="left">
				<td>XY</td>
				<td>なし</td>
				<td>信息</td>
			</tr>
			<tr align="left">
				<td>XYZ</td>
				<td>なし</td>
				<td>信息</td>
			</tr>
		</tbody></table>

   
		<p>上记の例では，ルーロロガーにDEBUG， <code>X</code>にINFOが割り当てられています。<code>X.Y</code>および<code>X.Y.Z</code>も，最も近い亲からレベルを継承しています。
		</p>

    <h3 class="doAnchor" name="basic_selection">印字メソッドと基本的な选択ルール</h3>

		<p>定义によると，印字メソッドはロギング要求のレベルを决定するものです。例えば， <code>L</code>がロガーのインスタンスだとすると，式<code>L.info("..")</code>はINFOレベルのロギングであることになります。</p>
		
    
    <p>ロギング要求は，そのロガーの有效レベル以上である场合に<em>有效</em>となります。ギ，ロギング要求は<em>无效</em>になります。向前のように，レベルが割り当てられていないロガーは最も近い祖先から継承します。はのルールは次のように要约できます。
  </p>

     
		<div class="definition">
			<div class="deftitle">基本的な选択ルール</div>

			<p>有效レベル<em>q</em>のロガーに発行されたレベル<em>p</em>のログ要求は， <em>p> = q</em>を満たす场合有效になる。
			</p>
		</div>

		<p>はのルールはlogbackの中核を为すものです。レベルは次のような顺序であることを想定しています。<code>TRACE < DEBUG < INFO < WARN < ERROR</code></p>
				
		<p>以下は，选択ルールをより具体的に示したものです。垂直方向のラベルはロギング要求のレベル<em>p</em>です。レベ水平方向のラベルはロガーの有效レベル<em>q</em>です。行（ロギング要求のレベル）と列（ロガーの有效レベル）の交点が，基本的な选択ルールの适用结果を表しています。
		</p>
		
		<table width="80%">
      <tbody><tr> 
        <td class="lgray_bg" rowspan="2"><br>ロギング要求のレベル<em>p</em></td>
				<td align="center" colspan="6" style="border-top:1px solid #dddddd">ロガーの有效レベル<em>q</em></td>
			</tr>
			<tr align="left">
				<th style="border-bottom:1px solid #dddddd">跟踪</th>
				<th style="border-bottom:1px solid #dddddd">调试</th>
				<th style="border-bottom:1px solid #dddddd">信息</th>
				<th style="border-bottom:1px solid #dddddd">警告</th>
				<th style="border-bottom:1px solid #dddddd">错误</th>	
        <th style="border-bottom:1px solid #dddddd">关</th>    			
			</tr>
			<tr align="left">
				<th class="lgray_bg">跟踪</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>

			<tr align="left">
				<th class="lgray_bg">调试</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>
			<tr align="left">
				<th class="lgray_bg">信息</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>
			<tr align="left">
				<th class="lgray_bg">警告</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="redBold">没有</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>
			<tr align="left">
				<th class="lgray_bg">错误</th>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
				<td><span class="greenBold">是</span></td>
        <td><span class="redBold">没有</span></td>
			</tr>		
		</tbody></table>
		
		<p>选択ルールのコード例を次に示します。</p>

		<pre class="prettyprint source">import ch.qos.logback.classic.Level;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
....

// "com.foo"という名前のロガーを取得します。
// ロガーのインスタンスはレベルを設定するために ch.qos.logback.classic.Logger とします。
ch.qos.logback.classic.Logger logger = 
        (ch.qos.logback.classic.Logger) LoggerFactory.getLogger("com.foo");
// レベルに<span class="blue">INFO</span>を設定します。setLevel() メソッドは logback のロガーにしかありません。
.setLevel(Level. <span class="blue">INFO</span>);

Logger barlogger = LoggerFactory.getLogger("com.foo.Bar");

// このロギング要求は有効です。<span class="green bold">WARN</span> &gt;= <span class="blue">INFO</span>
logger.<span class="green bold">warn</span>("Low fuel level.");

// このロギング要求は無効です。<span class="green bold">DEBUG</span> &lt; <span class="blue">INFO</span>. 
logger.<span class="green bold">debug</span>("Starting search for nearest gas station.");

// "com.foo.Bar" という名前のロガーは、"com.foo" ロガーからレベルを継承します。
// したがって、このロギング要求は有効です。<span class="green bold">INFO</span> &gt;= <span class="blue">INFO</span>. 
barlogger.<span class="green bold">info</span>("Located nearest gas station.");

// このロギング要求は無効です。<span class="green bold">DEBUG</span> &lt; <span class="blue">INFO</span>.
barlogger.<span class="green bold">debug</span>("Exiting gas station search");</pre>

    <a name="RetrievingLoggers"></a>
		<h3>ロガーの取得</h3>
		<p><code><a href="http://logback.qos.ch/apidocs/org/slf4j/LoggerFactory.html#getLogger(java.lang.String)">LoggerFactory.getLogger</a></code>を呼び出しましょう。同じ名前なら，常に同じロガーインスタンスへの参照を返します。
		</p>

		<p>例えば次のような场合は常に同じインスタンスを返します。</p>
		<pre class="prettyprint source">Logger x = LoggerFactory.getLogger("wombat"); 
Logger y = LoggerFactory.getLogger("wombat");</pre>

		<p>
			<code>x</code>と<code>y</code>は， <em>完全に</em>同じオブジェクトを参照します。
		</p>

		<p>ようにのように，一度ロガーのインスタンスを设定すれば，わざわざ参照を渡さなくても，コード中のどこででも同じインスタンスを取得することができます。现実世界の生物の亲子关系とは矛盾していますが，logbackのロガーは亲と子のどちらが先に生成されても问题ありません。ただし，「亲」ロガーから子孙ロガーを见つけようとするときは，事前にインスタンス化しておく必要があります。
		</p>
		<p>logbackの実行环境の设定は，アプリケーションの初期化时に行われるのが一般的です。设定ファイルを読み込むようにするとよいでしょう。方法についてはすぐ后で说明します。
		</p>
		<p>logbackでは， <em>コンポーネント</em>ごとにロガーの名前を付けるのが简単です。ロガーをクラスごとにインスタンス化すれば，それぞれのロガーの名前はクラスの完全名になります。これはロガーを定义する简単かつ便利な方法です。クラスの完全名であるロガーの名前をログに出力するようになっていれば，メッセージを出力した箇所を特定するのは简単です。戦，これはロガーの命名戦略としてごく一般的な方法の一つでしかありません。logback自体にロガーのインスタンス数の制限はありません。，开発者は自由に名前を付けることが出来ます。
		</p>

		<p>とはいえ，ロガーの名前にそれが置かれたクラスの完全名を付けることは，一般的に最も良い方法であるということが共通认识になっています。
		</p>

    <a name="AppendersAndLayouts"></a>
    <h3>アペンダーとレイアウト</h3>

		<p>ロガーのレベルに応じてロギンギ要求の有效无效を选択できる机能は，logbackの机能の一部でしかありません。logbackは，ロギング要求を复数の宛先の送りつけることができます。logbackでは，宛先のことをアペンダーと呼びます。现在利用できるアペンダーには，コンソール，ファイル，MySQLやPostgreSQLやOracleなどのデータベースへのリモート接続，JMS，リモートSyslogデーモンなどがあります。

      <!--It is also possible to log asynchronously. -->
		</p>

		<p>ロガーには一つ以上のアペンダーを割り当てることができます。</p>

    <p>指定されたロガーにアペンダーを割り当てるには， <code><a href="http://logback.qos.ch/apidocs/ch/qos/logback/classic/Logger.html#addAppender(ch.qos.logback.core.Appender)">addAppender</a></code>メソッドを使います。有效なロギング要求は，ロガーに割り当てられた全てのアペンダーについて，阶层关系が上位のアペンダーから顺に転送されます。别の言い方をすると，ロガー阶からアペンダーも引き継ぐということです。例えば，ルートロガーにコンにコールアペンダーを割り当てたなら，有效なロギング要求は少なくともコンソールに出力されることになります。さらに，ロガー<em>大号</em>にファイルアペンダーが割り当てられたなら<em>，L</em>とその子孙全てにおいて，有效なロギング要求はコンソールとファイルの両方に出力されます。ロガーの加法フラグをfalseに设定に，アペンダーを継承しないように振る舞いを変更することができます。
		</p>

		<p>アペンダーの加算ルールをまとめると次のようになります。
		</p>
		<div class="definition">

			<h4 class="deftitle"><a href="./01-architecture.html#additivity" name="additivity">アペンダーの加算性</a></h4>

			<p>ロガー<em>L</em>のログ出力は， <em>L</em>とその祖先も割り当てられた全てのアペンダーに転送される。これが「アペンダーの加算性」の定义である。
			</p>

			<p>ロガー<em>L</em>の祖先<em>P</em>のaditivityフラグが假の场合， <em>L</em>の出力は<em>L</em>自身に割り当てられたアペンダーと，祖先<em>P</em>に割り当てられたアペンダーだけに転送される。<em>P</em>よりも祖先のロガーのアペンダーには転送されない。</p>

			<p>adフォルトでは，ロガーのaditivityはtrueになっています。
			</p>

		</div>以上を踏まえた例を次の表に示します。<table class="bodyTable">
			<tbody><tr>
				<th>ロガー名</th>
				<th>割り当てられたアペンダー</th>
				<th>aditivityフラグ</th>
				<th>宛先</th>
				<th>コメント</th>
			</tr>
			<tr>
				<td>根</td>
				<td>A1</td>
				<td>适用できません</td>
				<td>A1</td>

				<td>ルートロガーは，ロガーCLASSの最上位になるため，亲和力フラグは无效です。
				</td>
			</tr>
			<tr class="alt">
				<td>X</td>
				<td>A-x1，A-x2</td>
				<td>真正</td>
				<td>A1，A-x1，A-x2</td>
				<td>「x」のアペンダーとルートロガーのアペンダーが対象</td>
			</tr>
			<tr>
				<td>y</td>
				<td>なし</td>
				<td>真正</td>
				<td>A1，A-x1，A-x2</td>
				<td>「x」のアペンダーとルートロガーのアペンダーが対象</td>
			</tr>
			<tr class="alt">
				<td>y</td>
				<td>a-xyz1</td>
				<td>真正</td>
				<td>A1，A-x1，A-x2，A-xyz1</td>
				<td>「xyz」のアペンダーと「×」のアペンダーとルートロガーのアペンダーが対象</td>
			</tr>
			<tr>
				<td>安全</td>
				<td>一秒</td>
				<td class="blue"><span class="blue">假</span></td>
				<td>一秒</td>

				<td>aditivityフラグが<code>false</code>なので，アペンダーは加算されません。A-secだけが対象になります</td>
			</tr>
			<tr class="alt">
				<td>安全访问</td>
				<td>なし</td>
				<td>真正</td>				
        <td>一秒</td>
				<td>「安全」の积极性<code>false</code> securityので，「安全」のアペンダーだけが加算されます</td>
			</tr>
		</tbody></table>


		<p>利用者は，ほとんどの场合出力先だけでなく出力形式もカスタマイズしたがるでしょう。アペンダーと<em>レイアウトウ</em>关连付けることで実现できます。レイアウトは，利用者の指定したとおりにロギング要求を整形するものです。一方，アペンダーは整形されたメッセージを指定された宛先に転送します。利用者は，logbackの标准配布物に含まれる<code>PatternLayout</code>を使って，C言语の<code>printf</code>关数で使うような変换指示子によって出力形式を指定します。
		</p>

		<p>PatternLayoutの変换パターンが“％-4relative [％thread]％-5level％logger {32}-％msg％n”のとき，出力は次のようになります。</p>

		<div class="prettyprint source"><pre>176  [main] DEBUG manual.architecture.HelloWorld2 - Hello world.</pre></div>

		<p>最初のフィールドはプログラムが开始开始してからの経过时间をミリ秒にしたものです。二番目のフィールドはログ要求を行ったスレッドです。三番目のフィールドはログ要求のレベルです。四番目のフィールドはログ要求を行ったロガーの名前です。'-'より后のテキストはログ要求に指定されたメッセージになります。</p>


		<h3 class="doAnchor" name="parametrized">パラメータ化ロギング</h3>

		<p>ogbakc-classicのロガーは， <a href="http://www.slf4j.org/api/org/slf4j/Logger.html">SLF4JのLoggerインェーフェイス</a>に含に一つ以上のパラメータを受け取る出力メソッドを実装しています。のメソッドは，コードの読みやすさへの影响を最小限に抑えながら，性能を改善するために用意されたものです。
		</p>

		<p></p>

		<pre class="prettyprint source">logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));</pre>

		<p>こんな书き方をしているロギンギ式グ场合，メッセージを组み立てるために，整体<code>i</code>と<code>entry[i]</code>を文字列にするコスト，文字列を连结する中间的なコストがかかるでしょう。ギ，ロギング要求が有效かどうかに关わらずかかってしまうコストです。
		</p>

		<p>ラメータ构筑のコストを回避するには，ロギング式全体をテスト条件で囲む方法があります。
		</p>

		<pre class="prettyprint source">if(logger.isDebugEnabled()) { 
  logger.debug("Entry number: " + i + " is " + String.valueOf(entry[i]));
}</pre>


		<p>，と，DEBUGレベルのロギング要求が无效になっていればパラメータ构筑のコストはかからないでしょう。しかし，有效になっている场合， <code>debugEnabled</code>と<code>debug</code>のそれぞれでロガーのレベルが有效かどうかを判定することになってしまいます。ロガーのレベルの评価はロギング要求に対して1％未満の时间しかかからないので，実际のオーバーヘッドは些细なものです。</p>

		<h4>より良い方法</h4>

		<p>メッセージフォーマットに基づいた便利な方法があります。<code>entry</code>が何らかのオブジェクトを指すものとして，次のように书くことが出来ます。</p>


		<pre class="prettyprint source">Object entry = new SomeObject(); 
logger.debug("The entry is {}.", entry);</pre>

		<p>ロギング要求が有效かどうかを判断した后にだけ，そして，それが有效な场合にだけ，ロガーはメッセージを书式化して，'{}'を<code>entry</code>の文字列表现で置き换えます。ギ，ロギング要求が无效な场合，このやり方だとパラメータ构筑のコストが発生しません。
		</p>


		<p>以下の二行からはまったく同じ出力が得られます。しかし，ロギング要求が<em>无效</em>な场合，二行目のやり方は一行目のやり方に比べて少なくとも30倍は遅くなるでしょう。
		</p>

		<pre class="prettyprint source">logger.debug("The new entry is "+entry+".");
logger.debug("The new entry is {}.", entry);</pre>


		<p>二つ替换场所を指定することもできます。たとえば，次のように书くことができます。</p>

		<pre class="prettyprint source">logger.debug("The new entry is {}. It replaces {}.", entry, oldEntry);</pre>

		<p>引数が三つ以上になる场合， <code>Object[]</code>でラップしなければなりません。たとえば，次のように书くことができます。</p>


		<pre class="prettyprint source">Object[] paramArray = {newVal, below, above};
logger.debug("Value {} was inserted between {} and {}.", paramArray);</pre>

  
  <a name="UnderTheHood"></a>
  <h3>内部実装を覗いてみよう</h3>

  <p>log，登录の中心的なコンポーネントについて绍介してきました。次のステップに进む准备は完璧です。利用者がlogbackの出力メソッドを呼び出した出した时に，logbackフレームワークの内部でどんなことが起きているのか见ていきましょう。利用者が<em>com.wombat</em>という名前のロガーについて， <code>info()</code>を呼び出した时の様子を分析してみましょう。
  </p>

  <h4>ステップ1。フィルタチェインの决定</h4>

  <p><code>TurboFilter</code>が存在するならそれが呼び出されます。Turbo Filterコンコストにまたがる阈値を设定できるし，いろんなイベントを舍てることができます。舍てるイベントは， <code>Marker</code> ， <code>Level</code> ， <code>Logger</code> ，メッセージ， <code>Throwable</code>といったロギング要求に关系する情报から判断します。フィルタチェインの结果が<code>FilterReply.DENY</code>だったら处理中のロギング要求はその时点で破弃します。 <code>FilterReply.NEUTRAL</code> だったら次のステップ（ステップ2）に进みます。 <code>FilterReply.ACCEPT</code> だったら，次のステップを无视してステップ3にジャンプします。
  </p>

  <h4>ステップ2。<a href="./02-architecture.html#basic_selection">基本的な选択ルール</a>の适用</h4>

  <p>レベのステップでは，登录はロガーの有效レベルとロギング要求のレベルを比较します。比较した结果ロギング要求が无效の场合は残りの处理は行わず，ロギング要求を破弃します。ロギング要求が破弃されなければ，次のステップに进みます。
  </p>

  <h4>ステップ3。<code>LoggingEvent</code>オブジェクトの作成</h4>

  <p>ロギング要求がここまでのフィルタを通过したら，logbackはロギング要求に含まれる必要な情报を全て格纳した<code>ch.qos.logback.classic.LoggingEvent</code>オブジェクトを作成します。， <code>MDC</code>などが含まれます。フィールドによってはレイジーな初期化となるものがあります。，必要になった时点で初期化される，ということです。<code>MDC</code>ギ，ロギング要求の付加情报となります。MDCについては<a href="./08-mdc.html">以降の章</a>で详しく说明します。</p>

  <h4>ステップ4。アペンダーの起动</h4>

  <p><code>LoggingEvent</code>オブジェクトを作ったら，登录は利用可能な全てのアペンダーについて<code>doAppend()</code>メソッドを呼び出します。ロガーコンテキストから受け継いだアペンペーが対象になります。
  </p>

  <p>logbackの配布物に含まれているアペンダーは，すべて<code>AppenderBase</code>抽象クラスを継承しています。<code>doAppend()</code>ドはッドは同步として宣言されており，スレッドセーフであることが保证されています。<code>AppenderBase</code>クラスの<code>doAppend()</code>メソッドでは，アペンダーに割に当てられたフィルターが存在する场合，それを呼び出します。カスタムフィルターは，実行时にアペンダーに割り当てることができるフィルターのことです。<a href="./07-filters.html">别の章</a>で说明しています。
  </p>

  <h4>ステップ5。书ッセージの书式化</h4>

  <p>ロギングイベントを书式化するのはアペンダーの责任です。てでは，全てでは无いにしてもいくつかのアペンダーは书式化のタスクをレイアウトに委譲します。レイアウトは， <code>LoggingEvent</code>のインスタンスを书式化して，文字列として返します。アペンダーによっては（ <code>SocketAppender</code>など），ロギングイベントを文字列に変换するのではなく，シリアライズすることがあります。つまり，アペンダーはレイアウトを持っていることもあるし，持っていないこともあるのです。
  </p>

  <h4>ステップ6。<code>LoggingEvent</code>の送信</h4>

  <p>完全に书式化されたロギングイベントは，それぞれのアペンダーの宛先に送信されます。
  </p>
  
  <p>UMのUMLのシーケンス図は，ここまでで绍介してきたステップ全体を概観するものです。なサクリックすればより大きなサイズの図を见ることができます。
  </p>

  <a href="underTheHood.html">
    <img src="images/chapters/architecture/underTheHoodSequence2_small.gif">
  </a>

  
  <h3 class="doAnchor" name="performance">表现</h3>

  <p>ロギングについてよく议论の的になるスの一つとして，必要な计算コストがあります。にの规模のアプリケーションであっても，规模に及ぶログ要求を生成することになるので，性能に关心があるのは当然です。开発中に私たちが一番多くの力と时间を费やしたのは，loggingの性能を测定することと，性能を调整することでした。私たちがどれだけの労力を费やしてきたとしてもそれとは关系无く，利用者は次のような性能问题に注意しなければなりません。
  </p>

  <h4>问题1。ロギングが完全にオフになっているときの性能</h4>

  <p>ルートロガーのレベルに最高レベルの<code>Level.OFF</code>を设定すると，完全にロギングをオフにすることができます。完全にロギングをオフにすると，ロギング要求のコストはメソッド呼び出しと整体比较だけになります。3.2GHz奔腾Dのマシンの场合，通常ならそのコストは20マイクロ秒程度になります。
  </p>

  <p>しかし，メソッド呼び出しによっては隠れたパラメータ构筑のコストが含まれます。例えば，ロガー<em>x</em>について次のように実装されていると</p>
  
  <pre class="prettyprint source">x.debug("Entry number: " + i + "is " + entry[i]);</pre>

  <p>パラメータ构筑のコストが含まれることになります。整数，整体<code>i</code>と<code>entry[i]</code>を文字列に変换するコストと，中间文字列を连结するコストです。これらのコストは，メッセージがログに出力されるかどうかは关系无くかかります。
  </p>

  <p>ラメータ构筑のコストは，パラメータの数にもよりますが非常に高くなることがあります。LFラメータ构筑のコストを回避するため，SLF4Jのパラメータ化されたロギングを利用することができます。</p>

  <pre class="prettyprint source">x.debug("Entry number: {} is {}", i, entry[i]);</pre>

  <p>パのやり方の场合パラメータ构筑のコストは発生しません。前の<code>debug()</code>メソッドの呼び出し方に比べると，圧倒的に速くなります。メッセージが书式化されるのは，割り当てられたアペンダーにロギング要求が送信されるときだけだからです。な，メッセージを书式化するコンポーネントには，高度な最适化が行われています。
  </p>

  <p>そうはいっても，非常に范囲の狭いループ中にロにンギ式グと，呼び出し回数が非常におおくなります。性能が性能する可能があるため，何のメリットもありません。てもとえロギングがオフになっていても，狭い范囲のループにロギンギ式が含まれていると，アプリケーションの动作が缓慢になってしまいます。それに，ロギングをオンにすると非常に大量の（そして役に立たない）出力が生じます。
  </p>

  <h4>问题2。ロギングをオンにした状态で，ロギングするかどうかを决定する场合の性能</h4>

  <p>logbackでは，ロガーCLASSを渡り歩く必要がありません。ロガーは，インスタンスが作成された时点で自分の有效レベル（ロガー自体のレベルと受け継いたレベルを考虑した结果）を知っています。亲ロガーのレベルを変更すると，全ての子ロガーは変更通知を受け取ります。したがって，ロガーは祖先ロガーに问い合わせること无く，有效レベルに基いてロギング要求を受け付けるか拒否するかを瞬间に判断することができます。
  </p>


  <h4>问题3。式际にロギングする（书式化と出力デバイスへの书き込み）</h4>

  <p>グ，ログ出力を书式化し，宛先へ送信するコストです。ォイアウト（フォーマッター）の处理を出来る限り高速化するために，同じように过大な労力を费やしました。同じことがアペンダーにも当てはまります。ローカルマシン上のファイルにロギンギとき，実际のロギングのコストは9マイクロ秒から12マイクロ秒程度になりました。リモートサーバ上のデータベースにロギングするとき，これが数ミリ秒に跳ね上がります。
  </p>

  <p>logbackは豊富な机能を备えていますが，设计上の第一目标は高速な実行速度であり，第二目标として挙げられていたのは信頼性だけでした。logbackのコンポーネントは，性能改善のため何度も书き直されています。
  </p>

    
  <script src="../templates/footer.js" type="text/javascript"></script>
</div>

</body></html>