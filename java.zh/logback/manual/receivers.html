<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第14章接收者</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">    
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">      
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>    
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>

    <div id="content">

      <h1>第14章接收者</h1>

    <a href="receivers_ja.html">和訳（日语翻译）</a>

      <div class="quote">

        <p><em>除非您有勇气看不见海岸，否则您将无法畅游新视野。</em></p>
  
        <p>—威廉·福克纳</p>
      </div>


      <script src="../templates/creative.js" type="text/javascript"></script>
      <script src="../templates/setup.js" type="text/javascript"></script>
    
      <h2 class="doAnchor" name="whatIsAReceiver">什么是接收器？</h2>
    
      <p><em>接收器</em>是一个Logback组件，它从远程附加程序接收日志事件，并根据本地策略记录每个接收到的事件。使用基于套接字的附加器和接收器的组合，可以构建复杂的拓扑，以便在网络上分发应用程序日志记录事件。</p>
  
      <p>接收器扩展<a href="../xref/ch/qos/logback/classic/net/ReceiverBase.html"><code>ch.qos.logback.classic.net.ReceiverBase</code></a>类。由于接收方可以扩展此类，因此接收方可以参与Logback组件<a href="../xref/ch/qos/logback/core/spi/LifeCycle.html">LifeCycle，</a>并且接收方可以使用<a href="../xref/ch/qos/logback/core/spi/ContextAware.html">ContextAware</a> 。</p>
    
      <p>过去，Logback提供了通过Logback通过网络连接记录事件传递的支持。 <code>SocketAppender</code>和相应的<code>SimpleSocketServer</code> 。附加程序充当客户端，启动与服务器应用程序的网络连接，并通过网络连接传递日志记录事件。接收器组件和相应的附加程序支持提供了更大的灵活性。</p>
    
      <p>与其他任何logback组件一样，在<em>logback.xml中</em>配置了接收器组件。这样就可以在配置接收器组件时利用<a href="onJoran.html">Joran</a>的全部功能。此外， <em>任何</em>应用程序都可以通过简单地配置一个或多个接收器组件来接收来自远程附加程序的日志事件。</p>
    
      <p>附加方和接收方之间的连接启动可以在任一方向上进行。接收者可以充当服务器的角色，被动地侦听来自远程附加客户端的连接。替代地，接收者可以充当客户端角色，以发起到与充当服务器角色的远程附加程序的连接。无论附加器和接收器的各自作用如何， <em>日志事件始终从附加器流向接收器</em> 。</p>
    
      <p>在某些情况下，允许接收者启动与附加程序的连接的灵活性特别有用：</p>
      <ul>
        <li>出于安全原因，中央日志记录服务器可能位于不允许进入连接的网络防火墙后面。使用充当客户端角色的接收器组件，中央日志记录服务器（在防火墙内部）可以启动与感兴趣的应用程序（在防火墙外部）的连接。
        </li>
        <li>开发人员工具（例如IDE插件）和企业管理应用程序通常希望能够访问正在运行的应用程序的日志事件流。传统上，Logback通过要求接收者应用程序（例如在IDE中运行的开发人员工具）充当服务器角色来支持此功能（例如在Logback Beagle中），从而被动地侦听来自远程附加程序的连接。事实证明，这很难管理，尤其是对于在开发人员工作站上运行的工具（可能确实是通过移动设备）。但是，现在可以使用充当客户端角色的Logback接收器组件，启动与远程附加程序的连接以接收用于本地显示，过滤和警报的日志记录事件，来实现此类工具。
        </li>
      </ul>

      <p>登录配置可以包括以服务器或客户端角色的任何组合形式起作用的任意数量的接收器组件。唯一的限制是，充当服务器角色的每个接收者都必须侦听一个不同的端口，并且充当客户端角色的每个接收者都将恰好连接到一个远程附加程序。</p>
    
      <h2 class="doAnchor" name="receiverServerComponents">充当服务器角色的接收者</h2>
    
      <p>配置为充当服务器角色的接收器可以被动地侦听来自远程附加程序的传入连接。这在功能上等同于使用独立<code>SimpleSocketServer</code>应用程序，除了使用接收器组件之外， <em>任何</em>使用Logback Classic的应用程序都可以通过简单地在<em>logback.xml中</em>配置接收器来接收来自远程附加程序的记录事件。</p>
        
      <p>
        <img border="1" src="images/chapters/receivers/serverSocketReceiver.png">
      </p>

      <p>Logback包括两个充当服务器角色的接收器组件； <a href="../xref/ch/qos/logback/classic/net/server/ServerSocketReceiver.html"><code>ServerSocketReceiver</code></a>及其启用了SSL的子类型<a href="../xref/ch/qos/logback/classic/net/server/SSLServerSocketReceiver.html"><code>SSLServerSocketReceiver</code></a> 。这两个接收器组件均设计为接受来自传入设备的连接<code>SocketAppender</code> （要么<code>SSLSocketAppender</code> ）客户。</p>
        
      <p>的<code>ServerSocketReceiver</code>组件提供以下可配置属性：</p>
    
      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>类型</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><span class="prop" container="serverSocketReceiver">地址</span></td>
          <td><code>String</code></td>
          <td>接收方将在其上侦听的本地网络接口地址。如果未指定此属性，则接收方将在所有网络接口上进行侦听。</td>
        </tr>
        <tr>
          <td><span class="prop" container="serverSocketReceiver">港口</span></td>
          <td><code>int</code></td>
          <td>接收方将在其上侦听的TCP端口。如果未指定此属性，则将使用默认值。</td>
        </tr>
        <tr>
          <td><span class="prop" container="serverSocketReceiver">ssl</span></td>
          <td><code>SSLConfiguration</code></td>
          <td>仅支持<code>SSLServerSocketReceiver</code> ，此属性提供了接收方将使用的SSL配置，如<a href="usingSSL.html">使用SSL中所述</a> 。</td>
        </tr>
      </tbody></table>
    
      <h3 class="doAnchor" name="usingServerSocketReceiver">使用ServerSocketReceiver</h3>
    
      <p>以下配置使用<code>ServerSocketReceiver</code>具有最少的本地附加程序和记录器配置的组件。从远程附加程序接收到的日志记录事件将由root记录器进行匹配，并传递给本地控制台附加程序。</p>
    
      <p class="example">示例：基本的ServerSocketReceiver配置（logback-examples / src / main / resources / chapters / receivers / socket / receiver1.xml）</p>

      <span class="asGroovy" onclick="return asGroovy('receiver1');">观看为.groovy</span>
  <pre id="receiver1" class="prettyprint source">&lt;configuration debug="true">

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>

  &lt;receiver class="ch.qos.logback.classic.net.server.ServerSocketReceiver">
    &lt;port>${port}&lt;/port>
  &lt;/receiver>

&lt;/configuration></pre>
  
      <p>请注意，接收器组件的<em>class</em>属性标识了我们希望使用的接收器子类型。在这个例子中，我们使用<code>ServerSocketReceiver</code> 。</p>
    
      <p>我们的示例服务器应用程序在功能和设计上与<code>SimpleSocketServer</code> 。它仅接受logback配置文件的路径作为命令行参数，并运行给定的配置。虽然我们的示例有些琐碎，但请记住，您可以配置logback的<code>ServerSocketReceiver</code> （要么<code>SSLServerSocketReceiver</code>在<em>任何</em>应用程序）组成。
      </p>
    
      <p>从<em>logback-examples</em>目录中的外壳程序中，我们可以如下运行示例服务器应用程序：</p>
    
      <p class="source">java -Dport = 6000 <a href="../xref/chapters/receivers/socket/ReceiverExample.html">chapters.receivers.socket。ReceiverExample</a> \ src / main / java / chapters / receivers / socket / receiver1.xml</p>
  
      <p>我们可以使用配置了<code>SocketAppender</code> 。我们的示例客户端应用程序仅加载了一个logback配置，该配置会将套接字附加程序连接到我们的示例接收器。然后，它以消息的形式等待用户的输入，该消息将被中继到接收器。我们可以如下运行示例客户端应用程序：</p>
    
      <p class="source">java -Dhost = localhost -Dport = 6000 \ <a href="../xref/chapters/receivers/socket/AppenderExample.html">chapters.receivers.socket。AppenderExample</a> \ src / main / java / chapters / receivers / socket / appender1.xml</p>
    
      <h3 class="doAnchor" name="usingSSLServerSocketReceiver">使用SSLServerSocketReceiver</h3>

      <p>以下配置重复相同的最小追加器和记录器配置，但是使用充当服务器角色的启用SSL的接收器组件。</p>

      <p class="example">示例：基本SSLServerSocketReceiver配置（logback-examples / src / main / resources / chapters / receivers / socket / receiver2.xml）</p>
      <span class="asGroovy" onclick="return asGroovy('receiver2');">观看为.groovy</span>
  <pre id="receiver2" class="prettyprint source">&lt;configuration debug="true">

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>

  &lt;receiver class="ch.qos.logback.classic.net.server.SSLServerSocketReceiver">
    &lt;port>${port}&lt;/port>
    &lt;ssl>
      &lt;keyStore>
        &lt;location>${keystore}&lt;/location>
        &lt;password>${password}&lt;/password>
      &lt;/keyStore>
    &lt;/ssl>
  &lt;/receiver>

&lt;/configuration></pre>

      <p>此配置与使用示例的上一个示例之间的本质区别<code>ServerSocketReceiver</code>是的规格<code>SSLServerSocketReceiver</code>在<em>class</em>属性中，以及是否存在嵌套的<span class="prop">ssl</span>属性（在此用于使用替换变量来指定包含接收者的私钥和证书的密钥存储的位置和密码）。有关为Logback组件配置SSL属性的详细信息，请参见<a href="usingSSL.html">使用SSL</a> 。</p>    
 
      <p>我们可以使用相同的示例服务器配置来运行此配置，仅带有几个其他配置属性：</p>

      <p class="source">java -Dport = 6001 \ -Dkeystore = file：src / main / java / chapters / appenders / socket / ssl / keystore.jks \ -Dpassword = changeit \ chapters.receivers.socket。ReceiverExample \ src / main / java / chapters / receivers / socket / receiver2.xml</p>
  
      <p>请注意，命令行上给出的<em>keystore</em>属性指定了一个文件URL，该文件URL标识了密钥库的位置。您还可以按照<a href="usingSSL.html">使用SSL中</a>所述<a href="usingSSL.html">使用</a>类路径URL。</p>
    
      <p>我们可以使用配置了<code>SSLSocketAppender</code> 。我们使用上一个示例中使用的示例示例客户端应用程序，以及一个使用启用了SSL的附加程序的配置文件。我们按以下方式运行示例：</p>
    
      <p class="source">java -Dhost = localhost -Dport = 6001 \ -Dtruststore = file：src / main / java / chapters / appenders / socket / ssl / truststore.jks \ -Dpassword = changeit \ chapters.receivers.socket。AppenderExample \ src / main / java / chapters / receivers / socket / appender2.xml</p>
    
      <p>请注意，我们的示例使用的是仅适用于测试和实验的自签名X.509凭据。<strong>在生产设置中，您应该获取适当的X.509凭据，以标识启用了SSL的登录组件</strong> 。有关更多信息，请参见<a href="usingSSL.html">使用SSL</a> 。</p>
  
      <h2 class="doAnchor" name="receiverClientComponents">扮演客户角色的接收者</h2>
    
      <p>配置为充当客户端角色的接收方会启动与远程附加程序的连接。远程附加程序必须是服务器类型，例如<code>ServerSocketAppender</code> 。</p>  
    
      <p>
        <img border="1" src="images/chapters/receivers/socketReceiver.png">
      </p>

      <p>Logback包括两个充当客户端角色的接收方组件； <a href="../xref/ch/qos/logback/classic/net/SocketReceiver.html"><code>SocketReceiver</code></a>及其启用了SSL的子类型<a href="../xref/ch/qos/logback/classic/net/SSLSocketReceiver.html"><code>SSLSocketReceiver</code></a> 。这两个接收器组件均旨在启动与远程附加程序的连接，该附加程序是<code>ServerSocketAppender</code> （要么<code>SSLServerSocketAppender</code> ）。</p>
        
      <p>以下配置属性受以下支持： <code>SocketReceiver</code>子类型：</p>
    
      <table class="bodyTable striped">
        <tbody><tr>
        <th>物业名称</th>
        <th>类型</th>
        <th>描述</th>
        </tr>
        <tr>
          <td><span class="prop" container="SocketReceiver">远程主机</span></td>
          <td><code>String</code></td>
          <td>远程服务器套接字附加程序的主机名或地址。</td>
        </tr>
        <tr>
          <td><span class="prop" container="SocketReceiver">港口</span></td>
          <td><code>int</code></td>
          <td>远程服务器套接字附加程序的端口号。</td>
        </tr> 
        <tr>
          <td><span class="prop" container="socket">重新连接延迟</span></td>
          <td><code>int</code></td>
          <td>一个正整数，表示连接失败后尝试重新连接之前要等待的毫秒数。默认值为30000（30秒）。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="SocketReceiver">ssl</span></td>
          <td><code>SSLConfiguration</code></td>
          <td>仅支持<code>SSLSocketReceiver</code> ，此属性提供了将用于此接收器的SSL配置，如<a href="usingSSL.html">使用SSL中所述</a> 。</td>
        </tr>
      </tbody></table>
        
      <h3 class="doAnchor" name="usingSocketReceiver">使用SocketReceiver</h3>

      <p>用于的配置<code>SocketReceiver</code>与前面的示例非常相似<code>ServerSocketReceiver</code> 。差异与以下事实有关：客户端和服务器的角色相反。类型的接收器<code>SocketReceiver</code>是一个客户端，远程附加程序充当服务器。</p>
        
      <p class="example">示例：基本SocketReceiver配置（logback-examples / src / main / resources / chapters / receivers / socket / receiver3.xml）</p>
      <span class="asGroovy" onclick="return asGroovy('receiver3');">观看为.groovy</span>
  <pre id="receiver3" class="prettyprint source">&lt;configuration debug="true">
    
  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">    
    &lt;encoder>
      &lt;pattern>%date %-5level [%thread] %logger - %message%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>  

  &lt;receiver class="ch.qos.logback.classic.net.SocketReceiver">
    &lt;remoteHost>${host}&lt;/remoteHost>
    &lt;port>${port}&lt;/port>
    &lt;reconnectionDelay>10000&lt;/reconnectionDelay>
  &lt;/receiver>

&lt;/configuration></pre>
        
      <p>此配置将导致logback连接到<code>ServerSocketAppender</code>在<em>主机</em>和<em>端口</em>替换变量指定的<em>主机</em>和<em>端口上运行</em> 。从远程附加程序接收到的日志记录事件将通过控制台附加程序本地记录（根据此处显示的配置）。
      </p>
   
      <p>假设您位于<em>logback-examples /</em>目录中，则可以使用以下命令运行此示例配置：</p>

         

      <p>该示例加载配置，然后仅等待来自远程附加程序的日志事件。如果在未运行远程附加程序的情况下运行此示例，则会定期在日志输出中看到<em>连接被拒绝的</em>消息。接收器将定期尝试重新连接到远程附加器，直到成功或直到记录器上下文关闭为止。尝试之间的延迟间隔可以使用<span class="prop">reconnectionDelay</span>属性进行配置，如示例配置中所示。
      </p>

      <p class="source">java -Dhost = localhost -Dport = 6000 \ chapters.receivers.socket。ReceiverExample \ src / main / java / chapters / receivers / socket / receiver3.xml</p>


      <p>我们可以提供一个远程附加器，我们的示例接收器可以连接到该远程附加器，使用先前使用的相同附加器示例。该示例加载了一个包含<code>ServerSocketAppender</code> ，然后等待来自用户的输入，该输入包含将发送到连接的接收者的消息。我们可以按以下方式运行示例追加程序应用程序：</p>

      <p class="source">java -Dport = 6000 \ chapters.receivers.socket。AppenderExample \ src / main / java / chapters / receivers / socket / appender3.xml</p>   

      <p>如果输入未连接接收器时要发送的消息，请注意该消息将被简单丢弃。</p>

      <h3 class="doAnchor" name="usingSSLSocketReceiver">使用SocketSSLReceiver</h3>


      <p>所需的配置<code>SSLSocketReceiver</code>与用于<code>SocketReceiver</code> 。主要区别在于为接收方指定的类以及嵌套<span class="prop">ssl</span>属性以指定SSL配置属性的能力。以下示例说明了基本配置：</p>
   
      <p class="example">示例：基本SSLSocketReceiver配置（logback-examples / src / main / resources / chapters / receivers / socket / receiver4.xml）</p>
      <span class="asGroovy" onclick="return asGroovy('receiver4');">观看为.groovy</span>
  <pre id="receiver4" class="prettyprint source">&lt;configuration debug="true">

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">    
    &lt;encoder>
      &lt;pattern>%date %-5level [%thread] %logger - %message%n&lt;/pattern>
    &lt;/encoder>         
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>  
 
  &lt;receiver class="ch.qos.logback.classic.net.SSLSocketReceiver">
    &lt;remoteHost>${host}&lt;/remoteHost>
    &lt;port>${port}&lt;/port>
    &lt;reconnectionDelay>10000&lt;/reconnectionDelay>
    &lt;ssl>
      &lt;trustStore>
        &lt;location>${truststore}&lt;/location>
        &lt;password>${password}&lt;/password>
      &lt;/trustStore>
    &lt;/ssl>
  &lt;/receiver>

&lt;/configuration></pre>

      <p>注意， <em>class</em>属性现在指定<code>SSLSocketReceiver</code>除了前面示例中显示的配置属性外，此配置还包含一个SSL配置，该配置指定用于验证远程附加程序是否受信任的信任库的位置和密码。有关配置SSL属性的更多信息，请参见<a href="usingSSL.html">使用SSL</a> 。
      </p>
  
      <p>您可以使用以下命令运行此示例配置：</p>
  
      <p class="source">java -Dhost = localhost -Dport = 6001 \ -Dtruststore = file：src / main / java / chapters / appenders / socket / ssl / truststore.jks \ -Dpassword = changeit \ chapters.receivers.socket。ReceiverExample \ src / main / java / chapters / receivers / socket / receiver4.xml</p>   
   
      <p>一旦启动，接收方将尝试连接到指定的远程附加程序。假设附加器尚未运行，您将看到日志输出中定期出现“拒绝连接”消息；接收器在延迟了由<span class="prop">reconnectionDelay</span>属性指定的时间后，将定期重试与远程附加程序的<span class="prop">连接</span> 。
      </p>
  
      <p>我们可以提供一个远程附加器，我们的示例接收器可以连接到该远程附加器，使用先前使用的相同附加器示例。该示例加载了一个包含<code>SSLServerSocketAppender</code> ，然后等待来自用户的输入，该输入包含一条消息，该消息将传递到连接的接收者。我们可以按以下方式运行示例追加程序应用程序：</p>

      <p class="source">java -Dport = 6001 \ -Dkeystore = file：src / main / java / chapters / appenders / socket / ssl / keystore.jks \ -Dpassword = changeit \ chapters.receivers.socket。AppenderExample \ src / main / java / chapters / receivers / socket / appender4.xml</p>   

      <p>如果输入未连接接收器时要发送的消息，请注意该消息将被简单丢弃。</p>

      <p>再次需要注意的重要一点是，我们的示例使用的是仅适用于测试和实验的自签名X.509凭据。<strong>在生产设置中，您应该获取适当的X.509凭据，以标识启用了SSL的登录组件</strong> 。有关更多信息，请参见<a href="usingSSL.html">使用SSL</a> 。</p>
  
        <script src="../templates/footer.js" type="text/javascript"></script>

    </div>
    

</body></html>