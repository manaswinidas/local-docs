<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第12章Groovyによる设定</title>
    
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">

  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content" class="chapter">
      
    <h1>第12章Groovyによる设定</h1>
      
      <div class="quote">
      <p><em>満足した豚になるより不満を抱えた人间になるほうがずっと良い。ましてや，満足気な愚か者になるより不満だらけのソクラテス派になるほうがずっと良い。豚や愚か者がこれとは异なる加盟をした，しても彼らに良いとされる侧の経験が无いからなのだ。
      </em>
      </p>
      <p>-ジョン·スチュアート·ミル， <em>功利主义</em></p>
    </div>
    <script src="../templates/creative.js" type="text/javascript"></script>


    <p>やイン固有言语やDSLはかなり普及しています。XMLベースのlogbackの设定は，DSLのインスタンスとみなすことができます。XMLの性质上，设定ファイルは非常に冗长でかさばるものになります。log，logbackのコードの大部分はXMLベースの设定ファイル处理専用のJoranと呼ばれるものです。Joranは，変数置换や条件分岐，および実行时の拡张など，気の利いた机能をサポートしています。しかし，Joranの问题は复雑さだけではありません。ユーザーエクスペリエンスは不十分ですし，直感とはかけ离れています。
    </p>

    <p>での章で说明するGroovyベースのDSLは，一贯性があり，直感的で，かつ，强力であることを目指しています。XMLの设定ファイルでできることはすべて，それもより短い行数で実现することができます。Groovyスタイルの设定ファイルへの移行を支援するために， <a href="http://logback.qos.ch/translator/asGroovy.html">既存の<em>logback.xml</em>を自动的に<em>logback.groovy</em>へ変换するツールを用意しました</a> 。
    </p>


    <h2 class="doAnchor">基本的な哲学</h2>
    
    <p>基本的なルールを说明します。<em>logback.groovy</em>はGroovyのプログラムです。Groovy言语はJava言语のスーパーセットなので，Javaにできるあらゆる设定アクションと同じことを<em>logback.groovy</em>で実行することができます。ですが，logbackをJavaの构文でプログラム的ム设置にのはかなり厄介なので，logback専用の拡张构文を追加しました。logback専用の拡张构文はできるだけ少なくなるようにしましたし，実际のところほんのわずかしかありません。Groovyに惯れているとしても本章に目を通してもらって， <em>logback.groovy</em>を书くのは非常に简単であることを理解してください。Groovyに不惯れな方であっても， <em>logback.xml</em>を使い続けるより<em>logback.groovy</em>の记法のほうがずっとわかりやすいと思えるようになるはずです。
    </p>

    <p>改めて整理します。<em>logback.groovy</em>は最小限のlogback専用の拡张がなされたGroovyプログラムです。<em>logback.groovy</em>の中では，クラスの导入や変数定义，変数评価，GStringのMavenProject：ch.qos.logback：logback-site：1.3.0-alpha5 @ C：\\ home \\ ceki \\ logback \\ logback-site \\ pom.xml记法，if-else构文などのGroovyの机能は<em>全て</em>利用可能です。</p>

    <h2 class="doAnchor">自动导入</h2>

    <p><span class="label">logback1.0.10以降</span>决まりきったものになる共通するクラスやパッケージのimportをしなくてもすむように，自动的にimportします。み込み，组み込みのアペンダーやレイウトウいにつimport文を书かなくても设定だけでよいのです。で，デフォルトの进口でカバーされていないクラスやパッケージがあるなら，それは自分でやらなければなりません。</p>

    <p>対フォルトの进口対象は次のとおりです。</p>

    <ul>
      <li><span class="code">导入ch.qos.logback.core。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.encoder。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.read。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.rolling。*;</span></li>
      <li><span class="code">导入ch.qos.logback.core.status。*;</span></li>
      <li><span class="code">导入ch.qos.logback.classic.net。*;</span></li>
      <li><span class="code">导入ch.qos.logback.classic.encoder。PatternLayoutEncoder;</span></li>
    </ul>

    <p>さらに， <span class="code">ch.qos.logback.classic。水平</span>の全ての定数は，大文字バージョンと小文字バージョンのそれぞれで静态导入されます。では，スクリプトでは<em>INFO</em>と<em>info</em>のどちらでも利用できます。</p>


    <h2 class="doAnchor" name="sift">SiftingAppenderはサポートされなくなりました</h2>

    <p><span class="label">logback1.0.12以降</span> Groovy设定ファイルでは<code>SiftingAppender</code>はサポートされなくなりました。需要がありそうなら复活するかもしれません。</p>

    <h2 class="doAnchor" name="entensions"><em>logback.groovy</em>用の拡张构文</h2>

    <p><span class="green">基本的に<em>logback.groovyの构文</em>は，次に说明する半ダースほどのメソッドで构成されています。これらは実际に定义する顺番とは逆顺に并んでいます。</span>厳密に言えば，これらのメソッドの呼び出し顺序し1つの例外（アペンダーはそれを割はそれを当てるロガーの前に定义しなければならない）を除いて重要ではありません。</p>

    

    <!-- ========================================================== -->

    <h3>• <span class="code">root（级别，列表<string>appenderNames = []）</string></span></h3>

    <p><code>root</code>メソッドはルートロガーのログレベルを设定するために使用します。第二引数のappenderName（ <code>List<String></code> ）は任意で，ルートロガーに割に当てるアペンダーを名前で指定します。引数に値を指定しなければ，空のリストが指定されたものとして扱います。。Groovyでは空のリストを<code>[]</code>で记述します。</p>

    <p>ルートロガーのログレベルにWARNを设定するには次のように记述します。</p>

    <pre class="prettyprint source">root(WARN)</pre>

    <p>ルートロガーのログレベルにINFOに设定し，“ CONSOLE”アペンダーと“ FILE”アペンダーを割を当てるには次のように记述します。</p>

    <pre class="prettyprint source">root(INFO, ["CONSOLE", "FILE"])</pre>

    <p>“ CONSOLE”と“ FILE”という名前のアペンダーはすでに定义されているものとします。アペンダーの定义の仕方はすぐ后で说明します。
    </p>

    <!-- ========================================================== -->

    <h3>• <span class="code">logger（字符串名称，级别，列表<string>appenderNames = []，<br>布尔可加性= null）</string></span></h3>

    <p><code>logger()</code>メソッドは引数を四つとります。后ろの二つは任意です。第一引数にはロガーの名前を指定します。第二引数にはロガーのログレベルを指定します。ログレベルに<code>null</code>指定すると，直近の祖先ロガーに指定されたログレベルを<a href="./01-architecture.html#effectiveLevel">継承</a>するという意味になります。第三引数は<code>List<String></code>で任意です。省略した场合は空のリストを指定したものとして扱います。リストにはロガーに割り当てるアペンダーの名前を并べます。第四引数は<code>Boolean</code>でこちらも任意です。<a href="./01-architecture.html#additivity">可加性フラグ</a>として使われます。省略した场合は<code>null</code>が指定されたものとして扱います。
    </p> 

    <p>comとえば，次のスクリプトはロガー名として“ com.foo”，ログレベルとしてINFOを设定します。</p>

       <pre class="prettyprint source">logger("com.foo", INFO)</pre>

    <p>次のスクリプトは，ロガー名として“ com.foo”，ログレベルとしてDEBUG，そしてアペンダーに“ CONSOLE”を割り当てます。</p>

  <pre class="prettyprint source">logger("com.foo", DEBUG, ["CONSOLE"])</pre>
    
   <p>次のスクリプトは前のスクリプトほとほ同じですが，加成フラグにfalseを设定します。</p>

  <pre class="prettyprint source">logger("com.foo", DEBUG, ["CONSOLE"], false)</pre>


    <!-- ========================================================== -->
    <h3>• <span class="code">appender（字符串名称，类clazz，闭包闭包= null）</span></h3>

    <p>appender（）メソッドでは，第一引数にアペンダーの名前を指定します。第二引数は必须で，インスタンス化するアペンダーのクラスを指定します。第三引数には，そのほかの设定をするクロージャーを指定します。省略した场合はnullになります。</p>

    <p>はとんどのアペンダーは，ちゃんと动作するためにプロパティを设定したりサブコンポーネントを注入しなければなりません。ロパティを设定するには'='演算子（代入）を使用します。をンポーネントを注入するには，プロパティ名をメソッド名のように记述して，引数にインスタンスするンス化するクラスを指定します。グのコーディング规约は，アペンダーのあらゆるサブコンポーネントについても同じように再帰的に适用されるものです。チはのアプローチは<em>logback.groovy</em>の中核を为すもので，覚えなければならない唯一の规约となるでしょう。</p>
    
    <p>例を见てみましょう。次のスクリプトは“ FILE”という名前の<code>FileAppender</code>してインスタンス化して， <span class="option">file</span>プロパティに“ testFile.log”を设定し， <span class="option">追加</span>プロパティにfalseを设定しています。编码器には<code>PatternLayoutEncoder</code>を注入しています。编码器の模式プロパティには“-百分比级别％logger-％msg％n”を设定しています。にのアペンダーをルートロガーに割り当てます。</p>

    <pre class="prettyprint source">appender("FILE", FileAppender) {
  file = "testFile.log"
  append = true
  encoder(PatternLayoutEncoder) {
    pattern = "%level %logger - %msg%n"
  }
}

root(DEBUG, ["FILE"])</pre>

    <p>
    </p>

    
    <!-- ========================================================== -->        
    <h3>• <span class="code">timestamp（String datePattern，long timeReference = -1）</span></h3>

    <p><code>timestamp()</code>メソッドは， <code>datePattern</code>に指定された书式文字列で<code>timeReference</code>に指定されたlong値の时间を书式化した文字列を返します。第一引数の<code>datePattern</code>指定する书式文字列は， <a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a>で定义されている规则に従わなければなりません。第二引数の<code>timeReference</code>が省略された场合-1が指定されたものとして扱います。现在设定ファイルを解析しているときの现在日时を表す値です。状况によりますが，基准时间として<code>context.birthTime</code>を使うこともあるでしょう。
    </p>

    <p>次の例では， <code>bySecond</code>変数に“ yyyyMMdd'T'HHmmss”という书式で文字列化した现在日时を代入していますそして，“ bySecond”変数を<span class="option">file</span>をロパティの値として使しています。
    </p>

<pre class="prettyprint source"><b>def bySecond = timestamp("yyyyMMdd'T'HHmmss")</b>

appender("FILE", FileAppender) {
  <b>file = "log-${bySecond}.txt"</b>
  encoder(PatternLayoutEncoder) {
    pattern = "%logger{35} - %msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>

    <!-- ========================================================== -->        
    <h3>• <span class="code">conversionRule（字符串conversionWord，class converterClass类）</span></h3>

    <p><a href="./06-layouts.html#customConversionSpecifier">変换指定子</a>を自作しても，logbackに教えてあげなければ利用できません。logのlogback.groovyでは，logbackが<code>%sample</code>という変换指定子に対してMySampleConverterを呼び出すようにしています。
    </p>

    <pre class="prettyprint source">
import chapters.layouts.MySampleConverter

conversionRule("sample", MySampleConverter)
appender("STDOUT", ConsoleAppender) {
  encoder(PatternLayoutEncoder) {
    pattern = "%-4relative [%thread] %<b>sample</b> - %msg%n"
  }
}
root(DEBUG, ["STDOUT"])</pre>

   <!-- ========================================================== -->
   <h3>• <span class="code">scan（String scanPeriod = null）</span></h3>

    <p>scan（）メソッドを使うと，logbackが定期的にlogback.groovyの変更を监视するようになります。logbackは変更を検出するたびに<em>logback.groovy</em>を再読み込みします。</p>

    <pre class="prettyprint source">scan()</pre>

    <p>デフォルトでは，一分ごとに设定ファイルの変更を监视します。监视周期を指定するには，“ scanPeriod”文字列引数を指定します。“ scanPeriod”に指定する文字列には，时间単位としてミリ秒，秒，分または时间を含めることができます。例をみてください。</p>

    <pre class="prettyprint source">scan("30 seconds")</pre>
    
    <p>时间単位がない场合ミリ秒が指定されたものとして扱いますが，ほとんどの偶然これは不适切な単位です。デフォルトの监视周期を変更する场合は，时间単位を指定することを忘れないでください。のように変更を监视するのかについて详しくは<a href="./03-configuration.html#autoScan">自动再読み込みのセクション</a>を参照してください。
    </p>
    
    <!-- ========================================================== -->
  
    <h3>• <span class="code">statusListener（Class listenerClass）</span></h3>

    <p><code>statusListener()</code>メソッドは，指定したリスナークラスをステータスリスナーとして追加します。例を见てください。</p>

    <pre class="prettyprint source">import chapters.layouts.MySampleConverter

<b>// statusListener()メソッドの呼び出しはimport文の直後、他の式よりも前に置くことを強く推奨します</b>
<b>statusListener(OnConsoleStatusListener)</b></pre>
 
    <p><a href="./03-configuration.html#statusListener">ステータスリスナー</a>については前の章で说明しました。</p>

    <h3>• <span class="code">jmxConfigurator（字符串名称）</span></h3>

    <p><a href="./10-jmxConfig.html"><code>JMXConfigurator</code></a>のMBeanを登录します。MBean名としてデフォルトのオブジェクト名（ <code>ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator</code> ）を使うには引数を指定せずに呼び出してください。</p>

    <pre class="prettyprint source">jmxConfigurator()</pre>

    <p><code>Name</code> defaultーに“ default”以外の値を指定するには， <code>jmxConfigurator()</code>ッドの引数として指定するだけです。</p>

    <pre class="prettyprint source">jmxConfigurator('MyName')</pre>

    <p>なオブジェクト名官员を指定したい场合は，正确なオブジェクト名文字列を引数に指定してください。</p>

    <pre class="prettyprint source">jmxConfigurator('myApp:type=LoggerManager')</pre>

    <p>のメソッドは，指定された文字列をオブジェクト名として使おうとしてから，それが有效なオブジェクト名ではなかったら，フォールバックとして“名字”キーの値にします。</p>

    <!-- ========================================================== -->

    <h2 class="doAnchor" name="internalDSL">内部DSL，すべてはGroovyの赐物だ！</h2>

    <p><em>logback.groovy</em>は内部DSLです。内容，内容自体が実行可能なGroovyスクリプトなのです。したがって，logback.groovyの中ではGroovy言语に备わっているクラスimport，GString，変数定义，GString文字列中のMavenProject：ch.qos.logback：logback-site：1.3.0-alpha5 @ C：\\ home \\ ceki \\ logback \\ logback-site \\ pom.xml记法の评価，if-else文などのあらゆる机能を利用することができるのです。以降の说明では<em>logback.groovy</em>における典型的なGroovy言语の使用例を绍介します。
    </p>


    <h3 class="doAnchor" name="varedef">String数定义，そしてGString</h3>

    <p><em>logback.groovy</em>の中ならどこでも変数を定义することができますし，その変数をGString文字列の中で评価することができます。例を见てください。</p>

    <pre class="prettyprint source">// USER_HOME 変数にシステムプロパティの "user.home" の値を代入します
<b>def USER_HOME = System.getProperty("user.home")</b>

appender("FILE", FileAppender) {
  // USER_HOME 変数を使います
  <b>file = "${USER_HOME}/myApp.log"</b>
  encoder(PatternLayoutEncoder) {
    pattern = "%msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>


    <h3 class="doAnchor" name="printing">コンソールへの出力</h3>

    <p>时髦の<code>println()</code>メソッドを使ってコンソールに出力することができます。例を见てください。</p>

    <pre class="prettyprint source">def USER_HOME = System.getProperty("user.home");
<b>println "USER_HOME=${USER_HOME}"</b>

appender("FILE", FileAppender) {
  <b>println "Setting [file] property to [${USER_HOME}/myApp.log]"</b>
  file = "${USER_HOME}/myApp.log"  
  encoder(PatternLayoutEncoder) {
    pattern = "%msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>


   <h3 class="doAnchor" name="automaticallyExported">自动的に公开されるフィールド</h3>

   <h4 class="doAnchor" name="hostname">'主机名'変数</h4>

   <p>'hostname'変数にはスクリプトを実行しているホスト名が设定されています。hostのドキュメントの著者には正确な说明はできませんが，视觉范囲のルールがあるため，'hostname'変数が利用できるのは最上位のスコープだけで，ネストされたスコープからは参照できません。次の例を见ればどういうことかわかるでしょう。
   </p>

 <pre class="prettyprint source">// will print "hostname is x" where x is the current host's name
println "Hostname is ${hostname}"

appender("STDOUT", ConsoleAppender) {
  <b>// will print "hostname is null"</b>
  <b>println "Hostname is ${hostname}" </b>
}</pre>

   <p>プでのスコープで主机名変数を使いたいなら，次のように别の変数に代入して参照しなければなりません。</p>

 <pre class="prettyprint source">// define HOSTNAME by assigning it hostname
def HOSTNAME=hostname
// will print "hostname is x" where x is the current host's name
println "Hostname is ${HOSTNAME}"

appender("STDOUT", ConsoleAppender) {
  // will print "hostname is x" where x is the current host's name
  println "Hostname is ${HOSTNAME}" 
}</pre>


   <h3 class="doAnchor" name="everythingIsContext">现在のコンテキストを参照するContextAwareが全ての土台になっている</h3>

   <p><em>logback.groovy</em>スクリプトは<a href="http://logback.qos.ch/xref/ch/qos/logback/core/spi/ContextAware.html">ContextAware</a>オブジェクト上で実行されます。したがって， <code>context</code>変数からいつでも现在のコンテキストにアクセスすることができます。それに， <code>addInfo()</code>メソッドや<code>addWarn()</code>メソッド， <code>addError()</code>メソッドで， <code>StatusManager</code>ますステータスメッセージを伝えることができます。</p>

   <pre class="prettyprint source">// always a good idea to add an on console status listener
statusListener(OnConsoleStatusListener)

// set the context's name to wombat
<b>context.name = "wombat"</b>
// add a status message regarding context's name
<b>addInfo("Context name has been set to ${context.name}")</b>

def USER_HOME = System.getProperty("user.home");
// add a status message regarding USER_HOME
<b>addInfo("USER_HOME=${USER_HOME}")</b>

appender("FILE", FileAppender) {
  // add a status message regarding the file property
  <b>addInfo("Setting [file] property to [${USER_HOME}/myApp.log]")</b>
  file = "${USER_HOME}/myApp.log"  
  encoder(PatternLayoutEncoder) {
    pattern = "%msg%n"
  }
}
root(DEBUG, ["FILE"])</pre>


   <h3 class="doAnchor">条件付き设定</h3>
   
   <p>Groovyは本格的なプログラグンミ言语なので，条件分岐を使うと1つの<em>logback.groovy</em>を开发，测试，生产とったいったいろいろな环境で使いのすことができます。</p>

   <p>次のスクリプトでは，ホスト名が本番环境のホスト名であるpixieあるいはorion不在の场合コンソールアペンダーが有效になるようにしています。ローリングファイルアペンダーの出力ディレクトリがホスト名に依存していることにも気をつけてください。</p>
   
   <pre class="prettyprint source">// always a good idea to add an on console status listener
statusListener(OnConsoleStatusListener)

def appenderList = ["ROLLING"]
def WEBAPP_DIR = "."
def consoleAppender = true;

// does hostname match pixie or orion?
if (hostname =~ /pixie|orion/) {
  WEBAPP_DIR = "/opt/myapp"     
  consoleAppender = false   
} else {
  appenderList.add("CONSOLE")
}

if (consoleAppender) {
  appender("CONSOLE", ConsoleAppender) {
    encoder(PatternLayoutEncoder) {
      pattern = "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    }
  }
}

appender("ROLLING", RollingFileAppender) {
  encoder(PatternLayoutEncoder) {
    Pattern = "%d %level %thread %mdc %logger - %m%n"
  }
  rollingPolicy(TimeBasedRollingPolicy) {
    FileNamePattern = "${WEBAPP_DIR}/log/translator-%d{yyyy-MM}.zip"
  }
}

root(INFO, appenderList)</pre>




    <script src="../templates/footer.js" type="text/javascript"></script>
    </div>
  
</body></html>