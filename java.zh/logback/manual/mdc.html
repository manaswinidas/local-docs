<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第8章：映射的诊断上下文</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">
      
    <h1>第8章：映射的诊断上下文</h1>

    <a href="mdc_ja.html">和訳（日语翻译）</a>

    <div class="quote">     
      <p><em>锁上门。</em></p>
      <p>—哥伦比亚特派团控制部飞行总监LEROY CAIN</p>
    </div>
    
    <script src="../templates/creative.js" type="text/javascript"></script>
    
		<p>登录的设计目标之一是审核和调试复杂的分布式应用程序。大多数现实世界的分布式系统都需要同时处理多个客户端。在这种系统的典型多线程实现中，不同的线程将处理不同的客户端。将一个客户端的日志记录输出与另一个客户端的日志记录输出区分开的一种可能但略微沮丧的方法包括为每个客户端实例化一个新的单独的记录器。此技术促进记录器的扩散，并可能增加其管理开销。
		</p>
		
    <script src="../templates/setup.js" type="text/javascript"></script>

    
    <p>一种更轻松的技术包括为服务给定客户端的每个日志请求加盖唯一标记。尼尔·哈里森（Neil Harrison）在R. Martin，D.Riehle和F.Buschmann（Addison-Wesley，1997）编辑的《程序设计的模式语言中的<em>诊断消息</em>的模式3》中描述了这种方法。Logback利用了SLF4J API：映射的诊断上下文（MDC）中包含的该技术的一种变体。
		</p>
		
		<p>为了唯一标记每个请求，用户将上下文信息放入<code>MDC</code> ，是“映射的诊断上下文”的缩写。MDC类的主要部分如下所示。请参考<a href="http://www.slf4j.org/api/org/slf4j/MDC.html">MDC javadocs</a>以获取方法的完整列表。
		</p>

<pre class="prettyprint source">package org.slf4j;

public class MDC {
  //Put a context value as identified by <em>key</em>
  //into the current thread's context map.
  <b>public static void put(String key, String val);</b>

  //Get the context identified by the <code>key</code> parameter.
  <b>public static String get(String key);</b>

  //Remove the context identified by the <code>key</code> parameter.
  <b>public static void remove(String key);</b>

  //Clear all entries in the MDC.
  <b>public static void clear();</b>
}</pre>

		<p>的<code>MDC</code>类仅包含静态方法。它使开发人员可以将信息放置在<em>诊断上下文中</em> ，随后可以由某些logback组件进行检索。的<code>MDC</code>在<em>每个线程的基础</em>上管理上下文信息。通常，在开始为新的客户请求提供服务时，开发人员会将相关的上下文信息（例如客户ID，客户的IP地址，请求参数等）插入到<code>MDC</code> 。如果配置正确，则Logback组件将自动在每个日志条目中包含此信息。
		</p>

    <p>请注意，由logback-classic实现的MDC假定将值以中等频率放入MDC。还要注意，子线程不会自动继承其父级的映射诊断上下文的副本。</p>

		<p>下一个应用程序名为<code><a href="../xref/chapters/mdc/SimpleMDC.html">SimpleMDC</a></code>证明了这一基本原理。
		</p>
<em>例7.1：基本MDC用法（ <a href="../xref/chapters/mdc/SimpleMDC.html">logback-examples / src / main / java / chapters / mdc / SimpleMDC.java）</a></em>
<pre class="prettyprint source">package chapters.mdc;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import ch.qos.logback.classic.PatternLayout;
import ch.qos.logback.core.ConsoleAppender;

public class SimpleMDC {
  static public void main(String[] args) throws Exception {

    // You can put values in the MDC at any time. Before anything else
    // we put the first name
    MDC.put("first", "Dorothy");

    [ SNIP ]
    
    Logger logger = LoggerFactory.getLogger(SimpleMDC.class);
    // We now put the last name
    MDC.put("last", "Parker");

    // The most beautiful two words in the English language according
    // to Dorothy Parker:
    logger.info("Check enclosed.");
    logger.debug("The most beautiful two words in English.");

    MDC.put("first", "Richard");
    MDC.put("last", "Nixon");
    logger.info("I am not a crook.");
    logger.info("Attributed to the former US president. 17 Nov 1973.");
  }

  [ SNIP ]

}</pre>

		<p>的主要方法，开始由上述值<em>多萝西</em>与键在<em>第一</em>关联<code>MDC</code> 。您可以在其中放置尽可能多的值/键关联<code>MDC</code>如你所愿。使用相同键的多次插入将覆盖较早的值。然后，代码继续进行配置，以配置logback。</p>

    <p>为了简洁起见，我们省略了使用配置文件<a href="http://github.com/qos-ch/logback/blob/master/logback-examples/src/main/java/chapters/mdc/simpleMDC.xml">simpleMDC.xml</a>配置回发的代码。这是该文件中的相关部分。
    </p>

 <pre class="prettyprint source">&lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"> 
  &lt;layout>
    &lt;Pattern><b>%X{first} %X{last}</b> - %m%n&lt;/Pattern>
  &lt;/layout> 
&lt;/appender></pre>
    


    <p>注意<em>％X</em>说明符中的使用<code>PatternLayout</code>转换模式。<em>％X</em>转换说明符被使用两次，一次用于名为<em>first</em>的键，一次用于<em>last</em>的键。获得对应的记录器后<code>SimpleMDC.class</code> ，该代码将值<em>Parker</em>与名为<em>last</em>的键相关联。然后，它使用不同的消息两次调用记录器。该代码通过设置<code>MDC</code>设置为不同的值并发出多个日志记录请求。运行SimpleMDC会产生：</p>

<div class="source"><pre>Dorothy Parker - Check enclosed.
Dorothy Parker - The most beautiful two words in English.
Richard Nixon - I am not a crook.
Richard Nixon - Attributed to the former US president. 17 Nov 1973.</pre></div>


		<p>的<code>SimpleMDC</code>该应用程序说明了如果配置正确，logback布局如何自动输出<code>MDC</code>信息。此外，将信息放入<code>MDC</code>可以被多个记录器调用使用。
		</p>
		
		<h3 class="doAnchor">进阶使用</h3>
		
		<p>映射的诊断上下文在客户端服务器体系结构中最为突出。通常，服务器上的多个线程将为多个客户端提供服务。虽然方法在<code>MDC</code>类是静态的，诊断上下文在每个线程的基础上进行管理，从而使每个服务器线程可以承载一个不同的<code>MDC</code>邮票。 <code>MDC</code>诸如<code>put()</code>和<code>get()</code>仅影响<code>MDC</code> <em>当前</em>线程的子代，以及当前线程的子代。的<code>MDC</code>在其他线程中不受影响。鉴于<code>MDC</code>信息是基于每个线程进行管理的，每个线程将拥有自己的副本<code>MDC</code> 。因此，开发人员无需担心使用线程编程时的线程安全性或同步性。 <code>MDC</code>因为它可以安全，透明地处理这些问题。
		</p>

		<p>下一个示例有些高级。它显示了<code>MDC</code>可以在客户端服务器设置中使用。服务器端实现<code>NumberCruncher</code>介面如范例7.2所示。<code>The NumberCruncher</code>接口包含一个名为的方法<code>factor()</code> 。客户端使用RMI技术调用<code>factor()</code>服务器应用程序的方法来检索整数的不同因子。
		</p>

<em>例7.2：服务接口（ <a href="../xref/chapters/mdc/NumberCruncher.html">logback-examples / src / main / java / chapters / mdc / NumberCruncher.java）</a></em>
<pre class="prettyprint source">package chapters.mdc;

import java.rmi.Remote;
import java.rmi.RemoteException;

/**
 * NumberCruncher factors positive integers.
 */
public interface NumberCruncher extends Remote {
  /**
   * Factor a positive integer <code>number</code> and return its
   * <em>distinct</em> factor's as an integer array.
   * */
  int[] factor(int number) throws RemoteException;
}</pre>

		<p>的<code>NumberCruncherServer</code>下面的示例7.3中列出的应用程序实现了<code>NumberCruncher</code>接口。它的主要方法是在本地主机上导出RMI注册表，该注册表接受一个知名端口上的请求。
		</p>

<em>例7.3：服务器端（ <a href="../xref/chapters/mdc/NumberCruncherServer.html">logback-examples / src / main / java / chapters / mdc / NumberCruncherServer.java）</a></em>
<pre class="prettyprint source">package chapters.mdc;

import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Vector;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;


/**
 * A simple NumberCruncher implementation that logs its progress when
 * factoring numbers. The purpose of the whole exercise is to show the
 * use of mapped diagnostic contexts in order to distinguish the log
 * output from different client requests.
 * */
public class NumberCruncherServer extends UnicastRemoteObject
  implements NumberCruncher {

  private static final long serialVersionUID = 1L;

  static Logger logger = LoggerFactory.getLogger(NumberCruncherServer.class);

  public NumberCruncherServer() throws RemoteException {
  }

  public int[] factor(int number) throws RemoteException {
    // The client's host is an important source of information.
    try {
      <b>MDC.put("client", NumberCruncherServer.getClientHost());</b>
    } catch (java.rmi.server.ServerNotActiveException e) {
      logger.warn("Caught unexpected ServerNotActiveException.", e);
    }

    // The information contained within the request is another source
    // of distinctive information. It might reveal the users name,
    // date of request, request ID etc. In servlet type environments,
    // useful information is contained in the HttpRequest or in the  
    // HttpSession.
    <b>MDC.put("number", String.valueOf(number));</b>

    logger.info("Beginning to factor.");

    if (number &lt;= 0) {
      throw new IllegalArgumentException(number +
        " is not a positive integer.");
    } else if (number == 1) {
      return new int[] { 1 };
    }

    Vector&lt;Integer> factors = new Vector&lt;Integer>();
    int n = number;

    for (int i = 2; (i &lt;= n) &amp;&amp; ((i * i) &lt;= number); i++) {
      // It is bad practice to place log requests within tight loops.
      // It is done here to show interleaved log output from
      // different requests. 
      logger.debug("Trying " + i + " as a factor.");

      if ((n % i) == 0) {
        logger.info("Found factor " + i);
        factors.addElement(new Integer(i));

        do {
          n /= i;
        } while ((n % i) == 0);
      }

      // Placing artificial delays in tight loops will also lead to
      // sub-optimal results. :-)
      delay(100);
    }

    if (n != 1) {
      logger.info("Found factor " + n);
      factors.addElement(new Integer(n));
    }

    int len = factors.size();

    int[] result = new int[len];

    for (int i = 0; i &lt; len; i++) {
      result[i] = ((Integer) factors.elementAt(i)).intValue();
    }

    <b>// clean up
    MDC.remove("client");
    MDC.remove("number");</b>

    return result;
  }

  static void usage(String msg) {
    System.err.println(msg);
    System.err.println("Usage: java chapters.mdc.NumberCruncherServer configFile\n" +
      "   where configFile is a logback configuration file.");
    System.exit(1);
  }

  public static void delay(int millis) {
    try {
      Thread.sleep(millis);
    } catch (InterruptedException e) {
    }
  }

  public static void main(String[] args) {
    if (args.length != 1) {
      usage("Wrong number of arguments.");
    }

    String configFile = args[0];

    if (configFile.endsWith(".xml")) {
      try {
        LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
        JoranConfigurator configurator = new JoranConfigurator();
        configurator.setContext(lc);
        lc.reset();
        configurator.doConfigure(args[0]);
      } catch (JoranException je) {
        je.printStackTrace();
      }
    }

    NumberCruncherServer ncs;

    try {
      ncs = new NumberCruncherServer();
      logger.info("Creating registry.");

      Registry registry = LocateRegistry.createRegistry(Registry.REGISTRY_PORT);
      registry.rebind("Factor", ncs);
      logger.info("NumberCruncherServer bound and ready.");
    } catch (Exception e) {
      logger.error("Could not bind NumberCruncherServer.", e);

      return;
    }
  }
}</pre>

		<p>实施<code>factor(int number)</code>方法特别重要。首先将客户端的主机名放入<code>MDC</code>在主要<em>客户下</em> 。根据客户要求将要分解的数字放入<code>MDC</code>在钥匙<em>号码下</em> 。计算完整数参数的不同因子后，结果将返回给客户端。然而，返回结果之前， <em>客户端</em>和<em>数量</em>值是通过调用清除<code>MDC.remove()</code>方法。通常情况下， <code>put()</code>操作应由相应的平衡<code>remove()</code>操作。否则， <code>MDC</code>将包含某些键的陈旧值。我们建议，只要有可能， <code>remove()</code>在finally块内执行操作，确保无论代码的执行路径如何都可以调用它们。
		</p>	
		
		<p>在进行了这些理论解释之后，我们准备运行数字运算器示例。使用以下命令启动服务器：</p>
		
<div class="source"><pre>java chapters.mdc.NumberCruncherServer src/main/java/chapters/mdc/mdc1.xml</pre></div>
		
		<p>下面列出了<em>mdc1.xml</em>配置文件：</p>
<em>例7.4：配置文件（logback-examples / src / main / java / chapters / mdc / mdc1.xml）</em>
<pre class="prettyprint source">&lt;configuration>
  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    &lt;layout>
      &lt;Pattern>%-4r [%thread] %-5level <b>C:%X{client} N:%X{number}</b> - %msg%n&lt;/Pattern>
    &lt;/layout>	    
  &lt;/appender>
  
  &lt;root level="debug">
    &lt;appender-ref ref="CONSOLE"/>
  &lt;/root>  
&lt;/configuration></pre>

		<p>请注意在“ <span class="option">模式”</span>选项中使用<em>％X</em>转换说明符。
		</p>
	
		<p>以下命令启动的实例<code>NumberCruncherClient</code>应用：</p>
		
<div class="source"><pre>java chapters.mdc.NumberCruncherClient <em>hostname</em></pre></div>

		<p>其中， <em>主机名</em>是其中的主机<code>NumberCruncherServer</code>在跑</p>
		
		<p>执行客户端的多个实例，并请求服务器从第一个客户端中分解出数字129，然后不久从第二个客户端中分解出数字71，服务器输出以下内容：</p>
		
<div class="source"><pre>
<b>70984 [RMI TCP Connection(4)-192.168.1.6] INFO  C:orion N:129 - Beginning to factor.</b>
70984 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 2 as a factor.
71093 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 3 as a factor.
71093 [RMI TCP Connection(4)-192.168.1.6] INFO  C:orion N:129 - Found factor 3
71187 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 4 as a factor.
71297 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 5 as a factor.
71390 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 6 as a factor.
<b>71453 [RMI TCP Connection(5)-192.168.1.6] INFO  C:orion N:71 - Beginning to factor.</b>
71453 [RMI TCP Connection(5)-192.168.1.6] DEBUG C:orion N:71 - Trying 2 as a factor.
71484 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 7 as a factor.
71547 [RMI TCP Connection(5)-192.168.1.6] DEBUG C:orion N:71 - Trying 3 as a factor.
71593 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 8 as a factor.
71656 [RMI TCP Connection(5)-192.168.1.6] DEBUG C:orion N:71 - Trying 4 as a factor.
71687 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 9 as a factor.
71750 [RMI TCP Connection(5)-192.168.1.6] DEBUG C:orion N:71 - Trying 5 as a factor.
71797 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 10 as a factor.
71859 [RMI TCP Connection(5)-192.168.1.6] DEBUG C:orion N:71 - Trying 6 as a factor.
71890 [RMI TCP Connection(4)-192.168.1.6] DEBUG C:orion N:129 - Trying 11 as a factor.
71953 [RMI TCP Connection(5)-192.168.1.6] DEBUG C:orion N:71 - Trying 7 as a factor.
72000 [RMI TCP Connection(4)-192.168.1.6] INFO  C:orion N:129 - Found factor 43
72062 [RMI TCP Connection(5)-192.168.1.6] DEBUG C:orion N:71 - Trying 8 as a factor.
72156 [RMI TCP Connection(5)-192.168.1.6] INFO  C:orion N:71 - Found factor 71</pre></div>

		<p>从上面的输出中可以看到，客户端是从称为<em>orion</em>的机器上运行的。即使服务器在单独的线程中几乎同时处理客户端的请求，也可以通过研究客户端的输出来区分与每个客户端请求有关的日志记录输出<code>MDC</code> 。请注意，例如，与<em>数字</em>关联的邮票，即要分解的数字。
		</p>
		
		<p>细心的读者可能已经注意到，线程名称也可以用于区分每个请求。如果服务器端技术回收线程，则线程名称可能引起混乱。在那种情况下，可能很难确定每个请求的边界，即给定线程何时完成为一个请求提供服务以及何时开始为下一个请求提供服务。因为<code>MDC</code>在应用程序开发人员的控制之下， <code>MDC</code>邮票不存在此问题。
		</p>
		
		
		
		<h3 class="doAnchor" name="autoMDC">自动访问<code>MDC</code></h3>
		
		<p>如我们所见， <code>MDC</code>与多个客户打交道时非常有用。对于管理用户身份验证的Web应用程序，一种简单的解决方案可以是在<code>MDC</code>并在用户注销后将其删除。不幸的是，使用这种技术并不总是可能获得可靠的结果。以来<code>MDC</code>在<em>每个线程的</em>基础上管理数据，回收线程的服务器可能会导致错误信息包含在<code>MDC</code> 。
		</p>
		
		<p>为了允许包含在<code>MDC</code>为了在处理请求时始终保持正确，可能的方法是在过程开始时存储用户名，并在过程结束时将其删除。一个servlet <a href="http://java.sun.com/javaee/5/docs/api/javax/servlet/Filter.html"><code>Filter</code></a>在这种情况下派上用场。
		</p>
		
		<p>在servlet过滤器的<code>doFilter</code>方法，我们可以通过请求（或其中的Cookie）检索相关的用户数据，并将其存储在<code>MDC</code> 。其他过滤器和Servlet的后续处理将自动受益于先前存储的MDC数据。最后，当我们的servlet过滤器重新获得控制权时，我们就有机会清除MDC数据。
		</p>
		
		<p>这是这种过滤器的实现：</p>

<em>例7.5：用户servlet过滤器（ <a href="../xref/chapters/mdc/UserServletFilter.html">logback-examples / src / main / java / chapters / mdc / UserServletFilter.java）</a></em>
<pre class="prettyprint source">package chapters.mdc;

import java.io.IOException;
import java.security.Principal;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.slf4j.MDC;

public class UserServletFilter implements Filter {

  private final String USER_KEY = "username";
  
  public void destroy() {
  }

  public void doFilter(ServletRequest request, ServletResponse response,
    FilterChain chain) throws IOException, ServletException {

    boolean successfulRegistration = false;

    HttpServletRequest req = (HttpServletRequest) request;    
    Principal principal = req.getUserPrincipal();
    // Please note that we could have also used a cookie to 
    // retrieve the user name

    if (principal != null) {
      String username = principal.getName();
      successfulRegistration = registerUsername(username);
    } 

    try {
      chain.doFilter(request, response);
    } finally {
      if (successfulRegistration) {
        MDC.remove(USER_KEY);
      }
    }
  }

  public void init(FilterConfig arg0) throws ServletException {
  }
  

  /**
   * Register the user in the MDC under USER_KEY.
   * 
   * @param username
   * @return true id the user can be successfully registered
   */
  private boolean registerUsername(String username) {
    if (username != null &amp;&amp; username.trim().length() > 0) {
      MDC.put(USER_KEY, username);
      return true;
    }
    return false;
  }
}</pre>

	<p>当过滤器的<code>doFilter()</code>方法被调用，它首先寻找一个<code>java.security.Principal</code>请求中的对象。该对象包含当前已认证用户的名称。如果找到用户信息，则将其注册到<code>MDC</code> 。
	</p>
		
	<p>过滤器链完成后，过滤器会将用户信息从<code>MDC</code> 。
	</p>

  <p>我们刚刚概述的方法仅在请求期间和处理线程的过程中设置MDC数据。其他线程不受影响。此外，任何给定线程在任何时间点都将包含正确的MDC数据。</p>
		


  <h3 class="doAnchor" name="managedThreads">MDC和托管线程</h3>

  <p>映射的诊断上下文的副本不能始终由工作线程从发起线程继承。这是当<code>java.util.concurrent.Executors</code>用于线程管理。例如， <code>newCachedThreadPool</code>方法创建一个<code>ThreadPoolExecutor</code>与其他线程池代码一样，它具有复杂的线程创建逻辑。
  </p>

  <p>在这种情况下，建议<code>MDC.getCopyOfContextMap()</code>在将任务提交给执行者之前，在原始（主）线程上调用。任务运行时，作为第一个动作，应调用<code>MDC.setContextMapValues()</code>将原始MDC值的存储副本与新的<code>Executor</code>托管线程。
  </p>

  <h3 class="doAnchor" name="mis">MDCInsertingServletFilter</h3>

  <p>在Web应用程序中，了解与给定HTTP请求关联的主机名，请求uri和用户代理通常会很有帮助。 <a href="../xref/ch/qos/logback/classic/helpers/MDCInsertingServletFilter.html"><code>MDCInsertingServletFilter</code></a>在以下键下将此类数据插入MDC。
  </p>

  <table class="bodyTable">
    <tbody><tr>
      <th>MDC密钥</th>
      <th>MDC值</th>
    </tr>

    <tr class="alt">
      <td><code>req.remoteHost</code></td>
      <td>由<a href="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/servlet/ServletRequest.html#getRemoteHost%28%29">getRemoteHost（）</a>方法返回</td>
    </tr>

    <tr>
      <td><code>req.xForwardedFor</code></td>
      <td><a href="http://en.wikipedia.org/wiki/X-Forwarded-For">“ X-Forwarded-For”</a>标头的值</td>
    </tr>

    <tr class="alt">
      <td><code>req.method</code></td>
      <td>由<a href="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/servlet/http/HttpServletRequest.html#getMethod%28%29">getMethod（）</a>方法返回</td>
    </tr>

    <tr>
      <td><code>req.requestURI</code></td>
      <td>由<a href="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/servlet/http/HttpServletRequest.html#getRequestURI%28%29">getRequestURI（）</a>方法返回</td>
    </tr>

    <tr class="alt">
      <td><code>req.requestURL</code></td>
      <td>由<a href="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/servlet/http/HttpServletRequest.html#getRequestURL%28%29">getRequestURL（）</a>方法返回</td>
    </tr>

    <tr>
      <td><code>req.queryString</code></td>
      <td>由<a href="http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/servlet/http/HttpServletRequest.html#getQueryString%28%29">getQueryString（）</a>方法返回</td>
    </tr>

    <tr class="alt">
      <td><code>req.userAgent</code></td>
      <td>“用户代理”标头的值</td>
    </tr>

  </tbody></table>

  <p>安装<code>MDCInsertingServletFilter</code> <em>将以下行</em>添加到Web应用程序的<em>web.xml</em>文件中</p>

  <pre class="prettyprint source">&lt;filter>
  &lt;filter-name>MDCInsertingServletFilter&lt;/filter-name>
  &lt;filter-class>
    ch.qos.logback.classic.helpers.MDCInsertingServletFilter
  &lt;/filter-class>
&lt;/filter>
&lt;filter-mapping>
  &lt;filter-name>MDCInsertingServletFilter&lt;/filter-name>
  &lt;url-pattern>/*&lt;/url-pattern>
&lt;/filter-mapping> </pre>

  <p><b>如果您的网络应用有多个过滤器，请确保<code>MDCInsertingServletFilter</code>在其他过滤器之前声明。</b> 例如，假设您的网络应用中的主要处理是在过滤器“ F”中完成的，则MDC值设置为<code>MDCInsertingServletFilter</code>如果“ F”调用的代码将看不到<code>MDCInsertingServletFilter</code>在“ F”之后。
  </p>

  <p>一旦安装了过滤器，对应于每个MDC密钥的值将由密钥首选通过的％X <a href="layouts.html#conversionWord">转换字</a>输出。例如，要打印远程主机，然后在一行上打印请求URI，在下一行上打印日期，然后在消息上打印，则需要设置<code>PatternLayout</code>的模式为：</p>

  <p class="source">％X {req.remoteHost}％X {req.requestURI}％n％d-％m％n</p>

  <script src="../templates/footer.js" type="text/javascript"></script>
</div>


</body></html>