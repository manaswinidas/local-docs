<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第14章レシーバー</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content">

      <h1>第14章レシーバー</h1>

      <div class="quote">

        <p><em>岸が见えなくなることを恐れない勇気が无ければ，地平线の向こうまで泳ぎ着くことはできない。</em></p>
  
        <p>—威廉·福克纳</p>
      </div>


    <script type="text/javascript" src="../templates/creative.js"></script>
    <script type="text/javascript" src="../templates/setup.js"></script>
    
      <h2 class="doAnchor" name="whatIsAReceiver">レシーバーとは何か？</h2>
    
      <p><em>しーバー</em>とは，リモートアペンダーからロギンギイベントを受信し，ローカルポリシーに基にいてログに记录するlogbackのコンポーネントです。でットベースのアペンダートレシーバーをーみ组み合わせることで，分散アプリケーションショログングイをネントをネットワーク越する配信する高度なトポロジーを実现することができます。</p>
  
      <p>レシーバーは<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/ReceiverBase.html">ch.qos.logback.classic.net.ReceiverBase</a></code>クラスを継承しています。おかげで<a href="http://logback.qos.ch/xref/ch/qos/logback/core/spi/LifeCycle.html">LifeCycle</a>に参加できるし，レシーバー自体が<a href="http://logback.qos.ch/xref/ch/qos/logback/core/spi/ContextAware.html">ContextAware</a>になります。</p>
    
      <p>歴史的な経纬により，logbackによるネットワーク越しのロギングイベントの配信は<code>SocketAppender</code>と<code>SimpleSocketServer</code>によって実现されてきました。アペンダーはクライアントとして动作します。続をーバーアプリケーションショのネットワーク接続を设置し，ロギングイベントベ配信するのです。をーバーコンポーネントと対応するアペンダーを使うことで，より优れた柔软性を実现することができます。</p>
    
      <p>はーバーコンポーネントは他のlogbackのコンポーネントと同様に<em>logback.xml</em>で设定します。つまり， <a href="./11-onJoran.html">Joran</a>の全ての机能を利用することができるのです。复，复数のレシーバーコンコーネンネントを设定するだけで， <em>あらゆる</em>アプリケーションのリモートアペンダーからロギングイベントを受け付けることができます。</p>
    
      <p>アペンダーとレシーバー间のネットワーク接続の连接はどちら侧からでも始めることができます。してーバーはサーバーとして振る舞うことができます。続を，クライアントたるリモートアペンダーからの接続を待ち受けることができます。レシーバーはクライアントとして振る舞うこともできます。してーバーとして振る舞うリモートアペンダーに対してネットワーク接続を建立することができるのです。アペンダーとレシーバーのそれぞれの役割とは无关系に， <em>ロギングイベントは常にアペンダーからレシーバーに送信されます</em> 。</p>
    
      <p>にーバーからアペンダーに接続できることは，特定の状况においてとても有用です。</p>
      <ul>
        <li>セキュリティ上の観点から，中央ロギングサーバーはファイアーウォールの后ろ侧に配置されることが多いです。，外部からの接続が许されないのです。でーバーコンポーネントがクライアントとして振る舞うことで，中央ロギングサーバー（ファイアーウォールの内侧）から対象のアプリケーション（ファイアーウォールの篱笆）に接続することができます。
        </li>
        <li>IDEのプラグインなどの开発者ツールに最适です。また，実行中のアプリケーションショ生成するロギングイベントのストリームへのアクセスを，企业统制の仕组みによって管理するのにも适しています。伝统的に，logbackでこのような状况に対応する（たとえばlogback Beagleなど）には，宛先のアプリケーション（たとえばIDEで実行される开発者ツール）がサーバーの役割を担う必要がありました。管理が大変になることは明らかです。特に，开発者のワークステーションショ行しているツールならなおさらです。モバイルPCが一般的になってきているのも悩みの种になります。今では，それらのツールはクライアントとしてのレシーバーコンポーネントを実装すればよくなりました。手元でロギングイベントをフィルタしたり，警告を上げたり，内容を确认するには，リモートアペンダーに接続すればよいのです。
        </li>
      </ul>

      <p>logbackの设定には，サーバーあるいはクライアントのいずれかの役割を担うレシーバーコンポーネントを混在させることができます。数少ない制限として，サーバーとして振る舞うレシーバーコンコーネントはそれぞれ固有のポート番号で接続を待ち受けなければならないということと，クライントとして振バ舞うレシーバーコンコーネンネーネントはそれぞれただ1つのリモートアペンダーにしか接続してはならないということがあります。</p>
    
      <h2 class="doAnchor" name="receiverServerComponents">サーバーとして振る舞うレシーバー</h2>
    
      <p>してーバーとして振る舞うレシーバーはリモートアペンダーからの接続を待ち受けます。これはスタンドアローンの<code>SimpleSocketServer</code>アプリケーションと同じ机能です。ただし，レシーバーコンポーネントなら<em>，logback.xml</em>に设定するだけで，的logback经典モジュールを使っているあらゆる<em>{\</em> 1}アプリケーションからロギングイベントを受信することができます。</p>
        
      <p>
        <img border="1" src="images/chapters/receivers/serverSocketReceiver.png">
      </p>

      <p>logbackの配布物には二つのレシーバーコンコーネントが含まれています。<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/server/ServerSocketReceiver.html">ServerSocketReceiver</a></code>とそのSSL対応の<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/server/SSLServerSocketReceiver.html"><code>SSLServerSocketReceiver</code></a>です。どちらも<code>SocketAppender</code> （あるいは<code>SSLSocketAppender</code> ）からの接続を待ち受けるように设计されています。</p>
        
      <p><code>ServerSocketReceiver</code>の设定可能なプロパティは次のとおりです。</p>
    
      <table class="bodyTable striped">
        <tbody><tr>
          <th>プロパティ名</th>
          <th>型</th>
          <th>说明</th>
        </tr>
        <tr>
          <td><span class="prop" container="serverSocketReceiver">地址</span></td>
          <td><code>String</code></td>
          <td>がーバーが待ち受けるローカルネットワークインターフェイスのネットワークアドレス。场合のプロパティが指定されない场合，レシーバーは全てのネットワークインターフェイスで待ち受けるようになります。</td>
        </tr>
        <tr>
          <td><span class="prop" container="serverSocketReceiver">港口</span></td>
          <td><code>int</code></td>
          <td>ーバーが待ち受けるTCPのポート番号。のプロパティが指定されない场合，デフォルト値が使用されます。</td>
        </tr>
        <tr>
          <td><span class="prop" container="serverSocketReceiver">ssl</span></td>
          <td><code>SSLConfiguration</code></td>
          <td><code>SSLServerSocketReceiver</code>でのみサポートされているプロパティです。このプロパティには<a href="./15-usingSSL.html">SSLを使用する</a>で说明されているSSLの设定を指定します。</td>
        </tr>
      </tbody></table>
    
      <h3 class="doAnchor" name="usingServerSocketReceiver">ServerSocketReceiverの使い方</h3>
    
      <p>次の设定は，最小限のアペンダーとロガーの设定とともに<code>ServerSocketReceiver</code>を使用するものです。リーートアペンダーから受信したロギンギイベントは，ルートロガーに渡に，ローカルのコンソールアペンダーダ配に。</p>
    
      <p class="example">例：基本的なServerSocketReceiverの设定（ <a href="http://logback.qos.ch/xref/chapters/receivers/socket/receiver1.xml">logback-examples / src / main / java / chapters / receivers / socket / receiver1.xml</a> ）</p>

      <span class="asGroovy" onclick="return asGroovy('receiver1');">Groovyとして表示</span>
  <pre id="receiver1" class="prettyprint source">&lt;configuration debug="true"&gt;

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="CONSOLE" /&gt;
  &lt;/root&gt;

  &lt;receiver class="ch.qos.logback.classic.net.server.ServerSocketReceiver"&gt;
    &lt;port&gt;${port}&lt;/port&gt;
  &lt;/receiver&gt;

&lt;/configuration&gt;</pre>
  
      <p><em>class</em>ーバーコンポーネントの<em>类属性</em>に指定した値によって，レシーバーのサブタイプを指定します。ここでは<code>ServerSocketReceiver</code>を指定しています。</p>
    
      <p>例として， <code>SimpleSocketServer</code>と非常によく似た机能を持ったサーバーアプリケーションを用意しました。logbackの设定ファイルへのパスをコマンドライン引数から受け取って，指定された设定ファイルを読み込みます。この例のアプリケーションは大した仕事をするわけではありませんが， <code>ServerSocketReceiver</code> （あるいは<code>SSLServerSocketReceiver</code> ）は<em>どんな</em>アプリケーションからでも利用できることを覚えておきましょう。
      </p>
    
      <p>でンドをプロンプトで<em>logback-examplesディレクトリ</em>に移动して，次のコマンドを実行しましょう。</p>
    
      <p class="source">java -Dport = 6000 <a href="http://logback.qos.ch/xref/chapters/receivers/socket/ReceiverExample.html">chapters.receivers.socket。ReceiverExample</a> \ src / main / java / chapters / receivers / socket / receiver1.xml</p>
  
      <p>クライアントアプリケーションで<code>SocketAppender</code>を设定して，実行中のレシーバーに接続することができます。はンプルのクライアントアプリケーションは，上记のレシーバーにー続する接続する设定ファイルを読み込むだけのものです。クライアントアプリケーションはユーザー入力を待ちます。ユーザー入力はそのままレシーバーに中継されます。クライアントアプリケーションは次のように実行します。</p>
    
      <p class="source">java -Dhost = localhost -Dport = 6000 \ <a href="http://logback.qos.ch/xref/chapters/receivers/socket/AppenderExample.html">chapters.receivers.socket。AppenderExample</a> \ src / main / java / chapters / receivers / socket / appender1.xml</p>
    
      <h3 class="doAnchor" name="usingSSLServerSocketReceiver">SSLServerSocketReceiverの使い方</h3>

      <p>次の设定は，前の设定とは违ってSSLに対応したレシーバーを使うものです。</p>

      <p class="example">例：基本的なSSLServerSocketReceiverの设定（ <a href="http://logback.qos.ch/xref/chapters/receivers/socket/receiver2.xml">logback-examples / src / main / java / chapters / receivers / socket / receiver2.xml</a> ）</p>

      <span class="asGroovy" onclick="return asGroovy('receiver2');">Groovyとして表示</span>
  <pre id="receiver2" class="prettyprint source">&lt;configuration debug="true"&gt;

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="CONSOLE" /&gt;
  &lt;/root&gt;

  &lt;receiver class="ch.qos.logback.classic.net.server.SSLServerSocketReceiver"&gt;
    &lt;port&gt;${port}&lt;/port&gt;
    &lt;ssl&gt;
      &lt;keyStore&gt;
        &lt;location&gt;${keystore}&lt;/location&gt;
        &lt;password&gt;${password}&lt;/password&gt;
      &lt;/keyStore&gt;
    &lt;/ssl&gt;
  &lt;/receiver&gt;

&lt;/configuration&gt;</pre>

      <p>前の<code>ServerSocketReceiver</code>を使った设定とこちらの设定で根本的に违うのは，レシーバーの<em>类属性</em>に<code>SSLServerSocketReceiver</code>が指定されていることと， <span class="prop">ssl</span>プロパティがネストされていることです。sslプロパティにはレシーバーの秘密键と证明书が配置されたキーストアの场所とパスワードを，変数で指定しています。sslプロパティの设定内容について详しくは<a href="./15-usingSSL.html">SSLを使用する</a>を参照してください。</p>    
 
      <p>いくつか引数を追加して次のようにサーバーアプリケーションを実行します。</p>

      <p class="source">java -Dport = 6001 \ -Dkeystore = file：src / main / java / chapters / appenders / socket / ssl / keystore.jks \ -Dpassword = changeit \ chapters.receivers.socket。ReceiverExample \ src / main / java / chapters / receivers / socket / receiver2.xml</p>
  
      <p>パティンドラインで指定したプロパティ<em>keystore</em>には，キーストアの文件から始まるURLを指定します。<a href="./15-usingSSL.html">SSLを使用する</a>でも说明していますが，クラスパス上のリソースを指定することもできます。</p>
    
      <p>にはのレシーバーには，クライアントアプリケーションから<code>SSLSocketAppender</code>で接続することができます。SSL対応のアペンダーを使う设定ファイルを，前の例で使用したクライアントアプリケーションから使うことができます。次のように実行します。</p>
    
      <p class="source">java -Dhost = localhost -Dport = 6001 \ -Dtruststore = file：src / main / java / chapters / appenders / socket / ssl / truststore.jks \ -Dpassword = changeit \ chapters.receivers.socket。AppenderExample \ src / main / java / chapters / receivers / socket / appender2.xml</p>
    
      <p>。の例では自己机构名したX.509证明书を使用していますが，これを使っていいのはテストや実験的な用途だけです。<strong>本番环境では，SSL対応のアペンダーのために适切なX.509证明书を使うようにしてください</strong> 。详细は<a href="./15-usingSSL.html">SSLを使用する</a>を参照してください。</p>
  
      <h2 class="doAnchor" name="receiverClientComponents">クライアントとして振る舞うレシーバー</h2>
    
      <p>クライアントとして振る舞うように设定したレシーバーは，リモートアペンダーに接続します。リモートアペンダーは<code>ServerSocketAppender</code>などのサーバ型でなければなりません。</p>  
    
      <p>
        <img border="1" src="images/chapters/receivers/socketReceiver.png">
      </p>

      <p>logackの配布物にはクライアントとして振る舞うレシーバーコンコーネントが2つ含まれています。<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/SocketReceiver.html">SocketReceiver</a></code>とそのSSL対応版の<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/net/SSLSocketReceiver.html"><code>SSLSocketReceiver</code></a>です。（のレシーバーもリモートアペンダー（ <code>ServerSocketAppender</code>あるいは<code>SSLServerSocketAppender</code> ）に対して接続を重置するようになっています。</p>
        
      <p><code>SocketReceiver</code>の派生クラスで设定可能なプロパティは次のとおりです。</p>
    
      <table class="bodyTable striped">
        <tbody><tr>
        <th>プロパティ名</th>
        <th>型</th>
        <th>说明</th>
        </tr>
        <tr>
          <td><span class="prop" container="SocketReceiver">远程主机</span></td>
          <td><code>String</code></td>
          <td>リモートアペンダーのホスト名またはIPアドレス。</td>
        </tr>
        <tr>
          <td><span class="prop" container="SocketReceiver">港口</span></td>
          <td><code>int</code></td>
          <td>リモートアペンダーの待ち受けポート番号。</td>
        </tr> 
        <tr>
          <td><span class="prop" container="socket">重新连接延迟</span></td>
          <td><code>int</code></td>
          <td>接続异常が発生した后で，再接続をする前に待机する时间を表す正の整体値。単位はミリ秒。0000フォルト値は30000（30秒）です。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="SocketReceiver">ssl</span></td>
          <td><code>SSLConfiguration</code></td>
          <td><code>SSLSocketReceiver</code>でのみ设定可能なプロパティ。<a href="./15-usingSSL.html">SSLを使用する</a>で说明しているとおり，SSLの设定を指定します。</td>
        </tr>
      </tbody></table>
        
      <h3 class="doAnchor" name="usingSocketReceiver">SocketReceiverの使い方</h3>

      <p><code>SocketReceiver</code>の设定は<code>ServerSocketReceiver</code>の设定と非常によく似ています。うの差は，サーバーとクライアントという真逆の役割に起因するものです。<code>SocketReceiver</code>はクライアントで，リモートアペンダはサーバーとして动作します。</p>
        
      <p class="example">例：基本的なSocketReceiverの设定（ <a href="http://logback.qos.ch/xref/chapters/receivers/socket/receiver3.xml">logback-examples / src / main / java / chapters / receivers / socket / receiver3.xml</a> ）</p>
      <span class="asGroovy" onclick="return asGroovy('receiver3');">Groovyとして表示</span>
  <pre id="receiver3" class="prettyprint source">&lt;configuration debug="true"&gt;
    
  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;    
    &lt;encoder&gt;
      &lt;pattern&gt;%date %-5level [%thread] %logger - %message%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="CONSOLE" /&gt;
  &lt;/root&gt;  

  &lt;receiver class="ch.qos.logback.classic.net.SocketReceiver"&gt;
    &lt;remoteHost&gt;${host}&lt;/remoteHost&gt;
    &lt;port&gt;${port}&lt;/port&gt;
    &lt;reconnectionDelay&gt;10000&lt;/reconnectionDelay&gt;
  &lt;/receiver&gt;

&lt;/configuration&gt;</pre>
        
      <p>だの设定だと，logbackは<em>host</em>変数で指定されたホストの， <em>port</em>変数で指定されたポート番号で実行中の<code>ServerSocketAppender</code>へ接続します。リモートアペンダーから受け取ったロギングイベントは，手元でコンソールアペンペーダ渡に。
      </p>
   
      <p>でンドプロンプトで<em>logback-examples</em>ディレクトリに移动して，次のコマンドを実行してみましょう。</p>

         

      <p>记ンプルアプリケーションショ上记の设定ファイルを読み込んだあと，リモートアペンダーからのロギングイベントを待ち受けます。リモートアペンダーが落ちているときは，定期的に<em>接続を拒否された</em>メッセージが出力されます。再接続が成功するか，アプリケーションショ停止するまで，レシーバーは定期的にリモートアペンダーへの再接続を缲り返します。设定例にあるとおり，再接続の间隔は<span class="prop">reconnectionDelay</span>プロパティで指定することができます。</p><p class="source">java -Dhost = localhost -Dport = 6000 \ chapters.receivers.socket。ReceiverExample \ src / main / java / chapters / receivers / socket / receiver3.xml</p>

      <p>はの例のレシーバーは，前のアプリケーションのアペンダーにそのまま接続できます。アペンダー用のサンプルアプリケーションは， <code>ServerSocketAppender</code>使った设定ファイルを読み込んでから，ユーザー入力を待ちます。ユーザー入力はアペンダーに接続してきたレシーバーに配信されます。アペンダー用のサンプルアプリケーションを実行を実。</p>

      <p class="source">java -Dport = 6000 \ chapters.receivers.socket。AppenderExample \ src / main / java / chapters / receivers / socket / appender3.xml</p>   

      <p>がーバーが接続する前に入力したメッセージは破弃されます。わかりやすいですね。</p>

      <h3 class="doAnchor" name="usingSSLSocketReceiver">SocketSSLReceiverの使い方</h3>


      <p><code>SSLSocketReceiver</code>の设定は<code>SocketReceiver</code>の设定とほとんど変わりません。根本的に违うのは，レシーバーの类属性の指定と， <span class="prop">ssl</span>プロパティがネストされていることです。基本的な设定を见てみましょう。</p>
   
      <p class="example">例：基本的なSSLSocketReceiverの设定（ <a href="http://logback.qos.ch/xref/chapters/receivers/socket/receiver4.xml">logback-examples / src / main / java / chapters / receivers / socket / receiver4.xml</a> ）</p>

      <span class="asGroovy" onclick="return asGroovy('receiver4');">Groovyとして表示</span>
  <pre id="receiver4" class="prettyprint source">&lt;configuration debug="true"&gt;

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender"&gt;    
    &lt;encoder&gt;
      &lt;pattern&gt;%date %-5level [%thread] %logger - %message%n&lt;/pattern&gt;
    &lt;/encoder&gt;         
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="CONSOLE" /&gt;
  &lt;/root&gt;  
 
  &lt;receiver class="ch.qos.logback.classic.net.SSLSocketReceiver"&gt;
    &lt;remoteHost&gt;${host}&lt;/remoteHost&gt;
    &lt;port&gt;${port}&lt;/port&gt;
    &lt;reconnectionDelay&gt;10000&lt;/reconnectionDelay&gt;
    &lt;ssl&gt;
      &lt;trustStore&gt;
        &lt;location&gt;${truststore}&lt;/location&gt;
        &lt;password&gt;${password}&lt;/password&gt;
      &lt;/trustStore&gt;
    &lt;/ssl&gt;
  &lt;/receiver&gt;

&lt;/configuration&gt;</pre>

      <p><em>类</em>属性に<code>SSLSocketReceiver</code>指定していること，そして，リモートアペンペーが信頼できるかどうかを検证するために使用するトラストストアの场所とパスワードを指定しているところが重要なところです。sslプロパティの设定内容について详しくは<a href="./15-usingSSL.html">SSLを使用する</a>を参照してください。

      </p>
  
      <p>をつかってレシの设定をつかってレシーバーのサンプルアプリケーションを実行しましょう。</p>
  
      <p class="source">java -Dhost = localhost -Dport = 6001 \ -Dtruststore = file：src / main / java / chapters / appenders / socket / ssl / truststore.jks \ -Dpassword = changeit \ chapters.receivers.socket。ReceiverExample \ src / main / java / chapters / receivers / socket / receiver4.xml</p>   
   
      <p>アプリケーションが开始すると，レシーバーは设定ファイルで指定されたリモートアペンダーに接続しようとします。定期アペンダーが実行されていないときは，定期的に“接続を拒否されました”というメッセージがログに出力されrrます。connectionーバーは<span class="prop">reconnectionDelay</span>プロパティで指定した时间间隔で，アペンダーに接続できるまで，再接続を缲り返します。
      </p>
  
      <p>がーバーが接続するアペンペーのためのサンプルアプリケーションを実行を実。アプリケーションが开始すると，アプリケーションがーはー入力を待ち受けます。<code>SSLServerSocketAppender</code>続をーバーからの接続を待ち受けつつ，接続されているレシーバーにユーザー入力をメッセージとして発生したロギングイベントを配信します。アペンダーのサンプルアプリケーションを実行を実。</p>

      <p class="source">java -Dport = 6001 \ -Dkeystore = file：src / main / java / chapters / appenders / socket / ssl / keystore.jks \ -Dpassword = changeit \ chapters.receivers.socket。AppenderExample \ src / main / java / chapters / receivers / socket / appender4.xml</p>   

      <p>がーバーが接続していない状态で何か入力しても，そのメッセージは単纯に破弃されるだけです。</p>

      <p>。返しになりますが，この例では自己署名したX.509证明书を使用していますが，これはあくまでもテストだからです。<strong>本番环境においては，SSL対応のlogbackコンポーネントが自身の身元を证明するため，适切なX.509证明书を取得しなければなりません</strong> 。详しくは<a href="./15-usingSSL.html">SSLを使用する</a>を参照してください。
</p>
  
    <script src="../templates/footer.js" type="text/javascript"></script>

    <p></p></div>
    
</body></html>