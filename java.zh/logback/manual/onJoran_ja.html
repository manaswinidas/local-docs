<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第11章乔兰</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content">
      
    <h1>第11章乔兰</h1>

    <div class="quote">
      <p><em>答えは风に吹かれている。答えは风に吹かれている。</em></p>
      
      <p><em>—鲍勃·迪伦（</em> BOB DYLAN）</p>
    </div>

    <p>Joranとは，ジュネーブ湖で一年中吹きすさんでいる冷たい北西风のことです。からややーブ湖は西ヨーロッパの中央からやや右にある湖で，ヨーロッパにいくつもある他の湖と比べるとずっと狭い湖です。は，平均水深は153メートルと非常に深く，西ヨーロッパ最大の淡水湖として知られています。
    </p>


    <p>での章で说明したように，登录はJoran设定フレームワークの成熟した，柔软で，强力な机能を頼りにしています。logbackのモジュールが提供する机能の大部分は，Joran无しでは実现できません。ではの章では，Joranの设计の根干部分と，顕着な特徴に焦点を当てていきます。
    </p>

    <p>Joranはロギングとは完全に无关系な，泛用设定システムです。をの点を明らかにするため，logback-coreモジュールにはロガーに关わる要素が一切存在しないことに触れておかなければなりません。に，本章に登场するほとんどの例に，ロガーもアペンダーもレイアウトウ出てこないこともそれを后押ししています。
    </p>

    <p>での章で使っている例は<em>LOGBACK_HOME / logback-examples / src / main / java / chapters / onJoran</em>に配置されています。
    </p>

    <p>Joranのインストールは简単です。<a href="http://logback.qos.ch/download.html">logbackをダウンロード</a>して，クラスパスに<em>logback-core-1.1.2.jar</em>を追加するだけです。</p>
    
    <h2 class="doAnchor">歴史的な観点</h2>

    <p>リフレクションは，宣言的にソフトウェアシステムを设定テムをきるようにしてくれる，Java言语の强力な机能です。たとえば，EJBの重要なプロパティの多くは<em>ejb.xml</em>で设定します。EJBがJavaで実装されているとしても，それらのプロパティのほとんどが<em>ejb.xml</em>で指定されるのです。同じように，logbackの设定もXML形式の设定ファイルで指定します。JDK1.5から引入されたアノテーションは，以前ならXMLで设定されていたものを置き换えるためにEJB3.0で多用されています。Joranもアノテーションは利用しますが，ほんの少しだけです。EJBに比べてlogbackの设定には动的な要素が多いので，Joranでアノテーションを活用できる范囲が限られてしまうのです。
    </p>

    <p>logbackの前身のlog4jでは， <code>DOMConfigurator</code> （log4j1.2.x以降に含にいます）がXML形式の设定ファイルをパースするために使われていました。<code>DOMConfigurator</code>设定，设定ファイルの构造を変えるたびに，コードを微调整しなければならない作りになっていました。修正したコードは，再コンパイルして再デプロイしなければなりません。同じくらい重要なのが， <code>DOMConfigurator</code>のコードは，たくさんのまばらなif / else文を含む子要素をループするような作りになっていたことです。たいして役に立ちませんでしたし，冗长であちこちに重复があるコードでした。aceのとき， <a href="http://jakarta.apache.org/commons/digester/">Apace commons-digester</a>ではパターンマッチ规则に基づいたXMLのパースができていました。消化器は，パース时に指定したパターンにマッチしたら，こちらも指定されたルールを适用します。さくていていのルールクラスは小さくて，1つのことしかやっていませんでした。のため，理解するのも保守するのも比较的简単でした。
    </p>

    <p>私たちは<code>DOMConfigurator</code>の経験を武器にしてlogbackで使うための设定フレームワーク<code>Joran</code>の开発を始めました。Joranはcommons-digesterに强く影响を受けています。にもかかわらず，使っている用语が若干异なります。たとえば，Commons-digesterだとルールとパターンは一绪に使うものでした。消化器の<code>addRule(String pattern, Rule rule)</code>メソッドがいい例です。私たちは，ルールがルールによって构成されている（再帰的という意味ではなく别の意味で）と，不会な乱を招くことに気づきました。Jo，Joranではルールがパターンとアクションで构成されるものとしました。アクションとは，対応するパターンがマッチしたときに行われる操作です。がーンとアクションの关系が，Joranの中核を为していると言ってもおかしくありません。着にあらわれているのが，単纯なパターンを使って非常に复雑な要件を満たすことができるというところです。具体的には正确なマッチングとワイルドカードのマッチングによって実现されています。
    </p>

    <h3 class="doAnchor" name="saxOrDom">SAXかDOMか</h3>

    <p>SAXのAPIはイベントベースのアーキテクチャなので，SAXをベースにしたツールで前方参照を扱うのは决して简単なことではありません。前方参照とは，现在の要素よりも后で定义される要素を参照することです。同様に循环参照も手强い相手です。一般的な话ですが，DOM APIなら全要素を検索対象にできるし，前方の要素にジャンプすることもできるのです。
    </p>
    
    <p>みていった柔软性についてのあれこれを鉴みて，Joranでは当初DOM APIを使ってパースしていました。试行错误の后，パターンとアクションの形式で表现されたルールを解釈する上で，DOMツリーをパースしてる途中で离れた要素にジャンプできても意味が无いことが明らかになりました。<em>Joranに必要だったのは，XMLドキュメントの要素を，深さ优先で逐次的に走查していくことだけだったのです。</em>
    </p>

    <p>また，SAX APIには要素の位置を取得するものがあったので，Joranは问题のあった行番号と列番号を表示できるようにもなりました。位置情报があれば，パースエラーの起きている场所を简単に特定することができます。
    </p>
    
    <h3>象外事项</h3>

    <p>高度な可変性を求められていることもあり，JoranのAPIは双重要素にもなる巨大なXMLドキュメントを扱うようには设计されていません。
    </p>


    <h3 class="doAnchor" name="pattern">ンーン</h3>

    <p>Joranのパターンとは基本的に文字列です。<em>正确なパターン</em>と<em>ワイルドカードパターン</em>の2种があります。aーン“ a / b”は，最上位要素<code>a</code>にネストされた要素<code>b</code>にマッチします。他の要素にはマッチしないことから，これは<em>正确なパターン</em>だと言えます。</p>

    <p>ドはイルドカードは，接尾辞または关节辞をマッチさせるときに使われます。*とえばパターン“ * / a”は接尾辞が“ a”であるものすべてにマッチします。ドキュメ，XMLドキュメント中で要素<code>a</code>をネストしているあらゆる要素がマッチするのです。パターン“ a / *”は接头辞が“ a”なので，要素<code>a</code>がネストしているあらゆる要素がマッチすることになります。
    </p>

    <h3 class="doAnchor" name="action">アクション</h3>
    
    <p>前に述べたように，Joranはパターンに关连付けられたルールをパースします。アクションは， <a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/action/Action.html"><code>Action</code></a>クラスを継承したもので，次のような抽象メソッドで肉付けします。他のメソッドは简洁にするために省略されています。
    </p>


    <pre class="prettyprint source">package ch.qos.logback.core.joran.action;

import org.xml.sax.Attributes;
import ch.qos.logback.core.joran.spi.ExecutionContext;

public abstract class Action {
  /**
   * Called when the parser encounters an element matching a
   * {@link ch.qos.logback.core.joran.spi.Pattern Pattern}.
   */
  public abstract void begin(InterpretationContext ic, String name,
      Attributes attributes) throws ActionException;

  /**
   * Called to pass the body (as text) contained within an element.
   */
  public void body(InterpretationContext ic, String body)
      throws ActionException {
    // NOP
  }

  /*
   * Called when the parser encounters an endElement event matching a
   * {@link ch.qos.logback.core.joran.spi.Pattern Pattern}.
   */
  public abstract void end(InterpretationContext ic, String name)
      throws ActionException;
}</pre>

   <p>ごらんのように，アクションは<code>begin()</code>メソッドと<code>end()</code>メソッドを実装しなければなりません。<code>body()</code>メソッドを実装するかどうかは选択可能ですが。<code>Action</code>クラスは空実装を提供しているからです。</p>


   <h3 class="doAnchor" name="ruleStore">规则库</h3>

   <p>前面のように，パターンマッチと关连するアクションの実行がJoranの中心的な考え方です。ルールはパターンとアクションを关连付けるものです。<a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/spi/RuleStore.html">uleRuleStore</a>に保存されます。
   </p>

   <p>向前したとり，JoranはSAX APIを使っています。SAX APIとは，XMLドキュメントのそれぞれの要素についてstart / body / endといいうイベントを生成しながらパースを进めていくものです。Joranコフィギュレーターは，イベントを受け付けると<em>今のパターン</em>に対応したアクションをルールストアから探してきます。のとえば，最上位要素<em>A</em>にネストされた要素<em>B</em>のstart / body / endイベントなら，今のパターンとは“ A / B”になります。今のパターンとは，JoranがSAXイベントを受け付けながら自动的に调整するデータ构造なのです。</p>

   <p>今のパターンにいくつかのルールがマッチするときは，正确なマッチが接尾辞职マッチより优先チより。そして接尾辞マッチは关节辞マッチより优先チより。装の详细については<a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/spi/SimpleRuleStore.html">SimpleRuleStoreの</a>を<a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/spi/SimpleRuleStore.html">参照</a>してください。
   </p>
   

   <h3 class="doAnchor" name="interpretationContext">解釈コンテキスト</h3>

   <p>いろいろなアクションが协调が动作させるため，beginメソッドとendメソッドの一つ目の引数に解釈コンテキストが渡されます。解釈コンテキストには，オブジェクトスタック，オブジェクトマップ，エラーリスト，アクションを呼び出したJoranインタプリタへの参照が含がいます。解釈コンテキストの完全なフィールドが知りたければ<a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/spi/InterpretationContext.html"><code>InterpretationContext</code></a>を见てください。
   </p>
   
   <p>アクションは，共通のオブジェクトスタックに対するフェッチ，プッシュ，ポップといった操作や， 。また，解釈コンテキストのの<code>StatusManager</code>をラーを追加することで，问题が起きたことを报告することができます。
   </p>
   
   <h3 class="doAnchor" name="helloWorld">こんにちは</h3>
   
   <p>最初に，Joranを使うために必要最低限の构成を见てもらいます。<code><a href="http://logback.qos.ch/xref/chapters/onJoran/helloWorld/HelloWorldAction.html">HelloWorldAction</a></code>は， <code>begin()</code>にンソールに“ Hello World”と出力するだけの小さなアクションです。XMLファイルはコンフィギュレーターでパースします。この章の说明用に，非常に小さくて単纯な<a href="http://logback.qos.ch/xref/chapters/onJoran/SimpleConfigurator.html"><code>SimpleConfigurator</code></a>というコンフィギュレーターを用意しました。<a href="http://logback.qos.ch/xref/chapters/onJoran/helloWorld/HelloWorld.html"><code>HelloWorld</code></a>アプリケーションはこれらの部品を全部使用します。</p>

   <ul>
     <li>ルールマップと<code>Context</code>を用意します</li>
     <li><code>HelloWorldAction</code>と<em>hello-world</em>パターンを关连付けて，パースルールを用意します</li>
     <li><code>SimpleConfigutator</code>を用意して，ルールマップを渡します</li>
     <li>XMLファイルを引数として，コンフィギュレーターの<code>doConfigure()</code>メソッドを呼び出します</li>
     <li>最后に，もしあれば解釈コンテキストに蓄积されたステータスメッセージを出力します</li>
   </ul>

    <p><em>hello.xml</em>には何もネストしていない1つのhello-world要素があります。<em>logback-examples / src / main / java / chapters / onJoran / helloWorld /</em>フォルダを指してください。
    </p>
 
    <p><em>hello.xml</em>ファイルを指定してHelloWorldアプリケーションを実行すると，コンソールに“ Hello World”と出力します。</p>
   
    <p class="command">Java chapter.onJoran.helloWorld。HelloWorld src / main / java / chapters / onJoran / helloWorld / hello.xml</p>

    <p>ルーストアに新しいルールを追加したり，XMLドキュメントを変更してみたり，新しいアクションを追加するなど，いろいろと试してみたくなったでしょう？
    </p>

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="calculator">アクションの协调</h3>
   
    <p>共通のオブジェクトスタックをンじて协调して简単な计算をするアクションが， <em>logback-examples / src / main / java / joran / calculator /</em>ディレクトリに入にいます。
    </p>

    <p><em>calculator1.xml</em>を见ると， <code>literal要素</code>をネストした<code>computation要素</code>があるので见てみましょう。
    </p>

    <p class="example">例10：Calculatorの设定例（ <a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/calculator1.xml">logback-examples / src / main / java / chapters / onJoran / calculator / calculator1.xml</a> ）</p>

    <pre class="prettyprint source">&lt;computation name="total"&gt;
  &lt;literal value="3"/&gt;
&lt;/computation&gt;</pre>

    <p><code><a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/Calculator1.html">Calculator1</a></code>アプリケーションでは，さまざまな解析ルール（パターンとアクション）を宣言しています。これらはXMLドキュメントの内容に基づき，协调して结果を算出するものです。
    </p>

    <p><em>calculator1.xml</em>を指定して<code>Calculator1</code>を実行してみましょう。</p>

    <p class="command">Java Chapters.onJoran.calculator。Calculator1 src / main / java / chapters / onJoran / calculator / calculator1.xml</p>

    <p>次のように出力されます。</p>

    <p class="console">名为[total]的计算得出的值为3</p>


    <p>上记の<em>calculator1.xml</em>は次のように解釈されます。</p>

    <ul>
      <li>计算要素のstartイベントが，“ / computation”パターンとみなされます。<code><a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/Calculator1.html">Calculator1</a></code>アプリケーションは“ / computation”パターンと<a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/ComputationAction1.html"><code>ComputationAction1</code></a>を关连付けています。ですので， <code>ComputationAction1</code>のインスタンスの<code>begin()</code>メソッドが実行されます。
      </li>

      <li><p>字面要素のstartイベントが，“ / computation / literal”パターンとみなされます。“ / computation / literal”パターンは<code><a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/LiteralAction.html">LiteralAction</a></code>と关连付けられています。ですので， <code>LiteralAction</code>のインスタンスの<code>begin()</code>メソッドが実行されます。</p>
      </li>

      <li><p>また，literal要素のendイベントより， <code>LiteralAction</code>のインスタンスの<code>end()</code>メソッドを実行されます。</p>
      </li>


      <li><p>同様に，computation本质のendイベントより， <code>ComputationAction1</code>のインスタンスの<code>end()</code>メソッドが実行されます。
      </p>
      </li>
    </ul>

    <p>して注目して欲しいのは，アクションがどのように协调しているのかということです。<code>LiteralAction</code>は设定ファイルからリテラル値を読み取り， <code>InterpretationContext</code>の保持しているオブジェクトスタックに登录します。他クトスタックに登录された値は，他のアクションから読み书きすることができるようになります。ここでは， <code>ComputationAction1</code>の<code>end()</code>メソッドが，オブジェクトスタックから値をポップして，出力しています。
    </p>

    <!-- TO BE CONTINUED -->

    <p>次に<em>calculator2.xml</em>を见てみましょう。前の例よりも少し复雑で，面白いことをしています。</p>

    <p class="example">例10：Calculatorの设定例（ <a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/calculator2.xml">logback-examples / src / main / java / chapters / onJoran / calculator / calculator2.xml</a> ）</p>

  <pre class="prettyprint source">&lt;computation name="toto"&gt;
  &lt;literal value="7"/&gt;
  &lt;literal value="3"/&gt;
  &lt;add/&gt;
  &lt;literal value="3"/&gt;
  &lt;multiply/&gt;
&lt;/computation&gt;</pre>


  <p>前の例と同じく，literal要素に対応する<code><a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/LiteralAction.html">LiteralAction</a></code>釈コ，解釈コンテキストのオブジェクトスタックに整体値を登录します。ここ（ <em>Calculator2.xml</em> ）ではまず7と3が登录されています。添加要素には<a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/AddAction.html"><code>AddAction</code></a>が关连付けられています。プしてクトスタックから二回整数値をポップして，それらを加算した结果をオブジェクトスタックにプッシュするものシュするも。次のliteral要素に対応するLiteralActionは，オブジェクトスタックの一番上に整体値3をプッシュします。多重要素には<a href="http://logback.qos.ch/xref/chapters/onJoran/calculator/MultiplyAction.html"><code>MultiplyAction</code></a>が关连付けられています。プしてクトスタックから二回整数値をポップして，それらをかけあわせた结果をオブジェクトスタックにプッシュするものシュするも。ここでは，计算结果の30がオブジェクトスタッククの一番上にプッシュされることになります。一番最后に，computation要素に关连付けられたComputationAction1（のend（）メソッド）によって，オブジェクトスタックの一番上の値が出力されます。実行してみましょう。</p>

  <p class="command">Java Chapters.onJoran.calculator。Calculator1 src / main / java / chapters / onJoran / calculator / calculator2.xml</p>
  
  <p>そうすると，次のように出力されます。</p>

  <p class="console">名为[toto]的计算得出值30</p>
  

  <!--


  <p>Finally, a <em>calculator3.xml</em> is also provided, to
  demonstrate the possibility elements that contain instances of the
  same element. Here's the content of <em>calculator3.xml</em>:</p>

  <em>Example 10.<span class="autoEx"/>: Calculator configuration file
  (logback-examples/src/main/java/chapters/onJoran/calculator/calculator3.xml)</em>

<pre class="prettyprint source">&lt;computation name="toto"&gt;
  &lt;computation&gt;
    &lt;literal value="7"/&gt;
    &lt;literal value="3"/&gt;
    &lt;add/&gt;
  &lt;/computation&gt;   
 
  &lt;literal value="3"/&gt;
  &lt;multiply/&gt;
&lt;/computation&gt;</pre>

  <p>Much like the use of parentheses in an algebrical equation, the
  presence of a <code>computation</code> element nested in another is
  managed by the <a
  href="../xref/chapters/onJoran/calculator/ComputationAction2.html">
  <code>ComputationAction2</code></a> class using an internal
  stack. The well-formedness of XML will guarantee that a value saved
  by one <code>begin()</code> will be consumed only by the matching
  <code>end()</code> method.</p>
  -->

  <h3 class="doAnchor" name="implicit">暗黙的なアクション</h3>

  <p>は绍介してきたルールの定义は明示的なアクションと呼ばれます。现在のxml要素に対応するパターンとアクションのペアを，ルールストアから1つだけ取り出すことができるからです。な拡，高度な拡张性を备えたシステムにおいて，コンポーネントの种类は膨大な数になります。それゆえに，すべてのパターンに明示的なアクションを关连付けるのはとても面倒なことになるのです。
  </p>

  <p>そうは言っても，高度な拡张性を备えたシステムなら，ルールに付随身するコンポーネントそれぞれに结びついたルールを，循环して见つけることができます。logのようにルールを発见できるとすると，logbackの设定ファイルをパースする时点ではUnknownのコンポーネントが含まれるコンポーネントを扱うことができるようになります。たとえば，Apacne Antでは， <code>addFile</code>や<code>addClassPath</code>といったコンポーネントを発见するメソッドを使うことで，设定ファイルをパースする时点では未知のタグを含んだタスクを扱えるようになっています。Antはタスクの处理中に未知のタグを発见すると，タグ名に基づいたクラスのオブジェクトを生成し，タスクの実装クラスに宣言されているaddXメソッドを呼び出して，亲のオブジェクトに登录します。
  </p>

  <p>Joranは暗黙的なアクションとして同じような机能を実现しています。现在のパターンが明示的なアクションにマッチしなかった时のために，暗黙的なアクションの一覧を保持するようになっています。黙，暗黙的なアクションを适用することが必ずしも适切ではない场合があります。Jo，Joranは暗黙的なアクションを実行する前に，现在の状况が妥当であるかどうかを确认するようになっています。Joranからの确认に対して，これから実行されようとするアクションが肯定を返すときだけ，アクションを呼び出します。対応によっての例外対応によって，复数の暗黙的なアクションを备えつつ，适切なアクションが无ければ何もしないことの両方のケースに対応できるのです。
  </p>

  <p>暗黙的なアクションの作成例が<em>logback-examples / src / main / java / chapters / onJoran / implicit</em>にあります。
  </p>

  <p><a href="http://logback.qos.ch/xref/chapters/onJoran/implicit/PrintMe.html"><code>PrintMe</code></a>アプリケーションでは，“ / * / foo”パターンと<a href="http://logback.qos.ch/xref/chapters/onJoran/implicit/NOPAction.html"><code>NOPAction</code></a>アクションを关连付けています。はのパターンは任意のfoo要素にマッチします。<code>NOPAction</code>の<code>begin()</code>メソッドと<code>end()</code>メソッドは，名前のとおり空っぽです。<code>PrintMe</code>アプリケーションは，暗黙的なアクションの一覧に<a href="http://logback.qos.ch/xref/chapters/onJoran/implicit/PrintMeImplicitAction.html">PrintMeImplicitAction</a>も登录しています。<code>PrintMeImplicitAction</code>は， <span class="attr">printme属性</span>にtrueを指定されたあらゆる要素について适用可能なアクションです。<code>PrintMeImplicitAction</code>の<code>isApplicable()</code>メソッドを见ておいてください。<code>PrintMeImplicitAction</code>の<code>begin()</code>メソッドは，现在の要素の名前をコンソールに出力します。
  </p>

  <p>暗黙的なアクションがどのように振る舞うのか， <em>implicit1.xml</em>で试してみましょう。</p>

  <p class="example">例10：暗黙的なルールの使い方（ <a href="http://logback.qos.ch/xref/chapters/onJoran/implicit/implicit1.xml">logback-examples / src / main / java / chapters / onJoran / implicit / implicit1.xml</a> ）</p>

  <pre class="prettyprint source">&lt;foo&gt;
  &lt;xyz printme="true"&gt;
    &lt;abc printme="true"/&gt;
  &lt;/xyz&gt;

  &lt;xyz/&gt;

  &lt;foo printme="true"/&gt;

&lt;/foo&gt;</pre>

  <p>実行してみましょう。</p>

  <p class="command">Java章节。onJoran.implicit。PrintMe src / main / java / chapters / onJoran / implicit / implicit1.xml</p>
  <p>次のように出力されます。</p>

  <p class="console">要求打印元素[xyz]。要求打印元素[abc]。20：33：43,750 |-cqlcjoran.spi中出现错误。口译员<b>10：9-</b> [xyz]没有适用的操作，当前模式为[[foo] [xyz]]</p>

  <p><code>NOPAction</code> *“ * / foo”パターンに关连付けられているので，foo要素について<code>NOPAction</code>の<code>begin()</code>メソッドと<code>end()</code>メソッドが実行されているはずです。のため，foo要素については<code>PrintMeImplicitAction</code>は呼び出されないのです。他の明示的なアクションがマッチしない要素について， <code>PrintMeImplicitAction{\0}の<code>isApplicable()</code></code>メソッドが呼び出されます。isApplicable（）， <span class="attr">printme属性</span>にtrueが指定されている场合にだけtrueを返します。最初，最初のxyz要素とabc要素についてはtrueを返します。10行目の二つ目のxyz要素には适用可能なアクションがないので，内部エラーメッセージが出力されます。エラーメッセージは<code>StatusPrinter</code>のprint（）メソッドが出力しています。
  </p>

  <h3 class="doAnchor" name="iaPractice">暗黙的なアクションの実装</h3>
  
  <p>logback-classic的经典日志，Joranコンフィギュレーターには，暗黙的なアクションが2つだけ含まれています。<code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/action/NestedBasicPropertyIA.html">NestedBasicPropertyIA</a></code>と<a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/action/NestedComplexPropertyIA.html"><code>NestedComplexPropertyIA</code></a>です。</p>

  <p><code>NestedBasicPropertyIA</code>は，プリミティブ型あるいはそのラッパークラス，列挙型，“ valueOf”规约に则った任意のクラスのプロパティに适用可能なアクションです。なプのアクションが适用可能なプロパティは<em>基本型</em>あるいは<em>単纯型</em>と呼ばれています。“ valueOf”规约に则るというのは， <code>java.lang.String</code>を引数とする静的メソッド<code>valueOf()</code>るインスタンス化できる，ということです。<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/Level.html"><code>Level</code></a>や<a href="http://logback.qos.ch/xref/ch/qos/logback/core/util/Duration.html"><code>Duration</code></a> ， <a href="http://logback.qos.ch/xref/ch/qos/logback/core/util/FileSize.html"><code>FileSize</code></a>规の规约に従っています。
  </p>
  
  <p><code>NestedComplexPropertyIA</code>は， <code>NestedBasicPropertyIA</code>が适用できない场合に， <em>かつ</em> ，オブジェクトスタックの一番上のオブジェクトに，现在の要素名に対応するセッターあるいはアダーメソッドがある偶尔に适用可能なアクションです。のアクションが适用可能なプロパティは，更に他のコンポーネントを内包することがあるので注意しましょう。なプのアクションが适用可能なプロパティは<em>复雑型</em>と呼ばれています。<code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/action/NestedComplexPropertyIA.html">NestedComplexPropertyIA</a></code>が复雑型のプロパティを见つけると，ネストされたコンポーネントに対応する适切なクラスをインスタンス化して，亲のコンポーネント（オブジェクトスタックの一番上のオブジェクト）に设定します。<span class="attr">class属性</span>でインスタンス化するクラスを指定することができます。<span class="attr">类属性</span>が指定されていない场合，次のいずれかを条件に従ってクラス名が决定されます。</p>

  <ol>
    <li>亲のオブジェクトのプロパティのクラスを决定する内部的なルールに基づいて决められたクラス名</li>
    <li>@ッターメソッドの@DefaultClassアノテーションに指定あされ</li>

    <li>引ッターメソッドの引数が公开コンストラクタを持つ具象クラスならそのクラス名</li>
  </ol>

  <h4 class="doAnchor" name="defaultClassMapping">デフォルトのクラスマッピング</h4>

  <p>logback-classicでは，亲のクラスとプロパティ名に対応するデフォルトのクラスを规定を内部的なルールがあります。表にまとめました。</p>

  <table class="bodyTable">
    <tbody><tr>
      <th>亲クラス</th>
      <th>プロパティ名</th>
      <th>ネストするコンポーネントのデフォルトクラス</th>
    </tr>

    <tr>
      <td>ch.qos.logback.core。AppenderBase</td>
      <td>编码器</td>
      <td>ch.qos.logback.classic.encoder。PatternLayoutEncoder</td>
    </tr>

    <tr class="alt">
      <td>ch.qos.logback.core。UnsynchronizedAppenderBase</td>
      <td>编码器</td>
      <td>ch.qos.logback.classic.encoder。PatternLayoutEncoder</td>
    </tr>

      <tr>
      <td>ch.qos.logback.core。AppenderBase</td>
      <td>布局</td>
      <td>ch.qos.logback.classic。模式布局</td>
    </tr>

    <tr class="alt">
      <td>ch.qos.logback.core。UnsynchronizedAppenderBase</td>
      <td>布局</td>
      <td>ch.qos.logback.classic。模式布局</td>
    </tr>

    <tr>
      <td>ch.qos.logback.core.filter。EvaluatorFilter</td>
      <td>评估者</td>
      <td>ch.qos.logback.classic.boolex。JaninoEventEvaluator</td>
    </tr>
  </tbody></table>

  <p>これらは将来的に変更されるかもしれません。最新のルールについては，logback-classicモジュールの<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/joran/JoranConfigurator.html">JoranConfigurator</a>の<code>addDefaultNestedComponentRegistryRules()</code>メソッドを参照してください。
  </p>

  <p>logback-accessモジュールのルールも似たようなものです。てはストするコンポーネントのデフォルトクラスについては，パッケージ名をch.qos.logback.classicからch.qos.logback.accessに読み替えてください。最新のルールについては，logback-accessモジュールの<a href="http://logback.qos.ch/xref/ch/qos/logback/access/joran/JoranConfigurator.html">JoranConfigurator</a>の<code>addDefaultNestedComponentRegistryRules()</code>メソッドを参照してください。

  </p>
  
  <h4 class="doAnchor">コレクション型のプロパティ</h4>

  
  <p>logbackの暗黙的なアクションは，単独の基本型プロパティ，复雑型プロパティに加えて，コレクション型のプロパティにも対応しています。ただし，セッターメソッドの代わりに，アダーメソッドを用意する必要があります。</p>

  <h3 class="doAnchor" name="newRule">その场で新しいルールを定义する</h3>

  <p>Joranには，XMLドキュメントを解釈している途中でも，Joranコフィギュレーィギュレーターに新しいルールを教をのアクションが含まれています。ドがンプルコードが<em>logback-examples / src / main / java / chapters / onJoran / newRule</em>ディレクトリにあります。<code><a href="http://logback.qos.ch/xref/chapters/onJoran/newRule/NewRuleCalculator.html">NewRuleCalculator</a></code>アプリケーションは，二つのルールを定义しています。1つは最上位要素を处理するためのもので，二つ目は动的に新しいルールを定义するためのものです。<code>NewRuleCalculator</code>の关连するコードをピックアップしました。
  </p>

  <pre class="prettyprint source">ruleMap.put(new Pattern("*/computation"), new ComputationAction1());
<b>ruleStore.addRule(new Pattern("/computation/newRule"), new NewRuleAction());</b></pre>

  <p><a href="http://logback.qos.ch/xref/ch/qos/logback/core/joran/action/NewRuleAction.html"><code>NewRuleAction</code></a> backlogback-coreの一部で，他のアクションと同じように动作します。Rーサーが<em>newRule要素</em>を见つけるたびに，このアクションの<code>begin()</code>メソッドと<code>end()</code>メソッドが呼び出されます。<code>begin()</code>メソッドは， <em>pattern属性</em>と<em>actionClass属性</em>を探します。しの后，対応するアクションクラスをインスタンス化し，Joranのルールストアにパターンとアクションの关连付けを新しいルールとして追加します。</p>


  <p>XMLドキュメント中では次のように新しいルールを宣言を。</p>

  <pre class="prettyprint source">&lt;newRule pattern="*/computation/literal"
          actionClass="chapters.onJoran.calculator.LiteralAction"/&gt;</pre>

  <p>newRule宣言を使って， <code>NewRuleCalculator</code>に<code>Calculator1</code>のような振る舞いをさせることができます。</p>

  <p class="example">例10：动的にルールを定义する设定例（ <a href="http://logback.qos.ch/xref/chapters/onJoran/newrule/newRule.xml">logback-examples / src / main / java / chapters / onJoran / newrule / newRule.xml</a> ）</p>

  <pre class="prettyprint source">&lt;computation name="toto"&gt;
  &lt;newRule pattern="*/computation/literal" 
            actionClass="chapters.onJoran.calculator.LiteralAction"/&gt;
  &lt;newRule pattern="*/computation/add" 
            actionClass="chapters.onJoran.calculator.AddAction"/&gt;
  &lt;newRule pattern="*/computation/multiply" 
            actionClass="chapters.onJoran.calculator.MultiplyAction"/&gt;

  &lt;computation&gt;
    &lt;literal value="7"/&gt;
    &lt;literal value="3"/&gt;
    &lt;add/&gt;
  &lt;/computation&gt;   
 
  &lt;literal value="3"/&gt;
  &lt;multiply/&gt;
&lt;/computation&gt;</pre>


  <p class="command">実行してみましょう。Java章.onJoran.newRule。NewRuleCalculator src / main / java / chapters / onJoran / newRule / newRule.xml</p>

  <p>次のように出力されます。</p>

  <p class="console">名为[toto]的计算得出值30</p>

  <p>これは<a href="./10-onJoran.html#calculator">元のCalculator1</a>の出力とまったく同じです。</p>


    <script src="../templates/footer.js" type="text/javascript"></script>
</div>

</body></html>