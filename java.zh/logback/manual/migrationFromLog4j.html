<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第13章：从log4j迁移</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../'</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">
      
    <h1>第13章：从log4j迁移</h1> 

    <a href="migrationFromLog4j_ja.html">和訳（日语翻译）</a>

    <div class="quote">
      <p><em>变化越多，它们保持不变的程度就越高。</em></p>
      
      <p>—ALPHONSE KARR， <em>莱斯·吉佩斯</em></p>
    </div>

    <p>本章讨论将自定义log4j组件（例如追加器或布局）迁移到经典的logback的主题。
    </p>

    <p>仅调用log4j客户端API的软件，即<code>Logger</code>要么<code>Category</code>中的课程<code>org.apache.log4j</code>软件包，可以通过<a href="http://www.slf4j.org/migrator.html">SLF4J迁移器工具</a>自动迁移为使用SLF4J。要将<em>log4j.property</em>文件迁移到等效的logback中，可以使用<a href="http://logback.qos.ch/translator/">log4j.properties转换器</a> 。
    </p>

    <p>从更广泛的角度来看，log4j和经典的logback紧密相关。记录器，附加器和布局之类的核心组件都存在于两个框架中，并且具有相同的用途。同样，最重要的内部数据结构即<code>LoggingEvent</code>在两个框架中都存在，它们的实现方式非常相似，但不完全相同。最值得注意的是，经典的logback <code>LoggingEvent</code>实现<code>ILoggingEvent</code>接口。将log4j组件迁移到经典的logback所需的大多数更改都与在实施上的差异有关。 <code>LoggingEvent</code>类。放心，这些差异相当有限。如果尽最大努力仍无法将任何给定的log4j组件迁移到经典的logback，请在<a href="../mailinglist.html">logback-dev邮件列表</a>上发布问题。登录开发人员应该能够提供指导。
    </p>

    
    <h3 class="doAnchor" name="log4jLayout">迁移log4j布局</h3>

    <p>让我们开始迁移一个名为<a href="../xref/chapters/migrationFromLog4j/TrivialLog4jLayout.html">TrivialLog4jLayout</a>的假设且简单的log4j布局，该布局将记录事件中包含的消息作为格式化消息返回。这是代码。
    </p>
    

    <pre class="prettyprint source">package chapters.migrationFromLog4j;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;

public class TrivialLog4jLayout extends Layout {

  public void activateOptions() {
    // there are no options to activate
  }

  public String format(LoggingEvent loggingEvent) {
    return loggingEvent.getRenderedMessage();
  }

  public boolean ignoresThrowable() {
    return true;
  }
}</pre>

    <p>名为<a href="../xref/chapters/migrationFromLog4j/TrivialLogbackLayout.html">TrivialLogbackLayout</a>的经典的logback等效为</p>
    
    <pre class="prettyprint source">package chapters.migrationFromLog4j;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class TrivialLogbackLayout extends <b>LayoutBase&lt;ILoggingEvent></b> {

  public String <b>doLayout</b>(ILoggingEvent loggingEvent) {
    return loggingEvent.getMessage();
  }
}    </pre>
 
   <p>如您所见，在经典的logback布局中，格式化方法名为<code>doLayout</code>代替<code>format</code> （）在log4j中。的<code>ignoresThrowable</code> （）方法不是必需的，并且在logback-classic中没有等效的方法。请注意，经典的logback布局必须扩展<code>LayoutBase<ILoggingEvent></code>类。
   </p>

   <p>的<code>activateOptions</code> （）方法值得进一步讨论。在log4j中，布局将具有<code>activateOptions</code> （）由log4j配置程序调用的方法，即<code>PropertyConfigurator</code>要么<code>DOMConfigurator</code>设置完布局的所有选项之后。因此，布局将有机会检查其选项是否一致，如果一致，则继续进行完全初始化。</p>


   <p>在经典的logback模式中，布局必须实现<a href="../xref/ch/qos/logback/core/spi/LifeCycle.html">LifeCycle</a>接口，该接口包括一个称为<code>start</code> （）。的<code>start</code> （）方法等效于log4j的<code>activateOptions</code> （） 方法。
   </p>

   <h3 class="doAnchor" name="log4jAppender">迁移log4j附加程序</h3>
   
   <p>迁移附加程序与迁移布局非常相似。这是一个称为<a href="../xref/chapters/migrationFromLog4j/TrivialLog4jAppender.html">TrivialLog4jAppender的</a>简单附加程序，它在控制台上写入其布局返回的字符串。</p>
   
    <pre class="prettyprint source">package chapters.migrationFromLog4j;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;


public class TrivialLog4jAppender extends AppenderSkeleton {

  protected void append(LoggingEvent loggingevent) {
    String s = this.layout.format(loggingevent);
    System.out.println(s);
  }

  public void close() {
    // nothing to do
  }

  public boolean requiresLayout() {
    return true;
  }
}</pre>

   <p>名为<a href="../xref/chapters/migrationFromLog4j/TrivialLogbackAppender.html">TrivialLogbackAppender</a>的经典的logback经典将写为</p>


   <pre class="prettyprint source">package chapters.migrationFromLog4j;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.AppenderBase;

public class TrivialLogbackAppender extends AppenderBase&lt;ILoggingEvent> {

  @Override
  public void start() {
    if (this.layout == null) {
      addError("No layout set for the appender named [" + name + "].");
      return;
    }
    super.start();
  }

  @Override
  protected void append(ILoggingEvent loggingevent) {
    // note that AppenderBase.doAppend will invoke this method only if
    // this appender was successfully started.
    
    String s = this.layout.doLayout(loggingevent);
    System.out.println(s);
  }
}</pre>


   <p>比较这两个类，您应该注意<code>append</code> （）方法保持不变。的<code>requiresLayout</code>方法未在登录中使用，可以删除。在logback中， <code>stop</code> （）方法等效于log4j的<code>close</code> （） 方法。然而， <code>AppenderBase</code>在logback-classic中，包含用于的nop实现<code>stop</code>对于这个琐碎的附加程序而言，这就足够了。
   </p>



  <script src="../templates/footer.js" type="text/javascript"></script>
</div>


</body></html>