<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第9章：日志记录分离</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">	
	
    <h1>第9章：日志记录分离</h1>

    <a href="loggingSeparation_ja.html">和訳（日语翻译）</a>
      
    <div class="quote">
      <p><em>给予最大享受的不是知识，而是学习的行为，而不是占有的行为，而是到达那里的行为。当我弄清并用尽了一个主题之后，我便转身离开它，以再次陷入黑暗。永不满足的人如果完成了一个结构，就会感到很奇怪，那不是为了和平地居住在其中，而是为了开始另一个。我想世界征服者一定会感到这样，在几乎征服了一个王国之后，谁会为其他国家伸手。</em></p>

      <p>卡尔·弗里德里希·高斯（KARL FRIEDRICH GAUSS），写给Bolyai的信，1808年。</p>

      <p><em>像纯粹的丝绸一样，花型经常掩盖湿疹。</em></p>
      
      <p>-阿尔伯特·卡缪斯， <em>《秋天》</em></p>

    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>		
    <script src="../templates/setup.js" type="text/javascript"></script>

    <h2>问题：日志记录分离</h2>

    <p>本章涉及一个相对困难的问题，即为在同一Web或EJB容器上运行的多个应用程序提供单独的日志记录环境。在本章的其余部分，术语“应用程序”将用于互换地指代Web应用程序或J2EE应用程序。在单独的日志记录环境中，每个应用程序都会看到不同的日志备份环境，因此一个应用程序的日志备份配置不会干扰另一个应用程序的设置。用更专业的术语来说，每个Web应用程序都有一个不同的副本<code>LoggerContext</code>保留供自己使用。回想一下，在logback中，每个logger对象都是由一个<code>LoggerContext</code>只要记录器对象存在于内存中，它就会一直保持连接状态。此问题的一个变体是将应用程序日志记录与容器本身的日志记录分离。
    </p>

    <h2 class="doAnchor" name="easy">最简单，最简单的方法</h2>

    <p>假设您的容器支持子类第一类的加载，则可以通过在每个应用程序中嵌入slf4j和logback jar文件的副本来完成日志记录的分离。对于Web应用程序，将slf4j和logback jar文件放在该<em>Web</em>应用程序的<em>WEB-INF / lib</em>目录下足以为每个Web应用程序提供单独的日志记录环境。当将logback加载到内存中时，将获取放置在<em>WEB-INF / classes</em>下的<em>logback.xml</em>配置文件的副本。
    </p>

    <p>借助容器提供的类加载器分隔，每个Web应用程序都将加载其自己的<code>LoggerContext</code>它将获取自己的<em>logback.xml</em>副本。</p>
    
    <p>非常简单。</p>

    <p>好吧，不完全是。有时，您会被迫将SLF4J和注销工件放置在可从所有应用程序访问的位置，通常是因为共享库使用了SLF4J。在这种情况下，所有应用程序将共享相同的日志记录环境。在其他各种情况下，必须将SLF4J和logback工件的副本放置在所有应用程序都可以看到的位置，从而无法通过类加载器分隔日志记录。所有希望都不会丢失。请继续阅读。
    </p>

    <h2 class="doAnchor" name="contextSelectors">上下文选择器</h2>

    <p>Logback为SLF4J的单个实例提供了一种机制，并且将logback类加载到内存中以提供多个记录器上下文。当你写：</p>

    <pre class="prettyprint source">Logger logger = LoggerFactory.getLogger("foo");</pre>

    <p>的<code>getLogger</code> （）方法<code>LoggerFactory</code>类将要求SLF4J绑定<code>ILoggerFactory</code> 。当SLF4J绑定到logback时，返回<code>ILoggerFactory</code>被委托给<a href="../apidocs/ch/qos/logback/classic/selector/ContextSelector.html">ContextSelector</a>的实例。注意<code>ContextSelector</code>实现总是返回实例<code>LoggerContext</code> 。此类实现<code>ILoggerFactory</code>接口。换句话说，上下文选择器可以选择返回任何<code>LoggerContext</code>实例根据自己的标准认为合适。因此，名称上下文<em>选择器</em> 。
    </p>

    <p>默认情况下，logback绑定使用<a href="../xref/ch/qos/logback/classic/selector/DefaultContextSelector.html">DefaultContextSelector</a> ，它始终返回相同的值<code>LoggerContext</code> ，称为默认记录器上下文。</p>

    <p>您可以通过设置<em>登录来指定其他上下文选择器<em>。ContextSelector</em>系统属性。假设您想将该上下文选择器指定给<code>myPackage.myContextSelector</code>类，您将添加以下系统属性：</em></p><em>

    <p class="source">-Dlogback。ContextSelector = myPackage.myContextSelector</p>

    <p>上下文选择器需要实现<code>ContextSelector</code>接口，并有一个构造函数方法允许一个<code>LoggerContext</code>实例作为其唯一参数。
    </p>


    <h3 class="doAnchor" name="ContextJNDISelector">上下文JNDISelector</h3>

    <p>经典的Logback附带一个选择器<code>ContextJNDISelector</code>它将根据通过JNDI查找提供的数据来选择记录器上下文。这种方法利用了J2EE规范要求的JNDI数据分离。因此，可以将相同的环境变量设置为在不同的应用程序中携带不同的值。换句话说， <code>LoggerFactory.getLogger()</code>即使将单个LoggerFactory类加载到所有应用程序共享的内存中，来自不同应用程序的应用程序也会返回附加到不同记录器上下文的记录器。这就是您的记录分隔。
    </p>

    <p>启用<code>ContextJNDISelector</code> ， <em>登录。ContextSelector</em>系统属性需要设置为“ JNDI”，如下所示：</p>

    <p class="source">-Dlogback。ContextSelector = JNDI</p>

    <p>注意值<code>JNDI</code>是一个方便的简写<code>ch.qos.logback.classic.selector.ContextJNDISelector</code> 。</p>

    <h3 class="doAnchor" name="settingJNDIVariables">在应用程序中设置JNDI变量</h3>
    
    <p>在每个应用程序中，您都需要为应用程序命名日志上下文。对于Web应用程序，在<em>web.xml</em>文件中指定了JNDI环境条目。如果“ kenobi”是应用程序的名称，则应将以下XML元素添加到kenobi的web.xml文件中：</p>

    <pre class="prettyprint source">&lt;env-entry>
  &lt;env-entry-name>logback/context-name&lt;/env-entry-name>
  &lt;env-entry-type>java.lang.String&lt;/env-entry-type>
  &lt;env-entry-value>kenobi&lt;/env-entry-value>
&lt;/env-entry></pre>

    <p>假设您已启用<code>ContextJNDISelector</code> ，则将使用名为“ kenobi”的记录器上下文来记录Kenobi。此外，通过使用线程上下文类加载器将名为<em>logback-kenobi.xml</em>的配置文件作为<em>资源</em>查找，可以<em>按照约定</em>初始化“ kenobi”记录器上下文。因此，例如对于kenobi Web应用程序，应将<em>logback-kenobi.xml</em>放在<em>WEB-INF / classes</em>文件夹下。
    </p>

    <p>如果愿意，可以通过设置“ logback / configuration-resource” JNDI变量来指定不同于约定的其他配置文件。例如，对于kenobi Web应用程序，如果您希望指定<em>aFolder / my_config.xml</em>而不是常规的<em>logback-kenobi.xml</em> ，则可以将以下XML元素添加到web.xml中</p>


   <pre class="prettyprint source">&lt;env-entry>
  &lt;env-entry-name>logback/configuration-resource&lt;/env-entry-name>
  &lt;env-entry-type>java.lang.String&lt;/env-entry-type>
  &lt;env-entry-value>aFolder/my_config.xml&lt;/env-entry-value>
&lt;/env-entry></pre> 

    <p>文件<em>my_config.xml</em>应该放在<em>WEB-INF / classes / aFolder /下</em> 。要记住的重要一点是，使用当前线程的上下文类加载器将配置作为Java资源查找。
    </p>
    

    <h3 class="doAnchor" name="jndiTomcat">为ContextJNDISelector配置Tomcat</h3>

    <p>首先，将logback jar（即logback-classic-1.3.0-alpha5.jar，logback-core-1.3.0-alpha5.jar和slf4j-api-2.0.0-alpha1.jar）放置在Tomcat的全局（共享）中。 ）类文件夹。在Tomcat 6.x中，此目录为<em>$ TOMCAT_HOME / lib /</em> 。
    </p>

    <p><em>登录。可以通过将以下行添加到<em>$ TOMCAT_HOME / bin</em>文件夹下的<em>catalina.sh</em>脚本Windows中的<em>catalina.bat</em>来设置ContextSelector</em>系统属性。</p>

    <p class="source">JAVA_OPTS =“ $ JAVA_OPTS-回送。ContextSelector = JNDI“</p>


    <h3 class="doAnchor" name="hotDeploy">热部署应用</h3>

    <p>当Web应用程序被回收或关闭时，我们强烈建议<code>LoggerContext</code>将其关闭，以便可以正确收集垃圾。Logback附带一个<code>ServletContextListener</code>叫<a href="../xref/ch/qos/logback/classic/selector/servlet/ContextDetachingSCL.html"><code>ContextDetachingSCL</code></a>专门设计用于拆卸<code>ContextSelector</code>与较旧的Web应用程序实例关联的实例。可以通过将以下行添加到Web应用程序的<em>web.xml</em>文件中来进行安装。</p>

    <pre class="prettyprint source">&lt;listener>
  &lt;listener-class>ch.qos.logback.classic.selector.servlet.ContextDetachingSCL&lt;/listener-class>
&lt;/listener></pre>

    <p><span class="label notice">注意</span>大多数容器会调用<code>contextInitialized()</code>侦听器的方法按其声明的顺序，但调用它们的顺序<code>contextDestroyed()</code>方法相反。因此，如果您有多个<code>ServletContextListener</code>然后在<em>web.xml中</em>声明<code>ContextDetachingSCL</code>应该<em>首先</em>声明，以便其<code>contextDestroyed()</code>方法在应用程序关闭期间<em>最后</em>被调用。</p>

    <h3 class="doAnchor" name="betterPerf">更好的性能</h3>

    <p>什么时候<code>ContextJNDISelector</code>如果处于活动状态，则每次检索记录器时，都必须执行JNDI查找。这可能会对性能产生负面影响，尤其是在使用非静态（又名实例）记录器引用的情况下。Logback附带了一个名为<a href="../xref/ch/qos/logback/classic/selector/servlet/LoggerContextFilter.html">LoggerContextFilter</a>的servlet过滤器，该过滤器专门用于避免JNDI查找成本。可以通过将以下行添加到应用程序的web.xml文件中来进行安装。</p>

 <pre class="prettyprint source">&lt;filter>
  &lt;filter-name>LoggerContextFilter&lt;/filter-name>
  &lt;filter-class>ch.qos.logback.classic.selector.servlet.LoggerContextFilter&lt;/filter-class>
&lt;/filter>
&lt;filter-mapping>
  &lt;filter-name>LoggerContextFilter&lt;/filter-name>
  &lt;url-pattern>/*&lt;/url-pattern>
&lt;/filter-mapping></pre>

   <p>在每个http请求的开头， <code>LoggerContextFilter</code>将获取与应用程序关联的记录器上下文，然后将其放置在<code>ThreadLocal</code>变量。<code>ContextJNDISelector</code>首先会检查<code>ThreadLocal</code>变量已设置。如果已设置，则将跳过JNDI查找。请注意，在http请求的末尾， <code>ThreadLocal</code>变量将为空。正在安装<code>LoggerContextFilter</code>大大提高了记录器的检索性能。
   </p>

   <p>调零<code>ThreadLocal</code>变量允许在停止或回收Web应用程序时对其进行垃圾回收。</p>


   <h2 class="doAnchor" name="tamingStaticRefs">在共享库中驯服静态引用</h2>

   <p><code>ContextJNDISelector</code>当所有应用程序共享SLF4J和logback工件时，可以很好地创建日志分隔。什么时候<code>ContextJNDISelector</code>处于活动状态，每次致电<code>LoggerFactory.getLogger()</code>将返回一个属于与调用方/当前应用程序关联的记录器上下文的记录器。</p>

   <p>引用记录器的常用习惯是通过静态引用。例如，</p>

   <pre class="prettyprint source">public class Foo {
  <b>static</b> Logger logger = LoggerFactory.getLogger(Foo.class);
  ...
}</pre>

    <p>静态记录器引用同时具有内存和CPU效率。该类的所有实例仅使用一个记录器引用。而且，当类被加载到内存中时，记录器实例仅被检索一次。如果主机类属于某个应用程序，例如kenobi，则静态记录器将通过以下方式附加到kenobi的记录器上下文中： <code>ContextJNDISelector</code> 。同样，如果主机类属于其他应用程序，例如yoda，则其静态记录器引用将再次附加到yoda的记录器上下文中， <code>ContextJNDISelector</code> 。
    </p>
    
    <p>如果上课，说<code>Mustafar</code> ，属于<em>kenobi</em>和<em>yoda</em>共享的图书馆，只要<code>Mustafar</code>具有非静态记录器，每次调用<code>LoggerFactory.getLogger()</code>将返回一个属于与调用方/当前应用程序关联的记录器上下文的记录器。但是如果<code>Mustafar</code>具有静态记录器引用，则其记录器将附加到首先调用它的应用程序的记录器上下文中。从而， <code>ContextJNDISelector</code>在使用静态记录器引用的共享类的情况下，不提供记录分离。这种极端的情况使人们无法找到解决方案。</p>


    <p>透明，完美地解决此问题的唯一方法是在记录器内部引入另一种间接方式，以便每个记录器外壳以某种方式将工作委派给附加到适当上下文的内部记录器。这种方法将很难实施，并且会产生大量的计算开销。这不是我们计划追求的方法。
    </p>

    <p>不用说，可以通过在Web应用程序内部移动共享类（取消共享）来简单地解决“共享类静态记录器”问题。如果无法共享，那么我们可以寻求<a href="appenders.html#SiftingAppender"><code>SiftingAppender</code></a>为了使用JNDI数据作为分离标准来分离日志记录。
    </p>

    <p>Logback附带了一个名为<a href="../xref/ch/qos/logback/classic/sift/JNDIBasedContextDiscriminator.html">JNDIBasedContextDiscriminator</a>的鉴别<a href="../xref/ch/qos/logback/classic/sift/JNDIBasedContextDiscriminator.html">符</a> ，该鉴别<a href="../xref/ch/qos/logback/classic/sift/JNDIBasedContextDiscriminator.html">符</a>返回由计算得出的当前记录器上下文的名称。 <code>ContextJNDISelector</code> 。的<code>SiftingAppender</code>和<code>JNDIBasedContextDiscriminator</code>组合将为每个Web应用程序创建单独的附加程序。
    </p>

    <pre class="prettyprint source">&lt;configuration>

  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" />  

  &lt;appender name="SIFT" class="ch.qos.logback.classic.sift.SiftingAppender">
    &lt;discriminator class="ch.qos.logback.classic.sift.JNDIBasedContextDiscriminator">
      &lt;defaultValue>unknown&lt;/defaultValue>
    &lt;/discriminator>
    &lt;sift>
      &lt;appender name="FILE-${contextName}" class="ch.qos.logback.core.FileAppender">
        &lt;file><b>${contextName}.log</b>&lt;/file>
        &lt;encoder>
          &lt;pattern>%-50(%level %logger{35}) cn=%contextName - %msg%n&lt;/pattern>
         &lt;/encoder>
      &lt;/appender>
     &lt;/sift>
    &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="SIFT" />
  &lt;/root>
&lt;/configuration></pre>


   <p>如果kenobi和yoda是Web应用程序，则上述配置会将yoda的日志输出输出到<em>yoda.log，</em>而kenobi的日志输出到<em>kenobi.log</em> ；这甚至适用于位于共享类中的静态记录器引用生成的日志。</p>
 
   <p>您可以在<a href="http://github.com/ceki/logback-starwars">logback-starwars</a>项目的帮助下尝试刚刚描述的技术。
   </p>
 
 
   <p>上述方法解决了测井分离问题，但是相当复杂。需要正确安装<code>ContextJNDISelector</code>并要求由<code>SiftingAppender</code>它本身就是不平凡的野兽。
   </p>
 
   <p>请注意，可以使用相同文件或不同文件配置每个日志记录上下文。这个选择由你。指示所有上下文使用同一配置文件更为简单，因为仅需维护一个文件。为每个应用程序维护不同的配置文件较难维护，但可以提供更大的灵活性。</p>
 
   <p>那我们完成了吗？我们可以宣布胜利并回家吗？好吧，不完全是。</p>
 
   <p>假设网络应用程序<code>yoda</code>在之前初始化<code>kenobi</code> 。初始化<code>yoda</code> ，访问<code>http://localhost:port/yoda/servlet</code>这将调用<code>YodaServlet</code> 。这个Servlet只会打个招呼，并在呼叫之前记录讯息<code>foo</code>方法中<code>Mustafar</code>毫不奇怪，它会记录一条简单的消息并返回。
   </p>
 
   <p>后<code>YodaServlet</code>被调用时， <em>yoda.log</em>文件的内容应包含</p>
 
   <pre class="source">DEBUG ch.qos.starwars.yoda.YodaServlet             cn=yoda - in doGet()
DEBUG ch.qos.starwars.shared.Mustafar              cn=yoda - in foo()</pre>
 
   <p>注意两个日志条目如何与“ yoda”上下文名称关联。在此阶段，直到服务器停止， <code>ch.qos.starwars.shared.Mustafar</code>记录器附加到“ yoda”上下文，并且将保持不变，直到服务器停止。
   </p>

   <p>来访<code>http://localhost:port/kenobi/servlet</code>将在<em>kenobi.log中</em>输出以下<em>内容</em> 。</p>

   <pre class="source">DEBUG ch.qos.starwars.kenobi.KenobiServlet          <b>cn=kenobi</b> - in doGet()
DEBUG ch.qos.starwars.shared.Mustafar               <b>cn=yoda</b> - in foo()</pre>

   <p>请注意，即使<code>ch.qos.starwars.shared.Mustafar</code> logger输出到<em>kenobi.log，</em>它仍然附加到'yoda'。因此，我们有两个不同的日志记录上下文记录到同一文件，在本例中为<em>kenobi.log</em> 。这些上下文参考中的每一个<code>FileAppender</code>实例，嵌套在不同的<code>SiftingAppender</code>实例，它们记录到同一文件。尽管日志分隔似乎按照我们的意愿起作用，但是FileAppender实例除非启用<span class="option">审慎</span>模式，否则无法安全地写入同一文件。否则，目标文件将被破坏。</p>
   
   <p>这是启用谨慎模式的配置文件：</p>

    <pre class="prettyprint source">&lt;configuration>

  &lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" />  

  &lt;appender name="SIFT" class="ch.qos.logback.classic.sift.SiftingAppender">
    &lt;discriminator class="ch.qos.logback.classic.sift.JNDIBasedContextDiscriminator">
      &lt;defaultValue>unknown&lt;/defaultValue>
    &lt;/discriminator>
    &lt;sift>
      &lt;appender name="FILE-${contextName}" class="ch.qos.logback.core.FileAppender">
        &lt;file>${contextName}.log&lt;/file>
        <b>&lt;prudent>true&lt;/prudent></b>
        &lt;encoder>
          &lt;pattern>%-50(%level %logger{35}) cn=%contextName - %msg%n&lt;/pattern>
         &lt;/encoder>
      &lt;/appender>
     &lt;/sift>
    &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="SIFT" />
  &lt;/root>
&lt;/configuration></pre>


   <p>如果您到目前为止能够跟上讨论的步伐，并且实际上已经尝试过logback-starwars示例，那么您必须真正沉迷于日志记录。您应该考虑寻求<a href="http://www.qos.ch/shop/products/professionalSupport">专业帮助</a> 。</p>



   <script src="../templates/footer.js"
   type="text/javascript"></script> </em></div><em>
   
    

</em></body></html>