<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>第13章log4jからの移行</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content">
      
    <h1>第13章log4jからの移行</h1> 

    <div class="quote">
      <p><em>多くのものが変化し，多くのものがそ化ままである。</em></p>
      
      <p>—ALPHONSE KARR， <em>莱斯·吉佩斯</em></p>
    </div>

    <p>本章ではカスタマイズされたlog4jのコンポーネントのアペンダーやレイアウトウlogback-classicに移行する方法について议论します。
    </p>

    <p>log4jのクライアントAPIとして<code>org.apache.log4j</code>パッケージの<code>Logger</code>や<code>Category</code>を使っているだけなら，SLF4Jの<a href="http://www.slf4j.org/migrator.html">SLF4J移行ツール</a>で自动的に移行することができます。<em>log4j.properties</em>から同じ内容のlogback.xmlを作るには， <a href="http://logback.qos.ch/translator/">log4j.propertiesトランスター</a>が使えます。
    </p>

    <p>広い観点から见ると，log4jとlogback-classicは密接に关连し合っています。ロガーやアペンダー，レイアウトといった基本的なコンポーネントはどちらのフレームワークにもありますし，目的も同じです。同様に，どちらのフレームワークにも一番重要な内部データ构造として<code>LoggingEvent</code>がありますが，実装まで完全に同じわけではありません。一番の违いは，logback-classicの<code>LoggingEvent</code>は<code>ILoggingEvent</code>インターフェイスを実装しているところです。log4jのコンポーネントをlogback-classicに移行するために必要な変更のほとんどは， <code>LoggingEvent</code>の実装の差异を埋めることに费やされます。差异があるといってもその范囲は限られているので安心してください。出来る限りの努力をしたにも关わらず移行がうまくいかなかったら， <a href="http://logback.qos.ch/mailinglist.html">logback-devメーリングリスト</a>で质问してください。logbackの开発者たちがアドバイスしてくれるはずです。
    </p>

    
    <h3 class="doAnchor" name="log4jLayout">log4jのレイアウトを移行する</h3>

    <p>さあ移行してみましょう。対象はlog4jの単纯なレイアウト<a href="http://logback.qos.ch/xref/chapters/migrationFromLog4j/TrivialLog4jLayout.html">TrivialLog4jLayout</a>ということにします。これはロギングイベントのメッセージを指定された书式で书式化した文字列を返すものです。コードを见てください。
    </p>
    

    <pre class="prettyprint source">package chapters.migrationFromLog4j;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;

public class TrivialLog4jLayout extends Layout {

  public void activateOptions() {
    // there are no options to activate
  }

  public String format(LoggingEvent loggingEvent) {
    return loggingEvent.getRenderedMessage();
  }

  public boolean ignoresThrowable() {
    return true;
  }
}</pre>

    <p>logback-classicで<a href="http://logback.qos.ch/xref/chapters/migrationFromLog4j/TrivialLogbackLayout.html">etc</a>価なレイアウト<a href="http://logback.qos.ch/xref/chapters/migrationFromLog4j/TrivialLogbackLayout.html">TrivialLogbackLayout</a>は次のようになります。</p>
    
    <pre class="prettyprint source">package chapters.migrationFromLog4j;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class TrivialLogbackLayout extends <b>LayoutBase&lt;ILoggingEvent&gt;</b> {

  public String <b>doLayout</b>(ILoggingEvent loggingEvent) {
    return loggingEvent.getMessage();
  }
}    </pre>
 
   <p>4のように，文字列を书式化するメソッドはlog4jでは<code>format()</code> log，经典logbackでは<code>doLayout()</code>なのです。log，经典logbackには<code>ignoresThrowable()</code>に相当するメソッドはありません。logback-classicのレイアウトは<code>LayoutBase<ILoggingEvent></code>を継承しなければならないので気をつけてください。
   </p>

   <p><code>activateOptions()</code>メソッドの效果については大いに议论の余地があります。log4jでは，log4j配置器（ <code>PropertyConfigurator</code>あるいは<code>DOMConfiguration</code> ）から，レイアウトの全てのオプションが设定された后に<code>activateOptions()</code>メソッドが呼ばれるようになっています。したがって，レイアウトには自分に指定されたオプションの综合性をチェックするタイミングが无いので，全て自分で贿で。</p>


   <p>logback-classicでは，レイアウトは<a href="http://logback.qos.ch/xref/ch/qos/logback/core/spi/LifeCycle.html">LifeCycle</a>インターフェイスを実装しなければなりません。このインターフェイスには<code>start()</code>メソッドがあります。この<code>start()</code>メソッドは，log4jの<code>activateOptions()</code>メソッドとほぼ同様の役割を果たします。
   </p>

   <h3 class="doAnchor" name="log4jAppender">log4jのアペンダーを移行する</h3>
   
   <p>アペンダーの移行は，レイアウトの移行とほとんど同じです。riv纯なアペンダー<a href="http://logback.qos.ch/xref/chapters/migrationFromLog4j/TrivialLog4jAppender.html">TrivialLog4jAppender</a>を移行することを考えてみましょう。すのアペンダーはレイアウトの返す文字列をコンソールに出力するだけのものです。</p>
   
    <pre class="prettyprint source">package chapters.migrationFromLog4j;

import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.spi.LoggingEvent;


public class TrivialLog4jAppender extends AppenderSkeleton {

  protected void append(LoggingEvent loggingevent) {
    String s = this.layout.format(loggingevent);
    System.out.println(s);
  }

  public void close() {
    // nothing to do
  }

  public boolean requiresLayout() {
    return true;
  }
}</pre>

   <p>logback-classicで等価なアペンダー<a href="http://logback.qos.ch/xref/chapters/migrationFromLog4j/TrivialLogbackAppender.html">TrivialLogbackAppender</a>は次のようになります。</p>


   <pre class="prettyprint source">package chapters.migrationFromLog4j;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.AppenderBase;

public class TrivialLogbackAppender extends AppenderBase&lt;ILoggingEvent&gt; {

  @Override
  public void start() {
    if (this.layout == null) {
      addError("No layout set for the appender named [" + name + "].");
      return;
    }
    super.start();
  }

  @Override
  protected void append(ILoggingEvent loggingevent) {
    // note that AppenderBase.doAppend will invoke this method only if
    // this appender was successfully started.
    
    String s = this.layout.doLayout(loggingevent);
    System.out.println(s);
  }
}</pre>


   <p>ードを比べてみると分かるのですが， <code>append()</code>メソッドはそのままです。返回日志では<code>requiresLayout()</code>メソッドを使用しないので，これは削除できます。logbackの<code>stop()</code>メソッドは，log4jの<code>close()</code>メソッドと同じ意味です。经典的logbackの<code>AppenderBase</code>には何もしない<code>stop()</code>今ッドの実装があるので，今回のように単纯なアペンダーならそれで十分でしょう。
   </p>



    <script src="../templates/footer.js" type="text/javascript"></script>
</div>

</body></html>