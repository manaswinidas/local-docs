<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第6章レイアウト</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content">

    <h1>第6章レイアウト</h1>

    <div class="quote">
      <p>TCPの実装は顽健性の一般原则に従う。つまり，自分本身の行动は保守的に，他者から行われる行动については寛容さを持って受け入れるということだ。
      </p>
      <p>-JON POSTEL，RFC 793</p>
    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>
    <script src="../templates/setup.js" type="text/javascript"></script>

    <h2 class="doAnchor">レイアウトとは何か</h2>

    <p>大规模イアトトといってもフロリダ州の大规模集合住宅とは何の关系もありません。backイアウトはlogbackのコンポーネントであり，受け取ったロギングイベンをトを文字列に変换する役割を担っています。<a href="http://logback.qos.ch/xref/ch/qos/logback/core/Layout.html"><code>Layout</code></a>インターフェイスの<code>format()</code>任意ッドは，引数としてロギンギイベントとみなされる（任意の型の）オブジェクトを受け取り，文字列を返します。<code>Layout</code>インターフェイスの概要を次に示します。
    </p>

    <pre class="prettyprint source">public interface Layout&lt;E&gt; extends ContextAware, LifeCycle {

  String doLayout(E event);
  String getFileHeader();
  String getPresentationHeader();
  String getFileFooter();
  String getPresentationFooter();
  String getContentType();
}</pre>

    <p>はのインターフェイスは简洁ですが，あらゆる书式化のニーズを十分に満たしています。<em>Catch-22</em>に登场するテキサス育ちの开拓者であるジョセフ・ヘラーならこう叫んでいるところです。レイアウトを実装しようにもたったの5つしかメソッドがない！！？ナンデ？！」
    </p>

    <h2>经典的Logbackモジュール</h2>

    <p>经典的logbackモジュールは<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/spi/ILoggingEvent.html">ch.qos.logback.classic.spi.ILoggingEvent</a></code>だけを扱うようになっています。を読みの节を読み进めていけば理由が明らかになります。</p>

    <h2 class="doAnchor" name="writingYourOwnLayout">レイアウトを自作する</h2>

    <p>logback-classicモジュールで使で，简洁で十分な机能性のあるレイアウトを自作してみましょう。出力したいのは次のようなものです。アプリケーションが启动してから経过した时间，ロギングイベントのログレベル，ブラケットで囲んだ呼で囲んだ出しスレッド名，ロガー名，ダッシュ（-のこと）とそれに続くロギンギイグントのメッセージ，最后に改行文字も加えておきましょう。
    </p>

    <p>出力例は次のようになります。</p>

    <div class="source">10489 DEBUG [main] com.marsupial。邮袋-世界您好。</div>

    <p>开拓スの开拓者が実装したレイアウトのコードを见てましょう。</p>
    <p class="example">例：自作レイアウトのサンプル実装（ <a href="http://logback.qos.ch/xref/chapters/layouts/MySampleLayout.html">logback-examples / src / main / java / chapters / layouts / MySampleLayout.java</a> ）</p>

    <pre class="prettyprint source">package chapters.layouts;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class MySampleLayout extends LayoutBase&lt;ILoggingEvent&gt; {

  public String doLayout(ILoggingEvent event) {
    StringBuffer sbuf = new StringBuffer(128);
    sbuf.append(event.getTimeStamp() - event.getLoggingContextVO.getBirthTime());
    sbuf.append(" ");
    sbuf.append(event.getLevel());
    sbuf.append(" [");
    sbuf.append(event.getThreadName());
    sbuf.append("] ");
    sbuf.append(event.getLoggerName();
    sbuf.append(" - ");
    sbuf.append(event.getFormattedMessage());
    sbuf.append(CoreConstants.LINE_SEP);
    return sbuf.toString();
  }
}</pre>

    <p><code>MySampleLayout</code>は<a href="http://logback.qos.ch/xref/ch/qos/logback/core/LayoutBase.html"><code>LayoutBase</code></a>を継承しているのに気付きましたか。このクラスは全てのレイアウトのインスタンスに共通する内部状态を管理するものです。例えば，レイアウトが开始しているか，停止しているか，ヘッダーはあるか，フッターはあるか，コンテンツタイプはあるか，といったものです。発，开発者は书式化の方法にだけ集中することができるのです。<code>LayoutBase</code>ですリッククラスです。上记のコードでは， <code>MySampleLayout</code>は<code>LayoutBase<ILoggingEvent></code>を継承しています。
    </p>

    <p><code>doLayout(ILoggingEvent event)</code>メソッド（ <code>MySampleLayout</code>の実装する唯一のメソッドです）では，最初に空の<code>StringBuffer</code>を生成して，ロギングイベントのパラメータを付け足していきます。开拓者らしく，慎重に书式化したようです。ロギング要求で1つ以上のパラメータが渡されることを考えればこれは大事なことです。</p>

    <p><code>doLayout()</code>をッドでは，StringBufferにいろいろな文字列を追加したあとで1つの文字列に変换して，その文字列を呼び出し元に返します。
    </p>

    <p>上记の<code>doLayout</code>メソッドでは，ロギングイベントに含まれる可能のあるあらゆる例外を无视します。実际のレイアウトの実装では，ほぼ确実に例外の内容を出力したいはずです。
    </p>

    <h3 class="doAnchor" name="configuringYourOwnLayout">自作レイアウトの设定</h3>

    <p>自作レイアウトは，他のコンポーネントと同じように设定されます。有利したように<code>FileAppender</code>とその派生生クラスにはエンコーダーがーが必要です。<code>FileAppender</code>のニーズを満たすため， <code>LayoutWrappingEncoder</code>に自作した<code>MySampleLayout</code>をラップしてみましょう。次のような设定になります。</p>

  <p class="example">例：MySampleLayoutの设定（ <a href="http://logback.qos.ch/xref/chapters/layouts/sampleLayoutConfig.xml">logback-examples / src / main / java / chapters / layouts / sampleLayoutConfig.xml</a> ）</p>
  <span class="asGroovy" onclick="return asGroovy('logback_Console');">Groovyで表示</span>
<pre id="sampleLayoutConfig" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    <b>&lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt;</b>
      <b>&lt;layout class="chapters.layouts.MySampleLayout" /&gt;</b>
    <b>&lt;/encoder&gt;</b>
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

    <p>ンプルアプリケーションの<code><a href="http://logback.qos.ch/xref/chapters/layouts/SampleLogging.html">chapters.layouts.SampleLogging</a></code>は，一つ目の引数で指定された设定ファイルを使ってlogbackを设定します。ジを，デバッグメッセージとエラーメッメージを1つづつロギングします。</p>

    <p><em>logback-examples</em>ディレクトリに移动して，次のコマンドを実行してみましょう。
    </p>

    <p class="command">Java chapters.layouts。SampleLogging src / main / java / chapters / layouts / sampleLayoutConfig.xml</p>

    <p>コンソールには次のように出力されます。</p>

<div class="source"><pre>0 DEBUG [main] chapters.layouts.SampleLogging - Everything's going well
0 ERROR [main] chapters.layouts.SampleLogging - maybe not quite...</pre></div>

    <p>简単でしょう？エレア派の懐疑论者ピュロンは，それ自体が不确実であるということ以外に确実なことは无い，と涉しました。かなこ，确かなことなど何もないというのです。彼はきっとこう质问するでしょう。「それでレイアウトのオプションについてはどうなっているの？」上记の自作レイアウトを少し変更したバージョンが<a href="http://logback.qos.ch/xref/chapters/layouts/MySampleLayout2.html"><code>MySampleLayout2.java</code></a>です。でものマニマアル全体を通じて言えることですが，レイアウトウlogbackの他のコンポーネントでも，単にセッターメソッドを设定するだけでプロパティを指定できるようになります。
    </p>

    <p><a href="http://logback.qos.ch/xref/chapters/layouts/MySampleLayout2.html"><code>MySampleLayout2</code></a>クラスには，2つのプロパティがあります。一つ目は，出力されるメッセージの先头に追加する接头辞です。二つ目は，ロギング要求を送信したスレッドの名前を表示するかどうかを选択する真伪値です。
    </p>

    <p><a href="http://logback.qos.ch/xref/chapters/layouts/MySampleLayout2.html"><code>MySampleLayout2</code></a>のコードを见てみましょう。</p>

    <pre class="prettyprint source">package chapters.layouts;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class MySampleLayout2 extends LayoutBase&lt;ILoggingEvent&gt; {

  String prefix = null;
  boolean printThreadName = true;

  <b>public void setPrefix(String prefix) {
    this.prefix = prefix;
  }

  public void setPrintThreadName(boolean printThreadName) {
    this.printThreadName = printThreadName;
  }</b>

  public String doLayout(ILoggingEvent event) {
    StringBuffer sbuf = new StringBuffer(128);
    <b>if (prefix != null) {
      sbuf.append(prefix + ": ");
    }</b>
    sbuf.append(event.getTimeStamp() - event.getLoggerContextVO().getBirthTime());
    sbuf.append(" ");
    sbuf.append(event.getLevel());
    <b>if (printThreadName) {
      sbuf.append(" [");
      sbuf.append(event.getThreadName());
      sbuf.append("] ");
    } else {
      sbuf.append(" ");
    }</b>
    sbuf.append(event.getLoggerName());
    sbuf.append(" - ");
    sbuf.append(event.getFormattedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }
}</pre>


    <p>ドをロパティのセッターメソッドを追加ドを设定ファイルから指定できるようになります。<code>printThreadName</code>プロパティの型は真伪値（boolean）であって文字列（ <code>String</code> ）ではないので注意してください。logbackのコンポーネントの设定については， <a href="http://logback.qos.ch/manual/configuration.html">设定に关する章</a>で详しく说明しています。<a href="http://logback.qos.ch/manual/onJoran.html">Joranの章</a>にはより详细な说明があります。<code>MySampleLayout2</code>のために特别に誂えた设定ファイルは次のとおりです。
    </p>


    <span class="asGroovy" onclick="return asGroovy('MySampleLayout2');">Groovyとして表示</span>
    <pre id="MySampleLayout2" class="prettyprint source">&lt;configuration&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt;
      &lt;layout class="chapters.layouts.MySampleLayout2"&gt;
        <b>&lt;prefix&gt;MyPrefix&lt;/prefix&gt;</b>
        <b>&lt;printThreadName&gt;false&lt;/printThreadName&gt;</b>
      &lt;/layout&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

   <p></p>


    <h2 class="doAnchor" name="ClassicPatternLayout">模式布局</h2>

    <p>经典的返配布物には， <code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/PatternLayout.html">PatternLayout</a></code>と呼ばれる柔软性のあるレイアウトが含まれています。他のレイアウトと同じく， <code>PatternLayout</code>はロギングイベントを受け取って<code>文字列</code>を返します。<code>文字列</code> ，変换パターン文字列を调整してカスタマイズすることができます。
    </p>

    <p><code>PatternLayout</code>の変换パターン文字列はC言语の<code>printf()</code>关数と非常によく似たもので，文字列リテラルと<em>変换指定</em>と呼ばれる书式制御风格で构成されています。変换パターン文字列には，どんな文字列リテラルでも入れることができます。％换指定はパーセント记号“％”で始まり，オプションの<em>书式修饰子</em> ， <em>変换指定子</em> ，括弧で囲まれたパラメータが続いたものです。変换指定子には変换したいデータフィールドを指定します。例えばロガー名，レベル，日付，スレッド名などです。书式修饰子には，フィールド幅，パディング，左揃えや右揃えを指定します。
    </p>

    <p>既に何度か述べたとおり， <code>FileAppender</code>とその派生生クラスにはエンコーダーがーが必要です。结局， <code>FileAppender</code>やその派生クラスと<code>PatternLayout</code>に一绪に使うには，エンコーダーでラップしなければなりません。<code>FileAppender</code>と<code>PatternLayout</code>を组み合わせることがあまりにも一般的になってしまったことを考虑して，logbackの配布物には<code>PatternLayoutEncoder</code>を含めるようになりました。これは単に<code>PatternLayout</code> atterラップするだけのエンコーダーなので，エンコーダーであるにも关わらずPatternLayoutのように扱えるようになっています。プログラム的に<code>ConsoleAppender</code>と<code>PatternLayoutEncoder</code>を设定する例を示します。</p>


  <p class="example">例：PatternLayoutの使用例（ <a href="http://logback.qos.ch/xref/chapters/layouts/PatternSample.html">logback-examples / src / main / java / chapters / layouts / PatternSample.java</a> ）</p>

    <pre class="prettyprint source">package chapters.layouts;

import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.ConsoleAppender;

public class PatternSample {

  static public void main(String[] args) throws Exception {
    Logger rootLogger = (Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    LoggerContext loggerContext = rootLogger.getLoggerContext();
    // we are not interested in auto-configuration
    loggerContext.reset();

    <b>PatternLayoutEncoder encoder = new PatternLayoutEncoder();</b>
    <b>encoder.setContext(loggerContext);</b>
    <b>encoder.setPattern("%-5level [%thread]: %message%n");</b>
    <b>encoder.start();</b>

    ConsoleAppender&lt;ILoggingEvent&gt; appender = new ConsoleAppender&lt;ILoggingEvent&gt;();
    appender.setContext(loggerContext);
    appender.setEncoder(encoder);
    appender.start();

    rootLogger.addAppender(appender);

    rootLogger.debug("Message 1");
    rootLogger.warn("Message 2");
  }
}</pre>

    <p>％の例では，変换パターン文字列として<b>“％-5level [％thread]％msg％n”</b>が设定されています。logbackに组み込みの変换指定子については后で简単に说明します。<code>PatternSample</code>アプリケーションを実行してみましょう。</p>

    <p class="source">Java Java Chapters.layouts。模式样本</p>

    <p>コンソールにに次のように出力されます。</p>

    <p class="source">调试[主要]：消息1警告[主要]：消息2</p>

    <p>変换パターン文字列の<b>“％-5level [％thread]％msg％n”</b>には，文字列リテラルと変换指定子を明示的に区切る文字が无いことに気付きましたか。変换パターン文字列を解析する际， <code>PatternLayout</code>空白文字列リテラル（空白文字，括弧，コロンなど）と変换指定を分离することができます。上记の例では，変换指定“％-5level”は，ロギングイベントのレベルを5文字の幅に左揃えすることを意味します。书式指定子については后で说明します。
    </p>

    <p><code>PatternLayout</code>は変换パターン文字列をグループ化するために括弧を使います。<b>（'（'と'）'には特别な意味があるので，リテラル文字列として使うときはエスケープしなければならないということです。</b> 括弧の特殊な性质について详しくは<a href="http://logback.qos.ch/manual/layouts.html#Parentheses">后で说明</a>します。
    </p>

    <p>前面的のとおり，変换指定によっては括弧で囲んでオプションの引数を指定することができます。例えばこういう书き方です。<code>%logger{10}</code> “ logger”が変换指定子で，10が引数です。ンの指定の仕方について详しくは<a href="http://logback.qos.ch/manual/layouts.html#cwOptions">后で说明</a>します。
    </p>

    <p>利用できる変换指定とオプションを表にまとめました。1つのセルに复数の変换指定子が登场する场合，それらは别名という意味です。
    </p>

    <table class="bodyTable properties striped" border="0">
      <tbody><tr>
        <th><a name="conversionWord" href="http://logback.qos.ch/manual/layouts.html#conversionWord">変换指定子</a></th>
        <th>效果</th>
      </tr>

      <tr>
        <td class="word" name="logger">
          <a name="logger" href="http://logback.qos.ch/manual/layouts.html#logger"><span class="anchor"></span></a> <b>c</b> { <em>长度</em> }<br>
          <b>lo</b> { <em>长度</em> }<br>
          <b>记录器</b> { <em>长度</em> }<br>
        </td>

        <td>ロギングイベントを生成する一番元になったロガーの名前を出力します。

          <p>この変换指定子に指定できるオプションは整体は。ロガー名は省略アルゴリズムに従って，意味が通る程度に短缩されます。0を指定すると特别な振る舞いをします。ロガー名文字列の中で一番右端のドット（。）から右だけを残すようになります。省略アルゴリズムの例を表にまとめました。
          </p>

          <table class="bodyTable dark" border="0" cellpadding="8">
            <tbody><tr>
              <th>変换指定</th>
              <th>ロガー名</th>
              <th>结果</th>
            </tr>
            <tr>
              <td>％logger</td>
              <td>mainPackage.sub.sample。酒吧</td>
              <td>mainPackage.sub.sample。酒吧</td>
            </tr>

            <tr>
              <td>％logger {0}</td>
              <td>mainPackage.sub.sample。酒吧</td>
              <td>酒吧</td>
            </tr>

            <tr>
              <td>％logger {5}</td>
              <td>mainPackage.sub.sample。酒吧</td>
              <td>短信酒吧</td>
            </tr>

            <tr>
              <td>％logger {10}</td>
              <td>mainPackage.sub.sample。酒吧</td>
              <td>短信酒吧</td>
            </tr>

            <tr>
              <td>％logger {15}</td>
              <td>mainPackage.sub.sample。酒吧</td>
              <td>mssample。酒吧</td>
            </tr>

            <tr>
              <td>％logger {16}</td>
              <td>mainPackage.sub.sample。酒吧</td>
              <td>m.sub.sample。酒吧</td>
            </tr>

            <tr>
              <td>％logger {26}</td>
              <td>mainPackage.sub.sample。酒吧</td>
              <td>mainPackage.sub.sample。酒吧</td>
            </tr>
          </tbody></table>

          <p>オプションで指定した长さを越えるとしても，一番右边のドット（。）から后ろは省略されないので気をつけてください。になりますが以外の部分は最短で1文字になりますが，削除することはありません。</p>

        </td>
      </tr>

      <tr>
        <td class="word" name="class">
          <b>C</b> { <em>长度</em> }<br>
          <b>类</b> { <em>长度</em> }<br>
        </td>

        <td>
          <p>ロギング要求を生成した呼び出し元のクラスの完全名を出力します。</p>

          <p><em>％logger</em>と同じように，引数の整体値に合わせて名前を短缩します。0には特别な意味があり，パッケージ名を除いた単纯クラス名を出力するようになります。デフォルトでは，完全クラス名が出力されます。
          </p>

          <p>送信侧のクラス情报を生成するのはとても高速とは言えません。実行速度が问题にならない场合にだけ使うほうが良いでしょう。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="contextName">
          <b>contextName</b><br>
          <b>cn</b><br></td>
          <td>ロギングイベントを生成したロガーの割り当てられたロギングコングコストの名前。</td>
      </tr>
      <tr>
        <td class="word" name="date">
          <b>d</b> { <em>模式</em> }<br>
          <b>日期</b> { <em>模式</em> }<br>
          <b>d</b> { <em>模式</em> ， <em>时区</em> }<br>
          <b>日期</b> { <em>pattern</em> ， <em>timezone</em> }<br>
        </td>
        <td>
         <p>ロギングイベントの日时を出力するために使います。引数として日时パターン文字列を指定することができます。日时パターン文字列は<a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html"><code>java.text.SimpleDateFormat</code></a>と互换性があります。</p>

         <p>引数に<em>“ ISO8601”</em>と指定するとISO8601の书式になります。日时パターン文字列が指定されなかった场合，デフォルトは<a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601书式</a>になるので注意してください。</p>

         <p>いくつかサンプルを见てください。日时が2006年10月20日（金曜日）であることを想定しています。のマニュアルを书いた人が昼食から戻ってきた日时です。</p>

         <table class="bodyTable dark" cellpadding="8">
           <tbody><tr>
             <th>変换パターン</th>
            <th>结果</th>
           </tr>
           <tr>
             <td>％d</td>
             <td>2006-10-20 14：06：49,812</td>
           </tr>
           <tr>
             <td>％日期</td>
             <td>2006-10-20 14：06：49,812</td>
           </tr>
           <tr>
             <td>％date {ISO8601}</td>
             <td>2006-10-20 14：06：49,812</td>
           </tr>
           <tr>
             <td>％date {HH：mm：ss。SSS}</td>
             <td>14：06：49.812</td>
           </tr>
           <tr>
             <td>％date {dd MMM yyyy; HH：mm：ss。SSS}</td>
             <td>10月20日2006; 14：06：49.812</td>
           </tr>
         </tbody></table>

          <p>二番目の引数にはタイムゾーンを指定します。たとえば，'％date {HH：mm：ss。SSS，澳大利亚/珀斯}'と指定すると，世界中で一番孤立しているオーストラリアのパースの时刻を出力するようになります。JVMイムゾーンが指定されなかった场合，JVMのタイムゾーンが使用されます。指定したタイムゾーンが未知のものであったりタイプミスだった场合， <a href="http://docs.oracle.com/javase/6/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String)">TimeZone.getTimeZone（String）</a>メソッドの仕様に基づいてGMTが指定されたものとして解釈します。
          </p>

          <p><span class="label">よくある间违い</span>は，カンマ（，）が引数の区切り文字として解釈されてしまうことです。<code>HH:mm:ss,SSS</code>というパターン文字列は<code>HM:mm:ss</code>というパターン文字列<code>SSS</code>というタイムゾーンが指定されたものとして解釈されてしまいます。日时パターン文字列にカンマ（，）を入れたければ，パターン文字列をクォートで囲んでください。たとえば次のようにします。％date { <b>“</b> HH：mm：ss，SSS <b>”</b> }。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="file">
          <b>F</b><br><b>文件</b>
        </td>

        <td>
          <p>ロギング要求を発行したクラスのソースコードファイル名を出力します。
          </p>

          <p>ファイル情报を生成するのはとても高速であるとは言えません。実行速度が问题にならない场合にだけ使うほうが良いでしょう。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="caller">
          <b>来电者（深度）</b><br>
<b>呼叫者{深度，评估者1，...评估者n}</b>
        </td>

        <td>
          <p>ロギングイベントを生成した呼び出し元の位置情报（スタックの深さ，ソースコードファイルの行番号）。
          </p>

          <p>位置情报の中身はJVM実装によって変わりますが，普通ならロギングイベントを生成したメソッドの定义されたクラスの完全名，ソースコードファイル名，行番号が含まれます。
          </p>

          <p>表示されるメソッド呼び出しの深さを指定するため，オプションとして串联値を指定できます。
          </p>

          <p>例えば， <b>％caller {2}</b>と书いたら次のように出力されます。</p>

<pre class="source white_bg">0    [main] DEBUG - logging statement
Caller+0   at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)
Caller+1   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)</pre>

          <p>call <b>％caller {3}</b>と书いたら次のように出力されます。</p>

<pre class="source white_bg">16   [main] DEBUG - logging statement
Caller+0   at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)
Caller+1   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)
Caller+2   at mainPackage.ConfigTester.main(ConfigTester.java:38)</pre>

          <p>ロギングイベントの送信元情报を计算するかどうかを判定するため，オプションとして评価器を指定できるようになっています。<b>call</b>とえば， <b>％caller {3，CALLER_DISPLAY_EVAL}</b>と指定すると评価器の<em>CALLER_DISPLAY_EVAL</em>が<b>真</b>を返す场合にだけ，3行分のスタックトレースを出力することになります。
        </p>

         <p>评価器の种类は后で绍介します。</p>
        </td>
      </tr>

      <tr>
        <td class="word" name="line">
          <b>大号</b><br><b>线</b>
        </td>

        <td><p>ロギング要求が生成されたソースコードファイル中の行番号を出力します。</p>

          <p>行番号を算出するのは决して高速とは言えません。実行速度が问题にならない场合にだけ使うほうが良いでしょう。

          </p>
        </td>
      </tr>


      <tr>
        <td class="word" name="message">
          <b>米</b><br><b>味精</b><br><b>信息</b>
        </td>
        <td>
          <p>アプリケーションがロギングイベントに关连付けたメッセージを出力します。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="method">
          <b>中号</b><br><b>方法</b>
        </td>

        <td>
          <p>ロギング要求が生成されたメソッド名を出力します。</p>
          <p>メソッド名を生成するのは决して高速とは言えません。実行速度が问题にならない场合にだけ使うほうが良いでしょう。
</p>
        </td>
      </tr>

      <tr>
        <td class="word" name="newline">
          <b>ñ</b>
        </td>

        <td>
          <p>プラットフォーム依存の行区切り文字を出力します。</p>
          <p>\の変换指定子を使っても，行区切り文字として可移动性の无い“ \ n”や“ \ r \ n”を指定した场合と性能は変わりません。したがって，どんなときでも行区切り文字そのものではなく，この変换指定子を使うべきです。
          </p>
        </td>

      </tr>

      <tr>
        <td class="word" name="level">
          <b>p</b><br><b>乐</b><br><b>水平</b>
        </td>
        <td>ロギングイベントのレベルを出力します。</td>
      </tr>

      <tr>

        <td class="word" name="relative">
          <b>[R</b><br><b>相对的</b>
        </td>

        <td>アプリケーションが开始してから，ロギングイベントを生成するまでの経过时间をミリ秒単位で出力します。
        </td>
      </tr>


      <tr>
        <td class="word" name="relative">
          <b>Ť</b><br><b>线</b>
        </td>

        <td>ロギングイベントを生成したスレッドの名前を出力します。
        </td>

      </tr>

      <tr>
        <td class="word" name="mdc">
          <b>X</b> { <em>键：-defaultVal</em> }<br>
          <b>mdc</b> { <em>键：-defaultVal</em> }<br>
        </td>

        <td>

          <p>ロギングイベントを生成したスレッドに关连付けられていたMDC（诊断コンテキスト）の値を出力します。
          </p>

          <p><b>％mdc {uesrid}</b>のように<b>mdc</b>オプションにキーが指定されている场合，対応するMDCの値が出力されます。MDCの値がnullの场合， <b>：-</b>演算子で指定したデフォルト値が出力されます。デフォルト値が无かったら空文字列が出力されます。
          </p>

          <p>DCーが未指定のときは，MDCの内容がすべて出力されます。そのときの书式は“ key1 = val1，key2 = val2”のようになります。
          </p>

          <p>详しくは<a href="http://logback.qos.ch/manual/mdc.html">MDCの章</a>を参照してください。</p>

        </td>
      </tr>
      <tr>
        <td class="word" name="ex">
          <b>前</b> { <em>深度</em> }<br>
            <b>异常</b> { <em>深度</em> }<br>
          <b>可抛</b> { <em>深度</em> }<br>
          <br>
          <b>ex</b> {depth，evaluator-1，...，evaluator-n}<br>
          <b>异常</b> {depth，evaluator-1，...，evaluator-n}<br>
          <b>throwable</b> {depth，evaluator-1，...，evaluator-n}</td>

        <td>
          <p>ロギングイベントに例外オブジェクトが关连付けられていたら，その例外オブジェクトのスタックトレースを出力します。デフォルトでは完全なスタックトレースを出力します。
         </p>

         <p><em></em> throwable変换指定子に指定できるオプションは次のとおりです。</p>
         <ul>
           <li><em>短</em> ：スタックトレースの一行目だけを出力します</li>
           <li><em>full</em> ：完全なスタックトレースを出力します</li>
           <li>任意の整体：スタックトレースの先头から数えて指定した行数を出力します</li>
         </ul>

         <p>いくつか例を见てみましょう。</p>

         <table class="bodyTable">
            <tbody><tr class="a">
              <th>変换指定</th>
              <th>结果</th>
            </tr>
            <tr class="b">
              <td>％ex</td>
              <td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)
  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)</pre></td>
            </tr>
            <tr class="a">
              <td>％ex {short}</td>
              <td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)</pre></td>
            </tr>
            <tr class="b">
              <td>％ex {full}</td>
              <td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)
  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)</pre></td>
            </tr>
            <tr class="a">
              <td>％ex {2}</td>
              <td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)</pre></td>
            </tr>
         </tbody></table>

          <p>スタックトレースを出力するかどうかを判定するため，オプションとして评価器を指定できるようになっています。例えば， <b>％ex {full，EX_DISPLAY_EVAL}</b>と指定した<b>场合，评判</b>器<em>EX_DISPLAY_EVAL</em>が<b>伪</b>を返すときだけ例外オブジェクトの完全なスタックトレースが出力されます。评価器についてはこのドキュメントの后のほうで说明しています。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="xThrowable">
          <b>xEx</b> { <em>深度</em> }<br>
          <b>xException</b> { <em>深度</em> }<br>
          <b>xThrowable</b> { <em>深度</em> }<br>
          <br>
          <b>xEx</b> {depth，evaluator-1，...，evaluator-n}<br>
          <b>xException</b> {depth，evaluator-1，...，evaluator-n}<br>
          <b>xThrowable</b> {depth，evaluator-1，...，evaluator-n}</td>

        <td>
          <p>クラスのパッケージングに关する情报が追加がいること以外は％throwableと同様です。</p>

          <p>変换パターン文字列に％xThrowableや他のthrowable关连の変换指定子を指定しなかった场合， <code>PatternLayout</code> x末尾に％xThrowableを自动的に追加します。スタックトレースの情报は非常に重要だからです。スタックトレースを出力したくなければ，％xThrowableの代わりに％nopexを指定すればよいです。％nopexの说明も参照してください。
         </p>

          <p>例外のスタックトレースの各行の终わりに，そのクラスが含まれるjarファイル名とMANIFEST.MFに书かれた“实施版”が追加されます。はの画期的なテクニックを考案したのは<a href="http://macstrac.blogspot.com/2008/09/better-stack-traces-in-java-with-log4j.html">James Strachan</a>です。がッケージングの情报が不确かな场合，先头にチルダ（〜）が付きます。
          </p>

          <p>例を见てみましょう。</p>

          <p class="source small">java.lang。com.xyz上的NullPointerException。Wombat（Wombat.java:57） <b><span class="red">〜</span> [wombat-1.3.jar：1.3]</b>在com.xyz。Wombat（Wombat.java:76）〜[wombat-1.3.jar：1.3]在sun.reflect。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）〜[na：1.5.0_06]。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）〜[na：1.5.0_06]。DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）〜[na：1.5.0_06]，位于java.lang.reflect。org.junit.internal.runners上的Method.invoke（Method.java:585）〜[na：1.5.0_06]。位于org.junit.internal.runners的TestMethod.invoke（TestMethod.java:59）[junit-4.4.jar：na]。MethodRoadie.runTestMethod（MethodRoadie.java:98）[junit-4.4.jar：na] ...等</p>

          <p>logbackはパッケージング情报グ正しく出力されるよう，适切な幅を确保します。がクラスローダーの阶层が复雑になっていても頑張ります。残念ながら正确性が担保できないときは先头にチルダ（〜）を付けます。理，理屈の上では実际のパッケージング情报とは异なる内容を出力させることも可能です。omb，前の例でWombatクラスのパッケージング情报の先头にはチルダ（〜）があるので，本当は[wombat.jar：1.7]となるはずだったかもしれないのです。
          </p>

          <p><a href="http://jira.qos.ch/browse/LBCLASSIC-212">利用者からのフィードバックによると</a> ，NetBeansはパッケージング情报を缩めてしまうそうです。Netbeansのユーザーは，変换パターン文字列の最后に“％ex”を追加して，スタックトレースにパッケージング情报が出てこないようにしたほうが良いでしょう。たとえば，“％d％logger-％m％n”という変换パターン文字列を使っているなら，“％d％logger-％m％n <b>％ex</b> ”と书き换えればよいのです。</p>
        </td>

      </tr>

      <tr>
        <td class="word" name="nopex">
          <b>诺佩克斯</b> <br>
          <b>止痛药</b>
        </td>

        <td>
          <p>スタックトレースの情报を<em>扱うように见えます</em>が，実际は何も出力しません。つまり，うまく例外を无视できるのです。
          </p>

          <p>％nopex変换指定子を使うと， <code>PatternLayout</code>が内部的に実装している安全弁を无かったことにします。安全弁とは，変换パターン文字列に例外を扱う変换指定子が含まれていなかったらこっそり最后に％xThrowableを追加することです。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="marker">
          <b>记号笔</b>
        </td>

        <td>
          <p>ロギング要求に关连付けられたマーカーを出力します。</p>

          <p>があるーカーに子マーカーがある场合，次のような书式で両方のマーカーを出力します。
          </p>
          <p>
            <em>parentName [child1，child2]</em>
          </p>
        </td>
      </tr>


      <tr>
        <td class="word" name="property">
          <b>财产{key}</b>
        </td>

        <td><p><em>ー</em>という名前のプロパティに设定された値を出力します。关连するドキュメントは<a href="http://logback.qos.ch/manual/configuration.html#variableSubstitution">変数の定义</a>と<a href="http://logback.qos.ch/manual/configuration.html#scopes">変数のスコープ</a>です。

        <em>キー</em>がロガーコンテキストのプロパティではなかったら，システムプロパティを探します。</p>


         <p><em>キー</em>に対するデフォルト値はありません。プロパティが见つからなかったら，“ Property_HAS_NO_KEY”という文字列が値になります。エラーであることがすぐにわかりますね。</p>

        </td>
      </tr>

      <tr>
        <td class="word" name="replace">
          <b>replace（ <em>p</em> ）{r，t}</b>
        </td>

        <td>
          <p>変换パターン文字列“ p”について，距离表现'r'にマッチした部分を文字列't'で放置き换えます。たとえば，“％replace（％msg）{'\ s'，”}“とすると，ロギングイベントに设定されたメッセージに含まれるすべての空白文字を削除します。
          </p>

          <p>换パターン文字列“ p”はどれだけ复雑になってもいいですし，复数の変换指定を含めることもできます。たとえば，“％replace（％logger％msg）'\。'，'/'}”とすると，ロガー名とメッセージに含まれる全てのドット（。）/スラッシュ（/）で置き换えます。
          </p>

        </td>
      </tr>


      <tr>
        <td class="word" name="rootException">
          <b>rEx</b> { <em>深度</em> }<br>
          <b>rootException</b> { <em>深度</em> }<br>
          <br>
          <b>rEx</b> {depth，evaluator-1，...，evaluator-n}<br>
          <b>rootException</b> {depth，evaluator-1，...，evaluator-n}</td>

        <td>
          <p>ロギングイベントに例外オブジェクトが关连付けられていたら，その例外オブジェクトのスタックトレースを出力します。标准とは逆に，例外の発生元から顺番にスタックトレースを出力します。出力になります（サンプルなのでだいぶ削っています）。</p>

         <pre class="small">java.lang.NullPointerException
  at com.xyz.Wombat(Wombat.java:57) ~[wombat-1.3.jar:1.3]
  at com.xyz.Wombat(Wombat.java:76) ~[wombat-1.3.jar:1.3]
Wrapped by: org.springframework.BeanCreationException: Error creating bean with name 'wombat':
  at org.springframework.AbstractBeanFactory.getBean(AbstractBeanFactory.java:248) [spring-2.0.jar:2.0]
  at org.springframework.AbstractBeanFactory.getBean(AbstractBeanFactory.java:170) [spring-2.0.jar:2.0]
  at org.apache.catalina.StandardContext.listenerStart(StandardContext.java:3934) [tomcat-6.0.26.jar:6.0.26]
</pre>

         <p>％rootExceptionには，％xExceptionと同じオプションを指定できます。グ，パッケージング情报も出力します。简単に言うと，％rootExceptionは％xExceptionとほとんど変わりませんが，スタックトレースの出力顺だけが逆になっているのです。
         </p>

         <p>％のrootExceptionの作者であるTomasz Nurkiewiczは，自身のブログエントリ<a href="http://nurkiewicz.blogspot.com/2011/09/logging-exceptions-root-cause-first.html">“记录信息的根本原因首先”</a>で解说しています。</p>
        </td>
      </tr>

    </tbody></table>


    <h4 class="doAnchor" name="percentIsSpecial">％文字の特别な意味</h4>

    <p>変换パターン文字列というコンテキストにおいて，％文字には特别な意味があります。文字列リテラルとして使用するにはバックスラッシュ（\）を前につけてエスケープしなければなりません。たとえば“％d％p \ %% m％n”といったようにします。
    </p>

    <h4 class="doAnchor" name="restrictionsOnLiterals">変换指定子の直后の文字列リテラルの制限</h4>

    <p>场合とんどの场合文字列リテララルにはスペースや他の区切り文字が含まれるので，変换指定子と混同されることはありません。例えば，変换パターン文字列“％level [％thread]-％mmessage％n”には文字列リテラル<code>" ["</code>と<code>"] - "</code>が含まれています。Java，Javaの识别子に使える文字リテラルが変换指定子の直后に现れると，logbackの文字列パターン解析器はその文字リテラルも変换指定子の一部だと勘违いしてしまいます。例えば，変换パターン文字列“％date <b>％nHello</b> ”は，％dateと％nHelloという二つの変换指定子として解釈されてしまいます。もちろん，％nHelloは変换指定子に存在しないため，logbackは％PARSER_ERROR [nHello]というエラーを出力するでしょう。％nのすぐ后に文字列リテラル“ Hello”を出したければ，％nに空の引数リストを指定すればよいでしょう。たとえば，“％date <b>％n {}</b>你好”とすれば，％date％n文字列リテラル“ Hello”という顺に解釈させることができるでしょう。

    </p>

    <h2 class="doAnchor" name="formatModifiers">书式修饰子</h2>

    <p>デフォルトでは，关连する情报はそのまま出力されます。しかし，书式修饰子を使えばそれぞれのデータを出力する幅の最小値と最大値，それに文字揃えを変えることが出来ます。
    </p>

    <p>书式修饰子のオプションは％记号と修饰文字の间に入れます。
    </p>

    <p>最初に绍介する书式修饰子のオプションは<em>左揃え</em>です。これはただのマイナス（-）を指定します。次は<em>最小幅</em>です。整体値で出力する文字数を指定します。出力する文字列长が指定した文字数より小さい时は，最小幅を全てうめるまで正面か垂直のどちらかをパディングします。デフォルトは右はのでルにパディングしますが，左揃えにして右にパディングさせることもできます。パディング文字は半角スペースです。出力する文字列长が指定した文字数より大きい时は，全て出力できるように幅を広げます。后ろを切り舍てることはありません。
    </p>

    <p>るの振る舞いは最杰出を指定すれば変えられます。<em>最大幅</em>はドット（。）の后に整体値で指定します。出力する文字列长が指定した文字数より大きい时は，溢れた分だけ出力する文字列の<em>先头</em>から削除されます。たとえば，最显着を8にしたとき，出力する文字列长が10だったら，先头の2文字が削除されることになります。C言语のprintf关数なら文字列の后ろのほうが削除されるので，逆の振る舞いをすることになります。
    </p>

    <p>ドット（。）に続けてマイナス文字（-）を指定すれば，后ろから削除することもできます。场合の场合，最显着が8として，出力する文字列长が10だったら，末尾の2文字が削除されることになります。
    </p>

    <p>书式修饰子の例をいくつか见ていきましょう。
    </p>

    <table class="bodyTable" border="0" cellpadding="8">
      <tbody><tr>
        <th>书式修饰子</th>
        <th>左寄せ</th>
        <th>最小幅</th>
        <th>最大幅</th>
        <th>コメント</th>
      </tr>
      <tr class="a">
        <td align="center">％20logger</td>
        <td align="center">しない</td>
        <td align="center">20</td>
        <td align="center">なし</td>
        <td>ロガー名が20文字未満であれば半角スペースで顶端にパディングします。
        </td>
      </tr>
      <tr class="b">
        <td align="center">％-20logger</td>
        <td align="center">する</td>
        <td align="center">20</td>
        <td align="center">なし</td>
        <td>ロガー名が20文字未満であれば半角スペースで右边でングします。
        </td>
      </tr>
      <tr class="a">
        <td align="center">％.30logger</td>
        <td align="center">指定できない</td>
        <td align="center">なし</td>
        <td align="center">30</td>
        <td>ロガー名が30文字を超える场合，先头から切り舍てます。
        </td>
      </tr>
      <tr class="b">
        <td align="center">％20.30logger</td>
        <td align="center">しない</td>
        <td align="center">20</td>
        <td align="center">30</td>
        <td>ロガー名が20文字未満であれば半角スペースで顶端にパディングします。ロガー名が30文字を超える场合，先头から切り舍てます。
        </td>
      </tr>
      <tr class="a">
        <td align="center">％-20.30logger</td>
        <td align="center">する</td>
        <td align="center">20</td>
        <td align="center">30</td>
        <td>ロガー名が20文字未満であれば半角スペースで右边でングします。ロガー名が30文字を超える<em>场合</em> ， <em>先头</em>から切り舍てます。
        </td>
      </tr>
      <tr class="b">
        <td align="center">％.- 30logger</td>
        <td align="center">指定できない</td>
        <td align="center">なし</td>
        <td align="center">30</td>
        <td>ロガー名が30文字を超える<em>场合</em> ， <em>末尾</em>から切り舍てます。
        </td>
      </tr>
    </tbody></table>

    <p>书式修饰子による文字列の切り舍ての例を表にまとめました。角括弧“ []”は出力される文字列ではなく，出力幅を示しているだけなので注意してください。</p>


    <table class="bodyTable" border="0" cellpadding="8">
      <tbody><tr>
        <th>书式修饰子</th>
        <th>ロガー名</th>
        <th>结果</th>
      </tr>
      <tr class="b">
        <td align="center">[％20.20logger]</td>
        <td align="center">主要。名称</td>
        <td align="center"><pre>[           main.Name]</pre></td>
      </tr>
      <tr class="a">
        <td align="center">[％-20.20logger]</td>
        <td align="center">主要。名称</td>
        <td align="center"><pre>[main.Name           ]</pre></td>
      </tr>
      <tr class="a">
        <td align="center">[％10.10logger]</td>
        <td align="center">main.foo.foo.bar。名称</td>
        <td align="center"><pre>[o.bar.Name]</pre></td>
      </tr>
      <tr class="b">
        <td align="center">[％10.-10logger]</td>
        <td align="center">main.foo.foo.bar。名称</td>
        <td align="center"><pre>[main.foo.f]</pre></td>
      </tr>
    </tbody></table>

    <h3 class="doAnchor" name="oneLetterLevel">でルを1文字で出力する</h3>

    <p>ロギングレベルをTRACE，DEBUG，WARN，INFO，ERRORのような文字列として出力するのではなく，T，D，W，I，Eのように一文字だけ出力したい场合もあるでしょう。<a href="http://logback.qos.ch/manual/layouts.html#customConversionSpecifier">カスタムコンバーター</a>を実装してもできるでしょうし，书式修饰子を使うこともできます。书式修饰子を使うなら<code>"%.-1level"</code>とすればよいでしょう。
    </p>

    <h2 class="doAnchor" name="cwOptions">変换指定子のオプション</h2>

    <p>変换指定子にはオプションを指定することができます。オプションは必ず中括弧で囲むようにします。オプションで何ができるのか，すでに目にしてきたものがあります。たとえば， <em>％mdc {someKey}</em>のようにMDC変换指定子と组み合わせることができます。
    </p>

    <p>変换指定子のオプションは复数になるかもしれません。たとえば，评価器を使う変换指定子があります。后で说明しますが，こんな风に评価器の名前を复数并べることがあるかもしれません。</p>

    <pre class="prettyprint source">&lt;pattern&gt;%-4relative [%thread] %-5level - %msg%n \
  <b>%caller{2, DISP_CALLER_EVAL, OTHER_EVAL_NAME, THIRD_EVAL_NAME}</b>&lt;/pattern&gt;</pre>

    <p>指定するオプションに括弧，スペース，カンマなどの特别な文字が含まれるときは，シングルクォートやダブルクォートで囲みます。たとえば，次のような変换パターン文字列になります。</p>

    <pre class="prettyprint source">&lt;pattern&gt;%-5level - %replace(%msg)<b>{'\d{14,16}', 'XXXX'}</b>%n&lt;/pattern&gt;</pre>


    <p>この例では， <code>replace</code>変换指定子にオプションとして<code>\d{14,16}</code>と<code>XXXX</code>を指定しています。これは，メッセージ中に14桁から16桁の数字文字列があったらそれをXXXXで置き换えるものです。クレジットカード番号をマスクするのに役立ちます。“ \ d”は一桁の数字を表す距离表现の省略形です。后ろに“ {14,16}”をつけているので，一つ前の文字，つまり一桁の数字が14个から16个缲り返される场合にマッチすることになります。
    </p>

    <h2 class="doAnchor" name="Parentheses">括弧は特别扱い</h2>

    <p>logbackでは，パターン文字列の中の括弧は，トークンをグループ化するものとして扱います。プはそれのグループはそれ自体を1つのパターン文字列として扱うことができます。logback0.9.27から， <a href="http://logback.qos.ch/manual/layouts.html#replace">％replace</a>のような変换指定子を组み合わせて部分パターン文字列を作れるようになりました。
    </p>

    <p>こんなパターン文字列があるとします。</p>

    <p class="source"><b>％-30（</b> ％d {HH：mm：ss。SSS} [％thread] <b>）</b> ％-5level％logger {32}-％msg％n</p>

    <p>，部分パターン文字列“％d {HH：mm：ss。SSS} [％thread]“によって生成された出力をグループ化します。が，この部分パターン文字列によって生成された出力が30文字未満の文字列だった场合，右侧にパディングされるのです。
    </p>

    <p>しなかったループ化しなかった场合はこういう出力になります。</p>

    <p class="source">13:09:30 [main]调试cqlogback.demo。ContextListener-Classload哈希码为13995234 13:09:30 [main] DEBUG cqlogback.demo。ContextListener-ServletContext的初始化13:09:30 [main]调试cqlogback.demo。ContextListener-试用平台Mbean服务器13:09:30 [pool-1-thread-1]信息ch.qos.logback.demo。LoggingTask-Howdydy-diddly-ho-0 13:09:38 [btpool0-7]信息cqldemo.lottery。LotteryAction-号码：50次尝试。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-开始分解。13:09:40 [btpool0-7]调试cqldprime。NumberCruncherImpl-尝试2作为一个因子。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-找到的因子2</p>

    <p>“％-30（）”でグループ化するとこうなります。</p>

    <p class="source">13:09:30 [main]调试cqlogback.demo。ContextListener-Classload哈希码为13995234 13:09:30 [main] DEBUG cqlogback.demo。ContextListener-ServletContext的初始化13:09:30 [main]调试cqlogback.demo。ContextListener-试用平台Mbean服务器13:09:30 [pool-1-thread-1]信息ch.qos.logback.demo。LoggingTask-Howdydy-diddly-ho-0 13:09:38 [btpool0-7]信息cqldemo.lottery。LotteryAction-号码：50次尝试。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-开始分解。13:09:40 [btpool0-7]调试cqldprime。NumberCruncherImpl-尝试2作为一个因子。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-找到的因子2</p>


    <p>上方のほうが読みやすいんじゃないでしょうか。</p>

    <p>括弧を文字列リテラルとして扱いたいときは，バックスラッシュ（\）でエスケープしなければなりません。こんな感じです。” <b>\（</b> ％d {HH：mm：ss。SSS} [％thread] <b>\）</b> “</p>

    <h2 class="doAnchor" name="coloring">カラー化</h2>

    <p><a href="http://logback.qos.ch/manual/layouts.html#Parentheses">括弧</a>でグループ化した部分パターン文字列には色を指定することができます。logback1.0.5から<code>PatternLayout</code>指定できるようになった色付け用の変换指定子は次のとおりです。
    </p><ul>
      <li>“％黑色”</li>
      <li>“％红色”</li>
      <li>“％绿色”</li>
      <li>“％黄色”</li>
      <li>“％蓝色”</li>
      <li>“％品红”</li>
      <li>“％青色”</li>
      <li>“％白色”</li>
      <li>“％灰色”</li>
      <li>“％boldRed”</li>
      <li>“％boldGreen”</li>
      <li>“％boldYellow”</li>
      <li>“％boldBlue”</li>
      <li>“％boldMagenta”</li>
      <li>“％boldCyan”</li>
      <li>“％boldWhite”</li>
      <li>“％突出”</li>
    </ul>これらの変换指定子にはオプションとして部分パターン文字列を指定することが想定されています。そしてその部分パターン文字列から生成された出力には色が付きます。
    <p></p>

    <p>色付けをわかりやすく说明する设定ファイルを次に示します。％cyan変换指定子には部分パターン文字列として“％logger {15}”を指定してあるのがわかりますか。にと，ロガー名は15文字に短缩されるだけでなく，文字色がシアンになります。％highlight変换指定子を使うと，部分パターン文字列の文字色が，ログレベルがERRORが赤太太字，ログレベルがWARNなら赤字，ログレベルがINFOが青字，それ以外のログレベルならデフォルトの色になります。</p>

  <p class="example">例：ログレベルに応じた代表表示（ <a href="http://logback.qos.ch/xref/chapters/layouts/highlighed.xml">logback-examples / src / main / java / chapters / layouts / highlighed.xml</a> ）</p>

<span class="asGroovy" onclick="return asGroovy('highlighted');">Groovyとして表示</span>


<pre id="highlighted" class="prettyprint">&lt;configuration debug="true"&gt;
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;!-- On Windows machines setting withJansi to true enables ANSI
         color code interpretation by the Jansi library. This requires
         org.fusesource.jansi:jansi:1.8 on the class path.  Note that
         Unix-based operating systems such as Linux and Mac OS X
         support ANSI color codes by default. --&gt;
    <b>&lt;withJansi&gt;true&lt;/withJansi&gt;</b>
    &lt;encoder&gt;
      &lt;pattern&gt;[%thread] <b>%highlight(%-5level)</b> <b>%cyan(%logger{15})</b> - %msg %n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

     <p>この设定ファイルを使うと次のように出力されます。</p>

<pre class="source">[main] <span style="color:#611">WARN</span>  <span style="color:#2bd">c.l.TrivialMain</span> - a warning message 0
[main] DEBUG <span style="color:#2bd">c.l.TrivialMain</span> - hello world number1
[main] DEBUG <span style="color:#2bd">c.l.TrivialMain</span> - hello world number2
[main] <span style="color:#00f">INFO</span>  <span style="color:#2bd">c.l.TrivialMain</span> - hello world number3
[main] DEBUG <span style="color:#2bd">c.l.TrivialMain</span> - hello world number4
[main] <span style="color:#611">WARN</span>  <span style="color:#2bd">c.l.TrivialMain</span> - a warning message 5
[main] <span style="color:#f00">ERROR</span> <span style="color:#2bd">c.l.TrivialMain</span> - Finish off with fireworks</pre>

    <p>色付け用変换指定子を使うとパターン文字列が复数行になってしまうこともあります。<a href="http://logback.qos.ch/manual/layouts.html#customConversionSpecifier">変换指定を自作する</a>では设定ファイルで使用できる変换指定子を登录する手顺について议论しています。</p>

    <h2 class="doAnchor" name="Evaluators">评価器</h2>

    <p>前置したように，オプションをリストで指定できると，変换指定子に<a href="http://logback.qos.ch/xref/ch/qos/logback/core/boolex/EventEvaluator.html">EventEvaluator</a>に基づく动的な振る舞いを复数指定できる必要があるときは便利です。
    <code>EventEvaluator</code>の役割は，ロンギイベントが基准が合致するかどうかを判定するかどうかをとです。
    </p>

    <p>早速<code>EventEvaluator</code>の例を见てみましょう。次の设定ファイルは，ロギングイベントの日付，スレッド，レベル，メッセージと送信者情报をコンソールに出力するものです。ロギングイベントの送信者情报を抽出するのはとてもコストが高いので，特定のロガーが生成したロギング要求の场合だけに限定しています。ジに，メッセージに特定の文字列が含まれている场合だけにしています。てだけので，特定のロギングイベントについてだけ，送信者情报の生成と出力を行うことになります。送，送信者情报の性能らなルティが発生しません。
    </p>

    <p>评価器と<em>具体的な评価式</em>については， <a href="http://logback.qos.ch/manual/filters.html#evalutatorFilter">フィルタの章の独立したセクション</a>で绍介しています。もし评価器を実戦摄取しようとしているなら必ず読んでおいてください。この后で绍介する例では，明示的に书いていませんが<code>JaninoEventEvaluator</code>を使用しています。するにはので実行するには<a href="http://docs.codehaus.org/display/JANINO/Home">Jainoライブラリ</a>が必要になります。设定方法をまとめたドキュメントの<a href="http://logback.qos.ch/setup.html#janino">该当するセクション</a>を読んでください。</p>

  <p class="example">例：EventEvaluatorsの使用例（ <a href="http://logback.qos.ch/xref/chapters/callerEvaluatorConfig.xml">logback-examples / src / main / java / chapters / callerEvaluatorConfig.xml</a> ）</p>
<span class="asGroovy" onclick="return asGroovy('callerEvaluatorConfig');">Groovyとして表示</span>


    <pre id="callerEvaluatorConfig" class="prettyprint source">&lt;configuration&gt;
  <b>&lt;evaluator name="DISP_CALLER_EVAL"&gt;
    &lt;expression&gt;logger.contains("chapters.layouts") &amp;amp;&amp;amp; \
      message.contains("who calls thee")&lt;/expression&gt;
  &lt;/evaluator&gt;</b>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;
        %-4relative [%thread] %-5level - %msg%n<b>%caller{2, DISP_CALLER_EVAL}</b>
      &lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

    <p>设定の设定ファイル中の评価式は，ロガー名に“ chapters.layouts”が含まれており，かつ，メッセージに“ cl住你的人”“含まれているロギングイベントにマッチするものです。XMLのエンコーディングルールに従うため，＆文字は＆のようにエスケープしなければなりません。</p>

    <p>设定の设定ファイルを使用するクラスを见てみましょう。</p>

  <p class="example">例：EventEvaluatorsの使用例（ <a href="http://logback.qos.ch/xref/chapters/CallerEvaluatorExample.html">logback-examples / src / main / java / chapters / CallerEvaluatorExample.java</a> ）</p>
    <pre class="prettyprint source">package <b>chapters.layouts</b>;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class CallerEvaluatorExample {

  public static void main(String[] args)  {
    Logger logger = LoggerFactory.getLogger(CallerEvaluatorExample.class);
    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();

    try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(lc);
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
      // StatusPrinter will handle this
    }
    StatusPrinter.printInCaseOfErrorsOrWarnings(lc);

    for (int i = 0; i &lt; 5; i++) {
      if (i == 3) {
        logger.debug(<b>"who calls thee</b>?");
      } else {
        logger.debug("I know me " + i);
      }
    }
  }
}</pre>

    <p>はのアプリケーションショ特别何もしません。forループでロギング要求を5回生成します。三回目だけ“谁叫你？“というメッセージを出力します。
    </p>

    <p>次のコマンドで実行します。</p>

    <p class="source">Java chapters.layouts。CallerEvaluatorExample src / main / java / chapters / layouts / callerEvaluatorConfig.xml</p>

    <p>そうすると，コンソールに次のように出力されます。</p>

    <div class="source"><pre>0    [main] DEBUG - I know me 0
0    [main] DEBUG - I know me 1
0    [main] DEBUG - I know me 2
0    [main] DEBUG - who calls thee?
Caller+0   at chapters.layouts.CallerEvaluatorExample.main(CallerEvaluatorExample.java:28)
0    [main] DEBUG - I know me 4</pre></div>


    <p>ロギング要求が生成されたら，そのロギングイベントが评価されます。三回目のロギングイベントだけが评だけが条件にマッチするので，送信者情报が出力されます。他のロギングイベントは评価基准とマッチしないので送信者情报が出力されていません。
    </p>


    <p>现実世界のシナリオに対応できるように评価式を変更することにしましょう。例えばロガー名とロギング要求のレベルを组み合わせることもできます。そうすれば，ロギング要求のレベルが<em>WARN</em>より高くて，かつ，アプリケーションの重要部品，例えばお金に络むトランザクションを处理するモジュールで生成された场合にだけ送信者情报を出力する，といったことができるでしょう。
    </p>

    <p><b>重要：</b> <em>呼叫者変换指定</em>によって送信者情报が出力されるのは，评価式が<b>true</b>と<em>评価された</em>ときだけです。</p>

    <p>别の状况を考えてみましょう。ロギング要求に例外オブジェクトが设定されていると，スタックトレースも出力されます。特定，特定の例外オブジェクトのスタックトレースは出力したくないこともあります。
    </p>

    <p>次のコードでは，例外オブジェクトを指定したロギング要求を3つ生成しています。二つ目の例外オブジェクトは他のものと违ってメッセージに“不显示此”ととう文字列が含まれていますし，例外クラスが<code>chapters.layouts.TestException</code>になっています。ジをのメッセージを指示とみなして，二つ目の例外オブジェクトのスタックトレースが出力されないようにしてみましょう。</p>

  <p class="example">例：ExceptionEventEvaluatorsの使用例（ <a href="http://logback.qos.ch/xref/chapters/ExceptionEvaluatorExample.html">logback-examples / src / main / java / chapters / ExceptionEvaluatorExample.java</a> ）</p>
<pre class="prettyprint source">package chapters.layouts;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class ExceptionEvaluatorExample {

  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(ExceptionEvaluatorExample.class);
    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();

    try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(lc);
      lc.reset();
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
       // StatusPrinter will handle this
    }
    StatusPrinter.printInCaseOfErrorsOrWarnings(lc);

    for (int i = 0; i &lt; 3; i++) {
      if (i == 1) {
        logger.debug("logging statement " + i, new TestException(
            "do not display this"));
      } else {
        logger.debug("logging statement " + i, new Exception("display"));
      }
    }
  }
}</pre>

    <p>次の设定ファイルで指定した评価式は， <code>chapters.layouts.TextException</code>の例外オブジェクトが设定されたロギングイベントにマッチします。例外の例外型はスタックトレースの出力を抑止したい型そのものです。
    </p>

  <p class="example">例：ExceptionEventEvaluatorsの使用例（ <a href="http://logback.qos.ch/xref/chapters/exceptionEvaluatorConfig.xml">logback-examples / src / main / java / chapters / exceptionEvaluatorConfig.xml</a> ）</p>
    <pre class="prettyprint source">&lt;configuration&gt;

  <b>&lt;evaluator name="DISPLAY_EX_EVAL"&gt;
    &lt;expression&gt;throwable != null &amp;amp;&amp;amp; throwable instanceof  \
      chapters.layouts.TestException&lt;/expression&gt;
  &lt;/evaluator&gt;</b>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%msg%n<b>%ex{full, DISPLAY_EX_EVAL}</b>&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

    <p>はの设定は， <em>pages.layouts。TestException</em>のインスタンスが设定されたロギング要求については，常にスタックトレースの出力を抑止します。
    </p>

    <p>実行してみましょう。</p>

    <p class="source">Java chapters.layouts。ExceptionEvaluatorExample src / main / java / chapters / layouts / exceptionEvaluatorConfig.xml</p>

    <p>そうすると，次のような出力になります。</p>

<p class="source">日志记录语句0 java.lang。例外：显示在chapters.layouts。ExceptionEvaluatorExample.main（ExceptionEvaluatorExample.java:43）[logback-examples-0.9.19.jar：na]记录语句1记录语句2 java.lang。例外：显示在chapters.layouts。ExceptionEvaluatorExample.main（ExceptionEvaluatorExample.java:43）[logback-examples-0.9.19.jar：na]</p>


    <p>二つ目のロギング要求による出力にはスタックトレースが含まれていないことがわかりますか。うまく<code>TestException</code>のスタックトレースを出力しないようにできました。スタックトレースの各行の最后にある角括弧で囲まれた部分は<a href="http://logback.qos.ch/manual/layouts.html#xThrowable">パッケージング情报</a>です。</p>

    <p><b><em>％ex</em></b>変换指定があるので， <em>评価式</em>の结果が<b>false</b>になったときだけスタックトレースが出力されるようになっています。</p>



    <h2 class="doAnchor" name="customConversionSpecifier">変换指定子を自作する</h2>

    <p>ここまでに， <code>PatternLayout</code>に组み込みの変换指定子を见てきました。，変换指定子を自作することもできるのです。</p>

    <p>カスタム変换指定子を作るには2つの手顺を踏みます。
    </p>

    <h4>ステップ1</h4>

    <p>まず， <code>ClassicConverter</code>を継承したクラスを作ります。<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/pattern/ClassicConverter.html">ClassicConverter</a></code>の役割は， <code>ILoggingEvent</code>から情报を抽出して出力する文字列を生成をとです。変とえば，％logger変换指定子を実装した<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/pattern/LoggerConverter.html">LoggerConverter</a></code>は， <code>ILoggingEvent</code>抽出したロガーの名前を文字列として返します。ロガー名の省略はこの手顺で行います。</p>

    <p>アプリケーションが启动してからの経过时间をナノ秒単位で返すカスタム変换指定子の実装を见てみましょう。</p>

  <p class="example">例：自作コンバーターの例（ <a href="http://logback.qos.ch/xref/chapters/MySampleConverter.html">logback-examples / src / main / java / chapters / MySampleConverter.java</a> ）</p>
<pre class="prettyprint source">public class MySampleConverter extends ClassicConverter {

  long start = System.nanoTime();

  <b>@Override</b>
  <b>public String convert(ILoggingEvent event) {</b>
    <b>long nowInNanos = System.nanoTime();</b>
    <b>return Long.toString(nowInNanos-start);</b>
  <b>}</b>
}</pre>

    <p>この実装は非常に简単です。<code>MySampleConverter</code>クラスは<code>ClassicConverter</code>を継承しており， <code>convert(ILoggingEvent)</code>がッドはアプリケーションショ启动してからの経过时间をナノ秒単位で计算して，それを文字列化しているだけです。
    </p>

    <h4>ステップ2</h4>

    <p>重新登录に自作した<code>Converter</code>のことを教えなければいけません。そのためには，设定ファイルで新しい変换指定子を宣言する必要があります。</p>

  <p class="example">例：自作コンバーターの设定例（ <a href="http://logback.qos.ch/xref/chapters/mySampleConverterConfig.xml">logback-examples / src / main / java / chapters / mySampleConverterConfig.xml</a> ）</p>
<span class="asGroovy" onclick="return asGroovy('mySampleConverterConfig');">Groovyとして表示</span>
<pre id="mySampleConverterConfig" class="prettyprint source">&lt;configuration&gt;

  <b>&lt;conversionRule conversionWord="nanos"
                  converterClass="chapters.layouts.MySampleConverter" /&gt;</b>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;<b>%-6nanos</b> [%thread] - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre>

    <p>设定ファイルで宣言した新しい変换指定子は， <code>PatternLayout</code>指定する変换パターン文字列の中で他の変换指定と同じように使うことが出来ます。</p>

    <p>実行してみましょう。</p>

    <div class="source">Java chapters.layouts。SampleLogging src / main / java / chapters / layouts / mySampleConverterConfig.xml</div>

    <p>次のような出力になるはずです。</p>

    <pre class="source">4868695 [main] DEBUG - Everything's going well
5758748 [main] ERROR - maybe not quite...</pre>


    <p>オプションの扱い方や，もっと复雑な振る舞いをさせるやり方を知りたければ， <a href="http://logback.qos.ch/xref/ch/qos/logback/classic/pattern/MDCConverter.html"><code>MDCConverter</code></a>などの既存の<code>Converter</code>実装を见てみるとよいでしょう。独自の色付けをしたければ<a href="http://logback.qos.ch/xref/ch/qos/logback/classic/pattern/color/HighlightingCompositeConverter.html"><code>HighlightingCompositeConverter</code></a>を参考にするとよいでしょう。
    </p>



    <h2 class="doAnchor" name="ClassicHTMLLayout">HTMLLayout</h2>

    <p><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/html/HTMLLayout.html"><code>HTMLLayout</code></a>形式HTML形式のログを出力します（logback-classicに含まれています）。<code>HTMLLayout</code>はHTMLのテーブルを出力します。がの行がロギングイベントに対応しています。</p>

    <p>をフォルトのCSSを使った<code>HTMLLayout</code>の出力例を见てください。</p>
    <img src="images/chapters/layouts/htmlLayout0.gif" alt="HTMLレイアトトサンプル画像">

    <p>テーブルの列は変换パターン文字列で指定します。<a href="http://logback.qos.ch/manual/layouts.html#ClassicPatternLayout"><code>PatternLayout</code></a>のドキュメントに书かれた変换パターン文字列の说明を见てください。ーブルの形も内容も全て制御することができます。<code>PatternLayout</code>で使えるあらゆるコンバーターを使うことができます。
    </p>

    <p>自由に使えるとはいえ一つだけ例外的な制限があります。<code>PatternLayout</code>と<code>HTMLLayout</code>を使うときは，変换パターン文字列中で変换指定を半角スペースで区切ってはいけません。文字というと文字列リテラルを使わないようにしてください。変换パターン文字列中の変换指定はそれぞれがテーブルの列になるからです。同様に，変换指定を区切るつもりの文字列リテラルはそれぞれが列はそれぞれがいます。下手をすると，横に超长いテーブルが出力されてしまうかもしれません。</p>

    <p><code>HTMLLayout</code>の使い方を说明する设定ファイルを见てください。
    </p>

  <p class="example">例：HTMLLayoutの设定例（ <a href="http://logback.qos.ch/xref/chapters/htmlLayoutConfig1.xml">logback-examples / src / main / java / chapters / htmlLayoutConfig1.xml</a> ）</p>

<span class="asGroovy" onclick="return asGroovy('htmlLayoutConfig1');">Groovyとして表示</span>
<pre id="htmlLayoutConfig1" class="prettyprint source">&lt;configuration debug="true"&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt;
      &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"&gt;
        <b>&lt;pattern&gt;%relative%thread%mdc%level%logger%msg&lt;/pattern&gt;</b>
      &lt;/layout&gt;
    &lt;/encoder&gt;
    &lt;file&gt;test.html&lt;/file&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</pre>

   <p><a href="http://logback.qos.ch/xref/chapters/layouts/TrivialMain.html">TrivialMain</a>アプリケーションは，いくつかログを出力してから最后に例外オブジェクトを指定したログを出力します。実行してみましょう。</p>

   <p class="source">Java chapters.layouts。TrivialMain src / main / java / chapters / layouts / htmlLayoutConfig1.xml</p>

    <p>すると，カレントフォルダに<em>test.html</em>というファイルが作成されます。<em>test.html</em>をブラウザで见ると次のようになっているでしょう。</p>
    <img src="images/chapters/layouts/htmlLayout1.png" alt="HTMLレイアトトサンプル画像">

    <h3>スタックトレース</h3>

    <p>スタックトレースを出力するには<em>％ex変换指定</em>を指定します。そうすると専用の列が追加されます。ほとんどの场合スタックトレースの列は空なので，无駄に画面を専有することでしょう。さらに，スタックトレースを専用の列に出力したところで読みやすくはならないです。変，スタックトレースを出力するには， <em>％ex変换指定</em>を指定する以外の方法があります。
    </p>

    <p>よりよい解决策は，自分で<code>IThrowableRenderer</code>インターフェイスを実装することです。実装したクラスは，例外オブジェクトに关系する情报を出力するため， <code>HTMLLayout</code>に割り当てることができます。デフォルトでは， <code>HTMLLayout</code>インスタンスに<code><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/html/DefaultThrowableRenderer.html">DefaultThrowableRenderer</a></code>が割り当てられています。これは例外オブジェクトのスタックトレースを<em>新しい行</em>に出力します。前の図を见るとわかりますが多少読みやすいです。
    </p>

    <p>を理由があって<em>％ex</em>を使いたいときは，设定ファイルに<code><a href="http://logback.qos.ch/xref/ch/qos/logback/core/html/NOPThrowableRenderer.html">NOPThrowableRenderer</a></code>ます指定すればスタックトレースを别々の行に出力しないようにできます。みの望み通りに全てが上手くいくようなアイデアはありません。それでも，こうしたいという気持ちがあればきっと実现できます。
    </p>

    <h3>的CSS</h3>

    <p><code>HTMLLayout</code>で生成したHTMLの见た目はCSSで调整することができます。特别な指定がなければ， <code>HTMLLayout</code>は组み込みのCSSを使います。しかし，外部のCSSを使うようにも指定できます。そのためには， <code>layout要素</code>に<code>cssBuilder要素</code>をネストさせればよいです。
    </p>

<pre class="prettyprint source">&lt;layout class="ch.qos.logback.classic.html.HTMLLayout"&gt;
  &lt;pattern&gt;%relative...%msg&lt;/pattern&gt;
  &lt;cssBuilder class="ch.qos.logback.classic.html.UrlCssBuilder"&gt;
    &lt;!-- url where the css file is located --&gt;
    &lt;url&gt;http://...&lt;/url&gt;
  &lt;/cssBuilder&gt;
&lt;/layout&gt;</pre>


    <p><code>HTMLLayout</code>は<code>SMTPAppender</code>と组み合わせて使われることがあります。とメールの内容がHTMLで绮丽に饰られたものになります。</p>


    <h2 class="doAnchor" name="log4jXMLLayout">Log4jのXMLLayout</h2>

    <p><a href="http://logback.qos.ch/xref/ch/qos/logback/classic/log4j/XMLLayout.html">XMLLayout</a> （logback-classicに含まれています）を使うとlog4j.dtdに准拠した书式で出力できるようになります。つまり， <a href="http://logging.apache.org/chainsaw/index.html">电锯</a>や<a href="http://vigilog.sourceforge.net/">Vigilog</a>などの， <a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/XMLLayout.html">log4jのXML书式</a>を入力とするツールと相互运用できるのです。
    </p>


    <p>XMLリジナルのXMLLayoutはlog4j1.2.15で导入されたものです。logback-classicのXMLLayoutには<span class="option">locationInfo</span>と<span class="option">properties</span>という二つのプロパティが指定できます。<span class="option">locationInfo</span>プロパティにtrueパティに指定すると，ロギングイベントの位置情报（送信者情报）を含められるようになります。<span class="option">属性</span>プロパティにtrueを指定すると，MDCの情报を含められるようになります。どちらのプロパティもデフォルトは假です。
    </p>

    <p>设定例を见てみましょう。</p>

  <p class="example">例：Log4jXMLLayoutの例（ <a href="http://logback.qos.ch/xref/chapters/log4jXMLLayout.xml">logback-examples / src / main / java / chapters / log4jXMLLayout.xml</a> ）</p>

<span class="asGroovy" onclick="return asGroovy('log4jXMLLayout');">Groovyとして表示</span>
    <pre id="log4jXMLLayout" class="prettyprint source">&lt;configuration&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;file&gt;test.xml&lt;/file&gt;
    &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt;
      &lt;layout class="ch.qos.logback.classic.log4j.XMLLayout"&gt;
        &lt;locationInfo&gt;true&lt;/locationInfo&gt;
      &lt;/layout&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG"&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt; </pre>

    <h1 class="doAnchor" name="logback-access">登录访问モジュール</h1>

    <p>logback-access，以及经典的logback-モジュールのレイアウトをそのまま移植しただけです。logback-classic moジュールとlogback-accessモジュールは用途が违うのですが，だいたい同じ机能を提供しています。</p>

    <h2>レイアウトを自作する</h2>

    <p>logback-访问用の<code>レイアウト</code>を自作するのは，logback-classicの<code>レイアウト</code>を自作するのとほとんど変わりありません。</p>


    <h3 class="doAnchor" name="AccessPatternLayout">模式布局</h3>

    <p>登录后进入の<code><a href="http://logback.qos.ch/xref/ch/qos/logback/access/PatternLayout.html">PatternLayout</a></code> log，logback-classicとほとんど同じように设定することができます。HTTP，HTTPリクエストやHTTPレスポンスにしか无い，ロギングに适した情报のための変换指定が追加されています。
    </p>

    <p>登录后进入の<code>PatternLayout</code>で使える変换指定を表にまとめました。</p>

    <table class="bodyTable striped" border="0" cellpadding="8">
      <tbody><tr>
        <th align="center">変换指定</th>
        <th align="center">效果</th>
      </tr>
      <tr>
        <td class="word" name="remoteIP">
          <b>一种</b><br><b>远程IP</b>
        </td>
        <td>
          <p>リモートIPアドレス。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="localIP"><b>一种</b><br><b>本地IP</b></td>
        <td>
          <p>ローカルIPアドレス。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="bytesSent"><b>b</b><br><b>乙</b><br><b>字节已发送</b></td>
        <td>
          <p>。スポンスのコンテンツ长。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="clientHost"><b>H</b><br><b>clientHost</b></td>
        <td>
          <p>リモートホスト名。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="protocol"><b>H</b><br><b>协议</b></td>
        <td>
          <p>リクエストプロトコル。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="remoteLogName"><b>升</b></td>
        <td>
          <p>リモートログ名。logback-accessではこのではこンバーターの値は常に“-”です。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="reqParameter"><b>reqParameter {paramName}</b></td>
        <td>
          <p>リクエストパラメータ。</p>
          <p>この変换指定子は，オプションで指定されたリクエストパラメータを探します。</p>
          <p><b>％reqParameter {input_data}</b>とする，リクエストパラメーメのinput_dataの値を出力します。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="header"><b>我{header}</b><br><b>标头{header}</b></td>
        <td>
          <p>リクエストヘッダ。</p>
          <p>この変换指定子はオプションで指定されたリクエストヘッダを探します。</p>
          <p><b>％header {Referer}</b>とすると，リクエストヘッダのRefererの値を出力します。</p>
          <p>オプションを指定しなかったら，利用可能なヘッダを全て出力します。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="requestMethod"><b>米</b><br><b>requestMethod</b></td>
        <td>
          <p>リクエストメソッド。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="requestURL"><b>[R</b><br><b>requestURL</b></td>
        <td>
          <p>要求されたURL。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="statusCode"><b>s</b><br><b>statusCode</b></td>
        <td>
          <p>ドスポンスのステータスコード。</p>
        </td>
      </tr>
      <tr>
          <td class="word" name="elapsedTime"><b>d</b><br><b>经过时间</b></td>
          <td>
              <p>リクエストを处理するのにかかった时间。ミリ秒単位です。
              </p>
          </td>
      </tr>
      <tr>
        <td class="word" name="dateAccess"><b>Ť</b><br><b>日期</b></td>
        <td>
          <p>ロギングイベントの日时を出力します。オプションとして， <code>java.text.SimpleDateFormat</code>で使用できる日时パターン文字列を指定します。<em>ISO8601</em>も有效な値です。
          </p>
          <p>具体的には， <b>％t {HH：mm：ss，SSS}</b>や， <b>％t {dd MMM yyyy; HH：mm：ss，SSS}</b>などです。日时パターン文字列が指定されなかったら，共通ログ书式の日时パターン文字列である<b>T6 {dd / MMM / yyyy：HH：mm：ss Z}</b>が指定されたものとして扱います。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="httpUser"><b>ü</b><br><b>用户</b></td>
        <td>
          <p>リモートユーザー。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="requestURI"><b>ü</b><br><b>requestURI</b></td>
        <td>
          <p>要求されたURI。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="server"><b>v</b><br><b>服务器</b></td>
        <td>
          <p>サーバー名。</p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="localPort"><b>localPort</b></td>
        <td>
          <p>ローカルポート番号。</p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="reqAttribute"><b>reqAttribute {attributeName}</b></td>
        <td>
          <p>リクエストの属性。</p>
          <p>この変换指定子はオプションで指定された属性を探します。
</p>
          <p><b>％reqAttribute {SOME_ATTRIBUTE}</b>とすると，リクエスト属性SOME_ATTRIBUTEの値を出力します。</p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="reqCookie"><b>reqCookie {cookie}</b></td>
        <td>
          <p>リクエストクッキー。</p>
          <p>この変换指定子はオプションで指定されたリクエストクッキーを探します。
</p>
          <p><b>％cookie {COOKIE_NAME}</b>とすると，クッキーCOOKIE_NAMEの値を出力します。</p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="responseHeader"><b>responseHeader {header}</b></td>
        <td>
          <p>。スポンスヘッダー。
          </p>
          <p>この変换指定子はオプションで指定されたレスポンスヘッダを探します。
</p>
          <p><b>％responseHeader {Server}</b>とすると，レスポンスヘッダServerの値を出力します。</p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="requestContent"><b>requestContent</b></td>
        <td>
          <p>この変换指定はリクエストの中身，つまり，リクエストのの<code>InputStream</code>を出力します。実际は， <code><a href="http://logback.qos.ch/xref/ch/qos/logback/access/servlet/TeeFilter.html">TeeFilter</a></code>によって元の<code>HttpServletRequest</code>を<code>TeeHttpServletRequest</code>に置き换えます。だから，データを失わずに何度でもリクエストのの<code>InputStream</code>にアクセスできるのです。
          </p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="fullRequest"><b>fullRequest</b></td>
        <td>
          <p>リクエストに关连するヘッダ，コンテンツを全て出力します。
          </p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="responseContent"><b>responseContent</b></td>
        <td>
          <p>レスポンスの中身，つまり，レsポンスの<code>InputStream</code>を出力します。実际は， <code>TeeFilter</code>によって元の<code>HttpServletResponse</code>を<code>TeeHttpServletResponse</code>に置き换えます。だから，データを失わずに何度でもレスポンスの<code>InputStream</code>にアクセスできるのです。
          </p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="fullResponse"><b>fullResponse</b></td>
        <td>
          <p>レスポンスに关连するヘッダ，コンテンツを全て出力します。
          </p>
        </td>
      </tr>
    </tbody></table>

    <p>登录后进入の<code>PatternLayout</code>ではさらに3つのキーワードが利用できます。これはいわゆるショートカットです。</p>

    <table class="bodyTable">
      <tbody><tr>
        <th>キーワード</th>
        <th>等価な変换パターン文字列</th>
      </tr>
      <tr class="a">
        <td><em>普通</em> <em>CLF</em></td>
        <td><em>％h％l％u [％t]“％r”％s％b</em></td>
      </tr>
      <tr class="b">
        <td><em>合并的</em></td>
        <td><em>％h％l％u [％t]“％r”％s％b“％i {Referer}”“％i {User-Agent}”</em></td>
      </tr>

    </tbody></table>


    <p>％ーワード<em>common</em>は変换文字列パターン<em>'％h％l％u [％t]“％r”％s％b'</em>と同じ意味になります。先头顺顺番に，クライアントホスト，リモートログ名，ユーザー名，日时，リクエストURL，ステータスコード，レスポンスのコンテンツ长が出力されます。</p>

    <p>％ーワード<em>组合</em> bin换文字列パターン<em>'％h％l％u [％t]“％r”％s％b“％i {Referer}”“％i {User-Agent}”'</em>のショートカットです。先头は<em>common</em>キーワードードの変换パターン文字列とほとんど代わりませんが，推荐人，用户代理というリクエストヘッダが追加されているのが违います。</p>

    <h3 class="doAnchor" name="AccessHTMLLayout">HTMLLayout</h3>

    <p>logback-accessモジュールの<a href="http://logback.qos.ch/xref/ch/qos/logback/access/html/HTMLLayout.html"><code>HTMLLayout</code></a> log，logback-classicモジュールの<a href="http://logback.qos.ch/manual/layouts.html#ClassicHTMLLayout"><code>HTMLLayout</code></a>とほとんど変わりません。
    </p>

    <p>デフォルトでは次の项目を含む表を作ります。</p>

    <ul>
      <li>リモートIP</li>
      <li>日付</li>
      <li>リクエストURL</li>
      <li>レスポンスのステータスコード</li>
      <li>コンテンツ长</li>
    </ul>

    <p>对数访问の<code>HTMLLayout</code>による出力例を见てください。</p>
    <img src="images/chapters/layouts/htmlLayoutAccess.gif" alt="アクセスHTMLレイアウトサンプル画像">

    <p>実际に使うと上でもっと良くするにはどうしたらいいでしょうか？log4j.properties用于logback <a href="http://logback.qos.ch/translator/">翻译器</a>は，logback-accessの<code>RollingFileAppender</code>と<code>HTMLLayout</code>を使ってリアルタイム出力をするようになっています。</p>


    <p>Webアプリケーションの<a href="http://logback.qos.ch/translator/">翻译者</a>に対するユーザーからのリクエストに対して，都度新しいアクセスログが出力されます。<a href="http://logback.qos.ch/translator/logs/access.html">このリンク先</a>でそれを见ることが出来ます。</p>


    <script src="../templates/footer.js" type="text/javascript"></script>
</div>

</body></html>