<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第三章：配置</title>
    
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">

  </head>
  <body  onload="prettyPrint(); decorate();">

    <script type="text/javascript">prefix='../'</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content" class="chapter">
      
    <h1>第3章：Logback配置</h1>

    <a href="configuration_ja.html">和訳（日语翻译）</a>

      
    <div class="quote">
      <p><em>在符号中，人们发现发现的优势是最大的，因为当他们简短地表达事物的确切性质并照原样描绘事物时，这是最大的。那么实际上思想的工作就大大减少了。</em>
      </p>
      <p>—盖特里·威廉·莱伯尼兹</p>
    </div>


    <script src="../templates/creative.js" type="text/javascript"></script>


    <p>我们首先通过许多示例配置脚本介绍用于配置登录的方法。Joran，基于Logback的配置框架将在<a href="onJoran.html">下一章中介绍</a> 。
    </p>


    <h2 class="doAnchor" name="auto_configuration">登录中的配置</h2>
    
    <p>将日志请求插入应用程序代码需要大量的计划和工作。观察表明，大约百分之四的代码专用于日志记录。因此，即使是中等大小的应用程序也将在其代码中包含数千个日志记录语句。给定它们的数量，我们需要工具来管理这些日志语句。
    </p>

    <p>可以通过编程或使用以XML或Groovy格式表示的配置脚本来配置Logback。顺便说一句，现有的log4j用户可以使用我们的<a href="http://logback.qos.ch/translator/">PropertiesTranslator</a> Web应用程序将其<em>log4j.properties</em>文件转换为<em>logback.xml</em> 。
    </p>

    <p>让我们开始讨论登录后尝试进行自我配置的初始化步骤：</p>

    <ol>

      <li>
        <p>Logback尝试<a href="../faq.html#configFileLocation">在类路径中</a>找到一个名为<em>logback-test.xml</em>的文件。</p> </li>

      <li>
        <p>如果找不到这样的文件，则logback尝试<a href="../faq.html#configFileLocation">在classpath中</a>找到一个名为<em>logback.groovy</em>的文件。</p>
      </li>


      <li><p>如果找不到这样的文件，它将<a href="../faq.html#configFileLocation">在类路径</a> ..中检查文件<em>logback.xml</em> 。</p>
      </li>
      
      <li><p>如果找不到这样的文件，则使用<a href="http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html">服务提供者加载工具</a> （在JDK 1.6中引入）来解决以下问题的实现： <a href="../xref/ch/qos/logback/classic/spi/Configurator.html"><code>com.qos.logback.classic.spi.Configurator</code></a>通过查找文件<em>META-INF \ services \ ch.qos.logback.classic.spi界面。类路径中的配置器</em> 。其内容应指定所需的全限定类名<code>Configurator</code>实施。
      </p>
      </li>
      
      <li><p>如果以上方法均未成功，则logback会使用<a href="../xref/ch/qos/logback/classic/BasicConfigurator.html"><code>BasicConfigurator</code></a>这将导致日志记录输出定向到控制台。
      </p> 
      </li> 

    </ol>

    <p>最后一步是在没有配置文件的情况下提供默认（但非常基本）的日志记录功能的最后努力。
    </p>


    <p>如果您使用的是Maven，并且将<em>logback-test.xml</em>放在<em>src / test / resources</em>文件夹下，则Maven将确保它不会包含在生成的工件中。因此，您可以在测试期间使用其他配置文件，即<em>logback-test.xml</em> ，在生产环境中使用另一个文件，即<em>logback.xml</em> 。
    </p>

    <p><span class="label">快速启动</span> Joran解析给定的logback配置文件大约需要100毫秒。要减少启动应用程序时的时间，可以使用服务提供者加载工具（上面的项目4）加载自己的自定义<code>Configurator</code> <a href="../xref/ch/qos/logback/classic/BasicConfigurator.html">BasicConfigrator</a>类作为一个很好的起点。</p>


    <h3 class="doAnchor" name="automaticConf">自动配置登录</h3>

    <p>配置logback的最简单方法是让logback退回到其默认配置。让我们来看看如何在一个名为<code>MyApp1</code> 。
    </p>

    <p class="example">示例： <code>BasicConfigurator</code>用法<a href="../xref/chapters/configuration/MyApp1.html">（logback-examples / src / main / java / chapters / configuration / MyApp1.java）</a></p>

    <pre class="prettyprint source">package chapters.configuration;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyApp1 {
  final static Logger logger = LoggerFactory.getLogger(MyApp1.class);

  public static void main(String[] args) {
    logger.info("Entering application.");

    Foo foo = new Foo();
    foo.doIt();
    logger.info("Exiting application.");
  }
}</pre>

  <p>此类定义了静态记录器变量。然后实例化一个<code>Foo</code>宾语。的<code>Foo</code>该类如下所示：</p>

  <p class="example">示例：小型类进行日志记录<a href="../xref/chapters/configuration/Foo.html">（logback-examples / src / main / java / chapters / configuration / Foo.java）</a>
  </p>

  <pre class="prettyprint source">package chapters.configuration;
  
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
   
public class Foo {
  static final Logger logger = LoggerFactory.getLogger(Foo.class);
  
  public void doIt() {
    logger.debug("Did it again!");
  }
}</pre>


    <p>为了运行本章中的示例，您需要确保在类路径中存在某些jar文件。请参阅<a href="../setup.html">设置页面</a>以获取更多详细信息。
    </p>

    <p>假设配置文件<em>logback-test.xml</em>或<em>logback.xml</em>不存在，则logback将默认为调用<a href="../xref/ch/qos/logback/classic/BasicConfigurator.html"><code>BasicConfigurator</code></a>这将设置一个最小的配置。此最低配置包括<code>ConsoleAppender</code>附加到根记录器。使用以下命令格式化输出<code>PatternLayoutEncoder</code>设置为模式<em>％d {HH：mm：ss。SSS} [％thread]％-5level％logger {36}-％msg％n</em> 。此外，默认情况下，为根记录程序分配了<code>DEBUG</code>水平。
    </p>

    <p>因此，该命令的输出为<em>java chapters.configuration。MyApp1</em>应该类似于：</p>

    <p class="source">16：06：09.031 [main] INFO章节。配置。MyApp1-输入应用程序。16：06：09.046 [main] DEBUG章节。配置。Foo-再来一次！16：06：09.046 [main] INFO章节。配置。MyApp1-退出应用程序。</p>


   <p class="highlight">除了用于配置回送的代码（如果存在此类代码），客户端代码不需要依赖于回送。使用logback作为其日志记录框架的应用程序将对SLF4J具有编译时依赖性，但对logback没有依赖性。
   </p>

   <p>的<code>MyApp1</code>应用程序通过调用链接到logback <code>org.slf4j.LoggerFactory</code>和<code>org.slf4j.Logger</code>类，检索它希望使用的记录器，然后进行切换。请注意， <code>Foo</code>登录时的类均通过<code>org.slf4j.LoggerFactory</code>和<code>org.slf4j.Logger</code>进口。除了用于配置回送的代码（如果存在此类代码），客户端代码不需要依赖于回送。由于SLF4J允许在其抽象层下使用任何日志记录框架，因此很容易将大量代码从一个日志记录框架迁移到另一个日志记录框架。
   </p>

   <h3>使用<em>logback-test.xml</em>或<em>logback.xml</em>自动配置</h3>

   <p>如前所述，如果在类路径上找到<em>logback-test.xml</em>或<em>logback.xml</em>文件，则logback会尝试自行配置。这是一个等效于配置文件的配置文件<code>BasicConfigurator</code>我们刚刚看到。
   </p>

   <p class="example">示例：基本配置文件（logback-examples / src / main / resources / chapters / configuration / sample0.xml）</p>
   <span class="asGroovy" onclick="return asGroovy('sample0');">观看为.groovy</span>


  <pre id="sample0" class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

   <p>将<em>sample0.xml</em>重命名为<em>logback.xml</em> （或<em>logback-test.xml</em> ）后，将其放入可从类路径访问的目录中。运行<em>MyApp1</em>应用程序应获得与其先前运行相同的结果。</p>

   <h4 class="doAnchor" name="automaticStatusPrinting">在出现警告或错误的情况下自动打印状态消息</h4>

   <p class="highlight">如果在配置文件解析期间出现警告或错误，则logback将自动在控制台上打印其内部状态消息。</p>
 
   <p>如果在解析配置文件期间发生警告或错误，则logback将自动在控制台上打印其内部状态数据。请注意，为避免重复，如果用户明确注册状态侦听器（定义如下），则会禁用自动状态打印。</p>

   <p>在没有警告或错误的情况下，如果您仍然希望检查logback的内部状态，则可以通过调用以下命令指示logback打印状态数据： <code>print()</code>的<code>StatusPrinter</code>类。下面示出的<em>MyApp2</em>应用是除了增加的两行代码打印内部状态数据相同<em>MyApp1。</em></p>

    <p class="example">示例：打印回传的内部状态信息<a href="../xref/chapters/configuration/MyApp2.html">（logback-examples / src / main / java / chapters / configuration / MyApp2.java）</a></p>

  
<pre class="prettyprint lang-java source">
public static void main(String[] args) {
  // assume SLF4J is bound to logback in the current environment
  <b>LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
  // print logback's internal status
  <b>StatusPrinter.print(lc);</b>
  ...
}</pre>

  <p>如果一切顺利，您应该在控制台上看到以下输出</p>

   <div class="source longline"><pre>17:44:58,578 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback-test.xml]
17:44:58,671 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - debug attribute not set
17:44:58,671 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.ConsoleAppender]
17:44:58,687 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [STDOUT]
17:44:58,812 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Popping appender named [STDOUT] from the object stack
17:44:58,812 |-INFO in ch.qos.logback.classic.joran.action.LevelAction - root level set to DEBUG
17:44:58,812 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [STDOUT] to Logger[root]

17:44:58.828 [main] INFO  chapters.configuration.MyApp2 - Entering application.
17:44:58.828 [main] DEBUG chapters.configuration.Foo - Did it again!
17:44:58.828 [main] INFO  chapters.configuration.MyApp2 - Exiting application.
</pre></div>

  <p>在此输出的结尾，您可以识别上一个示例中打印的行。您还应该注意到logback的内部消息，也就是<code>Status</code>对象，可以方便地访问logback的内部状态。
  </p>

   <h4 class="doAnchor" name="dumpingStatusData">状态数据</h4>

   <p class="highlight">在诊断回送问题时，通常启用状态数据输出会走很长一段路。因此，强烈建议您将其视为<b>首选</b>手段。</p>

   <p>而不是调用<code>StatusPrinter</code>通过代码以编程方式，即使没有错误，也可以指示配置文件转储状态数据。为此，您需要设置<em>配置</em>元素的<span class="attr">调试</span>属性，即配置文件中最顶层的元素，如下所示。请注意，此<span class="attr">调试</span>属性仅与状态数据有关。它<em>不</em>影响的logback的配置，否则，特别是相对于记录器级别。（如果您询问，否， <em>则不</em>会将root logger设置为<code>DEBUG</code> ）
   </p>

   <p class="example">示例：使用调试模式的基本配置文件（logback-examples / src / main / resources / chapters / configuration / sample1.xml）</p>
   <span class="asGroovy" onclick="return asGroovy('sample1');">观看为.groovy</span>

   <pre id="sample1" class="prettyprint source">
&lt;configuration <span class="big bold">debug="true"</span>> 

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"> 
    &lt;!-- encoders are  by default assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder -->
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>
  
   <p>设置<code>debug="true"</code> <configuration>假定以下条件，</configuration>则<configuration>元素</configuration>内的<configuration>元素将输出状态信息：</configuration></p>
   <ol>
     <li>找到配置文件</li>
     <li>配置文件是格式正确的XML。</li>
   </ol>
     
   <p>如果不满足这两个条件中的任何一个，Joran将无法解释<span class="attr">调试</span>属性，因为无法读取配置文件。如果找到了配置文件，但格式错误，则logback将检测到错误情况，并在控制台上自动打印其内部状态。但是，如果找不到配置文件，则logback不会自动打印其状态数据，因为这不一定是错误情况。以编程方式调用<code>StatusPrinter.print()</code>如上面<a href="../xref/chapters/configuration/MyApp2.html"><em>MyApp2</em></a>应用程序中所示，可以确保在每种情况下都可以打印状态信息。</p>

 
 
   <p><span class="label">强制状态输出</span>在没有状态消息的情况下，很难追踪到流氓<em>logback.xml</em>配置文件，尤其是在无法轻松修改应用程序源的生产环境中。为了帮助识别恶意配置文件的位置，您可以设置一个<code>StatusListener</code>通过“ logback.statusListenerClass”系统属性（ <a href="#logback.statusLC">定义如下</a> ）强制输出状态消息。系统属性“ logback.statusListenerClass”也可以用于使出现错误时自动生成的输出静音。
   </p>

   <p>顺便说一句<code>debug="true"</code>严格等同于安装<code>OnConsoleStatusListener</code> 。状态侦听器将在下面进一步讨论。安装<code>OnConsoleStatusListener</code>如下所示。</p>

   <p class="example">示例：注册状态侦听器（logback-examples / src / main / resources / chapters / configuration / onConsoleStatusListener.xml）</p>
   <span class="asGroovy" onclick="return asGroovy('onConsoleStatusListener');">观看为.groovy</span>
   <pre id="onConsoleStatusListener" class="prettyprint source">&lt;configuration>
  <b>&lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /></b>  

  ... the rest of the configuration file  
&lt;/configuration></pre>


   <p>通过debug属性或等效地通过安装启用状态数据输出<code>OnConsoleStatusListener</code> ，将在帮助您诊断登录问题方面大有帮助。因此，强烈建议启用登录状态数据，并且应将其视为<b>首选方法</b> 。
   </p>

   <h3 class="doAnchor" name="configFileProperty">将默认配置文件的位置指定为系统属性</h3>

   <p>您可以使用名为的系统属性指定默认配置文件的位置。 <code>"logback.configurationFile"</code> 。该属性的值可以是URL，类路径上的资源或应用程序外部文件的路径。
   </p>

   <p class="source">java <b>-Dlogback.configurationFile = / path / to / config.xml</b>章节配置。MyApp1</p>

   <p>请注意，文件扩展名必须为“ .xml”或“ .groovy”。其他扩展名将被忽略。<a href="#logback.statusLC">明确注册状态侦听器</a>可能有助于调试查找配置文件的问题。</p>

   <p>鉴于<code>"logback.configurationFile"</code>是Java系统属性，也可以在您的应用程序中设置它。但是，必须在创建任何记录器实例之前设置系统属性。</p>

   <pre class="prettyprint lang-java source">import ch.qos.logback.classic.util.ContextInitializer;

public class ServerMain {
    public static void main(String args[]) throws IOException, InterruptedException {
       // must be set before the first call to  LoggerFactory.getLogger();
       // ContextInitializer.CONFIG_FILE_PROPERTY is set to "logback.configurationFile"
       System.setProperty(ContextInitializer.CONFIG_FILE_PROPERTY, "/path/to/config.xml");
       ...
    }   
}</pre>
   
   <h3 class="doAnchor" name="autoScan">修改后自动重新加载配置文件</h3>

   <p class="highlight">经典的Logback可以扫描其配置文件中的更改，并在配置文件更改时自动重新配置自身。</p>

   <p>如果指示这样做，logback-classic将扫描其配置文件中的更改，并在配置文件更改时自动重新配置自身。为了指示的logback经典扫描在其配置文件，并自动更改重新配置自身设置的<span class="attr">扫描</span>属性<code><configuration></code>元素设置为true，如下所示。

   </p>
  
   <p class="example">示例：扫描配置文件中的更改并自动重新配置（logback-examples / src / main / resources / chapters / configuration / scan1.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('scan1');">观看为.groovy</span>
<pre id="scan1" class="prettyprint source">
&lt;configuration <b>scan="true"</b>> 
  ... 
&lt;/configuration> </pre>


   <p>默认情况下，每分钟扫描一次配置文件是否有更改。您可以通过设置以下文件的<span class="attr">scanPeriod</span>属性来指定其他扫描周期<code><configuration></code>元件。可以以毫秒，秒，分钟或小时为单位指定值。这是一个例子：</p>

  <p class="example">示例：指定不同的扫描周期（logback-examples / src / main / resources / chapters / configuration / scan2.xml）</p>
  <span class="asGroovy" onclick="return asGroovy('scan2');">观看为.groovy</span>
  <pre id="scan2" class="prettyprint source">
&lt;configuration scan="true" <b>scanPeriod="30 seconds"</b> > 
  ...
&lt;/configuration> </pre>

   <p><span class="label">注意</span>如果未指定时间单位，则将时间单位假定为毫秒，这通常是不合适的。如果更改默认扫描周期，请不要忘记指定时间单位。
   </p>

   <p>在后台，当您将<span class="option">scan</span>属性设置为<code>true</code> ， 一种<a href="../xref/ch/qos/logback/classic/joran/ReconfigureOnChangeTask.html"><code>ReconfigureOnChangeTask</code></a>将会被安装。该任务在单独的线程中运行，将检查您的配置文件是否已更改。 <code>ReconfigureOnChangeTask</code>也会自动监视所有<a href="#fileInclusion">包含的</a>文件。</p>

   <p>由于在编辑配置文件时很容易出错，因此如果最新版本的配置文件具有XML语法错误，则它将退回到没有XML语法错误的先前配置文件。</p>


   
   <h4 class="doAnchor" name="packagingData">在堆栈跟踪中启用打包数据</h4>

   <p class="highlight">打包数据虽然有用，但计算起来却很昂贵，尤其是在经常出现异常的应用程序中。</p>

   <p><span class="label notice">注意</span>从版本1.1.4开始，包装数据默认为禁用。</p>

   <p>如果指示这样做，则logback可以包含其输出的堆栈跟踪行的每一行的打包数据。打包数据由jar文件的名称和版本组成，而堆栈跟踪行的源于此。打包数据对于识别软件版本控制问题非常有用。但是，计算起来相当昂贵，尤其是在经常引发异常的应用程序中。这是一个示例输出：</p>

   <pre>14:28:48.835 [btpool0-7] INFO  c.q.l.demo.prime.PrimeAction - 99 is not a valid value
java.lang.Exception: 99 is invalid
  at ch.qos.logback.demo.prime.PrimeAction.execute(PrimeAction.java:28) [classes/:na]
  at org.apache.struts.action.RequestProcessor.processActionPerform(RequestProcessor.java:431) <b>[struts-1.2.9.jar:1.2.9]</b>
  at org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:236) [struts-1.2.9.jar:1.2.9]
  at org.apache.struts.action.ActionServlet.doPost(ActionServlet.java:432) [struts-1.2.9.jar:1.2.9]
  at javax.servlet.http.HttpServlet.service(HttpServlet.java:820) <b>[servlet-api-2.5-6.1.12.jar:6.1.12]</b>
  at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:502) [jetty-6.1.12.jar:6.1.12]
  at ch.qos.logback.demo.UserServletFilter.doFilter(UserServletFilter.java:44) [classes/:na]
  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115) <b>[jetty-6.1.12.jar:6.1.12]</b>
  at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:361) [jetty-6.1.12.jar:6.1.12]
  at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:417) [jetty-6.1.12.jar:6.1.12]
  at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230) [jetty-6.1.12.jar:6.1.12]</pre>


  <p>打包数据默认情况下处于禁用状态，但可以通过配置启用：</p>

<pre class="prettyprint source">
&lt;configuration <span class="big bold">packagingData="true"</span>>
  ...
&lt;/configuration></pre>

   <p>或者，可以通过调用以下程序中的<a href="../apidocs/ch/qos/logback/classic/LoggerContext.html#setPackagingDataEnabled(boolean)">setPackagingDataEnabled（boolean）</a>方法以编程方式启用/禁用打包数据： <code>LoggerContext</code> ，如下所示：</p>


<pre class="prettyprint lang-java source">
  LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
  <b>lc.setPackagingDataEnabled(true);</b>
</pre>

   <h3 class="doAnchor" name="joranDirectly">调用中<code>JoranConfigurator</code>直</h3>

   <p>Logback依赖于一个名为Joran的配置库，它是logback-core的一部分。Logback的默认配置机制调用<code>JoranConfigurator</code>在默认配置文件中找到的类路径。如果出于任何原因希望覆盖logback的默认配置机制，可以通过调用<code>JoranConfigurator</code>直。的下一个应用<em>，MyApp3，</em>调用上作为参数传递的配置文件JoranConfigurator。</p>
   
   <p class="example">示例：调用<code>JoranConfigurator</code>直接<a href="../xref/chapters/configuration/MyApp3.html">（logback-examples / src / main / java / chapters / configuration / MyApp3.java）</a></p>

<pre class="prettyprint source">package chapters.configuration;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class MyApp3 {
  final static Logger logger = LoggerFactory.getLogger(MyApp3.class);

  public static void main(String[] args) {
    // assume SLF4J is bound to logback in the current environment
    <b>LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
    
    <b>try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(context);
      // Call context.reset() to clear any previous configuration, e.g. default 
      // configuration. For multi-step configuration, omit calling context.reset().
      context.reset(); 
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
      // StatusPrinter will handle this
    }
    StatusPrinter.printInCaseOfErrorsOrWarnings(context);</b>

    logger.info("Entering application.");

    Foo foo = new Foo();
    foo.doIt();
    logger.info("Exiting application.");
  }
}</pre>

   <p>此应用程序获取<code>LoggerContext</code>当前有效，创建一个新的<code>JoranConfigurator</code> ，设置将在其上运行的上下文，重置记录器上下文，然后最终要求配置器使用作为参数传递给应用程序的配置文件来配置上下文。如果出现警告或错误，将打印内部状态数据。请注意，对于多步配置， <code>context.reset()</code>调用应省略。</p>

   <h3 class="doAnchor" name="viewingStatusMessages">查看状态消息</h3>

   <p>Logback将其内部状态数据收集到<code><a href="../xref/ch/qos/logback/core/status/StatusManager.html">StatusManager</a></code>对象，可通过<code>LoggerContext</code> 。
   </p>

   <p>给定一个<code>StatusManager</code>您可以访问与注销上下文关联的所有状态数据。为了将内存使用率保持在合理水平，默认<code>StatusManager</code>实现将状态消息存储在两个单独的部分中：标头部分和尾部部分。标题部分存储前<em>H个</em>状态消息，而尾部存储最后<em>T个</em>消息。目前， <em>H</em> = <em>T</em> = 150，尽管这些值在将来的版本中可能会更改。</p>

   <p>经典的Logback附带了一个称为ViewStatusMessagesServlet的servlet。该servlet打印出<code>StatusManager</code>与当前相关<code>LoggerContext</code>作为HTML表格。这是示例输出。
   </p>
   
   <a href="images/chapters/configuration/lbClassicStatus.jpg">
     <img src="images/chapters/configuration/lbClassicStatus.jpg" alt="点击放大" width="90%">
   </a>

   <p>要将此servlet添加到您的Web应用程序，请将以下行添加到其<em>WEB-INF / web.xml</em>文件。</p>

   <pre class="prettyprint source">  &lt;servlet>
    &lt;servlet-name>ViewStatusMessages&lt;/servlet-name>
    &lt;servlet-class>ch.qos.logback.classic.ViewStatusMessagesServlet&lt;/servlet-class>
  &lt;/servlet>

  &lt;servlet-mapping>
    &lt;servlet-name>ViewStatusMessages&lt;/servlet-name>
    &lt;url-pattern>/lbClassicStatus&lt;/url-pattern>
  &lt;/servlet-mapping></pre>
   
   <p>的<code>ViewStatusMessages</code>可以在URL上查看servlet <code>http://host/yourWebapp/lbClassicStatus</code>
   </p>

   <h3 class="doAnchor" name="statusListener">收听状态消息</h3>

   <p>您也可以附加一个<code>StatusListener</code>到一个<code>StatusManager</code>这样您就可以立即采取措施来响应状态消息，尤其是对配置logback之后发生的消息。注册状态侦听器是一种方便的方法来监视回发的内部状态，而无需人工干预。
   </p>

   <p>Logback附带一个<code>StatusListener</code>实现称为<code><a href="../xref/ch/qos/logback/core/status/OnConsoleStatusListener.html">OnConsoleStatusListener</a></code>顾名思义，它将在控制台上打印所有<em>新的</em>传入状态消息。
   </p>

   <p>这是注册一个<a href="../xref/chapters/configuration/AddStatusListenerApp.html">示例代码</a> <code>OnConsoleStatusListener</code> StatusManager实例。
   </p>

   <pre class="prettyprint source">   LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory(); 
   StatusManager statusManager = lc.getStatusManager();
   OnConsoleStatusListener onConsoleListener = new OnConsoleStatusListener();
   statusManager.add(onConsoleListener);</pre>

   <p>请注意，注册的状态侦听器将仅在注册之后接收状态事件。它不会收到以前的消息。因此，通常最好将状态侦听器注册指令放在配置文件的顶部，然后再放置其他指令。</p>

   <p>也可以在配置文件中注册一个或多个状态侦听器。这是一个例子。</p>

   <p class="example">示例：注册状态侦听器（logback-examples / src / main / resources / chapters / configuration / onConsoleStatusListener.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('onConsoleStatusListener');">观看为.groovy</span>
   <pre id="onConsoleStatusListener" class="prettyprint source">&lt;configuration>
  <b>&lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /></b>  

  ... the rest of the configuration file  
&lt;/configuration></pre>

   <h3 class="doAnchor" name="logback.statusLC">“ logback.statusListenerClass”系统属性</h3>

   <p>也可以通过将Java系统属性“ logback.statusListenerClass”设置为您希望注册的侦听器类的名称来注册状态侦听器。例如，</p>

   <p class="source">java <b>-Dlogback.statusListenerClass</b> = ch.qos.logback.core.status。OnConsoleStatusListener ...</p>
   
   <p>Logback附带了几种状态侦听器实现。<a href="../xref/ch/qos/logback/core/status/OnConsoleStatusListener.html">OnConsoleStatusListener</a>在控制台上（即在System.out上）打印传入的状态消息。<a href="../xref/ch/qos/logback/core/status/OnErrorConsoleStatusListener.html">OnErrorConsoleStatusListener</a>在System.err上打印传入的状态消息。<a href="../xref/ch/qos/logback/core/status/NopStatusListener.html">NopStatusListener</a>丢弃传入的状态消息。</p>
   

   <p>请注意，如果在配置过程中注册了任何状态侦听器，特别是如果用户通过“ logback.statusListenerClass”系统指定了状态侦听器，则将禁用<a href="#automaticStatusPrinting">自动状态打印</a> （如果发生错误）。因此，通过设置<code>NopStatusListener</code>作为状态侦听器，您可以完全使内部状态打印静音。</p>
   
   <p class="source">java <b>-Dlogback.statusListenerClass</b> = ch.qos.logback.core.status。NopStatusListener ...</p>


   <h2 class="doAnchor" name="stopContext">停止经典的logback</h2>

   <p>为了释放经典的logback使用的资源，停止logback上下文总是一个好主意。停止上下文将关闭所有附加到该上下文定义的记录器的附加程序，并以有序的方式停止所有活动线程。另请阅读下面的“关机钩”部分。</p>

<pre class="prettyprint lang-java source">
import org.sflf4j.LoggerFactory;
import ch.qos.logback.classic.LoggerContext;
...

// assume SLF4J is bound to logback-classic in the current environment
<b>LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();</b>
<b>loggerContext.stop();</b></pre>

   <p>在Web应用程序中，可以从以下代码的<a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletContextListener.html#contextDestroyed(javax.servlet.ServletContextEvent)">contextDestroyed</a>方法中调用以上代码： <code>ServletContextListener</code>为了停止经典的logback并释放资源。从版本1.1.10开始，适当的<code>ServletContextListener</code>为您自动安装（ <a href="#webShutdownHook">请参阅下面的内容</a> ）。
   </p>

   <h4 class="doAnchor" name="shutdownHook">通过关闭挂钩停止经典的logback</h4>
   
   <p>安装JVM关机钩子是关闭登录和释放关联资源的便捷方法。
   </p>


   <pre class="prettyprint source">&lt;configuration debug="true">
   &lt;!-- in the absence of the class attribute, assume 
   ch.qos.logback.core.hook.DefaultShutdownHook --&gt;
   <b>&lt;shutdownHook/></b>
  .... 
&lt;/configuration></pre>

   <p>请注意，您可以通过将<span class="attr">class</span>属性设置为与您的关机钩子的类名相对应来安装自己的关机钩子。</p>
  
   <p>默认的关闭挂钩，即<a href="../apidocs/ch/qos/logback/core/hook/DefaultShutdownHook.html">DefaultShutdownHook</a> ，将在指定的延迟（默认为0）后<b>停止</b>登录上下文。停止上下文将使在后台运行的任何日志文件压缩任务最多需要30秒才能完成。在独立的Java应用程序中，添加一个<code><shutdownHook/></code>配置文件中的伪指令是确保JVM退出之前允许任何正在进行的压缩任务完成的简便方法。在Web服务器中的应用程序中，将自动安装<a href="#webShutdownHook">webShutdownHook</a> <code><shutdownHook/></code>指令相当多余和不必要。</p>


 
    <h4 class="doAnchor" name="webShutdownHook">WebShutdown在Web应用程序中挂接或停止经典的logback</h4>
  
   <p><span class="label">自1.1.10</span>起，经典的Logback-class将<b>自动</b>要求网络服务器安装一个<code><a href="../apidocs/ch/qos/logback/classic/servlet/LogbackServletContainerInitializer.html">LogbackServletContainerInitializer</a></code>实施<code>ServletContainerInitializer</code>接口（在servlet-api 3.x和更高版本中可用）。该初始化程序将依次安装和<code><a href="../apidocs/ch/qos/logback/classic/servlet/LogbackServletContextListener.html">LogbackServletContextListener</a></code> 。当Web应用程序停止或重新加载时，此侦听器将停止当前的logback-classic上下文。
   </p>

   <p>您可以禁用自动安装<code>LogbackServletContextListener</code>通过设置一个<context-param>命名<code>logbackDisableServletContainerInitializer</code>在您的Web应用程序的web.xml文件中。这是相关的代码段。</context-param></p>

   
<pre class="prettyprint source">&lt;web-app>
    &lt;context-param>
        &lt;param-name>logbackDisableServletContainerInitializer&lt;/param-name>
        &lt;param-value>true&lt;/param-value>
    &lt;/context-param>
    .... 
&lt;/web-app></pre>

    <p>注意<code>logbackDisableServletContainerInitializer</code>变量也可以设置为OS环境变量的Java系统属性。最本地的设置具有优先权，即首先是Web应用程序，其次是系统属性，最后是OS环境。</p>

   

   <!-- =================================================================== -->
   <!-- =================================================================== -->

   <h2 class="doAnchor" name="syntax">配置文件语法</h2>

   <p>到目前为止，您已经在手册中看到了很多示例，但logback允许您重新定义日志记录行为，而无需重新编译代码。确实，您可以轻松配置登录回显，以便为应用程序的某些部分禁用日志记录，或者将输出定向到UNIX Syslog守护程序，数据库，日志可视化器，或者将日志记录事件转发到远程登录日志服务器，后者将进行日志记录根据本地服务器策略，例如通过将日志事件转发到第二个Logback服务器。
   </p>
	
   <p>本节的其余部分介绍配置文件的语法。
   </p>

   <p>正如将一再说明的那样，logback配置文件的语法非常灵活。因此，不可能用DTD文件或XML模式指定允许的语法。尽管如此，配置文件的最基本结构可以描述为： <code><configuration></code>元素，包含零个或多个<code><appender></code>元素，后跟零个或多个<code><logger></code>元素，然后最多是一个<code><root></code>元件。下图说明了此基本结构。</p>

  
  <p align="left">
    <img src="images/chapters/configuration/basicSyntax.png" alt="基本语法" title="基本配置文件结构">
  </p>


    <p class="highlight">如果不确定给定标签名使用哪种情况，只需遵循<a href="http://en.wikipedia.org/wiki/CamelCase">camelCase约定</a> ，几乎总是正确的约定。</p>

    <h4 class="doAnchor" name="caseSensitivity">标签名称区分大小写</h4>
   
    <p>从Logback版本0.9.17开始，与显式规则有关的标记名称不区分大小写。例如， <code><logger></code> ， <code><Logger></code>和<code><LOGGER></code>是有效的配置元素，将以相同的方式解释。请注意，如果您按以下方式打开标签，则XML格式规则仍然适用<code><xyz></code>您必须将其关闭为<code></xyz></code> ， <code></XyZ></code>不管用。对于<a href="onJoran.html#implicit">隐式规则</a> ，标签名称区分大小写，但首字母除外。从而， <code><xyz></code>和<code><Xyz></code>是等效的，但不是<code><xYz></code> 。隐式规则通常遵循Java世界中常见的<a href="http://en.wikipedia.org/wiki/CamelCase">camelCase</a>约定。由于很难区分标记何时与显式动作相关联以及标记与隐式动作相关联，因此很难说XML标记相对于第一个字母区分大小写还是不区分大小写。如果不确定给定标签名使用哪种情况，只需遵循camelCase约定，几乎总是正确的约定。
    </p>

    <h4 class="doAnchor" name="loggerElement">配置记录器，或者<code><logger></code>元件</h4>

    <p>在这一点上，您应该至少对<a href="architecture.html#effectiveLevel">级别继承</a>和<a href="architecture.html#basic_selection">基本选择规则</a>有所了解。否则，除非您是埃及专家，否则登录配置对您而言不会比象形文字有意义。
    </p>

    <p>使用以下命令配置记录器<code><logger></code>元件。一种<code><logger></code>元素仅接受一个必填<span class="attr">名称</span>属性，一个可选的<span class="attr">level</span>属性和一个可选的可<span class="attr">加性</span>属性，并接受值<em>true</em>或<em>false</em> 。允许不区分大小写的字符串值之一TRACE，DEBUG，INFO，WARN，ERROR，ALL或OFF的<span class="attr">level</span>属性值。不区分大小写的特殊值<em>INHERITED</em>或它的同义词<em>NULL</em>将强制记录器的级别从层次结构的上层继承。如果您设置了记录器的级别，后来又决定它应该继承其级别，那么这将派上用场。
    </p>

    <p class="highlight">需要注意的是不同的log4j，的logback经典<em>不会</em>关闭，也没有配置给定的记录时，删除任何先前提及追加程序。
    </p>

    <p>的<code><logger></code>元素可以包含零个或多个<code><appender-ref></code>元素;如此引用的每个附加程序都会添加到命名记录器中。需要注意的是不同的log4j，的logback经典<em>不会</em>关闭，也没有配置给定的记录时，删除任何先前提及追加程序。
    </p>



   <h4 class="doAnchor" name="rootElement">配置根记录器，或者<code><root></code>元件</h4>

   <p>的<code><root></code>元素配置根记录器。它支持单个属性，即<span class="attr">级别</span>属性。它不允许任何其他属性，因为可加性标志不适用于根记录器。此外，由于根记录器已经被命名为“ ROOT”，因此它也不允许使用name属性。level属性的值可以是不区分大小写的字符串TRACE，DEBUG，INFO，WARN，ERROR，ALL或OFF之一。请注意，根记录器的级别不能设置为INHERITED或NULL。</p>

   <p class="highlight">需要注意的是不同的log4j，的logback经典关<em>不</em>上，也不在配置根记录时，删除以前提及追加程序。</p>

   <p>类似于<code><logger></code>元素<code><root></code>元素可以包含零个或多个<code><appender-ref></code>元素;如此引用的每个附加程序都会添加到根记录器中。需要注意的是不同的log4j，的logback经典关<em>不</em>上，也不在配置根记录时，删除以前提及追加程序。</p>

   <h4>例</h4>

   <p>设置记录器或根记录器的级别就像声明和设置其级别一样简单，如下面的示例所示。假设我们不再希望看到来自属于“ chapters.configuration”包的任何组件的任何DEBUG消息。以下配置文件显示了如何实现此目的。
   </p>

   <p class="example">示例：设置记录器的级别（logback-examples / src / main / resources / chapters / configuration / sample2.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('sample2');">观看为.groovy</span>
   <pre id="sample2" class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  <b>&lt;logger name="chapters.configuration" level="INFO"/></b>

  &lt;!-- Strictly speaking, the level attribute is not necessary since --&gt;
  &lt;!-- the level of the root level is set to DEBUG by default.       --&gt;
  &lt;root level="DEBUG">		
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>  
  
&lt;/configuration></pre>

  <p>当以上配置文件作为<em>MyApp3</em>应用程序的参数提供时，它将产生以下输出：</p>

<pre class="source">17:34:07.578 [main] INFO  chapters.configuration.MyApp3 - Entering application.
17:34:07.578 [main] INFO  chapters.configuration.MyApp3 - Exiting application.</pre>

  <p>请注意， <a href="../xref/chapters/configuration/Foo.html">“ chapters.configuration”生成的级别为DEBUG的消息</a><a href="../xref/chapters/configuration/Foo.html">。Foo”</a>记录器已被取消。另请参见Foo类。</p>

  <p>您可以根据需要配置任意数量的记录器。在下一个配置文件中，我们将<em>Chapters.configuration</em>记录器的级别设置为INFO，但同时将Chapters.configuration的级别设置为<em>。Foo</em>记录器到<code>DEBUG</code> 。
  </p>

  <p class="example">示例：设置多个记录器的级别（logback-examples / src / main / resources / chapters / configuration / sample3.xml）</p>
  
  <span class="asGroovy" onclick="return asGroovy('sample3');">观看为.groovy</span>
  <pre id="sample3" class="source prettyprint">&lt;configuration>

  &lt;appender name="STDOUT"
    class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
     &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  <b>&lt;logger name="chapters.configuration" level="INFO" /></b>
  <b>&lt;logger name="chapters.configuration.Foo" level="DEBUG" /></b>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>

&lt;/configuration></pre>

  <p>跑步<code>MyApp3</code>使用此配置文件将在控制台上产生以下输出：</p>

<p class="prettyprint source">17：39：27.593 [main] INFO章节。配置。MyApp3-输入应用程序。17：39：27.593 [main] DEBUG的章。配置。Foo-再来一次！17：39：27.593 [main] INFO章节。配置。MyApp3-退出应用程序。</p>

   <p>下表列出了记录器及其级别，之后<code>JoranConfigurator</code>已使用<em>sample3.xml</em>配置文件配置了logback。
   </p>

   <table class="bodyTable">
     <tbody><tr>
       <th>记录仪名称</th>
       <th>分配级别</th>
       <th>有效水平</th>
     </tr>
     <tr>
       <td>根</td>
       <td><code>DEBUG</code></td>
       <td><code>DEBUG</code></td>
     </tr>
     <tr class="alt">
       <td>章节配置</td>
       <td><code>INFO</code></td>
       <td><code>INFO</code></td>
     </tr>
     <tr>
       <td>章节配置MyApp3</td>
       <td><code>null</code></td>
       <td><code>INFO</code></td>
     </tr>
     <tr class="alt">
       <td>章节配置oo</td>
       <td><code>DEBUG</code></td>
       <td><code>DEBUG</code></td>
     </tr>
   </tbody></table>

  <p>因此，两个日志记录级别<code>INFO</code>在里面<code>MyApp3</code>类以及中的DEBUG消息<code>Foo.doIt()</code>全部启用。请注意，根记录器的级别始终设置为非空值，默认情况下为DEBUG。
  </p>

  <p>让我们注意到， <a href="architecture.html#basic_selection">基本选择规则</a>取决于所调用记录器的有效级别，而不取决于附加了附加程序的记录器的级别。Logback首先将确定是否启用了日志记录语句，如果启用，它将调用在记录器层次结构中找到的附加程序，而不管其级别如何。配置文件<em>sample4.xml</em>就是一个<em>很好</em>的例子：</p>

  <p class="example">示例：记录器级别示例（logback-examples / src / main / resources / chapters / configuration / sample4.xml）</p>
  <span class="asGroovy" onclick="return asGroovy('sample4');">观看为.groovy</span>
  <pre id="sample4" class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT"
   class="ch.qos.logback.core.ConsoleAppender">
   &lt;encoder>
     &lt;pattern>
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  <b>&lt;logger name="chapters.configuration" level="INFO" /></b>

  &lt;!-- turn OFF all logging (children can override) -->
  &lt;root <b>level="OFF"</b>>
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>

&lt;/configuration></pre>

  <p>下表列出了应用<em>sample4.xml</em>配置文件后的记录器及其级别。
  </p>

  <table class="bodyTable">
    <tbody><tr>
      <th>记录仪名称</th>
      <th>分配级别</th>
      <th>有效水平</th>
    </tr>
    <tr>
      <td>根</td>
      <td><code>OFF</code></td>
      <td><code>OFF</code></td>
    </tr>
    <tr class="alt">
      <td>章节配置</td>
      <td><code>INFO</code></td>
      <td><code>INFO</code></td>
    </tr>
    <tr>
      <td>章节配置MyApp3</td>
      <td><code>null</code></td>
      <td><code>INFO</code></td>
    </tr>
    <tr class="alt">
      <td>章节配置oo</td>
      <td><code>null</code></td>
      <td><code>INFO</code></td>
    </tr>
  </tbody></table>

  <p>名为<em>STDOUT</em>的ConsoleAppender是<em>sample4.xml中</em>唯一配置的附加程序，它附加到根记录程序，其级别设置为。 <code>OFF</code> 。然而，配置脚本运行<em>sample4.xml</em>将<em>MyApp3</em>产生：</p>

  <div class="source"><pre>17:52:23.609 [main] INFO chapters.configuration.MyApp3 - Entering application.
17:52:23.609 [main] INFO chapters.configuration.MyApp3 - Exiting application.</pre></div>

  <p>因此，根记录器的级别没有明显的影响，因为<code>chapters.configuration.MyApp3</code>和<code>chapters.configuration.Foo</code>所有类均已启用<code>INFO</code>水平。附带说明一下， <em>pages.configuration</em> logger通过其在配置文件中的声明而存在-即使Java源代码没有直接引用它。
  </p>

  <h4 class="doAnchor" name="configuringAppenders">配置追加者</h4>

  <p>附加程序配置有<code><appender></code>元素，它具有两个必需属性<span class="attr">name</span>和<span class="attr">class</span> 。<span class="attr">name</span>属性指定附加程序的名称，而<span class="attr">class</span>属性指定要实例化的附加程序类的全限定名称。的<code><appender></code>元素可以包含零或一<code><layout></code>零个或多个元素<code><encoder></code>元素且零个或多个<code><filter></code>元素。除了这三个共同的要素， <code><appender></code>元素可以包含任意数量的与appender类的JavaBean属性相对应的元素。无缝支持给定logback组件的任何属性是<a href="onJoran.html">Joran</a>的主要优势之一，如下一章所述。下图说明了通用结构。请注意，对属性的支持不可见。
  </p>

  <p align="left">
    <img src="images/chapters/configuration/appenderSyntax.png" alt="追加语法" title="Appender元素语法">
  </p>

  <p>的<code><layout></code>元素采用必需的类属性，该属性指定要实例化的布局类的完全限定名称。与<code><appender></code>元件， <code><layout></code>可能包含与布局实例的属性相对应的其他元素。由于这种情况很常见，因此如果布局类为<code>PatternLayout</code> ，则可以按照<a href="onJoran.html#defaultClassMapping">默认的类映射</a>规则指定的方式省略class属性。
  </p>

  <p>的<code><encoder></code>元素采用必需的类属性，该属性指定要实例化的编码器类的完全限定名称。由于这种情况很普遍，如果编码器类是<code>PatternLayoutEncoder</code> ，则可以按照<a href="onJoran.html#defaultClassMapping">默认的类映射</a>规则指定的方式省略class属性。
  </p>

  <p>登录到多个追加程序就像定义各种追加程序并在记录器中引用它们一样容易，就像下一个配置文件所示：</p>

  <p class="example">示例：多个记录器（logback-examples / src / main / resources / chapters / configuration / multiple.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('multiple');">观看为.groovy</span>
  <pre id="multiple" class="prettyprint source">&lt;configuration>

  &lt;appender name="<b>FILE</b>" class="ch.qos.logback.core.FileAppender">
    &lt;file>myApp.log&lt;/file>

    &lt;encoder>
      &lt;pattern>%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;appender name="<b>STDOUT</b>" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    <b>&lt;appender-ref ref="FILE" /></b>
    <b>&lt;appender-ref ref="STDOUT" /></b>
  &lt;/root>
&lt;/configuration></pre>

  <p>这些配置脚本定义了两个称为<em>FILE</em>和<em>STDOUT的</em>附加程序。<em>FILE</em>附加程序记录到名为<em>myApp.log</em>的文件中。该附加器的编码器是<code>PatternLayoutEncoder</code>它输出日期，级别，线程名称，记录器名称，文件名和日志请求所在的行号，消息和行分隔符。第二个附加器称为<code>STDOUT</code>输出到控制台。此追加器的编码器仅输出消息字符串，后跟一个行分隔符。
  </p>

  <p>通过在<em>appender-ref</em>元素中按名称引用附加程序，将附加程序附加到根记录器。请注意，每个附加程序都有其自己的编码器。编码器通常不设计为由多个附加程序共享。布局也是如此。因此，logback配置文件不提供用于共享编码器或布局的任何语法手段。
  </p>

  <h4 class="doAnchor" name="cumulative">申请者积累</h4>

  <p>默认情况下， <b>附加程序是累积的</b> ：记录器将记录到附加到其自身的附加程序（如果有）以及附加到其祖先的所有附加程序。因此，将同一附加程序附加到多个记录器将导致记录输出重复。
  </p>

  <p class="example">示例：重复的追加程序（logback-examples / src / main / resources / chapters / configuration / duplicate.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('duplicate');">观看为.groovy</span>
  <pre id="duplicate" class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;logger name="chapters.configuration">
    &lt;appender-ref ref="STDOUT" />
  &lt;/logger>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>跑步<code>MyApp3</code>使用<em>plicate.xml</em>将产生以下输出：</p>

<p class="source">14：25：36.343 [main] INFO章节。配置。MyApp3-输入应用程序。14：25：36.343 [main] INFO章节。配置。MyApp3-输入应用程序。14：25：36.359 [main]调试Chapters.configuration。Foo-再来一次！14：25：36.359 [main]调试Chapters.configuration。Foo-再来一次！14：25：36.359 [main] INFO章节。配置。MyApp3-退出应用程序。14：25：36.359 [main] INFO章节。配置。MyApp3-退出应用程序。</p>

  <p>注意重复的输出。名为<em>STDOUT</em>的附加程序附加到两个记录器（分别是root和<em>chapters.configuration）</em> 。由于根记录器是所有记录器和<em>各章</em>的始祖，所以configuration是这两<em>章.configuration的父级<em>。MyApp3</em>和Chapters.configuration</em> <em>。富</em> ，这两个记录器由将被输出两次，一次是因为<em>STDOUT</em>被附接到<em>chapters.configuration</em>并且一旦因为它被连接到<em>根</em>每个日志记录请求。
  </p>

  <p>Appender可加性不旨在成为新用户的陷阱。这是一个非常方便的注销功能。例如，您可以配置日志记录，以使日志消息出现在控制台上（对于系统中的所有记录器），而仅来自某些特定记录器集的消息流入特定的附加程序。
  </p>

  <p class="example">示例：多个附加程序（logback-examples / src / main / resources / chapters / configuration / restricted.xml）</p>
  <span class="asGroovy" onclick="return asGroovy('restricted');">观看为.groovy</span>
  <pre id="restricted" class="prettyprint source">&lt;configuration>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;file>myApp.log&lt;/file>
    &lt;encoder>
      &lt;pattern>%date %level [%thread] %logger{10} [%file:%line] %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;logger name="chapters.configuration">
    &lt;appender-ref ref="FILE" />
  &lt;/logger>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>在这个例子中，控制台添加器将记录所有消息（系统中的所有记录仪），而只从<em>chapters.configuration</em>记录器记录的请求发起和它的孩子们将进入<em>myApp.log</em>文件。
  </p>
	
  <h4 class="doAnchor" name="overrridingCumulativity">覆盖默认的累积行为</h4>

  <p>如果默认的累积行为证明不适合您的需求，则可以通过将可加性标志设置为false来覆盖它。因此，记录器树中的分支可能会将输出定向到与其余树不同的一组附加程序。
  </p>

  <p class="example">示例：可加性标志（logback-examples / src / main / resources / chapters / configuration / additivityFlag.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('additivityFlag');">观看为.groovy</span>
  <pre id="additivityFlag" class="prettyprint source">&lt;configuration>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;file>foo.log&lt;/file>
    &lt;encoder>
      &lt;pattern>%date %level [%thread] %logger{10} [%file : %line] %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;logger name="chapters.configuration.Foo" <b>additivity="false"</b>>
    &lt;appender-ref ref="FILE" />
  &lt;/logger>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>在此示例中，名为<em>FILE</em>的附加程序附加到<em>Chapters.configuration。Foo</em>记录器。此外，各<em>章中的配置。Foo</em> logger的可加性标志设置为false，以便其日志记录输出将发送到名为<em>FILE</em>的附加程序，而不发送到层次结构中较高位置附加的任何附加程序。其他记录器仍然忽略这些<em>章的可设置性<em>。Foo</em>记录器。运行<code>MyApp3</code>带有<em>additivityFlag.xml</em>配置文件的应用程序将从控制台中的“配置” <em>章节输出结果<em>。MyApp3</em>记录器。但是，从“配置”一<em>章中的输出<em>。Foo</em>记录器将仅出现在<em>foo.log</em>文件中。
  </em></em></em></p><em><em>

  <h3 class="doAnchor" name="contextName">设置上下文名称</h3>

  <p>如<a href="architecture.html#LoggerContext">前一章所述</a> ，每个记录器都附加到记录器上下文。默认情况下，记录器上下文称为“默认”。但是，您可以在<code><contextName></code>配置指令。请注意，一旦设置，记录器上下文名称<a href="../apidocs/ch/qos/logback/core/ContextBase.html#setName(java.lang.String)">就无法更改</a> 。设置上下文名称是一种简单明了的方法，以区分登录到同一目标的多个应用程序。
  </p>
  
  <p class="example">示例：设置上下文名称并显示它（logback-examples / src / main / resources / chapters / configuration / contextName.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('contextName');">观看为.groovy</span>
  <pre id="contextName" class="prettyprint source">&lt;configuration>
  <b>&lt;contextName>myAppName&lt;/contextName></b>
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%d <b>%contextName</b> [%t] %level %logger{36} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

  <p>最后一个示例说明了记录器上下文的命名。在布局的模式中添加<a href="layouts.html#conversionWord">contextName转换词</a>将输出所述名称。</p>
  
  <!-- =============================================================== -->
 
  <h3 class="doAnchor" name="variableSubstitution">变量替代</h3>

  <p><span class="label">注意</span>本文档的早期版本使用术语“属性替换”代替术语“变量”。请考虑两个术语的互换性，尽管后一个术语传达了更清晰的含义。
  </p>

  <p>与许多脚本语言一样，logback配置文件支持变量的定义和替换。变量具有<a href="#scopes">作用域</a> （请参见下文）。此外，变量可以在配置文件本身中，在外部文件中，在外部资源中<a href="#definingPropsOnTheFly">定义，</a>甚至可以<a href="#definingPropsOnTheFly">即时</a>计算和<a href="#definingPropsOnTheFly">定义</a> 。
  </p>

  <p class="highlight">变量替换可以在配置文件中可以指定值的任何位置进行。</p>

  <p>变量替换可以在配置文件中可以指定值的任何位置进行。变量替换的语法类似于Unix shell的语法。开头<em>$ {</em>和结束<em>}</em>之间的字符串被解释为对属性<em>值</em>的引用。对于属性<em>aName</em> ，字符串“ $ {aName}”将替换为<em>aName</em>属性持有的值。
  </p>

  

  <p>由于经常会派上用场，因此HOSTNAME和CONTEXT_NAME变量会自动定义并具有上下文范围。考虑到在某些环境中可能需要花费一些时间来计算主机名，因此其值是延迟计算的（仅在需要时）。此外，可以<a href="#definingProps">直接</a>在<a href="#definingProps">配置中</a>设置HOSTNAME <a href="#definingProps">。</a>
  </p>

   <h4 class="doAnchor" name="definingProps">定义变量</h4>

  <p>变量可以一次在配置文件中定义，也可以从外部属性文件或外部资源中批量加载。由于历史原因，用于定义变量的XML元素是<code><property></code>尽管在1.0.7及更高版本的logback中<code><variable></code>可以互换使用。</p>

  <p>下一个示例显示在配置文件开头声明的变量。然后在文件中进一步使用它来指定输出文件的位置。
  </p>

  <p class="example">示例：简单变量替换（logback-examples / src / main / resources / chapters / configuration / variableSubstitution1.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('variableSubstitution1');">观看为.groovy</span>
  <pre id="variableSubstitution1" class="prettyprint source">&lt;configuration>

  <b>&lt;property name="USER_HOME" value="/home/sebastien" /></b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

  <p>下一个示例说明如何使用System属性获得相同的结果。该属性未在配置文件中声明，因此重新登录将在系统属性中查找它。可以在命令行上设置Java系统属性，如下所示：</p>
  
  <p class="source">java -DUSER_HOME =“ / home / sebastien” MyApp2</p>

  <p class="example">示例：系统变量替换（logback-examples / src / main / resources / chapters / configuration / variableSubstitution2.xml）</p>
  <span class="asGroovy" onclick="return asGroovy('variableSubstitution2');">观看为.groovy</span>
  <pre id="variableSubstitution2" class="prettyprint source">&lt;configuration>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

  
  <p>当需要多个变量时，创建包含所有变量的单独文件可能更方便。这是进行这种设置的方法。
  </p>

  <p class="example">示例：使用单独的文件进行变量替换（logback-examples / src / main / resources / chapters / configuration / variableSubstitution3.xml）</p>
  <span class="asGroovy" onclick="return asGroovy('variableSubstitution3');">观看为.groovy</span>
  <pre id="variableSubstitution3" class="prettyprint source">&lt;configuration>

  <b>&lt;property file="src/main/java/chapters/configuration/variables1.properties" /></b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
     <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
     &lt;encoder>
       &lt;pattern>%msg%n&lt;/pattern>
     &lt;/encoder>
   &lt;/appender>

   &lt;root level="debug">
     &lt;appender-ref ref="FILE" />
   &lt;/root>
&lt;/configuration></pre>

   <p>此配置文件包含对名为<em>variables1.properties</em>的文件的引用。该文件中包含的变量将被读取，然后在本地范围内定义。这是<em>variable.properties</em>文件的外观。
   </p>

   <em>示例：变量文件（logback-examples / src / main / resources / chapters / configuration / variables1.properties）</em>

   <pre class="source">USER_HOME=/home/sebastien</pre>

   <p>您也可以在类路径上引用资源而不是文件。</p>

  <pre class="prettyprint source">&lt;configuration>

  <b>&lt;property resource="resource1.properties" /></b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
     <b>&lt;file>${USER_HOME}/myApp.log&lt;/file></b>
     &lt;encoder>
       &lt;pattern>%msg%n&lt;/pattern>
     &lt;/encoder>
   &lt;/appender>

   &lt;root level="debug">
     &lt;appender-ref ref="FILE" />
   &lt;/root>
&lt;/configuration></pre>


   <h4 class="doAnchor" name="scopes">范围</h4>

   <p>可以定义一个属性以在<em>本地范围</em> ， <em>上下文范围</em>或<em>系统范围中</em>插入。本地范围是默认设置。尽管可以从OS环境中读取变量，但是无法写入OS环境中。</p>


   <p><span class="label">本地范围</span>从配置文件中定义其范围的角度到该配置文件的解释/执行结束为止，都存在具有<span class="label">本地范围</span>的属性。因此，每次解析和执行配置文件时，都会重新定义本地作用域中的变量。</p>

   <p><span class="label">上下文范围</span>具有<span class="label">上下文范围</span>的属性插入到上下文中，并且持续时间与上下文一样长，直到清除为止。一旦定义，上下文范围内的属性就是上下文的一部分。这样，它在所有日志记录事件中都可用，包括那些通过序列化发送到远程主机的事件。
   </p>

   <p><span class="label">系统范围</span>具有<span class="label">系统范围</span>的属性被插入JVM的系统属性中，并且持续时间与JVM一样长，或者直到被清除为止。
   </p>
 
   <p class="highlight">首先在本地范围内，然后在上下文范围内，然后在系统属性范围内，最后在OS环境中查找属性。
   </p>

   <p>在替换期间，首先在本地范围内查找属性，然后在上下文范围内查找属性，然后在系统属性范围内查找属性，然后在<a href="http://docs.oracle.com/javase/tutorial/essential/environment/env.html">OS环境</a>中查找属性，最后查找属性。
   </p>

   <p>的<span class="attr">范围</span>属性<code><property></code>元件， <code><define></code>元素或<code><insertFromJNDI></code>元素可用于设置属性的范围。<span class="attr">作用域</span>属性允许将“本地”，“上下文”和“系统”字符串作为可能的值。如果未指定，则范围始终假定为“本地”。
   </p>

   <p class="example">示例：在“上下文”范围内定义的变量（logback-examples / src / main / resources / chapters / configuration / contextScopedVariable.xml）</p>

  <span class="asGroovy" onclick="return
  asGroovy('contextScopedVariable');">观看为.groovy</span>
  <pre id="contextScopedVariable" class="prettyprint source">&lt;configuration>

  &lt;property <b class="big">scope="context"</b> name="nodeId" value="firstNode" />

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <b>&lt;file>/opt/${nodeId}/myApp.log&lt;/file></b>
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

   <p>在上面的示例中，假定在上下文范围中定义了<em>nodeId</em>属性，它将在每个日志记录事件中可用，即使是那些通过序列化发送到远程主机的事件也是如此。</p>


  <h3 class="doAnchor" name="defaultValuesForVariables">变量的默认值</h3>

  <p>在某些情况下，如果未声明变量或其值为空，则可能希望变量具有默认值。与<a href="http://tldp.org/LDP/abs/html/parameter-substitution.html">Bash shell中一样</a> ，可以使用<b>“：-”</b>运算符指定默认值。例如，假设未定义名为<em>aName</em>的变量， <code>"${aName<b>:-golden</b>}"</code>将被解释为“黄金”。</p>

   <h3 class="doAnchor" name="nestedSubst">嵌套变量</h3>

   <p>完全支持变量嵌套。变量的名称，默认值和值定义都可以引用其他变量。</p>


   <h4>价值嵌套</h4>
   <p>变量的值定义可以包含对其他变量的引用。假设您希望使用变量不仅指定目标目录，还指定文件名，然后将这两个变量组合到名为“目标”的第三个变量中。下面显示的属性文件提供了一个示例。
   </p>

   <p class="example">示例：嵌套变量引用（logback-examples / src / main / resources / chapters / configuration / variables2.properties）</p>

   <pre class="source">USER_HOME=/home/sebastien
fileName=myApp.log
<b>destination=${USER_HOME}/${fileName}</b></pre>

    <p>请注意，在上面的属性文件中，“目的地”由其他两个变量组成，即“ USER_HOME”和“ fileName”。
    </p>
    
    <em>示例：使用单独的文件进行变量替换（logback-examples / src / main / resources / chapters / configuration / variableSubstitution4.xml）</em>

    <pre class="prettyprint source">&lt;configuration>

  &lt;property file="variables2.properties" />

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <b>&lt;file>${destination}&lt;/file></b>
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>


   <h4>名称嵌套</h4>

   <p>引用变量时，变量名称可能包含对另一个变量的引用。例如，如果为名为“ userid”的变量分配了值“ alice”，则“ $ {$ {userid} .password}”引用名称为“ alice.password”的变量。</p>

   <h4>默认值嵌套</h4>

   <p>变量的默认值可以引用另一个变量。例如，假设未分配变量'id'，并且为变量'userid'分配了值“ alice”，则表达式“ $ {id <b>：-</b> $ {userid}}”将返回“ alice”。
   </p>


  <!-- ==============================================================
       -->
  <h3 class="doAnchor" name="hostname">HOSTNAME财产</h3>

  <p>由于经常派上用场， <code>HOSTNAME</code>属性是在配置上下文范围时自动定义的。</p>

  <!-- ============================================================== -->
  <h3 class="doAnchor" name="context_name">CONTEXT_NAME属性</h3>

  <p>顾名思义， <code>CONTEXT_NAME</code>属性对应于当前日志记录上下文的名称。</p>

  <!-- ============================================================== -->
  
  <h3 class="doAnchor" name="timestamp">设置时间戳</h3>

  <p><em>timestamp</em>元素可以根据当前日期和时间定义属性。<em>时间戳</em>元素<a href="appenders.html#uniquelyNamed">将在下一章中进行说明</a> 。</p>

  <!-- ============================================================== -->
  <h3 class="doAnchor" name="definingPropsOnTheFly">动态定义属性</h3>

  <p>您可以使用<code><define></code>元件。define元素具有两个必填属性： <span class="attr">name</span>和<span class="attr">class</span> 。<span class="attr">name</span>属性指定要设置的属性的名称，而<span class="attr">class</span>属性则指定实现<a href="../xref/ch/qos/logback/core/spi/PropertyDefiner.html">PropertyDefiner</a>接口的任何类。由返回的值<code>getPropertyValue</code> （）的方法<code>PropertyDefiner</code>实例将是命名属性的值。你也可以指定一个<a href="#scopes">范围内</a>通过指定<span class="attr">scope</span>属性的命名属性。
  </p>

  <p>这是一个例子。</p>

  <pre class="prettyprint source">&lt;configuration>

  &lt;define name="rootLevel" class="a.class.implementing.PropertyDefiner">
    &lt;shape>round&lt;/shape>
    &lt;color>brown&lt;/color>
    &lt;size>24&lt;/size>
  &lt;/define>
 
  &lt;root level="${rootLevel}"/>
&lt;/configuration></pre>

  <p>在上面的示例中，形状，颜色和大小是“ a.class.implementing”的属性。PropertyDefiner”。只要您在实施中<code>PropertyDefiner</code>例如，logback将注入配置文件中指定的适当值。</p>

 

  <p>目前，logback确实提供了两个相当简单的实现<code>PropertyDefiner</code> 。
  </p>

  <table class="bodyTable striped">
    <tbody><tr>
      <th>实现名称</th>
      <th>描述</th>
    </tr>

    <tr>
      <td><a href="../apidocs/ch/qos/logback/core/property/CanonicalHostNamePropertyDefiner.html"><code>CanonicalHostNamePropertyDefiner</code></a>
      </td>
      <td>将命名变量设置为本地主机的规范主机名。请注意，获取规范的主机名可能需要几秒钟。
      </td>
    </tr>
    <tr>

    </tr><tr>
      <td><a href="../apidocs/ch/qos/logback/core/property/FileExistsPropertyDefiner.html"><code>FileExistsPropertyDefiner</code></a>
      </td>
      <td>如果<span class="prop">path</span>属性指定的文件存在，则将命名变量设置为“ true”，否则设置为“ false”。
      </td>
    </tr>
    <tr>
      <td><a href="../apidocs/ch/qos/logback/core/property/FileExistsPropertyDefiner.html"><code>ResourceExistsPropertyDefiner</code></a>
      </td>
      <td>如果用户指定的<span class="prop">资源</span>在类路径上可用，则将命名变量设置为“ true”，否则设置为“ false”。
      </td>
    </tr>
  </tbody></table>

  <!-- ============================================================== -->

  <h3 class="doAnchor" name="conditional">有条件地处理配置文件</h3>
  
  <p>开发人员经常需要在针对不同环境（例如开发，测试和生产）的多个logback配置文件之间进行切换。这些配置文件有很多共同点，仅在几个地方有所不同。为避免重复，logback支持在以下条件的帮助下对配置文件进行有条件的处理： <code><if></code> ， <code><then></code>和<code><else></code>元素，以便单个配置文件可以适当地针对多个环境。请注意，条件处理需要<a href="../setup.html#janino">Janino库</a> 。
  </p>

  <p>条件语句的一般格式如下所示。</p>

  <pre class="prettyprint source">
   &lt;!-- if-then form -->
   &lt;if condition="some conditional expression">
    &lt;then>
      ...
    &lt;/then>
  &lt;/if>
  
  &lt;!-- if-then-else form -->
  &lt;if condition="some conditional expression">
    &lt;then>
      ...
    &lt;/then>
    &lt;else>
      ...
    &lt;/else>    
  &lt;/if></pre>  

  <p>条件是其中只能访问上下文属性或系统属性的Java表达式。对于作为参数传递的键， <code>property</code> （）或更短等价<code>p</code> （）方法返回属性的String值。例如，要使用键“ k”访问属性的值，应编写<code>property("k")</code>或同等<code>p("k")</code> 。如果未定义键为“ k”的属性，则属性方法将返回空字符串，而不是null。这避免了需要检查空值。</p>

  <p>的<code>isDefined()</code>方法可用于检查是否定义了属性。例如，要检查是否定义了属性“ k”，您可以编写<code>isDefined("k")</code>同样，如果您需要检查属性是否为null，则<code>isNull()</code>提供了方法。例： <code>isNull("k")</code> 。</p>

  <pre class="prettyprint source">&lt;configuration debug="true">

  <b>&lt;if condition='property("HOSTNAME").contains("torino")'></b>
    <b>&lt;then></b>
      &lt;appender name="CON" class="ch.qos.logback.core.ConsoleAppender">
        &lt;encoder>
          &lt;pattern>%d %-5level %logger{35} - %msg %n&lt;/pattern>
        &lt;/encoder>
      &lt;/appender>
      &lt;root>
        &lt;appender-ref ref="CON" />
      &lt;/root>
    <b>&lt;/then></b>
  <b>&lt;/if></b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;file>${randomOutputDir}/conditional.log&lt;/file>
    &lt;encoder>
      &lt;pattern>%d %-5level %logger{35} - %msg %n&lt;/pattern>
   &lt;/encoder>
  &lt;/appender>

  &lt;root level="ERROR">
     &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

  
  <p>条件处理支持内的<em>任何地方</em> <code><configuration></code>元件。还支持嵌套的if-then-else语句。但是，XML语法非常繁琐，不适合用作通用编程语言的基础。因此，太多的条件将使后续的读者（包括您自己）难以理解您的配置文件。
  </p>


  <!-- ============================================================== -->

   <h3 class="doAnchor" name="insertFromJNDI">从JNDI获取变量</h3>

   <p>在某些情况下，您可能需要使用JNDI中存储的环境。的<code><insertFromJNDI></code>配置指令提取存储在JNDI中的环境，并使用<span class="attr">as</span>属性指定的键将属性插入本地范围。作为所有属性，可以借助<em>scope</em>属性将新属性插入到<a href="#scopes">其他范围中</a> 。
   </p>

   <p class="example">示例：插入通过JNDI获得的属性环境条目（logback-examples / src / main / resources / chapters / configuration / insertFromJNDI.xml）</p>

   <pre class="prettyprint source">&lt;configuration>
  <b>&lt;insertFromJNDI env-entry-name="java:comp/env/appName" as="<span class="green">appName"</span> /></b>
  <b>&lt;contextName><span class="green">${appName}</span>&lt;/contextName></b>

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%d ${CONTEXT_NAME} %level %msg %logger{50}%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>
&lt;/configuration></pre>

  <p>在最后一个示例中，插入了“ java：comp / env / appName”环境条目作为<span class="variable">appName</span>属性。请注意<code><contextName></code>指令根据前一个插入的<span class="variable">appName</span>属性的值设置上下文名称<code><insertFromJNDI></code>指示。
  </p>

  <h3 class="doAnchor" name="fileInclusion">文件包含</h3>

  <p>Joran支持将配置文件的一部分包含在另一个文件中。这是通过声明一个<code><include></code>元素，如下所示：</p>

  <p class="example">示例：文件包括（logback-examples / src / main / resources / chapters / configuration / containsConfig.xml）</p>

  <pre class="prettyprint source">&lt;configuration>
  <b>&lt;include file="src/main/java/chapters/configuration/includedConfig.xml"/></b>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="includedConsole" />
  &lt;/root>

&lt;/configuration></pre>

  <p>目标文件必须将其元素嵌套在<code><included></code>元件。例如，一个<code>ConsoleAppender</code>可以声明为：</p>

  <p class="example">示例：文件包括（logback-examples / src / main / resources / chapters / configuration / includedConfig.xml）</p>

  <pre class="source"><b class="green big">&lt;included></b>
  &lt;appender name="includedConsole" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>"%d - %m%n"&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
<b class="green big">&lt;/included></b></pre>


  <p>同样，请注意必填项<code class="big green"><included></code>元件。</p>

  <p>要包含的内容可以引用为文件，资源或URL。</p>

  <ul>

    <li><b>作为文件：</b><br>要包含文件，请使用<span class="attr">file</span>属性。您可以使用相对路径，但是请注意，当前目录是由应用程序定义的，不一定与配置文件的路径相关。</li>

    <li><p><b>作为资源：</b><br>要包括资源，即在类路径上找到的文件，请使用<span class="attr">resource</span>属性。</p>

    <pre class="prettyprint source">&lt;include resource="includedConfig.xml"/></pre>
    
    </li>

    <li><p><b>作为URL：</b><br>要包括URL的内容，请使用<span class="attr">url</span>属性。</p>

    <pre class="prettyprint source">&lt;include url="http://some.host.com/includedConfig.xml"/></pre>

    </li>
  </ul>

  <p>如果找不到要包含的文件，则将通过打印状态消息来进行注销以进行注销。如果包含的文件是可选的，则可以通过将<span class="attr">optional</span>属性设置为来禁止显示警告消息。 <code>true</code>在里面<code><include></code>元件。</p>


  <pre class="prettyprint source">&lt;include optional="true" ..../></pre>

  <!-- ==================== ContextListener =================== -->
  <h2 class="doAnchor" name="contextListener">添加上下文监听器</h2>

  <p><a href="../xref/ch/qos/logback/classic/spi/LoggerContextListener.html">LoggerContextListener</a>接口的实例侦听与记录器上下文的生命周期有关的事件。
  </p>


  <p><code>JMXConfigurator</code>是的一种实现<code>LoggerContextListener</code>接口。在<a href="jmxConfig.html">下一章中</a>对此进行了描述。
  </p>

  <h3 class="doAnchor" name="LevelChangePropagator">LevelChangePropagator</h3>

  <p>从0.9.25版开始，经典的logback随附<a href="../xref/ch/qos/logback/classic/jul/LevelChangePropagator.html">LevelChangePropagator</a> ，该实现是<code>LoggerContextListener</code>它将对任何经典的logback记录器级别所做的更改传播到java.util.logging框架。这种传播消除了禁用日志语句对性能的影响。仅对于已启用的日志语句， <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/logging/LogRecord.html?is-external=true">LogRecord的</a>实例将被发送到logback（通过SLF4J）。这使实际应用程序可以使用<a href="http://www.slf4j.org/legacy.html#jul-to-slf4j">jul-slf4j</a>桥。
  </p>


  <p>contextListener元素可用于安装<code>LevelChangePropagator</code>如下所示。</p>
  
  <pre class="prettyprint source">&lt;configuration debug="true">
  <b>&lt;contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator"/></b>
  .... 
&lt;/configuration></pre>

  <p>设置<span class="option">LevelChangePropagator的resetJUL</span>属性将重置所有jul记录器的所有先前的级别配置。但是，以前安装的处理程序将保持不变。</p>

  <pre class="prettyprint source">&lt;configuration debug="true">
  &lt;contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator">
    <b>&lt;resetJUL>true&lt;/resetJUL></b>
  &lt;/contextListener>
  ....
&lt;/configuration></pre>
  <p>
  </p>
  

  <script src="../templates/footer.js" type="text/javascript"></script>
</em></em></div><em><em>


</em></em></body></html>