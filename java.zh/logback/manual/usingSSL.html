<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第15章：使用SSL</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">    

  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">      
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>    
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">    

      <h1>第15章：使用SSL</h1>


    <a href="usingSSL_ja.html">和訳（日语翻译）</a>
      
      <div class="quote">

        <p><em>建造与创造之间的全部区别恰恰是：建造的东西只有在被建造后才能被爱。但是创造的事物在存在之前就被爱着。</em></p>
        <p>-查尔斯·狄更斯</p>
      </div>


      <script src="../templates/creative.js" type="text/javascript"></script>
      <!-- script src="../templates/setup.js" type="text/javascript"></script -->

      <p>从基于套接字的附加程序向远程接收器传递日志事件时，Logback支持使用安全套接字层（SSL）。当使用启用SSL的附加程序和相应的接收器时，序列化的日志记录事件将通过安全通道传递。
      </p>
      
      <h2 class="doAnchor">SSL和组件角色</h2>
      
      <p>就网络连接启动而言，诸如附加程序和接收程序之类的回传组件可以充当服务器角色或客户端角色。当充当服务器角色时，登录组件被动侦听来自远程客户端组件的连接。相反，充当客户端角色的组件将启动到远程服务器组件的连接。例如，充当<em>客户端</em>角色的附加程序连接到充当<em>服务器</em>角色的接收<em>程序</em> 。或者，充当<em>客户端</em>角色的接收者连接到充当<em>服务器</em>角色的追加器。</p>
      
      <p>组件的角色通常由组件类型决定。例如， <code>SSLServerSocketAppender</code>是充当服务器角色的附加程序组件，而<code>SSLSocketAppender</code>是充当客户端角色的附加程序组件。因此，开发人员或应用程序管理员可以配置Logback组件以支持所需的网络连接启动方向。</p>
      
      <p>在SSL上下文中，连接启动的方向很重要，因为在SSL中，服务器组件必须拥有X.509凭据才能向连接客户端标识自己。客户端组件在连接到服务器时，将使用服务器的证书来验证服务器是否受信任。开发人员或应用程序管理员必须了解Logback组件的角色，以便正确配置服务器的密钥存储（包含服务器的X.509凭据）和客户端的信任存储（包含验证服务器信任时使用的自签名根证书） ）。</p>
      
      <p>如果将SSL配置为进行<em>相互身份验证</em> ，则服务器组件和客户端组件都必须拥有有效的X.509凭据，其信任关系可以由各自的对等方声明。在服务器组件中配置了相互身份验证，因此开发人员或应用程序管理员必须知道哪些组件在充当服务器角色。</p>
      
      <p>在本章中，我们使用术语<em>服务器组件</em>或简单地<em>服务器</em>来指代充当服务器角色的Logback组件，例如附加器或接收器。我们使用术语“ <em>客户端组件”</em>或简称“ <em>客户端”</em>来指代充当客户端角色的组件。
            
      </p><h2 class="doAnchor">SSL和X.509证书</h2>
      
      <p>为了使用启用SSL的Logback组件，您将需要X.509凭据（私钥，相应的证书和CA认证链）来标识充当SSL服务器的组件。如果希望使用相互身份验证，则还需要充当SSL客户端的组件的凭据。
      </p>      
      <p>虽然您可以使用由商业证书颁发机构（CA）颁发的证书，但也可以使用从您自己的内部CA颁发的证书，甚至可以使用自签名证书。以下是所需的全部：</p> 
      <ol>
        <li>服务器组件必须配置有密钥库，该密钥库包含服务器的私钥，相应的证书和CA证书链（如果不使用自签名证书）。
        </li>
        <li>必须使用包含信任的根CA证书或服务器的自签名根证书的信任库配置客户端组件。
        </li>
      </ol>
          
      <h2 class="doAnchor">配置SSL的Logback组件</h2>
      <p>用于实现Logback的SSL支持的Java安全套接字扩展（JSSE）和Java密码体系结构（JCA）具有许多可配置的选项，以及一个可插拔的提供程序框架，该框架允许替换或内置平台的内置SSL和加密功能。增强。启用SSL的Logback组件提供了完全指定SSL引擎和加密提供程序的所有可配置方面的能力，以满足您独特的安全需求。
      </p>
      
      <h3>使用JSSE系统属性的基本SSL配置</h3>
      <p>幸运的是，启用SSL的Logback组件的几乎所有可配置SSL属性都具有合理的默认值。在大多数情况下，只需要配置一些JSSE系统属性即可。
      </p>
      
      <p>本节的其余部分描述了大多数环境中所需的特定JSSE属性。见<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#InstallationAndCustomization">定制JSSE</a>中<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南</a>中关于设置JSSE系统属性来定制JSSE的更多信息。
      </p>

      <p>如果您使用的是Logback的任何启用了SSL的附加器或接收器组件，都充当服务器角色（例如， <code>SSLServerSocketReceiver</code> ， <code>SSLServerSocketAppender</code> ， 要么<code>SimpleSSLSocketServer</code> ），您需要配置JSSE系统属性，以提供包含私钥和证书的密钥库的位置，类型和密码。
      </p>
      
      <h4><a name="basicConfig.keyStore"></a>服务器密钥库配置的系统属性</h4>
      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><code>javax.net.ssl.keyStore</code></td>
          <td>指定包含服务器组件的私钥和证书的文件的文件系统路径。</td>
        </tr>
        <tr>
          <td><code>javax.net.ssl.keyStoreType</code></td>
          <td>指定密钥库类型。如果未指定此属性，则采用平台的默认类型（JKS）。
          </td>
        </tr>
        <tr>
          <td><code>javax.net.ssl.keyStorePassword</code></td>
          <td>指定访问密钥库所需的密码。
          </td>
        </tr>
      </tbody></table>

      <p>见<a href="#Examples">例如</a>下面的设置这些系统属性的例子开始使用的logback的启用了SSL的服务器组件的应用程序时。
      </p>
         
      <p>如果您的服务器组件正在使用由商业证书颁发机构（CA）签署的证书，则<strong>在使用启用了SSL的客户端组件的应用程序中</strong> ， <strong>您可能不需要提供<em>任何</em> SSL配置</strong> 。对于服务器组件使用商业签名的证书时，通常只需为运行服务器组件的JVM设置系统密钥库属性。
      </p>
               
      <p>如果您使用的是自签名服务器证书，或者服务器证书是由证书颁发机构（CA）签名的，则该证书颁发机构的根证书不在Java平台的默认信任存储中（例如，当您的组织拥有自己的内部证书时）权限），您将需要配置JSSE系统属性，以提供信任库的位置，类型和密码，该信任库包含服务器证书或用于签署服务器证书的证书颁发机构（CA）的受信任根证书。<strong>这些属性将需要在每个使用启用了SSL的客户端组件的应用程序中设置</strong> 。
      </p>
        
      <h4><a name="basicConfig.trustStore"></a>客户端信任库配置的系统属性</h4>
      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><code>javax.net.ssl.trustStore</code></td>
          <td>指定文件的文件系统路径，该文件包含服务器组件的证书或签署服务器证书的证书颁发机构（CA）的受信任的根证书。</td>
        </tr>
        <tr>
          <td><code>javax.net.ssl.trustStoreType</code></td>
          <td>指定信任库类型。如果未指定此属性，则采用平台的默认类型（JKS）。
          </td>
        </tr>
        <tr>
          <td><code>javax.net.ssl.trustStorePassword</code></td>
          <td>指定访问信任库所需的密码。
          </td>
        </tr>
      </tbody></table>

      <p>见<a href="#Examples">实施例</a>下面，用于设置这些系统属性的例子开始，它利用的logback的支持SSL的客户端组件的应用程序时。
      </p>         
            
      <h3 class="doAnchor"><a name="SSLConfiguration"></a>高级SSL配置</h3>
      <p>在某些情况下，使用JSSE系统属性的基本SSL配置是不够的。例如，如果您正在使用<code>SSLServerSocketReceiver</code> Web应用程序中的组件，您可能希望使用与Web服务器用来向Web客户端标识自己的凭据不同的凭据来标识远程日志记录客户端的日志服务器。您可能希望在日志服务器上使用SSL客户端身份验证，以确保只有经过身份验证和授权的远程日志记录器才能连接。或者，您的组织对组织网络上可能使用的SSL协议和密码套件具有严格的政策。对于这些需求，您将需要使用Logback的SSL高级配置选项。</p>
      <p>在配置支持SSL的Logback组件时，您可以使用<code>ssl</code>组件配置中的属性。
      </p>      
      <p>例如，如果您想使用<code>SSLServerSocketReceiver</code>并为日志服务器的凭据配置密钥存储属性，则可以使用以下配置。
      </p>

      <span class="asGroovy" onclick="return asGroovy('logback-ssl-serverKeyStore');">观看为.groovy</span>
      <pre id="logback-ssl-serverKeyStore" class="prettyprint source">&lt;configuration>

  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
  
  &lt;root level="debug">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>

  &lt;receiver class="ch.qos.logback.classic.net.server.SSLServerSocketReceiver">
    &lt;ssl>
      &lt;keyStore>
        &lt;location>classpath:/logging-server-keystore.jks&lt;/location>
        &lt;password>changeit&lt;/password>
      &lt;/keyStore>
    &lt;/ssl>
  &lt;/receiver> 

&lt;/configuration></pre>

      <p>此配置将密钥存储的位置指定为应用程序的类路径根目录下的<em>logging-server-keystore.jks</em> 。您也可以指定一个<code>file:</code>标识密钥库位置的URL。
      </p>
      <p>如果您想使用<code>SSLSocketAppender</code>在应用程序的Logback配置中，但不想使用JSSE更改应用程序的默认信任库<code>javax.net.ssl.trustStore</code>属性，您可以按以下方式配置附加程序。
      </p>          

      <span class="asGroovy" onclick="return asGroovy('logback-ssl-clientTrustStore');">观看为.groovy</span>
      <pre id="logback-ssl-clientTrustStore" class="prettyprint source">&lt;configuration>
  &lt;appender name="SOCKET" class="ch.qos.logback.classic.net.SSLSocketAppender">
    &lt;ssl>
      &lt;trustStore>
        &lt;location>classpath:/logging-server-truststore.jks&lt;/location>
        &lt;password>changeit&lt;/password>
      &lt;/trustStore>
    &lt;/ssl>
  &lt;/appender>
  
  &lt;root level="debug">
    &lt;appender-ref ref="SOCKET" />
  &lt;/root>

&lt;/configuration></pre>

      <p>此配置将信任库的位置指定为应用程序的类路径的根目录下的<em>logging-server-truststore.jks</em> 。您也可以指定一个<code>file:</code>标识信任库位置的URL。
      </p>

      <h4>SSL配置属性</h4>
      
      <p>JSSE公开了大量可配置的选项，Logback的SSL支持使几乎所有这些选项都可供您在启用SSL的组件配置中指定。使用XML配置时，通过<ssl>在组件配置中嵌套一个<ssl>元素，将 SSL属性引入这些组件<ssl>。此配置元素对应于<a href="../xref/ch/qos/logback/core/net/ssl/SSLConfiguration.html"><code>SSLConfiguration</code></a>类。
      </ssl></ssl></ssl></p>
      
      <p>在为组件配置SSL时，只需配置默认值不足的那些SSL属性。过度指定SSL配置通常是导致难以诊断的问题的原因。
      </p>
 
      <p>下表描述了顶级SSL配置属性。这些属性中的许多属性引入了其他子属性，在描述顶级属性之后的表格中对此进行了描述。
      </p>
            
      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>类型</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><span class="prop" container="ssl">keyManagerFactory</span></td>
          <td><a href="../xref/ch/qos/logback/core/net/ssl/KeyManagerFactoryFactoryBean.html">
              <code>KeyManagerFactoryFactoryBean</code></a>
          </td>
          <td>指定用于创建配置文件的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/net/ssl/KeyManagerFactory.html"><code>KeyManagerFactory</code></a> 。如果未配置此属性，则将使用Java平台的默认工厂。请参阅下面的<a href="#KeyManagerFactoryFactoryBean">密钥管理器出厂配置</a> 。
          </td>
        </tr>
        <tr>
          <td><a name="ssl.keyStore"></a> <span class="prop" container="ssl">密钥库</span></td>
          <td><a href="../xref/ch/qos/logback/core/net/ssl/KeyStoreFactoryBean.html">
              <code>KeyStoreFactoryBean</code></a>
          </td>
          <td>
            <p>指定用于创建配置文件的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/security/KeyStore.html"><code>KeyStore</code></a> 。此属性创建的KeyStore应该包含单个X.509凭据（由私钥，相应的证书和CA证书链组成）。该证书由本地SSL对等方提供给远程SSL对等方。
            </p>
            <p>配置SSL客户端时（例如， <code>SSLSocketAppender</code> ），只有将远程对等方配置为需要客户端身份验证时，才需要<span class="prop" container="ssl">keyStore</span>属性。
            </p>
            <p>配置SSL服务器时（例如， <code>SimpleSSLSocketServer</code> ）<span class="prop" container="ssl">keyStore</span>属性指定包含服务器凭据的密钥库。如果未配置此属性，则JSSE的<code>javax.net.ssl.keyStore</code>必须配置系统属性以提供服务器密钥库的位置。有关设置JSSE系统属性的更多信息，请参见《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》中的“</a> <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#InstallationAndCustomization">定制JSSE</a> <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">”</a> 。
            </p>
            <p>请参阅下面的<a href="#KeyStoreFactoryBean">密钥库配置</a> 。
            </p>
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="ssl">参数</span></td>
          <td><a href="../xref/ch/qos/logback/core/net/ssl/SSLParametersConfiguration.html">
              <code>SSLParametersConfiguration</code></a></td>
          <td>指定SSL会话协商中使用的各种参数。请参阅下面的<a href="#SSLParametersConfiguration">SSL参数配置</a> 。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="ssl">协议</span></td>
          <td><code>String</code></td>
          <td>指定将用于创建证书的SSL协议<a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/net/ssl/SSLContext.html"><code>SSLContext</code></a> 。请参阅《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》</a>中的“ <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#AppA">标准名称”</a>规范。如果未配置此属性，则将使用Java平台的默认协议。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="ssl">提供者</span></td>
          <td><code>String</code></td>
          <td>指定将用于创建JSSE提供程序的JSSE提供程序的名称。 <a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/net/ssl/SSLContext.html"><code>SSLContext</code></a> 。如果未配置此属性，则将使用Java平台的默认JSSE提供程序。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="ssl">安全随机</span></td>
          <td><a href="../xref/ch/qos/logback/core/net/ssl/SecureRandomFactoryBean.html">
              <code>SecureRandomFactoryBean</code></a>
          </td>
          <td>指定用于创建配置文件的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/security/SecureRandom.html"><code>SecureRandom</code></a> —安全的随机数生成器。如果未配置此属性，则将使用Java平台的默认生成器。请参阅下面的<a href="#SecureRandomFactoryBean">安全随机生成器配置</a> 。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="ssl">trustManagerFactory</span></td>
          <td><a href="../xref/ch/qos/logback/core/net/ssl/TrustManagerFactoryFactoryBean.html">
              <code>TrustManagerFactoryFactoryBean</code></a>
          </td>
          <td>指定用于创建配置文件的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/net/ssl/TrustManagerFactory.html"><code>TrustManagerFactory</code></a> 。如果未配置此属性，则将使用Java平台的默认工厂。请参阅下面的<a href="#TrustManagerFactoryFactoryBean">Trust Manager工厂</a> 。
          </td>
        </tr>
        <tr>
          <td><a name="ssl.trustStore"></a> <span class="prop" container="ssl">trustStore</span></td>
          <td><a href="../xref/ch/qos/logback/core/net/ssl/KeyStoreFactoryBean.html">
              <code>KeyStoreFactoryBean</code></a>
          </td>
          <td>
            <p>指定用于创建配置文件的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/security/KeyStore.html"><code>KeyStore</code></a>用于验证远程SSL对等方的身份。通过此属性创建的KeyStore应该包含一个或多个<em>信任锚</em> ，即在密钥库中标记为“可信”的自签名证书。通常，信任库包含自签名的CA证书。
            </p>
            <p>此属性指定的信任库将覆盖JSSE的指定的任何信任库<code>javax.net.ssl.trustStore</code>系统属性和平台的默认信任库。有关设置JSSE系统属性的更多信息，请参见《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》中的“</a> <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#InstallationAndCustomization">定制JSSE</a> <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">”</a> 。
            </p>
          </td>
        </tr>
      </tbody></table>
      
      <h4 class="doAnchor"><a name="KeyStoreFactoryBean"></a>密钥库配置</h4>
          
      <p>的<a href="../xref/ch/qos/logback/core/net/ssl/KeyStoreFactoryBean.html"><code>KeyStoreFactoryBean</code></a>指定创建一个所需的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/security/KeyStore.html"><code>KeyStore</code></a>包含X.509凭据。此工厂Bean的属性可以在<a href="#SSLConfiguration">SSL配置</a>的<a href="#ssl.keyStore"><span class="prop" container="ssl">keyStore</span></a>和<a href="#ssl.trustStore"><span class="prop" container="ssl">trustStore</span></a>属性中使用。
      </p>
 
      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>类型</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><span class="prop" container="keyStore">地点</span></td>
          <td><code>String</code></td>
          <td>一个URL，它指定密钥库的位置。用一个<code>file:</code> URL，用于指定密钥库在文件系统上的位置。用一个<code>classpath:</code>用于指定密钥库的URL，该URL可以在类路径中找到。如果网址未指定方案， <code>classpath:</code>假设。</td>
        </tr>
        <tr>
          <td><span class="prop" container="keyStore">密码</span></td>
          <td><code>String</code></td>
          <td>指定访问密钥库所需的密码。</td>
        </tr>
        <tr>
          <td><span class="prop" container="keyStore">提供者</span></td>
          <td><code>String</code></td>
          <td>指定将用于创建JCA的JCA提供程序的名称<code>KeyStore</code> 。如果未配置此属性，则将使用Java平台的默认密钥存储提供程序。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="keyStore">类型</span></td>
          <td><code>String</code></td>
          <td>指定<code>KeyStore</code>类型。请参阅<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/CryptoSpec.html">Java密码体系结构</a>规范中的<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/CryptoSpec.html#AppA">标准名称</a>规范。如果未配置此属性，则将使用Java平台的默认密钥库类型。
          </td>
        </tr>
      </tbody></table>
      
      <h4><a name="KeyManagerFactoryFactoryBean"></a>密钥管理器出厂配置</h4>
          
      <p>的<a href="../xref/ch/qos/logback/core/net/ssl/KeyManagerFactoryFactoryBean.html"><code>KeyManagerFactoryFactoryBean</code></a>指定创建一个所需的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/net/ssl/KeyManagerFactory.html"><code>KeyManagerFactory</code></a> 。通常，由于平台的默认工厂足以满足大多数需求，因此无需显式配置密钥管理器工厂。
      </p>

      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>类型</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><span class="prop" container="keyManagerFactory">算法</span></td>
          <td><code>String</code></td>
          <td>指定<code>KeyManagerFactory</code>算法名称。请参阅《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》</a>中的“ <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#AppA">标准名称”</a>规范。如果未配置此属性，则将使用Java平台的默认密钥管理器算法。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="keyManagerFactory">提供者</span></td>
          <td><code>String</code></td>
          <td>指定将用于创建JCA的JCA提供程序的名称<code>SecureRandom</code>发电机。如果未配置此属性，则将使用Java平台的默认JSSE提供程序。
          </td>
        </tr>
      </tbody></table>

      <h4 class="doAnchor"><a name="SecureRandomFactoryBean"></a>安全随机生成器配置</h4>
          
      <p>的<a href="../xref/ch/qos/logback/core/net/ssl/SecureRandomFactoryBean.html"><code>SecureRandomFactoryBean</code></a>指定创建一个所需的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/security/SecureRandom.html"><code>SecureRandom</code></a>发电机。通常，由于平台的默认生成器足以满足大多数需求，因此无需显式配置安全随机生成器。
      </p>
 
      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>类型</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><span class="prop" container="secureRandom">算法</span></td>
          <td><code>String</code></td>
          <td>指定<code>SecureRandom</code>算法名称。请参阅<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/CryptoSpec.html">Java密码体系结构</a>规范中的<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/CryptoSpec.html#AppA">标准名称</a>规范。如果未配置此属性，则将使用Java平台的默认随机数生成算法。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="secureRandom">提供者</span></td>
          <td><code>String</code></td>
          <td>指定将用于创建JCA的JCA提供程序的名称<code>SecureRandom</code>发电机。如果未配置此属性，则将使用Java平台的默认JSSE提供程序。
          </td>
        </tr>
      </tbody></table>
      
      <h4><a name="SSLParametersConfiguration"></a> SSL参数配置</h4>
          
      <p>的<a href="../xref/ch/qos/logback/core/net/ssl/SSLParametersConfiguration.html"><code>SSLParametersConfiguration</code></a>允许自定义允许的SSL协议，密码套件和客户端身份验证选项。
      </p>

      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>类型</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><a name="parameters.excludedCipherSuites"></a> <span class="prop" container="parameters">排除密码套件</span></td>
          <td><code>String</code></td>
          <td>
            <p>指定在会话协商期间要禁用的SSL密码套件名称或模式的逗号分隔列表。此属性用于过滤SSL引擎支持的密码套件，以便禁用与此属性匹配的所有密码套件。
            </p>
            <p>为此属性指定的逗号分隔列表中的每个字段都可以是简单字符串或正则表达式。
            </p>
            <p>有关密码套件名称的列表，请参见《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》</a>中的“ <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#AppA">标准名称”</a>规范。
            </p>
          </td>
        </tr>
        <tr>
          <td><a name="parameters.includedCipherSuites"></a> <span class="prop" container="parameters">包括密码套件</span></td>
          <td><code>String</code></td>
          <td>
            <p>指定在会话协商期间启用的SSL密码套件名称或模式的逗号分隔列表。此属性用于过滤SSL引擎支持的密码套件，以便仅启用与此属性匹配的那些密码套件。
            </p>
            <p>为此属性指定的逗号分隔列表中的每个字段都可以是简单字符串或正则表达式。
            </p>
            <p>有关密码套件名称的列表，请参见《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》</a>中的“ <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#AppA">标准名称”</a>规范。
            </p>
          </td>
        </tr>
        <tr>
          <td><a name="parameters.excludedProtocols"></a> <span class="prop" container="parameters">排除协议</span></td>
          <td><code>String</code></td>
          <td>
            <p>指定在会话协商期间要禁用的SSL协议名称或模式的逗号分隔列表。此属性用于过滤SSL引擎支持的协议，以便禁用与此属性匹配的任何协议。
            </p>
            <p>为此属性指定的逗号分隔列表中的每个字段都可以是简单字符串或正则表达式。
            </p>
            <p>有关协议名称的列表，请参见《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》</a>中的“ <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#AppA">标准名称”</a>规范。
            </p>
          </td>
        </tr>
        <tr>
          <td><a name="parameters.includedProtocols"></a> <span class="prop" container="parameters">包含的协议</span></td>
          <td><code>String</code></td>
          <td>
            <p>指定在会话协商期间启用的SSL协议名称或模式的逗号分隔列表。此属性用于过滤SSL引擎支持的协议，以便仅启用与此属性匹配的那些协议。
            </p>
            <p>为此属性指定的逗号分隔列表中的每个字段都可以是简单字符串或正则表达式。
            </p>
            <p>有关协议名称的列表，请参见《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》</a>中的“ <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#AppA">标准名称”</a>规范。
            </p>
          </td>
        </tr>
        <tr>
          <td><a name="parameters.needClientAuth"></a> <span class="prop" container="parameters">needClientAuth</span></td>
          <td><code>boolean</code></td>
          <td>将此属性设置为值<code>true</code>配置服务器以<em>要求</em>有效的客户端证书。为客户端组件（例如）配置时，将忽略此属性<code>SSLSocketAppender</code> 。
          </td>
        </tr>
        <tr>
          <td><a name="parameters.wantClientAuth"></a> <span class="prop" container="parameters">wantClientAuth</span></td>
          <td><code>boolean</code></td>
          <td>将此属性设置为值<code>true</code>配置服务器以<em>请求</em>客户端证书。为客户端组件（例如）配置时，将忽略此属性<code>SSLSocketAppender</code> 。
          </td>
        </tr>
      </tbody></table>
      
      <h4><a name="TrustManagerFactoryFactoryBean"></a>信任管理器出厂配置</h4>
          
      <p>的<a href="../xref/ch/qos/logback/core/net/ssl/TrustManagerFactoryFactoryBean.html"><code>TrustManagerFactoryFactoryBean</code></a>指定创建一个所需的配置<a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/net/ssl/TrustManagerFactory.html"><code>TrustManagerFactory</code></a> 。通常，由于平台的默认工厂足以满足大多数需求，因此无需显式配置信任管理器工厂。
      </p>

      <table class="bodyTable striped">
        <tbody><tr>
          <th>物业名称</th>
          <th>类型</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><span class="prop" container="trustManagerFactory">算法</span></td>
          <td><code>String</code></td>
          <td>指定<code>TrustManagerFactory</code>算法名称。请参阅《 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">JSSE参考指南》</a>中的“ <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#AppA">标准名称”</a>规范。如果未配置此属性，则将使用Java平台的默认密钥管理器算法。
          </td>
        </tr>
        <tr>
          <td><span class="prop" container="trustManagerFactory">提供者</span></td>
          <td><code>String</code></td>
          <td>指定将用于创建JCA的JCA提供程序的名称<code>SecureRandom</code>发电机。如果未配置此属性，则将使用Java平台的默认JSSE提供程序。
          </td>
        </tr>
      </tbody></table>
      
      <h2 class="doAnchor"><a name="Examples"></a>例子</h2>

      <h3>使用JSSE系统属性</h3>
      <p>JSSE系统属性可用于为包含服务器X.509凭据的密钥存储指定位置和密码，或为包含客户端组件用来验证服务器的自签名根CA证书的信任存储指定位置和密码。信任。</p>

      <h4>指定服务器的密钥库</h4>
      <p>运行服务器组件时，需要为包含服务器凭据的密钥库指定位置和密码。一种方法是使用JSSE系统属性。以下示例显示了可用于启动<code>SimpleSSLSocketServer</code>随Logback一起提供。</p>
    
      <p class="source">java -DkeyStore = / etc / logback-server-keystore.jks \ -DkeyStorePassword = changeit -DkeyStoreType = JKS \ ch.qos.logback.net。SimpleSSLSocketServer 6000 /etc/logback-server-config.xml</p>
              
      <p>请注意，在使用JSSE <em>keyStore</em>系统属性时，将指定密钥库的路径。在<em>logback.xml中</em>指定位置时，将指定密钥库的URL。</p>
      
      <p>尽管此示例启动了Logback随附的独立服务器应用程序，但是可以指定相同的系统属性来启动任何使用启用了SSL的Logback服务器组件的应用程序。
      
      </p><h4>指定客户的信任库</h4>
      
      <p>使用客户端组件时，需要为信任库指定位置和密码，该信任库包含用于验证服务器信任的根CA证书。一种方法是使用JSSE系统属性。以下示例显示了可用于启动名为的应用程序的命令行<code>com.example.MyLoggingApplication</code>使用一个或多个Logback的启用SSL的客户端组件。</p>

      <p class="source">java -DtrustStore = / etc / logback-client-truststore.jks \ -DtrustStorePassword = changeit -DtrustStoreType = JKS \ com.example。MyLoggingApplication</p>
      
      <p>请注意，在使用JSSE <em>trustStore</em>系统属性时，将指定密钥库的路径。在<em>logback.xml中</em>指定位置时，将指定信任库的URL。</p>
      
      <h3>创建和使用自签名服务器组件凭据</h3>
      <p>要生成自签名证书，可以使用Java Runtime Environment（JRE）附带的<em>keytool</em>实用程序。下面的说明逐步说明了在服务器组件的密钥存储区中创建自签名X.509凭据以及创建与客户端组件一起使用的信任存储区的过程。
      </p>
      
      <h4>创建服务器组件凭证：</h4>
      <p>以下命令将在名为<em>server.keystore</em>的文件中生成自签名客户端证书。</p>
      <pre class="source">keytool -genkey -alias server -dname &quot;CN=my-logging-server&quot; \
    -keyalg RSA -validity 365 -keystore server.keystore
Enter keystore password: &lt;Enter password of your choosing>
Re-enter new password: &lt;Re-enter same password>
Enter key password for &lt;my-logging-server>
	(RETURN if same as keystore password):  &lt;Press RETURN>
</pre>

      <p><em>dname中</em>使用的名称<em>my-logging-server</em>可以是您选择的任何有效名称。您可能希望使用服务器主机的标准域名。<em>有效性</em>参数指定从当前日期到证书过期的日历天数。</p>
      
      <p>在生产设置中，为包含服务器凭据的密钥存储区选择一个强密码特别重要。此密码可保护服务器的私钥，防止被授权方使用。记下该密码，因为在后续步骤和配置服务器时将需要该密码。
      </p>

      <h4>为客户端组件创建信任库：</h4>
      <p>为了在客户端组件的配置中使用，需要从上一步中创建的密钥存储中导出服务器的证书，并将其导入信任存储中。以下命令将导出证书，并将其导入名为<em>server.truststore</em>的信任库中。</p>
      
      <pre class="source">keytool -export -rfc -alias server -keystore server.keystore \
    -file server.crt
Enter keystore password: &lt;Enter password you chose for in previous step>

keytool -import -alias server -file server.crt -keystore server.truststore
Enter keystore password: &lt;Enter password of your choosing>
Re-enter new password: &lt;Re-enter same password>
Owner: CN=my-logging-server
Issuer: CN=my-logging-server
Serial number: 6e7eea40
Valid from: Sun Mar 31 07:57:29 EDT 2013 until: Mon Mar 31 07:57:29 EDT 2014

   ...

Trust this certificate? [no]:  &lt;Enter "yes">
</pre>

      <p>第一个命令从密钥存储区导出服务器的证书（而不是服务器的私钥），并将其导出到名为<em>server.crt</em>的文件中。第二步创建一个包含服务器证书的名为<em>server.truststore</em>的新信任库。
      </p>
      
      <p>在生产设置中，为信任存储区选择一个与您从服务器密钥存储区选择的密码不同的强密码特别重要。记下该密码，因为在配置附加程序客户端时将需要它。
      </p>
          
      <h4>配置服务器组件：</h4>
      <p>您将需要将<em>server.keystore</em>文件复制到服务器应用程序的配置中。可以将密钥库与应用程序的类路径资源一起放置，也可以仅将其存储在服务器主机的文件系统上的某个位置。在配置中指定密钥存储的位置时，您将使用<code>classpath:</code>网址或<code>file:</code> URL（视情况而定）。服务器配置示例如下：</p>

      <p class="example">示例：服务器组件配置</p>
      <pre class="prettyprint source">&lt;configuration debug="true">
  &lt;appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
  
  &lt;root level="DEBUG">
    &lt;appender-ref ref="CONSOLE" />
  &lt;/root>

  &lt;server class="ch.qos.logback.classic.net.server.SSLServerSocketReceiver">
    &lt;ssl>
      &lt;keyStore>
        &lt;location>classpath:server.keystore&lt;/location>
        &lt;password>${server.keystore.password}&lt;/password>
      &lt;/keyStore>
    &lt;/ssl>
  &lt;/server>
&lt;/configuration></pre>
      
      <p>本示例假定密钥库位于应用程序的类路径的根目录下。</p>
      
      <p>请注意，此配置使用<em>server.keystore.password</em>替换变量指定密钥存储区密码。这种方法将使您避免将密码存储在任何配置文件中。例如，您的应用程序可以在启动时在控制台上提示输入此密码，然后在配置日志记录系统之前使用输入的密码将<em>server.keystore.password</em>设置为系统属性。
      </p>
      
      <h4>配置客户端组件：</h4>
      <p>您需要将<em>server.truststore</em>文件复制到每个使用在客户端模式下启用SSL的组件的应用程序的应用程序配置中。信任库可以与应用程序的类路径资源一起放置，也可以简单地放置在文件系统上的某个位置。在配置中指定信任库的位置时，可以使用<code>classpath:</code>网址或<code>file:</code> URL（视情况而定）。示例追加器客户端配置如下：</p>

      <p class="example">示例：Appender客户端配置</p>

      <pre class="prettyprint source">&lt;configuration debug="true">
  &lt;appender name="SOCKET" class="ch.qos.logback.classic.net.SSLSocketAppender">
    &lt;remoteHost>${host}&lt;/remoteHost>
    &lt;ssl>
      &lt;trustStore>
        &lt;location>classpath:server.truststore&lt;/location>
        &lt;password>${server.truststore.password}&lt;/password>
      &lt;/trustStore>
    &lt;/ssl>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="SOCKET" />
  &lt;/root>
&lt;/configuration></pre>

      <p>此示例假定信任存储位于应用程序的类路径的根目录下。</p>
      
      <p>请注意，此配置使用<em>server.truststore.password</em>替换变量指定信任库密码。这种方法将使您避免将密码存储在任何配置文件中。例如，您的应用程序可以在启动时在控制台上提示输入此密码，然后在配置日志记录系统之前使用输入的密码将<em>server.truststore.password</em>设置为系统属性。
      </p>

      <h2>审核SSL配置</h2>
      <p>在需要安全通信的环境中，通常有必要审核使用SSL的组件的配置，以验证与本地安全策略的符合性。Logback中的SSL支持通过在初始化Logback时提供SSL配置的详细日志来满足此需求。您可以使用<code>debug</code>配置中的属性：</p>
      
      <pre class="prettyprint source">&lt;configuration debug="true">
  
  ...
  
&lt;/configuration></pre>

      <p>启用debug属性后，初始化日志记录系统时，将记录结果SSL配置的所有相关方面。以下是为SSL记录的信息的代表性示例。</p>
      
      <p class="example">示例：SSL配置审核日志记录</p>
      
      <pre>06:46:31,941 |-INFO in SSLServerSocketReceiver@4ef18d37 - SSL protocol 'SSL' provider 'SunJSSE version 1.6'
06:46:31,967 |-INFO in SSLServerSocketReceiver@4ef18d37 - key store of type 'JKS' provider 'SUN version 1.6': file:src/main/java/chapters/appenders/socket/ssl/keystore.jks
06:46:31,967 |-INFO in SSLServerSocketReceiver@4ef18d37 - key manager algorithm 'SunX509' provider 'SunJSSE version 1.6'
06:46:31,973 |-INFO in SSLServerSocketReceiver@4ef18d37 - secure random algorithm 'SHA1PRNG' provider 'SUN version 1.6'
06:46:32,755 |-INFO in SSLParametersConfiguration@4a6f19d5 - enabled protocol: SSLv2Hello
06:46:32,755 |-INFO in SSLParametersConfiguration@4a6f19d5 - enabled protocol: SSLv3
06:46:32,755 |-INFO in SSLParametersConfiguration@4a6f19d5 - enabled protocol: TLSv1
06:46:32,756 |-INFO in SSLParametersConfiguration@4a6f19d5 - enabled cipher suite: SSL_RSA_WITH_RC4_128_MD5
06:46:32,756 |-INFO in SSLParametersConfiguration@4a6f19d5 - enabled cipher suite: SSL_RSA_WITH_RC4_128_SHA
06:46:32,756 |-INFO in SSLParametersConfiguration@4a6f19d5 - enabled cipher suite: TLS_RSA_WITH_AES_256_CBC_SHA
</pre>

      <p>为简洁起见，此处显示的输出已被截断，但通常将包括协议，提供程序，算法和密码套件的完整列表，以及配置中使用的密钥存储和信任存储资源的位置。
      </p>
      
      <p>虽然这些审核日志记录都不是特别敏感，但是安全性最佳实践建议，在验证配置之后，不应在生产设置中保持启用此日志记录。当<code>debug</code>属性已删除或设置为<code>false</code> 。
      </p>
      
      <h2>解决SSL异常</h2>
      <p>如果SSL配置不正确，通常会导致客户端和服务器组件无法协商同意的会话。当客户端尝试连接到服务器时，该问题通常表现为双方都抛出异常。
      </p>
      <p>异常消息的内容取决于您是查看客户端日志还是服务器日志。这主要是由于会话协商期间错误报告中固有的协议限制。因此，为了解决会话协商问题，通常需要查看客户端和服务器的日志。
      </p>
      
      <h3>服务器的证书不可用</h3>
      <p>启动服务器组件时，您会在日志中看到以下异常：</p>
         
      <p><em>javax.net.ssl。SSLException：没有可用的证书或密钥与启用的SSL密码套件相对应</em>
      </p>
      
      <p>在大多数情况下，这意味着您尚未配置包含服务器的私钥和相应证书的密钥库的位置。
      </p>
      
      <h4>解</h4>
      <p>使用<a href="#basicConfig.keyStore">密钥库系统属性</a>或服务器组件的<span class="prop">ssl</span>属性的<a href="#ssl.keyStore"><span class="prop">keyStore</span></a>属性，必须为包含服务器的私钥和证书的密钥库指定位置和密码。
      </p>
      
      <h3>客户端不信任服务器</h3>
      <p>当客户端尝试连接到服务器时，您会在日志中看到以下异常：</p>
      
      <p><em>javax.net.ssl。SSLHandshakeException：sun.security.validator。ValidatorException：PKIX路径构建失败</em>
      </p>
      <p>此问题是服务器出示客户端不信任的证书的结果。最常见的原因是您使用的是自签名服务器证书（或由组织的内部证书颁发机构签名的服务器证书），并且尚未配置客户端，以便客户端引用包含服务器自签名的信任库。证书（或签署服务器证书的CA的受信任的根证书）。
      </p> 
      <p>如果您的服务器证书已过期或已被吊销，也会发生此问题。如果您有权访问服务器日志，则每次客户端尝试连接时，您可能会看到记录以下异常：</p>
      
      <p><em>javax.net.ssl。SSLHandshakeException：收到致命警报：...</em>
      </p>
      
      <p>异常消息的其余部分通常将提供一个代码，指示客户端为什么拒绝服务器的证书。
      </p>
      <table class="bodyTable striped">
        <tbody><tr>
          <th>码</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><code>certificate_unknown</code></td>
          <td>通常指示客户端的信任库未正确配置。
          </td>
        </tr>
        <tr>
          <td><code>certificate_expired</code></td>
          <td>表示服务器的证书已过期，需要更换。
          </td>
        </tr>
        <tr>
          <td><code>certificate_revoked</code></td>
          <td>表示发行证书颁发机构（CA）吊销了服务器的证书，并且该证书需要更换。
          </td>
        </tr>
      </tbody></table>
        
      <h4>解决方案</h4>
      <p>如果服务器的日志消息正在报告<code>certificate_unknown</code>然后，必须使用附加组件的<span class="prop">ssl</span>属性的信任库<a href="#basicConfig.trustStore">系统属性</a>或<a href="#ssl.trustStore"><span class="prop">trustStore</span></a>属性，您必须指定包含服务器的自签名证书或颁发证书颁发机构的根证书的信任库的位置和密码。
      </p>

      <p>如果服务器的日志消息正在报告<code>certificate_expired</code>要么<code>certificate_revoked</code>服务器需要新证书。需要将新证书和关联的私钥放置在服务器配置中指定的密钥存储区中。并且，如果使用自签名服务器证书，则还需要将服务器的证书放置在附加器客户端配置中指定的信任存储中。
      </p>
      
      <h3>服务器不信任客户端</h3>
      <p>注意： <strong>仅当您已明确配置服务器以请求客户端证书（使用<a href="#parameters.needClientAuth"><span class="prop">needClientAuth</span></a>或<a href="#parameters.wantClientAuth"><span class="prop">wantClientAuth</span></a>属性）时，才会出现此问题</strong> 。
      </p>
 
      <p>当客户端尝试连接到日志服务器时，您会在客户端的日志中看到以下异常：</p>
      
      <p><em>javax.net.ssl。SSLHandshakeException：收到致命警报：...</em>
      </p>

      <p>异常消息的其余部分通常将提供指示服务器为什么拒绝客户端证书的代码。
      </p>
      <table class="bodyTable striped">
        <tbody><tr>
          <th>码</th>
          <th>描述</th>
        </tr>
        <tr>
          <td><code>certificate_unknown</code></td>
          <td>通常表示服务器的信任库未正确配置。
          </td>
        </tr>
        <tr>
          <td><code>certificate_expired</code></td>
          <td>表示客户端的证书已过期，需要更换。
          </td>
        </tr>
        <tr>
          <td><code>certificate_revoked</code></td>
          <td>表示签发证书颁发机构（CA）吊销了客户的证书，并且该证书需要更换。
          </td>
        </tr>
      </tbody></table>
        
      <h4>解决方案</h4>
      <p>如果客户端的日志消息正在报告<code>bad_certificate</code>然后必须使用<a href="#basicConfig.trustStore">信任库系统属性</a>或服务器组件<span class="prop">ssl</span>属性的<a href="#ssl.trustStore"><span class="prop">trustStore</span></a>属性，为包含客户端的自签名证书或颁发证书颁发机构的根证书的信任库指定位置和密码。
      </p>

      <p>如果服务器的日志消息正在报告<code>certificate_expired</code>要么<code>certificate_revoked</code>客户需要新证书。新证书和关联的私钥需要放置在客户端配置中指定的密钥存储中。并且，如果使用自签名客户端证书，则还需要将客户端的证书放置在服务器配置中指定的信任存储中。
      </p>
      
      <h3>客户端和服务器无法同意协议</h3>
      <p>注意： <strong>通常，仅当您在配置中明确<a href="#parameters.excludedProtocols">排除</a>或<a href="#parameters.includedProtocols">包括</a> SSL协议时，才会发生此问题</strong> 。
      </p>

      <p>当客户端尝试连接到服务器时，您会在日志中看到以下异常：</p>
      
      <p><em>javax.net.ssl。SSLHandshakeException：收到致命警报：handshake_failure</em>
      </p>
      
      <p>服务器的日志消息通常更具描述性。例如：</p>
      
      <p><em>javax.net.ssl。SSLHandshakeException：SSLv2Hello已禁用</em>
      </p>
      
      <p>通常，这意味着您已从一个对等方而不是另一个对等方排除了协议。</p>
         
      <h4>解</h4>
      <p>检查为服务器和客户端上的<a href="#parameters.excludedProtocols"><span class="prop">excludedProtocols</span></a>和<a href="#parameters.includedProtocols"><span class="prop">includedProtocols</span></a>属性指定的值。
      </p>

      <h3>客户端和服务器无法同意密码套件</h3>
      <p>注意： <strong>仅当您在配置中明确<a href="#parameters.excludedCipherSuites">排除</a>或<a href="#parameters.includedCipherSuites">包括</a> SSL密码套件时，才会发生此问题</strong> 。
      </p>
      
      <p>当客户端尝试连接到服务器时，您会在日志中看到以下异常：</p>
      
      <p><em>javax.net.ssl。SSLHandshakeException：收到致命警报：handshake_failure</em>
      </p>
      
      <p>服务器的日志消息通常更具描述性：</p>
      
      <p><em>javax.net.ssl。SSLHandshakeException：没有通用的密码套件</em>
      </p>
      
      <p>这意味着您已经在服务器和客户端上配置了密码套件，以使它们各自的启用密码套件集的交集为空。</p>
      
      <h4>解</h4>
      <p>检查为服务器和客户端上的<a href="#parameters.excludedCipherSuites"><span class="prop">excludeCipherSuites</span></a>和<a href="#parameters.includedCipherSuites"><span class="prop">includedCipherSuites</span></a>属性指定的值。
      </p>
         
      <script src="../templates/footer.js" type="text/javascript"></script>

    </div>
  
</body></html>