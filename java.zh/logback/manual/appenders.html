<html  xmlns="http://www.w3.org/1999/xhtml"><head></head><body  onload="prettyPrint(); decorate();">﻿
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第4章：追加者</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">    
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">      
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>    
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>

    <div id="content">

    <h1>第4章：追加者</h1>

    <a href="appenders_ja.html">和訳（日语翻译）</a>


    <div class="quote">

      <p><em>那天对西方国家有太多要说的，所以很难知道从哪里开始。一件事引发了另外一百件事。问题在于决定先告诉哪个。</em></p>
  
      <p>—伊恩<em>以东的</em>约翰·斯坦贝克</p>
    </div>


    <script src="../templates/creative.js" type="text/javascript"></script>
    <script src="../templates/setup.js" type="text/javascript"></script>
    
    <h2 class="doAnchor" name="whatIsAnAppender">什么是Appender？</h2>
    
		<p>Logback将编写日志记录事件的任务委派给称为附加程序的组件。申请者必须执行<a href="../xref/ch/qos/logback/core/Appender.html"><code>ch.qos.logback.core.Appender</code></a>接口。该接口的主要方法总结如下：</p>
		<pre class="prettyprint source">package ch.qos.logback.core;
  
import ch.qos.logback.core.spi.ContextAware;
import ch.qos.logback.core.spi.FilterAttachable;
import ch.qos.logback.core.spi.LifeCycle;
  

public interface Appender&lt;E> extends LifeCycle, ContextAware, FilterAttachable {

  public String getName();
  public void setName(String name);
  <b>void doAppend(E event);</b>
  
}</pre>

	<p>大部分方法<code>Appender</code>接口是setter和getter。一个明显的例外是<code>doAppend()</code>方法，将类型<em>E</em>的对象实例作为其唯一参数。<em>E</em>的实际类型将取决于登录模块。在经典的<a href="../apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">backback</a>模块中， <em>E</em>将为<a href="../apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">ILoggingEvent</a>类型；在经典的logback-access模块中，它将为<a href="../apidocs/ch/qos/logback/access/spi/AccessEvent.html">AccessEvent</a>类型。的<code>doAppend()</code>方法可能是logback框架中最重要的方法。它负责以适当的格式将日志记录事件输出到适当的输出设备。
  </p>

  <p>追加者被称为实体。这样可以确保可以按名称引用它们，这种质量在配置脚本中被证明是有用的。的<code>Appender</code>接口扩展了<code>FilterAttachable</code>接口。因此，可以将一个或多个过滤器附加到附加程序实例。过滤器将在下一章中详细讨论。
	</p>
	
	<p>Appender最终负责输出日志记录事件。但是，他们可以将事件的实际格式委托给<code>Layout</code>或到<code>Encoder</code>宾语。每个布局/编码器都与一个且只有一个附加程序（称为拥有附加程序）相关联。一些附加程序具有内置或固定的事件格式。因此，它们不需要布局/编码器。例如， <code>SocketAppender</code>只需序列化日志事件，然后再通过网络传输它们即可。
	</p>
	
	
	<h2 class="doAnchor" name="AppenderBase">AppenderBase</h2>
	
	<p>的<a href="../xref/ch/qos/logback/core/AppenderBase.html"><code>ch.qos.logback.core.AppenderBase</code></a>类是实现<code>Appender</code>接口。它提供了所有附加程序共享的基本功能，例如获取或设置其名称的方法，其激活状态，其布局和其过滤器。它是Logback附带的所有附加程序的超类。虽然是抽象类<code>AppenderBase</code>实际上实现了<code>doAppend()</code>中的方法<code>Append</code>接口。也许是最清晰的讨论方式<code>AppenderBase</code>该类是通过提供实际源代码的摘录。
	</p>
	
<pre class="prettyprint source">public synchronized void doAppend(E eventObject) {

  // prevent re-entry.
  if (guard) {
    return;
  }

  try {
    guard = true;

    if (!this.started) {
      if (statusRepeatCount++ &lt; ALLOWED_REPEATS) {
        addStatus(new WarnStatus(
            "Attempted to append to non started appender [" + name + "].",this));
      }
      return;
    }

    if (getFilterChainDecision(eventObject) == FilterReply.DENY) {
      return;
    }
    
    // ok, we now invoke the derived class's implementation of append
    this.append(eventObject);

  } finally {
    guard = false;
  }
}</pre>
	
	<p>这个实现<code>doAppend()</code>方法已同步。因此，从不同的线程登录到同一追加程序是安全的。当一个线程（例如<em>T</em> ）正在执行<code>doAppend()</code>方法，其他线程的后续调用将排队，直到<em>T</em>离开<code>doAppend()</code>方法，确保<em>T</em>独占访问附加程序。
	</p>

  <p>由于这种同步并非总是合适的，因此logback附带<a href="../xref/ch/qos/logback/core/UnsynchronizedAppenderBase.html"><code>ch.qos.logback.core.UnsynchronizedAppenderBase</code></a>这与<a href="../xref/ch/qos/logback/core/AppenderBase.html"><code>AppenderBase</code></a>类。为了简洁起见，我们将讨论<code>UnsynchronizedAppenderBase</code>在本文档的其余部分。
  </p>


  <p>第一件事<code>doAppend()</code>方法所做的是检查防护措施是否设置为true。如果是，它将立即退出。如果未设置防护，则在下一条语句中将其设置为true。警卫确保<code>doAppend()</code>方法不会递归地调用自身。试想一下，一个组件，在<code>append()</code>方法，想记录一些东西。它的调用可能直接指向刚刚调用它的附加程序，从而导致无限循环和堆栈溢出。
	</p>
	
	<p>在下面的语句中，我们检查<code>started</code>字段为真。如果不是， <code>doAppend()</code>将发送警告消息并返回。换句话说，一旦关闭了附加器，就无法对其进行写入。 <code>Appender</code>对象实现<code>LifeCycle</code>接口，这意味着它们实现了<code>start()</code> ， <code>stop()</code>和<code>isStarted()</code>方法。设置附加程序的所有属性后，logback的配置框架Joran调用<code>start()</code>通知附加程序激活其属性的方法。根据其种类，如果缺少某些属性或由于各种属性之间的干扰，追加程序可能无法启动。例如，假设文件创建取决于截断模式， <code>FileAppender</code>不能根据其价值行事<code>File</code>直到Append选项的值也被确定为止。显式激活步骤可确保在知道属性值<em>后</em> ，附加程序对其属性<em>进行操作</em> 。
	</p>
	
	<p>如果追加器无法启动或已停止，则将通过logback的内部状态管理系统发出警告消息。经过多次尝试，为避免内部状态系统被相同警告消息的副本淹没， <code>doAppend()</code>方法将停止发出这些警告。
  </p>

	<p>下一个<code>if</code>语句检查附加过滤器的结果。根据过滤器链产生的决定，事件可以被拒绝或明确接受。如果过滤器链没有做出决定，则默认情况下会接受事件。
	</p>
	
	<p>的<code>doAppend()</code>然后，该方法调用派生类的实现<code>append()</code>方法。此方法完成了将事件附加到适当设备的实际工作。
	</p>
	
  <p>最后，释放防护装置，以允许随后调用<code>doAppend()</code>方法。
  </p>

	<p>在本手册的其余部分中，对于通过setter和getter方法使用JavaBeans自省功能动态推断出的任何属性，我们都保留术语“选项”或“属性”。</p>
	
	<h1>Logback核心</h1>
	
	<p>Logback-core为构建其他logback模块奠定了基础。通常，logback-core中的组件需要一些（尽管最少）自定义。但是，在接下来的几节中，我们将介绍几个可以直接使用的附加程序。
  </p>


	
	<h2 class="doAnchor" name="OutputStreamAppender">OutputStreamAppender</h2>
	
	<p><a href="../xref/ch/qos/logback/core/OutputStreamAppender.html"><code>OutputStreamAppender</code></a>将事件附加到<code>java.io.OutputStream</code> 。此类提供其他附加程序所基于的基本服务。用户通常不实例化<code>OutputStreamAppender</code>直接反对，因为通常<code>java.io.OutputStream</code>类型无法方便地映射到字符串，因为无法指定目标<code>OutputStream</code>配置脚本中的对象。简而言之，您无法配置<code>OutputStreamAppender</code>从配置文件。但是，这并不意味着<code>OutputStreamAppender</code>缺乏可配置的属性。接下来将描述这些属性。
	</p>
	
  <table class="bodyTable striped">
    <tbody><tr>
      <th>物业名称</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
    
    <tr>
      <td><span class="prop" name="osaEncoder">编码器</span></td>

      <td><a href="../xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a></td>

      <td>确定将事件写入基础的方式<code>OutputStreamAppender</code> 。编码器在<a href="encoders.html">专门的章节中介绍</a> 。
			</td>
    </tr>
   <tr>
     <td><span class="prop" name="immediateFlush">立即冲洗</span></td>
     <td><code>boolean</code></td>
     
     <td>对于<span class="option">immediateFlush</span>的默认值是“真”。立即刷新输出流可确保立即写出日志记录事件，并且在您的应用程序未正确关闭附加程序而退出的情况下也不会丢失。另一方面，将此属性设置为'false'可能会使日志记录吞吐量增加四倍（您的里程可能会有所不同）。同样，如果将<span class="option">InstantFlush</span>设置为“ false”，并且在应用程序退出时未正确关闭附加程序，则尚未写入磁盘的日志记录事件可能会丢失。
     </td>
    </tr>
	
	
	</tbody></table>
    
  <p>的<code>OutputStreamAppender</code>是其他三个附加器的超类，即<code>ConsoleAppender</code> ， <code>FileAppender</code>反过来又是<code>RollingFileAppender</code> 。下图说明了该类的类图<code>OutputStreamAppender</code>及其子类。
	</p>
	
	<img src="images/chapters/appenders/appenderClassDiagram.jpg" alt="显示OutputStreamAppender和子类的UML图">
	

	<h2 class="doAnchor" name="ConsoleAppender">ConsoleAppender</h2>
	
  <p>的<a href="../xref/ch/qos/logback/core/ConsoleAppender.html"><code>ConsoleAppender</code></a> ，顾名思义，追加在控制台上，或更确切地说追加在<em>System.out</em>或<em>System.err上</em> ，前者是默认目标。 <code>ConsoleAppender</code>在用户指定的编码器的帮助下格式化事件。编码器将在下一章中讨论。<em>System.out</em>和<em>System.err</em>均为类型<code>java.io.PrintStream</code> 。因此，它们被包裹在一个<code>OutputStreamWriter</code>缓冲I / O操作。
	</p>
	
	<table class="bodyTable striped">
			<tbody><tr>
			<th>物业名称</th>
			<th>类型</th>
			<th>描述</th>
		</tr>
		<tr>
			<td><span class="prop" container="conApp">编码器</span></td>
      <td>
        <a href="../xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a>
      </td>
			<td>看到<code>OutputStreamAppender</code>属性。</td>
		</tr>
		<tr>
			<td><span class="prop" container="conApp">目标</span></td>
			<td><code>String</code></td>
			<td>字符串值之一<em>System.out</em>或<em>System.err</em> 。默认目标是<em>System.out</em> 。
			</td>
		</tr>

		<tr>
			<td><span class="prop" container="conApp">与简思</span></td>
			<td><code>boolean</code></td>
			<td>默认情况下， <span class="prop">withJansi</span>属性设置为<code>false</code> 。设置<span class="prop">withJansi</span>到<code>true</code>激活<a href="http://jansi.fusesource.org/">Jansi</a>库，该库为Windows计算机上的ANSI颜色代码提供支持。在Windows主机上，如果将此属性设置为true，则应在类路径上放置“ org.fusesource.jansi：jansi：1.17”。请注意，默认情况下，基于Unix的操作系统（例如Linux和Mac OS X）支持ANSI颜色代码。

      <p>在Eclipse IDE下，您可能想尝试<a href="http://www.mihai-nita.net/eclipse/">Eclipse Console</a>插件中的<a href="http://www.mihai-nita.net/eclipse/">ANSI</a> 。
      </p>
			</td>
		</tr>

	</tbody></table>
	
	<p>这是使用的示例配置<code>ConsoleAppender</code> 。
	</p>



  <p class="example">示例：ConsoleAppender配置（logback-examples / src / main / resources / chapters / appenders / conf / logback-Console.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('logback_Console');">观看为.groovy</span>

  <pre id="logback_Console" class="prettyprint source">&lt;configuration>

  <b>&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender></b>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

   <p>在将当前路径设置为<em>logback-examples</em>目录并<a href="../setup.html">设置类路径后</a> ，可以通过发出以下命令来对上述配置文件进行旋转：</p>

   <p class="source">Java <a href="../xref/chapters/appenders/ConfigurationTester.html">chapters.appenders。ConfigurationTester</a> src / main / java / chapters / appenders / conf / logback-Console.xml</p>
	
	
   <h2 class="doAnchor" name="FileAppender">FileAppender</h2>
	
   <p>的<a href="../xref/ch/qos/logback/core/FileAppender.html"><code>FileAppender</code></a> ，是的子类<code>OutputStreamAppender</code> ，将日志事件附加到文件中。目标文件由“ <span class="prop">文件”</span>选项指定。如果文件已经存在，则将其追加或截断，具体取决于<span class="prop">append</span>属性的值。
   </p>
	
   <table class="bodyTable properties striped">
     <tbody><tr>
       <th>物业名称</th>
       <th>类型</th>
       <th>描述</th>
     </tr>
     <tr>
       <td><span class="prop" container="fileApppender">附加</span></td>
       <td><code>boolean</code></td>
       <td>如果为true，则事件将附加到现有文件的末尾。否则，如果<span class="prop">append</span>为false，则任何现有文件都会被截断。默认情况下， <span class="option">append</span>选项设置为true。
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="fileApppender">编码器</span></td>
       <td>
         <a href="../xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a>
       </td>
       <td>看到<code>OutputStreamAppender</code>属性。</td>
     </tr>
    
   
     <tr>
       <td><span class="prop" container="fileApppender">文件</span></td>
       <td><code>String</code></td>
       <td>要写入的文件名。如果该文件不存在，则会创建它。在MS Windows平台上，用户经常忘记转义反斜杠。例如，值<em>c：\ temp \ test.log</em>不太可能正确解释，因为<em>'\ t'</em>是解释为单个制表符<em>（\ u0009）</em>的转义序列。可以将正确值指定为<em>c：/temp/test.log，</em>也可以指定为<em>c：\\ temp \\ test.log</em> 。<span class="prop">File</span>选项没有默认值。

       <p>如果文件的父目录不存在， <code>FileAppender</code>会自动创建它，包括任何必要但不存在的父目录。
       </p>
       </td>
     </tr>

     <tr>
       <td><span class="prop" name="prudent">谨慎</span></td>
       <td><code>boolean</code></td>

       <td>在谨慎模式下， <code>FileAppender</code>将安全地写入指定的文件，即使存在其他文件<code>FileAppender</code>实例在不同的JVM中运行，可能在不同的主机上运行。谨慎模式的默认值为<code>false</code> 。

         <p>谨慎模式可与<code>RollingFileAppender</code>尽管有一些<a href="#prudentWithRolling">限制</a> 。</p>

         <p>谨慎模式表示<span class="prop">append</span>属性会自动设置为true。
         </p>

         <p>谨慎地更多地使用排他文件锁。实验表明，文件锁定写入日志事件的成本大约是三倍（x3）。在“平均” PC上，如果写入<b>本地</b>硬盘上的文件，则在谨慎模式关闭时，大约需要10微秒的时间来写入单个日志记录事件。谨慎模式打开时，大约需要30微秒来输出单个日志记录事件。这意味着在关闭谨慎模式时，日志记录吞吐量为每秒100'000个事件，而在谨慎模式下，日志吞吐量约为每秒33'000个事件。
         </p>

         <p>谨慎模式有效地序列化了所有写入同一文件的JVM之间的I / O操作。因此，随着竞争访问文件的JVM数量的增加，每个I / O操作所引起的延迟也会增加。只要I / O操作的<em>总数</em>约为每秒20个日志请求，那么对性能的影响应该可以忽略不计。每秒产生100个或更多I / O操作的应用程序可能会对性能产生影响，因此应避免使用<span class="prop">审慎</span>模式。
         </p>

         <p><span class="label">联网文件锁定</span>当日志文件位于联网文件系统上时，谨慎模式的代价更大。同样重要的是，有时会强烈偏重网络文件系统上的文件锁，以使当前拥有该锁的进程在释放锁后立即重新获得该锁。因此，尽管一个进程为日志文件锁定了锁，但其他进程却饿死了，等待锁出现僵局。
         </p>
         
         <p>谨慎模式的影响高度取决于网络速度以及操作系统的实现细节。我们提供了一个名为<a href="https://gist.github.com/2794241">FileLockSimulator</a>的非常小的应用程序，它可以帮助您模拟环境中谨慎模式的行为。
         </p>


       </td>
       
     </tr>
   </tbody></table>
	
   <p><span class="label notice">立即刷新</span>默认情况下，每个日志事件都会立即刷新到基础输出流。从某种意义上说，这种默认方法更安全，因为在您的应用程序未正确关闭附加程序的情况下退出时，不会丢失日志记录事件。但是，为了显着提高日志记录吞吐量，您可能需要将<span class="prop">InstantFlush</span>属性设置为<code>false</code> 。</p>

   <p>下面是一个配置文件示例<code>FileAppender</code> ：</p>

   <p class="example">示例：FileAppender配置（logback-examples / src / main / resources / chapters / appenders / conf / logback-fileAppender.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-fileAppender');">观看为.groovy</span>
   <pre id="logback-fileAppender"  class="prettyprint source">&lt;configuration>

  <b>&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;file>testFile.log&lt;/file>
    &lt;append>true&lt;/append>
    &lt;!-- set immediateFlush to false for much higher logging throughput -->
    &lt;immediateFlush>true&lt;/immediateFlush>
    &lt;!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender></b>
	
  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

   <p>将当前目录更改为<em>logback-examples后</em> ，通过启动以下命令来运行此示例：</p>
	
   <p class="source">Java chapters.appenders。ConfigurationTester src / main / java / chapters / appenders / conf / logback-fileAppender.xml</p>
	
	
   <h3 class="doAnchor" name="uniquelyNamed">唯一命名的文件（按时间戳记）</h3>
   
   <p>在应用程序开发阶段或短期应用程序（例如批处理应用程序）的情况下，希望在每次启动新应用程序时创建一个新的日志文件。这是很容易做到的<code><timestamp></code>元件。这是一个例子。</p>


   <p class="example">示例：按时间戳唯一命名的FileAppender配置（logback-examples / src / main / resources / chapters / appenders / conf / logback-timestamp.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-timestamp');">观看为.groovy</span>
   <pre id="logback-timestamp" class="prettyprint source">&lt;configuration>

  &lt;!-- Insert the current time formatted as "yyyyMMdd'T'HHmmss" under
       the key "bySecond" into the logger context. This value will be
       available to all subsequent configuration elements. -->
  <b>&lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/></b>

  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;!-- use the previously created timestamp to create a uniquely
         named log file -->
    &lt;file><b>log-${bySecond}.txt</b>&lt;/file>
    &lt;encoder>
      &lt;pattern>%logger{35} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>


   <p>timestamp元素具有两个必需属性<span class="attr">key</span>和<span class="attr">datePattern</span>以及一个可选的<span class="attr">timeReference</span>属性。<span class="attr">key</span>属性是<span class="attr">密钥</span>的名称，在该名称下时间戳可<a href="configuration.html#variableSubstitution">作为变量</a>提供给后续配置元素。<span class="attr">datePattern</span>属性表示用于将当前时间（解析配置文件的时间）转换为字符串的日期模式。日期模式应遵循<a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat中</a>定义的约定。<span class="attr">timeReference</span>属性表示时间戳的时间参考。默认值为配置文件的解释/解析时间，即当前时间。但是，在某些情况下，使用上下文出生时间作为时间参考可能会很有用。这可以通过将<span class="attr">timeReference</span>属性设置为<code>"contextBirth"</code> 。
   </p>

   <p>试用<code><timestamp></code>元素，通过运行以下命令：</p>

   <p class="command">Java chapters.appenders。ConfigurationTester src / main / resources / chapters / appenders / conf / logback-timestamp.xml</p>

   <p>要将记录器上下文的出生日期用作时间参考，您可以将<span class="attr">timeReference</span>属性设置为“ contextBirth”，如下所示。</p>


   <p class="example">示例：使用上下文出生日期作为时间参考的时间戳（logback-examples / src / main / resources / chapters / appenders / conf / logback-timestamp-contextBirth.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-timestamp-contextBirth');">观看为.groovy</span>   
   <pre id="logback-timestamp-contextBirth" class="prettyprint source">&lt;configuration>
  &lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss" 
             <b>timeReference="contextBirth"</b>/>
  ...
&lt;/configuration></pre>

   <h2 class="doAnchor" name="RollingFileAppender">RollingFileAppender</h2>
   
   <p><a href="../xref/ch/qos/logback/core/rolling/RollingFileAppender.html"><code>RollingFileAppender</code></a>延伸<code>FileAppender</code>具有翻转日志文件的功能。例如， <code>RollingFileAppender</code>可以登录到名为<em>log.txt的</em>文件，一旦满足特定条件，就可以将其记录目标更改为另一个文件。
   </p>
     
   <p>有两个重要的子组件与之交互<code>RollingFileAppender</code> 。首先<code>RollingFileAppender</code>子组件，即<code>RollingPolicy</code> ，（ <a href="#onRollingPolicies">请参阅下文</a> ）负责执行过渡所需的操作。的第二个子组件<code>RollingFileAppender</code> ，即<code>TriggeringPolicy</code> ，（ <a href="#TriggeringPolicy">请参阅下文</a> ）将确定是否以及何时准确发生过渡。从而， <code>RollingPolicy</code>对<em>什么</em>负责<code>TriggeringPolicy</code>负责<em>什么时候</em> 。</p>
	
   <p>为了有用， <code>RollingFileAppender</code>必须同时具有<code>RollingPolicy</code>和一个<code>TriggeringPolicy</code>设定。但是，如果<code>RollingPolicy</code>还实现了<code>TriggeringPolicy</code>接口，则只需明确指定前者即可。
   </p>
	
   <p>以下是的可用属性<code>RollingFileAppender</code> ：</p>
	
   <table class="bodyTable striped">
     <tbody><tr>
       <th>物业名称</th>
       <th>类型</th>
       <th>描述</th>
     </tr>
     <tr>
       <td><span class="prop" container="rfa">文件</span></td>
       <td><code>String</code></td>
       <td>看到<code>FileAppender</code>属性。</td>
     </tr>	
     <tr>
       <td><span class="prop" container="rfa">附加</span></td>
       <td><code>boolean</code></td>
       <td>看到<code>FileAppender</code>属性。</td>
     </tr>	
     <tr>
       <td><span class="prop" container="rfa">编码器</span></td>
       <td>
         <a href="../xref/ch/qos/logback/core/encoder/Encoder.html"><code>Encoder</code></a>
       </td>
       <td>看到<code>OutputStreamAppender</code>属性。</td>
     </tr>
     <tr>
       <td><span class="prop" container="rfa">滚动政策</span></td>
       <td><code>RollingPolicy</code></td>
       <td>此选项是将决定<code>RollingFileAppender</code>发生翻转时的行为。请参阅下面的更多信息。
       </td>
     </tr>	
     <tr>
       <td><span class="prop" container="rfa">触发政策</span></td>
       <td><code>TriggeringPolicy</code></td>
       <td>该选项将告诉您<code>RollingFileAppender</code>何时激活过渡过程。请参阅下面的更多信息。
       </td>
     </tr>	
     <tr>
       <td valign="top"><span class="prop" name="prudentWithRolling">谨慎</span></td>

       <td valign="top"><code>boolean</code></td>

       <td valign="top">
         <a href="#FixedWindowRollingPolicy"><code>FixedWindowRollingPolicy</code></a>谨慎模式不支持。

         <p> <code>RollingFileAppender</code>支持谨慎模式与<a href="#TimeBasedRollingPolicy"><code>TimeBasedRollingPolicy</code></a>尽管有两个限制。
         </p>

         <ol>
           <li>在谨慎模式下，不支持也不允许文件压缩。（我们不能让一个JVM写入文件，而另一个JVM对其进行压缩。）</li>
           
           <li>的<span class="prop">文件</span>属性<code>FileAppender</code>无法设置，必须留空。实际上，大多数操作系统不允许在打开另一个进程的同时重命名文件。
           </li>
           
         </ol>另请参阅属性<code>FileAppender</code> 。
       </td>
     </tr>
   </tbody></table>
	
   <h3 class="doAnchor" name="onRollingPolicies">滚动政策概述</h3>
	
   <p><a href="../xref/ch/qos/logback/core/rolling/RollingPolicy.html"><code>RollingPolicy</code></a>负责涉及文件移动和重命名的过渡过程。</p>
	
   <p>的<code>RollingPolicy</code>界面如下所示：</p>
   
   <pre class="prettyprint source">package ch.qos.logback.core.rolling;  

import ch.qos.logback.core.FileAppender;
import ch.qos.logback.core.spi.LifeCycle;

public interface RollingPolicy extends LifeCycle {

  <b>public void rollover() throws RolloverFailure;</b>
  public String getActiveFileName();
  public CompressionMode getCompressionMode();
  public void setParent(FileAppender appender);
}</pre>

   <p>的<code>rollover</code>该方法完成了归档当前日志文件所涉及的工作。的<code>getActiveFileName()</code>调用方法来计算当前日志文件的名称（将实时日志写入该文件）。如所示<code>getCompressionMode</code> RollingPolicy方法还负责确定压缩模式。最后， <code>RollingPolicy</code>通过<code>setParent</code>方法。
   </p>

   <!-- =================
        ================= -->

	
   <h4 class="doAnchor" name="TimeBasedRollingPolicy">时基滚动策略</h4>

   <p><a href="../xref/ch/qos/logback/core/rolling/TimeBasedRollingPolicy.html"><code>TimeBasedRollingPolicy</code></a>这可能是最受欢迎的滚动政策。它基于时间定义了过渡策略，例如按天或按月。
   <code>TimeBasedRollingPolicy</code>承担翻滚以及触发所述翻滚的责任。确实， <code>TimeBasedTriggeringPolicy</code> <em>同时</em>实现<em>了</em> <code>RollingPolicy</code>和<code>TriggeringPolicy</code>接口。
   </p>

   <p><code>TimeBasedRollingPolicy</code>的配置带有一个必需的<span class="prop">fileNamePattern</span>属性和几个可选属性。
   </p>

   <table class="bodyTable striped">
     <tbody><tr>
       <th>物业名称</th>
       <th>类型</th>
       <th>描述</th>
     </tr>
     <tr>
       <td><span class="prop" container="tbrp">fileNamePattern</span></td>
       <td><code>String</code></td>
       <td>强制性的<span class="prop">fileNamePattern</span>属性定义了过渡（存档）日志文件的名称。它的值应包括文件名以及适当放置的<em>％d</em>转换说明符。<em>％d</em>转换说明符可能包含日期和时间模式，如<code>java.text.SimpleDateFormat</code>类。如果省略了日期和时间模式，则采用默认模式<em>yyyy-MM-dd</em> 。<b>从<span class="prop">fileNamePattern</span>的值推断出过渡期。</b>


         <p>请注意， <span class="prop">文件</span>属性在<code>RollingFileAppender</code> （的父母<code>TimeBasedRollingPolicy</code> ）可以设置或省略。通过设置包含的<span class="prop">文件</span>属性<code>FileAppender</code> ，您可以将活动日志文件的位置与归档日志文件的位置分离。当前日志将始终以<span class="prop">file</span>属性指定的<span class="prop">文件</span>为目标。因此，当前活动日志文件的名称将不会随时间变化。但是，如果选择忽略<span class="prop">file</span>属性，那么将根据<span class="prop">fileNamePattern</span>的值在每个期间重新计算活动文件。下面的示例应阐明这一点。
         </p>

         <p>在％d {}的赞誉中找到的日期和时间模式遵循java.text。SimpleDateFormat约定。<span class="option">fileNamePattern</span>属性内或日期和时间模式内任何位置的正斜杠“ /”或反斜杠“ \”字符都将被解释为目录分隔符。
         </p>

         <h5>多个％d说明符</h5> 

         <p>可以指定多个％d说明符，但其中只有一个可以是主要的，即用于推断过渡期。<em>必须</em>通过传递'aux'参数将所有其他标记标记为辅助标记（请参见下面的示例）。</p>
         
         <p>多个％d说明符使您可以将存档文件组织为不同于过渡期的文件夹结构。例如，下面显示的文件名模式按年和月组织日志文件夹，但每天午夜都将日志文件翻转。</p>
         
         <pre>/var/log/<b>%d{yyyy/MM, aux}</b>/myapplication.<b>%d{yyyy-MM-dd}</b>.log</pre>

         <h5>时区</h5> 

         <p>在某些情况下，您可能希望根据与主机不同的时区中的时钟来翻转日志文件。可以在％d转换说明符内的日期和时间模式之后传递时区参数。例如：</p>

         <pre>aFolder/test.<b>%d</b>{yyyy-MM-dd-HH, <b>UTC</b>}.log</pre>

         <p>如果指定的时区标识符未知或拼写错误，则将GMT时区视为由<a href="http://docs.oracle.com/javase/6/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String)">TimeZone.getTimeZone（String）</a>方法规范指定。
         </p>
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="tbrp">maxHistory</span></td>
       <td>整型</td>
       <td>可选的<span class="prop">maxHistory</span>属性控制要保留的归档文件的最大数量，以异步方式删除较旧的文件。例如，如果您指定每月滚动，并将maxHistory设置为6，则将保留6个月的归档文件，并删除6个月以上的文件。请注意，由于删除了旧的归档日志文件，将适当删除为日志文件归档而创建的所有文件夹。
       </td>
     </tr>

     <tr>
       <td><span class="prop" container="tbrp">totalSizeCap</span></td>
       <td>整型</td>
       <td><p>可选的<span class="prop">totalSizeCap</span>属性控制所有存档文件的总大小。当超过总大小上限时，最早的档案将被异步删除。<span class="prop">totalSizeCap</span>属性还需要设置<span class="option">maxHistory</span>属性。此外，始终始终先应用“最大历史记录”限制，然后再应用“总大小上限”限制。</p>
       </td>
     </tr>

     <tr>
       <td><span class="prop" container="tbrp">cleanHistoryOnStart</span></td>
       <td>布尔值</td>
       <td>
         <p>如果设置为true，则将在追加程序启动时执行归档删除。默认情况下，此属性设置为false。</p>

         <p>通常在过渡期间执行归档删除。但是，某些应用程序的生存时间可能不足以触发翻转。因此，对于这种短暂的应用程序，归档删除可能永远都没有执行的机会。通过将<span class="prop">cleanHistoryOnStart</span>设置为true，将在附加程序启动时执行归档删除。</p>
       </td>
     </tr>
   </tbody></table>


   <p>这里有一些<code>fileNamePattern</code>值及其作用说明。</p>

  
   
   <table class="bodyTable striped">
     <tbody><tr>
       <th>
         <span class="prop">fileNamePattern</span>
       </th>
       <th>展期时间表</th>
       <th>例</th>
     </tr>
     <tr>
       <td class="small">
         <em>/wombat/foo.%d</em>
       </td>
       <td>每日展期（午夜）。由于省略了<em>％d</em>令牌说明符的可选时间和日期模式，因此采用了默认模式<em>yyyy-MM-dd</em> ，它对应于每日滚动。
       </td>

       <td>
         <p>未设置<span class="prop">文件</span>属性：在2006年11月23日，日志记录输出将转到文件<em>/wombat/foo.2006-11-23</em> 。在午夜以及24日的其余时间，日志记录输出将定向到<em>/wombat/foo.2006-11-24</em> 。
       </p>

         <p><span class="prop">文件</span>属性设置为<em>/wombat/foo.txt</em> ：在2006年11月23日，日志记录输出将进入文件<em>/wombat/foo.txt</em> 。在午夜， <em>foo.txt</em>将重命名为<em>/wombat/foo.2006-11-23</em> 。将创建一个新的<em>/wombat/foo.txt</em>文件，并在11月24日的其余时间将日志输出定向到<em>foo.txt</em> 。
       </p>

       </td>
     </tr>
     

     <tr>
       <td class="small">
         <em>/wombat/%d{yyyy/MM}/foo.txt</em>
       </td>
       <td>在每个月初进行过渡。</td>
       <td>
         <p>未设置<span class="prop">文件</span>属性：在2006年10月，日志记录输出将进入<em>/wombat/2006/10/foo.txt</em> 。在10月31日午夜之后和11月<em>下旬</em> ，日志记录输出将定向到<em>/wombat/2006/11/foo.txt</em> 。
         </p>

         <p><span class="prop">文件</span>属性设置为<em>/wombat/foo.txt</em> ：活动日志文件将始终为<em>/wombat/foo.txt</em> 。在2006年10月，日志记录输出将转到<em>/wombat/foo.txt</em> 。在10月31日午夜，/ <em>wombat/foo.txt</em>将重命名为<em>/wombat/2006/10/foo.txt</em> 。将创建一个新的<em>/wombat/foo.txt</em>文件，该日志文件将在11月<em>下旬</em>输出。在11月30日午夜，/ <em>wombat / foo.txt</em>将重命名为<em>/wombat/2006/11/foo.txt</em> ，依此类推。
         </p>
       </td>
     </tr>
     <tr>
       <td class="small">
         <em>/wombat/foo.%d{yyyy-ww}.log</em>
       </td>
       
       <td>每周第一天的展期。请注意，一周的第一天取决于语言环境。</td>
       
       <td>与以前的情况类似，不同的是，过渡将在每个新的星期开始时进行。
       </td>     
     </tr>	
     <tr>
       <td class="small">
         <em>/wombat/foo%d{yyyy-MM-dd_HH}.log</em>
       </td>
       <td>每小时顶部滚动一次。</td>
       <td>与以前的情况类似，除了滚动将在每小时的顶部进行。
       </td>
     </tr>
     <tr>
       <td class="small">
         <em>/wombat/foo%d{yyyy-MM-dd_HH-mm}.log</em>
       </td>
       <td>每分钟开始时进行翻转。</td>
       <td>与以前的情况类似，除了在每分钟的开始发生翻转。
       </td>     
     </tr>
     <tr>
       <td class="small">
         <em>/ wombat / foo％d {yyyy-MM-dd_HH-mm，UTC} .log</em>
       </td>
       <td>每分钟开始时进行翻转。</td>
       <td>与以前的情况类似，除了文件名将以UTC表示。</td>     
     </tr>


     <tr>
       <td class="small">
         <em>/ foo /％d {yyyy-MM， <b>aux</b> } /％d.log</em>
       </td>
       <td>每天滚动。存档位于包含年和月的文件夹下。
       </td>
       <td>在此示例中，第一个％d令牌被标记为<b>辅助</b> iliary。然后假定第二个％d令牌是主要令牌，其中省略了时间和日期模式。因此，过渡将每天发生一次（％d的默认设置），并且文件夹名称将取决于年份和月份。例如，在2006年11月，归档文件将全部放在/ foo / 2006-11 /文件夹下，例如<em>/foo/2006-11/2006-11-14.log</em> 。
       </td>     
       
     </tr>
   </tbody></table>
   
   <p>任何正斜杠或反斜杠字符都将解释为文件夹（目录）分隔符。将根据需要创建任何所需的文件夹。因此，您可以轻松地将日志文件放在单独的文件夹中。
   </p>


 	 <p><code>TimeBasedRollingPolicy</code>支持自动文件压缩。如果<span class="prop">fileNamePattern</span>选项的值以<em>.gz</em>或<em>.zip</em>结尾，则启用此功能。
   </p>

   <table class="bodyTable striped">
     <tbody><tr class="a">
       <th><span class="prop">fileNamePattern</span></th>
       <th>展期时间表</th>
       <th>例</th>
     </tr>
     <tr>
       <td><em>/wombat/foo.%d.gz</em></td>
       <td>每日翻转（在午夜），对存档文件进行自动GZIP压缩。</td>
       <td>
         <p>未设置<span class="prop">文件</span>属性：在2009年11月23日，日志记录输出将转到文件<em>/wombat/foo.2009-11-23</em> 。但是，在午夜该文件将被压缩为<em>/wombat/foo.2009-11-23.gz</em> 。对于11月24日，日志记录输出将定向到<em>/wombat/folder/foo.2009-11-24，</em>直到第二天开始将其<em>翻转</em>为止。
         </p>
         
         <p><span class="prop">文件</span>属性设置为/wombat/foo.txt：在2009年11月23日，日志记录输出将进入文件<em>/wombat/foo.txt</em> 。在午夜，该文件将被压缩<em>并重</em>命名为<em>/wombat/foo.2009-11-23.gz</em> 。将创建一个新的<em>/wombat/foo.txt</em>文件，日志输出将在11月24日的其余时间发送。在11月24日午夜，/ <em>wombat / foo.txt</em>将被压缩<em>并重</em>命名为<em>/wombat/foo.2009-11-24.gz</em> ，依此类推。
         </p>
       </td>
     </tr>
   </tbody></table>
   
   <p><span class="prop">fileNamePattern</span>具有双重用途。首先，通过研究模式，logback计算所需的翻转周期。其次，它计算每个存档文件的名称。注意，两个不同的模式可以指定相同的周期性。模式<em>yyyy-MM</em>和<em>yyyy @ MM</em>都指定了月度过渡，尽管生成的归档文件将带有不同的名称。
   </p>

	 <p>通过设置<span class="prop">文件</span>属性，您可以使活动日志文件的位置与归档日志文件的位置分离。日志输出将定向到<span class="prop">file</span>属性指定的<span class="prop">文件中</span> 。因此，活动日志文件的名称不会随时间变化。但是，如果选择忽略<span class="prop">file</span>属性，那么将根据<span class="prop">fileNamePattern</span>的值在每个期间重新计算活动文件。通过不设置<span class="prop">文件</span>选项，您可以避免文件<a href="../codes.html#renamingError">重命名错误</a> ，该<a href="../codes.html#renamingError">错误</a>在翻转期间存在外部文件句柄引用日志文件时发生。
   </p>
	
   <p><span class="prop">maxHistory</span>属性控制要保留的存档文件的最大数量，从而删除较旧的文件。例如，如果您指定每月滚动，并将<span class="prop">maxHistory</span>设置为6，则将保留6个月的归档文件，并删除6个月以上的文件。请注意，由于删除了旧的归档日志文件，将适当删除为日志文件归档而创建的所有文件夹。
   </p>

   <p>由于各种技术原因，翻转不是由时钟驱动的，而是取决于日志记录事件的到达。例如，在2002年3月8日，假设<span class="prop">fileNamePattern</span>设置为<em>yyyy-MM-dd</em> （每日翻转），则午夜之后第一个事件的到来将触发翻转。如果在午夜后的23分47秒内没有日志记录事件，则实际上将在3月9日凌晨00：23'47 AM而非0:00 AM发生翻转。因此，根据事件的到达率，可能会以一定的延迟触发翻转。但是，无论延迟如何，从某种意义上讲，已知过渡算法都是正确的，因为在一定时间段内生成的所有日志记录事件都将在界定该时间段的正确文件中输出。
   </p>
	
   <p>这是一个示例配置<code>RollingFileAppender</code>结合<code>TimeBasedRollingPolicy</code> 。
   </p>
	
   <p class="example">示例：一个的示例配置<code>RollingFileAppender</code>用一个<code>TimeBasedRollingPolicy</code> （logback-examples / src / main / resources / chapters / appenders / conf / logback-RollingTimeBased.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-RollingTimeBased');">观看为.groovy</span>
   <pre id="logback-RollingTimeBased" class="prettyprint source">&lt;configuration>
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    &lt;file>logFile.log&lt;/file>
    <b>&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      &lt;!-- daily rollover -->
      &lt;fileNamePattern>logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern>

      &lt;!-- keep 30 days' worth of history capped at 3GB total size -->
      &lt;maxHistory>30&lt;/maxHistory>
      &lt;totalSizeCap>3GB&lt;/totalSizeCap>

    &lt;/rollingPolicy></b>

    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender> 

  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

    <p>下一个配置示例说明了<code>RollingFileAppender</code>有关联<code>TimeBasedRollingPolicy</code>在<span class="prop">谨慎</span>模式下。
    </p>

   <p class="example">示例：一个的示例配置<code>RollingFileAppender</code>用一个<code>TimeBasedRollingPolicy</code> （logback-examples / src / main / resources / chapters / appenders / conf / logback-PrudentTimeBasedRolling.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('logback-PrudentTimeBasedRolling');">观看为.groovy</span>
  <pre id="logback-PrudentTimeBasedRolling" class="prettyprint source">&lt;configuration>
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <b>&lt;!-- Support multiple-JVM writing to the same log file --></b>
    <b>&lt;prudent>true&lt;/prudent></b>
    &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      &lt;fileNamePattern>logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern>
      &lt;maxHistory>30&lt;/maxHistory> 
      &lt;totalSizeCap>3GB&lt;/totalSizeCap>
    &lt;/rollingPolicy>

    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender> 

  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

  

    <h3 class="doAnchor" name="SizeAndTimeBasedRollingPolicy">基于大小和时间的滚动策略</h3>

    
     <p>有时，您可能希望基本上按日期归档文件，但同时限制每个日志文件的大小，尤其是在后处理工具对日志文件施加大小限制的情况下。为了解决此要求，logback附带<code>SizeAndTimeBasedRollingPolicy</code> 。</p>

    <p>注意<code>TimeBasedRollingPolicy</code>已经允许限制归档日志文件的总大小。如果仅希望限制日志归档的总大小，则<code>TimeBasedRollingPolicy</code>以上所述并设置<a href="#tbrpTotalSizeCap"><span class="option">totalSizeCap</span></a>属性应足够。
    </p>

    <p>这是一个示例配置文件，展示了基于时间和大小的日志文件归档。</p>
    
  <p class="example">示例：的示例配置<code>SizeAndTimeBasedFNATP</code> （logback-examples / src / main / resources / chapters / appenders / conf / logback-sizeAndTime.xml）</p>

  <span class="asGroovy" onclick="return asGroovy('logback-sizeAndTime');">观看为.groovy</span>
  <pre id="logback-sizeAndTime" class="prettyprint source">&lt;configuration>
  &lt;appender name="ROLLING" class="ch.qos.logback.core.rolling.RollingFileAppender">
    &lt;file>mylog.txt&lt;/file>
    &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
      &lt;!-- rollover daily -->
      &lt;fileNamePattern><b>mylog-%d{yyyy-MM-dd}.<span class="big">%i</span>.txt</b>&lt;/fileNamePattern>
       <b>&lt;!-- each file should be at most 100MB, keep 60 days worth of history, but at most 20GB --></b>
       <b>&lt;maxFileSize>100MB&lt;/maxFileSize></b>    
       &lt;maxHistory>60&lt;/maxHistory>
       &lt;totalSizeCap>20GB&lt;/totalSizeCap>
    &lt;/rollingPolicy>
    &lt;encoder>
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>


  &lt;root level="DEBUG">
    &lt;appender-ref ref="ROLLING" />
  &lt;/root>

&lt;/configuration></pre>
    
    <p>请注意，除了“％d”外，还包括“％i”转换令牌。<b>％i和％d令牌都是必需的。</b> 每次当前日志文件在当前时间段结束之前达到<span class="prop">maxFileSize</span>时，将使用从0开始的递增索引进行归档。</p>

    <p>基于大小和时间的归档支持删除旧的归档文件。您需要使用<span class="prop">maxHistory</span>属性指定要保留的周期数。当您的应用程序停止并重新启动时，日志记录将在正确的位置继续进行，即在当前期间以最大的索引号进行记录。
    </p>

    <p>在1.1.7之前的版本中，本文档提到了一个名为<code>SizeAndTimeBasedFNATP</code> 。但是，鉴于<code>SizeAndTimeBasedFNATP</code>提供了更简单的配置结构，我们不再文档<code>SizeAndTimeBasedFNATP</code> 。不过，较早的配置文件使用<code>SizeAndTimeBasedFNATP</code>将继续正常工作。事实上， <code>SizeAndTimeBasedRollingPolicy</code>用<code>SizeAndTimeBasedFNATP</code>子组件。</p>

   <h4 class="doAnchor" name="FixedWindowRollingPolicy">FixedWindowRollingPolicy</h4>

   <p>翻滚时<a href="../xref/ch/qos/logback/core/rolling/FixedWindowRollingPolicy.html"><code>FixedWindowRollingPolicy</code></a>如下所述根据固定的窗口算法重命名文件。
   </p>

   <p><span class="prop">fileNamePattern</span>选项代表已归档（滚动）日志文件的文件名模式。此选项是必需的，并且必须在模式内的某个位置包含整数令牌<em>％i</em> 。
   </p>
	
   <p>以下是的可用属性<code>FixedWindowRollingPolicy</code>
   </p>
	
   <table class="bodyTable striped">
     <tbody><tr>
       <th>物业名称</th>
       <th>类型</th>
       <th>描述</th>
     </tr>
     <tr>
       <td><span class="prop" container="fwrp">minIndex</span></td>
       <td><code>int</code></td>
       <td>
         <p>此选项代表窗口索引的下限。
         </p>
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="fwrp">maxIndex</span></td>
       <td><code>int</code></td>
       <td>
         <p>此选项代表窗口索引的上限。
         </p>
       </td>
     </tr>
     <tr>
       <td><span class="prop" container="fwrp">fileNamePattern</span></td>
       <td><code>String</code></td>
       <td>
         <p>此选项代表模式，后面将跟随<code>FixedWindowRollingPolicy</code>重命名日志文件时。它必须包含字符串<em>％i</em> ，它将指示当前窗口索引值将插入的位置。
         </p>
         <p>例如，使用与最小值和最大值<em>1</em>和<em>3</em>关联的<em>MyLogFile％i.log</em>将生成名为<em>MyLogFile1.log</em> ， <em>MyLogFile2.log</em>和<em>MyLogFile3.log的</em>存档文件。
         </p>
         <p>请注意，文件压缩也是通过此属性指定的。例如，将<span class="prop">fileNamePattern</span>设置为<em>MyLogFile％i.log.zip</em>意味着必须使用<em>zip</em>格式压缩归档文件；还支持<em>gz</em>格式。
         </p>
       </td>
     </tr>			
   </tbody></table>
   
   <p>鉴于固定的窗口滚动策略需要与窗口大小一样多的文件重命名操作，因此强烈建议不要使用较大的窗口大小。当用户指定大值时，当前实现将自动将窗口大小减小到20。
   </p>

   <p>让我们看看固定窗口翻转策略的更具体示例。假设<span class="prop">minIndex</span>设置为<em>1</em> ， <span class="prop">maxIndex</span>设置为<em>3</em> ， <span class="prop">fileNamePattern</span>属性设置为<em>foo％i.log</em> ，并且<span class="prop">file</span>属性设置为<em>foo.log</em> 。
   </p>
	
   <table class="bodyTable striped">
     <tbody><tr>
       <th>展期数</th>
       <th>有效输出目标</th>
       <th>存档的日志文件</th>
       <th>描述</th>
     </tr>
		<tr>
			<td>0</td>
			<td>foo.log</td>
			<td>--</td>
			<td>尚未发生过渡，重新登录将登录到初始文件。
			</td>
     </tr>		
     <tr>
       <td>1个</td>
       <td>foo.log</td>
       <td>foo1.log</td>
       <td>第一次翻转。 <em>foo.log</em>重命名为<em>foo1.log</em> 。创建一个新的<em>foo.log</em>文件， <em>该</em>文件成为活动的输出目标。
       </td>
     </tr>
     <tr>
       <td>2</td>
       <td>foo.log</td>
       <td>foo1.log，foo2.log</td>
       <td>第二次翻转。 <em>foo1.log</em>重命名为<em>foo2.log</em> 。 <em>foo.log</em>重命名为<em>foo1.log</em> 。创建一个新的<em>foo.log</em>文件， <em>该</em>文件成为活动的输出目标。
       </td>
     </tr>
     <tr>
       <td>3</td>
       <td>foo.log</td>
       <td>foo1.log，foo2.log，foo3.log</td>
       <td>第三轮过渡。 <em>foo2.log</em>重命名为<em>foo3.log</em> 。 <em>foo1.log</em>重命名为<em>foo2.log</em> 。 <em>foo.log</em>重命名为<em>foo1.log</em> 。创建一个新的<em>foo.log</em>文件， <em>该</em>文件成为活动的输出目标。
       </td>
     </tr>
     <tr>
       <td>4</td>
       <td>foo.log</td>
       <td>foo1.log，foo2.log，foo3.log</td>
       <td>在本轮及以后的回合中，过渡通过删除<em>foo3.log</em>开始。如先前步骤所示，通过增加其索引来重命名其他文件。在此和后续过渡中，将有三个归档日志和一个活动日志文件。
       </td>
     </tr>
   </tbody></table>
	
   <p>以下配置文件提供了配置示例<code>RollingFileAppender</code>和<code>FixedWindowRollingPolicy</code> 。请注意，即使<span class="prop">File</span>选项包含与<span class="prop">fileNamePattern</span>选项传达的信息相同的信息，也是必须的。
   </p>
	
   <p class="example">示例：一个的示例配置<code>RollingFileAppender</code>用一个<code>FixedWindowRollingPolicy</code> （logback-examples / src / main / resources / chapters / appenders / conf / logback-RollingFixedWindow.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('logback-RollingFixedWindow');">观看为.groovy</span>
   <pre id="logback-RollingFixedWindow" class="prettyprint source">&lt;configuration>
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <b>&lt;file>test.log&lt;/file></b>

    <b>&lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
      &lt;fileNamePattern>tests.%i.log.zip&lt;/fileNamePattern>
      &lt;minIndex>1&lt;/minIndex>
      &lt;maxIndex>3&lt;/maxIndex>
    &lt;/rollingPolicy></b>

    &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      &lt;maxFileSize>5MB&lt;/maxFileSize>
    &lt;/triggeringPolicy>
    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
	
  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>


		<h2>
      <a name="TriggeringPolicy" href="#TriggeringPolicy">触发策略概述</a>
    </h2>
		
		<p><a href="../xref/ch/qos/logback/core/rolling/TriggeringPolicy.html"><code>TriggeringPolicy</code></a>实施负责指导<code>RollingFileAppender</code>什么时候翻转。</p>
		
		<p>的<code>TriggeringPolicy</code>接口仅包含一种方法。</p>
	
    <pre class="prettyprint source">package ch.qos.logback.core.rolling;

import java.io.File;
import ch.qos.logback.core.spi.LifeCycle;

public interface TriggeringPolicy&lt;E&gt; extends LifeCycle {

  <b>public boolean isTriggeringEvent(final File activeFile, final &lt;E&gt; event);</b>
}</pre>

		<p>的<code>isTriggeringEvent()</code>方法将活动文件和当前正在处理的日志记录事件作为参数。具体的实现基于这些参数来确定是否应进行翻转。
		</p>

    <p>使用最广泛的触发策略，即<code>TimeBasedRollingPolicy</code>它也可以作为滚动政策的两倍， <a href="#TimeBasedRollingPolicy">前面</a>已经与其他滚动政策进行了<a href="#TimeBasedRollingPolicy">讨论</a> 。</p>
		
		<h4><a name="SizeBasedTriggeringPolicy" href="#SizeBasedTriggeringPolicy">基于大小的触发政策</a></h4>

		<p><a href="../xref/ch/qos/logback/core/rolling/SizeBasedTriggeringPolicy.html"><code>SizeBasedTriggeringPolicy</code></a>查看当前活动文件的大小。如果它大于指定的大小，则会发出信号通知拥有<code>RollingFileAppender</code>触发现有活动文件的翻转。
		</p>

		<p><code>SizeBasedTriggeringPolicy</code>仅接受一个参数，即<span class="prop">maxFileSize</span> ，默认值为10 MB。</p>

		<p>通过用<em>KB</em> ， <em>MB</em>和<em>GB</em>分别后缀数字值，可以以字节，千字节，兆字节或千兆字节指定<span class="prop">maxFileSize</span>选项。例如<em>，500万</em> <em><em>，5000KB，5MB</em></em>和<em>2GB</em>都是有效的值，其中前三个等同。
		</p>

		<p>这是带有<code>RollingFileAppender</code>和这个结合<code>SizeBasedTriggeringPolicy</code>日志文件大小达到5MB时触发翻转。
		</p>

    <p class="example">示例：一个的示例配置<code>RollingFileAppender</code>用一个<code>SizeBasedTriggeringPolicy</code> （logback-examples / src / main / resources / chapters / appenders / conf / logback-RollingSizeBased.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('logback-RollingSizeBased');">观看为.groovy</span>
    <pre id="logback-RollingSizeBased" class="prettyprint source">&lt;configuration>
  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    &lt;file>test.log&lt;/file>
    &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
      &lt;fileNamePattern>test.%i.log.zip&lt;/fileNamePattern>
      &lt;minIndex>1&lt;/minIndex>
      &lt;maxIndex>3&lt;/maxIndex>
    &lt;/rollingPolicy>

    <b>&lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      &lt;maxFileSize>5MB&lt;/maxFileSize>
    &lt;/triggeringPolicy></b>
    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
	
  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration></pre>

	
    <!-- XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx -->
		<a name="Classic"></a>
		<h2>经典后退</h2>
				
    
		<p>虽然日志记录事件在logback-core中是通用的，但在logback-classic中，它们始终是<code>ILoggingEvent</code> 。经典的Logback就是专门处理管道实例的处理管道<code>ILoggingEvent</code> 。

    </p>

		<h3 class="doAnchor" name="SocketAppender">SocketAppender和SSLSocketAppender</h3>
		
		<p>到目前为止涵盖的附加程序只能登录到本地资源。相反， <a href="../xref/ch/qos/logback/classic/net/SocketAppender.html"><code>SocketAppender</code></a>用于通过传输序列化日志记录到远程实体<code>ILoggingEvent</code>电线上的实例。使用时<code>SocketAppender</code>线路上的日志记录事件以明文形式发送。但是，使用时<a href="../xref/ch/qos/logback/classic/net/SSLSocketAppender.html"><code>SSLSocketAppender</code></a> ，记录事件是通过安全通道传递的。</p>

    <p>序列化事件的实际类型是<a href="../xref/ch/qos/logback/classic/spi/LoggingEventVO.html"><code>LoggingEventVO</code></a>实施<code>ILoggingEvent</code>接口。但是，就日志事件而言，远程日志是非侵入性的。在反序列化后的接收端，可以记录该事件，就好像它是本地生成的一样。多<code>SocketAppender</code>在不同计算机上运行的实例可以将其日志输出定向到格式固定的中央日志服务器。<code>SocketAppender</code>不采用关联的布局，因为它会将序列化的事件发送到远程服务器。 <code>SocketAppender</code>在<em>传输控制协议（TCP）</em>层之上运行，该层提供可靠的，顺序的，流控制的端到端八位字节流。因此，如果远程服务器可访问，则日志事件最终将到达那里。否则，如果远程服务器已关闭或无法访问，则将仅删除日志记录事件。如果服务器重新启动，则事件传输将透明地恢复。通过连接器线程执行此透明的重新连接，该连接器线程会定期尝试连接到服务器。
		</p>
		
		<p>日志事件由本机TCP实现自动缓冲。这意味着，如果到服务器的链接速度较慢，但仍比客户端的事件产生速率快，则客户端将不会受到速度较慢的网络连接的影响。但是，如果网络连接的速度慢于事件产生的速度，则客户端只能以网络速度前进。特别是，在极端情况下，到服务器的网络链接已断开，最终将阻止客户端。或者，如果网络链接已打开，但服务器已关闭，则客户端将不会被阻止，尽管由于服务器不可用，日志事件也会丢失。
		</p>
		
		<p>即使一个<code>SocketAppender</code>不再连接到任何记录器，在存在连接器线程的情况下不会被垃圾回收。仅当与服务器的连接断开时，连接器线程才存在。为避免此垃圾收集问题，您应该关闭<code>SocketAppender</code>明确地。寿命长的应用程序会创建/破坏许多应用程序<code>SocketAppender</code>实例应注意此垃圾回收问题。大多数其他应用程序可以放心地忽略它。如果JVM托管<code>SocketAppender</code>在之前退出<code>SocketAppender</code>在显式关闭垃圾回收之后或在垃圾回收之后将其关闭，则管道中可能有未传输的数据可能会丢失。这是基于Windows的系统上的常见问题。为了避免数据丢失，通常足以<code>close()</code>的<code>SocketAppender</code>明确地或通过调用<code>LoggerContext</code>的<code>stop()</code>方法，然后退出应用程序。
		</p>
		
		<p>远程服务器由<span class="prop">remoteHost</span>和<span class="prop">端口</span>属性标识。
		<code>SocketAppender</code>下表中列出了属性。 <code>SSLSocketAppender</code>支持许多其他配置属性，这些属性在标题为<a href="usingSSL.html">使用SSL</a>的部分中进行了详细介绍。</p>

    <table class="bodyTable striped">
      <tbody><tr>
			<th>物业名称</th>
			<th>类型</th>
			<th>描述</th>
      </tr>
      <tr>
        <td><span class="prop" container="socket">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>
          <p><span class="prop" container="socket">includeCallerData</span>选项采用布尔值。如果为true，则呼叫者数据将可用于远程主机。默认情况下，没有呼叫者数据发送到服务器。
          </p>
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="socket">港口</span></td>
        <td><code>int</code></td>
        <td>
          <p>远程服务器的端口号。
          </p>
        </td>
      </tr>	
      <tr>
        <td><span class="prop" container="socket">重新连接延迟</span></td>
        <td><code><a href="../apidocs/ch/qos/logback/core/util/Duration.html">Duration</a></code></td>
        <td><span class="prop">reconnectionDelay</span>选项采用一个持续时间字符串，例如“ 10秒”，表示在每次尝试与服务器的失败连接之间等待的时间。此选项的默认值为30秒。将此选项设置为零将关闭重新连接功能。请注意，在成功连接到服务器的情况下，将不存在连接器线程。
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="socket">queueSize</span></td>
        <td><code>int</code></td>
        <td>
          <p><span class="prop">queueSize</span>属性采用一个整数（大于零），该整数表示要保留以传递给远程接收器的日志事件的数量。当队列大小为1时，到远程接收器的事件传递是同步的。当队列大小大于1时，假定队列中有可用空间，新事件将进入队列。使用大于1的队列长度可以消除瞬态网络延迟引起的延迟，从而提高性能。
          </p>

          <p>另请参见<span class="prop">eventDelayLimit</span>属性。</p>

        </td>
      </tr>	

      <tr>
        <td><span class="prop" container="socket">eventDelayLimit</span></td>
        <td><code><a href="../apidocs/ch/qos/logback/core/util/Duration.html">Duration</a></code></td>
        <td><span class="prop">eventDelayLimit</span>选项采用持续时间字符串，例如“ 10秒”。它表示在本地队列已满（即已包含<span class="prop">queueSize</span>事件）的情况下，丢弃事件之前要等待的时间。如果远程主机持续缓慢地接受事件，则可能会发生这种情况。此选项的默认值为100毫秒。
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="socket">远程主机</span></td>
        <td><code>String</code></td>
        <td>服务器的主机名。
        </td>
      </tr>		
      <tr>
        <td><span class="prop" container="socket">ssl</span></td>
        <td><code>SSLConfiguration</code></td>
        <td>仅支持<code>SSLSocketAppender</code> ，此属性提供了附加程序将使用的SSL配置，如<a href="usingSSL.html">使用SSL中所述</a> 。</td>
      </tr>
    </tbody></table>
    
    <h4>记录服务器选项</h4>
    <p>标准的Logback Classic发行版包括两个服务器选项，可用于从以下服务器接收日志事件<code>SocketAppender</code>要么<code>SSLSocketAppender</code> 。</p>
    <ul>
      <li><code>ServerSocketReceiver</code>及其启用SSL的对应对象<code>SSLServerSocketReceiver</code>是接收器组件，可以在应用程序的<em>logback.xml</em>配置文件中<em>对其进行</em>配置，以接收来自远程套接字附加程序的事件。有关配置的详细信息和用法示例，请参见<a href="receivers.html">接收器</a> 。
      </li>
      <li><code>SimpleSocketServer</code>及其启用SSL的对应对象<code>SimpleSSLSocketServer</code>两者都提供了易于使用的独立Java应用程序，该应用程序旨在通过shell的命令行界面进行配置和运行。这些应用程序只是等待来自<code>SocketAppender</code>要么<code>SSLSocketAppender</code>客户。根据本地服务器策略记录每个接收到的事件。使用示例如下。
      </li>
    </ul>
    
    <h4><a name="simpleSocketServer"></a>使用SimpleSocketServer</h4>
    <p>的<code>SimpleSocketServer</code>应用程序使用两个命令行参数： <em>port</em>和<em>configFile</em> ；其中<em>port</em>是要侦听的端口， <em>configFile</em>是XML格式的配置脚本。
    </p>
	
    <p>假设您位于<em>logback-examples /</em>目录中，请启动<code>SimpleSocketServer</code>使用以下命令：</p>
    
    <p class="source">java ch.qos.logback.classic.net。SimpleSocketServer 6000 \ src / main / java / chapters / appenders / socket / server1.xml</p>

    <p>其中6000是要侦听的端口号， <em>server1.xml</em>是一个配置脚本，它添加了一个<code>ConsoleAppender</code>和一个<code>RollingFileAppender</code>到根记录器。开始之后<code>SimpleSocketServer</code> ，您可以使用以下命令从多个客户端发送日志事件： <code>SocketAppender</code> 。与本手册相关的示例包括两个这样的客户端： <code>chapters.appenders.SocketClient1</code>和<code>chapters.appenders.SocketClient2</code>两个客户端都等待用户在控制台上键入一行文本。文本封装在调试级别的日志记录事件中，然后发送到远程服务器。这两个客户端的配置不同<code>SocketAppender</code> 。 <code>SocketClient1</code>通过编程方式配置附加程序，而<code>SocketClient2</code>需要一个配置文件。
    </p>
	
    <p>假设<code>SimpleSocketServer</code>在本地主机上运行，您可以使用以下命令连接到该主机：</p>
	
    <p class="source">Java chapters.appenders.socket。SocketClient1本地主机6000</p>

		<p>您键入的每一行都应显示在<code>SimpleSocketServer</code>在上一步中启动。如果停止并重新启动<code>SimpleSocketServer</code>客户端将透明地重新连接到新的服务器实例，尽管断开时生成的事件将简单（并且不可撤消）丢失。
		</p>

		<p>不像<code>SocketClient1</code> ，示例应用程序<code>SocketClient2</code>不会自行配置回传。它需要XML格式的配置文件。如下所示的配置文件<em>client1.xml</em>创建一个<code>SocketAppender</code>并将其附加到根记录器。
		</p>

		<p class="example">示例：SocketAppender配置（logback-examples / src / main / resources / chapters / appenders / socket / client1.xml）</p>
    <span class="asGroovy" onclick="return asGroovy('client1');">观看为.groovy</span>
<pre id="client1" class="prettyprint source">&lt;configuration>
	  
  &lt;appender name="SOCKET" class="ch.qos.logback.classic.net.SocketAppender">
    &lt;remoteHost>${host}&lt;/remoteHost>
    &lt;port>${port}&lt;/port>
    &lt;reconnectionDelay>10000&lt;/reconnectionDelay>
    &lt;includeCallerData>${includeCallerData}&lt;/includeCallerData>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="SOCKET" />
  &lt;/root>  

&lt;/configuration></pre>
	
		<p>请注意，在上述配置脚本中， <span class="prop">remoteHost</span> ， <span class="prop">port</span>和<span class="prop">includeCallerData</span>属性的值不是直接给出的，而是作为替换变量键给出的。变量的值可以指定为系统属性：</p>
	
    <p class="source">java -Dhost = localhost -Dport = 6000 -DincludeCallerData = false \ chapters.appenders.socket。SocketClient2 src / main / java / chapters / appenders / socket / client1.xml</p>

		<p>该命令应提供与上一个类似的结果<code>SocketClient1</code>例。
		</p>
		
		<p>让我们再次强调一下，日志记录事件的序列化不是侵入性的。反序列化事件携带的信息与任何其他日志记录事件相同。可以像在本地生成一样对其进行操作；除了默认情况下序列化的日志记录事件不包含调用方数据外，其他信息均不包括在内。这是一个例子来说明这一点。首先开始<code>SimpleSocketServer</code>使用以下命令：</p>

    <p class="source">java ch.qos.logback.classic.net。SimpleSocketServer 6000 \ src / main / java / chapters / appenders / socket / server2.xml</p>

   <p>配置文件<em>server2.xml</em>创建一个<code>ConsoleAppender</code>其布局可输出呼叫者的文件名和行号以及其他信息。如果你跑<code>SocketClient2</code>使用以前的配置文件<em>client1.xml</em> ，您会注意到服务器端的输出将在括号之间包含两个问号，而不是文件名和调用方的行号：</p>

    <p class="source">2006-11-06 17：37：30,968调试[Thread-0] [？：？]章.appenders.socket。SocketClient2-嗨</p>

		<p>通过指示<code>SocketAppender</code>通过将<span class="prop">includeCallerData</span>选项设置为true来包含呼叫者数据。使用以下命令可以解决问题：</p>

   <pre class="source">java -Dhost=localhost -Dport=6000 -DincludeCallerData=true \
  chapters.appenders.socket.SocketClient2 src/main/java/chapters/appenders/socket/client1.xml</pre>

		<p>因为反序列化事件可以用与本地生成的事件相同的方式处理，所以它们甚至可以发送到第二台服务器进行进一步处理。作为练习，您可能希望设置两个服务器，其中第一台服务器将其从客户端接收的事件传送到第二台服务器。
		</p>
		
		<h4><a name="simpleSSLSocketServer"></a>使用SimpleSSLSocketServer</h4>

    <p>的<code>SimpleSSLSocketServer</code>要求使用相同的<em>port</em>和<em>configFile</em>命令行参数<code>SimpleSocketServer</code> 。此外，您必须使用命令行上指定的系统属性为日志服务器的X.509凭据提供位置和密码。
    </p>
    
    <p>假设您位于<em>logback-examples /</em>目录中，请启动<code>SimpleSSLSocketServer</code>使用以下命令：</p>

    <p class="source">java -Djavax.net.ssl.keyStore = src / main / java / chapters / appenders / socket / ssl / keystore.jks \ -Djavax.net.ssl.keyStorePassword = changeit \ ch.qos.logback.classic.net。SimpleSSLSocketServer 6000 \ src / main / java / chapters / appenders / socket / ssl / server.xml</p>
	
    <p>这个例子运行<code>SimpleSSLSocketServer</code>使用仅适用于测试和实验的X.509凭据。<strong>使用之前<code>SimpleSSLSocketServer</code>在生产设置中，您应该获得适当的X.509凭据来标识您的日志记录服务器</strong> 。有关更多详细信息，请参见<a href="usingSSL.html">使用SSL</a> 。
    </p>
    
    <p>因为服务器配置有<code>debug="true"</code>在根元素上指定，您将在服务器启动时看到将要使用的SSL配置的日志记录。这对于验证是否正确实施了本地安全策略很有用。
    </p>

    <p>用<code>SimpleSSLSocketServer</code>运行时，您可以使用<code>SSLSocketAppender</code> 。以下示例显示所需的附加程序配置：</p>
      
   	<p class="example">示例：SSLSocketAppender配置（logback-examples / src / main / resources / chapters / appenders / socket / ssl / client.xml）</p>
    <span class="asGroovy" onclick="return asGroovy('sslclient');">观看为.groovy</span>
<pre id="sslclient" class="prettyprint source">&lt;configuration debug="true">
	  
  &lt;appender name="SOCKET" class="ch.qos.logback.classic.net.SSLSocketAppender">
    &lt;remoteHost>${host}&lt;/remoteHost>
    &lt;port>${port}&lt;/port>
    &lt;reconnectionDelay>10000&lt;/reconnectionDelay>
    &lt;ssl>
      &lt;trustStore>
        &lt;location>${truststore}&lt;/location>
        &lt;password>${password}&lt;/password>
      &lt;/trustStore>
    &lt;/ssl>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="SOCKET" />
  &lt;/root>  

&lt;/configuration></pre>
	  
	  <p>请注意，就像前面的示例一样， <span class="prop">remoteHost</span> ， <span class="prop">port</span>的值是使用替换变量键指定的。此外，请注意<span class="prop">ssl</span>属性及其嵌套的<span class="prop">trustStore</span>属性的存在，该属性使用替代变量指定信任库的位置和密码。因为我们的示例服务器使用的是自签名证书，所以此配置是必需的。有关以下内容的SSL配置属性的更多信息，请参见<a href="usingSSL.html">使用SSL</a> 。 <code>SSLSocketAppender</code> 。
	  </p>

    <p>通过在命令行上将替换变量值指定为系统属性，我们可以使用此配置运行客户端应用程序：</p>
    	  	
    <p class="source">java -Dhost = localhost -Dport = 6000 \ -Dtruststore = file：src / main / java / chapters / appenders / socket / ssl / truststore.jks \ -Dpassword = changeit \ chapters.appenders.socket。SocketClient2 src / main / java / chapters / appenders / socket / ssl / client.xml</p>
 	  
 	  <p>与前面的示例一样，您可以在客户端应用程序提示时键入一条消息，然后该消息将传递到日志服务器（现在通过安全通道），并在控制台上显示该消息。
 	  </p>
 	  
 	  <p>请注意，命令行上给出的<em>truststore</em>属性指定了一个文件URL，该文件URL标识了信任库的位置。您还可以按照<a href="usingSSL.html">使用SSL中</a>所述<a href="usingSSL.html">使用</a>类路径URL。</p>
 
    <p>正如我们之前在服务器启动时所看到的，因为客户端配置具有<code>debug="true"</code>在根元素上指定的客户端启动日志包括SSL配置的详细信息，以帮助审核本地策略的一致性。
    </p>
 	  
 	  
    <h3 class="doAnchor" name="serverSocketAppender">ServerSocketAppender和SSLServerSocketAppender</h3>
    
    <p>的<code>SocketAppender</code>前面讨论的组件（及其支持SSL的对等组件）旨在允许应用程序通过网络连接到远程日志记录服务器，以便将日志记录事件传递到服务器。在某些情况下，让应用程序启动与远程日志记录服务器的连接可能不方便或不可行。对于这些情况，Logback提供<a href="../xref/ch/qos/logback/classic/net/server/ServerSocketAppender"><code>ServerSocketAppender</code></a> 。
    </p>
    
    <p>除了启动与远程日志记录服务器的连接外， <code>ServerSocketAppender</code>被动地侦听TCP套接字，以等待来自远程客户端的传入连接。传递给附加程序的日志事件将分发给每个连接的客户端。未连接任何客户端时发生的日志记录事件将被<em>丢弃</em> 。
    </p>
    
    <p>除了基本<code>ServerSocketAppender</code> ，Logback提供<a href="../xref/ch/qos/logback/classic/net/server/SSLServerSocketAppender"><code>SSLServerSocketAppender</code></a> ，它使用安全的加密通道将日志记录事件分发给每个连接的客户端。此外，启用SSL的附加程序完全支持基于相互证书的身份验证，可用于确保只有授权的客户端才能连接到附加程序以接收日志事件。
    </p>
   
    <p>编码日志事件以在线上传输的方法与以下方法相同： <code>SocketAppender</code> ;每个事件都是的序列化实例<code>ILoggingEvent</code> 。仅连接启动方向相反。而<code>SocketAppender</code>在建立与日志服务器的连接时充当活动对等方， <code>ServerSocketAppender</code>是被动的；它侦听来自客户端的传入连接。</p>  

    <p>的<code>ServerSocketAppender</code>子类型只能与Logback <em>接收器</em>组件一起使用。有关此组件类型的其他信息，请参见<a href="receivers.html">接收器</a> 。</p>
    
    <p>以下配置属性受以下支持： <code>ServerSocketAppender</code> ：</p>
    
    <table class="bodyTable striped">
      <tbody><tr>
      <th>物业名称</th>
      <th>类型</th>
      <th>描述</th>
      </tr>
      <tr>
        <td><span class="prop" container="serverSocketAppender">地址</span></td>
        <td><code>String</code></td>
        <td>追加程序将在其上侦听的本地网络接口地址。如果未指定此属性，则附加程序将在所有网络接口上侦听。</td>
      </tr>
      <tr>
        <td><span class="prop" container="serverSocketAppender">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>
          <p>如果为true，则呼叫者数据将可用于远程主机。默认情况下，没有呼叫者数据发送到客户端。
          </p>
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="serverSocketAppender">港口</span></td>
        <td><code>int</code></td>
        <td>
          <p>追加程序将在其上侦听的端口号。
          </p>
        </td>
      </tr> 
      <tr>
        <td><span class="prop" container="serverSocketAppender">ssl</span></td>
        <td><code>SSLConfiguration</code></td>
        <td>仅支持<code>SSLServerSocketAppender</code> ，此属性提供了附加程序将使用的SSL配置，如<a href="usingSSL.html">使用SSL中所述</a> 。</td>
      </tr>
    </tbody></table>
    
    <p>以下示例说明了使用<code>ServerSocketAppender</code> ：</p>

    <p class="example">示例：基本的ServerSocketAppender配置（logback-examples / src / main / resources / chapters / appenders / socket / server4.xml）</p>
<pre id="SocketReceiver" class="prettyprint source">&lt;configuration debug="true">
  &lt;appender name="SERVER" 
    class="ch.qos.logback.classic.net.server.ServerSocketAppender">
    &lt;port>${port}&lt;/port>
    &lt;includeCallerData>${includeCallerData}&lt;/includeCallerData>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="SERVER" />
  &lt;/root>  

&lt;/configuration>
</pre>
    <p>请注意，此配置与使用以下示例的先前示例不同<code>SocketAppender</code>仅在为附加程序指定的<em>类中</em> ，并且没有<span class="prop">remoteHost</span>属性-该附加程序被动地等待来自远程主机的入站连接，而不是打开与远程日志记录服务器的连接。
    </p>
    
    <p>以下示例说明了使用<code>SSLServerSocketAppender</code> 。</p>
        
     <p class="example">示例：SSLServerSocketAppender基本配置（logback-examples / src / main / resources / chapters / appenders / socket / ssl / server3.xml）</p>
<pre id="SocketReceiver" class="prettyprint source">&lt;configuration debug="true">
  &lt;appender name="SERVER" 
    class="ch.qos.logback.classic.net.server.SSLServerSocketAppender">
    &lt;port>${port}&lt;/port>
    &lt;includeCallerData>${includeCallerData}&lt;/includeCallerData>
    &lt;ssl>
      &lt;keyStore>
        &lt;location>${keystore}&lt;/location>
        &lt;password>${password}&lt;/password>
      &lt;/keyStore>
    &lt;/ssl>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="SERVER" />
  &lt;/root>  

&lt;/configuration>
</pre>
   
    <p>此配置与以前的配置之间的主要区别在于，附加程序的<em>class</em>属性标识了<code>SSLServerSocketAppender</code>类型，以及嵌套<span class="prop">ssl</span>元素的存在，在此示例中，该元素指定了密钥存储的配置，该密钥存储包含用于附加程序的X.509凭证。有关SSL配置属性的信息，请参阅<a href="usingSSL.html">使用SSL</a> 。
    </p>
    
    <p>因为<code>ServerSocketAppender</code>子类型旨在与接收器组件一起使用，我们将在“ <a href="receivers.html">接收器</a> ”一章中介绍示例。</p>
    
   <h3 class="doAnchor">SMTPAppender</h3>
   
   <p>的<a href="../xref/ch/qos/logback/classic/net/SMTPAppender.html"><code>SMTPAppender</code></a>在用户指定的事件发生后，将日志事件累积在一个或多个固定大小的缓冲区中，并在电子邮件中发送适当缓冲区的内容。SMTP电子邮件传输（发送）是异步执行的。默认情况下，电子邮件传输由级别为ERROR的日志记录事件触发。此外，默认情况下，所有事件都使用单个缓冲区。
   </p>
		
   <p>的各种属性<code>SMTPAppender</code>下表汇总。
	 </p>
		
		<table class="bodyTable striped">
      <tbody><tr>
        <th>物业名称</th>
        <th>类型</th>
        <th>描述</th>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">smtpHost</span></td>
        <td><code>String</code></td>
        <td>SMTP服务器的主机名。此参数是必需的。</td>
      </tr>
      
      <tr>
        <td><span class="prop" container="smtp">smtpPort</span></td>
        <td><code>int</code></td>
        <td>SMTP服务器正在侦听的端口。默认为25。</td>
      </tr>
      
      <tr>
        <td><span class="prop" name="smtpTo">至</span></td>
        <td><code>String</code></td>
        <td>收件人的电子邮件地址，作为一种<em>模式</em> 。使用触发事件作为每个外发电子邮件的输入来重新评估该模式。可以通过用逗号分隔目标地址来指定多个收件人。或者，也可以使用多个指定多个收件人<code><to></code>元素。
        </td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">从</span></td>
        <td><code>String</code></td>
        <td>发送的电子邮件的发起者<code>SMTPAppender</code>以<a href="http://en.wikipedia.org/wiki/Email_address">通常的电子邮件地址格式</a> 。如果您希望包含发件人的姓名，请使用格式“ Adam Smith <smith@moral.org>”，以使消息显示为源自“ Adam Smith <smith@moral.org>”。
        </smith@moral.org></td>
      </tr>
      <tr>
        <td><span class="prop">学科</span></td>
        <td><code>String</code></td>
        <td> 
          <p>电子邮件的主题。它可以是<a href="layouts.html#ClassicPatternLayout">PatternLayout</a>接受为有效转换模式的任何值。布局将在下一章中讨论。
          </p>
          
          <p>外发电子邮件将有一个主题行，该主题行对应于在触发电子邮件的记录事件上应用模式。
          </p>

          <p>假设<span class="prop">主题</span>选项设置为“ Log：％logger-％msg”，并且触发事件的记录器名为“ com.foo”。栏”，并包含消息“ Hello world”，那么外发电子邮件的主题行将为“ Log：com.foo”。酒吧-Hello World”。
          </p>

          <p>默认情况下，此选项设置为“％logger {20}-％m”。</p>
        </td>
        
      </tr>
      <tr>
        <td><span class="prop" container="smtp">判别器</span></td>
        <td><code><a href="../xref/ch/qos/logback/core/sift/Discriminator.html">Discriminator</a></code></td>
        <td>
          <p>在<span class="prop">歧视者</span>的帮助下， <code>SMTPAppender</code>可以根据区分符返回的值将传入事件分散到不同的缓冲区中。默认的鉴别符始终返回相同的值，以便对所有事件使用相同的缓冲区。
          </p>

          <p>通过指定除默认标识符以外的标识符，可以接收包含与特定用户，用户会话或客户端IP地址有关的事件的电子邮件。
          </p>
        </td>
      </tr>
      <tr>
        <td><span class="prop" name="smtpAppender_Evaluator">评估者</span></td>
        <td><code><a href="../xref/ch/qos/logback/classic/boolex/IEvaluator.html">IEvaluator</a></code></td>
        <td>
          <p>通过创建新选项来声明此选项<code><EventEvaluator/></code>元件。用户希望用作的类的名称<code>SMTPAppender</code>的<code>Evaluator</code>需要通过<span class="attr">class</span>属性指定。
          </p>
          
          
          <p>如果没有此选项， <code>SMTPAppender</code>被分配了一个<a href="../xref/ch/qos/logback/classic/boolex/OnErrorEvaluator.html">OnErrorEvaluator</a>实例，该实例在遇到<em>ERROR</em>或更高级别的事件时触发电子邮件传输。
          </p>

          <!--
          <p><code>EventEvaluator</code> objects are subclasses of the
          <code>JaninoEventEvaluatorBase</code> which depends on
          Janino. See the <a href="../dependencies.html">dependencies
          page</a> for more information.
          </p>
          -->

          <p>Logback附带了其他几个评估器，即<a href="../xref/ch/qos/logback/classic/boolex/OnMarkerEvaluator.html"><code>OnMarkerEvaluator</code></a> （如下所述）和功能强大的评估师<a href="../xref/ch/qos/logback/classic/boolex/JaninoEventEvaluator.html"><code>JaninoEventEvaluator</code></a>在<a href="filters.html#evalutatorFilter">另一章中</a>讨论。最新版本的logback附带了一个更强大的评估程序，称为<a href="filters.html#GEventEvaluator"><code>GEventEvaluator</code></a> 。
          </p>

        </td>
      </tr>

      <tr>
        <td valign="top"><span class="prop" container="smtp">cyclicBufferTracker</span></td>
        <td><a href="../xref/ch/qos/logback/core/spi/CyclicBufferTracker.html"><code>CyclicBufferTracker</code></a>
        </td>
        <td>
          <p>顾名思义， <code>CyclicBufferTracker</code>类跟踪循环缓冲区。它是根据<span class="prop">鉴别器</span>返回的键来实现的（请参见上文）。
          </p>
          <p>如果不指定<span class="prop">cyclicBufferTracker，</span>实例<a href="../xref/ch/qos/logback/core/spi/CyclicBufferTracker.html">CyclicBufferTracker</a>将自动创建。默认情况下，此实例会将事件保留在大小为256的循环缓冲区中。您可以在<span class="prop">bufferSize</span>选项的帮助下更改大小（请参见下文）。</p>
        </td>        
      </tr>
      <tr>
        <td><span class="prop" container="smtp">用户名</span></td>
        <td><code>String</code></td> <td>在普通用户/密码身份验证期间使用的用户名值。默认情况下，此参数为null。</td> 
      </tr> 
      <tr class="alt">
        <td><span class="prop" container="smtp">密码</span></td>
        <td><code>String</code></td>
        <td>用于普通用户/密码身份验证的密码值。默认情况下，此参数为null。
        </td>
      </tr>
      <tr> 
        <td><span class="prop" container="smtp">STARTTLS</span> </td>
        <td><code>boolean</code></td> 
        <td>如果将此参数设置为true，则此附加程序将发出STARTTLS命令（如果服务器支持），导致连接切换到SSL。请注意，该连接最初是未加密的。默认情况下，此参数设置为false。
        </td> 
      </tr>
      <tr>
        <td><span class="prop" container="smtp">SSL协议</span></td>
        <td><code>boolean</code></td> <td>如果将此参数设置为true，则此附加程序将打开与服务器的SSL连接。默认情况下，此参数设置为false。</td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">charsetEncoding</span></td>
        <td><code>String</code></td>
        <td>外发电子邮件将被编码为指定的<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html">字符集</a> 。默认的字符集编码为“ UTF-8”，在大多数情况下效果很好。
        </td>
      </tr>


      <tr>
        <td><span class="prop" container="smtp">本地主机</span></td>
        <td><code>String</code></td>
        <td>如果未正确配置SMTP客户端的主机名，例如，如果客户端主机名不完全合格，则某些SMTP服务器可能会拒绝客户端发送的HELO / EHLO命令。要解决此问题，可以将<span class="prop">localhost</span>属性的值设置为客户端主机的标准名称。另请参阅<a href="http://javamail.kenai.com/nonav/javadocs/com/sun/mail/smtp/package-summary.html">com.sun.mail.smtp</a>软件包的文档中的“ mail.smtp.localhost”属性。</td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">异步发送</span></td>
        <td><code>boolean</code></td>
        <td>此属性确定电子邮件传输是否异步完成。默认情况下， <span class="prop">asynchronousSending</span>属性为“ true”。但是，在某些情况下，异步发送可能是不合适的。例如，如果您的应用程序使用<code>SMTPAppender</code>要发送警报以响应致命错误，然后退出，相关线程可能没有时间发送警报电子邮件。在这种情况下，将<span class="prop">异步发送</span>属性设置为“ false”以进行同步电子邮件传输。
        </td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>默认情况下， <span class="prop">includeCallerData</span>设置为<code>false</code> 。您应该将<span class="prop">includeCallerData</span>设置为<code>true</code>如果启用了<span class="prop">异步发送</span> ，并且您希望在日志中包括呼叫者数据。</td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">sessionViaJNDI</span></td>
        <td><code>boolean</code></td>
        <td><code>SMTPAppender</code>依靠<code>javax.mail.Session</code>发送电子邮件。默认情况下， <span class="prop">sessionViaJNDI</span>设置为<code>false</code>所以<code>javax.mail.Session</code>实例是由<code>SMTPAppender</code>本身具有用户指定的属性。如果<span class="prop">sessionViaJNDI</span>属性设置为<code>true</code> ， <code>javax.mail.Session</code>对象将通过JNDI检索。另请参见<span class="prop">jndiLocation</span>属性。

        <p>检索<code>Session</code>通过JNDI可以减少您需要配置/重新配置相同信息的位置数量，从而使应用程序变得更<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">干燥</a> 。有关在Tomcat中配置资源的更多信息，请参见《 <a href="http://tomcat.apache.org/tomcat-6.0-doc/jndi-resources-howto.html#JavaMail_Sessions">JNDI资源指南》</a> 。 <span class="label">请</span>注意，如该文档中所述，在检索以下内容时，请确保从Web应用程序<em>WEB-INF / lib</em>文件夹中删除<em>mail.jar</em>和<em>activation.jar</em> 。 <code>Session</code>来自JNDI。</p>
        </td>
      </tr>

      <tr>
        <td><span class="prop" container="smtp">jndi位置</span></td>
        <td><code>String</code></td>
        <td>javax.mail的位置。会话放置在JNDI中。默认情况下， <span class="prop">jndiLocation</span>设置为<span style="white-space:nowrap">“ java：comp / env / mail / Session”</span> 。
        </td>
      </tr>

		</tbody></table>		
		
		<p>的<code>SMTPAppender</code>仅将最后的256个日志记录事件保留在其循环缓冲区中，当缓冲区变满时将丢弃较旧的事件。因此，在由发送的任何电子邮件中传递的日志记录事件数<code>SMTPAppender</code>上限为256。这使内存需求不受限制，同时仍提供合理数量的应用程序上下文。
		</p>
		
		<p>的<code>SMTPAppender</code>依赖于JavaMail API。已通过JavaMail API 1.4版进行了测试。JavaMail API需要JavaBeans激活框架包。您可以从各自的网站下载<a href="http://java.sun.com/products/javamail/">JavaMail API</a>和<a href="http://java.sun.com/beans/glasgow/jaf.html">JavaBeans激活框架</a> 。在尝试以下示例之前，请确保将这两个jar文件放置在类路径中。
		</p>
		
		<p>一个示例应用程序<a href="../xref/chapters/appenders/mail/EMail.html"><code>chapters.appenders.mail.EMail</code></a>生成许多日志消息，后跟一条错误消息。它有两个参数。第一个参数是一个整数，对应于要生成的日志记录事件的数量。第二个参数是logback配置文件。由<em>电子邮件</em>应用程序生成的最后一个日志记录事件（错误）将触发电子邮件的传输。
		</p>

		<p>这是用于<code>Email</code>应用：</p>	
		
    <p class="example">示例：一个样本<code>SMTPAppender</code>配置（logback-examples / src / main / resources / chapters / appenders / mail / mail1.xml）</p>	
    <span class="asGroovy" onclick="return asGroovy('mail1');">观看为.groovy</span>	
    <pre id="mail1" class="prettyprint source">&lt;configuration>	  
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    &lt;smtpHost>ADDRESS-OF-YOUR-SMTP-HOST&lt;/smtpHost>
    &lt;to>EMAIL-DESTINATION&lt;/to>
    &lt;to>ANOTHER_EMAIL_DESTINATION&lt;/to> &lt;!-- additional destinations are possible --&gt;
    &lt;from>SENDER-EMAIL&lt;/from>
    &lt;subject>TESTING: %logger{20} - %m&lt;/subject>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;pattern>%date %-5level %logger{35} - %message%n&lt;/pattern>
    &lt;/layout>	    
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="EMAIL" />
  &lt;/root>  
&lt;/configuration></pre>

		<p>尝试之前<code>chapters.appenders.mail.Email</code>应用上述的配置文件，您必须将<span class="prop">smtpHost，</span> <span class="prop">设置</span> <span class="prop">和</span>属性值适合您的环境。在配置文件中设置正确的值后，执行以下命令：</p>
		
<div class="source"><pre>java chapters.appenders.mail.EMail 100 src/main/java/chapters/appenders/mail/mail1.xml</pre></div>

		<p>您指定的收件人应收到一封电子邮件，其中包含100个日志记录事件，格式为<code>PatternLayout</code>下图是由此产生的电子邮件，如Mozilla Thunderbird所示。
		</p>
    
    <p><img src="images/chapters/appenders/smtpAppender1.jpg" alt="产生的电子邮件"></p>
		
		<p>在接下来的示例配置文件<em>mail2.xml，</em>对于<span class="prop">smtpHost</span>的值， <span class="prop">和</span> <span class="prop">从</span>属性是由变量替代确定。这是<em>mail2.xml</em>的相关部分。
		</p>		

    <pre class="prettyprint source">&lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
  &lt;smtpHost>${smtpHost}&lt;/smtpHost>
  &lt;to>${to}&lt;/to>
  &lt;from>${from}&lt;/from>
  &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/>
&lt;/appender></pre>
		
		<p>您可以在命令行上传递所需的参数：</p>
		
<div class="source"><pre>java -Dfrom=source@xyz.com -Dto=recipient@xyz.com -DsmtpHost=some_smtp_host \
  chapters.appenders.mail.EMail 10000 src/main/java/chapters/appenders/mail/mail2.xml
</pre></div>

		<p>确保用适合您的环境的值替换。
		</p>
		
		<p>请注意，在此最新示例中， <code>PatternLayout</code>被替换为<code>HTMLLayout</code>将日志格式设置为HTML表。您可以更改列的列表和顺序以及表格的CSS。请参阅<a href="layouts.html#ClassicHTMLLayout">HTMLLayout</a>文档以获取更多详细信息。
    </p>
    
    <p>给定循环缓冲区的大小为256，收件人应该会看到一封电子邮件，其中包含256个事件，这些事件方便地以HTML表格格式设置。请注意， <code>chapters.appenders.mail.Email</code>应用程序生成了10'000个事件，其中仅最后256个事件包含在传出电子邮件中。
		</p>
		
    <p><img src="images/chapters/appenders/smtpAppender2.jpg" alt="第二封电子邮件"></p>

    <p>电子邮件客户端（例如Mozilla Thunderbird，Eudora或MS Outlook）为HTML电子邮件提供了相当不错的CSS支持。但是，它们有时会自动将HTML降级为纯文本。例如，要在Thunderbird中查看HTML电子邮件，必须设置“查看→消息正文为→原始HTML”选项。雅虎！ Mail对HTML电子邮件的支持，特别是对CSS的支持非常好。另一方面，Gmail遵循基本的HTML表结构，却忽略了内部CSS格式。Gmail支持内联CSS格式，但由于内联CSS会使输出结果过于庞大， <code>HTMLLayout</code>不使用内联CSS。</p>

    <h3 class="doAnchor" name="cyclicBufferSize">自定义缓冲区大小</h3>

    <p>默认情况下，外发邮件将包含由<code>SMTPAppender</code> 。如果您的心愿，可以设置一个不同的缓冲区大小，如下例所示。
    </p>

   <p class="example">例： <code>SMTPAppender</code>具有自定义缓冲区大小的配置（logback-examples / src / main / resources / chapters / appenders / mail / customBufferSize.xml）</p>	
    <pre class="prettyprint source">&lt;configuration>   
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    &lt;smtpHost>${smtpHost}&lt;/smtpHost>
    &lt;to>${to}&lt;/to>
    &lt;from>${from}&lt;/from>
    &lt;subject>%logger{20} - %m&lt;/subject>
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/>

    <b>&lt;cyclicBufferTracker class="ch.qos.logback.core.spi.CyclicBufferTracker"></b>
      <b>&lt;!-- send just one log entry per email --></b>
      <b>&lt;bufferSize>1&lt;/bufferSize></b>
    <b>&lt;/cyclicBufferTracker></b>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="EMAIL" />
  &lt;/root>  
&lt;/configuration>    </pre>
    

    <h3 class="doAnchor">触发事件</h3>

    <p>如果未设置“评估者”属性，则<code>SMTPAppender</code>默认为<a href="../xref/ch/qos/logback/classic/boolex/OnErrorEvaluator.html">OnErrorEvaluator</a>实例，该实例在遇到ERROR级事件时触发电子邮件传输。虽然响应错误而触发传出电子邮件相对合理，但可以通过提供不同的实现来覆盖此默认行为。 <code>EventEvaluator</code>接口。
    </p>
		
		<p>的<code>SMTPAppender</code>通过调用将每个传入事件提交给评估者<code>evaluate()</code>方法，以检查事件是应该触发电子邮件还是将其放置在循环缓冲区中。当评估者对其评估给出肯定的答案时，将发送一封电子邮件。的<code>SMTPAppender</code>包含一个且只有一个评估者对象。该对象可以管理自己的内部状态。出于说明目的， <code>CounterBasedEvaluator</code>接下来列出的类实现一个事件评估器，由此每第1024个事件触发一次电子邮件。
		</p>

    <p class="example">示例：A <code>EventEvaluator</code>评估为<code>true</code>第1024个事件（ <a href="../xref/chapters/appenders/mail/CounterBasedEvaluator.html">logback-examples / src / main / java / chapters / appenders / mail / CounterBasedEvaluator.java</a> ）</p>
   
   <pre class="prettyprint source">package chapters.appenders.mail;

import ch.qos.logback.core.boolex.EvaluationException;
import ch.qos.logback.core.boolex.EventEvaluator;
import ch.qos.logback.core.spi.ContextAwareBase;

public class CounterBasedEvaluator extends ContextAwareBase implements EventEvaluator {

  static int LIMIT = 1024;
  int counter = 0;
  String name;

  <b>public boolean evaluate(Object event) throws NullPointerException,
      EvaluationException {
    counter++;

    if (counter == LIMIT) {
      counter = 0;

      return true;
    } else {
      return false;
    }
  }</b>

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}</pre>

		<p>请注意，此类扩展<code>ContextAwareBase</code>并实施<code>EventEvaluator</code> 。这使用户可以专注于她的核心功能<code>EventEvaluator</code>并让基类提供通用功能。
		</p>

		<p>设置的<span class="prop">评估者</span>选项<code>SMTPAppender</code>指示它使用自定义评估程序。下一个配置文件附加一个<code>SMTPAppender</code>到根记录器。此附加程序使用<code>CounterBasedEvaluator</code>实例作为其事件评估者。
		</p>

    <p class="example">例： <code>SMTPAppender</code>定制<code>Evaluator</code>和缓冲区大小（logback-examples / src / main / resources / chapters / appenders / mail / mail3.xml）</p>
    <span class="asGroovy" onclick="return asGroovy('mail3');">观看为.groovy</span>	
    <pre id="mail3" class="prettyprint source">&lt;configuration>
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    <b>&lt;evaluator class="chapters.appenders.mail.CounterBasedEvaluator" /></b>
    &lt;smtpHost>${smtpHost}&lt;/smtpHost>
    &lt;to>${to}&lt;/to>
    &lt;from>${from}&lt;/from>
    &lt;subject>%logger{20} - %m&lt;/subject>

    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="EMAIL" />
  &lt;/root>  
&lt;/configuration></pre>
    

    <h3 class="doAnchor" name="OnMarkerEvaluator">基于标记的触发</h3>

    <p>尽管合理，但是默认的触发策略（每个级别为ERROR的事件都会触发外发电子邮件）可能导致电子邮件过多，从而使目标用户的邮箱混乱。Logback附带了另一个触发策略，称为<a href="../xref/ch/qos/logback/classic/boolex/OnMarkerEvaluator.html">OnMarkerEvaluator</a> 。它基于标记。本质上，仅当事件用用户指定的标记标记时，电子邮件才会被触发。下一个示例应该更清楚地说明这一点。
    </p>

    <p><a href="../xref/chapters/appenders/mail/Marked_EMail.html">Marked_EMail</a>应用程序包含几个日志记录语句，其中一些语句的级别为ERROR。一个值得注意的陈述包含一个标记。这是相关的代码。
    </p>

    <pre class="prettyprint source">Marker notifyAdmin = MarkerFactory.getMarker("NOTIFY_ADMIN");
logger.error(<b>notifyAdmin</b>,
  "This is a serious an error requiring the admin's attention",
   new Exception("Just testing"));</pre>

   <p>下一个配置文件仅在出现带有NOTIFY_ADMIN或TRANSACTION_FAILURE标记的事件时才触发传出电子邮件。
   </p>

   <p class="example">例： <code>SMTPAppender</code>与<code>OnMarkerEvaluator</code> （logback-examples / src / main / resources / chapters / appenders / mail / mailWithMarker.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('mailWithMarker');">观看为.groovy</span>	
   <pre id="mailWithMarker" class="prettyprint source">&lt;configuration>
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    <b>&lt;evaluator class="ch.qos.logback.classic.boolex.OnMarkerEvaluator">
      &lt;marker>NOTIFY_ADMIN&lt;/marker>
      &lt;!-- you specify add as many markers as you want -->
      &lt;marker>TRANSACTION_FAILURE&lt;/marker>
    &lt;/evaluator></b>
    &lt;smtpHost>${smtpHost}&lt;/smtpHost>
    &lt;to>${to}&lt;/to>
    &lt;from>${from}&lt;/from>
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout"/>
  &lt;/appender>

  &lt;root>
    &lt;level value ="debug"/>
    &lt;appender-ref ref="EMAIL" />
  &lt;/root>  
&lt;/configuration></pre>
    
    <p>使用以下命令旋转一下：</p>

    <pre class="source">java -Dfrom=source@xyz.com -Dto=recipient@xyz.com -DsmtpHost=some_smtp_host \
  chapters.appenders.mail.Marked_EMail src/main/java/chapters/appenders/mail/mailWithMarker.xml</pre>


  <h4 class="doAnchor" name="marker_JaninoEventEvaluator">使用JaninoEventEvaluator进行基于标记的触发</h4>

    <p>请注意，不要使用以标记为中心的<code>OnMarkerEvaluator</code> ，我们可以使用更通用的<a href="filters.html#JaninoEventEvaluator"><code>JaninoEventEvaluator</code></a>或更强大的表弟<a href="filters.html#GEventEvaluator"><code>GEventEvaluator</code></a> 。例如，以下配置文件使用<code>JaninoEventEvaluator</code>代替<code>OnMarkerEvaluator</code>但等效于先前的配置文件。
    </p>

    <p class="example">例： <code>SMTPAppender</code>与<code>JaninoEventEvaluator</code> （logback-examples / src / main / resources / chapters / appenders / mail / mailWithMarker_Janino.xml）</p>

   <span class="asGroovy" onclick="return asGroovy('mailWithMarker_Janino');">观看为.groovy</span>	
    <pre id="mailWithMarker_Janino" class="prettyprint source">&lt;configuration>
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    &lt;evaluator class="ch.qos.logback.classic.boolex.JaninoEventEvaluator">
      &lt;expression>
        (marker != null) &amp;&amp;
        (marker.contains("NOTIFY_ADMIN") || marker.contains("TRANSACTION_FAILURE"))
      &lt;/expression>
    &lt;/evaluator>    
    ... same as above
  &lt;/appender>
&lt;/configuration></pre>

    <h4 class="doAnchor" name="marker_GEventEvaluator">使用GEventEvaluator进行基于标记的触发</h4>

    <p>这是使用<a href="filters.html#GEventEvaluator">GEventEvaluator</a>的等效评估器。</p>

    <p class="example">例子：同<code>GEventEvaluator</code> （logback-examples / src / main / resources / chapters / appenders / mail / mailWithMarker_GEvent.xml）</p>
   <span class="asGroovy" onclick="return asGroovy('mailWithMarker_GEventEvaluator');">观看为.groovy</span>	

   <pre id="mailWithMarker_GEventEvaluator" class="prettyprint source">&lt;configuration>
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    &lt;evaluator class="ch.qos.logback.classic.boolex.GEventEvaluator">
      &lt;expression>
        e.marker?.contains("NOTIFY_ADMIN") || e.marker?.contains("TRANSACTION_FAILURE")
      &lt;/expression>
    &lt;/evaluator>    
    ... same as above
  &lt;/appender>
&lt;/configuration></pre>

    <p>注意，由于事件可能缺少标记，因此e.marker的值可以为null。因此，使用Groovy的<a href="http://groovy.codehaus.org/Null+Object+Pattern">安全取消引用运算符</a> ，即。？。操作员。
    </p>


    <h3 class="doAnchor" name="smtpAuthentication">身份验证/ STARTTLS / SSL</h3>

    <p><code>SMTPAppender</code>支持通过普通用户密码以及STARTTLS和SSL协议进行身份验证。请注意，STARTTLS与SSL的不同之处在于，在STARTTLS中，连接最初是未加密的，并且只有在客户端发出STARTTLS命令（如果服务器支持）之后，连接才会切换到SSL。在SSL模式下，连接从一开始就被加密。
    </p>

    <h3 class="doAnchor" name="gmailSSL">Gmail（SMTP）的SMTPAppender配置</h3>

    <p>下一个示例向您展示如何配置<code>SMTPAppender</code>适用于具有SSL协议的Gmail。</p>
    
    <p class="example">例：： <code>SMTPAppender</code>使用SSL到Gmail（logback-examples / src / main / resources / chapters / appenders / mail / gmailSSL.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('gmailSSLExample');">观看为.groovy</span>	
    <pre id="gmailSSLExample" class="prettyprint source">&lt;configuration>
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    <b>&lt;smtpHost>smtp.gmail.com&lt;/smtpHost></b>
    <b>&lt;smtpPort>465&lt;/smtpPort></b>
    <b>&lt;SSL>true&lt;/SSL></b>
    <b>&lt;username>YOUR_USERNAME@gmail.com&lt;/username></b>
    <b>&lt;password>YOUR_GMAIL_PASSWORD&lt;/password></b>

    &lt;to>EMAIL-DESTINATION&lt;/to>
    &lt;to>ANOTHER_EMAIL_DESTINATION&lt;/to> &lt;!-- additional destinations are possible -->
    &lt;from>YOUR_USERNAME@gmail.com&lt;/from>
    &lt;subject>TESTING: %logger{20} - %m&lt;/subject>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;pattern>%date %-5level %logger{35} - %message%n&lt;/pattern>
    &lt;/layout>	    
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="EMAIL" />
  &lt;/root>  
&lt;/configuration></pre>


    <h3 class="doAnchor" name="gmailSTARTTLS">适用于Gmail的SMTPAppender（STARTTLS）</h3>

    <p>下一个示例向您展示如何配置<code>SMTPAppender</code>适用于STARTTLS协议的Gmail。</p>

    <p class="example">例： <code>SMTPAppender</code>使用STARTTLS到GMAIL（logback-examples / src / main / resources / chapters / appenders / mail / gmailSTARTTLS.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('gmailSTARTTLSExample');">观看为.groovy</span>	
    <pre id="gmailSTARTTLSExample" class="prettyprint source">&lt;configuration>	  
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    &lt;smtpHost>smtp.gmail.com&lt;/smtpHost>
    &lt;smtpPort>587&lt;/smtpPort>
    &lt;STARTTLS>true&lt;/STARTTLS>
    &lt;username>YOUR_USERNAME@gmail.com&lt;/username>
    &lt;password>YOUR_GMAIL_xPASSWORD&lt;/password>
    
    &lt;to>EMAIL-DESTINATION&lt;/to>
    &lt;to>ANOTHER_EMAIL_DESTINATION&lt;/to> &lt;!-- additional destinations are possible -->
    &lt;from>YOUR_USERNAME@gmail.com&lt;/from>
    &lt;subject>TESTING: %logger{20} - %m&lt;/subject>
    &lt;layout class="ch.qos.logback.classic.PatternLayout">
      &lt;pattern>%date %-5level %logger - %message%n&lt;/pattern>
    &lt;/layout>	    
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="EMAIL" />
  &lt;/root>  
&lt;/configuration></pre>


    <h3 class="doAnchor" name="smtpDiscriminator">带有MDCDiscriminator的SMTPAppender</h3>


    <p>如前所述，通过指定除默认标识符以外的其他标识符， <code>SMTPAppender</code>将根据指定的标识符生成包含与特定用户，用户会话或客户端IP地址有关的事件的电子邮件。
    </p>

    <p>下一个示例说明了<a href="../xref/ch/qos/logback/classic/sift/MDCBasedDiscriminator.html">MDCBasedDiscriminator</a>与名为“ req.remoteHost”的MDC密钥的结合使用，假定该密钥包含访问虚拟应用程序的远程主机的IP地址。在Web应用程序中，可以使用<a href="mdc.html#mis">MDCInsertingServletFilter</a>填充MDC值。
    </p>

    <p class="example">例： <code>SMTPAppender</code>使用MDCBasedDsicriminator（logback-examples / src / main / resources / chapters / appenders / mail / mailWithMDCBasedDiscriminator.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('mailWithMDCBasedDiscriminator');">观看为.groovy</span>	
    <pre id="mailWithMDCBasedDiscriminator" class="prettyprint source">&lt;configuration>	  
  &lt;appender name="EMAIL" class="ch.qos.logback.classic.net.SMTPAppender">
    &lt;smtpHost>ADDRESS-OF-YOUR-SMTP-HOST&lt;/smtpHost>
    &lt;to>EMAIL-DESTINATION&lt;/to>
    &lt;from>SENDER-EMAIL&lt;/from>

    <b>&lt;discriminator class="ch.qos.logback.classic.sift.MDCBasedDiscriminator"></b>
      <b>&lt;key>req.remoteHost&lt;/key></b>
      <b>&lt;defaultValue>default&lt;/defaultValue></b>
    <b>&lt;/discriminator></b>

    &lt;subject>${HOSTNAME} -- %X{req.remoteHost} %msg"&lt;/subject>
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout">
      &lt;pattern>%date%level%thread%X{req.remoteHost}%X{req.requestURL}%logger%msg&lt;/pattern>
    &lt;/layout>
  &lt;/appender>

  &lt;root>
    &lt;level level="DEBUG"/>
    &lt;appender-ref ref="EMAIL" />
  &lt;/root>  
&lt;/configuration></pre>

    <p>因此，由<code>SMTPAppender</code>将属于<em>唯一的</em>远程主机，极大地促进了问题诊断。
    </p>
    
    <h4 class="doAnchor" name="bufferManagement">繁忙系统中的缓冲区管理</h4>

    <p>在内部，鉴别器返回的每个不同的值都将导致创建新的循环缓冲区。但是，最多将保留<span class="prop">maxNumberOfBuffers</span> （默认为64）。每当缓冲区的数量超过<span class="prop">maxNumberOfBuffers时</span> ，将自动丢弃最近更新的缓冲区。作为第二安全措施，最近30分钟内未更新的任何缓冲区也将被自动丢弃。</p>

    <p>在每分钟处理大量事务的系统上，仅允许<span class="prop">maxNumberOfBuffers的</span>数量<span class="prop">很少</span> （默认为64）通常会导致传出电子邮件中的事件数量不必要地减少。实际上，在存在大量事务的情况下，与同一事务相关联的缓冲区将不止一个，因为对于相同的区分值（或事务），缓冲区将被终止并相继重生。请注意，即使在这样非常繁忙的系统中，循环缓冲区的最大数量也受<span class="prop">maxNumberOfBuffers的限制</span> 。
    </p>

    <p>为了避免这种溜溜球效应， <code>SMTPAppender</code>一旦看到一个标记为“ FINALIZE_SESSION”的事件，它将立即释放与给定标识符键关联的缓冲区。这将导致在每个事务结束时丢弃适当的缓冲区。然后，您可以安全地将<span class="prop">maxNumberOfBuffers</span>的值<span class="prop">增加到</span>较大的值，例如512或1024，而不必担心内存不足。
    </p>

    <p>有三种不同但互补的机制共同管理循环缓冲区。它们确保即使在非常繁忙的系统中，在任何给定的时刻，只有相关的缓冲区保持活动状态。</p>

    <!-- =========================================================== -->
    <!-- =========================================================== -->


    <h3 class="doAnchor" name="DBAppender">DBAppender</h3>
		
		<p>的<a href="../xref/ch/qos/logback/classic/db/DBAppender.html"><code>DBAppender</code></a>以独立于Java编程语言的格式将日志记录事件插入到三个数据库表中。
		</p>

		<p>这三个表是<em>logging_event</em> ， <em>logging_event_property</em>和<em>logging_event_exception</em> 。它们必须存在之前<code>DBAppender</code>可以使用。Logback附带了将创建表的SQL脚本。它们可以在<em>logback-classic / src / main / java / ch / qos / logback / classic / db / script</em>文件夹下找到。每个最受欢迎的数据库系统都有一个特定的脚本。如果缺少用于您特定类型的数据库系统的脚本，那么以已经存在的脚本为例，应该很容易编写一个脚本。如果您将它们发送给我们，我们将很乐意在将来的版本中包含缺少的脚本。
		</p>

		<p>如果您的JDBC驱动程序支持<code>getGeneratedKeys</code> JDBC 3.0规范中引入的方法，假设您已经创建了如上所述的适当的数据库表，则不需要其他步骤。否则，必须有一个<code>SQLDialect</code>适用于您的数据库系统。当前，logback具有适用于H2，HSQL，MS SQL Server，MySQL，Oracle，PostgreSQL，SQLLite和Sybase的方言。</p>

		<p>下表总结了数据库类型及其对数据库的支持。 <code>getGeneratedKeys()</code>方法。
		</p>

		<table class="bodyTable striped" border="0" cellpadding="4">
			<tbody><tr>
				<th>关系数据库管理系统</th>
        <th>测试版本</th>
        <th>经过测试的JDBC驱动程序版本</th>
        <th>支持<br>
					<code>getGeneratedKeys()</code>方法</th>		

        <th>是方言<br>由logback提供</th>
			</tr>

      <tr>
				<td>DB2</td>
        <td>未经测试</td>
				<td>未经测试</td>
				<td>未知</td>
        <td>没有</td>
			</tr>

      <tr>
        <td>H2</td>
        <td>1.2.132</td>
        <td>--</td>
				<td>未知</td>
        <td>是</td>
			</tr>

      <tr>
        <td>HSQL</td>
        <td>1.8.0.7</td>
        <td>--</td>
				<td>没有</td>
        <td>是</td>
			</tr>

      <tr>
        <td>Microsoft SQL服务器</td>
        <td>2005年</td>
        <td>2.0.1008.2（sqljdbc.jar）</td>
				<td>是</td>
        <td>是</td>
			</tr>

      <tr>
				<td>的MySQL</td>
        <td>5.0.22</td>
        <td>5.0.8（mysql-connector.jar）</td>        
				<td>是</td>
        <td>是</td>
			</tr>

			<tr>
				<td>PostgreSQL的</td>
        <td>8.x</td>
        <td>8.4-701.jdbc4</td>
				<td>没有</td>
        <td>是</td>

			</tr>
		
			<tr>
				<td>甲骨文</td>
        <td>10克</td>
        <td>10.2.0.1（ojdbc14.jar）</td>
				<td>是</td>
        <td>是</td>
			</tr>
	
      <tr>
        <td>SQLLite</td>
        <td>3.7.4</td>
        <td>--</td>
        <td>未知</td>
        <td>是</td>
      </tr>
	
			
      <tr>
        <td>Sybase SQLAnywhere</td>
        <td>10.0.1</td>
        <td>--</td>
        <td>未知</td>
        <td>是</td>
      </tr>

		</tbody></table>
		
		<p>实验表明，在“标准” PC上，将单个事件写入数据库大约需要10毫秒。如果使用池连接，则该数字下降到大约1毫秒。请注意，大多数JDBC驱动程序已经附带连接池支持。
		</p>
		
		<p>配置要使用的登录<code>DBAppender</code>可以通过几种不同的方式来完成，这取决于必须连接到数据库的工具以及数据库本身。配置中的关键问题<code>DBAppender</code>关于设置它<code>ConnectionSource</code>我们很快就会发现。
		</p>
		
		<p>一旦<code>DBAppender</code>为您的数据库配置后，日志记录事件将发送到指定的数据库。如前所述，logback使用三个表来存储日志记录事件数据。
		</p>
		
		<p><em>logging_event</em>表包含以下字段：</p>
		<table class="bodyTable striped">
			<tbody><tr>
				<th>领域</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td><b>时间戳记</b></td>
				<td><code>big int</code></td>
				<td>创建日志事件时有效的时间戳。</td>
			</tr>
			<tr>
				<td><b>formatted_message</b></td>
				<td><code>text</code></td>

				<td>使用以下命令格式化后已添加到日志记录事件中的消息<code>org.slf4j.impl.MessageFormatter</code> ，以防对象随消息一起传递。</td>
			</tr>
			<tr>
				<td><b>logger_name</b></td>
				<td><code>varchar</code></td>
				<td>用于发出日志记录请求的记录器的名称。</td>
			</tr>
			<tr>
				<td><b>level_string</b></td>
				<td><code>varchar</code></td>
				<td>日志记录事件的级别。</td>
			</tr>
			<tr>
				<td><b>reference_flag</b></td>
				<td><code>smallint</code></td>
				<td>
					<p>Logback使用此字段来标识具有异常或<code>MDC</code>属性值关联。
					</p>

					<p>其值由下式计算<code>ch.qos.logback.classic.db.DBHelper</code> 。包含以下内容的日志记录事件<code>MDC</code>要么<code>Context</code>属性的标志号为<em>1</em> 。包含异常的标记的标记号为<em>2</em> 。包含这两个元素的日志事件的标志号为<em>3</em> 。
					</p>
				</td>
			</tr>
			<tr>
				<td><b>呼叫者档案名称</b></td>
				<td><code>varchar</code></td>
				<td>发出日志记录请求的文件的名称。</td>
			</tr>
			<tr>
				<td><b>caller_class</b></td>
				<td><code>varchar</code></td>
				<td>发出日志记录请求的类。</td>
			</tr>
			<tr>
				<td><b>caller_method</b></td>
				<td><code>varchar</code></td>
				<td>发出日志记录请求的方法的名称。</td>
			</tr>
			<tr>
				<td><b>caller_line</b></td>
				<td><code>char</code></td>
				<td>发出日志记录请求的行号。</td>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>日志记录事件的数据库标识。</td>
			</tr>
		</tbody></table>
		
		<p><em>logging_event_property</em>用于存储包含在密钥中的键和值。 <code>MDC</code>或者<code>Context</code> 。它包含以下字段：</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>领域</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>日志记录事件的数据库标识。</td>
			</tr>
			<tr>
				<td><b>映射键</b></td>
				<td><code>varchar</code></td>
				<td>的关键<code>MDC</code>属性</td>
			</tr>		
			<tr>
				<td><b>映射值</b></td>
				<td><code>text</code></td>
				<td>的价值<code>MDC</code>属性</td>
			</tr>				
		</tbody></table>
		
		<p><em>logging_event_exception</em>表包含以下字段：</p>
		
		<table class="bodyTable striped">
			<tbody><tr>
				<th>领域</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>日志记录事件的数据库标识。</td>
			</tr>
			<tr>
				<td><b>一世</b></td>
				<td><code>smallint</code></td>
				<td>行在完整堆栈跟踪中的索引。</td>
			</tr>		
			<tr>
				<td><b>trace_line</b></td>
				<td><code>varchar</code></td>
				<td>对应行</td>
			</tr>				
		</tbody></table>
		
		<p>给出一个更直观的例子，说明<code>DBAppender</code> ，这是MySQL数据库的屏幕截图，其中包含的内容由<code>DBAppender</code> 。
		</p>
		
		<p><em>logging_event</em>表：</p>

		<img src="images/chapters/appenders/dbAppenderLE.gif" alt="记录事件表">

		<p><em>logging_event_exception</em>表：</p>
		
		<img src="images/chapters/appenders/dbAppenderLEException.gif" alt="记录事件异常表">

		<p><em>logging_event_property</em>表：</p>
		
		<img src="images/chapters/appenders/dbAppenderLEProperty.gif" alt="记录事件属性表">

		
		<h4>连接源</h4>
		
		<p>的<code>ConnectionSource</code>接口提供了一种可插拔的方式，可以透明地获取需要使用的登录类的JDBC连接。 <code>java.sql.Connection</code> 。当前有三种实现<code>ConnectionSource</code> ，即<code>DataSourceConnectionSource</code> ， <code>DriverManagerConnectionSource</code>和<code>JNDIConnectionSource</code> 。
		</p>
		
		<p>我们将审查的第一个示例是使用<code>DriverManagerConnectionSource</code>和一个MySQL数据库。以下配置文件是需要的。
		</p>
		
    <p class="example">例： <code>DBAppender</code>配置（logback-examples / src / main / resources / chapters / appenders / db / append-toMySQL-with-driverManager.xml）</p>
    <span class="asGroovy" onclick="return asGroovy('append-toMySQL-with-driverManager');">观看为.groovy</span>	
    <pre id="append-toMySQL-with-driverManager" class="prettyprint source">&lt;configuration>

  <b>&lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender">
    &lt;connectionSource class="ch.qos.logback.core.db.DriverManagerConnectionSource">
      &lt;driverClass>com.mysql.jdbc.Driver&lt;/driverClass>
      &lt;url>jdbc:mysql://host_name:3306/datebase_name&lt;/url>
      &lt;user>username&lt;/user>
      &lt;password>password&lt;/password>
    &lt;/connectionSource>
  &lt;/appender></b>
  
  &lt;root level="DEBUG" >
    &lt;appender-ref ref="DB" />
  &lt;/root>
&lt;/configuration></pre>

		<p>必须声明正确的驱动程序。在这里<code>com.mysql.jdbc.Driver</code>使用类。<span class="prop">网址</span>必须以<em>jdbc：mysql：//</em>开头。
		</p>
		
		<p>的<a href="../xref/ch/qos/logback/core/db/DriverManagerConnectionSource.html"><code>DriverManagerConnectionSource</code></a>是一个实现<code>ConnectionSource</code>它基于连接URL以传统的JDBC方式获得连接。</p>
		<p>请注意，该类将建立一个新的<code>Connection</code>每次致电<code>getConnection()</code> 。建议您使用本机支持连接池的JDBC驱动程序，或者创建自己的实现<code>ConnectionSource</code>利用您已经在使用的任何池化机制。如果您有权访问支持以下内容的JNDI实现<code>javax.sql.DataSource</code> ，例如在J2EE应用服务器中，请参见<a href="#JNDIConnectionSource"><code>JNDIConnectionSource</code></a>下面。
		</p>
<!-- 
		
		HAS TO BE TESTED

		<p>
			If you do not have another connection pooling mechanism built
			into your application, you can use the
			<a href="http://jakarta.apache.org/commons/dbcp/index.html">
		  commons-dbcp </a> package from Apache:
		</p>

<pre class="prettyprint source">
  &lt;connectionSource
    class=&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;&gt;
    &lt;param name=&quot;driver&quot; value=&quot;org.apache.commons.dbcp.PoolingDriver&quot;/&gt; 
    &lt;param name=&quot;url&quot; value=&quot;jdbc:apache:commons:dbcp:/myPoolingDriver&quot;/&gt; 
  &lt;/connectionSource&gt;
</pre>
		
		<p>
			Then the configuration information for the commons-dbcp
			package goes into the file <em>myPoolingDriver.jocl</em> and is
			placed in the classpath. See the
			<a href="http://jakarta.apache.org/commons/dbcp/index.html"> commons-dbcp </a>
			documentation for details.
		</p>
 -->
 
		<p>使用数据库连接到数据库<code>DataSource</code>相当相似。现在配置使用<a href="../xref/ch/qos/logback/core/db/DataSourceConnectionSource.html"><code>DataSourceConnectionSource</code></a> ，这是<code>ConnectionSource</code>获得<code>Connection</code>以推荐的JDBC方式（基于<code>javax.sql.DataSource</code> 。
		</p>
	
    <p class="example">例： <code>DBAppender</code>配置（logback-examples / src / main / resources / chapters / appenders / db / append-with-datasource.xml）</p>	


    <span class="asGroovy" onclick="return asGroovy('append-with-datasource');">观看为.groovy</span>	
    <pre id="append-with-datasource" class="prettyprint source">&lt;configuration  debug="true">

  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender">
     <b>&lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource">
       
       &lt;dataSource class="${dataSourceClass}">
       	 </b>&lt;!-- Joran cannot substitute variables
       	 that are not attribute values. Therefore, we cannot
       	 declare the next parameter like the others. 
       	 -->
         <b>&lt;param name="${url-key:-url}" value="${url_value}"/>
         &lt;serverName>${serverName}&lt;/serverName>
         &lt;databaseName>${databaseName}&lt;/databaseName>
       &lt;/dataSource></b>
       
       &lt;user>${user}&lt;/user>
       &lt;password>${password}&lt;/password>
     &lt;/connectionSource>
  &lt;/appender>

  &lt;root level="INFO">
    &lt;appender-ref ref="DB" />
  &lt;/root>  
&lt;/configuration></pre>

		<p>请注意，在此配置示例中，我们大量使用了替换变量。当必须将连接详细信息集中在单个配置文件中并由Logback和其他框架共享时，它们有时很方便。
		</p>	
		
<!-- TO BE TESTED 

     <p>The connection created by
     <code>DataSourceConnectionSource</code> can be placed in a JNDI
     context by using <code>BindDataSourceToJNDIAction</code>. In that
     case, one has to specify the use of this class by adding a new
     rule to Joran, logback's configuration framework. Here is an
     excerpt of such a configuration file.  </p>
		
<div class="source"><pre>&lt;configuration>
  ..
  <b>&lt;newRule pattern="configuration/bindDataSourceToJNDI" 
           actionClass="ch.qos.logback.core.db.BindDataSourceToJNDIAction"/>
  	    
  &lt;bindDataSourceToJNDI /></b>
  ..
&lt;/configuration></pre></div>

		<p> The <em>newRule</em> element teaches Joran to use specified
		action class with the given pattern.  Then, we simply declare the
		given element. The action class will be called and our connection
		source will be bound to a JNDI context.  </p>

		<p>This is a very powerful capability of Joran. If you'd like to
		read more about Joran, please see the <a
		href="onJoran.html">chapter to Joran</a>.  </p>
		
		-->

    <h4 class="doAnchor" name="JNDIConnectionSource">JNDIConnectionSource</h4>

		<p><a href="../xref/ch/qos/logback/core/db/JNDIConnectionSource.html"><code>JNDIConnectionSource</code></a>是另一个<code>ConnectionSource</code>实施以logback交付。顾名思义，它检索一个<code>javax.sql.DataSource</code>从JNDI，然后利用它来获取<code>java.sql.Connection</code>实例。 <code>JNDIConnectionSource</code>主要设计用于J2EE应用程序服务器内部或由应用程序服务器客户端使用，前提是应用程序服务器支持对J2EE的远程访问。 <code>javax.sql.DataSource</code> 。因此，可以利用连接池和应用程序服务器提供的其他任何优点。更重要的是，您的应用程序将变得更加<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">干燥，</a>因为不再需要定义<code>DataSource</code>在<em>logback.xml中</em> 。</p>

    <p>例如，这是Tomcat的配置代码段。尽管所有受支持的数据库系统（上面列出）都可以使用，但它假定PostgreSQL为数据库。</p>

<pre  class="prettyprint source">&lt;Context docBase="/path/to/app.war" path="/myapp">
  ...
  &lt;Resource <b>name="jdbc/logging"</b>
               auth="Container"
               type="javax.sql.DataSource"
               username="..."
               password="..."
               driverClassName="org.postgresql.Driver"
               url="jdbc:postgresql://localhost/..."
               maxActive="8"
               maxIdle="4"/>
  ...
&lt;/Context></pre>
		
   <p>一旦<code>DataSource</code>是在J2EE服务器中定义的，您的logback配置文件可以轻松地引用它，如下面的示例所示。</p>
   
   <p class="example">例： <code>DBAppender</code>通过配置<code>JNDIConnectionSource</code> （logback-examples / src / main / resources / chapters / appenders / db / append-via-jndi.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('append-via-jndi');">观看为.groovy</span>	
 

<pre id="append-via-jndi" class="prettyprint source">&lt;configuration debug="true">
  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender">
    &lt;connectionSource class=&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;&gt;
      <b>&lt;!-- please note the "java:comp/env/" prefix --&gt;</b>
      <b>&lt;jndiLocation>java:comp/env/jdbc/logging&lt;/jndiLocation></b>
    &lt;/connectionSource&gt;
  &lt;/appender>
  &lt;root level="INFO">
    &lt;appender-ref ref="DB" />
  &lt;/root>  
&lt;/configuration></pre>

		<p>请注意，此类将获得<code>javax.naming.InitialContext</code>使用无参数构造函数。在J2EE环境中执行时，这通常会起作用。在J2EE环境之外时，请确保提供JNDI提供程序的文档所述的<em>jndi.properties</em>文件。
		</p>
		
		<h4 class="doAnchor">连接池</h4>
		
		<p>日志事件可以以相当快的速度创建。为了跟上必须插入数据库的事件流，建议使用连接池<code>DBAppender</code> 。
		</p>
		
		<p>实验表明，将连接池与<code>DBAppender</code>大大提高了性能。使用以下配置文件，日志记录事件将被发送到MySQL数据库，而不会进行任何池化。
		</p>
    
    <p class="example">例： <code>DBAppender</code>无需池配置（logback-examples / src / main / resources / chapters / appenders / db / append-toMySQL-with-datasource.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('append-toMySQL-with-datasource');">观看为.groovy</span>	
    <pre id="append-toMySQL-with-datasource" class="prettyprint source">&lt;configuration>

  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender">
    &lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource">
      &lt;dataSource class="com.mysql.jdbc.jdbc2.optional.MysqlDataSource">
        &lt;serverName>${serverName}&lt;/serverName>
        &lt;port>${port$&lt;/port>
        &lt;databaseName>${dbName}&lt;/databaseName>
        &lt;user>${user}&lt;/user>
        &lt;password>${pass}&lt;/password>
      &lt;/dataSource>
    &lt;/connectionSource>
  &lt;/appender>
    
  &lt;root level="DEBUG">
    &lt;appender-ref ref="DB" />
  &lt;/root>
&lt;/configuration></pre>

		<p>使用此配置文件，将500个日志记录事件发送到MySQL数据库需要5秒钟，即每个请求10毫秒。当处理大型应用程序时，此数字是不可接受的。
		</p>

		<p>要使用连接池，必须使用专用的外部库<code>DBAppender</code> 。下一个示例使用<a href="http://sourceforge.net/projects/c3p0">c3p0</a> 。为了能够使用c3p0，必须下载它并将<em>c3p0-VERSION.jar</em>放在类路径中。
		</p>

    <p class="example">例： <code>DBAppender</code>使用池进行配置（logback-examples / src / main / resources / chapters / appenders / db / append-toMySQL-with-datasource-and-pooling.xml）</p>
    <span class="asGroovy" onclick="return asGroovy('append-toMySQL-with-datasource-and-pooling');">观看为.groovy</span>	
    <pre id="append-toMySQL-with-datasource-and-pooling" class="prettyprint source">&lt;configuration>

  &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender">
    &lt;connectionSource
      class="ch.qos.logback.core.db.DataSourceConnectionSource">
      <b>&lt;dataSource
        class="com.mchange.v2.c3p0.ComboPooledDataSource">
        &lt;driverClass>com.mysql.jdbc.Driver&lt;/driverClass>
        &lt;jdbcUrl>jdbc:mysql://${serverName}:${port}/${dbName}&lt;/jdbcUrl>
        &lt;user>${user}&lt;/user>
        &lt;password>${password}&lt;/password>
      &lt;/dataSource></b>
    &lt;/connectionSource>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="DB" />
  &lt;/root>
&lt;/configuration></pre>

		<p>使用这种新配置，向上述MySQL数据库发送500个日志记录请求大约需要0.5秒，平均每个请求1毫秒，这使性能提高了十倍。
		</p>

		<h3 class="doAnchor" name="SyslogAppender">SyslogAppender</h3>

		<p>syslog协议是一个非常简单的协议：syslog发送方向syslog接收方发送一条小消息。接收器通常称为<em>syslog守护程序</em>或<em>syslog服务器</em> 。Logback可以将消息发送到远程syslog守护程序。这是通过使用<a href="../xref/ch/qos/logback/classic/net/SyslogAppender.html"><code>SyslogAppender</code></a> 。
		</p>
		
		<p>这是您可以传递给SyslogAppender的属性。</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>物业名称</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td><span class="prop" container="syslog">syslogHost</span></td>
				<td><code>String</code></td>
				<td>syslog服务器的主机名。</td>
			</tr>
			<tr>
				<td><span class="prop" container="syslog">港口</span></td>
				<td><code>String</code></td>
				<td>syslog服务器上要连接的端口号。通常，人们不希望更改默认值<em>514</em> 。
				</td>
			</tr>
			<tr>
				<td><span class="prop" container="syslog">设施</span></td>
				<td><code>String</code></td>
				<td>
					<p>该<span class="prop">功能</span>旨在识别消息的来源。</p>
					<p><span class="prop">设施</span>选项必须设置为以下字符串之一： <em>KERN，USER，MAIL，DAEMON，AUTH，SYSLOG，LPR，NEWS，UUCP，CRON，AUTHPRIV，FTP，NTP，AUDIT，ALERT，CLOCK，LOCAL0，LOCAL1，LOCAL2，LOCAL3 ，LOCAL4，LOCAL5，LOCAL6，LOCAL7</em> 。大小写并不重要。</p>
				</td>
			</tr>
      <tr>
        <td><span class="prop" container="syslog">后缀模式</span></td>
				<td><code>String</code></td>
				<td><p><span class="prop">suffixPattern</span>选项指定发送到syslog服务器的消息的非标准化部分的格式。默认情况下，它的值是<em>[％thread]％logger％msg</em> 。任何值<code>PatternLayout</code>可以使用的是正确的<span class="prop">suffixPattern</span>值。
					</p>
				</td>
			</tr>

      <tr>
        <td><span class="prop" container="syslog">stackTracePattern</span></td>
				<td><code>String</code></td>
				<td><p><span class="prop">stackTracePattern</span>属性允许自定义出现在每个堆栈跟踪行之前的字符串。此属性的默认值为“ \ t”，即制表符。接受的任何值<code>PatternLayout</code>是<span class="prop">stackTracePattern</span>的有效值。</p>
				</td>
			</tr>

			<tr>
				<td><span class="prop" container="syslog">throwable排除</span></td>
				<td><code>boolean</code></td>
				<td>设置<span class="prop">throwableExcluded</span>为<code>true</code>将导致与Throwable关联的堆栈跟踪数据被忽略。默认情况下， <span class="prop">throwableExcluded</span>设置为<code>false</code>以便将堆栈跟踪数据发送到syslog服务器。</td>
			</tr>


		</tbody></table>
		
		<p>日志事件的系统日志严重性是从日志事件的级别转换而来的。<em>DEBUG</em>级别转换为<em>7</em> ， <em>INFO</em>转换为<em>6</em> ， <em>WARN</em>转换为<em>4</em> ， <em>ERROR</em>转换为<em>3</em> 。
		</p>
		
		<p>由于syslog请求的格式遵循相当严格的规则，因此没有布局可用于<code>SyslogAppender</code> 。但是，使用<span class="prop">suffixPattern</span>选项可以使用户显示她希望的任何信息。
		</p>
		
		<p>这是使用<code>SyslogAppender</code> 。</p>
		
    <p class="example">例： <code>SyslogAppender</code>配置（logback-examples / src / main / resources / chapters / appenders / conf / logback-syslog.xml）</p>	
    <span class="asGroovy" onclick="return asGroovy('logback-syslog');">观看为.groovy</span>	
    <pre id="logback-syslog" class="prettyprint source">&lt;configuration>

  &lt;appender name="SYSLOG" class="ch.qos.logback.classic.net.SyslogAppender">
    &lt;syslogHost>remote_home&lt;/syslogHost>
    &lt;facility>AUTH&lt;/facility>
    &lt;suffixPattern>[%thread] %logger %msg&lt;/suffixPattern>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="SYSLOG" />
  &lt;/root>
&lt;/configuration></pre>

		<p>测试此配置时，应验证远程syslog守护程序是否接受来自外部源的请求。经验表明，默认情况下，syslog守护程序通常会拒绝通过网络连接发出的请求。
		</p>
		

    <h3 class="doAnchor" name="SiftingAppender">SiftingAppender</h3>

    <p>顾名思义， <code>SiftingAppender</code>可以根据给定的运行时属性来分隔（或筛选）日志记录。例如， <code>SiftingAppender</code>可以根据用户会话将日志记录事件分开，以便将不同用户生成的日志放入不同的日志文件中，每个用户一个日志文件。
    </p>


    
    <table class="bodyTable striped">
			<tbody><tr>
				<th>物业名称</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td><span class="prop" container="sift">超时</span></td>
				<td><code><a href="../apidocs/ch/qos/logback/core/util/Duration.html">Duration</a></code></td>
				<td><span class="prop">超时</span>持续时间内未访问的嵌套追加器被认为是陈旧的。一个过时的附加程序已关闭，并且未被引用<code>SiftingAppender</code> 。<span class="prop">超时</span>的默认值为30分钟。</td>
			</tr>
			<tr>
				<td><span class="prop" container="sift">maxAppenderCount</span></td>
				<td><code>integer</code></td>
				<td>嵌套追加器的最大数量<code>SiftingAppender</code>可以创建和跟踪。<span class="prop">maxAppenderCount的</span>默认值为Integer。MAX_VALUE。</td>
			</tr>
  </tbody></table>

    <p><code>SiftingAppender</code>通过动态创建嵌套的追加程序来实现这一壮举。嵌套的附加器是根据在配置中指定的模板创建的<code>SiftingAppender</code>本身（包含在<code><sift></code>元素，请参见下面的示例）。 <code>SiftingAppender</code>负责管理子追加程序的生命周期。例如， <code>SiftingAppender</code>将自动关闭并删除所有过时的附加程序。如果没有超过<span class="prop">timeout</span>参数指定的持续时间，则嵌套的追加程序被认为是过时的。
    </p>

    <p>处理记录事件时， <code>SiftingAppender</code>将选择一个子附加程序委托给它。选择标准是在运行时由鉴别器计算的。用户可以借助<code><a href="../xref/ch/qos/logback/core/sift/Discriminator.html">Discriminator</a></code> 。现在让我们研究一个例子。
    </p>
 
    <h4>例</h4>

    <p><a href="../xref/chapters/appenders/sift/SiftExample.html">SiftExample</a>应用程序记录一条消息，指出该应用程序已启动。然后，它将MDC密钥“ userid”设置为“ Alice”并记录一条消息。这是明显的代码：</p>
   
    <p class="source">logger.debug（“应用程序已启动”）; MDC.put（“ userid”，“ Alice”）; logger.debug（“爱丽丝问好”）;</p>

    <p>配置文件的模板说明了<code>SiftingAppender</code> 。</p>


    <p class="example">例： <code>SiftingAppender</code>配置（logback-examples / src / main / resources / chapters / appenders / sift / byUserid.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('byUserid');">观看为.groovy</span>

    <pre id="byUserid" class="prettyprint source">&lt;configuration>

  <b>&lt;appender name="SIFT" class="ch.qos.logback.classic.sift.SiftingAppender"></b>
    &lt;!-- in the absence of the class attribute, it is assumed that the
         desired discriminator type is
         ch.qos.logback.classic.sift.MDCBasedDiscriminator -->
    <b>&lt;discriminator></b>
      <b>&lt;key><span class="green">userid</span>&lt;/key></b>
      <b>&lt;defaultValue>unknown&lt;/defaultValue></b>
    <b>&lt;/discriminator></b>
    <b>&lt;sift></b>
      <b>&lt;appender name="FILE-<span class="green">${userid}</span>" class="ch.qos.logback.core.FileAppender"></b>
        <b>&lt;file><span class="green">${userid}</span>.log&lt;/file></b>
        <b>&lt;append>false&lt;/append></b>
        <b>&lt;layout class="ch.qos.logback.classic.PatternLayout"></b>
          <b>&lt;pattern>%d [%thread] %level %mdc %logger{35} - %msg%n&lt;/pattern></b>
        <b>&lt;/layout></b>
      <b>&lt;/appender></b>
    <b>&lt;/sift></b>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="SIFT" />
  &lt;/root>
&lt;/configuration></pre>
    
    
    <p>在没有class属性的情况下，假定鉴别器类型为<a href="../xref/ch/qos/logback/classic/sift/MDCBasedDiscriminator.html">MDCBasedDiscriminator</a> 。区别值是与<span class="prop">key</span>属性给定的<span class="prop">key</span>相关联的MDC值。但是，如果该MDC值为null，则将<span class="prop">defaultValue</span>用作区分值。
    </p>

    <p>的<code>SiftingAppender</code>在引用和配置子附加程序方面具有独特的能力。在以上示例中， <code>SiftingAppender</code>将创建多个<code>FileAppender</code>每个实例<code>FileAppender</code>由与“用户ID” MDC密钥关联的值标识的实例。每当为“用户ID” MDC密钥分配新值时， <code>FileAppender</code>实例将从头开始构建。的<code>SiftingAppender</code>跟踪其创建的附加程序。未使用30分钟的广告者将自动关闭并丢弃。
    </p>

    <p><span class="label notice">变量导出</span>拥有不同的追加器实例是不够的。每个实例必须输出到不同的目标资源。为了进行这种区分，在附加模板中，导出了传递给鉴别符的密钥（在上面的示例中为“ userid”），并成为<a href="configuration.html#variableSubstitution">变量</a> 。因此，此变量可用于区分给定子附加器使用的实际资源。
    </p>

    <p>运行<code>SiftExample</code>具有上面显示的“ byUserid.xml”配置文件的应用程序，将产生两个不同的日志文件，即“ unknown.log”和“ Alice.log”。
		</p>

    <p><span class="label">局部作用域变量</span>从版本1.0.12开始，配置文件中本地作用域中定义的属性将可用于嵌套的追加程序。此外，你可以<a href="configuration.html#definingProps">定义变量</a>或<a href="configuration.html#definingPropsOnTheFly">动态地计算</a>从该<em>内部</em>变量<code><sift></code>元件。组合来自外部和内部定义的零件的变量<code><sift></code>元素也受支持。
    </p>

    <h4 class="doAnchor" name="siftGettingTimeoutRight">正确设置<span class="prop">超时时间</span></h4>

    <p>对于某些类型的应用程序，可能很难正确设置<span class="prop">超时</span>参数。如果<span class="prop">超时时间</span>太短，则可能会删除嵌套的附加程序，而仅在几秒钟后重新创建。这种现象称为<em>垃圾</em> 。如果<span class="prop">超时时间</span>太长，并且快速连续创建了附加程序，则可能会耗尽资源。同样，将<span class="prop">maxAppenderCount</span>设置得太低也可能导致垃圾<span class="prop">回收</span> 。
    </p>

    <p>在许多情况下，在代码中更精确地定位某个位置，此后不再需要嵌套的附加程序可能更容易。如果存在这样的位置（甚至近似存在），则使用<a href="../apidocs/ch/qos/logback/classic/ClassicConstants.html#FINALIZE_SESSION_MARKER">FINALIZE_SESSION</a>标记从该位置记录日志。每当SiftingAppender看到标记为<code>FINALIZE_SESSION</code>它将终止相关的嵌套追加器。到达使用寿命终止时，嵌套的附加程序将停留几秒钟以处理任何即将发生的事件（如果有），然后将其关闭。
    </p>
    
    <pre class="prettyprint source">import org.slf4j.Logger;
import static ch.qos.logback.classic.ClassicConstants.FINALIZE_SESSION_MARKER;

  void job(String jobId) {
   
    MDC.put("jobId", jobId);
    logger.info("Starting job.");

    ... do whather the job needs to do
    
    // will cause the nested appender reach end-of-life. It will
    // linger for a few seconds.
    logger.info(FINALIZE_SESSION_MARKER, "About to end the job");

    try {
      .. perform clean up
    } catch(Exception e);  
      // This log statement will be handled by the lingering appender. 
      // No new appender will be created.
      logger.error("unexpected error while cleaning up", e);
    }
  }

</pre>

    <h3 class="doAnchor" name="AsyncAppender">AsyncAppender</h3>

    <p>AsyncAppender异步记录<a href="../apidocs/ch/qos/logback/classic/spi/ILoggingEvent.html">ILoggingEvent</a> 。它仅充当事件分发程序，因此必须引用另一个追加程序才能执行任何有用的操作。</p>

    <p><span class="label notice">如果80％的完整</span> AsyncAppender缓冲<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue中的</a>事件， <span class="label notice">则默认情况下有损</span> 。由创建的工作线程<code>AsyncAppender</code>从队列的开头获取事件，并将其分派到附加到<code>AsyncAppender</code> 。请注意，默认情况下， <code>AsyncAppender</code>如果队列的队列已满80％，将丢弃级别TRACE，DEBUG和INFO的事件。该策略以事件丢失为代价，对性能产生了惊人的有利影响。
    </p>

    <p><span class="label">应用程序停止/重新部署</span>在应用程序关闭或重新部署后， <code>AsyncAppender</code>必须停止以停止并回收工作线程并从队列中清除日志记录事件。这可以通过<a href="configuration.html#stopContext">停止LoggerContext</a>来完成， <a href="configuration.html#stopContext">该LoggerContext</a>将关闭所有附加程序，包括所有附加程序。 <code>AsyncAppender</code>实例。<code>AsyncAppender</code>将等待工作线程刷新到<span class="prop">maxFlushTime中</span>指定的超时。如果您发现排队的事件在关闭期间被丢弃<code>LoggerContext</code> ，您可能需要增加超时时间。为<span class="prop">maxFlushTime</span>指定值0将强制<code>AsyncAppender</code>从stop方法返回之前，等待所有排队的事件被刷新。
    </p>
    
    <p><span class="label">关闭后清理</span>取决于JVM关闭的模式，处理排队事件的工作线程可能会中断，从而使事件滞留在队列中。通常，当<code>LoggerContext</code>不能完全停止运行，或者当JVM在典型控制流之外终止时。为了避免在这种情况下中断工作线程，可以在JVM运行时中插入一个关闭钩子，以在启动JVM关闭后<a href="configuration.html#stopContext">正确停止LoggerContext</a> 。当其他关闭挂钩尝试记录事件时，关闭挂钩也可能是干净关闭Logback的首选方法。
    </p>


    <p>这是被认可的财产清单<code>AsyncAppender:</code></p>

		<table class="bodyTable striped">
      <tbody><tr>
        <th>物业名称</th>
        <th>类型</th>
        <th>描述</th>
      </tr>
			<tr>
        <td><span class="prop" container="async">queueSize</span></td>
        <td><code>int</code></td>
        <td>阻塞队列的最大容量。默认情况下， <span class="prop">queueSize</span>设置为256。
				</td>
			</tr>
      <tr>
        <td><span class="prop" container="async">丢弃阈值</span></td>
        <td><code>int</code></td>
        <td>默认情况下，当阻塞队列的剩余容量为20％时，它将丢弃级别TRACE，DEBUG和INFO的事件，仅保留级别WARN和ERROR的事件。要保留所有事件，请将<span class="prop">discardingThreshold</span>设置为0。
			</td>
			</tr>
      <tr>
        <td><span class="prop" container="async">includeCallerData</span></td>
        <td><code>boolean</code></td>
        <td>提取呼叫者数据可能非常昂贵。为了提高性能，默认情况下，将事件添加到事件队列时，不会提取与事件关联的呼叫者数据。默认情况下，仅复制“廉价”数据（例如线程名和<a href="mdc.html">MDC）</a> 。您可以通过将<span class="prop">includeCallerData</span>属性设置为true来指示此附加程序包括调用方数据。
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="async">maxFlushTime</span></td>
        <td><code>int</code></td>
        <td>根据队列深度和到引用的附加程序的延迟， <code>AsyncAppender</code>可能会花费不可接受的时间来完全刷新队列。当。。。的时候<code>LoggerContext</code>停止后， <code>AsyncAppender stop</code>方法等待此超时，直到工作线程完成。使用<span class="prop">maxFlushTime</span>指定最大队列刷新超时（以毫秒为单位）。无法在此窗口内处理的事件将被丢弃。该值的语义与<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#join(long)">Thread.join（long）的</a>语义相同。
        </td>
      </tr>
      <tr>
        <td><span class="prop" container="async">永不阻塞</span></td>
        <td><code>boolean</code></td>
        <td>如果<code>false</code> （默认）附加程序会在附加到完整队列时阻止，而不是丢失消息。调成<code>true</code>附加程序将仅丢弃该消息，并且不会阻止您的应用程序。</td>
      </tr>
    </tbody></table>

    <p>默认情况下，事件队列配置的最大容量为256个事件。如果队列已满，则将阻止应用程序线程记录新事件，直到工作线程有机会分派一个或多个事件。当队列不再达到最大容量时，应用程序线程能够再次开始记录事件。因此，当追加程序以其事件缓冲区的容量或其附近进行操作时，异步日志记录将变为伪同步。这不一定是一件坏事。附加程序旨在允许应用程序继续运行，尽管花费一些时间记录事件，直到减轻附加程序缓冲区的压力。
    </p>

    <p>为了最大程度地提高应用程序吞吐量，最佳地调整appender事件队列的大小取决于几个因素。以下任何一个或所有因素都可能导致显示伪同步行为：</p>
  
    <ul>
      <li>大量的应用程序线程</li>
      <li>每个应用程序调用都会记录大量日志事件</li>
      <li>每个日志记录事件有大量数据</li>
      <li>儿童追加器的高延迟</li>
    </ul>

    <p>为了保持运行状态，增加队列大小通常会有所帮助，但会浪费应用程序可用的堆空间。
    </p>

    
    <p><span class="label notice">有损行为</span>鉴于以上讨论，并且为了减少阻塞，默认情况下，当剩余的队列容量不到20％时， <code>AsyncAppender</code>将丢弃TRACE，DEBUG和INFO级别的事件，仅保留WARN和ERROR级别的事件。当队列的容量不足20％时，此策略可确保以TRACE，DEBUG和INFO级别的成本损失事件来无阻塞地处理日志事件（因此具有出色的性能）。通过将<span class="prop">discardingThreshold</span>属性设置为0（零），可以防止事件丢失。
    </p>

    <p class="example">例： <code>AsyncAppender</code>配置（logback-examples / src / main / resources / chapters / appenders / conc / logback-async.xml）</p>

    <span class="asGroovy" onclick="return asGroovy('asyncAppender');">观看为.groovy</span>

    <pre id="asyncAppender" class="prettyprint source">&lt;configuration>
  &lt;appender name="<b>FILE</b>" class="ch.qos.logback.core.FileAppender">
    &lt;file>myapp.log&lt;/file>
    &lt;encoder>
      &lt;pattern>%logger{35} - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  <b>&lt;appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender"></b>
    <b>&lt;appender-ref ref="FILE" /></b>
  <b>&lt;/appender></b>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="<b>ASYNC</b>" />
  &lt;/root>
&lt;/configuration></pre>
  

		<h3 class="doAnchor" name="WriteYourOwnAppender">编写自己的Appender</h3>


    <p>您可以通过子类化轻松编写您的附加程序<code>AppenderBase</code> 。它处理对大多数附加程序共享的过滤器，状态消息和其他功能的支持。派生类只需要实现一种方法，即<code>append(Object eventObject)</code> 。
    </p>

    <p>的<code>CountingConsoleAppender</code>接下来列出的，会在控制台上附加一定数量的传入事件。达到限制后它将关闭。它使用<code>PatternLayoutEncoder</code>格式化事件并接受名为<code>limit</code> 。因此，除了<code>append(Object eventObject)</code>是必需的。如下所示，这些参数是由logback的各种配置机制自动处理的。
    </p>
    
    <em>示例4 <span class="autoExec"></span> ： <code>CountingConsoleAppender</code> （logback-examples / src / main / java / chapters / appenders / CountingConsoleAppender.java）</em>
    <pre class="prettyprint source">package chapters.appenders;

import java.io.IOException;

import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.AppenderBase;


public class CountingConsoleAppender extends AppenderBase&lt;ILoggingEvent> {
  static int DEFAULT_LIMIT = 10;
  int counter = 0;
  int limit = DEFAULT_LIMIT;
  
  PatternLayoutEncoder encoder;
  
  public void setLimit(int limit) {
    this.limit = limit;
  }

  public int getLimit() {
    return limit;
  }
  
  @Override
  public void start() {
    if (this.encoder == null) {
      addError("No encoder set for the appender named ["+ name +"].");
      return;
    }
    
    try {
      encoder.init(System.out);
    } catch (IOException e) {
    }
    super.start();
  }

  public void append(ILoggingEvent event) {
    if (counter >= limit) {
      return;
    }
    // output the events as formatted by our layout
    try {
      this.encoder.doEncode(event);
    } catch (IOException e) {
    }

    // prepare for next event
    counter++;
  }

  public PatternLayoutEncoder getEncoder() {
    return encoder;
  }

  public void setEncoder(PatternLayoutEncoder encoder) {
    this.encoder = encoder;
  }
}</pre>

		<p>的<code>start()</code>方法检查是否存在<code>PatternLayoutEncoder</code> 。如果未设置编码器，则附加器无法启动并发出错误消息。
		</p>
		
		<p>此自定义附加程序说明了两点：</p>
		
		<ul>

      <li>遵循setter / getter JavaBeans约定的所有属性均由logback配置器透明处理。的<code>start()</code>方法在logback配置期间会自动调用，它负责验证设置器的各种属性是否已设置并保持一致。
			</li>

			<li>的<code>AppenderBase.doAppend()</code>方法调用其派生类的append（）方法。实际的输出操作发生在<code>append</code> （） 方法。特别是，在此方法中，附加程序通过调用事件的布局来格式化事件。
			</li>
		</ul>
		
		<p>的<a href="../xref/chapters/appenders/CountingConsoleAppender.html"><code>CountingConsoleAppender</code></a>可以像其他任何附加程序一样进行配置。有关示例，请参阅样本配置文件<em>logback-examples / src / main / resources / chapters / appenders / countingConsole.xml</em> 。
		</p>
  

		<h2 class="doAnchor" name="logback_access">登录回访</h2>
		
		<p>在logback-classic中发现的大多数附加程序在logback-access中具有相同的功能。这些工作基本上与经典的logback工作方式相同。在下一节中，我们将介绍它们的用法。
		</p>
		
		<h3 class="doAnchor" name="AccessSocketAppender">SocketAppender和SSLSocketAppender</h3>
		
		<p>的<a href="../xref/ch/qos/logback/access/net/SocketAppender.html"><code>SocketAppender</code></a>用于通过传输序列化日志记录到远程实体<code>AccessEvent</code>电线上的物体。就访问事件而言，远程日志记录是非侵入式的。在反序列化后的接收端，可以记录该事件，就好像它是本地生成的一样。
		</p>
		
		<p>的<a href="../xref/ch/qos/logback/access/net/SSLSocketAppender.html"><code>SSLSocketAppender</code></a>扩展基本<code>SocketAppender</code>允许通过安全套接字层（SSL）登录到远程实体。
    </p>
    
		<p>访问的属性<code>SocketAppender</code>与经典版的相同<code>SocketAppender</code> 。
		</p>

    <h3 class="doAnchor" name="AccessServerSocketAppender">ServerSocketAppender和SSLServerSocketAppender</h3>
    
    <p>喜欢<code>SocketAppender</code> ， <a href="../xref/ch/qos/logback/access/net/server/ServerSocketAppender.html"><code>ServerSocketAppender</code></a>用于通过传输序列化日志记录到远程实体<code>AccessEvent</code>电线上的物体。但是，使用时<code>ServerSocketAppender</code>附加程序充当服务器，被动侦听TCP套接字，以等待感兴趣的客户端的入站连接。传递给附加程序的日志事件将分发给所有连接的客户端。
    </p>
    
    <p>的<a href="../xref/ch/qos/logback/access/net/server/SSLServerSocketAppender.html"><code>SSLSocketAppender</code></a>扩展基本<code>ServerSocketAppender</code>允许通过安全套接字层（SSL）登录到远程实体。
    </p>
    
    <p>访问的属性<code>ServerSocketAppender</code>与经典版的相同<code>ServerSocketAppender</code> 。
    </p>
    
	 	
		<h3 class="doAnchor" name="AccessSMTPAppender">SMTPAppender</h3>
		
		<p>访问' <a href="../xref/ch/qos/logback/access/net/SMTPAppender.html"><code>SMTPAppender</code></a>的工作方式与经典产品相同。但是， <span class="prop">评估者</span>选项却大不相同。默认情况下， <code>URLEvaluator</code>对象由<code>SMTPAppender</code> 。该评估器包含一个URL列表，该列表将根据当前请求的URL进行检查。当其中一个页面提供给<code>URLEvaluator</code>被要求<code>SMTPAppender</code>发送电子邮件。
		</p>
		
		<p>这是一个示例配置<code>SMTPAppender</code>在访问环境中。
		</p>
    <p class="example">例： <code>SMTPAppender</code>配置（logback-examples / src / main / resources / chapters / appenders / conf / access / logback-smtp.xml）</p>

<pre class="prettyprint source">&lt;appender name="SMTP"
  class="ch.qos.logback.access.net.SMTPAppender">
  &lt;layout class="ch.qos.logback.access.html.HTMLLayout">
    &lt;pattern>%h%l%u%t%r%s%b&lt;/pattern>
  &lt;/layout>
    
  <b>&lt;Evaluator class="ch.qos.logback.access.net.URLEvaluator">
    &lt;URL>url1.jsp&lt;/URL>
    &lt;URL>directory/url2.html&lt;/URL>
  &lt;/Evaluator></b>
  &lt;from>sender_email@host.com&lt;/from>
  &lt;smtpHost>mail.domain.com&lt;/smtpHost>
  &lt;to>recipient_email@host.com&lt;/to>
&lt;/appender></pre>

		<p>例如，这种触发电子邮件的方式使用户可以选择在特定过程中是重要步骤的页面。当访问此类页面时，将与先前访问的页面以及用户希望包含在电子邮件中的所有信息一起发送电子邮件。
		</p>

		<h3 class="doAnchor" name="AccessDBAppender">DBAppender</h3>
		
		<p><a href="../xref/ch/qos/logback/access/db/DBAppender.html"><code>DBAppender</code></a>用于将访问事件插入数据库。
		</p>

		<p>使用两个表<code>DBAppender</code> ： <em>access_event</em>和<em>access_event_header</em> 。它们都必须存在之前<code>DBAppender</code>可以使用。Logback附带了将创建表的SQL脚本。它们可以在<em>logback-access / src / main / java / ch / qos / logback / access / db / script</em>目录中找到。每个最受欢迎的数据库系统都有一个特定的脚本。如果缺少针对您特定类型的数据库系统的脚本，则以现有脚本之一为例，应该很容易编写一个脚本。鼓励您将缺少的脚本贡献给项目。
		</p>
		
		<p><em>access_event</em>表的字段如下所述：</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>领域</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td><b>时间戳记</b></td>
				<td><code>big int</code></td>
				<td>在创建访问事件时有效的时间戳。</td>
			</tr>
			<tr>
				<td><b>requestURI</b></td>
				<td><code>varchar</code></td>
				<td>请求的URI。</td>
			</tr>
			<tr>
				<td><b>requestURL</b></td>
				<td><code>varchar</code></td>
				<td>所请求的URL。这是一个由请求方法，请求URI和请求协议组成的字符串。
				</td>
			</tr>
			<tr>
				<td><b>远程主机</b></td>
				<td><code>varchar</code></td>
				<td>远程主机的名称。</td>
			</tr>
			<tr>
				<td><b>remoteUser</b></td>
				<td><code>varchar</code></td>
				<td>远程用户的名称。
				</td>
			</tr>
			<tr>
				<td><b>remoteAddr</b></td>
				<td><code>varchar</code></td>
				<td>远端IP地址。</td>
			</tr>
			<tr>
				<td><b>协议</b></td>
				<td><code>varchar</code></td>
				<td>请求协议，例如<em>HTTP</em>或<em>HTTPS</em> 。</td>
			</tr>
			<tr>
				<td><b>方法</b></td>
				<td><code>varchar</code></td>
				<td>请求方法，通常是<em>GET</em>或<em>POST</em> 。</td>
			</tr>
			<tr>
				<td><b>服务器名称</b></td>
				<td><code>varchar</code></td>
				<td>发出请求的服务器的名称。</td>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>访问事件的数据库ID。</td>
			</tr>
		</tbody></table>
		
		<p><em>access_event_header</em>表包含每个请求的标头。信息的组织如下所示：</p>

		<table class="bodyTable striped">
			<tbody><tr>
				<th>领域</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td><b>event_id</b></td>
				<td><code>int</code></td>
				<td>相应访问事件的数据库标识。</td>
			</tr>
			<tr>
				<td><b>header_key</b></td>
				<td><code>varchar</code></td>
				<td>标头名称，例如<em>User-Agent</em> 。</td>
			</tr>
			<tr>
				<td><b>header_value</b></td>
				<td><code>varchar</code></td>
				<td>标头值，例如<em>Mozilla / 5.0（Windows; U; Windows NT 5.1; fr; rv：1.8.1）Gecko / 20061010 Firefox / 2.0</em></td>
			</tr>
			</tbody></table>

		<p>经典的所有属性<code>DBAppender</code>在访问权限中可用<code>DBAppender</code> 。后者提供了另一个选项，如下所述。
		</p>
		
		<table class="bodyTable striped">
			<tbody><tr>
				<th>物业名称</th>
				<th>类型</th>
				<th>描述</th>
			</tr>
			<tr>
				<td>
					<b>
						<span class="prop">insertHeaders</span>
					</b>
				</td>
				<td>
					<code>boolean</code>
				</td>
				<td>告诉<code>DBAppender</code>用所有传入请求的标头信息填充数据库。
				</td>
			</tr>
		</tbody></table>

		<p>这是使用的示例配置<code>DBAppender</code> 。</p>

    <p class="example">示例：DBAppender配置<em>（logback-examples / src / main / resources / chapters / appenders / conf / access / logback-DB.xml）</em></p>
    
    <pre class="prettyprint source">&lt;configuration>

  &lt;appender name="DB" class="ch.qos.logback.access.db.DBAppender">
    &lt;connectionSource class="ch.qos.logback.core.db.DriverManagerConnectionSource">
      &lt;driverClass>com.mysql.jdbc.Driver&lt;/driverClass>
      &lt;url>jdbc:mysql://localhost:3306/logbackdb&lt;/url>
      &lt;user>logback&lt;/user>
      &lt;password>logback&lt;/password>
    &lt;/connectionSource>
    &lt;insertHeaders>true&lt;/insertHeaders>
  &lt;/appender>

  &lt;appender-ref ref="DB" />
&lt;/configuration></pre>


    <h3 class="doAnchor" name="AccessSiftingAppender">SiftingAppender</h3>
   
    <p>在logback-access中的SiftingAppender与它的logback-classic类似。主要区别在于在logback-access中，默认区分<a href="../xref/ch/qos/logback/access/sift/AccessEventDiscriminator.html">符</a> （即<a href="../xref/ch/qos/logback/access/sift/AccessEventDiscriminator.html">AccessEventDiscriminator</a> ）不是基于MDC的。顾名思义，AccessEventDiscriminator使用AccessEvent中的指定字段作为选择嵌套追加程序的基础。如果指定字段的值为null，则使用<span class="prop">defaultValue</span>属性中指定的值。
    </p>

    <p>指定的AccessEvent字段可以是COOKIE，REQUEST_ATTRIBUTE，SESSION_ATTRIBUTE，REMOTE_ADDRESS，LOCAL_PORT和REQUEST_URI之一。请注意，前三个字段要求还必须指定<span class="prop">AdditionalKey</span>属性。</p>
    
    <p>以下是示例配置文件。</p>

    <p class="example">示例：SiftingAppender配置（logback-examples / src / main / resources / chapters / appenders / conf / sift / access-siftingFile.xml）</p>
    
    <pre class="prettyprint source">&lt;configuration>
  &lt;appender name="SIFTING" class="ch.qos.logback.access.sift.SiftingAppender">
    &lt;Discriminator class="ch.qos.logback.access.sift.AccessEventDiscriminator">
      &lt;Key>id&lt;/Key>
      &lt;FieldName>SESSION_ATTRIBUTE&lt;/FieldName>
      &lt;AdditionalKey>username&lt;/AdditionalKey>
      &lt;defaultValue>NA&lt;/defaultValue>
    &lt;/Discriminator>
    &lt;sift>
       &lt;appender name="ch.qos.logback:logback-site:jar:1.3.0-alpha5" class="ch.qos.logback.core.FileAppender">
        &lt;file>byUser/ch.qos.logback:logback-site:jar:1.3.0-alpha5.log&lt;/file>
        &lt;layout class="ch.qos.logback.access.PatternLayout">
          &lt;pattern>%h %l %u %t \"%r\" %s %b&lt;/pattern>
        &lt;/layout>
      &lt;/appender>
    &lt;/sift>
  &lt;/appender>
  &lt;appender-ref ref="SIFTING" />
&lt;/configuration></pre>


    <p>在上面的配置文件中， <code>SiftingAppender</code>巢<code>FileAppender</code>实例。键“ id”被指定为变量，该变量可用于嵌套<code>FileAppender</code>实例。默认区分符，即<code>AccessEventDiscriminator</code> ，将在每个中搜索“用户名”会话属性<code>AccessEvent</code> 。如果没有这样的属性可用，则将使用默认值“ NA”。因此，假设名为“用户名”的会话属性包含每个登录用户的用户名，则在（当前文件夹的） <em>byUser /</em>文件夹下将存在一个日志文件，该文件以包含该用户访问日志的每个用户的名字命名。
    </p>


    <script src="../templates/footer.js" type="text/javascript"></script>


  </div>
  


</body></html>