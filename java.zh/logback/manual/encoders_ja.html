<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml"><head></head><body dir="ltr" onload="prettyPrint(); decorate();"></ s> </ s> </ s> <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第5章エンコーダ</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  
  
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script src="../templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu_ja.js" type="text/javascript"></script>
    </div>
    <div id="content">

    <h1>第5章エンコーダー</h1>

    <div class="quote">
      <p><b>这天的动作</b>彼らの要求するものを全て最优先にして，それが终わったら报告してくれ。
      </p>
      <p>アラン・チューリングと彼の同僚の暗号解読者が署名した破格の予算请求书について，1941年10月，チャーチル首相がヘイスティングス・イスメイ将军に伝えた言葉</p>
    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>
    <script src="../templates/setup.js" type="text/javascript"></script>


    <h2 class="doAnchor">エンコーダーとは何か</h2>

    <p>役ンコーダーの役割は，ロギングイベントをバイト配列に変换するだけでなく，そのバイト配列を<code>OutputStream</code>に书き込むことです。はンコーダーはlogback 0.9.19から导入されました。以前のバージョンでは，ほとんどのアペンダーはロギングイベントを文字列に変换して<code>java.io.Writer</code>に书き込むのをレイアウトに任せていました。また，以前のバージョンでは，利用者は<code>FileAppender</code>に<code>PatternLayout</code>をネストしていました。返回0.9.19になってから， <code>FileAppender</code>派の派生クラスも， <a href="http://logback.qos.ch/codes.html#layoutInsteadOfEncoder">エンコーダーを利用するようになり，レイアウトを使わなくなりました</a> 。
    </p>

    <p>どうしてこんな破壊的な変更をしたのか？</p>

    <p>详细は次章で说明しますが，レイアウトウきにでのはロギングイベントを文字列に変换することだけです。また，レイアウトはロギングイグンをントを书き込む间何もできません。ロギングイベントをまとめてバッチ的に处理することができないのです。式照的にエンコーダーはバイト配列を书式化している间だけでなく，书式化されたバイト配列を书き込んでいる间も完全に使権を握っています。
    </p>

    <p>现时点では，利便性のあるエンコーダーは<code>PatternLayoutEncoder</code>だけです。単に<code>PatternLayout</code>をラップしただけで，ほとんどの仕事は任せてしまいます。一见すると，エンコーダーは超越な复雑さだけをもたらしているようにも见えます。たちは，私たちは新しく强力なエンコーダーがーが登场することによってこういった印象を上书きしてくれることに期待しています。</p>

    <h2 class="doAnchor" name="interface">エンコーダーインターフェイス</h2>

    <p>役ンコーダーの役割は，到着したロギングイベントをバイト配列に変换すること<b>と</b>换変イト配列を适切な<code>OutputStream</code>に书き込むことです。谐振したように，エンコーダーは亲のアペンダーが管理している<code>OutputStream</code>に対して，いつ，どんなバイト配列を书き込むのか完全に制御することができます。<a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html">エンコーダのインターフェイス</a>を见てみましょう。

    </p>
    <pre class="prettyprint source">package ch.qos.logback.core.encoder;

public interface Encoder&lt;E&gt; extends ContextAware, LifeCycle {

   /**
   * This method is called when the owning appender starts or whenever output
   * needs to be directed to a new OutputStream, for instance as a result of a
   * rollover.
   */
  void init(OutputStream os) throws IOException;

  /**
   * Encode and write an event to the appropriate {@link OutputStream}.
   * Implementations are free to defer writing out of the encoded event and
   * instead write in batches.
   */
  void doEncode(E event) throws IOException;


  /**
   * This method is called prior to the closing of the underling
   * {@link OutputStream}. Implementations MUST not close the underlying
   * {@link OutputStream} which is the responsibility of the owning appender.
   */
  void close() throws IOException;
}</pre>

    <p>见ての通り， <code>Encoder</code>インターフェイスには少ししかメソッドが宣言されていません。ですが，これらのメソッドだけで惊くほどたくさんの仕事ができるのです。
    </p>


    <h2 class="doAnchor">LayoutWrappingEncoder</h2>

    <p>logback0.9.19より前は，ほとんどのアペンダーがログの出力形式の面倒をレイアウトにまかせていました。でイアトトインターフェイスを使用するコードが大量に残っているので，レイアウトとエンコーダーする仲介する方法が必要でした。がのが<a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/LayoutWrappingEncoder.html">LayoutWrappingEncoder</a>です。LayoutWrappingEncoder rンコーダーインターフェイスを実装しています。を，ラップしたレイアウトにロギングイベントを文字列に変换する仕事を委譲します。
    </p>

    <p><code>LayoutWrappingEncoder</code>のコードを一部抜粋して绍介します。レイアトトインスタンスにどうやって委譲しているのかがわかるでしょうか。。</p>

 <pre class="prettyprint source">package ch.qos.logback.core.encoder;

public class LayoutWrappingEncoder&lt;E&gt; extends EncoderBase&lt;E&gt; {

  protected Layout&lt;E&gt; layout;
  private Charset charset;
  private boolean immediateFlush = true;

  public void doEncode(E event) throws IOException {
    String txt = layout.doLayout(event);
    outputStream.write(convertToBytes(txt));
    if (immediateFlush)
      outputStream.flush();
  }

  private byte[] convertToBytes(String s) {
    if (charset == null) {
      return s.getBytes();
    } else {
      return s.getBytes(charset);
    }
  }
}</pre>

    <p><code>doEncode()</code>まずッドは，まず最初に受け取ったロギンギイベントをラップしたレイアウトで文字列に変换します。そして変换结果の文字列を，使用者が指定した文字セットで符号化してバイト配列に変换します。次に，変换されたバイト配列を亲アペンダーの<code>OutputStream</code>に书き込みます。デフォルトでは<code>OutputStream</code>をすぐにフラッシュします。ただし<span class="prop">，immediateFlush</span>プロパティに明示的に假が指定されているときはフラッシュしません。<span class="prop">立即</span> Flushプロパティに假を指定しておくと，ロギングのスループットが突出に向上します。设定例については，次の<code>PatternLayoutEncoder</code>のところで绍介します。
    </p>


    <h2 class="doAnchor">PatternLayoutEncoder</h2>

    <p><code>PatternLayout</code>は最も広く使われているレイアウトです。logの一般的なユースケースに対応するため，logbackは<code>PatternLayoutEncoder</code>を提供しています。これは， <code>PatternLayout</code>のインスタンスだけをラップするようにした<code>LayoutWrappingEncoder</code>の派生クラスです。
    </p>

    <p>logback0.9.19の顷は， <code>FileAppender</code>やその派生クラスの设定には必ず<code>PatternLayout</code>が使われていました。今は代わりに<code>PatternLayoutEncoder</code>を使わなければなりません。いては， <a href="http://logback.qos.ch/codes.html#layoutInsteadOfEncoder">logbackのエラーコード</a>でも说明しています。
    </p>

     <h4 class="doAnchor" name="immediateFlush"><span class="prop">立即</span>冲洗</h4>

     <p><code>PatternLayoutEncoder</code>は<a href="http://logback.qos.ch/xref/ch/qos/logback/core/encoder/LayoutWrappingEncoder.html"><code>LayoutWrappingEncoder</code></a>の派生クラスなので， <span class="prop">即时</span> Flushプロパティを设定することができます。<span class="prop">immediateFlush</span>のデフォルト値は“真”です。出力ストリームをすぐにフラッシュすることで，ロギングイベントスクに书き込まれること，アプリケーションが终がするときにちゃんとアペンダーを闭じなかったときでも，ロギングイベントが失われないわれなとを保证することができます。一方，このプロパティに“ false”を指定すると，（それが必要なのかどうかはわかりませんが）ロギングのスループットが5倍にまで向上する可能性があります。前述したとおり<span class="prop">，immediateFlush</span>に假を指定した场合，アプリケーションが终了するときにちゃんとアペンダーを闭じなかったとき，ディスクに书き込まれていないロギングイベントが失われる可能性があります。
     </p>

     <p><code>FileAppender</code>に<code>PatternLayoutEncoder</code>を指定した设定例を见てみましょう。<span class="prop">ImmediateFlush</span>プロパティにはfalseを指定しています。</p>

<pre class="prettyprint">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
  &lt;file&gt;foo.log&lt;/file&gt;
  &lt;encoder&gt;
    &lt;pattern&gt;%d %-5level [%thread] %logger{0}: %msg%n&lt;/pattern&gt;
    &lt;!-- this quadruples logging throughput --&gt;
    <b>&lt;immediateFlush&gt;false&lt;/immediateFlush&gt;</b>
  &lt;/encoder&gt;
&lt;/appender&gt;</pre>


    <h4 class="doAnchor" name="outputPatternAsHeader">ヘッダに出力形式を入れる</h4>

    <p>ログファイルの解析を容易にするため，logbackはログファイルの先头にログの出力形式を出力することができます。机の机能はデフォルトでは<b>无效</b>になっています。<code>PatternLayoutEncoder</code>の<span class="prop">outputPatternAsHeader</span>プロパティにtrueを指定すれば，有效化することができます。以下に例を示します。</p>

<pre class="prettyprint">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
  &lt;file&gt;foo.log&lt;/file&gt;
  &lt;encoder&gt;
    &lt;pattern&gt;%d %-5level [%thread] %logger{0}: %msg%n&lt;/pattern&gt;
    <b>&lt;outputPatternAsHeader&gt;true&lt;/outputPatternAsHeader&gt;</b>
  &lt;/encoder&gt;
&lt;/appender&gt;</pre>

    <p>この设定を使うと次のように出力されます。</p>

    <pre>#logback.classic pattern: %d [%thread] %-5level %logger{36} - %msg%n
2012-04-26 14:54:38,461 [main] DEBUG com.foo.App - Hello world
2012-04-26 14:54:38,461 [main] DEBUG com.foo.App - Hi again
...</pre>

     <p>先头行の“＃logback.classic pattern”が出力形式として出力されたヘッダです。</p>




    <script src="../templates/footer.js" type="text/javascript"></script>

    </div>
  
</body></html>