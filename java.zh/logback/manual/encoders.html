<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第5章编码器</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js" ></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>
    <div id="left">      
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>    
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>

    <div id="content">

    <h1>第5章编码器</h1>

    <a href="encoders_ja.html">和訳（日语翻译）</a>

    <div class="quote">
      <p>今天的<b>行动</b>请确保他们拥有他们想要的所有优先事项，并向我报告已经完成。
      </p>
      <p>— 1941年10月，为了回应艾伦·图灵（Alan Turing）和他在布莱奇利公园（Bletchley Park）的密码分析家同事签署的更多资源请求，致使黑斯廷斯·伊斯梅（General Hastings Ismay）将军</p>
    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>
    <script src="../templates/setup.js" type="text/javascript"></script>


    <h2 class="doAnchor">什么是编码器</h2>

    <p>编码器负责将事件转换为字节数组，并将该字节数组写为<code>OutputStream</code> 。在Logback版本0.9.19中引入了编码器。在以前的版本中，大多数追加程序都依赖于布局将事件转换为字符串并使用<code>java.io.Writer</code> 。在以前的版本中，用户将嵌套一个<code>PatternLayout</code>中<code>FileAppender</code> 。自从登录0.9.19开始， <code>FileAppender</code>和子类<a href="../codes.html#layoutInsteadOfEncoder">期望使用编码器，并且不再采用layout</a> 。
    </p>

    <p>为什么要进行重大变革？</p>

    <p>布局将在下一章中详细讨论，它只能将事件转换为字符串。而且，由于布局无法控制何时写入事件，因此布局无法将事件聚合为批处理。与此相比，编码器不仅可以完全控制要写出的字节的格式，还可以控制何时（以及是否）可以写出这些字节。
    </p>

    <p>在目前的时间， <code>PatternLayoutEncoder</code>是唯一真正有用的编码器。它只包装一个<code>PatternLayout</code>可以完成大部分工作。因此，似乎除了不必要的复杂性之外，编码器并没有带来太多好处。但是，我们希望随着新型强大编码器的出现，这种印象会改变。</p>

    <h2 class="doAnchor" name="interface">编码器接口</h2>

    <p>编码器负责将进入的事件转换为字节数组<b>，</b>并将结果字节数组写到适当的位置<code>OutputStream</code> 。因此，编码器可以完全控制什么字节以及何时向其写入字节。 <code>OutputStream</code>由拥有者负责维护。这是<a href="../xref/ch/qos/logback/core/encoder/Encoder.html">编码器接口：</a>
   
    </p>
    <pre class="prettyprint source">package ch.qos.logback.core.encoder;

public interface Encoder&lt;E> extends ContextAware, LifeCycle {

   /**
   * This method is called when the owning appender starts or whenever output
   * needs to be directed to a new OutputStream, for instance as a result of a
   * rollover.
   */
  void init(OutputStream os) throws IOException;

  /**
   * Encode and write an event to the appropriate {@link OutputStream}.
   * Implementations are free to defer writing out of the encoded event and
   * instead write in batches.
   */
  void doEncode(E event) throws IOException;


  /**
   * This method is called prior to the closing of the underling
   * {@link OutputStream}. Implementations MUST not close the underlying
   * {@link OutputStream} which is the responsibility of the owning appender.
   */
  void close() throws IOException;
}</pre>

    <p>如您所见， <code>Encoder</code>接口由几种方法组成，但是令人惊讶的是，使用这些方法可以完成许多有用的事情。
    </p>


    <h2 class="doAnchor">LayoutWrappingEncoder</h2>

    <p>在0.9.19版本的Logback之前，许多附加程序都依赖Layout实例来控制日志输出的格式。由于存在大量基于布局接口的代码，因此我们需要一种编码器与布局进行互操作的方法。<a href="../xref/ch/qos/logback/core/encoder/LayoutWrappingEncoder.html">LayoutWrappingEncoder</a>弥合了编码器和布局之间的差距。它实现了编码器接口并包装了一个布局，该布局委派了将事件转换为字符串的工作。
    </p>

    <p>以下是摘录自<code>LayoutWrappingEncoder</code>类，说明如何完成委派给包装的布局实例。</p>

 <pre class="prettyprint source">package ch.qos.logback.core.encoder;

public class LayoutWrappingEncoder&lt;E> extends EncoderBase&lt;E> {

  protected Layout&lt;E> layout;
  private Charset charset;
 
   // encode a given event as a byte[]
   public byte[] encode(E event) {
     String txt = layout.doLayout(event);
     return convertToBytes(txt);
  }

  private byte[] convertToBytes(String s) {
    if (charset == null) {
      return s.getBytes();
    } else {
      return s.getBytes(charset);
    }
  } 
}</pre>

    <p>的<code>doEncode</code> （）方法首先使包装的布局将传入事件转换为字符串。根据用户选择的字符集编码，将所得的文本字符串转换为字节。</p>
    

    <h2 class="doAnchor">PatternLayoutEncoder</h2>

    <p>鉴于<code>PatternLayout</code>是最常用的布局，logback可以满足以下常见用例<code>PatternLayoutEncoder</code> ，是<code>LayoutWrappingEncoder</code>仅限于包装实例<code>PatternLayout</code> 。
    </p>

    <p>从0.9.19版开始， <code>FileAppender</code>或其子类别之一配置了一个<code>PatternLayout</code> ， 一种<code>PatternLayoutEncoder</code>必须改为使用。这在<a href="../codes.html#layoutInsteadOfEncoder">登录错误代码</a>的<a href="../codes.html#layoutInsteadOfEncoder">相关条目中进行了</a>说明。
    </p>

     <h4 class="doAnchor" name="immediateFlush"><span class="prop">InstantFlush</span>属性</h4>

     <p>由于<span class="label notice">的logback 1.2.0</span>中<span class="prop">，immediateFlush</span>属性是封闭追加程序的一部分。</p>

    <h4 class="doAnchor" name="outputPatternAsHeader">输出模式字符串作为标题</h4>

    <p>为了便于解析日志文件，logback可以在日志文件顶部插入用于日志输出的模式。默认情况下<b>禁用</b>此功能。可以通过将<span class="prop">outputPatternAsHeader</span>属性设置为'true'来启用相关<code>PatternLayoutEncoder</code> 。这是一个例子：</p>

<pre class="prettyprint">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"> 
  &lt;file>foo.log&lt;/file>
  &lt;encoder>
    &lt;pattern>%d %-5level [%thread] %logger{0}: %msg%n&lt;/pattern>
    <b>&lt;outputPatternAsHeader>true&lt;/outputPatternAsHeader></b>
  &lt;/encoder> 
&lt;/appender></pre>
    
    <p>这将导致输出类似于日志文件中的以下内容：</p>

    <pre>#logback.classic pattern: %d [%thread] %-5level %logger{36} - %msg%n
2012-04-26 14:54:38,461 [main] DEBUG com.foo.App - Hello world
2012-04-26 14:54:38,461 [main] DEBUG com.foo.App - Hi again
...</pre>

     <p>以“＃logback.classic pattern”开头的行是新插入的pattern行。</p>

    
     

    <script src="../templates/footer.js" type="text/javascript"></script>

    </div>
  

</body></html>