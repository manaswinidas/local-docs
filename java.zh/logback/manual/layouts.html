<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第6章：布局</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
    
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../';</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript" src="../templates/header.js"></script>
    <script type="text/javascript" src="../js/dsl.js"></script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">
    
    <h1>第6章：布局</h1>

    <a href="layouts_ja.html">和訳（日语翻译）</a>
	
    <div class="quote">
      <p>TCP实现将遵循鲁棒性的一般原则：对所做的事情要保守一些，对别人接受的内容要宽松一些。
      </p>
      <p>-JON POSTEL，RFC 793</p>
    </div>

    <script src="../templates/creative.js" type="text/javascript"></script>
    <script src="../templates/setup.js" type="text/javascript"></script>
     
		<h2 class="doAnchor">什么是布局？</h2>

		<p>如果您想知道，布局与佛罗里达州的大型庄园无关。布局是logback组件，负责将传入事件转换为String。的<code>format()</code>中的方法<a href="../xref/ch/qos/logback/core/Layout.html"><code>Layout</code></a>接口接受一个表示事件（任何类型）的对象，并返回一个String。的概要<code>Layout</code>界面如下所示。
		</p>

		<pre class="prettyprint source">public interface Layout&lt;E> extends ContextAware, LifeCycle {

  String doLayout(E event);
  String getFileHeader();
  String getPresentationHeader();
  String getFileFooter();
  String getPresentationFooter();
  String getContentType();
}</pre>

		<p>该界面非常简单，但足以满足许多格式需求。您可能从约瑟夫·海勒（Joseph Heller）的<em>Catch-22中</em>认识到得克萨斯州的得克萨斯州德克萨斯州开发人员：可能只需五种方法即可实现布局！？
		</p>

		<h2>经典的Logback</h2>

		<p>经典的Logback连接到仅处理类型的事件<a href="../xref/ch/qos/logback/classic/spi/ILoggingEvent.html"><code>ch.qos.logback.classic.spi.ILoggingEvent</code></a> 。这一事实在本节中将显而易见。</p>

		<h2 class="doAnchor" name="writingYourOwnLayout">编写自己的自定义布局</h2>

		<p>让我们为logback-classic模块实现一个简单而又实用的布局，该布局显示自应用程序启动以来经过的时间，日志记录事件的级别，括号之间的调用者线程，其记录器名称，破折号和后跟事件消息和一条新线。
		</p>

		<p>示例输出可能类似于：</p>

		<div class="source">10489 DEBUG [main] com.marsupial。邮袋-世界您好。</div>

		<p>这是由Texan开发人员编写的可能的实现：</p>
		<em>示例：布局的示例实现<a href="../xref/chapters/layouts/MySampleLayout.html">（logback-examples / src / main / java / chapters / layouts / MySampleLayout.java）</a></em>

		<pre class="prettyprint source">package chapters.layouts;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class MySampleLayout extends LayoutBase&lt;ILoggingEvent> {

  public String doLayout(ILoggingEvent event) {
    StringBuffer sbuf = new StringBuffer(128);
    sbuf.append(event.getTimeStamp() - event.getLoggingContextVO.getBirthTime());
    sbuf.append(" ");
    sbuf.append(event.getLevel());
    sbuf.append(" [");
    sbuf.append(event.getThreadName());
    sbuf.append("] ");
    sbuf.append(event.getLoggerName();
    sbuf.append(" - ");
    sbuf.append(event.getFormattedMessage());
    sbuf.append(CoreConstants.LINE_SEP);
    return sbuf.toString();
  }
}</pre>

		<p>注意<code>MySampleLayout</code>延伸<a href="../xref/ch/qos/logback/core/LayoutBase.html"><code>LayoutBase</code></a> 。此类管理所有布局实例的公共状态，例如布局是开始还是停止，页眉，页脚和内容类型数据。它使开发人员可以专注于他/她期望的格式<code>Layout</code> 。请注意<code>LayoutBase</code>类是通用的。在其类声明中， <code>MySampleLayout</code>延伸<code>LayoutBase<ILoggingEvent></code> 。
		</p>
		
		<p>的<code>doLayout(ILoggingEvent event)</code>方法，即唯一的方法<code>MySampleLayout</code> ，首先实例化一个<code>StringBuffer</code> 。它通过添加事件参数的各个字段来进行。来自得克萨斯州的德州人小心地打印了邮件的格式化形式。如果将一个或多个参数与日志记录请求一起传递，则这一点很重要。</p>
		
    <p>将这些各种字符添加到字符串缓冲区后， <code>doLayout()</code>方法将缓冲区转换为<code>String</code>并返回结果值。
		</p>

		<p>在上面的示例中， <code>doLayout</code>方法将忽略事件中包含的所有最终异常。在实际的布局实现中，您很可能也希望打印异常内容。
		</p>

    <h3 class="doAnchor" name="configuringYourOwnLayout">配置自定义布局</h3>

		<p>自定义布局被配置为任何其他组件。如前面提到的， <code>FileAppender</code>及其子类需要编码器。为了满足此要求，我们传递给<code>FileAppender</code>的实例<code>LayoutWrappingEncoder</code>包裹我们的<code>MySampleLayout</code> 。这是配置文件：</p>
		
		<em>示例：MySampleLayout的配置（logback-examples / src / main / resources / chapters / layouts / sampleLayoutConfig.xml）</em> <span class="asGroovy" onclick="return asGroovy('sampleLayoutConfig');">视图为.groovy</span>
<pre id="sampleLayoutConfig" class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"></b>
      <b>&lt;layout class="chapters.layouts.MySampleLayout" /></b>
    <b>&lt;/encoder></b>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>
   
		<p>样例应用<a href="../xref/chapters/layouts/SampleLogging.html"><code>chapters.layouts.SampleLogging</code></a>使用作为其第一个参数传递的配置脚本来配置logback，然后记录调试消息，随后是错误消息。</p>
		
		<p>要运行此示例，请从<em>logback-examples</em>目录中发出以下命令。
    </p>
    
    <p class="command">Java chapters.layouts。SampleLogging src / main / java / chapters / layouts / sampleLayoutConfig.xml</p>
    
    <p>这将产生：</p>
		
<div class="source"><pre>0 DEBUG [main] chapters.layouts.SampleLogging - Everything's going well
0 ERROR [main] chapters.layouts.SampleLogging - maybe not quite...</pre></div>

		<p>那很简单。怀疑论者埃利亚（Elea）坚持认为除了不确定性本身外没有其他确定因素，不确定性本身也不确定，他可能会问：带有选项的布局怎么样？读者可以在以下位置找到我们的自定义布局的略微修改版本<a href="../xref/chapters/layouts/MySampleLayout2.html"><code>MySampleLayout2.java</code></a> 。如本手册中所提到的，将属性添加到布局或任何其他logback组件就像声明该属性的setter方法一样简单。
		</p>

		<p>的<a href="../xref/chapters/layouts/MySampleLayout2.html"><code>MySampleLayout2</code></a>类包含两个属性。第一个是可以添加到输出中的前缀。第二个属性用于选择是否显示从中发送日志记录请求的线程的名称。
    </p>
		
    <p>这是<a href="../xref/chapters/layouts/MySampleLayout2.html"><code>MySampleLayout2</code></a>类：</p>

    <pre class="prettyprint source">package chapters.layouts;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.LayoutBase;

public class MySampleLayout2 extends LayoutBase&lt;ILoggingEvent> {

  String prefix = null;
  boolean printThreadName = true;

  <b>public void setPrefix(String prefix) {
    this.prefix = prefix;
  }

  public void setPrintThreadName(boolean printThreadName) {
    this.printThreadName = printThreadName;
  }</b>

  public String doLayout(ILoggingEvent event) {
    StringBuffer sbuf = new StringBuffer(128);
    <b>if (prefix != null) {
      sbuf.append(prefix + ": ");
    }</b>
    sbuf.append(event.getTimeStamp() - event.getLoggerContextVO().getBirthTime());
    sbuf.append(" ");
    sbuf.append(event.getLevel());
    <b>if (printThreadName) {
      sbuf.append(" [");
      sbuf.append(event.getThreadName());
      sbuf.append("] ");
    } else {
      sbuf.append(" ");
    }</b>
    sbuf.append(event.getLoggerName());
    sbuf.append(" - ");
    sbuf.append(event.getFormattedMessage());
    sbuf.append(LINE_SEP);
    return sbuf.toString();
  }
}</pre>


    <p>只需添加相应的setter方法即可启用属性配置。请注意<code>PrintThreadName</code>属性是布尔值，而不是<code>String</code> 。<a href="configuration.html">在配置一章</a>中详细介绍了登录组件的<a href="configuration.html">配置</a> 。<a href="onJoran.html">有关Joran</a>的<a href="onJoran.html">章节</a>提供了更多详细信息。这是为之量身定制的配置文件<code>MySampleLayout2</code> 。
    </p> 


    <span class="asGroovy" onclick="return asGroovy('MySampleLayout2');">观看为.groovy</span>
    <pre id="MySampleLayout2" class="prettyprint source">&lt;configuration>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
      &lt;layout class="chapters.layouts.MySampleLayout2"> 
        <b>&lt;prefix&gt;MyPrefix&lt;/prefix&gt;</b>
        <b>&lt;printThreadName&gt;false&lt;/printThreadName&gt;</b>
      &lt;/layout>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

   <p></p>


		<h2 class="doAnchor" name="ClassicPatternLayout">模式布局</h2>

		<p>经典的Logback附带灵活的布局，称为<a href="../xref/ch/qos/logback/classic/PatternLayout.html"><code>PatternLayout</code></a> 。作为所有布局， <code>PatternLayout</code>进行记录事件并返回一个<code>String</code> 。但是这个<code>String</code>可以通过调整来定制<code>PatternLayout</code>的转换模式。
		</p>   

    <p>的转换模式<code>PatternLayout</code>与<code>printf()</code>用C编程语言编写的函数。转换模式由文字文本和称为<em>转换说明符的</em>格式控制表达式组成。您可以随意在转换模式中插入任何文字文本。每个转换说明符均以百分号“％”开头，后跟可选的<em>格式修饰符</em> ， <em>转换字</em>和大括号之间的可选参数。转换字控制数据字段进行转换，例如记录器名称，级别，日期或线程名称。格式修饰符控制字段的宽度，填充和左对齐或右对齐。
		</p>

    <p>如前所述， <code>FileAppender</code>子类需要编码器。因此，当与<code>FileAppender</code>或其子类<code>PatternLayout</code>必须包装在编码器中。鉴于<code>FileAppender</code> / <code>PatternLayout</code>组合是如此常见，logback附带了一个名为<code>PatternLayoutEncoder</code> ，仅用于包装<code>PatternLayout</code>实例，以便可以将其视为编码器。以下是以编程方式配置<code>ConsoleAppender</code>与一个<code>PatternLayoutEncoder</code> ：</p>

 
		<em>示例：PatternLayout的示例用法<a href="../xref/chapters/layouts/PatternSample.html">（logback-examples / src / main / java / chapters / layouts / PatternSample.java）</a>
		</em>
		<pre class="prettyprint source">package chapters.layouts;

import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.ConsoleAppender;

public class PatternSample {

  static public void main(String[] args) throws Exception {
    Logger rootLogger = (Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    LoggerContext loggerContext = rootLogger.getLoggerContext();
    // we are not interested in auto-configuration
    loggerContext.reset();

    <b>PatternLayoutEncoder encoder = new PatternLayoutEncoder();</b>
    <b>encoder.setContext(loggerContext);</b>
    <b>encoder.setPattern("%-5level [%thread]: %message%n");</b>
    <b>encoder.start();</b>

    ConsoleAppender&lt;ILoggingEvent> appender = new ConsoleAppender&lt;ILoggingEvent>();
    appender.setContext(loggerContext);
    appender.setEncoder(encoder); 
    appender.start();

    rootLogger.addAppender(appender);

    rootLogger.debug("Message 1"); 
    rootLogger.warn("Message 2");
  } 
}</pre>

		<p>在上面的示例中，转换模式设置为<b>“％-5level [％thread]：％message％n”</b> 。稍后将给出logback中包含的转换词的提要。跑步<code>PatternSample</code>申请为：</p>

    <p class="source">Java Java Chapters.layouts。模式样本</p>

    <p>将在控制台上产生以下输出。</p>

		<p class="source">调试[主要]：消息1警告[主要]：消息2</p>

    <p>请注意，在转换模式<b>“％-5level [％thread]：％message％n”中</b> ，文字文本和转换说明符之间没有明确的分隔符。解析转换模式时， <code>PatternLayout</code>能够区分文字文本（空格字符，方括号，冒号字符）和转换说明符。在上面的示例中，转换说明符％-5level表示应将日志记录事件的级别调整为5个字符的宽度。格式说明符将在下面说明。
		</p>

		<p>在<code>PatternLayout</code> ，圆括号可用于对转换模式进行分组。<b>因此，'（'和'）'具有特殊含义，如果要用作文字，则需要转义。</b> 括号的特殊性质<a href="#Parentheses">将在下面</a>进一步<a href="#Parentheses">说明</a> 。
		</p>

		<p>如前所述，某些转换说明符可能包括在括号之间传递的可选参数。带有选项的样本转换说明符可以是<code>%logger{10}</code> 。这里的“ logger”是转换词，“ 10”是选项。选项将<a href="#cwOptions">在下面进一步讨论</a> 。
		</p>
		
		<p>下表描述了可识别的转换词及其选项。当在同一表单元格中列出多个转换词时，它们被视为别名。
		</p>

		<table class="bodyTable properties striped" border="0">
      <tbody><tr>
        <th><a name="conversionWord" href="#conversionWord">转换字</a></th>
        <th>影响</th>
      </tr>

			<tr>
				<td class="word" name="logger">
          <a name="logger" href="#logger"><span class="anchor"></span></a> <b>c</b> { <em>长度</em> }<br> 				
					<b>lo</b> { <em>长度</em> }<br>
					<b>记录器</b> { <em>长度</em> }<br>
				</td>

				<td>在记录事件的起点输出记录器的名称。

					<p>此转换字将整数作为第一个也是唯一的选择。转换器的缩写算法将缩短记录器名称，通常不会造成重大意义损失。将length选项的值设置为零是一个例外。它将使转换单词将子字符串返回到记录器名称中最右边的点字符。下表提供了实际使用的缩写算法的示例。
          </p>

					<table class="bodyTable dark" border="0" cellpadding="8">
						<tbody><tr>
							<th>转换说明符</th>
							<th>记录仪名称</th>
							<th>结果</th>
						</tr>
						<tr>
							<td>％logger</td>
							<td>mainPackage.sub.sample。酒吧</td>
							<td>mainPackage.sub.sample。酒吧</td>
						</tr>

            <tr>
							<td>％logger {0}</td>
							<td>mainPackage.sub.sample。酒吧</td>
							<td>酒吧</td>
						</tr>

						<tr>
							<td>％logger {5}</td>
							<td>mainPackage.sub.sample。酒吧</td>
							<td>短信酒吧</td>
						</tr>

						<tr>
							<td>％logger {10}</td>
							<td>mainPackage.sub.sample。酒吧</td>
							<td>短信酒吧</td>
						</tr>

						<tr>
							<td>％logger {15}</td>
							<td>mainPackage.sub.sample。酒吧</td>
							<td>mssample。酒吧</td>
						</tr>

						<tr>
							<td>％logger {16}</td>
							<td>mainPackage.sub.sample。酒吧</td>
							<td>m.sub.sample。酒吧</td>
						</tr>

						<tr>
							<td>％logger {26}</td>
							<td>mainPackage.sub.sample。酒吧</td>
							<td>mainPackage.sub.sample。酒吧</td>
						</tr>
					</tbody></table>

          <p>请注意，记录器名称中最右边的段永远不会缩写，即使其长度大于<em>length</em>选项。其他段可能会缩短到最多一个字符，但永远不会删除。</p>

				</td>
			</tr>

			<tr>
				<td class="word" name="class">
					<b>C</b> { <em>长度</em> }<br> 
					<b>类</b> { <em>长度</em> }<br>
				</td>

				<td>
					<p>输出发出日志记录请求的调用方的全限定类名。</p>

					<p>就像上面的<em>％logger</em>转换词一样，此转换将整数作为缩短类名的选项。零具有特殊含义，将导致在没有包名前缀的情况下打印简单类名。默认情况下，类名是完整打印的。
					</p>

          <p>生成呼叫者类别信息的速度不是特别快。因此，除非执行速度不是问题，否则应避免使用它。
					</p>
				</td>
			</tr>

      <tr>
        <td class="word" name="contextName">
          <b>contextName</b><br>
          <b>cn</b><br></td>
          <td>输出事件起源处的记录器所附加到的记录器上下文的名称。</td>
      </tr>
			<tr>
        <td class="word" name="date">
          <b>d</b> { <em>模式</em> }<br> 
          <b>日期</b> { <em>模式</em> }<br>
          <b>d</b> { <em>模式</em> ， <em>时区</em> }<br>
          <b>日期</b> { <em>pattern</em> ， <em>timezone</em> }<br>
        </td>
        <td>
         <p>用于输出记录事件的日期。日期转换词允许使用模式字符串作为参数。模式语法与以下格式兼容： <a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html"><code>java.text.SimpleDateFormat</code></a> 。</p>

         <p>您可以为ISO8601日期格式指定字符串<em>“ ISO8601”</em> 。请注意，在没有模式参数的情况下，％date转换字默认为<a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601日期格式</a> 。</p>

         <p>以下是一些示例参数值。他们假定实际日期为2006年10月20日星期五，并且撰文人午餐后刚回到工作状态。</p>
					
         <table class="bodyTable dark" cellpadding="8">
           <tbody><tr>
             <th>转换方式</th>
            <th>结果</th>
           </tr>
           <tr>
             <td>％d</td>
             <td>2006-10-20 14：06：49,812</td>
           </tr>
           <tr>
             <td>％日期</td>
             <td>2006-10-20 14：06：49,812</td>
           </tr>
           <tr>
             <td>％date {ISO8601}</td>
             <td>2006-10-20 14：06：49,812</td>
           </tr>			
           <tr>
             <td>％date {HH：mm：ss。SSS}</td>
             <td>14：06：49.812</td>
           </tr>
           <tr>
             <td>％date {dd MMM yyyy; HH：mm：ss。SSS}</td>
             <td>10月20日2006; 14：06：49.812</td>
           </tr>
         </tbody></table>
         
          <p>第二个参数指定时区。例如，'％date {HH：mm：ss。SSS，澳大利亚/珀斯}会在世界上最孤立的城市澳大利亚珀斯的时区中显示时间。请注意，在缺少timezone参数的情况下，将使用主机Java平台的默认时区。如果指定的时区标识符未知或拼写错误，则将GMT时区视为由<a href="http://docs.oracle.com/javase/6/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String)">TimeZone.getTimeZone（String）</a>方法规范指定。
          </p>

          <p><span class="label">常见错误</span>假设逗号'，'字符被解释为参数分隔符，即模式<code>HH:mm:ss,SSS</code>将被解释为模式<code>HM:mm:ss</code>和时区<code>SSS</code> 。如果希望在日期模式中包含逗号，则只需将模式括在引号之间。例如，％date { <b>“</b> HH：mm：ss，SSS <b>”</b> }。
          </p>
				</td>
			</tr>

			<tr>
				<td class="word" name="file">
					<b>F /文件</b>
				</td>

				<td>
					<p>输出发出记录请求的Java源文件的文件名。
					</p>

					<p>生成文件信息并不是特别快。因此，除非执行速度不是问题，否则应避免使用它。
					</p>
				</td>
			</tr>

			<tr>
				<td class="word" name="caller">
					<b>呼叫者{depth}</b> <b>呼叫者{depthStart..depthEnd}</b> <b>呼叫者{depth，evaluator-1，... evaluator-n}</b> <b>呼叫者{depthStart..depthEnd，evaluator-1，... evaluator-n}</b>
				</td>

				<td>
					<p>输出生成日志事件的呼叫者的位置信息。
					</p>

					<p>位置信息取决于JVM的实现，但通常包括调用方法的标准名称，后跟调用者的源代码，文件名和括号之间的行号。
					</p>

					<p>可以将整数添加到<em>调用方</em>转换说明符的选项中，以配置要显示的信息的深度。
					</p>

          <p>例如， <b>％caller {2}</b>将显示以下摘录：</p>
					
<pre class="source white_bg">0    [main] DEBUG - logging statement 
Caller+0   at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)
Caller+1   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)</pre>

					<p>而<b>％caller {3}</b>将显示另一个摘录：</p>

<pre class="source white_bg">16   [main] DEBUG - logging statement 
Caller+0   at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22)
Caller+1   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)
Caller+2   at mainPackage.ConfigTester.main(ConfigTester.java:38)</pre>

                    <p>可以将范围说明符添加到<em>呼叫者</em>转换说明符的选项中，以配置要显示的信息的深度范围。
                    </p>

                    <p>例如， <b>％caller {1..2}</b>将显示以下摘录：</p>

<pre class="source white_bg">0    [main] DEBUG - logging statement
Caller+0   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)</pre>

					<p>此转换字还可以使用评估程序在计算呼叫者数据之前根据给定的标准测试记录事件。例如，仅当名为<em>CALLER_DISPLAY_EVAL</em>的评估<em>程序</em>返回<b>肯定</b>答案时，使用<b>％caller {3，CALLER_DISPLAY_EVAL}</b>将显示三行<em>堆栈跟踪</em> 。
				</p>

				 <p>评估器如下所述。</p>
				</td>
			</tr>

			<tr>
				<td class="word" name="line">
					<b>L /线</b>
				</td>

				<td><p>从发出记录请求的地方输出行号。</p>

					<p>生成行号信息并不是特别快。因此，除非执行速度不是问题，否则应避免使用它。
					</p>
				</td>
			</tr>


			<tr>
				<td class="word" name="message">
					<b>m / msg /消息</b>
				</td>
				<td>
          <p>输出与日志记录事件关联的应用程序提供的消息。
          </p>
				</td>
			</tr>

			<tr>
				<td class="word" name="method">
					<b>M /方法</b>
				</td>

				<td>
					<p>在发出记录请求的地方输出方法名称。</p>
					<p>生成方法名称并不是特别快。因此，除非执行速度不是问题，否则应避免使用它。</p>
				</td>
			</tr>

			<tr>
				<td class="word" name="newline">
					<b>ñ</b>
				</td>

				<td>
					<p>输出平台相关的行分隔符或多个字符。</p>
					<p>此转换字提供的性能几乎与使用不可移植的行分隔符字符串（例如“ \ n”或“ \ r \ n”）相同。因此，这是指定行分隔符的首选方式。
					</p>
				</td>

			</tr>

			<tr>
				<td class="word" name="level">
					<b>p / le /水平</b>
				</td>
				<td>输出日志记录事件的级别。</td>
			</tr>

			<tr>

				<td class="word" name="relative">
					<b>r /相对</b>
				</td>

				<td>输出从应用程序启动到创建日志记录事件为止经过的毫秒数。
				</td>
			</tr>


			<tr>
				<td class="word" name="relative">
					<b>t /螺纹</b>
				</td>

				<td>输出生成日志事件的线程的名称。
				</td>

			</tr>

			<tr>
				<td class="word" name="mdc">
					<b>X</b> { <em>键：-defaultVal</em> }<br> 
					<b>mdc</b> { <em>键：-defaultVal</em> }<br>
				</td>

				<td>

					<p>输出与生成日志事件的线程关联的MDC（映射的诊断上下文）。
					</p>

					<p>如果<b>mdc</b>转换字后面的括号之间有一个键，如<b>％mdc {userid}</b> ，那么将输出与键“ userid”相对应的MDC值。如果该值为null，则输出在<b>：-</b>运算符之后指定的<a href="configuration.html#defaultValuesForVariables">默认值</a> 。如果未指定默认值，则输出空字符串。
					</p>

					<p>如果没有给出密钥，则MDC的全部内容将以“ key1 = val1，key2 = val2”格式输出。
					</p>

					<p>有关该主题的更多详细信息，请参见<a href="mdc.html">有关MDC</a>的<a href="mdc.html">章节</a> 。</p>

				</td>
			</tr>
			<tr>
				<td class="word" name="ex">
					<b>前</b> { <em>深度</em> }<br> 
          	<b>异常</b> { <em>深度</em> }<br> 
					<b>可抛</b> { <em>深度</em> }<br>
          <br>
					<b>ex</b> {depth，evaluator-1，...，evaluator-n}<br>
					<b>异常</b> {depth，evaluator-1，...，evaluator-n}<br>
					<b>throwable</b> {depth，evaluator-1，...，evaluator-n}</td>

				<td>
					<p>输出与日志记录事件关联的异常的堆栈跟踪（如果有）。默认情况下，将输出完整的堆栈跟踪。
				 </p>
         

  			 <p><em>投掷</em>转换字后面可以<em>带有</em>以下选项之一：</p>
				 <ul>
				   <li><em>short</em> ：打印堆栈跟踪的第一行</li>
				   <li><em>full</em> ：打印完整的堆栈跟踪</li>
				   <li>任何整数：打印给定行数的堆栈跟踪</li>
				 </ul>
				 
				 <p>这里有些例子：</p>
				 
				 <table class="bodyTable">
						<tbody><tr class="a">
							<th>转换方式</th>
							<th>结果</th>
						</tr>
						<tr class="b">
							<td>％ex</td>
							<td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)
  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)</pre></td>
						</tr>
						<tr class="a">
							<td>％ex {short}</td>
							<td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)</pre></td>
						</tr>
						<tr class="b">
							<td>％ex {full}</td>
							<td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)
  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)</pre></td>
						</tr>
						<tr class="a">
							<td>％ex {2}</td>
							<td><pre>mainPackage.foo.bar.TestException: Houston we have a problem
  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)
  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)</pre></td>
						</tr>
				 </tbody></table>
					
					<p>在创建输出之前，此转换词还可以使用评估程序根据给定的标准测试日志记录事件。例如，仅当名为<em>EX_DISPLAY_EVAL</em>的评估<em>程序</em>返回<b>否定</b>答案时，使用<b>％ex {full，EX_DISPLAY_EVAL}</b>才会显示异常的完整堆栈跟踪。评估器在本文档的后面进行了描述。
					</p>

         <p>如果您在转换模式中未指定％throwable或其他与throwable相关的转换词， <code>PatternLayout</code>考虑到堆栈跟踪信息的重要性，它将自动将其添加为最后一个转换字。如果您不希望显示堆栈跟踪信息，则可以将$ nopex转换词替换为％throwable。另请参见％nopex转换字。
         </p>

				</td>
			</tr>
      
      <tr>
				<td class="word" name="xThrowable">
					<b>xEx</b> { <em>深度</em> }<br> 
          <b>xException</b> { <em>深度</em> }<br> 
					<b>xThrowable</b> { <em>深度</em> }<br>
          <br>
					<b>xEx</b> {depth，evaluator-1，...，evaluator-n}<br>
					<b>xException</b> {depth，evaluator-1，...，evaluator-n}<br>
					<b>xThrowable</b> {depth，evaluator-1，...，evaluator-n}</td>

				<td>
					<p>与上面的％throwable转换词相同，并增加了类包装信息。</p>

          <p>在异常的每个堆栈帧的末尾，将添加一个字符串，该字符串由包含相关类的jar文件组成，后跟该jar清单中的“ Implementation-Version”。这项创新技术<a href="http://macstrac.blogspot.com/2008/09/better-stack-traces-in-java-with-log4j.html">最初是由James Strachan提出的</a> 。如果信息不确定，则类包装数据前将带有波浪号，即“〜”字符。
          </p>

          <p>这是一个例子：</p>

          <p class="source small">java.lang。com.xyz上的NullPointerException。Wombat（Wombat.java:57） <b><span class="red">〜</span> [wombat-1.3.jar：1.3]</b>在com.xyz。Wombat（Wombat.java:76）〜[wombat-1.3.jar：1.3]在sun.reflect。sun.reflect处的NativeMethodAccessorImpl.invoke0（本机方法）〜[na：1.5.0_06]。在sun.reflect处调用NativeMethodAccessorImpl.invoke（NativeMethodAccessorImpl.java:39）〜[na：1.5.0_06]。DelegatingMethodAccessorImpl.invoke（DelegatingMethodAccessorImpl.java:25）〜[na：1.5.0_06]，位于java.lang.reflect。org.junit.internal.runners上的Method.invoke（Method.java:585）〜[na：1.5.0_06]。位于org.junit.internal.runners的TestMethod.invoke（TestMethod.java:59）[junit-4.4.jar：na]。MethodRoadie.runTestMethod（MethodRoadie.java:98）[junit-4.4.jar：na] ...等</p>

          <p>即使在任意复杂的类加载器层次结构中，Logback也要竭尽全力以确保其显示的类包装信息正确无误。但是，当无法保证信息的绝对正确性时，它将在数据前面加上波浪号（即'〜'字符）。因此，从理论上讲，印刷类包装信息可能与真实类包装信息不同。因此，在上面的示例中，假定Wombat类的包装数据前面有波浪号，则实际上可能是正确的包装数据[wombat.jar：1.7]。
          </p>

          <p>请注意，鉴于其潜在成本， <a href="configuration.html#packagingData"><b>包装数据的</b></a>计算<a href="configuration.html#packagingData"><b>默认情况下</b></a>处于<a href="configuration.html#packagingData"><b>禁用状态</b></a> 。启用打包数据计算后， <code>PatternLayout</code>会在模式字符串的末尾自动采用％xThrowable后缀而不是％throwable后缀。</p>

          <p><a href="http://jira.qos.ch/browse/LBCLASSIC-212">用户的反馈</a>表明Netbeans在打包信息方面感到窒息。
          </p>
        </td>

      </tr>

      <tr>
        <td class="word" name="nopex">
          <b>诺佩克斯</b> <br>
          <b>止痛药</b>
        </td>

        <td>
          <p>尽管它<em>假装</em>处理堆栈跟踪数据，但此转换字不输出任何数据，因此有效地忽略了异常。
          </p>

          <p>％nopex转换词允许用户覆盖<code>PatternLayout</code>的内部安全机制，在没有其他转换字处理异常的情况下，静默添加％xThrowable转换关键字。
          </p>
        </td>
      </tr>

      <tr>
        <td class="word" name="marker">
          <b>记号笔</b>
        </td>

        <td>
          <p>输出与记录器请求关联的标记。</p>

          <p>如果标记包含子标记，则转换器将根据以下所示格式显示父名称和子名称。
          </p>
          <p>
            <em>parentName [child1，child2]</em>
          </p>
        </td>
      </tr>


      <tr>
        <td class="word" name="property">
          <b>财产{key}</b>
        </td>
        
        <td><p>输出与名为<em>key</em>的属性关联的值。有关如何定义离子的相关文档标题为“ <a href="configuration.html#variableSubstitution">定义变量</a>和<a href="configuration.html#scopes">变量范围”</a> 。

        <!-- XXXXXXXXXXXX -->如果<em>key</em>不是记录器上下文的属性，则将在System属性中查找<em>key</em> 。</p>


         <p><em>key</em>没有默认值。如果省略该参数，则返回的值将是“ Property_HAS_NO_KEY”，表明错误情况。</p>
          
        </td>
      </tr>

      <tr>
        <td class="word" name="replace">
          <b>replace（ <em>p</em> ）{r，t}</b>
        </td>
        
        <td>
          <p>用子模式“ p”产生的字符串中的“ t”替换正则表达式“ r”。例如，“％replace（％msg）{'\ s'，”}”将删除事件消息中包含的所有空格。
          </p>

          <p>模式“ p”可以任意复杂，特别是可以包含多个转换关键字。例如，“％replace（％logger％msg）{'\。'，'/'}”将用正斜杠替换记录器中的所有点或事件消息。
          </p>
          
        </td>
      </tr>


      <tr>
        <td class="word" name="rootException">
          <b>rEx</b> { <em>深度</em> }<br> 
          <b>rootException</b> { <em>深度</em> }<br> 
          <br>
					<b>rEx</b> {depth，evaluator-1，...，evaluator-n}<br>
					<b>rootException</b> {depth，evaluator-1，...，evaluator-n}</td>
        
        <td>
          <p>输出与日志记录事件关联的异常的堆栈跟踪（如果有）。将首先输出根本原因，而不是标准的“根本原因最后”。这是一个示例输出（针对空间进行编辑）：</p>

         <pre class="small">java.lang.NullPointerException
  at com.xyz.Wombat(Wombat.java:57) ~[wombat-1.3.jar:1.3]
  at com.xyz.Wombat(Wombat.java:76) ~[wombat-1.3.jar:1.3]
Wrapped by: org.springframework.BeanCreationException: Error creating bean with name 'wombat': 
  at org.springframework.AbstractBeanFactory.getBean(AbstractBeanFactory.java:248) [spring-2.0.jar:2.0]
  at org.springframework.AbstractBeanFactory.getBean(AbstractBeanFactory.java:170) [spring-2.0.jar:2.0]
  at org.apache.catalina.StandardContext.listenerStart(StandardContext.java:3934) [tomcat-6.0.26.jar:6.0.26]
</pre>          

         <p>％rootException转换器接受与上述％xException转换器相同的可选参数，包括深度和评估器。它还输出包装信息。简而言之，％rootException与％xException非常相似，只是异常输出的顺序相反。
         </p>

         <p>％rootException转换器的作者Tomasz Nurkiewicz在博客条目<a href="http://nurkiewicz.blogspot.com/2011/09/logging-exceptions-root-cause-first.html">“首先记录异常的根本原因”中记录</a>了他的贡献。</p>
        </td>
      </tr>

		</tbody></table>


    <h4 class="doAnchor" name="percentIsSpecial">％字符有特殊含义</h4>

    <p>鉴于在转换模式的上下文中，百分号带有特殊含义，为了将其包括在文字中，需要使用反斜杠对其进行转义，例如“％d％p <b>\</b> ％％m％n”。
    </p>

    <h4 class="doAnchor" name="restrictionsOnLiterals">紧随转换字之后的文字的限制</h4>

    <p>在大多数情况下，文字自然包含空格或其他定界字符，以使它们不会与转换词混淆。例如，模式“％level [％thread]-％message％n”包含字符串文字<code>" ["</code>和<code>"] - "</code> 。但是，如果一个字符（可能是Java标识符的一部分）紧随转换词之后，则将把logback的模式解析器当作愚弄者以为文字是转换词的一部分。例如，模式“％date <b>％nHello</b> ”将被解释为两个转换字％date和％nHello，并且由于％nHello不是已知的转换字，因此logback将为％nHello输出％PARSER_ERROR [nHello]。如果希望字符串文字“ Hello”立即将％n和Hello分开，请将空的参数列表传递给％n。例如，“％date <b>％n {}</b> Hello”将解释为％date，后跟％n，然后是文字“ Hello”。

    </p>

    <h2 class="doAnchor" name="formatModifiers">格式修饰符</h2>

		<p>默认情况下，相关信息按原样输出。但是，借助格式修饰符可以更改每个数据字段的最小和最大宽度以及对齐方式。
		</p>

		<p>可选的格式修饰符位于百分号与转换字符或单词之间。
		</p>

		<p>第一个可选的格式修饰符是<em>左对齐标志</em> ，它只是减号（-）。然后是可选的<em>最小字段宽度</em>修饰符。这是一个十进制常数，代表要输出的最少字符数。如果数据项包含的字符较少，则在左侧或右侧填充它，直到达到最小宽度。默认为在左侧填充（右对齐），但您可以使用左侧对齐标志指定右填充。填充字符为空格。如果数据项大于最小字段宽度，则字段将扩展以容纳数据。该值永远不会被截断。
		</p>

		<p>可以使用<em>最大字段宽度</em>修饰符来更改此行为，该修饰符由句点和十进制常数指定。如果数据项长于最大字段，则多余的字符将从数据项的<em>开头</em>删除。例如，如果最大字段宽度为8，数据项的长度为10个字符，则将删除数据项的前两个字符。此行为与C中的printf函数不同，后者从头开始进行截断。
		</p>

		<p>通过在句点之后添加减号，可以从结尾截断。在这种情况下，如果最大字段宽度为8，数据项的长度为10个字符，则将删除数据项的最后两个字符。
		</p>

		<p>以下是记录器转换说明符的各种格式修改器示例。
		</p>

		<table class="bodyTable" border="0" cellpadding="8">
      <tbody><tr>
        <th>格式修饰符</th>
        <th>左对齐</th>
        <th>最小宽度</th>
        <th>最大宽度</th>
        <th>评论</th>
      </tr>
			<tr class="a">
				<td align="center">％20logger</td>
				<td align="center">假</td>
				<td align="center">20</td>
				<td align="center">没有</td>
				<td>如果记录器名称的长度少于20个字符，请在左侧用空格填充。
				</td>
			</tr>
			<tr class="b">
				<td align="center">％-20logger</td>
				<td align="center">真正</td>
				<td align="center">20</td>
				<td align="center">没有</td>
				<td>如果记录器名称的长度少于20个字符，请在右边加空格。
				</td>
			</tr>
			<tr class="a">
				<td align="center">％.30logger</td>
				<td align="center">不适用</td>
				<td align="center">没有</td>
				<td align="center">30</td>
				<td>如果记录器名称超过30个字符，请从头开始截断。
				</td>
			</tr>
			<tr class="b">
				<td align="center">％20.30logger</td>
				<td align="center">假</td>
				<td align="center">20</td>
				<td align="center">30</td>
				<td>如果记录器名称少于20个字符，则在左空格处留空格。但是，如果记录器名称超过30个字符，则从头开始截断。
				</td>
			</tr>
			<tr class="a">
				<td align="center">％-20.30logger</td>
				<td align="center">真正</td>
				<td align="center">20</td>
				<td align="center">30</td>
				<td>如果记录器名称少于20个字符，请在右空格处加空格。但是，如果记录器名称超过30个字符，则从头<em>开始</em>截断。
				</td>
			</tr>
			<tr class="b">
				<td align="center">％.- 30logger</td>
				<td align="center">不适用</td>
				<td align="center">没有</td>
				<td align="center">30</td>
				<td>如果记录器名称超过30个字符，则从<em>末尾</em>截断。
				</td>
			</tr>
		</tbody></table>
				
		<p>下表列出了格式修饰符截断的示例。请注意，方括号（即成对的[[]]字符）不是输出的一部分。它们用于界定输出的宽度。</p>


		<table class="bodyTable" border="0" cellpadding="8">
      <tbody><tr>
        <th>格式修饰符</th>
        <th>记录仪名称</th>
        <th>结果</th>		
      </tr>
			<tr class="b">
				<td align="center">[％20.20logger]</td>
				<td align="center">主要。名称</td>
				<td align="center"><pre>[           main.Name]</pre></td>
			</tr>
      <tr class="a">
				<td align="center">[％-20.20logger]</td>
				<td align="center">主要。名称</td>
				<td align="center"><pre>[main.Name           ]</pre></td>
			</tr>
		  <tr class="a">
				<td align="center">[％10.10logger]</td>
				<td align="center">main.foo.foo.bar。名称</td>
				<td align="center"><pre>[o.bar.Name]</pre></td>
			</tr>
			<tr class="b">
				<td align="center">[％10.-10logger]</td>
				<td align="center">main.foo.foo.bar。名称</td>
				<td align="center"><pre>[main.foo.f]</pre></td>
			</tr>
		</tbody></table>

    <h3 class="doAnchor" name="oneLetterLevel">只输出一个字母</h3>

    <p>您可能只想打印T，D，W，I和E，而不是为该级别打印TRACE，DEBUG，WARN，INFO或ERROR。您可以为此编写一个<a href="#customConversionSpecifier">自定义转换器</a> ，或者简单地使用格式修饰符（刚刚讨论过）将级别值缩短为单个字符。适当的转化说明应为“ <code>%.-1level</code> ”。
    </p>
    
		<h2 class="doAnchor" name="cwOptions">转换字选项</h2>

		<p>转换说明符后可以跟选项。总是在花括号之间声明。我们已经看到了选项提供的一些可能性，例如，与MDC转换说明符一起使用，如： <em>％mdc {someKey}</em> 。
		</p>

    <p>转换说明符可能有多个选择。例如，使用评估程序的转换说明符（很快将介绍）可以将评估程序名称添加到选项列表中，如下所示：</p>

		<pre class="prettyprint source">&lt;pattern>%-4relative [%thread] %-5level - %msg%n \
  <b>%caller{2, DISP_CALLER_EVAL, OTHER_EVAL_NAME, THIRD_EVAL_NAME}</b>&lt;/pattern></pre>
    
    <p>如果选项包括大括号，空格或逗号之类的特殊字符，则可以将其括在单引号或双引号之间。例如，考虑下一个模式。</p>

		<pre class="prettyprint source">&lt;pattern>%-5level - %replace(%msg)<b>{'\d{14,16}', 'XXXX'}</b>%n&lt;/pattern></pre>


    <p>我们通过选项<code>\d{16}</code>和<code>XXXX</code>到<code>replace</code>转换词。它用XXXX替换消息中包含的任何14、15或16位数字序列，从而有效地混淆了信用卡号。请注意，“ \ d”是正则表达式中一位数字的简写。“ {14,16 \}”被解释为“ {14，16}”，即，重复前一项至少14次，但最多重复16次。
    </p>

		<h2 class="doAnchor" name="Parentheses">括号很特殊</h2>

    <p>在logback中，模式字符串中的括号被视为分组标记。因此，可以对子模式进行分组并在该子模式上应用格式指令。从0.9.27版本开始，logback支持复合转换字，例如<a href="#replace">％replace</a> ，可以转换子模式。
    </p>

    <p>例如图案</p> 

    <p class="source"><b>％-30（</b> ％d {HH：mm：ss。SSS} [％thread] <b>）</b> ％-5level％logger {32}-％msg％n</p> 

    <p>会将子模式“％d {HH：mm：ss”生成的输出分组。SSS} [％thread]”，因此，如果少于30个字符，则将其右边填充。
    </p>

    <p>如果不进行分组，则输出为</p>

    <p class="source">13:09:30 [main]调试cqlogback.demo。ContextListener-Classload哈希码为13995234 13:09:30 [main] DEBUG cqlogback.demo。ContextListener-ServletContext的初始化13:09:30 [main]调试cqlogback.demo。ContextListener-试用平台Mbean服务器13:09:30 [pool-1-thread-1]信息ch.qos.logback.demo。LoggingTask-Howdydy-diddly-ho-0 13:09:38 [btpool0-7]信息cqldemo.lottery。LotteryAction-号码：50次尝试。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-开始分解。13:09:40 [btpool0-7]调试cqldprime。NumberCruncherImpl-尝试2作为一个因子。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-找到的因子2</p>

    <p>与“％-30（）”分组将是</p>

    <p class="source">13:09:30 [main]调试cqlogback.demo。ContextListener-Classload哈希码为13995234 13:09:30 [main] DEBUG cqlogback.demo。ContextListener-ServletContext的初始化13:09:30 [main]调试cqlogback.demo。ContextListener-试用平台Mbean服务器13:09:30 [pool-1-thread-1]信息ch.qos.logback.demo。LoggingTask-Howdydy-diddly-ho-0 13:09:38 [btpool0-7]信息cqldemo.lottery。LotteryAction-号码：50次尝试。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-开始分解。13:09:40 [btpool0-7]调试cqldprime。NumberCruncherImpl-尝试2作为一个因子。13:09:40 [btpool0-7]信息cqldprime。NumberCruncherImpl-找到的因子2</p>

    
    <p>后一种形式更易于阅读。</p>
    
    <p>如果需要将括号字符视为文字，则需要在每个括号前面加上反斜杠来对其进行转义。就像<b>\（</b> ％d {HH：mm：ss。SSS} [％thread] <b>\）</b> 。
    </p>

    <h2 class="doAnchor" name="coloring">染色</h2>

    <p>如上所述，通过<a href="#Parentheses">括号</a>分组可以使子图案着色。从1.0.5版开始， <code>PatternLayout</code>识别“％black”，“％red”，“％green”，“％yellow”，“％blue”，“％magenta”，“％cyan”，“％white”，“％gray”，“％boldRed” ，“％boldGreen”，“％boldYellow”，“％boldBlue”，“％boldMagenta”，“％boldCyan”，“％boldWhite”和“％highlight”作为转换词。这些转换字旨在包含一个子模式。着色词包围的任何子图案将以指定的颜色输出。
    </p>

    <p>以下是说明着色的配置文件。请注意，包含“％logger {15}”的％cyan转换说明符。这将输出记录器名称，缩写为青色的15个字符。％highlight转换说明符针对级别为ERROR的事件以红色显示其子模式，对于警告为红色，对于警告为红色，对于信息为蓝色，其默认模式为其他级别。</p>

		<em>示例：突出显示级别（logback-examples / src / main / resources / chapters / layouts / highlighted.xml）</em> <span class="asGroovy" onclick="return asGroovy('highlighted');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('highlighted');">查看</span>


<pre id="highlighted" class="prettyprint">&lt;configuration debug="true">
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <b>&lt;withJansi>true&lt;/withJansi></b>
    &lt;encoder>
      &lt;pattern>[%thread] <b>%highlight(%-5level)</b> <b>%cyan(%logger{15})</b> - %msg %n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

     <p>设置<code>withJansi</code>如果为true，则启用Jansi库对ANSI颜色代码的解释，如果基础终端不兼容，它将透明过滤掉ANSI转义序列。对于跨平台部署，这是最安全的选择，但在类路径上需要org.fusesource.jansi：jansi：1.17或更高版本。请注意，基于Unix的操作系统（例如Linux和Mac OS X）本机支持ANSI颜色代码，通常不需要启用Jansi库，但是这样做是无害的。但是，在Windows上，建议启用Jansi以受益于DOS命令提示符上的颜色代码解释，否则可能会被发送无法解释的ANSI转义序列。
     </p>

     <p>这是相应的输出：</p>

<pre class="source">[main] <span style="color:#611">WARN</span>  <span style="color:#2bd">c.l.TrivialMain</span> - a warning message 0
[main] DEBUG <span style="color:#2bd">c.l.TrivialMain</span> - hello world number1
[main] DEBUG <span style="color:#2bd">c.l.TrivialMain</span> - hello world number2
[main] <span style="color:#00F">INFO</span>  <span style="color:#2bd">c.l.TrivialMain</span> - hello world number3
[main] DEBUG <span style="color:#2bd">c.l.TrivialMain</span> - hello world number4
[main] <span style="color:#611">WARN</span>  <span style="color:#2bd">c.l.TrivialMain</span> - a warning message 5
[main] <span style="color:#F00">ERROR</span> <span style="color:#2bd">c.l.TrivialMain</span> - Finish off with fireworks</pre>

    <p>创建着色转换词只需很少的代码行。标题为<a href="#customConversionSpecifier">创建自定义转换说明符的部分</a>讨论了在配置文件中注册转换字所需的步骤。</p>
   
		<h2 class="doAnchor" name="Evaluators">评估者</h2>

		<p>如上所述，当要求转换说明符基于一个或多个动态运行时，选项列表会派上用场<a href="../xref/ch/qos/logback/core/boolex/EventEvaluator.html"><code>EventEvaluator</code></a>对象。
		<code>EventEvaluator</code>对象负责确定给定的日志记录事件是否符合评估者的条件。
		</p>
		
    <p>让我们回顾一个涉及<code>EventEvaluator</code> 。下一个配置文件将日志记录事件输出到控制台，显示日期，线程，级别，消息和呼叫者数据。鉴于提取日志事件的调用方数据是很昂贵的，因此仅当日志请求来自特定的日志程序并且消息包含特定的字符串时，我们才会这样做。因此，我们确保仅特定的日志记录请求将生成并显示其呼叫者信息。在其他情况下，如果调用方数据多余，我们将不会损害应用程序性能。
		</p>

    <p>如果要以任何有意义的方式使用评估<a href="filters.html#evalutatorFilter">器</a> ，则必须阅读<a href="filters.html#evalutatorFilter">过滤器一章</a>的<a href="filters.html#evalutatorFilter">专用部分，其中介绍了</a>评估器，尤其是<em>评估表达式</em> 。另请注意，以下示例隐式基于<code>JaninoEventEvaluator</code>这需要<a href="http://docs.codehaus.org/display/JANINO/Home">Janino库</a> 。请参阅安装文档的<a href="../setup.html#janino">相应部分</a> 。</p>

		<em>示例：EventEvaluators的示例用法（logback-examples / src / main / resources / chapters / layouts / callerEvaluatorConfig.xml）</em> <span class="asGroovy" onclick="return asGroovy('callerEvaluatorConfig');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('callerEvaluatorConfig');">查看</span>


		<pre id="callerEvaluatorConfig" class="prettyprint source">&lt;configuration>
  <b>&lt;evaluator name="DISP_CALLER_EVAL">
    &lt;expression>logger.contains("chapters.layouts") &amp;amp;&amp;amp; \
      message.contains("who calls thee")&lt;/expression>
  &lt;/evaluator></b>

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"> 
    &lt;encoder>
      &lt;pattern>
        %-4relative [%thread] %-5level - %msg%n<b>%caller{2, DISP_CALLER_EVAL}</b>
      &lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG"> 
    &lt;appender-ref ref="STDOUT" /> 
  &lt;/root>
&lt;/configuration></pre>

		<p>上面的评估表达式匹配从记录器发出的事件，该事件的名称包含字符串“ chapters.layouts”，消息包含字符串“ who调用thee”。由于XML编码规则，＆字符不能按原样编写，而需要按＆进行转义。</p>

    <p>下列类利用了上述配置文件中提到的某些特征。</p>
		
    <p><em>示例：EventEvaluators的示例用法<a href="../xref/chapters/layouts/CallerEvaluatorExample.html">（logback-examples / src / main / java / chapters / layouts / CallerEvaluatorExample.java）</a>
		</em>
    </p>
		<pre class="prettyprint source">package <b>chapters.layouts</b>;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class CallerEvaluatorExample {

  public static void main(String[] args)  {
    Logger logger = LoggerFactory.getLogger(CallerEvaluatorExample.class);
    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();

    try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(lc);
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
      // StatusPrinter will handle this
    }
    StatusPrinter.printInCaseOfErrorsOrWarnings(lc);

    for (int i = 0; i &lt; 5; i++) {
      if (i == 3) {
        logger.debug(<b>"who calls thee</b>?");
      } else {
        logger.debug("I know me " + i);
      }
    }
  }
}</pre>

		<p>上面的应用程序没有做任何特别的花哨。发出五个记录请求，第三个发出消息“谁叫你？”</p>

		<p>命令</p>

    <p class="source">Java chapters.layouts。CallerEvaluatorExample src / main / java / chapters / layouts / callerEvaluatorConfig.xml</p>

    <p>将产生</p>

		<div class="source"><pre>0    [main] DEBUG - I know me 0 
0    [main] DEBUG - I know me 1 
0    [main] DEBUG - I know me 2 
0    [main] DEBUG - who calls thee? 
Caller+0   at chapters.layouts.CallerEvaluatorExample.main(CallerEvaluatorExample.java:28)
0    [main] DEBUG - I know me 4</pre></div>


		<p>发出日志记录请求时，将评估相应的日志记录事件。只有第三个记录事件符合评估标准，才会显示其呼叫者数据。对于其他日志记录事件，评估标准不匹配，并且不会打印任何呼叫者数据。
		</p>


		<p>可以更改表达式以对应现实情况。例如，可以将记录器名称和请求级别结合在一起。因此，源自应用程序的敏感部分（例如金融交易模块）的<em>WARN</em>级及更高级别的日志记录请求将显示其呼叫者数据。
		</p>

		<p><b>要点：</b>使用<em>调用方</em>转换词，当<em>表达式的值为<b>true</b></em>时， <em>将</em>输出调用方数据<em>。</em></p>

		<p>让我们考虑另一种情况。当异常包含在日志记录请求中时，还将输出其堆栈跟踪。但是，对于某些特定的异常，可能要取消堆栈跟踪。
		</p>

		<p>下面显示的Java代码创建三个日志请求，每个日志请求都有一个异常。第二个例外与其他例外不同：它包含字符串“不显示此”，并且类型为<code>chapters.layouts.TestException</code> 。作为其消息命令，现在让我们阻止第二个异常的打印。</p>

   <p><em>示例：EventEvaluators的示例用法<a href="../xref/chapters/layouts/ExceptionEvaluatorExample.html">（logback-examples / src / main / java / chapters / layouts / ExceptionEvaluatorExample.java）</a>
		</em>
    </p>
<pre class="prettyprint source">package chapters.layouts;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.util.StatusPrinter;

public class ExceptionEvaluatorExample {

  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(ExceptionEvaluatorExample.class);
    LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();

    try {
      JoranConfigurator configurator = new JoranConfigurator();
      configurator.setContext(lc);
      lc.reset();
      configurator.doConfigure(args[0]);
    } catch (JoranException je) {
       // StatusPrinter will handle this
    }
    StatusPrinter.printInCaseOfErrorsOrWarnings(lc);

    for (int i = 0; i &lt; 3; i++) {
      if (i == 1) {
        logger.debug("logging statement " + i, new TestException(
            "do not display this"));
      } else {
        logger.debug("logging statement " + i, new Exception("display"));
      }
    }
  }
}</pre>
		
		<p>在下一个配置文件中，评估表达式匹配包含类型为throwable的事件<code>chapters.layouts.TextException</code> ，正是我们希望抑制的异常类型。
    </p>

		<em>示例：EventEvaluators的示例用法（logback-examples / src / main / resources / chapters / layouts / exceptionEvaluatorConfig.xml）</em>
		<pre class="prettyprint source">&lt;configuration>

  <b>&lt;evaluator name="DISPLAY_EX_EVAL">
    &lt;expression>throwable != null &amp;amp;&amp;amp; throwable instanceof  \
      chapters.layouts.TestException&lt;/expression>
  &lt;/evaluator></b>
	
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%msg%n<b>%ex{full, DISPLAY_EX_EVAL}</b>&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="debug">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

		<p>使用此配置时，每次都有pages.layouts的实例<em>。TestException</em>包含在日志记录请求中，将取消堆栈跟踪。
		</p>

    <p>启动命令</p>

    <p class="source">Java chapters.layouts。ExceptionEvaluatorExample src / main / java / chapters / layouts / exceptionEvaluatorConfig.xml</p>

    <p>将产生</p>

<p class="source">日志记录语句0 java.lang。例外：显示在chapters.layouts。ExceptionEvaluatorExample.main（ExceptionEvaluatorExample.java:43）[logback-examples-0.9.19.jar：na]记录语句1记录语句2 java.lang。例外：显示在chapters.layouts。ExceptionEvaluatorExample.main（ExceptionEvaluatorExample.java:43）[logback-examples-0.9.19.jar：na]</p>


    <p>注意第二个日志语句如何没有堆栈跟踪。我们有效地取消了<code>TextException</code> 。每个堆栈跟踪行末尾方括号之间的文本是前面讨论过的<a href="#xThrowable">包装信息</a> 。</p>

		<p><span class="label notice">注意</span>使用<b><em>％ex</em></b>转换说明符，当<em>表达式的计算结果为<b>false</b></em>时，将显示堆栈跟踪<em>。</em></p>


    
		<h2 class="doAnchor" name="customConversionSpecifier">创建自定义转换说明符</h2>

		<p>到目前为止，我们已经在<code>PatternLayout</code> 。但是也可以添加您自己创建的转换词。</p>
		
		<p>构建自定义转换说明符包括两个步骤。
    </p>
		
    <h4>步骤1</h4>

		<p>首先，您必须扩展<code>ClassicConverter</code>类。<a href="../xref/ch/qos/logback/classic/pattern/ClassicConverter.html"><code>ClassicConverter</code></a>对象负责从中提取信息<code>ILoggingEvent</code>实例并生成一个String。例如， <a href="../xref/ch/qos/logback/classic/pattern/LoggerConverter.html"><code>LoggerConverter</code></a> ，即％logger转换词基础的转换器，从中提取logger的名称<code>ILoggingEvent</code>并将其作为字符串返回。它可能会在此过程中缩写记录器名称。</p>
		
		<p>这是一个客户转换器，它返回自创建以来经过的时间（以纳秒为单位）：</p>
		
<em>示例：示例转换器示例<a href="../xref/chapters/layouts/MySampleConverter.html">（src / main / java / chapters / layouts / MySampleConverter.java）</a></em>
<pre class="prettyprint source">public class MySampleConverter extends ClassicConverter {

  long start = System.nanoTime();

  <b>@Override</b>
  <b>public String convert(ILoggingEvent event) {</b>
    <b>long nowInNanos = System.nanoTime();</b>
    <b>return Long.toString(nowInNanos-start);</b>
  <b>}</b>
}</pre>

		<p>此实现非常简单。的<code>MySampleConverter</code>类扩展<code>ClassicConverter</code> ，并实现<code>convert</code>该方法返回自创建以来经过的纳秒数。
		</p>

    <h4>第2步</h4>

		<p>第二步，我们必须让Logback知道新的<code>Converter</code> 。为此，我们需要在配置文件中声明新的转换词，如下所示：</p>
		
<em>示例：示例转换器示例（src / main / java / chapters / layouts / mySampleConverterConfig.xml）</em> <span class="asGroovy" onclick="return asGroovy('mySampleConverterConfig');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('mySampleConverterConfig');">查看</span>
<pre id="mySampleConverterConfig" class="prettyprint source">&lt;configuration>

  <b>&lt;conversionRule conversionWord="nanos" 
                  converterClass="chapters.layouts.MySampleConverter" /></b>
	
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern><b>%-6nanos</b> [%thread] - %msg%n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;appender-ref ref="STDOUT" />
  &lt;/root>
&lt;/configuration></pre>

		<p>在配置文件中声明了新的转换字后，我们可以在<code>PatternLayout</code>模式，与其他任何转换字一样。</p>
		
    <p>命令：</p>

    <div class="source">Java chapters.layouts。SampleLogging src / main / java / chapters / layouts / mySampleConverterConfig.xml</div>

    <p>应该产生类似于以下的输出：</p>
    
    <pre class="source">4868695 [main] DEBUG - Everything's going well
5758748 [main] ERROR - maybe not quite...</pre>


		<p>读者可能想看看其他<code>Converter</code>诸如<a href="../xref/ch/qos/logback/classic/pattern/MDCConverter.html"><code>MDCConverter</code></a>了解更复杂的行为，例如期权处理。要创建自己的配色方案，请查看<a href="../xref/ch/qos/logback/classic/pattern/color/HighlightingCompositeConverter.html"><code>HighlightingCompositeConverter</code></a> 。
		</p>

   	

    <h2 class="doAnchor" name="ClassicHTMLLayout">HTMLLayout</h2>
	
	  <p><a href="../xref/ch/qos/logback/classic/html/HTMLLayout.html"><code>HTMLLayout</code></a> （包含在经典的logback中）生成HTML格式的日志。 <code>HTMLLayout</code>在HTML表中输出记录事件，该表的每一行都对应一个记录事件。</p>
		
		<p>这是由<code>HTMLLayout</code>使用其默认的CSS样式表：</p>
		<img src="images/chapters/layouts/htmlLayout0.gif" alt="HTML布局样本图像">
		
		<p>表列的内容是在转换模式的帮助下指定的。看到<a href="#ClassicPatternLayout"><code>PatternLayout</code></a>有关转换模式的文档。因此，您可以完全控制表的内容和格式。您可以选择并显示转换器的任意组合<code>PatternLayout</code>知道。
		</p>

		<p>关于使用的一个显着例外<code>PatternLayout</code>与<code>HTMLLayout</code>是转换说明符不应该由空格字符或更一般地由文字文本分隔。模式中找到的每个说明符将导致一个单独的列。同样，将为模式中找到的每个文字文本块生成一个单独的列，这可能会浪费屏幕上的宝贵房地产。</p>
     
    <p>这是简单但功能齐全的配置文件，说明了<code>HTMLLayout</code> 。
    </p>

<em>示例：HTMLLayout示例（src / main / java / chapters / layouts / htmlLayoutConfig1.xml）</em> <span class="asGroovy" onclick="return asGroovy('htmlLayoutConfig1');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('htmlLayoutConfig1');">查看</span>
<pre id="htmlLayoutConfig1" class="prettyprint source">&lt;configuration debug="true"&gt;
  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
    &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
      &lt;layout class="ch.qos.logback.classic.html.HTMLLayout">
        <b>&lt;pattern&gt;%relative%thread%mdc%level%logger%msg&lt;/pattern&gt;</b>
      &lt;/layout&gt;
    &lt;/encoder>
    &lt;file>test.html&lt;/file&gt;
  &lt;/appender&gt;

  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration>
</pre>

   <p><a href="../xref/chapters/layouts/TrivialMain.html">TrivialMain</a>应用程序记录了一些异常结束的消息。命令：</p>

   <p class="source">Java chapters.layouts。TrivialMain src / main / java / chapters / layouts / htmlLayoutConfig1.xml</p>

    <p>将在当前文件夹中创建文件<em>test.html</em> 。<em>test.html</em>的内容应类似于：</p>
		<img src="images/chapters/layouts/htmlLayout1.png" alt="HTML布局样本图像">

    <h3>堆栈痕迹</h3>

		<p>如果使用<em>％em</em>转换字显示堆栈跟踪，将创建一个表列以显示堆栈跟踪。在大多数情况下，该列将为空，浪费屏幕空间。此外，在单独的列上打印堆栈跟踪不会产生非常可读的结果。幸运的是， <em>％ex</em>转换字不是显示堆栈跟踪的唯一方法。
		</p>

		<p>可以通过以下方式实现更好的解决方案： <code>IThrowableRenderer</code>接口。这样的实现可以分配给<code>HTMLLayout</code>管理与异常相关的显示数据。默认情况下， <a href="../xref/ch/qos/logback/classic/html/DefaultThrowableRenderer.html"><code>DefaultThrowableRenderer</code></a>被分配给每个<code>HTMLLayout</code>实例。如上图所示，它以易于读取的方式在<em>新表行</em>及其堆栈跟踪上写入异常。
		</p>

		<p>如果由于某种原因您仍然希望使用<em>％ex</em>模式，则可以指定<a href="../xref/ch/qos/logback/core/html/NOPThrowableRenderer.html"><code>NOPThrowableRenderer</code></a>在配置文件中，以禁用为堆栈跟踪显示单独的行。我们不知道为什么要这么做，但是如果您愿意，可以这样做。
		</p>

    <h3>的CSS</h3>

    <p>由创建的HTML的表示形式<code>HTMLLayout</code>通过级联样式表（CSS）进行控制。在没有具体说明的情况下， <code>HTMLLayout</code>将默认为其内部CSS。但是，您可以指示<code>HTMLLayout</code>使用外部CSS文件。为此， <code>cssBuilder</code>元素可以嵌套在<code><layout></code>元素，如下所示。
		</p>

<pre class="prettyprint source">&lt;layout class="ch.qos.logback.classic.html.HTMLLayout">
  &lt;pattern>%relative...%msg&lt;/pattern>
  &lt;cssBuilder class="ch.qos.logback.classic.html.UrlCssBuilder">
    &lt;!-- url where the css file is located --&gt;
    &lt;url>http://...&lt;/url>
  &lt;/cssBuilder>	
&lt;/layout></pre>

	
		<p>的<code>HTMLLayout</code>通常与<code>SMTPAppender</code>以便以HTML格式愉快地格式化外发电子邮件。</p>


    <h2 class="doAnchor" name="log4jXMLLayout">Log4j XMLLayout</h2>

    <p><a href="../xref/ch/qos/logback/classic/log4j/XMLLayout.html">XMLLayout</a> （属于logback-classic的一部分）以与log4j.dtd兼容的格式生成输出，以与诸如<a href="http://logging.apache.org/chainsaw/index.html">Chainsaw</a>和<a href="http://vigilog.sourceforge.net/">Vigilog之类的</a>工具进行互操作，这些工具能够处理由<a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/XMLLayout.html">log4j的XMLLayout</a>生成的文件。
    </p>


    <p>作为log4j 1.2.15版中的原始XMLLayout，logback-classic中的XMLLayout具有两个布尔属性， <span class="option">locationInfo</span>和<span class="option">properties</span> 。将<span class="option">locationInfo</span>设置为true可以在每个事件中包含位置信息（呼叫者数据）。将<span class="option">属性</span>设置为true可以包含MDC信息。默认情况下，两个选项都设置为false。
    </p>

    <p>这是一个示例配置</p>

<em>示例：Log4jXMLLayout示例（src / main / java / chapters / layouts / log4jXMLLayout.xml）</em> <span class="asGroovy" onclick="return asGroovy('log4jXMLLayout');">以.groovy</span> <em>格式</em> <span class="asGroovy" onclick="return asGroovy('log4jXMLLayout');">查看</span>
    <pre id="log4jXMLLayout" class="prettyprint source">&lt;configuration>
  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
    &lt;file>test.xml&lt;/file>
    &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
      &lt;layout class="ch.qos.logback.classic.log4j.XMLLayout">
        &lt;locationInfo>true&lt;/locationInfo>
      &lt;/layout>
    &lt;/encoder> 
  &lt;/appender> 

  &lt;root level="DEBUG">
    &lt;appender-ref ref="FILE" />
  &lt;/root>
&lt;/configuration> </pre>
    
		<h1 class="doAnchor" name="logback-access">登陆访问</h1>

		<p>大多数logback-access布局仅仅是对logback-classic布局的改编。Logback-Classic和Logback-Access模块可满足不同的需求，但通常提供可比较的功能。</p>
		
		<h2>编写自己的布局</h2>

		<p>写一个习惯<code>Layout</code>进行logback访问几乎与其兄弟相同<code>Layout</code>在经典的logback中。</p>
		

		<h3 class="doAnchor" name="AccessPatternLayout">模式布局</h3>

		<p><a href="../xref/ch/qos/logback/access/PatternLayout.html"><code>PatternLayout</code></a>在logback-access中，可以使用与传统方式相同的方式进行配置。但是，它具有附加的转换说明符，适用于记录仅在HTTP Servlet请求和HTTP Servlet响应中可用的特定信息位。
    </p>

		<p>以下是的转换说明符列表<code>PatternLayout</code>在logback访问中。</p>
		
		<table class="bodyTable striped" border="0" cellpadding="8">
      <tbody><tr>
        <th align="center">转换字</th>
        <th align="center">影响</th>
      </tr>
      <tr>
        <td class="word" name="remoteIP">
          <b>一个/ remoteIP</b>
        </td>
        <td>
          <p>远端IP地址。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="localIP"><b>A / localIP</b></td>
        <td>
          <p>本地IP地址。</p>
        </td>
      </tr>		
      <tr>
        <td class="word" name="bytesSent"><b>b / B /字节发送</b></td>
        <td>
          <p>响应的内容长度。
          </p>
        </td>
      </tr>				
      <tr>
        <td class="word" name="clientHost"><b>h / clientHost</b></td>
        <td>
          <p>远程主机。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="protocol"><b>H /协议</b></td>
        <td>
          <p>请求协议。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="remoteLogName"><b>升</b></td>
        <td>
          <p>远程日志名称。在logback-access中，此转换器始终返回值“-”。
          </p>
        </td>
      </tr>
      
      <tr>
        <td class="word" name="reqParameter"><b>reqParameter {paramName}</b></td>
        <td>
          <p>响应参数。</p>
          <p>该转换词使用大括号的第一个选项，并在请求中查找相应的参数。</p>
          <p><b>％reqParameter {input_data}</b>显示相应的参数。</p>
        </td>
      </tr>		
      <tr>
        <td class="word" name="header"><b>i {header} / header {header}</b></td>
        <td>
          <p>请求标头。</p>
          <p>该转换词使用大括号的第一个选项，并在请求中查找相应的标头。</p>
          <p><b>％header {Referer}</b>显示请求的引荐来源。</p>
          <p>如果未指定选项，则显示每个可用的标题。
          </p>
        </td>
      </tr>	
      <tr>
        <td class="word" name="requestMethod"><b>m / requestMethod</b></td>
        <td>
          <p>请求方法。</p>
        </td>
      </tr>		
      <tr>
        <td class="word" name="requestURL"><b>r / requestURL</b></td>
        <td>
          <p>要求的网址。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="statusCode"><b>s / statusCode</b></td>
        <td>
          <p>请求的状态码。</p>
        </td>
      </tr>
      <tr>
          <td class="word" name="elapsedTime"><b>D /经过时间</b></td>
          <td>
              <p>服务请求所花费的时间（以毫秒为单位）。
              </p>
          </td>
      </tr>
      <tr>
        <td class="word" name="elapsedSeconds"><b>T /已用秒</b></td>
        <td>
          <p>服务请求所花费的时间，以秒为单位。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="dateAccess"><b>t /日期</b></td>
        <td>
          <p>输出记录事件的日期。日期转换说明符后可以跟一组花括号，这些花括号包含由日期使用的日期和时间模式字符串<code>java.text.SimpleDateFormat</code> 。<em>ISO8601</em>也是有效值。
					</p>
					<p>例如， <b>％t {HH：mm：ss，SSS}</b>或<b>％t {dd MMM yyyy; HH：mm：ss，SSS}</b> 。如果没有给出日期格式说明符，则假定使用通用日志格式日期格式，即： <b>％t {dd / MMM / yyyy：HH：mm：ss Z}</b>
					</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="httpUser"><b>你/用户</b></td>
        <td>
          <p>远程用户。
          </p>
        </td>
      </tr>		
      <tr>
        <td class="word" name="queryString"><b>q / queryString</b></td>
        <td>
          <p>请求查询字符串，以“？”开头'。
          </p>
        </td>
      </tr>
      <tr>
        <td class="word" name="requestURI"><b>U / requestURI</b></td>
        <td>
          <p>请求的URI。</p>
        </td>
      </tr>		
      <tr>
        <td class="word" name="sessionID"><b>S / sessionID</b></td>
        <td>
          <p>会话ID。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="server"><b>v /服务器</b></td>
        <td>
          <p>服务器名称。</p>
        </td>
      </tr>
      <tr>
        <td class="word" name="threadName"><b>我/ threadName</b></td>
        <td>
          <p>处理请求的线程的名称。</p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="localPort"><b>localPort</b></td>
        <td>
          <p>本地端口。</p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="reqAttribute"><b>reqAttribute {attributeName}</b></td>
        <td>
          <p>请求的属性。</p>
          <p>此转换词使用大括号的第一个选项，并在请求中查找相应的属性。</p>
          <p><b>％reqAttribute {SOME_ATTRIBUTE}</b>显示相应的属性。</p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="reqCookie"><b>reqCookie {cookie}</b></td>
        <td>
          <p>要求Cookie。</p>
          <p>该转换词使用大括号的第一个选项，并在请求中查找相应的cookie。</p>
          <p><b>％cookie {COOKIE_NAME}</b>显示相应的cookie。</p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="responseHeader"><b>responseHeader {header}</b></td>
        <td>
          <p>响应的标题。
          </p>
          <p>该转换词采用大括号形式的第一个选项，并在响应中查找相应的标头。</p>
          <p><b>％header {Referer}</b>显示响应的引荐来源。</p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="requestContent"><b>requestContent</b></td>
        <td>
          <p>此转换字显示请求的内容，即请求的内容<code>InputStream</code> 。它与<a href="../xref/ch/qos/logback/access/servlet/TeeFilter.html"><code>TeeFilter</code></a> ， 一种<code>javax.servlet.Filter</code>取代了原来的<code>HttpServletRequest</code>由一个<a href="../xref/ch/qos/logback/access/servlet/TeeHttpServletRequest.html"><code>TeeHttpServletRequest</code></a> 。后一个对象允许访问请求的<code>InputStream</code>多次而不会丢失任何数据。
          </p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="fullRequest"><b>fullRequest</b></td>
        <td>
          <p>该转换器输出与请求关联的数据，包括所有标头和请求内容。
          </p>
        </td>
      </tr>
      <tr class="b">
        <td class="word" name="responseContent"><b>responseContent</b></td>
        <td>
          <p>此转换字显示响应的内容，即响应的<code>InputStream</code> 。它与<a href="../xref/ch/qos/logback/access/servlet/TeeFilter.html"><code>TeeFilter</code></a> ， 一种<code>javax.servlet.Filter</code>取代了原来的<code>HttpServletResponse</code>由一个<a href="../xref/ch/qos/logback/access/servlet/TeeHttpServletResponse.html"><code>TeeHttpServletResponse</code></a> 。后一个对象允许访问请求的<code>InputStream</code>多次而不会丢失任何数据。
          </p>
        </td>
      </tr>
      <tr class="a">
        <td class="word" name="fullResponse"><b>fullResponse</b></td>
        <td>
          <p>该转换字采用与响应相关的所有可用数据，包括响应的所有标头和响应内容。
          </p>
        </td>
      </tr>
    </tbody></table>
		
		<p>登录访问” <code>PatternLayout</code>还可以识别三个类似于快捷键的关键字。</p>

    <table class="bodyTable">
      <tbody><tr>
        <th>关键词</th>
        <th>等效转换模式</th>
      </tr>
      <tr class="a">
        <td><em>普通</em>或<em>CLF</em></td>
        <td><em>％h％l％u [％t]“％r”％s％b</em></td>
      </tr>
      <tr class="b">
        <td><em>合并的</em></td>
        <td><em>％h％l％u [％t]“％r”％s％b“％i {Referer}”“％i {User-Agent}”</em></td>
      </tr>

    </tbody></table>

 	
	 	<p><em>common</em>关键字对应于模式<em>'％h％l％u [％t]“％r”％s％b'</em> ，该模式显示客户端主机，远程日志名称，用户，日期，请求的URL，状态代码和响应的内容长度</p>
	 	
	 	<p><em>组合</em>关键字是<em>'％h％l％u [％t]“％r”％s％b“％i {Referer}”“％i {User-Agent}”“</em>的快捷方式。此模式与<em>通用</em>模式非常相似，但也显示两个请求标头，即引用者和用户代理。</p>

		<h3 class="doAnchor" name="AccessHTMLLayout">HTMLLayout</h3>
		
		<p>的<a href="../xref/ch/qos/logback/access/html/HTMLLayout.html"><code>HTMLLayout</code></a>在logback-access中找到的类类似于<a href="#ClassicHTMLLayout"><code>HTMLLayout</code></a> logback-classic中的class。
    </p>
		
		<p>默认情况下，它将创建一个包含以下数据的表：</p>
		
		<ul>
			<li>远程IP</li>
			<li>日期</li>
			<li>要求网址</li>
			<li>状态码</li>
			<li>内容长度</li>
		</ul>
		
		<p>这是由<code>HTMLLayout</code>在logback访问中：</p>
		<img src="images/chapters/layouts/htmlLayoutAccess.gif" alt="访问HTML布局样本图像">

		<p>有什么比真实的例子更好的呢？我们自己的用于logback <a href="http://logback.qos.ch/translator/">转换器</a>的log4j属性利用logback-access来演示实时输出<code>RollingFileAppender</code>与<code>HTMLLayout</code> 。</p>


    <p>在对我们的<a href="http://logback.qos.ch/translator/">翻译器</a> Web应用程序的每个新用户请求中，都会在访问日志中添加一个新条目，您可以通过<a href="http://logback.qos.ch/translator/logs/access.html">以下链接</a>进行查看。</p>


    <script src="../templates/footer.js" type="text/javascript"></script>
</div>


</body></html>