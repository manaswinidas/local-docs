<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>第11章乔兰</title>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
    <link rel="stylesheet" type="text/css" href="../css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="../css/prettify.css" media="screen">
  </head>
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript">prefix='../'</script>
    <script type="text/javascript" src="../js/prettify.js"></script>
    <script type="text/javascript"> src="../templates/header.js"</script>
    <script type="text/javascript" src="../js/jquery-min.js"></script>
    <script type="text/javascript" src="../js/decorator.js"></script>

    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="../templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="menu.js" type="text/javascript"></script>
    </div>
    <div id="content">
      
    <h1>第11章乔兰</h1>

    <a href="onJoran_ja.html">和訳（日语翻译）</a>

    <div class="quote">
      <p><em>我的朋友，答案在风中飞舞。答案在风中。</em></p>
      
      <p><em>—鲍勃·迪伦（</em> BOB DYLAN）</p>
    </div>

    <p class="big red">本章已过时，需要重写以说明1.3中发生的大量更改。</p>
    
    <p>乔兰（Joran）代表西北冷风，时不时地在日内瓦湖上吹大风。日内瓦湖位于西欧中部，比许多其他欧洲湖泊要小。但是，它的平均深度为153米，异常深，按体积计恰好是西欧最大的甜水储备。
    </p>


    <p>如前几章所述，logback依赖于Joran，Joran是一个成熟，灵活且功能强大的配置框架。只有Joran才能提供回溯模块提供的许多功能。本章重点介绍Joran，其基本设计及其显着特征。
    </p>

    <p>Joran实际上是一个通用配置系统，可以独立于日志使用。为了强调这一点，我们应该提到logback-core模块没有记录器的概念。本着这种精神，本章中的大多数示例都与记录器，附加器或布局无关。
    </p>

    <p>本章介绍的示例位于<em>LOGBACK_HOME / logback-examples / src / main / java / chapters / onJoran /</em>文件夹下。
    </p>

    <p>要安装Joran，只需<a href="../download.html">下载</a> logback并将<em>logback-core-1.3.0-alpha5.jar添加</em>到您的类路径中。</p>
    
    <h2 class="doAnchor">历史的角度</h2>

    <p>反射是Java语言的强大功能，因此可以声明性地配置软件系统。例如，使用<em>ejb.xml</em>文件配置了EJB的许多重要属性。尽管EJB是用Java编写的，但它们的许多属性是在<em>ejb.xml</em>文件中指定的。同样，可以在配置文件中以XML格式表示登录设置。JDK 1.5中可用的注释以及EJB 3.0中大量使用的注释替换了以前在XML文件中发现的许多指令。乔兰（Joran）还使用注释，但范围更小。由于logback配置数据的动态特性（与EJB相比），Joran对注释的使用受到很大限制。
    </p>

    <p>在log4j中，logback的前身是<code>DOMConfigurator</code> log4j版本1.2.x和更高版本的一部分，该类也可以解析以XML编写的配置文件。 <code>DOMConfigurator</code>编写这种方式时，迫使我们开发人员每次更改配置文件的结构时都要对代码进行调整。修改后的代码必须重新编译和重新部署。同样重要的是， <code>DOMConfigurator</code>由处理子元素的循环组成，这些子元素包含许多散布的if / else语句。人们不禁注意到，这一特定代码充满了冗余和重复。<a href="http://jakarta.apache.org/commons/digester/">commons-digester项目</a>向我们展示了可以使用模式匹配规则来解析XML文件。在解析时，摘要器将应用与指定模式匹配的规则。规则类通常很小且专门。因此，它们相对容易理解和维护。
    </p>

    <p>武装着<code>DOMConfigurator</code>经验，我们开始发展<code>Joran</code> ，一个用于登录的功能强大的配置框架。乔兰（Joran）在很大程度上受到了“公地－学生计划”的启发。但是，它使用的术语略有不同。在下议院，规则可以看作是由模式和规则组成，如<code>Digester.addRule(String pattern, Rule rule)</code>方法。我们发现使规则由自身构成（而不是递归地但具有不同的含义）会不必要地造成混淆。在Joran中，规则由模式和动作组成。当对应的模式发生匹配时，将调用一个动作。模式与行为之间的这种关系是乔兰的核心。非常明显的是，通过使用简单的模式，或更精确地使用完全匹配和通配符匹配，可以满足相当复杂的要求。
    </p>

    <h3 class="doAnchor" name="saxOrDom">SAX还是DOM？</h3>

    <p>由于SAX API的基于事件的体系结构，因此基于SAX的工具无法轻松处理正向引用，即对元素的引用比在当前要处理的元素之后定义。具有循环引用的元素同样有问题。更一般而言，DOM API允许用户对所有元素执行搜索并进行向前跳转。
    </p>
    
    <p>这种额外的灵活性最初使我们选择DOM API作为Joran的基础解析API。经过一些实验，很快就清楚了，当解释规则以模式和动作的形式表达时，在解析DOM树时处理跳转到远处的元素是没有意义的。<em>仅需要按顺序，深度优先的顺序为Joran提供XML文档中的元素。</em>
    </p>

    <p>此外，SAX API提供了元素位置信息，该信息使Joran可以显示发生错误的确切行号和列号。位置信息在识别解析问题时非常方便。
    </p>
    
    <h3>非目标</h3>

    <p>鉴于其高度动态的特性，Joran API不能用于解析具有成千上万个元素的超大型XML文档。
    </p>


    <h3 class="doAnchor" name="pattern">图案</h3>

    <p>Joran模式本质上是一个字符串。有两种模式， <em>精确</em>模式和<em>通配符</em> 。模式“ a / b”可用于匹配<code><b></code>嵌套在顶层的元素<code><a></code>元件。“ a / b”模式将不匹配任何其他元素，因此将指定<em>完全</em>匹配的名称。</p>

    <p>通配符可用于匹配后缀或前缀。例如，“ * / a”模式可用于匹配任何以“ a”结尾的后缀，即<code><a></code> XML文档中的元素，但不嵌套在其中的任何元素<code><a></code> 。“ a / *”模式将匹配以开头的任何元素<code><a></code> ，即嵌套在<code><a></code>元件。
    </p>

    <h3 class="doAnchor" name="action">动作</h3>
    
    <p>如上所述，Joran解析规则由模式关联组成。动作扩展了<a href="../xref/ch/qos/logback/core/joran/action/Action.html"><code>Action</code></a>类，由以下抽象方法组成。为了简洁起见，省略了其他方法。
    </p>


    <pre class="prettyprint source">package ch.qos.logback.core.joran.action;

import org.xml.sax.Attributes;
import org.xml.sax.Locator;
import ch.qos.logback.core.joran.spi.InterpretationContext;

public abstract class Action extends ContextAwareBase {
  /**
   * Called when the parser encounters an element matching a
   * {@link ch.qos.logback.core.joran.spi.Pattern Pattern}.
   */
  public abstract void begin(InterpretationContext ic, String name,
      Attributes attributes) throws ActionException;

  /**
   * Called to pass the body (as text) contained within an element.
   */
  public void body(InterpretationContext ic, String body)
      throws ActionException {
    // NOP
  }

  /*
   * Called when the parser encounters an endElement event matching a
   * {@link ch.qos.logback.core.joran.spi.Pattern Pattern}.
   */
  public abstract void end(InterpretationContext ic, String name)
      throws ActionException;
}</pre>

   <p>因此，每个动作都必须执行<code>begin()</code>和<code>end()</code>方法。实施<code>body()</code>由于提供了空/ nop实现，因此该方法是可选的<code>Action</code> 。</p>


   <h3 class="doAnchor" name="ruleStore">规则库</h3>

   <p>如前所述，根据匹配模式调用动作是Joran的中心概念。规则是模式与动作的关联。规则存储在<a href="../xref/ch/qos/logback/core/joran/spi/RuleStore.html">RuleStore中</a> 。
   </p>

   <p>如上所述，Joran建立在SAX API之上。解析XML文档时，每个元素都会生成与每个元素的开头，正文和结尾相对应的事件。当Joran配置器收到这些事件时，它将尝试在其规则存储中查找与<em>当前模式</em>对应的操作。例如，嵌套在顶级<em>A</em>元素中的元素<em>B</em>的开始，主体或结束事件的当前模式是“ A / B”。当前模式是Joran在接收和处理SAX事件时自动维护的数据结构。</p>

   <p>当多个规则与当前模式匹配时，精确匹配将覆盖后缀匹配，而后缀匹配将覆盖前缀匹配。有关实现的确切详细信息，请参见<a href="../xref/ch/qos/logback/core/joran/spi/SimpleRuleStore.html">SimpleRuleStore</a>类。
   </p>
   

   <h3 class="doAnchor" name="interpretationContext">解释语境</h3>

   <p>为了允许各种动作进行协作，begin和end方法的调用将解释上下文作为第一个参数。解释上下文包括一个对象堆栈，一个对象映射，一个错误列表以及对调用该动作的Joran解释器的引用。请看<a href="../xref/ch/qos/logback/core/joran/spi/InterpretationContext.html"><code>InterpretationContext</code></a>类，用于解释上下文中包含的字段的确切列表。
   </p>
   
   <p>动作可以通过从公共对象堆栈中获取，推送或弹出对象，或者通过在公共对象图上放置和获取键对象来进行协作。动作可以通过在解释上下文的上下文中添加错误项来报告任何错误情况。 <code>StatusManager</code> 。
   </p>
   
   <h3 class="doAnchor" name="helloWorld">你好，世界</h3>
   
   <p>本章中的第一个示例说明了使用Joran所需的最小管道设置。该示例包含一个名为<a href="../xref/chapters/onJoran/helloWorld/HelloWorldAction.html"><code>HelloWorldAction</code></a>当它在控制台上打印“ Hello World”时<code>begin()</code>方法被调用。XML文件的解析是由配置程序完成的。在本章中，我们开发了一个非常简单的配置器，称为<a href="../xref/chapters/onJoran/SimpleConfigurator.html"><code>SimpleConfigurator</code></a> 。的<a href="../xref/chapters/onJoran/helloWorld/HelloWorld.html"><code>HelloWorld</code></a>应用程序将所有这些部分组合在一起：</p>

   <ul>
     <li>它创建了规则图和<code>Context</code></li>
     <li>它通过将<em>hello-world</em>模式与相应的关联来创建解析规则<code>HelloWorldAction</code>实例</li>
     <li>它创建一个<code>SimpleConfigutator</code> ，并通过上述规则图</li>
     <li>然后，它调用<code>doConfigure</code>配置程序的方法，将指定的XML文件作为参数传递</li>
     <li>最后，打印上下文中的累积状态消息（如果有）</li>
   </ul>

    <p><em>hello.xml</em>文件包含一个<hello-world>元素，没有任何其他嵌套元素。有关确切内容，请参阅<em>logback-examples / src / main / java / chapters / onJoran / helloWorld /</em>文件夹。
    </hello-world></p>
 
    <p>使用<em>hello.xml</em>文件运行HelloWorld应用程序将在控制台上打印“ Hello World”。</p>
   
    <p class="command">Java chapter.onJoran.helloWorld。HelloWorld src / main / java / chapters / onJoran / helloWorld / hello.xml</p>

    <p>在此示例中，强烈建议您通过在规则存储中添加新规则，修改XML文档（hello.xml）并添加新操作来进行讨论。
    </p>

    <!-- ====================================================== -->

    <h3 class="doAnchor" name="calculator">合作行动</h3>
   
    <p><em>logback-examples / src / main / java / joran / calculator /</em>目录包含几个动作，这些动作通过公共对象堆栈共同协作以完成简单的计算。
    </p>

    <p><em>Calculator1.xml</em>文件包含一个<code>computation</code>元素，带有嵌套<code>literal</code>元件。这是其内容。
    </p>

    <em>范例10。 <span class="autoEx"></span> ：第一个计算器示例（logback-examples / src / main / java / chapters / onJoran / calculator / calculator1.xml）</em> <em> </em>
    <pre class="prettyprint source">&lt;computation name="total">
  &lt;literal value="3"/>
&lt;/computation></pre>

    <p>在里面<a href="../xref/chapters/onJoran/calculator/Calculator1.html"><code>Calculator1</code></a>在应用程序中，我们声明各种解析规则（模式和动作）共同协作以基于XML文档的内容计算结果。
    </p>

    <p>跑步<code>Calculator1</code>带<em>Calculator1.xml的</em>应用程序</p>

    <p class="command">Java Chapters.onJoran.calculator。Calculator1 src / main / java / chapters / onJoran / calculator / calculator1.xml</p>

    <p>将打印：</p>

    <p class="console">名为[total]的计算得出的值为3</p>


    <p>解析<em>calculator1.xml</em>文档（上面列出）涉及以下步骤：</p>

    <ul>
      <li>与<computation>元素相对应的开始事件<computation>转换为当前模式“ / computation”。由于在<a href="../xref/chapters/onJoran/calculator/Calculator1.html"><code>Calculator1</code></a>应用程序中，我们将模式“ / computation”与<a href="../xref/chapters/onJoran/calculator/ComputationAction1.html"><code>ComputationAction1</code></a>例如， <code>begin()</code>那个方法<code>ComputationAction1</code>实例被调用。
      </computation></computation></li>

      <li><p>对应于<literal>元素的开始事件<literal>转换为当前模式“ / computation / literal”。给定“ /计算/文字”模式与<a href="../xref/chapters/onJoran/calculator/LiteralAction.html"><code>LiteralAction</code></a>例如， <code>begin()</code>那个方法<code>LiteralAction</code>实例被调用。</literal></literal></p>
      </li>

      <li><p>同样，与<literal>元素</literal>相对应的结束事件<literal>触发对<code>end</code> （）方法相同<code>LiteralAction</code>实例。</literal></p>
      </li>


      <li><p>同样，对应于<computation>元素结尾的事件<computation>会触发调用<code>end()</code>的方法<code>ComputationAction1</code>同一实例。
      </computation></computation></p>
      </li>
    </ul>

    <p>这里有趣的是动作协作的方式。的<code>LiteralAction</code>读取文字值并将其压入由<code>InterpretationContext</code> 。完成后，任何其他操作都可以弹出该值以读取或修改它。在这里<code>end()</code>的方法<code>ComputationAction1</code>类从堆栈中弹出值并进行打印。
    </p>

    <!-- TO BE CONTINUED -->

    <p>下一个示例<em>Calculator2.xml</em>文件稍微复杂一点，但也更有趣。</p>

    <em>示例10 <span class="autoEx"></span> ：计算器配置文件（logback-examples / src / main / java / chapters / onJoran / calculator / calculator2.xml）</em>
  <pre class="prettyprint source">&lt;computation name="toto"&gt;
  &lt;literal value="7"/&gt;
  &lt;literal value="3"/&gt;
  &lt;add/&gt;
  &lt;literal value="3"/&gt;
  &lt;multiply/&gt;
&lt;/computation&gt;</pre>


  <p>与前面的示例一样，响应<literal>元素<a href="../xref/chapters/onJoran/calculator/LiteralAction.html"><code>LiteralAction</code></a>实例将在解释上下文的对象堆栈顶部推入一个与value属性对应的整数。在此示例中，即<em>Calculator2.xml</em> ，值为7和3。针对<add>元素，适当<a href="../xref/chapters/onJoran/calculator/AddAction.html"><code>AddAction</code></a>将弹出两个先前压入的整数，计算它们的总和，并将结果（即10（= 7 + 3））压入解释上下文堆栈的顶部。下一个文字元素将导致LiteralAction在堆栈顶部压入一个值为3的整数。针对<multiply>元素，适当<a href="../xref/chapters/onJoran/calculator/MultiplyAction.html"><code>MultiplyAction</code></a>将弹出两个先前压入的整数，即10和3，并计算其乘积。它将结果（即30）推入堆栈的顶部。最后，响应于与标签相对应的结束事件，ComputationAction1将在堆栈的顶部打印对象。因此，运行：</multiply></add></literal></p>

  <p class="command">Java Chapters.onJoran.calculator。Calculator1 src / main / java / chapters / onJoran / calculator / calculator2.xml</p>
  
  <p>将产生</p>

  <p class="console">名为[toto]的计算得出值30</p>
  

  <!--


  <p>Finally, a <em>calculator3.xml</em> is also provided, to
  demonstrate the possibility elements that contain instances of the
  same element. Here's the content of <em>calculator3.xml</em>:</p>

  <em>Example 10.<span class="autoEx"/>: Calculator configuration file
  (logback-examples/src/main/java/chapters/onJoran/calculator/calculator3.xml)</em>

<pre class="prettyprint source">&lt;computation name="toto"&gt;
  &lt;computation&gt;
    &lt;literal value="7"/&gt;
    &lt;literal value="3"/&gt;
    &lt;add/&gt;
  &lt;/computation&gt;   
 
  &lt;literal value="3"/&gt;
  &lt;multiply/&gt;
&lt;/computation&gt;</pre>

  <p>Much like the use of parentheses in an algebrical equation, the
  presence of a <code>computation</code> element nested in another is
  managed by the <a
  href="../xref/chapters/onJoran/calculator/ComputationAction2.html">
  <code>ComputationAction2</code></a> class using an internal
  stack. The well-formedness of XML will guarantee that a value saved
  by one <code>begin()</code> will be consumed only by the matching
  <code>end()</code> method.</p>
  -->

  <h3 class="doAnchor" name="implicit">隐式动作</h3>

  <p>到目前为止定义的规则称为显式操作，因为可以在规则存储中找到当前元素的模式/操作关联。但是，在高度可扩展的系统中，组件的数量和类型可能非常大，以至于将显式操作与所有模式相关联非常繁琐。
  </p>

  <p>同时，即使在高度可扩展的系统中，也可以观察到将各个部分链接在一起的循环规则。假设我们可以确定这样的规则，我们可以处理由编译时未知的子组件组成的组件（logback）。例如，Apache Ant能够通过检查组件中名称以<em>add</em>开头的方法，来处理包含编译时未知标签的任务。 <code>addFile</code> ， 要么<code>addClassPath</code> 。当Ant在任务中遇到嵌入式标签时，它仅实例化一个与任务类的add方法的签名匹配的对象，并将结果对象附加到父对象。
  </p>

  <p>Joran以隐式动作的形式支持类似的功能。如果没有显式模式可以匹配当前模式，Joran会保留一个隐式动作列表。但是，应用隐式操作可能并不总是合适的。在执行隐式动作之前，Joran会询问给定的隐式动作在当前情况下是否合适。仅当操作回答为肯定时，Joran配置程序才会调用（隐式）操作。请注意，如果没有任何隐式操作适用于给定的情况，则此额外步骤可以支持多个隐式操作，或者可能不支持。
  </p>

  <p>您可以创建并注册一个自定义的隐式操作，如<em>logback-examples / src / main / java / chapters / onJoran / implicit</em>文件夹中包含的下一个示例所示。
  </p>

  <p>的<a href="../xref/chapters/onJoran/implicit/PrintMe.html"><code>PrintMe</code></a>应用程序关联一个<a href="../xref/chapters/onJoran/implicit/NOPAction.html"><code>NOPAction</code></a>模式为“ * / foo”的实例，即任何名为“ foo”的元素。顾名思义， <code>begin</code> （）和<code>end</code> （）方法<code>NOPAction</code>是空的。的<code>PrintMe</code>应用程序还在其隐式操作列表中注册<a href="../xref/chapters/onJoran/implicit/PrintMeImplicitAction.html">PrintMeImplicitAction</a>的实例。的<code>PrintMeImplicitAction</code>适用于将<span class="attr">printme</span>属性设置为true的任何元素。见<code>isApplicable()</code>方法中<code>PrintMeImplicitAction</code> 。的<code>begin()</code> （） 的方法<code>PrintMeImplicitAction</code>在控制台上打印当前元素的名称。
  </p>

  <p>XML文档<em>hidden1.xml</em>旨在说明隐式动作是如何发挥作用的。</p>

  <em>示例10 <span class="autoEx"></span> ：隐式规则的使用（logback-examples / src / main / java / chapters / onJoran / implicit / implicit1.xml）</em>
  <pre class="prettyprint source">&lt;foo&gt;
  &lt;xyz printme="true"&gt;
    &lt;abc printme="true"/&gt;
  &lt;/xyz&gt;

  &lt;xyz/&gt;

  &lt;foo printme="true"/&gt;

&lt;/foo&gt;</pre>

  <p>跑步</p>

  <p class="command">Java章节。onJoran.implicit。PrintMe src / main / java / chapters / onJoran / implicit / implicit1.xml</p>
  <p>产量：</p>

  <p class="console">要求打印元素[xyz]。要求打印元素[abc]。20：33：43,750 |-cqlcjoran.spi中出现错误。口译员<b>10：9-</b> [xyz]没有适用的操作，当前模式为[[foo] [xyz]]</p>

  <p>鉴于<code>NOPAction</code>实例与“ * / foo”模式显式关联， <code>NOPAction</code>的<code>begin()</code>和<code>end()</code>方法是在<foo>元素上调用的<foo>。 <code>PrintMeImplicitAction</code>永远不会触发任何<foo>元素。对于其他元素，由于没有匹配的显式操作，因此<code>isApplicable()</code>的方法<code>PrintMeImplicitAction</code>被调用。仅对于将<span class="attr">printme</span>属性设置为true的<xyz>元素（即第一个<xyz>元素（但不包括第二个<abc>元素 ）和<abc>元素 ），它将返回true <xyz><abc>。第<xyz>10行的第二个<xyz>元素没有适用的操作，将生成内部错误消息。此消息是由<code>StatusPrinter.print</code>调用中的最后一条语句<code>PrintMe</code>应用。这解释了上面显示的输出（请参阅上一段）。
  </xyz></xyz></abc></xyz></abc></abc></xyz></xyz></foo></foo></foo></p>

  <h3 class="doAnchor" name="iaPractice">实践中的隐式动作</h3>
  
  <p>经典的logback和logback-access的Joran配置器仅包含两个隐式操作，即<a href="../xref/ch/qos/logback/core/joran/action/NestedBasicPropertyIA.html"><code>NestedBasicPropertyIA</code></a>和<a href="../xref/ch/qos/logback/core/joran/action/NestedComplexPropertyIA.html"><code>NestedComplexPropertyIA</code></a> 。
  </p>

  <p><code>NestedBasicPropertyIA</code>适用于其类型为原始类型（或<code>java.lang</code>包），枚举类型或任何遵循“ valueOf”约定的类型。据说这些属性是<em>基本的</em>或<em>简单的</em> 。如果某个类包含名为的静态方法，则该类遵守“ valueOf”约定<code>valueOf</code> （）正在<code>java.lang.String</code>作为参数并返回相关类型的实例。目前， <a href="../xref/ch/qos/logback/classic/Level.html"><code>Level</code></a> ， <a href="../xref/ch/qos/logback/core/util/Duration.html"><code>Duration</code></a>和<a href="../xref/ch/qos/logback/core/util/FileSize.html"><code>FileSize</code></a>类遵循此约定。
  </p>
  
  <p><code>NestedComplexPropertyIA</code>在其余情况下适用<code>NestedBasicPropertyIA</code>不适用， <em>并且</em>如果对象堆栈顶部的对象的setter或adder方法的属性名称等于当前元素名称。请注意，此类属性可以依次包含其他组件。因此，这种性质被认为是<em>复杂的</em> 。在拥有复杂财产的情况下， <a href="../xref/ch/qos/logback/core/joran/action/NestedComplexPropertyIA.html"><code>NestedComplexPropertyIA</code></a>将实例化嵌套组件的适当类，并使用父组件的setter / adder方法和嵌套元素的名称将其附加到父组件（在对象堆栈的顶部）。相应的类由（嵌套的）当前元素的<span class="attr">class</span>属性指定。但是，如果缺少<span class="attr">class</span>属性，则满足以下任一条件时，可以隐式推断类名：</p>

  <ol>
    <li>有一个内部规则将父对象的属性与指定的类相关联</li>
    <li>setter方法包含一个@DefaultClass属性，用于指定给定的类</li>

    <li>setter方法的参数类型是具有公共构造函数的具体类</li>
  </ol>

  <h4 class="doAnchor" name="defaultClassMapping">默认类映射</h4>

  <p>在经典的logback中，有一些内部规则将父类/属性名称对映射到默认类。这些在下表中列出。</p>

  <table class="bodyTable">
    <tbody><tr>
      <th>家长班</th>
      <th>物业名称</th>
      <th>默认的嵌套类</th>
    </tr>

    <tr>
      <td>ch.qos.logback.core。AppenderBase</td>
      <td>编码器</td>
      <td>ch.qos.logback.classic.encoder。PatternLayoutEncoder</td>
    </tr>

    <tr class="alt">
      <td>ch.qos.logback.core。UnsynchronizedAppenderBase</td>
      <td>编码器</td>
      <td>ch.qos.logback.classic.encoder。PatternLayoutEncoder</td>
    </tr>

      <tr>
      <td>ch.qos.logback.core。AppenderBase</td>
      <td>布局</td>
      <td>ch.qos.logback.classic。模式布局</td>
    </tr>

    <tr class="alt">
      <td>ch.qos.logback.core。UnsynchronizedAppenderBase</td>
      <td>布局</td>
      <td>ch.qos.logback.classic。模式布局</td>
    </tr>

    <tr>
      <td>ch.qos.logback.core.filter。EvaluatorFilter</td>
      <td>评估者</td>
      <td>ch.qos.logback.classic.boolex。JaninoEventEvaluator</td>
    </tr>
  </tbody></table>

  <p>此列表在将来的版本中可能会更改。请参阅经典的logback <a href="../xref/ch/qos/logback/classic/joran/JoranConfigurator.html">JoranConfigurator</a>的<code>addDefaultNestedComponentRegistryRules</code>最新规则的方法。
  </p>

  <p>在logback-access中，规则非常相似。在嵌套组件的默认类中，ch.qos.logback.classic包由ch.qos.logback.access代替。请参阅logback-access <a href="../xref/ch/qos/logback/access/joran/JoranConfigurator.html">JoranConfigurator</a>的<code>addDefaultNestedComponentRegistryRules</code>最新规则的方法。
  </p>
  
  <h4 class="doAnchor">属性集合</h4>

  
  <p>请注意，除了单个简单属性或单个复杂属性之外，logback的隐式操作还支持属性的集合，无论它们是简单的还是复杂的。该属性由“ adder”方法指定，而不是setter方法。</p>

  <h3 class="doAnchor" name="newRule">新规则飞速发展</h3>

  <p>Joran包含一个动作，该动作允许Joran解释器在解释XML文档时即时学习新规则。请参阅<em>logback-examples / src / main / java / chapters / onJoran / newRule /</em>目录以获取示例代码。在此套件中， <a href="../xref/chapters/onJoran/newRule/NewRuleCalculator.html"><code>NewRuleCalculator</code></a>应用程序仅设置两个规则，一个规则处理最顶层的元素，第二个规则学习新规则。这是来自的相关代码<code>NewRuleCalculator</code> 。
  </p>

  <pre class="prettyprint source">ruleMap.put(new Pattern("*/computation"), new ComputationAction1());
<b>ruleStore.addRule(new Pattern("/computation/newRule"), new NewRuleAction());</b></pre>

  <p><a href="../xref/ch/qos/logback/core/joran/action/NewRuleAction.html"><code>NewRuleAction</code></a>是logback-core的一部分，其工作原理与其他操作非常相似。它有一个<code>begin()</code>和<code>end()</code>方法，并在每次解析器找到<em>newRule</em>元素时<em>调用</em> 。调用时， <code>begin()</code>方法查找<em>pattern</em>和<em>actionClass</em>属性。然后，它实例化相应的动作类，并将模式/动作关联作为新规则添加到Joran的规则存储中。</p>


  <p>这是可以在xml文件中声明新规则的方式：</p>

  <pre class="prettyprint source">&lt;newRule pattern="*/computation/literal"
          actionClass="chapters.onJoran.calculator.LiteralAction"/&gt;</pre>

  <p>使用这样的newRule声明，我们可以进行转换<code>NewRuleCalculator</code>表现得像<code>Calculator1</code>我们之前看到的应用程序。涉及计算，可以这样表示：</p>

  <em>例子10 .. <span class="autoEx"></span> ：动态使用新规则的配置文件（logback-examples / src / main / java / chapters / onJoran / newrule / newRule.xml）</em>

  <pre class="prettyprint source">&lt;computation name="toto"&gt;
  &lt;newRule pattern="*/computation/literal" 
            actionClass="chapters.onJoran.calculator.LiteralAction"/&gt;
  &lt;newRule pattern="*/computation/add" 
            actionClass="chapters.onJoran.calculator.AddAction"/&gt;
  &lt;newRule pattern="*/computation/multiply" 
            actionClass="chapters.onJoran.calculator.MultiplyAction"/&gt;

  &lt;computation&gt;
    &lt;literal value="7"/&gt;
    &lt;literal value="3"/&gt;
    &lt;add/&gt;
  &lt;/computation&gt;   
 
  &lt;literal value="3"/&gt;
  &lt;multiply/&gt;
&lt;/computation&gt;</pre>


  <p class="command">Java Java Chapters.onJoran.newRule。NewRuleCalculator src / main / java / chapters / onJoran / newRule / newRule.xml</p>

  <p>产量</p>

  <p class="console">名为[toto]的计算得出值30</p>

  <p>与<a href="#calculator">原始计算器示例</a>的输出相同。</p>


  <script src="../templates/footer.js" type="text/javascript"></script>
</div>


</body></html>