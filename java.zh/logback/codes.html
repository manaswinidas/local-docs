<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>登录错误代码</title>

    <link rel="stylesheet" type="text/css" href="css/common.css">
    <link rel="stylesheet" type="text/css" href="css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/_print.css" media="print">
    <link rel="stylesheet" type="text/css" href="css/prettify.css">
    <style type="text/css">
      h3.doAnchor {
        border-top: 2px solid #888888;
        /*color: #333;*/
        padding-bottom: 1ex;
        padding-top: 1ex;
      }
    </style>
  </head>
  
  <body  onload="prettyPrint(); decorate();">
    <script type="text/javascript" src="js/prettify.js"></script>
    <script type="text/javascript">prefix='';</script>
    <script type="text/javascript" src="templates/header.js"></script>
    <script type="text/javascript" src="js/jquery-min.js"></script>
    <script type="text/javascript" src="js/decorator.js"></script>
    

  <div id="left">
    <script src="templates/left.js" type="text/javascript"></script>
  </div>
    <div id="right">
      <script type="text/javascript" src="templates/right.js" ></script>
    </div>

  <div id="content">
    
  <h2><a name="top">Logback错误消息及其含义</a></h2>
  

  <h3 class="doAnchor" name="null_CS">contextSelector在中不能为null <code>StaticLoggerBinder</code> 。
  </h3>

  <p>一个<code>IllegalStateException</code>当无法为回传设置ContextSelector时抛出<code>StaticLoggerBinder</code> 。原则上，仅当用户明确指定了上下文选择器并且无法正确实例化该上下文选择器时，才会发生此错误。
  </p>

  <p>使用默认或JNDI上下文选择器时，不应发生这种情况。
  </p>
  

  <!-- =========================================================== -->
  <h3 class="doAnchor" name="layoutInsteadOfEncoder">此附加程序不再将布局视为子组件，而应设置编码器。
  </h3>

  <p>从0.9.19版的Logback版本开始， <code>WriterAppender</code>该类已重命名为<code>OutputStreamAppender</code> ，带有<code>FileAppender</code>现在将后者分类。 <code>OutputStreamAppender</code>现在，子类需要一个<code>Encoder</code>作为子组件而不是<code>Layout</code> 。
  </p>

  <p>实际上，这意味着需要更改配置文件</p>
  
  <p class="red bold">来自（已弃用）</p>
  
  <pre class="prettyprint source">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
  &lt;file>testFile.log&lt;/file>
  ...
  &lt;layout class="ch.qos.logback.classic.PatternLayout">
    &lt;pattern>%msg%n&lt;/pattern>
  &lt;/layout>
&lt;/appender>   </pre>

  <p class="red bold">或更短的等效项（不推荐使用）</p>

  <pre class="prettyprint source">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
  &lt;file>testFile.log&lt;/file>
  ...
  &lt;!-- layout are assigned the type ch.qos.logback.classic.PatternLayout by default -->
  &lt;layout>
    &lt;pattern>%msg%n&lt;/pattern>
  &lt;/layout>
&lt;/appender>   </pre>


  <p class="green bold">至（良好）</p>
    <pre class="prettyprint source">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
  &lt;file>testFile.log&lt;/file>
  ...
  &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
    &lt;pattern>%msg%n&lt;/pattern>
  &lt;/encoder>
&lt;/appender>   </pre>
 
  <p class="green bold">或更短的对等词（GOOD）</p>

   <pre class="prettyprint source">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
  &lt;file>testFile.log&lt;/file>
  ...
  &lt;!-- encoders are assigned the type 
       ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
  &lt;encoder>
    &lt;pattern>%msg%n&lt;/pattern>
  &lt;/encoder>
&lt;/appender>   </pre>


  <p>对于除以外的布局类型<code>PatternLayout</code> ， 例如<code>HTMLLayout</code> ，您的配置文件需要更改</p>

  <p class="red bold">来自（已弃用）</p>

  <pre class="prettyprint source">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
  &lt;file>testFile.log&lt;/file>
  ...
  &lt;layout class="ch.qos.logback.classic.html.HTMLLayout">
    &lt;pattern>%msg%n&lt;/pattern>
  &lt;/layout>
&lt;/appender> </pre>


  <p class="green bold">至（良好）</p>
    <pre class="prettyprint source">&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender">
  &lt;file>testFile.log&lt;/file>
  ...
  &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
    &lt;layout class="ch.qos.logback.classic.html.HTMLLayout">
      &lt;pattern>%msg%n&lt;/pattern>
    &lt;/layout>
  &lt;/encoder>
&lt;/appender> </pre>
  
  

  <p>我们希望通过一些很酷的新功能来弥补这种不便，这些新功能只有使用编码器才能实现。<b>在过渡期间，作为参数传递的布局将由编码器自动包装，以便旧格式的配置文件（使用布局而不是编码器）将继续工作而不会修改。</b>
  </p>

  
  

  <!-- =========================================================== -->

  <h3 class="doAnchor" name="socket_no_host">没有设置远程主机或地址<code>SocketAppender</code>
    
  </h3>

  <p>SocketAppender必须使用远程主机或地址。</p>
  <p>您可以按如下所示在配置文件中指定远程主机。
  </p>
  
  <pre class="prettyprint source">&lt;appender name="SOCKET"
  class="ch.qos.logback.classic.net.SocketAppender">
  ...
  &lt;remoteHost>127.0.0.1&lt;/remoteHost>
  ...
&lt;/appender&gt;</pre>


  

  <!-- ============================================================= -->

  <h3 class="doAnchor" name="socket_no_port">没有设置远程端口<code>SocketAppender</code>    
  </h3>
    
  <p>SocketAppender必须使用远程端口。</p>
      
  <p>您可以在配置文件中指定远程端口，如下所示：</p>
      
  <pre class="prettyprint source">&lt;appender name="SOCKET" class=&quot;ch.qos.logback.classic.net.SocketAppender&quot;&gt;
  ...
  &lt;port>4560&lt;/port>
  ...
&lt;/appender&gt;</pre>
				


  

  <!-- ============================================================= -->

  <h3 class="doAnchor" name="smtp_no_layout">没有<code>Layout</code>为SMTPAppender设置</h3>

  <p>一种<code>Layout</code>是强制性的<code>SMTPAppender</code> 。它允许SMTPAppender在发送电子邮件之前格式化日志记录事件。
  </p>
      
  <p>您可以指定<code>Layout</code>在配置文件中如下所示：</p>
      
  <pre class="prettyprint source">&lt;appender name=&quot;SMTP&quot; class=&quot;ch.qos.logback.classic.net.SMTPAppender&quot;&gt;
  ...
  &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
    &lt;pattern>%date [%thread] %-5level %logger - %msg%n&quot;&gt;&lt;/pattern>
  &lt;/layout&gt;
  ...
&lt;/appender&gt;</pre>
      
  <p>众所周知SMTPAppender与<a href="manual/layouts.html#ClassicPatternLayout">PatternLayout</a>和<a href="manual/layouts.html#ClassicHTMLLayout">HTMLLayout</a>可以很好地配合使用。
  </p>


  
      
  <!-- ============================================================= -->

  <h3 class="doAnchor" name="sbtp_size_format">指定的数字格式不正确，或者格式不正确。
  </h3>
    
  <p>当您指定要由SizeBasedRollingPolicy使用的MaxFileSize时，logback需要一种相当精确的格式：</p>
  
  <ul>
    <li>该数字必须是整数</li>
    <li>您可以在数字后添加“ KB”，“ MB”或“ GB”。
    </li>
  </ul>
      
  <p>以下是一些正确的值：500KB，15MB，2GB。</p>
  
  
      
  <!-- ============================================================= -->

  <h3 class="doAnchor" name="rfa_no_tp">没有<code>TriggeringPolicy</code>为<code>RollingFileAppender</code> 。
    
  </h3>
    
  <p>的<code>RollingFileAppender</code>必须设置一个<code>TriggeringPolicy</code> 。它允许Appender知道何时必须激活过渡功能。
  </p>
  
  <p>查找有关的更多信息<code>TriggeringPolicy</code>对象，请阅读以下javadocs：</p>
  
  <ul>
    <li>
      <a href="manual/appenders.html#SizeBasedTriggeringPolicy"><code>SizeBasedTriggeringPolicy</code>
      </a>
    </li>
    <li>
      <a href="manual/appenders.html#TimeBasedRollingPolicy"><code>TimeBasedRollingPolicy</code>
      </a>
    </li>
  </ul>
  
  <p>请注意<code>TimeBasedRollingPolicy</code>是TriggeringPolicy <em>和</em>和<code>RollingPolicy</code>同时。
  </p>
      
  <!-- ============================================================= -->

  <h3 class="doAnchor" name="#sat_missing_integer_token">FileNamePattern [...]中缺少整数令牌，即％i。
    
  </h3>
  
  <p>对于<a href="manual/appenders.html#SizeAndTimeBasedFNATP">基于大小和时间的归档，</a>必须使用％i转换令牌。万一％i令牌丢失， <code>SizeAndTimeBasedFNATP</code>附于<code>RollingFileAppender</code>将检测到遗漏并且不会开始。
  </p>

      
  <!-- ============================================================= -->

  <h3 class="doAnchor" name="rfa_no_rp">没有<code>RollingPolicy</code>为<code>RollingFileAppender</code> 。
  </h3>
  
  <p>的<code>RollingFileAppender</code>必须设置一个<code>RollingPolicy</code> 。它允许追加者知道请求过渡时该怎么做。
  </p>
    
  <p>查找有关的更多信息<code>RollingPolicy</code>对象，请阅读以下javadocs：</p>
    
  <ul>
    <li>
      <a href="apidocs/ch/qos/logback/core/rolling/FixedWindowRollingPolicy.html">
        <code>FixedWindowRollingPolicy</code>
      </a>
    </li>
    <li>
      <a href="apidocs/ch/qos/logback/core/rolling/TimeBasedRollingPolicy.html">
        <code>TimeBasedRollingPolicy</code>
      </a>
    </li>
  </ul>
  
  <p>请注意<code>TimeBasedRollingPolicy</code>是一个<code>TriggeringPolicy</code> <em>和</em> RollingPolicy同时显示。
  </p>
  
  
  

  <!-- ============================================================= -->
  <h3 class="doAnchor" name="tbr_fnp_not_set"><span class="option">FileNamePattern</span>属性对于两个都是必需的<code>TimeBasedRollingPolicy</code>和<code>FixedWindowRollingPolicy</code> 。
  </h3>

  
  <p>两者的<span class="option">FileNamePattern</span>属性<code>TimeBasedRollingPolicy</code>和<code>FixedWindowRollingPolicy</code>是强制性的。
  </p>
  
  <p>有关示例，请参阅<a href="manual/appenders.html#TimeBasedRollingPolicy">TimeBasedRollingPolicy</a>和<a href="manual/appenders.html#FixedWindowRollingPolicy">FixedWindowRollingPolicy</a>的文档。
  </p>


  

  <!-- ============================================================= -->
  <h3 class="doAnchor" name="rfa_file_after">必须在任何滚动策略或触发策略之前设置<span class="option">File</span>属性。
    
  </h3>

  <p>如果存在<span class="option">File</span>属性，则必须将其放在任何滚动策略或触发策略之前。因此，在配置文件中，必须在任何滚动策略或触发策略声明之前声明<span class="option">File</span>属性（如果存在）。
  </p>

  <!-- ============================================================= -->  

  <h3 class="doAnchor" name="rfa_collision"><span class="option">文件</span>属性与<span class="option">fileNamePattern</span>冲突。中止。
  </h3>

  <p>当<span class="option">file</span>属性与<span class="option">fileNamePattern</span>定义的正则表达式匹配时，存在冲突的风险。当由<span class="option">file</span>属性定义的活动日志文件具有与现有日志归档文件相同的路径时，将发生冲突。这样的冲突将导致日志存档被覆盖。
  </p>

  <p>因此，如果<span class="option">file</span>属性与<span class="option">fileNamePattern</span>定义的正则表达式匹配，为了避免数据丢失， <code>RollingFileAppender</code>将发出错误消息并拒绝启动。</p>

  <!-- ============================================================= -->  

  <h3 class="doAnchor" name="rfa_collision_in_dateFormat"><span class="option">fileNamePattern中</span>的日期格式将导致归档日志文件的名称发生冲突。
  </h3>

  <p>当<span class="option">fileNamePattern中</span> ％d令牌中的日期时间模式不冲突时，将输出此错误消息。例如，以下代码> fileNamePattern将在一个月的第一周之后的每周的每一天产生相同的日志归档。
  </p>

  <pre class="source">myapp-%d{yyyy-MM-<span class="bold red">uu</span>}.log.zip</pre>

  <p>由于此类冲突将导致日志数据丢失， <code>RollingFileAppender</code>将检查各种此类可能的冲突，并且如果检测到任何冲突将不会开始。</p>

  <!-- ============================================================= -->  

  <h3 class="doAnchor" name="earlier_fa_collision"><span class="option">File</span> / <span class="option">FileNamePattern</span>选项具有与先前定义的追加程序[...]相同的值“ ...”。
  </h3>


  <p>如果一个<code>FileAppender</code> / <code>RollingFileAppender</code>较早定义的<span class="option">文件</span>具有与当前追加程序相同的<span class="option">File</span>选项，则这两个追加程序在冲突中<code>FileAppender</code>实例不能共享相同的输出目标。为防止数据丢失，当前的追加程序将不会启动。确保每个追加程序都有一个唯一的“ <span class="option">文件”</span>选项。
  </p>

  <p>类似地，RollingFileAppender的<span class="option">FileNamePattern</span>选项也有相同的限制。确保每个RollingFileAppender具有唯一的<span class="option">FileNamePattern</span>选项</p>
  
  <!-- =============================================================
       -->
  <h3 class="doAnchor" name="renamingError">无法将文件[x]重命名为[y]。</h3>

  <b>在Windows上</b>

  <p>在Windows平台上，如果有句柄引用，则无法重命名日志文件。例如，当文件被另一个进程读取时，例如<code>less</code> ， <code>tail</code> ，等等。在应用程序热重新部署期间，应用程序的旧实例将具有对日志文件的开放引用，直到旧实例完全关闭或直到<code>stop()</code>其方法<a href="apidocs/ch/qos/logback/classic/LoggerContext.html"><code>LoggerContext</code></a>被调用。
  </p>

  <p><a href="http://technet.microsoft.com/en-us/sysinternals/bb896653">Process Explorer</a>可以帮助您找到引用给定文件的进程（查找->查找句柄或DLL）。在Linux上，您可以使用<code><a href="http://www.manpagez.com/man/8/lsof/">lsof </a> <em>pathToFile</em></code>命令以查找哪个进程打开了由<em>pathToFile</em>给出的文件。</p>

  <p>由于文件权限设置不正确，滚动也可能会失败。在Windows上，重命名文件需要具有“修改”权限，该权限不同于“写入”文件的权限。</p>

  <p class="highlight">通过省略RollingFileAppender中的<span class="option">file</span>属性，可以完全避免滚动期间的文件重命名操作。</p>

  <p>在实践中，很难设置正确的权限或确保没有对日志文件的文件句柄引用。</p>

  <p>在许多情况下，完全避免在过渡期间重命名文件可能会更可靠。就像在中省略<span class="option">file</span>属性一样简单<code>RollingFileAppender</code> ，如下一个配置片段所示。
  </p>

  <pre class="prettyprint source">&lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
  <b>&lt;!-- <span class="option">file</span> property left unset/blank --></b>
  &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
    &lt;fileNamePattern>mylog.%d{yyyy-MM-dd}.log&lt;/fileNamePattern>
  &lt;/rollingPolicy>

  &lt;encoder>
    &lt;pattern>%relative [%thread] %level %logger - %msg%n&lt;/pattern>
  &lt;/encoder>
&lt;/appender></pre>

   <p>请注意<code>FixedWindowRollingPolicy</code> ， <span class="option">文件</span>属性是必需的。
   </p>
 
   <h4 class="doAnchor" name="renamingErrorOnUnix">在Unix- *上</h4>
  
   <p>在Unix平台上，如果源文件和目标文件位于不同的文件系统上，则JDK提供的基本/快速重命名方法将不起作用。为了应对这种情况，如果满足以下所有三个条件，则登录将通过复制来重命名：</p>

   <ol>
     <li>快速重命名失败，</li>
     <li>重命名的源文件和目标文件位于不同的文件系统上，</li>

     <li>主机JVM平台运行Java 7或更高版本。</li>
   </ol>

   <p>确定文件文件系统的代码需要Java 7。在Java 6或更早版本上，不会通过复制进行重命名。</p>
   
   <p>如上面Windows部分所述，可以通过省略<span class="option">文件</span>属性来完全避免重命名。
   </p>

  <!-- ============================================================= -->
  <h3 class="doAnchor" name="fwrp_parentFileName_not_set">必须先设置<span class="option">File</span>属性<code>FixedWindowRollingPolicy</code>    
  </h3>

  <p><span class="option">File</span>属性是强制性的<code>FixedWindowRollingPolicy</code> 。此外，该<span class="option">文件</span>选项前必须先进行设置<code>FixedWindowRollingPolicy</code>元件。
  </p>
      
  <p>有关更多信息，请参考<a href="manual/appenders.html#FixedWindowRollingPolicy">FixedWindowRollingPolicy</a>上的<a href="manual/appenders.html#FixedWindowRollingPolicy">注销</a>手册。
  </p>
			
  
  <!-- ============================================================= -->
  <h3 class="doAnchor" name="tbr_fnp_prudent_unsupported">不支持谨慎模式<code>FixedWindowRollingPolicy</code> 。
  </h3>

  <p>鉴于<code>FixedWindowRollingPolicy</code>在过渡期间执行多个文件重命名操作，并且不能保证这些操作在多JVM上下文中是安全的，不允许将谨慎模式与<code>FixedWindowRollingPolicy</code> 。
  </p>

  
  
  <!-- ============================================================= -->
  <h3 class="doAnchor" name="syslog_layout">SyslogAppender不允许布局。
  </h3>


  <p>鉴于syslog请求的格式遵循严格的规则，因此您无法自由指定要与SyslogAppender一起使用的布局。但是，您可以改用<span class="option">SuffixPattern</span>选项来影响发送到syslog守护程序的消息的内容。
  </p>
  
  <p>有关SyslogAppender的更多信息，请参阅<a href="manual/appenders.html#SyslogAppender">其文档。</a>
  </p>

  

  <!-- ============================================================= -->
  <h3 class="doAnchor" name="1andOnly1"><sift>元素</sift>只能嵌套在一个追加器<sift>中<code>SiftingAppender</code> 。</sift></h3>
  
  <p>SiftingAppender只允许一个嵌套的追加器。
  </p>
  

  <!-- ============================================================= -->
  <h3 class="doAnchor" name="ifJanino">在类路径上找不到Janino库。跳过条件处理。
  </h3>
  
  <p>配置文件中的<a href="manual/configuration.html#conditional">条件处理</a>需要<a href="http://docs.codehaus.org/display/JANINO/Home">Janino库</a> 。请参阅将Janino添加到您的课程路径的<a href="setup.html#janino">设置说明</a> 。
  </p>

  <!-- ============================================================= -->
  <h3 class="doAnchor" name="block">从logback版本0.9.28开始，JaninoEventEvaluator需要Java块。
  </h3>

  <p>从0.9.28版本的logback开始，JaninoEvaluator期望Java“块”，即方法的主体。在以前的版本中，仅允许布尔表达式。出于向后兼容性的原因，每当logback看到布尔表达式时，它都会尝试通过在表达式前面加上“ return”并在其后加上分号来将其转换为块。
  </p>

  <p>布尔表达式可以很快变得多毛。例如，以下布尔表达式相当难以理解。
</p>

  <pre class="prettyprint source"> !logger.startsWith("org.apache.http")
  ||
  ( logger.equals("org.apache.http.wire")  &amp;&amp;
       (mdc != null &amp;&amp; mdc.get("entity") != null
         &amp;&amp;
       ((String) mdc.get("entity")).contains("someSpecialValue"))
       &amp;&amp;
     !message.contains("someSecret")
  )</pre>

  <p>而等效的Java块则相当容易遵循。</p>

<pre class="prettyprint source">if(logger.startsWith("org.apache.http"))
  return true;

if(mdc == null || mdc.get("entity") == null)
  return false;

String payee = (String) mdc.get("entity");

if(logger.equals("org.apache.http.wire") &amp;&amp;
  payee.contains("someSpecialValue") &amp;&amp;
  !message.contains("someSecret")) {
  return true;
}

return false;</pre>

   <p>
   </p>

     <!-- ============================================================= -->
   <h3 class="doAnchor" name="param">的<param>不推荐使用element，而采用更直接的语法。
   </h3>


   <p class="red bold">而不是写（不推荐）</p>  
   
   <pre class="prettyprint source">
    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
      &lt;encoder>
        &lt;<b>param name="pattern" value="%logger- %msg %n"/&gt;</b>
      &lt;/encoder>
    &lt;/appender>
   </pre>

   <p class="green bold">偏爱直接形式（良好）</p><pre class="prettyprint source">
    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
      &lt;encoder>
        <b>&lt;pattern>%logger - %msg %n&lt;/pattern></b>
      &lt;/encoder>
    &lt;/appender>
   </pre>

   <!-- ============================================================= -->
   <h3 class="doAnchor" name="missingRightParenthesis">在转换模式中，必须关闭打开的括号。
   </h3>
   
   <p>在转换模式中， <a href="manual/layouts.html#Parentheses">括号是特殊的，</a>因为它们被视为分组标记。如果需要将括号字符视为文字，则需要在每个括号前面加反斜杠来转义该字符。就像<b>\（</b> ％d {HH：mm：ss。SSS} [％thread] <b>\）</b> 。
   </p>
  

   <!-- ============================================================= -->
   <h3 class="doAnchor" name="appender_order">必须先定义添加者，然后才能对其进行引用。
   </h3>
   
   <p>在配置文件中，按名称引用附加器时，必须在配置文件中更早定义它。不允许引用文件中稍后定义的追加程序。以下是定义和参考的正确和不正确顺序的示例。
   </p>


  <p>下面是正确排序的示例，其中追加程序定义在对其的引用之前。
  </p>

  <p class="green bold">正确的顺序</p>
  <pre class="prettyprint source">&lt;configuration>
  <b>&lt;!-- definition of appender STDOUT --></b>
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>

  &lt;root level="DEBUG">
    &lt;!-- appender referenced after it is defined -->
    <b class="big">&lt;appender-ref ref="STDOUT"/></b>
  &lt;/root> 
&lt;/configuration></pre>

  <p>下面是不正确排序的示例，其中追加程序定义遵循对它的引用。
  </p>

   <p class="red bold">订单不正确</p>
   <pre class="prettyprint source">&lt;configuration>
  &lt;root level="DEBUG">
    &lt;!-- appender INCORRECTLY referenced before it is defined -->
    <b class="big">&lt;appender-ref ref="STDOUT"/></b>
  &lt;/root>

  <b>&lt;!-- definition of appender STDOUT --></b>
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    &lt;encoder>
      &lt;pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n&lt;/pattern>
    &lt;/encoder>
  &lt;/appender>
&lt;/configuration>
   </pre>

 
  <script src="templates/footer.js" type="text/javascript"></script>
  </div>


</body></html>