<html  xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
    <title>首选登录的原因</title>
    <link rel="stylesheet" type="text/css" href="css/common.css">
    <link rel="stylesheet" type="text/css" href="css/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/_print.css" media="print">

  </head>
  <body  onload="decorate();">
    <script type="text/javascript">prefix='';</script>
    <script src="templates/header.js" type="text/javascript"></script>
    <script type="text/javascript" src="js/jquery-min.js"></script>
    <script type="text/javascript" src="js/decorator.js"></script>
    <div id="left">
      <noscript>请打开Javascript查看此菜单</noscript>
      <script src="templates/left.js" type="text/javascript"></script>
    </div>
    <div id="right">
      <script src="templates/right.js" type="text/javascript"></script>
    </div>

    <div id="content">
		
		<h2>与log4j相比更喜欢登录的原因</h2>

    <p>与大大小小的log4j相比，logback带来了很多改进。他们太多了，无法详尽列举。但是，这是从log4j切换到logback的原因的详尽列表。请记住，由于两个项目都是由同一开发人员创建的，因此logback在概念上与log4j非常相似。如果您已经熟悉log4j，则可以使用logback迅速感到宾至如归。如果您喜欢log4j，则可能会喜欢logback。</p>


    <h3 class="doAnchor" name="fasterImpl">更快的实施</h3>

    <p>根据我们之前在log4j上所做的工作，已重写了logback内部，使其在某些关键执行路径上的执行速度提高了大约十倍。Logback组件不仅速度更快，而且内存占用也较小。</p>

    <h3 class="doAnchor" name="tdd">大量的测试</h3>

    <p>Logback附带了一系列非常广泛的测试，这些测试是经过数年的历时和不计其数的工作量开发而成的。同时还测试了log4j时，logback使测试达到了完全不同的水平。我们认为，这是与log4j相比更喜欢登录的唯一最重要的原因。您希望您的日志记录框架即使在不利条件下也能坚如磐石且可靠。
    </p>
    
    <h3 class="doAnchor" name="slf4j">经典的logback会本地讲SLF4J</h3>

    <p>自从<code>Logger</code> logback-classic中的class本地实现SLF4J API，在调用以logback-classic作为基础实现的SLF4J记录器时，您将产生零开销。此外，由于logback-classic强烈建议使用SLF4J作为其客户端API，因此，如果需要切换到log4j或jul，可以通过将一个jar文件替换为另一个jar文件来实现。您无需通过SLF4J API来触摸代码记录。这可以大大减少切换日志记录框架所涉及的工作。
    </p>
    
    <h3 class="doAnchor" name="docs">广泛的文档</h3>
    
    <p>Logback随附了详细且不断更新的文档。</p>

    <h3 class="doAnchor" name="DSL">XML或Groovy中的配置文件</h3>

    <p>配置回发的传统方式是通过XML文件。文档中的大多数示例都使用此XML语法。但是，从0.9.22版本的注销版本开始，还支持<a href="manual/groovy.html">以Groovy编写的配置文件</a> 。与XML相比，Groovy风格的配置更直观，更一致且语法更短。
    </p>

    <p>还有一个<a href="http://logback.qos.ch/translator/asGroovy.html">工具可以自动将logback.xml文件迁移到logback.groovy</a> 。
    </p>

    <h3 class="doAnchor" name="autoScan">自动重载配置文件</h3>

    <p>Logback-classic可以<a href="manual/configuration.html#autoScan">在修改后自动重新加载其配置文件</a> 。扫描过程快速，无争用，并且动态扩展到每秒数百个线程，遍及数百个线程。它还可以播放中的应用服务器以及更一般地内的JEE环境，它<em>不</em>涉及扫描一个单独的线程的创建。
   </p>

    <h3 class="doAnchor" name="grace">从I / O故障中恢复正常</h3>

    <p>Logback的<code>FileAppender</code>及其所有子类，包括<code>RollingFileAppender</code> ，可以从I / O故障中正常恢复。因此，如果文件服务器暂时出现故障，则不再需要重新启动应用程序即可使日志再次工作。一旦文件服务器恢复正常，相关的logback附加程序将透明且快速地从先前的错误情况中恢复。
    </p>
    
    <h3 class="doAnchor" name="maxHistory">自动删除旧的日志档案</h3>

    <p>通过设置<a href="manual/appenders.html#TimeBasedRollingPolicy">TimeBasedRollingPolicy</a>或<a href="manual/appenders.html#SizeAndTimeBasedFNATP">SizeAndTimeBasedFNATP</a>的<span class="option">maxHistory</span>属性，可以控制已存档文件的最大数量。如果您的滚动策略要求每月进行一次滚动，并且希望保留一年的日志价值，只需将<span class="option">maxHistory</span>属性设置为12。超过12个月的归档日志文件将被自动删除。
    </p>

    <h3 class="doAnchor" name="compression">自动压缩存档的日志文件</h3>

    <p><a href="manual/appenders.html#RollingFileAppender">RollingFileAppender</a>可以在过渡期间自动压缩存档的日志文件。压缩总是异步发生的，因此即使对于大型日志文件，在压缩期间也不会阻止您的应用程序。
    </p>

    <h3 class="doAnchor" name="prudent">谨慎模式</h3>

    <p>在<a href="manual/appenders.html#prudent">审慎模式下</a> <code>FileAppender</code>在多个JVM上运行的实例可以安全地写入同一日志文件。在某些限制下，谨慎模式扩展到<code>RollingFileAppender</code> 。
    </p>

    <h3 class="doAnchor" name="lilith">莉莉丝</h3>

    <p><a href="http://lilith.huxhorn.de/">Lilith</a>是用于登录的日志记录和访问事件查看器。它与log4j的电锯相当，不同之处在于Lilith旨在处理大量的日志数据而不会退缩。</p>
  
    <h3 class="doAnchor" name="conditional">有条件地处理配置文件</h3>

    <p>开发人员经常需要在针对不同环境（例如开发，测试和生产）的多个logback配置文件之间进行切换。这些配置文件有很多共同点，仅在几个地方有所不同。为避免重复，logback支持在以下<a href="manual/configuration.html#conditional">条件</a>的帮助<a href="manual/configuration.html#conditional">下对配置文件</a>进行<a href="manual/configuration.html#conditional">有条件的处理</a> ： <code><if></code> ， <code><then></code>和<code><else></code>元素，以便单个配置文件可以适当地针对多个环境。
    </p>


    <h3 class="doAnchor" name="filters">筛选器</h3>

    <p>Logback具有多种<a href="manual/filters.html">过滤功能</a> ，远远超出了log4j所提供的功能。例如，假设您在生产服务器上部署了关键业务应用程序。考虑到已处理的大量事务，将日志记录级别设置为WARN，以便仅记录警告和错误。现在想象一下，您遇到了一个可以在生产系统上重现的错误，但是由于这两个环境（生产/测试）之间的未指定差异，在测试平台上仍然难以捉摸。
    </p>

    <p>使用log4j时，您唯一的选择是将生产系统上的日志记录级别降低到DEBUG，以尝试识别问题。不幸的是，这将生成大量的日志数据，使分析变得困难。更重要的是，广泛的日志记录可能会影响应用程序在生产系统上的性能。</p>

    <p>使用logback，您可以选择将所有用户的日志记录保持在WARN级别，只有一个用户（负责识别问题的用户）说。登录Alice后，她将以DEBUG级别登录，而其他用户可以继续以WARN级别登录。可以通过在配置文件中添加4行XML来完成此任务。搜索<code>MDCFilter</code>在手册的<a href="manual/filters.html#TurboFilter">相关章节</a>中。
    </p>
    

    <h3 class="doAnchor" name="sift">SiftingAppender</h3>
    
    <p><a href="manual/appenders.html#SiftingAppender">SiftingAppender</a>是一款功能强大的附加器。它可用于根据<b>任何</b>给定的运行时属性来分离（或筛选）日志记录。例如， <code>SiftingAppender</code>可以根据用户会话将日志事件分开，以便每个用户生成的日志进入不同的日志文件，每个用户一个日志文件。
    </p>
    
    <h3 class="doAnchor" name="packagingData">带有包装数据的堆栈跟踪</h3>

    <p>当logback打印异常时，堆栈跟踪将包括打包数据。这是由<a href="demo.html">logback-demo</a> Web应用程序生成的示例堆栈跟踪。</p>

    <pre>14:28:48.835 [btpool0-7] INFO  c.q.l.demo.prime.PrimeAction - 99 is not a valid value
java.lang.Exception: 99 is invalid
  at ch.qos.logback.demo.prime.PrimeAction.execute(PrimeAction.java:28) [classes/:na]
  at org.apache.struts.action.RequestProcessor.processActionPerform(RequestProcessor.java:431) [struts-1.2.9.jar:1.2.9]
  at org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:236) [struts-1.2.9.jar:1.2.9]
  at org.apache.struts.action.ActionServlet.doPost(ActionServlet.java:432) [struts-1.2.9.jar:1.2.9]
  at javax.servlet.http.HttpServlet.service(HttpServlet.java:820) [servlet-api-2.5-6.1.12.jar:6.1.12]
  at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:502) [jetty-6.1.12.jar:6.1.12]
  at ch.qos.logback.demo.UserServletFilter.doFilter(UserServletFilter.java:44) [classes/:na]
  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1115) [jetty-6.1.12.jar:6.1.12]
  at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:361) [jetty-6.1.12.jar:6.1.12]
  at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:417) [jetty-6.1.12.jar:6.1.12]
  at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230) [jetty-6.1.12.jar:6.1.12]</pre>

    <p>从上面可以看出，该应用程序正在使用Struts版本1.2.9，并已在码头版本6.1.12下部署。因此，堆栈跟踪将迅速告知读者有关干预异常的类以及它们所属的软件包和软件包版本的信息。当您的客户向您发送堆栈跟踪时，作为开发人员，您将不再需要让他们向您发送有关他们正在使用的软件包版本的信息。该信息将成为堆栈跟踪的一部分。有关详细信息，请参见<a href="manual/layouts.html#xThrowable">“％xThrowable”转换词</a> 。
    </p>

    <p>对于某些用户错误地认为此<a href="http://www.jetbrains.net/devnet/message/5259058">功能是其IDE</a>的<a href="http://www.jetbrains.net/devnet/message/5259058">功能而言，</a>此功能可能非常有用。</p>

    <h3 class="doAnchor" name="logbackAccess">Logback访问，即具有大脑的HTTP访问日志记录，是Logback不可或缺的一部分</h3>

    <p>最后但并非最不重要的一点是，logback-access模块是logback发行版的一部分，它与Servlet容器（如Jetty或Tomcat）集成在一起，以提供丰富而强大的HTTP-access日志功能。由于logback-access是初始设计的一部分，因此您喜欢的所有logback-classic功能也可以在logback-access中使用。</p>

    <h3 class="doAnchor" name="inSummary">综上所述</h3>

    <p>我们列出了一些优先选择log4j而不是log4j的原因。简而言之，鉴于logback建立在我们先前对log4j的工作的基础上，logback只是更好的log4j。</p>

    <script src="templates/footer.js" type="text/javascript"></script>	   
    </div>

  

</body></html>