<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>ZooKeeper:因为协调分布式系统是动物园</title>
    <link type="text/css" href="skin/basic.css" rel="stylesheet">
    <link type="text/css" href="skin/screen.css" rel="stylesheet" media="screen">
    <link type="text/css" href="skin/print.css" rel="stylesheet" media="print">
    <link type="text/css" href="skin/profile.css" rel="stylesheet">
    <script src="skin/getBlank.js" type="text/javascript" language="javascript"></script>
    <script src="skin/getMenu.js" type="text/javascript" language="javascript"></script>
    <script src="skin/init.js" type="text/javascript" language="javascript"></script>
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body dir="ltr" onload="init();">
<div id="top">
    <div class="breadtrail">
        <a href="http://www.apache.org/">Apache</a> &gt; <a href="http://zookeeper.apache.org/">ZooKeeper</a>
    </div>
    <div class="header">
        <div class="grouplogo">
            <a href="http://hadoop.apache.org/"><img class="logoImage" alt="Hadoop" src="images/hadoop-logo.jpg" title="Apache Hadoop"></a>
        </div>
        <div class="projectlogo">
            <a href="http://zookeeper.apache.org/"><img class="logoImage" alt="ZooKeeper" src="images/zookeeper_small.gif" title="ZooKeeper:分布式协调"></a>
        </div>
        <div class="searchbox">
            <form action="http://www.google.com/search" method="get">
                <input value="zookeeper.apache.org" name="sitesearch" type="hidden"><input onFocus="getBlank (this, 'Search the site with google');" size="25" name="q" id="query" type="text" value="Search the site with google">&nbsp;
                <input name="Search" value="搜索" type="submit">
            </form>
        </div>
        <ul id="tabs">
            <li>
                <a class="unselected" href="http://zookeeper.apache.org/">项目</a>
            </li>
            <li>
                <a class="unselected" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/">维基</a>
            </li>
            <li class="current">
                <a class="selected" href="index.html">ZooKeeper 3.5文档</a>
            </li>
        </ul>
    </div>
</div>
<div id="main">
    <div id="publishedStrip">
        <div id="level2tabs"></div>
        <script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
    </div>
    <div class="breadtrail">
         
    </div>
    <div id="menu">
        <div onclick="SwitchMenu('menu_1', 'skin/')" id="menu_1Title" class="menutitle">Overview</div>
        <div id="menu_1" class="menuitemgroup">
            <div class="menuitem">
                <a href="index.html">欢迎</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperOver.html">概观</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperStarted.html">入门</a>
            </div>
            <div class="menuitem">
                <a href="releasenotes.html">发行说明</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_2', 'skin/')" id="menu_2Title" class="menutitle">Developer</div>
        <div id="menu_2" class="menuitemgroup">
            <div class="menuitem">
                <a href="api/index.html">API文档</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperProgrammers.html">程序员指南</a>
            </div>
            <div class="menuitem">
                <a href="javaExample.html">Java示例</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperTutorial.html">障碍和队列教程</a>
            </div>
            <div class="menuitem">
                <a href="recipes.html">食谱</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_3', 'skin/')" id="menu_3Title" class="menutitle">Admin &amp; Ops</div>
        <div id="menu_3" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperAdmin.html">管理员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperQuotas.html">配额指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperJMX.html">JMX</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperObservers.html">观察员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperReconfig.html">动态重新配置</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_4', 'skin/')" id="menu_4Title" class="menutitle">Contributor</div>
        <div id="menu_4" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperInternals.html">ZooKeeper Internals</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_5', 'skin/')" id="menu_5Title" class="menutitle">Miscellaneous</div>
        <div id="menu_5" class="menuitemgroup">
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER">维基</a>
            </div>
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ">常问问题</a>
            </div>
            <div class="menuitem">
                <a href="http://zookeeper.apache.org/mailing_lists.html">邮件列表</a>
            </div>
        </div>
    </div>
    <div id="content">
<!--
Copyright 2002-2004 The Apache Software Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
//--><h1>ZooKeeper食谱和解决方案</h1>
<ul>
  <li><a href="#ch_recipes">使用ZooKeeper创建更高级别构造的指南</a>
  <ul>
    <li><a href="#sc_recipes_errorHandlingNote">关于错误处理的重要说明</a></li>
    <li><a href="#sc_outOfTheBox">开箱即用的应用程序:名称服务,配置,组成员身份</a></li>
    <li><a href="#sc_recipes_eventHandles">障碍</a>
    <ul>
      <li><a href="#sc_doubleBarriers">双重障碍</a></li>
    </ul></li>
    <li><a href="#sc_recipes_Queues">队列</a>
    <ul>
      <li><a href="#sc_recipes_priorityQueues">优先级队列</a></li>
    </ul></li>
    <li><a href="#sc_recipes_Locks">锁</a>
    <ul>
      <li><a href="#sc_recipes_GuidNote">可恢复的错误和GUID</a></li>
      <li><a href="#Shared+Locks">共享锁</a></li>
      <li><a href="#sc_revocableSharedLocks">可撤销共享锁</a></li>
    </ul></li>
    <li><a href="#sc_recipes_twoPhasedCommit">两阶段提交</a></li>
    <li><a href="#sc_leaderElection">领导人选举</a></li>
  </ul></li>
</ul><p><a name="ch_recipes"></a></p><h2>使用ZooKeeper创建更高级别构造的指南</h2><p>在本文中,您将找到使用ZooKeeper实现更高阶函数的指南。所有这些都是在客户端实现的约定,不需要ZooKeeper的特殊支持。社区将在客户端库中捕获这些约定,以便于使用并鼓励标准化。</p><p>ZooKeeper最有趣的一点是,即使ZooKeeper使用<em>异步</em>通知,您也可以使用它来构建<em>同步</em>一致性原语,例如队列和锁。正如您将看到的,这是可能的,因为ZooKeeper对更新施加了整体顺序,并且具有公开此排序的机制。</p><p>请注意,下面的配方尝试采用最佳实践。特别是,它们避免了轮询,计时器或其他任何会导致"群体效应"的行为,从而导致突发流量和限制可扩展性。</p><p>这里有许多可以想象的有用功能 - 可撤销的读写优先级锁,仅作为一个例子。这里提到的一些结构 - 特别是锁定 - 说明了某些点,即使你可能发现其他结构,例如事件句柄或队列,是执行相同功能的更实用的方法。一般而言,本节中的示例旨在激发思考。</p><p><a name="sc_recipes_errorHandlingNote"></a></p><h3>关于错误处理的重要说明</h3><p>实施配方时,您必须处理可恢复的异常(请参阅<a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ">常见问题解答</a> )。特别是,一些配方采用顺序临时节点。创建顺序临时节点时,存在一个错误情况,其中create()在服务器上成功但服务器在将节点名称返回给客户端之前崩溃。当客户端重新连接其会话时仍然有效,因此不会删除该节点。这意味着客户端很难知道其节点是否已创建。下面的食谱包括处理这个问题的措施。</p><p><a name="sc_outOfTheBox"></a></p><h3>开箱即用的应用程序:名称服务,配置,组成员身份</h3><p>名称服务和配置是ZooKeeper的两个主要应用程序。这两个函数由ZooKeeper API直接提供。</p><p>ZooKeeper直接提供的另一个功能是<em>组成员身份</em> 。该组由节点表示。该组的成员在组节点下创建临时节点。当ZooKeeper检测到故障时,将自动删除异常失败的成员节点。</p><p><a name="sc_recipes_eventHandles"></a></p><h3>障碍</h3><p>分布式系统使用<em>障碍</em>来阻止一组节点的处理,直到满足条件,此时允许所有节点继续进行。通过指定屏障节点在ZooKeeper中实现障碍。如果屏障节点存在,则屏障就位。这是伪代码:</p>
<ol>
  <li>客户端在屏障节点上调用ZooKeeper API的<strong>exists()</strong>函数,并将<em>watch</em>设置为true。</li>
  <li>如果<strong>exists()</strong>返回false,则屏障消失,客户端继续</li>
  <li>否则,如果<strong>exists()</strong>返回true,则客户端等待来自ZooKeeper的监视节点的监视事件。</li>
  <li>当触发监视事件时,客户端重新发出<strong>exists()</strong>调用,再次等待,直到删除屏障节点。</li>
</ol><p><a name="sc_doubleBarriers"></a></p><h4>双重障碍</h4><p>双障碍使客户端能够同步计算的开始和结束。当足够的进程加入屏障时,进程开始计算并在完成后离开屏障。此配方显示如何使用ZooKeeper节点作为屏障。</p><p>此配方中的伪代码将屏障节点表示为<em>b</em> 。每个客户端进程<em>p</em>在进入时向barrier节点注册,并在准备离开时取消注册。节点通过下面的<strong>Enter</strong>过程向barrier节点注册,它等待<em>x</em> client客户端进程注册,然后再继续计算。(这里的<em>x</em>取决于您确定您的系统。)</p>
<table>
  <thead>
    <tr>
      <th><strong>输入</strong> </th>
      <th><strong>离开</strong> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1。创建名称<strong>n_ = <em>b</em>+“/”+_p</strong> </td>
      <td>1。<strong>L = getChildren(b,false)</strong> </td>
    </tr>
    <tr>
      <td>2。设置监视: <strong>exists(_b_ + ‘‘/ready’’, true)</strong> </td>
      <td>2.如果没有孩子,退出</td>
    </tr>
    <tr>
      <td>3。创建子: <strong>create(_n_,EPHEMERAL)</strong> </td>
      <td>3.如果<em>p</em>只是L中的进程节点,则删除(n)并退出</td>
    </tr>
    <tr>
      <td>4。<strong>L = getChildren(b,false)</strong> </td>
      <td>4.如果<em>p</em>是L中的最低进程节点,则等待L中的最高进程节点</td>
    </tr>
    <tr>
      <td>5.如果L than_x_中的孩子较少,则等待观看事件</td>
      <td>5.否则<strong>delete(_n_)</strong>如果仍然存在并等待L中的最低进程节点</td>
    </tr>
    <tr>
      <td>6. else <strong>create(b +''/ ready'',REGULAR)</strong> </td>
      <td>6.转到1</td>
    </tr>
  </tbody>
</table><p>在进入时,所有进程都在就绪节点上进行监视,并创建一个临时节点作为屏障节点的子节点。每个进程但最后一个进入屏障并等待就绪节点出现在第5行。创建第x个节点(最后一个进程)的进程将在子列表中看到x个节点,并创建就绪节点,唤醒其他进程。请注意,等待进程仅在退出时才会唤醒,因此等待是有效的。</p><p>退出时,您不能使用诸如<em>ready之类</em>的标志,因为您正在监视进程节点是否消失。通过使用临时节点,在输入屏障后失败的进程不会阻止正确的进程完成。当进程准备离开时,他们需要删除其进程节点并等待所有其他进程执行相同操作。</p><p>当没有剩余进程节点作为<em>b的</em>子节点时,进程退出。但是,作为效率,您可以使用最低的进程节点作为就绪标志。准备退出的所有其他进程监视最低的现有进程节点将消失,并且最低进程的所有者监视任何其他进程节点(为简单起见选择最高)以消失。这意味着除了最后一个节点之外,每个节点删除时只会唤醒一个进程,这会删除所有节点。</p><p><a name="sc_recipes_Queues"></a></p><h3>队列</h3><p>分布式队列是一种常见的数据结构。要在ZooKeeper中实现分布式队列,首先要指定一个znode来保存队列,即队列节点。分布式客户端通过调用带有以"queue-"结尾的路径名的create()将一些内容放入队列,并将create()调用中的<em>序列</em>和<em>临时</em>标志设置为true。因为设置了<em>序列</em>标志,所以新路径名将具有<em>路径到队列节点</em> /队列X的形式,其中X是单调递增的数字。想要从队列中删除的客户端调用ZooKeeper的<strong>getChildren()</strong>函数,并在队列节点上将<em>watch</em>设置为true,并开始处理编号最小的节点。客户端不需要发出另一个<strong>getChildren(),</strong>直到它耗尽从第一个<strong>getChildren()</strong>调用获得的列表。如果队列节点中没有子节点,则阅读器会等待观察通知再次检查队列。</p><h6>注意</h6>
<blockquote><p>现在在ZooKeeper食谱目录中存在一个Queue实现。这与发布工件的release-zookeeper-recipes / zookeeper-recipes-queue目录一起分发。</p>
</blockquote><p><a name="sc_recipes_priorityQueues"></a></p><h4>优先级队列</h4><p>要实现优先级队列,只需对通用<a href="#sc_recipes_Queues">队列配方</a>进行两次简单更改。首先,要添加到队列,路径名以"queue-YY"结尾,其中YY是元素的优先级,较低的数字表示较高的优先级(就像UNIX一样)。其次,当从队列中删除时,客户端使用最新的子列表,这意味着如果针对队列节点触发监视通知,则客户端将使先前获得的子列表无效。</p><p><a name="sc_recipes_Locks"></a></p><h3>锁</h3><p>完全分布式锁,全局同步,意味着在任何快照时,没有两个客户端认为它们拥有相同的锁。这些可以使用ZooKeeeper实现。与优先级队列一样,首先定义一个锁定节点。</p><h6>注意</h6>
<blockquote><p>现在在ZooKeeper食谱目录中存在一个Lock实现。这与发布工件的release-zookeeper-recipes / zookeeper-recipes-lock目录一起分发。</p>
</blockquote><p>希望获得锁定的客户执行以下操作:</p>
<ol>
  <li>使用路径名 "_locknode_/guid-lock-" 调用<strong>create()</strong> ,并设置<em>序列</em>和<em>短暂</em>标志。如果错过了create()结果,则需要<em>guid</em> 。请参阅下面的注释。</li>
  <li>在锁定节点上调用<strong>getChildren()</strong> <em>而不</em>设置监视标志(这对于避免群体效应很重要)。</li>
  <li>如果在步骤<strong>1中</strong>创建的路径名具有最低序列号后缀,则客户端具有锁,并且客户端退出协议。</li>
  <li>客户端调用<strong>exists()</strong> ,并在lock目录中的路径上设置watch标志,并使用下一个最低序列号。</li>
  <li>如果<strong>exists()</strong>返回null,请转到步骤<strong>2</strong> 。否则,在转到步骤<strong>2</strong>之前,请等待上一步中路径名的通知。</li>
</ol><p>解锁协议非常简单:希望释放锁的客户端只删除他们在步骤1中创建的节点。</p><p>以下是一些需要注意的事项:</p>
<ul>
  <li><p>删除节点只会导致一个客户端被唤醒,因为每个节点都被一个客户端监视。通过这种方式,您可以避免群体效应。</p></li>
  <li><p>没有民意调查或超时。</p></li>
  <li><p>由于您实现锁定的方式,很容易看到锁争用,中断锁,调试锁定问题等的数量。</p></li>
</ul><p><a name="sc_recipes_GuidNote"></a></p><h4>可恢复的错误和GUID</h4>
<ul>
  <li>如果调用<strong>create()</strong>时发生可恢复的错误,则客户端应调用<strong>getChildren()</strong>并检查包含路径名中使用的<em>guid</em>的节点。这将处理服务器上成功的create()的情况( <a href="#sc_recipes_errorHandlingNote">如上所述</a> ),但服务器在返回新节点的名称之前崩溃。</li>
</ul><p><a name="Shared+Locks"></a></p><h4>共享锁</h4><p>您可以通过对锁协议进行一些更改来实现共享锁:</p>
<table>
  <thead>
    <tr>
      <th><strong>获取读锁定:</strong> </th>
      <th><strong>获取写锁:</strong> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1。调用<strong>create( )</strong>以创建路径名为"* guid- / read- *"的节点。这是稍后在协议中使用的锁节点。确保设置<em>序列</em>和<em>短暂</em>标志。</td>
      <td>1。调用<strong>create( )</strong>以创建路径名为"* guid- / write- *"的节点。这是协议中稍后提到的锁定节点。确保设置<em>序列</em>和<em>短暂</em>标志。</td>
    </tr>
    <tr>
      <td>2。在锁定节点上调用<strong>getChildren()</strong> <em>而不</em>设置<em>监视</em>标志 - 这很重要,因为它避免了群体效应。</td>
      <td>2。在锁定节点上调用<strong>getChildren()</strong> <em>而不</em>设置<em>监视</em>标志 - 这很重要,因为它避免了群体效应。</td>
    </tr>
    <tr>
      <td>3。如果没有子路径名以"* write- *"开头并且序列号低于步骤<strong>1中</strong>创建的节点,则客户端具有锁定并可以退出协议。</td>
      <td>3。如果没有序列号低于步骤<strong>1中</strong>创建的节点的子节点,则客户端具有锁定,客户端退出协议。</td>
    </tr>
    <tr>
      <td>4。否则,使用<em>watch</em>标志调用<strong>exists()</strong> ,在lock目录中的节点上设置,路径名以"* write- *"开头,具有下一个最低序列号。</td>
      <td>4。在具有下一个最低序列号的路径名的节点上调用<strong>exists(),</strong>并设置<em>监视</em>标志。</td>
    </tr>
    <tr>
      <td>5。如果<strong>exists( )</strong>返回<em>false</em> ,请转到步骤<strong>2</strong> 。</td>
      <td>5。如果<strong>exists( )</strong>返回<em>false</em> ,请转到步骤<strong>2</strong> 。否则,在转到步骤<strong>2</strong>之前,请等待上一步中路径名的通知。</td>
    </tr>
    <tr>
      <td>6。否则,在转到步骤<strong>2</strong>之前,请等待上一步中路径名的通知 </td>
      <td> </td>
    </tr>
  </tbody>
</table><p>笔记:</p>
<ul>
  <li><p>看起来这个配方会产生一个群体效应:当有一大群客户端等待读锁定时,当删除序列号最小的"* write- *"节点时,所有客户端都会或多或少地同时得到通知。事实上。这是有效的行为:所有那些等待读者客户端应该被释放,因为他们有锁。群体效应是指释放"群体",实际上只有一个或少数机器可以继续。</p></li>
  <li><p>有关如何在节点中使用guid的信息,请参阅<a href="#sc_recipes_GuidNote">锁定</a>说明。</p></li>
</ul><p><a name="sc_revocableSharedLocks"></a></p><h4>可撤销共享锁</h4><p>通过对共享锁协议的微小修改,您可以通过修改共享锁协议来使共享锁可撤销:</p><p>在步骤<strong>1中</strong> ,获取读取器和写入器锁定协议,在调用<strong>create()</strong>之后立即调用带有<em>监视</em>集的<strong>getData</strong> <strong>()</strong> 。如果客户端随后接收到它在步骤<strong>1中</strong>创建的节点的通知,则它在该节点上执行另一个<strong>getData()</strong> ,并设置<em>监视</em>并查找字符串"unlock",该字符串向客户端发出必须释放锁定的信号。这是因为,根据此共享锁协议,您可以通过在锁节点上调用<strong>setData()</strong>来向锁定放置锁的客户端请求,将"unlock"写入该节点。</p><p>请注意,此协议要求锁定持有者同意释放锁定。这种同意很重要,特别是如果锁具持有者在释放锁之前需要进行一些处理。当然,您可以通过在您的协议中规定,如果在一段时间后锁定器没有删除锁定,则允许撤销者删除锁定节点,您可以始终<em>使用Freaking Laser Beams</em>实现<em>Revocable Shared Locks</em> 。</p><p><a name="sc_recipes_twoPhasedCommit"></a></p><h3>两阶段提交</h3><p>两阶段提交协议是一种算法,它允许分布式系统中的所有客户端同意提交事务或中止。</p><p>在ZooKeeper中,您可以通过让协调器创建一个事务节点(例如"/ app / Tx")和每个参与站点的一个子节点(例如"/ app / Tx / s_i")来实现两阶段提交。当协调器创建子节点时,它会使内容未定义。一旦参与事务的每个站点从协调器接收到该事务,该站点就会读取每个子节点并设置一个监视。然后,每个站点处理查询并通过写入其相应节点来投票"提交"或"中止"。一旦写入完成,其他站点将得到通知,并且一旦所有站点都获得所有投票,他们就可以决定"中止"或"提交"。请注意,如果某个站点投票"中止",节点可以更早地决定"中止"。</p><p>此实现的一个有趣方面是协调器的唯一作用是决定站点组,创建ZooKeeper节点,以及将事务传播到相应的站点。实际上,即使传播事务也可以通过ZooKeeper在事务节点中写入来完成。</p><p>上述方法存在两个重要缺点。一个是消息复杂性,即O(n²)。第二个是通过临时节点检测站点故障的不可能性。要使用临时节点检测站点的故障,站点必须创建节点。</p><p>要解决第一个问题,您只能通知协调器有关事务节点的更改,然后在协调器做出决策后通知站点。请注意,这种方法是可扩展的,但它也较慢,因为它需要所有通信都通过协调器。</p><p>要解决第二个问题,您可以让协调器将事务传播到站点,并让每个站点创建自己的临时节点。</p><p><a name="sc_leaderElection"></a></p><h3>领导人选举</h3><p>使用ZooKeeper进行领导者选举的一种简单方法是在创建表示客户端"提议"的znode时使用<strong>SEQUENCE |</strong> EPHEMERAL标志。这个想法是有一个znode,比如"/ election",这样每个znode创建一个带有两个标志SEQUENCE | EPHEMERAL的子znode"/ election / guid-n_"。使用序列标志,ZooKeeper会自动附加一个序列号,该序列号大于先前附加到"/ election"子节点的序列号。创建具有最小附加序列号的znode的过程是领导者。</p><p>但这并不是全部。重要的是要注意领导者的失败,以便在当前领导者失败的情况下,新的领导者成为新的领导者。一个简单的解决方案是让所有应用程序进程监视当前最小的znode,并在最小的znode消失时检查它们是否是新的领导者(请注意,如果领导者因为节点是短暂的而失败,则最小的znode将消失)。但是这会导致群体效应:当前领导者失败时,所有其他进程都会收到通知,并在"/选举"中执行getChildren以获取"/选举"子项的当前列表。如果客户端数量很大,则会导致ZooKeeper服务器必须处理的操作数量激增。为了避免群体效应,在znode序列上观察下一个znode就足够了。如果客户端收到它正在观看的znode消失的通知,那么在没有更小的znode的情况下它成为新的领导者。请注意,这可以通过不让所有客户端观看相同的znode来避免群体效应。</p><p>这是伪代码:</p><p>让ELECTION成为应用程序的选择路径。志愿成为领导者:</p>
<ol>
  <li>使用带有SEQUENCE和EPHEMERAL标志的路径"ELECTION/guid-n_"创建znode z;</li>
  <li>设C为 "ELECTION" 的子项, i 是z的序号;</li>
  <li>注意 "ELECTION/guid-n_j" 的变化,其中j是最大的序列号,使得j &lt;i和n_j是C中的znode;</li>
</ol><p>收到znode删除通知后:</p>
<ol>
  <li>让C成为ELECTION的新子集;</li>
  <li>如果z是C中的最小节点,则执行leader过程;</li>
  <li>否则,请注意 "ELECTION/guid-n_j" 的更改,其中j是最大的序列号,使得j &lt;i和n_j是C中的znode;</li>
</ol><p>笔记:</p>
<ul>
  <li><p>请注意,子节点列表中没有前面的znode的znode并不意味着此znode的创建者知道它是当前的领导者。应用程序可能会考虑创建一个单独的znode来确认领导者已经执行了领导程序。</p></li>
  <li><p>有关如何在节点中使用guid的信息,请参阅<a href="#sc_recipes_GuidNote">锁定</a>说明。</p></li>
</ul></div>
<div class="clearboth"> </div>
</div>
<div id="footer">
    <div class="lastmodified">
        <script type="text/javascript">
        <!--
            document.write("Last Published: " + document.lastModified);
        //  -->
        </script>
    </div>
    <div class="copyright">版权所有© <a href="http://www.apache.org/licenses/">Apache Software Foundation。</a>
    </div>
    <div id="logos"></div>
</div>
</body>
</html>