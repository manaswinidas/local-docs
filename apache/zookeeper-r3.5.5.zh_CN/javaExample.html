<html dir="ltr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
    <title>ZooKeeper：因为协调分布式系统是动物园</title>
    <link type="text/css" href="skin/basic.css" rel="stylesheet"></link>
    <link type="text/css" href="skin/screen.css" rel="stylesheet" media="screen"></link>
    <link type="text/css" href="skin/print.css" rel="stylesheet" media="print"></link>
    <link type="text/css" href="skin/profile.css" rel="stylesheet"></link>
    <script src="skin/getBlank.js" type="text/javascript" language="javascript"></script>
    <script src="skin/getMenu.js" type="text/javascript" language="javascript"></script>
    <script src="skin/init.js" type="text/javascript" language="javascript"></script>
    <link rel="shortcut icon" href="images/favicon.ico"></link>
</head>
<body dir="ltr" onload="init();">
<div id="top">
    <div class="breadtrail">
        <a href="http://www.apache.org/">Apache</a> &gt; <a href="http://zookeeper.apache.org/">ZooKeeper</a>
    </div>
    <div class="header">
        <div class="grouplogo">
            <a href="http://hadoop.apache.org/"><img class="logoImage" alt="Hadoop的" src="images/hadoop-logo.jpg" title="Apache Hadoop"></a>
        </div>
        <div class="projectlogo">
            <a href="http://zookeeper.apache.org/"><img class="logoImage" alt="动物园管理员" src="images/zookeeper_small.gif" title="ZooKeeper：分布式协调"></a>
        </div>
        <div class="searchbox">
            <form action="http://www.google.com/search" method="get">
                <input value="zookeeper.apache.org" name="sitesearch" type="hidden"><input size="25" name="q" id="query" type="text" value="用谷歌搜索网站" onfocus="getBlank (this, &#39;Search the site with google&#39;);"> 
                <input name="Search" value="搜索" type="submit">
            </form>
        </div>
        <ul id="tabs">
            <li>
                <a class="unselected" href="http://zookeeper.apache.org/">项目</a>
            </li>
            <li>
                <a class="unselected" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/">维基</a>
            </li>
            <li class="current">
                <a class="selected" href="index.html">ZooKeeper 3.5文档</a>
            </li>
        </ul>
    </div>
</div>
<div id="main">
    <div id="publishedStrip">
        <div id="level2tabs"></div>
        <script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
    </div>
    <div class="breadtrail">
         
    </div>
    <div id="menu">
        <div id="menu_1Title" class="menutitle" onclick="SwitchMenu(&#39;menu_1&#39;, &#39;skin/&#39;)">概观</div>
        <div id="menu_1" class="menuitemgroup">
            <div class="menuitem">
                <a href="index.html">欢迎</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperOver.html">概观</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperStarted.html">入门</a>
            </div>
            <div class="menuitem">
                <a href="releasenotes.html">发行说明</a>
            </div>
        </div>
        <div id="menu_2Title" class="menutitle" onclick="SwitchMenu(&#39;menu_2&#39;, &#39;skin/&#39;)">开发人员</div>
        <div id="menu_2" class="menuitemgroup">
            <div class="menuitem">
                <a href="api/index.html">API文档</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperProgrammers.html">程序员指南</a>
            </div>
            <div class="menuitem">
                <a href="javaExample.html">Java示例</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperTutorial.html">障碍和队列教程</a>
            </div>
            <div class="menuitem">
                <a href="recipes.html">食谱</a>
            </div>
        </div>
        <div id="menu_3Title" class="menutitle" onclick="SwitchMenu(&#39;menu_3&#39;, &#39;skin/&#39;)">管理员和行动</div>
        <div id="menu_3" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperAdmin.html">管理员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperQuotas.html">配额指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperJMX.html">JMX</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperObservers.html">观察员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperReconfig.html">动态重新配置</a>
            </div>
        </div>
        <div id="menu_4Title" class="menutitle" onclick="SwitchMenu(&#39;menu_4&#39;, &#39;skin/&#39;)">贡献者</div>
        <div id="menu_4" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperInternals.html">ZooKeeper Internals</a>
            </div>
        </div>
        <div id="menu_5Title" class="menutitle" onclick="SwitchMenu(&#39;menu_5&#39;, &#39;skin/&#39;)">杂</div>
        <div id="menu_5" class="menuitemgroup">
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER">维基</a>
            </div>
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ">常问问题</a>
            </div>
            <div class="menuitem">
                <a href="http://zookeeper.apache.org/mailing_lists.html">邮件列表</a>
            </div>
        </div>
    </div>
    <div id="content">
<!--
Copyright 2002-2004 The Apache Software Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
//--><h1>ZooKeeper Java示例</h1>
<ul>
  <li><a href="#ch_Introduction">简单的手表客户端</a>
  <ul>
    <li><a href="#sc_requirements">要求</a></li>
    <li><a href="#sc_design">程序设计</a></li>
  </ul></li>
  <li><a href="#sc_executor">执行者类</a></li>
  <li><a href="#sc_DataMonitor">DataMonitor类</a></li>
  <li><a href="#sc_completeSourceCode">完整的源列表</a></li>
</ul><p><a name="ch_Introduction"></a></p><h2>简单的手表客户端</h2><p>为了向您介绍ZooKeeper Java API，我们在这里开发了一个非常简单的手表客户端。此ZooKeeper客户端监视ZooKeeper节点的更改并通过启动或停止程序来响应。</p><p><a name="sc_requirements"></a></p><h3>要求</h3><p>客户有四个要求：</p>
<ul>
  <li>它需要作为参数：</li>
  <li>ZooKeeper服务的地址</li>
  <li>znode的名称 - 要观看的名称</li>
  <li>要将输出写入的文件的名称</li>
  <li>带参数的可执行文件。</li>
  <li>它获取与znode关联的数据并启动可执行文件。</li>
  <li>如果znode更改，则客户端将重新获取内容并重新启动可执行文件。</li>
  <li>如果znode消失，客户端将终止可执行文件。</li>
</ul><p><a name="sc_design"></a></p><h3>程序设计</h3><p>传统上，ZooKeeper应用程序分为两个单元，一个维护连接，另一个监视数据。在此应用程序中，名为<strong>Executor</strong>的类维护ZooKeeper连接，而名为<strong>DataMonitor</strong>的类监视ZooKeeper树中的数据。此外，Executor包含主线程并包含执行逻辑。它负责与用户进行的少量交互，以及与作为参数传递的exectuable程序的交互，以及根据znode的状态，样本（根据要求）关闭并重新启动。</p><p><a name="sc_executor"></a></p><h2>执行者类</h2><p>Executor对象是示例应用程序的主要容器。它包含<strong>ZooKeeper</strong>对象<strong>DataMonitor</strong> ，如上面<a href="#sc_design">Program Program中</a>所述。</p>
<pre><code>//来自Executor类......public static void main（String [] args）{if（args.length &lt;4）{System.err .println（“USAGE：Executor hostPort znode filename program [args ...]”）; System.exit（2）; } String hostPort = args [0]; String znode = args [1]; String filename = args [2]; String exec [] = new String [args.length  -  3]; System.arraycopy（args，3，exec，0，exec.length）; try {new Executor（hostPort，znode，filename，exec）.run（）; } catch（Exception e）{e.printStackTrace（）; public Executor（String hostPort，String znode，String filename，String exec []）抛出KeeperException，IOException {this.filename = filename; this.exec = exec; zk = new ZooKeeper（hostPort，3000，this）; dm = new DataMonitor（zk，znode，null，this）; } public void run（）{try {synchronized（this）{while（！dm.dead）{wait（）; } catch（InterruptedException e）{}}</code></pre><p>回想一下，Executor的工作是启动和停止在命令行上传入其名称的可执行文件。它这是为了响应ZooKeeper对象触发的事件。正如您在上面的代码中所看到的，Executor将对自身的引用作为ZooKeeper构造函数中的Watcher参数传递。它还将对自身的引用传递给DataMonitor构造函数的DataMonitorListener参数。根据Executor的定义，它实现了这两个接口：</p>
<pre><code>公共类Executor实现了Watcher，Runnable，DataMonitor。DataMonitorListener {...
</code></pre><p><strong>Watcher</strong>接口由ZooKeeper Java API定义。 ZooKeeper使用它来回传给它的容器。它只支持一个方法， <code>process()</code> ，并且ZooKeeper使用它来传递主线程所涉及的通用事件，例如ZooKeeper连接或ZooKeeper会话的状态。此示例中的Executor只是将这些事件转发给DataMonitor，以决定如何处理它们。它这样做只是为了说明按照惯例，Executor或类似Executor的对象“拥有”ZooKeeper连接，但可以将事件委托给其他事件到其他对象。它还使用此作为触发监视事件的默认通道。（稍后会详细介绍。）</p>
<pre><code>public void process（WatchedEvent event）{dm.process（event）; }</code></pre><p>另一方面， <strong>DataMonitorListener</strong>接口不是ZooKeeper API的一部分。它是一个完全自定义的界面，专为此示例应用程序而设计。DataMonitor对象使用它与其容器进行通信，该容器也是Executor对象。DataMonitorListener接口如下所示：</p>
<pre><code>public interface DataMonitorListener {/ ** *节点的存在状态已更改。* / void exists（byte data []）; / ** * ZooKeeper会话不再有效。* * @param rc * ZooKeeper原因码* / void closing（int rc）; }</code></pre><p>此接口在DataMonitor类中定义，并在Executor类中实现。当调用<code>Executor.exists()</code> ，Executor根据需求决定是启动还是关闭。回想一下，当znode不再<em>存在</em>时，需要说杀死可执行文件。</p><p>当调用<code>Executor.closing()</code> ，Executor决定是否自动关闭以响应ZooKeeper连接永久消失。</p><p>您可能已经猜到，DataMonitor是调用这些方法的对象，以响应ZooKeeper状态的变化。</p><p>这是Executor的<code>DataMonitorListener.exists()</code>和<code>DataMonitorListener.closing</code>的实现：</p>
<pre><code>public void exists（byte [] data）{if（data == null）{if（child！）= null）{System.out.println（“杀戮过程”）; child.destroy（）; try {child.waitFor（）; } catch（InterruptedException e）{}} child = null; } else {if（孩子！= null）{System.out.println（“Stopping child”）; child.destroy（）; try {child.waitFor（）; } catch（InterruptedException e）{e.printStackTrace（）;尝试{FileOutputStream fos = new FileOutputStream（filename）; fos.write（数据）; fos.close（）; } catch（IOException e）{e.printStackTrace（）; } try {System.out.println（“Starting child”）; child = Runtime.getRuntime（）。exec（exec）; new StreamWriter（child.getInputStream（），System.out）; new StreamWriter（child.getErrorStream（），System.err）; } catch（IOException e）{e.printStackTrace（）; public void closing（int rc）{synchronized（this）{notifyAll（）; }}</code></pre><p><a name="sc_DataMonitor"></a></p><h2>DataMonitor类</h2><p>DataMonitor类具有ZooKeeper逻辑的功能。它主要是异步和事件驱动的。DataMonitor使用以下命令在构造函数中启动：</p>
<pre><code>public DataMonitor（ZooKeeper zk，String znode，Watcher chainedWatcher，DataMonitorListener listener）{this.zk = zk; this.znode = znode; this.chainedWatcher = chainedWatcher; this.listener =听众; //通过检查节点是否存在来开始。我们要完全被事件驱动</code></pre><p>对<code>ZooKeeper.exists()</code>的调用检查是否存在znode，设置监视，并将对自身（ <code>this</code> ）的引用作为完成回调对象传递。从这个意义上说，它可以解决问题，因为真正的处理是在手表被触发时发生的。</p><h6>注意</h6>
<blockquote><p>不要将完成回调与手表回调混淆。当<em>监视</em>操作的异步<em>设置</em> （由<code>ZooKeeper.exists()</code> ）在服务器上完成时，将调用<code>ZooKeeper.exists()</code>完成回调，该回调恰好是在DataMonitor对象中实现的<code>StatCallback.processResult()</code>方法。</p><p>另一方面，触发监视会向<em>Executor</em>对象发送一个事件，因为Executor注册为ZooKeeper对象的Watcher。</p><p>另外，您可能会注意到DataMonitor也可以将自己注册为此特定监视事件的观察者。这是ZooKeeper 3.0.0的新功能（多个Watchers的支持）。但是，在此示例中，DataMonitor未注册为Watcher。</p>
</blockquote><p>当<code>ZooKeeper.exists()</code>操作在服务器上完成时，ZooKeeper API会在客户端上调用此完成回调：</p>
<pre><code>public void processResult（int rc，String path，Object ctx，Stat stat）{boolean exists; switch（rc）{case Code。好的：exists = true;打破;案例代码。NoNode：exists = false;打破;案例代码。SessionExpired：案例代码。NoAuth：dead = true; listener.closing（RC）;返回; default：//重试错误zk.exists（znode，true，this，null）;返回; } byte b [] = null; if（exists）{try {b = zk.getData（znode，false，null）; } catch（KeeperException e）{//我们现在不需要担心恢复。手表//回调将启动任何异常处理e.printStackTrace（）; } catch（InterruptedException e）{return; if（（b == null＆amp;＆amp; b！= prevData）|| （b！= null＆amp;＆amp; ！Arrays.equals（prevData，b）））{listener.exists（b）; &lt;/ emphasis&gt; prevData = b; }}</code></pre><p>代码首先检查错误代码是否存在znode，致命错误和可恢复错误。如果文件（或znode）存在，它将从znode获取数据，然后在状态发生更改时调用Executor的exists（）回调。注意，它不必为getData调用执行任何异常处理，因为它有可能导致错误的任何事件的监视：如果在调用<code>ZooKeeper.getData()</code>之前删除该节点，则由<code>ZooKeeper.exists()</code>设置监视事件<code>ZooKeeper.exists()</code>触发回调;如果存在通信错误，则在连接恢复时会触发连接监视事件。</p><p>最后，请注意DataMonitor如何处理监视事件：</p>
<pre><code>public void process（WatchedEvent event）{String path = event.getPath（）; if（event.getType（）== Event。事件类型。无）{//我们被告知//连接的状态已经改变了switch（event.getState（））{case SyncConnected：//在这个特例中我们不需要做任何事情//这里 - 手表会自动重新注册//服务器，并且当客户端//断开连接时触发的任何手表将按顺序交付（按顺序）中断; case已过期：//已经死了=真; listener.closing（KeeperException。码。sessionExpired时）;打破; }} else {if（路径！= null &amp;&amp; path.equals（znode））{//节点上有些东西发生了变化，让我们找出zk.exists（znode，true，this，null）; if（chainedWatcher！）= null）{chainedWatcher.process（event）; }}</code></pre><p>如果客户端ZooKeeper库可以在会话到期（Expired事件）之前重新建立到ZooKeeper的通信通道（SyncConnected事件），则所有会话的监视将自动与服务器重新建立（手表的自动重置是新的ZooKeeper 3.0.0）。有关详细信息，请参阅程序员指南中的<a href="zookeeperProgrammers.html#ch_zkWatches">ZooKeeper Watches</a> 。在此函数中稍微低一点，当DataMonitor获取znode的事件时，它调用<code>ZooKeeper.exists()</code>来找出已更改的内容。</p><p><a name="sc_completeSourceCode"></a></p><h2>完整的源列表</h2><h3>Executor.java</h3>
<pre><code>/ ** *使用DataMonitor启动和*停止基于znode的可执行文件的简单示例程序。程序监视*指定的znode并保存与文件系统中的* znode对应的数据。当znode存在时，它还使用指定的参数启动指定的程序*，如果znode消失，则终止*程序。* / import java.io.FileOutputStream中; import java.io.IOException异常; import java.io.InputStream的; import java.io.的OutputStream; import org.apache.zookeeper。KeeperException; import org.apache.zookeeper。WatchedEvent; import org.apache.zookeeper。看守; import org.apache.zookeeper。动物园管理员;公共类Executor实现了Watcher，Runnable，DataMonitor。DataMonitorListener {String znode; DataMonitor dm; ZooKeeper zk; String filename; String exec [];处理孩子; public Executor（String hostPort，String znode，String filename，String exec []）抛出KeeperException，IOException {this.filename = filename; this.exec = exec; zk = new ZooKeeper（hostPort，3000，this）; dm = new DataMonitor（zk，znode，null，this）; } / ** * @param args * / public static void main（String [] args）{if（args.length &lt;4）{System.err .println（“USAGE：Executor hostPort znode filename program [args ...] “）; System.exit（2）; } String hostPort = args [0]; String znode = args [1]; String filename = args [2]; String exec [] = new String [args.length  -  3]; System.arraycopy（args，3，exec，0，exec.length）; try {new Executor（hostPort，znode，filename，exec）.run（）; } catch（Exception e）{e.printStackTrace（）; / *********************************************** **************************** *我们自己处理任何活动，我们只需要转发它们。* * @see org.apache.zookeeper。看守＃过程（org.apache.zookeeper.proto。WatcherEvent）* / public void process（WatchedEvent event）{dm.process（event）; } public void run（）{try {synchronized（this）{while（！dm.dead）{wait（）; catch（InterruptedException e）{}} public void closing（int rc）{synchronized（this）{notifyAll（）; static class StreamWriter扩展了Thread {OutputStream os; InputStream是; StreamWriter（InputStream是，OutputStream os）{this.is = is; this.os = os;开始（）; public void run（）{byte b [] = new byte [80]; int rc; try {while（（rc = is.read（b））&gt; 0）{os.write（b，0，rc）; catch（IOException e）{}}} public void exists（byte [] data）{if（data == null）{if（child！）= null）{System.out.println（“杀戮过程”）; child.destroy（）; try {child.waitFor（）; } catch（InterruptedException e）{}} child = null; } else {if（孩子！= null）{System.out.println（“Stopping child”）; child.destroy（）; try {child.waitFor（）; } catch（InterruptedException e）{e.printStackTrace（）;尝试{FileOutputStream fos = new FileOutputStream（filename）; fos.write（数据）; fos.close（）; } catch（IOException e）{e.printStackTrace（）; } try {System.out.println（“Starting child”）; child = Runtime.getRuntime（）。exec（exec）; new StreamWriter（child.getInputStream（），System.out）; new StreamWriter（child.getErrorStream（），System.err）; } catch（IOException e）{e.printStackTrace（）; }}}}</code></pre><h3>DataMonitor.java</h3>
<pre><code>/ ** *一个监视ZooKeeper *节点数据和存在的简单类。它使用异步ZooKeeper API。 * / import java.util。阵列; import org.apache.zookeeper。KeeperException; import org.apache.zookeeper。WatchedEvent; import org.apache.zookeeper。看守; import org.apache.zookeeper。动物园管理员; import org.apache.zookeeper。AsyncCallback的。StatCallback; import org.apache.zookeeper。KeeperException。码; import org.apache.zookeeper.data。统计;公共类DataMonitor实现了Watcher，StatCallback {ZooKeeper zk; String znode; Watcher chainedWatcher;布尔死了; DataMonitorListener侦听器; byte prevData []; public DataMonitor（ZooKeeper zk，String znode，Watcher chainedWatcher，DataMonitorListener listener）{this.zk = zk; this.znode = znode; this.chainedWatcher = chainedWatcher; this.listener =听众; //通过检查节点是否存在来开始。我们要//完全由事件驱动zk.exists（znode，true，this，null）; } / ** *其他类通过实现此方法使用DataMonitor * / public interface DataMonitorListener {/ ** *节点的存在状态已更改。* / void exists（byte data []）; / ** * ZooKeeper会话不再有效。* * @param rc * ZooKeeper原因码* / void closing（int rc）; public void process（WatchedEvent event）{String path = event.getPath（）; if（event.getType（）== Event。事件类型。无）{//我们被告知//连接的状态已经改变了switch（event.getState（））{case SyncConnected：//在这个特例中我们不需要做任何事情//这里 - 手表会自动重新注册//服务器，并且当客户端//断开连接时触发的任何手表将按顺序交付（按顺序）中断; case已过期：//已经死了=真; listener.closing（KeeperException。码。sessionExpired时）;打破; }} else {if（路径！= null &amp;&amp; path.equals（znode））{//节点上有些东西发生了变化，让我们找出zk.exists（znode，true，this，null）; if（chainedWatcher！）= null）{chainedWatcher.process（event）; public void processResult（int rc，String path，Object ctx，Stat stat）{boolean exists; switch（rc）{case Code。好的：exists = true;打破;案例代码。NoNode：exists = false;打破;案例代码。SessionExpired：案例代码。NoAuth：dead = true; listener.closing（RC）;返回; default：//重试错误zk.exists（znode，true，this，null）;返回; } byte b [] = null; if（exists）{try {b = zk.getData（znode，false，null）; } catch（KeeperException e）{//我们现在不需要担心恢复。手表//回调将启动任何异常处理e.printStackTrace（）; } catch（InterruptedException e）{return; if（（b == null &amp;&amp; b！）= prevData）|| （b！= null &amp;&amp;！Arrays.equals（prevData，b）））{listener.exists（b）; prevData = b; }}}</code></pre></div>
<div class="clearboth"> </div>
</div>
<div id="footer">
    <div class="lastmodified">
        <script type="text/javascript">
        <!--
            document.write("Last Published: " + document.lastModified);
        //  -->
        </script>
    </div>
    <div class="copyright">版权所有© <a href="http://www.apache.org/licenses/">Apache Software Foundation。</a>
    </div>
    <div id="logos"></div>
</div>
</body>
</html>