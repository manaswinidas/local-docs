<html dir="ltr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
    <title>ZooKeeper：因为协调分布式系统是动物园</title>
    <link type="text/css" href="skin/basic.css" rel="stylesheet"></link>
    <link type="text/css" href="skin/screen.css" rel="stylesheet" media="screen"></link>
    <link type="text/css" href="skin/print.css" rel="stylesheet" media="print"></link>
    <link type="text/css" href="skin/profile.css" rel="stylesheet"></link>
    <script src="skin/getBlank.js" type="text/javascript" language="javascript"></script>
    <script src="skin/getMenu.js" type="text/javascript" language="javascript"></script>
    <script src="skin/init.js" type="text/javascript" language="javascript"></script>
    <link rel="shortcut icon" href="images/favicon.ico"></link>
</head>
<body dir="ltr" onload="init();">
<div id="top">
    <div class="breadtrail">
        <a href="http://www.apache.org/">Apache</a> &gt; <a href="http://zookeeper.apache.org/">ZooKeeper</a>
    </div>
    <div class="header">
        <div class="grouplogo">
            <a href="http://hadoop.apache.org/"><img class="logoImage" alt="Hadoop的" src="images/hadoop-logo.jpg" title="Apache Hadoop"></a>
        </div>
        <div class="projectlogo">
            <a href="http://zookeeper.apache.org/"><img class="logoImage" alt="动物园管理员" src="images/zookeeper_small.gif" title="ZooKeeper：分布式协调"></a>
        </div>
        <div class="searchbox">
            <form action="http://www.google.com/search" method="get">
                <input value="zookeeper.apache.org" name="sitesearch" type="hidden"><input size="25" name="q" id="query" type="text" value="用谷歌搜索网站" onfocus="getBlank (this, &#39;Search the site with google&#39;);"> 
                <input name="Search" value="搜索" type="submit">
            </form>
        </div>
        <ul id="tabs">
            <li>
                <a class="unselected" href="http://zookeeper.apache.org/">项目</a>
            </li>
            <li>
                <a class="unselected" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/">维基</a>
            </li>
            <li class="current">
                <a class="selected" href="index.html">ZooKeeper 3.5文档</a>
            </li>
        </ul>
    </div>
</div>
<div id="main">
    <div id="publishedStrip">
        <div id="level2tabs"></div>
        <script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
    </div>
    <div class="breadtrail">
         
    </div>
    <div id="menu">
        <div id="menu_1Title" class="menutitle" onclick="SwitchMenu(&#39;menu_1&#39;, &#39;skin/&#39;)">概观</div>
        <div id="menu_1" class="menuitemgroup">
            <div class="menuitem">
                <a href="index.html">欢迎</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperOver.html">概观</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperStarted.html">入门</a>
            </div>
            <div class="menuitem">
                <a href="releasenotes.html">发行说明</a>
            </div>
        </div>
        <div id="menu_2Title" class="menutitle" onclick="SwitchMenu(&#39;menu_2&#39;, &#39;skin/&#39;)">开发人员</div>
        <div id="menu_2" class="menuitemgroup">
            <div class="menuitem">
                <a href="api/index.html">API文档</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperProgrammers.html">程序员指南</a>
            </div>
            <div class="menuitem">
                <a href="javaExample.html">Java示例</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperTutorial.html">障碍和队列教程</a>
            </div>
            <div class="menuitem">
                <a href="recipes.html">食谱</a>
            </div>
        </div>
        <div id="menu_3Title" class="menutitle" onclick="SwitchMenu(&#39;menu_3&#39;, &#39;skin/&#39;)">管理员和行动</div>
        <div id="menu_3" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperAdmin.html">管理员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperQuotas.html">配额指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperJMX.html">JMX</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperObservers.html">观察员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperReconfig.html">动态重新配置</a>
            </div>
        </div>
        <div id="menu_4Title" class="menutitle" onclick="SwitchMenu(&#39;menu_4&#39;, &#39;skin/&#39;)">贡献者</div>
        <div id="menu_4" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperInternals.html">ZooKeeper Internals</a>
            </div>
        </div>
        <div id="menu_5Title" class="menutitle" onclick="SwitchMenu(&#39;menu_5&#39;, &#39;skin/&#39;)">杂</div>
        <div id="menu_5" class="menuitemgroup">
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER">维基</a>
            </div>
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ">常问问题</a>
            </div>
            <div class="menuitem">
                <a href="http://zookeeper.apache.org/mailing_lists.html">邮件列表</a>
            </div>
        </div>
    </div>
    <div id="content">
<!--
Copyright 2002-2004 The Apache Software Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
//--><h1>使用ZooKeeper编程 - 一个基本教程</h1>
<ul>
  <li><a href="#ch_Introduction">介绍</a></li>
  <li><a href="#sc_barriers">障碍</a></li>
  <li><a href="#sc_producerConsumerQueues">生产者 - 消费者队列</a></li>
  <li><a href="#Complete+example">完整的例子</a>
  <ul>
    <li><a href="#Queue+test">队列测试</a></li>
    <li><a href="#Barrier+test">屏障测试</a></li>
    <li><a href="#sc_sourceListing">来源清单</a></li>
  </ul></li>
</ul><p><a name="ch_Introduction"></a></p><h2>介绍</h2><p>在本教程中，我们使用ZooKeeper显示障碍和生产者 - 消费者队列的简单实现。我们将相应的类称为障碍和队列。这些示例假定您至少运行了一个ZooKeeper服务器。</p><p>两个原语都使用以下常见的代码摘录：</p>
<pre><code>static ZooKeeper zk = null; static Integer mutex;字符串根; SyncPrimitive（String address）{if（zk == null）{try {System.out.println（“Starting ZK：”）; zk = new ZooKeeper（地址，3000，这个）; mutex = new Integer（-1）; System.out.println（“完成开始ZK：”+ zk）; } catch（IOException e）{System.out.println（e.toString（））; zk = null; synchronized public void process（WatchedEvent event）{synchronized（mutex）{mutex.notify（）; }}</code></pre><p>这两个类都扩展了SyncPrimitive。通过这种方式，我们执行SyncPrimitive构造函数中所有基元共有的步骤。为了简化示例，我们在第一次实例化屏障对象或队列对象时创建一个ZooKeeper对象，并声明一个静态变量，该变量是对该对象的引用。Barrier和Queue的后续实例检查ZooKeeper对象是否存在。或者，我们可以让应用程序创建一个ZooKeeper对象并将其传递给Barrier和Queue的构造函数。</p><p>我们使用process（）方法处理由于监视而触发的通知。在下面的讨论中，我们提供了设置手表的代码。监视是内部结构，使ZooKeeper能够通知客户端节点的更改。例如，如果客户端正在等待其他客户端留下障碍，那么它可以设置监视并等待对特定节点的修改，这可以指示它是等待的结束。一旦我们回顾这些例子，这一点就变得清晰了。</p><p><a name="sc_barriers"></a></p><h2>障碍</h2><p>屏障是一种原语，它使一组进程能够同步计算的开始和结束。这种实现的一般思想是拥有一个屏障节点，其目的是成为各个进程节点的父节点。假设我们调用屏障节点“/ b1”。然后每个进程“p”创建一个节点“/ b1 / p”。一旦足够的进程创建了相应的节点，连接的进程就可以开始计算。</p><p>在此示例中，每个进程都实例化一个Barrier对象，其构造函数作为参数：</p>
<ul>
  <li>ZooKeeper服务器的地址（例如“zoo1.foo.com:2181”）</li>
  <li>ZooKeeper上的障碍节点的路径（例如，“/ b1”）</li>
  <li>进程组的大小</li>
</ul><p>Barrier的构造函数将Zookeeper服务器的地址传递给父类的构造函数。如果不存在，则父类创建ZooKeeper实例。然后，Barrier的构造函数在ZooKeeper上创建一个屏障节点，它是所有进程节点的父节点，我们称之为root（**注意：**这不是ZooKeeper根“/”）。</p>
<pre><code>/ ** *障碍构造函数* * @param地址* @param root * @param size * / Barrier（字符串地址，字符串根，int大小）{super（address）; this.root = root; this.size = size; //创建障碍节点if（zk！= null）{try {Stat s = zk.exists（root，false）; if（s == null）{zk.create（root，new byte [0]，Ids。OPEN_ACL_UNSAFE，CreateMode。永久）; catch（KeeperException e）{System.out .println（“实例化队列时的Keeper异常：”+ e.toString（））; } catch（InterruptedException e）{System.out.println（“Interrupted exception”）;我的节点名称try {name = new String（InetAddress.getLocalHost（）。getCanonicalHostName（）。toString（））; } catch（UnknownHostException e）{System.out.println（e.toString（））; }}</code></pre><p>要进入屏障，进程会调用enter（）。该进程在根目录下创建一个节点来表示它，使用其主机名来形成节点名称。然后等到有足够的进程进入屏障。一个进程通过检查根节点具有“getChildren（）”的子节点数并在没有足够的情况下等待通知来完成它。要在根节点发生更改时收到通知，进程必须设置监视，并通过调用“getChildren（）”来完成。在代码中，我们知道“getChildren（）”有两个参数。第一个表示要读取的节点，第二个是布尔标志，使进程能够设置监视。在代码中，标志为true。</p>
<pre><code>/ ** * Join barrier * * @return * @throws KeeperException * @throws InterruptedException * / boolean enter（）throws KeeperException，InterruptedException {zk.create（root +“/”+ name，new byte [0]，Ids。OPEN_ACL_UNSAFE，CreateMode。EPHEMERAL_SEQUENTIAL）; while（true）{synchronized（mutex）{List &lt;String&gt; list = zk.getChildren（root，true）; if（list.size（）&lt;size）{mutex.wait（）; } else {return true; }}}}</code></pre><p>请注意，enter（）会抛出KeeperException和InterruptedException，因此应用程序负责捕获和处理此类异常。</p><p>计算完成后，进程调用leave（）离开屏障。首先，它删除其对应的节点，然后获取根节点的子节点。如果至少有一个子节点，则等待通知（obs：请注意，对getChildren（）的调用的第二个参数为true，这意味着ZooKeeper必须在根节点上设置监视）。收到通知后，它再次检查根节点是否有子节点。</p>
<pre><code>/ ** *等到所有到达障碍* * @return * @throws KeeperException * @throws InterruptedException * / boolean leave（）抛出KeeperException，InterruptedException {zk.delete（root +“/”+ name，0）; while（true）{synchronized（mutex）{List &lt;String&gt; list = zk.getChildren（root，true）; if（list.size（）&gt; 0）{mutex.wait（）; } else {return true; }}}}</code></pre><p><a name="sc_producerConsumerQueues"></a></p><h2>生产者 - 消费者队列</h2><p>生产者 - 消费者队列是一种分布式数据结构，进程组用于生成和使用项目。生产者进程创建新元素并将其添加到队列中。使用者进程从列表中删除元素并处理它们。在此实现中，元素是简单的整数。队列由根节点表示，并且为了向队列添加元素，生成器进程创建新节点，即根节点的子节点。</p><p>以下代码摘录对应于对象的构造函数。与Barrier对象一样，它首先调用父类SyncPrimitive的构造函数，如果不存在，则创建ZooKeeper对象。然后，它验证队列的根节点是否存在，如果不存在则创建。</p>
<pre><code>/ ** *生产者 - 消费者队列的构造函数* * @param地址* @param name * / Queue（String address，String name）{super（address）; this.root = name; //创建ZK节点名称if（zk！= null）{try {Stat s = zk.exists（root，false）; if（s == null）{zk.create（root，new byte [0]，Ids。OPEN_ACL_UNSAFE，CreateMode。永久）; catch（KeeperException e）{System.out .println（“实例化队列时的Keeper异常：”+ e.toString（））; } catch（InterruptedException e）{System.out.println（“Interrupted exception”）; }}}</code></pre><p>生产者进程调用“produce（）”将元素添加到队列，并传递整数作为参数。要向队列添加元素，该方法使用“create（）”创建一个新节点，并使用SEQUENCE标志指示ZooKeeper附加与根节点关联的sequencer计数器的值。通过这种方式，我们对队列的元素施加了一个总顺序，从而保证队列中最旧的元素是下一个消耗的元素。</p>
<pre><code>/ ** *将元素添加到队列中。* * @param i * @return * / boolean produce（int i）throws KeeperException，InterruptedException {ByteBuffer b = ByteBuffer.allocate（4）; byte []值; //添加有价值的孩子i b.putInt（i）; value = b.array（）; zk.create（root +“/ element”，value，Ids。OPEN_ACL_UNSAFE，CreateMode。PERSISTENT_SEQUENTIAL）;返回true; }</code></pre><p>要使用元素，使用者进程将获取根节点的子节点，读取具有最小计数器值的节点，并返回该元素。请注意，如果存在冲突，则两个竞争进程中的一个将无法删除该节点，并且删除操作将引发异常。</p><p>对getChildren（）的调用以字典顺序返回子项列表。由于词典顺序不必遵循计数器值的数字顺序，我们需要确定哪个元素是最小的。为了确定哪一个具有最小的计数器值，我们遍历列表，并从每个列表中删除前缀“元素”。</p>
<pre><code>/ ** *从队列中删除第一个元素。* * @return * @throws KeeperException * @throws InterruptedException * / int consume（）throws KeeperException，InterruptedException {int retvalue = -1; Stat stat = null; //获取第一个元素while（true）{synchronized（mutex）{List &lt;String&gt; list = zk.getChildren（root，true）; if（list.size（）== 0）{System.out.println（“Going to wait”）; mutex.wait（）; } else {Integer min = new Integer（list.get（0）.substring（7））; for（String s：list）{Integer tempValue = new Integer（s.substring（7））; //System.out.println("Temporary value：“+ tempValue）; if（tempValue &lt;min）min = tempValue; System.out.println（“临时值：”+ root +“/ element”+ min）; byte [] b = zk.getData（root +“/ element”+ min，false，stat）; zk.delete（root +“/ element”+ min，0）; ByteBuffer buffer = ByteBuffer.wrap（b）; retvalue = buffer.getInt（）;返回值; }}}}}</code></pre><p><a name="Complete+example"></a></p><h2>完整的例子</h2><p>在下一节中，您可以找到完整的命令行应用程序来演示上述配方。使用以下命令运行它。</p>
<pre><code>ZOOBINDIR =“[path_to_distro] / bin”。 “$ ZOOBINDIR”/zkEnv.sh java SyncPrimitive [测试类型] [ZK服务器] [元素数] [客户端类型]</code></pre><p><a name="Queue+test"></a></p><h3>队列测试</h3><p>启动生产者以创建100个元素</p>
<pre><code>java SyncPrimitive qTest localhost 100 p</code></pre><p>启动使用者消耗100个元素</p>
<pre><code>java SyncPrimitive qTest localhost 100 c</code></pre><p><a name="Barrier+test"></a></p><h3>屏障测试</h3><p>开始一个有2个参与者的障碍（开始的次数是您想要输入的参与者的数量）</p>
<pre><code>java SyncPrimitive bTest localhost 2</code></pre><p><a name="sc_sourceListing"></a></p><h3>来源清单</h3><h4>SyncPrimitive。Java的</h4>
<pre><code>import java.io.IOException异常; import java.net。InetAddress类; import java.net。的UnknownHostException; import java.nio。字节缓冲区; import java.util。清单; import java.util。随机; import org.apache.zookeeper。CreateMode; import org.apache.zookeeper。KeeperException; import org.apache.zookeeper。WatchedEvent; import org.apache.zookeeper。看守; import org.apache.zookeeper。动物园管理员; import org.apache.zookeeper。ZooDefs。IDS; import org.apache.zookeeper.data。统计;公共类SyncPrimitive实现了Watcher {static ZooKeeper zk = null; static Integer mutex;字符串根; SyncPrimitive（String address）{if（zk == null）{try {System.out.println（“Starting ZK：”）; zk = new ZooKeeper（地址，3000，这个）; mutex = new Integer（-1）; System.out.println（“完成开始ZK：”+ zk）; } catch（IOException e）{System.out.println（e.toString（））; zk = null; }} // else mutex = new Integer（-1）; } synchronized public void process（WatchedEvent event）{synchronized（mutex）{// System.out.println（“Process：”+ event.getType（））; mutex.notify（）; }} / ** * Barrier * / static public class Barrier扩展SyncPrimitive {int size;字符串名称; / ** *障碍构造函数* * @param地址* @param root * @param size * / Barrier（字符串地址，字符串根，int大小）{super（address）; this.root = root; this.size = size; //创建障碍节点if（zk！= null）{try {Stat s = zk.exists（root，false）; if（s == null）{zk.create（root，new byte [0]，Ids。OPEN_ACL_UNSAFE，CreateMode。永久）; catch（KeeperException e）{System.out .println（“实例化队列时的Keeper异常：”+ e.toString（））; } catch（InterruptedException e）{System.out.println（“Interrupted exception”）;我的节点名称try {name = new String（InetAddress.getLocalHost（）。getCanonicalHostName（）。toString（））; } catch（UnknownHostException e）{System.out.println（e.toString（））; } * / * * Join barrier * * @return * @throws KeeperException * @throws InterruptedException * / boolean enter（）throws KeeperException，InterruptedException {zk.create（root +“/”+ name，new byte [0]，Ids 。OPEN_ACL_UNSAFE，CreateMode。EPHEMERAL_SEQUENTIAL）; while（true）{synchronized（mutex）{List &lt;String&gt; list = zk.getChildren（root，true）; if（list.size（）&lt;size）{mutex.wait（）; } else {return true; } *} *等待直到所有到达障碍* * @return * @throws KeeperException * @throws InterruptedException * / boolean leave（）抛出KeeperException，InterruptedException {zk.delete（root +“/”+ name，0） ; while（true）{synchronized（mutex）{List &lt;String&gt; list = zk.getChildren（root，true）; if（list.size（）&gt; 0）{mutex.wait（）; } else {return true;生成器 - 消费者队列* /静态公共类队列扩展SyncPrimitive {/ ** *生产者 - 消费者队列的构造函数* * @param地址* @param name * / Queue（字符串地址，字符串名称） ）{super（地址）; this.root = name; //创建ZK节点名称if（zk！= null）{try {Stat s = zk.exists（root，false）; if（s == null）{zk.create（root，new byte [0]，Ids。OPEN_ACL_UNSAFE，CreateMode。永久）; catch（KeeperException e）{System.out .println（“实例化队列时的Keeper异常：”+ e.toString（））; } catch（InterruptedException e）{System.out.println（“Interrupted exception”）; } / ** *将元素添加到队列中。* * @param i * @return * / boolean produce（int i）throws KeeperException，InterruptedException {ByteBuffer b = ByteBuffer.allocate（4）; byte []值; //添加有价值的孩子i b.putInt（i）; value = b.array（）; zk.create（root +“/ element”，value，Ids。OPEN_ACL_UNSAFE，CreateMode。PERSISTENT_SEQUENTIAL）;返回true; } / ** *从队列中删除第一个元素。* * @return * @throws KeeperException * @throws InterruptedException * / int consume（）throws KeeperException，InterruptedException {int retvalue = -1; Stat stat = null; //获取第一个元素while（true）{synchronized（mutex）{List &lt;String&gt; list = zk.getChildren（root，true）; if（list.size（）== 0）{System.out.println（“Going to wait”）; mutex.wait（）; } else {Integer min = new Integer（list.get（0）.substring（7））; String minNode = list.get（0）; for（String s：list）{Integer tempValue = new Integer（s.substring（7））; //System.out.println("Temporary value：“+ tempValue）; if（tempValue &lt;min）{min = tempValue; minNode = s; System.out.println（“临时值：”+ root +“/”+ minNode）; byte [] b = zk.getData（root +“/”+ minNode，false，stat）; zk.delete（root +“/”+ minNode，0）; ByteBuffer buffer = ByteBuffer.wrap（b）; retvalue = buffer.getInt（）;返回值; public static void main（String args []）{if（args [0] .equals（“qTest”））queueTest（args）; else barrierTest（args）; public static void queueTest（String args []）{Queue q = new Queue（args [1]，“/ app1”）; System.out.println（“输入：”+ args [1]）; int i; Integer max = new Integer（args [2]）; if（args [3] .equals（“p”））{System.out.println（“Producer”）; for（i = 0; i &lt;max; i ++）try {q.produce（10 + i）; } catch（KeeperException e）{} catch（InterruptedException e）{}} else {System.out.println（“Consumer”）; for（i = 0; i &lt;max; i ++）{try {int r = q.consume（）; System.out.println（“Item：”+ r）; } catch（KeeperException e）{i--; } catch（InterruptedException e）{}}}} public static void barrierTest（String args []）{Barrier b = new Barrier（args [1]，“/ b1”，new Integer（args [2]））; try {boolean flag = b.enter（）; System.out.println（“输入屏障：”+ args [2]）;如果（！flag）System.out.println（“进入屏障时出错”）; } catch（KeeperException e）{} catch（InterruptedException e）{} //生成随机整数Random rand = new Random（）; int r = rand.nextInt（100）; //循环for rand迭代为（int i = 0; i &lt;r; i ++）{try {Thread.sleep（100）; } catch（InterruptedException e）{}} try {b.leave（）; } catch（KeeperException e）{} catch（InterruptedException e）{} System.out.println（“Left barrier”）; }}</code></pre></div>
<div class="clearboth"> </div>
</div>
<div id="footer">
    <div class="lastmodified">
        <script type="text/javascript">
        <!--
            document.write("Last Published: " + document.lastModified);
        //  -->
        </script>
    </div>
    <div class="copyright">版权所有© <a href="http://www.apache.org/licenses/">Apache Software Foundation。</a>
    </div>
    <div id="logos"></div>
</div>
</body>
</html>