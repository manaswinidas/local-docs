<html dir="ltr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
    <title>ZooKeeper：因为协调分布式系统是动物园</title>
    <link type="text/css" href="skin/basic.css" rel="stylesheet"></link>
    <link type="text/css" href="skin/screen.css" rel="stylesheet" media="screen"></link>
    <link type="text/css" href="skin/print.css" rel="stylesheet" media="print"></link>
    <link type="text/css" href="skin/profile.css" rel="stylesheet"></link>
    <script src="skin/getBlank.js" type="text/javascript" language="javascript"></script>
    <script src="skin/getMenu.js" type="text/javascript" language="javascript"></script>
    <script src="skin/init.js" type="text/javascript" language="javascript"></script>
    <link rel="shortcut icon" href="images/favicon.ico"></link>
</head>
<body dir="ltr" onload="init();">
<div id="top">
    <div class="breadtrail">
        <a href="http://www.apache.org/">Apache</a> &gt; <a href="http://zookeeper.apache.org/">ZooKeeper</a>
    </div>
    <div class="header">
        <div class="grouplogo">
            <a href="http://hadoop.apache.org/"><img class="logoImage" alt="Hadoop的" src="images/hadoop-logo.jpg" title="Apache Hadoop"></a>
        </div>
        <div class="projectlogo">
            <a href="http://zookeeper.apache.org/"><img class="logoImage" alt="动物园管理员" src="images/zookeeper_small.gif" title="ZooKeeper：分布式协调"></a>
        </div>
        <div class="searchbox">
            <form action="http://www.google.com/search" method="get">
                <input value="zookeeper.apache.org" name="sitesearch" type="hidden"><input size="25" name="q" id="query" type="text" value="用谷歌搜索网站" onfocus="getBlank (this, &#39;Search the site with google&#39;);"> 
                <input name="Search" value="搜索" type="submit">
            </form>
        </div>
        <ul id="tabs">
            <li>
                <a class="unselected" href="http://zookeeper.apache.org/">项目</a>
            </li>
            <li>
                <a class="unselected" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/">维基</a>
            </li>
            <li class="current">
                <a class="selected" href="index.html">ZooKeeper 3.5文档</a>
            </li>
        </ul>
    </div>
</div>
<div id="main">
    <div id="publishedStrip">
        <div id="level2tabs"></div>
        <script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
    </div>
    <div class="breadtrail">
         
    </div>
    <div id="menu">
        <div onclick="SwitchMenu('menu_1', 'skin/')" id="menu_1Title" class="menutitle">Overview</div>
        <div id="menu_1" class="menuitemgroup">
            <div class="menuitem">
                <a href="index.html">欢迎</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperOver.html">概观</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperStarted.html">入门</a>
            </div>
            <div class="menuitem">
                <a href="releasenotes.html">发行说明</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_2', 'skin/')" id="menu_2Title" class="menutitle">Developer</div>
        <div id="menu_2" class="menuitemgroup">
            <div class="menuitem">
                <a href="api/index.html">API文档</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperProgrammers.html">程序员指南</a>
            </div>
            <div class="menuitem">
                <a href="javaExample.html">Java示例</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperTutorial.html">障碍和队列教程</a>
            </div>
            <div class="menuitem">
                <a href="recipes.html">食谱</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_3', 'skin/')" id="menu_3Title" class="menutitle">Admin &amp; Ops</div>
        <div id="menu_3" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperAdmin.html">管理员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperQuotas.html">配额指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperJMX.html">JMX</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperObservers.html">观察员指南</a>
            </div>
            <div class="menuitem">
                <a href="zookeeperReconfig.html">动态重新配置</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_4', 'skin/')" id="menu_4Title" class="menutitle">Contributor</div>
        <div id="menu_4" class="menuitemgroup">
            <div class="menuitem">
                <a href="zookeeperInternals.html">ZooKeeper Internals</a>
            </div>
        </div>
        <div onclick="SwitchMenu('menu_5', 'skin/')" id="menu_5Title" class="menutitle">Miscellaneous</div>
        <div id="menu_5" class="menuitemgroup">
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER">维基</a>
            </div>
            <div class="menuitem">
                <a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ">常问问题</a>
            </div>
            <div class="menuitem">
                <a href="http://zookeeper.apache.org/mailing_lists.html">邮件列表</a>
            </div>
        </div>
    </div>
    <div id="content">
<!--
Copyright 2002-2004 The Apache Software Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
//--><h1>ZooKeeper管理员指南</h1><h3>部署和管理指南</h3>
<ul>
  <li><a href="#ch_deployment">部署</a>
  <ul>
    <li><a href="#sc_systemReq">系统要求</a>
    <ul>
      <li><a href="#sc_supportedPlatforms">支持的平台</a></li>
      <li><a href="#sc_requiredSoftware">必备软件</a></li>
    </ul></li>
    <li><a href="#sc_zkMulitServerSetup">群集（多服务器）安装程序</a></li>
    <li><a href="#sc_singleAndDevSetup">单服务器和开发人员设置</a></li>
  </ul></li>
  <li><a href="#ch_administration">管理</a>
  <ul>
    <li><a href="#sc_designing">设计ZooKeeper部署</a>
    <ul>
      <li><a href="#sc_CrossMachineRequirements">跨机器要求</a></li>
      <li><a href="#Single+Machine+Requirements">单机要求</a></li>
    </ul></li>
    <li><a href="#sc_provisioning">供应</a></li>
    <li><a href="#sc_strengthsAndLimitations">需要考虑的事项：ZooKeeper的优势和局限</a></li>
    <li><a href="#sc_administering">管理</a></li>
    <li><a href="#sc_maintenance">保养</a>
    <ul>
      <li><a href="#Ongoing+Data+Directory+Cleanup">正在进行的数据目录清理</a></li>
      <li><a href="#Debug+Log+Cleanup+%28log4j%29">调试日志清理（log4j）</a></li>
    </ul></li>
    <li><a href="#sc_supervision">监督</a></li>
    <li><a href="#sc_monitoring">监控</a></li>
    <li><a href="#sc_logging">记录</a></li>
    <li><a href="#sc_troubleshooting">故障排除</a></li>
    <li><a href="#sc_configuration">配置参数</a>
    <ul>
      <li><a href="#sc_minimumConfiguration">最低配置</a></li>
      <li><a href="#sc_advancedConfiguration">高级配置</a></li>
      <li><a href="#sc_clusterOptions">群集选项</a></li>
      <li><a href="#sc_authOptions">加密，身份验证，授权选项</a></li>
      <li><a href="#Experimental+Options%2FFeatures">实验选项/功能</a></li>
      <li><a href="#Unsafe+Options">不安全的选择</a></li>
      <li><a href="#Disabling+data+directory+autocreation">禁用数据目录自动创建</a></li>
      <li><a href="#sc_db_existence_validation">启用db存在验证</a></li>
      <li><a href="#sc_performance_options">性能调整选项</a></li>
      <li><a href="#sc_adminserver_config">AdminServer配置</a></li>
    </ul></li>
    <li><a href="#Communication+using+the+Netty+framework">使用Netty框架进行通信</a>
    <ul>
      <li><a href="#Quorum+TLS">法定人数TLS</a></li>
      <li><a href="#Upgrading+existing+nonTLS+cluster">升级现有的非TLS群集，无需停机</a></li>
    </ul></li>
    <li><a href="#sc_zkCommands">ZooKeeper命令</a>
    <ul>
      <li><a href="#sc_4lw">四字母词</a></li>
      <li><a href="#sc_adminserver">AdminServer</a></li>
    </ul></li>
    <li><a href="#sc_dataFileManagement">数据文件管理</a>
    <ul>
      <li><a href="#The+Data+Directory">数据目录</a></li>
      <li><a href="#The+Log+Directory">日志目录</a></li>
      <li><a href="#sc_filemanagement">文件管理</a></li>
      <li><a href="#Recovery+-+TxnLogToolkit">恢复 -  TxnLogToolkit</a></li>
    </ul></li>
    <li><a href="#sc_commonProblems">要避免的事情</a></li>
    <li><a href="#sc_bestPractices">最佳实践</a></li>
  </ul></li>
</ul><p><a name="ch_deployment"></a></p><h2>部署</h2><p>本节包含有关部署Zookeeper的信息，并涵盖以下主题：</p>
<ul>
  <li><a href="#sc_systemReq">系统要求</a></li>
  <li><a href="#sc_zkMulitServerSetup">群集（多服务器）安装程序</a></li>
  <li><a href="#sc_singleAndDevSetup">单服务器和开发人员设置</a></li>
</ul><p>前两节假设您有兴趣在生产环境（如数据中心）中安装ZooKeeper。最后一节介绍了在有限的基础上设置ZooKeeper的情况 - 用于评估，测试或开发 - 但不适用于生产环境。</p><p><a name="sc_systemReq"></a></p><h3>系统要求</h3><p><a name="sc_supportedPlatforms"></a></p><h4>支持的平台</h4><p>ZooKeeper由多个组件组成。某些组件得到广泛支持，其他组件仅在较小的平台上受支持。</p>
<ul>
  <li><strong>客户端</strong>是Java客户端库，应用程序使用它连接到ZooKeeper集合。</li>
  <li><strong>Server</strong>是在ZooKeeper集合节点上运行的Java服务器。</li>
  <li><strong>Native Client</strong>是一个用C实现的客户端，类似于Java客户端，应用程序使用它连接到ZooKeeper集合。</li>
  <li><strong>Contrib</strong>是指多个可选的附加组件。</li>
</ul><p>以下矩阵描述了为在不同操作系统平台上运行每个组件而提交的支持级别。</p><h5>支持矩阵</h5>
<table>
  <thead>
    <tr>
      <th>操作系统</th>
      <th>客户</th>
      <th>服务器</th>
      <th>原生客户端</th>
      <th>的Contrib</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GNU / Linux的</td>
      <td>开发和生产</td>
      <td>开发和生产</td>
      <td>开发和生产</td>
      <td>开发和生产</td>
    </tr>
    <tr>
      <td>的Solaris</td>
      <td>开发和生产</td>
      <td>开发和生产</td>
      <td>不支持</td>
      <td>不支持</td>
    </tr>
    <tr>
      <td>FreeBSD的</td>
      <td>开发和生产</td>
      <td>开发和生产</td>
      <td>不支持</td>
      <td>不支持</td>
    </tr>
    <tr>
      <td>视窗</td>
      <td>开发和生产</td>
      <td>开发和生产</td>
      <td>不支持</td>
      <td>不支持</td>
    </tr>
    <tr>
      <td>Mac OS X.</td>
      <td>仅限发展</td>
      <td>仅限发展</td>
      <td>不支持</td>
      <td>不支持</td>
    </tr>
  </tbody>
</table><p>对于矩阵中未明确提及的任何操作系统，组件可能有效，也可能无效。ZooKeeper社区将修复针对其他平台报告的明显错误，但没有完全支持。</p><p><a name="sc_requiredSoftware"></a></p><h4>必备软件</h4><p>ZooKeeper在Java中运行，1.7或更高版本（JDK 7或更高版本，FreeBSD支持需要openjdk7）。它作为ZooKeeper服务器的<em>集合</em>运行。三个ZooKeeper服务器是整体的最小建议大小，我们还建议它们在不同的机器上运行。在Yahoo！，ZooKeeper通常部署在专用的RHEL盒子上，具有双核处理器，2GB RAM和80GB IDE硬盘。</p><p><a name="sc_zkMulitServerSetup"></a></p><h3>群集（多服务器）安装程序</h3><p>对于可靠的ZooKeeper服务，您应该在称为<em>集合</em>的集群中部署ZooKeeper。只要合奏的大部分都在增加，该服务将可用。因为Zookeeper需要占多数，所以最好使用奇数个机器。例如，使用四台机器，ZooKeeper只能处理单台机器的故障;如果两台机器出现故障，其余两台机器不会占多数。但是，有了五台机器，ZooKeeper可以处理两台机器的故障。</p><h6>注意</h6>
<blockquote><p>如<a href="zookeeperStarted.html">ZooKeeper入门指南中所述</a> ，容错群集设置至少需要三台服务器，强烈建议您使用奇数个服务器。</p><p>通常三台服务器对于生产安装来说已经足够了，但为了在维护期间获得最大可靠性，您可能希望安装五台服务器。使用三台服务器时，如果对其中一台服务器执行维护，则在维护期间，您很容易在其他两台服务器上发生故障。如果你有五个正在运行，你可以拿一个进行维护，并且知道如果其他四个中的一个突然失败你仍然可以。</p><p>您的冗余注意事项应包括环境的所有方面。如果您有三台ZooKeeper服务器，但它们的网络电缆都插入同一个网络交换机，那么该交换机的故障将会占用整个集合。</p>
</blockquote><p>以下是设置将成为集合一部分的服务器的步骤。这些步骤应该在整体中的每个主机上执行：</p>
<ol>
  <li><p>安装Java JDK。您可以为系统使用本机打包系统，也可以从以下位置下载JDK： <a href="http://java.sun.com/javase/downloads/index.jsp">http</a> ： <a href="http://java.sun.com/javase/downloads/index.jsp">//java.sun.com/javase/downloads/index.jsp</a></p></li>
  <li><p>设置Java堆大小。这对于避免交换非常重要，这会严重降低ZooKeeper的性能。要确定正确的值，请使用负载测试，并确保远低于导致交换的使用限制。保守一点 - 对于4GB机器，最大堆大小为3GB。</p></li>
  <li><p>安装ZooKeeper服务器包。它可以从<a href="http://zookeeper.apache.org/releases.html">http://zookeeper.apache.org/releases.html</a>下载</p></li>
  <li><p>创建配置文件。这个文件可以被称为任何东西。使用以下设置作为起点：</p>
  <pre><code>tickTime = 2000 dataDir = / var / lib / zookeeper / clientPort = 2181 initLimit = 5 syncLimit = 2 server.1 = zoo1：2888：3888 server.2 = zoo2：2888：3888 server.3 = zoo3：2888：3888</code></pre><p>您可以在“ <a href="#sc_configuration">配置参数</a> ”部分中找到这些和其他配置设置的含义。这里有一个词虽然有几个：ZooKeeper整体中的每台机器都应该知道整体中的其他机器。您可以使用<strong>server.id = host：port：port</strong>形式的一系列行来完成此操作。参数<strong>host</strong>和<strong>port</strong>很简单。您可以通过创建名为<em>myid</em>的文件将服务器ID归因于每台计算机，每个服务器<em>对应</em>一个文件，该文件位于该服务器的数据目录中，由配置文件参数<strong>dataDir</strong>指定。</p></li>
  <li><p>myid文件由一行组成，只包含该机器id的文本。所以服务器1的<em>myid</em>将包含文本“1”而没有别的。id在整体中必须是唯一的，并且应该具有1到255之间的值。<strong>重要信息：</strong>如果启用TTL节点等扩展功能（见下文），由于内部限制，ID必须介于1和254之间。</p></li>
  <li><p>如果您的配置文件已设置，则可以启动ZooKeeper服务器：</p>
  <pre><code>$ java -cp zookeeper.jar：lib / *：conf org.apache.zookeeper.server.quorum。QuorumPeerMain zoo.conf</code></pre></li>
</ol><p>QuorumPeerMain启动ZooKeeper服务器，还注册了<a href="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/">JMX</a>管理bean，允许通过JMX管理控制台进行管理。<a href="zookeeperJMX.html">ZooKeeper JMX文档</a>包含有关使用JMX管理ZooKeeper的详细信息。有关启动服务器实例的示例，请参阅发行版中包含的脚本<em>bin / zkServer.sh</em> 。</p>
<ol>
  <li><p>通过连接到主机来测试部署：在Java中，您可以运行以下命令来执行简单操作：</p>
  <pre><code>$ bin / zkCli.sh -server 127.0.0.1:2181</code></pre></li>
</ol><p><a name="sc_singleAndDevSetup"></a></p><h3>单服务器和开发人员设置</h3><p>如果要设置ZooKeeper用于开发目的，您可能需要设置ZooKeeper的单个服务器实例，然后在开发计算机上安装Java或C客户端库和绑定。</p><p>设置单个服务器实例的步骤与上述类似，但配置文件更简单。您可以在<a href="zookeeperStarted.html">ZooKeeper入门指南的“</a> <a href="zookeeperStarted.html#sc_InstallingSingleMode">单服务器模式下安装和运行ZooKeeper”</a>部分找到完整说明。</p><p>有关安装客户端库的信息，请参阅<a href="zookeeperProgrammers.html">ZooKeeper程序员指南</a>的<a href="zookeeperProgrammers.html#ch_bindings">Bindings</a>部分。</p><p><a name="ch_administration"></a></p><h2>管理</h2><p>本节包含有关运行和维护ZooKeeper的信息，并涵盖以下主题：</p>
<ul>
  <li><a href="#sc_designing">设计ZooKeeper部署</a></li>
  <li><a href="#sc_provisioning">供应</a></li>
  <li><a href="#sc_strengthsAndLimitations">需要考虑的事项：ZooKeeper的优势和局限</a></li>
  <li><a href="#sc_administering">管理</a></li>
  <li><a href="#sc_maintenance">保养</a></li>
  <li><a href="#sc_supervision">监督</a></li>
  <li><a href="#sc_monitoring">监控</a></li>
  <li><a href="#sc_logging">记录</a></li>
  <li><a href="#sc_troubleshooting">故障排除</a></li>
  <li><a href="#sc_configuration">配置参数</a></li>
  <li><a href="#sc_zkCommands">ZooKeeper命令</a></li>
  <li><a href="#sc_dataFileManagement">数据文件管理</a></li>
  <li><a href="#sc_commonProblems">要避免的事情</a></li>
  <li><a href="#sc_bestPractices">最佳实践</a></li>
</ul><p><a name="sc_designing"></a></p><h3>设计ZooKeeper部署</h3><p>ZooKeeper的可靠性取决于两个基本假设。</p>
<ol>
  <li>部署中只有少数服务器会失败。此上下文中的<em>失败</em>意味着机器崩溃或网络中的一些错误将服务器与大多数分区。</li>
  <li>部署的机器正常运行。正确操作意味着正确执行代码，使时钟正常工作，以及使存储和网络组件始终如一地执行。</li>
</ol><p>以下部分包含ZooKeeper管理员的注意事项，以最大化这些假设保持为真的概率。其中一些是跨机器考虑因素，而另一些则是您应该为部署中的每台计算机考虑的事项。</p><p><a name="sc_CrossMachineRequirements"></a></p><h4>跨机器要求</h4><p>要使ZooKeeper服务处于活动状态，必须有大多数可以相互通信的非故障机器。要创建可以容忍F计算机故障的部署，您应该依赖部署2xF + 1计算机。因此，由三台机器组成的部署可以处理一个故障，而五台机器的部署可以处理两个故障。请注意，由于三台计算机不是多数，因此部署六台计算机只能处理两次故障。因此，ZooKeeper部署通常由奇数个计算机组成。</p><p>为了实现容忍故障的最高概率，您应该尝试使机器故障独立。例如，如果大多数机器共享同一个交换机，则该交换机的故障可能导致相关故障并导致服务中断。共享电源电路，冷却系统等也是如此。</p><p><a name="Single+Machine+Requirements"></a></p><h4>单机要求</h4><p>如果ZooKeeper必须与其他应用程序竞争访问存储介质，CPU，网络或内存等资源，其性能将受到显着影响。ZooKeeper具有强大的持久性保证，这意味着它允许存储介质记录更改，然后才能完成负责更改的操作。您应该知道这种依赖关系，如果您想确保媒体不会阻止ZooKeeper操作，请务必小心。以下是您可以采取的一些措施，以尽量减少这种退化：</p>
<ul>
  <li>ZooKeeper的事务日志必须位于专用设备上。（专用分区是不够的。）ZooKeeper按顺序写入日志，而不寻求与其他进程共享您的日志设备可能导致搜索和争用，这反过来可能导致多秒延迟。</li>
  <li>不要将ZooKeeper置于可能导致交换的情况。为了使ZooKeeper能够以任何时间运行，它根本不允许交换。因此，请确保为ZooKeeper提供的最大堆大小不大于ZooKeeper可用的实际内存量。有关详细信息，请参阅下面的“ <a href="#sc_commonProblems">要避免的事项”</a> 。</li>
</ul><p><a name="sc_provisioning"></a></p><h3>供应</h3><p><a name="sc_strengthsAndLimitations"></a></p><h3>需要考虑的事项：ZooKeeper的优势和局限</h3><p><a name="sc_administering"></a></p><h3>管理</h3><p><a name="sc_maintenance"></a></p><h3>保养</h3><p>ZooKeeper集群需要很少的长期维护，但您必须了解以下内容：</p><p><a name="Ongoing+Data+Directory+Cleanup"></a></p><h4>正在进行的数据目录清理</h4><p>ZooKeeper <a href="#var_datadir">数据目录</a>包含的文件是特定服务集合存储的znode的持久副本。这些是快照和事务日志文件。随着对znode的更改，这些更改将附加到事务日志中。有时，当日志变大时，所有znode的当前状态的快照将写入文件系统，并为将来的事务创建新的事务日志文件。在快照期间，ZooKeeper可以继续将传入事务附加到旧日志文件。因此，可以在快照之前的最后一个事务日志中找到一些比快照更新的事务。</p><p>使用默认配置时，ZooKeeper服务器<strong>不会删除旧快照和日志文件</strong> （请参阅下面的autopurge），这是运营商的责任。每个服务环境都不同，因此管理这些文件的要求可能因安装而不同（例如备份）。</p><p>PurgeTxnLog实用程序实现了管理员可以使用的简单保留策略。<a href="index.html">API文档</a>包含有关调用约定（参数等）的详细信息。</p><p>在以下示例中，将保留最后的计数快照及其相应的日志，并删除其他日志。值<count>应该通常大于3（尽管不是必需的，但在最近的日志已损坏的情况下，这提供了3个备份）。这可以作为ZooKeeper服务器计算机上的cron作业运行，以便每天清理日志。</count></p>
<pre><code>java -cp zookeeper.jar：lib / slf4j-api-1.7.5.jar：lib / slf4j-log4j12-1.7.5.jar：lib / log4j-1.2.17.jar：conf org.apache.zookeeper.server。PurgeTxnLog &lt;dataDir&gt; &lt;snapDir&gt; -n &lt;count&gt;</code></pre><p>版本3.4.0中引入了自动清除快照和相应的事务日志，可以通过以下配置参数<strong>autopurge.snapRetainCount</strong>和<strong>autopurge.purgeInterval启用</strong> 。有关详细信息，请参阅下面的<a href="#sc_advancedConfiguration">高级配置</a> 。</p><p><a name="Debug+Log+Cleanup+%28log4j%29"></a></p><h4>调试日志清理（log4j）</h4><p>请参阅本文档中的<a href="#sc_logging">登录</a>部分。预计您将使用内置的log4j功能设置滚动文件追加器。发行版tar的conf / log4j.properties中的示例配置文件提供了此示例。</p><p><a name="sc_supervision"></a></p><h3>监督</h3><p>您将需要一个管理每个ZooKeeper服务器进程（JVM）的监督过程。ZK服务器被设计为“快速失败”，这意味着如果发生无法恢复的错误，它将关闭（进程退出）。由于ZooKeeper服务群集非常可靠，这意味着虽然服务器可能会在整个群集中停留，但仍然处于活动状态并提供请求。此外，由于群集是“自我修复”，故障服务器一旦重新启动，将自动重新加入整体，无需任何手动交互。</p><p>有一个监控过程，如<a href="http://cr.yp.to/daemontools.html">daemontools</a>或<a href="http://en.wikipedia.org/wiki/Service\_Management\_Facility">SMF</a> （监控过程的其他选项也可用，取决于你想要使用哪一个，这只是两个例子）管理你的ZooKeeper服务器确保如果进程异常退出它将自动重新启动并快速重新加入群集。</p><p>如果发生OutOfMemoryError **，还建议将ZooKeeper服务器进程配置为终止并转储其堆。这是通过分别在Linux和Windows上使用以下参数启动JVM来实现的。随ZooKeeper一起提供的<em>zkServer.sh</em>和<em>zkServer.cmd</em>脚本设置了这些选项。</p>
<pre><code>-XX：+ HeapDumpOnOutOfMemoryError -XX：OnOutOfMemoryError ='kill -9％p'“ -  XX：+ HeapDumpOnOutOfMemoryError”“ -  XX：OnOutOfMemoryError = cmd / c taskkill / pid %%%% p / t / f”</code></pre><p><a name="sc_monitoring"></a></p><h3>监控</h3><p>ZooKeeper服务可以通过两种主要方式之一进行监控; 1）命令端口通过使用<a href="#sc_zkCommands">4个字母的单词</a>和2） <a href="zookeeperJMX.html">JMX</a> 。有关您的环境/要求，请参阅相应部分。</p><p><a name="sc_logging"></a></p><h3>记录</h3><p>ZooKeeper使用<strong><a href="http://www.slf4j.org">SLF4J</a></strong>版本1.7.5作为其日志记录基础结构。为了向后兼容，它绑定到<strong>LOG4J，</strong>但您可以使用<strong><a href="http://logback.qos.ch/">LOGBack</a></strong>或您选择的任何其他支持的日志框架。</p><p>ZooKeeper默认的<em>log4j.properties</em>文件位于<em>conf</em>目录中。Log4j要求<em>log4j.properties</em>位于工作目录（运行ZooKeeper的目录）中，或者可以从类路径访问。</p><p>有关SLF4J的更多信息，请参阅<a href="http://www.slf4j.org/manual.html">其手册</a> 。</p><p>有关LOG4J的更多信息，请参阅log4j手册的<a href="http://logging.apache.org/log4j/1.2/manual.html#defaultInit">Log4j默认初始化过程</a> 。</p><p><a name="sc_troubleshooting"></a></p><h3>故障排除</h3>
<ul>
  <li><em>服务器因文件损坏</em>而无法启动：由于ZooKeeper服务器的事务日志中的某些文件损坏，服务器可能无法读取其数据库并且无法启动。您将在加载ZooKeeper数据库时看到一些IOException。在这种情况下，请确保您的整体中的所有其他服务器都已启动并正常工作。在命令端口上使用“stat”命令查看它们是否运行状况良好。在验证了集合的所有其他服务器都已启动后，您可以继续清理损坏服务器的数据库。删除datadir / version-2和datalogdir / version-2 /中的所有文件。重启服务器。</li>
</ul><p><a name="sc_configuration"></a></p><h3>配置参数</h3><p>ZooKeeper的行为由ZooKeeper配置文件控制。假设磁盘布局相同，则此文件的设计使得构成ZooKeeper服务器的所有服务器都可以使用完全相同的文件。如果服务器使用不同的配置文件，则必须注意确保所有不同配置文件中的服务器列表匹配。</p><h6>注意</h6>
<blockquote><p>在3.5.0及更高版本中，其中一些参数应放在动态配置文件中。如果将它们放在静态配置文件中，ZooKeeper会自动将它们移动到动态配置文件中。有关更多信息，请参阅<a href="zookeeperReconfig.html">动态重新配置</a> 。</p>
</blockquote><p><a name="sc_minimumConfiguration"></a></p><h4>最低配置</h4><p>以下是必须在配置文件中定义的最低配置关键字：</p>
<ul>
  <li><p><em>clientPort</em> ：侦听客户端连接的端口;也就是客户端尝试连接的端口。</p></li>
  <li><p><em>secureClientPort</em> ：使用SSL侦听安全客户端连接的端口。 <strong>clientPort</strong>指定明文连接的端口，而<strong>secureClientPort</strong>指定SSL连接的端口。指定两者都启用混合模式，而忽略将禁用该模式。请注意，当用户将zookeeper.serverCnxnFactory，zookeeper.clientCnxnSocket作为Netty插件时，将启用SSL功能。</p></li>
  <li><p><em>dataDir</em> ：ZooKeeper将存储内存数据库快照的位置，除非另有说明，否则为数据库更新的事务日志。</p><h6>注意</h6>
  <blockquote><p>放置事务日志的位置要小心。专用的事务日志设备是始终如一的良好性能的关键。将日志置于繁忙的设备上会对性能产生负面影响。</p>
  </blockquote></li>
  <li><p><em>tickTime</em> ：单个tick的长度，是ZooKeeper使用的基本时间单位，以毫秒为单位。它用于调节心跳和超时。例如，最小会话超时将是两个滴答。</p></li>
</ul><p><a name="sc_advancedConfiguration"></a></p><h4>高级配置</h4><p>该部分中的配置设置是可选的。您可以使用它们来进一步微调ZooKeeper服务器的行为。有些也可以使用Java系统属性进行设置，通常采用<em>zookeeper.keyword</em>形式。确切的系统属性（如果可用）如下所示。</p>
<ul>
  <li><p></p><p><em>dataLogDir</em> :(无Java系统属性）此选项将指示计算机将事务日志写入<strong>dataLogDir</strong>而不是<strong>dataDir</strong> 。这允许使用专用的日志设备，并有助于避免日志记录和快照之间的竞争。</p><h6>注意</h6>
  <blockquote>拥有专用的日志设备会对吞吐量和稳定的延迟产生很大影响。强烈建议专用日志设备并将<strong>dataLogDir</strong>设置为指向该设备上的目录，然后确保将<strong>dataDir</strong>指向<em>不</em>驻留在该设备上的目录。
  </blockquote></li>
  <li><p><em>globalOutstandingLimit</em> :( Java系统属性： <strong>zookeeper.globalOutstandingLimit。</strong> ）客户端可以比ZooKeeper更快地提交请求，尤其是在有很多客户端的情况下。为防止ZooKeeper因排队请求而耗尽内存，ZooKeeper将限制客户端，以便系统中只有globalOutstandingLimit未完成的请求。默认限制为1,000。</p></li>
  <li><p><em>preAllocSize</em> :( Java系统属性： <strong>zookeeper.preAllocSize</strong> ）为了避免搜索，ZooKeeper以preAllocSize千字节为单位在事务日志文件中分配空间。默认块大小为64M。更改块大小的一个原因是，如果更频繁地拍摄快照，则减小块大小。（另请参阅<strong>snapCount</strong> ）。</p></li>
  <li><p><em>snapCount</em> :( Java系统属性： <strong>zookeeper.snapCount</strong> ）ZooKeeper使用快照和事务日志记录其事务（想想预写日志）。在拍摄快照之前记录在事务日志中的事务数（以及事务日志已滚动）由snapCount确定。为了防止仲裁中的所有计算机同时拍摄快照，每个ZooKeeper服务器将在事务日志中的事务数达到[snapCount / 2 + 1]中的运行时生成的随机值时拍摄快照，snapCount]范围。默认snapCount为100,000。</p></li>
  <li><p><em>maxClientCnxns</em> :(无Java系统属性）限制由IP地址标识的单个客户端可能对ZooKeeper集合的单个成员进行的并发连接数（在套接字级别）。这用于防止某些类别的DoS攻击，包括文件描述符耗尽。默认值为60。将此值设置为0将完全消除并发连接的限制。</p></li>
  <li><p><em>clientPortAddress</em> ： <strong>3.3.0中的新增内容：</strong>侦听客户端连接的地址（ipv4，ipv6或hostname）;也就是客户端尝试连接的地址。这是可选的，默认情况下我们以这样的方式绑定，即接受服务器上任何地址/接口/ nic的<strong>clientPort的</strong>任何连接。</p></li>
  <li><p><em>minSessionTimeout</em> :(无Java系统属性） <strong>3.3.0中的新增内容：</strong>服务器允许客户端协商的最小会话超时（以毫秒为单位）。默认为<strong>tickTime的</strong> 2倍。</p></li>
  <li><p><em>maxSessionTimeout</em> :(无Java系统属性） <strong>3.3.0中的新增内容：</strong>服务器允许客户端协商的最大会话超时（以毫秒为单位）。默认为<strong>tickTime的</strong> 20倍。</p></li>
  <li><p><em>fsync.warningthresholdms</em> :( Java系统属性： <strong>zookeeper.fsync.warningthresholdms</strong> ） <strong>3.3.4中的新增内容：</strong>只要事务日志（WAL）中的fsync花费的时间超过此值，就会向日志输出警告消息。值以毫秒为单位指定，默认值为1000。此值只能设置为系统属性。</p></li>
  <li><p><em>autopurge.snapRetainCount</em> :(无Java系统属性） <strong>3.4.0中的新增</strong>功能<strong>：</strong>启用后，ZooKeeper自动清除功能分别在<strong>dataDir</strong>和<strong>dataLogDir中</strong>保留<strong>autopurge.snapRetainCount</strong>最新快照和相应的事务日志，并删除其余日志。默认为3。最小值为3。</p></li>
  <li><p><em>autopurge.purgeInterval</em> :(无Java系统属性） <strong>3.4.0中的新增内容：</strong>必须触发清除任务的时间间隔（以小时为单位）。设置为正整数（1和更高）以启用自动清除。默认为0。</p></li>
  <li><p><em>syncEnabled</em> :( Java系统属性： <strong>zookeeper.observer.syncEnabled</strong> ） <em>3.4.6,3.5.0中的</em> <strong>新增内容：</strong>观察者现在默认记录事务并将快照写入磁盘，就像参与者一样。这减少了重启时观察者的恢复时间。设置为“false”以禁用此功能。默认为“true”</p></li>
  <li><p><em>zookeeper.extendedTypesEnabled</em> :(仅限Java系统属性： <strong>zookeeper.extendedTypesEnabled</strong> ） <strong>3.5.4中的新增内容：</strong>定义为“true”以启用扩展功能，例如创建TTL节点。它们默认是禁用的。重要信息：由于内部限制，启用的服务器ID必须小于255。</p></li>
  <li><p><em>zookeeper.emulate353TTLNodes</em> :(仅限Java系统属性： <strong>zookeeper.emulate353TTLNodes</strong> ） <strong>3.5.4中的新功能：</strong>由于ZOOKEEPER-2901，3.5.4 / 3.6.0版不支持在3.5.3版中创建的TTL节点。但是，通过zookeeper.emulate353TTLNodes系统属性提供了一种解决方法。如果您在ZooKeeper 3.5.3中使用了TTL节点，并且除了<strong>zookeeper.extendedTypesEnabled</strong>之外，还需要将兼容性设置<strong>zookeeper.emulate353TTLNodes</strong>设置为“true”。注意：由于该错误，服务器ID必须为127或更少。此外，最大支持TTL值为1099511627775，小于3.5.3（1152921504606846975）中允许的值</p></li>
  <li><p><em>serverCnxnFactory</em> :( Java系统属性： <strong>zookeeper.serverCnxnFactory</strong> ）指定ServerCnxnFactory实现。应将其设置为<code>NettyServerCnxnFactory</code> ，以便使用基于TLS的服务器通信。默认为<code>NIOServerCnxnFactory</code> 。</p></li>
</ul><p><a name="sc_clusterOptions"></a></p><h4>群集选项</h4><p>本节中的选项旨在与服务器集合一起使用 - 即，在部署服务器群集时。</p>
<ul>
  <li><p></p><p><em>electionAlg</em> :(没有Java系统属性）要使用的选举实现。值“1”对应于未经认证的基于UDP的快速领导者选举版本，“2”对应于经认证的基于UDP的快速领导者选举版本，“3”对应于基于TCP的快速领导者选举版本选举。目前，算法3是默认值。</p><h6>注意</h6>
  <blockquote>领导者选举1和2的实施现已<strong>弃用</strong> 。我们打算在下一个版本中删除它们，此时只有FastLeaderElection可用。
  </blockquote></li>
  <li><p><em>initLimit</em> :(无Java系统属性）允许关注者连接并同步到领导者的时间量（以tick为<a href="#id_tickTime">单位</a> ）（请参阅<a href="#id_tickTime">tickTime</a> ）。如果ZooKeeper管理的数据量很大，则根据需要增加此值。</p></li>
  <li><p><em>leaderServes</em> :( Java系统属性：zookeeper。** leaderServes **）Leader接受客户端连接。默认值为“是”。领导者协调更新。为了获得更高的更新吞吐量，只需稍微花费读取吞吐量，就可以将领导者配置为不接受客户端并专注于协调。此选项的默认值为yes，这表示领导者将接受客户端连接。</p><h6>注意</h6>
  <blockquote><p>如果集合中有三个以上的ZooKeeper服务器，强烈建议启用领导者选择。</p>
  </blockquote></li>
  <li><p><em>server.x = [hostname]：nnnnn [：nnnnn]等</em> :(没有Java系统属性）服务器构成ZooKeeper集合。当服务器启动时，它通过在数据目录中查找文件<em>myid</em>来确定它是哪个服务器。该文件包含服务器编号（ASCII），它应与此设置左侧<strong>server.x</strong>中的<strong>x</strong>匹配。组成客户端使用的ZooKeeper服务器的服务器列表必须与每个ZooKeeper服务器所具有的ZooKeeper服务器列表相匹配。有两个端口号<strong>nnnnn</strong> 。第一批追随者用来连接领导者，第二个追随者用于领导者选举。如果要在一台计算机上测试多个服务器，则可以为每个服务器使用不同的端口。</p></li>
  <li><p><em>syncLimit</em> :(无Java系统属性）允许关注者与ZooKeeper同步的时间量（以tick为<a href="#id_tickTime">单位</a> ）（请参阅<a href="#id_tickTime">tickTime</a> ）。如果粉丝落后于领导者，他们就会被淘汰。</p></li>
  <li><p><em>group.x = nnnnn [：nnnnn]</em> :(无Java系统属性）启用分层仲裁构造。“x”是组标识符，“=”符号后面的数字对应于服务器标识符。赋值的左侧是以冒号分隔的服务器标识符列表。请注意，组必须是不相交的，并且所有组的并集必须是ZooKeeper集合。你会<a href="zookeeperHierarchicalQuorums.html">在这里</a>找到一个例子</p></li>
  <li><p><em>weight.x = nnnnn</em> :(无Java系统属性）与“group”一起使用时，它在形成仲裁时为服务器分配权重。这样的值对应于投票时服务器的权重。ZooKeeper的一些部分需要投票，例如领导者选举和原子广播协议。默认情况下，服务器的权重为1。如果配置定义组而不是权重，则将为所有服务器分配值1。你会<a href="zookeeperHierarchicalQuorums.html">在这里</a>找到一个例子</p></li>
  <li><p><em>cnxTimeout</em> :( Java系统属性：zookeeper。** cnxTimeout **）设置打开领导者选举通知连接的超时值。仅适用于您使用electionAlg 3的情况。</p><h6>注意</h6>
  <blockquote><p>默认值为5秒。</p>
  </blockquote></li>
  <li><p><em>standaloneEnabled</em> :(无Java系统属性） <strong>3.5.0中的新功能：</strong>当设置为false时，可以在复制模式下启动单个服务器，单个参与者可以使用观察者运行，并且群集可以重新配置为一个节点，并且从一个节点。对于向后兼容性，默认值为true。可以使用QuorumPeerConfig的setStandaloneEnabled方法或通过将“standaloneEnabled = false”或“standaloneEnabled = true”添加到服务器的配置文件来设置它。</p></li>
  <li><p><em>reconfigEnabled</em> :(无Java系统属性） <strong>3.5.3中的新增功能：</strong>它控制<a href="zookeeperReconfig.html">动态重新配置</a>功能的启用或禁用。启用此功能后，用户可以通过ZooKeeper客户端API或ZooKeeper命令行工具执行重新配置操作，前提是用户有权执行此类操作。禁用此功能后，任何用户（包括超级用户）都无法执行重新配置。任何重新配置的尝试都将返回错误。 <strong>“reconfigEnabled”</strong>选项可以设置为<strong>“reconfigEnabled = false”</strong>或<strong>“reconfigEnabled = true”</strong>到服务器的配置文件，或使用QuorumPeerConfig的setReconfigEnabled方法。默认值为false。如果存在，则该值应该在整个集合中的每个服务器上保持一致。在某些服务器上将值设置为true而在其他服务器上将其设置为false将导致不一致的行为，具体取决于哪个服务器被选为leader。如果领导者的设置为<strong>“reconfigEnabled = true”</strong> ，则整体将启用重新配置功能。如果领导者的设置为<strong>“reconfigEnabled = false”</strong> ，则整体将禁用重新配置功能。因此，建议在整体中的服务器之间具有<strong>“reconfigEnabled”</strong>的一致值。</p></li>
  <li><p><em>4lw.commands.whitelist</em> :( Java系统属性： <strong>zookeeper.4lw.commands.whitelist</strong> ） <strong>3.5.3中的新功能：</strong>用户想要使用的逗号分隔的<a href="#sc_4lw">四字母单词</a>命令列表。必须在此列表中放入有效的Four Letter Words命令，否则ZooKeeper服务器将不启用该命令。默认情况下，白名单仅包含zkServer.sh使用的“srvr”命令。默认情况下，禁用其余的四个字母单词命令。以下是启用stat，ruok，conf和isro命令的配置示例，同时禁用其余的Four Letter Words命令：</p>
  <pre><code>4lw.commands.whitelist = stat，ruok，conf，isro</code></pre></li>
</ul><p>如果您确实需要默认启用所有四个字母单词命令，则可以使用星号选项，这样您就不必在列表中逐个包含每个命令。例如，这将启用所有四个字母单词命令：</p>
<pre><code>4lw.commands.whitelist = *</code></pre>
<ul>
  <li><em>tcpKeepAlive</em> :( Java系统属性： <strong>zookeeper.tcpKeepAlive</strong> ） <strong>3.5.4中的新增内容：</strong>将此设置为true会在仲裁成员用于执行选举的套接字上设置TCP keepAlive标志。这将允许仲裁成员之间的连接在存在可能以其他方式破坏它们的网络基础结构时保持不变。对于长时间运行或空闲连接，某些NAT和防火墙可能会终止或丢失状态。启用此选项依赖于操作系统级别设置才能正常工作，请查看操作系统有关TCP keepalive的选项以获取更多信息。默认为<strong>false</strong> 。</li>
</ul><p><a name="sc_authOptions"></a></p><h4>加密，身份验证，授权选项</h4><p>本节中的选项允许控制服务执行的加密/身份验证/授权。</p>
<ul>
  <li><p><em>DigestAuthenticationProvider.superDigest</em> :( Java系统属性： <strong>zookeeper。DigestAuthenticationProvider.superDigest</strong> ）默认情况下，此功能被<strong>禁用</strong> <strong>3.2中的新</strong>功能<strong>：</strong>允许ZooKeeper集合管理员以“超级”用户身份访问znode层次结构。特别是对于经过身份验证的用户，不会进行ACL检查。 org.apache.zookeeper.server.auth。DigestAuthenticationProvider可用于生成superDigest，使用“super： <password>”参数调用它<password>。<data>在启动整体的每个服务器时，提供生成的“super： <data>”作为系统属性值。当对ZooKeeper服务器（来自ZooKeeper客户端）进行身份验证时，传递“digest”的方案和“super： <password>”的 authdata <password>。请注意，摘要auth以明文形式将authdata传递给服务器，仅在localhost（不是通过网络）或通过加密连接使用此身份验证方法是明智的。</password></data></password></p></li>
  <li><p><em>X509AuthenticationProvider.superUser</em> :( Java系统属性： <strong>zookeeper。X509AuthenticationProvider.superUser</strong> ）支持SSL的方式，使ZooKeeper集合管理员能够以“超级”用户身份访问znode层次结构。当此参数设置为X500主体名称时，只有具有该主体的经过身份验证的客户端才能绕过ACL检查并拥有所有znode的完全权限。</p></li>
  <li><p><em>zookeeper.superUser</em> :( Java系统属性： <strong>zookeeper.superUser</strong> ）与<strong>zookeeper类似<strong>。X509AuthenticationProvider.superUser</strong>但对于基于SASL的登录是通用的。它存储可以作为“超级”用户访问znode层次结构的用户的名称。</p></li>
  <li><p><em>ssl.authProvider</em> :( Java系统属性： <strong>zookeeper.ssl.authProvider</strong> ）指定<strong>org.apache.zookeeper.auth的子类<strong>。X509AuthenticationProvider</strong>用于安全客户端身份验证。这在不使用JKS的证书密钥基础结构中很有用。可能需要扩展<strong>javax.net.ssl。X509KeyManager</strong>和<strong>javax.net.ssl。X509TrustManager</strong>从SSL堆栈中获取所需的行为。要将ZooKeeper服务器配置为使用自定义提供程序进行身份验证，请为自定义AuthenticationProvider选择方案名称，并将属性<strong>zookeeper.authProvider。[scheme]</strong>设置为自定义实现的完全限定类名。这会将提供程序加载到ProviderRegistry中。然后设置此属性<strong>zookeeper.ssl.authProvider = [scheme]</strong> ，该提供程序将用于安全身份验证。</p></li>
  <li><p><em>sslQuorum</em> :( Java系统属性： <strong>zookeeper.sslQuorum</strong> ） <strong>3.5.5中的新增功能：</strong>启用加密的仲裁通信。默认值为<code>false</code> 。</p></li>
  <li><p><em>ssl.keyStore.location和ssl.keyStore.password</em>和<em>ssl.quorum.keyStore.location</em>和<em>ssl.quorum.keyStore.password</em> :( Java系统属性： <strong>zookeeper.ssl.keyStore.location</strong>和<strong>zookeeper.ssl.keyStore.password</strong>和<strong>zookeeper .ssl.quorum.keyStore.location</strong>和<strong>zookeeper.ssl.quorum.keyStore.password</strong> ） <strong>3.5.5中的新增内容：</strong>指定Java密钥库的文件路径，该密钥库包含用于客户端和仲裁TLS连接的本地凭据以及密码解锁文件。</p></li>
  <li><p><em>ssl.keyStore.type</em>和<em>ssl.quorum.keyStore.type</em> :( Java系统属性： <strong>zookeeper.ssl.keyStore.type</strong>和<strong>zookeeper.ssl.quorum.keyStore.type</strong> ） <strong>3.5.5中的新增内容：</strong>指定客户端的文件格式和仲裁密钥库。值：JKS，PEM或null（通过文件名检测）。<br>默认值：null</p></li>
  <li><p><em>ssl.trustStore.location</em>和<em>ssl.trustStore.password</em>和<em>ssl.quorum.trustStore.location</em>和<em>ssl.quorum.trustStore.password</em> :( Java系统属性： <strong>zookeeper.ssl.trustStore.location</strong>和<strong>zookeeper.ssl.trustStore.password</strong>和<strong>zookeeper .ssl.quorum.trustStore.location</strong>和<strong>zookeeper.ssl.quorum.trustStore.password</strong> ） <strong>3.5.5中的新增内容：</strong>指定Java信任库的文件路径，该信任库包含用于客户端和仲裁TLS连接的远程凭据以及密码解锁文件。</p></li>
  <li><p><em>ssl.trustStore.type</em>和<em>ssl.quorum.trustStore.type</em> :( Java系统属性： <strong>zookeeper.ssl.trustStore.type</strong>和<strong>zookeeper.ssl.quorum.trustStore.type</strong> ） <strong>3.5.5中的新增内容：</strong>指定客户端的文件格式和仲裁信任商店。值：JKS，PEM或null（通过文件名检测）。<br>默认值：null</p></li>
  <li><p><em>ssl.protocol</em>和<em>ssl.quorum.protocol</em> :( Java系统属性： <strong>zookeeper.ssl.protocol</strong>和<strong>zookeeper.ssl.quorum.protocol</strong> ） <strong>3.5.5中的新增内容：</strong>指定要在客户端和仲裁TLS协商中使用的协议。默认值：TLSv1.2</p></li>
  <li><p><em>ssl.enabledProtocols</em>和<em>ssl.quorum.enabledProtocols</em> :( Java系统属性： <strong>zookeeper.ssl.enabledProtocols</strong>和<strong>zookeeper.ssl.quorum.enabledProtocols</strong> ） <strong>3.5.5中的新增</strong>功能<strong>：</strong>指定客户端和仲裁TLS协商中启用的协议。默认值： <code>protocol</code>属性的值</p></li>
  <li><p><em>ssl.ciphersuites</em>和<em>ssl.quorum.ciphersuites</em> :( Java系统属性： <strong>zookeeper.ssl.ciphersuites</strong>和<strong>zookeeper.ssl.quorum.ciphersuites</strong> ） <strong>3.5.5中的新增内容：</strong>指定要在客户端和仲裁TLS协商中使用的已启用密码套件。默认值：启用的密码套件取决于所使用的Java运行时版本。</p></li>
  <li><p><em>ssl.context.supplier.class</em>和<em>ssl.quorum.context.supplier.class</em> :( Java系统属性： <strong>zookeeper.ssl.context.supplier.class</strong>和<strong>zookeeper.ssl.quorum.context.supplier.class</strong> ） <strong>3.5.5中的新功能：</strong>指定用于在客户端和仲裁SSL通信中创建SSL上下文的类。这允许您使用自定义SSL上下文并实现以下方案：</p>
  <ol>
    <li>使用硬件密钥库，使用PKCS11或类似的东西加载。</li>
    <li>您无权访问软件密钥库，但可以从其容器中检索已构建的SSLContext。默认值：null</li>
  </ol></li>
  <li><p><em>ssl.hostnameVerification</em>和<em>ssl.quorum.hostnameVerification</em> :( Java系统属性： <strong>zookeeper.ssl.hostnameVerification</strong>和<strong>zookeeper.ssl.quorum.hostnameVerification</strong> ） <strong>3.5.5中的新增内容：</strong>指定是否在客户端和仲裁TLS协商过程中启用主机名验证。禁用它仅建议用于测试目的。默认值：true</p></li>
  <li><p><em>ssl.crl</em>和<em>ssl.quorum.crl</em> :( Java系统属性： <strong>zookeeper.ssl.crl</strong>和<strong>zookeeper.ssl.quorum.crl</strong> ） <strong>3.5.5中的新增功能：</strong>指定是否在客户端和仲裁TLS协议中启用证书吊销列表。默认值：false</p></li>
  <li><p><em>ssl.ocsp</em>和<em>ssl.quorum.ocsp</em> :( Java系统属性： <strong>zookeeper.ssl.ocsp</strong>和<strong>zookeeper.ssl.quorum.ocsp</strong> ） <strong>3.5.5中的新增内容：</strong>指定是否在客户端和仲裁TLS协议中启用联机证书状态协议。默认值：false</p></li>
  <li><p><em>ssl.clientAuth</em>和<em>ssl.quorum.clientAuth</em> :( Java系统属性： <strong>zookeeper.ssl.clientAuth</strong>和<strong>zookeeper.ssl.quorum.clientAuth</strong> ） <strong>3.5.5中的新功能：</strong>待定</p></li>
  <li><p><em>ssl.handshakeDetectionTimeoutMillis</em>和<em>ssl.quorum.handshakeDetectionTimeoutMillis</em> :( Java系统属性： <strong>zookeeper.ssl.handshakeDetectionTimeoutMillis</strong>和<strong>zookeeper.ssl.quorum.handshakeDetectionTimeoutMillis</strong> ） <strong>3.5.5中新增：</strong> TBD</p></li>
</ul><p><a name="Experimental+Options%2FFeatures"></a></p><h4>实验选项/功能</h4><p>目前被认为是实验性的新功能。</p>
<ul>
  <li><em>只读模式服务器</em> ：（Java系统属性： <strong>readonlymode.enabled</strong> ） <strong>3.4.0中的新增内容：</strong>将此值设置为true将启用只读模式服务器支持（默认情况下禁用）。即使服务器可能与仲裁分区，ROM也允许请求ROM支持的客户端会话连接到服务器。在此模式下，ROM客户端仍然可以从ZK服务读取值，但无法写入值并查看其他客户端的更改。有关详细信息，请参阅ZOOKEEPER-784。</li>
</ul><p><a name="Unsafe+Options"></a></p><h4>不安全的选择</h4><p>以下选项可能很有用，但在使用它们时要小心。解释每个的风险以及变量的作用的解释。</p>
<ul>
  <li><p><em>forceSync</em> :( Java系统属性： <strong>zookeeper.forceSync</strong> ）要求在完成更新处理之前将更新同步到事务日志的介质。如果此选项设置为no，则ZooKeeper不需要将更新同步到媒体。</p></li>
  <li><p><em>jute.maxbuffer :</em> :（Java系统属性：** jute.maxbuffer **）此选项只能设置为Java系统属性。它上面没有zookeeper前缀。它指定可以存储在znode中的数据的最大大小。默认值为0xfffff，或者仅为1M。如果更改此选项，则必须在所有服务器和客户端上设置系统属性，否则将出现问题。这真是一个健全检查。ZooKeeper旨在存储大小为千字节的数据。</p></li>
  <li><p><em>skipACL</em> :( Java系统属性： <strong>zookeeper.skipACL</strong> ）跳过ACL检查。这样可以提高吞吐量，但可以向所有人开放对数据树的完全访问权限。</p></li>
  <li><p><em>quorumListenOnAllIPs</em> ：当设置为true时，ZooKeeper服务器将在所有可用IP地址上侦听来自其对等方的连接，而不仅是在配置文件的服务器列表中配置的地址。它会影响处理ZAB协议和快速领导者选举协议的连接。默认值为<strong>false</strong> 。</p></li>
</ul><p><a name="Disabling+data+directory+autocreation"></a></p><h4>禁用数据目录自动创建</h4><p><strong>3.5中的新功能：</strong> ZooKeeper服务器的默认行为是，如果该目录尚不存在，则在启动时自动创建数据目录（在配置文件中指定）。在某些情况下，这可能是不方便的甚至是危险的。<strong>假设</strong>对正在运行的服务器进行配置更改，其中<strong>dataDir</strong>参数被意外更改。当ZooKeeper服务器重新启动时，它将创建这个不存在的目录并开始服务 - 使用空的znode命名空间。这种情况可能导致有效的“裂脑”情况（即新的无效目录和原始有效数据存储中的数据）。因此，可以选择关闭此自动创建行为。通常，对于生产环境，这应该是完成的，但不幸的是，此时无法更改默认的遗留行为，因此必须根据具体情况进行此操作。这留给了用户和ZooKeeper发行版的打包者。</p><p>运行<strong>zkServer.sh时，</strong>可以通过将环境变量<strong>ZOO_DATADIR_AUTOCREATE_DISABLE</strong>设置为1来禁用autocreate。直接从类文件运行ZooKeeper服务器时，可以通过在java命令行上设置<strong>zookeeper.datadir.autocreate = false</strong>来完成，即<strong>-Dzookeeper.datadir.autocreate = false</strong></p><p>禁用此功能后，ZooKeeper服务器确定所需的目录不存在，它将生成错误并拒绝启动。</p><p>提供了一个新脚本<strong>zkServer-initialize.sh</strong>来支持此新功能。如果禁用autocreate，则用户必须首先安装ZooKeeper，然后创建数据目录（可能还有txnlog目录），然后启动服务器。否则如前一段所述，服务器将无法启动。运行<strong>zkServer-initialize.sh</strong>将创建所需的目录，并可选择设置myid文件（可选的命令行参数）。即使未使用自动创建功能本身也可以使用此脚本，并且可能对用户有用，因为这（过去，包括创建myid文件）一直是用户的问题。请注意，此脚本仅确保数据目录存在，它不会创建配置文件，而是需要配置文件才能执行。</p><p><a name="sc_performance_options"></a></p><h4>性能调整选项</h4><p><strong>3.5.0中的新功能：</strong>重新设计了几个子系统以提高读取吞吐量。这包括NIO通信子系统和请求处理管道（提交处理器）的多线程。NIO是默认的客户端/服务器通信子系统。它的线程模型包括1个接受线程，1-N选择器线程和0-M套接字I / O工作线程。在请求处理流水线中，系统可以配置为一次处理多个读取请求，同时保持相同的一致性保证（同一会话后读写）。提交处理器线程模型包括1个主线程和0-N工作线程。</p><p>默认值旨在最大化专用ZooKeeper机器上的读取吞吐量。两个子系统都需要有足够的线程来实现峰值读取吞吐量。</p>
<ul>
  <li><p><em>zookeeper.nio.numSelectorThreads</em> :(仅限Java系统属性： <strong>zookeeper.nio.numSelectorThreads</strong> ） <strong>3.5.0中的新增内容：</strong> NIO选择器线程数。至少需要1个选择器线程。建议为大量客户端连接使用多个选择器。默认值为sqrt（cpu核心数/ 2）。</p></li>
  <li><p><em>zookeeper.nio.numWorkerThreads</em> :(仅限Java系统属性： <strong>zookeeper.nio.numWorkerThreads</strong> ） <strong>3.5.0中新增：</strong> NIO工作线程数。如果配置了0个工作线程，则选择器线程直接执行套接字I / O.默认值是cpu核心数的2倍。</p></li>
  <li><p><em>zookeeper.commitProcessor.numWorkerThreads</em> :(仅限Java系统属性： <strong>zookeeper.commitProcessor.numWorkerThreads</strong> ） <strong>3.5.0中新增：</strong>提交处理器工作线程数。如果配置了0个工作线程，主线程将直接处理请求。默认值是cpu核心数。</p></li>
  <li><p><em>znode.container.checkIntervalMs</em> :(仅限Java系统属性） <strong>3.5.1中的新增内容：</strong>候选容器和ttl节点的每次检查的时间间隔（以毫秒为单位）。默认值为“60000”。</p></li>
  <li><p><em>znode.container.maxPerMinute</em> :(仅限Java系统属性） <strong>3.5.1中的新增内容：</strong>每分钟可删除的最大容器和ttl节点数。这可以防止在容器删除期间放牧。默认值为“10000”。</p></li>
</ul><p><a name="sc_adminserver_config"></a></p><h4>AdminServer配置</h4><p><strong>3.5.0中的新增功能：</strong>以下选项用于配置<a href="#sc_adminserver">AdminServer</a> 。</p>
<ul>
  <li><p><em>admin.enableServer</em> :( Java系统属性： <strong>zookeeper.admin.enableServer</strong> ）设置为“false”以禁用AdminServer。默认情况下，AdminServer已启用。</p></li>
  <li><p><em>admin.serverAddress</em> :( Java系统属性： <strong>zookeeper.admin.serverAddress</strong> ）嵌入式Jetty服务器侦听的地址。默认为0.0.0.0。</p></li>
  <li><p><em>admin.serverPort</em> :( Java系统属性： <strong>zookeeper.admin.serverPort</strong> ）嵌入式Jetty服务器侦听的端口。默认为8080。</p></li>
  <li><p><em>admin.idleTimeout</em> :( Java系统属性： <strong>zookeeper.admin.idleTimeout</strong> ）设置连接在发送或接收数据之前可以等待的最长空闲时间（以毫秒为单位）。默认为30000毫秒。</p></li>
  <li><p><em>admin.commandURL</em> :( Java系统属性： <strong>zookeeper.admin.commandURL</strong> ）用于列出和发出相对于根URL的命令的URL。默认为“/ commands”。</p></li>
</ul><p><a name="Communication+using+the+Netty+framework"></a></p><h3>使用Netty框架进行通信</h3><p><a href="http://netty.io">Netty</a>是一个基于NIO的客户端/服务器通信框架，它简化了（通过NIO直接使用）许多Java应用程序的网络级通信的复杂性。此外，Netty框架内置了对加密（SSL）和身份验证（证书）的支持。这些是可选功能，可以单独打开或关闭。</p><p>在版本3.5+中，ZooKeeper服务器可以通过将环境变量<strong>zookeeper.serverCnxnFactory</strong>设置为<strong>org.apache.zookeeper.server.NettyServerCnxnFactory</strong>来使用Netty而不是NIO（默认选项）;对于客户端，将<strong>zookeeper.clientCnxnSocket</strong>设置为<strong>org.apache.zookeeper。ClientCnxnSocketNetty</strong> 。</p><p>TBD  -  netty的调整选项 - 目前没有netty特定的，但我们应该添加一些。Esp围绕netty创建的读者工作线程数量的最大界限。</p><p><a name="Quorum+TLS"></a></p><h4>法定人数TLS</h4><p><em>3.5.5中的新功能</em></p><p>基于Netty框架，ZooKeeper集合可以设置为在其通信通道中使用TLS加密。本节介绍如何在仲裁通信上设置加密。</p><p>请注意，Quorum TLS封装了保护领导者选举和仲裁通信协议的安全性。</p>
<ol>
  <li>创建SSL密钥库JKS以存储本地凭据</li>
</ol><p>应为每个ZK实例创建一个密钥库。</p><p>在此示例中，我们生成一个自签名证书，并将其与私钥一起存储在<code>keystore.jks</code> 。这适用于测试目的，但您可能需要官方证书才能在生产环境中签署密钥。</p><p>请注意，别名（ <code>-alias</code> ）和可分辨名称（ <code>-dname</code> ）必须与相关联的计算机的主机名匹配，否则主机名验证将不起作用。</p>
<pre><code>keytool -genkeypair -alias $（hostname -f）-keyalg RSA -keysize 2048 -dname“cn = $（hostname -f）” -  keypass password -keystore keystore.jks -storepass password</code></pre>
<ol>
  <li>从密钥库中提取签名的公钥（证书）</li>
</ol><p><em>此步骤可能仅适用于自签名证书。</em></p>
<pre><code>keytool -exportcert -alias $（hostname -f）-keystore keystore.jks -file $（hostname -f）.cer -rfc</code></pre>
<ol>
  <li>创建包含所有ZooKeeper实例的证书的SSL信任库JKS</li>
</ol><p>应该在集合的参与者上共享相同的信任库（存储所有接受的证书）。您需要使用不同的别名在同一个信任库中存储多个证书。别名的名称无关紧要。</p>
<pre><code>keytool -importcert -alias [host1..3] -file [host1..3] .cer -keystore truststore.jks -storepass password</code></pre>
<ol>
  <li>您需要使用<code>NettyServerCnxnFactory</code>作为serverCnxnFactory，因为NIO不支持SSL。将以下配置设置添加到<code>zoo.cfg</code>配置文件中：</li>
</ol>
<pre><code>sslQuorum = true serverCnxnFactory = org.apache.zookeeper.server.NettyServerCnxnFactory ssl.quorum.keyStore.location = / path / to / keystore.jks ssl.quorum.keyStore.password = password ssl.quorum.trustStore.location = / path / to / truststore.jks ssl.quorum.trustStore.password = password</code></pre>
<ol>
  <li>在日志中验证您的集合在TLS上运行：</li>
</ol>
<pre><code>INFO [main：QuorumPeer @ 1789]  - 使用TLS加密的仲裁通信INFO [main：QuorumPeer @ 1797]  - 禁用端口统一...INFO [QuorumPeerListener：QuorumCnxManager $ Listener @ 877]  - 创建仅限TLS的仲裁服务器套接字</code></pre><p><a name="Upgrading+existing+nonTLS+cluster"></a></p><h4>升级现有的非TLS群集，无需停机</h4><p><em>3.5.5中的新功能</em></p><p>以下是利用端口统一功能将已经运行的ZooKeeper集合升级到TLS而无需停机所需的步骤。</p>
<ol>
  <li><p>如上一节所述，为所有ZK参与者创建必要的密钥库和信任库</p></li>
  <li><p>添加以下配置设置并重新启动第一个节点</p></li>
</ol>
<pre><code>sslQuorum = false portUnification = true serverCnxnFactory = org.apache.zookeeper.server.NettyServerCnxnFactory ssl.quorum.keyStore.location = / path / to / keystore.jks ssl.quorum.keyStore.password = password ssl.quorum.trustStore.location = /path/to/truststore.jks ssl.quorum.trustStore.password = password</code></pre><p>请注意，尚未启用TLS，但我们打开端口统一。</p>
<ol>
  <li>在其余节点上重复步骤＃2。验证您是否在日志中看到以下条目：</li>
</ol>
<pre><code>INFO [main：QuorumPeer @ 1791]  - 使用不安全（非TLS）仲裁通信INFO [main：QuorumPeer @ 1797]  - 启用端口统一...INFO [QuorumPeerListener：QuorumCnxManager $ Listener @ 874]  - 创建启用TLS的仲裁服务器套接字</code></pre><p>您还应该在每个节点重新启动后仔细检查以使仲裁再次变为健康状态。</p>
<ol>
  <li>在每个节点上启用Quorum TLS并执行滚动重新启动：</li>
</ol>
<pre><code>sslQuorum = true portUnification = true</code></pre>
<ol>
  <li>一旦验证了整个集合在TLS上运行，就可以禁用端口统一并再次进行滚动重启</li>
</ol>
<pre><code>sslQuorum = true portUnification = false</code></pre><p><a name="sc_zkCommands"></a></p><h3>ZooKeeper命令</h3><p><a name="sc_4lw"></a></p><h4>四字母词</h4><p>ZooKeeper响应一小组命令。每个命令由四个字母组成。您可以通过telnet或nc在客户端端口向ZooKeeper发出命令。</p><p>三个更有趣的命令：“stat”给出了关于服务器和连接客户端的一些一般信息，而“srvr”和“cons”分别给出了服务器和连接的扩展细节。</p><p><strong>3.5.3中的新功能：</strong>使用前需要明确列出四个字母单词。有关详细信息，请参阅<a href="#sc_clusterOptions">群集配置部分中</a>描述的<strong>4lw.commands.whitelist</strong> 。继续前进，不推荐使用Four Letter Words，请改用<a href="#sc_adminserver">AdminServer</a> 。</p>
<ul>
  <li><p><em>conf</em> ： <strong>3.3.0中的新功能：</strong>打印有关服务配置的详细信息。</p></li>
  <li><p><em>缺点</em> ： <strong>3.3.0中的新功能：</strong>列出连接到此服务器的所有客户端的完整连接/会话详细信息。包括有关接收/发送的数据包数量，会话ID，操作延迟，上次执行的操作等信息...</p></li>
  <li><p><em>crst</em> ： <strong>3.3.0中的新功能：</strong>重置所有连接的连接/会话统计信息。</p></li>
  <li><p><em>dump</em> ：列出未完成的会话和临时节点。这只适用于领导者。</p></li>
  <li><p><em>envi</em> ：打印有关服务环境的详细信息</p></li>
  <li><p><em>ruok</em> ：测试服务器是否在非错误状态下运行。如果正在运行，服务器将使用imok响应。否则它根本不会响应。“imok”的响应不一定表示服务器已加入仲裁，只是服务器进程处于活动状态并绑定到指定的客户端端口。有关状态wrt仲裁和客户端连接信息的详细信息，请使用“stat”。</p></li>
  <li><p><em>srst</em> ：重置服务器统计信息。</p></li>
  <li><p><em>srvr</em> ： <strong>3.3.0中的新功能：</strong>列出服务器的完整详细信息。</p></li>
  <li><p><em>stat</em> ：列出服务器和连接客户端的简要详细信息。</p></li>
  <li><p><em>wchs</em> ： <strong>3.3.0中的新功能：</strong>列出服务器手表的简要信息。</p></li>
  <li><p><em>wchc</em> ： <strong>3.3.0中的新功能：</strong>按会话列出服务器<em>监视的</em>详细信息。这将输出与相关监视（路径）的会话（连接）列表。请注意，根据手表的数量，此操作可能很昂贵（即影响服务器性能），请谨慎使用。</p></li>
  <li><p><em>dirs</em> ： <strong>3.5.1中的新增功能：</strong>显示快照和日志文件的总大小（以字节为单位）</p></li>
  <li><p><em>wchp</em> ： <strong>3.3.0中的新功能：</strong>按路径列出服务器<em>监视的</em>详细信息。这将输出一个包含相关会话的路径列表（znodes）。请注意，根据手表的数量，此操作可能很昂贵（即影响服务器性能），请谨慎使用。</p></li>
  <li><p><em>mntr</em> ： <strong>3.4.0中的新增内容：</strong>输出可用于监视群集运行状况的变量列表。</p></li>
</ul>
<pre><code>$ echo mntr | NC本地主机2185 zk_version 3.4.0 zk_avg_latency 0 zk_max_latency 0 zk_min_latency 0 zk_packets_received 70 zk_packets_sent 69个zk_num_alive_connections 1个zk_outstanding_requests 0 zk_server_state前导zk_znode_count 4个zk_watch_count 0 zk_ephemerals_count 0 zk_approximate_data_size 27 zk_followers 4  - 仅由组长zk_pending_syncs 0暴露 - 仅由组长zk_synced_followers 4露出 - 仅由领导者zk_open_file_descriptor_count 23公开 - 仅在Unix平台上可用zk_max_file_descriptor_count 1024  - 仅在Unix平台上可用zk_last_proposal_size 23 zk_min_proposal_size 23 zk_max_proposal_size 64</code></pre><p>输出与java属性格式兼容，内容可能随时间而变化（添加了新的键）。您的脚本应该预期更改。注意：某些键是特定于平台的，而某些键仅由Leader导出。输出包含多行，格式如下：</p>
<pre><code>key \ t value</code></pre>
<ul>
  <li><p><em>isro</em> ： <strong>3.4.0中的新增功能：</strong>测试服务器是否以只读模式运行。如果处于只读模式，服务器将以“ro”响应，如果不处于只读模式，则响应“rw”。</p></li>
  <li><p><em>gtmk</em> ：以十进制格式获取当前跟踪掩码为64位有符号长<em>整型</em>值。有关可能值的说明，请参阅<code>stmk</code> 。</p></li>
  <li><p><em>stmk</em> ：设置当前的跟踪掩码。跟踪掩码是64位，其中每个位启用或禁用服务器上特定类别的跟踪日志记录。必须将Log4J配置为首先启用<code>TRACE</code>级别才能查看跟踪日志记录消息。跟踪掩码的位对应于以下跟踪日志记录类别。</p>
  <table>
    <thead>
      <tr>
        <th>跟踪掩码位值</th>
        <th> </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0b0000000000</td>
        <td>未使用，留作将来使用。</td>
      </tr>
      <tr>
        <td>0b0000000010</td>
        <td>记录客户端请求，不包括ping请求。</td>
      </tr>
      <tr>
        <td>0b0000000100</td>
        <td>未使用，留作将来使用。</td>
      </tr>
      <tr>
        <td>0b0000001000</td>
        <td>记录客户端ping请求。</td>
      </tr>
      <tr>
        <td>0b0000010000</td>
        <td>记录从作为当前领导者的仲裁对等方接收的数据包，不包括ping请求。</td>
      </tr>
      <tr>
        <td>0b0000100000</td>
        <td>记录客户端会话的添加，删除和验证。</td>
      </tr>
      <tr>
        <td>0b0001000000</td>
        <td>将监视事件的传递记录到客户端会话。</td>
      </tr>
      <tr>
        <td>0b0010000000</td>
        <td>记录从作为当前领导者的仲裁对等方接收的数据包。</td>
      </tr>
      <tr>
        <td>0b0100000000</td>
        <td>未使用，留作将来使用。</td>
      </tr>
      <tr>
        <td>0b1000000000</td>
        <td>未使用，留作将来使用。</td>
      </tr>
    </tbody>
  </table><p>64位值中的所有剩余位未使用，并保留供将来使用。通过计算记录值的按位OR来指定多个跟踪日志记录类别。默认跟踪掩码为0b0100110010。因此，默认情况下，跟踪日志记录包括客户端请求，从领导者和会话接收的数据包。要设置不同的跟踪掩码，请发送包含<code>stmk</code>四字母单词的请求，后跟表示为64位有符号长<code>stmk</code>的跟踪掩码。此示例使用Perl <code>pack</code>函数构造跟踪掩码，该掩码启用上述所有跟踪日志记录类别，并将其转换为具有big-endian字节顺序的64位带符号long值。结果附加到<code>stmk</code>并使用netcat发送到服务器。服务器以十进制格式响应新的跟踪掩码。</p></li>
</ul>
<pre><code>$ perl -e“print'stmk'，pack（'q&gt;'，0b0011111010）”| nc localhost 2181 250</code></pre><p>这是<strong>ruok</strong>命令的一个例子：</p>
<pre><code>$ echo ruok | nc 127.0.0.1 5111 imok</code></pre><p><a name="sc_adminserver"></a></p><h4>AdminServer</h4><p><strong>3.5.0中的新增功能：</strong> AdminServer是一个嵌入式Jetty服务器，它为四个字母的单词命令提供HTTP接口。默认情况下，服务器在端口8080上启动，并通过转到URL“/ commands / [command name]”发出命令，例如http：// localhost：8080 / commands / stat。命令响应以JSON形式返回。与原始协议不同，命令不限于四个字母的名称，命令可以有多个名称;例如，“stmk”也可以称为“set_trace_mask”。要查看所有可用命令的列表，请将浏览器指向URL /命令（例如，http：// localhost：8080 / commands）。有关如何更改端口和URL的信息，请参阅<a href="#sc_adminserver_config">AdminServer配置选项</a> 。</p><p>AdminServer默认启用，但可以通过以下任一方式禁用：</p>
<ul>
  <li>将zookeeper.admin.enableServer系统属性设置为false。</li>
  <li>从类路径中删除Jetty。（如果要覆盖ZooKeeper的jetty依赖项，此选项很有用。）</li>
</ul><p>请注意，如果禁用AdminServer，则TCP四字母字界面仍可用。</p><p><a name="sc_dataFileManagement"></a></p><h3>数据文件管理</h3><p>ZooKeeper将其数据存储在数据目录中，将其事务日志存储在事务日志目录中。默认情况下，这两个目录是相同的。服务器可以（并且应该）配置为将事务日志文件存储在与数据文件不同的目录中。当事务日志驻留在专用日志设备上时，吞吐量增加和延迟减少。</p><p><a name="The+Data+Directory"></a></p><h4>数据目录</h4><p>该目录中有两个或三个文件：</p>
<ul>
  <li><em>myid</em> - 包含人类可读ASCII文本中的单个整数，表示服务器ID。</li>
  <li><em>initialize</em> -  presence表示预计缺少数据树。创建数据树后清理。</li>
  <li><em>快照。 <zxid></zxid></em> - 保存数据树的模糊快照。</li>
</ul><p>每个ZooKeeper服务器都有一个唯一的id。此id用于两个位置： <em>myid</em>文件和配置文件。<em>myid</em>文件标识与给定数据目录对应的服务器。配置文件列出了由其服务器标识标识的每个服务器的联系信息。当ZooKeeper服务器实例启动时，它从<em>myid</em>文件读取其id，然后使用该id从配置文件中读取，查找它应该监听的端口。</p><p>存储在数据目录中的<em>快照</em>文件是模糊快照，因为在ZooKeeper服务器拍摄快照期间，数据树正在进行更新。<em>快照</em>文件名的后缀是<em>快照</em>开始时最后提交的事务的<em>zxid</em> （ZooKeeper事务标识）。因此，快照包括在快照处理期间发生的数据树更新的子集。然后，快照可能与实际存在的任何数据树不对应，因此我们将其称为模糊快照。尽管如此，ZooKeeper仍然可以使用此快照进行恢复，因为它利用了其更新的幂等特性。通过针对模糊快照重放事务日志，ZooKeeper在日志结束时获取系统的状态。</p><p><a name="The+Log+Directory"></a></p><h4>日志目录</h4><p>日志目录包含ZooKeeper事务日志。在进行任何更新之前，ZooKeeper确保将表示更新的事务写入非易失性存储。当写入当前日志文件的事务数达到（可变）阈值时，将启动新的日志文件。使用影响快照频率的相同参数计算阈值（请参阅上面的snapCount）。日志文件的后缀是写入该日志的第一个zxid。</p><p><a name="sc_filemanagement"></a></p><h4>文件管理</h4><p>快照和日志文件的格式在独立ZooKeeper服务器和复制的ZooKeeper服务器的不同配置之间不会更改。因此，您可以将这些文件从正在运行的复制ZooKeeper服务器提取到具有独立ZooKeeper服务器的开发计算机，以便进行故障排除。</p><p>使用较旧的日志和快照文件，您可以查看ZooKeeper服务器的先前状态，甚至还原该状态。LogFormatter类允许管理员查看日志中的事务。</p><p>ZooKeeper服务器创建快照和日志文件，但从不删除它们。数据和日志文件的保留策略在ZooKeeper服务器之外实现。服务器本身只需要最新的完整模糊快照，其后面的所有日志文件以及它之前的最后一个日志文件。后一个要求必须包括在此快照启动后发生但当时进入现有日志文件的更新。这是可能的，因为在ZooKeeper中，日志的快照和滚动有些独立。有关设置保留策略和维护ZooKeeper存储的更多详细信息，请参阅本文档中的<a href="#sc_maintenance">维护</a>部分。</p><h6>注意</h6>
<blockquote><p>存储在这些文件中的数据未加密。在ZooKeeper中存储敏感数据的情况下，需要采取必要的措施来防止未经授权的访问。这些措施在ZooKeeper外部（例如，控制对文件的访问），并取决于部署它的各个设置。</p>
</blockquote><p><a name="Recovery+-+TxnLogToolkit"></a></p><h4>恢复 -  TxnLogToolkit</h4><p>TxnLogToolkit是ZooKeeper附带的命令行工具，它能够恢复CRC损坏的事务日志条目。</p><p>在没有任何命令行参数或<code>-h,--help</code>参数的情况下运行它，它会输出以下帮助页面：</p>
<pre><code>$ bin / zkTxnLogToolkit.sh用法：TxnLogToolkit [-dhrv] txn_log_file_name -d， - 转储转储模式。转储日志文件的所有条目。 （这是默认设置）-h， -  help打印帮助消息-r， - 恢复恢复模式。重新计算已损坏条目的CRC。-v， -  verbose在恢复模式下要详细：打印所有条目，而不仅仅是固定条目。-y， -  yes非交互模式：修复所有CRC错误而不询问</code></pre><p>默认行为是安全的：它将给定事务日志文件的条目转储到屏幕:(与使用<code>-d,--dump</code>参数相同）</p>
<pre><code>$ bin / zkTxnLogToolkit.sh log.100000001带有dbid的ZooKeeper事务日志文件0 txnlog格式版本2 4/5/18 2:15:58 PM CEST会话0x16295bafcc40000 cxid 0x0 zxid 0x100000001 createSession 30000 CRC ERROR  -  4/5/18 2： 16:05 PM CEST session 0x16295bafcc40000 cxid 0x1 zxid 0x100000002 closeSession null 4/5/18 2:16:05 PM CEST session 0x16295bafcc40000 cxid 0x1 zxid 0x100000002 closeSession null 4/5/18 2:16:12 PM CEST session 0x26295bafcc90000 cxid 0x0 zxid 0x100000003 createSession 30000 4/5/18 2:17:34 PM CEST会话0x26295bafcc90000 cxid 0x0 zxid 0x200000001 closeSession null 4/5/18 2:17:34 PM CEST会话0x16295bd23720000 cxid 0x0 zxid 0x200000002 createSession 30000 4/5/18 2： 18:02 PM CEST会话0x16295bd23720000 cxid 0x2 zxid 0x200000003创建'/ andor，＃626262，v {s {31，s {'world，'anyone}}}，F，1个EOF在6个txns之后达到。
</code></pre><p>上述事务日志文件的第二个条目中存在CRC错误。在<strong>转储</strong>模式下，工具包仅将此信息打印到屏幕而不触及原始文件。在<strong>恢复</strong>模式（ <code>-r,--recover</code>标志）中，原始文件仍保持不变，所有事务将被复制到带有“.fixed”后缀的新txn日志文件。它重新计算CRC值并复制计算值，如果它与原始txn条目不匹配。默认情况下，该工具以交互方式工作：它会在遇到CRC错误时要求确认。</p>
<pre><code>$ bin / zkTxnLogToolkit.sh -r log.100000001带有dbid的ZooKeeper事务日志文件0 txnlog格式版本2 CRC错误 -  4/5/18 2:16:05 PM CEST会话0x16295bafcc40000 cxid 0x1 zxid 0x100000002 closeSession null是否要修复它（是/否/中止）？
</code></pre><p>回答<strong>是</strong>表示新计算的CRC值将输出到新文件。<strong>否</strong>表示将复制原始CRC值。<strong>Abort</strong>将中止整个操作并退出。（在这种情况下，“。fixed”将不会被删除并保持半完成状态：仅包含已处理的条目，或仅包含在第一个条目中中止操作时的标题。）</p>
<pre><code>$ bin / zkTxnLogToolkit.sh -r log.100000001带有dbid的ZooKeeper事务日志文件0 txnlog格式版本2 CRC错误 -  4/5/18 2:16:05 PM CEST会话0x16295bafcc40000 cxid 0x1 zxid 0x100000002 closeSession null是否要修复它（是/否/中止）？在6 txns之后达到了EOF。恢复文件log.100000001.fixed已写入1个固定CRC错误（s）</code></pre><p>恢复的默认行为是静默：只有带有CRC错误的条目才会打印到屏幕上。可以使用<code>-v,--verbose</code>参数打开详细模式以查看所有记录。可以使用<code>-y,--yes</code>参数关闭交互模式。在这种情况下，所有CRC错误都将在新的事务文件中修复。</p><p><a name="sc_commonProblems"></a></p><h3>要避免的事情</h3><p>以下是通过正确配置ZooKeeper可以避免的一些常见问题：</p>
<ul>
  <li><p><em>不一致的服务器</em>列表：客户端使用的ZooKeeper服务器列表必须与每个ZooKeeper服务器所拥有的ZooKeeper服务器列表相匹配。如果客户端列表是真实列表的子集，那么事情就可以了，但如果客户端有一个位于不同ZooKeeper集群中的ZooKeeper服务器列表，事情就会变得很奇怪。此外，每个Zookeeper服务器配置文件中的服务器列表应该彼此一致。</p></li>
  <li><p><em>事务日志的错误放置</em> ：ZooKeeper中性能最关键的部分是事务日志。ZooKeeper在返回响应之前将事务同步到媒体。专用的事务日志设备是始终如一的良好性能的关键。将日志置于繁忙的设备上会对性能产生负面影响。如果您只有一个存储设备，请将跟踪文件放在NFS上并增加snapshotCount;它并没有消除这个问题，但它应该减轻它。</p></li>
  <li><p><em>不正确的Java堆大小</em> ：您应该特别注意正确设置Java最大堆大小。特别是，您不应该创建ZooKeeper交换到磁盘的情况。该磁盘是ZooKeeper的死亡。一切都是有序的，所以如果处理一个请求交换磁盘，所有其他排队的请求可能会做同样的事情。磁盘。不要交换。保守估计：如果你有4G的RAM，不要将Java最大堆大小设置为6G甚至4G。例如，您更有可能将3G堆用于4G计算机，因为操作系统和缓存也需要内存。估计系统所需堆大小的最佳且唯一建议的做法是运行负载测试，然后确保远低于导致系统交换的使用限制。</p></li>
  <li><p><em>可公开访问的部署</em> ：ZooKeeper集合有望在可信计算环境中运行。因此，建议在防火墙后部署ZooKeeper。</p></li>
</ul><p><a name="sc_bestPractices"></a></p><h3>最佳实践</h3><p>为获得最佳结果，请注意以下良好的Zookeeper实践列表：</p><p>对于多租户安装看到<a href="zookeeperProgrammers.html#ch_zkSessions">部分</a>细节的ZooKeeper“chroot环境”的支持，部署很多应用程序/服务的接口，以单一的ZooKeeper集群时，这是非常有用的。</p></div>
<div class="clearboth"> </div>
</div>
<div id="footer">
    <div class="lastmodified">
        <script type="text/javascript">
        <!--
            document.write("Last Published: " + document.lastModified);
        //  -->
        </script>
    </div>
    <div class="copyright">版权所有© <a href="http://www.apache.org/licenses/">Apache Software Foundation。</a>
    </div>
    <div id="logos"></div>
</div>
</body>
</html>