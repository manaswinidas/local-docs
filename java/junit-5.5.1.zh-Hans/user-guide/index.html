<html lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8"></meta>
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
<meta name="generator" content="Asciidoctor 1.5.7.1"></meta>
<meta name="author" content="Stefan Bechtold, Sam Brannen, Johannes Link, Matthias Merdes, Marc Philipp, Christian Stein"></meta>
<title>JUnit 5用户指南</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote::before{display:none}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{word-spacing:0;line-height:1.6}
.quoteblock.abstract blockquote::before,.quoteblock.abstract p::before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<link rel="icon" type="image/png" href="https://junit.org/junit5/assets/img/junit5-logo.png" />
<style>
  /* Tocbot dynamic TOC, works with tocbot 3.0.2 */
  /* Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
    #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
    #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
      padding-left: 0 }
    #tocbot a.toc-link{ height:100% }
    .is-collapsible{ max-height:3000px; overflow:hidden; }
    .is-collapsed{ max-height:0 }
    .is-active-link{ font-weight:700 }
  }
  @media print{
    #tocbot a.toc-link.node-name--H4{ display:none }
  }
</style>
</head>
<body id="user-guide" class="article toc2 toc-left" dir="ltr">
<div id="header">
<h1>JUnit 5用户指南</h1>
<div class="details">
<span id="author" class="author">Stefan Bechtold</span><br>
<span id="author2" class="author">萨姆布兰嫩</span><br>
<span id="author3" class="author">约翰内斯林克</span><br>
<span id="author4" class="author">马蒂亚斯梅德斯</span><br>
<span id="author5" class="author">马克菲利普</span><br>
<span id="author6" class="author">克里斯蒂安斯坦</span><br>
<span id="revnumber">版本5.5.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#overview">1。概观</a>
<ul class="sectlevel2">
<li><a href="#overview-what-is-junit-5">1.1。什么是JUnit 5？</a></li>
<li><a href="#overview-java-versions">1.2。支持的Java版本</a></li>
<li><a href="#overview-getting-help">1.3。获得帮助</a></li>
<li><a href="#overview-getting-started">1.4。入门</a>
<ul class="sectlevel3">
<li><a href="#overview-getting-started-junit-artifacts">1.4.1。下载JUnit工件</a></li>
<li><a href="#overview-getting-started-features">1.4.2。JUnit 5功能</a></li>
<li><a href="#overview-getting-started-example-projects">1.4.3。示例项目</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#writing-tests">2。写测试</a>
<ul class="sectlevel2">
<li><a href="#writing-tests-annotations">2.1。注释</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-meta-annotations">2.1.1。元注释和组合注释</a></li>
</ul>
</li>
<li><a href="#writing-tests-classes-and-methods">2.2。测试类和方法</a></li>
<li><a href="#writing-tests-display-names">2.3。显示名称</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-display-name-generator">2.3.1。显示名称生成器</a></li>
<li><a href="#writing-tests-display-name-generator-default">2.3.2。设置默认显示名称生成器</a></li>
</ul>
</li>
<li><a href="#writing-tests-assertions">2.4。断言</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-assertions-kotlin">2.4.1。Kotlin断言支持</a></li>
<li><a href="#writing-tests-assertions-third-party">2.4.2。第三方断言库</a></li>
</ul>
</li>
<li><a href="#writing-tests-assumptions">2.5。假设</a></li>
<li><a href="#writing-tests-disabling">2.6。禁用测试</a></li>
<li><a href="#writing-tests-conditional-execution">2.7。条件测试执行</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-conditional-execution-os">2.7.1。操作系统条件</a></li>
<li><a href="#writing-tests-conditional-execution-jre">2.7.2。Java运行时环境条件</a></li>
<li><a href="#writing-tests-conditional-execution-system-properties">2.7.3。系统属性条件</a></li>
<li><a href="#writing-tests-conditional-execution-environment-variables">2.7.4。环境可变条件</a></li>
<li><a href="#writing-tests-conditional-execution-scripts">2.7.5。基于脚本的条件</a>
<ul class="sectlevel4">
<li><a href="#writing-tests-conditional-execution-scripts-bindings">脚本绑定</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#writing-tests-tagging-and-filtering">2.8。标记和过滤</a>
<ul class="sectlevel3">
<li><a href="#syntax-rules-for-tags">2.8.1。标签的语法规则</a></li>
</ul>
</li>
<li><a href="#writing-tests-test-execution-order">2.9。测试执行顺序</a></li>
<li><a href="#writing-tests-test-instance-lifecycle">2.10。测试实例生命周期</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-test-instance-lifecycle-changing-default">2.10.1。更改默认测试实例生命周期</a></li>
</ul>
</li>
<li><a href="#writing-tests-nested">2.11。嵌套测试</a></li>
<li><a href="#writing-tests-dependency-injection">2.12。构造函数和方法的依赖注入</a></li>
<li><a href="#writing-tests-test-interfaces-and-default-methods">2.13。测试接口和默认方法</a></li>
<li><a href="#writing-tests-repeated-tests">2.14。重复测试</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-repeated-tests-examples">2.14.1。重复测试示例</a></li>
</ul>
</li>
<li><a href="#writing-tests-parameterized-tests">2.15。参数化测试</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-parameterized-tests-setup">2.15.1。必需的设置</a></li>
<li><a href="#writing-tests-parameterized-tests-consuming-arguments">2.15.2。消费论据</a></li>
<li><a href="#writing-tests-parameterized-tests-sources">2.15.3。争论的来源</a>
<ul class="sectlevel4">
<li><a href="#writing-tests-parameterized-tests-sources-ValueSource">@ValueSource</a></li>
<li><a href="#writing-tests-parameterized-tests-sources-null-and-empty">空和空来源</a></li>
<li><a href="#writing-tests-parameterized-tests-sources-EnumSource">@EnumSource</a></li>
<li><a href="#writing-tests-parameterized-tests-sources-MethodSource">@MethodSource</a></li>
<li><a href="#writing-tests-parameterized-tests-sources-CsvSource">@CsvSource</a></li>
<li><a href="#writing-tests-parameterized-tests-sources-CsvFileSource">@CsvFileSource</a></li>
<li><a href="#writing-tests-parameterized-tests-sources-ArgumentsSource">@ArgumentsSource</a></li>
</ul>
</li>
<li><a href="#writing-tests-parameterized-tests-argument-conversion">2.15.4。参数转换</a>
<ul class="sectlevel4">
<li><a href="#writing-tests-parameterized-tests-argument-conversion-widening">扩大转换</a></li>
<li><a href="#writing-tests-parameterized-tests-argument-conversion-implicit">隐式转换</a></li>
<li><a href="#writing-tests-parameterized-tests-argument-conversion-explicit">显式转换</a></li>
</ul>
</li>
<li><a href="#writing-tests-parameterized-tests-argument-aggregation">2.15.5。参数聚合</a>
<ul class="sectlevel4">
<li><a href="#writing-tests-parameterized-tests-argument-aggregation-custom">自定义聚合器</a></li>
</ul>
</li>
<li><a href="#writing-tests-parameterized-tests-display-names">2.15.6。自定义显示名称</a></li>
<li><a href="#writing-tests-parameterized-tests-lifecycle-interop">2.15.7。生命周期和互操作性</a></li>
</ul>
</li>
<li><a href="#writing-tests-test-templates">2.16。测试模板</a></li>
<li><a href="#writing-tests-dynamic-tests">2.17。动态测试</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-dynamic-tests-examples">2.17.1。动态测试示例</a></li>
<li><a href="#writing-tests-dynamic-tests-uri-test-source">2.17.2。动态测试的URI测试源</a></li>
</ul>
</li>
<li><a href="#writing-tests-declarative-timeouts">2.18。超时</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-declarative-timeouts-polling">2.18.1。使用@Timeout进行轮询测试</a></li>
</ul>
</li>
<li><a href="#writing-tests-parallel-execution">2.19。并行执行</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-parallel-execution-config">2.19.1。组态</a></li>
<li><a href="#writing-tests-parallel-execution-synchronization">2.19.2。同步</a></li>
</ul>
</li>
<li><a href="#writing-tests-built-in-extensions">2.20。内置扩展程序</a>
<ul class="sectlevel3">
<li><a href="#writing-tests-built-in-extensions-TempDirectory">2.20.1。TempDirectory扩展</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#migrating-from-junit4">3。从JUnit 4迁移</a>
<ul class="sectlevel2">
<li><a href="#migrating-from-junit4-running">3.1。在JUnit平台上运行JUnit 4测试</a>
<ul class="sectlevel3">
<li><a href="#migrating-from-junit4-categories-support">3.1.1。分类支持</a></li>
</ul>
</li>
<li><a href="#migrating-from-junit4-tips">3.2。迁移提示</a></li>
<li><a href="#migrating-from-junit4-rule-support">3.3。有限的JUnit 4规则支持</a></li>
<li><a href="#migrating-from-junit4-ignore-annotation-support">3.4。JUnit 4 @Ignore支持</a></li>
</ul>
</li>
<li><a href="#running-tests">4。运行测试</a>
<ul class="sectlevel2">
<li><a href="#running-tests-ide">4.1。IDE支持</a>
<ul class="sectlevel3">
<li><a href="#running-tests-ide-intellij-idea">4.1.1。IntelliJ IDEA</a></li>
<li><a href="#running-tests-ide-eclipse">4.1.2。日食</a></li>
<li><a href="#running-tests-ide-netbeans">4.1.3。NetBeans的</a></li>
<li><a href="#running-tests-ide-vscode">4.1.4。Visual Studio代码</a></li>
<li><a href="#running-tests-ide-other">4.1.5。其他IDE</a></li>
</ul>
</li>
<li><a href="#running-tests-build">4.2。构建支持</a>
<ul class="sectlevel3">
<li><a href="#running-tests-build-gradle">4.2.1。摇篮</a>
<ul class="sectlevel4">
<li><a href="#running-tests-build-gradle-config-params">配置参数</a></li>
<li><a href="#running-tests-build-gradle-engines-configure">配置测试引擎</a></li>
<li><a href="#running-tests-build-gradle-logging">配置日志记录（可选）</a></li>
</ul>
</li>
<li><a href="#running-tests-build-maven">4.2.2。Maven的</a>
<ul class="sectlevel4">
<li><a href="#running-tests-build-maven-engines-configure">配置测试引擎</a></li>
<li><a href="#running-tests-build-maven-filter-test-class-names">按测试类名称过滤</a></li>
<li><a href="#running-tests-build-maven-filter-tags">按标签过滤</a></li>
<li><a href="#running-tests-build-maven-config-params">配置参数</a></li>
</ul>
</li>
<li><a href="#running-tests-build-ant">4.2.3。蚂蚁</a>
<ul class="sectlevel4">
<li><a href="#basic-usage">基本用法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#running-tests-console-launcher">4.3。控制台启动器</a>
<ul class="sectlevel3">
<li><a href="#running-tests-console-launcher-options">4.3.1。选项</a></li>
<li><a href="#running-tests-console-launcher-argument-files">4.3.2。参数文件（@ -files）</a></li>
</ul>
</li>
<li><a href="#running-tests-junit-platform-runner">4.4。使用JUnit 4运行JUnit平台</a>
<ul class="sectlevel3">
<li><a href="#running-tests-junit-platform-runner-setup">4.4.1。建立</a>
<ul class="sectlevel4">
<li><a href="#explicit-dependencies">明确的依赖关系</a></li>
<li><a href="#transitive-dependencies">传递依赖</a></li>
</ul>
</li>
<li><a href="#running-tests-junit-platform-runner-technical-names">4.4.2。显示名称与技术名称</a></li>
<li><a href="#running-tests-junit-platform-runner-single-test">4.4.3。单一测试类</a></li>
<li><a href="#running-tests-junit-platform-runner-test-suite">4.4.4。测试套件</a></li>
</ul>
</li>
<li><a href="#running-tests-config-params">4.5。配置参数</a></li>
<li><a href="#running-tests-tag-expressions">4.6。标记表达式</a></li>
<li><a href="#running-tests-capturing-output">4.7。捕获标准输出/错误</a></li>
</ul>
</li>
<li><a href="#extensions">5。扩展模型</a>
<ul class="sectlevel2">
<li><a href="#extensions-overview">5.1。概观</a></li>
<li><a href="#extensions-registration">5.2。注册扩展程序</a>
<ul class="sectlevel3">
<li><a href="#extensions-registration-declarative">5.2.1。声明性扩展注册</a></li>
<li><a href="#extensions-registration-programmatic">5.2.2。程序化扩展注册</a>
<ul class="sectlevel4">
<li><a href="#extensions-registration-programmatic-static-fields">静态字段</a></li>
<li><a href="#extensions-registration-programmatic-static-fields-kotlin">科特林的静电场</a></li>
<li><a href="#extensions-registration-programmatic-instance-fields">实例字段</a></li>
</ul>
</li>
<li><a href="#extensions-registration-automatic">5.2.3。自动扩展注册</a>
<ul class="sectlevel4">
<li><a href="#extensions-registration-automatic-enabling">启用自动扩展检测</a></li>
</ul>
</li>
<li><a href="#extensions-registration-inheritance">5.2.4。扩展继承</a></li>
</ul>
</li>
<li><a href="#extensions-conditions">5.3。条件测试执行</a>
<ul class="sectlevel3">
<li><a href="#extensions-conditions-deactivation">5.3.1。停用条件</a>
<ul class="sectlevel4">
<li><a href="#extensions-conditions-deactivation-patterns">模式匹配语法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#extensions-test-instance-factories">5.4。测试实例工厂</a></li>
<li><a href="#extensions-test-instance-post-processing">5.5。测试实例后处理</a></li>
<li><a href="#extensions-parameter-resolution">5.6。参数分辨率</a></li>
<li><a href="#extensions-test-result-processing">5.7。测试结果处理</a></li>
<li><a href="#extensions-lifecycle-callbacks">5.8。测试生命周期回调</a>
<ul class="sectlevel3">
<li><a href="#extensions-lifecycle-callbacks-before-after-execution">5.8.1。测试执行回调之前和之后</a></li>
</ul>
</li>
<li><a href="#extensions-exception-handling">5.9。异常处理</a></li>
<li><a href="#extensions-intercepting-invocations">5.10。拦截调用</a></li>
<li><a href="#extensions-test-templates">5.11。为测试模板提供调用上下文</a></li>
<li><a href="#extensions-keeping-state">5.12。保持国家的延伸</a></li>
<li><a href="#extensions-supported-utilities">5.13。扩展中支持的实用程序</a>
<ul class="sectlevel3">
<li><a href="#extensions-supported-utilities-annotations">5.13.1。注释支持</a></li>
<li><a href="#extensions-supported-utilities-classes">5.13.2。班级支持</a></li>
<li><a href="#extensions-supported-utilities-reflection">5.13.3。反思支持</a></li>
<li><a href="#extensions-supported-utilities-modifier">5.13.4。修改器支持</a></li>
</ul>
</li>
<li><a href="#extensions-execution-order">5.14。用户代码和扩展的相对执行顺序</a>
<ul class="sectlevel3">
<li><a href="#extensions-execution-order-overview">5.14.1。用户和扩展代码</a></li>
<li><a href="#extensions-execution-order-wrapping-behavior">5.14.2。回调的包装行为</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#advanced-topics">6。高级主题</a>
<ul class="sectlevel2">
<li><a href="#launcher-api">6.1。JUnit Platform Launcher API</a>
<ul class="sectlevel3">
<li><a href="#launcher-api-discovery">6.1.1。发现测试</a></li>
<li><a href="#launcher-api-execution">6.1.2。执行测试</a></li>
<li><a href="#launcher-api-engines-custom">6.1.3。插入自己的测试引擎</a></li>
<li><a href="#launcher-api-listeners-custom">6.1.4。插入自己的测试执行监听器</a></li>
<li><a href="#launcher-api-listeners-reporting">6.1.5。JUnit平台报告</a></li>
<li><a href="#launcher-api-launcher-config">6.1.6。配置启动器</a></li>
</ul>
</li>
<li><a href="#testkit">6.2。JUnit平台测试工具包</a>
<ul class="sectlevel3">
<li><a href="#testkit-engine">6.2.1。发动机测试套件</a></li>
<li><a href="#testkit-engine-statistics">6.2.2。断言统计</a></li>
<li><a href="#testkit-engine-events">6.2.3。断言事件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#api-evolution">7。API演变</a>
<ul class="sectlevel2">
<li><a href="#api-evolution-version-and-status">7.1。API版本和状态</a></li>
<li><a href="#api-evolution-experimental-apis">7.2。实验API</a></li>
<li><a href="#api-evolution-deprecated-apis">7.3。弃用的API</a></li>
<li><a href="#api-evolution-tooling">7.4。@API工具支持</a></li>
</ul>
</li>
<li><a href="#contributors">8。贡献者</a></li>
<li><a href="#release-notes">9。发行说明</a></li>
<li><a href="#appendix">10。附录</a>
<ul class="sectlevel2">
<li><a href="#dependency-metadata">10.1。依赖元数据</a>
<ul class="sectlevel3">
<li><a href="#dependency-metadata-junit-platform">10.1.1。JUnit平台</a></li>
<li><a href="#dependency-metadata-junit-jupiter">10.1.2。JUnit Jupiter</a></li>
<li><a href="#dependency-metadata-junit-vintage">10.1.3。JUnit Vintage</a></li>
<li><a href="#dependency-metadata-junit-bom">10.1.4。物料清单（BOM）</a></li>
<li><a href="#dependency-metadata-dependencies">10.1.5。依赖</a></li>
</ul>
</li>
<li><a href="#dependency-diagram">10.2。依赖关系图</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a> 1。概观</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本文档的目标是为编写测试的程序员，扩展作者和引擎作者以及构建工具和IDE供应商提供全面的参考文档。</p>
</div>
<div class="paragraph">
<p>本文档也可以<a href="index.pdf">PDF格式下载</a> 。</p>
</div>
<div class="sect2">
<h3 id="overview-what-is-junit-5"><a class="anchor" href="#overview-what-is-junit-5"></a> 1.1。什么是JUnit 5？</h3>
<div class="paragraph">
<p>与以前版本的JUnit不同，JUnit 5由来自三个不同子项目的几个不同模块组成。</p>
</div>
<div class="paragraph">
<p><strong>JUnit 5 = <em>JUnit平台</em> + <em>JUnit Jupiter</em> + <em>JUnit Vintage</em></strong></p>
</div>
<div class="paragraph">
<p><strong>JUnit平台</strong>是在JVM上<a href="#launcher-api">启动测试框架</a>的基础。它还定义了<code><a href="../api/org/junit/platform/engine/TestEngine.html">TestEngine</a></code> API，用于开发在平台上运行的测试框架。此外，该平台还提供了一个<a href="#running-tests-console-launcher">Console Launcher，</a>用于从命令行启动平台，以及一个<a href="#running-tests-junit-platform-runner">基于JUnit 4的Runner，</a>用于在基于JUnit 4的环境中运行平台上的任何<code>TestEngine</code> 。JUnit平台的一流支持也存在于流行的IDE中（参见<a href="#running-tests-ide-intellij-idea">IntelliJ IDEA</a> ， <a href="#running-tests-ide-eclipse">Eclipse</a> ， <a href="#running-tests-ide-netbeans">NetBeans</a>和<a href="#running-tests-ide-vscode">Visual Studio Code</a> ）和构建工具（请参阅<a href="#running-tests-build-gradle">Gradle</a> ， <a href="#running-tests-build-maven">Maven</a>和<a href="#running-tests-build-ant">Ant</a> ）。</p>
</div>
<div class="paragraph">
<p><strong>JUnit Jupiter</strong>是用于在JUnit 5中编写测试和扩展的新<a href="#writing-tests">编程模型</a>和<a href="#extensions">扩展模型</a>的组合。Jupiter子项目提供了一个<code>TestEngine</code>用于在平台上运行基于Jupiter的测试。</p>
</div>
<div class="paragraph">
<p><strong>JUnit Vintage</strong>提供了一个<code>TestEngine</code>用于在平台上运行基于JUnit 3和JUnit 4的测试。</p>
</div>
</div>
<div class="sect2">
<h3 id="overview-java-versions"><a class="anchor" href="#overview-java-versions"></a> 1.2。支持的Java版本</h3>
<div class="paragraph">
<p>JUnit 5在运行时需要Java 8（或更高版本）。但是，您仍然可以测试使用以前版本的JDK编译的代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="overview-getting-help"><a class="anchor" href="#overview-getting-help"></a> 1.3。获得帮助</h3>
<div class="paragraph">
<p>在<a href="https://stackoverflow.com/questions/tagged/junit5">Stack Overflow</a>上询问JUnit 5相关问题或在<a href="https://gitter.im/junit-team/junit5">Gitter</a>上与我们聊聊。</p>
</div>
</div>
<div class="sect2">
<h3 id="overview-getting-started"><a class="anchor" href="#overview-getting-started"></a> 1.4。入门</h3>
<div class="sect3">
<h4 id="overview-getting-started-junit-artifacts"><a class="anchor" href="#overview-getting-started-junit-artifacts"></a> 1.4.1。下载JUnit工件</h4>
<div class="paragraph">
<p>要了解哪些工件可供下载并包含在项目中，请参阅<a href="#dependency-metadata">依赖关系元数据</a> 。要为构建设置依赖关系管理，请参阅<a href="#running-tests-build">构建支持</a>和<a href="#overview-getting-started-example-projects">示例项目</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="overview-getting-started-features"><a class="anchor" href="#overview-getting-started-features"></a> 1.4.2。JUnit 5功能</h4>
<div class="paragraph">
<p>要了解JUnit 5中可用的功能以及如何使用它们，请阅读本用户指南的相应部分，按主题组织。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#writing-tests">在JUnit Jupiter中编写测试</a></p>
</li>
<li>
<p><a href="#migrating-from-junit4">从JUnit 4迁移到JUnit Jupiter</a></p>
</li>
<li>
<p><a href="#running-tests">运行测试</a></p>
</li>
<li>
<p><a href="#extensions">JUnit Jupiter的扩展模型</a></p>
</li>
<li>
<p>高级主题</p>
<div class="ulist">
<ul>
<li>
<p><a href="#launcher-api">JUnit Platform Launcher API</a></p>
</li>
<li>
<p><a href="#testkit">JUnit平台测试工具包</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="overview-getting-started-example-projects"><a class="anchor" href="#overview-getting-started-example-projects"></a> 1.4.3。示例项目</h4>
<div class="paragraph">
<p>要查看可以复制和试验的项目的完整工作示例， <a href="https://github.com/junit-team/junit5-samples"><code>junit5-samples</code></a>存储库是一个很好的起点。<code>junit5-samples</code>存储库托管基于JUnit Jupiter，JUnit Vintage和其他测试框架的示例项目集合。您将在示例项目中找到适当的构建脚本（例如， <code>build.gradle</code> ， <code>pom.xml</code>等）。以下链接突出显示了您可以选择的一些组合。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Gradle和Java，请查看<code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-starter-gradle">junit5-jupiter-starter-gradle</a></code>项目。</p>
</li>
<li>
<p>对于Gradle和Kotlin，请查看<code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-starter-gradle-kotlin">junit5-jupiter-starter-gradle-kotlin</a></code>项目。</p>
</li>
<li>
<p>对于Gradle和Groovy，请查看<code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-starter-gradle-groovy">junit5-jupiter-starter-gradle-groovy</a></code>项目。</p>
</li>
<li>
<p>对于Maven，请查看<code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-starter-maven">junit5-jupiter-starter-maven</a></code>项目。</p>
</li>
<li>
<p>对于Ant，请查看<code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-starter-ant">junit5-jupiter-starter-ant</a></code>项目。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="writing-tests"><a class="anchor" href="#writing-tests"></a> 2。写测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>以下示例提供了在JUnit Jupiter中编写测试的最低要求的一瞥。本章的后续部分将提供有关所有可用功能的更多详细信息。</p>
</div>
<div class="listingblock">
<div class="title">第一个测试用例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">example.util。计算器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="type">class</span> <span class="class">MyFirstJUnitJupiterTests</span> { <span class="directive">private</span> <span class="directive">final</span> Calculator calculator = <span class="keyword">new</span> Calculator（）; <span class="annotation">@Test</span> <span class="type">空隙</span>另外（）{的<span class="integer"><span class="integer"><span class="integer">assertEquals（2，calculator.add（1，1））;</span></span></span> }}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-annotations"><a class="anchor" href="#writing-tests-annotations"></a> 2.1。注释</h3>
<div class="paragraph">
<p>JUnit Jupiter支持以下注释，用于配置测试和扩展框架。</p>
</div>
<div class="paragraph">
<p>除非另有说明，否则所有核心注释都位于<code>junit-jupiter-api</code>模块的<code><a href="../api/org/junit/jupiter/api/package-summary.html">org.junit.jupiter.api</a></code>包中。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@测试</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示方法是一种测试方法。与JUnit 4的<code>@Test</code>注释不同，此注释不会声明任何属性，因为JUnit Jupiter中的测试扩展基于它们自己的专用注释进行操作。除非被<em>覆盖，</em>否则这些方法是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ParameterizedTest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示方法是<a href="#writing-tests-parameterized-tests">参数化测试</a> 。除非被<em>覆盖，</em>否则这些方法是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RepeatedTest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示方法是<a href="#writing-tests-repeated-tests">重复测试</a>的测试模板。除非被<em>覆盖，</em>否则这些方法是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@TestFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示方法是<a href="#writing-tests-dynamic-tests">动态测试</a>的测试工厂。除非被<em>覆盖，</em>否则这些方法是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@TestTemplate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示方法是设计为多次调用的<a href="#writing-tests-test-templates">测试用例</a>的<a href="#writing-tests-test-templates">模板，</a>具体取决于注册<a href="#extensions-test-templates">提供程序</a>返回的调用上下文的数量。除非被<em>覆盖，</em>否则这些方法是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@TestMethodOrder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于配置带注释的测试类的<a href="#writing-tests-test-execution-order">测试方法执行顺序</a> ;类似于JUnit 4的<code>@FixMethodOrder</code> 。这样的注释是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@TestInstance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于为带注释的测试类配置<a href="#writing-tests-test-instance-lifecycle">测试实例生命周期</a> 。这样的注释是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@显示名称</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明测试类或测试方法的自定义<a href="#writing-tests-display-names">显示名称</a> 。这样的注释不是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DisplayNameGeneration</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明测试类的自定义<a href="#writing-tests-display-name-generator">显示名称生成器</a> 。这样的注释是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@BeforeEach</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示该注释的方法应在<strong>每次</strong> <em>之前</em>执行<code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code> ，或<code>@TestFactory</code>在当前类的方法;类似于JUnit 4的<code>@Before</code> 。除非被<em>覆盖，</em>否则这些方法是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@AfterEach</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示该注释的方法<em>后</em>应执行<strong>的每个</strong> <code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code> ，或<code>@TestFactory</code>在当前类的方法;类似于JUnit 4的<code>@After</code> 。除非被<em>覆盖，</em>否则这些方法是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@BeforeAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示该注释的方法应该被执行<em>之前</em> <strong>的所有</strong> <code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code>和<code>@TestFactory</code>在当前类的方法;类似于JUnit 4的<code>@BeforeClass</code> 。这些方法是<em>继承的</em> （除非它们被<em>隐藏</em>或<em>覆盖</em> ）并且必须是<code>static</code> （除非使用“每类” <a href="#writing-tests-test-instance-lifecycle">测试实例生命周期</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@毕竟</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示该注释的方法<em>后</em>应执行<strong>的所有</strong> <code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code>和<code>@TestFactory</code>在当前类的方法;类似于JUnit 4的<code>@AfterClass</code> 。这些方法是<em>继承的</em> （除非它们被<em>隐藏</em>或<em>覆盖</em> ）并且必须是<code>static</code> （除非使用“每类” <a href="#writing-tests-test-instance-lifecycle">测试实例生命周期</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Nested</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示带注释的类是非静态<a href="#writing-tests-nested">嵌套测试类</a> 。<code>@BeforeAll</code>和<code>@AfterAll</code>方法不能直接在<code>@Nested</code>测试类中使用，除非使用“每类” <a href="#writing-tests-test-instance-lifecycle">测试实例生命周期</a> 。这样的注释不是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@标签</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于在类或方法级别声明<a href="#writing-tests-tagging-and-filtering">用于过滤测试的标记</a> ;类似于TestNG中的测试组或JUnit 4中的类别。此类注释在类级别<em>继承</em> ，但不在方法级别<em>继承</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Disabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于<a href="#writing-tests-disabling">禁用</a>测试类或测试方法;类似于JUnit 4的<code>@Ignore</code> 。这样的注释不是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@超时</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于在测试，测试工厂，测试模板或生命周期方法执行超过给定持续时间时使其失败。这样的注释是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ExtendWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于以<a href="#extensions-registration-declarative">声明</a>方式<a href="#extensions-registration-declarative">注册扩展</a> 。这样的注释是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RegisterExtension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于通过字段以<a href="#extensions-registration-programmatic">编程</a>方式<a href="#extensions-registration-programmatic">注册扩展</a> 。除非它们被<em>遮蔽，</em>否则这些字段是<em>继承的</em> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@TempDir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于通过生命周期方法或测试方法中的字段注入或参数注入来提供<a href="#writing-tests-built-in-extensions-TempDirectory">临时目录</a> ;位于<code>org.junit.jupiter.api.io</code>包中。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">一些注释目前可能是<em>实验性的</em> 。有关详细信息，请参阅<a href="#api-evolution-experimental-apis">实验API中</a>的表。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="writing-tests-meta-annotations"><a class="anchor" href="#writing-tests-meta-annotations"></a> 2.1.1。元注释和组合注释</h4>
<div class="paragraph">
<p>JUnit Jupiter注释可以用作<em>元注释</em> 。这意味着您可以定义自己的<em>组合注释</em> ，该<em>注释</em>将自动<em>继承</em>其元注释的语义。</p>
</div>
<div class="paragraph">
<p>例如，不是在整个代码库中复制和粘贴<code>@Tag("fast")</code> （请参阅<a href="#writing-tests-tagging-and-filtering">标记和过滤</a> ），而是可以创建一个名为<code>@Fast</code>的自定义<em>组合注释</em> ，如下所示。<code>@Fast</code>可以用作<code>@Tag("fast")</code>替代品。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.lang.annotation。ElementType</span> ; <span class="keyword">import</span> <span class="include">java.lang.annotation。保留</span> ; <span class="keyword">import</span> <span class="include">java.lang.annotation。保留政策</span> ; <span class="keyword">import</span> <span class="include">java.lang.annotation。目标</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。标签</span> ; <span class="annotation">@Target</span> （{ <span class="predefined-type">ElementType</span> 。TYPE， <span class="predefined-type">ElementType</span> 。方法}） <span class="annotation">@</span> <span class="predefined-type">Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">fast</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="annotation">@interface</span> Fast {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下<code>@Test</code>方法演示了<code>@Fast</code>注释的用法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Fast</span> <span class="annotation">@Test</span> <span class="type">void</span> myFastTest（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以通过引入自定义<code>@FastTest</code>注释来进一步采用<code>@FastTest</code>注释，该注释可用作<code>@Tag("fast")</code> <em>和</em> <code>@Test</code>替代品。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.lang.annotation。ElementType</span> ; <span class="keyword">import</span> <span class="include">java.lang.annotation。保留</span> ; <span class="keyword">import</span> <span class="include">java.lang.annotation。保留政策</span> ; <span class="keyword">import</span> <span class="include">java.lang.annotation。目标</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。标签</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。方法） <span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">快</span> <span class="delimiter">”</span></span> ） <span class="annotation">@Test</span> <span class="directive">public</span> <span class="annotation">@interface</span> FastTest {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JUnit会自动将以下内容识别为标记为“fast”的<code>@Test</code>方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FastTest</span> <span class="type">void</span> myFastTest（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-classes-and-methods"><a class="anchor" href="#writing-tests-classes-and-methods"></a> 2.2。测试类和方法</h3>
<div class="paragraph">
<p><strong>测试类</strong> ：包含至少一个<em>测试方法的</em>任何顶级类， <code>static</code>成员类或<a href="#writing-tests-nested"><code>@Nested</code>类</a> 。</p>
</div>
<div class="paragraph">
<p>测试类不能是<code>abstract</code> ，必须有一个构造函数。</p>
</div>
<div class="paragraph">
<p><strong>测试方法</strong> ：即直接注释或元注解的任何实例方法<code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code> ， <code>@TestFactory</code> ，或<code>@TestTemplate</code> 。</p>
</div>
<div class="paragraph">
<p><strong>生命周期方法</strong> ：使用<code>@BeforeAll</code> ， <code>@AfterAll</code> ， <code>@BeforeEach</code>或<code>@AfterEach</code>直接注释或元注释的任何方法。</p>
</div>
<div class="paragraph">
<p>测试方法和生命周期方法可以在当前测试类中本地声明，从超类继承，或从接口继承（请参阅<a href="#writing-tests-test-interfaces-and-default-methods">测试接口和默认方法</a> ）。此外，测试方法和生命周期方法不得是<code>abstract</code> ，不得返回值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">测试类，测试方法和生命周期方法不需要<code>public</code> ，但它们<em>不能</em>是<code>private</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下测试类演示了<code>@Test</code>方法和所有受支持的生命周期方法的使用。有关运行时语义的更多信息，请参阅<a href="#writing-tests-test-execution-order">测试执行顺序</a>和<a href="#extensions-execution-order-wrapping-behavior">回调的包装行为</a> 。</p>
</div>
<div class="listingblock">
<div class="title">标准测试类</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。断言</span> 。 失败</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assumptions.assumeTrue</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。AfterAll</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。AfterEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。之前所有</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。BeforeEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。残疾</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="type">类</span> <span class="class">StandardTests</span> <span class="annotation">{@BeforeAll</span> <span class="directive">静态</span> <span class="type">无效</span> initAll（）{} <span class="annotation">@BeforeEach</span> <span class="type">无效</span>的init（）{} <span class="annotation">@Test</span> <span class="type">空隙</span> succeedingTest（）{} <span class="annotation">@Test</span> <span class="type">空隙</span> failingTest（）{失败（ <span class="string"><span class="delimiter">“</span> <span class="content">失败的测试</span> <span class="delimiter">”）;</span></span> } <span class="annotation">@Test</span> <span class="annotation">@Disabled</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">用于演示目的</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> skippedTest（）{ <span class="comment">// not executed</span> } <span class="annotation">@Test</span> <span class="type">void</span> abortedTest（）{assumeTrue（ <span class="string"><span class="delimiter">“</span> <span class="content">abc</span> <span class="delimiter">”</span></span> .contains（ <span class="string"><span class="delimiter">“</span> <span class="content">Z</span> <span class="delimiter">”</span></span> ））;失败（ <span class="string"><span class="delimiter">“</span> <span class="content">测试本应中止</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterEach</span> <span class="type">void</span> tearDown（）{} <span class="annotation">@AfterAll</span> <span class="directive">static</span> <span class="type">void</span> tearDownAll（）{}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-display-names"><a class="anchor" href="#writing-tests-display-names"></a> 2.3。显示名称</h3>
<div class="paragraph">
<p>测试类和测试方法可以通过<code>@DisplayName</code>声明自定义显示名称 - 包含空格，特殊字符，甚至是表情符号 - 将在测试报告中以及测试运行者和IDE中显示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DisplayName</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">特殊测试用例</span> <span class="delimiter">”</span></span> ） <span class="type">类</span> <span class="class">DisplayNameDemo</span> { <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">包含空格的自定义测试名称</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithDisplayNameContainingSpaces（）{} <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">╯°□°）╯</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithDisplayNameContainingSpecialCharacters（） {} <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">😱</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithDisplayNameContainingEmoji（）{}}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-display-name-generator"><a class="anchor" href="#writing-tests-display-name-generator"></a> 2.3.1。显示名称生成器</h4>
<div class="paragraph">
<p>JUnit Jupiter支持可以通过<code>@DisplayNameGeneration</code>批注配置的自定义显示名称生成器。通过<code>@DisplayName</code>注释提供的值始终优先于<code>DisplayNameGenerator</code>生成的显示名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.lang.reflect。方法</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DisplayName</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DisplayNameGeneration</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DisplayNameGenerator</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。嵌套</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.params。ParameterizedTest</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.params.provider。ValueSource</span> ; <span class="type">class</span> <span class="class">DisplayNameGeneratorDemo</span> { <span class="annotation">@Nested</span> <span class="annotation">@DisplayNameGeneration</span> （DisplayNameGenerator。ReplaceUnderscores.class） <span class="type">类</span> <span class="class">A_year_is_not_supported</span> { <span class="annotation">@Test</span> <span class="type">void</span> if_it_is_zero（）{} <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">闰年计算不支持年份的负值。</span> <span class="delimiter">”</span></span> <span class="annotation">@ParameterizedTest</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">例如，年{0}不是支持。</span> <span class="delimiter">“</span></span> ） <span class="annotation">@ ValueSource</span> （ints = { - <span class="integer">1</span> ， - <span class="integer">4</span> }） <span class="type">void</span> if_it_is_negative（ <span class="type">int</span> year）{}} <span class="annotation">@Nested</span> <span class="annotation">@DisplayNameGeneration</span> （IndicativeSentences.class） <span class="type">class</span> <span class="class">A_year_is_a_leap_year</span> { <span class="annotation">@Test</span> <span class="type">void</span> if_it_is_divisible_by_4_but_not_by_100（）{} <span class="annotation">@ParameterizedTest</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">年份{0}是闰年<span class="delimiter"><span class="annotation">。”）@ValueSource（</span></span></span></span>整型= <span class="integer"><span class="integer"><span class="integer">{2016，2020，2048}）</span></span></span> <span class="type">空隙</span> <span class="type">if_it_is_one_of_the_following_years（INT</span>年）{}} <span class="directive">静态</span> <span class="type">类</span> <span class="class">IndicativeSentences</span> <span class="directive">延伸</span> DisplayNameGenerator。ReplaceUnderscores <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="predefined-type">字符串</span> generateDisplayNameForClass（ <span class="predefined-type">类</span> &lt;？&gt; testClass）{ <span class="keyword">return</span> <span class="local-variable">super</span> .generateDisplayNameForClass（testClass）; } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="predefined-type">String</span> generateDisplayNameForNestedClass（ <span class="predefined-type">Class</span> &lt;？&gt; nestedClass）{ <span class="keyword">return</span> <span class="local-variable">super</span> .generateDisplayNameForNestedClass（nestedClass）+ <span class="string"><span class="delimiter">“</span> <span class="content">...</span> <span class="delimiter">”</span></span> ; } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="predefined-type">String</span> generateDisplayNameForMethod（ <span class="predefined-type">Class</span> &lt;？&gt; testClass， <span class="predefined-type">Method</span> testMethod）{ <span class="predefined-type">String</span> name = testClass.getSimpleName（）+ <span class="string"><span class="delimiter">'</span> <span class="content"> </span> <span class="delimiter">'</span></span> + testMethod.getName（）; <span class="keyword">return</span> name.replace（ <span class="string"><span class="delimiter">'</span> <span class="content">_</span> <span class="delimiter">'</span></span> ， <span class="string"><span class="delimiter">'</span> <span class="content"> </span> <span class="delimiter">'</span></span> ）+ <span class="string"><span class="delimiter">'</span> <span class="content">。</span><span class="delimiter">'</span></span> ; }}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>+  -  DisplayNameGeneratorDemo [确定] +  - 不支持一年[确定] | +  - 闰年计算不支持年份的负值。[确定] | | +  - 例如，不支持年-1。[确定] | | ' - 例如，不支持第-4年。[确定] | ' - 如果它是零（）[OK]' - 一年是闰年......[OK] +  - 如果一年可以被4整除而不是100，那么它是一年。[OK]' - 如果是下一年中的一年，则一年是闰年。[确定] +  -  2016年是闰年。[OK] +  -  2020年是闰年。[OK]' -  2048年是闰年。[好]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-display-name-generator-default"><a class="anchor" href="#writing-tests-display-name-generator-default"></a> 2.3.2。设置默认显示名称生成器</h4>
<div class="paragraph">
<p>您可以使用<code>junit.jupiter.displayname.generator.default</code> <a href="#running-tests-config-params">配置参数</a>来指定默认情况下要使用的<code>DisplayNameGenerator</code>的完全限定类名。就像通过<code>@DisplayNameGeneration</code>批注配置的显示名称生成器一样，提供的类必须实现<code>DisplayNameGenerator</code>接口。默认显示名称生成器将用于所有测试，除非封闭测试类或测试接口上存在<code>@DisplayNameGeneration</code>批注。通过<code>@DisplayName</code>注释提供的值始终优先于<code>DisplayNameGenerator</code>生成的显示名称。</p>
</div>
<div class="paragraph">
<p>例如，要默认使用<code>ReplaceUnderscores</code>显示名称生成器，您应该将配置参数设置为相应的完全限定类名称（例如，在<code>src/test/resources/junit-platform.properties</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">junit.jupiter.displayname.generator.default = \ org.junit.jupiter.api。DisplayNameGenerator $ ReplaceUnderscores</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可以指定实现<code>DisplayNameGenerator</code>的任何自定义类的完全限定名称。</p>
</div>
<div class="paragraph">
<p>总之，测试类或方法的显示名称是根据以下优先规则确定的：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>@DisplayName</code>注释的值（如果存在）</p>
</li>
<li>
<p>通过调用<code>@DisplayNameGeneration</code>注释中指定的<code>DisplayNameGenerator</code> （如果存在）</p>
</li>
<li>
<p>通过调用通过配置参数配置的默认<code>DisplayNameGenerator</code> （如果存在）</p>
</li>
<li>
<p>通过调用<code>org.junit.jupiter.api.DisplayNameGenerator。标准</code></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-assertions"><a class="anchor" href="#writing-tests-assertions"></a> 2.4。断言</h3>
<div class="paragraph">
<p>JUnit Jupiter附带了许多JUnit 4所拥有的断言方法，并添加了一些非常适合与Java 8 lambdas一起使用的方法。所有JUnit Jupiter断言都是<code><a href="../api/org/junit/jupiter/api/Assertions.html">org.junit.jupiter.api.中的<code>static</code>方法<code><a href="../api/org/junit/jupiter/api/Assertions.html">org.junit.jupiter.api.Assertions</a></code>类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">java.time。持续时间.Millis</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">java.time。持续时间</span> 。 <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertAll</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertNotNull</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertThrows</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertTimeout</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertTimeoutPreemptively</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertTrue</span> ; <span class="keyword">import</span> <span class="include">example.domain。人</span> ; <span class="keyword">import</span> <span class="include">example.util。计算器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="type">class</span> <span class="class">AssertionsDemo</span> { <span class="directive">private</span> <span class="directive">final</span> Calculator calculator = <span class="keyword">new</span> Calculator（）; <span class="directive">私人</span> <span class="directive">最终</span>人员= <span class="keyword">新人</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">简</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">Doe</span> <span class="delimiter">”</span></span> ）; <span class="annotation">@Test</span> <span class="type">空隙</span> standardAssertions（）{的<span class="integer"><span class="integer"><span class="integer">assertEquals（2，calculator.add（1，1））;</span></span></span>的<span class="integer"><span class="integer"><span class="integer">assertEquals（4，calculator.multiply（2，2），</span></span></span> <span class="string"><span class="delimiter">“</span> <span class="content">可选的失败消息现在是最后一个参数</span> <span class="delimiter">”）;</span></span> assertTrue（ <span class="string"><span class="delimiter">'</span> <span class="content">a</span> <span class="delimiter">'</span></span> &lt; <span class="string"><span class="delimiter">'</span> <span class="content">b</span> <span class="delimiter">'</span></span> ，（） - &gt; <span class="string"><span class="delimiter">“</span> <span class="content">可以延迟评估断言消息 -</span> <span class="delimiter">”</span></span> + <span class="string"><span class="delimiter">“</span> <span class="content">以避免不必要地构造复杂消息。</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Test</span> <span class="type">void</span> groupedAssertions（）{ <span class="comment">//在分组断言中执行所有断言，并且所有</span> <span class="comment">//失败将一起报告。</span>assertAll（ <span class="string"><span class="delimiter">“</span> <span class="content">person</span> <span class="delimiter">”</span></span> ，（） - &gt; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">Jane</span> <span class="delimiter">”</span></span> ，person.getFirstName（）），（） - &gt; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">Doe</span> <span class="delimiter">”</span></span> ，person.getLastName（）））; } <span class="annotation">@Test</span> <span class="type">void</span> dependentAssertions（）{ <span class="comment">//在代码块中，如果断言失败，</span> <span class="comment">则将跳过//同一块中的后续代码。</span>assertAll（ <span class="string"><span class="delimiter">“</span> <span class="content">properties</span> <span class="delimiter">”</span></span> ，（） - &gt; { <span class="predefined-type">String</span> firstName = person.getFirstName（）; assertNotNull（firstName）; <span class="comment">//仅在前一个断言有效时执行。</span>assertAll（ <span class="string"><span class="delimiter">“</span> <span class="content">first name</span> <span class="delimiter">”</span></span> ，（） - &gt; assertTrue（firstName.startsWith（ <span class="string"><span class="delimiter">“</span> <span class="content">J</span> <span class="delimiter">”</span></span> ）），（） - &gt; assertTrue（firstName.endsWith（ <span class="string"><span class="delimiter">“</span> <span class="content">e</span> <span class="delimiter">”</span></span> ）））; }，（） - &gt; { <span class="comment">//分组断言，因此独立处理</span> <span class="comment">//名字断言的结果。</span>
                <span class="predefined-type">String</span> lastName = person.getLastName（）; assertNotNull（lastName的）; <span class="comment">//仅在前一个断言有效时执行。</span>assertAll（ <span class="string"><span class="delimiter">“</span> <span class="content">姓氏</span> <span class="delimiter">”</span></span> ，（） - &gt; assertTrue（lastName.startsWith（ <span class="string"><span class="delimiter">“</span> <span class="content">D</span> <span class="delimiter">”</span></span> ）），（） - &gt; assertTrue（lastName.endsWith（ <span class="string"><span class="delimiter">“</span> <span class="content">e</span> <span class="delimiter">”</span></span> ）））; }）; } <span class="annotation">@Test</span> <span class="type">空隙</span> exceptionTesting（）{ <span class="exception">异常</span>异常= <span class="exception">assertThrows（ArithmeticException</span>的.class，（） - &gt; <span class="integer"><span class="integer">calculator.divide（1，0））;</span></span> assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">/ by zero</span> <span class="delimiter">”</span></span> ，exception.getMessage（））; } <span class="annotation">@Test</span> <span class="type">void</span> timeoutNotExceeded（）{ <span class="comment">//以下断言成功。</span>assertTimeout（ofMinutes（ <span class="integer">2</span> ），（） - &gt; { <span class="comment">//执行花费不到2分钟的任务。</span>}）; } <span class="annotation">@Test</span> <span class="type">void</span> timeoutNotExceededWithResult（）{ <span class="comment">//以下断言成功，并返回提供的对象。</span>
        <span class="predefined-type">String</span> actualResult = assertTimeout（ofMinutes（ <span class="integer">2</span> ），（） - &gt; { <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">a result</span> <span class="delimiter">”</span></span> ;}）; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">a result</span> <span class="delimiter">”</span></span> ，actualResult）; } <span class="annotation">@Test</span> <span class="type">void</span> timeoutNotExceededWithMethod（）{ <span class="comment">//以下断言调用方法引用并返回一个对象。</span>
        <span class="predefined-type">String</span> actualGreeting = assertTimeout（ofMinutes（ <span class="integer">2</span> ），AssertionsDemo :: greeting）; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">你好，世界！</span><span class="delimiter">“</span></span> ，actualGreeting）;} <span class="annotation">@Test</span> <span class="type">void</span> timeoutExceeded（）{ <span class="comment">//以下断言失败并显示类似于以下内容的错误消息：</span> <span class="comment">//执行超过10毫秒的超时时间91毫秒</span> assertTimeout（ofMillis（ <span class="integer">10</span> ），（） - &gt; { <span class="comment">/ /模拟超过10毫秒的任务。</span>
            <span class="predefined-type">Thread</span> .sleep（ <span class="integer">100</span> ）; }）; } <span class="annotation">@Test</span> <span class="type">void</span> timeoutExceededWithPreemptiveTermination（）{ <span class="comment">//以下断言失败，错误消息类似于：</span> <span class="comment">//执行超时后10秒</span> assertTimeoutPreemptively（ofMillis（ <span class="integer">10</span> ），（） - &gt; { <span class="comment">//模拟任务超过10女士。</span>
            <span class="predefined-type">Thread</span> .sleep（ <span class="integer">100</span> ）; }）; <span class="directive">private</span> <span class="directive">static</span> <span class="predefined-type">String</span> greeting（）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">Hello，World！</span><span class="delimiter">“</span></span> ;}}</code></pre>
</div>
</div>
<div id="writing-tests-assertions-preemptive-timeouts" class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">使用<code>assertTimeoutPreemptively()</code>抢先超时</div>
<div class="paragraph">
<p>与<a href="#writing-tests-declarative-timeouts">声明性超时</a>相反， <code>Assertions</code>类中的各种<code>assertTimeoutPreemptively()</code>方法在与调用代码不同的线程中执行提供的<code>executable</code>或<code>supplier</code> 。如果在<code>executable</code>或<code>supplier</code>执行的代码依赖于<code>java.lang. ，则此行为可能导致不良副作用<code>java.lang.ThreadLocal</code>存储。</p>
</div>
<div class="paragraph">
<p>一个常见的例子是Spring Framework中的事务测试支持。具体来说，Spring的测试支持在调用测试方法之前将事务状态绑定到当前线程（通过<code>ThreadLocal</code> ）。因此，如果提供给<code>assertTimeoutPreemptively()</code>的<code>executable</code>或<code>supplier</code>调用参与事务的Spring管理的组件，那么这些组件所采取的任何操作都不会与测试管理的事务一起回滚。相反，即使回滚了测试管理的事务，这些动作也将被提交给持久存储（例如，关系数据库）。</p>
</div>
<div class="paragraph">
<p>其他依赖<code>ThreadLocal</code>存储的框架可能会遇到类似的副作用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="writing-tests-assertions-kotlin"><a class="anchor" href="#writing-tests-assertions-kotlin"></a> 2.4.1。Kotlin断言支持</h4>
<div class="paragraph">
<p>JUnit Jupiter还附带了一些断言方法，这些方法很适合在<a href="https://kotlinlang.org/">Kotlin中使用</a> 。所有JUnit Jupiter Kotlin断言都是<code>org.junit.jupiter.api</code>包中的顶级函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">example.domain。人员</span> <span class="keyword">导入</span> <span class="include">example.util。计算器</span> <span class="keyword">导入</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> <span class="keyword">导入</span> <span class="include">org.junit.jupiter.api。Assertions.assertTrue</span> <span class="keyword">导入</span> <span class="include">org.junit.jupiter.api。测试</span> <span class="keyword">导入</span> <span class="include">org.junit.jupiter.api.assertAll</span> <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.assertDoesNotThrow</span> <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.assertThrows</span> <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.assertTimeout</span> <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。 assertTimeoutPreemptively</span> <span class="keyword">导入</span> <span class="include">java.time。Duration</span> <span class="type">类</span> <span class="class">KotlinAssertionsDemo</span> { <span class="directive">私人</span> VAL人=人（ <span class="string"><span class="delimiter">“</span> <span class="content">简</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">李四</span> <span class="delimiter">”）</span></span> <span class="directive">的私人</span> VAL人= SETOF（人，人（ <span class="string"><span class="delimiter">“</span> <span class="content">约翰福音</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">李四</span> <span class="delimiter"><span class="annotation">”））@Test</span></span></span>好玩<span class="error">`</span>例外情况下测试<span class="error">`（）{VAL</span>计算器=计算器（）VAL结果= assertDoesNotThrow（ <span class="string"><span class="delimiter">“</span> <span class="content">应该不会引发异常</span> <span class="delimiter"><span class="integer"><span class="integer">”）{calculator.divide（0,1）}</span></span></span></span>的<span class="integer">assertEquals（0，</span>结果）} <span class="annotation">@Test</span>乐趣<span class="error">`</span>预期异常测试<span class="error">`（）{VAL</span>计算器=计算器（ ）VAL例外= assertThrows <span class="exception">&lt;ArithmeticException&gt;（</span> <span class="string"><span class="delimiter">“</span> <span class="content">应该抛出异常</span> <span class="delimiter"><span class="integer"><span class="integer">”）{calculator.divide（1,0）}</span></span></span></span>的assertEquals（ <span class="string"><span class="content"><span class="delimiter">“/</span>由零</span> <span class="delimiter">”，exception.message）}</span></span> <span class="annotation">@Test</span>乐趣<span class="error">`</span>分组断言<span class="error">`（）{assertAll</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">人属性</span> <span class="delimiter">”，{</span></span>的assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">简</span> <span class="delimiter">”，person.firstName）}，{</span></span>的assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">李四</span> <span class="delimiter">”，person.lastName）}）}</span></span> <span class="annotation">@Test</span>好玩<span class="error">`</span>分组从流断言<span class="string"><span class="error"><span class="delimiter">`（）{assertAll（“</span></span> <span class="content">人名字以J</span> <span class="delimiter">“</span> <span class="content">开头</span></span> ，人们.stream（）。map { <span class="comment">//此映射返回Stream &lt;（） - &gt; Unit&gt;</span> {assertTrue（ <span class="local-variable">it</span> .firstName.startsWith（ <span class="string"><span class="delimiter">”</span> <span class="content">J</span> <span class="delimiter">“</span></span> ））}}） } <span class="annotation">@Test</span>好玩<span class="error">`</span>分组从集合断言<span class="error">`（）{assertAll（</span> <span class="string"><span class="delimiter">“</span> <span class="content">能源部的姓氏的人</span> <span class="delimiter">”，people.map</span></span> {{的assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">李四</span> <span class="delimiter">”，</span></span> <span class="local-variable">它</span> .lastName）}}）} <span class="annotation">@Test</span>好玩<span class="error">`</span>不是超时超过测试<span class="error">`（）{VAL</span> fibonacciCalculator = FibonacciCalculator（）VAL结果= assertTimeout（ <span class="predefined-type">持续时间</span> <span class="integer"><span class="integer">.ofMillis（100））{fibonacciCalculator.fib（14）}</span></span>的<span class="integer">assertEquals（377，</span>结果）} <span class="annotation">@Test</span>乐趣<span class="error">`</span>超时超过与抢占终止<span class="error">`（</span> ）{ <span class="comment">//以下断言失败，错误消息类似于：</span> <span class="comment">//执行超时10 ms后</span> assertTimeoutPreemptively（ <span class="predefined-type">持续时间</span> .ofMillis（ <span class="integer">10</span> ））{ <span class="comment">//模拟占用时间超过10毫秒的任务。</span>
            <span class="predefined-type">线程</span> .sleep（ <span class="integer">100</span> ）}}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-assertions-third-party"><a class="anchor" href="#writing-tests-assertions-third-party"></a> 2.4.2。第三方断言库</h4>
<div class="paragraph">
<p>即使JUnit Jupiter提供的断言功能足以满足许多测试场景，但有时需要或需要更多功能和附加功能（如<em>匹配器）</em> 。在这种情况下，JUnit团队建议使用第三方断言库，如<a href="https://joel-costigliola.github.io/assertj/">AssertJ</a> ， <a href="https://hamcrest.org/JavaHamcrest/">Hamcrest</a> ， <a href="https://google.github.io/truth/">Truth</a>等。因此，开发人员可以自由使用他们选择的断言库。</p>
</div>
<div class="paragraph">
<p>例如， <em>匹配器</em>和流畅API的组合可用于使断言更具描述性和可读性。但是，JUnit Jupiter的<code><a href="../api/org/junit/jupiter/api/Assertions.html">org.junit.jupiter.api.Assertions</a></code>类不提供类似于JUnit 4的<code>org.junit.的<a href="https://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat"><code>assertThat()</code></a>方法<code>org.junit.Assert</code>接受Hamcrest <a href="https://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html"><code>Matcher</code></a> 。相反，鼓励开发人员使用第三方断言库提供的对匹配器的内置支持。</p>
</div>
<div class="paragraph">
<p>以下示例演示如何在JUnit Jupiter测试中使用Hamcrest的<code>assertThat()</code>支持。只要将Hamcrest库添加到类路径中，就可以静态导入<code>assertThat()</code> ， <code>is()</code>和<code>equalTo()</code> ，然后在下面的<code>assertWithHamcrestMatcher()</code>方法中使用它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.hamcrest.CoreMatchers.equalTo</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.hamcrest.CoreMatchers.is</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.hamcrest.MatcherAssert.assertThat</span> ; <span class="keyword">import</span> <span class="include">example.util。计算器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="type">class</span> <span class="class">HamcrestAssertionsDemo</span> { <span class="directive">private</span> <span class="directive">final</span> Calculator calculator = <span class="keyword">new</span> Calculator（）; <span class="annotation">@Test</span> <span class="type">空隙</span> <span class="integer"><span class="integer">assertWithHamcrestMatcher（）{assertThat（calculator.subtract（4，1），</span></span>是<span class="integer">（equalTo（3）））;</span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，基于JUnit 4编程模型的遗留测试可以继续使用<code>org.junit.Assert#assertThat</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-assumptions"><a class="anchor" href="#writing-tests-assumptions"></a> 2.5。假设</h3>
<div class="paragraph">
<p>JUnit Jupiter附带了JUnit 4提供的假设方法的一个子集，并添加了一些非常适合与Java 8 lambda表达式和方法引用一起使用的方法。所有JUnit Jupiter假设都是<code><a href="../api/org/junit/jupiter/api/Assumptions.html">org.junit.jupiter.api.中的静态方法<code><a href="../api/org/junit/jupiter/api/Assumptions.html">org.junit.jupiter.api.Assumptions</a></code>类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assumptions.assumeTrue</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assumptions.assumingThat</span> ; <span class="keyword">import</span> <span class="include">example.util。计算器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="type">class</span> <span class="class">AssumptionsDemo</span> { <span class="directive">private</span> <span class="directive">final</span> Calculator calculator = <span class="keyword">new</span> Calculator（）; <span class="annotation">@Test</span> <span class="type">void</span> testOnlyOnCiServer（）{assumeTrue（ <span class="string"><span class="delimiter">“</span> <span class="content">CI</span> <span class="delimiter">”</span></span> .equals（ <span class="predefined-type">System</span> .getenv（ <span class="string"><span class="delimiter">“</span> <span class="content">ENV</span> <span class="delimiter">”</span></span> ）））; <span class="comment">//测试的剩余部分</span> } <span class="annotation">@Test</span> <span class="type">void</span> testOnlyOnDeveloperWorkstation（）{assumeTrue（ <span class="string"><span class="delimiter">“</span> <span class="content">DEV</span> <span class="delimiter">”</span></span> .equals（ <span class="predefined-type">System</span> .getenv（ <span class="string"><span class="delimiter">“</span> <span class="content">ENV</span> <span class="delimiter">”</span></span> ）），（） - &gt; <span class="string"><span class="delimiter">“</span> <span class="content">中止测试：不在开发人员工作站上</span> <span class="delimiter">”</span></span> ）; <span class="comment">//测试的剩余部分</span> } <span class="annotation">@Test</span> <span class="type">void</span> testInAllEnvironments（）{assumeThat（ <span class="string"><span class="delimiter">“</span> <span class="content">CI</span> <span class="delimiter">”</span></span> .equals（ <span class="predefined-type">System</span> .getenv（ <span class="string"><span class="delimiter">“</span> <span class="content">ENV</span> <span class="delimiter">”</span></span> ）），（） - &gt; { <span class="comment">//仅在CI服务器上执行这些断言</span> assertEquals（ <span class="integer">2</span> ， <span class="integer"><span class="integer">calculator.divide（4，2））;}）;</span></span> <span class="comment">//在所有环境中</span>的assertEquals <span class="comment">进行这些断言</span> <span class="integer"><span class="integer"><span class="integer">（42，calculator.multiply（6,7））;</span></span></span> }}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从JUnit Jupiter 5.4开始，也可以使用JUnit 4的<code>org.junit.Assume</code>类的假设。具体来说，JUnit Jupiter支持JUnit 4的<code>AssumptionViolatedException</code>来表示应该中止测试而不是标记为失败。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-disabling"><a class="anchor" href="#writing-tests-disabling"></a> 2.6。禁用测试</h3>
<div class="paragraph">
<p>可以通过<code><a href="../api/org/junit/jupiter/api/Disabled.html">@Disabled</a></code>注释，通过<a href="#writing-tests-conditional-execution">条件测试执行中</a>讨论的注释之一或通过自定义<a href="#extensions-conditions"><code>ExecutionCondition</code></a> <em>禁用</em>整个测试类或单个测试方法。</p>
</div>
<div class="paragraph">
<p>这是一个<code>@Disabled</code>测试类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.junit.jupiter.api。残疾</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="annotation">@Disabled</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">在修复bug＃99之前已</span></span> <span class="class">禁用</span> <span class="string"><span class="delimiter">”</span></span> ） <span class="type">class</span> <span class="class">DisabledClassDemo</span> { <span class="annotation">@Test</span> <span class="type">void</span> testWillBeSkipped（）{}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个包含<code>@Disabled</code>测试方法的测试类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.junit.jupiter.api。残疾</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="type">class</span> <span class="class">DisabledTestsDemo</span> { <span class="annotation">@Disabled</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">禁用直到bug＃42已解决</span> <span class="delimiter">”</span></span> ） <span class="annotation">@Test</span> <span class="type">void</span> testWillBeSkipped（）{} <span class="annotation">@Test</span> <span class="type">void</span> testWillBeExecuted（）{}}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
可以在没有提供<em>理由的</em>情况下声明<code>@Disabled</code> ;但是，JUnit团队建议开发人员提供一个简短的解释，说明为什么禁用了测试类或测试方法。因此，上面的例子都显示了一个原因的使用 - 例如， <code>@Disabled("Disabled until bug #42 has been resolved")</code> 。一些开发团队甚至要求在自动可追溯性等<em>原因中</em>存在问题跟踪编号。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-conditional-execution"><a class="anchor" href="#writing-tests-conditional-execution"></a> 2.7。条件测试执行</h3>
<div class="paragraph">
<p>JUnit Jupiter中的<a href="#extensions-conditions"><code>ExecutionCondition</code></a>扩展API允许开发人员以<em>编程方式</em>基于某些条件<em>启用</em>或<em>禁用</em>容器或测试。这种情况最简单的例子是内置的<code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/DisabledCondition.java">DisabledCondition</a></code> ，它支持<code><a href="../api/org/junit/jupiter/api/Disabled.html">@Disabled</a></code>注释（请参阅<a href="#writing-tests-disabling">禁用测试</a> ）。除了<code>@Disabled</code> ，JUnit Jupiter还支持<code>org.junit.jupiter.api.condition</code>包中的其他几个基于注释的条件，允许开发人员以<em>声明方式</em>启用或禁用容器和测试。有关详细信息，请参阅以下部分</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">组合注释</div>
<div class="paragraph">
<p>请注意，以下部分中列出的任何<em>条件</em>注释也可以用作元注释，以便创建自定义<em>组合注释</em> 。例如， <code>@TestOnMac</code> <a href="#writing-tests-conditional-execution-os-demo">EnabledOnOs演示</a>中的<code>@TestOnMac</code>注释显示了如何在单个可重用注释中组合<code>@Test</code>和<code>@EnabledOnOs</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下部分中列出的每个<em>条件</em>注释只能在给定的测试接口，测试类或测试方法上声明一次。如果条件注释在给定元素上直接存在，间接存在或元存在多次，则仅使用JUnit发现的第一个这样的注释;任何其他声明都将被默默忽略。但请注意，每个条件注释都可以与<code>org.junit.jupiter.api.condition</code>包中的其他条件注释一起使用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="writing-tests-conditional-execution-os"><a class="anchor" href="#writing-tests-conditional-execution-os"></a> 2.7.1。操作系统条件</h4>
<div class="paragraph">
<p>可以通过<code><a href="../api/org/junit/jupiter/api/condition/EnabledOnOs.html">@EnabledOnOs</a></code>和<code><a href="../api/org/junit/jupiter/api/condition/DisabledOnOs.html">@DisabledOnOs</a></code>注释在特定操作系统上启用或禁用容器或测试。</p>
</div>
<div id="writing-tests-conditional-execution-os-demo" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@EnabledOnOs</span> （MAC） <span class="type">void</span> onlyOnMacOs（）{ <span class="comment">// ...</span>} <span class="annotation">@TestOnMac</span> <span class="type">void</span> testOnMac（）{ <span class="comment">// ...</span>} <span class="annotation">@Test</span> <span class="annotation">@EnabledOnOs</span> （{LINUX，MAC}） <span class="type">void</span> onLinuxOrMac（）{ <span class="comment">// ...</span>} <span class="annotation">@Test</span> <span class="annotation">@DisabledOnOs</span> （WINDOWS） <span class="type">void</span> notOnWindows（）{ <span class="comment">// ...</span>} <span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。方法） <span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Test</span> <span class="annotation">@EnabledOnOs</span> （MAC） <span class="annotation">@interface</span> TestOnMac {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-conditional-execution-jre"><a class="anchor" href="#writing-tests-conditional-execution-jre"></a> 2.7.2。Java运行时环境条件</h4>
<div class="paragraph">
<p>可以通过<code><a href="../api/org/junit/jupiter/api/condition/EnabledOnJre.html">@EnabledOnJre</a></code>和<code><a href="../api/org/junit/jupiter/api/condition/DisabledOnJre.html">@DisabledOnJre</a></code>注释在特定版本的Java运行时环境（JRE）上启用或禁用容器或测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@EnabledOnJre</span> （JAVA_8） <span class="type">void</span> onlyOnJava8（）{ <span class="comment">// ...</span>} <span class="annotation">@Test</span> <span class="annotation">@EnabledOnJre</span> （{JAVA_9，JAVA_10}） <span class="type">void</span> onJava9Or10（）{ <span class="comment">// ...</span>} <span class="annotation">@Test</span> <span class="annotation">@DisabledOnJre</span> （JAVA_9） <span class="type">void</span> notOnJava9（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-conditional-execution-system-properties"><a class="anchor" href="#writing-tests-conditional-execution-system-properties"></a> 2.7.3。系统属性条件</h4>
<div class="paragraph">
<p>可以通过<code><a href="../api/org/junit/jupiter/api/condition/EnabledIfSystemProperty.html">@EnabledIfSystemProperty</a></code>和<code><a href="../api/org/junit/jupiter/api/condition/DisabledIfSystemProperty.html">@DisabledIfSystemProperty</a></code>注释，根据<code>named</code> JVM系统属性的值启用或禁用容器或测试。通过<code>matches</code>属性提供的值将被解释为正则表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@EnabledIfSystemProperty</span> （named = <span class="string"><span class="delimiter">“</span> <span class="content">os.arch</span> <span class="delimiter">”</span></span> ，matches = <span class="string"><span class="delimiter">“</span> <span class="content">。* 64. *</span> <span class="delimiter">“</span></span> ） <span class="type">void</span> onlyOn64BitArchitectures（）{ <span class="comment">// ...</span>} <span class="annotation">@Test</span> <span class="annotation">@DisabledIfSystemProperty</span> （named = <span class="string"><span class="delimiter">“</span> <span class="content">ci-server</span> <span class="delimiter">”</span></span> ，matches = <span class="string"><span class="delimiter">“</span> <span class="content">true</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> notOnCiServer（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-conditional-execution-environment-variables"><a class="anchor" href="#writing-tests-conditional-execution-environment-variables"></a> 2.7.4。环境可变条件</h4>
<div class="paragraph">
<p>可以基于来自底层操作系统的<code>named</code>环境变量的值，通过<code><a href="../api/org/junit/jupiter/api/condition/EnabledIfEnvironmentVariable.html">@EnabledIfEnvironmentVariable</a></code>和<code><a href="../api/org/junit/jupiter/api/condition/DisabledIfEnvironmentVariable.html">@DisabledIfEnvironmentVariable</a></code>注释来启用或禁用容器或测试。通过<code>matches</code>属性提供的值将被解释为正则表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@EnabledIfEnvironmentVariable</span> （named = <span class="string"><span class="delimiter">“</span> <span class="content">ENV</span> <span class="delimiter">”</span></span> ，matches = <span class="string"><span class="delimiter">“</span> <span class="content">staging-server</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> onlyOnStagingServer（）{ <span class="comment">// ...</span>} <span class="annotation">@Test</span> <span class="annotation">@DisabledIfEnvironmentVariable</span> （named = <span class="string"><span class="delimiter">“</span> <span class="content">ENV</span> <span class="delimiter">”</span></span> ，matches = <span class="string"><span class="delimiter">“</span> <span class="content">。* development。*</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> notOnDeveloperWorkstation（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-conditional-execution-scripts"><a class="anchor" href="#writing-tests-conditional-execution-scripts"></a> 2.7.5。基于脚本的条件</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">通过<code><a href="../api/org/junit/jupiter/api/condition/EnabledIf.html">@EnabledIf</a></code>和<code><a href="../api/org/junit/jupiter/api/condition/DisabledIf.html">@DisabledIf</a></code>条件测试执行已<em>弃用，</em>以便在将来的JUnit Jupiter版本中删除。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>JUnit Jupiter提供了<em>启用</em>或<em>禁用</em>容器或测试的功能，具体取决于通过<code><a href="../api/org/junit/jupiter/api/condition/EnabledIf.html">@EnabledIf</a></code>或<code><a href="../api/org/junit/jupiter/api/condition/DisabledIf.html">@DisabledIf</a></code>注释配置的脚本的评估。脚本可以用JavaScript，Groovy或任何其他脚本语言编写，这些脚本语言支持Java Scripting API，由JSR 223定义。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果脚本的逻辑仅依赖于当前操作系统，当前Java运行时环境版本，特定JVM系统属性或特定环境变量，则应考虑使用专用于此目的的其中一个内置注释。有关更多详细信息，请参阅本章的前几节。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您发现自己多次使用相同的基于脚本的条件，请考虑编写专用的<a href="#extensions-conditions">ExecutionCondition</a>扩展，以便以更快，类型安全且更易于维护的方式实现条件。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="comment">//静态JavaScript表达式。</span>
<span class="annotation">@EnabledIf</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">2 * 3 == 6</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> willBeExecuted（）{ <span class="comment">// ...</span>} <span class="annotation">@RepeatedTest</span> （ <span class="integer">10</span> ） <span class="comment">//动态JavaScript表达式。</span>
<span class="annotation">@DisabledIf</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">Math.random（）&lt;0.314159</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> mayNotBeExecuted（）{ <span class="comment">// ...</span>} <span class="annotation">@Test</span> <span class="comment">//正则表达式测试绑定系统属性。</span>
<span class="annotation">@DisabledIf</span> （ <span class="string"><span class="delimiter">“/</span> <span class="content">32/</span></span> <span class="annotation">.test</span> ( <span class="annotation">systemProperty.get</span> ( <span class="string"><span class="delimiter">'</span> <span class="content">os.arch'））</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> disabledOn32BitArchitectures（）{assertFalse（ <span class="predefined-type">System</span> .getProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">os.arch</span> <span class="delimiter">”</span></span> ）。enctains（ <span class="string"><span class="delimiter">“</span> <span class="content">32</span> <span class="delimiter">”</span></span> ））; } <span class="annotation">@Test</span> <span class="annotation">@EnabledIf</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">'CI'==</span></span> <span class="annotation">systemEnvironment.get</span> （ <span class="string"><span class="content">'ENV'）</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> onlyOnCiServer（）{assertTrue（ <span class="string"><span class="delimiter">“</span> <span class="content">CI</span> <span class="delimiter">”</span></span> .equals（ <span class="predefined-type">System</span> .getenv（ <span class="string"><span class="delimiter">“</span> <span class="content">ENV</span> <span class="delimiter">”</span></span> ）））; } <span class="annotation">@Test</span> <span class="comment">//多行脚本，自定义引擎名称和自定义原因。</span>
<span class="annotation">@EnabledIf</span> （value = { <span class="string"><span class="delimiter">“</span> <span class="content">load（'nashorn：mozilla_compat.js'）</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">importPackage（java.time）</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">var today = LocalDate.now（）</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">var tomorrow = today.plusDays（ 1）</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">tomorrow.isAfter（今天）</span> <span class="delimiter">“</span></span> }，engine = <span class="string"><span class="delimiter">”</span> <span class="content">nashorn</span> <span class="delimiter">“</span></span> ，reason = <span class="string"><span class="delimiter">”</span> <span class="content">自我实现：{result}</span> <span class="delimiter">“</span></span> ） <span class="type">void</span> theDayAfterTomorrow（）{LocalDate today = LocalDate.now（）;明天的LocalDate = today.plusDays（ <span class="integer">1</span> ）; assertTrue（tomorrow.isAfter（今天））; }</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-conditional-execution-scripts-bindings"><a class="anchor" href="#writing-tests-conditional-execution-scripts-bindings"></a>脚本绑定</h5>
<div class="paragraph">
<p>以下名称绑定到每个脚本上下文，因此可在脚本中使用。一个<em>访问器</em>提供通过简单的访问地图状结构<code>String get(String name)</code>方法。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:60%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>systemEnvironment</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>访问</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作系统环境变量访问器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>systemProperty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>访问</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JVM系统属性访问器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>junitConfigurationParameter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>访问</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置参数访问器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>junitDisplayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>串</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示测试或容器的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>junitTags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>设置&lt;字符串&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">分配给测试或容器的所有标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>junitUniqueId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>串</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">测试或容器的唯一ID。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-tagging-and-filtering"><a class="anchor" href="#writing-tests-tagging-and-filtering"></a> 2.8。标记和过滤</h3>
<div class="paragraph">
<p>可以通过<code>@Tag</code>注释标记测试类和方法。稍后可以使用这些标记来过滤<a href="#running-tests">测试发现和执行</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">另请参阅： <a href="#running-tests-tag-expressions">标记表达式</a>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="syntax-rules-for-tags"><a class="anchor" href="#syntax-rules-for-tags"></a> 2.8.1。标签的语法规则</h4>
<div class="ulist">
<ul>
<li>
<p>标签不能为<code>null</code>或<em>空白</em> 。</p>
</li>
<li>
<p><em>修剪过的</em>标签不得包含空格。</p>
</li>
<li>
<p><em>修剪过的</em>标签不得包含ISO控制字符。</p>
</li>
<li>
<p><em>修剪过的</em>标签不得包含以下任何<em>保留字符</em> 。</p>
<div class="ulist">
<ul>
<li>
<p><code>,</code> ： <em>逗号</em></p>
</li>
<li>
<p><code>(</code> ： <em>左括号</em></p>
</li>
<li>
<p><code>)</code> ： <em>右括号</em></p>
</li>
<li>
<p><code>&amp;</code> ： <em>＆符号</em></p>
</li>
<li>
<p><code>|</code> ： <em>竖条</em></p>
</li>
<li>
<p><code>!</code> ： <em>感叹号</em></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在上面的上下文中，“trimmed”表示已删除前导和尾随空白字符。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.junit.jupiter.api。标签</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">fast</span> <span class="delimiter">”</span></span> ） <span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">model</span> <span class="delimiter">”</span></span> ） <span class="type">class</span> <span class="class">TaggingDemo</span> { <span class="annotation">@Test</span> <span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">tax</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testingTaxCalculation（）{}}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关如何为标记创建自定义注释的示例，请参阅<a href="#writing-tests-meta-annotations">Meta-Annotations和Composed Annotations</a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-test-execution-order"><a class="anchor" href="#writing-tests-test-execution-order"></a> 2.9。测试执行顺序</h3>
<div class="paragraph">
<p>默认情况下，测试方法将使用确定性但有意不明显的算法进行排序。这确保了测试套件的后续运行以相同的顺序执行测试方法，从而允许可重复的构建。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">见<a href="#writing-tests-classes-and-methods">测试类和方法</a>的<em>测试方法</em>的定义。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>虽然真正的<em>单元测试</em>通常不应该依赖于它们的执行顺序，但有时需要强制执行特定的测试方法执行顺序 - 例如，在编写<em>集成测试</em>或<em>功能测试时</em> ， <em>测试</em>的顺序是很重要，特别是与<code>@TestInstance(Lifecycle.PER_CLASS)</code> 。</p>
</div>
<div class="paragraph">
<p>要控制执行测试方法的顺序，请使用<code><a href="../api/org/junit/jupiter/api/TestMethodOrder.html">@TestMethodOrder</a></code>注释测试类或测试接口，并指定所需的<code><a href="../api/org/junit/jupiter/api/MethodOrderer.html">MethodOrderer</a></code>实现。您可以实现自己的自定义<code>MethodOrderer</code>或使用以下内置<code>MethodOrderer</code>实现之一。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../api/org/junit/jupiter/api/MethodOrderer.Alphanumeric.html">Alphanumeric</a></code> ：根据<em>字母</em>名称和形式参数列表以<em>字母数字</em>的形式对测试方法进行排序。</p>
</li>
<li>
<p><code><a href="../api/org/junit/jupiter/api/MethodOrderer.OrderAnnotation.html">OrderAnnotation</a></code> ：根据通过<code><a href="../api/org/junit/jupiter/api/Order.html">@Order</a></code>注释指定的值以<em>数字方式</em>对测试方法进行排序。</p>
</li>
<li>
<p><code><a href="../api/org/junit/jupiter/api/MethodOrderer.Random.html">Random</a></code> ： <em>伪随机</em>命令测试方法，并支持自定义<em>种子的</em>配置。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">另请参阅： <a href="#extensions-execution-order-wrapping-behavior">回调的包装行为</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例演示如何保证测试方法按照通过<code>@Order</code>注释指定的顺序执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.junit.jupiter.api。MethodOrderer。OrderAnnotation</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。订单</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。TestMethodOrder</span> ; <span class="annotation">@TestMethodOrder</span> （OrderAnnotation.class） <span class="type">类</span> <span class="class">OrderedTestsDemo</span> { <span class="annotation">@Test</span> <span class="annotation">@Order</span> （ <span class="integer">1</span> ） <span class="type">void</span> nullValues（）{ <span class="comment">//对空值执行断言</span> } <span class="annotation">@Test</span> <span class="annotation">@Order</span> （ <span class="integer">2</span> ） <span class="type">void</span> emptyValues（）{ <span class="comment">//对空值执行断言</span> } <span class="annotation">@Test</span> <span class="annotation">@Order</span> （ <span class="integer">3</span> ） <span class="type">void</span> validValues（）{ <span class="comment">//对有效值执行断言</span> }}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-test-instance-lifecycle"><a class="anchor" href="#writing-tests-test-instance-lifecycle"></a> 2.10。测试实例生命周期</h3>
<div class="paragraph">
<p>为了允许单独执行单个测试方法并避免由于可变测试实例状态引起的意外副作用，JUnit在执行每个<em>测试方法</em>之前创建每个测试类的新实例（请参阅<a href="#writing-tests-classes-and-methods">测试类和方法</a> ）。这个“per-method”测试实例生命周期是JUnit Jupiter中的默认行为，类似于所有以前版本的JUnit。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，如果通过<a href="#writing-tests-conditional-execution">条件</a> （例如， <code>@Disabled</code> ， <code>@DisabledOnOs</code>等） <em>禁用</em>给定的<em>测试方法</em> ，即使“per-method”测试实例生命周期模式处于活动状态，测试类仍将被实例化。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您希望JUnit Jupiter在同一测试实例上执行所有测试方法，请使用<code>@TestInstance(Lifecycle.注释您的测试类<code>@TestInstance(Lifecycle.PER_CLASS)</code> 。使用此模式时，将为每个测试类创建一个新的测试实例。因此，如果您的测试方法依赖于存储在实例变量中的状态，则可能需要在<code>@BeforeEach</code>或<code>@AfterEach</code>方法中重置该状态。</p>
</div>
<div class="paragraph">
<p>“每类”模式比默认的“每个方法”模式有一些额外的好处。具体来说，使用“每类”模式，可以在非静态方法和接口<code>default</code>方法上声明<code>@BeforeAll</code>和<code>@AfterAll</code> 。因此，“每类”模式还可以在<code>@Nested</code>测试类中使用<code>@BeforeAll</code>和<code>@AfterAll</code>方法。</p>
</div>
<div class="paragraph">
<p>如果您使用Kotlin编程语言编写测试，您可能会发现通过切换到“每类”测试实例生命周期模式更容易实现<code>@BeforeAll</code>和<code>@AfterAll</code>方法。</p>
</div>
<div class="sect3">
<h4 id="writing-tests-test-instance-lifecycle-changing-default"><a class="anchor" href="#writing-tests-test-instance-lifecycle-changing-default"></a> 2.10.1。更改默认测试实例生命周期</h4>
<div class="paragraph">
<p>如果测试类或测试接口未使用<code>@TestInstance</code>注释，则JUnit Jupiter将使用<em>默认的</em>生命周期模式。标准<em>默认</em>模式为<code>PER_METHOD</code> ;但是，可以更改执行整个测试计划的<em>默认值</em> 。要更改默认测试实例生命周期模式，请将<code>junit.jupiter.testinstance.lifecycle.default</code> <em>配置参数</em>设置为<code>junit.jupiter.testinstance.lifecycle.default</code>定义的枚举常量的名称<code>TestInstance.Lifecycle</code> ，无视案例。这可以作为JVM系统属性提供，作为传递给<code>Launcher</code>的<code>LauncherDiscoveryRequest</code>中的<em>配置参数</em>提供，或者通过JUnit Platform配置文件提供（有关详细信息，请参阅<a href="#running-tests-config-params">配置参数</a> ）。</p>
</div>
<div class="paragraph">
<p>例如，将默认测试实例生命周期模式设置为<code>Lifecycle.PER_CLASS</code> ，您可以使用以下系统属性启动JVM。</p>
</div>
<div class="paragraph">
<p><code>-Djunit.jupiter.testinstance.lifecycle.default = per_class</code></p>
</div>
<div class="paragraph">
<p>但请注意，通过JUnit Platform配置文件设置默认测试实例生命周期模式是一种更强大的解决方案，因为配置文件可以与项目一起检入版本控制系统，因此可以在IDE和构建软件中使用。</p>
</div>
<div class="paragraph">
<p>将默认测试实例生命周期模式设置为<code>Lifecycle.PER_CLASS</code>通过JUnit Platform配置文件，在类路径的根目录（例如， <code>src/test/resources</code> ）中创建一个名为<code>junit-platform.properties</code>文件，其中包含以下内容。</p>
</div>
<div class="paragraph">
<p><code>junit.jupiter.testinstance.lifecycle.default = per_class</code></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果不一致地应用，更改<em>默认</em>测试实例生命周期模式可能会导致不可预测的结果和脆弱的构建。例如，如果构建将“per-class”语义配置为默认语言，但IDE中的测试使用“per-method”语义执行，这会使调试构建服务器上发生的错误变得困难。因此，建议更改JUnit Platform配置文件中的缺省值，而不是通过JVM系统属性。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-nested"><a class="anchor" href="#writing-tests-nested"></a> 2.11。嵌套测试</h3>
<div class="paragraph">
<p><code>@Nested</code>测试为测试编写者提供了更多表达几组测试之间关系的能力。这是一个精心制作的例子。</p>
</div>
<div class="listingblock">
<div class="title">用于测试堆栈的嵌套测试套件</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertFalse</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertThrows</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertTrue</span> ; <span class="keyword">import</span> <span class="include">java.util。EmptyStackException</span> ; <span class="keyword">import</span> <span class="include">java.util。堆栈</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。BeforeEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DisplayName</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。嵌套</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">A stack</span> <span class="delimiter">”</span></span> ） <span class="type">类</span> <span class="class">TestingAStackDemo</span> { <span class="predefined-type">Stack</span> &lt; <span class="predefined-type">Object</span> &gt; stack; <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">用new Stack（）实例化</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> isInstantiatedWithNew（）{ <span class="keyword">new</span> <span class="predefined-type">Stack</span> &lt;&gt;（）; <span class="annotation">@Nested</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">when new</span> <span class="delimiter">”时</span></span> ） <span class="type">类</span> <span class="class">WhenNew</span> { <span class="annotation">@BeforeEach</span> <span class="type">void</span> createNewStack（）{stack = <span class="keyword">new</span> <span class="predefined-type">Stack</span> &lt;&gt;（）; } <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">is empty</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> isEmpty（）{assertTrue（stack.isEmpty（））; } <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">弹出时抛出EmptyStackException</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> throwsExceptionWhenPopped（）{assertThrows（ <span class="exception">EmptyStackException</span> .class，stack :: pop）; } <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">当偷看时抛出EmptyStackException</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> throwsExceptionWhenPeeked（）{assertThrows（ <span class="exception">EmptyStackException</span> .class，stack :: peek）; <span class="annotation">@Nested</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">推送元素后</span> <span class="delimiter">”</span></span> ） <span class="type">类</span> <span class="class">AfterPushing</span> { <span class="predefined-type">String</span> anElement = <span class="string"><span class="delimiter">“</span> <span class="content">an element</span> <span class="delimiter">”</span></span> ; <span class="annotation">@BeforeEach</span> <span class="type">void</span> pushAnElement（）{stack.push（anElement）; } <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">它不再是空的</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> isNotEmpty（）{assertFalse（stack.isEmpty（））; } <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">弹出时返回元素并为空</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> returnElementWhenPopped（）{assertEquals（anElement，stack.pop（））; assertTrue（stack.isEmpty（））; <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">在</span></span> <span class="annotation">查看</span> <span class="string"><span class="content">时返回该元素但仍然不为空</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> returnElementWhenPeeked（）{assertEquals（anElement，stack.peek（））; assertFalse（stack.isEmpty（））; }}}}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<em>只有非静态嵌套类</em> （即<em>内部类</em> ）才能用作<code>@Nested</code>测试类。嵌套可以任意深入，并且这些内部类被认为是测试类系列的完整成员，但有一个例外： <code>@BeforeAll</code>和<code>@AfterAll</code>方法<em>默认</em>不起作用。原因是Java不允许内部类中的<code>static</code>成员。但是，可以通过使用<code>@TestInstance(Lifecycle.注释<code>@Nested</code>测试类来规避此限制<code>@TestInstance(Lifecycle.PER_CLASS)</code> （参见<a href="#writing-tests-test-instance-lifecycle">测试实例生命周期</a> ）。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-dependency-injection"><a class="anchor" href="#writing-tests-dependency-injection"></a> 2.12。构造函数和方法的依赖注入</h3>
<div class="paragraph">
<p>在所有以前的JUnit版本中，不允许测试构造函数或方法具有参数（至少不使用标准的<code>Runner</code>实现）。作为JUnit Jupiter的主要变化之一，现在允许测试构造函数和方法都有参数。这允许更大的灵活性并为构造函数和方法启用<em>依赖注入</em> 。</p>
</div>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/ParameterResolver.html">ParameterResolver</a></code>为希望在运行时<em>动态</em>解析参数的测试扩展定义API。如果<em>测试类</em>构造函数， <em>测试方法</em>或<em>生命周期方法</em> （请参阅<a href="#writing-tests-classes-and-methods">测试类和方法</a> ）接受参数，则必须在运行时通过已注册的<code>ParameterResolver</code>解析该<code>ParameterResolver</code> 。</p>
</div>
<div class="paragraph">
<p>目前有三个自动注册的内置解析器。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestInfoParameterResolver.java">TestInfoParameterResolver</a></code> ：如果构造函数或方法参数的类型为<code><a href="../api/org/junit/jupiter/api/TestInfo.html">TestInfo</a></code> ，则<code>TestInfoParameterResolver</code>将提供与当前容器或test对应的<code>TestInfo</code>实例作为参数的值。然后，可以使用<code>TestInfo</code>检索有关当前容器或测试的信息，例如显示名称，测试类，测试方法和关联的标记。显示名称是技术名称，例如测试类或测试方法的名称，或通过<code>@DisplayName</code>配置的自定义名称。</p>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/TestInfo.html">TestInfo</a></code>充当JUnit 4中<code>TestName</code>规则的替代品。下面演示了如何将<code>TestInfo</code>注入到测试构造函数， <code>@BeforeEach</code>方法和<code>@Test</code>方法中。</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertTrue</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。BeforeEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DisplayName</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。标签</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。TestInfo</span> ; <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">TestInfo Demo</span> <span class="delimiter">”</span></span> ） <span class="type">类</span> <span class="class">TestInfoDemo</span> {TestInfoDemo（TestInfo testInfo）{assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">TestInfo Demo</span> <span class="delimiter">”</span></span> ，testInfo.getDisplayName（））; } <span class="annotation">@BeforeEach</span> <span class="type">void</span> init（TestInfo testInfo）{ <span class="predefined-type">String</span> displayName = testInfo.getDisplayName（）; assertTrue（displayName.equals（ <span class="string"><span class="delimiter">“</span> <span class="content">TEST 1</span> <span class="delimiter">”</span></span> ）|| displayName.equals（ <span class="string"><span class="delimiter">“</span> <span class="content">test2（）</span> <span class="delimiter">”</span></span> ））; } <span class="annotation">@Test</span> <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">TEST 1</span> <span class="delimiter">”</span></span> ） <span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">my-tag</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> test1（TestInfo testInfo）{assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">TEST 1</span> <span class="delimiter">”</span></span> ，testInfo.getDisplayName（））; assertTrue（testInfo.getTags（）。contains（ <span class="string"><span class="delimiter">“</span> <span class="content">my-tag</span> <span class="delimiter">”</span></span> ））; } <span class="annotation">@Test</span> <span class="type">void</span> test2（）{}}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/RepetitionInfoParameterResolver.java">RepetitionInfoParameterResolver</a></code> ：如果在一个方法参数<code>@RepeatedTest</code> ， <code>@BeforeEach</code> ，或<code>@AfterEach</code>方法是类型的<code><a href="../api/org/junit/jupiter/api/RepetitionInfo.html">RepetitionInfo</a></code> ，所述<code>RepetitionInfoParameterResolver</code>将提供的实例<code>RepetitionInfo</code> 。然后可以使用<code>RepetitionInfo</code>检索有关当前重复的信息以及相应的<code>@RepeatedTest</code>的重复总次数。但请注意， <code>RepetitionInfoParameterResolver</code>未在<code>@RepeatedTest</code>的上下文之外注册。请参阅<a href="#writing-tests-repeated-tests-examples">重复测试示例</a> 。</p>
</li>
<li>
<p><code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestReporterParameterResolver.java">TestReporterParameterResolver</a></code> ：如果一个构造函数或方法参数的类型的<code><a href="../api/org/junit/jupiter/api/TestReporter.html">TestReporter</a></code> ，所述<code>TestReporterParameterResolver</code>将提供的实例<code>TestReporter</code> 。<code>TestReporter</code>可用于发布有关当前测试运行的其他数据。可以通过<code><a href="../api/org/junit/platform/launcher/TestExecutionListener.html">TestExecutionListener</a></code>的<code>reportingEntryPublished()</code>方法使用该数据，从而允许在IDE中查看或包含在报告中。</p>
<div class="paragraph">
<p>在JUnit Jupiter中，您应该使用<code>TestReporter</code> ，在那里您将信息打印到JUnit 4中的<code>stdout</code>或<code>stderr</code> 。使用<code>@RunWith(JUnitPlatform.class)</code>将所有报告的条目输出到<code>stdout</code> 。此外，某些IDE会将报告条目打印到<code>stdout</code>或在用户界面中显示它们以获取测试结果。</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TestReporterDemo</span> { <span class="annotation">@Test</span> <span class="type">void</span> reportSingleValue（TestReporter testReporter）{testReporter.publishEntry（ <span class="string"><span class="delimiter">“</span> <span class="content">a status message</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Test</span> <span class="type">void</span> reportKeyValuePair（TestReporter testReporter）{testReporter.publishEntry（ <span class="string"><span class="delimiter">“</span> <span class="content">a key</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">a value</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Test</span> <span class="type">void</span> reportMultipleKeyValuePairs（TestReporter testReporter）{ <span class="predefined-type">Map</span> &lt; <span class="predefined-type">String</span> ， <span class="predefined-type">String</span> &gt; values = <span class="keyword">new</span> <span class="predefined-type">HashMap</span> &lt;&gt;（）; values.put（ <span class="string"><span class="delimiter">“</span> <span class="content">用户名</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">dk38</span> <span class="delimiter">”</span></span> ）; values.put（ <span class="string"><span class="delimiter">“</span> <span class="content">奖励年</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">1974</span> <span class="delimiter">”</span></span> ）; testReporter.publishEntry（值）; }}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">必须通过<code>@ExtendWith</code>注册适当的<a href="#extensions">扩展</a>来显式启用其他参数解析器。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>查看<code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-extensions/src/main/java/com/example/random/RandomParametersExtension.java">RandomParametersExtension</a></code>以获取自定义<code><a href="../api/org/junit/jupiter/api/extension/ParameterResolver.html">ParameterResolver</a></code>的示例。虽然不打算生产就绪，但它展示了扩展模型和参数解析过程的简单性和表现力。<code>MyRandomParametersTest</code>演示了如何将随机值注入<code>@Test</code>方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtendWith</span> （RandomParametersExtension.class） <span class="type">类</span> <span class="class">MyRandomParametersTest</span> { <span class="annotation">@Test</span> <span class="type">void</span> injectsInteger（ <span class="annotation">@Random</span> <span class="type">int</span> i， <span class="annotation">@ Random</span> <span class="type">int</span> j）{assertNotEquals（i，j）; } <span class="annotation">@Test</span> <span class="type">void</span> injectsDouble（ <span class="annotation">@Random</span> <span class="type">double</span> d）{assertEquals（ <span class="float">0.0</span> ，d， <span class="float">1.0</span> ）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于实际用例，请查看<code><a href="https://github.com/mockito/mockito/blob/release/2.x/subprojects/junit-jupiter/src/main/java/org/mockito/junit/jupiter/MockitoExtension.java">MockitoExtension</a></code>和<code><a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java">SpringExtension</a></code>的源代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-test-interfaces-and-default-methods"><a class="anchor" href="#writing-tests-test-interfaces-and-default-methods"></a> 2.13。测试接口和默认方法</h3>
<div class="paragraph">
<p>JUnit的木星允许<code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code> ， <code>@TestFactory</code> ， <code>@TestTemplate</code> ， <code>@BeforeEach</code>和<code>@AfterEach</code>在接口中声明<code>default</code>方法。<code>@BeforeAll</code>和<code>@AfterAll</code>既可以在测试接口中的<code>static</code>方法上声明，也可以在接口<code>default</code>方法上声明， <em>如果</em>测试接口或测试类使用<code>@TestInstance(Lifecycle. ）进行注释<code>@TestInstance(Lifecycle.PER_CLASS)</code> （参见<a href="#writing-tests-test-instance-lifecycle">测试实例生命周期</a> ）。这里有些例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@TestInstance</span> （生命周期。PER_CLASS） <span class="type">接口</span> <span class="class">TestLifecycleLogger</span> { <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Logger</span> logger = <span class="predefined-type">Logger</span> .getLogger（TestLifecycleLogger.class.getName（））; <span class="annotation">@BeforeAll</span> <span class="keyword">默认</span> <span class="type">void</span> beforeAllTests（）{logger.info（ <span class="string"><span class="delimiter">“</span> <span class="content">在所有测试之前</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterAll</span> <span class="keyword">默认</span> <span class="type">void</span> afterAllTests（）{logger.info（ <span class="string"><span class="delimiter">“</span> <span class="content">After all tests</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@BeforeEach</span> <span class="keyword">默认</span> <span class="type">void</span> beforeEachTest（TestInfo testInfo）{logger.info（（） - &gt; <span class="predefined-type">String</span> .format（ <span class="string"><span class="delimiter">“</span> <span class="content">关于执行[％s]</span> <span class="delimiter">”</span></span> ，testInfo.getDisplayName（）））; } <span class="annotation">@AfterEach</span> <span class="keyword">默认</span> <span class="type">void</span> afterEachTest（TestInfo testInfo）{logger.info（（） - &gt; <span class="predefined-type">String</span> .format（ <span class="string"><span class="delimiter">“</span> <span class="content">完成执行[％s]</span> <span class="delimiter">”</span></span> ，testInfo.getDisplayName（）））; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">接口</span> <span class="class">TestInterfaceDynamicTestsDemo</span> <span class="annotation">{@TestFactory</span> <span class="keyword">默认</span>流&lt;DynamicTest&gt; dynamicTestsForPalindromes（）{ <span class="keyword">返回</span> Stream.of（ <span class="string"><span class="delimiter">“</span> <span class="content">赛车</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">雷达</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">妈妈</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">爸爸</span> <span class="delimiter">”）.MAP（</span></span>文本- &gt; dynamicTest（文本，（） - &gt; assertTrue （isPalindrome（文本））））; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在测试接口上声明<code>@ExtendWith</code>和<code>@Tag</code> ，以便实现接口的类自动继承其标记和扩展。请参阅<a href="#extensions-lifecycle-callbacks-before-after-execution">测试执行回调之前和之后</a>的<a href="#extensions-lifecycle-callbacks-timing-extension">TimingExtension</a>源代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Tag</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">timed</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ExtendWith</span> （TimingExtension.class） <span class="type">接口</span> <span class="class">TimeExecutionLogger</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在测试类中，您可以实现这些测试接口以应用它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TestInterfaceDemo</span> <span class="directive">实现了</span> TestLifecycleLogger，TimeExecutionLogger，TestInterfaceDynamicTestsDemo { <span class="annotation">@Test</span> <span class="type">void</span> isEqualValue（）{assertEquals（ <span class="integer">1</span> ， <span class="string"><span class="delimiter">“</span> <span class="content">a</span> <span class="delimiter">”</span></span> 。length（）， <span class="string"><span class="delimiter">“</span> <span class="content">总是相等</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行<code>TestInterfaceDemo</code>产生类似于以下内容的输出：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>信息示例。TestLifecycleLogger  - 在所有测试之前INFO示例。TestLifecycleLogger  - 即将执行[dynamicTestsForPalindromes（）] INFO示例。TimingExtension  - 方法[dynamicTestsForPalindromes]花了19毫秒。信息示例。TestLifecycleLogger  - 完成执行[dynamicTestsForPalindromes（）] INFO示例。TestLifecycleLogger  - 即将执行[isEqualValue（）] INFO示例。TimingExtension  - 方法[isEqualValue]耗时1 ms。信息示例。TestLifecycleLogger  - 完成执行[isEqualValue（）] INFO示例。TestLifecycleLogger  - 经过所有测试</pre>
</div>
</div>
<div class="paragraph">
<p>此功能的另一个可能应用是编写接口契约的测试。例如，您可以编写有关<code>Object.equals</code>或<code>Comparable.compareTo</code>应如何表现的测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">Testable</span> &lt;T&gt; {T createValue（）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">接口</span> <span class="class">EqualsContract</span> &lt;T&gt; <span class="directive">扩展</span> Testable &lt;T&gt; {T createNotEqualValue（）; <span class="annotation">@Test</span> <span class="keyword">默认</span> <span class="type">void</span> valueEqualsItself（）{T value = createValue（）; assertEquals（value，value）; } <span class="annotation">@Test</span> <span class="keyword">default</span> <span class="type">void</span> valueDoesNotEqualNull（）{T value = createValue（）; assertFalse（value.equals（ <span class="predefined-constant">null</span> ））; } <span class="annotation">@Test</span> <span class="keyword">default</span> <span class="type">void</span> valueDoesNotEqualDifferentValue（）{T value = createValue（）; T differentValue = createNotEqualValue（）; assertNotEquals（value，differentValue）; assertNotEquals（differentValue，value）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ComparableContract</span> &lt;T <span class="directive">extends</span> <span class="predefined-type">Comparable</span> &lt;T &gt;&gt; <span class="directive">extends</span> Testable &lt;T&gt; {T createSmallerValue（）; <span class="annotation">@Test</span> <span class="keyword">default</span> <span class="type">void</span> returnsZeroWhenComparedToItself（）{T value = createValue（）; assertEquals（ <span class="integer">0</span> ，value.compareTo（value））; } <span class="annotation">@Test</span> <span class="keyword">default</span> <span class="type">void</span> returnsPositiveNumberWhenComparedToSmallerValue（）{T value = createValue（）; T smallerValue = createSmallerValue（）; assertTrue（value.compareTo（smallerValue）&gt; <span class="integer">0</span> ）; } <span class="annotation">@Test</span> <span class="keyword">default</span> <span class="type">void</span> returnsNegativeNumberWhenComparedToLargerValue（）{T value = createValue（）; T smallerValue = createSmallerValue（）; assertTrue（smallerValue.compareTo（value）&lt; <span class="integer">0</span> ）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在您的测试类中，您可以实现两个合同接口，从而继承相应的测试。当然，你必须实现抽象方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">类</span> <span class="class">StringTests</span> <span class="directive">实现</span> ComparableContract &lt; <span class="predefined-type">字符串</span> &gt;，EqualsContract &lt; <span class="predefined-type">字符串</span> &gt; <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="predefined-type">字符串</span> createValue（）{ <span class="keyword">返回</span> <span class="string"><span class="delimiter">“</span> <span class="content">香蕉</span> <span class="delimiter">”;</span></span> } <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="predefined-type">字符串</span> createSmallerValue（）{ <span class="keyword">回报</span> <span class="string"><span class="delimiter">“</span> <span class="content">苹果</span> <span class="delimiter">”;</span></span> <span class="comment">//'a'&lt;'</span> <span class="annotation">b'in</span> <span class="comment">“banana”</span> } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="predefined-type">String</span> createNotEqualValue（）{ <span class="keyword">return</span> <span class="string"><span class="delimiter">“</span> <span class="content">cherry</span> <span class="delimiter">”</span></span> ; }}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">以上测试仅作为示例，因此不完整。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-repeated-tests"><a class="anchor" href="#writing-tests-repeated-tests"></a> 2.14。重复测试</h3>
<div class="paragraph">
<p>JUnit Jupiter提供了通过使用<code>@RepeatedTest</code>注释方法并指定所需的重复总数来重复测试指定次数的能力。每次重复测试的调用都像执行常规<code>@Test</code>方法一样，完全支持相同的生命周期回调和扩展。</p>
</div>
<div class="paragraph">
<p>以下示例演示如何声明名为<code>repeatedTest()</code>的测试，该测试将自动重复10次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RepeatedTest</span> （ <span class="integer">10</span> ） <span class="type">void</span> repeatedTest（）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了指定重复次数外，还可以通过<code>@RepeatedTest</code>注释的<code>name</code>属性为每次重复配置自定义显示名称。此外，显示名称可以是由静态文本和动态占位符的组合组成的模式。目前支持以下占位符。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>{displayName}</code> ：显示<code>@RepeatedTest</code>方法的名称</p>
</li>
<li>
<p><code>{currentRepetition}</code> ：当前的重复次数</p>
</li>
<li>
<p><code>{totalRepetitions}</code> ：重复的总次数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>给定重复的默认显示名称是基于以下模式生成的： <code>"repetition {currentRepetition} of {totalRepetitions}"</code> 。因此，前一个<code>repeatedTest()</code>示例的单个重复的显示名称将是： <code>repetition 1 of 10</code> ， <code>repetition 2 of 10</code> ，等等。如果您希望每次重复的名称中包含<code>@RepeatedTest</code>方法的显示名称，您可以定义自己的自定义模式或使用预定义的<code>RepeatedTest.LONG_DISPLAY_NAME</code>模式。后者等于<code>"{displayName} :: repetition {currentRepetition} of {totalRepetitions}"</code> ，导致个别重复的显示名称，例如<code>repeatedTest() :: repetition 1 of 10</code> ， <code>repeatedTest() :: repetition 2 of 10</code> ，等等。</p>
</div>
<div class="paragraph">
<p>为了以编程方式检索有关当前重复和重复总数的信息，开发人员可以选择将<code>RepetitionInfo</code>实例注入<code>@RepeatedTest</code> ， <code>@BeforeEach</code>或<code>@AfterEach</code>方法。</p>
</div>
<div class="sect3">
<h4 id="writing-tests-repeated-tests-examples"><a class="anchor" href="#writing-tests-repeated-tests-examples"></a> 2.14.1。重复测试示例</h4>
<div class="paragraph">
<p>本节末尾的<code>RepeatedTestsDemo</code>类演示了几个重复测试的示例。</p>
</div>
<div class="paragraph">
<p><code>repeatedTest()</code>方法与上一节中的示例相同;而<code>repeatedTestWithRepetitionInfo()</code>演示了如何将一个<code>RepetitionInfo</code>实例注入到测试中以访问当前重复测试的总重复次数。</p>
</div>
<div class="paragraph">
<p>接下来的两个方法演示了如何在每次重复的显示名称中为<code>@RepeatedTest</code>方法包含自定义<code>@DisplayName</code> 。 <code>customDisplayName()</code>将自定义显示名称与自定义模式组合在一起，然后使用<code>TestInfo</code>验证生成的显示名称的格式。<code>重复！</code> 是来自<code>@DisplayName</code>声明的<code>{displayName}</code> ，而<code>1/1</code>来自<code>{currentRepetition}/{totalRepetitions}</code> 。与此相反， <code>customDisplayNameWithLongPattern()</code>使用上述预定<code>RepeatedTest.LONG_DISPLAY_NAME</code>图案。</p>
</div>
<div class="paragraph">
<p><code>repeatedTestInGerman()</code>演示了将重复测试的显示名称翻译成外语的能力 - 在本例中为德语，导致个别重复的名称，例如： <code>Wiederholung 1 von 5</code> ， <code>Wiederholung 2 von 5</code>等。</p>
</div>
<div class="paragraph">
<p>由于<code>beforeEach()</code>方法使用<code>@BeforeEach</code>注释，因此它将在每次重复测试重复之前执行。通过将<code>TestInfo</code>和<code>RepetitionInfo</code>注入到方法中，我们看到可以获得有关当前正在执行的重复测试的信息。在启用<code>INFO</code>日志级别的情况下执行<code>RepeatedTestsDemo</code>产生以下输出。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>信息：即将执行重复1的10重复测试信息：关于执行重复2 of 10 for repeatedTest INFO：关于执行重复3 of 10 for repeatedTest INFO：关于执行重复4 of 10 for repeatedTest INFO：即将执行重复5 of 10 for repeatedTest INFO：即将执行重复6 of 10 for repeatedTest INFO：即将执行重复7 of 10 for repeatedTest INFO：即将执行重复8 of 10 for repeatedTest INFO：即将执行重复9 of 10 for repeatedTest INFO ：关于执行重复10 of 10 for repeatedTest INFO：关于执行重复1 of 5 for repeatedTestWithRepetitionInfo INFO：关于执行重复2 of 5 for repeatedTestWithRepetitionInfo INFO：关于执行重复3 of 5 for repeatedTestWithRepetitionInfo INFO：即将执行重复4 5对于repeatedTestWithRepetitionInfo INFO：关于执行重复5 of 5 for repeatedTestWithRepetitionInfo INFO：即将执行repeti第1页，共1页for customDisplayName INFO：关于执行repeatDisplayNameWithLongPattern的重复1 of 1 INFO：关于执行重复1 of 5 for repeatedTestInGerman INFO：关于执行重复2 of 5 for repeatedTestInGerman INFO：关于执行重复3 of 5 for repeatedTestInGerman信息：即将执行重复4 of 5 for repeatedTestInGerman INFO：即将执行重复5 of 5 for repeatedTestInGerman</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">java.util.logging。记录器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。BeforeEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DisplayName</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。重复测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。RepetitionInfo</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。TestInfo</span> ; <span class="type">class</span> <span class="class">RepeatedTestsDemo</span> { <span class="directive">private</span> <span class="predefined-type">Logger</span> logger = <span class="comment">// ...</span>

    <span class="annotation">@BeforeEach</span> <span class="type">void</span> beforeEach（TestInfo testInfo，RepetitionInfo repetitionInfo）{ <span class="type">int</span> currentRepetition = repetitionInfo.getCurrentRepetition（）; <span class="type">int</span> totalRepetitions = repetitionInfo.getTotalRepetitions（）; <span class="predefined-type">String</span> methodName = testInfo.getTestMethod（）。get（）。getName（）; logger.info（ <span class="predefined-type">String</span> .format（ <span class="string"><span class="delimiter">“</span> <span class="content">关于为％s执行％d的重复％d</span> <span class="delimiter">”</span></span> ， <span class="comment">//</span> currentRepetition，totalRepetitions，methodName））; } <span class="annotation">@RepeatedTest</span> （ <span class="integer">10</span> ） <span class="type">void</span> repeatedTest（）{ <span class="comment">// ...</span>} <span class="annotation">@RepeatedTest</span> （ <span class="integer">5</span> ） <span class="type">void</span> repeatedTestWithRepetitionInfo（RepetitionInfo repetitionInfo）{assertEquals（ <span class="integer">5</span> ，repetitionInfo.getTotalRepetitions（））; } <span class="annotation">@RepeatedTest</span> （value = <span class="integer">1</span> ，name = <span class="string"><span class="delimiter">“</span> <span class="content">{displayName} {currentRepetition} / {totalRepetitions}</span> <span class="delimiter">”</span></span> ） <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">重复！</span><span class="delimiter">“</span></span> ） <span class="type">void</span> customDisplayName（TestInfo testInfo）{assertEquals（ <span class="string"><span class="delimiter">”</span> <span class="content">重复！1/1</span> <span class="delimiter">“</span></span> ，testInfo.getDisplayName（））;} <span class="annotation">@ RepeatedTest</span> （value = <span class="integer">1</span> ，name = <span class="annotation">RepeatedTest.LONG_DISPLAY_NAME</span> ） <span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">”</span> <span class="content">Details ...</span> <span class="delimiter">“</span></span> ） <span class="type">void</span> customDisplayNameWithLongPattern（TestInfo testInfo）{assertEquals（ <span class="string"><span class="delimiter">”</span> <span class="content">Details ... :: repetition 1 of 1</span> <span class="delimiter">“</span></span> ，testInfo.getDisplayName（））;} <span class="annotation">@ RepeatedTest</span> （value = <span class="integer">5</span> ，name = <span class="string"><span class="delimiter">”</span> <span class="content">Wiederholung {currentRepetition} von {totalRepetitions}</span> <span class="delimiter">“</span></span> ） <span class="type">void</span> repeatedTestInGerman（）{ <span class="comment">// ...</span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用启用了unicode主题的<code>ConsoleLauncher</code>时，执行<code>RepeatedTestsDemo</code>导致以下输出到控制台。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>├─重复测试演示✔│├─重复测试（）✔││├─重复1个10✔││├─重复2个10✔││├─重复3个10✔││├─重复4个10✔││├ ─重复5 of10✔││├─重复6 of10✔││├─重复7 of10✔││├─重复8 of10✔││├─重复9 of10✔││└─重复10 of 10 ✔│├─repetedTestWithRepetitionInfo（RepetitionInfo）✔││├─重复1 of5✔││├─重复2 of5✔││├─重复3 of5✔││├─重复4 of5✔││└───────────────────────────────────────────────────────────────────────────────────────────────────────────────── 5 of5✔│├─重复！✔││└─重复！1/1✔│├─细节......✔││└─细节...... ::重复1 of1✔│└─重复测试英语（）✔│├─Wiederholung1 von5✔│├─Wiederholung2 von5✔│├─Wiederholung3 von5✔│├──────────────────────────────────────────────────────────────────── Wiederholung 4 von5✔│└─Wiederholung5 von5✔</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-parameterized-tests"><a class="anchor" href="#writing-tests-parameterized-tests"></a> 2.15。参数化测试</h3>
<div class="paragraph">
<p>参数化测试可以使用不同的参数多次运行测试。声明它们与常规<code>@Test</code>方法一样，但使用<code><a href="../api/org/junit/jupiter/params/ParameterizedTest.html">@ParameterizedTest</a></code>注释。此外，您必须至少声明一个将为每个调用提供参数的<em>源</em> ，然后<em>使用</em>测试方法中的参数。</p>
</div>
<div class="paragraph">
<p>以下示例演示了一个参数化测试，该测试使用<code>@ValueSource</code>批注将<code>String</code>数组指定为参数源。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@ValueSource（</span>字符串= { <span class="string"><span class="delimiter">“</span> <span class="content">赛车</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">雷达</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">能够是我埃雷只见埃尔巴</span> <span class="delimiter">”}）</span></span> <span class="type">空隙</span>回文（ <span class="predefined-type">字符串</span>候选）{assertTrue（StringUtils.isPalindrome（候选））; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行上述参数化测试方法时，将分别报告每次调用。例如， <code>ConsoleLauncher</code>将打印类似于以下内容的输出。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>palindromes（String）✔├─[1]赛车✔├─[2]雷达✔└─[3]能够在我看到elba✔</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">参数化测试目前是一项<em>实验性</em>功能。有关详细信息，请参阅<a href="#api-evolution-experimental-apis">实验API中</a>的表。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="writing-tests-parameterized-tests-setup"><a class="anchor" href="#writing-tests-parameterized-tests-setup"></a> 2.15.1。必需的设置</h4>
<div class="paragraph">
<p>要使用参数化测试，您需要在<code>junit-jupiter-params</code>工件上添加依赖项。有关详细信息，请参阅<a href="#dependency-metadata">依赖性元</a>数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-parameterized-tests-consuming-arguments"><a class="anchor" href="#writing-tests-parameterized-tests-consuming-arguments"></a> 2.15.2。消费论据</h4>
<div class="paragraph">
<p>参数化测试方法通常<em>消耗</em>直接从配置的源参数（参见<a href="#writing-tests-parameterized-tests-sources">参数的来源</a> ）以下论点源索引和方法参数索引（见实施例之间的一对一的关系<a href="#writing-tests-parameterized-tests-sources-CsvSource">@CsvSource</a> ）。然而，参数化的测试方法也可以选择从源到传递给该方法的单个对象<em>集合体</em>参数（参见<a href="#writing-tests-parameterized-tests-argument-aggregation">参数聚集</a> ）。<code>ParameterResolver</code>也可以提供附加<code>ParameterResolver</code> （例如，获取<code>TestInfo</code> ， <code>TestReporter</code>等的实例）。具体而言，参数化测试方法必须根据以下规则声明形式参数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>必须首先声明零个或多个<em>索引参数</em> 。</p>
</li>
<li>
<p>接下来必须声明零个或多个<em>聚合器</em> 。</p>
</li>
<li>
<p>必须最后声明<code>ParameterResolver</code>提供的零个或多个参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在此上下文中， <em>索引参数</em>是<code>Arguments</code>提供的<code>ArgumentsProvider</code>中给定索引的<code>Arguments</code> ， <code>ArgumentsProvider</code>作为参数传递给方法的形式参数列表中相同索引处的参数化方法。<em>聚合器</em>是<code>ArgumentsAccessor</code>类型的任何参数或使用<code>@AggregateWith</code>注释的任何参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-parameterized-tests-sources"><a class="anchor" href="#writing-tests-parameterized-tests-sources"></a> 2.15.3。争论的来源</h4>
<div class="paragraph">
<p>开箱即用，JUnit Jupiter提供了不少<em>源代码</em>注释。以下每个小节都提供了每个小节的简要概述和示例。有关其他信息，请参阅<code><a href="../api/org/junit/jupiter/params/provider/package-summary.html">org.junit.jupiter.params.provider</a></code>包中的Javadoc。</p>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-sources-ValueSource"><a class="anchor" href="#writing-tests-parameterized-tests-sources-ValueSource"></a> @ValueSource</h5>
<div class="paragraph">
<p><code>@ValueSource</code>是最简单的来源之一。它允许您指定单个文字值数组，并且只能用于为每个参数化测试调用提供单个参数。</p>
</div>
<div class="paragraph">
<p><code>@ValueSource</code>支持以下类型的文字值。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>短</code></p>
</li>
<li>
<p><code>字节</code></p>
</li>
<li>
<p><code>INT</code></p>
</li>
<li>
<p><code>长</code></p>
</li>
<li>
<p><code>浮动</code></p>
</li>
<li>
<p><code>双</code></p>
</li>
<li>
<p><code>烧焦</code></p>
</li>
<li>
<p><code>布尔</code></p>
</li>
<li>
<p><code>java.lang中。串</code></p>
</li>
<li>
<p><code>java.lang中。类</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，下面的<code>@ParameterizedTest</code>方法将被调用三次，用值<code>1</code> ， <code>2</code> ，和<code>3</code>分别。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@ValueSource（</span>整型= <span class="integer"><span class="integer"><span class="integer">{1，2，3}）</span></span></span> <span class="type">空隙</span> <span class="type">testWithValueSource（int</span>参数）{assertTrue（引&gt; <span class="integer">0</span> &amp;&amp;参数<span class="integer">&lt;4）;</span> }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-sources-null-and-empty"><a class="anchor" href="#writing-tests-parameterized-tests-sources-null-and-empty"></a>空和空来源</h5>
<div class="paragraph">
<p>为了检查拐角情况并在提供<em>错误输入</em>时验证我们软件的正确行为，为我们的参数化测试提供<code>null</code>和<em>empty</em>值会很有用。以下注释用作接受单个参数的参数化测试的<code>null</code>和empty值的来源。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../api/org/junit/jupiter/params/provider/NullSource.html">@NullSource</a></code> ：为带注释的<code>@ParameterizedTest</code>方法提供单个<code>null</code>参数。</p>
<div class="ulist">
<ul>
<li>
<p><code>@NullSource</code>不能用于具有基本类型的参数。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code><a href="../api/org/junit/jupiter/params/provider/EmptySource.html">@EmptySource</a></code> ：为带注释的<code>@ParameterizedTest</code>方法提供一个<em>空</em>参数，用于以下类型的参数： <code>java.lang.String</code> ， <code>java.util.List</code> ， <code>java.util.Set</code> ， <code>java.util.Map</code> ，原始数组（例如， <code>int[]</code> ， <code>char[][]</code>等），对象数组（例如， <code>String[]</code> ， <code>Integer[][]</code>等）。</p>
<div class="ulist">
<ul>
<li>
<p>不支持受支持类型的子类型。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code><a href="../api/org/junit/jupiter/params/provider/NullAndEmptySource.html">@NullAndEmptySource</a></code> ：一个<em>组合注释</em> ，它结合了<code>@NullSource</code>和<code>@EmptySource</code>的功能。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果需要为参数化测试提供多种不同类型的<em>空白</em>字符串，可以使用<a href="#writing-tests-parameterized-tests-sources-ValueSource">@ValueSource</a>实现 - 例如<code>@ValueSource(strings = {" ", "   ", "\t", "\n"})</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以组合<code>@NullSource</code> ， <code>@EmptySource</code>和<code>@ValueSource</code>来测试更广泛的<code>null</code> ， <em>empty</em>和<em>blank</em>输入。以下示例演示了如何为字符串实现此目的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@NullSource</span> <span class="annotation">@EmptySource</span> <span class="annotation">@ValueSource</span> （strings = { <span class="string"><span class="delimiter">“</span> <span class="content"> </span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">   </span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="char">\ t</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="char">\ n</span> <span class="delimiter">“</span></span> }） <span class="type">void</span> nullEmptyAndBlankStrings（ <span class="predefined-type">String</span> text）{assertTrue（text == <span class="predefined-constant">null</span> || text.trim（）。isEmpty（））;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>利用组合的<code>@NullAndEmptySource</code>注释简化了以上内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@NullAndEmptySource</span> <span class="annotation">@ValueSource</span> （strings = { <span class="string"><span class="delimiter">“</span> <span class="content"> </span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">   </span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="char">\ t</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="char">\ n</span> <span class="delimiter">“</span></span> }） <span class="type">void</span> nullEmptyAndBlankStrings（ <span class="predefined-type">String</span> text）{assertTrue（text == <span class="predefined-constant">null</span> || text.trim（）。isEmpty（））;}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code>nullEmptyAndBlankStrings(String)</code>参数化测试方法的两个变体<code>nullEmptyAndBlankStrings(String)</code>导致六次调用：1表示<code>null</code> ，1表示空字符串，4表示通过<code>@ValueSource</code>提供的显式空字符串。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-sources-EnumSource"><a class="anchor" href="#writing-tests-parameterized-tests-sources-EnumSource"></a> @EnumSource</h5>
<div class="paragraph">
<p><code>@EnumSource</code>提供了一种使用<code>Enum</code>常量的便捷方法。注释提供了一个可选的<code>names</code>参数，允许您指定应使用哪些常量。如果省略，将使用所有常量，如下例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@EnumSource</span> （ <span class="predefined-type">TimeUnit</span> .class） <span class="type">void</span> testWithEnumSource（ <span class="predefined-type">TimeUnit</span> timeUnit）{assertNotNull（timeUnit）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@EnumSource</span> （value = <span class="predefined-type">TimeUnit</span> .class，names = { <span class="string"><span class="delimiter">“</span> <span class="content">DAYS</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">HOURS</span> <span class="delimiter">”</span></span> }） <span class="type">void</span> testWithEnumSourceInclude（ <span class="predefined-type">TimeUnit</span> timeUnit）{assertTrue（ <span class="predefined-type">EnumSet</span> .of（ <span class="predefined-type">TimeUnit</span> 。DAYS， <span class="predefined-type">TimeUnit</span> 。小时）。载（TIMEUNIT））; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@EnumSource</code>注释还提供了一个可选的<code>mode</code>参数，该参数可以对传递给测试方法的常量进行细粒度控制。例如，您可以从枚举常量池中排除名称，也可以指定正则表达式，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@EnumSource</span> （value = <span class="predefined-type">TimeUnit</span> .class，mode = EXCLUDE，names = { <span class="string"><span class="delimiter">“</span> <span class="content">DAYS</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">HOURS</span> <span class="delimiter">”</span></span> }） <span class="type">void</span> testWithEnumSourceExclude（ <span class="predefined-type">TimeUnit</span> timeUnit）{assertFalse（ <span class="predefined-type">EnumSet</span> .of（ <span class="predefined-type">TimeUnit</span> 。DAYS， <span class="predefined-type">TimeUnit</span> 。小时）。载（TIMEUNIT））; assertTrue（timeUnit.name（）。length（）&gt; <span class="integer">5</span> ）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@EnumSource</span> （value = <span class="predefined-type">TimeUnit</span> .class，mode = MATCH_ALL，names = <span class="string"><span class="delimiter">“</span> <span class="content">^（M | N）。+ SECONDS $</span> <span class="delimiter">“</span></span> ） <span class="type">void</span> testWithEnumSourceRegex（ <span class="predefined-type">TimeUnit</span> timeUnit）{ <span class="predefined-type">String</span> name = timeUnit.name（）; assertTrue（name.startsWith（ <span class="string"><span class="delimiter">”</span> <span class="content">M</span> <span class="delimiter">“</span></span> ）|| name.startsWith（ <span class="string"><span class="delimiter">”</span> <span class="content">N</span> <span class="delimiter">“</span></span> ））; assertTrue（name.endsWith（ <span class="string"><span class="delimiter">”</span> <span class="content">SECONDS</span> <span class="delimiter">“</span></span> ））;}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-sources-MethodSource"><a class="anchor" href="#writing-tests-parameterized-tests-sources-MethodSource"></a> @MethodSource</h5>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/params/provider/MethodSource.html">@MethodSource</a></code>允许您引用测试类或外部类的一个或多个<em>工厂</em>方法。</p>
</div>
<div class="paragraph">
<p>除非使用<code>@TestInstance(Lifecycle. ）注释测试类，否则测试类中的工厂方法必须是<code>static</code>的<code>@TestInstance(Lifecycle.PER_CLASS)</code> ;而外部类中的工厂方法必须始终是<code>static</code> 。此外，此类工厂方法不得接受任何参数。</p>
</div>
<div class="paragraph">
<p>每个工厂方法必须生成一个<em>参数</em> <em>流</em> ，并且<em>流中</em>的每组参数将作为带注释的<code>@ParameterizedTest</code>方法的单个调用的物理参数提供。一般来说，这会转换为<code>Arguments</code> <code>Stream</code> （即<code>Stream&lt;Arguments&gt;</code> ）;但是，实际的具体返回类型可以采用多种形式。在此上下文中，“流”是JUnit可以可靠地转换为<code>Stream</code>任何内容，例如<code>Stream</code> ， <code>DoubleStream</code> ， <code>LongStream</code> ， <code>IntStream</code> ， <code>Collection</code> ， <code>Iterator</code> ， <code>Iterable</code> ，对象数组或基元数组。流中的“参数”可以作为<code>Arguments</code>的实例，对象数组（例如， <code>Object[]</code> ）提供，或者如果参数化测试方法接受单个参数，则提供单个值。</p>
</div>
<div class="paragraph">
<p>如果只需要一个参数，则可以返回参数类型的实例<code>Stream</code> ，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@MethodSource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">stringProvider</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithExplicitLocalMethodSource（ <span class="predefined-type">String</span> argument）{assertNotNull（argument）; <span class="directive">static</span> Stream &lt; <span class="predefined-type">String</span> &gt; stringProvider（）{ <span class="keyword">return</span> Stream.of（ <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">banana</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果未通过<code>@MethodSource</code>显式提供工厂方法名称，JUnit Jupiter将<code>@MethodSource</code>搜索与当前<code>@ParameterizedTest</code>方法同名的<em>工厂</em>方法。这在以下示例中进行了演示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@MethodSource</span> <span class="type">void</span> testWithDefaultLocalMethodSource（ <span class="predefined-type">String</span> argument）{assertNotNull（argument）; <span class="directive">static</span> Stream &lt; <span class="predefined-type">String</span> &gt; testWithDefaultLocalMethodSource（）{ <span class="keyword">return</span> Stream.of（ <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">banana</span> <span class="delimiter">”</span></span> ）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>还支持基本类型的流（ <code>DoubleStream</code> ， <code>IntStream</code>和<code>LongStream</code> ），如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@MethodSource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">range</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithRangeMethodSource（ <span class="type">int</span> argument）{assertNotEquals（ <span class="integer">9</span> ，argument）; } <span class="directive">静态</span> IntStream范围（）{ <span class="keyword">返回</span> <span class="integer"><span class="integer"><span class="integer">IntStream.range（0，20）.skip（10）;</span></span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果参数化测试方法声明了多个参数，则需要返回<code>Arguments</code>实例或对象数组的集合，流或数组，如下所示（有关支持的返回类型的更多详细信息，请参阅<code><a href="../api/org/junit/jupiter/params/provider/MethodSource.html">@MethodSource</a></code>的Javadoc）。请注意， <code>arguments(Object…​)</code>是<code>Arguments</code>接口中定义的静态工厂方法。另外， <code>Arguments.of(Object…​)</code>可以用作<code>arguments(Object…​)</code>的替代<code>arguments(Object…​)</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@MethodSource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">stringIntAndListProvider</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithMultiArgMethodSource（ <span class="predefined-type">String</span> str， <span class="type">int</span> num， <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; list）{assertEquals（ <span class="integer">5</span> ，str.length（））; assertTrue（num&gt; = <span class="integer">1</span> &amp;&amp; num &lt;= <span class="integer">2</span> ）; assertEquals（ <span class="integer">2</span> ，list.size（））; <span class="directive">static</span> Stream &lt;Arguments&gt; stringIntAndListProvider（）{ <span class="keyword">return</span> Stream.of（arguments（ <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ， <span class="integer">1</span> ， <span class="predefined-type">Arrays</span> .asList（ <span class="string"><span class="delimiter">“</span> <span class="content">a</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">b</span> <span class="delimiter">”</span></span> ）），arguments（ <span class="string"><span class="delimiter">“</span> <span class="content">lemon</span> <span class="delimiter">”</span></span> ， <span class="integer">2</span> ， <span class="predefined-type">Arrays</span> .asList（ <span class="string"><span class="delimiter">“</span> <span class="content">x</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">y</span> <span class="delimiter">“</span></span> ）））; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过提供其<em>完全限定的方法名称</em>来引用外部<code>static</code> <em>工厂</em>方法，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">包装</span> <span class="namespace">示例</span> ; <span class="keyword">import</span> <span class="include">java.util.stream。流</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.params。ParameterizedTest</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.params.provider。MethodSource</span> ; <span class="type">class</span> <span class="class">ExternalMethodSourceDemo</span> { <span class="annotation">@ParameterizedTest</span> <span class="annotation">@MethodSource</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">example。StringsProviders＃tinyStrings</span> <span class="delimiter">“</span></span> ） <span class="type">void</span> testWithExternalMethodSource（ <span class="predefined-type">String</span> tinyString）{ <span class="comment">//使用tiny string</span> }} <span class="type">class</span> <span class="class">StringsProviders</span> { <span class="directive">static</span> Stream &lt; <span class="predefined-type">String</span> &gt; tinyStrings（）{ <span class="keyword">return</span> Stream.of（ <span class="string"><span class="delimiter">”</span> <span class="content">。</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">oo</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">OOO</span> <span class="delimiter">“</span></span> ）; }}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-sources-CsvSource"><a class="anchor" href="#writing-tests-parameterized-tests-sources-CsvSource"></a> @CsvSource</h5>
<div class="paragraph">
<p><code>@CsvSource</code>允许您将参数列表表示为逗号分隔值（即<code>String</code>文字）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@CsvSource</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">apple，1</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">banana，2</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">'lemon，lime'，0xF1</span> <span class="delimiter">”</span></span> }} <span class="type">void</span> testWithCsvSource（ <span class="predefined-type">String</span> fruit， <span class="type">int</span> rank）{assertNotNull（fruit）; assertNotEquals（ <span class="integer">0</span> ，rank）; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@CsvSource</code>使用单引号<code>'</code>作为它的引号字符。请参阅上面示例和下表中的<code>'lemon, lime'</code>值。除非设置了<code>emptyValue</code>属性，否则空的引用值<code>''</code>会产生空<code>String</code> ;而完全<em>空</em>值被解释为<code>null</code>引用。如果<code>null</code>引用的目标类型是基本类型，则引发<code>ArgumentConversionException</code> 。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">示例输入</th>
<th class="tableblock halign-left valign-top">结果参数列表</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CsvSource（{“apple，banana”}）</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"apple"</code> ， <code>"banana"</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CsvSource（{“apple，'lemon，lime'”}）</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"apple"</code> ， <code>"lemon, lime"</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CsvSource（{“apple，''”}）</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"apple"</code> ， <code>""</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CsvSource（{“apple，”}）</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"apple"</code> ， <code>null</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-sources-CsvFileSource"><a class="anchor" href="#writing-tests-parameterized-tests-sources-CsvFileSource"></a> @CsvFileSource</h5>
<div class="paragraph">
<p><code>@CsvFileSource</code>允许您使用类路径中的CSV文件。CSV文件中的每一行都会导致参数化测试的一次调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@CsvFileSource</span> （resources = <span class="string"><span class="delimiter">“/</span> <span class="content">two-column.csv</span> <span class="delimiter">”</span></span> ，numLinesToSkip = <span class="integer">1</span> ） <span class="type">void</span> testWithCsvFileSource（ <span class="predefined-type">String</span> country， <span class="type">int</span> reference）{assertNotNull（country）; assertNotEquals（ <span class="integer">0</span> ，reference）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">两column.csv</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="csv">国家，参考瑞典，1波兰，2“美利坚合众国”，3</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与<code>@CsvFileSource</code>使用的语法<code>@CsvSource</code> ， <code>@CsvFileSource</code>使用双引号<code>"</code>作为引号字符。请参阅上面示例中的<code>"United States of America"</code>值。除非设置了<code>emptyValue</code>属性，否则空的引用值<code>""</code>导致空<code>String</code> ;而完全<em>空</em>值被解释为<code>null</code>引用。如果<code>null</code>引用的目标类型是基本类型，则引发<code>ArgumentConversionException</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-sources-ArgumentsSource"><a class="anchor" href="#writing-tests-parameterized-tests-sources-ArgumentsSource"></a> @ArgumentsSource</h5>
<div class="paragraph">
<p><code>@ArgumentsSource</code>可用于指定自定义，可重用的<code>ArgumentsProvider</code> 。请注意， <code>ArgumentsProvider</code>的实现必须声明为顶级类或<code>static</code>嵌套类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@ArgumentsSource</span> （MyArgumentsProvider.class） <span class="type">void</span> testWithArgumentsSource（ <span class="predefined-type">String</span> argument）{assertNotNull（argument）; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">MyArgumentsProvider</span> <span class="directive">实现</span> ArgumentsProvider <span class="annotation">{@覆盖</span> <span class="directive">公共</span>流“？<span class="directive">extends</span> Arguments&gt; provideArguments（ExtensionContext context）{ <span class="keyword">return</span> Stream.of（ <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">banana</span> <span class="delimiter">”</span></span> ）。map（Arguments :: of）; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-parameterized-tests-argument-conversion"><a class="anchor" href="#writing-tests-parameterized-tests-argument-conversion"></a> 2.15.4。参数转换</h4>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-argument-conversion-widening"><a class="anchor" href="#writing-tests-parameterized-tests-argument-conversion-widening"></a>扩大转换</h5>
<div class="paragraph">
<p>JUnit Jupiter支持为提供给<code>@ParameterizedTest</code>参数<code>@ParameterizedTest</code> <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2">原始转换</a> 。例如，可以声明使用<code>@ValueSource(ints = { 1, 2, 3 })</code>注释的参数化测试不仅接受<code>int</code>类型的参数，还接受<code>long</code> ， <code>float</code>或<code>double</code>类型的参数。</p>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-argument-conversion-implicit"><a class="anchor" href="#writing-tests-parameterized-tests-argument-conversion-implicit"></a>隐式转换</h5>
<div class="paragraph">
<p>为了支持<code>@CsvSource</code>等用例，JUnit Jupiter提供了许多内置的隐式类型转换器。转换过程取决于每个方法参数的声明类型。</p>
</div>
<div class="paragraph">
<p>例如，如果<code>@ParameterizedTest</code>声明了<code>TimeUnit</code>类型的参数，并且声明的源提供的实际类型是<code>String</code> ，则该字符串将自动转换为相应的<code>TimeUnit</code>枚举常量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@ValueSource</span> （strings = <span class="string"><span class="delimiter">“</span> <span class="content">SECONDS</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithImplicitArgumentConversion（ <span class="predefined-type">TimeUnit</span> argument）{assertNotNull（argument.name（））; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>String</code>实例隐式转换为以下目标类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">十进制，十六进制和八进制<code>String</code>文字将转换为它们的整数类型： <code>byte</code> ， <code>short</code> ， <code>int</code> ， <code>long</code>和它们的盒装对应物。
</td>
</tr>
</table>
</div>
<table id="writing-tests-parameterized-tests-argument-conversion-implicit-table" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:10%">
<col style="width:90%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">目标类型</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code> / <code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"true"</code> → <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byte</code> / <code>Byte</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"15"</code> ， <code>"0xF"</code>或<code>"017"</code> → <code>(byte) 15</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code> / <code>Character</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"o"</code> → <code>'o'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>short</code> / <code>Short</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"15"</code> ， <code>"0xF"</code>或<code>"017"</code> → <code>(short) 15</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code> / <code>Integer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"15"</code> ， <code>"0xF"</code>或<code>"017"</code> → <code>15</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code> / <code>Long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"15"</code> ， <code>"0xF"</code>或<code>"017"</code> → <code>15L</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code> / <code>Float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"1.0"</code> → <code>1.0f</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code> / <code>Double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"1.0"</code> → <code>1.0d</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Enum</code>子类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"SECONDS"</code> → <code>TimeUnit.SECONDS</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.文件</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"/path/to/file"</code> → <code>new File("/path/to/file")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang中。类</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>“java.lang中。Integer"</code> → <code>java.lang.Integer.class</code> <em>（对嵌套类使用<code>$</code> ，例如<code>"java.lang.Thread$State"</code> ）</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang中。类</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"byte"</code> → <code>byte.class</code> <em>（支持基元类型）</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang中。类</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"char[]"</code> → <code>char[].class</code> <em>（支持数组类型）</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.math中。BigDecimal的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"123.456e789"</code> → <code>new BigDecimal("123.456e789")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.math中。的BigInteger</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"1234567890123456789"</code> → <code>new BigInteger("1234567890123456789")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.net。URI</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"https://junit.org/"</code> <code>URI.create("https://junit.org/")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.net。网址</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"https://junit.org/"</code> <code>new URL("https://junit.org/")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.nio.charset中。字符集</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"UTF-8"</code> → <code>Charset.forName("UTF-8")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.nio.file。路径</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"/path/to/file"</code> → <code>Paths.get("/path/to/file")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。持续时间</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"PT3S"</code> → <code>Duration.ofSeconds(3)</code> <code>"PT3S"</code> <code>Duration.ofSeconds(3)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。瞬间</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"1970-01-01T00:00:00Z"</code> → <code>Instant.ofEpochMilli(0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。LocalDateTime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"2017-03-14T12:34:56.789"</code> → <code>LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。LOCALDATE的</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"2017-03-14"</code> → <code>LocalDate.of(2017, 3, 14)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。当地时间</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"12:34:56.789"</code> → <code>LocalTime.of(12, 34, 56, 789_000_000)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。月日</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"--03-14"</code> → <code>MonthDay.of(3, 14)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。OffsetDateTime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"2017-03-14T12:34:56.789Z"</code> → <code>OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.世界标准时间）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。OffsetTime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"12:34:56.789Z"</code> → <code>OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.世界标准时间）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。期</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"P2M6D"</code> → <code>Period.of(0, 2, 6)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。YearMonth</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"2017-03"</code> → <code>YearMonth.of(2017, 3)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。年</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"2017"</code> → <code>Year.of(2017)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。ZonedDateTime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"2017-03-14T12:34:56.789Z"</code> → <code>ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.世界标准时间）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。了zoneid</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"Europe/Berlin"</code> → <code>ZoneId.of("Europe/Berlin")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.time。ZoneOffset</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"+02:30"</code> → <code>ZoneOffset.ofHoursMinutes(2, 30)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。货币</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"JPY"</code> → <code>Currency.getInstance("JPY")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。语言环境</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"en"</code> → <code>new Locale("en")</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util中。UUID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"d043e930-7b3b-48e3-bdbe-5a3ccfb833db"</code> → <code>UUID.fromString("d043e930-7b3b-48e3-bdbe-5a3ccfb833db")</code></p></td>
</tr>
</tbody>
</table>
<div class="sect5">
<h6 id="writing-tests-parameterized-tests-argument-conversion-implicit-fallback"><a class="anchor" href="#writing-tests-parameterized-tests-argument-conversion-implicit-fallback"></a>后备字符串到对象的转换</h6>
<div class="paragraph">
<p>除了从字符串到上表中列出的目标类型的隐式转换之外，如果目标类型只声明一个合适的<em>工厂方法</em>或<em>工厂构造函数</em> ，JUnit Jupiter还提供了从<code>String</code>到给定目标类型的自动转换的回退机制。定义如下。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>factory方法</em> ：在目标类型中声明的非私有<code>static</code>方法，它接受单个<code>String</code>参数并返回目标类型的实例。方法的名称可以是任意的，不需要遵循任何特定的约定。</p>
</li>
<li>
<p><em>工厂构造函数</em> ：目标类型中的非私有构造函数，它接受单个<code>String</code>参数。请注意，目标类型必须声明为顶级类或<code>static</code>嵌套类。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果发现多个<em>工厂方法</em> ，则会忽略它们。如果发现<em>工厂方法</em>和<em>工厂构造函数</em> ，将使用工厂方法而不是构造函数。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，在下面的<code>@ParameterizedTest</code>方法中，将通过调用<code>Book.fromTitle(String)</code>工厂方法并将<code>"42 Cats"</code>作为书的标题传递来创建<code>Book</code>参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@ValueSource</span> （strings = <span class="string"><span class="delimiter">“</span> <span class="content">42 Cats</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithImplicitFallbackArgumentConversion（ <span class="predefined-type">Book</span> book）{assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">42 Cats</span> <span class="delimiter">”</span></span> ，book.getTitle（））; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Book</span> { <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> title; <span class="directive">私人</span> <span class="predefined-type">书</span> （ <span class="predefined-type">字符串</span>标题）{ <span class="local-variable">this</span> .title = title; <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">Book</span> fromTitle（ <span class="predefined-type">String</span> title）{ <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Book</span> （title）; <span class="directive">public</span> <span class="predefined-type">String</span> getTitle（）{ <span class="keyword">return</span> <span class="local-variable">this</span> .title; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-argument-conversion-explicit"><a class="anchor" href="#writing-tests-parameterized-tests-argument-conversion-explicit"></a>显式转换</h5>
<div class="paragraph">
<p>您可以使用<code>@ConvertWith</code>注释显式指定用于特定参数的<code>ArgumentConverter</code> ，而不是依赖于隐式参数转换，如下例所示。请注意， <code>ArgumentConverter</code>的实现必须声明为顶级类或<code>static</code>嵌套类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@EnumSource</span> （ <span class="predefined-type">TimeUnit</span> .class） <span class="type">void</span> testWithExplicitArgumentConversion（ <span class="annotation">@ConvertWith</span> （ToStringArgumentConverter.class） <span class="predefined-type">String</span> argument）{assertNotNull（ <span class="predefined-type">TimeUnit</span> .valueOf（argument））; }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">ToStringArgumentConverter</span> <span class="directive">延伸</span> SimpleArgumentConverter <span class="annotation">{@覆盖</span> <span class="directive">保护</span> <span class="predefined-type">对象</span>转换（ <span class="predefined-type">对象</span>源， <span class="predefined-type">类</span> &lt;？&gt; targetType）{assertEquals（ <span class="predefined-type">String</span> .class，targetType， <span class="string"><span class="delimiter">“</span> <span class="content">只能转换为String</span> <span class="delimiter">”</span></span> ）; <span class="keyword">return</span> <span class="predefined-type">String</span> .valueOf（source）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>显式参数转换器应由测试和扩展作者实现。因此， <code>junit-jupiter-params</code>只提供一个显式参数转换器，它也可以作为参考实现： <code>JavaTimeArgumentConverter</code> 。它通过组合注释<code>JavaTimeConversionPattern</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@ValueSource</span> （strings = { <span class="string"><span class="delimiter">“</span> <span class="content">01.01.2017</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">31.12.2017</span> <span class="delimiter">”</span></span> }） <span class="type">void</span> testWithExplicitJavaTimeConverter（ <span class="annotation">@JavaTimeConversionPattern</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">dd。MM.yyyy</span> <span class="delimiter">“</span></span> ）LocalDate参数）{assertEquals（ <span class="integer">2017</span> ，argument.getYear（））;}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-parameterized-tests-argument-aggregation"><a class="anchor" href="#writing-tests-parameterized-tests-argument-aggregation"></a> 2.15.5。参数聚合</h4>
<div class="paragraph">
<p>默认情况下，提供给<code>@ParameterizedTest</code>方法的每个<em>参数都</em>对应一个方法参数。因此，预期提供大量参数的参数源可能导致大的方法签名。</p>
</div>
<div class="paragraph">
<p>在这种情况下，可以使用<code><a href="../api/org/junit/jupiter/params/aggregator/ArgumentsAccessor.html">ArgumentsAccessor</a></code>而不是多个参数。使用此API，您可以通过传递给测试方法的单个参数访问提供的参数。此外，支持类型转换，如<a href="#writing-tests-parameterized-tests-argument-conversion-implicit">隐式转换中所述</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@CsvSource</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">Jane，Doe，F，1990-05-20</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">John，Doe，M，1990-10-22</span> <span class="delimiter">”</span></span> }） <span class="type">void</span> testWithArgumentsAccessor（ArgumentsAccessor arguments）{Person person = <span class="keyword">new</span> Person（arguments。 getString（ <span class="integer">0</span> ），arguments.getString（ <span class="integer">1</span> ），arguments.get（ <span class="integer">2</span> ，Gender.class），arguments.get（ <span class="integer">3</span> ，LocalDate.class））; <span class="keyword">if</span> （person.getFirstName（）。equals（ <span class="string"><span class="delimiter">“</span> <span class="content">Jane</span> <span class="delimiter">”</span></span> ））{assertEquals（Gender。F，person.getGender（））; } <span class="keyword">else</span> {assertEquals（性别。M，person.getGender（））; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">Doe</span> <span class="delimiter">”</span></span> ，person.getLastName（））; assertEquals（ <span class="integer">1990</span> ，person.getDateOfBirth（）。getYear（））; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><em><code>ArgumentsAccessor</code>一个实例会自动注入到<code>ArgumentsAccessor</code>类型的任何参数中。</em></p>
</div>
<div class="sect4">
<h5 id="writing-tests-parameterized-tests-argument-aggregation-custom"><a class="anchor" href="#writing-tests-parameterized-tests-argument-aggregation-custom"></a>自定义聚合器</h5>
<div class="paragraph">
<p>除了使用<code>ArgumentsAccessor</code>直接访问<code>@ParameterizedTest</code>方法的<code>ArgumentsAccessor</code> ，JUnit Jupiter还支持使用自定义，可重用的<em>聚合器</em> 。</p>
</div>
<div class="paragraph">
<p>要使用自定义聚合器，请实现<code><a href="../api/org/junit/jupiter/params/aggregator/ArgumentsAggregator.html">ArgumentsAggregator</a></code>接口，并通过<code>@ParameterizedTest</code>方法中的兼容参数上的<code>@AggregateWith</code>注释进行注册。在调用参数化测试时，聚合的结果将作为相应参数的参数提供。请注意， <code>ArgumentsAggregator</code>的实现必须声明为顶级类或<code>static</code>嵌套类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@CsvSource</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">Jane，Doe，F，1990-05-20</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">John，Doe，M，1990-10-22</span> <span class="delimiter">”</span></span> }） <span class="type">void</span> testWithArgumentsAggregator（ <span class="annotation">@AggregateWith</span> （PersonAggregator.class）Person person）{ <span class="comment">/ /对人进行断言</span> }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">PersonAggregator</span> <span class="directive">实现</span> ArgumentsAggregator <span class="annotation">{@覆盖</span> <span class="directive">公共</span>人aggregateArguments（ArgumentsAccessor参数，ParameterContext上下文）{ <span class="keyword">返回</span> <span class="keyword">新</span>的人<span class="integer"><span class="integer"><span class="integer">（arguments.getString（0），arguments.getString（1），arguments.get（2，Gender.class），</span></span></span>自变量。 get（ <span class="integer">3</span> ，LocalDate.class））; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您发现自己在代码库中为多个参数化测试方法重复声明<code>@AggregateWith(MyTypeAggregator.class)</code> ，您可能希望创建一个自定义<em>组合注释，</em>例如<code>@CsvToMyType</code> ，它使用<code>@AggregateWith(MyTypeAggregator.class)</code>元注释。以下示例使用自定义<code>@CsvToPerson</code>批注演示此操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ParameterizedTest</span> <span class="annotation">@CsvSource</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">Jane，Doe，F，1990-05-20</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">John，Doe，M，1990-10-22</span> <span class="delimiter">”</span></span> }） <span class="type">void</span> testWithCustomAggregatorAnnotation（ <span class="annotation">@CsvToPerson</span> Person person）{ <span class="comment">//对人进行断言</span> }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span> （ <span class="predefined-type">RetentionPolicy</span> 。RUNTIME） <span class="annotation">@Target</span> （ <span class="predefined-type">ElementType</span> 。PARAMETER） <span class="annotation">@AggregateWith</span> （PersonAggregator.class） <span class="directive">public</span> <span class="annotation">@interface</span> CsvToPerson {}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-parameterized-tests-display-names"><a class="anchor" href="#writing-tests-parameterized-tests-display-names"></a> 2.15.6。自定义显示名称</h4>
<div class="paragraph">
<p>默认情况下，参数化测试调用的显示名称包含调用索引和该特定调用的所有参数的<code>String</code>表示形式。但是，您可以通过<code>@ParameterizedTest</code>注释的<code>name</code>属性自定义调用显示名称，如下例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">显示容器的名称</span> <span class="delimiter">”</span></span> ） <span class="annotation">@ParameterizedTest</span> （name = <span class="string"><span class="delimiter">“</span> <span class="content">{index} ==&gt; fruit =''{0}''，rank = {1}</span> <span class="delimiter">”</span></span> ） <span class="annotation">@CsvSource</span> （{ <span class="string"><span class="delimiter">“</span> <span class="content">apple，1</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">banana，2</span> <span class="delimiter">“</span></span> ， <span class="string"><span class="delimiter">”</span> <span class="content">'lemon，lime'，3</span> <span class="delimiter">“</span></span> }） <span class="type">void</span> testWithCustomDisplayNames（ <span class="predefined-type">String</span> fruit， <span class="type">int</span> rank）{}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用<code>ConsoleLauncher</code>执行上述方法时，您将看到类似于以下内容的输出。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>显示容器的名称✔├─1==&gt; fruit ='apple'，rank =1✔├─2==&gt; fruit ='banana'，rank =2✔└─3==&gt; fruit ='lemon，lime' ，等级= 3✔</pre>
</div>
</div>
<div class="paragraph">
<p>自定义显示名称中支持以下占位符。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">占位符</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{指数}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前的调用索引（基于1）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{}参数</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">完整的逗号分隔参数列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{0}</code> ， <code>{1}</code> ，...</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">个人论点</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="writing-tests-parameterized-tests-lifecycle-interop"><a class="anchor" href="#writing-tests-parameterized-tests-lifecycle-interop"></a> 2.15.7。生命周期和互操作性</h4>
<div class="paragraph">
<p>每次调用参数化测试都与常规<code>@Test</code>方法具有相同的生命周期。例如， <code>@BeforeEach</code>方法将在每次调用之前执行。与<a href="#writing-tests-dynamic-tests">动态测试</a>类似，调用将逐一显示在IDE的测试树中。您可能会在同一测试类中混合使用常规<code>@Test</code>方法和<code>@ParameterizedTest</code>方法。</p>
</div>
<div class="paragraph">
<p>您可以使用带有<code>@ParameterizedTest</code>方法的<code>ParameterResolver</code>扩展。但是，由参数源解析的方法参数需要首先出现在参数列表中。由于测试类可能包含常规测试以及具有不同参数列表的参数化测试，因此不会为生命周期方法（例如<code>@BeforeEach</code> ）和测试类构造函数解析参数源中的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@BeforeEach</span> <span class="type">void</span> beforeEach（TestInfo testInfo）{ <span class="comment">// ...</span>} <span class="annotation">@ParameterizedTest</span> <span class="annotation">@ValueSource</span> （strings = <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ） <span class="type">void</span> testWithRegularParameterResolver（ <span class="predefined-type">String</span> argument，TestReporter testReporter）{testReporter.publishEntry（ <span class="string"><span class="delimiter">“</span> <span class="content">argument</span> <span class="delimiter">”</span></span> ，argument）; } <span class="annotation">@AfterEach</span> <span class="type">void</span> afterEach（TestInfo testInfo）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-test-templates"><a class="anchor" href="#writing-tests-test-templates"></a> 2.16。测试模板</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/TestTemplate.html">@TestTemplate</a></code>方法不是常规测试用例，而是测试用例的模板。因此，它被设计为根据注册的提供者返回的调用上下文的数量被多次调用。因此，它必须与注册的<code><a href="../api/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html">TestTemplateInvocationContextProvider</a></code>扩展一起使用。每次调用测试模板方法的行为都类似于常规<code>@Test</code>方法的执行，完全支持相同的生命周期回调和扩展。有关使用示例，请参阅<a href="#extensions-test-templates">为测试模板提供调用上下文</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<a href="#writing-tests-repeated-tests">重复测试</a>和<a href="#writing-tests-parameterized-tests">参数化测试</a>是测试模板的内置特化。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-dynamic-tests"><a class="anchor" href="#writing-tests-dynamic-tests"></a> 2.17。动态测试</h3>
<div class="paragraph">
<p>标准<code>@Test</code> JUnit中木星注释中所描述<a href="#writing-tests-annotations">的注释</a>是非常相似的<code>@Test</code>注释JUnit 4中。两者都描述了实现测试用例的方法。这些测试用例是静态的，因为它们在编译时完全指定，并且它们的行为不能被运行时发生的任何事情所改变。<em>假设提供了动态行为的基本形式，但故意在其表达方面受到限制。</em></p>
</div>
<div class="paragraph">
<p>除了这些标准测试之外，JUnit Jupiter还引入了一种全新的测试编程模型。这种新的测试是一种<em>动态测试</em> ，它在运行时由一个用<code>@TestFactory</code>注释的工厂方法<code>@TestFactory</code> 。</p>
</div>
<div class="paragraph">
<p>与<code>@Test</code>方法相比， <code>@TestFactory</code>方法本身不是测试用例，而是测试用例的工厂。因此，动态测试是工厂的产物。从技术上讲， <code>@TestFactory</code>方法必须返回单个<code>DynamicNode</code>或<code>Stream</code> ， <code>Collection</code> ， <code>Iterable</code> ， <code>Iterator</code>或<code>DynamicNode</code>实例数组。<code>DynamicNode</code>可实例<code>DynamicNode</code>类是<code>DynamicContainer</code>和<code>DynamicTest</code> 。 <code>DynamicContainer</code>实例由<em>显示名称</em>和动态子节点列表组成，可以创建任意嵌套的动态节点层次结构。
<code>DynamicTest</code>实例将被懒惰地执行，从而实现动态甚至非确定性的测试用例生成。</p>
</div>
<div class="paragraph">
<p>通过调用<code>stream.close()</code>可以正确关闭<code>@TestFactory</code>返回的任何<code>Stream</code> ，从而可以安全地使用<code>Files.lines()</code>等资源。</p>
</div>
<div class="paragraph">
<p>与<code>@Test</code>方法一样， <code>@TestFactory</code>方法不能是<code>private</code>或<code>static</code>并且可以选择声明ParameterResolvers要解析的<code>ParameterResolvers</code> 。</p>
</div>
<div class="paragraph">
<p><code>DynamicTest</code>是在运行时生成的测试用例。它由<em>显示名称</em>和<code>Executable</code> 。<code>Executable</code>是<code>@FunctionalInterface</code> ，这意味着动态测试的实现可以作为<em>lambda表达式</em>或<em>方法引用提供</em> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">动态测试生命周期</div>动态测试的执行生命周期与标准<code>@Test</code>案例的执行生命周期完全不同。具体而言，单个动态测试没有生命周期回调。这意味着<code>@BeforeEach</code>和<code>@AfterEach</code>方法及其相应的扩展回调是针对<code>@TestFactory</code>方法执行的，但不是针对每个<em>动态测试执行的</em> 。换句话说，如果从lambda表达式中的测试实例访问字段以进行动态测试，那么这些字段将不会被执行由相同的<code>@TestFactory</code>方法生成的各个动态测试之间的回调方法或扩展重置。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>从JUnit Jupiter 5.5.1开始，动态测试必须始终由工厂方法创建;但是，这可能会在以后的版本中通过注册工具进行补充。</p>
</div>
<div class="sect3">
<h4 id="writing-tests-dynamic-tests-examples"><a class="anchor" href="#writing-tests-dynamic-tests-examples"></a> 2.17.1。动态测试示例</h4>
<div class="paragraph">
<p>以下<code>DynamicTestsDemo</code>类演示了测试工厂和动态测试的几个示例。</p>
</div>
<div class="paragraph">
<p>第一种方法返回无效的返回类型。由于在编译时无法检测到无效的返回类型，因此在运行时检测到<code>JUnitException</code>会引发<code>JUnitException</code> 。</p>
</div>
<div class="paragraph">
<p>接下来的五个方法是非常简单的示例，演示了<code>Collection</code> ， <code>Iterable</code> ， <code>Iterator</code>或<code>DynamicTest</code>实例<code>Stream</code>的生成。这些示例中的大多数并不真正展示动态行为，而只是原则上演示了支持的返回类型。但是， <code>dynamicTestsFromStream()</code>和<code>dynamicTestsFromIntStream()</code>演示了为给定字符串集或一系列输入数生成动态测试是多么容易。</p>
</div>
<div class="paragraph">
<p>下一种方法本质上是真正的动态。 <code>generateRandomNumberOfTests()</code>实现一个生成随机数的<code>Iterator</code> ，一个显示名称生成器和一个测试执行器，然后将所有三个提供给<code>DynamicTest.stream()</code> 。虽然<code>generateRandomNumberOfTests()</code>的非确定性行为当然与测试可重复性相冲突，因此应谨慎使用，但它有助于证明动态测试的表现力和力量。</p>
</div>
<div class="paragraph">
<p>最后一个方法使用<code>DynamicContainer</code>生成动态测试的嵌套层次结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">example.util。StringUtils.isPalindrome</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertFalse</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertNotNull</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertTrue</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。DynamicContainer.dynamicContainer</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。DynamicTest.dynamicTest</span> ; <span class="keyword">import</span> <span class="include">java.util。数组</span> ; <span class="keyword">import</span> <span class="include">java.util。收藏</span> ; <span class="keyword">import</span> <span class="include">java.util。迭代器</span> ; <span class="keyword">import</span> <span class="include">java.util。清单</span> ; <span class="keyword">import</span> <span class="include">java.util。随机</span> ; <span class="keyword">import</span> <span class="include">java.util.function。功能</span> ; <span class="keyword">import</span> <span class="include">java.util.stream。IntStream</span> ; <span class="keyword">import</span> <span class="include">java.util.stream。流</span> ; <span class="keyword">import</span> <span class="include">example.util。计算器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DynamicNode</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。DynamicTest</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。标签</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。TestFactory</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.function。投掷消费者</span> ; <span class="type">class</span> <span class="class">DynamicTestsDemo</span> { <span class="directive">private</span> <span class="directive">final</span> Calculator calculator = <span class="keyword">new</span> Calculator（）; <span class="comment">//这将导致JUnitException！</span>
    <span class="annotation">@TestFactory</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; dynamicTestsWithInvalidReturnType（）{ <span class="keyword">return</span> <span class="predefined-type">Arrays</span> .asList（ <span class="string"><span class="delimiter">“</span> <span class="content">Hello</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@TestFactory</span> <span class="predefined-type">Collection</span> &lt;DynamicTest&gt; dynamicTestsFromCollection（）{ <span class="keyword">return</span> <span class="predefined-type">Arrays</span> .asList（dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">1st dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt; assertTrue（isPalindrome（ <span class="string"><span class="delimiter">“</span> <span class="content">madam</span> <span class="delimiter">”</span></span> ））），dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">2nd dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt;的<span class="integer"><span class="integer"><span class="integer">assertEquals（4，calculator.multiply（2，2））））;</span></span></span> } <span class="annotation">@TestFactory</span> <span class="predefined-type">Iterable</span> &lt;DynamicTest&gt; dynamicTestsFromIterable（）{ <span class="keyword">return</span> <span class="predefined-type">Arrays</span> .asList（dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">3rd dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt; assertTrue（isPalindrome（ <span class="string"><span class="delimiter">“</span> <span class="content">madam</span> <span class="delimiter">”</span></span> ））），dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">4th dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt;的<span class="integer"><span class="integer"><span class="integer">assertEquals（4，calculator.multiply（2，2））））;</span></span></span> } <span class="annotation">@TestFactory</span> <span class="predefined-type">Iterator</span> &lt;DynamicTest&gt; dynamicTestsFromIterator（）{ <span class="keyword">return</span> <span class="predefined-type">Arrays</span> .asList（dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">5th dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt; assertTrue（isPalindrome（ <span class="string"><span class="delimiter">“</span> <span class="content">madam</span> <span class="delimiter">”</span></span> ））），dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">6th dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt;的<span class="integer"><span class="integer"><span class="integer">assertEquals（4，calculator.multiply（2，2））））.iterator（）;</span></span></span> } <span class="annotation">@TestFactory</span> DynamicTest <span class="type">[]</span> dynamicTestsFromArray（）{ <span class="keyword">return</span> <span class="keyword">new</span> DynamicTest <span class="type">[]</span> {dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">7th dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt; assertTrue（isPalindrome（ <span class="string"><span class="delimiter">“</span> <span class="content">madam</span> <span class="delimiter">”</span></span> ））），dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">8th dynamic test</span> <span class="delimiter">”</span></span> ，（） - &gt;的<span class="integer"><span class="integer"><span class="integer">assertEquals（4，calculator.multiply（2，2）））};</span></span></span> } <span class="annotation">@TestFactory</span>流&lt;DynamicTest&gt; dynamicTestsFromStream（）{ <span class="keyword">返回</span> Stream.of（ <span class="string"><span class="delimiter">“</span> <span class="content">赛车</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">雷达</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">妈妈</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">爸爸</span> <span class="delimiter">”）.MAP（</span></span>文本- &gt; dynamicTest（文本，（） - &gt; assertTrue（isPalindrome（文本））））; } <span class="annotation">@TestFactory</span> Stream &lt;DynamicTest&gt; dynamicTestsFromIntStream（）{ <span class="comment">//为前10个偶数整数生成测试。</span>
        <span class="keyword">return</span> IntStream.iterate（ <span class="integer">0</span> ，n  - &gt; n + <span class="integer">2</span> ）.limit（ <span class="integer">10</span> ）.mapToObj（n  - &gt; dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">test</span> <span class="delimiter">”</span></span> + n，（） - &gt; assertTrue（n％ <span class="integer">2</span> == <span class="integer">0</span> ）））; } <span class="annotation">@TestFactory</span> Stream &lt;DynamicTest&gt; generateRandomNumberOfTests（）{ <span class="comment">//生成0到100之间的随机正整数，直到</span> <span class="comment">//遇到可被7整除的数字。</span>
        <span class="predefined-type">Iterator</span> &lt; <span class="predefined-type">Integer</span> &gt; inputGenerator = <span class="keyword">new</span> <span class="predefined-type">Iterator</span> &lt; <span class="predefined-type">Integer</span> &gt;（）{ <span class="predefined-type">Random</span> random = <span class="keyword">new</span> <span class="predefined-type">Random</span> （）; <span class="type">int</span> current; <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">boolean</span> hasNext（）{current = random.nextInt（ <span class="integer">100</span> ）; <span class="keyword">返回</span>当前％ <span class="integer">7</span> ！= <span class="integer">0</span> ; } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="predefined-type">Integer</span> next（）{ <span class="keyword">return</span> current; }}; <span class="comment">//生成显示名称，如：input：5，input：37，input：85等。</span>函数&lt; <span class="predefined-type">Integer</span> ， <span class="predefined-type">String</span> &gt; displayNameGenerator =（input） - &gt; <span class="string"><span class="delimiter">“</span> <span class="content">input：</span> <span class="delimiter">”</span></span> + input; <span class="comment">//根据当前输入值执行测试。</span>ThrowingConsumer &lt; <span class="predefined-type">Integer</span> &gt; testExecutor =（输入） - &gt; assertTrue（输入％ <span class="integer">7</span> ！= <span class="integer">0</span> ）; <span class="comment">//返回动态测试流。</span>
        <span class="keyword">返回</span> DynamicTest.stream（inputGenerator，displayNameGenerator，testExecutor）; } <span class="annotation">@TestFactory</span> Stream &lt;DynamicNode&gt; dynamicTestsWithContainers（）{ <span class="keyword">return</span> Stream.of（ <span class="string"><span class="delimiter">“</span> <span class="content">A</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">B</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">C</span> <span class="delimiter">”</span></span> ）。map（input  - &gt; dynamicContainer（ <span class="string"><span class="delimiter">“</span> <span class="content">Container</span> <span class="delimiter">”</span></span> + input，Stream.of（dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">not not null</span> <span class="delimiter">“</span></span> ，（） - &gt; assertNotNull（input）），dynamicContainer（ <span class="string"><span class="delimiter">”</span> <span class="content">properties</span> <span class="delimiter">“</span></span> ，Stream.of（dynamicTest（ <span class="string"><span class="delimiter">”</span> <span class="content">length&gt; 0</span> <span class="delimiter">“</span></span> ，（） - &gt; assertTrue（input.length（）&gt; <span class="integer">0</span> ）），dynamicTest（ <span class="string"><span class="delimiter">”</span> <span class="content">not empty</span> <span class="delimiter">“</span></span> ，（） - &gt; assertFalse（input.isEmpty（））））））））; } <span class="annotation">@TestFactory</span> DynamicNode dynamicNodeSingleTest（）{ <span class="keyword">return</span> dynamicTest（ <span class="string"><span class="delimiter">“</span> <span class="content">'</span></span> pop'is <span class="string"><span class="content">a palindrome</span> <span class="delimiter">”</span></span> ，（） - &gt; assertTrue（isPalindrome（ <span class="string"><span class="delimiter">“</span> <span class="content">pop</span> <span class="delimiter">”</span></span> ）））; } <span class="annotation">@TestFactory</span> DynamicNode dynamicNodeSingleContainer（）{ <span class="keyword">返回</span> dynamicContainer（ <span class="string"><span class="delimiter">“</span> <span class="content">回文</span> <span class="delimiter">”，Stream.of（</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">赛车</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">雷达</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">妈妈</span> <span class="delimiter">”，</span></span> <span class="string"><span class="delimiter">“</span> <span class="content">爸爸</span> <span class="delimiter">”）.MAP（</span></span>文本- &gt; dynamicTest（文字，（） - &gt; assertTrue （isPalindrome（text）））））; }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-dynamic-tests-uri-test-source"><a class="anchor" href="#writing-tests-dynamic-tests-uri-test-source"></a> 2.17.2。动态测试的URI测试源</h4>
<div class="paragraph">
<p>JUnit Platform提供了<code>TestSource</code> ，它是用于通过IDE和构建工具导航到其位置的测试或容器的源代表。</p>
</div>
<div class="paragraph">
<p>可以从<code>java.net.构造动态测试或动态容器的<code>TestSource</code> <code>java.net.URI</code>可以经由供给<code>DynamicTest.dynamicTest(String, URI, Executable)</code>或<code>DynamicContainer.dynamicContainer(String, URI, Stream)</code>工厂方法分别。<code>URI</code>将转换为以下<code>TestSource</code>实现之一。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ClasspathResourceSource</code> </dt>
<dd>
<p>如果<code>URI</code>包含<code>classpath</code>方案 - 例如， <code>classpath:/test/foo.xml?line=20,column=2</code> 。</p>
</dd>
<dt class="hdlist1"><code>DirectorySource</code> </dt>
<dd>
<p>如果<code>URI</code>表示文件系统中存在的目录。</p>
</dd>
<dt class="hdlist1"><code>FileSource</code> </dt>
<dd>
<p>如果<code>URI</code>表示文件系统中存在的文件。</p>
</dd>
<dt class="hdlist1"><code>MethodSource</code> </dt>
<dd>
<p>如果<code>URI</code>包含<code>method</code>方案和完全限定的方法名称（FQMN） - 例如， <code>method:org.junit.富＃酒吧（java.lang中。String，java.lang。String[])</code> 。有关FQMN支持的格式，请参阅Javadoc for <code>DiscoverySelectors.selectMethod(String)</code> 。</p>
</dd>
<dt class="hdlist1"><code>UriSource</code> </dt>
<dd>
<p>如果上述<code>TestSource</code>实现都不适用。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-declarative-timeouts"><a class="anchor" href="#writing-tests-declarative-timeouts"></a> 2.18。超时</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">声明性超时是一个实验性功能</div>您被邀请尝试并向JUnit团队提供反馈，以便他们可以改进并最终<a href="#api-evolution">推广</a>此功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Timeout</code>注释允许在执行时间超过给定持续时间时声明测试，测试工厂，测试模板或生命周期方法失败。持续时间的时间单位默认为秒，但可以配置。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>@Timeout</code>如何应用于生命周期和测试方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TimeoutDemo</span> { <span class="annotation">@BeforeEach</span> <span class="annotation">@Timeout</span> （ <span class="integer">5</span> ） <span class="type">void</span> setUp（）{ <span class="comment">//如果执行时间超过5秒则失败</span> } <span class="annotation">@Test</span> <span class="annotation">@Timeout</span> （value = <span class="integer">100</span> ，unit = <span class="predefined-type">TimeUnit</span> 。MILLISECONDS） <span class="type">void</span> failedIfExecutionTimeExceeds100Milliseconds（）{ <span class="comment">//如果执行时间超过100毫秒则失败</span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与<code>assertTimeoutPreemptively()</code>断言相反，带注释的方法的执行在测试的主线程中进行。如果超出超时，则主线程将从另一个线程中断。这样做是为了确保与Spring等框架的互操作性，这些框架利用对当前运行的线程敏感的机制 - 例如， <code>ThreadLocal</code>事务管理。</p>
</div>
<div class="paragraph">
<p>要对测试类及其所有<code>@Nested</code>类中的所有测试方法应用相同的超时，可以在类级别声明<code>@Timeout</code>注释。然后，它将应用于该类及其<code>@Nested</code>类中的所有测试，测试工厂和测试模板方法，除非被特定方法或<code>@Nested</code>类上的<code>@Timeout</code>注释覆盖。请注意，在类级别声明的<code>@Timeout</code>注释不适用于生命周期方法。</p>
</div>
<div class="paragraph">
<p>在<code>@TestFactory</code>方法上声明<code>@Timeout</code>检查工厂方法是否在指定的持续时间内返回，但会验证工厂生成的每个<code>DynamicTest</code>的执行时间。请使用<code>assertTimeout()</code>或<code>assertTimeoutPreemptively()</code>来实现此目的。</p>
</div>
<div class="paragraph">
<p>如果<code>@Timeout</code>存在于<code>@TestTemplate</code>方法上 - 例如， <code>@RepeatedTest</code>或<code>@ParameterizedTest</code> - 每次调用都会应用给定的超时。</p>
</div>
<div class="paragraph">
<p>以下<a href="#running-tests-config-params">配置参数</a>可用于为某个类别的所有方法指定全局超时，除非它们或封闭的测试类使用<code>@Timeout</code>注释：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.default</code></dt>
<dd>
<p>所有可测试和生命周期方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.testable.method.default</code></dt>
<dd>
<p>所有可测试方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.test.method.default</code></dt>
<dd>
<p><code>@Test</code>方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.testtemplate.method.default</code></dt>
<dd>
<p><code>@TestTemplate</code>方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.testfactory.method.default</code></dt>
<dd>
<p><code>@TestFactory</code>方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.lifecycle.method.default</code></dt>
<dd>
<p>所有生命周期方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.beforeall.method.default</code></dt>
<dd>
<p><code>@BeforeAll</code>方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.beforeeach.method.default</code></dt>
<dd>
<p><code>@BeforeEach</code>方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.aftereach.method.default</code></dt>
<dd>
<p><code>@AfterEach</code>方法的默认超时</p>
</dd>
<dt class="hdlist1"><code>junit.jupiter.execution.timeout.afterall.method.default</code></dt>
<dd>
<p><code>@AfterAll</code>方法的默认超时</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>更具体的配置参数覆盖不太具体的配置。例如， <code>junit.jupiter.execution.timeout.test.method.default</code>会覆盖<code>junit.jupiter.execution.timeout.testable.method.default</code> ，它会覆盖<code>junit.jupiter.execution.timeout.default</code> 。</p>
</div>
<div class="paragraph">
<p>此类配置参数的值必须采用以下不区分大小写的格式： <code>&lt;number&gt; [ns|μs|ms|s|m|h|d]</code> 。可以省略数字和单元之间的空间。指定无单位等同于使用秒。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表格1。示例超时配置参数值</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数值</th>
<th class="tableblock halign-left valign-top">等价注释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（42）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42 ns</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（value = 42，unit = NANOSECONDS）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42μs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（值= 42，单位= MICROSECONDS）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42毫秒</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（值= 42，单位= MILLISECONDS）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42秒</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（value = 42，unit = SECONDS）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42米</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（value = 42，unit = MINUTES）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42小时</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（值= 42，单位= HOURS）</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>42天</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timeout（值= 42，单位= DAYS）</code></p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="writing-tests-declarative-timeouts-polling"><a class="anchor" href="#writing-tests-declarative-timeouts-polling"></a> 2.18.1。使用@Timeout进行轮询测试</h4>
<div class="paragraph">
<p>在处理异步代码时，通常会在执行任何断言之前编写轮询测试，同时等待某些事情发生。在某些情况下，您可以重写逻辑以使用<code>CountDownLatch</code>或其他同步机制，但有时这是不可能的 - 例如，如果受测试的主体将消息发送到外部消息代理中的通道，并且在执行之前无法执行断言消息已成功通过该频道发送。像这样的异步测试需要某种形式的超时，以确保它们不会通过无限期执行来挂起测试套件，就像异步消息永远不会成功传递一样。</p>
</div>
<div class="paragraph">
<p>通过为轮询的异步测试配置超时，可以确保测试不会无限期地执行。以下示例演示了如何使用JUnit Jupiter的<code>@Timeout</code>注释实现此<code>@Timeout</code> 。该技术可用于非常容易地实现“轮询直到”逻辑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="annotation">@Timeout</span> （ <span class="integer">5</span> ） <span class="comment">//轮询最多5秒</span> <span class="type">void</span> pollUntil（） <span class="directive">抛出</span> <span class="exception">InterruptedException</span> { <span class="keyword">while</span> （asynchronousResultNotAvailable（））{ <span class="predefined-type">Thread</span> .sleep（ <span class="integer">250</span> ）; <span class="comment">// custom poll interval</span> } <span class="comment">//获取异步结果并执行断言</span> }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您需要通过异步测试更多地控制轮询间隔和更大的灵活性，请考虑使用<a href="https://github.com/awaitility/awaitility">Awaitility</a>等专用库。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-parallel-execution"><a class="anchor" href="#writing-tests-parallel-execution"></a> 2.19。并行执行</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">并行测试执行是一项实验性功能</div>您被邀请尝试并向JUnit团队提供反馈，以便他们可以改进并最终<a href="#api-evolution">推广</a>此功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，JUnit Jupiter测试在单个线程中按顺序运行。并行运行测试 - 例如，加速执行 - 从版本5.3开始作为选择加入功能提供。要启用并行执行，请将<code>junit.jupiter.execution.parallel.enabled</code>配置参数设置为<code>true</code> - 例如，在<code>junit-platform.properties</code> （请参阅其他选项的<a href="#running-tests-config-params">配置参数</a> ）。</p>
</div>
<div class="paragraph">
<p>请注意，启用此属性只是并行执行测试所需的第一步。如果启用，默认情况下仍将按顺序执行测试类和方法。测试树中的节点是否同时执行由其执行模式控制。有以下两种模式可供选择。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SAME_THREAD</code></dt>
<dd>
<p>强制执行父级使用的同一线程。例如，在测试方法上使用时，测试方法将在与包含测试类的任何<code>@BeforeAll</code>或<code>@AfterAll</code>方法相同的线程中执行。</p>
</dd>
<dt class="hdlist1"><code>同时</code></dt>
<dd>
<p>除非资源锁在同一线程中强制执行，否则执行并发。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>默认情况下，测试树中的节点使用<code>SAME_THREAD</code>执行模式。您可以通过设置<code>junit.jupiter.execution.parallel.mode.default</code>配置参数来更改默认值。或者，您可以使用<code><a href="../api/org/junit/jupiter/api/parallel/Execution.html">@Execution</a></code>批注来更改带注释元素及其子元素（如果有）的执行模式，该元素允许您逐个激活各个测试类的并行执行。</p>
</div>
<div class="listingblock">
<div class="title">配置参数以并行执行所有测试</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = concurrent</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认执行模式应用于测试树的所有节点，但有一些值得注意的例外，即使用<code>Lifecycle.测试类<code>Lifecycle.PER_CLASS</code>模式或<code><a href="../api/org/junit/jupiter/api/MethodOrderer.html">MethodOrderer</a></code> （ <code><a href="../api/org/junit/jupiter/api/MethodOrderer.Random.html">Random</a></code>除外）。在前一种情况下，测试作者必须确保测试类是线程安全的;在后者中，并发执行可能与配置的执行顺序冲突。因此，在这两种情况下，如果测试类或方法上存在<code>@Execution(CONCURRENT)</code>注释，则此类测试类中的测试方法仅同时执行。</p>
</div>
<div class="paragraph">
<p>使用<code>CONCURRENT</code>执行模式配置的测试树的所有节点将根据提供的<a href="#writing-tests-parallel-execution-config">配置</a>完全并行执行，同时观察声明性<a href="#writing-tests-parallel-execution-synchronization">同步</a>机制。请注意，需要单独启用<a href="#running-tests-capturing-output">捕获标准输出/错误</a> 。</p>
</div>
<div class="paragraph">
<p>此外，您可以通过设置<code>junit.jupiter.execution.parallel.mode.classes.default</code>配置参数<code>junit.jupiter.execution.parallel.mode.classes.default</code>配置顶级类的默认执行模式。通过组合这两个配置参数，您可以将类配置为并行运行，但它们的方法在同一个线程中：</p>
</div>
<div class="listingblock">
<div class="title">配置参数以并行方式执行顶级类但在同一线程中执行方法</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = same_thread junit.jupiter.execution.parallel.mode.classes.default = concurrent</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反的组合将并行运行一个类中的所有方法，但顶级类将按顺序运行：</p>
</div>
<div class="listingblock">
<div class="title">配置参数按顺序执行顶级类，但并行执行它们的方法</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">junit.jupiter.execution.parallel.enabled = true junit.jupiter.execution.parallel.mode.default = concurrent junit.jupiter.execution.parallel.mode.classes.default = same_thread</code></pre>
</div>
</div>
<div class="paragraph">
<p>下图说明了如何使用每个类的两个测试方法执行两个顶级测试类<code>A</code>和<code>B</code>对于<code>junit.jupiter.execution.parallel.mode.default</code>和<code>junit.jupiter.execution.parallel.mode.classes.default</code>所有四种组合的行为。 <code>junit.jupiter.execution.parallel.mode.classes.default</code> （请参阅第一列中的标签）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/writing-tests_execution_mode.svg" alt="编写测试执行模式">
</div>
<div class="title">默认执行模式配置组合</div>
</div>
<div class="paragraph">
<p>如果未显式设置<code>junit.jupiter.execution.parallel.mode.classes.default</code>配置参数，则将使用<code>junit.jupiter.execution.parallel.mode.default</code>的值。</p>
</div>
<div class="sect3">
<h4 id="writing-tests-parallel-execution-config"><a class="anchor" href="#writing-tests-parallel-execution-config"></a> 2.19.1。组态</h4>
<div class="paragraph">
<p>可以使用<code><a href="../api/org/junit/platform/engine/support/hierarchical/ParallelExecutionConfigurationStrategy.html">ParallelExecutionConfigurationStrategy</a></code>配置所需的并行性和最大池大小等属性。JUnit平台提供了两种开箱即用的实现： <code>dynamic</code>和<code>fixed</code> 。或者，您可以实施<code>custom</code>策略。</p>
</div>
<div class="paragraph">
<p>要选择策略，请将<code>junit.jupiter.execution.parallel.config.strategy</code>配置参数设置为以下选项之一。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>动态</code></dt>
<dd>
<p>根据可用处理器/核心数乘以<code>junit.jupiter.execution.parallel.config.dynamic.factor</code>配置参数（默认为<code>1</code> ）计算所需的并行度。</p>
</dd>
<dt class="hdlist1"><code>固定</code></dt>
<dd>
<p>使用强制的<code>junit.jupiter.execution.parallel.config.fixed.parallelism</code>配置参数作为所需的并行性。</p>
</dd>
<dt class="hdlist1"><code>习惯</code></dt>
<dd>
<p>允许您通过强制<code>junit.jupiter.execution.parallel.config.custom.class</code>配置参数指定自定义<code><a href="../api/org/junit/platform/engine/support/hierarchical/ParallelExecutionConfigurationStrategy.html">ParallelExecutionConfigurationStrategy</a></code>实现，以确定所需的配置。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果未设置配置策略，则JUnit Jupiter使用系数为<code>1</code>的<code>dynamic</code>配置策略。因此，期望的并行度将等于可用处理器/核的数量。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">并行性并不意味着并发线程的最大数量</div>JUnit Jupiter不保证并发执行的测试数量不会超过配置的并行度。例如，当使用下一节中描述的同步机制之一时，在幕后使用的<code>ForkJoinPool</code>可能会产生额外的线程，以确保以足够的并行性继续执行。因此，如果您在测试类中需要这样的保证，请使用您自己的控制并发方法。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="writing-tests-parallel-execution-synchronization"><a class="anchor" href="#writing-tests-parallel-execution-synchronization"></a> 2.19.2。同步</h4>
<div class="paragraph">
<p>除了使用<code><a href="../api/org/junit/jupiter/api/parallel/Execution.html">@Execution</a></code>批注控制执行模式<code><a href="../api/org/junit/jupiter/api/parallel/Execution.html">@Execution</a></code> ，JUnit Jupiter还提供了另一种基于注释的声明性同步机制。<code><a href="../api/org/junit/jupiter/api/parallel/ResourceLock.html">@ResourceLock</a></code>批注允许您声明测试类或方法使用需要同步访问的特定共享资源，以确保可靠的测试执行。共享资源由唯一名称标识，该名称是<code>String</code> 。该名称可以是用户定义的或在预定义的常量的一个<code><a href="../api/org/junit/jupiter/api/parallel/Resources.html">Resources</a></code> ： <code>SYSTEM_PROPERTIES</code> ， <code>SYSTEM_OUT</code> ， <code>SYSTEM_ERR</code> ， <code>LOCALE</code> ，或<code>TIME_ZONE</code> 。</p>
</div>
<div class="paragraph">
<p>如果以下示例中的测试是在<em>不</em>使用<a href="../api/org/junit/jupiter/api/parallel/ResourceLock.html">@ResourceLock的</a> <em>情况下</em>并行运行的，那么它们将是<em>不稳定的</em> 。有时它们会通过，有时它们会因为写入的固有竞争条件而失败，然后读取相同的JVM系统属性。</p>
</div>
<div class="paragraph">
<p>当使用<a href="../api/org/junit/jupiter/api/parallel/ResourceLock.html">@ResourceLock</a>批注声明对共享资源的访问时，JUnit Jupiter引擎使用此信息来确保不会并行运行冲突的测试。</p>
</div>
<div class="paragraph">
<p>除了唯一标识共享资源的<code>String</code>之外，您还可以指定访问模式。需要对共享资源进行<code>READ</code>访问的两个测试可以彼此并行运行，但不需要运行需要<code>READ_WRITE</code>访问同一共享资源的任何其他测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Execution</span> （CONCURRENT） <span class="type">类</span> <span class="class">SharedResourcesDemo</span> { <span class="directive">private</span> <span class="predefined-type">Properties</span> backup; <span class="annotation">@BeforeEach</span> <span class="type">void</span> backup（）{backup = <span class="keyword">new</span> <span class="predefined-type">Properties</span> （）; backup.putAll（ <span class="predefined-type">System</span> .getProperties（））; } <span class="annotation">@AfterEach</span> <span class="type">void</span> restore（）{ <span class="predefined-type">System</span> .setProperties（backup）; } <span class="annotation">@Test</span> <span class="annotation">@ResourceLock</span> （value = SYSTEM_PROPERTIES，mode = READ） <span class="type">void</span> customPropertyIsNotSetByDefault（）{assertNull（ <span class="predefined-type">System</span> .getProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">my.prop</span> <span class="delimiter">”</span></span> ））; } <span class="annotation">@Test</span> <span class="annotation">@ResourceLock</span> （value = SYSTEM_PROPERTIES，mode = READ_WRITE） <span class="type">void</span> canSetCustomPropertyToApple（）{ <span class="predefined-type">System</span> .setProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">my.prop</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ）; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">System</span> .getProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">my.prop</span> <span class="delimiter">”</span></span> ））; } <span class="annotation">@Test</span> <span class="annotation">@ResourceLock</span> （value = SYSTEM_PROPERTIES，mode = READ_WRITE） <span class="type">void</span> canSetCustomPropertyToBanana（）{ <span class="predefined-type">System</span> .setProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">my.prop</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">banana</span> <span class="delimiter">”</span></span> ）; assertEquals（ <span class="string"><span class="delimiter">“</span> <span class="content">banana</span> <span class="delimiter">”</span></span> ， <span class="predefined-type">System</span> .getProperty（ <span class="string"><span class="delimiter">“</span> <span class="content">my.prop</span> <span class="delimiter">”</span></span> ））; }}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-tests-built-in-extensions"><a class="anchor" href="#writing-tests-built-in-extensions"></a> 2.20。内置扩展程序</h3>
<div class="paragraph">
<p>虽然JUnit团队鼓励可重用扩展在单独的库中打包和维护，但JUnit Jupiter API工件包括一些面向用户的扩展实现，这些实现通常被认为非常有用，用户不应该添加另一个依赖项。</p>
</div>
<div class="sect3">
<h4 id="writing-tests-built-in-extensions-TempDirectory"><a class="anchor" href="#writing-tests-built-in-extensions-TempDirectory"></a> 2.20.1。TempDirectory扩展</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title"><code>@TempDir</code>是一个实验性功能</div>您被邀请尝试并向JUnit团队提供反馈，以便他们可以改进并最终<a href="#api-evolution">推广</a>此功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>内置的<code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java">TempDirectory</a></code>扩展用于为单个测试或测试类中的所有测试创建和清理临时目录。它是默认注册的。要使用它，请注释<code>java.nio.file.类型的非私有字段<code>java.nio.file.Path</code>或<code>java.io.使用<code><a href="../api/org/junit/jupiter/api/io/TempDir.html">@TempDir</a></code> File</code>或添加<code>java.nio.file.类型的参数<code>java.nio.file.Path</code>或<code>java.io.使用<code>@TempDir</code>注释的File</code>到生命周期方法或测试方法。</p>
</div>
<div class="paragraph">
<p>例如，以下测试声明了一个用<code>@TempDir</code>注释的参数，用于单个测试方法，创建并写入临时目录中的文件，并检查其内容。</p>
</div>
<div class="listingblock">
<div class="title">一种需要临时目录的测试方法</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Test</span> <span class="type">void</span> writeItemsToFile（ <span class="annotation">@TempDir</span> Path tempDir） <span class="directive">抛出</span> <span class="exception">IOException</span> {Path file = tempDir.resolve（ <span class="string"><span class="delimiter">“</span> <span class="content">test.txt</span> <span class="delimiter">”</span></span> ）; <span class="keyword">new</span> ListWriter（file）.write（ <span class="string"><span class="delimiter">“</span> <span class="content">a</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">b</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">c</span> <span class="delimiter">”</span></span> ）; assertEquals（singletonList（ <span class="string"><span class="delimiter">“</span> <span class="content">a，b，c</span> <span class="delimiter">”</span></span> ），Files.readAllLines（file））; }</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
构造函数参数不支持<code>@TempDir</code> 。如果您希望在生命周期方法和当前测试方法中保留对临时目录的单个引用，请使用字段注入，方法是使用<code>@TempDir</code>注释非私有实例字段。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例将<em>共享</em>临时目录存储在<code>static</code>字段中。这允许在测试类的所有生命周期方法和测试方法中使用相同的<code>sharedTempDir</code> 。</p>
</div>
<div class="listingblock">
<div class="title">一个测试类，它跨测试方法共享一个临时目录</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">SharedTempDirectoryDemo</span> { <span class="annotation">@TempDir</span> <span class="directive">static</span> Path sharedTempDir; <span class="annotation">@Test</span> <span class="type">void</span> writeItemsToFile（） <span class="directive">抛出</span> <span class="exception">IOException</span> {Path file = sharedTempDir.resolve（ <span class="string"><span class="delimiter">“</span> <span class="content">test.txt</span> <span class="delimiter">”</span></span> ）; <span class="keyword">new</span> ListWriter（file）.write（ <span class="string"><span class="delimiter">“</span> <span class="content">a</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">b</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">c</span> <span class="delimiter">”</span></span> ）; assertEquals（singletonList（ <span class="string"><span class="delimiter">“</span> <span class="content">a，b，c</span> <span class="delimiter">”</span></span> ），Files.readAllLines（file））; } <span class="annotation">@Test</span> <span class="type">void</span> anotherTestThatUsesTheSameTempDir（）{ <span class="comment">//使用sharedTempDir</span> }}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="migrating-from-junit4"><a class="anchor" href="#migrating-from-junit4"></a> 3。从JUnit 4迁移</h2>
<div class="sectionbody">
<div class="paragraph">
<p>虽然JUnit的木星编程模型和扩展模型将不支持JUnit 4种中的功能，如<code>Rules</code>和<code>Runners</code>本身，它并不期望源代码维护者将需要更新其所有现有的测试，测试扩展和自定义生成测试基础设施的迁移到JUnit Jupiter。</p>
</div>
<div class="paragraph">
<p>相反，JUnit通过<em>JUnit Vintage测试引擎</em>提供了一个温和的迁移路径，该<em>引擎</em>允许使用JUnit Platform基础结构执行基于JUnit 3和JUnit 4的现有测试。由于特定于JUnit Jupiter的所有类和注释都位于新的<code>org.junit.jupiter</code>基础包下，因此在类路径中同时包含JUnit 4和JUnit Jupiter不会导致任何冲突。因此，在JUnit Jupiter测试的同时维护现有的JUnit 4测试是安全的。此外，由于JUnit团队将继续为JUnit 4.x基准提供维护和错误修复版本，因此开发人员有足够的时间按照自己的计划迁移到JUnit Jupiter。</p>
</div>
<div class="sect2">
<h3 id="migrating-from-junit4-running"><a class="anchor" href="#migrating-from-junit4-running"></a> 3.1。在JUnit平台上运行JUnit 4测试</h3>
<div class="paragraph">
<p>只需确保<code>junit-vintage-engine</code>工件位于测试运行时路径中。在这种情况下，JUnit 3和JUnit 4测试将由JUnit Platform启动程序自动获取。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="https://github.com/junit-team/junit5-samples"><code>junit5-samples</code></a>存储库中的示例项目，了解如何使用Gradle和Maven完成此操作。</p>
</div>
<div class="sect3">
<h4 id="migrating-from-junit4-categories-support"><a class="anchor" href="#migrating-from-junit4-categories-support"></a> 3.1.1。分类支持</h4>
<div class="paragraph">
<p>对于使用<code>@Category</code>注释的测试类或方法， <em>JUnit Vintage测试引擎</em>将类别的完全限定类名称公开为相应测试标识符的标记。例如，如果测试方法使用<code>@Category(Example.class)</code>注释，则将使用<code>"com.acme.标记<code>"com.acme.Example"</code> 。与JUnit 4中的<code>Categories</code> runner类似，此信息可用于在执行之前过滤发现的测试（有关详细信息，请参阅<a href="#running-tests">运行测试</a> ）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migrating-from-junit4-tips"><a class="anchor" href="#migrating-from-junit4-tips"></a> 3.2。迁移提示</h3>
<div class="paragraph">
<p>以下是将现有JUnit 4测试迁移到JUnit Jupiter时应注意的主题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>注释位于<code>org.junit.jupiter.api</code>包中。</p>
</li>
<li>
<p>断言位于<code>org.junit.jupiter.api.Assertions</code> 。</p>
<div class="ulist">
<ul>
<li>
<p>请注意，您可以继续使用<code>org.junit.断言方法<code>org.junit.Assert</code>或任何其他断言库，如<a href="https://joel-costigliola.github.io/assertj/">AssertJ</a> ， <a href="https://hamcrest.org/JavaHamcrest/">Hamcrest</a> ， <a href="https://google.github.io/truth/">Truth</a>等。</p>
</li>
</ul>
</div>
</li>
<li>
<p>假设位于<code>org.junit.jupiter.api.Assumptions</code> 。</p>
<div class="ulist">
<ul>
<li>
<p>请注意，JUnit Jupiter 5.4及更高版本支持JUnit 4的<code>org.junit.Assume</code>类的假设。具体来说，JUnit Jupiter支持JUnit 4的<code>AssumptionViolatedException</code>来表示应该中止测试而不是标记为失败。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@Before</code>和<code>@After</code>不再存在;请改用<code>@BeforeEach</code>和<code>@AfterEach</code> 。</p>
</li>
<li>
<p><code>@BeforeClass</code>和<code>@AfterClass</code>不再存在;请改用<code>@BeforeAll</code>和<code>@AfterAll</code> 。</p>
</li>
<li>
<p><code>@Ignore</code>不再存在：使用<code>@Disabled</code>或其他一个内置<a href="#writing-tests-conditional-execution">执行条件</a></p>
<div class="ulist">
<ul>
<li>
<p>另请参见<a href="#migrating-from-junit4-ignore-annotation-support">JUnit 4 @Ignore支持</a> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@Category</code>不再存在;请改用<code>@Tag</code> 。</p>
</li>
<li>
<p><code>@RunWith</code>不再存在;被<code>@ExtendWith</code>取代。</p>
</li>
<li>
<p><code>@Rule</code>和<code>@ClassRule</code>不再存在;被<code>@ExtendWith</code>和<code>@RegisterExtension</code>取代</p>
<div class="ulist">
<ul>
<li>
<p>另请参阅<a href="#migrating-from-junit4-rule-support">有限的JUnit 4规则支持</a> 。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="migrating-from-junit4-rule-support"><a class="anchor" href="#migrating-from-junit4-rule-support"></a> 3.3。有限的JUnit 4规则支持</h3>
<div class="paragraph">
<p>如上所述，JUnit Jupiter本身不支持也不支持JUnit 4规则。然而，JUnit团队意识到许多组织，特别是大型组织，可能拥有使用自定义规则的大型JUnit 4代码库。为了服务这些组织并实现渐进式迁移路径，JUnit团队决定在JUnit Jupiter中逐字支持一系列JUnit 4规则。此支持基于适配器，并且仅限于与JUnit Jupiter扩展模型在语义上兼容的那些规则，即那些不会完全更改测试的整体执行流程的规则。</p>
</div>
<div class="paragraph">
<p>JUnit Jupiter的<code>junit-jupiter-migrationsupport</code>模块目前支持以下三种<code>Rule</code>类型，包括这些类型的子类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.junit.rules。ExternalResource</code> （包括<code>org.junit.rules.TemporaryFolder</code> ）</p>
</li>
<li>
<p><code>org.junit.rules。Verifier</code> （包括<code>org.junit.rules.ErrorCollector</code> ）</p>
</li>
<li>
<p><code>org.junit.rules。的ExpectedException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与在JUnit 4中一样，支持带有规则注释的字段以及方法。通过在测试类上使用这些类级扩展，可以<em>保留</em>遗留代码库中的<code>Rule</code>实现，包括JUnit 4规则导入语句。</p>
</div>
<div class="paragraph">
<p>这种有限形式的<code>Rule</code>支持可以通过类级别注释<code><a href="../api/org/junit/jupiter/migrationsupport/rules/EnableRuleMigrationSupport.html">@EnableRuleMigrationSupport</a></code> 。此批注是一个<em>组合批注</em> ，它支持所有规则迁移支持扩展： <code>VerifierSupport</code> ， <code>ExternalResourceSupport</code>和<code>ExpectedExceptionSupport</code> 。您也可以选择使用<code>@EnableJUnit4MigrationSupport</code>来注释您的测试类，它支持规则的迁移支持<em>和</em> JUnit 4的<code>@Ignore</code>注释（参见<a href="#migrating-from-junit4-ignore-annotation-support">JUnit 4 @Ignore支持</a> ）。</p>
</div>
<div class="paragraph">
<p>但是，如果您打算为JUnit 5开发新的扩展，请使用JUnit Jupiter的新扩展模型，而不是基于规则的JUnit 4模型。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">JUnit Jubiter中的JUnit 4 <code>Rule</code>支持目前是一个<em>实验性</em>功能。有关详细信息，请参阅<a href="#api-evolution-experimental-apis">实验API中</a>的表。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="migrating-from-junit4-ignore-annotation-support"><a class="anchor" href="#migrating-from-junit4-ignore-annotation-support"></a> 3.4。JUnit 4 @Ignore支持</h3>
<div class="paragraph">
<p>为了提供从JUnit 4到JUnit Jupiter的平滑迁移路径， <code>junit-jupiter-migrationsupport</code>模块为JUnit 4的<code>@Ignore</code>注释提供了类似于Jupiter的<code><a href="../api/org/junit/jupiter/api/Disabled.html">@Disabled</a></code>注释的支持。</p>
</div>
<div class="paragraph">
<p>要将<code>@Ignore</code>与基于JUnit Jupiter的测试一起使用，请在构建中的<code>junit-jupiter-migrationsupport</code>模块上配置<em>测试</em>依赖项，然后使用<code>@ExtendWith(IgnoreCondition.class)</code>或<code><a href="../api/org/junit/jupiter/migrationsupport/EnableJUnit4MigrationSupport.html">@EnableJUnit4MigrationSupport</a></code> （它自动注册<code>IgnoreCondition</code>以及<a href="#migrating-from-junit4-rule-support">有限的JUnit 4规则支持</a> ）。<code>IgnoreCondition</code>是一个<code><a href="../api/org/junit/jupiter/api/extension/ExecutionCondition.html">ExecutionCondition</a></code> ，它禁用使用<code>@Ignore</code>注释的测试类或测试方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.junit。忽略</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.migrationsupport。EnableJUnit4MigrationSupport</span> ; <span class="comment">// @ExtendWith（IgnoreCondition.class）</span> <span class="annotation">@EnableJUnit4MigrationSupport</span> <span class="type">类</span> <span class="class">IgnoredTestsDemo</span> { <span class="annotation">@Ignore</span> <span class="annotation">@Test</span> <span class="type">void</span> testWillBeIgnored（）{} <span class="annotation">@Test</span> <span class="type">void</span> testWillBeExecuted（）{}}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">JUnit 4中的JUnit 4 <code>@Ignore</code>支持<code>@Ignore</code>目前是一个<em>实验性</em>功能。有关详细信息，请参阅<a href="#api-evolution-experimental-apis">实验API中</a>的表。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="running-tests"><a class="anchor" href="#running-tests"></a> 4。运行测试</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="running-tests-ide"><a class="anchor" href="#running-tests-ide"></a> 4.1。IDE支持</h3>
<div class="sect3">
<h4 id="running-tests-ide-intellij-idea"><a class="anchor" href="#running-tests-ide-intellij-idea"></a> 4.1.1。IntelliJ IDEA</h4>
<div class="paragraph">
<p>IntelliJ IDEA支持自2016.2版以来在JUnit平台上运行测试。有关详细信息，请参阅<a href="https://blog.jetbrains.com/idea/2016/08/using-junit-5-in-intellij-idea/">IntelliJ IDEA博客上的帖子</a> 。但请注意，建议使用IDEA 2017.3或更新版本，因为这些较新版本的IDEA将根据项目中使用的API版本自动下载以下JAR： <code>junit-platform-launcher</code> ， <code>junit-jupiter-engine</code>和<code>junit-vintage-engine</code> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">IntelliJ IDEA在IDEA 2017.3之前发布了特定版本的JUnit 5。因此，如果要使用较新版本的JUnit Jupiter，则由于版本冲突，IDE中的测试执行可能会失败。在这种情况下，请按照以下说明使用较新版本的JUnit 5，而不是与IntelliJ IDEA捆绑的版本。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了使用不同的JUnit 5版本（例如，5.5.1），您可能需要在类路径中包含相应版本的<code>junit-platform-launcher</code> ， <code>junit-jupiter-engine</code>和<code>junit-vintage-engine</code> JAR。</p>
</div>
<div class="listingblock">
<div class="title">额外的Gradle依赖项</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">//只需要在IntelliJ IDEA版本中运行测试，该版本捆绑旧版本</span> testRuntimeOnly（ <span class="string"><span class="delimiter">“</span> <span class="content">org.junit.platform：junit-platform-launcher：1.5.1</span> <span class="delimiter">”</span></span> ）testRuntimeOnly（ <span class="string"><span class="delimiter">“</span> <span class="content">org.junit.jupiter：junit-jupiter-引擎：5.5.1</span> <span class="delimiter">“</span></span> ）testRuntimeOnly（ <span class="string"><span class="delimiter">”</span> <span class="content">org.junit.vintage：junit-vintage-engine：5.5.1</span> <span class="delimiter">“</span></span> ）</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">额外的Maven依赖项</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ - 仅需要在捆绑旧版本的IntelliJ IDEA版本中运行测试 - &gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> org.junit.platform <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> junit-platform-launcher <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt; version&gt;</span> 1.5.1 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;scope&gt;</span> test <span class="tag">&lt;/ scope&gt;</span> <span class="tag">&lt;/ dependency&gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> org.junit.jupiter <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> junit-jupiter-engine <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version &gt;</span> 5.5.1 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;scope&gt;</span> test <span class="tag">&lt;/ scope&gt;</span> <span class="tag">&lt;/ dependency&gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> org.junit.vintage <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> junit-vintage-engine <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 5.5.1 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;scope&gt;</span> test <span class="tag">&lt;/ scope&gt;</span> <span class="tag">&lt;/ dependency&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-ide-eclipse"><a class="anchor" href="#running-tests-ide-eclipse"></a> 4.1.2。日食</h4>
<div class="paragraph">
<p>自Eclipse Oxygen.1a（4.7.1a）发布以来，Eclipse IDE为JUnit平台提供支持。</p>
</div>
<div class="paragraph">
<p>有关在Eclipse中使用JUnit 5的更多信息，请参阅<a href="https://www.eclipse.org/eclipse/news/4.7.1a/#junit-5-support">Eclipse Project Oxygen.1a（4.7.1a）的</a> <em>JUnit 5</em>部分的官方<em>Eclipse支持</em> <a href="https://www.eclipse.org/eclipse/news/4.7.1a/#junit-5-support">- 新的和值得注意的</a>文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-ide-netbeans"><a class="anchor" href="#running-tests-ide-netbeans"></a> 4.1.3。NetBeans的</h4>
<div class="paragraph">
<p>自<a href="https://netbeans.apache.org/download/nb100/nb100.html">Apache NetBeans 10.0发布</a>以来， <a href="https://netbeans.apache.org/download/nb100/nb100.html">NetBeans</a>为JUnit Jupiter和JUnit Platform提供支持。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="https://netbeans.apache.org/download/nb100/index.html#_junit_5">Apache NetBeans 10.0发行说明</a>的JUnit 5部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-ide-vscode"><a class="anchor" href="#running-tests-ide-vscode"></a> 4.1.4。Visual Studio代码</h4>
<div class="paragraph">
<p><a href="https://code.visualstudio.com/">Visual Studio Code</a>通过<a href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-test">Java Test Runner</a>扩展支持JUnit Jupiter和JUnit Platform，该扩展默认安装为<a href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack">Java Extension Pack的一部分</a> 。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="https://code.visualstudio.com/docs/languages/java#_testing">Visual Studio代码</a>文档中<a href="https://code.visualstudio.com/docs/languages/java#_testing">Java</a>的“ <em>测试”</em>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-ide-other"><a class="anchor" href="#running-tests-ide-other"></a> 4.1.5。其他IDE</h4>
<div class="paragraph">
<p>如果您使用的是前一节中列出的编辑器或IDE之外的其他编辑器或IDE，则JUnit团队提供了两种替代解决方案来帮助您使用JUnit 5。您可以手动使用<a href="#running-tests-console-launcher">Console Launcher</a> （例如，从命令行） - 或者如果您的IDE具有对JUnit 4的内置支持，则可以使用<a href="#running-tests-junit-platform-runner">基于JUnit 4的Runner</a>执行测试。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-tests-build"><a class="anchor" href="#running-tests-build"></a> 4.2。构建支持</h3>
<div class="sect3">
<h4 id="running-tests-build-gradle"><a class="anchor" href="#running-tests-build-gradle"></a> 4.2.1。摇篮</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">JUnit Platform Gradle插件已停止使用</div>
<div class="paragraph">
<p>由JUnit团队开发的<code>junit-platform-gradle-plugin</code>在JUnit Platform 1.2中已弃用，在1.3中已停止使用。请切换到Gradle的标准<code>test</code>任务。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>从<a href="https://docs.gradle.org/4.6/release-notes.html">版本4.6</a>开始，Gradle为在JUnit平台上执行测试提供<a href="https://docs.gradle.org/current/userguide/java_testing.html#using_junit5">本机支持</a> 。要启用它，你只需要指定<code>useJUnitPlatform()</code>一内部<code>test</code>中的任务声明<code>build.gradle</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">test {useJUnitPlatform（）}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还支持按标签或引擎过滤：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">测试{useJUnitPlatform {includeTags <span class="string"><span class="delimiter">'</span> <span class="content">快</span> <span class="delimiter">'，</span></span> <span class="string"><span class="delimiter">'</span> <span class="content">烟雾＆特征<span class="delimiter">-A'</span></span></span> <span class="comment">// excludeTags '慢'， '词'</span> includeEngines <span class="string"><span class="delimiter">'</span> <span class="content">的junit-木星</span> <span class="delimiter">'</span></span> <span class="comment">// excludeEngines '的junit复古'}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关选项的完整列表，请参阅<a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_test">官方Gradle文档</a> 。</p>
</div>
<div class="sect4">
<h5 id="running-tests-build-gradle-config-params"><a class="anchor" href="#running-tests-build-gradle-config-params"></a>配置参数</h5>
<div class="paragraph">
<p>标准Gradle <code>test</code>任务当前未提供专用DSL来设置JUnit Platform <a href="#running-tests-config-params">配置参数</a>以影响测试发现和执行。但是，您可以通过系统属性（如下所示）或通过<code>junit-platform.properties</code>文件在构建脚本中提供配置参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">测试{ <span class="comment">// ...</span>systemProperty <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">'junit.jupiter.conditions.deactivate'，</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">'*'</span></span></span></span> systemProperties = [ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">'junit.jupiter.extensions.autodetection.enabled'：</span></span></span></span> <span class="string"><span class="delimiter">'</span> <span class="content">真</span> <span class="delimiter">'，</span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">'junit.jupiter.testinstance.lifecycle.default'：</span></span></span></span> <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">'per_class']</span></span></span></span> <span class="comment">/ / ...</span>}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running-tests-build-gradle-engines-configure"><a class="anchor" href="#running-tests-build-gradle-engines-configure"></a>配置测试引擎</h5>
<div class="paragraph">
<p>为了运行任何测试， <code>TestEngine</code>实现必须在类路径上。</p>
</div>
<div class="paragraph">
<p>要配置支持基于JUnit的木星测试，配置<code>testImplementation</code>上了JUnit木星API和依赖<code>testRuntimeOnly</code>上JUnit的木星依赖<code>TestEngine</code>执行类似如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">dependencies {testImplementation（ <span class="string"><span class="delimiter">“</span> <span class="content">org.junit.jupiter：junit-jupiter-api：5.5.1</span> <span class="delimiter">”</span></span> ）testRuntimeOnly（ <span class="string"><span class="delimiter">“</span> <span class="content">org.junit.jupiter：junit-jupiter-engine：5.5.1</span> <span class="delimiter">”</span></span> ）}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要您在JUnit 4上配置<code>testRuntimeOnly</code>依赖项并对JUnit Vintage <code>TestEngine</code>实现配置<code>testImplementation</code>依赖项，JUnit Platform就可以运行基于JUnit 4的测试，类似于以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">依赖项{testImplementation（ <span class="string"><span class="delimiter">“</span> <span class="content">junit：junit：4.12</span> <span class="delimiter">”</span></span> ）testRuntimeOnly（ <span class="string"><span class="delimiter">“</span> <span class="content">org.junit.vintage：junit-vintage-engine：5.5.1</span> <span class="delimiter">”</span></span> ）}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running-tests-build-gradle-logging"><a class="anchor" href="#running-tests-build-gradle-logging"></a>配置日志记录（可选）</h5>
<div class="paragraph">
<p>JUnit使用<code>java.util.logging</code>包（也称为<em>JUL</em> ） <code>java.util.logging</code>的Java Logging API来发出警告和调试信息。有关配置选项，请参阅<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/LogManager.html">LogManager</a></code>的官方文档。</p>
</div>
<div class="paragraph">
<p>或者，可以将日志消息重定向到其他日志框架，例如<a href="https://logging.apache.org/log4j/2.x/">Log4j</a>或<a href="https://logback.qos.ch/">Logback</a> 。要使用提供<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/LogManager.html">LogManager</a></code>自定义实现的日志记录框架，请将<code>java.util.logging.manager</code>系统属性设置为要使用的<code><a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/LogManager.html">LogManager</a></code>实现的<em>完全限定类名</em> 。下面的示例演示了如何配置Log4j 2.x（有关详细信息，请参阅<a href="https://logging.apache.org/log4j/2.x/log4j-jul/index.html">Log4j JDK日志记录适配器</a> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">测试{systemProperty <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="string"><span class="delimiter"><span class="content">'java.util.logging.manager'，'org.apache.logging.log4j.jul。</span></span></span></span></span>LogManager</span> <span class="delimiter">'</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他日志记录框架提供了不同的方法来重定向使用<code>java.util.logging</code>记录的消息。例如，对于<a href="https://logback.qos.ch/">Logback，</a>您可以通过向运行时类路径添加其他依赖项来使用<a href="https://www.slf4j.org/legacy.html#jul-to-slf4j">JUL到SLF4J Bridge</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-build-maven"><a class="anchor" href="#running-tests-build-maven"></a> 4.2.2。Maven的</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">JUnit平台Maven Surefire提供商已经停产</div>
<div class="paragraph">
<p>最初由JUnit团队开发的<code>junit-platform-surefire-provider</code>在JUnit Platform 1.3中已被弃用，并在1.4中停止使用。请改用Maven Surefire的原生支持。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>从<a href="https://issues.apache.org/jira/browse/SUREFIRE-1330">版本2.22.0</a>开始，Maven Surefire和Maven Failsafe为在JUnit平台上执行测试提供<a href="https://maven.apache.org/surefire/maven-surefire-plugin/examples/junit-platform.html">本机支持</a> 。<code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-starter-maven">junit5-jupiter-starter-maven</a></code>项目中的<code>pom.xml</code>文件演示了如何使用Maven Surefire插件，并可以作为配置Maven构建的起点。</p>
</div>
<div class="sect4">
<h5 id="running-tests-build-maven-engines-configure"><a class="anchor" href="#running-tests-build-maven-engines-configure"></a>配置测试引擎</h5>
<div class="paragraph">
<p>为了让Maven Surefire或Maven Failsafe运行任何测试，必须至少将一个<code>TestEngine</code>实现添加到测试类路径中。</p>
</div>
<div class="paragraph">
<p>要配置对基于JUnit Jupiter的测试的支持，请在JUnit Jupiter API和JUnit Jupiter <code>TestEngine</code>实现上配置<code>test</code>范围依赖项，类似于以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;build&gt;</span> <span class="tag">&lt;plugins&gt;</span> <span class="tag">&lt;plugin&gt;</span> <span class="tag">&lt;artifactId&gt;</span> maven-surefire-plugin <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 2.22.2 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;/ plugin&gt;</span> <span class="tag">&lt;plugin&gt;</span> <span class="tag">&lt;artifactId&gt;</span> maven-failsafe-plugin <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 2.22.2 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;/ plugin&gt;</span> <span class="tag">&lt;/ plugins&gt;</span> <span class="tag">&lt;/ build&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;dependencies&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId &gt;</span> org.junit.jupiter <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> junit-jupiter-api <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 5.5.1 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;scope&gt;</span> test <span class="tag">&lt;/ scope&gt;</span> <span class="tag">&lt;/ dependency&gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> org.junit.jupiter <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> junit-jupiter-engine <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 5.5.1 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;scope&gt;</span> test <span class="tag">&lt;/ scope&gt;</span> <span class="tag">&lt;/ dependency&gt;</span> <span class="comment">&lt;！ -  ... - &gt;</span> <span class="tag">&lt;/ dependencies&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>只要您在JUnit 4和JUnit Vintage <code>TestEngine</code>实现上配置<code>test</code>范围依赖项，Maven Surefire和Maven Failsafe就可以运行基于JUnit 4的测试以及Jupiter测试，类似于以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;build&gt;</span> <span class="tag">&lt;plugins&gt;</span> <span class="tag">&lt;plugin&gt;</span> <span class="tag">&lt;artifactId&gt;</span> maven-surefire-plugin <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 2.22.2 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;/ plugin&gt;</span> <span class="tag">&lt;plugin&gt;</span> <span class="tag">&lt;artifactId &gt;</span> maven-failsafe-plugin <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 2.22.2 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;/ plugin&gt;</span> <span class="tag">&lt;/ plugins&gt;</span> <span class="tag">&lt;/ build&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;dependencies&gt;</span> <span class="comment">&lt;！ - 。 ..  - &gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> junit <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> junit <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 4.12 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;scope&gt;</span> test <span class="tag">&lt;/ scope&gt;</span> <span class="tag">&lt;/ dependency&gt;</span> <span class="tag">&lt;dependency&gt;</span> <span class="tag">&lt;groupId&gt;</span> org.junit.vintage <span class="tag">&lt;/ groupId&gt;</span> <span class="tag">&lt;artifactId&gt;</span> junit-vintage-engine <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 5.5.1 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;scope&gt;</span> test <span class="tag">&lt;/ scope&gt;</span> <span class="tag">&lt;/ dependency&gt;</span> <span class="comment">&lt;！ -  ... - &gt;</span> <span class="tag">&lt;/ dependencies&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running-tests-build-maven-filter-test-class-names"><a class="anchor" href="#running-tests-build-maven-filter-test-class-names"></a>按测试类名称过滤</h5>
<div class="paragraph">
<p>Maven Surefire插件将扫描其完全限定名称与以下模式匹配的测试类。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>** /测试*的.java</code></p>
</li>
<li>
<p><code>** / * Test.java</code></p>
</li>
<li>
<p><code>** / * Tests.java</code></p>
</li>
<li>
<p><code>** / * TestCase.java</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，它将默认排除所有嵌套类（包括静态成员类）。</p>
</div>
<div class="paragraph">
<p>但请注意，您可以通过在<code>pom.xml</code>文件中配置显式<code>include</code>和<code>exclude</code>规则来覆盖此默认行为。例如，为了防止Maven Surefire排除静态成员类，您可以按如下方式覆盖其排除规则。</p>
</div>
<div class="listingblock">
<div class="title">覆盖Maven Surefire的排除规则</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;build&gt;</span> <span class="tag">&lt;plugins&gt;</span> <span class="tag">&lt;plugin&gt;</span> <span class="tag">&lt;artifactId&gt;</span> maven-surefire-plugin <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 2.22.2 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;configuration&gt;</span> <span class="tag">&lt;excludes&gt;</span> <span class="tag">&lt;exclude</span> <span class="tag">/ &gt;</span> <span class="tag">&lt;/ excludes&gt;</span> <span class="tag">&lt;/ configuration&gt;</span> <span class="tag">&lt;/ plugin&gt;</span> <span class="tag">&lt;/ plugins&gt;</span> <span class="tag">&lt;/ build&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅Maven Surefire的<a href="https://maven.apache.org/surefire/maven-surefire-plugin/examples/inclusion-exclusion.html">包含和排除测试</a>文档。</p>
</div>
</div>
<div class="sect4">
<h5 id="running-tests-build-maven-filter-tags"><a class="anchor" href="#running-tests-build-maven-filter-tags"></a>按标签过滤</h5>
<div class="paragraph">
<p>您可以使用以下配置属性按标记或<a href="#running-tests-tag-expressions">标记表达式</a>过滤测试。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要包含<em>标签</em>或<em>标签表达式</em> ，请使用<code>groups</code> 。</p>
</li>
<li>
<p>要排除<em>标记</em>或<em>标记表达式</em> ，请使用<code>excludedGroups</code> 。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;build&gt;</span> <span class="tag">&lt;plugins&gt;</span> <span class="tag">&lt;plugin&gt;</span> <span class="tag">&lt;artifactId&gt;</span> maven-surefire-plugin <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 2.22.2 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;configuration&gt;</span> <span class="tag">&lt;groups&gt;</span> acceptance | ！feature-a <span class="tag">&lt;/ groups&gt;</span> <span class="tag">&lt;excludedGroups&gt;</span>集成，回归<span class="tag">&lt;/ excludedGroups&gt;</span> <span class="tag">&lt;/ configuration&gt;</span> <span class="tag">&lt;/ plugin&gt;</span> <span class="tag">&lt;/ plugins&gt;</span> <span class="tag">&lt;/ build&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running-tests-build-maven-config-params"><a class="anchor" href="#running-tests-build-maven-config-params"></a>配置参数</h5>
<div class="paragraph">
<p>您可以通过声明<code>configurationParameters</code>属性并使用Java <code>Properties</code>文件语法（如下所示）或<code>junit-platform.properties</code>文件提供键值对来设置JUnit Platform <a href="#running-tests-config-params">配置参数</a>以影响测试发现和执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;！ -  ...  - &gt;</span> <span class="tag">&lt;build&gt;</span> <span class="tag">&lt;plugins&gt;</span> <span class="tag">&lt;plugin&gt;</span> <span class="tag">&lt;artifactId&gt;</span> maven-surefire-plugin <span class="tag">&lt;/ artifactId&gt;</span> <span class="tag">&lt;version&gt;</span> 2.22.2 <span class="tag">&lt;/ version&gt;</span> <span class="tag">&lt;configuration&gt;</span> <span class="tag">&lt;properties&gt;</span> <span class="tag">&lt;configurationParameters&gt;</span> junit.jupiter.conditions.deactivate = * junit.jupiter.extensions.autodetection.enabled = true junit.jupiter.testinstance.lifecycle.default = per_class <span class="tag">&lt;/ configurationParameters&gt;</span> <span class="tag">&lt;/ properties&gt;</span> <span class="tag">&lt;/ configuration&gt;</span> <span class="tag">&lt;/ plugin&gt;</span> <span class="tag">&lt;/ plugins &gt;</span> <span class="tag">&lt;/ build&gt;</span> <span class="comment">&lt;！ -  ...  - &gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-build-ant"><a class="anchor" href="#running-tests-build-ant"></a> 4.2.3。蚂蚁</h4>
<div class="paragraph">
<p>从<a href="https://ant.apache.org/">Ant的</a> <code>1.10.3</code>版本开始，引入了一个新的<a href="https://ant.apache.org/manual/Tasks/junitlauncher.html"><code>junitlauncher</code></a>任务，为在JUnit平台上启动测试提供本机支持。<code>junitlauncher</code>任务完全负责启动JUnit平台并将选定的测试集合传递给它。然后，JUnit平台委托已注册的测试引擎来发现和执行测试。</p>
</div>
<div class="paragraph">
<p><code>junitlauncher</code>任务尝试尽可能地与本机Ant构造（例如<a href="https://ant.apache.org/manual/Types/resources.html#collection">资源集合）</a>对齐，以允许用户选择他们想要由测试引擎执行的测试。与许多其他核心Ant任务相比，这使任务具有一致和自然的感觉。</p>
</div>
<div class="paragraph">
<p>从Ant的<code>1.10.6</code>版开始， <code>junitlauncher</code>任务支持<a href="https://ant.apache.org/manual/Tasks/junitlauncher.html#fork">在单独的JVM中分配测试</a> 。</p>
</div>
<div class="paragraph">
<p><code><a href="https://github.com/junit-team/junit5-samples/tree/r5.5.1/junit5-jupiter-starter-ant">junit5-jupiter-starter-ant</a></code>项目中的<code>build.xml</code>文件演示了如何使用该任务，并可以作为起点。</p>
</div>
<div class="sect4">
<h5 id="basic-usage"><a class="anchor" href="#basic-usage"></a>基本用法</h5>
<div class="paragraph">
<p>以下示例演示如何配置<code>junitlauncher</code>任务以选择单个测试类（即<code>org.myapp.test.MyFirstJUnit5Test</code> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;path</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">test.classpath</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 编译类的</span> <span class="attribute-name">位置</span> <span class="comment">- &gt;</span> <span class="tag">&lt;pathelement</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {build.classes.dir}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ path&gt;</span> <span class="comment">&lt;！ - 。 ..  - &gt;</span> <span class="tag">&lt;junitlauncher&gt;</span> <span class="tag">&lt;classpath</span> <span class="attribute-name">refid</span> = <span class="string"><span class="delimiter">“</span> <span class="content">test.classpath</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;test</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org.myapp.test.MyFirstJUnit5Test</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ junitlauncher&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>test</code>元素允许您指定要选择和执行的单个测试类。<code>classpath</code>元素允许您指定用于启动JUnit Platform的类路径。此类路径还将用于定位作为执行一部分的测试类。</p>
</div>
<div class="paragraph">
<p>以下示例演示如何配置<code>junitlauncher</code>任务以从多个位置选择测试类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;path</span> <span class="attribute-name">id</span> = <span class="string"><span class="delimiter">“</span> <span class="content">test.classpath</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="comment">&lt;！ - 编译类的</span> <span class="attribute-name">位置</span> <span class="comment">- &gt;</span> <span class="tag">&lt;pathelement</span> <span class="attribute-name">location</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {build.classes.dir}</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ path&gt;</span> <span class="comment">&lt;！ - 。 .. - &gt;</span> <span class="tag">&lt;junitlauncher&gt;</span> <span class="tag">&lt;类路径</span> <span class="attribute-name">REFID</span> = <span class="string"><span class="delimiter"><span class="content"><span class="delimiter"><span class="tag">“test.classpath”/&gt;</span></span></span></span></span> <span class="tag">&lt;testclasses</span> <span class="attribute-name">outputdir</span> = <span class="string"><span class="content"><span class="delimiter">“$</span> <span class="delimiter"><span class="tag">{output.dir}”&gt;</span></span></span></span> <span class="tag">&lt;文件集</span> <span class="attribute-name">DIR</span> = <span class="string"><span class="content"><span class="delimiter">“$</span> {的<span class="delimiter"><span class="tag">build.classes.dir}”&gt;</span></span></span></span> <span class="tag">&lt;包括</span> <span class="attribute-name">名称</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org / example / ** / demo / ** /</span> <span class="delimiter">”</span></span> <span class="tag">/&gt;</span> <span class="tag">&lt;/ fileset&gt;</span> <span class="tag">&lt;fileset</span> <span class="attribute-name">dir</span> = <span class="string"><span class="delimiter">“</span> <span class="content">$ {some.other.dir}</span> <span class="delimiter">”</span></span> <span class="tag">&gt;</span> <span class="tag">&lt;include</span> <span class="attribute-name">name</span> = <span class="string"><span class="delimiter">“</span> <span class="content">org / myapp / ** /</span> <span class="delimiter">”</span></span> <span class="tag">/ &gt;</span> <span class="tag">&lt;/ fileset</span> <span class="tag">&gt;</span> <span class="tag">&lt;/ testclasses&gt; &lt;/ junitlauncher&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中， <code>testclasses</code>元素允许您选择位于不同位置的多个测试类。</p>
</div>
<div class="paragraph">
<p>有关使用和配置选项的更多详细信息，请参阅<a href="https://ant.apache.org/manual/Tasks/junitlauncher.html"><code>junitlauncher</code>任务</a>的官方Ant文档。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-tests-console-launcher"><a class="anchor" href="#running-tests-console-launcher"></a> 4.3。控制台启动器</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/platform/console/ConsoleLauncher.html">ConsoleLauncher</a></code>是一个命令行Java应用程序，允许您从控制台启动JUnit平台。例如，它可用于运行JUnit Vintage和JUnit Jupiter测试并将测试执行结果打印到控制台。</p>
</div>
<div class="paragraph">
<p>包含所有依赖项的可执行文件<code>junit-platform-console-standalone-1.5.1.jar</code>发布在<a href="https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone">junit-platform-console-standalone</a>目录下的<a href="https://search.maven.org/">Maven Central</a>存储库中。您可以<a href="https://docs.oracle.com/javase/tutorial/deployment/jar/run.html">运行</a>独立的<code>ConsoleLauncher</code> ，如下所示。</p>
</div>
<div class="paragraph">
<p><code>java -jar junit-platform-console-standalone-1.5.1.jar &lt; <a href="#running-tests-console-launcher-options">Options</a> &gt;</code></p>
</div>
<div class="paragraph">
<p>以下是其输出的示例：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>├─JUnitVintage│└--例子。JUnit4测试│└─standardJUnit4测试✔└─JUnitJupiter├─标准测试│├─successTest（）✔│└─swpedpedTest（）↷用于演示目的└─特殊测试用例├─包含空格的自定义测试名称✔├─╯°□° ）╯✔└─😱✔测试运行在64 ms后完成[找到5个容器] [0个容器已跳过] [5个容器已启动] [0个容器已中止] [5个容器已成功] [0个容器已成功] [0个容器已失败] [找到6个测试] [1跳过测试] [5个测试开始] [0测试中止] [5个测试成功] [0测试失败]</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">退出代码</div>如果任何容器或测试失败， <code><a href="../api/org/junit/platform/console/ConsoleLauncher.html">ConsoleLauncher</a></code>退出，状态代码为<code>1</code> 。如果未发现任何测试并且提供了<code>--fail-if-no-tests</code>命令行选项，则<code>ConsoleLauncher</code>将以状态代码<code>2</code>退出。否则退出代码为<code>0</code> 。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="running-tests-console-launcher-options"><a class="anchor" href="#running-tests-console-launcher-options"></a> 4.3.1。选项</h4>
<div class="listingblock">
<div class="content">
<pre>感谢您使用JUnit！支持其开发https://junit.org/sponsoring用法：ConsoleLauncher [-h] [--disable-ansi-colors] [--disable-banner] [--fail-if-no-tests] [ - scan-modules] [--scan-classpath [= PATH [; |：PATH ...]]] ... [--details = MODE] [--details-theme = THEME] [--reports-dir = DIR] [--config = KEY = VALUE] ......[--exclude-package = PKG] ... [--include-package = PKG] ......[-c = CLASS] ... [-cp = PATH [; |：PATH ...]] ... [-d = DIR] ... [-e = ID] ......[-E = ID] ... [ -  f = FILE] ... [ -  m = NAME] ... [-n = PATTERN] ...[-N = PATTERN] ... [ -  o = NAME] ... [ -  p = PKG] ... [ -  r = RESOURCE] ...[-t = TAG] ...[-T = TAG] ... [ -  u = URI] ...从控制台启动JUnit平台。-h， -  help显示帮助信息。--disable-ansi-colors禁用输出中的ANSI颜色（并非所有终端都支持）。--disable-banner禁止打印欢迎消息。--details = MODE选择执行测试时的输出详细信息模式。使用以下之一：none，summary，flat，tree，verbose。如果选择“无”，则仅显示摘要和测试失败。默认值：树。--details-theme = THEME选择执行测试时的输出详细信息树主题。使用以下之一：ascii，unicode。默认值：unicode。-cp， -  classpath， -  class-path = PATH [; |：PATH ...]提供其他类路径条目 - 例如，用于添加引擎及其依赖项。可以重复此选项。--fail-if-no-tests如果没有找到测试，则失败并返回退出状态码2。--reports-dir = DIR将报告输出启用到指定的本地目录（如果不存在，将创建）。--scan-modules实验：扫描所有已解析的模块以进行测试发现。-o， -  select-module = NAME EXPERIMENTAL：选择单个模块进行测试发现。可以重复此选项。--scan-classpath， -  scan-class-path [= PATH [; |：PATH ...]]扫描类路径或显式类路径根目录上的所有目录。如果没有参数，则只扫描系统类路径上的目录以及通过-cp（目录和JAR文件）提供的其他类路径条目。将隐式忽略不在类路径上的显式类路径根。可以重复此选项。-u， -  select-uri = URI选择测试发现的URI。可以重复此选项。-f， -  select-file = FILE选择用于测试发现的文件。可以重复此选项。-d， -  select-directory = DIR选择用于测试发现的目录。可以重复此选项。-p， -  select-package = PKG选择用于测试发现的包。可以重复此选项。-c， -  select-class = CLASS选择用于测试发现的类。可以重复此选项。-m， -  select-method = NAME选择测试发现的方法。可以重复此选项。-r， -  select-resource = RESOURCE选择用于测试发现的类路径资源。可以重复此选项。-n， -  include-classname = PATTERN提供正则表达式以仅包含完全限定名称匹配的类。为避免不必要地加载类，默认模式仅包括以“Test”开头或以“Test”或“Tests”结尾的类名。重复此选项时，将使用OR语义组合所有模式。默认值：[^（测试。* |。+ [。$]测试。* |。*测试？）$] -N， -  exclude-classname = PATTERN提供正则表达式以排除那些完全限定名称匹配的类。重复此选项时，将使用OR语义组合所有模式。--include-package = PKG提供要包含在测试运行中的包。可以重复此选项。--exclude-package = PKG提供要从测试运行中排除的包。可以重复此选项。-t， -  include-tag = TAG提供标记或标记表达式，仅包含其标记匹配的测试。重复此选项时，将使用OR语义组合所有模式。-T， -  exclude-tag = TAG提供标记或标记表达式以排除那些标记匹配的测试。重复此选项时，将使用OR语义组合所有模式。-e， -  include-engine = ID提供要包含在测试运行中的引擎的ID。可以重复此选项。-E， -  exclude-engine = ID提供要从测试运行中排除的引擎的ID。可以重复此选项。--config = KEY = VALUE设置测试发现和执行的配置参数。可以重复此选项。</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-console-launcher-argument-files"><a class="anchor" href="#running-tests-console-launcher-argument-files"></a> 4.3.2。参数文件（@ -files）</h4>
<div class="paragraph">
<p>在某些平台上，在创建具有大量选项或长参数的命令行时，您可能会遇到命令行长度的系统限制。</p>
</div>
<div class="paragraph">
<p>从版本1.3开始， <code>ConsoleLauncher</code>支持<em>参数文件</em> ，也称为<em>@ -files</em> 。参数文件是本身包含要传递给命令的参数的文件。当底层<a href="https://github.com/remkop/picocli">picocli</a>命令行解析器遇到以字符<code>@</code>开头的参数时，它会将该文件的内容扩展到参数列表中。</p>
</div>
<div class="paragraph">
<p>文件中的参数可以用空格或换行符分隔。如果参数包含嵌入的空格，则整个参数应包含在双引号或单引号中 - 例如， <code>"-f=My Files/Stuff.java"</code> 。</p>
</div>
<div class="paragraph">
<p>如果参数文件不存在或无法读取，则参数将按字面处理，不会被删除。这可能会导致“不匹配的参数”错误消息。您可以通过执行<code>picocli.trace</code>系统属性设置为<code>DEBUG</code>的命令来解决此类错误。</p>
</div>
<div class="paragraph">
<p>可以在命令行上指定多个<em>@ -files</em> 。指定的路径可能相对于当前目录或绝对路径。</p>
</div>
<div class="paragraph">
<p>您可以通过使用额外的<code>@</code>符号转义它来传递带有初始<code>@</code>字符的实参数。例如， <code>@@somearg</code>将成为<code>@somearg</code> ，不会受到扩展。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-tests-junit-platform-runner"><a class="anchor" href="#running-tests-junit-platform-runner"></a> 4.4。使用JUnit 4运行JUnit平台</h3>
<div class="paragraph">
<p><code>JUnitPlatform</code>是基于JUnit 4的<code>Runner</code> ，它允许您在JUnit 4环境中运行JUnit平台支持其编程模型的任何测试 - 例如，JUnit Jupiter测试类。</p>
</div>
<div class="paragraph">
<p>使用<code>@RunWith(JUnitPlatform.class)</code>注释类允许它使用IDE运行并构建支持JUnit 4但尚未直接支持JUnit Platform的系统。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于JUnit平台具有JUnit 4所没有的功能，因此运行器只能支持JUnit平台功能的一部分，特别是在报告方面（请参阅<a href="#running-tests-junit-platform-runner-technical-names">显示名称与技术名称</a> ）。但目前<code>JUnitPlatform</code>跑步者是一种简单的入门方式。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="running-tests-junit-platform-runner-setup"><a class="anchor" href="#running-tests-junit-platform-runner-setup"></a> 4.4.1。建立</h4>
<div class="paragraph">
<p>您需要在类路径上使用以下工件及其依赖项。有关组ID，工件ID和版本的详细信息，请参阅<a href="#dependency-metadata">依赖关系元数据</a> 。</p>
</div>
<div class="sect4">
<h5 id="explicit-dependencies"><a class="anchor" href="#explicit-dependencies"></a>明确的依赖关系</h5>
<div class="ulist">
<ul>
<li>
<p><em>测试</em>范围内的<code>junit-platform-runner</code> ： <code>JUnitPlatform</code>位置</p>
</li>
<li>
<p><em>测试</em>范围内的<code>junit-4.12.jar</code> ：使用JUnit 4运行测试</p>
</li>
<li>
<p><em>测试</em>范围内的<code>junit-jupiter-api</code> ：使用JUnit Jupiter编写测试的API，包括<code>@Test</code>等。</p>
</li>
<li>
<p><em>测试运行时</em>范围内的<code>junit-jupiter-engine</code> ：JUnit Jupiter的<code>TestEngine</code> API的实现</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="transitive-dependencies"><a class="anchor" href="#transitive-dependencies"></a>传递依赖</h5>
<div class="ulist">
<ul>
<li>
<p><em>测试</em>范围内的<code>junit-platform-suite-api</code></p>
</li>
<li>
<p><em>测试</em>范围内的<code>junit-platform-launcher</code></p>
</li>
<li>
<p><em>测试</em>范围内的<code>junit-platform-engine</code></p>
</li>
<li>
<p><em>测试</em>范围内的<code>junit-platform-commons</code></p>
</li>
<li>
<p><em>测试</em>范围内的<code>opentest4j</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-junit-platform-runner-technical-names"><a class="anchor" href="#running-tests-junit-platform-runner-technical-names"></a> 4.4.2。显示名称与技术名称</h4>
<div class="paragraph">
<p>以限定用于经由运行类的定制<em>显示名称</em> <code>@RunWith(JUnitPlatform.class)</code>简单地注释与类<code>@SuiteDisplayName</code>和提供自定义的值。</p>
</div>
<div class="paragraph">
<p>默认情况下， <em>显示名称</em>将用于测试工件;但是，当<code>JUnitPlatform</code>器用于使用构建工具（如Gradle或Maven）执行测试时，生成的测试报告通常需要包含测试工件的<em>技术名称</em> - 例如，完全限定的类名称 - 而不是像测试类的简单名称或包含特殊字符的自定义显示名称。要为报告目的启用技术名称，只需在<code>@RunWith(JUnitPlatform.class)</code>旁边声明<code>@UseTechnicalNames</code>批注。</p>
</div>
<div class="paragraph">
<p>请注意， <code>@UseTechnicalNames</code>的存在会覆盖通过<code>@SuiteDisplayName</code>配置的任何自定义显示名称。</p>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-junit-platform-runner-single-test"><a class="anchor" href="#running-tests-junit-platform-runner-single-test"></a> 4.4.3。单一测试类</h4>
<div class="paragraph">
<p>使用<code>JUnitPlatform</code>一种方法是直接使用<code>@RunWith(JUnitPlatform.class)</code>注释测试类。请注意，以下示例中的测试方法使用<code>org.junit.jupiter.api.进行注释<code>org.junit.jupiter.api.Test</code> （JUnit Jupiter），而不是<code>org.junit.Test</code> （JUnit 4）。此外，在这种情况下，测试类必须是<code>public</code> ;否则，某些IDE和构建工具可能无法将其识别为JUnit 4测试类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。断言</span> 。 失败</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.runner。JUnitPlatform</span> ; <span class="keyword">import</span> <span class="include">org.junit.runner。RunWith</span> ; <span class="annotation">@RunWith</span> （JUnitPlatform.class） <span class="directive">公共</span> <span class="type">类</span> <span class="class">JUnitPlatformClassDemo</span> { <span class="annotation">@Test</span> <span class="type">void</span> <span class="class">succeedingTest</span> （）{ <span class="comment">/ * no-op * /</span> } <span class="annotation">@Test</span> <span class="type">void</span> failingTest（）{fail（ <span class="string"><span class="delimiter">“</span> <span class="content">失败为了失败。</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-tests-junit-platform-runner-test-suite"><a class="anchor" href="#running-tests-junit-platform-runner-test-suite"></a> 4.4.4。测试套件</h4>
<div class="paragraph">
<p>如果您有多个测试类，则可以创建测试套件，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.junit.platform.runner。JUnitPlatform</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.suite.api。SelectPackages</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.suite.api。SuiteDisplayName</span> ; <span class="keyword">import</span> <span class="include">org.junit.runner。RunWith</span> ; <span class="annotation">@RunWith</span> （JUnitPlatform.class） <span class="annotation">@SuiteDisplayName</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">JUnit Platform Suite Demo</span> <span class="delimiter">”</span></span> ） <span class="annotation">@SelectPackages</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">example</span> <span class="delimiter">”</span></span> ） <span class="directive">public</span> <span class="type">class</span> <span class="class">JUnitPlatformSuiteDemo</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>JUnitPlatformSuiteDemo</code>将发现并运行<code>example</code>包及其子包中的所有测试。默认情况下，它只包含名称以<code>Test</code>开头或以<code>Test</code>或<code>Tests</code>结尾的<code>Tests</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">其他配置选项</div>除了<code>@SelectPackages</code>之外，还有更多用于发现和过滤测试的配置选项。有关详细信息，请咨询<a href="../api/org/junit/platform/suite/api/package-summary.html">Javadoc</a> 。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">使用<code>@RunWith(JUnitPlatform.class)</code>注释的测试类和套件<strong>不能</strong>直接在JUnit平台上执行（或者作为某些IDE中记录的“JUnit 5”测试）。此类类和套件只能使用JUnit 4基础结构执行。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-tests-config-params"><a class="anchor" href="#running-tests-config-params"></a> 4.5。配置参数</h3>
<div class="paragraph">
<p>除了指示要包括测试类和测试引擎的平台，要扫描哪些包等之外，有时还需要提供特定于特定测试引擎或注册扩展的附加自定义配置参数。例如，JUnit Jupiter <code>TestEngine</code>支持以下用例的<em>配置参数</em> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#writing-tests-test-instance-lifecycle-changing-default">更改默认测试实例生命周期</a></p>
</li>
<li>
<p><a href="#extensions-registration-automatic-enabling">启用自动扩展检测</a></p>
</li>
<li>
<p><a href="#extensions-conditions-deactivation">停用条件</a></p>
</li>
<li>
<p><a href="#writing-tests-display-name-generator-default">设置默认显示名称生成器</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>配置参数</em>是基于文本的键值对，可以通过以下机制之一提供给在JUnit平台上运行的测试引擎。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>LauncherDiscoveryRequestBuilder</code>的<code>configurationParameter()</code>和<code>configurationParameters()</code>方法，用于构建提供给<a href="#launcher-api"><code>Launcher</code> API</a>的请求。通过JUnit Platform提供的工具之一运行测试时，您可以指定配置参数，如下所示：</p>
<div class="ulist">
<ul>
<li>
<p><a href="#running-tests-console-launcher">Console Launcher</a> ：使用<code>--config</code>命令行选项。</p>
</li>
<li>
<p><a href="#running-tests-build-gradle-config-params">Gradle</a> ：使用<code>systemProperty</code>或<code>systemProperties</code> DSL。</p>
</li>
<li>
<p><a href="#running-tests-build-maven-config-params">Maven Surefire提供程序</a> ：使用<code>configurationParameters</code>属性。</p>
</li>
</ul>
</div>
</li>
<li>
<p>JVM系统属性。</p>
</li>
<li>
<p>JUnit Platform配置文件：类路径根目录中名为<code>junit-platform.properties</code>的文件，该文件遵循Java <code>Properties</code>文件的语法规则。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">按照上面定义的确切顺序查找配置参数。因此，直接提供给<code>Launcher</code>配置参数优先于通过系统属性和配置文件提供的参数。同样，通过系统属性提供的配置参数优先于通过配置文件提供的参数。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="running-tests-tag-expressions"><a class="anchor" href="#running-tests-tag-expressions"></a> 4.6。标记表达式</h3>
<div class="paragraph">
<p>标签表达式是运算符的布尔表达式<code>!</code> ， <code>&amp;</code>和<code>|</code> 。此外， <code>(</code>和<code>)</code>可用于调整运算符优先级。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表2。运算符（按优先级降序排列）</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作者</th>
<th class="tableblock halign-left valign-top">含义</th>
<th class="tableblock halign-left valign-top">关联性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>！</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>＆</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">剩下</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>|</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要么</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">剩下</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果要跨多个维度标记测试，标记表达式可帮助您选择要执行的测试。当通过测试类型（例如， <em>微观</em> ， <em>集成</em> ， <em>端到端</em> ）和特征（例如， <strong>产品</strong> ， <strong>目录</strong> ， <strong>运输</strong> ）进行标记时，以下标记表达式可能是有用的。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:40%">
<col style="width:60%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">标签表达</th>
<th class="tableblock halign-left valign-top">选择</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">产品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有<strong>产品</strong>测试</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目录|运输</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>目录的</strong>所有测试以及所有<strong>运输</strong>测试</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">目录和运输</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有测试<strong>目录</strong>和<strong>运输</strong>之间的交集</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">产品＆！端至端</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有<strong>产品</strong>测试，但不是<em>端到端</em>测试</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（微观|整合）＆（产品|运输）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有<strong>产品</strong>或<strong>运输的</strong> <em>微观</em>或<em>集成</em>测试</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="running-tests-capturing-output"><a class="anchor" href="#running-tests-capturing-output"></a> 4.7。捕获标准输出/错误</h3>
<div class="paragraph">
<p>从版本1.3开始，JUnit平台提供了选择性支持，用于捕获打印到<code>System.out</code>和<code>System.err</code>输出。要启用它，只需将<code>junit.platform.output.capture.stdout</code>和/或<code>junit.platform.output.capture.stderr</code> <a href="#running-tests-config-params">配置参数设置</a>为<code>true</code> 。此外，您可以使用<code>junit.platform.output.capture.maxBuffer</code>配置每个执行的测试或容器使用的最大缓冲字节数。</p>
</div>
<div class="paragraph">
<p>如果启用，JUnit Platform会在报告测试或容器完成之前立即捕获相应的输出并使用<code>stdout</code>或<code>stderr</code>键将其作为报告条目发布到所有已注册的<code><a href="../api/org/junit/platform/launcher/TestExecutionListener.html">TestExecutionListener</a></code>实例。</p>
</div>
<div class="paragraph">
<p>请注意，捕获的输出将仅包含用于执行容器或测试的线程发出的输出。其他线程的任何输出都将被省略，因为特别是<a href="#writing-tests-parallel-execution">在并行执行测试时，</a>不可能将其归因于特定的测试或容器。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">捕获输出目前是一项<em>实验性</em>功能。您被邀请尝试并向JUnit团队提供反馈，以便他们可以改进并最终<a href="#api-evolution">推广</a>此功能。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extensions"><a class="anchor" href="#extensions"></a> 5。扩展模型</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="extensions-overview"><a class="anchor" href="#extensions-overview"></a> 5.1。概观</h3>
<div class="paragraph">
<p>与JUnit 4中竞争的<code>Runner</code> ， <code>TestRule</code>和<code>MethodRule</code>扩展点相比，JUnit Jupiter扩展模型由一个连贯的概念组成： <code>Extension</code> API。但请注意， <code>Extension</code>本身只是一个标记接口。</p>
</div>
</div>
<div class="sect2">
<h3 id="extensions-registration"><a class="anchor" href="#extensions-registration"></a> 5.2。注册扩展程序</h3>
<div class="paragraph">
<p>扩展可以通过<a href="#extensions-registration-declarative"><code>@ExtendWith</code></a> <em>编程方式</em>通过<a href="#extensions-registration-programmatic"><code>@RegisterExtension</code></a>以<em>声明</em>方式注册，也<em>可以</em>通过Java的<a href="#extensions-registration-automatic"><code>ServiceLoader</code></a>机制<em>自动</em>注册。</p>
</div>
<div class="sect3">
<h4 id="extensions-registration-declarative"><a class="anchor" href="#extensions-registration-declarative"></a> 5.2.1。声明性扩展注册</h4>
<div class="paragraph">
<p>开发人员可以通过使用<code>@ExtendWith(…​)</code>注释测试接口，测试类，测试方法或自定义<em><a href="#writing-tests-meta-annotations">组合注释</a></em> ，并为扩展注册提供类引用，以<em>声明</em>方式注册一个或多个扩展。</p>
</div>
<div class="paragraph">
<p>例如，要为特定测试方法注册自定义<code>RandomParametersExtension</code> ，您可以按如下方式注释测试方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtendWith</span> （RandomParametersExtension.class） <span class="annotation">@Test</span> <span class="type">void</span> test（ <span class="annotation">@Random</span> <span class="type">int</span> i）{ <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要为特定类及其子类中的所有测试注册自定义<code>RandomParametersExtension</code> ，您可以按如下方式注释测试类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtendWith</span> （RandomParametersExtension.class） <span class="type">类</span> <span class="class">MyTests</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以像这样一起注册多个扩展：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtendWith</span> （{DatabaseExtension.class，WebServerExtension.class}） <span class="type">类</span> <span class="class">MyFirstTests</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为替代方案，可以单独注册多个扩展，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtendWith</span> （DatabaseExtension.class） <span class="annotation">@ExtendWith</span> （WebServerExtension.class） <span class="type">类</span> <span class="class">MySecondTests</span> { <span class="comment">// ...</span>}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">扩展注册订单</div>
<div class="paragraph">
<p>通过<code>@ExtendWith</code>以声明方式注册的扩展将按照它们在源代码中声明的顺序执行。例如， <code>MyFirstTests</code>和<code>MySecondTests</code>的测试执行将由<code>DatabaseExtension</code>和<code>WebServerExtension</code> <strong>以完全相同的顺序</strong>进行扩展。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="extensions-registration-programmatic"><a class="anchor" href="#extensions-registration-programmatic"></a> 5.2.2。程序化扩展注册</h4>
<div class="paragraph">
<p>开发人员可以通过使用<code><a href="../api/org/junit/jupiter/api/extension/RegisterExtension.html">@RegisterExtension</a></code>注释测试类中的字段来以<em>编程</em>方式注册扩展。</p>
</div>
<div class="paragraph">
<p>当通过<a href="#extensions-registration-declarative"><code>@ExtendWith</code></a> <em>声明</em>方式注册扩展时，通常只能通过注释进行配置。相反，当通过<code>@RegisterExtension</code>注册扩展时，可以通过<em>编程</em>方式配置它 - 例如，为了将参数传递给扩展的构造函数，静态工厂方法或构建器API。</p>
</div>
<div id="extensions-registration-programmatic-order" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">扩展注册订单</div>
<div class="paragraph">
<p>默认情况下，通过<code>@RegisterExtension</code>以编程方式注册的扩展将使用确定性但有意<code>@RegisterExtension</code>的算法进行排序。这确保了测试套件的后续运行以相同的顺序执行扩展，从而允许可重复的构建。但是，有时需要以明确的顺序注册扩展。为此，使用<code><a href="../api/org/junit/jupiter/api/Order.html">@Order</a></code>注释每个<code>@RegisterExtension</code>字段。任何未使用<code>@Order</code>注释的<code>@RegisterExtension</code>字段都将显示在已排序列表的末尾。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@RegisterExtension</code>字段不能为<code>private</code>或<code>null</code> （在评估时），但可以是<code>static</code>或非静态。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="extensions-registration-programmatic-static-fields"><a class="anchor" href="#extensions-registration-programmatic-static-fields"></a>静态字段</h5>
<div class="paragraph">
<p>如果<code>@RegisterExtension</code>字段是<code>static</code> ，则扩展名将在通过<code>@ExtendWith</code>在类级别注册的扩展名之后注册。这些<em>静态扩展</em>不限于它们可以实现的扩展API。因此，通过静态字段注册的扩展可以实现类级和实例级扩展API，例如<code>BeforeAllCallback</code> ， <code>AfterAllCallback</code>和<code>TestInstancePostProcessor</code> ，以及方法级扩展API，例如<code>BeforeEachCallback</code>等。</p>
</div>
<div class="paragraph">
<p>在以下示例中，使用<code>WebServerExtension</code>支持的构建器模式以编程方式初始化测试类中的<code>server</code>字段。配置的<code>WebServerExtension</code>将自动注册为类级别的扩展 - 例如，为了在类中的所有测试之前启动服务器，然后在类中的所有测试完成后停止服务器。此外，使用<code>@BeforeAll</code>或<code>@AfterAll</code>以及<code>@BeforeEach</code> ， <code>@AfterEach</code>和<code>@Test</code>方法注释的静态生命周期方法可以根据需要通过<code>server</code>字段访问扩展的实例。</p>
</div>
<div class="listingblock">
<div class="title">通过静态字段注册的扩展</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">WebServerDemo</span> { <span class="annotation">@RegisterExtension</span> <span class="directive">static</span> WebServerExtension server = WebServerExtension.builder（）。enableSecurity（ <span class="predefined-constant">false</span> ）.build（）; <span class="annotation">@Test</span> <span class="type">void</span> getProductList（）{WebClient webClient = <span class="keyword">new</span> WebClient（）; <span class="predefined-type">String</span> serverUrl = server.getServerUrl（）; <span class="comment">//使用WebClient使用serverUrl连接到Web服务器并验证响应</span> assertEquals（ <span class="integer">200</span> ，webClient.get（serverUrl + <span class="string"><span class="delimiter">“</span> <span class="content">/ products</span> <span class="delimiter">”</span></span> ）。getResponseStatus（））; }}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="extensions-registration-programmatic-static-fields-kotlin"><a class="anchor" href="#extensions-registration-programmatic-static-fields-kotlin"></a>科特林的静电场</h5>
<div class="paragraph">
<p>Kotlin编程语言没有<code>static</code>字段的概念。但是，可以指示编译器使用注释生成静态字段。因为，如前所述， <code>@RegisterExtension</code>字段不能是<code>private</code>也不能为<code>null</code> ， <strong>因此无法</strong>在Kotlin中使用<code>@JvmStatic</code>注释，因为它会生成<code>private</code>字段。相反，必须使用<code>@JvmField</code>注释。</p>
</div>
<div class="paragraph">
<p>以下示例是上一节中已移植到Kotlin的<code>WebServerDemo</code>一个版本。</p>
</div>
<div class="listingblock">
<div class="title">通过Kotlin中的静态字段注册扩展</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">KotlinWebServerDemo</span> {companion object { <span class="annotation">@JvmField</span> <span class="annotation">@RegisterExtension</span> val server = WebServerExtension.builder（）。enableSecurity（ <span class="predefined-constant">false</span> ）.build（）} @ <span class="annotation">Test</span> fun getProductList（）{ <span class="comment">//使用WebClient使用serverUrl连接到Web服务器并验证响应</span> val webClient = WebClient（）val serverUrl = server.serverUrl assertEquals（ <span class="integer">200</span> ，webClient.get（ <span class="string"><span class="delimiter">“</span> <span class="inline"><span class="inline-delimiter">$</span> serverUrl</span> <span class="content">/ products</span> <span class="delimiter">”</span></span> ）。responseStatus）}}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="extensions-registration-programmatic-instance-fields"><a class="anchor" href="#extensions-registration-programmatic-instance-fields"></a>实例字段</h5>
<div class="paragraph">
<p>如果<code>@RegisterExtension</code>字段是非静态的（即实例字段），则在实例化测试类之后并且在每个已注册的<code>TestInstancePostProcessor</code>有机会对测试实例进行后处理之后，将注册扩展（可能注入要用于带注释字段的扩展的实例）。因此，如果此类<em>实例扩展</em>实现类级别或实例级扩展API（如<code>BeforeAllCallback</code> ， <code>AfterAllCallback</code>或<code>TestInstancePostProcessor</code> ，则不会<code>TestInstancePostProcessor</code>这些API。默认情况下，实例扩展名将在通过<code>@ExtendWith</code>在方法级别注册的扩展名<em>之后</em>注册;但是，如果测试类配置了<code>@TestInstance(Lifecycle.PER_CLASS)</code>语义，实例扩展将在通过<code>@ExtendWith</code>在方法级别注册的扩展<em>之前</em>注册。</p>
</div>
<div class="paragraph">
<p>在以下示例中，通过调用自定义<code>lookUpDocsDir()</code>方法并将结果提供给<code>DocumentationExtension</code>的静态<code>forPath()</code>工厂方法，以编程方式初始化测试类中的<code>docs</code>字段。配置的<code>DocumentationExtension</code>将自动注册为方法级别的扩展。此外， <code>@BeforeEach</code> ， <code>@AfterEach</code> <code>@BeforeEach</code> ， <code>@AfterEach</code>和<code>@Test</code>方法可以通过<code>docs</code>字段访问扩展实例。</p>
</div>
<div class="listingblock">
<div class="title">通过实例字段注册的扩展</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">DocumentationDemo</span> { <span class="directive">static</span> Path lookUpDocsDir（）{ <span class="comment">//返回docs dir的路径</span> } <span class="annotation">@RegisterExtension</span> DocumentationExtension docs = DocumentationExtension.forPath（lookUpDocsDir（））; <span class="annotation">@Test</span> <span class="type">void</span> generateDocumentation（）{ <span class="comment">//使用this.docs ...</span>}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="extensions-registration-automatic"><a class="anchor" href="#extensions-registration-automatic"></a> 5.2.3。自动扩展注册</h4>
<div class="paragraph">
<p>除了使用注释的<a href="#extensions-registration-declarative">声明性扩展注册</a>和<a href="#extensions-registration-programmatic">程序扩展注册</a>支持之外，JUnit Jupiter还通过Java的<code>java.util.支持<em>全局扩展注册</em> <code>java.util.ServiceLoader</code>机制，允许自动检测第三方扩展，并根据类路径中的可用内容自动注册。</p>
</div>
<div class="paragraph">
<p>具体来说，可以通过在名为<code>org.junit.jupiter.api.extension.的文件中提供其完全限定的类名来注册自定义扩展<code>org.junit.jupiter.api.extension.在其封闭的JAR文件中的<code>/META-INF/services</code>文件夹中的Extension</code> 。</p>
</div>
<div class="sect4">
<h5 id="extensions-registration-automatic-enabling"><a class="anchor" href="#extensions-registration-automatic-enabling"></a>启用自动扩展检测</h5>
<div class="paragraph">
<p>自动检测是一项高级功能，因此默认情况下不启用。要启用它，只需将<code>junit.jupiter.extensions.autodetection.enabled</code> <em>配置参数</em>设置为<code>true</code> 。这可以作为JVM系统属性提供，作为传递给<code>Launcher</code>的<code>LauncherDiscoveryRequest</code>中的<em>配置参数</em>提供，或者通过JUnit Platform配置文件提供（有关详细信息，请参阅<a href="#running-tests-config-params">配置参数</a> ）。</p>
</div>
<div class="paragraph">
<p>例如，要启用扩展的自动检测，可以使用以下系统属性启动JVM。</p>
</div>
<div class="paragraph">
<p><code>-Djunit.jupiter.extensions.autodetection.enabled =真</code></p>
</div>
<div class="paragraph">
<p>启用自动检测后，通过<code>ServiceLoader</code>机制发现的扩展将在JUnit Jupiter的全局扩展（例如，支持<code>TestInfo</code> ， <code>TestReporter</code>等）之后添加到扩展注册表中。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="extensions-registration-inheritance"><a class="anchor" href="#extensions-registration-inheritance"></a> 5.2.4。扩展继承</h4>
<div class="paragraph">
<p>已注册的扩展在测试类层次结构中以自上而下的语义继承。类似地，在类级别注册的扩展在方法级别继承。此外，特定的扩展实现只能为给定的扩展上下文及其父上下文注册一次。因此，任何注册重复扩展实现的尝试都将被忽略。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extensions-conditions"><a class="anchor" href="#extensions-conditions"></a> 5.3。条件测试执行</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/ExecutionCondition.html">ExecutionCondition</a></code>为程序化的<em>条件测试执行</em>定义了<code>Extension</code> API。</p>
</div>
<div class="paragraph">
<p>对每个容器（例如，测试类） <em>评估</em> <code>ExecutionCondition</code> ，以确定是否应该基于提供的<code>ExtensionContext</code>执行它包含的所有测试。类似地，为每个测试<em>评估</em> <code>ExecutionCondition</code> ，以确定是否应该基于提供的<code>ExtensionContext</code>执行给定的测试方法。</p>
</div>
<div class="paragraph">
<p>注册多个<code>ExecutionCondition</code>扩展时，只要其中一个条件返回<em>禁用</em> ，就会禁用容器或测试。因此，无法保证评估条件，因为另一个扩展可能已导致禁用容器或测试。换句话说，评估的工作方式类似于短路布尔OR运算符。</p>
</div>
<div class="paragraph">
<p>有关具体示例，请参阅<code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/DisabledCondition.java">DisabledCondition</a></code>和<code><a href="../api/org/junit/jupiter/api/Disabled.html">@Disabled</a></code>的源代码。</p>
</div>
<div class="sect3">
<h4 id="extensions-conditions-deactivation"><a class="anchor" href="#extensions-conditions-deactivation"></a> 5.3.1。停用条件</h4>
<div class="paragraph">
<p>有时，在<em>没有</em>特定条件激活的<em>情况</em>下运行测试套件会很有用。例如，您可能希望运行测试，即使它们使用<code>@Disabled</code>进行注释，以查看它们是否仍然<em>损坏</em> 。为此，只需为<code>junit.jupiter.conditions.deactivate</code> <em>配置参数</em>提供一个模式，以指定当前测试运行应停用（即，未评估）的条件。该模式可以作为JVM系统属性提供，作为传递给<code>Launcher</code>的<code>LauncherDiscoveryRequest</code>中的<em>配置参数</em>提供，或者通过JUnit Platform配置文件提供（有关详细信息，请参阅<a href="#running-tests-config-params">配置参数</a> ）。</p>
</div>
<div class="paragraph">
<p>例如，要停用JUnit的<code>@Disabled</code>条件，可以使用以下系统属性启动JVM。</p>
</div>
<div class="paragraph">
<p><code>-Djunit.jupiter.conditions.deactivate = org.junit。* DisabledCondition</code></p>
</div>
<div class="sect4">
<h5 id="extensions-conditions-deactivation-patterns"><a class="anchor" href="#extensions-conditions-deactivation-patterns"></a>模式匹配语法</h5>
<div class="paragraph">
<p>如果<code>junit.jupiter.conditions.deactivate</code>模式仅包含星号（ <code>*</code> ），则所有条件都将被停用。否则，该模式将用于匹配每个已注册条件的完全限定类名（ <em>FQCN</em> ）。模式中的任何点（ <code>.</code> ）将与FQCN中的点（ <code>.</code> ）或美元符号（ <code>$</code> ）匹配。任何星号（ <code>*</code> ）都将与FQCN中的一个或多个字符匹配。模式中的所有其他字符将与FQCN一对一匹配。</p>
</div>
<div class="paragraph">
<p>例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>*</code> ：停用所有条件。</p>
</li>
<li>
<p><code>org.junit.*</code> ：取消激活<code>org.junit</code>基础包及其任何子包下的每个条件。</p>
</li>
<li>
<p><code>*。MyCondition</code> ：停用其简单类名正好为<code>MyCondition</code>所有条件。</p>
</li>
<li>
<p><code>*System*</code> ：取消激活简单类名称包含<code>System</code>每个条件。</p>
</li>
<li>
<p><code>org.example。MyCondition</code> ：停用其FQCN正好是<code>org.example.的条件<code>org.example.MyCondition</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extensions-test-instance-factories"><a class="anchor" href="#extensions-test-instance-factories"></a> 5.4。测试实例工厂</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/TestInstanceFactory.html">TestInstanceFactory</a></code>为希望<em>创建</em>测试类实例的<code>Extensions</code>定义API。</p>
</div>
<div class="paragraph">
<p>常见用例包括从依赖注入框架获取测试实例或调用静态工厂方法来创建测试类实例。</p>
</div>
<div class="paragraph">
<p>如果没有注册<code>TestInstanceFactory</code> ，框架将只调用测试类的<em>唯一</em>构造函数来实例化它，可能通过注册的<code>ParameterResolver</code>扩展来解析构造函数<code>ParameterResolver</code> 。</p>
</div>
<div class="paragraph">
<p>实现<code>TestInstanceFactory</code>扩展可以在测试接口，顶级测试类或<code>@Nested</code>测试类上注册。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为任何单个类注册实现<code>TestInstanceFactory</code>多个扩展将导致为该类，任何子类和任何嵌套类中的所有测试抛出异常。请注意，在超类或<em>封闭</em>类中注册的任何<code>TestInstanceFactory</code> （即，在<code>@Nested</code>测试类的情况下）都是<em>继承的</em> 。用户有责任确保只为任何特定测试类注册一个<code>TestInstanceFactory</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="extensions-test-instance-post-processing"><a class="anchor" href="#extensions-test-instance-post-processing"></a> 5.5。测试实例后处理</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/TestInstancePostProcessor.html">TestInstancePostProcessor</a></code>为希望<em>发布流程</em>测试实例的<code>Extensions</code>定义API。</p>
</div>
<div class="paragraph">
<p>常见用例包括将依赖项注入测试实例，在测试实例上调用自定义初始化方法等。</p>
</div>
<div class="paragraph">
<p>有关具体示例，请参阅<code><a href="https://github.com/mockito/mockito/blob/release/2.x/subprojects/junit-jupiter/src/main/java/org/mockito/junit/jupiter/MockitoExtension.java">MockitoExtension</a></code>和<code><a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java">SpringExtension</a></code>的源代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="extensions-parameter-resolution"><a class="anchor" href="#extensions-parameter-resolution"></a> 5.6。参数分辨率</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/ParameterResolver.html">ParameterResolver</a></code>定义<code>Extension</code> API，用于在运行时动态解析参数。</p>
</div>
<div class="paragraph">
<p>如果<em>测试类</em>构造函数， <em>测试方法</em>或<em>生命周期方法</em> （请参阅<a href="#writing-tests-classes-and-methods">测试类和方法</a> ）接受参数，则必须在运行时通过<code>ParameterResolver</code> <em>解析</em>该<code>ParameterResolver</code> 。<code>ParameterResolver</code>既可以内置（参见<code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestInfoParameterResolver.java">TestInfoParameterResolver</a></code> ），也可以<a href="#extensions-registration">由用户注册</a> 。一般而言，可以通过<em>名称</em> ， <em>类型</em> ， <em>注释</em>或其任何组合来解析参数。有关具体示例，请参阅<code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/injection/sample/CustomTypeParameterResolver.java">CustomTypeParameterResolver</a></code>和<code><a href="https://github.com/junit-team/junit5/tree/r5.5.1/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/injection/sample/CustomAnnotationParameterResolver.java">CustomAnnotationParameterResolver</a></code>的源代码。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于<code>javac</code>在JDK 9之前的JDK版本上生成的字节代码中存在错误，因此直接通过核心<code>java.lang.reflect.查找参数注释<code>java.lang.reflect.对于<em>内部类</em>构造函数（例如， <code>@Nested</code>测试类中的构造函数）， Parameter</code> API将始终失败。</p>
</div>
<div class="paragraph">
<p>因此，提供给<code>ParameterResolver</code>实现的<code><a href="../api/org/junit/jupiter/api/extension/ParameterContext.html">ParameterContext</a></code> API包括以下便于正确查找参数注释的方法。强烈建议扩展作者使用这些方法而不是<code>java.lang.reflect.提供的方法<code>java.lang.reflect.Parameter</code>以避免JDK中的这个错误。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean isAnnotated（Class &lt;？extends Annotation&gt; annotationType）</code></p>
</li>
<li>
<p><code>可选&lt;A&gt; findAnnotation（Class &lt;A&gt; annotationType）</code></p>
</li>
<li>
<p><code>List &lt;A&gt; findRepeatableAnnotations（Class &lt;A&gt; annotationType）</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="extensions-test-result-processing"><a class="anchor" href="#extensions-test-result-processing"></a> 5.7。测试结果处理</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/TestWatcher.html">TestWatcher</a></code>定义了希望处理<em>测试方法</em>执行结果的扩展的API。具体来说，将使用以下事件的上下文信息调用<code>TestWatcher</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>testDisabled</code> ：在跳过禁用的<em>测试方法</em>后调用</p>
</li>
<li>
<p><code>testSuccessful</code> ：在<em>测试方法</em>成功完成后调用</p>
</li>
<li>
<p><code>testAborted</code> ：在<em>测试方法</em>中止后调用</p>
</li>
<li>
<p><code>testFailed</code> ：在<em>测试方法</em>失败后调用</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与<a href="#writing-tests-classes-and-methods">测试类和方法中</a>提供的“测试方法”的定义相反，在此上下文中， <em>测试方法</em>引用任何<code>@Test</code>方法或<code>@TestTemplate</code>方法（例如， <code>@RepeatedTest</code>或<code>@ParameterizedTest</code> ）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以在方法级别或类级别注册实现此接口的扩展。在后一种情况下，它们将被调用用于任何包含的<em>测试方法，</em>包括<code>@Nested</code>类中的<em>测试方法</em> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ExtensionContext.任何实例<code>ExtensionContext.商店。存储在提供的<code><a href="../api/org/junit/jupiter/api/extension/ExtensionContext.html">ExtensionContext</a></code>的<code>Store</code>中的CloseableResource</code>将在调用此API中的方法<em>之前</em>关闭（请参阅<a href="#extensions-keeping-state">在扩展中保持状态</a> ）。您可以使用父上下文的<code>Store</code>来处理此类资源。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="extensions-lifecycle-callbacks"><a class="anchor" href="#extensions-lifecycle-callbacks"></a> 5.8。测试生命周期回调</h3>
<div class="paragraph">
<p>以下接口定义用于在测试执行生命周期的各个点扩展测试的API。有关更多详细信息，请参阅以下部分以获取示例以及<code><a href="../api/org/junit/jupiter/api/extension/package-summary.html">org.junit.jupiter.api.extension</a></code>包中每个接口的Javadoc。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../api/org/junit/jupiter/api/extension/BeforeAllCallback.html">BeforeAllCallback</a></code></p>
<div class="ulist">
<ul>
<li>
<p><code><a href="../api/org/junit/jupiter/api/extension/BeforeEachCallback.html">BeforeEachCallback</a></code></p>
<div class="ulist">
<ul>
<li>
<p><code><a href="../api/org/junit/jupiter/api/extension/BeforeTestExecutionCallback.html">BeforeTestExecutionCallback</a></code></p>
</li>
<li>
<p><code><a href="../api/org/junit/jupiter/api/extension/AfterTestExecutionCallback.html">AfterTestExecutionCallback</a></code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code><a href="../api/org/junit/jupiter/api/extension/AfterEachCallback.html">AfterEachCallback</a></code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code><a href="../api/org/junit/jupiter/api/extension/AfterAllCallback.html">AfterAllCallback</a></code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">实现多个扩展API</div>扩展开发人员可以选择在单个扩展中实现任意数量的这些接口。有关具体示例，请参阅<code><a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/main/java/org/springframework/test/context/junit/jupiter/SpringExtension.java">SpringExtension</a></code>的源代码。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="extensions-lifecycle-callbacks-before-after-execution"><a class="anchor" href="#extensions-lifecycle-callbacks-before-after-execution"></a> 5.8.1。测试执行回调之前和之后</h4>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/BeforeTestExecutionCallback.html">BeforeTestExecutionCallback</a></code>和<code><a href="../api/org/junit/jupiter/api/extension/AfterTestExecutionCallback.html">AfterTestExecutionCallback</a></code>为希望添加将在执行测试方法<em>之前</em>和<em>之后立即</em>执行的行为的<code>Extensions</code>定义API。因此，这些回调非常适合于计时，跟踪和类似的用例。如果需要实现<em>围绕</em> <code>@BeforeEach</code>和<code>@AfterEach</code>方法调用的回调， <code>AfterEachCallback</code>改为实现<code>BeforeEachCallback</code>和<code>AfterEachCallback</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用这些回调来计算和记录测试方法的执行时间。<code>TimingExtension</code>实现<code>BeforeTestExecutionCallback</code>和<code>AfterTestExecutionCallback</code> ，以便计时和记录测试执行。</p>
</div>
<div id="extensions-lifecycle-callbacks-timing-extension" class="listingblock">
<div class="title">一个扩展，计时和记录测试方法的执行</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.lang.reflect。方法</span> ; <span class="keyword">import</span> <span class="include">java.util.logging。记录器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。AfterTestExecutionCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。BeforeTestExecutionCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。ExtensionContext</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。ExtensionContext。命名空间</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。ExtensionContext。商店</span> ; <span class="directive">public</span> <span class="type">class</span> <span class="class">TimingExtension</span> <span class="directive">实现</span> BeforeTestExecutionCallback，AfterTestExecutionCallback { <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Logger</span> logger = <span class="predefined-type">Logger</span> .getLogger（TimingExtension.class.getName（））; <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> START_TIME = <span class="string"><span class="delimiter">“</span> <span class="content">start time</span> <span class="delimiter">”</span></span> ; <span class="annotation">@Override</span> <span class="directive">public</span> <span class="type">void</span> beforeTestExecution（ExtensionContext context） <span class="directive">throws</span> <span class="exception">Exception</span> {getStore（context）.put（START_TIME， <span class="predefined-type">System</span> .currentTimeMillis（））; } <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> afterTestExecution（ExtensionContext上下文） <span class="directive">抛出</span> <span class="exception">异常</span> { <span class="predefined-type">方法</span> TestMethod的= context.getRequiredTestMethod（）; <span class="type">long</span> startTime = getStore（context）.remove（START_TIME， <span class="type">long</span> .class）; <span class="type">long</span> duration = <span class="predefined-type">System</span> .currentTimeMillis（） -  startTime; logger.info（（） - &gt; <span class="predefined-type">String</span> .format（ <span class="string"><span class="delimiter">“</span> <span class="content">Method [％s] take％s ms。</span> <span class="delimiter">”</span></span> ，testMethod.getName（），duration））; <span class="directive">private</span> store getStore（ExtensionContext context）{ <span class="keyword">return</span> context.getStore（Namespace.create（getClass（），context.getRequiredTestMethod（）））; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于<code>TimingExtensionTests</code>类通过<code>@ExtendWith</code>注册<code>TimingExtension</code> ，因此它的测试将在执行时应用此时序。</p>
</div>
<div class="listingblock">
<div class="title">使用示例TimingExtension的测试类</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtendWith</span> （TimingExtension.class） <span class="type">类</span> <span class="class">TimingExtensionTests</span> { <span class="annotation">@Test</span> <span class="type">void</span> sleep20ms（） <span class="directive">抛出</span> <span class="exception">异常</span> { <span class="predefined-type">Thread</span> .sleep（ <span class="integer">20</span> ）; } <span class="annotation">@Test</span> <span class="type">void</span> sleep50ms（） <span class="directive">抛出</span> <span class="exception">异常</span> { <span class="predefined-type">Thread</span> .sleep（ <span class="integer">50</span> ）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是运行<code>TimingExtensionTests</code>时生成的日志记录示例。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>信息：方法[sleep20ms]耗时24毫秒。信息：方法[sleep50ms]耗时53毫秒。</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extensions-exception-handling"><a class="anchor" href="#extensions-exception-handling"></a> 5.9。异常处理</h3>
<div class="paragraph">
<p>在进一步传播之前，可以截获并相应地处理在测试执行期间抛出的异常，以便可以在专用<code>Extensions</code>定义诸如错误记录或资源释放之类的某些动作。JUnit Jupiter为<code>Extensions</code>提供API，希望通过<code><a href="../api/org/junit/jupiter/api/extension/TestExecutionExceptionHandler.html">TestExecutionExceptionHandler</a></code>处理在<code>@Test</code>方法期间抛出的异常，以及通过<code><a href="../api/org/junit/jupiter/api/extension/LifecycleMethodExecutionExceptionHandler.html">LifecycleMethodExecutionExceptionHandler</a></code>在测试生命周期方法（ <code>@BeforeAll</code> ， <code>@BeforeEach</code> ， <code>@AfterEach</code>和<code>@AfterAll</code> ）中抛出的异常。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个扩展，它将吞没<code>IOException</code>所有实例，但重新抛出任何其他类型的异常。</p>
</div>
<div class="listingblock">
<div class="title">一个异常处理扩展，用于在测试执行中过滤IOExceptions</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">IgnoreIOExceptionExtension</span> <span class="directive">实现</span> TestExecutionExceptionHandler <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> handleTestExecutionException（ExtensionContext上下文<span class="predefined-type">，Throwable的</span>抛出） <span class="directive">抛出</span> <span class="predefined-type">的Throwable</span> { <span class="keyword">如果</span> （抛出<span class="keyword">的instanceof</span> <span class="exception">IOException异常</span> ）{ <span class="keyword">返回</span> ; <span class="keyword">扔掉扔掉</span> ; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个示例显示了如何在安装和清理期间抛出意外异常时准确记录被测应用程序的状态。请注意，与依赖于生命周期回调（可能会或可能不会根据测试状态执行）不同，此解决方案可确保在失败<code>@BeforeAll</code> ， <code>@BeforeEach</code> ， <code>@AfterEach</code>或<code>@AfterAll</code>后立即执行。</p>
</div>
<div class="listingblock">
<div class="title">一个异常处理扩展，记录错误时的应用程序状态</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">类</span> <span class="class">RecordStateOnErrorExtension</span> <span class="directive">实现</span> LifecycleMethodExecutionExceptionHandler <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> handleBeforeAllMethodExecutionException（ExtensionContext上下文<span class="predefined-type">，Throwable的</span>前） <span class="directive">抛出</span> <span class="predefined-type">的Throwable</span> {memoryDumpForFurtherInvestigation（ <span class="string"><span class="delimiter">“</span> <span class="content">失败类设置期间记录</span> <span class="delimiter">”）;</span></span> <span class="keyword">抛出</span>前} <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> handleBeforeEachMethodExecutionException（ExtensionContext上下文<span class="predefined-type">，Throwable的</span>前） <span class="directive">抛出</span> <span class="predefined-type">的Throwable</span> {memoryDumpForFurtherInvestigation（ <span class="string"><span class="delimiter">“</span> <span class="content">失败的测试设置期间记录</span> <span class="delimiter">”）;</span></span> <span class="keyword">抛出</span>前} <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> handleAfterEachMethodExecutionException（ExtensionContext上下文<span class="predefined-type">，Throwable的</span>前） <span class="directive">抛出</span> <span class="predefined-type">的Throwable</span> {memoryDumpForFurtherInvestigation（ <span class="string"><span class="delimiter">“</span> <span class="content">失败测试清理期间记录</span> <span class="delimiter">”）;</span></span> <span class="keyword">抛出</span>前} <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> handleAfterAllMethodExecutionException（ExtensionContext上下文<span class="predefined-type">，Throwable的</span>前） <span class="directive">抛出</span> <span class="predefined-type">的Throwable</span> {memoryDumpForFurtherInvestigation（ <span class="string"><span class="delimiter">“</span> <span class="content">失败类清理期间记录</span> <span class="delimiter">”）;</span></span> <span class="keyword">抛出</span>前}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以按声明的顺序为同一生命周期方法调用多个执行异常处理程序。如果其中一个处理程序吞下处理的异常，则不会执行后续处理异常，并且不会将任何故障传播到JUnit引擎，就好像从未抛出异常一样。处理程序也可以选择重新抛出异常或抛出异常，可能包装原始异常。</p>
</div>
<div class="paragraph">
<p>实现<code><a href="../api/org/junit/jupiter/api/extension/LifecycleMethodExecutionExceptionHandler.html">LifecycleMethodExecutionExceptionHandler</a></code>扩展，希望处理在<code>@BeforeAll</code>或<code>@AfterAll</code>期间抛出的异常需要在类级别注册，而<code>BeforeEach</code>和<code>AfterEach</code>处理程序也可以为各个测试方法注册。</p>
</div>
<div class="listingblock">
<div class="title">注册多个异常处理扩展</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//为@Test，@ BeforeEach，@ AfterEach以及@BeforeAll和@AfterAll</span> <span class="annotation">@ExtendWith</span> （ThirdExecutedHandler.class） <span class="type">类</span> <span class="comment">注册处理程序</span> <span class="class">MultipleHandlersTestCase</span> { <span class="comment">//为@Test注册处理程序，@ BestEach，@ AfterEach仅</span> <span class="annotation">@ExtendWith</span> （SecondExecutedHandler。 class） <span class="annotation">@ExtendWith</span> （FirstExecutedHandler.class） <span class="annotation">@Test</span> <span class="type">void</span> testMethod（）{}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extensions-intercepting-invocations"><a class="anchor" href="#extensions-intercepting-invocations"></a> 5.10。拦截调用</h3>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/InvocationInterceptor.html">InvocationInterceptor</a></code>定义了希望拦截对测试代码的调用的<code>Extensions</code> API。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个在Swing的Event Dispatch Thread中执行所有测试方法的扩展。</p>
</div>
<div class="listingblock">
<div class="title">在用户定义的线程中执行测试的扩展</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">公共</span> <span class="type">类</span> <span class="class">SwingEdtInterceptor</span> <span class="directive">实现</span> InvocationInterceptor <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> interceptTestMethod（调用&lt; <span class="predefined-type">空隙</span> &gt;调用，ReflectiveInvocationContext &lt; <span class="predefined-type">方法</span> &gt; invocationContext，ExtensionContext extensionContext） <span class="directive">抛出</span> <span class="predefined-type">的Throwable</span> { <span class="predefined-type">的AtomicReference</span> <span class="predefined-type">&lt;Throwable的</span> &gt;抛出= <span class="keyword">新</span> <span class="predefined-type">的AtomicReference</span> &lt;&gt;（）; <span class="predefined-type">SwingUtilities</span> .invokeAndWait（（） - &gt; { <span class="keyword">try</span> {invocation.proceed（）;} <span class="keyword">catch</span> （ <span class="predefined-type">Throwable</span> t）{throwable.set（t）;}}）; <span class="predefined-type">Throwable</span> t = throwable.get（）; <span class="keyword">如果</span> （t！= <span class="predefined-constant">null</span> ）{ <span class="keyword">throw</span> t; }}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extensions-test-templates"><a class="anchor" href="#extensions-test-templates"></a> 5.11。为测试模板提供调用上下文</h3>
<div class="paragraph">
<p>只有在注册了至少一个<code><a href="../api/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html">TestTemplateInvocationContextProvider</a></code>时，才能执行<code><a href="../api/org/junit/jupiter/api/TestTemplate.html">@TestTemplate</a></code>方法。每个这样的提供者负责提供<code>Stream</code> of <code><a href="../api/org/junit/jupiter/api/extension/TestTemplateInvocationContext.html">TestTemplateInvocationContext</a></code>实例。每个上下文都可以指定自定义显示名称和附加扩展名列表，这些扩展名仅用于下次调用<code><a href="../api/org/junit/jupiter/api/TestTemplate.html">@TestTemplate</a></code>方法。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何编写测试模板以及如何注册和实现<code><a href="../api/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html">TestTemplateInvocationContextProvider</a></code> 。</p>
</div>
<div class="listingblock">
<div class="title">附带扩展名的测试模板</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">final</span> <span class="predefined-type">List</span> &lt; <span class="predefined-type">String</span> &gt; fruits = <span class="predefined-type">Arrays</span> .asList（ <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">banana</span> <span class="delimiter">”</span></span> ， <span class="string"><span class="delimiter">“</span> <span class="content">lemon</span> <span class="delimiter">”</span></span> ）; <span class="annotation">@TestTemplate</span> <span class="annotation">@ExtendWith</span> （MyTestTemplateInvocationContextProvider.class） <span class="type">void</span> testTemplate（ <span class="predefined-type">String</span> fruit）{assertTrue（fruits.contains（fruit））; } <span class="directive">公共</span> <span class="type">类</span> <span class="class">MyTestTemplateInvocationContextProvider</span> <span class="directive">实现</span> TestTemplateInvocationContextProvider <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">布尔</span> supportsTestTemplate（ExtensionContext上下文）{ <span class="keyword">返回</span> <span class="predefined-constant">true;</span> } <span class="annotation">@Override</span> <span class="directive">public</span> Stream &lt;TestTemplateInvocationContext&gt; provideTestTemplateInvocationContexts（ExtensionContext context）{ <span class="keyword">return</span> Stream.of（invocationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">apple</span> <span class="delimiter">”</span></span> ），invocationContext（ <span class="string"><span class="delimiter">“</span> <span class="content">banana</span> <span class="delimiter">”</span></span> ））; <span class="directive">private</span> TestTemplateInvocationContext invocationContext（ <span class="predefined-type">String</span> parameter）{ <span class="keyword">return</span> <span class="keyword">new</span> TestTemplateInvocationContext（）{ <span class="annotation">@ Override</span> <span class="directive">public</span> <span class="predefined-type">String</span> getDisplayName（ <span class="type">int</span> invocationIndex）{ <span class="keyword">return</span> parameter; } <span class="annotation">@Override</span> <span class="directive">public</span> <span class="predefined-type">List</span> &lt;Extension&gt; getAdditionalExtensions（）{ <span class="keyword">return</span> <span class="predefined-type">Collections</span> .singletonList（ <span class="keyword">new</span> ParameterResolver（）{ <span class="annotation">@</span> Override <span class="directive">public</span> <span class="type">boolean</span> supportsParameter（ParameterContext parameterContext，ExtensionContext extensionContext）{ <span class="keyword">return</span> parameterContext.getParameter（）。getType（）。equals（ <span class="predefined-type">String</span> 。 class）;} <span class="annotation">@Override</span> <span class="directive">public</span> <span class="predefined-type">Object</span> resolveParameter（ParameterContext parameterContext，ExtensionContext extensionContext）{ <span class="keyword">return</span> parameter;}}）; }}; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，将调用测试模板两次。调用的显示名称将是调用上下文指定的<code>apple</code>和<code>banana</code> 。每次调用都会注册一个自定义的<code><a href="../api/org/junit/jupiter/api/extension/ParameterResolver.html">ParameterResolver</a></code> ，用于解析方法参数。使用<code>ConsoleLauncher</code>时的输出如下。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>└─testTemplate（String）✔├─苹果✔└─香蕉✔</pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="../api/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html">TestTemplateInvocationContextProvider</a></code>扩展API主要用于实现不同类型的测试，这些测试依赖于类似测试的方法的重复调用，尽管在不同的上下文中 - 例如，使用不同的参数，通过不同地准备测试类实例，或多次而不修改上下文。请参阅使用此扩展点的<a href="#writing-tests-repeated-tests">重复测试</a>或<a href="#writing-tests-parameterized-tests">参数化测试</a>的实现来提供其功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="extensions-keeping-state"><a class="anchor" href="#extensions-keeping-state"></a> 5.12。保持国家的延伸</h3>
<div class="paragraph">
<p>通常，扩展仅实例化一次。所以这个问题变得相关：你如何保持状态从一个扩展的调用到下一个？<code>ExtensionContext</code> API完全为此提供了一个<code>Store</code> 。扩展可以将值放入商店以供以后检索。有关将<code>Store</code>与方法级作用域一起使用的示例，请参阅<code><a href="#extensions-lifecycle-callbacks-timing-extension">TimingExtension</a></code> 。重要的是要记住，在测试执行期间存储在<code>ExtensionContext</code>中的值在周围的<code>ExtensionContext</code>不可用。由于<code>ExtensionContexts</code>可以嵌套，因此内部上下文的范围也可能是有限的。有关可通过<code><a href="../api/org/junit/jupiter/api/extension/ExtensionContext.Store.html">Store</a></code>存储和检索值的方法的详细信息，请参阅相应的Javadoc。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title"><code>ExtensionContext。商店。CloseableResource</code></div>扩展上下文存储绑定到其扩展上下文生命周期。当扩展上下文生命周期结束时，它会关闭其关联的存储。作为<code>CloseableResource</code>实例的所有存储值都通过调用其<code>close()</code>方法得到通知。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="extensions-supported-utilities"><a class="anchor" href="#extensions-supported-utilities"></a> 5.13。扩展中支持的实用程序</h3>
<div class="paragraph">
<p><code>junit-platform-commons</code>工件公开了一个名为<code><a href="../api/org/junit/platform/commons/support/package-summary.html">org.junit.platform.commons.support</a></code>的包，其中包含用于处理注释，类，反射和类路径扫描任务的<em>维护</em>实用程序方法。我们鼓励<code>TestEngine</code>和<code>Extension</code>作者使用这些支持的方法，以便与JUnit平台的行为保持一致。</p>
</div>
<div class="sect3">
<h4 id="extensions-supported-utilities-annotations"><a class="anchor" href="#extensions-supported-utilities-annotations"></a> 5.13.1。注释支持</h4>
<div class="paragraph">
<p><code>AnnotationSupport</code>提供了对带注释元素（例如，包，注释，类，接口，构造函数，方法和字段）进行操作的静态实用程序方法。这些方法包括检查元素是否使用特定注释进行注释或元注释，搜索特定注释以及在类或接口中查找带注释的方法和字段的方法。其中一些方法在实现的接口和类层次结构中搜索以查找注释。有关更多详细信息，请参阅Javadoc for <code><a href="../api/org/junit/platform/commons/support/AnnotationSupport.html">AnnotationSupport</a></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="extensions-supported-utilities-classes"><a class="anchor" href="#extensions-supported-utilities-classes"></a> 5.13.2。班级支持</h4>
<div class="paragraph">
<p><code>ClassSupport</code>提供了用于处理类的静态实用程序方法（即<code>java.lang.实例） <code>java.lang.Class</code> ）。有关更多详细信息，请参阅Javadoc for <code><a href="../api/org/junit/platform/commons/support/ClassSupport.html">ClassSupport</a></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="extensions-supported-utilities-reflection"><a class="anchor" href="#extensions-supported-utilities-reflection"></a> 5.13.3。反思支持</h4>
<div class="paragraph">
<p><code>ReflectionSupport</code>提供了静态实用程序方法，可以增强标准的JDK反射和类加载机制。这些方法包括扫描类路径以搜索与指定谓词匹配的类，加载和创建类的新实例以及查找和调用方法的方法。其中一些方法遍历类层次结构以定位匹配方法。有关更多详细信息，请参阅Javadoc for <code><a href="../api/org/junit/platform/commons/support/ReflectionSupport.html">ReflectionSupport</a></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="extensions-supported-utilities-modifier"><a class="anchor" href="#extensions-supported-utilities-modifier"></a> 5.13.4。修改器支持</h4>
<div class="paragraph">
<p><code>ModifierSupport</code>提供了用于处理成员和类修饰符的静态实用程序方法 - 例如，确定成员是否声明为<code>public</code> ， <code>private</code> ， <code>abstract</code> ， <code>static</code>等。有关更多详细信息，请参阅Javadoc for <code><a href="../api/org/junit/platform/commons/support/ModifierSupport.html">ModifierSupport</a></code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extensions-execution-order"><a class="anchor" href="#extensions-execution-order"></a> 5.14。用户代码和扩展的相对执行顺序</h3>
<div class="paragraph">
<p>在执行包含一个或多个测试方法的测试类时，除了用户提供的测试和生命周期方法之外，还会调用许多扩展回调。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">另请参阅： <a href="#writing-tests-test-execution-order">测试执行顺序</a>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="extensions-execution-order-overview"><a class="anchor" href="#extensions-execution-order-overview"></a> 5.14.1。用户和扩展代码</h4>
<div class="paragraph">
<p>下图说明了用户提供的代码和扩展代码的相对顺序。用户提供的测试和生命周期方法以橙色显示，回调代码由扩展名以蓝色显示。灰色框表示单个测试方法的执行，并将对测试类中的每个测试方法重复。</p>
</div>
<div id="extensions-execution-order-diagram" class="imageblock">
<div class="content">
<img src="images/extensions_lifecycle.png" alt="扩展生命周期">
</div>
<div class="title">用户代码和扩展代码</div>
</div>
<div class="paragraph">
<p>下表进一步说明了<a href="#extensions-execution-order-diagram">用户代码和扩展代码</a>图中的16个步骤。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:5%">
<col style="width:15%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">步</th>
<th class="tableblock halign-left valign-top">接口/注释</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.BeforeAllCallback</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行容器的所有测试之前执行的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释<code>org.junit.jupiter.api.BeforeAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行容器的所有测试之前执行的用户代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler #handleBeforeAllMethodExecutionException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理从<code>@BeforeAll</code>方法抛出的异常的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.BeforeEachCallback</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行每个测试之前执行的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">五</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释<code>org.junit.jupiter.api.BeforeEach</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行每个测试之前执行的用户代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler #handleBeforeEachMethodExecutionException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理从<code>@BeforeEach</code>方法抛出的异常的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.BeforeTestExecutionCallback</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行测试之前立即执行的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释<code>org.junit.jupiter.api.测试</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实际测试方法的用户代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.TestExecutionExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理测试期间抛出的异常的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.AfterTestExecutionCallback</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">测试执行后立即执行的扩展代码及其相应的异常处理程序</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释<code>org.junit.jupiter.api.AfterEach</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行每个测试后执行的用户代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler #handleAfterEachMethodExecutionException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理从<code>@AfterEach</code>方法抛出的异常的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.AfterEachCallback</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行每个测试后执行的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释<code>org.junit.jupiter.api.毕竟</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行容器的所有测试后执行的用户代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler #handleAfterAllMethodExecutionException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理从<code>@AfterAll</code>方法抛出的异常的扩展代码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接口<code>org.junit.jupiter.api.extension.AfterAllCallback</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行容器的所有测试后执行的扩展代码</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在最简单的情况下，只执行实际的测试方法（步骤8）;所有其他步骤都是可选的，具体取决于是否存在用户代码或对应生命周期回调的扩展支持。有关各种生命周期回调的更多详细信息，请参阅相应的Javadoc以获取每个注释和扩展。</p>
</div>
<div class="paragraph">
<p>通过实现<a href="#extensions-intercepting-invocations"><code>InvocationInterceptor</code></a>可以另外拦截上表中所有用户代码方法的<a href="#extensions-intercepting-invocations"><code>InvocationInterceptor</code></a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="extensions-execution-order-wrapping-behavior"><a class="anchor" href="#extensions-execution-order-wrapping-behavior"></a> 5.14.2。回调的包装行为</h4>
<div class="paragraph">
<p>JUnit Jupiter始终保证实现生命周期回调的多个已注册扩展的<em>包装</em>行为，例如<code>BeforeAllCallback</code> ， <code>AfterAllCallback</code> ， <code>BeforeEachCallback</code> ， <code>AfterEachCallback</code> ， <code>BeforeTestExecutionCallback</code>和<code>AfterTestExecutionCallback</code> 。</p>
</div>
<div class="paragraph">
<p>这意味着，给定两个扩展<code>Extension1</code>和<code>Extension2</code>与<code>Extension1</code>日前登记的<code>Extension2</code> ，任何“之前”的实施回调<code>Extension1</code>保证<strong>之前</strong>实施的任何“之前的”回调执行<code>Extension2</code> 。类似地，给定的相同顺序登记在两个相同的两个延伸部，任何“后”由实现回调<code>Extension1</code>保证<strong>后</strong>实施的任何“之后的”回调来执行<code>Extension2</code> 。因此， <code>Extension1</code>被称为<em>包装</em> <code>Extension2</code> 。</p>
</div>
<div class="paragraph">
<p>JUnit Jupiter还保证了用户提供的<em>生命周期方法的</em>类和接口层次结构中的<em>包装</em>行为（请参阅<a href="#writing-tests-classes-and-methods">测试类和方法</a> ）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BeforeAll</code>方法继承自超类，只要它们不被<em>隐藏</em>或<em>覆盖</em> 。此外， <code>@BeforeAll</code>从超方法将<strong>之前</strong>执行<code>@BeforeAll</code>在子类中的方法。</p>
<div class="ulist">
<ul>
<li>
<p>同样， <code>@BeforeAll</code>因为他们没有被<em>隐藏</em>或<em>覆盖</em> ，并在接口中声明方法，只要继承<code>@BeforeAll</code>从接口中的方法将<strong>之前</strong>执行<code>@BeforeAll</code>在实现接口的类的方法。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@AfterAll</code>方法继承自超类，只要它们不被<em>隐藏</em>或<em>覆盖</em> 。此外， <code>@AfterAll</code>从超方法将<strong>后</strong>执行<code>@AfterAll</code>在子类中的方法。</p>
<div class="ulist">
<ul>
<li>
<p>同样， <code>@AfterAll</code>因为他们没有被<em>隐藏</em>或<em>覆盖</em> ，并在接口中声明方法，只要继承<code>@AfterAll</code>从接口中的方法将<strong>后</strong>执行<code>@AfterAll</code>在实现接口的类的方法。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@BeforeEach</code>方法从超类继承，只要它们不<em>被重写</em> 。此外， <code>@BeforeEach</code>从超方法将<strong>之前</strong>执行<code>@BeforeEach</code>在子类中的方法。</p>
<div class="ulist">
<ul>
<li>
<p>类似地，声明为接口默认方法的<code>@BeforeEach</code>方法只要不<em>被覆盖</em>就会被继承，并且<code>@BeforeEach</code>默认方法将在实现接口的类中的<code>@BeforeEach</code>方法<strong>之前</strong>执行。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@AfterEach</code>方法只要不<em>被覆盖</em>就从超类继承。此外， <code>@AfterEach</code>从超方法将<strong>后</strong>执行<code>@AfterEach</code>在子类中的方法。</p>
<div class="ulist">
<ul>
<li>
<p>类似地，声明为接口默认方法的<code>@AfterEach</code>方法只要不<em>被覆盖</em>就会被继承，并且<code>@AfterEach</code>默认方法将在实现接口的类中的<code>@AfterEach</code>方法<strong>之后</strong>执行。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例演示了此行为。请注意，这些示例实际上并没有做任何实际的事情。相反，它们模仿测试与数据库交互的常见场景。从<code>Logger</code>类静态导入的所有方法只是记录上下文信息，以帮助我们更好地理解用户提供的回调方法和扩展中的回调方法的执行顺序。</p>
</div>
<div class="listingblock">
<div class="title">扩展1</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.afterEachCallback</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.beforeEachCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。AfterEachCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。BeforeEachCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。ExtensionContext</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">扩展1</span> <span class="directive">实现</span> BeforeEachCallback，AfterEachCallback <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> beforeEach（ExtensionContext上下文）{beforeEachCallback（ <span class="local-variable">本</span> ）; } <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> afterEach（ExtensionContext上下文）{afterEachCallback（ <span class="local-variable">本</span> ）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">扩展名2</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.afterEachCallback</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.beforeEachCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。AfterEachCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。BeforeEachCallback</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。ExtensionContext</span> ; <span class="directive">公共</span> <span class="type">类</span> <span class="class">扩展名2</span> <span class="directive">实现</span> BeforeEachCallback，AfterEachCallback <span class="annotation">{@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> beforeEach（ExtensionContext上下文）{beforeEachCallback（ <span class="local-variable">本</span> ）; } <span class="annotation">@覆盖</span> <span class="directive">公共</span> <span class="type">无效</span> afterEach（ExtensionContext上下文）{afterEachCallback（ <span class="local-variable">本</span> ）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">AbstractDatabaseTests</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.afterAllMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.afterEachMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.beforeAllMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.beforeEachMethod</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。AfterAll</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。AfterEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。之前所有</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。BeforeEach</span> ; <span class="comment">/ ** *使用数据库的测试的抽象基类。* /</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractDatabaseTests</span> { <span class="annotation">@BeforeAll</span> <span class="directive">static</span> <span class="type">void</span> createDatabase（）{beforeAllMethod（AbstractDatabaseTests.class.getSimpleName（）+ <span class="string"><span class="delimiter">“。</span> <span class="content">createDatabase（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@BeforeEach</span> <span class="type">void</span> connectToDatabase（）{beforeEachMethod（AbstractDatabaseTests.class.getSimpleName（）+ <span class="string"><span class="delimiter">“</span> <span class="content">。</span></span> connectToDatabase <span class="string"><span class="content">（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterEach</span> <span class="type">void</span> disconnectFromDatabase（）{afterEachMethod（AbstractDatabaseTests.class.getSimpleName（）+ <span class="string"><span class="delimiter">“。</span> <span class="content">DisconnectFromDatabase（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterAll</span> <span class="directive">static</span> <span class="type">void</span> destroyDatabase（）{afterAllMethod（AbstractDatabaseTests.class.getSimpleName（）+ <span class="string"><span class="delimiter">“。</span> <span class="content">destroyDatabase（）</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">DatabaseTestsDemo</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.afterEachMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.beforeAllMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.beforeEachMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.testMethod</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。AfterAll</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。AfterEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。之前所有</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。BeforeEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。ExtendWith</span> ; <span class="comment">/ ** *将测试数据*插入数据库的{@link AbstractDatabaseTests}的扩展（在打开数据库连接之后）*并删除测试数据（在数据库连接关闭之前）。* /</span> <span class="annotation">@ExtendWith</span> （{Extension1.class，Extension2.class}） <span class="type">类</span> <span class="class">DatabaseTestsDemo</span> <span class="directive">扩展</span> AbstractDatabaseTests { <span class="annotation">@BeforeAll</span> <span class="directive">static</span> <span class="type">void</span> beforeAll（）{beforeAllMethod（DatabaseTestsDemo.class.getSimpleName（）+ <span class="string"><span class="delimiter">“。</span> <span class="content">eachforeAll（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@BeforeEach</span> <span class="type">void</span> insertTestDataIntoDatabase（）{beforeEachMethod（getClass（）。 <span class="string"><span class="content">getSimpleName（）</span></span> + <span class="string"><span class="delimiter">“。</span> <span class="content">insertTestDataIntoDatabase（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Test</span> <span class="type">void</span> testDatabaseFunctionality（）{testMethod（getClass（）。 <span class="string"><span class="content">getSimpleName（）</span></span> + <span class="string"><span class="delimiter">“。</span> <span class="content">testDatabaseFunctionality（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterEach</span> <span class="type">void</span> deleteTestDataFromDatabase（）{afterEachMethod（getClass（）。 <span class="string"><span class="content">getSimpleName（）</span></span> + <span class="string"><span class="delimiter">“。</span> <span class="content">deleteTestDataFromDatabase（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterAll</span> <span class="directive">static</span> <span class="type">void</span> afterAll（）{beforeAllMethod（DatabaseTestsDemo.class.getSimpleName（）+ <span class="string"><span class="delimiter">“。</span> <span class="content">afterAll（）</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行<code>DatabaseTestsDemo</code>测试类时，将记录以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@BeforeAll AbstractDatabaseTests.createDatabase（）@ BeforeAll DatabaseTestsDemo.beforeAll（）Extension1.beforeEach（）Extension2.beforeEach（）@ BeeEach AbstractDatabaseTests.connectToDatabase（）@ BeforeEach DatabaseTestsDemo.insertTestDataIntoDatabase（）@Test DatabaseTestsDemo.testDatabaseFunctionality（）@AfterEach DatabaseTestsDemo.deleteTestDataFromDatabase （）@AfterEach AbstractDatabaseTests.disconnectFromDatabase（）Extension2.afterEach（）Extension1.afterEach（）@ BeforeAll DatabaseTestsDemo.afterAll（）@ AfterAllAll AbstractDatabaseTests.destroyDatabase（）</pre>
</div>
</div>
<div class="paragraph">
<p>以下序列图有助于进一步了解执行<code>DatabaseTestsDemo</code>测试类时<code>JupiterTestEngine</code>实际发生的<code>JupiterTestEngine</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/extensions_DatabaseTestsDemo.png" alt="扩展DatabaseTestsDemo">
</div>
<div class="title">DatabaseTestsDemo</div>
</div>
<div class="paragraph">
<p>JUnit的木星<strong>不</strong>保证的是在<em>单个</em>测试类或测试界面内声明的多重生命周期方法的执行顺序。有时可能会出现JUnit Jupiter按字母顺序调用此类方法。然而，这并不完全正确。排序类似于单个测试类中<code>@Test</code>方法的排序。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在<em>单个</em>测试类或测试接口中声明的生命周期方法将使用确定性但有意不明显的算法进行排序。这确保了测试套件的后续运行以相同的顺序执行生命周期方法，从而允许可重复的构建。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此外，JUnit的木星<strong>不</strong>支持单个测试类或测试接口内声明的多重生命周期方法<em>包装</em>行为。</p>
</div>
<div class="paragraph">
<p>以下示例演示了此行为。具体而言，由于本地声明的生命周期方法的执行顺序，生命周期方法配置被<em>破坏</em> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>在</em>打开数据库连接<em>之前</em>插入测试数据，这导致无法连接到数据库。</p>
</li>
<li>
<p><em>在</em>删除测试数据<em>之前</em>关闭数据库连接，这导致无法连接到数据库。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">BrokenLifecycleMethodConfigDemo</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.afterEachMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.beforeEachMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">example.callbacks。Logger.testMethod</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。AfterEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。BeforeEach</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api.extension。ExtendWith</span> ; <span class="comment">/ ** *“损坏”生命周期方法配置的示例。* * &lt;p&gt;在打开数据库连接之前插入测试数据。* * &lt;p&gt;在删除测试数据之前，数据库连接已关闭。* /</span> <span class="annotation">@ExtendWith</span> （{Extension1.class，Extension2.class}） <span class="type">类</span> <span class="class">BrokenLifecycleMethodConfigDemo</span> { <span class="annotation">@BeforeEach</span> <span class="type">void</span> connectToDatabase（）{beforeEachMethod（getClass（）。getSimpleName（）+ <span class="string"><span class="delimiter">“</span></span> 。connectToDatabase <span class="string"><span class="content">（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@BeforeEach</span> <span class="type">void</span> insertTestDataIntoDatabase（）{beforeEachMethod（getClass（）。 <span class="string"><span class="content">getSimpleName（）</span></span> + <span class="string"><span class="delimiter">“。</span> <span class="content">insertTestDataIntoDatabase（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@Test</span> <span class="type">void</span> testDatabaseFunctionality（）{testMethod（getClass（）。 <span class="string"><span class="content">getSimpleName（）</span></span> + <span class="string"><span class="delimiter">“。</span> <span class="content">testDatabaseFunctionality（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterEach</span> <span class="type">void</span> deleteTestDataFromDatabase（）{afterEachMethod（getClass（）。 <span class="string"><span class="content">getSimpleName（）</span></span> + <span class="string"><span class="delimiter">“。</span> <span class="content">deleteTestDataFromDatabase（）</span> <span class="delimiter">”</span></span> ）; } <span class="annotation">@AfterEach</span> <span class="type">void</span> disconnectFromDatabase（）{afterEachMethod（getClass（）。 <span class="string"><span class="content">getSimpleName（）</span></span> + <span class="string"><span class="delimiter">“。</span> <span class="content">disconnectFromDatabase（）</span> <span class="delimiter">”</span></span> ）; }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行<code>BrokenLifecycleMethodConfigDemo</code>测试类时，将记录以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Extension1.beforeEach（）Extension2.beforeEach（）@BeforeEach BrokenLifecycleMethodConfigDemo.insertTestDataIntoDatabase（）@BeforeEach BrokenLifecycleMethodConfigDemo.connectToDatabase（）@Test BrokenLifecycleMethodConfigDemo.testDatabaseFunctionality（）@AfterEach BrokenLifecycleMethodConfigDemo.disconnectFromDatabase（）@AfterEach BrokenLifecycleMethodConfigDemo.deleteTestDataFromDatabase（）Extension2.afterEach（） Extension1.afterEach（）</pre>
</div>
</div>
<div class="paragraph">
<p>以下序列图有助于进一步<code>JupiterTestEngine</code>在执行<code>BrokenLifecycleMethodConfigDemo</code>测试类时<code>BrokenLifecycleMethodConfigDemo</code>实际发生的<code>JupiterTestEngine</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/extensions_BrokenLifecycleMethodConfigDemo.png" alt="扩展BrokenLifecycleMethodConfigDemo">
</div>
<div class="title">BrokenLifecycleMethodConfigDemo</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于上述行为，JUnit团队建议开发人员为每个测试类或测试接口最多声明每种类型的<em>生命周期方法</em> （参见<a href="#writing-tests-classes-and-methods">测试类和方法</a> ），除非这些生命周期方法之间没有依赖关系。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-topics"><a class="anchor" href="#advanced-topics"></a> 6。高级主题</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="launcher-api"><a class="anchor" href="#launcher-api"></a> 6.1。JUnit Platform Launcher API</h3>
<div class="paragraph">
<p>JUnit 5的一个突出目标是使JUnit与其程序化客户端（构建工具和IDE）之间的接口更加强大和稳定。目的是将发现和执行测试的内部与外部所需的所有过滤和配置分离。</p>
</div>
<div class="paragraph">
<p>JUnit 5引入了可用于发现，过滤和执行测试的<code>Launcher</code>概念。此外，第三方测试库（如Spock，Cucumber和FitNesse）可以通过提供自定义<code><a href="../api/org/junit/platform/engine/TestEngine.html">TestEngine</a></code>插入JUnit平台的启动基础架构。</p>
</div>
<div class="paragraph">
<p>启动器API位于<code><a href="../api/org/junit/platform/launcher/package-summary.html">junit-platform-launcher</a></code>模块中。</p>
</div>
<div class="paragraph">
<p>启动器API的示例消费者是<code><a href="../api/org/junit/platform/console/package-summary.html">junit-platform-console</a></code>项目中的<code><a href="../api/org/junit/platform/console/ConsoleLauncher.html">ConsoleLauncher</a></code> 。</p>
</div>
<div class="sect3">
<h4 id="launcher-api-discovery"><a class="anchor" href="#launcher-api-discovery"></a> 6.1.1。发现测试</h4>
<div class="paragraph">
<p>将<em>测试发现</em>作为平台本身的专用功能引入（希望）免费的IDE和构建工具，避免他们过去需要通过的大多数困难来识别测试类和测试方法。</p>
</div>
<div class="paragraph">
<p>用法示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.engine.discovery。ClassNameFilter.includeClassNamePatterns</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.engine.discovery。DiscoverySelectors.selectClass</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.engine.discovery。DiscoverySelectors.selectPackage</span> ; <span class="keyword">import</span> <span class="include">java.io.PrintWriter</span> ; <span class="keyword">import</span> <span class="include">java.nio.file。路径</span> ; <span class="keyword">import</span> <span class="include">java.nio.file。路径</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher。发射器</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher。LauncherDiscoveryRequest</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher。TestExecutionListener</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher。TestPlan</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher.core。LauncherConfig</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher.core。LauncherDiscoveryRequestBuilder</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher.core。LauncherFactory</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher.listeners。SummaryGeneratingListener</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.launcher.listeners。TestExecutionSummary</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.reporting.legacy.xml。LegacyXmlReportGeneratingListener</span> ;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request（）。selector（selectPackage（ <span class="string"><span class="delimiter">“</span> <span class="content">com.example.mytests</span> <span class="delimiter">”</span></span> ），selectClass（MyTestClass.class））.filters（includeClassNamePatterns（ <span class="string"><span class="delimiter">“</span> <span class="content">。*测试</span> <span class="delimiter">“</span></span> ））。build（）; Launcher launcher = LauncherFactory.create（）; TestPlan testPlan = launcher.discover（request）;</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前可以在包中选择类，方法和所有类，甚至可以在类路径中搜索所有测试。发现在所有参与的测试引擎中进行。</p>
</div>
<div class="paragraph">
<p>生成的<code>TestPlan</code>是适合<code>LauncherDiscoveryRequest</code>的所有引擎，类和测试方法的分层（和只读）描述。客户端可以遍历树，检索有关节点的详细信息，并获取指向原始源的链接（如类，方法或文件位置）。测试计划中的每个节点都有一个<em>唯一的ID</em> ，可用于调用特定测试或一组测试。</p>
</div>
</div>
<div class="sect3">
<h4 id="launcher-api-execution"><a class="anchor" href="#launcher-api-execution"></a> 6.1.2。执行测试</h4>
<div class="paragraph">
<p>要执行测试，客户端可以使用与发现阶段相同的<code>LauncherDiscoveryRequest</code> ，也可以创建新请求。可以通过使用<code>Launcher</code>注册一个或多个<code><a href="../api/org/junit/platform/launcher/TestExecutionListener.html">TestExecutionListener</a></code>实现来实现测试进度和报告，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request（）。selector（selectPackage（ <span class="string"><span class="delimiter">“</span> <span class="content">com.example.mytests</span> <span class="delimiter">”</span></span> ），selectClass（MyTestClass.class））.filters（includeClassNamePatterns（ <span class="string"><span class="delimiter">“</span> <span class="content">。*测试</span> <span class="delimiter">“</span></span> ））。build（）; Launcher launcher = LauncherFactory.create（）; <span class="comment">//注册您选择的</span>侦听器SummaryGeneratingListener listener = <span class="keyword">new</span> SummaryGeneratingListener（）; launcher.registerTestExecutionListeners（listener）; launcher.execute（request）; TestExecutionSummary summary = listener.getSummary（）; <span class="comment">//使用TestExecutionSummary执行某些操作。</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>execute()</code>方法没有返回值，但您可以轻松地使用侦听器将最终结果聚合到您自己的对象中。有关示例，请参阅<code><a href="../api/org/junit/platform/launcher/listeners/SummaryGeneratingListener.html">SummaryGeneratingListener</a></code>和<code><a href="../api/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListener.html">LegacyXmlReportGeneratingListener</a></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="launcher-api-engines-custom"><a class="anchor" href="#launcher-api-engines-custom"></a> 6.1.3。插入自己的测试引擎</h4>
<div class="paragraph">
<p>JUnit目前提供两个<code><a href="../api/org/junit/platform/engine/TestEngine.html">TestEngine</a></code>实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../api/org/junit/jupiter/engine/package-summary.html">junit-jupiter-engine</a></code> ：JUnit Jupiter的核心。</p>
</li>
<li>
<p><code><a href="../api/org/junit/vintage/engine/package-summary.html">junit-vintage-engine</a></code> ：JUnit 4顶部的薄层，允许使用启动器基础设施运行<em>复古</em>测试。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第三方也可以通过实现<a href="../api/org/junit/platform/engine/package-summary.html">junit-platform-engine</a>模块中的接口并<em>注册</em>其引擎来贡献自己的<code>TestEngine</code> 。默认情况下，通过Java的<code>java.util.支持引擎注册<code>java.util.ServiceLoader</code>机制。例如， <code>junit-jupiter-engine</code>模块注册其<code>org.junit.jupiter.engine.JupiterTestEngine</code>在名为<code>org.junit.platform.engine.的文件中<code>org.junit.platform.engine.在<code>junit-jupiter-engine</code> JAR中的<code>/META-INF/services</code>中的TestEngine</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code><a href="../api/org/junit/platform/engine/support/hierarchical/HierarchicalTestEngine.html">HierarchicalTestEngine</a></code>是一个方便的抽象基础实现（由<code><a href="../api/org/junit/jupiter/engine/package-summary.html">junit-jupiter-engine</a></code> ），它只需要实现者为测试发现提供逻辑。它实现了实现<code>Node</code>接口的<code>TestDescriptors</code>执行，包括对并行执行的支持。
</td>
</tr>
</table>
</div>
<div id="launcher-api-engines-custom-ids" class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title"><code>junit-</code>前缀是为JUnit Team的TestEngines保留的</div>
<div class="paragraph">
<p>JUnit Platform <code>Launcher</code>强制执行只有JUnit团队发布的<code>TestEngine</code>实现可以使用<code>junit-</code>前缀作为其<code>TestEngine</code> ID。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果任何第三方<code>TestEngine</code>声称是<code>junit-jupiter</code>或<code>junit-vintage</code> ，则会抛出异常，立即停止执行JUnit平台。</p>
</li>
<li>
<p>如果任何第三方<code>TestEngine</code>使用<code>junit-</code>前缀作为其ID，则将记录警告消息。JUnit平台的后续版本将针对此类违规行为抛出异常。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="launcher-api-listeners-custom"><a class="anchor" href="#launcher-api-listeners-custom"></a> 6.1.4。插入自己的测试执行监听器</h4>
<div class="paragraph">
<p>除了用于以编程方式注册测试执行侦听<code><a href="../api/org/junit/platform/launcher/Launcher.html">Launcher</a></code>的公共<code><a href="../api/org/junit/platform/launcher/Launcher.html">Launcher</a></code> API方法之外，默认情况下，将通过Java的<code>java.util.在运行时发现自定义<code><a href="../api/org/junit/platform/launcher/TestExecutionListener.html">TestExecutionListener</a></code>实现<code>java.util.ServiceLoader</code>机制，并通过<code>Launcher</code>创建的<code>LauncherFactory</code>自动注册。例如，一个<code>example.TestInfoPrinter</code>类实现<code><a href="../api/org/junit/platform/launcher/TestExecutionListener.html">TestExecutionListener</a></code>并在<code>/META-INF/services/org.junit.platform.launcher.声明<code>/META-INF/services/org.junit.platform.launcher.TestExecutionListener</code>文件自动加载并注册。</p>
</div>
</div>
<div class="sect3">
<h4 id="launcher-api-listeners-reporting"><a class="anchor" href="#launcher-api-listeners-reporting"></a> 6.1.5。JUnit平台报告</h4>
<div class="paragraph">
<p><code>junit-platform-reporting</code>工件包含生成测试报告的<code><a href="../api/org/junit/platform/launcher/TestExecutionListener.html">TestExecutionListener</a></code>实现。这些侦听器通常由IDE和构建工具使用。<code>org.junit.platform.reporting.legacy.xml</code>包当前包含以下实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="../api/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListener.html">LegacyXmlReportGeneratingListener</a></code>为<code><a href="../api/org/junit/platform/launcher/TestPlan.html">TestPlan</a></code>每个根生成单独的XML报告。请注意，生成的XML格式与基于JUnit 4的测试报告的事实标准兼容，该测试报告受Ant构建系统的欢迎。<code>LegacyXmlReportGeneratingListener</code>也由<a href="#running-tests-console-launcher">Console Launcher</a>使用。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><code><a href="../api/org/junit/platform/launcher/package-summary.html">junit-platform-launcher</a></code>模块还包含可用于报告目的的<code><a href="../api/org/junit/platform/launcher/TestExecutionListener.html">TestExecutionListener</a></code>实现。有关详细信息，请参阅<code><a href="../api/org/junit/platform/launcher/listeners/LoggingListener.html">LoggingListener</a></code>和<code><a href="../api/org/junit/platform/launcher/listeners/SummaryGeneratingListener.html">SummaryGeneratingListener</a></code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="launcher-api-launcher-config"><a class="anchor" href="#launcher-api-launcher-config"></a> 6.1.6。配置启动器</h4>
<div class="paragraph">
<p>如果您需要对测试引擎和测试执行侦听<code>LauncherConfig</code>自动检测和注册进行细粒度控制，您可以创建一个<code>LauncherConfig</code>实例并将其提供给<code>LauncherFactory.create(LauncherConfig)</code>方法。通常， <code>LauncherConfig</code>的实例是通过内置的流畅<em>构建器</em> API创建的，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">LauncherConfig launcherConfig = LauncherConfig.builder（）。enableableTestEngineAutoRegistration（ <span class="predefined-constant">false</span> ）.enableTestExecutionListenerAutoRegistration（ <span class="predefined-constant">false</span> ）.addTestEngines（ <span class="keyword">new</span> CustomTestEngine（））。addTestExecutionListeners（ <span class="keyword">new</span> LegacyXmlReportGeneratingListener（reportsDir，out））。addTestExecutionListeners（ <span class="keyword">new</span> CustomTestExecutionListener（））。build（）; Launcher launcher = LauncherFactory.create（launcherConfig）; LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request（）。selector（selectPackage（ <span class="string"><span class="delimiter">“</span> <span class="content">com.example.mytests</span> <span class="delimiter">”</span></span> ））。build（）; launcher.execute（请求）;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testkit"><a class="anchor" href="#testkit"></a> 6.2。JUnit平台测试工具包</h3>
<div class="paragraph">
<p><code>junit-platform-testkit</code>工件支持在JUnit平台上执行测试计划，然后验证预期结果。从JUnit Platform 1.4开始，此支持仅限于执行单个<code>TestEngine</code> （请参阅<a href="#testkit-engine">引擎测试工具包</a> ）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">虽然测试工具包目前是一个<a href="#api-evolution-experimental-apis"><em>实验性</em></a>功能，但JUnit团队邀请您试用它并提供反馈，以帮助改进测试工具包API并最终<a href="#api-evolution">推广</a>此功能。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="testkit-engine"><a class="anchor" href="#testkit-engine"></a> 6.2.1。发动机测试套件</h4>
<div class="paragraph">
<p><code><a href="../api/org/junit/platform/testkit/engine/package-summary.html">org.junit.platform.testkit.engine</a></code>包为在JUnit Platform上运行的给定<code><a href="../api/org/junit/platform/engine/TestEngine.html">TestEngine</a></code>执行<code><a href="../api/org/junit/platform/launcher/TestPlan.html">TestPlan</a></code>提供支持，然后通过流畅的API访问结果以验证预期结果。这个API的关键入口点是<code><a href="../api/org/junit/platform/testkit/engine/EngineTestKit.html">EngineTestKit</a></code> ，它提供名为<code>engine()</code>和<code>execute()</code>静态工厂方法。建议您选择其中一个<code>engine()</code>变体，以便从用于构建<code>EngineDiscoveryRequest</code>的流畅API中<code>EngineDiscoveryRequest</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果你喜欢使用<code>LauncherDiscoveryRequestBuilder</code>从<code>Launcher</code> API来构建<code>EngineDiscoveryRequest</code> ，你必须使用的一个<code>execute()</code>的变种<code>EngineTestKit</code> 。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用JUnit Jupiter编写的以下测试类将用于后续示例中。</p>
</div>
<div id="testkit-engine-ExampleTestCase" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assertions.assertEquals</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.jupiter.api。Assumptions.assumeTrue</span> ; <span class="keyword">import</span> <span class="include">example.util。计算器</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。残疾</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。MethodOrderer。OrderAnnotation</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。订单</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。TestMethodOrder</span> ; <span class="annotation">@TestMethodOrder</span> （OrderAnnotation.class） <span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleTestCase</span> { <span class="directive">private</span> <span class="directive">final</span> Calculator calculator = <span class="keyword">new</span> Calculator（）; <span class="annotation">@Test</span> <span class="annotation">@Disabled</span> （ <span class="string"><span class="delimiter">“</span> <span class="content">用于演示目的</span> <span class="delimiter">”</span></span> ） <span class="annotation">@Order</span> （ <span class="integer">1</span> ） <span class="type">void</span> skippedTest（）{ <span class="comment">//跳过...</span>} <span class="annotation">@Test</span> <span class="annotation"><span class="integer">@Order（2）</span></span> <span class="type">的空隙</span> succeedingTest（）{的<span class="integer"><span class="integer"><span class="integer">assertEquals（42，calculator.multiply（6,7））;</span></span></span> } <span class="annotation">@Test</span> <span class="annotation">@Order</span> （ <span class="integer">3</span> ） <span class="type">void</span> abortedTest（）{assumeTrue（ <span class="string"><span class="delimiter">“</span> <span class="content">abc</span> <span class="delimiter">”</span></span> .contains（ <span class="string"><span class="delimiter">“</span> <span class="content">Z</span> <span class="delimiter">”</span></span> ）， <span class="string"><span class="delimiter">“</span> <span class="content">abc不包含Z</span> <span class="delimiter">”</span></span> ）; <span class="comment">//中止...</span><span class="comment">“被零/” <span class="integer"><span class="integer">calculator.divide（1，0）;：}</span></span></span> <span class="annotation">@Test</span> <span class="annotation"><span class="integer">@Order（4）</span></span> <span class="type">空隙</span> <span class="comment">failingTest（）{//以下抛出ArithmeticException</span> }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为简洁起见，以下部分演示了如何测试JUnit自己的<code>JupiterTestEngine</code>其唯一引擎ID为<code>"junit-jupiter"</code> 。如果要测试自己的<code>TestEngine</code>实现，则需要使用其唯一的引擎ID。或者，您可以通过向<code>EngineTestKit.engine(TestEngine)</code>静态工厂方法提供它的实例来测试您自己的<code>TestEngine</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="testkit-engine-statistics"><a class="anchor" href="#testkit-engine-statistics"></a> 6.2.2。断言统计</h4>
<div class="paragraph">
<p>测试工具包最常见的功能之一是能够对执行<code>TestPlan</code>期间触发的事件断言统计信息。以下测试演示了如何在JUnit Jupiter <code>TestEngine</code>声明<em>容器</em>和<em>测试的</em>统计信息。有关可用统计信息的详细信息，请参阅Javadoc for <code><a href="../api/org/junit/platform/testkit/engine/EventStatistics.html">EventStatistics</a></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.engine.discovery。DiscoverySelectors.selectClass</span> ; <span class="keyword">导入</span> <span class="include">示例。ExampleTestCase</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.testkit.engine。EngineTestKit</span> ; <span class="type">class</span> <span class="class">EngineTestKitStatisticsDemo</span> { <span class="annotation">@Test</span> <span class="type">void</span> verifyJupiterContainerStats（）{EngineTestKit .engine（ <span class="string"><span class="delimiter">“</span> <span class="content">junit-jupiter</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .selectors（selectClass（ExampleTestCase.class）） <i class="conum" data-value="2"></i> <b>（2）</b> .execute（） <i class="conum" data-value="3"></i> <b>（3）</b> .containers（） <i class="conum" data-value="4"></i> <b>（4）</b> .assertStatistics（stats  - &gt; stats.started（ <span class="integer">2</span> ）.succeeded（ <span class="integer">2</span> ））; <i class="conum" data-value="5"></i> <b>（5）</b> } <span class="annotation">@Test</span> <span class="type">void</span> verifyJupiterTestStats（）{EngineTestKit .engine（ <span class="string"><span class="delimiter">“</span> <span class="content">junit-jupiter</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .selectors（selectClass（ExampleTestCase.class）） <i class="conum" data-value="2"></i> <b>（2）</b> .execute（） <i class="conum" data-value="3"></i> <b>（3）</b> .tests（） <i class="conum" data-value="6"></i> <b>（6）</b> .assertStatistics（stats  - &gt; stats.skipped（ <span class="integer">1</span> ）.started（ <span class="integer">3</span> ）.succeeded（ <span class="integer">1</span> ）.aborted（ <span class="integer">1</span> ）.failed（ <span class="integer">1</span> ））; <i class="conum" data-value="7"></i> <b>（7）</b> }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>选择JUnit Jupiter <code>TestEngine</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>选择<a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a>测试类。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>执行<code>TestPlan</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>按<em>容器</em>事件过滤。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>五</b></td>
<td>断言<em>容器</em>事件的统计信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>按<em>测试</em>事件过滤。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>断言<em>测试</em>事件的统计信息。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在<code>verifyJupiterContainerStats()</code>测试方法中，由于<code>JupiterTestEngine</code>和<a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a>类都被视为容器，因此<code>started</code>和<code>succeeded</code>统计信息的计数为<code>2</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testkit-engine-events"><a class="anchor" href="#testkit-engine-events"></a> 6.2.3。断言事件</h4>
<div class="paragraph">
<p>如果您发现仅<a href="#testkit-engine-statistics">断言统计信息</a>不足以验证测试执行的预期行为，则可以直接使用记录的<code><a href="../api/org/junit/platform/testkit/engine/Event.html">Event</a></code>元素并对它们执行断言。</p>
</div>
<div class="paragraph">
<p>例如，如果要验证是否跳过<a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a>中的<code>skippedTest()</code>方法的原因，可以按如下方式执行此操作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下示例中的<code>assertThatEvents()</code>方法是<code>org.assertj.core.api.的快捷方式<code>org.assertj.core.api.来自<a href="https://joel-costigliola.github.io/assertj/">AssertJ</a>断言库的Assertions.assertThat(events.list())</code> 。</p>
</div>
<div class="paragraph">
<p>有关可用于AssertJ断言事件的<em>条件的</em>详细信息，请参阅Javadoc for <code><a href="../api/org/junit/platform/testkit/engine/EventConditions.html">EventConditions</a></code> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.engine.discovery。DiscoverySelectors.selectMethod</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.event</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.skippedWithReason</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.test</span> ; <span class="keyword">导入</span> <span class="include">示例。ExampleTestCase</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.testkit.engine。EngineTestKit</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.testkit.engine。活动</span> ; <span class="type">class</span> <span class="class">EngineTestKitSkippedMethodDemo</span> { <span class="annotation">@Test</span> <span class="type">void</span> verifyJupiterMethodWasSkipped（）{ <span class="predefined-type">String</span> methodName = <span class="string"><span class="delimiter">“</span> <span class="content">skippedTest</span> <span class="delimiter">”</span></span> ;事件testEvents = EngineTestKit <i class="conum" data-value="5"></i> <b>（5）</b> .engine（ <span class="string"><span class="delimiter">“</span> <span class="content">junit-jupiter</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .selectors（selectMethod（ExampleTestCase.class，methodName）） <i class="conum" data-value="2"></i> <b>（2）</b> .execute（） <i class="conum" data-value="3"></i> <b>（3）</b> .tests（）; <i class="conum" data-value="4"></i> <b>（4）</b> testEvents.assertStatistics（stats  - &gt; stats.skipped（ <span class="integer">1</span> ））; <i class="conum" data-value="6"></i> <b>（6）</b> testEvents.assertThatEvents（） <i class="conum" data-value="7"></i> <b>（7）</b> .haveExactly（ <span class="integer">1</span> ，事件（test（methodName），skippedWithReason（ <span class="string"><span class="delimiter">“</span> <span class="content">用于演示目的</span> <span class="delimiter">”</span></span> ）））; }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>选择JUnit Jupiter <code>TestEngine</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在<a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a>测试类中选择<code>skippedTest()</code>方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>执行<code>TestPlan</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>按<em>测试</em>事件过滤。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>五</b></td>
<td>将<em>测试</em> <code>Events</code>保存到本地变量。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>（可选）断言预期的统计信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i> <b>7</b></td>
<td>断言记录的<em>测试</em>事件包含一个名为<code>skippedTest</code>跳过测试，其中<code>"for demonstration purposes"</code>为<em>原因</em> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您想验证从抛出的异常的类型<code>failingTest()</code>的方法<a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a> ，你可以做如下。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有关可用于AssertJ断言的事件和执行结果的<em>条件的</em>详细信息，请分别参阅Javadoc for <code><a href="../api/org/junit/platform/testkit/engine/EventConditions.html">EventConditions</a></code>和<code><a href="../api/org/junit/platform/testkit/engine/TestExecutionResultConditions.html">TestExecutionResultConditions</a></code> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.engine.discovery。DiscoverySelectors.selectClass</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.event</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.finishedWithFailure</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.test</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。TestExecutionResultConditions.instanceOf</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。TestExecutionResultConditions.message</span> ; <span class="keyword">导入</span> <span class="include">示例。ExampleTestCase</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.testkit.engine。EngineTestKit</span> ; <span class="type">class</span> <span class="class">EngineTestKitFailedMethodDemo</span> { <span class="annotation">@Test</span> <span class="type">void</span> verifyJupiterMethodFailed（）{EngineTestKit.engine（ <span class="string"><span class="delimiter">“</span> <span class="content">junit-jupiter</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .selectors（selectClass（ExampleTestCase.class）） <i class="conum" data-value="2"></i> <b>（2）</b> .execute（） <i class="conum" data-value="3"></i> <b>（3）</b> .tests（） <i class="conum" data-value="4"></i> <b>（4）</b> .assertThatEvents（）。haveExactly（ <span class="integer">1</span> ， <i class="conum" data-value="5"></i> <b>（5）</b> event（test（ <span class="string"><span class="delimiter">“</span> <span class="content">failingTest</span> <span class="delimiter">”</span></span> ），finishedWithFailure（instanceOf（ <span class="exception">ArithmeticException</span> .class），message（ <span class="string"><span class="delimiter">“</span> <span class="content">/ by zero</span> <span class="delimiter">”</span></span> ））））; }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>选择JUnit Jupiter <code>TestEngine</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>选择<a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a>测试类。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>执行<code>TestPlan</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>按<em>测试</em>事件过滤。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>五</b></td>
<td>断言记录的<em>测试</em>事件恰好包含一个名为<code>failingTest</code>失败测试，其中<code>ArithmeticException</code>类型的异常和等于<code>"/ by zero"</code>的错误消息。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>虽然通常是不必要的，但有时您需要验证在执行<code>TestPlan</code>期间触发的<strong>所有</strong>事件。以下测试演示了如何通过<code>EngineTestKit</code> API中的<code>assertEventsMatchExactly()</code>方法实现此<code>EngineTestKit</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于<code>assertEventsMatchExactly()</code>完全按照触发事件的顺序匹配条件， <a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a>使用<code>@TestMethodOrder(OrderAnnotation.class)</code>注释了<code>@TestMethodOrder(OrderAnnotation.class)</code>并且每个测试方法都使用<code>@Order(…​)</code>进行了注释。这允许我们强制执行测试方法的顺序，这反过来允许我们的<code>verifyAllJupiterEvents()</code>测试可靠。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.engine.discovery。DiscoverySelectors.selectClass</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.abortedWithReason</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.container</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.engine</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.event</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.finishedSuccessfully</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.finishedWithFailure</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.skippedWithReason</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.started</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。EventConditions.test</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。TestExecutionResultConditions.instanceOf</span> ; <span class="keyword">import</span> <span class="include">static</span> <span class="include">org.junit.platform.testkit.engine。TestExecutionResultConditions.message</span> ; <span class="keyword">import</span> <span class="include">java.io.StringWriter</span> ; <span class="keyword">import</span> <span class="include">java.io.作家</span> ; <span class="keyword">导入</span> <span class="include">示例。ExampleTestCase</span> ; <span class="keyword">import</span> <span class="include">org.junit.jupiter.api。测试</span> ; <span class="keyword">import</span> <span class="include">org.junit.platform.testkit.engine。EngineTestKit</span> ; <span class="keyword">import</span> <span class="include">org.opentest4j。TestAbortedException</span> ; <span class="type">class</span> <span class="class">EngineTestKitAllEventsDemo</span> { <span class="annotation">@Test</span> <span class="type">void</span> verifyAllJupiterEvents（）{ <span class="predefined-type">Writer</span> writer = <span class="comment">//创建一个java.io.调试输出的</span>编写器EngineTestKit.engine（ <span class="string"><span class="delimiter">“</span> <span class="content">junit-jupiter</span> <span class="delimiter">”</span></span> ） <i class="conum" data-value="1"></i> <b>（1）</b> .selectors（selectClass（ExampleTestCase.class）） <i class="conum" data-value="2"></i> <b>（2）</b> .execute（） <i class="conum" data-value="3"></i> <b>（3）</b> .all（） <i class="conum" data-value="4"></i> <b>（4）</b> .debug（作家） <i class="conum" data-value="5"></i> <b>（5）</b> .assertEventsMatchExactly（ <i class="conum" data-value="6"></i> <b>（6）</b> event（engine（），started（）），event（容器（ExampleTestCase.class），started（）），event（test（ <span class="string"><span class="delimiter">“</span> <span class="content">skippedTest</span> <span class="delimiter">”</span></span> ），skippedWithReason（ <span class="string"><span class="delimiter">“</span> <span class="content">用于演示目的</span> <span class="delimiter">”</span></span> ）），event（test） （ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“succeedingTest”），</span></span></span></span>开始（）），事件（测试（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“succeedingTest”），finishedSuccessfully（）），</span></span></span></span>事件（测试（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“abortedTest”），</span></span></span></span>开始（）），事件（测试（ <span class="string"><span class="delimiter"><span class="content"><span class="delimiter">“abortedTest”），abortedWithReason（</span></span></span></span> instanceOf（TestAbortedException.class），message（m  - &gt; m.contains（ <span class="string"><span class="delimiter">“</span> <span class="content">abc不包含Z</span> <span class="delimiter">”</span></span> ）））），event（test（ <span class="string"><span class="delimiter">“</span> <span class="content">failingTest</span> <span class="delimiter">”</span></span> ），started（）），event（test（ <span class="string"><span class="delimiter">“</span> <span class="content">failingTest</span> <span class="delimiter">”</span></span> ）） ，finishedWithFailure（instanceOf（ <span class="exception">ArithmeticException</span> .class），message（ <span class="string"><span class="delimiter">“</span> <span class="content">/ by zero</span> <span class="delimiter">”</span></span> ））），event（container（ExampleTestCase.class），finishedSuccessfully（）），event（engine（），finishedSuccessfully（）））; }}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i> <b>1</b></td>
<td>选择JUnit Jupiter <code>TestEngine</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>选择<a href="#testkit-engine-ExampleTestCase"><code>ExampleTestCase</code></a>测试类。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>执行<code>TestPlan</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>按<em>所有</em>活动过滤。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>五</b></td>
<td>将所有事件打印到提供的<code>writer</code>以进行调试。调试信息也可以写入<code>OutputStream</code> ，如<code>System.out</code>或<code>System.err</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i> <b>6</b></td>
<td>完全按照测试引擎触发的顺序断言<em>所有</em>事件。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>来自前面示例的<code>debug()</code>调用导致类似于以下的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>所有事件：事件[type = STARTED，testDescriptor = JupiterEngineDescriptor：[engine：junit-jupiter]，timestamp = 2018-12-14T12：45：14.082280Z，payload = null]事件[type = STARTED，testDescriptor = ClassTestDescriptor：[engine] ：的junit-木星] / [类：例子。ExampleTestCase]，timestamp = 2018-12-14T12：45：14.089339Z，payload = null]事件[type = SKIPPED，testDescriptor = TestMethodTestDescriptor：[engine：junit-jupiter] / [class：example。ExampleTestCase] / [method：skippedTest（）]，timestamp = 2018-12-14T12：45：14.094314Z，payload ='用于演示目的']事件[type = STARTED，testDescriptor = TestMethodTestDescriptor：[engine：junit-jupiter] / [类：例子。ExampleTestCase] / [method：succeedingTest（）]，timestamp = 2018-12-14T12：45：14.095182Z，payload = null]事件[type = FINISHED，testDescriptor = TestMethodTestDescriptor：[engine：junit-jupiter] / [class：example 。ExampleTestCase] / [method：succeedingTest（）]，timestamp = 2018-12-14T12：45：14.104922Z，payload = TestExecutionResult [status = SUCCESSFUL，throwable = null]]事件[type = STARTED，testDescriptor = TestMethodTestDescriptor：[engine：的junit-木星] / [类：例子。ExampleTestCase] / [method：abortedTest（）]，timestamp = 2018-12-14T12：45：14.106121Z，payload = null]事件[type = FINISHED，testDescriptor = TestMethodTestDescriptor：[engine：junit-jupiter] / [class：example] 。ExampleTestCase] / [method：abortedTest（）]，timestamp = 2018-12-14T12：45：14.109956Z，payload = TestExecutionResult [status = ABORTED，throwable = org.opentest4j。TestAbortedException：假设失败：abc不包含Z]] Event [type = STARTED，testDescriptor = TestMethodTestDescriptor：[engine：junit-jupiter] / [class：example。ExampleTestCase] / [method：failingTest（）]，timestamp = 2018-12-14T12：45：14.110680Z，payload = null]事件[type = FINISHED，testDescriptor = TestMethodTestDescriptor：[engine：junit-jupiter] / [class：example] 。ExampleTestCase] / [method：failingTest（）]，timestamp = 2018-12-14T12：45：14.111217Z，payload = TestExecutionResult [status = FAILED，throwable = java.lang。ArithmeticException：/ by zero]] Event [type = FINISHED，testDescriptor = ClassTestDescriptor：[engine：junit-jupiter] / [class：example。ExampleTestCase]，timestamp = 2018-12-14T12：45：14.113731Z，payload = TestExecutionResult [status = SUCCESSFUL，throwable = null]]事件[type = FINISHED，testDescriptor = JupiterEngineDescriptor：[engine：junit-jupiter]，timestamp = 2018 -12-14T12：45：14.113806Z，payload = TestExecutionResult [status = SUCCESSFUL，throwable = null]]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-evolution"><a class="anchor" href="#api-evolution"></a> 7。API演变</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JUnit 5的主要目标之一是提高维护者发展JUnit的能力，尽管它被用于许多项目中。对于JUnit 4，最初作为内部构造添加的许多东西仅被外部扩展编写器和工具构建器使用。这使得改变JUnit 4变得特别困难，有时甚至是不可能的。</p>
</div>
<div class="paragraph">
<p>这就是为什么JUnit 5为所有公共可用的接口，类和方法引入了一个定义的生命周期。</p>
</div>
<div class="sect2">
<h3 id="api-evolution-version-and-status"><a class="anchor" href="#api-evolution-version-and-status"></a> 7.1。API版本和状态</h3>
<div class="paragraph">
<p>每发表神器都有一个版本号<code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> ，和所有公开可用的接口，类和方法与注释<a href="https://apiguardian-team.github.io/apiguardian/docs/current/api/">@API</a>从<a href="https://github.com/apiguardian-team/apiguardian">@API卫报</a>项目。可以为注释的<code>status</code>属性分配以下值之一。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>内部</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除了JUnit本身之外的任何代码都不能使用它。如有更改，恕不另行通知。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>弃用</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不应再使用;可能会在下一个次要版本中消失。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>实验</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于我们正在寻找反馈的新的实验性功能。<br>谨慎使用此元素;它可能在将来被提升为<code>MAINTAINED</code>或<code>STABLE</code> ，但也可能在未事先通知的情况下删除，即使是在补丁中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>保持</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于<strong>至少</strong>在当前主要版本的下一个次要版本中不会以向后兼容的方式更改的功能。如果计划删除，它将首先降级为<code>DEPRECATED</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>稳定</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于在当前主要版本中不会以向后兼容的方式更改的功能（ <code>5.*</code> ）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果某个类型上存在<code>@API</code>注释，则它也被视为适用于该类型的所有公共成员。允许成员声明稳定性较低的不同<code>status</code>值。</p>
</div>
</div>
<div class="sect2">
<h3 id="api-evolution-experimental-apis"><a class="anchor" href="#api-evolution-experimental-apis"></a> 7.2。实验API</h3>
<div class="paragraph">
<p>下表列出了当前通过<code>@API(status = EXPERIMENTAL)</code>指定为<em>实验的</em> API。在依赖此类API时应谨慎。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">包裹名字</th>
<th class="tableblock halign-left valign-top">输入名称</th>
<th class="tableblock halign-left valign-top">以来</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AssertionsKt</code> <em>（班级）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisplayNameGeneration</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisplayNameGenerator</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MethodDescriptor</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MethodOrderer</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MethodOrdererContext</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Order</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TestMethodOrder</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Timeout</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvocationInterceptor</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Invocation</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LifecycleMethodExecutionExceptionHandler</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReflectiveInvocationContext</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ScriptEvaluationException</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TestInstanceFactory</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TestInstanceFactoryContext</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TestInstances</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TestInstantiationException</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.extension</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TestWatcher</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.io</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TempDir</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.parallel</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Execution</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.parallel</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExecutionMode</code> <em>（枚举）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.parallel</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceAccessMode</code> <em>（枚举）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.parallel</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLock</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.parallel</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLocks</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.parallel</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resources</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.migrationsupport</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EnableJUnit4MigrationSupport</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.migrationsupport.conditions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IgnoreCondition</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.migrationsupport.rules</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EnableRuleMigrationSupport</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.migrationsupport.rules</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExpectedExceptionSupport</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.migrationsupport.rules</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExternalResourceSupport</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.migrationsupport.rules</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VerifierSupport</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ParameterizedTest</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.aggregator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AggregateWith</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.aggregator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentAccessException</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.aggregator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentsAccessor</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.aggregator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentsAggregationException</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.aggregator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentsAggregator</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentConversionException</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentConverter</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConvertWith</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JavaTimeConversionPattern</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleArgumentConverter</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Arguments</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentsProvider</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentsSource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ArgumentsSources</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CsvFileSource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CsvParsingException</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CsvSource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EmptySource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EnumSource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MethodSource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NullAndEmptySource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NullSource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ValueSource</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.params.support</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationConsumer</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.config</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PrefixedConfigurationParameters</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.discovery</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EngineDiscoveryRequestResolver</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.discovery</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Builder</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.discovery</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InitializationContext</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.discovery</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SelectorResolver</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.discovery</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Context</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.discovery</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Match</code> <em>（班级）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.discovery</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Resolution</code> <em>（班级）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultParallelExecutionConfigurationStrategy</code> <em>（枚举）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExclusiveResource</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ForkJoinPoolHierarchicalTestExecutorService</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HierarchicalTestExecutorService</code> <em>（接口）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExecutionMode</code> <em>（枚举）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Invocation</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ParallelExecutionConfiguration</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ParallelExecutionConfigurationStrategy</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLock</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SameThreadHierarchicalTestExecutorService</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.launcher</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LauncherConstants</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.launcher.core</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LauncherConfig</code> <em>（界面）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.reporting.legacy.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LegacyXmlReportGeneratingListener</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EngineExecutionResults</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EngineTestKit</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Event</code> <em>（班级）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EventConditions</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EventStatistics</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EventType</code> <em>（枚举）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Events</code> <em>（班级）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Execution</code> <em>（班级）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Executions</code> <em>（班级）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TerminationInfo</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.testkit.engine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TestExecutionResultConditions</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.4</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="api-evolution-deprecated-apis"><a class="anchor" href="#api-evolution-deprecated-apis"></a> 7.3。弃用的API</h3>
<div class="paragraph">
<p>下表列出了当前通过<code>@API(status = DEPRECATED)</code>指定为<em>不推荐使用的</em> API。您应该尽可能避免使用已弃用的API，因为这些API很可能会在即将发布的版本中删除。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">包裹名字</th>
<th class="tableblock halign-left valign-top">输入名称</th>
<th class="tableblock halign-left valign-top">以来</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.condition</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisabledIf</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.jupiter.api.condition</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EnabledIf</code> <em>（注释）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.commons.util</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PreconditionViolationException</code> <em>（class）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.filter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClasspathScanningSupport</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.junit.platform.engine.support.hierarchical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SingleTestExecutor</code> <em>（类）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.2</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="api-evolution-tooling"><a class="anchor" href="#api-evolution-tooling"></a> 7.4。@API工具支持</h3>
<div class="paragraph">
<p><a href="https://github.com/apiguardian-team/apiguardian">@API Guardian</a>项目计划为使用<a href="https://apiguardian-team.github.io/apiguardian/docs/current/api/">@API</a>注释的API的发布者和使用者提供工具支持。例如，工具支持可能会提供一种方法来检查是否正在根据<code>@API</code>注释声明使用JUnit API。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributors"><a class="anchor" href="#contributors"></a> 8。贡献者</h2>
<div class="sectionbody">
<div class="paragraph">
<p>直接在GitHub上浏览<a href="https://github.com/junit-team/junit5/graphs/contributors">当前的贡献者列表</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="release-notes"><a class="anchor" href="#release-notes"></a> 9。发行说明</h2>
<div class="sectionbody">
<div class="paragraph">
<p>发行说明可<a href="../release-notes/index.html#release-notes">在此处获得</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a> 10。附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="dependency-metadata"><a class="anchor" href="#dependency-metadata"></a> 10.1。依赖元数据</h3>
<div class="paragraph">
<p>最终版本和里程碑的工件部署到<a href="https://search.maven.org/">Maven Central</a> ，快照工件部署到<a href="https://oss.sonatype.org/content/repositories/snapshots/org/junit/">/ org / junit</a>下的Sonatype的<a href="https://oss.sonatype.org/content/repositories/snapshots">快照存储库</a> 。</p>
</div>
<div class="sect3">
<h4 id="dependency-metadata-junit-platform"><a class="anchor" href="#dependency-metadata-junit-platform"></a> 10.1.1。JUnit平台</h4>
<div class="ulist">
<ul>
<li>
<p><strong>组ID</strong> ： <code>org.junit.platform</code></p>
</li>
<li>
<p><strong>版本</strong> ： <code>1.5.1</code></p>
</li>
<li>
<p><strong>工件ID</strong> ：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>JUnit的平台公地</code></dt>
<dd>
<p>JUnit平台的通用API和支持实用程序。任何使用<code>@API(status = INTERNAL)</code>注释的API仅用于JUnit框架本身。<em>不支持外部方使用内部API！</em></p>
</dd>
<dt class="hdlist1"><code>JUnit的平台控制台</code></dt>
<dd>
<p>支持从控制台在JUnit平台上发现和执行测试。有关详细信息，请参阅<a href="#running-tests-console-launcher">Console Launcher</a> 。</p>
</dd>
<dt class="hdlist1"><code>JUnit的平台，控制台独立</code></dt>
<dd>
<p>包含所有依赖项的可执行JAR在<a href="https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone">junit-platform-console-standalone</a>目录下的Maven Central中提供。有关详细信息，请参阅<a href="#running-tests-console-launcher">Console Launcher</a> 。</p>
</dd>
<dt class="hdlist1"><code>JUnit的平台引擎</code></dt>
<dd>
<p>测试引擎的公共API。有关详细信息，请参阅<a href="#launcher-api-engines-custom">插入自己的测试引擎</a> 。</p>
</dd>
<dt class="hdlist1"><code>JUnit的平台，发射</code></dt>
<dd>
<p>用于配置和启动测试计划的公共API  - 通常由IDE和构建工具使用。有关详细信息，请参阅<a href="#launcher-api">JUnit Platform Launcher API</a> 。</p>
</dd>
<dt class="hdlist1"><code>JUnit的平台 - 报告</code></dt>
<dd>
<p>生成测试报告的<code>TestExecutionListener</code>实现 - 通常由IDE和构建工具使用。有关详细信息，请参阅<a href="#launcher-api-listeners-reporting">JUnit平台报告</a> 。</p>
</dd>
<dt class="hdlist1"><code>JUnit的平台，亚军</code></dt>
<dd>
<p>用于在JUnit 4环境中的JUnit平台上执行测试和测试套件的运行器。有关详细信息，请参阅<a href="#running-tests-junit-platform-runner">使用JUnit 4运行JUnit平台</a> 。</p>
</dd>
<dt class="hdlist1"><code>JUnit的平台套房的API</code></dt>
<dd>
<p>在JUnit平台上配置测试套件的注释。由<a href="#running-tests-junit-platform-runner">JUnitPlatform运行程序</a>支持，可能由第三方<code>TestEngine</code>实现支持。</p>
</dd>
<dt class="hdlist1"><code>JUnit的平台，testkit</code></dt>
<dd>
<p>为执行给定<code>TestEngine</code>的测试计划提供支持，然后通过流畅的API访问结果以验证预期结果。</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dependency-metadata-junit-jupiter"><a class="anchor" href="#dependency-metadata-junit-jupiter"></a> 10.1.2。JUnit Jupiter</h4>
<div class="ulist">
<ul>
<li>
<p><strong>组ID</strong> ： <code>org.junit.jupiter</code></p>
</li>
<li>
<p><strong>版本</strong> ： <code>5.5.1</code></p>
</li>
<li>
<p><strong>工件ID</strong> ：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>JUnit的木星</code></dt>
<dd>
<p>JUnit Jupiter聚合器工件，可传递地依赖<code>junit-jupiter-api</code> ， <code>junit-jupiter-params</code>和<code>junit-jupiter-engine</code>以简化Gradle和Maven等构建工具中的依赖关系管理。</p>
</dd>
<dt class="hdlist1"><code>JUnit的木星-API</code></dt>
<dd>
<p>用于<a href="#writing-tests">编写测试</a>和<a href="#extensions">扩展的</a> JUnit Jupiter API。</p>
</dd>
<dt class="hdlist1"><code>JUnit的木星引擎</code></dt>
<dd>
<p>JUnit Jupiter测试引擎实现;仅在运行时需要。</p>
</dd>
<dt class="hdlist1"><code>JUnit的木星-PARAMS</code></dt>
<dd>
<p>支持JUnit Jupiter中的<a href="#writing-tests-parameterized-tests">参数化测试</a> 。</p>
</dd>
<dt class="hdlist1"><code>JUnit的木星，migrationsupport</code></dt>
<dd>
<p>支持从JUnit 4迁移到JUnit Jupiter;仅支持JUnit 4的<code>@Ignore</code>注释以及运行选定的JUnit 4规则。</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dependency-metadata-junit-vintage"><a class="anchor" href="#dependency-metadata-junit-vintage"></a> 10.1.3。JUnit Vintage</h4>
<div class="ulist">
<ul>
<li>
<p><strong>组ID</strong> ： <code>org.junit.vintage</code></p>
</li>
<li>
<p><strong>版本</strong> ： <code>5.5.1</code></p>
</li>
<li>
<p><strong>工件ID</strong> ：</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>JUnit的复古引擎</code></dt>
<dd>
<p>JUnit Vintage测试引擎实现，允许在JUnit平台上运行<em>复古</em> JUnit测试。<em>Vintage</em>测试包括使用JUnit 3或JUnit 4 API编写的测试或使用基于这些API构建的测试框架编写的测试。</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dependency-metadata-junit-bom"><a class="anchor" href="#dependency-metadata-junit-bom"></a> 10.1.4。物料清单（BOM）</h4>
<div class="paragraph">
<p>在使用<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies">Maven</a>或<a href="https://docs.gradle.org/current/userguide/managing_transitive_dependencies.html#sec:bom_import">Gradle</a>引用多个上述工件时，可以使用以下Maven坐标下提供<em>的物料清单</em> POM来简化依赖关系管理。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>组ID</strong> ： <code>org.junit</code></p>
</li>
<li>
<p><strong>工件ID</strong> ： <code>junit-bom</code></p>
</li>
<li>
<p><strong>版本</strong> ： <code>5.5.1</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dependency-metadata-dependencies"><a class="anchor" href="#dependency-metadata-dependencies"></a> 10.1.5。依赖</h4>
<div class="paragraph">
<p>上面的大多数工件在他们发布的Maven POM上都依赖于以下的<em>@API Guardian</em> JAR。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>组ID</strong> ： <code>org.apiguardian</code></p>
</li>
<li>
<p><strong>工件ID</strong> ： <code>apiguardian-api</code></p>
</li>
<li>
<p><strong>版本</strong> ： <code>1.1.0</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，上述大多数工件都对以下<em>OpenTest4J</em> JAR具有直接或传递依赖性。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>组ID</strong> ： <code>org.opentest4j</code></p>
</li>
<li>
<p><strong>工件ID</strong> ： <code>opentest4j</code></p>
</li>
<li>
<p><strong>版本</strong> ： <code>1.2.0</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dependency-diagram"><a class="anchor" href="#dependency-diagram"></a> 10.2。依赖关系图</h3>
<div class="imageblock">
<div class="content">
<img src="images/component-diagram.svg" alt="组件图" width="1746" height="596">
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.5.1<br>最后更新2019-06-25 12:32:15 CEST</div>
</div>
<script src="../tocbot-3.0.2/tocbot.min.js"></script>
<script>
    /* Tocbot dynamic TOC, works with tocbot 3.0.2 */
    /* Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006 */
    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();
</script>
</body>
</html>