<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Reference Documentation</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Good Relationships"><link rel="up" href="reference.html" title="Part&nbsp;II.&nbsp;Reference Documentation"><link rel="prev" href="reference.html" title="Part&nbsp;II.&nbsp;Reference Documentation"><link rel="next" href="neo4j.html" title="Chapter&nbsp;17.&nbsp;Introduction to Neo4j"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://static.springframework.org/spring-ws/site/" title="The Spring Framework - Spring Web Services"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/s2_box_logo.png"></a></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:preface"></a>Reference Documentation</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e843"></a>1.&nbsp;Spring Data and Spring Data Graph</h2></div></div></div><p>
            <a class="ulink" href="http://springsource.org/spring-data" target="_top">Spring Data</a> is a SpringSource project that aims to
            provide Spring's convenient programming model and well known conventions for NOSQL databases. Currently there
            is support for graph (Neo4j), key-value (Redis, Riak), document (MongoDB) and relational (Oracle)
            databases. Mark Pollack, the author of Spring.NET, is the project lead for the Spring Data project.
        </p><p>
            The Spring Data Graph project, as part of the Spring Data initiative, aims to simplify development
            with the Neo4j graph database. Like JPA, it uses annotations on simple POJO domain objects.
            The annotations activate the AspectJ aspects in the Spring Data Graph framework, mapping the POJO entities
            and their fields to nodes, relationships, and properties in the graph database.
        </p><p>
            Spring Data Graph allows, at anytime, to drop down to the <a class="xref" href="neo4j.html" title="Chapter&nbsp;17.&nbsp;Introduction to Neo4j">Chapter&nbsp;17, <i>Introduction to Neo4j</i></a> level to execute functionality with
            the highest performance possible.
        </p><p>
            For Integration of Neo4j and Grails/GORM please refer to the Neo4j
            <a class="ulink" href="http://www.grails.org/plugin/neo4j" target="_top">grails plugin</a>. For other language bindings or frameworks
            visit the <a class="ulink" href="http://wiki.neo4j.org/content/Main_Page#Language_and_framework_bindings" target="_top">Neo4j Wiki</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e866"></a>2.&nbsp;Reference Documentation Overview</h2></div></div></div><p>
        The explanation of Spring Data Graphs programming model starts with some underlying details.
        The basic internal workings of Spring Data Graph are explained in the initial chapter about AspectJ <a class="xref" href="programming-model.html#reference:aspectj" title="18.1.&nbsp;AspectJ support">Section&nbsp;18.1, &#8220;AspectJ support&#8221;</a>.
        It also explains some of the common issues around AspectJ tooling with the current IDEs.
    </p><p>
        To get started with a simple application, you need only your domain model and the annotations
        (see <a class="xref" href="programming-model.html#reference:programming-model:annotations" title="18.2.&nbsp;Defining node entities">Section&nbsp;18.2, &#8220;Defining node entities&#8221;</a>) provided by the library. You use annotations to
        mark domain objects to be backed by nodes and relationships of the graph database. For individual fields the
        annotations allow you to declare how they should be processed and mapped to the graph. For property fields and
        references to other entities this is straightforward.
    </p><p>
        To use advanced functionality like traversals, Cypher and Gremlin, a basic understanding of the graph data model is required.
        The graph data model is explained in the chapter about <a class="xref" href="neo4j.html" title="Chapter&nbsp;17.&nbsp;Introduction to Neo4j">Chapter&nbsp;17, <i>Introduction to Neo4j</i></a>.
    </p><p>
        Relationships between entities are first class citizens in a graph database and therefore worth a separate
        <a class="xref" href="programming-model.html#reference:programming_model:relationships" title="18.3.&nbsp;Relating node entities">Section&nbsp;18.3, &#8220;Relating node entities&#8221;</a> describing their usage in Spring Data Graph.
    </p><p>
        To add fields that are just backed by graph operations is a bit more involved. First you should know
        about traversals, Cypher queries and Gremlin expressions.
        Those are explained in the <a class="xref" href="neo4j.html" title="Chapter&nbsp;17.&nbsp;Introduction to Neo4j">Chapter&nbsp;17, <i>Introduction to Neo4j</i></a> chapter. Then you can start adding purely
        dynamically gathered fields to your entities.
    </p><p>
        You might probably use the additional
        entity methods (see <a class="xref" href="programming-model.html#reference:programming-model:introduced-methods" title="18.4.&nbsp;Introduced methods">Section&nbsp;18.4, &#8220;Introduced methods&#8221;</a>) that are added to your
        domain objects by Spring Data Graph. Those allow you to manage the entity lifecycles as well as to connect entities.
        Those methods also provide the means to execute the mentioned graph operations with your entity as a starting point.
    </p><p>
        Indexing operations are useful for finding individual nodes and relationships in a graph. They can be used to
        start graph operations or to be processed in your application. Indexing in the plain Neo4j API is a bit more involved.
        Spring Data Graph maintains automatic indexes per entity class, with @Indexed annotations on relevant fields.
        (<a class="xref" href="programming-model.html#reference:programming-model:indexing" title="18.5.&nbsp;Indexing">Section&nbsp;18.5, &#8220;Indexing&#8221;</a>)
    </p><p>
        If you don't want to go the path of persistence aware domain objects (Active-Record) but rather use a DAO layer,
        Spring Data Commons provides a repository abstraction that is also implemented in Spring Data Graph. Those repositories
        just consist of a composition of interfaces that declare the available methods on the concrete repository. The implementation
        details are handled by the library. At least for typical CRUD, Index- and Query-operatoins that is very convenient.
        For custom implementations of repository methods you are free to add your own code. (<a class="xref" href="programming-model.html#reference:programming-model:repositories" title="18.6.&nbsp;CRUD with repositories">Section&nbsp;18.6, &#8220;CRUD with repositories&#8221;</a>).
    </p><p>
        Neo4j is an ACID database, it uses Java transactions (and internally even a 2 phase commit protocol) to guarantee the
        safety of your data. The implications of that are described in the chapter around transactions. (<a class="xref" href="programming-model.html#reference:programming-model:transactions" title="18.7.&nbsp;Transactions">Section&nbsp;18.7, &#8220;Transactions&#8221;</a>)
    </p><p>
        The need of an active transaction for mutating the state of nodes or relationships implies that direct changes to
        the graph are only possible in a transactional context. Unfortunately many higher level application layers don't
        want to care about transactions and the open-session-in-view pattern is not widely used. Therefore Spring Data
        Graph introduced an entity lifecyle and added support for detached entities which can be used for temporary
        domain objects that are not intended to be stored in the graph or which will be attached to the graph only later.
        (<a class="xref" href="programming-model.html#reference:programming-model:lifecycle" title="18.8.&nbsp;Detached node entities">Section&nbsp;18.8, &#8220;Detached node entities&#8221;</a>)
    </p><p>
        Unlike Neo4j which is a schema free database, Spring Data Graph works on Java domain objects. So it needs to store
        the type information of the entities in the graph to be able to reconstruct them when just nodes are retrieved. To
        achieve that it employs type-representation-strategies which are described in a separate chapter.
        (<a class="xref" href="programming-model.html#reference:programming-model:typerepresentationstrategy" title="18.9.&nbsp;Entity type representation">Section&nbsp;18.9, &#8220;Entity type representation&#8221;</a>)
    </p><p>
        To be able to leverage the schema-free nature of Neo4j it is possible to project any entity to another entity type. That
        is useful as long as they share some properties (or relationships). The entities don't have to share any super-types
        or hierarchies. How that works is explained here: <a class="xref" href="programming-model.html#reference:programming-model:projection" title="18.10.&nbsp;Projecting entities">Section&nbsp;18.10, &#8220;Projecting entities&#8221;</a>.
    </p><p>
        Spring Data Graph offers basic support for bean property validation (JSR-303). Annotations from that JSR are recognized
        and evaluated whenever a property is set, or when a previously detached entity is persisted to the graph.
        (see <a class="xref" href="programming-model.html#reference:programming-model:validation" title="18.11.&nbsp;Bean validation (JSR-303)">Section&nbsp;18.11, &#8220;Bean validation (JSR-303)&#8221;</a>)
    </p><p>
        Unfortunately the setup of Spring Data Graph is more involved than we'd like. That is partly due to the maven setup
        and dependencies, which can be alleviated by using different build systems like gradle or ant/ivy. The Spring configuration
        itself boils down to two lines of <code class="code">&lt;datagraph&gt;</code> namespace setup. (see <a class="xref" href="setup.html" title="Chapter&nbsp;19.&nbsp;Environment setup">Chapter&nbsp;19, <i>Environment setup</i></a>)
    </p><p>
        Spring Data Graph can also be used in a JPA environment to add graph features to your JPA entities. In the <a class="xref" href="reference:cross-store.html" title="Chapter&nbsp;20.&nbsp;Cross-store persistence">Chapter&nbsp;20, <i>Cross-store persistence</i></a>
        the slightly different behavior and setup of a Graph-JPA interaction are described.
    </p><p>
        The provided samples, which are also publicly hosted on <a class="ulink" href="http://github.com/springsource/spring-data-graph-examples" target="_top">github</a> are explained in
        <a class="xref" href="reference:samples.html" title="Chapter&nbsp;21.&nbsp;Sample code">Chapter&nbsp;21, <i>Sample code</i></a>.
    </p><p>
        The performance implications of using Spring Data Graph are detailed in <a class="xref" href="reference:performance.html" title="Chapter&nbsp;22.&nbsp;Performance considerations">Chapter&nbsp;22, <i>Performance considerations</i></a>. This chapter also discusses
        which usecases should be handled with Spring Data Graph and when it should not be used.
    </p><p>
        Being a Spring Data library, Spring Data Graph also implements a comprehensive template for interacting with the Neo4j graph database.
        The <a class="xref" href="reference:template.html" title="Chapter&nbsp;23.&nbsp;Neo4jTemplate">Chapter&nbsp;23, <i>Neo4jTemplate</i></a> provides all basic graph operations as well as advanced querying with
        Indexes, Cypher, Gremlin and Traversals with a convenient API.
    </p><p>
        As AspectJ might not come that easy to everyone, some of the core concepts of this Aspect oriented programming implementation for Java
        are explained in <a class="xref" href="reference:aspectj-details.html" title="Chapter&nbsp;24.&nbsp;AspectJ details">Chapter&nbsp;24, <i>AspectJ details</i></a>.
    </p><p>
        How to consume the REST-API of a Neo4j-Server is the topic of <a class="xref" href="reference:neo4j-server.html" title="Chapter&nbsp;25.&nbsp;Neo4j Server">Chapter&nbsp;25, <i>Neo4j Server</i></a>. But Spring Data Graph can also
        be used to create custom Extensions for the Neo4j Server which would serve domain model abstractions to a suitable front-end. So instead of
        talking low level primitives to a database, the front-end would communicate via a domain level protocol with endpoints implemented
        in Jersey and Spring Data Graph.
    </p><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
               As Spring Data Graph is based on AspectJ and uses some advanced features of that toolset, please
                be aware of that. Please see the section on AspectJ (<a class="xref" href="programming-model.html#reference:aspectj" title="18.1.&nbsp;AspectJ support">Section&nbsp;18.1, &#8220;AspectJ support&#8221;</a>) for
                details if you run into any problems.
            </p></div><p>
    </p></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="reference.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="neo4j.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;II.&nbsp;Reference Documentation&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource
                                        </a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;17.&nbsp;Introduction to Neo4j</td></tr></table></div></body></html>