<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;17.&nbsp;Introduction to Neo4j</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Good Relationships"><link rel="up" href="reference.html" title="Part&nbsp;II.&nbsp;Reference Documentation"><link rel="prev" href="reference:preface.html" title="Reference Documentation"><link rel="next" href="programming-model.html" title="Chapter&nbsp;18.&nbsp;Programming model"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://static.springframework.org/spring-ws/site/" title="The Spring Framework - Spring Web Services"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/s2_box_logo.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="neo4j"></a>Chapter&nbsp;17.&nbsp;Introduction to Neo4j</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e970"></a>17.1.&nbsp;What is a graph database?</h2></div></div></div><p>
            A graph database is a storage engine that is specialized in storing and retrieving vast networks of
            data. It efficiently stores nodes and relationships and allows high performance traversal of those
            structures. Properties can be added to nodes and relationships.
        </p><p>
            Graph databases are well suited for storing most kinds of domain models. In almost all domain models,
            there are certain things connected to other things. In most other modeling approaches, the relationships
            between things are reduced to a single link without identity and attributes. Graph databases allow one
            to keep the rich relationships that originate from the domain, equally well-represented in the database
            without resorting to also modeling the relationships as "things". There is very little "impedance
            mismatch" when putting real-life domains into a graph database.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e977"></a>17.2.&nbsp;About Neo4j</h2></div></div></div><p>
            <a class="ulink" href="http://neo4j.org/" target="_top">Neo4j</a> is a graph database. It is a fully transactional database
            (ACID) that stores data structured as graphs. A graph consists of nodes, connected by relationships.
            Inspired by the structure of the human brain, it allows for high query performance on complex data,
            while remaining intuitive and simple for the developer.
        </p><p>
            Neo4j has been in commercial development for 10 years and in production for over 7 years.
            Most importantly it has a helpful and contributing community surrounding it, but it also:
            </p><div class="itemizedlist"><ul type="disc"><li>has an intuitive graph-oriented model for data representation. Instead of tables, rows,
                and columns, you work with a graph consisting of
                <a class="ulink" href="http://wiki.neo4j.org/content/Getting_Started" target="_top">nodes, relationships, and properties</a>.
            </li><li>has a disk-based, native storage manager optimized for storing graph structures
                with maximum performance and scalability.
            </li><li>is scalable. Neo4j can handle graphs with many billions of nodes/relationships/properties on
                a single machine, but can also be scaled out across multiple machines for high availability.
            </li><li>has a powerful traversal framework for traversing in the node space.
            </li><li>can be deployed as a standalone server or an embedded database with a very small
                distribution footprint (~700k jar).
            </li><li>has a Java <a class="ulink" href="http://api.neo4j.org/" target="_top">API</a>.
            </li></ul></div><p>
        </p><p>
            In addition, Neo4j has ACID transactions, durable persistence, concurrency control, transaction
            recovery, high availability, and more. Neo4j is released under a dual free software/commercial
            license model.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1009"></a>17.3.&nbsp;GraphDatabaseService</h2></div></div></div><p>
            The interface <code class="code">org.neo4j.graphdb.GraphDatabaseService</code> provides access to the
            storage engine. Its features include creating and retrieving nodes and relationships, managing
            indexes (via the IndexManager), database life cycle callbacks, transaction management, and more.
		</p><p>
			The <code class="code">EmbeddedGraphDatabase</code> is an implementation of GraphDatabaseService that is used to
            embed Neo4j in a Java application.  This implementation is used so as to provide the highest
            and tightest integration with the database. Besides the embedded mode, the
            <a class="ulink" href="http://wiki.neo4j.org/content/Getting_Started_With_Neo4j_Server" target="_top">Neo4j server</a>
            provides access to the graph database via an HTTP-based REST API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1025"></a>17.4.&nbsp;Creating nodes and relationships</h2></div></div></div><p>
            Using the API of GraphDatabaseService, it is easy to create nodes and relate them to each other.
            Relationships are typed. Both nodes and relationships can have properties. Property values can be
            primitive Java types and Strings, or arrays of Java primitives or Strings. Node creation and
            modification has to happen within a transaction, while reading from the graph store can be
            done with or without a transaction.
        </p><div class="example"><a name="d0e1030"></a><p class="title"><b>Example&nbsp;17.1.&nbsp;Neo4j usage</b></p><div class="example-contents"><pre class="programlisting">GraphDatabaseService graphDb = <span class="hl-keyword">new</span> EmbeddedGraphDatabase( <span class="hl-string">"helloworld"</span> );
Transaction tx = graphDb.beginTx();
<span class="hl-keyword">try</span> {
	Node firstNode = graphDb.createNode();
	Node secondNode = graphDb.createNode();
	firstNode.setProperty( <span class="hl-string">"message"</span>, <span class="hl-string">"Hello, "</span> );
	secondNode.setProperty( <span class="hl-string">"message"</span>, <span class="hl-string">"world!"</span> );

	Relationship relationship = firstNode.createRelationshipTo( secondNode,
		DynamicRelationshipType.of(<span class="hl-string">"KNOWS"</span>) );
	relationship.setProperty( <span class="hl-string">"message"</span>, <span class="hl-string">"brave Neo4j "</span> );
	tx.success();
} <span class="hl-keyword">finally</span> {
	tx.finish();
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1035"></a>17.5.&nbsp;Graph traversal</h2></div></div></div><p>
            Getting a single node or relationship and examining it is not the main use case of a graph database.
            Fast graph traversal and application of graph algorithms are. Neo4j provides a DSL for defining
            <code class="code">TraversalDescription</code>s that can then be applied to a start node and will produce a
            lazy <code class="code">java.lang.Iterable</code> result of nodes and/or relationships.
        </p><div class="example"><a name="d0e1046"></a><p class="title"><b>Example&nbsp;17.2.&nbsp;Traversal usage</b></p><div class="example-contents"><pre class="programlisting">TraversalDescription traversalDescription = Traversal.description()
        .depthFirst()
        .relationships(KNOWS)
        .relationships(LIKES, Direction.INCOMING)
        .evaluator(Evaluators.toDepth(5));
<span class="hl-keyword">for</span> (Path position : traversalDescription.traverse(myStartNode)) {
    System.out.println(<span class="hl-string">"Path from start node to current position is "</span> + position);
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1051"></a>17.6.&nbsp;Indexing</h2></div></div></div><p>
            The best way for retrieving start nodes for traversals is by using Neo4j's integrated index
            facilities. The GraphDatabaseService provides access to the IndexManager which in turn provides
            named indexes for nodes and relationships. Both can be indexed with property names and values.
            Retrieval is done with query methods on indexes, returning an IndexHits iterator.
        </p><p>
            Spring Data Graph provides automatic indexing via the @Indexed annotation, eliminating the need
            for manual index management.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            Modifying Neo4j indexes also requires transactions.
        </div><div class="example"><a name="d0e1060"></a><p class="title"><b>Example&nbsp;17.3.&nbsp;Index usage</b></p><div class="example-contents"><pre class="programlisting">IndexManager indexManager = graphDb.index();
Index&lt;Node&gt; nodeIndex = indexManager.forNodes(<span class="hl-string">"a-node-index"</span>);
Node node = ...;
Transaction tx = graphDb.beginTx();
<span class="hl-keyword">try</span> {
    nodeIndex.add(node, <span class="hl-string">"property"</span>,<span class="hl-string">"value"</span>);
    tx.success();
} <span class="hl-keyword">finally</span> {
    tx.finish();
}
<span class="hl-keyword">for</span> (Node foundNode : nodeIndex.get(<span class="hl-string">"property"</span>,<span class="hl-string">"value"</span>)) {
    <span class="hl-comment">// found node</span>
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1065"></a>17.7.&nbsp;Querying with Cypher</h2></div></div></div><p>
            With version 1.4.M04 Neo4j introduced a textual query language called
            <a class="ulink" href="http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html" target="_top">"Cypher"</a> which draws from many
            sources. From graph matching like in SPARQL, some keywords and query structure that reminds of SQL and
            some iconic representation. A screencast presenting cypher queries on the cineasts.net dataset is available
            at <a class="ulink" href="http://video.neo4j.org/U2Y/introduction-to-cypher" target="_top">video.neo4j.org</a>. Cypher was written
            in Scala to leverage the high expressiveness for lazy sequence operations of the language and the great
            parser combinator library.
        </p><p>
            Cypher queries always begin with a <code class="code">start</code> set of nodes. Those can be either expressed by their
            id's or by a index lookup expression. Those start-nodes are then related to other nodes in the
            <code class="code">match</code> clause to other nodes. Start and match clause can introduce new identifiers for nodes and
            relationships. In the <code class="code">where</code> clause additional filtering of the result set is applied by evaluating
            boolean expressions. The <code class="code">return</code> clause defines which part of the query result will be available.
            Aggregation also happens in the return clause by using aggregation functions on some of the values.
            Sorting can happen in the <code class="code">order by</code> clause and the <code class="code">skip</code> and <code class="code">limit</code> parts
            restrict the result set to a certain window.
        </p><p>
            Cypher can be executed on an embedded graph db using <code class="code">ExecutionEngine</code> and
            <code class="code">CypherParser</code>. This is encapsulated in Spring Data Graph with
            <code class="code">CypherQueryEngine</code>. The Neo4j-REST-Server comes with a Cypher-Plugin that is accessible remotely and is
            available in the Spring Data Graph REST-Binding.
        </p><div class="example"><a name="d0e1110"></a><p class="title"><b>Example&nbsp;17.4.&nbsp;Cypher Examples on the Cineasts.net Dataset</b></p><div class="example-contents"><pre class="programlisting">
// Actors of Forrest Gump:
start movie=(Movie,id,'13') match (movie)&lt;-[:ACTS_IN]-(actor)
    return actor.name, actor.birthplace?

// User-Ratings:
start user=(User,login,'micha') match (user)-[r,:RATED]-&gt;(movie) where r.stars &gt; 3
    return movie.title, r.stars, r.comment

// Mutual Friend recommendations:
start user=(User,login,'micha') match (user)-[:FRIEND]-(friend)-[r,:RATED]-&gt;(movie) where r.stars &gt; 3
    return friend.name, movie.title, r.stars, r.comment?

// Movie suggestions based on a movie:
start movie=(Movie,id,'13') match (movie)&lt;-[:ACTS_IN]-()-[:ACTS_IN]-&gt;(suggestion)
    return suggestion.title, count(*) order by count(*) desc limit 5

// Co-Actors, sorted by count and name of Lucy Liu
start lucy=(1000) match (lucy)-[:ACTS_IN]-&gt;(movie)&lt;-[:ACTS_IN]-(co_actor)
    return count(*), co_actor.name order by count(*) desc,co_actor.name limit 20

// recommendations including counts, grouping and sorting
start user=(User,login,'micha') match (user)-[:FRIEND]-(friend)-[r,:RATED]-&gt;(movie)
    return movie.title, AVG(r.stars), count(*) order by AVG(r.stars) desc, count(*) desc
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1115"></a>17.8.&nbsp;Gremlin a Graph Traversal DSL</h2></div></div></div><p>
            Gremlin is an expressive Groovy DSL developed by <a class="ulink" href="http://markorodriguez.com" target="_top">Marko Rodriguez</a>
            as part of the <a class="ulink" href="http://tinkerpop.com" target="_top">tinkerpop</a> stack. It builds on top of a pipe implementation
            (Blueprints Pipes) that uses connected operations to traverse a graph. Gremlin has a concise syntax but is
            turing complete.
        </p><p>Gremlin can be executed by including the tinkerpop and blueprints dependencies and then requesting a <code class="code">ScriptEngine</code>
        of type "gremlin" from the <code class="code">javax.Script*</code> facilities. In Spring Data Graph this is encapsulated in
        <code class="code">GremlinQueryEngine</code>. The Neo4j-REST-Server also comes with a Gremlin-Plugin that is accessible remotely and is
            available in the Spring Data Graph REST-Binding.
        </p><div class="example"><a name="d0e1137"></a><p class="title"><b>Example&nbsp;17.5.&nbsp;Sample Gremlin Queries</b></p><div class="example-contents"><pre class="programlisting">
// Vertex with id 1
v = g.v(1)

// determine the name of the vertices that vertex 1 knows and that are older than 30 years of age
v.outE{it.label=='knows'}.inV{it.age &gt; 30}.name

// calculate basic collaborative filtering for vertex 1
m = [:]
g.v(1).out('likes').in('likes').out('likes').groupCount(m)
m.sort{a,b -&gt; a.value &lt;=&gt; b.value}
</pre></div></div><br class="example-break"></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="reference:preface.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="programming-model.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Reference Documentation&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource
                                        </a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;18.&nbsp;Programming model</td></tr></table></div></body></html>