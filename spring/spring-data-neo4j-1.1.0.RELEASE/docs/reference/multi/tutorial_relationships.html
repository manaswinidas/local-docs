<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;9.&nbsp;Relationships</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Good Relationships"><link rel="up" href="tutorial.html" title="Part&nbsp;I.&nbsp;Tutorial"><link rel="prev" href="tutorial_repository.html" title="Chapter&nbsp;8.&nbsp;Repositories"><link rel="next" href="tutorial_running.html" title="Chapter&nbsp;10.&nbsp;Get it running"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://static.springframework.org/spring-ws/site/" title="The Spring Framework - Spring Web Services"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/s2_box_logo.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_relationships"></a>Chapter&nbsp;9.&nbsp;Relationships</h2></div><div><h3 class="subtitle"><i>A convincing act</i></h3></div></div></div><p>
        Our application was not yet very much fun yet, just storing movies and actors. After all,
        the power is in the relationships between them. Fortunately, Neo4j treats relationships as first class citizens,
        allowing them to be addressed individually and assigned properties. That allows for representing them as entities
        if needed.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e417"></a>9.1.&nbsp;Creating relationships</h2></div></div></div><p>
            Relationships without properties ("anonymous" relationships) don't require any @RelationshipEntity
            classes. Unfortunately we had none of those, because our relationships were richer.
            Therefore we went with the Role relationship between Movie and Actor.
            It had to be annotated with @RelationshipEntity and the @StartNode and @EndNode had to be marked.
            So our Role looked like this:
        </p><p>
            </p><div class="mediaobject" align="center"><img src="relationship.png" align="middle"></div><p>
        </p><p>
            </p><div class="example"><a name="d0e430"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;Role class</b></p><div class="example-contents"><pre class="programlisting">@RelationshipEntity
<span class="hl-keyword">class</span> Role {
    @StartNode Actor actor;
    @EndNode Movie movie;
    String role;
}
</pre></div></div><p><br class="example-break">
        </p><p>
            When writing a test for that we tried to create the relationship entity with the <code class="code">new</code>
            keyword, but we got an exception saying that it was not allowed. At first this surprised us, but
            then we realized that a relationship entity must have a starting entity and ending entity. It
            turned out that the aspect had introduced a <code class="code">entity.relateTo</code> method in the node entities.
            It turned out to be exactly what we needed. We simply added a method to the Actor class, connecting
            it to movies.
        </p><p>
            </p><div class="example"><a name="d0e446"></a><p class="title"><b>Example&nbsp;9.2.&nbsp;Relating actors to movies</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">class</span> Actor {
...
    <span class="hl-keyword">public</span> Role playedIn(Movie movie, String roleName) {
        Role role = relateTo(movie, Role.<span class="hl-keyword">class</span>, <span class="hl-string">"ACTS_IN"</span>);
        role.setRole(roleName);
        <span class="hl-keyword">return</span> role;
    }
}
</pre></div></div><p><br class="example-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e452"></a>9.2.&nbsp;Accessing related entities</h2></div></div></div><p>
            Now we wanted to find connected entities.
            We already had fields for the relationships in both classes. It was time to annotate them
            correctly. It turned out that we needed to provide the target type of the fields again, due to
            Java's type erasure. The Neo4j relationship type and direction were easy to figure out.
            The direction even defaulted to outgoing, so we only had to specify it for the movie.
        </p><p>
            </p><div class="example"><a name="d0e459"></a><p class="title"><b>Example&nbsp;9.3.&nbsp;@RelatedTo usage</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Movie {
    @Indexed <span class="hl-keyword">int</span> id;
    String title;
    <span class="hl-keyword">int</span> year;
    @RelatedTo(elementClass = Actor.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>, direction = Direction.INCOMING)
    Set&lt;Actor&gt; cast;
}

@NodeEntity
<span class="hl-keyword">class</span> Actor {
    @Indexed <span class="hl-keyword">int</span> id;
    String name;
    @RelatedTo(elementClass = Movie.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>)
    Set&lt;Movie&gt; movies;

    <span class="hl-keyword">public</span> Role playedIn(Movie movie, String roleName) {
        Role role = relateTo(movie, Role.<span class="hl-keyword">class</span>, <span class="hl-string">"ACTS_IN"</span>);
        role.setRole(roleName);
        <span class="hl-keyword">return</span> role;
    }
}
</pre></div></div><p><br class="example-break">
        </p><p>
            While reading about these relationship collections, we learned that they are actually
            Spring Data Graph-managed sets. So whenever we add or remove something from the set,
            it automatically gets reflected in the underlying relationships. That's neat! But this
            also meant we did not need to initialize the fields. That could be easy to forget.
        </p><p>
            We made sure to add a test for those, so we were assured that the collections worked as
            advertised.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e469"></a>9.3.&nbsp;Accessing the relationship entities</h2></div></div></div><p>
            But we still couldn't access the Role relationships. It turned out that there was a separate
            annotation <code class="code">@RelatedToVia</code> for accessing the actual relationship entities. And we had
            to declare the field as an Iterable&lt;Role&gt;, with read-only semantics. This appeared to mean
            that we were not able to add new roles through the field. Adding relationship entities seemed like
            it had to be done by using <code class="code">entity.relateTo()</code>. The annotation attributes were similar to
            those used for <code class="code">@RelatedTo</code>. So off we went, creating our first real relationship (just kidding).
        </p><p>
            </p><div class="example"><a name="d0e485"></a><p class="title"><b>Example&nbsp;9.4.&nbsp;@RelatedToVia usage</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Movie {
    @Indexed <span class="hl-keyword">int</span> id;
    String title;
    <span class="hl-keyword">int</span> year;
    @RelatedTo(elementClass = Actor.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>, direction = Direction.INCOMING)
    Set&lt;Actor&gt; cast;

    @RelatedToVia(elementClass = Role.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>, direction = Direction.INCOMING)
    Iterable&lt;Roles&gt; roles;
}
</pre></div></div><p><br class="example-break">
        </p><p>
            After watching the tests pass, we were confident that the relationship fields really mirrored
            the underlying relationships in the graph. We were pretty satisfied with our domain.
        </p></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial_repository.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="tutorial_running.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;8.&nbsp;Repositories&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource
                                        </a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;10.&nbsp;Get it running</td></tr></table></div></body></html>