<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;6.&nbsp;Annotating the domain</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Good Relationships"><link rel="up" href="tutorial.html" title="Part&nbsp;I.&nbsp;Tutorial"><link rel="prev" href="tutorial_about-spring-data.html" title="Chapter&nbsp;5.&nbsp;Spring Data Graph"><link rel="next" href="tutorial_indexing.html" title="Chapter&nbsp;7.&nbsp;Indexing"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://static.springframework.org/spring-ws/site/" title="The Spring Framework - Spring Web Services"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/s2_box_logo.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_annotations"></a>Chapter&nbsp;6.&nbsp;Annotating the domain</h2></div><div><h3 class="subtitle"><i>Decorations</i></h3></div></div></div><p>
        Looking at the Spring Data Graph documentation, we found a simple
        <a class="ulink" href="http://github.com/SpringSource/spring-data-graph-examples/tree/master/hello-worlds" target="_top">Hello World example</a>
        and tried to understand it. The entity classes were annotated with <code class="code">@NodeEntity</code>.
        That was simple, so we added the annotation to our domain classes too. Entity classes representing
        relationships were instead annotated with <code class="code">@RelationshipEntity</code>.
        Property fields were taken care of automatically.
    </p><p>
        It was time to put our entities to a test. How could we now be assured that an attribute really was persisted to
        the graph store? We wanted to load the entity and check the attribute.

        Either we could have a GraphDatabaseContext injected and use its <code class="code">getById(entityId)</code>
        method to load the entity. Or use a more versatile Repository. We decided to keep things simple for now.

        Looking at the documentation revealed that there are a bunch of methods introduced to the
        entities by the aspects to support working with the entities.
        That's not entirely obvious. We found two that would do the job:
        <code class="code">entity.persist()</code> <code class="code">entity.getNodeId()</code>.
    </p><p>
        So here's what our test ended up looking like:
    </p><p>
        </p><div class="example"><a name="d0e341"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;First test case</b></p><div class="example-contents"><pre class="programlisting">@Autowired GraphDatabaseContext graphDatabaseContext;

@Test <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> persistedMovieShouldBeRetrievableFromGraphDb() {
    Movie forrestGump = <span class="hl-keyword">new</span> Movie(<span class="hl-string">"Forrest Gump"</span>, 1994).persist();
    Movie retrievedMovie = graphDatabaseContext.getById(forrestGump.getNodeId());
    assertEqual(<span class="hl-string">"retrieved movie matches persisted one"</span>, forrestGump, retrievedMovie);
    assertEqual(<span class="hl-string">"retrieved movie title matches"</span>, <span class="hl-string">"Forrest Gump"</span>, retrievedMovie.getTitle());
}
</pre></div></div><p><br class="example-break">
    </p><p>
        It worked! But hold on, what about transactions? After all, we had not declared the test to be
        transactional. After some further reading we learned that calling <code class="code">persist()</code> outside
        of a transaction automatically creates an implicit transaction. Very much like an EntityManager
        would behave. We also learned that when performing more complex operations on the entities we'd
        need external transactions, but not for this simple test.
    </p><p>
        </p><div class="example"><a name="d0e354"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;Movie class with annotation</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Movie {
    String id;
    String title;
    <span class="hl-keyword">int</span> year;
    Set&lt;Role&gt; cast;
}
</pre></div></div><p><br class="example-break">
    </p></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial_about-spring-data.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="tutorial_indexing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;5.&nbsp;Spring Data Graph&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource
                                        </a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;7.&nbsp;Indexing</td></tr></table></div></body></html>