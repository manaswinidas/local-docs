<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;24.&nbsp;AspectJ details</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Good Relationships"><link rel="up" href="reference.html" title="Part&nbsp;II.&nbsp;Reference Documentation"><link rel="prev" href="reference:template.html" title="Chapter&nbsp;23.&nbsp;Neo4jTemplate"><link rel="next" href="reference:neo4j-server.html" title="Chapter&nbsp;25.&nbsp;Neo4j Server"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://static.springframework.org/spring-ws/site/" title="The Spring Framework - Spring Web Services"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/s2_box_logo.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:aspectj-details"></a>Chapter&nbsp;24.&nbsp;AspectJ details</h2></div></div></div><p>
        The object graph mapper of Spring Data Graph relies heavily on AspectJ. AspectJ is a Java implementation
        of the <a class="ulink" href="https://secure.wikimedia.org/wikipedia/en/wiki/Aspect-oriented_programming" target="_top">aspect-oriented
        programming</a> paradigm that allows easy extraction and controlled application of so-called
        cross-cutting concerns. Cross-cutting concerns are typically repetitive tasks in a system (e.g. logging,
        security, auditing, caching, transaction scoping) that are difficult to extract using the normal OO
        paradigms. Many OO concepts, such as subclassing, polymorphism, overriding and delegation are still
        cumbersome to use with many of those concerns applied in the code base. Also, the flexibility becomes
        limited, potentially adding quite a number of configuration options or parameters.
    </p><p>
        The AspectJ pointcut language can be intimidating, but a developer using Spring Data Graph will not have
        to deal with that. Users don't have care about to hooking into a framework mechanism, or having to extend
        a framework superclass.
    </p><p>
        AspectJ uses a declarative approach, defining concrete advice, which is just pieces of code that contain
        the implementation of the concern. AspectJ advice can for instance be applied before, after, or instead
        of a method or constructor call. It can also be applied on variable and field access. This is declared
        using AspectJ's expressive pointcut language, able to express any place within a code structure or flow.
        AspectJ is also able to introduce new methods, fields, annotations, interfaces, and superclasses to
        existing classes.
    </p><p>
        Spring Data Graph uses a mix of these mechanisms internally. First, when encountering the
        <code class="code">@NodeEntity</code> or <code class="code">@RelationshipEntity</code> annotations it introduces a new interface
        <code class="code">NodeBacked</code> or <code class="code">RelationshipBacked</code> to the annotated class. Secondly, it introduces
        fields and methods to the annotated class. See <a class="xref" href="programming-model.html#reference:programming-model:introduced-methods" title="18.4.&nbsp;Introduced methods">Section&nbsp;18.4, &#8220;Introduced methods&#8221;</a>
        for more information on the methods introduced.
    </p><p>
        Spring Data Graph also leverages AspectJ to intercept access to fields, delegating the calls to the graph
        database instead. Under the hood, properties and relationships will be created.
    </p><p>
        So how is an aspect applied to a concrete class? At compile time, the AspectJ Java compiler (ajc) takes
        source files and aspect definitions, and compiles the source files while adding all the necessary
        interception code for the aspects to hook in where they're declared to. This is known as compile-time
        <span class="emphasis"><em>weaving</em></span>. At runtime only a small AspectJ runtime is needed, as the byte code of the
        classes has already been rewritten to delegate the appropriate calls via the declared advice in the aspects.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            A caveat of using compile-time weaving is that all source files that should be part of the weaving
            process must be compiled with the AspectJ compiler. Fortunately, this is all taken care of seamlessly
            by the AspectJ Maven plugin.
        </p></div><p>
        AspectJ also supports other types of weaving, e.g. load-time weaving and runtime weaving. These are
        currently not supported by Spring Data Graph.
    </p></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="reference:template.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="reference:neo4j-server.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;23.&nbsp;Neo4jTemplate&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource
                                        </a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;25.&nbsp;Neo4j Server</td></tr></table></div></body></html>