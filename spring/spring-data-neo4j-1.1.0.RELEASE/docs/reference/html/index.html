<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Good Relationships</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Good Relationships</h1></div><div><h2 class="subtitle">The Spring Data Graph Guide Book</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Michael</span> <span class="surname">Hunger</span></span>, <span class="author"><span class="firstname">David</span> <span class="surname">Montag</span></span></div></div><div><p class="releaseinfo">1.1.0.RELEASE</p></div><div><div class="legalnotice"><a name="d0e22"></a><p>
	            Copies of this document may be made for your own use and for distribution
	            to others, provided that you do not charge any fee for such copies and
	            further provided that each copy contains this Copyright Notice, whether
	            distributed in print or electronically.
	        </p><p>
                Copyright 2010-2011 Neo Technology
            </p></div></div></div><hr></div><div class="toc"><dl><dt><span class="preface"><a href="#d0e28">Foreword by Rod Johnson</a></span></dt><dt><span class="preface"><a href="#d0e45">Foreword by Emil Eifrem</a></span></dt><dt><span class="preface"><a href="#d0e60">About this guide book</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e63">1. The Spring Data Graph Project</a></span></dt><dt><span class="section"><a href="#d0e77">2. Feedback</a></span></dt><dt><span class="section"><a href="#d0e96">3. Format of the Book</a></span></dt><dt><span class="section"><a href="#d0e108">4. Acknowledgements</a></span></dt></dl></dd><dt><span class="part"><a href="#tutorial">I. Tutorial</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tutorial_about-tutorial">1. Introducing our project</a></span></dt><dt><span class="chapter"><a href="#tutorial_setup">2. The Spring stack</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e170">2.1. Required setup</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial_domain">3. The domain model</a></span></dt><dt><span class="chapter"><a href="#tutorial_neo4j">4. Learning Neo4j</a></span></dt><dt><span class="chapter"><a href="#tutorial_about-spring-data">5. Spring Data Graph</a></span></dt><dt><span class="chapter"><a href="#tutorial_annotations">6. Annotating the domain</a></span></dt><dt><span class="chapter"><a href="#tutorial_indexing">7. Indexing</a></span></dt><dt><span class="chapter"><a href="#tutorial_repository">8. Repositories</a></span></dt><dt><span class="chapter"><a href="#tutorial_relationships">9. Relationships</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e417">9.1. Creating relationships</a></span></dt><dt><span class="section"><a href="#d0e452">9.2. Accessing related entities</a></span></dt><dt><span class="section"><a href="#d0e469">9.3. Accessing the relationship entities</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial_running">10. Get it running</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e500">10.1. Populating the database</a></span></dt><dt><span class="section"><a href="#d0e529">10.2. Inspecting the datastore</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e534">10.2.1. Neoclipse visualization</a></span></dt><dt><span class="section"><a href="#d0e545">10.2.2. The Neo4j Shell</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#tutorial_webapp">11. Web views</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e595">11.1. Searching</a></span></dt><dt><span class="section"><a href="#d0e613">11.2. Listing results</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial_social">12. Adding social</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e647">12.1. Users</a></span></dt><dt><span class="section"><a href="#d0e670">12.2. Ratings for movies</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial_security">13. Adding Security</a></span></dt><dt><span class="chapter"><a href="#tutorial_user-experience">14. More UI</a></span></dt><dt><span class="chapter"><a href="#tutorial_import">15. Importing Data</a></span></dt><dt><span class="chapter"><a href="#tutorial_recommendations">16. Recommendations</a></span></dt></dl></dd><dt><span class="part"><a href="#reference">II. Reference Documentation</a></span></dt><dd><dl><dt><span class="preface"><a href="#reference:preface">Reference Documentation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e843">1. Spring Data and Spring Data Graph</a></span></dt><dt><span class="section"><a href="#d0e866">2. Reference Documentation Overview</a></span></dt></dl></dd><dt><span class="chapter"><a href="#neo4j">17. Introduction to Neo4j</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e970">17.1. What is a graph database?</a></span></dt><dt><span class="section"><a href="#d0e977">17.2. About Neo4j</a></span></dt><dt><span class="section"><a href="#d0e1009">17.3. GraphDatabaseService</a></span></dt><dt><span class="section"><a href="#d0e1025">17.4. Creating nodes and relationships</a></span></dt><dt><span class="section"><a href="#d0e1035">17.5. Graph traversal</a></span></dt><dt><span class="section"><a href="#d0e1051">17.6. Indexing</a></span></dt><dt><span class="section"><a href="#d0e1065">17.7. Querying with Cypher</a></span></dt><dt><span class="section"><a href="#d0e1115">17.8. Gremlin a Graph Traversal DSL</a></span></dt></dl></dd><dt><span class="chapter"><a href="#programming-model">18. Programming model</a></span></dt><dd><dl><dt><span class="section"><a href="#reference:aspectj">18.1. AspectJ support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1193">18.1.1. AspectJ IDE support</a></span></dt></dl></dd><dt><span class="section"><a href="#reference:programming-model:annotations">18.2. Defining node entities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1242">18.2.1. @NodeEntity: The basic building block</a></span></dt><dt><span class="section"><a href="#d0e1290">18.2.2. @GraphProperty: Optional annotation for property fields</a></span></dt><dt><span class="section"><a href="#d0e1308">18.2.3. @Indexed: Making entities searchable by field value</a></span></dt><dt><span class="section"><a href="#d0e1317">18.2.4. @Query: fields as query result views</a></span></dt><dt><span class="section"><a href="#d0e1347">18.2.5. @GraphTraversal: fields as traversal result views</a></span></dt></dl></dd><dt><span class="section"><a href="#reference:programming_model:relationships">18.3. Relating node entities</a></span></dt><dd><dl><dt><span class="section"><a href="#reference:programming_model:relationships:relatedto">18.3.1. @RelatedTo: Connecting node entities</a></span></dt><dt><span class="section"><a href="#d0e1461">18.3.2. @RelationshipEntity: Rich relationships</a></span></dt><dt><span class="section"><a href="#reference:programming_model:relationships:relatedtovia">18.3.3. @RelatedToVia: Accessing relationship entities</a></span></dt></dl></dd><dt><span class="section"><a href="#reference:programming-model:introduced-methods">18.4. Introduced methods</a></span></dt><dt><span class="section"><a href="#reference:programming-model:indexing">18.5. Indexing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1661">18.5.1. Exact and numeric index</a></span></dt><dt><span class="section"><a href="#d0e1694">18.5.2. Fulltext indexes</a></span></dt><dt><span class="section"><a href="#d0e1726">18.5.3. Manual index access</a></span></dt><dt><span class="section"><a href="#d0e1742">18.5.4. Indexing in Neo4jTemplate</a></span></dt></dl></dd><dt><span class="section"><a href="#reference:programming-model:repositories">18.6. CRUD with repositories</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1810">18.6.1. CRUDRepository</a></span></dt><dt><span class="section"><a href="#d0e1903">18.6.2. IndexRepository and NamedIndexRepository</a></span></dt><dt><span class="section"><a href="#d0e1949">18.6.3. TraversalRepository</a></span></dt><dt><span class="section"><a href="#d0e1966">18.6.4. Cypher-Queries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1969">18.6.4.1. Annotated Queries</a></span></dt><dt><span class="section"><a href="#d0e1992">18.6.4.2. Named Queries</a></span></dt><dt><span class="section"><a href="#d0e2009">18.6.4.3. Query results</a></span></dt><dt><span class="section"><a href="#d0e2017">18.6.4.4. Cypher Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2062">18.6.5. Creating repositories</a></span></dt><dt><span class="section"><a href="#d0e2081">18.6.6. Composing repositories</a></span></dt></dl></dd><dt><span class="section"><a href="#reference:programming-model:transactions">18.7. Transactions</a></span></dt><dt><span class="section"><a href="#reference:programming-model:lifecycle">18.8. Detached node entities</a></span></dt><dd><dl><dt><span class="section"><a href="#reference:programming-model:detached:relating">18.8.1. Relating detached entities</a></span></dt></dl></dd><dt><span class="section"><a href="#reference:programming-model:typerepresentationstrategy">18.9. Entity type representation</a></span></dt><dt><span class="section"><a href="#reference:programming-model:projection">18.10. Projecting entities</a></span></dt><dt><span class="section"><a href="#reference:programming-model:validation">18.11. Bean validation (JSR-303)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#setup">19. Environment setup</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2356">19.1. Gradle configuration</a></span></dt><dt><span class="section"><a href="#d0e2368">19.2. Ant/Ivy configuration</a></span></dt><dt><span class="section"><a href="#d0e2381">19.3. Maven configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2386">19.3.1. Repositories</a></span></dt><dt><span class="section"><a href="#d0e2396">19.3.2. Dependencies</a></span></dt><dt><span class="section"><a href="#d0e2409">19.3.3. AspectJ build configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2419">19.4. Spring configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2424">19.4.1. XML namespace</a></span></dt><dt><span class="section"><a href="#d0e2462">19.4.2. Java-based bean configuration</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#reference:cross-store">20. Cross-store persistence</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2506">20.1. Partial entities</a></span></dt><dt><span class="section"><a href="#d0e2528">20.2. Cross-store annotations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2536">20.2.1. @NodeEntity(partial = "true")</a></span></dt><dt><span class="section"><a href="#d0e2547">20.2.2. @GraphProperty</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2568">20.3. Configuring cross-store persistence</a></span></dt></dl></dd><dt><span class="chapter"><a href="#reference:samples">21. Sample code</a></span></dt><dd><dl><dt><span class="section"><a href="#samples:introduction">21.1. Introduction</a></span></dt><dt><span class="section"><a href="#samples:hello-worlds">21.2. Hello Worlds sample application</a></span></dt><dt><span class="section"><a href="#samples:imdb">21.3. IMDB sample application</a></span></dt><dt><span class="section"><a href="#samples:myrestaurants-original">21.4. MyRestaurants sample application</a></span></dt><dt><span class="section"><a href="#samples:myrestaurants-social">21.5. MyRestaurant-Social sample application</a></span></dt></dl></dd><dt><span class="chapter"><a href="#reference:performance">22. Performance considerations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2654">22.1. When is Spring Data Graph right</a></span></dt></dl></dd><dt><span class="chapter"><a href="#reference:template">23. Neo4jTemplate</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2673">23.1. Basic operations</a></span></dt><dt><span class="section"><a href="#d0e2700">23.2. QueryResult</a></span></dt><dt><span class="section"><a href="#d0e2729">23.3. Indexing</a></span></dt><dt><span class="section"><a href="#d0e2748">23.4. Graph traversal</a></span></dt><dt><span class="section"><a href="#d0e2768">23.5. Cypher Queries</a></span></dt><dt><span class="section"><a href="#d0e2782">23.6. Gremlin Scripts</a></span></dt><dt><span class="section"><a href="#d0e2793">23.7. Transactions</a></span></dt><dt><span class="section"><a href="#d0e2810">23.8. Neo4j REST Server</a></span></dt></dl></dd><dt><span class="chapter"><a href="#reference:aspectj-details">24. AspectJ details</a></span></dt><dt><span class="chapter"><a href="#reference:neo4j-server">25. Neo4j Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2863">25.1. Server Extension</a></span></dt><dt><span class="section"><a href="#d0e2923">25.2. Using Spring Data Graph as a REST client</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e28"></a>Foreword by Rod Johnson</h2></div></div></div><p>
        I&#8217;m excited about Spring Data Graph for several reasons.
    </p><p>
        First, this project is in a very important space. We are in an era of transition. A very few years ago, a
        relational database was a given for storing nearly all the data in nearly all applications. While relational
        databases remain important, new application requirements and massive data proliferation have prompted a richer
        choice of data stores. Graph databases have some very interesting strengths, and Neo4j is proving itself
        valuable in many applications. It's a choice you should add to your toolbox.
    </p><p>
        Second, Spring Data Graph is an innovative project, which makes it easy to work with one of the most interesting
        new data stores. Unfortunately, the proliferation of new data stores has not been matched by innovation in
        programming models to work with them. Ironically, just after modern ORM mapping made working with relational
        data in Java relatively easy, the data store disruption occurred, and developers were back to square one:
        struggling once more with clumsy, low level APIs. Working with most non-relational technologies is overly
        complex and imposes too much work on developers. Spring Data Graph makes working with Neo4j amazingly easy, and
        therefore has the potential to make you more successful as a developer. Its use of AspectJ to eliminate
        persistence code from your domain model is truly innovative, and on the cutting edge of today&#8217;s Java
        technologies.
    </p><p>
        Third, I'm excited about Spring Data Graph for personal reasons. I no longer get to write code as often as I
        would like. My initial convictions that Spring and AspectJ could both make building applications with Neo4j
        dramatically easier and cross-store object navigation possible gave me an excuse for a much-needed coding binge
        early in 2010. This led to a prototype of what became Spring Data Graph &#8212; at times written paired with Emil. I&#8217;m
        sure the vast majority of my code has long since been replaced (probably for the better) by coders who aren't
        rusty &#8212; thanks Michael and Thomas! &#8212; but I retain my pleasant memories.
    </p><p>
        Finally, Spring Data Graph is part of the broader Spring Data project: one of the key areas in which Spring is
        innovating to help meet new application requirements. I encourage you to explore Spring Data, and &#8212; better
        still &#8212; become involved in the community and contribute.
    </p><p>
        Enjoy the Spring Data Graph book, and happy coding!
    </p><p>
        Rod Johnson, Founder, Spring and SVP, Application Platform, VMware
    </p></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e45"></a>Foreword by Emil Eifrem</h2></div></div></div><p>
		"Spring is the most popular middleware on the planet," I thought to myself as I walked up to Rod Johnson in late 2009 at the JAOO conference in Aarhus, Denmark. Rod had just given an introductory presentation about Spring Roo and when he was done I told him "Great talk. You're clearly building a stack for the future. What about support for non-relational databases?"
	</p><p>
		We started talking and quickly agreed that NOSQL will play an important role in emerging stacks. Now, a year and half later, Spring Data Graph is available in its first stable release and I'm blown away by the result. Never before in any environment, in any programming framework, in any stack, has it been so easy and intuitive to tap into the power of a graph database like Neo4j. It's a testament to the efforts by an awesome team of four hackers from Neo Technology and VMware: Michael Hunger, David Montag, Thomas Risberg and Mark Pollack.
	</p><p>
		The Spring framework revolutionized how we all wrote enterprise Java applications and today it's used by millions of enterprise developers. Graph databases also stand out in the NOSQL crowd when it comes to enterprise adoption. You can find graph databases used in areas as diverse as network management, fraud detection, cloud management, anything with social data, geo and location services, master data management, bioinformatics, configuration databases, and much more.
	</p><p>
		Spring developers deserve access to the best tools available to solve their problem. Sometimes that's a relational database accessed through JPA. But more often than not, a graph database like Neo4j is the perfect fit for your project. I hope that Spring Data Graph will give you access to the power and flexibility of graph databases while retaining the familiar productivity and convenience of the Spring framework.
	</p><p>
		Enjoy the Spring Data Graph guide book and welcome to the wonderful world of graph databases!
	</p><p>
       Emil Eifrem, CEO of Neo Technology
    </p></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e60"></a>About this guide book</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e63"></a>1.&nbsp;The Spring Data Graph Project</h2></div></div></div><p>
            Welcome to the Spring Data Graph Guide Book. Thank you for taking the time to get an in depth look
            into <a class="ulink" href="https://github.com/SpringSource/spring-data-graph" target="_top">Spring Data Graph</a>.
            This project is part of the <a class="ulink" href="http://springsource.org/spring-data" target="_top">Spring Data project</a>,
            which brings the convenient programming model of the Spring Framework to modern NOSQL databases.
     		Spring Data Graph, as the name alludes to, aims to provide support for graph databases. It currently
            supports <a class="ulink" href="http://neo4j.org" target="_top">Neo4j</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e77"></a>2.&nbsp;Feedback</h2></div></div></div><p>
            It was written by developers for developers. Hopefully we've created a guide that is well received
            by our peers.
        </p><p>
            If you have any feedback on Spring Data Graph or this book, please provide it via the
            <a class="ulink" href="https://jira.springsource.org/browse/DATAGRAPH" target="_top">SpringSource JIRA</a>, the
            <a class="ulink" href="http://forum.springsource.org/forumdisplay.php?f=80" target="_top">SpringSource NOSQL Forum</a>,
            <a class="ulink" href="https://github.com/SpringSource/spring-data-graph/issues" target="_top">github comments or issues</a>,
            or the <a class="ulink" href="http://neo4j.org/community/list/" target="_top">Neo4j mailing list</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e96"></a>3.&nbsp;Format of the Book</h2></div></div></div><p>
            This book is presented as a <a class="ulink" href="http://martinfowler.com/bliki/DuplexBook.html" target="_top">duplex book</a>,
            a term coined by Martin Fowler. A duplex book consists of at least two parts. The first part is an easily
            accessible tutorial that gives the reader an overview of the topics contained in the book. It contains lots
            of examples and discussion topics. This part of the book is highly suited for cover-to-cover reading.
        </p><p>
            We chose a tutorial describing the creation of a web application that allows movie enthusiasts to
            find their favorite movies, rate them, connect with fellow movie geeks, and enjoy social features such as
            recommendations. The application is running on Neo4j using Spring Data Graph and the well-known Spring
            Web Stack.
        </p><p>
            The second part of the book is the classic reference documentation, containing detailed information about
            the library. It discusses the programming model, the underlying assumptions, and internals, as well as the
            APIs for the object-graph mapping. The reference documentation is typically used to look up concrete bits of
            information, or to drill down into certain topics. For hackers wanting to really delve into Spring Data
            Graph, it can of course also be read cover-to-cover.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e108"></a>4.&nbsp;Acknowledgements</h2></div></div></div><p>
            We would like to thank everyone who contributed to this book, especially Mark Pollack and Thomas Risberg,
            the leads of the Spring Data Project, who helped a lot during the development of the library as well as sharing
            great feedback about the book. Also Oliver Gierke, our local German VMWare/SpringSource engineer, who invested a
            lot of time discussing various aspects of the library as well as providing the superb foundations for the Spring
            Data Repositories. We tortured Andy Clement, the AspectJ project lead, with many questions and issues around our
            advanced AspectJ usage which caused some headaches. He always quickly solved our issues and gave us excellent
            answers.
        </p><p>
            We also appreciate very much the foresight of Rod Johnson and Emil Eifrem to initiate the project, and now
            also providing great forewords. Their leadership inspired collaboration between the engineering teams at
            SpringSource and Neo Technology, a tremendous help during the making of Spring Data Graph.
            &nbsp;
        </p>
        &nbsp;
        <p>
            Last but not least we thank our vibrant community, both in the Spring Forums as well as on the Neo4j
            Mailing list and on many other places on the internet for giving us feedback, reporting issues and suggesting
            improvements. Without that important feedback we wouldn't be where we are today.
            &nbsp;
        </p></div>    &nbsp;
    <p>
        Enjoy the book!
    </p></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="tutorial"></a>Part&nbsp;I.&nbsp;Tutorial</h1></div></div></div><div class="partintro" lang="en"><div></div><p>
                </p><div class="mediaobject" align="center"><img src="tutorial/cineasts.png" align="middle" width="432"></div><p>
            </p><p>
                The first part of the book provides a tutorial that walks through the creation of a complete web
                application called cineasts.net, built with Spring Data Graph and Neo4j.
                Cineasts are people who love movies, and the site is a gathering place for moviegoers. For
                cineasts.net we decided to add a social aspect to the rating of movies, allowing friends to
                share their scores and get recommendations for new friends and movies.
            </p><p>
                The tutorial takes the reader through the steps necessary to create the application.
                It provides the configuration and code examples that are needed to understand what's
                happening in Spring Data Graph. The complete source code for the app is available on
                <a class="ulink" href="http://github.com/jexp/cineasts" target="_top">Github</a>.
            </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_about-tutorial"></a>Chapter&nbsp;1.&nbsp;Introducing our project</h2></div><div><h3 class="subtitle"><i>Allow me to introduce Cineasts.net</i></h3></div></div></div><p>
        Once upon a time we wanted to build a social movie database. At first there was only the name: Cineasts,
        the cinema enthusiasts who have a burning passion for movies. So we went ahead and bought the domain
        <a class="ulink" href="http://cineasts.net" target="_top">cineasts.net</a>, and the project was almost done.
    </p><p>
        We had some ideas about the domain model too. There would obviously be actors playing roles in movies.
        We also needed someone to rate the movies - enter the cineast. And cineasts being the social people they are,
        they wanted to make friends with other fellow cineasts. Imagine instantly finding someone to watch a movie
        with, or share movie preferences with. Even better, finding new friends and movies based on what you and
        your friends like.
    </p><p>
        When we looked for possible sources of data, IMDB was our first stop. But they're a bit expensive
        for our taste, charging $15k USD for data access. Fortunately, we found
        <a class="ulink" href="http://themoviedb.org" target="_top">TheMoviedb.org</a> which provides user-generated data for free.
        They also have liberal terms and conditions, and a nice API for retrieving the data.
    </p><p>
        We had many more ideas, but we wanted to get something out there quickly. Here is how we envisioned
        the final website:
    </p><div class="mediaobject" align="center"><img src="cineasts_main.png" align="middle" width="432"></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_setup"></a>Chapter&nbsp;2.&nbsp;The Spring stack</h2></div></div></div><p>
        Being Spring developers, we naturally choose components from the Spring stack to do all the
        heavy lifting. After all, we have the concept etched out, so we're already halfway there.
    </p><p>
        What database would fit both the complex network of cineasts, movies, actors, roles, ratings,
        and friends, while also being able to support the recommendation algorithms that we had in mind?
        We had no idea.
    </p><p>
        But hold your horses, there is this new Spring Data project, started in 2010, which brings
        the convenience of the Spring programming model to NOSQL databases. That should be in line with
        what we already know, providing us with a quick start. We had a look at the list of projects
        supporting the different NOSQL databases out there. Only one of them mentioned the kind of social
        network we were thinking of - Spring Data Graph for Neo4j, a graph database. Neo4j's slogan of
        "value in relationships" and the accompanying docs looked like what we needed.
        We decided to give it a try.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e170"></a>2.1.&nbsp;Required setup</h2></div></div></div><p>
            To set up the project we created a public github account and began setting up the
            infrastructure for a spring web project using Maven as the build system. So we added
            the dependencies for the Spring Framework libraries, added the web.xml for the DispatcherServlet,
            and the applicationContext.xml in the webapp directory.
        </p><p>
            </p><div class="example"><a name="d0e177"></a><p class="title"><b>Example&nbsp;2.1.&nbsp;Project pom.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">properties</span>&gt;
    &lt;<span class="hl-tag">spring.version</span>&gt;3.0.5.RELEASE&lt;<span class="hl-tag">/spring.version</span>&gt;
&lt;<span class="hl-tag">/properties</span>&gt;

&lt;<span class="hl-tag">dependencies</span>&gt;
&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.springframework&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-comment">!-- abbreviated for all the dependencies --</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;spring-(core,context,aop,aspects,tx,webmvc)&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;${spring.version}&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.springframework&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;spring-test&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;${spring.version}&lt;<span class="hl-tag">/version</span>&gt;
    &lt;<span class="hl-tag">scope</span>&gt;test&lt;<span class="hl-tag">/scope</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
&lt;<span class="hl-tag">/dependencies</span>&gt;

&lt;<span class="hl-tag">build</span>&gt;&lt;<span class="hl-tag">plugins</span>&gt;
	&lt;<span class="hl-tag">plugin</span>&gt;
		&lt;<span class="hl-tag">groupId</span>&gt;org.mortbay.jetty&lt;<span class="hl-tag">/groupId</span>&gt;
		&lt;<span class="hl-tag">artifactId</span>&gt;jetty-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
		&lt;<span class="hl-tag">version</span>&gt;7.1.2.v20100523&lt;<span class="hl-tag">/version</span>&gt;
		&lt;<span class="hl-tag">configuration</span>&gt;
		   &lt;<span class="hl-tag">webAppConfig</span>&gt;
		     &lt;<span class="hl-tag">contextPath</span>&gt;/&lt;<span class="hl-tag">/contextPath</span>&gt;
		   &lt;<span class="hl-tag">/webAppConfig</span>&gt;
		&lt;<span class="hl-tag">/configuration</span>&gt;
	&lt;<span class="hl-tag">/plugin</span>&gt;
&lt;<span class="hl-tag">/plugins</span>&gt;&lt;<span class="hl-tag">/build</span>&gt;
</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e183"></a><p class="title"><b>Example&nbsp;2.2.&nbsp;Project web.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">listener</span>&gt;
    &lt;<span class="hl-tag">listener-class</span>&gt;org.springframework.web.context.ContextLoaderListener&lt;<span class="hl-tag">/listener-class</span>&gt;
&lt;<span class="hl-tag">/listener</span>&gt;

&lt;<span class="hl-tag">servlet</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;dispatcherServlet&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">servlet-class</span>&gt;org.springframework.web.servlet.DispatcherServlet&lt;<span class="hl-tag">/servlet-class</span>&gt;
    &lt;<span class="hl-tag">load-on-startup</span>&gt;1&lt;<span class="hl-tag">/load-on-startup</span>&gt;
&lt;<span class="hl-tag">/servlet</span>&gt;

&lt;<span class="hl-tag">servlet-mapping</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;dispatcherServlet&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">url-pattern</span>&gt;/&lt;<span class="hl-tag">/url-pattern</span>&gt;
&lt;<span class="hl-tag">/servlet-mapping</span>&gt;
</pre></div></div><p><br class="example-break">
        </p><p>
            With this setup in place we were ready for the first spike: creating a simple MovieController
            showing a static view. See the Spring Framework documentation for information on doing this.
        </p><p>
            </p><div class="example"><a name="d0e198"></a><p class="title"><b>Example&nbsp;2.3.&nbsp;Project applicationContext.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8" standalone="no"?</span>&gt;
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
	http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
	http://www.springframework.org/schema/tx
	http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;

 &lt;<span class="hl-tag">context:annotation-config</span>/&gt;
 &lt;<span class="hl-tag">context:spring-configured</span>/&gt;
 &lt;<span class="hl-tag">context:component-scan</span> <span class="hl-attribute">base-package</span>=<span class="hl-value">"org.neo4j.cineasts"</span>&gt;
     &lt;<span class="hl-tag">context:exclude-filter</span> <span class="hl-attribute">type</span>=<span class="hl-value">"annotation"</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"org.springframework.stereotype.Controller"</span>/&gt;
 &lt;<span class="hl-tag">/context:component-scan</span>&gt;

 &lt;<span class="hl-tag">tx:annotation-driven</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"aspectj"</span>/&gt;
&lt;<span class="hl-tag">/beans</span>&gt;
</pre></div></div><p><br class="example-break">
            </p><div class="example"><a name="d0e204"></a><p class="title"><b>Example&nbsp;2.4.&nbsp;Project dispatcherServlet-servlet.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">mvc:annotation-driven</span>/&gt;
&lt;<span class="hl-tag">mvc:resources</span> <span class="hl-attribute">mapping</span>=<span class="hl-value">"/images/**"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"/images/"</span>/&gt;
&lt;<span class="hl-tag">mvc:resources</span> <span class="hl-attribute">mapping</span>=<span class="hl-value">"/resources/**"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"/resources/"</span>/&gt;
&lt;<span class="hl-tag">context:component-scan</span> <span class="hl-attribute">base-package</span>=<span class="hl-value">"org.neo4j.cineasts.controller"</span>/&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"viewResolver"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hl-attribute">p:prefix</span>=<span class="hl-value">"/WEB-INF/views/"</span> <span class="hl-attribute">p:suffix</span>=<span class="hl-value">".jsp"</span>/&gt;

&lt;<span class="hl-tag">tx:annotation-driven</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"aspectj"</span>/&gt;
</pre></div></div><p><br class="example-break">

        </p><p>
            We spun up Jetty by doing <code class="code">mvn jetty:run</code> to see if there were any obvious
            issues with the config. It all seemed to work just fine.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_domain"></a>Chapter&nbsp;3.&nbsp;The domain model</h2></div><div><h3 class="subtitle"><i>Setting the stage</i></h3></div></div></div><p>
        We wanted to outline the domain model before diving into library details. We also looked at the
        data model of the TheMoviedb.org data to confirm that it matched our expectations.
    </p><p>
        </p><div class="mediaobject"><img src="domain.png"></div><p>

    </p><p>
        In Java code this looks pretty straightforward:
    </p><p>
        </p><div class="example"><a name="d0e233"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Domain model</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">class</span> Movie {
    <span class="hl-keyword">int</span> id;
    String title;
    <span class="hl-keyword">int</span> year;
    Set&lt;Role&gt; cast;
}

<span class="hl-keyword">class</span> Actor {
    <span class="hl-keyword">int</span> id;
    String name;
    Set&lt;Movie&gt; filmography;
    Role playedIn(Movie movie, String role) { ... }
}

<span class="hl-keyword">class</span> Role {
    Movie movie;
    Actor actor;
    String role;
}

<span class="hl-keyword">class</span> User {
    String login;
    String name;
    String password;
    Set&lt;Rating&gt; ratings;
    Set&lt;User&gt; friends;
    Rating rate(Movie movie, <span class="hl-keyword">int</span> stars, String comment) { ... }
    <span class="hl-keyword">void</span> befriend(User user) { ... }
}

<span class="hl-keyword">class</span> Rating {
    User user;
    Movie movie;
    <span class="hl-keyword">int</span> stars;
    String comment;
}
</pre></div></div><p><br class="example-break">
    </p><p>
        Then we wrote some simple tests to show that the basic design of the domain is good enough so far. Just creating
        a movie populating it with actors and having it rated by a user and its friends.
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_neo4j"></a>Chapter&nbsp;4.&nbsp;Learning Neo4j</h2></div><div><h3 class="subtitle"><i>Graphs ahead</i></h3></div></div></div><p>
        Now we needed to figure out how to store our chosen domain model in the chosen database.
        First we read up about graph databases, in particular our chosen one,
        <a class="ulink" href="http://neo4j.org" target="_top">Neo4j</a>.
        The Neo4j data model consists of nodes and relationships, both of which can have key/value-style
        properties. Relationships are first-class citizens in Neo4j, meaning we can link together nodes
        into semantically rich networks. This really appealed to us. Then we found that we were also able to
        <a class="ulink" href="http://docs.neo4j.org/chunked/snapshot/indexing.html" target="_top">index nodes and relationships</a>
        by {key, value} pairs. We also found that we could traverse relationships both imperatively using
        the core API, and declaratively using a query-like
        <a class="ulink" href="http://wiki.neo4j.org/content/Traversal_Framework" target="_top">Traversal Description</a>.
    </p><p>
        We also learned that Neo4j is fully transactional and therefore upholds <a class="ulink" href="http://en.wikipedia.org/wiki/ACID" target="_top">ACID</a> guarantees for our data.
        This is unusual for NOSQL databases, but easier for us to get our head around than non-transactional
        eventual consistency. It also made us feel safe, though it also meant that we had to manage transactions.
        Something to keep in mind for later.
    </p><p>
        We started out by doing some prototyping with the Neo4j core API to get a feeling for that. And also
        to see, what the domain might look like when it's saved in the graph database. After adding the Maven
        dependency for Neo4j, we were ready to go.
    </p><p>
        </p><div class="example"><a name="d0e266"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Neo4j Maven dependency</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.neo4j&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;neo4j&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;1.3.M05&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
</pre></div></div><p><br class="example-break">
    </p><p>
        </p><div class="example"><a name="d0e274"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Neo4j core API (transaction code omitted)</b></p><div class="example-contents"><pre class="programlisting">enum RelationshipTypes <span class="hl-keyword">implements</span> RelationshipType { ACTS_IN };

GraphDatabaseService gds = <span class="hl-keyword">new</span> EmbeddedGraphDatabase(<span class="hl-string">"/path/to/store"</span>);
Node forrest=gds.createNode();
forrest.setProperty(<span class="hl-string">"title"</span>,<span class="hl-string">"Forrest Gump"</span>);
forrest.setProperty(<span class="hl-string">"year"</span>,1994);
gds.index().forNodes(<span class="hl-string">"movies"</span>).add(forrest,<span class="hl-string">"id"</span>,1);

Node tom=gds.createNode();
tom.setProperty(<span class="hl-string">"Tom Hanks"</span>);

Relationship role=tom.createRelationshipTo(forrest,ACTS_IN);
role.setProperty(<span class="hl-string">"role"</span>,<span class="hl-string">"Forrest Gump"</span>);

Node movie=gds.index().forNodes(<span class="hl-string">"movies"</span>).get(<span class="hl-string">"id"</span>,1).getSingle();
print(movie.getProperty(<span class="hl-string">"title"</span>));
<span class="hl-keyword">for</span> (Relationship role : movie.getRelationships(ACTS_IN,INCOMING)) {
    Node actor=role.getOtherNode(movie);
    print(actor.getProperty(<span class="hl-string">"name"</span>) +<span class="hl-string">" as "</span> + role.getProperty(<span class="hl-string">"role"</span>));
}
</pre></div></div><p><br class="example-break">
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_about-spring-data"></a>Chapter&nbsp;5.&nbsp;Spring Data Graph</h2></div><div><h3 class="subtitle"><i>Conjuring magic</i></h3></div></div></div><p>
        So far it had all been pure Spring Framework and Neo4j. However, using the Neo4j code in our domain
        classes polluted them with graph database details. For this application, we wanted to keep the domain
        classes clean. Spring Data Graph promised to do the heavy lifting for us, so we continued investigating it.
    </p><p>
        Spring Data Graph depends heavily on AspectJ <a class="xref" href="#reference:aspectj-details" title="Chapter&nbsp;24.&nbsp;AspectJ details">Chapter&nbsp;24, <i>AspectJ details</i></a>.
        Some parts of our classes would get new behavior,
        but it would not be visible in our code. The upside of this is that you get rid of a lot of boilerplate
        code.
    </p><p>
        The first step was to configure Maven:
        </p><div class="example"><a name="d0e294"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;Spring Data Graph Maven configuration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">properties</span>&gt;
    &lt;<span class="hl-tag">aspectj.version</span>&gt;1.6.12.M1&lt;<span class="hl-tag">/aspectj.version</span>&gt;
&lt;<span class="hl-tag">/properties</span>&gt;

&lt;<span class="hl-tag">dependency</span>&gt;
  &lt;<span class="hl-tag">groupId</span>&gt;org.springframework.data&lt;<span class="hl-tag">/groupId</span>&gt;
  &lt;<span class="hl-tag">artifactId</span>&gt;spring-data-neo4j&lt;<span class="hl-tag">/artifactId</span>&gt;
  &lt;<span class="hl-tag">version</span>&gt;1.1.0&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;

&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.aspectj&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;aspectjrt&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;${aspectj.version}&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;

&lt;<span class="hl-tag">build</span>&gt; &lt;<span class="hl-tag">plugins</span>&gt; &lt;<span class="hl-tag">plugin</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;aspectj-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;1.2&lt;<span class="hl-tag">/version</span>&gt;
    &lt;<span class="hl-tag">dependencies</span>&gt;
        &lt;<span class="hl-tag">dependency</span>&gt;
            &lt;<span class="hl-tag">groupId</span>&gt;org.aspectj&lt;<span class="hl-tag">/groupId</span>&gt;
            &lt;<span class="hl-tag">artifactId</span>&gt;aspectjrt&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">version</span>&gt;${aspectj.version}&lt;<span class="hl-tag">/version</span>&gt;
        &lt;<span class="hl-tag">/dependency</span>&gt;
        &lt;<span class="hl-tag">dependency</span>&gt;
            &lt;<span class="hl-tag">groupId</span>&gt;org.aspectj&lt;<span class="hl-tag">/groupId</span>&gt;
            &lt;<span class="hl-tag">artifactId</span>&gt;aspectjtools&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">version</span>&gt;${aspectj.version}&lt;<span class="hl-tag">/version</span>&gt;
        &lt;<span class="hl-tag">/dependency</span>&gt;
    &lt;<span class="hl-tag">/dependencies</span>&gt;
    &lt;<span class="hl-tag">executions</span>&gt;
        &lt;<span class="hl-tag">execution</span>&gt;
            &lt;<span class="hl-tag">goals</span>&gt;
                &lt;<span class="hl-tag">goal</span>&gt;compile&lt;<span class="hl-tag">/goal</span>&gt;
                &lt;<span class="hl-tag">goal</span>&gt;test-compile&lt;<span class="hl-tag">/goal</span>&gt;
            &lt;<span class="hl-tag">/goals</span>&gt;
        &lt;<span class="hl-tag">/execution</span>&gt;
    &lt;<span class="hl-tag">/executions</span>&gt;
    &lt;<span class="hl-tag">configuration</span>&gt;
        &lt;<span class="hl-tag">outxml</span>&gt;true&lt;<span class="hl-tag">/outxml</span>&gt;
        &lt;<span class="hl-tag">aspectLibraries</span>&gt;
            &lt;<span class="hl-tag">aspectLibrary</span>&gt;
                &lt;<span class="hl-tag">groupId</span>&gt;org.springframework&lt;<span class="hl-tag">/groupId</span>&gt;
                &lt;<span class="hl-tag">artifactId</span>&gt;spring-aspects&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">/aspectLibrary</span>&gt;
            &lt;<span class="hl-tag">aspectLibrary</span>&gt;
                &lt;<span class="hl-tag">groupId</span>&gt;org.springframework.data&lt;<span class="hl-tag">/groupId</span>&gt;
                &lt;<span class="hl-tag">artifactId</span>&gt;spring-data-neo4j&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">/aspectLibrary</span>&gt;
        &lt;<span class="hl-tag">/aspectLibraries</span>&gt;
        &lt;<span class="hl-tag">source</span>&gt;1.6&lt;<span class="hl-tag">/source</span>&gt;
        &lt;<span class="hl-tag">target</span>&gt;1.6&lt;<span class="hl-tag">/target</span>&gt;
    &lt;<span class="hl-tag">/configuration</span>&gt;
&lt;<span class="hl-tag">/plugin</span>&gt; &lt;<span class="hl-tag">/plugins</span>&gt; &lt;<span class="hl-tag">/build</span>&gt;
</pre></div></div><p><br class="example-break">
    </p><p>
        The Spring context configuration was much easier, thanks to a provided namespace:
    </p><p>
        </p><div class="example"><a name="d0e304"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Spring Data Graph context configuration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span> <span class="hl-attribute">...</span>
       <span class="hl-attribute">xmlns:datagraph</span>=<span class="hl-value">"http://www.springframework.org/schema/data/graph"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"... http://www.springframework.org/schema/data/graph
       http://www.springframework.org/schema/data/graph/datagraph-1.0.xsd"</span>&gt;
    ...
    &lt;<span class="hl-tag">datagraph:config</span> <span class="hl-attribute">storeDirectory</span>=<span class="hl-value">"data/graph.db"</span>/&gt;
    ...
&lt;<span class="hl-tag">/beans</span>&gt;
</pre></div></div><p><br class="example-break">
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_annotations"></a>Chapter&nbsp;6.&nbsp;Annotating the domain</h2></div><div><h3 class="subtitle"><i>Decorations</i></h3></div></div></div><p>
        Looking at the Spring Data Graph documentation, we found a simple
        <a class="ulink" href="http://github.com/SpringSource/spring-data-graph-examples/tree/master/hello-worlds" target="_top">Hello World example</a>
        and tried to understand it. The entity classes were annotated with <code class="code">@NodeEntity</code>.
        That was simple, so we added the annotation to our domain classes too. Entity classes representing
        relationships were instead annotated with <code class="code">@RelationshipEntity</code>.
        Property fields were taken care of automatically.
    </p><p>
        It was time to put our entities to a test. How could we now be assured that an attribute really was persisted to
        the graph store? We wanted to load the entity and check the attribute.

        Either we could have a GraphDatabaseContext injected and use its <code class="code">getById(entityId)</code>
        method to load the entity. Or use a more versatile Repository. We decided to keep things simple for now.

        Looking at the documentation revealed that there are a bunch of methods introduced to the
        entities by the aspects to support working with the entities.
        That's not entirely obvious. We found two that would do the job:
        <code class="code">entity.persist()</code> <code class="code">entity.getNodeId()</code>.
    </p><p>
        So here's what our test ended up looking like:
    </p><p>
        </p><div class="example"><a name="d0e341"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;First test case</b></p><div class="example-contents"><pre class="programlisting">@Autowired GraphDatabaseContext graphDatabaseContext;

@Test <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> persistedMovieShouldBeRetrievableFromGraphDb() {
    Movie forrestGump = <span class="hl-keyword">new</span> Movie(<span class="hl-string">"Forrest Gump"</span>, 1994).persist();
    Movie retrievedMovie = graphDatabaseContext.getById(forrestGump.getNodeId());
    assertEqual(<span class="hl-string">"retrieved movie matches persisted one"</span>, forrestGump, retrievedMovie);
    assertEqual(<span class="hl-string">"retrieved movie title matches"</span>, <span class="hl-string">"Forrest Gump"</span>, retrievedMovie.getTitle());
}
</pre></div></div><p><br class="example-break">
    </p><p>
        It worked! But hold on, what about transactions? After all, we had not declared the test to be
        transactional. After some further reading we learned that calling <code class="code">persist()</code> outside
        of a transaction automatically creates an implicit transaction. Very much like an EntityManager
        would behave. We also learned that when performing more complex operations on the entities we'd
        need external transactions, but not for this simple test.
    </p><p>
        </p><div class="example"><a name="d0e354"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;Movie class with annotation</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Movie {
    String id;
    String title;
    <span class="hl-keyword">int</span> year;
    Set&lt;Role&gt; cast;
}
</pre></div></div><p><br class="example-break">
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_indexing"></a>Chapter&nbsp;7.&nbsp;Indexing</h2></div><div><h3 class="subtitle"><i>Do I know you?</i></h3></div></div></div><p>
        There is an @Indexed annotation for fields. We wanted to try this out, and use it to guide the
        next test. We added @Indexed to the ID field of the Movie class. This field is intended to represent
        the external ID that will be used in URIs and will be stable across database imports and updates.
        This time we went with the default GraphRepository (previously Finder) to retrieve the indexed movie.
    </p><p>
        </p><div class="example"><a name="d0e369"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Exact Indexing for Movie id</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity <span class="hl-keyword">class</span> Movie {
    @Indexed <span class="hl-keyword">int</span> id;
    String title;
    <span class="hl-keyword">int</span> year;
}

@Autowired DirectGraphRepositoryFactory graphRepositoryFactory;

@Test <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> persistedMovieShouldBeRetrievableFromGraphDb() {
    <span class="hl-keyword">int</span> id = 1;
    Movie forrestGump = <span class="hl-keyword">new</span> Movie(id, <span class="hl-string">"Forrest Gump"</span>, 1994).persist();
    GraphRepository&lt;Movie&gt; movieRepository =
                               graphRepositoryFactory.createGraphRepository(Movie.<span class="hl-keyword">class</span>);
    Movie retrievedMovie = movieRepository.findByPropertyValue(<span class="hl-string">"id"</span>, id);
    assertEqual(<span class="hl-string">"retrieved movie matches persisted one"</span>, forrestGump, retrievedMovie);
    assertEqual(<span class="hl-string">"retrieved movie title matches"</span>, <span class="hl-string">"Forrest Gump"</span>, retrievedMovie.getTitle());
}
</pre></div></div><p><br class="example-break">
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_repository"></a>Chapter&nbsp;8.&nbsp;Repositories</h2></div><div><h3 class="subtitle"><i>Serving a good cause</i></h3></div></div></div><p>
        We wanted to add repositories with domain-specific operations. We started by creating a
        movie-specific repository, simply by creating an empty interface. It is more convenient to
        work with a named interface rather than different versions of a generic one.
        </p><div class="example"><a name="d0e382"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Movie repository</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">package</span> org.neo4j.cineasts.repository;
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MovieRepository <span class="hl-keyword">extends</span> GraphRepository&lt;Movie&gt; {}
</pre></div></div><p><br class="example-break">
        Then we added it to the Spring context configuration by simply adding:
        </p><div class="example"><a name="d0e388"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;Repository context configuration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">datagraph:repositories</span> <span class="hl-attribute">base-package</span>=<span class="hl-value">"org.neo4j.cineasts.repository"</span>/&gt;
</pre></div></div><p><br class="example-break">
        We then created the domain-specific repository class, annotating it with <code class="code">@Repository</code> and
        <code class="code">@Transactional</code>, and injected the movie repository.
    </p><p>
        </p><div class="example"><a name="d0e402"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Domain-specific repository</b></p><div class="example-contents"><pre class="programlisting">@Repository @Transactional
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CineastsRepostory {
  @Autowired MovieRepository movieRepository;

  <span class="hl-keyword">public</span> Movie getMovie(<span class="hl-keyword">int</span> id) {
      <span class="hl-keyword">return</span> movieRepository.findByPropertyValue(<span class="hl-string">"id"</span>, id);
  }
}
</pre></div></div><p><br class="example-break">
    </p><p>
        We did the same for the actors and users.
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_relationships"></a>Chapter&nbsp;9.&nbsp;Relationships</h2></div><div><h3 class="subtitle"><i>A convincing act</i></h3></div></div></div><p>
        Our application was not yet very much fun yet, just storing movies and actors. After all,
        the power is in the relationships between them. Fortunately, Neo4j treats relationships as first class citizens,
        allowing them to be addressed individually and assigned properties. That allows for representing them as entities
        if needed.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e417"></a>9.1.&nbsp;Creating relationships</h2></div></div></div><p>
            Relationships without properties ("anonymous" relationships) don't require any @RelationshipEntity
            classes. Unfortunately we had none of those, because our relationships were richer.
            Therefore we went with the Role relationship between Movie and Actor.
            It had to be annotated with @RelationshipEntity and the @StartNode and @EndNode had to be marked.
            So our Role looked like this:
        </p><p>
            </p><div class="mediaobject" align="center"><img src="relationship.png" align="middle"></div><p>
        </p><p>
            </p><div class="example"><a name="d0e430"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;Role class</b></p><div class="example-contents"><pre class="programlisting">@RelationshipEntity
<span class="hl-keyword">class</span> Role {
    @StartNode Actor actor;
    @EndNode Movie movie;
    String role;
}
</pre></div></div><p><br class="example-break">
        </p><p>
            When writing a test for that we tried to create the relationship entity with the <code class="code">new</code>
            keyword, but we got an exception saying that it was not allowed. At first this surprised us, but
            then we realized that a relationship entity must have a starting entity and ending entity. It
            turned out that the aspect had introduced a <code class="code">entity.relateTo</code> method in the node entities.
            It turned out to be exactly what we needed. We simply added a method to the Actor class, connecting
            it to movies.
        </p><p>
            </p><div class="example"><a name="d0e446"></a><p class="title"><b>Example&nbsp;9.2.&nbsp;Relating actors to movies</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">class</span> Actor {
...
    <span class="hl-keyword">public</span> Role playedIn(Movie movie, String roleName) {
        Role role = relateTo(movie, Role.<span class="hl-keyword">class</span>, <span class="hl-string">"ACTS_IN"</span>);
        role.setRole(roleName);
        <span class="hl-keyword">return</span> role;
    }
}
</pre></div></div><p><br class="example-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e452"></a>9.2.&nbsp;Accessing related entities</h2></div></div></div><p>
            Now we wanted to find connected entities.
            We already had fields for the relationships in both classes. It was time to annotate them
            correctly. It turned out that we needed to provide the target type of the fields again, due to
            Java's type erasure. The Neo4j relationship type and direction were easy to figure out.
            The direction even defaulted to outgoing, so we only had to specify it for the movie.
        </p><p>
            </p><div class="example"><a name="d0e459"></a><p class="title"><b>Example&nbsp;9.3.&nbsp;@RelatedTo usage</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Movie {
    @Indexed <span class="hl-keyword">int</span> id;
    String title;
    <span class="hl-keyword">int</span> year;
    @RelatedTo(elementClass = Actor.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>, direction = Direction.INCOMING)
    Set&lt;Actor&gt; cast;
}

@NodeEntity
<span class="hl-keyword">class</span> Actor {
    @Indexed <span class="hl-keyword">int</span> id;
    String name;
    @RelatedTo(elementClass = Movie.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>)
    Set&lt;Movie&gt; movies;

    <span class="hl-keyword">public</span> Role playedIn(Movie movie, String roleName) {
        Role role = relateTo(movie, Role.<span class="hl-keyword">class</span>, <span class="hl-string">"ACTS_IN"</span>);
        role.setRole(roleName);
        <span class="hl-keyword">return</span> role;
    }
}
</pre></div></div><p><br class="example-break">
        </p><p>
            While reading about these relationship collections, we learned that they are actually
            Spring Data Graph-managed sets. So whenever we add or remove something from the set,
            it automatically gets reflected in the underlying relationships. That's neat! But this
            also meant we did not need to initialize the fields. That could be easy to forget.
        </p><p>
            We made sure to add a test for those, so we were assured that the collections worked as
            advertised.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e469"></a>9.3.&nbsp;Accessing the relationship entities</h2></div></div></div><p>
            But we still couldn't access the Role relationships. It turned out that there was a separate
            annotation <code class="code">@RelatedToVia</code> for accessing the actual relationship entities. And we had
            to declare the field as an Iterable&lt;Role&gt;, with read-only semantics. This appeared to mean
            that we were not able to add new roles through the field. Adding relationship entities seemed like
            it had to be done by using <code class="code">entity.relateTo()</code>. The annotation attributes were similar to
            those used for <code class="code">@RelatedTo</code>. So off we went, creating our first real relationship (just kidding).
        </p><p>
            </p><div class="example"><a name="d0e485"></a><p class="title"><b>Example&nbsp;9.4.&nbsp;@RelatedToVia usage</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Movie {
    @Indexed <span class="hl-keyword">int</span> id;
    String title;
    <span class="hl-keyword">int</span> year;
    @RelatedTo(elementClass = Actor.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>, direction = Direction.INCOMING)
    Set&lt;Actor&gt; cast;

    @RelatedToVia(elementClass = Role.<span class="hl-keyword">class</span>, type = <span class="hl-string">"ACTS_IN"</span>, direction = Direction.INCOMING)
    Iterable&lt;Roles&gt; roles;
}
</pre></div></div><p><br class="example-break">
        </p><p>
            After watching the tests pass, we were confident that the relationship fields really mirrored
            the underlying relationships in the graph. We were pretty satisfied with our domain.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_running"></a>Chapter&nbsp;10.&nbsp;Get it running</h2></div><div><h3 class="subtitle"><i>Curtains up!</i></h3></div></div></div><p>
        Now we had a pretty complete application. It was time to put it to the test.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e500"></a>10.1.&nbsp;Populating the database</h2></div></div></div><p>
            Before we opened the gates we needed to add some movie data. So we wrote a small class for
            populating the database which could be called from our controller. To make it safe to call
            several times we added index lookups to check for existing entries. A simple <code class="code">/populate</code> endpoint
            for the controller that called it would be enough for now.
        </p><p>
            </p><div class="example"><a name="d0e510"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;Populating the database - Controller</b></p><div class="example-contents"><pre class="programlisting">@Service
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DatabasePopulator {

    @Autowired GraphDatabaseContext ctx;
    @Autowired CineastsRepository repository;

    @Transactional
    <span class="hl-keyword">public</span> List&lt;Movie&gt; populateDatabase() {
        Actor tomHanks = <span class="hl-keyword">new</span> Actor(<span class="hl-string">"1"</span>, <span class="hl-string">"Tom Hanks"</span>).persist();
        Movie forestGump = <span class="hl-keyword">new</span> Movie(<span class="hl-string">"1"</span>, <span class="hl-string">"Forrest Gump"</span>).persist();
        tomHanks.playedIn(forestGump,<span class="hl-string">"Forrest"</span>);
        <span class="hl-keyword">return</span> asList(forestGump);
    }
}

@Controller
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MovieController {

    <span class="hl-keyword">private</span> DatabasePopulator populator;

    @Autowired
    <span class="hl-keyword">public</span> MovieController(DatabasePopulator populator) {
        <span class="hl-keyword">this</span>.populator = populator;
    }

    @RequestMapping(value = <span class="hl-string">"/populate"</span>, method = RequestMethod.GET)
    <span class="hl-keyword">public</span> String populateDatabase(Model model) {
        Collection&lt;Movie&gt; movies = populator.populateDatabase();
        model.addAttribute(<span class="hl-string">"movies"</span>,movies);
        <span class="hl-keyword">return</span> <span class="hl-string">"/movies/list"</span>;
    }
}
</pre></div></div><p><br class="example-break">
            </p><div class="example"><a name="d0e516"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;Populating the database - JSP</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">%@</span> <span class="hl-attribute">page</span> <span class="hl-attribute">session</span>=<span class="hl-value">"false"</span> <span class="hl-attribute">%&gt;</span>
<span class="hl-attribute">&lt;%@</span> <span class="hl-attribute">taglib</span> <span class="hl-attribute">uri</span>=<span class="hl-value">"http://www.springframework.org/tags"</span> <span class="hl-attribute">prefix</span>=<span class="hl-value">"s"</span> <span class="hl-attribute">%&gt;</span>
<span class="hl-attribute">&lt;%@</span> <span class="hl-attribute">taglib</span> <span class="hl-attribute">prefix</span>=<span class="hl-value">"c"</span> <span class="hl-attribute">uri</span>=<span class="hl-value">"http://java.sun.com/jsp/jstl/core"</span> <span class="hl-attribute">%&gt;</span>

<span class="hl-attribute">&lt;c:choose&gt;</span>
  <span class="hl-attribute">&lt;c:when</span> <span class="hl-attribute">test</span>=<span class="hl-value">"${not empty movie}"</span>&gt;
    &lt;<span class="hl-tag">h2</span>&gt;${movie.title}&lt;<span class="hl-tag">/h2</span>&gt;
    &lt;<span class="hl-tag">c:if</span> <span class="hl-attribute">test</span>=<span class="hl-value">"${not empty movie.roles}"</span>&gt;
    &lt;<span class="hl-tag">ul</span>&gt;
    &lt;<span class="hl-tag">c:forEach</span> <span class="hl-attribute">items</span>=<span class="hl-value">"${movie.roles}"</span> <span class="hl-attribute">var</span>=<span class="hl-value">"role"</span>&gt;
      &lt;<span class="hl-tag">li</span>&gt;
        &lt;<span class="hl-tag">a</span> <span class="hl-attribute">href</span>=<span class="hl-value">"/actors/${role.actor.id}"</span>&gt;&lt;<span class="hl-tag">c:out</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${role.actor.name}"</span> /&gt; as
        &lt;<span class="hl-tag">c:out</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${role.name}"</span> /&gt;&lt;<span class="hl-tag">/a</span>&gt;&lt;<span class="hl-tag">br</span>/&gt;
      &lt;<span class="hl-tag">/li</span>&gt;
    &lt;<span class="hl-tag">/c:forEach</span>&gt;
    &lt;<span class="hl-tag">/ul</span>&gt;
    &lt;<span class="hl-tag">/c:if</span>&gt;
  &lt;<span class="hl-tag">/c:when</span>&gt;
  &lt;<span class="hl-tag">c:otherwise</span>&gt;
      No Movie with id ${id} found!
  &lt;<span class="hl-tag">/c:otherwise</span>&gt;
&lt;<span class="hl-tag">/c:choose</span>&gt;
</pre></div></div><p><br class="example-break">
        </p><p>
            Accessing the URI showed the single added movie on screen.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            Pardon the misused GET parameter for that (don't try this at home, the
            <a class="ulink" href="http://restinpractice.com" target="_top">REST guys</a> will hunt you down). This is only for
            running it from the browser address line. The next iteration of this website would use a button
            with POST.
        </div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e529"></a>10.2.&nbsp;Inspecting the datastore</h2></div></div></div><p>
            Being the geeks we are, we also wanted to inspect the raw data in the database. Reading the
            Neo4j docs, there were a couple of different ways of going about this.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e534"></a>10.2.1.&nbsp;Neoclipse visualization</h3></div></div></div><p>
                First we tried Neoclipse, an Eclipse RCP application/plugin that opens an existing graph store
                and visualizes its content. After getting an exception about concurrent access, we learned that
                we have to use Neoclipse in read-only mode when our webapp was still running. Good to know.
            </p><p>
                </p><div class="mediaobject" align="center"><img src="neoclipse.png" align="middle" width="531.496062992126"></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e545"></a>10.2.2.&nbsp;The Neo4j Shell</h3></div></div></div><p>
                For console junkies there was also a shell that was able to connect to a running Neo4j instance
                (if it was started with enable_remote_shell=true), or directly open an existing graph store.
            </p><p>
                </p><div class="example"><a name="d0e552"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;Starting the Neo4j Shell</b></p><div class="example-contents"><pre class="programlisting">neo4j-shell -readonly -path data/graph.db
</pre></div></div><p><br class="example-break">
            </p><p>
                The shell was very similar to a standard Bash shell. We were able to <code class="code">cd</code> to
                between the nodes, and <code class="code">ls</code> the relationships and properties. There were also
                more advanced commands for indexing and traversals.
            </p><p>
                </p><div class="example"><a name="d0e568"></a><p class="title"><b>Example&nbsp;10.4.&nbsp;Neo4j Shell usage</b></p><div class="example-contents"><pre class="programlisting">neo4j-sh[readonly] (0)$ help
Available commands: index dbinfo ls rm alias set eval mv gsh env rmrel mkrel
                    trav help pwd paths ... man cd
Use man &lt;command&gt; for info about each command.

neo4j-sh[readonly] (0)$ index --cd -g User login micha

neo4j-sh[readonly] (Micha,1)$ ls
*__type__ =[org.neo4j.cineasts.domain.User]
*login    =[micha]
*name     =[Micha]
*roles    =[ROLE_ADMIN,ROLE_USER]
(me) --[FRIEND]-&gt; (Olliver,2)
(me) --[RATED]-&gt; (The Matrix,3)

neo4j-sh[readonly] (Micha,1)$ ls 2
*__type__ =[org.neo4j.cineasts.domain.User]
*login    =[ollie]
*name     =[Olliver]
*roles    =[ROLE_USER]
(Olliver,2) &lt;-[FRIEND]-- (me)

neo4j-sh[readonly] (Micha,1)$ cd 3

neo4j-sh[readonly] (The Matrix,3)$ ls
*__type__     =[org.neo4j.cineasts.domain.Movie]
*description  =[Neo is a young software engineer and part-time hacker who is singled  ...]
*genre        =[Action]
*homepage     =[http://whatisthematrix.warnerbros.com/]
...
*studio       =[Warner Bros. Pictures]
*tagline      =[Welcome to the Real World.]
*title        =[The Matrix]
*trailer      =[http://www.youtube.com/watch?v=UM5yepZ21pI]
*version      =[324]
(me) &lt;-[ACTS_IN]-- (Marc Aden,19)
(me) &lt;-[ACTS_IN]-- (David Aston,18)
...
(me) &lt;-[ACTS_IN]-- (Keanu Reeves,6)
(me) &lt;-[DIRECTED]-- (Andy Wachowski,5)
(me) &lt;-[DIRECTED]-- (Lana Wachowski,4)
(me) &lt;-[RATED]-- (Micha,1)
            </pre></div></div><p><br class="example-break">
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_webapp"></a>Chapter&nbsp;11.&nbsp;Web views</h2></div><div><h3 class="subtitle"><i>Showing off</i></h3></div></div></div><p>
        After having put some data in the graph database, we also wanted to show it to the user. Adding
        the controller method to show a single movie with its attributes and cast in a JSP was
        straightforward. It basically just involved using the repository to look the movie up and add
        it to the model, and then forwarding to the /movies/show view and voil&aacute;.
    </p><p>
        </p><div class="example"><a name="d0e583"></a><p class="title"><b>Example&nbsp;11.1.&nbsp;Controller for showing movies</b></p><div class="example-contents"><pre class="programlisting">@RequestMapping(value = <span class="hl-string">"/movies/{movieId}"</span>,
method = RequestMethod.GET, headers = <span class="hl-string">"Accept=text/html"</span>)
<span class="hl-keyword">public</span> String singleMovieView(<span class="hl-keyword">final</span> Model model, @PathVariable String movieId) {
    Movie movie = repository.getMovie(movieId);
    model.addAttribute(<span class="hl-string">"id"</span>, movieId);
    <span class="hl-keyword">if</span> (movie != null) {
        model.addAttribute(<span class="hl-string">"movie"</span>, movie);
        model.addAttribute(<span class="hl-string">"stars"</span>, movie.getStars());
    }
    <span class="hl-keyword">return</span> <span class="hl-string">"/movies/show"</span>;
}
</pre></div></div><p><br class="example-break">
    </p><p>
        The UI had now evolved to this:
        </p><div class="mediaobject" align="center"><img src="cineasts_movie.png" align="middle" width="531.496062992126"></div><p>
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e595"></a>11.1.&nbsp;Searching</h2></div></div></div><p>
            The next thing was to allow users to search for movies, so we needed some fulltext search
            capabilities. As the index provider implementation of Neo4j is based on <a class="ulink" href="http://lucene.apache.org/java/docs/index.html" target="_top">Apache Lucene</a>,
            we were delighted to see that fulltext indexes were supported out of the box.
        </p><p>
            We happily annotated the title field of the Movie class with @Indexed(fulltext = true).
            We got an exception back telling us that we have to specify a separate index name.
            So we simply changed it to @Indexed(fulltext = true, indexName = "search"). The corresponding
            repository method is called findAllByQuery. To restrict the size of the returned set we simply
            added a limit that truncates the result.
        </p><p>
            </p><div class="example"><a name="d0e607"></a><p class="title"><b>Example&nbsp;11.2.&nbsp;Searching for movies</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CineastRepository {
    ....
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> List&lt;Movie&gt; findMovies(String query, <span class="hl-keyword">int</span> count) {
        List&lt;Movie&gt; movies=<span class="hl-keyword">new</span> ArrayList&lt;Movie&gt;(count);
        ClosableIterable&lt;Movie&gt; searchResults = movieRepository.findAllByQuery(<span class="hl-string">"title"</span>, query);
        <span class="hl-keyword">for</span> (Movie movie : searchResults) {
            movies.add(movie);
            <span class="hl-keyword">if</span> (count-- == 0) <span class="hl-keyword">break</span>;
        }
        searchResults.close();
        <span class="hl-keyword">return</span> movies;
    }
}
</pre></div></div><p><br class="example-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e613"></a>11.2.&nbsp;Listing results</h2></div></div></div><p>
            We then used this result in the controller to render a list of movies, driven by a
            search box. The movie properties and the cast were accessible through the getters
            in the domain classes.
        </p><p>
            </p><div class="example"><a name="d0e620"></a><p class="title"><b>Example&nbsp;11.3.&nbsp;Search controller</b></p><div class="example-contents"><pre class="programlisting">@RequestMapping(value = <span class="hl-string">"/movies"</span>,
method = RequestMethod.GET, headers = <span class="hl-string">"Accept=text/html"</span>)
<span class="hl-keyword">public</span> String findMovies(Model model, @RequestParam(<span class="hl-string">"q"</span>) String query) {
    List&lt;Movie&gt; movies = repository.findMovies(query, 20);
    model.addAttribute(<span class="hl-string">"movies"</span>, movies);
    model.addAttribute(<span class="hl-string">"query"</span>, query);
    <span class="hl-keyword">return</span> <span class="hl-string">"/movies/list"</span>;
}
</pre></div></div><p><br class="example-break">
        </p><p>
            </p><div class="example"><a name="d0e628"></a><p class="title"><b>Example&nbsp;11.4.&nbsp;Search Results JSP</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">h2</span>&gt;Movies&lt;<span class="hl-tag">/h2</span>&gt;

&lt;<span class="hl-tag">c:choose</span>&gt;
    &lt;<span class="hl-tag">c:when</span> <span class="hl-attribute">test</span>=<span class="hl-value">"${not empty movies}"</span>&gt;
        &lt;<span class="hl-tag">dl</span> <span class="hl-attribute">class</span>=<span class="hl-value">"listings"</span>&gt;
        &lt;<span class="hl-tag">c:forEach</span> <span class="hl-attribute">items</span>=<span class="hl-value">"${movies}"</span> <span class="hl-attribute">var</span>=<span class="hl-value">"movie"</span>&gt;
            &lt;<span class="hl-tag">dt</span>&gt;
                &lt;<span class="hl-tag">a</span> <span class="hl-attribute">href</span>=<span class="hl-value">"/movies/${movie.id}"</span>&gt;&lt;<span class="hl-tag">c:out</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${movie.title}"</span> /&gt;&lt;<span class="hl-tag">/a</span>&gt;&lt;<span class="hl-tag">br</span>/&gt;
            &lt;<span class="hl-tag">/dt</span>&gt;
            &lt;<span class="hl-tag">dd</span>&gt;
                &lt;<span class="hl-tag">c:out</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${movie.description}"</span> <span class="hl-attribute">escapeXml</span>=<span class="hl-value">"true"</span> /&gt;
            &lt;<span class="hl-tag">/dd</span>&gt;
        &lt;<span class="hl-tag">/c:forEach</span>&gt;
        &lt;<span class="hl-tag">/dl</span>&gt;
    &lt;<span class="hl-tag">/c:when</span>&gt;
    &lt;<span class="hl-tag">c:otherwise</span>&gt;
        No movies found for query &amp;quot;${query}&amp;quot;.
    &lt;<span class="hl-tag">/c:otherwise</span>&gt;
&lt;<span class="hl-tag">/c:choose</span>&gt;
            </pre></div></div><p><br class="example-break">
        </p><p>
            The UI now looked like this:
            </p><div class="mediaobject" align="center"><img src="cineasts_results.png" align="middle" width="531.496062992126"></div><p>
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_social"></a>Chapter&nbsp;12.&nbsp;Adding social</h2></div><div><h3 class="subtitle"><i>Movies 2.0</i></h3></div></div></div><p>
        So far, the website had only been a plain old movie database (POMD?). We now wanted to add
        a touch of social to it.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e647"></a>12.1.&nbsp;Users</h2></div></div></div><p>
            So we started out by taking the User class that we'd already coded and made it a
            full-fledged Spring Data Graph entity. We added the ability to make friends and to
            rate movies. With that we also added a simple UserRepository that was able to look
            up users by ID.
        </p><p>
            </p><div class="example"><a name="d0e654"></a><p class="title"><b>Example&nbsp;12.1.&nbsp;Social entities</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> User {
    @Indexed String login;
    String name;
    String password;

    @RelatedToVia(elementClass = Rating.<span class="hl-keyword">class</span>, type = RATED)
    Iterable&lt;Rating&gt; ratings;

    @RelatedTo(elementClass = User.<span class="hl-keyword">class</span>, type = <span class="hl-string">"FRIEND"</span>, direction=Direction.BOTH)
    Set&lt;User&gt; friends;

    <span class="hl-keyword">public</span> Rating rate(Movie movie, <span class="hl-keyword">int</span> stars, String comment) {
        <span class="hl-keyword">return</span> relateTo(movie, Rating.<span class="hl-keyword">class</span>, <span class="hl-string">"RATED"</span>).rate(stars, comment);
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> befriend(User user) {
        <span class="hl-keyword">this</span>.friends.add(user);
    }
}

@RelationshipEntity
<span class="hl-keyword">class</span> Rating {
    @StartNode User user;
    @EndNode Movie movie;
    <span class="hl-keyword">int</span> stars;
    String comment;
    <span class="hl-keyword">public</span> Rating rate(<span class="hl-keyword">int</span> stars, String comment) {
       <span class="hl-keyword">this</span>.stars = stars; <span class="hl-keyword">this</span>.comment = comment;
       <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>;
    }
}
</pre></div></div><p><br class="example-break">
        </p><p>
            We extended the DatabasePopulator to add some users and ratings to the initial setup.
        </p><p>
            </p><div class="example"><a name="d0e664"></a><p class="title"><b>Example&nbsp;12.2.&nbsp;Populate users and ratings</b></p><div class="example-contents"><pre class="programlisting">@Transactional
<span class="hl-keyword">public</span> List&lt;Movie&gt; populateDatabase() {
    Actor tomHanks = <span class="hl-keyword">new</span> Actor(<span class="hl-string">"1"</span>, <span class="hl-string">"Tom Hanks"</span>).persist();
    Movie forestGump = <span class="hl-keyword">new</span> Movie(<span class="hl-string">"1"</span>, <span class="hl-string">"Forrest Gump"</span>).persist();
    tomHanks.playedIn(forestGump, <span class="hl-string">"Forrest"</span>);

    User me = <span class="hl-keyword">new</span> User(<span class="hl-string">"micha"</span>, <span class="hl-string">"Micha"</span>, <span class="hl-string">"password"</span>,
        User.Roles.ROLE_ADMIN, User.Roles.ROLE_USER).persist();
    Rating awesome = me.rate(forestGump, 5, <span class="hl-string">"Awesome"</span>);

    User ollie = <span class="hl-keyword">new</span> User(<span class="hl-string">"ollie"</span>, <span class="hl-string">"Olliver"</span>, <span class="hl-string">"password"</span>, User.Roles.ROLE_USER).persist();
    ollie.rate(forestGump, 2, <span class="hl-string">"ok"</span>);
    me.addFriend(ollie);
    <span class="hl-keyword">return</span> asList(forestGump);
}
</pre></div></div><p><br class="example-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e670"></a>12.2.&nbsp;Ratings for movies</h2></div></div></div><p>
            We also put a ratings field into the Movie class to be able to get a movie's ratings,
            and also a method to average its star rating.
        </p><p>
            </p><div class="example"><a name="d0e677"></a><p class="title"><b>Example&nbsp;12.3.&nbsp;Getting the rating of a movie</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">class</span> Movie {
    ...

    @RelatedToVia(elementClass=Rating.<span class="hl-keyword">class</span>, type=<span class="hl-string">"RATED"</span>, direction = Direction.INCOMING)
    Iterable&lt;Rating&gt; ratings;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getStars() {
        <span class="hl-keyword">int</span> stars = 0, count = 0;
        <span class="hl-keyword">for</span> (Rating rating : ratings) {
            stars += rating.getStars(); count++;
        }
        <span class="hl-keyword">return</span> count == 0 ? 0 : stars / count;
    }
}
</pre></div></div><p><br class="example-break">
        </p><p>
            Fortunately our tests highlighted the division by zero error when calculating the stars for
            a movie without ratings. The next steps were to add this information to the movie presentation in
            the UI, and creating a user profile page. But for that to happen, users must first be able to log in.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_security"></a>Chapter&nbsp;13.&nbsp;Adding Security</h2></div><div><h3 class="subtitle"><i>Protecting assets</i></h3></div></div></div><p>
        To have a user in the webapp we had to put it in the session and add login and registration
        pages. Of course the pages that were only meant for logged-in users had to be secured as well.
    </p><p>
        Being Spring users, we naturally used Spring Security for this. We wrote  a simple UserDetailsService
        that used a repository for looking up the users and validating their credentials. The config is located
        in a separate applicationContext-security.xml. But first, as always, Maven and web.xml setup.
    </p><p>
        </p><div class="example"><a name="d0e696"></a><p class="title"><b>Example&nbsp;13.1.&nbsp;Spring Security pom.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.springframework.security&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;spring-security-web&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;${spring.version}&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.springframework.security&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;spring-security-config&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;${spring.version}&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
</pre></div></div><p><br class="example-break">
    </p><p>
        </p><div class="example"><a name="d0e704"></a><p class="title"><b>Example&nbsp;13.2.&nbsp;Spring Security web.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">context-param</span>&gt;
    &lt;<span class="hl-tag">param-name</span>&gt;contextConfigLocation&lt;<span class="hl-tag">/param-name</span>&gt;
    &lt;<span class="hl-tag">param-value</span>&gt;
        /WEB-INF/applicationContext-security.xml
        /WEB-INF/applicationContext.xml
    &lt;<span class="hl-tag">/param-value</span>&gt;
&lt;<span class="hl-tag">/context-param</span>&gt;

&lt;<span class="hl-tag">listener</span>&gt;
    &lt;<span class="hl-tag">listener-class</span>&gt;org.springframework.web.context.ContextLoaderListener&lt;<span class="hl-tag">/listener-class</span>&gt;
&lt;<span class="hl-tag">/listener</span>&gt;

&lt;<span class="hl-tag">filter</span>&gt;
    &lt;<span class="hl-tag">filter-name</span>&gt;springSecurityFilterChain&lt;<span class="hl-tag">/filter-name</span>&gt;
    &lt;<span class="hl-tag">filter-class</span>&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;<span class="hl-tag">/filter-class</span>&gt;
&lt;<span class="hl-tag">/filter</span>&gt;

&lt;<span class="hl-tag">filter-mapping</span>&gt;
    &lt;<span class="hl-tag">filter-name</span>&gt;springSecurityFilterChain&lt;<span class="hl-tag">/filter-name</span>&gt;
    &lt;<span class="hl-tag">url-pattern</span>&gt;/*&lt;<span class="hl-tag">/url-pattern</span>&gt;
&lt;<span class="hl-tag">/filter-mapping</span>&gt;
</pre></div></div><p><br class="example-break">
    </p><p>
        </p><div class="example"><a name="d0e712"></a><p class="title"><b>Example&nbsp;13.3.&nbsp;Spring Security applicationContext-security.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">security:global-method-security</span> <span class="hl-attribute">secured-annotations</span>=<span class="hl-value">"enabled"</span>&gt;
&lt;<span class="hl-tag">/security:global-method-security</span>&gt;

&lt;<span class="hl-tag">security:http</span> <span class="hl-attribute">auto-config</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">access-denied-page</span>=<span class="hl-value">"/auth/denied"</span>&gt; &lt;<span class="hl-comment">!-- use-expressions="true" --</span>&gt;
    &lt;<span class="hl-tag">security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/admin/*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_ADMIN"</span>/&gt;
    &lt;<span class="hl-tag">security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/import/*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_ADMIN"</span>/&gt;
    &lt;<span class="hl-tag">security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/user/*"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"ROLE_USER"</span>/&gt;
    &lt;<span class="hl-tag">security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/auth/login"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;
    &lt;<span class="hl-tag">security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/auth/register"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;
    &lt;<span class="hl-tag">security:intercept-url</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"/**"</span> <span class="hl-attribute">access</span>=<span class="hl-value">"IS_AUTHENTICATED_ANONYMOUSLY"</span>/&gt;
    &lt;<span class="hl-tag">security:form-login</span> <span class="hl-attribute">login-page</span>=<span class="hl-value">"/auth/login"</span> <span class="hl-attribute">authentication-failure-url</span>=<span class="hl-value">"/auth/login?login_error=true"</span>
    <span class="hl-attribute">default-target-url</span>=<span class="hl-value">"/user"</span>/&gt;
    &lt;<span class="hl-tag">security:logout</span> <span class="hl-attribute">logout-url</span>=<span class="hl-value">"/auth/logout"</span> <span class="hl-attribute">logout-success-url</span>=<span class="hl-value">"/"</span> <span class="hl-attribute">invalidate-session</span>=<span class="hl-value">"true"</span>/&gt;
&lt;<span class="hl-tag">/security:http</span>&gt;

&lt;<span class="hl-tag">security:authentication-manager</span>&gt;
    &lt;<span class="hl-tag">security:authentication-provider</span> <span class="hl-attribute">user-service-ref</span>=<span class="hl-value">"userDetailsService"</span>&gt;
        &lt;<span class="hl-tag">security:password-encoder</span> <span class="hl-attribute">hash</span>=<span class="hl-value">"md5"</span>&gt;
            &lt;<span class="hl-tag">security:salt-source</span> <span class="hl-attribute">system-wide</span>=<span class="hl-value">"cewuiqwzie"</span>/&gt;
        &lt;<span class="hl-tag">/security:password-encoder</span>&gt;
    &lt;<span class="hl-tag">/security:authentication-provider</span>&gt;
&lt;<span class="hl-tag">/security:authentication-manager</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userDetailsService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.movies.service.CineastsUserDetailsService"</span>/&gt;
</pre></div></div><p><br class="example-break">
        </p><div class="example"><a name="d0e718"></a><p class="title"><b>Example&nbsp;13.4.&nbsp;UserDetailsService and UserDetails implementation</b></p><div class="example-contents"><pre class="programlisting">@Service
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CineastsUserDetailsService <span class="hl-keyword">implements</span> UserDetailsService, InitializingBean {

    @Autowired <span class="hl-keyword">private</span> UserRepository userRepository;

    @Override
    <span class="hl-keyword">public</span> UserDetails loadUserByUsername(String login)
                                <span class="hl-keyword">throws</span> UsernameNotFoundException, DataAccessException {
        <span class="hl-keyword">final</span> User user = findUser(login);
        <span class="hl-keyword">if</span> (user==null) <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> UsernameNotFoundException(<span class="hl-string">"Username not found"</span>,login);
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> CineastsUserDetails(user);
    }

    <span class="hl-keyword">public</span> User findUser(String login) {
        <span class="hl-keyword">return</span> userRepository.findByPropertyValue(<span class="hl-string">"login"</span>,login);
    }
    <span class="hl-keyword">public</span> User getUserFromSession() {
        SecurityContext context = SecurityContextHolder.getContext();
        Authentication authentication = context.getAuthentication();
        Object principal = authentication.getPrincipal();
        <span class="hl-keyword">if</span> (principal <span class="hl-keyword">instanceof</span> CineastsUserDetails) {
            CineastsUserDetails userDetails = (CineastsUserDetails) principal;
            <span class="hl-keyword">return</span> userDetails.getUser();
        }
        <span class="hl-keyword">return</span> null;
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CineastsUserDetails <span class="hl-keyword">implements</span> UserDetails {
    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> User user;

    <span class="hl-keyword">public</span> CineastsUserDetails(User user) {
        <span class="hl-keyword">this</span>.user = user;
    }

    @Override
    <span class="hl-keyword">public</span> Collection&lt;GrantedAuthority&gt; getAuthorities() {
        User.Roles[] roles = user.getRoles();
        <span class="hl-keyword">if</span> (roles ==null) <span class="hl-keyword">return</span> Collections.emptyList();
        <span class="hl-keyword">return</span> Arrays.&lt;GrantedAuthority&gt;asList(roles);
    }

    @Override
    <span class="hl-keyword">public</span> String getPassword() {
        <span class="hl-keyword">return</span> user.getPassword();
    }

    @Override
    <span class="hl-keyword">public</span> String getUsername() {
        <span class="hl-keyword">return</span> user.getLogin();
    }

    ...
    <span class="hl-keyword">public</span> User getUser() {
        <span class="hl-keyword">return</span> user;
    }
}
</pre></div></div><p><br class="example-break">
    </p><p>
        Any logged-in user was now available in the session, and could be used for all the social
        interactions. The remaining work for this was mainly adding controller methods and JSPs
        for the views. We used the helper method <code class="code">getUserFromSession()</code> in the controllers
        to access the logged-in user and put it in the model for rendering.
        Here's what the UI had evolved to:
    </p><div class="mediaobject"><img src="cineasts_user.png" width="531.496062992126"></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_user-experience"></a>Chapter&nbsp;14.&nbsp;More UI</h2></div><div><h3 class="subtitle"><i>Oh the glamour</i></h3></div></div></div><p>
        To create a nice user experience, we wanted to have a nice looking app. Not something that
        looked like a toddler made it. So we got some user experience people involved and the results
        were impressive. This sections presents some of the remaining screen shots of Cineasts.net.
    </p><p>
        Some noteworthy things. Since Spring Data Graph reads through down to the database for property
        and relationship access, we tried to minimize that by using <code class="code">&lt;c:var/&gt;</code> several times.
        The app contains very little javascript / ajax code right now, that will change when it moves ahead.
    </p><p>
        </p><div class="mediaobject"><img src="cineasts_main.png" width="531.496062992126"></div><p>
        </p><div class="mediaobject"><img src="cineasts_results.png" width="531.496062992126"></div><p>
        </p><div class="mediaobject"><img src="cineasts_movie.png" width="531.496062992126"></div><p>
        </p><div class="mediaobject"><img src="cineasts_actor.png" width="531.496062992126"></div><p>
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_import"></a>Chapter&nbsp;15.&nbsp;Importing Data</h2></div><div><h3 class="subtitle"><i>The dusty archives</i></h3></div></div></div><p>
        It was now time to pull the data from <a class="ulink" href="http://themoviedb.org" target="_top">themoviedb.org</a>.
        Registering there and getting an API key was simple, as was using the API on the command-line with
        <code class="code">curl</code>. Looking at the JSON returned for movies and people, we decided to enhance our
        domain model and add some more fields to enrich the UI.
    </p><p>
        </p><div class="example"><a name="d0e777"></a><p class="title"><b>Example&nbsp;15.1.&nbsp;JSON movie response</b></p><div class="example-contents"><pre class="programlisting">[{<span class="hl-string">"popularity"</span>:3,
<span class="hl-string">"translated"</span>:true, <span class="hl-string">"adult"</span>:false, <span class="hl-string">"language"</span>:<span class="hl-string">"en"</span>,
<span class="hl-string">"original_name"</span>:<span class="hl-string">"[Rec]"</span>, <span class="hl-string">"name"</span>:<span class="hl-string">"[Rec]"</span>, <span class="hl-string">"alternative_name"</span>:<span class="hl-string">"[REC]"</span>,
<span class="hl-string">"movie_type"</span>:<span class="hl-string">"movie"</span>,
<span class="hl-string">"id"</span>:8329, <span class="hl-string">"imdb_id"</span>:<span class="hl-string">"tt1038988"</span>, <span class="hl-string">"url"</span>:<span class="hl-string">"http://www.themoviedb.org/movie/8329"</span>,
<span class="hl-string">"votes"</span>:11, <span class="hl-string">"rating"</span>:7.2,
<span class="hl-string">"status"</span>:<span class="hl-string">"Released"</span>,
<span class="hl-string">"tagline"</span>:<span class="hl-string">"One Witness. One Camera"</span>,
<span class="hl-string">"certification"</span>:<span class="hl-string">"R"</span>,
<span class="hl-string">"overview"</span>:<span class="hl-string">"\"REC\" turns on a young TV reporter and her cameraman who cover the night shift
 at the local fire station...
"</span>keywords":[<span class="hl-string">"terror"</span>, <span class="hl-string">"lebende leichen"</span>, <span class="hl-string">"obsession"</span>, <span class="hl-string">"camcorder"</span>, <span class="hl-string">"firemen"</span>, <span class="hl-string">"reality tv "</span>,
 <span class="hl-string">"bite"</span>, <span class="hl-string">"cinematographer"</span>,
<span class="hl-string">"attempt to escape"</span>, <span class="hl-string">"virus"</span>, <span class="hl-string">"lodger"</span>, <span class="hl-string">"live-reportage"</span>, <span class="hl-string">"schwerverletzt"</span>],
<span class="hl-string">"released"</span>:<span class="hl-string">"2007-08-29"</span>,
<span class="hl-string">"runtime"</span>:78,
<span class="hl-string">"budget"</span>:0,
<span class="hl-string">"revenue"</span>:0,
<span class="hl-string">"homepage"</span>:<span class="hl-string">"http://www.3l-filmverleih.de/rec"</span>,
<span class="hl-string">"trailer"</span>:<span class="hl-string">"http://www.youtube.com/watch?v=YQUkX_XowqI"</span>,
<span class="hl-string">"genres"</span>:[{<span class="hl-string">"type"</span>:<span class="hl-string">"genre"</span>,
<span class="hl-string">"url"</span>:<span class="hl-string">"http://themoviedb.org/genre/horror"</span>,
<span class="hl-string">"name"</span>:<span class="hl-string">"Horror"</span>,
<span class="hl-string">"id"</span>:27}],
<span class="hl-string">"studios"</span>:[{<span class="hl-string">"url"</span>:<span class="hl-string">"http://www.themoviedb.org/company/2270"</span>, <span class="hl-string">"name"</span>:<span class="hl-string">"Filmax Group"</span>, <span class="hl-string">"id"</span>:2270}],
<span class="hl-string">"languages_spoken"</span>:[{<span class="hl-string">"code"</span>:<span class="hl-string">"es"</span>, <span class="hl-string">"name"</span>:<span class="hl-string">"Spanish"</span>, <span class="hl-string">"native_name"</span>:<span class="hl-string">"Espa\u00f1ol"</span>}],
<span class="hl-string">"countries"</span>:[{<span class="hl-string">"code"</span>:<span class="hl-string">"ES"</span>, <span class="hl-string">"name"</span>:<span class="hl-string">"Spain"</span>, <span class="hl-string">"url"</span>:<span class="hl-string">"http://www.themoviedb.org/country/es"</span>}],
<span class="hl-string">"posters"</span>:[{<span class="hl-string">"image"</span>:{<span class="hl-string">"type"</span>:<span class="hl-string">"poster"</span>,
<span class="hl-string">"size"</span>:<span class="hl-string">"original"</span>, <span class="hl-string">"height"</span>:1000, <span class="hl-string">"width"</span>:706,
<span class="hl-string">"url"</span>:<span class="hl-string">"http://cf1.imgobject.com/posters/3a0/4cc8df415e73d650240003a0/rec-original.jpg"</span>,
<span class="hl-string">"id"</span>:<span class="hl-string">"4cc8df415e73d650240003a0"</span>}},
....
<span class="hl-string">"cast"</span>:[{<span class="hl-string">"name"</span>:<span class="hl-string">"Manuela Velasco"</span>,
<span class="hl-string">"job"</span>:<span class="hl-string">"Actor"</span>, <span class="hl-string">"department"</span>:<span class="hl-string">"Actors"</span>,
<span class="hl-string">"character"</span>:<span class="hl-string">"Angela Vidal"</span>,
<span class="hl-string">"id"</span>:34793, <span class="hl-string">"order"</span>:0, <span class="hl-string">"cast_id"</span>:1,
<span class="hl-string">"url"</span>:<span class="hl-string">"http://www.themoviedb.org/person/34793"</span>,
<span class="hl-string">"profile"</span>:<span class="hl-string">"http://cf1.imgobject.com/profiles/390/.../manuela-velasco-thumb.jpg"</span>},
...
{<span class="hl-string">"name"</span>:<span class="hl-string">"Gl\u00f2ria Viguer"</span>,
<span class="hl-string">"job"</span>:<span class="hl-string">"Costume Design"</span>, <span class="hl-string">"department"</span>:<span class="hl-string">"Costume \u0026 Make-Up"</span>,
<span class="hl-string">"character"</span>:<span class="hl-string">""</span>,
<span class="hl-string">"id"</span>:54531, <span class="hl-string">"order"</span>:0, <span class="hl-string">"cast_id"</span>:21,
<span class="hl-string">"url"</span>:<span class="hl-string">"http://www.themoviedb.org/person/54531"</span>,
<span class="hl-string">"profile"</span>:<span class="hl-string">""</span>}],
<span class="hl-string">"version"</span>:150, <span class="hl-string">"last_modified_at"</span>:<span class="hl-string">"2011-02-20 23:16:57"</span>}]
    </pre></div></div><p><br class="example-break">
        </p><div class="example"><a name="d0e783"></a><p class="title"><b>Example&nbsp;15.2.&nbsp;JSON actor response</b></p><div class="example-contents"><pre class="programlisting">[{<span class="hl-string">"popularity"</span>:3,
<span class="hl-string">"name"</span>:<span class="hl-string">"Glenn Strange"</span>, <span class="hl-string">"known_as"</span>:[{<span class="hl-string">"name"</span>:<span class="hl-string">"George Glenn Strange"</span>}, {<span class="hl-string">"name"</span>:<span class="hl-string">"Glen Strange"</span>},
{<span class="hl-string">"name"</span>:<span class="hl-string">"Glen 'Peewee' Strange"</span>}, {<span class="hl-string">"name"</span>:<span class="hl-string">"Peewee Strange"</span>}, {<span class="hl-string">"name"</span>:<span class="hl-string">"'Peewee' Strange"</span>}],
<span class="hl-string">"id"</span>:30112,
<span class="hl-string">"biography"</span>:<span class="hl-string">""</span>,
<span class="hl-string">"known_movies"</span>:4,
<span class="hl-string">"birthday"</span>:<span class="hl-string">"1899-08-16"</span>, <span class="hl-string">"birthplace"</span>:<span class="hl-string">"Weed, New Mexico, USA"</span>,
<span class="hl-string">"url"</span>:<span class="hl-string">"http://www.themoviedb.org/person/30112"</span>,
<span class="hl-string">"filmography"</span>:[{<span class="hl-string">"name"</span>:<span class="hl-string">"Bud Abbott Lou Costello Meet Frankenstein"</span>,
<span class="hl-string">"id"</span>:3073,
<span class="hl-string">"job"</span>:<span class="hl-string">"Actor"</span>, <span class="hl-string">"department"</span>:<span class="hl-string">"Actors"</span>,
<span class="hl-string">"character"</span>:<span class="hl-string">"The Frankenstein Monster"</span>,
<span class="hl-string">"cast_id"</span>:23,
<span class="hl-string">"url"</span>:<span class="hl-string">"http://www.themoviedb.org/movie/3073"</span>,
<span class="hl-string">"poster"</span>:<span class="hl-string">"http://cf1.imgobject.com/posters/4ca/.../bud-abbott-lou-costello-meet-frankenstein-cover.jpg"</span>,
<span class="hl-string">"adult"</span>:false, <span class="hl-string">"release"</span>:<span class="hl-string">"1948-06-15"</span>},
...],
<span class="hl-string">"profile"</span>:[],
<span class="hl-string">"version"</span>:19, <span class="hl-string">"last_modified_at"</span>:<span class="hl-string">"2011-03-07 13:02:35"</span>}]
    </pre></div></div><p><br class="example-break">
    </p><p>
        For the import process we created a separate importer using Jackson (a JSON library) to fetch
        and parse the data, and then some transactional methods in the MovieDbImportService to actually
        import it as movies, roles, and actors.
        
        The importer used a simple caching mechanism to keep downloaded actor and movie data on the
        filesystem, so that we didn't have to overload the remote API.
        In the code below you can see that we've changed the actor to a person so that we can also accommodate
        the other folks that participate in movie production.
    </p><p>
        </p><div class="example"><a name="d0e795"></a><p class="title"><b>Example&nbsp;15.3.&nbsp;Importing the data</b></p><div class="example-contents"><pre class="programlisting">@Transactional
<span class="hl-keyword">public</span> Movie importMovie(String movieId) {
    Movie movie = repository.getMovie(movieId);
    <span class="hl-keyword">if</span> (movie == null) { <span class="hl-comment">// Not found: Create fresh</span>
        movie = <span class="hl-keyword">new</span> Movie(movieId,null);
    }

    Map data = loadMovieData(movieId);
    <span class="hl-keyword">if</span> (data.containsKey(<span class="hl-string">"not_found"</span>))
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(<span class="hl-string">"Data for Movie "</span>+movieId+<span class="hl-string">" not found."</span>);
    movieDbJsonMapper.mapToMovie(data, movie);
    movie.persist();
    relatePersonsToMovie(movie, data);
    <span class="hl-keyword">return</span> movie;
}

<span class="hl-keyword">private</span> <span class="hl-keyword">void</span> relatePersonsToMovie(Movie movie, Map data) {
    Collection&lt;Map&gt; cast = (Collection&lt;Map&gt;) data.get(<span class="hl-string">"cast"</span>);
    <span class="hl-keyword">for</span> (Map entry : cast) {
        String id = entry.get(<span class="hl-string">"id"</span>);
        Roles job = entry.get(<span class="hl-string">"job"</span>);
        Person person = importPerson(id);
        <span class="hl-keyword">switch</span> (job) {
            <span class="hl-keyword">case</span> DIRECTED:
                person.directed(movie);
                <span class="hl-keyword">break</span>;
            <span class="hl-keyword">case</span> ACTS_IN:
                person.playedIn(movie, (String) entry.get(<span class="hl-string">"character"</span>));
                <span class="hl-keyword">break</span>;
        }
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> mapToMovie(Map data, Movie movie) {
   movie.setTitle((String) data.get(<span class="hl-string">"name"</span>));
   movie.setLanguage((String) data.get(<span class="hl-string">"language"</span>));
   movie.setTagline((String) data.get(<span class="hl-string">"tagline"</span>));
   movie.setReleaseDate(toDate(data, <span class="hl-string">"released"</span>, <span class="hl-string">"yyyy-MM-dd"</span>));
...
   movie.setImageUrl(selectImageUrl((List&lt;Map&gt;) data.get(<span class="hl-string">"posters"</span>), <span class="hl-string">"poster"</span>, <span class="hl-string">"mid"</span>));
}

        </pre></div></div><p><br class="example-break">
    </p><p>
        The last part involved adding a protected URI to the MovieController to allow importing ranges
        of movies. During testing, it became obvious that the calls to TheMoviedb.org were a limiting
        factor. As soon as the data was stored locally, the Neo4j import was a sub-second deal.
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial_recommendations"></a>Chapter&nbsp;16.&nbsp;Recommendations</h2></div><div><h3 class="subtitle"><i>Movies! Friends! Bargains!</i></h3></div></div></div><p>
        In the last part of this exercise we wanted to add recommendations to the app. One
        obvious recommendation was movies that our friends liked (and their friends too, but
        with less importance). The second recommendation was for new friends that also liked
        the movies that we liked most.
    </p><p>
        Doing these kinds of ranking algorithms is a lot of fun with graph databases. The algorithms
        are implemented by traversing the graph in a certain order, collecting information on the go,
        and deciding which paths to follow and what to include in the results.
    </p><p>
        We were only interested in recommendations of a certain degree of friends.
    </p><p>
        </p><div class="example"><a name="d0e816"></a><p class="title"><b>Example&nbsp;16.1.&nbsp;Recommendations</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">public</span> Map&lt;Movie,Integer&gt; recommendMovies(User user, <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> ratingDistance) {
    <span class="hl-keyword">final</span> DynamicRelationshipType RATED = withName(User.RATED);
    <span class="hl-keyword">final</span> Map&lt;Long,<span class="hl-keyword">int</span>[]&gt; ratings=<span class="hl-keyword">new</span> HashMap&lt;Long, <span class="hl-keyword">int</span>[]&gt;();
    TraversalDescription traversal= Traversal.description().breadthFirst()
        .relationships(withName(User.FRIEND)).relationships(RATED, OUTGOING)
        .evaluator(<span class="hl-keyword">new</span> Evaluator() {

      <span class="hl-keyword">public</span> Evaluation evaluate(Path path) {
          <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> length = path.length() - 1;
          <span class="hl-comment">// only as far as requested</span>
          <span class="hl-keyword">if</span> (length &gt; ratingDistance) <span class="hl-keyword">return</span> Evaluation.EXCLUDE_AND_PRUNE;
          Relationship rating = path.lastRelationship();
          <span class="hl-comment">// process RATED relationships, not FRIEND</span>
          <span class="hl-keyword">if</span> (rating != null &amp;&amp; rating.getType().equals(RATED)) {
              <span class="hl-comment">// my rated movies</span>
              <span class="hl-keyword">if</span> (length == 0) <span class="hl-keyword">return</span> Evaluation.EXCLUDE_AND_PRUNE;
              <span class="hl-keyword">final</span> <span class="hl-keyword">long</span> movieId = rating.getEndNode().getId();
              <span class="hl-keyword">int</span>[] stars = ratings.get(movieId);
              <span class="hl-keyword">if</span> (stars == null) {
                  stars = <span class="hl-keyword">new</span> <span class="hl-keyword">int</span>[2];
                  ratings.put(movieId, stars);
              }
              <span class="hl-comment">// aggregate for averaging, inverse to distance</span>
              <span class="hl-keyword">int</span> weight = ratingDistance - length;
              stars[0] += weight * (Integer) rating.getProperty(<span class="hl-string">"stars"</span>, 0);
              stars[1] += weight;
              <span class="hl-keyword">return</span> Evaluation.INCLUDE_AND_PRUNE;
          }
          <span class="hl-keyword">return</span> Evaluation.EXCLUDE_AND_CONTINUE;
      }
    });

    Map&lt;Movie,Integer&gt; result=<span class="hl-keyword">new</span> HashMap&lt;Movie, Integer&gt;();
    <span class="hl-comment">// lazy traversal results</span>
    <span class="hl-keyword">final</span> Iterable&lt;Movie&gt; movies = movieRepository.findAllByTraversal(user, traversal);
    <span class="hl-keyword">for</span> (Movie movie : movies) { <span class="hl-comment">// assign movie to averaged rating</span>
      <span class="hl-keyword">final</span> <span class="hl-keyword">int</span>[] stars = ratings.get(movie.getNodeId());
      result.put(movie, stars[0]/stars[1]);
    }
    <span class="hl-keyword">return</span> result;
}
</pre></div></div><p><br class="example-break">
    </p><p>
        The UserController simply called this method, added its results to the model, and the
        view rendered the recommendation alongside the user's own ratings.
    </p></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="reference"></a>Part&nbsp;II.&nbsp;Reference Documentation</h1></div></div></div><div class="partintro" lang="en"><div></div><p>
                </p><div class="mediaobject"><img src="introduction/springdatagraph.png" width="531.496062992126"></div><p>
            </p><p>
                This part of the Spring Data Graph Guide book provides the reference documentation. It details many
                aspects of the tutorial and also explains concepts that were only just mentioned there.
            </p><p>
                Its content covers information about the programming model, APIs, concepts, annotations and
                technical details of Spring Data Graph.
            </p><p>
                Whenever you look for the means to employ the full power of the Spring Data Graph library you find your
                answers in the reference section. If you don't, please inform us about missing or incorrect content so that
                we can fix that.
            </p></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:preface"></a>Reference Documentation</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e843"></a>1.&nbsp;Spring Data and Spring Data Graph</h2></div></div></div><p>
            <a class="ulink" href="http://springsource.org/spring-data" target="_top">Spring Data</a> is a SpringSource project that aims to
            provide Spring's convenient programming model and well known conventions for NOSQL databases. Currently there
            is support for graph (Neo4j), key-value (Redis, Riak), document (MongoDB) and relational (Oracle)
            databases. Mark Pollack, the author of Spring.NET, is the project lead for the Spring Data project.
        </p><p>
            The Spring Data Graph project, as part of the Spring Data initiative, aims to simplify development
            with the Neo4j graph database. Like JPA, it uses annotations on simple POJO domain objects.
            The annotations activate the AspectJ aspects in the Spring Data Graph framework, mapping the POJO entities
            and their fields to nodes, relationships, and properties in the graph database.
        </p><p>
            Spring Data Graph allows, at anytime, to drop down to the <a class="xref" href="#neo4j" title="Chapter&nbsp;17.&nbsp;Introduction to Neo4j">Chapter&nbsp;17, <i>Introduction to Neo4j</i></a> level to execute functionality with
            the highest performance possible.
        </p><p>
            For Integration of Neo4j and Grails/GORM please refer to the Neo4j
            <a class="ulink" href="http://www.grails.org/plugin/neo4j" target="_top">grails plugin</a>. For other language bindings or frameworks
            visit the <a class="ulink" href="http://wiki.neo4j.org/content/Main_Page#Language_and_framework_bindings" target="_top">Neo4j Wiki</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e866"></a>2.&nbsp;Reference Documentation Overview</h2></div></div></div><p>
        The explanation of Spring Data Graphs programming model starts with some underlying details.
        The basic internal workings of Spring Data Graph are explained in the initial chapter about AspectJ <a class="xref" href="#reference:aspectj" title="18.1.&nbsp;AspectJ support">Section&nbsp;18.1, &#8220;AspectJ support&#8221;</a>.
        It also explains some of the common issues around AspectJ tooling with the current IDEs.
    </p><p>
        To get started with a simple application, you need only your domain model and the annotations
        (see <a class="xref" href="#reference:programming-model:annotations" title="18.2.&nbsp;Defining node entities">Section&nbsp;18.2, &#8220;Defining node entities&#8221;</a>) provided by the library. You use annotations to
        mark domain objects to be backed by nodes and relationships of the graph database. For individual fields the
        annotations allow you to declare how they should be processed and mapped to the graph. For property fields and
        references to other entities this is straightforward.
    </p><p>
        To use advanced functionality like traversals, Cypher and Gremlin, a basic understanding of the graph data model is required.
        The graph data model is explained in the chapter about <a class="xref" href="#neo4j" title="Chapter&nbsp;17.&nbsp;Introduction to Neo4j">Chapter&nbsp;17, <i>Introduction to Neo4j</i></a>.
    </p><p>
        Relationships between entities are first class citizens in a graph database and therefore worth a separate
        <a class="xref" href="#reference:programming_model:relationships" title="18.3.&nbsp;Relating node entities">Section&nbsp;18.3, &#8220;Relating node entities&#8221;</a> describing their usage in Spring Data Graph.
    </p><p>
        To add fields that are just backed by graph operations is a bit more involved. First you should know
        about traversals, Cypher queries and Gremlin expressions.
        Those are explained in the <a class="xref" href="#neo4j" title="Chapter&nbsp;17.&nbsp;Introduction to Neo4j">Chapter&nbsp;17, <i>Introduction to Neo4j</i></a> chapter. Then you can start adding purely
        dynamically gathered fields to your entities.
    </p><p>
        You might probably use the additional
        entity methods (see <a class="xref" href="#reference:programming-model:introduced-methods" title="18.4.&nbsp;Introduced methods">Section&nbsp;18.4, &#8220;Introduced methods&#8221;</a>) that are added to your
        domain objects by Spring Data Graph. Those allow you to manage the entity lifecycles as well as to connect entities.
        Those methods also provide the means to execute the mentioned graph operations with your entity as a starting point.
    </p><p>
        Indexing operations are useful for finding individual nodes and relationships in a graph. They can be used to
        start graph operations or to be processed in your application. Indexing in the plain Neo4j API is a bit more involved.
        Spring Data Graph maintains automatic indexes per entity class, with @Indexed annotations on relevant fields.
        (<a class="xref" href="#reference:programming-model:indexing" title="18.5.&nbsp;Indexing">Section&nbsp;18.5, &#8220;Indexing&#8221;</a>)
    </p><p>
        If you don't want to go the path of persistence aware domain objects (Active-Record) but rather use a DAO layer,
        Spring Data Commons provides a repository abstraction that is also implemented in Spring Data Graph. Those repositories
        just consist of a composition of interfaces that declare the available methods on the concrete repository. The implementation
        details are handled by the library. At least for typical CRUD, Index- and Query-operatoins that is very convenient.
        For custom implementations of repository methods you are free to add your own code. (<a class="xref" href="#reference:programming-model:repositories" title="18.6.&nbsp;CRUD with repositories">Section&nbsp;18.6, &#8220;CRUD with repositories&#8221;</a>).
    </p><p>
        Neo4j is an ACID database, it uses Java transactions (and internally even a 2 phase commit protocol) to guarantee the
        safety of your data. The implications of that are described in the chapter around transactions. (<a class="xref" href="#reference:programming-model:transactions" title="18.7.&nbsp;Transactions">Section&nbsp;18.7, &#8220;Transactions&#8221;</a>)
    </p><p>
        The need of an active transaction for mutating the state of nodes or relationships implies that direct changes to
        the graph are only possible in a transactional context. Unfortunately many higher level application layers don't
        want to care about transactions and the open-session-in-view pattern is not widely used. Therefore Spring Data
        Graph introduced an entity lifecyle and added support for detached entities which can be used for temporary
        domain objects that are not intended to be stored in the graph or which will be attached to the graph only later.
        (<a class="xref" href="#reference:programming-model:lifecycle" title="18.8.&nbsp;Detached node entities">Section&nbsp;18.8, &#8220;Detached node entities&#8221;</a>)
    </p><p>
        Unlike Neo4j which is a schema free database, Spring Data Graph works on Java domain objects. So it needs to store
        the type information of the entities in the graph to be able to reconstruct them when just nodes are retrieved. To
        achieve that it employs type-representation-strategies which are described in a separate chapter.
        (<a class="xref" href="#reference:programming-model:typerepresentationstrategy" title="18.9.&nbsp;Entity type representation">Section&nbsp;18.9, &#8220;Entity type representation&#8221;</a>)
    </p><p>
        To be able to leverage the schema-free nature of Neo4j it is possible to project any entity to another entity type. That
        is useful as long as they share some properties (or relationships). The entities don't have to share any super-types
        or hierarchies. How that works is explained here: <a class="xref" href="#reference:programming-model:projection" title="18.10.&nbsp;Projecting entities">Section&nbsp;18.10, &#8220;Projecting entities&#8221;</a>.
    </p><p>
        Spring Data Graph offers basic support for bean property validation (JSR-303). Annotations from that JSR are recognized
        and evaluated whenever a property is set, or when a previously detached entity is persisted to the graph.
        (see <a class="xref" href="#reference:programming-model:validation" title="18.11.&nbsp;Bean validation (JSR-303)">Section&nbsp;18.11, &#8220;Bean validation (JSR-303)&#8221;</a>)
    </p><p>
        Unfortunately the setup of Spring Data Graph is more involved than we'd like. That is partly due to the maven setup
        and dependencies, which can be alleviated by using different build systems like gradle or ant/ivy. The Spring configuration
        itself boils down to two lines of <code class="code">&lt;datagraph&gt;</code> namespace setup. (see <a class="xref" href="#setup" title="Chapter&nbsp;19.&nbsp;Environment setup">Chapter&nbsp;19, <i>Environment setup</i></a>)
    </p><p>
        Spring Data Graph can also be used in a JPA environment to add graph features to your JPA entities. In the <a class="xref" href="#reference:cross-store" title="Chapter&nbsp;20.&nbsp;Cross-store persistence">Chapter&nbsp;20, <i>Cross-store persistence</i></a>
        the slightly different behavior and setup of a Graph-JPA interaction are described.
    </p><p>
        The provided samples, which are also publicly hosted on <a class="ulink" href="http://github.com/springsource/spring-data-graph-examples" target="_top">github</a> are explained in
        <a class="xref" href="#reference:samples" title="Chapter&nbsp;21.&nbsp;Sample code">Chapter&nbsp;21, <i>Sample code</i></a>.
    </p><p>
        The performance implications of using Spring Data Graph are detailed in <a class="xref" href="#reference:performance" title="Chapter&nbsp;22.&nbsp;Performance considerations">Chapter&nbsp;22, <i>Performance considerations</i></a>. This chapter also discusses
        which usecases should be handled with Spring Data Graph and when it should not be used.
    </p><p>
        Being a Spring Data library, Spring Data Graph also implements a comprehensive template for interacting with the Neo4j graph database.
        The <a class="xref" href="#reference:template" title="Chapter&nbsp;23.&nbsp;Neo4jTemplate">Chapter&nbsp;23, <i>Neo4jTemplate</i></a> provides all basic graph operations as well as advanced querying with
        Indexes, Cypher, Gremlin and Traversals with a convenient API.
    </p><p>
        As AspectJ might not come that easy to everyone, some of the core concepts of this Aspect oriented programming implementation for Java
        are explained in <a class="xref" href="#reference:aspectj-details" title="Chapter&nbsp;24.&nbsp;AspectJ details">Chapter&nbsp;24, <i>AspectJ details</i></a>.
    </p><p>
        How to consume the REST-API of a Neo4j-Server is the topic of <a class="xref" href="#reference:neo4j-server" title="Chapter&nbsp;25.&nbsp;Neo4j Server">Chapter&nbsp;25, <i>Neo4j Server</i></a>. But Spring Data Graph can also
        be used to create custom Extensions for the Neo4j Server which would serve domain model abstractions to a suitable front-end. So instead of
        talking low level primitives to a database, the front-end would communicate via a domain level protocol with endpoints implemented
        in Jersey and Spring Data Graph.
    </p><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
               As Spring Data Graph is based on AspectJ and uses some advanced features of that toolset, please
                be aware of that. Please see the section on AspectJ (<a class="xref" href="#reference:aspectj" title="18.1.&nbsp;AspectJ support">Section&nbsp;18.1, &#8220;AspectJ support&#8221;</a>) for
                details if you run into any problems.
            </p></div><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="neo4j"></a>Chapter&nbsp;17.&nbsp;Introduction to Neo4j</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e970"></a>17.1.&nbsp;What is a graph database?</h2></div></div></div><p>
            A graph database is a storage engine that is specialized in storing and retrieving vast networks of
            data. It efficiently stores nodes and relationships and allows high performance traversal of those
            structures. Properties can be added to nodes and relationships.
        </p><p>
            Graph databases are well suited for storing most kinds of domain models. In almost all domain models,
            there are certain things connected to other things. In most other modeling approaches, the relationships
            between things are reduced to a single link without identity and attributes. Graph databases allow one
            to keep the rich relationships that originate from the domain, equally well-represented in the database
            without resorting to also modeling the relationships as "things". There is very little "impedance
            mismatch" when putting real-life domains into a graph database.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e977"></a>17.2.&nbsp;About Neo4j</h2></div></div></div><p>
            <a class="ulink" href="http://neo4j.org/" target="_top">Neo4j</a> is a graph database. It is a fully transactional database
            (ACID) that stores data structured as graphs. A graph consists of nodes, connected by relationships.
            Inspired by the structure of the human brain, it allows for high query performance on complex data,
            while remaining intuitive and simple for the developer.
        </p><p>
            Neo4j has been in commercial development for 10 years and in production for over 7 years.
            Most importantly it has a helpful and contributing community surrounding it, but it also:
            </p><div class="itemizedlist"><ul type="disc"><li>has an intuitive graph-oriented model for data representation. Instead of tables, rows,
                and columns, you work with a graph consisting of
                <a class="ulink" href="http://wiki.neo4j.org/content/Getting_Started" target="_top">nodes, relationships, and properties</a>.
            </li><li>has a disk-based, native storage manager optimized for storing graph structures
                with maximum performance and scalability.
            </li><li>is scalable. Neo4j can handle graphs with many billions of nodes/relationships/properties on
                a single machine, but can also be scaled out across multiple machines for high availability.
            </li><li>has a powerful traversal framework for traversing in the node space.
            </li><li>can be deployed as a standalone server or an embedded database with a very small
                distribution footprint (~700k jar).
            </li><li>has a Java <a class="ulink" href="http://api.neo4j.org/" target="_top">API</a>.
            </li></ul></div><p>
        </p><p>
            In addition, Neo4j has ACID transactions, durable persistence, concurrency control, transaction
            recovery, high availability, and more. Neo4j is released under a dual free software/commercial
            license model.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1009"></a>17.3.&nbsp;GraphDatabaseService</h2></div></div></div><p>
            The interface <code class="code">org.neo4j.graphdb.GraphDatabaseService</code> provides access to the
            storage engine. Its features include creating and retrieving nodes and relationships, managing
            indexes (via the IndexManager), database life cycle callbacks, transaction management, and more.
		</p><p>
			The <code class="code">EmbeddedGraphDatabase</code> is an implementation of GraphDatabaseService that is used to
            embed Neo4j in a Java application.  This implementation is used so as to provide the highest
            and tightest integration with the database. Besides the embedded mode, the
            <a class="ulink" href="http://wiki.neo4j.org/content/Getting_Started_With_Neo4j_Server" target="_top">Neo4j server</a>
            provides access to the graph database via an HTTP-based REST API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1025"></a>17.4.&nbsp;Creating nodes and relationships</h2></div></div></div><p>
            Using the API of GraphDatabaseService, it is easy to create nodes and relate them to each other.
            Relationships are typed. Both nodes and relationships can have properties. Property values can be
            primitive Java types and Strings, or arrays of Java primitives or Strings. Node creation and
            modification has to happen within a transaction, while reading from the graph store can be
            done with or without a transaction.
        </p><div class="example"><a name="d0e1030"></a><p class="title"><b>Example&nbsp;17.1.&nbsp;Neo4j usage</b></p><div class="example-contents"><pre class="programlisting">GraphDatabaseService graphDb = <span class="hl-keyword">new</span> EmbeddedGraphDatabase( <span class="hl-string">"helloworld"</span> );
Transaction tx = graphDb.beginTx();
<span class="hl-keyword">try</span> {
	Node firstNode = graphDb.createNode();
	Node secondNode = graphDb.createNode();
	firstNode.setProperty( <span class="hl-string">"message"</span>, <span class="hl-string">"Hello, "</span> );
	secondNode.setProperty( <span class="hl-string">"message"</span>, <span class="hl-string">"world!"</span> );

	Relationship relationship = firstNode.createRelationshipTo( secondNode,
		DynamicRelationshipType.of(<span class="hl-string">"KNOWS"</span>) );
	relationship.setProperty( <span class="hl-string">"message"</span>, <span class="hl-string">"brave Neo4j "</span> );
	tx.success();
} <span class="hl-keyword">finally</span> {
	tx.finish();
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1035"></a>17.5.&nbsp;Graph traversal</h2></div></div></div><p>
            Getting a single node or relationship and examining it is not the main use case of a graph database.
            Fast graph traversal and application of graph algorithms are. Neo4j provides a DSL for defining
            <code class="code">TraversalDescription</code>s that can then be applied to a start node and will produce a
            lazy <code class="code">java.lang.Iterable</code> result of nodes and/or relationships.
        </p><div class="example"><a name="d0e1046"></a><p class="title"><b>Example&nbsp;17.2.&nbsp;Traversal usage</b></p><div class="example-contents"><pre class="programlisting">TraversalDescription traversalDescription = Traversal.description()
        .depthFirst()
        .relationships(KNOWS)
        .relationships(LIKES, Direction.INCOMING)
        .evaluator(Evaluators.toDepth(5));
<span class="hl-keyword">for</span> (Path position : traversalDescription.traverse(myStartNode)) {
    System.out.println(<span class="hl-string">"Path from start node to current position is "</span> + position);
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1051"></a>17.6.&nbsp;Indexing</h2></div></div></div><p>
            The best way for retrieving start nodes for traversals is by using Neo4j's integrated index
            facilities. The GraphDatabaseService provides access to the IndexManager which in turn provides
            named indexes for nodes and relationships. Both can be indexed with property names and values.
            Retrieval is done with query methods on indexes, returning an IndexHits iterator.
        </p><p>
            Spring Data Graph provides automatic indexing via the @Indexed annotation, eliminating the need
            for manual index management.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            Modifying Neo4j indexes also requires transactions.
        </div><div class="example"><a name="d0e1060"></a><p class="title"><b>Example&nbsp;17.3.&nbsp;Index usage</b></p><div class="example-contents"><pre class="programlisting">IndexManager indexManager = graphDb.index();
Index&lt;Node&gt; nodeIndex = indexManager.forNodes(<span class="hl-string">"a-node-index"</span>);
Node node = ...;
Transaction tx = graphDb.beginTx();
<span class="hl-keyword">try</span> {
    nodeIndex.add(node, <span class="hl-string">"property"</span>,<span class="hl-string">"value"</span>);
    tx.success();
} <span class="hl-keyword">finally</span> {
    tx.finish();
}
<span class="hl-keyword">for</span> (Node foundNode : nodeIndex.get(<span class="hl-string">"property"</span>,<span class="hl-string">"value"</span>)) {
    <span class="hl-comment">// found node</span>
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1065"></a>17.7.&nbsp;Querying with Cypher</h2></div></div></div><p>
            With version 1.4.M04 Neo4j introduced a textual query language called
            <a class="ulink" href="http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html" target="_top">"Cypher"</a> which draws from many
            sources. From graph matching like in SPARQL, some keywords and query structure that reminds of SQL and
            some iconic representation. A screencast presenting cypher queries on the cineasts.net dataset is available
            at <a class="ulink" href="http://video.neo4j.org/U2Y/introduction-to-cypher" target="_top">video.neo4j.org</a>. Cypher was written
            in Scala to leverage the high expressiveness for lazy sequence operations of the language and the great
            parser combinator library.
        </p><p>
            Cypher queries always begin with a <code class="code">start</code> set of nodes. Those can be either expressed by their
            id's or by a index lookup expression. Those start-nodes are then related to other nodes in the
            <code class="code">match</code> clause to other nodes. Start and match clause can introduce new identifiers for nodes and
            relationships. In the <code class="code">where</code> clause additional filtering of the result set is applied by evaluating
            boolean expressions. The <code class="code">return</code> clause defines which part of the query result will be available.
            Aggregation also happens in the return clause by using aggregation functions on some of the values.
            Sorting can happen in the <code class="code">order by</code> clause and the <code class="code">skip</code> and <code class="code">limit</code> parts
            restrict the result set to a certain window.
        </p><p>
            Cypher can be executed on an embedded graph db using <code class="code">ExecutionEngine</code> and
            <code class="code">CypherParser</code>. This is encapsulated in Spring Data Graph with
            <code class="code">CypherQueryEngine</code>. The Neo4j-REST-Server comes with a Cypher-Plugin that is accessible remotely and is
            available in the Spring Data Graph REST-Binding.
        </p><div class="example"><a name="d0e1110"></a><p class="title"><b>Example&nbsp;17.4.&nbsp;Cypher Examples on the Cineasts.net Dataset</b></p><div class="example-contents"><pre class="programlisting">
// Actors of Forrest Gump:
start movie=(Movie,id,'13') match (movie)&lt;-[:ACTS_IN]-(actor)
    return actor.name, actor.birthplace?

// User-Ratings:
start user=(User,login,'micha') match (user)-[r,:RATED]-&gt;(movie) where r.stars &gt; 3
    return movie.title, r.stars, r.comment

// Mutual Friend recommendations:
start user=(User,login,'micha') match (user)-[:FRIEND]-(friend)-[r,:RATED]-&gt;(movie) where r.stars &gt; 3
    return friend.name, movie.title, r.stars, r.comment?

// Movie suggestions based on a movie:
start movie=(Movie,id,'13') match (movie)&lt;-[:ACTS_IN]-()-[:ACTS_IN]-&gt;(suggestion)
    return suggestion.title, count(*) order by count(*) desc limit 5

// Co-Actors, sorted by count and name of Lucy Liu
start lucy=(1000) match (lucy)-[:ACTS_IN]-&gt;(movie)&lt;-[:ACTS_IN]-(co_actor)
    return count(*), co_actor.name order by count(*) desc,co_actor.name limit 20

// recommendations including counts, grouping and sorting
start user=(User,login,'micha') match (user)-[:FRIEND]-(friend)-[r,:RATED]-&gt;(movie)
    return movie.title, AVG(r.stars), count(*) order by AVG(r.stars) desc, count(*) desc
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1115"></a>17.8.&nbsp;Gremlin a Graph Traversal DSL</h2></div></div></div><p>
            Gremlin is an expressive Groovy DSL developed by <a class="ulink" href="http://markorodriguez.com" target="_top">Marko Rodriguez</a>
            as part of the <a class="ulink" href="http://tinkerpop.com" target="_top">tinkerpop</a> stack. It builds on top of a pipe implementation
            (Blueprints Pipes) that uses connected operations to traverse a graph. Gremlin has a concise syntax but is
            turing complete.
        </p><p>Gremlin can be executed by including the tinkerpop and blueprints dependencies and then requesting a <code class="code">ScriptEngine</code>
        of type "gremlin" from the <code class="code">javax.Script*</code> facilities. In Spring Data Graph this is encapsulated in
        <code class="code">GremlinQueryEngine</code>. The Neo4j-REST-Server also comes with a Gremlin-Plugin that is accessible remotely and is
            available in the Spring Data Graph REST-Binding.
        </p><div class="example"><a name="d0e1137"></a><p class="title"><b>Example&nbsp;17.5.&nbsp;Sample Gremlin Queries</b></p><div class="example-contents"><pre class="programlisting">
// Vertex with id 1
v = g.v(1)

// determine the name of the vertices that vertex 1 knows and that are older than 30 years of age
v.outE{it.label=='knows'}.inV{it.age &gt; 30}.name

// calculate basic collaborative filtering for vertex 1
m = [:]
g.v(1).out('likes').in('likes').out('likes').groupCount(m)
m.sort{a,b -&gt; a.value &lt;=&gt; b.value}
</pre></div></div><br class="example-break"></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="programming-model"></a>Chapter&nbsp;18.&nbsp;Programming model</h2></div></div></div><p>
        This chapter covers the fundamentals of the programming model behind Spring Data Graph. It discusses the
        AspectJ features used and the annotations provided by Spring Data Graph and how to use them.
        Examples for this section are taken from the "IMDB" project of
        <a class="ulink" href="http://github.com/SpringSource/spring-data-graph-examples" target="_top">Spring Data Graph examples</a>.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:aspectj"></a>18.1.&nbsp;AspectJ support</h2></div></div></div><p>
        Behind the scenes, Spring Data Graph leverages <a class="ulink" href="http://www.eclipse.org/aspectj/" target="_top">AspectJ</a>
        aspects to modify the behavior of simple annotated POJO entities
        (see <a class="xref" href="#reference:aspectj-details" title="Chapter&nbsp;24.&nbsp;AspectJ details">Chapter&nbsp;24, <i>AspectJ details</i></a>). Each node entity is backed by a graph node that holds its
        properties and relationships to other entities. AspectJ is used for intercepting field access, so that
        Spring Data Graph can retrieve the information from the entity's backing node or relationship in the database.
    </p><p>
        The aspect introduces some internal fields and some public methods
        (see <a class="xref" href="#reference:programming-model:introduced-methods" title="18.4.&nbsp;Introduced methods">Section&nbsp;18.4, &#8220;Introduced methods&#8221;</a>) to the entities, such as
        <code class="code">entity.getPersistentState()</code> and <code class="code">entity.relateTo</code>.
        It also introduces repository methods like<code class="code">find(Class&lt;? extends NodeEntity&gt;, TraversalDescription)</code>.
        Introduced methods for <code class="code">equals()</code> and <code class="code">hashCode()</code> use the underlying node or relationship.
    </p><p>
        Spring Data Graph internally uses an abstraction called <code class="code">EntityState</code> that the field
        access and instantiation advices of the aspect delegate to. This way, the aspect code is kept to a
        minimum, focusing mainly on the pointcuts and delegation code. The <code class="code">EntityState</code> then uses
        a number of <code class="code">FieldAccessorFactories</code> to create a <code class="code">FieldAccessor</code> instance per
        field that does the specific handling needed for the concrete field type. There are various layers of
        caching involved as well, so it handles repeated instantiation efficiently.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1193"></a>18.1.1.&nbsp;AspectJ IDE support</h3></div></div></div><p>
            As Spring Data Graph uses some advanced features of AspectJ, users may experience issues with
            their IDE reporting errors where in fact there are none. Features that might be reported wrongfully
            include: introduction of methods to interfaces, declaration of additional interfaces for annotated
            classes, and generified introduced methods.
        </p><p>
            IDE's not providing the full AJ support might mark parts of your code as errors.
            You should rely on your build-system and test to verify the correctness of the code. You might also have
            your Entities (or their interfaces) implement the <code class="code">NodeBacked</code> and <code class="code">RelationshipBacked</code>
            interfaces directly to benefit from completion support and error checking.
        </p><p>
            Eclipse and STS support AspectJ via the AJDT plugin which can be installed from the update-site:
            <a class="ulink" href="http://download.eclipse.org/tools/ajdt/36/update/" target="_top">http://download.eclipse.org/tools/ajdt/36/update/</a>
            (it might be necessary to use the latest development snapshot of the plugin
            <a class="ulink" href="http://download.eclipse.org/tools/ajdt/36/dev/update" target="_top">http://download.eclipse.org/tools/ajdt/36/dev/update</a>).
            The current version that does not show incorrect errors is AspectJ 1.6.12.M1 (included in STS 2.7.0.M2), previous versions are reported
            to mislead the user.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            There might be some issues with the eclipse maven plugin not adding AspectJ files correctly to the build path.
            If you encounter issues, please try the following:

            Try editing the build path to <code class="code">include **/*.aj</code> for the spring-data-neo4j project.
            You can do this by selecting "Build Path -&gt; Configure Build Path ..." from the Package Explorer.
            Then for the <code class="code">spring-data-neo4j/src/main/java</code> add <code class="code">**/*.aj</code> to the Included path.
        </p></div><p>
            The AspectJ support in IntelliJ IDEA lacks some of the features. JetBrains is working on improving
            the situation in their upcoming 11 release of their popular IDE. Their latest work is available
            under their early access program (EAP). Building the project with the AspectJ compiler
            <code class="code">ajc</code> works in IDEA (Options -&gt; Compiler -&gt; Java Compiler should show ajc). Make sure to
            give the compiler at least 512 MB of RAM.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:annotations"></a>18.2.&nbsp;Defining node entities</h2></div></div></div><p>
        Node entities are declared using the <code class="code">@NodeEntity</code> annotation. Relationship entities use
        the <code class="code">@RelationshipEntity</code> annotation.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1242"></a>18.2.1.&nbsp;@NodeEntity: The basic building block</h3></div></div></div><p>
            The <code class="code">@NodeEntity</code> annotation is used to turn a POJO class into an entity backed by a node
            in the graph database. Fields on the entity are by default mapped to properties of the node. Fields
            referencing other node entities (or collections thereof) are linked with relationships. If the
            <code class="code">useShortNames</code> attribute overridden to false, the property and relationship names will
            have the class name of the entity prepended.
        </p><p>
            <code class="code">@NodeEntity</code> annotations are inherited from super-types and interfaces. It is not necessary
            to annotate your domain objects at every inheritance level.
        </p><p>
            If the <code class="code">partial</code> attribute is set to true, this entity takes part in a cross-store setting,
            where the entity lives in both the graph database and a JPA data source. See
            <a class="xref" href="#">???</a> for more information.
        </p><p>
            Entity fields can be annotated with <code class="code">@GraphProperty</code>, <code class="code">@RelatedTo</code>,
            <code class="code">@RelatedToVia</code>, <code class="code">@Indexed</code>, <code class="code">@GraphId</code> and
            <code class="code">@GraphTraversal</code>.
        </p><div class="example"><a name="d0e1285"></a><p class="title"><b>Example&nbsp;18.1.&nbsp;Simple node entity</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Movie {
    String title;
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1290"></a>18.2.2.&nbsp;@GraphProperty: Optional annotation for property fields</h3></div></div></div><p>
            It is not necessary to annotate data fields, as they are persisted by default; all fields that
            contain primitive values are persisted directly to the graph. All fields convertible to String
            using the Spring conversion services will be stored as a string. Spring Data Graph includes a
            custom conversion factory that comes with converters for <code class="code">Enum</code>s and <code class="code">Date</code>s.
            Transient fields are not persisted.
        </p><p>
            Currently there is no support for handling arbitrary collections of primitive or convertable values.
            Support for this will be added by the 1.1. release.
        </p><p>
            This annotation is typically used with cross-store persistence. When a node entity is configured
            as partial, then all fields that should be persisted to the graph must be explicitly annotated
            with <code class="code">@GraphProperty</code>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1308"></a>18.2.3.&nbsp;@Indexed: Making entities searchable by field value</h3></div></div></div><p>
            The @Indexed annotation can be declared on fields that are intended to be indexed by the Neo4j
            indexing facilities. The resulting index can be used to later retrieve nodes or relationships
            that contain a certain property value, e.g. a name. Often an index is used to establish the start
            node for a traversal. Indexes are accessed by a repository for a particular node or relationship
            entity type. See <a class="xref" href="#reference:programming-model:indexing" title="18.5.&nbsp;Indexing">Section&nbsp;18.5, &#8220;Indexing&#8221;</a> and
            <a class="xref" href="#reference:programming-model:repositories" title="18.6.&nbsp;CRUD with repositories">Section&nbsp;18.6, &#8220;CRUD with repositories&#8221;</a> for more information.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1317"></a>18.2.4.&nbsp;@Query: fields as query result views</h3></div></div></div><p>
            The <code class="code">@Query</code> annotation leverages the delegation infrastructure used by the
            Spring Data Graph aspects. It provides dynamic fields which, when accessed, return the values
            selected by the provided query language expression. The provided query must contain a placeholder named <code class="code">%start</code>
            for the id of the current entity. For instance <code class="code">start n=(%start) match n-[:FRIEND]-&gt;friend return friend</code>.
            Graph queries can return variable number of entities. That's why annotation can be put onto fields
            with a single value, an Iterable of a concrete type or an Iterable of <code class="code">Map&lt;String,Object&gt;</code>.
            Additional parameters are taken from the params attribute of the <code class="code">@Query</code> annotation.
            The tuples form key-value pairs that are provided to the query at execution time.
        </p><div class="example"><a name="d0e1337"></a><p class="title"><b>Example&nbsp;18.2.&nbsp;@Graph on a node entity field</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Group {
    @Query(value = <span class="hl-string">"start n=(%start) match (n)-[:%relType]-&gt;(friend) return friend"</span>,
                params = {<span class="hl-string">"relType"</span>, <span class="hl-string">"FRIEND"</span>})
    <span class="hl-keyword">private</span> Iterable&lt;Person&gt; friends;
}
</pre></div></div><br class="example-break"><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                Please note that this annotation can also be used on repository methods.
            </div><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1347"></a>18.2.5.&nbsp;@GraphTraversal: fields as traversal result views</h3></div></div></div><p>
            The <code class="code">@GraphTraversal</code> annotation leverages the delegation infrastructure used by the
            Spring Data Graph aspects. It provides dynamic fields which, when accessed, return an Iterable
            of node entities that are the result of a traversal starting at the entity containing the field.
            The <code class="code">TraversalDescription</code> used for this is created by the
            <code class="code">FieldTraversalDescriptionBuilder</code> class defined by the <code class="code">traversalBuilder</code>
            attribute. The class of the resulting node entities must be provided with the
            <code class="code">elementClass</code> attribute.
        </p><div class="example"><a name="d0e1367"></a><p class="title"><b>Example&nbsp;18.3.&nbsp;@GraphTraversal from a node entity</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Group {
    @GraphTraversal(traversalBuilder = PeopleTraversalBuilder.<span class="hl-keyword">class</span>,
            elementClass = Person.<span class="hl-keyword">class</span>, params = <span class="hl-string">"persons"</span>)
    <span class="hl-keyword">private</span> Iterable&lt;Person&gt; people;

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> PeopleTraversalBuilder <span class="hl-keyword">implements</span> FieldTraversalDescriptionBuilder {
        @Override
        <span class="hl-keyword">public</span> TraversalDescription build(NodeBacked start, Field field, String... params) {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> TraversalDescriptionImpl()
                    .relationships(DynamicRelationshipType.withName(params[0]))
                    .filter(Traversal.returnAllButStartNode());
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming_model:relationships"></a>18.3.&nbsp;Relating node entities</h2></div></div></div><p>
        Since relationships are first-class citizens in Neo4j, associations between node entities are represented
        by relationships. In general, relationships are categorized by a type, and start and end nodes (which
        imply the direction of the relationship). Relationships can have an arbitrary number of properties.
        Spring Data Graph has special support to represent Neo4j relationships as entities too, but it is often
        not needed.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            As of Neo4j 1.4.M03, circular references are allowed. Spring Data Graph reflects this accordingly.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="reference:programming_model:relationships:relatedto"></a>18.3.1.&nbsp;@RelatedTo: Connecting node entities</h3></div></div></div><p>
            Every field of a node entity that references one or more other node entities is backed by relationships
            in the graph. These relationships are managed by Spring Data Graph automatically.
        </p><p>
            The simplest kind of relationship is a single field pointing to another node entity (1:1).
            In this case, the field does not have to be annotated at all, although the annotation may be
            used to control the direction and type of the relationship. When setting the field, a
            relationship is created. If the field is set to <code class="code">null</code>, the relationship is removed.
        </p><div class="example"><a name="d0e1390"></a><p class="title"><b>Example&nbsp;18.4.&nbsp;Single relationship field</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Movie {
    <span class="hl-keyword">private</span> Actor mostPaidActor;
}
</pre></div></div><br class="example-break"><p>
            It is also possible to have fields that reference a set of node entities (1:N). These fields come in
            two forms, modifiable or read-only. Modifiable fields are of the type <code class="code">java.util.Set&lt;T&gt;</code>,
            and read-only fields are <code class="code">java.lang.Iterable&lt;T&gt;</code>, where T is a @NodeEntity-annotated
            class.
        </p><div class="example"><a name="d0e1403"></a><p class="title"><b>Example&nbsp;18.5.&nbsp;Node entity with relationships</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Actor {
    @RelatedTo(type = <span class="hl-string">"mostPaidActor"</span>, direction = Direction.INCOMING)
    <span class="hl-keyword">private</span> Set&lt;Movie&gt; mostPaidIn;

    @RelatedTo(type = <span class="hl-string">"ACTS_IN"</span>)
    <span class="hl-keyword">private</span> Set&lt;Movie&gt; movies;
}
</pre></div></div><br class="example-break"><p>
            Fields referencing other entities should not be manually initialized, as they are managed by
            Spring Data Graph under the hood. 1:N fields can be accessed immediately, and Spring Data Graph
            will provide a java.util.Set representing the relationships. If the returned set is modified,
            the changes are reflected in the graph. Spring Data Graph also ensures that there is only one
            relationship of a given type between any two given entities.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Before an entity has been attached with <code class="code">persist()</code> for the first time, it will
                not have its state managed by Spring Data Graph. For example, given the Actor class defined above,
                if <code class="code">actor.movies</code> was accessed in a non-persisted entity, it would return
                <code class="code">null</code>, whereas if it was accessed in a persisted entity, it would return
                an empty managed set.
            </p></div><p>
            When you use an Interface as target type for the <code class="code">Set</code> and/or as <code class="code">elementClass</code>
            please make sure that it implements <code class="code">NodeBacked</code> either by extending that Super-Interface manually
            or by annotating the Interface with <code class="code">@NodeEntity</code> too.
        </p><p>
            By setting direction to <code class="code">BOTH</code>, relationships are created in the outgoing direction, but when the
            1:N field is read, it will include relationships in both directions. A cardinality of M:N is
            not necessary because relationships can be navigated in both directions.
        </p><p>
            The relationships can also be accessed by using the aspect-introduced methods
            <code class="code">entity.getRelationshipTo(target, type)</code> and
            <code class="code">entity.relateTo(target, type)</code> available on each NodeEntity.
            These methods find and create Neo4j relationships. It is also possible to manually remove
            relationships by using <code class="code">entity.removeRelationshipTo(target, type)</code>.
            Using these methods is significantly faster than adding/removing from the collection of
            relationships as it doesn't have to re-synchronize a whole set of relationships with the graph.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Other collection types than <code class="code">Set</code> are not supported so far, also currently NO
                <code class="code">Map&lt;RelationshipType,Set&lt;NodeBacked&gt;&gt;</code>.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1461"></a>18.3.2.&nbsp;@RelationshipEntity: Rich relationships</h3></div></div></div><p>
            To access the full data model of graph relationships, POJOs can also be annotated with
            <code class="code">@RelationshipEntity</code>, making them relationship entities. Just as node entities represent
            nodes in the graph, relationship entities represent relationships. As described above,
            fields annotated with <code class="code">@RelatedTo</code> provide a way to link node entities together
            via relationships, but it provides no way of accessing the relationships themselves.
        </p><p>
            Relationship entities cannot be instantiated directly but are rather created via
            node entities, either by @RelatedToVia-annotated fields
            (see <a class="xref" href="#reference:programming_model:relationships:relatedtovia" title="18.3.3.&nbsp;@RelatedToVia: Accessing relationship entities">Section&nbsp;18.3.3, &#8220;@RelatedToVia: Accessing relationship entities&#8221;</a>),
            or by the introduced
            <code class="code">entity.relateTo(target, relationshipClass, type)</code> and
            <code class="code">entity.getRelationshipTo(target, relationshipClass, type)</code> methods
            (see <a class="xref" href="#reference:programming-model:introduced-methods" title="18.4.&nbsp;Introduced methods">Section&nbsp;18.4, &#8220;Introduced methods&#8221;</a>).
        </p><p>
            Fields in relationship entities are, similarly to node entities, persisted as properties on
            the relationship. For accessing the two endpoints of the relationship, two special annotations
            are available: <code class="code">@StartNode</code> and <code class="code">@EndNode</code>. A field annotated with
            one of these annotations will provide read-only access to the corresponding endpoint, depending
            on the chosen annotation.
        </p><div class="example"><a name="d0e1492"></a><p class="title"><b>Example&nbsp;18.6.&nbsp;Relationship entity</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Actor {
    <span class="hl-keyword">public</span> Role playedIn(Movie movie, String title) {
        <span class="hl-keyword">return</span> relatedTo(movie, Role.<span class="hl-keyword">class</span>, <span class="hl-string">"ACTS_IN"</span>);
    }
}

@RelationshipEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Role {
    String title;

    @StartNode <span class="hl-keyword">private</span> Actor actor;
    @EndNode <span class="hl-keyword">private</span> Movie movie;
}
        </pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="reference:programming_model:relationships:relatedtovia"></a>18.3.3.&nbsp;@RelatedToVia: Accessing relationship entities</h3></div></div></div><p>
            To provide easy programmatic access to the richer relationship entities of the data model,
            the annotation <code class="code">@RelatedToVia</code> can be added on fields of type
            <code class="code">java.lang.Iterable&lt;T&gt;</code>, where T is a <code class="code">@RelationshipEntity</code>-annotated
            class. These fields provide read-only access to relationship entities.
        </p><div class="example"><a name="d0e1511"></a><p class="title"><b>Example&nbsp;18.7.&nbsp;Accessing relationship entities using @RelatedToVia</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Actor {
    @RelatedToVia(type = <span class="hl-string">"ACTS_IN"</span>)
    <span class="hl-keyword">private</span> Iterable&lt;Role&gt; roles;

    <span class="hl-keyword">public</span> Role playedIn(Movie movie, String title) {
        Role role = relateTo(movie, Role.<span class="hl-keyword">class</span>, <span class="hl-string">"ACTS_IN"</span>);
        role.setTitle(title);
        <span class="hl-keyword">return</span> role;
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:introduced-methods"></a>18.4.&nbsp;Introduced methods</h2></div></div></div><p>
        The node and relationship aspects introduce (via AspectJ ITD - inter type declaration) several
        methods to the entities.
        </p><div class="variablelist"><dl><dt><span class="term">
                    Persisting the node entity after creation and after changes outside of a transaction.
                    Participates in an open transaction, or creates its own implicit transaction otherwise.
                </span></dt><dd><p><code class="code">nodeEntity.persist()</code></p></dd><dt><span class="term">
                    Accessing node and relationship IDs
                </span></dt><dd><p><code class="code">nodeEntity.getNodeId()</code> and <code class="code">relationshipEntity.getRelationshipId()</code></p></dd><dt><span class="term">
                    Accessing the node or relationship backing the entity
                </span></dt><dd><p><code class="code">entity.getPersistentState()</code></p></dd><dt><span class="term">
                    equals() and hashCode() are delegated to the underlying state
                </span></dt><dd><p><code class="code">entity.equals()</code> and <code class="code">entity.hashCode()</code></p></dd><dt><span class="term">
                    Creating relationships to a target node entity, and returning the relationship entity instance
                </span></dt><dd><p><code class="code">nodeEntity.relateTo(targetEntity, relationshipClass, relationshipType)</code></p></dd><dt><span class="term">
                    Retrieving a single relationship entity
                </span></dt><dd><p><code class="code">nodeEntity.getRelationshipTo(targetEntity, relationshipClass, relationshipType)</code></p></dd><dt><span class="term">
                    Creating relationships to a target node entity and returning the relationship
                </span></dt><dd><p><code class="code">nodeEntity.relateTo(targetEntity, relationshipType)</code></p></dd><dt><span class="term">
                    Retrieving a single relationship
                </span></dt><dd><p><code class="code">nodeEntity.getRelationshipTo(targetEnttiy, relationshipType)</code></p></dd><dt><span class="term">
                    Removing a single relationship
                </span></dt><dd><p><code class="code">nodeEntity.removeRelationshipTo(targetEntity, relationshipType)</code></p></dd><dt><span class="term">
                    Remove the node entity, its relationships, and all index entries for it
                </span></dt><dd><p><code class="code">nodeEntity.remove()</code> and <code class="code">relationshipEntity.remove()</code></p></dd><dt><span class="term">
                    Project entity to a different target type, using the same backing state
                </span></dt><dd><p><code class="code">entity.projectTo(targetClass)</code></p></dd><dt><span class="term">
                    Traverse, starting from the current node. Returns end nodes of traversal converted to
                    the provided type.
                </span></dt><dd><p><code class="code">nodeEntity.findAllByTraversal(targetType, traversalDescription)</code></p></dd><dt><span class="term">
                    Traverse, starting from the current node. Returns <code class="code">EntityPath</code>s of the traversal result
                    bound to the provided start and end-node-entity types
                </span></dt><dd><p><code class="code">Iterable&lt;EntityPath&gt; findAllPathsByTraversal(traversalDescription)</code></p></dd><dt><span class="term">Executes the given query, replacing <code class="code">%start</code> with the node-id and returning the results converted to the target type.</span></dt><dd><p><code class="code">&lt;T&gt; Iterable&lt;T&gt; NodeBacked.findAllByQuery(final String query, final Class&lt;T&gt; targetType)</code></p></dd><dt><span class="term">Executes the given query, replacing <code class="code">%start</code> with the node-id and returning the original result, but with nodes and relationships replaced by their appropriate entities.</span></dt><dd><p><code class="code">Iterable&lt;Map&lt;String,Object&gt;&gt; NodeBacked.findAllByQuery(final String query)</code></p></dd><dt><span class="term">Executes the given query, replacing <code class="code">%start</code> with the node-id and returns a single result converted to the target type.</span></dt><dd><p><code class="code">&lt;T&gt; T NodeBacked.findByQuery(final String query, final Class&lt;T&gt; targetType)</code></p></dd></dl></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:indexing"></a>18.5.&nbsp;Indexing</h2></div></div></div><p>
        The Neo4j graph database can use different so-called index providers for exact lookups and fulltext
        searches. Lucene is the default index provider implementation. Each named index is configured to be
        fulltext or exact.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1661"></a>18.5.1.&nbsp;Exact and numeric index</h3></div></div></div><p>
            When using the standard Neo4j API, nodes and relationships have to be manually indexed with
            key-value pairs, typically being the property name and value. When using Spring Data Graph,
            this task is simplified to just adding an <code class="code">@Indexed</code> annotation on entity fields
            by which the entity should be searchable. This will result in automatic updates of the index
            every time an indexed field changes.
        </p><p>
            Numerical fields are indexed numerically so that they are available for range queries. All
            other fields are indexed with their string representation.
        </p><p>
            The @Indexed annotation also provides the option of using a custom index. The default index
            name is the simple class name of the entity, so that each class typically gets its own index.
            It is recommended to not have two entity classes with the same class name, regardless of
            package.
        </p><p>
            The indexes can be queried by using a repository (see
            <a class="xref" href="#reference:programming-model:repositories" title="18.6.&nbsp;CRUD with repositories">Section&nbsp;18.6, &#8220;CRUD with repositories&#8221;</a>).
            Typically, the repository is an instance of
            <code class="code">org.springframework.data.neo4j.repository.DirectGraphRepositoryFactory</code>.
            The methods <code class="code">findByPropertyValue()</code> and <code class="code">findAllByPropertyValue()</code> work on
            the exact indexes and return the first or all matches. To do range queries, use
            <code class="code">findAllByRange()</code> (please note that currently both values are inclusive).
        </p><div class="example"><a name="d0e1689"></a><p class="title"><b>Example&nbsp;18.8.&nbsp;Indexing entities</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Person {
    @Indexed(indexName = <span class="hl-string">"people"</span>) String name;
    @Indexed <span class="hl-keyword">int</span> age;
}

GraphRepository&lt;Person&gt; graphRepository = graphRepositoryFactory
        .createGraphRepository(Person.<span class="hl-keyword">class</span>);

<span class="hl-comment">// Exact match, in named index</span>
Person mark = graphRepository.findByPropertyValue(<span class="hl-string">"people"</span>, <span class="hl-string">"name"</span>, <span class="hl-string">"mark"</span>);

<span class="hl-comment">// Numeric range query, index name inferred automatically</span>
<span class="hl-keyword">for</span> (Person middleAgedDeveloper : graphRepository.findAllByRange(<span class="hl-string">"age"</span>, 20, 40)) {
    Developer developer=middleAgedDeveloper.projectTo(Developer.<span class="hl-keyword">class</span>);
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1694"></a>18.5.2.&nbsp;Fulltext indexes</h3></div></div></div><p>
            Spring Data Graph also supports fulltext indexes. By default, indexed fields are stored in
            an exact lookup index. To have them analyzed and prepared for fulltext search, the
            <code class="code">@Indexed</code> annotation has the boolean <code class="code">fulltext</code> attribute.

            Please note that fulltext indexes require a separate index name as the fulltext configuration
            is stored in the index itself.
        </p><p>
            Access to the fulltext index is provided by the <code class="code">findAllByQuery()</code> repository method.
            Wildcards like <code class="code">*</code> are allowed. Generally though, the fulltext querying rules of the
            underlying index provider apply. See the
            <a class="ulink" href="http://lucene.apache.org/java/3_0_1/" target="_top">Lucene documentation</a> for more
            information on this.
        </p><p>
            </p><div class="example"><a name="d0e1718"></a><p class="title"><b>Example&nbsp;18.9.&nbsp;Fulltext indexing</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Person {
    @Indexed(indexName = <span class="hl-string">"people-search"</span>, fulltext=true) String name;
}

GraphRepository&lt;Person&gt; graphRepository = graphRepositoryFactory
        .createGraphRepository(Person.<span class="hl-keyword">class</span>);

Person mark = graphRepository.findAllByQuery(<span class="hl-string">"people-search"</span>, <span class="hl-string">"name"</span>, <span class="hl-string">"ma*"</span>);
</pre></div></div><p><br class="example-break">

        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            Please note that indexes are currently created on demand, so whenever an index that doesn't exist
            is requested from a query or get operation it is created. This is subject to change but has
            currently the implication that those indexes won't be configured as fulltext which causes
            subsequent fulltext updates to those indexes to fail.
        </div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1726"></a>18.5.3.&nbsp;Manual index access</h3></div></div></div><p>
            The index for a domain class is also available from <code class="code">GraphDatabaseContext</code> via
            the <code class="code">getIndex()</code> method. The second parameter is optional and takes the index name
            if it should not be inferred from the class name. It returns the index implementation that is
            provided by Neo4j.
        </p><div class="example"><a name="d0e1737"></a><p class="title"><b>Example&nbsp;18.10.&nbsp;Manual index usage</b></p><div class="example-contents"><pre class="programlisting">@Autowired GraphDatabaseContext gdc;

<span class="hl-comment">// Default index</span>
Index&lt;Node&gt; personIndex = gdc.getIndex(Person.<span class="hl-keyword">class</span>);
personIndex.query(<span class="hl-keyword">new</span> QueryContext(NumericRangeQuery.new&Iacute;ntRange(<span class="hl-string">"age"</span>, 20, 40, true, true))
                       .sort(<span class="hl-keyword">new</span> Sort(<span class="hl-keyword">new</span> SortField(<span class="hl-string">"age"</span>, SortField.INT, false))));

<span class="hl-comment">// Named index</span>
Index&lt;Node&gt; namedPersonIndex = gdc.getIndex(Person.<span class="hl-keyword">class</span>, <span class="hl-string">"people"</span>);
namedPersonIndex.get(<span class="hl-string">"name"</span>, <span class="hl-string">"Mark"</span>);

<span class="hl-comment">// Fulltext index</span>
Index&lt;Node&gt; personFulltextIndex = gdc.getIndex(Person.<span class="hl-keyword">class</span>, <span class="hl-string">"people-search"</span>, true);
personFulltextIndex.query(<span class="hl-string">"name"</span>, <span class="hl-string">"*cha*"</span>);
personFulltextIndex.query(<span class="hl-string">"{name:*cha*}"</span>);
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1742"></a>18.5.4.&nbsp;Indexing in Neo4jTemplate</h3></div></div></div><p>
            Neo4jTemplate also offers index support, providing auto-indexing for fields at creation time.
            There is an <code class="code">autoIndex</code> method that can also add indexes for a set of fields in one go.
        </p><p>
            For querying the index, the template offers query methods that take either the exact match
            parameters or a query object/expression, and push the results wrapped uniformly as Paths to
            the supplied <code class="code">PathMapper</code> to be converted or collected.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:repositories"></a>18.6.&nbsp;CRUD with repositories</h2></div></div></div><p>
        The repositories provided by Spring Data Graph build on the composable repository infrastructure
        in <a class="ulink" href="http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/#repositories.custom-implementations" target="_top">Spring Data Commons</a>.
        They allow for interface based composition of repositories consisting of provided default
        implementations for certain interfaces and additional custom implementations for other methods.
    </p><p>
        Spring Data Graph repositories support annotated and named queries for the Neo4j
        <a class="ulink" href="http://docs.neo4j.org/chunked/milestone/query-lang.html" target="_top">Cypher</a> query-language.
    </p><p>
        Spring Data Graph comes with typed repository implementations that provide methods for
        locating node and relationship entities. There are 3 types of basic repository interfaces
        and implementations. <code class="code">CRUDRepository</code> provides basic operations,
        <code class="code">IndexRepository</code> and <code class="code">NamedIndexRepository</code> delegate to Neo4j's internal
        indexing subsystem for queries, and <code class="code">TraversalRepository</code> handles Neo4j traversals.
    </p><p>
        <code class="code">GraphRepository</code> is a convenience repository interface, extending <code class="code">CRUDRepository</code>,
        <code class="code">IndexRepository</code>, and <code class="code">TraversalRepository</code>. Generally, it has all the
        desired repository methods. If named index operations are required, then <code class="code">NamedIndexRepository</code>
        may also be included.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1810"></a>18.6.1.&nbsp;CRUDRepository</h3></div></div></div><p>
            <code class="code">CRUDRepository</code> delegates to the configured <code class="code">TypeRepresentationStrategy</code>
            (see <a class="xref" href="#reference:programming-model:typerepresentationstrategy" title="18.9.&nbsp;Entity type representation">Section&nbsp;18.9, &#8220;Entity type representation&#8221;</a>)
            for type based queries.
            </p><div class="variablelist"><dl><dt><span class="term">Load an instance via a Neo4j node id</span></dt><dd><p><code class="code">T findOne(id)</code></p></dd><dt><span class="term">Check for existence of a Neo4j node id</span></dt><dd><p><code class="code">boolean exists(id)</code></p></dd><dt><span class="term">Iterate over all nodes of a node entity type</span></dt><dd><p><code class="code">Iterable&lt;T&gt; findAll()</code>
                        (supported in future versions:
                        <code class="code">Iterable&lt;T&gt; findAll(Sort)</code> and
                        <code class="code">Page&lt;T&gt; findAll(Pageable)</code>)</p></dd><dt><span class="term">Count the instances of a node entity type</span></dt><dd><p><code class="code">Long count()</code></p></dd><dt><span class="term">Save a graph entity</span></dt><dd><p><code class="code">T save(T)</code> and <code class="code">Iterable&lt;T&gt; save(Iterable&lt;T&gt;)</code></p></dd><dt><span class="term">Delete a graph entity</span></dt><dd><p><code class="code">void delete(T)</code>, <code class="code">void; delete(Iterable&lt;T&gt;)</code>,
                        and <code class="code">deleteAll()</code></p></dd></dl></div><p>
        </p><p>
            Important to note here is that the <code class="code">save</code>, <code class="code">delete</code>, and <code class="code">deleteAll</code>
            methods are only there to conform to the <code class="code">org.springframework.data.repository.Repository</code>
            interface. The recommended way of saving and deleting entities is by using <code class="code">entity.persist()</code>
            and <code class="code">entity.remove()</code>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1903"></a>18.6.2.&nbsp;IndexRepository and NamedIndexRepository</h3></div></div></div><p>
            <code class="code">IndexRepository</code> works with the indexing subsystem and provides methods to find
            entities by indexed properties, ranged queries, and combinations thereof. The index key is
            the name of the indexed entity field, unless overridden in the <code class="code">@Indexed</code> annotation.
            </p><div class="variablelist"><dl><dt><span class="term">Iterate over all indexed entity instances with a certain field value</span></dt><dd><p><code class="code">Iterable&lt;T&gt; findAllByPropertyValue(key, value)</code></p></dd><dt><span class="term">Get a single entity instance with a certain field value</span></dt><dd><p><code class="code">T findByPropertyValue(key, value)</code></p></dd><dt><span class="term">Iterate over all indexed entity instances with field values in a certain numerical range (inclusive)</span></dt><dd><p><code class="code">Iterable&lt;T&gt; findAllByRange(key, from, to)</code></p></dd><dt><span class="term">Iterate over all indexed entity instances with field values matching the given fulltext string or QueryContext query</span></dt><dd><p><code class="code">Iterable&lt;T&gt; findAllByQuery(key, queryOrQueryContext)</code></p></dd></dl></div><p>
        </p><p>
            There is also a <code class="code">NamedIndexRepository</code> with the same methods, but with an additional index
            name parameter, making it possible to query any index.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1949"></a>18.6.3.&nbsp;TraversalRepository</h3></div></div></div><p>
            <code class="code">TraversalRepository</code> delegates to the Neo4j traversal framework.
            </p><div class="variablelist"><dl><dt><span class="term">Iterate over a traversal result</span></dt><dd><p><code class="code">Iterable&lt;T&gt; findAllByTraversal(startEntity, traversalDescription)</code></p></dd></dl></div><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1966"></a>18.6.4.&nbsp;Cypher-Queries</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1969"></a>18.6.4.1.&nbsp;Annotated Queries</h4></div></div></div><p>
            Queries for the cypher graph-query language can be supplied with the <code class="code">@Query</code> annotation.
            That means every method annotated with <code class="code">@Query("start n=(%node) match (n)--&gt;(m) return m")</code>
            will use the query string. The named parameter <code class="code">%node</code> will be replaced by the actual method parameters.
            Node and Relationship-Entities are resolved to their respective id's and all other parameters are
            replaced directly (i.e. Strings, Longs, etc). There is special support for the <code class="code">Sort</code> and <code class="code">Pageable</code>
            parameters from Spring Data Commons, which are supported to add programmatic paging and sorting (alternatively
            static paging and sorting can be supplied in the query string itself).

            For using the named parameters you have to either annotate the parameters of the method with the
            <code class="code">@Param("node")</code> annotation or enable debug symbols.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1992"></a>18.6.4.2.&nbsp;Named Queries</h4></div></div></div><p>Spring Data Graph also supports the notion of named queries which are externalized in property-config-files
            (<code class="code">META-INF/graph-named-queries.properties</code>). Those files have the format:
            <code class="code">Entity.finderName=query</code> (e.g. <code class="code">Person.findBoss=start p=(%person) match (p)&lt;-[:BOSS]-(boss) return boss</code>).
            Otherwise named queries support the same parameters as annotated queries. For using the named parameters you have to either
            annotate the parameters of the method with the <code class="code">@Param("person")</code> annotation or enable debug symbols.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2009"></a>18.6.4.3.&nbsp;Query results</h4></div></div></div><p>Typical results for queries are <code class="code">Iterable&lt;Type&gt;, Iterable&lt;Map&lt;String,Object&gt;&gt;, Type and Page&lt;Type&gt;</code>.
                Nodes and Relationships are converted to their respective Entities (if they exist). Other values are converted
                using the registered Spring conversion services (e.g. enums).
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2017"></a>18.6.4.4.&nbsp;Cypher Examples</h4></div></div></div><p>There is a <a class="ulink" href="http://neo4j.vidcaster.com/U2Y/introduction-to-cypher" target="_top">screencast</a> available showing many features of the query language.
                The following examples are taken from the cineasts dataset of the tutorial section.
                </p><div class="variablelist"><dl><dt><span class="term"><code class="code">start n=(0) return n</code></span></dt><dd><p>returns the node with id 0</p></dd><dt><span class="term"><code class="code">start movie=(Movie,title,'Matrix') return movie</code></span></dt><dd><p>returns the nodes which are indexed as 'Matrix'</p></dd><dt><span class="term"><code class="code">start movie=(Movie,title,'Matrix') match (movie)&lt;-[:ACTS_IN]-(actor) return actor.name</code></span></dt><dd><p>returns the names of the actors that have a ACTS_IN relationship to the movie node for matrix</p></dd><dt><span class="term"><code class="code">start movie=(Movie,title,'Matrix') match (movie)&lt;-[r,:RATED]-(user) where r.stars &gt; 3 return user.name, r.stars, r.comment</code></span></dt><dd><p>returns users names and their ratings (&gt;3) of the movie matrix</p></dd><dt><span class="term"><code class="code">start user=(User,login,'micha') match (user)-[:FRIEND]-(friend)-[r,:RATED]-&gt;(movie) return movie.title, AVG(r.stars), count(*) order by AVG(r.stars) desc, count(*) desc</code></span></dt><dd><p>returns the movies rate by the friends of the user 'micha', aggregated by movie.title, with averaged ratings and rating-counts sorted by both</p></dd></dl></div><p>
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2062"></a>18.6.5.&nbsp;Creating repositories</h3></div></div></div><p>
            The <code class="code">Repository</code> instances are either created manually via a
            <code class="code">DirectGraphRepositoryFactory</code>, bound to a concrete node or relationship entity class.
            The <code class="code">DirectGraphRepositoryFactory</code> is configured in the Spring context and can be injected.
        </p><div class="example"><a name="d0e2076"></a><p class="title"><b>Example&nbsp;18.11.&nbsp;Using GraphRepositories</b></p><div class="example-contents"><pre class="programlisting">GraphRepository&lt;Person&gt; graphRepository = graphRepositoryFactory
        .createGraphRepository(Person.<span class="hl-keyword">class</span>);

Person michael = graphRepository.save(<span class="hl-keyword">new</span> Person(<span class="hl-string">"Michael"</span>, 36));

Person dave = graphRepository.findOne(123);

Long numberOfPeople = graphRepository.count();

Person mark = graphRepository.findByPropertyValue(<span class="hl-string">"name"</span>, <span class="hl-string">"mark"</span>);

Iterable&lt;Person&gt; devs = graphRepository.findAllByProperyValue(<span class="hl-string">"occupation"</span>, <span class="hl-string">"developer"</span>);

Iterable&lt;Person&gt; middleAgedPeople = graphRepository.findAllByRange(<span class="hl-string">"age"</span>, 20, 40);

Iterable&lt;Person&gt; aTeam = graphRepository.findAllByQuery(<span class="hl-string">"name"</span>, <span class="hl-string">"A*"</span>);

Iterable&lt;Person&gt; davesFriends = graphRepository.findAllByTraversal(dave,
    Traversal.description().pruneAfterDepth(1)
    .relationships(KNOWS).filter(returnAllButStartNode()));
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2081"></a>18.6.6.&nbsp;Composing repositories</h3></div></div></div><p>
            The recommended way of providing repositories is to define a repository interface per domain
            class. The mechanisms provided by the repository infrastructure will automatically detect
            them, along with additional implementation classes, and create an injectable repository
            implementation to be used in services or other spring beans.
        </p><div class="example"><a name="d0e2086"></a><p class="title"><b>Example&nbsp;18.12.&nbsp;Composing repositories</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> PersonRepository <span class="hl-keyword">extends</span> GraphRepository&lt;Person&gt;, PersonRepositoryExtension {}

<span class="hl-comment">// alternatively select some of the required repositories individually</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> PersonRepository <span class="hl-keyword">extends</span> CRUDGraphRepository&lt;Node,Person&gt;,
        IndexQueryExecutor&lt;Node,Person&gt;, TraversalQueryExecutor&lt;Node,Person&gt;,
        PersonRepositoryExtension {}

<span class="hl-comment">// provide a custom extension if needed</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> PersonRepositoryExtension {
    Iterable&lt;Person&gt; findFriends(Person person);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonRepositoryImpl <span class="hl-keyword">implements</span> PersonRepositoryExtension {
    <span class="hl-comment">// optionally inject default repository, or use DirectGraphRepositoryFactory</span>
    @Autowired PersonRepository baseRepository;
    <span class="hl-keyword">public</span> Iterable&lt;Person&gt; findFriends(Person person) {
        <span class="hl-keyword">return</span> baseRepository.findAllByTraversal(person, friendsTraversal);
    }
}

<span class="hl-comment">// configure the repositories, preferably via the datagraph:repositories namespace</span>
<span class="hl-comment">// (graphDatabaseContext reference is optional)</span>
&lt;datagraph:repositories base-<span class="hl-keyword">package</span>=<span class="hl-string">"org.springframework.data.neo4j"</span>
    graph-database-context-ref=<span class="hl-string">"graphDatabaseContext"</span>/&gt;

<span class="hl-comment">// have it injected</span>
@Autowired
PersonRepository personRepository;

Person michael = personRepository.save(<span class="hl-keyword">new</span> Person(<span class="hl-string">"Michael"</span>,36));

Person dave=personRepository.findOne(123);

Iterable&lt;Person&gt; devs = personRepository.findAllByProperyValue(<span class="hl-string">"occupation"</span>,<span class="hl-string">"developer"</span>);

Iterable&lt;Person&gt; aTeam = graphRepository.findAllByQuery( <span class="hl-string">"name"</span>,<span class="hl-string">"A*"</span>);

Iterable&lt;Person&gt; friends = personRepository.findFriends(dave);
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:transactions"></a>18.7.&nbsp;Transactions</h2></div></div></div><p>
        Neo4j is a transactional database, only allowing modifications to be performed within transaction
        boundaries. Reading data does however not require transactions.
    </p><p>
        Spring Data Graph integrates with transaction managers configured using Spring. The simplest
        scenario of just running the graph database uses a SpringTransactionManager provided by the
        Neo4j kernel to be used with Spring's JtaTransactionManager. That is, configuring Spring to
        use Neo4j's transaction manager.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            The explicit XML configuration given below is encoded in the <code class="code">Neo4jConfiguration</code>
            configuration bean that uses Spring's <code class="code">@Configuration</code> feature. This greatly
            simplifies the configuration of Spring Data Graph.
            
        </p></div><div class="example"><a name="d0e2109"></a><p class="title"><b>Example&nbsp;18.13.&nbsp;Simple transaction manager configuration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"transactionManager"</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.kernel.impl.transaction.SpringTransactionManager"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"graphDatabaseService"</span>/&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userTransaction"</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.kernel.impl.transaction.UserTransactionImpl"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"graphDatabaseService"</span>/&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">tx:annotation-driven</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"aspectj"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span>/&gt;
</pre></div></div><br class="example-break"><p>
        For scenarios with multiple transactional resources there are two options. The first option
        is to have Neo4j participate in the externally configured transaction manager by using the
        Spring support in Neo4j by enabling the configuration parameter for your graph database.
        Neo4j will then use Spring's transaction manager instead of its own.
    </p><div class="example"><a name="d0e2116"></a><p class="title"><b>Example&nbsp;18.14.&nbsp;Neo4j Spring integration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">![CDATA[&lt;context:annotation-config</span> /&gt;
&lt;<span class="hl-tag">context:spring-configured</span>/&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"transactionManager"</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jotm"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.neo4j.transaction.JotmFactoryBean"</span>/&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.kernel.EmbeddedGraphDatabase"</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"shutdown"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"target/test-db"</span>/&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">map</span>&gt;
            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"tx_manager_impl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"spring-jta"</span>/&gt;
        &lt;<span class="hl-tag">/map</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">tx:annotation-driven</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"aspectj"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span>/&gt;
</pre></div></div><br class="example-break"><p>
        One can also configure a stock XA transaction manager (e.g. Atomikos, JOTM, App-Server-TM) to be
        used with Neo4j and the other resources. For a bit less secure but fast 1 phase commit best effort,
        use <code class="code">ChainedTransactionManager</code>, which comes bundled with Spring Data Graph. It takes a
        list of transaction managers as constructor params and will handle them in order for transaction
        start and commit (or rollback) in the reverse order.
    </p><div class="example"><a name="d0e2126"></a><p class="title"><b>Example&nbsp;18.15.&nbsp;ChainedTransactionManager example</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">![CDATA[&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jpaTransactionManager"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"entityManagerFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"entityManagerFactory"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jtaTransactionManager"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.transaction.jta.JtaTransactionManager"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"transactionManager"</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.kernel.impl.transaction.SpringTransactionManager"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"graphDatabaseService"</span> /&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"userTransaction"</span>&gt;
        &lt;<span class="hl-tag">bean</span>  <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.kernel.impl.transaction.UserTransactionImpl"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"graphDatabaseService"</span> /&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.neo4j.transaction.ChainedTransactionManager"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">list</span>&gt;
            &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jpaTransactionManager"</span>/&gt;
            &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jtaTransactionManager"</span>/&gt;
        &lt;<span class="hl-tag">/list</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">tx:annotation-driven</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"aspectj"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span>/&gt;
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:lifecycle"></a>18.8.&nbsp;Detached node entities</h2></div></div></div><p>
        Node entities can be in two different persistence state: attached or detached. By default, newly created node
        entities are in the detached state. When <code class="code">persist()</code> is called on the entity, it becomes
        attached to the graph, and its properties and relationships are stores in the database. If
        <code class="code">persist()</code> is not called within a transaction, it automatically creates an implicit
        transaction for the operation.
    </p><p>
        Changing an attached entity inside a transaction will immediately write through the changes to
        the datastore. Whenever an entity is changed outside of a transaction it becomes detached. The
        changes are stored in the entity itself until the next call to <code class="code">persist()</code>.
    </p><p>
        All entities returned by library functions are initially in an attached state.
        Just as with any other entity, changing them outside of a transaction detaches them, and they
        must be reattached with <code class="code">persist()</code> for the data to be saved.
    </p><div class="example"><a name="d0e2158"></a><p class="title"><b>Example&nbsp;18.16.&nbsp;Persisting entities</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Person {
    String name;
    Person(String name) { <span class="hl-keyword">this</span>.name = name; }
}

<span class="hl-comment">// Store Michael in the database.</span>
Person p = <span class="hl-keyword">new</span> Person(<span class="hl-string">"Michael"</span>).persist();
</pre></div></div><br class="example-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="reference:programming-model:detached:relating"></a>18.8.1.&nbsp;Relating detached entities</h3></div></div></div><p>
            As mentioned above, an entity simply created with the <code class="code">new</code> keyword starts out detached.
            It also has no state assigned to it. If you create a new entity with <code class="code">new</code> and then throw
            it away, the database won't be touched at all.
        </p><p>
            Now consider this scenario:
            </p><div class="example"><a name="d0e2176"></a><p class="title"><b>Example&nbsp;18.17.&nbsp;Relationships outside of transactions</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Movie {
    <span class="hl-keyword">private</span> Actor topActor;
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTopActor(Actor actor) {
        topActor = actor;
    }
}

@NodeEntity
<span class="hl-keyword">class</span> Actor {
}

Movie movie = <span class="hl-keyword">new</span> Movie();
Actor actor = <span class="hl-keyword">new</span> Actor();

movie.setTopActor(actor);
</pre></div></div><p><br class="example-break">
        </p><p>
            Neither the actor nor the movie has been assigned a node in the graph. If we were to call
            <code class="code">movie.persist()</code>, then Spring Data Graph would first create a node for the movie.
            It would then note that there is a relationship to an actor, so it would call actor.persist()
            in a cascading fashion. Once the actor has been persisted, it will create the relationship
            from the movie to the actor. All of this will be done atomically in one transaction.
        </p><p>
            Important to note here is that if <code class="code">actor.persist()</code> is called instead, then only
            the actor will be persisted. The reason for this is that the actor entity knows nothing about
            the movie entity. It is the movie entity that has the reference to the actor. Also note that
            this behavior is not dependent on any configured relationship direction on the annotations.
            It is a matter of Java references and is not related to the data model in the database.
        </p><p>
            The persist operation (merge) stores all properties of the entity to the graph database
            and puts the entity in attached mode. There is no need to update the reference to the Java
            POJO as the underlying backing node handles the read-through transparently. If multiple
            object instances that point to the same node are persisted, the ordering is not important
            as long as they contain distinct changes. For concurrent changes a concurrent modification
            exception is thrown (subject to be parametrizable in the future).
        </p><p>
            If the relationships form a cycle, then the entities will first all be assigned a node in
            the database, and then the relationships will be created. The cascading of <code class="code">persist()</code>
            is however only cascaded to related entity fields that have been modified.
        </p><p>
            In the following example, the actor and the movie are both attached entites, having both been
            previously persisted to the graph:
            </p><div class="example"><a name="d0e2201"></a><p class="title"><b>Example&nbsp;18.18.&nbsp;Cascade for modified fields</b></p><div class="example-contents"><pre class="programlisting">actor.setName(<span class="hl-string">"Billy Bob"</span>);
movie.persist();
</pre></div></div><p><br class="example-break">
            In this case, even though the movie has a reference to the actor, the name change on the actor
            will not be persisted by the call to <code class="code">movie.persist()</code>. The reason for this is, as
            mentioned above, that cascading will only be done for fields that have been modified. Since the
            <code class="code">movie.topActor</code> field has not been modified, it will not cascade the persist operation
            to the actor.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:typerepresentationstrategy"></a>18.9.&nbsp;Entity type representation</h2></div></div></div><p>
        There are several ways to represent the Java type hierarchy of the data model in the graph. In general, for all
        node and relationship entities, type information is needed to perform certain repository operations. Some of
        this type information is saved in the graph database.
    </p><p>
        Implementations of <code class="code">TypeRepresentationStrategy</code> take care of persisting this information on entity instance
        creation. They also provide the repository methods that use this type information to perform their operations,
        like findAll and count.
    </p><p>
        There are three available implementations for node entities to choose from.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <code class="code">IndexingNodeTypeRepresentationStrategy</code>
                </p><p>
                    Stores entity types in the integrated index. Each entity node gets indexed with its type and
                    any supertypes that are also<code class="code">@NodeEntity</code>-annotated. The special index used for this
                    is called<code class="code">__types__</code>. Additionally, in order to get the type of an entity node, each
                    node has a property
                    <code class="code">__type__</code>
                    with the type of that entity.
                </p></li><li><p>
                    <code class="code">SubReferenceNodeTypeRepresentationStrategy</code>
                </p><p>
                    Stores entity types in a tree in the graph representing the type hierarchy. Each entity
                    has a INSTANCE_OF relationship to a type node representing that entity's type. The type may or
                    may not have a SUBCLASS_OF relationship to another type node.
                </p></li><li><p>
                    <code class="code">NoopNodeTypeRepresentationStrategy</code>
                </p><p>
                    Does not store any type information, and does hence not support finding by type, counting by type,
                    or retrieving the type of any entity.
                </p></li></ul></div><p>
    </p><p>
        There are two implementations for relationship entities available, same behavior as the corresponding ones
        above:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <code class="code">IndexingRelationshipTypeRepresentationStrategy</code>
                </p></li><li><p>
                    <code class="code">NoopRelationshipTypeRepresentationStrategy</code>
                </p></li></ul></div><p>
    </p><p>
        Spring Data Graph will by default autodetect which are the most suitable strategies for node and relationship
        entities. For new data stores, it will always opt for the indexing strategies. If a data store was created
        with the older<code class="code">SubReferenceNodeTypeRepresentationStrategy</code>, then it will continue to use that
        strategy for node entities. It will however in that case use the no-op strategy for relationship entities,
        which means that the old data stores have no support for searching for relationship entities. The indexing
        strategies are recommended for all new users.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:projection"></a>18.10.&nbsp;Projecting entities</h2></div></div></div><p>
        As the underlying data model of a graph database doesn't imply and enforce strict type constraints like a
        relational model does, it offers much more flexibility on how to model your domain classes and which of
        those to use in different contexts.
    </p><p>
        For instance an order can be used in these contexts: customer, procurement, logistics, billing, fulfillment
        and many more. Each of those contexts requires its distinct set of attributes and operations. As Java
        doesn't support mixins one would put the sum of all of those into the entity class and thereby making it
        very big, brittle and hard to understand. Being able to take a basic order and project it to a different
        (not related in the inheritance hierarchy or even an interface) order type that is valid in the current
        context and only offers the attributes and methods needed here would be very benefitial.
    </p><p>Spring Data Graph offers initial support for projecting node and relationship entities to different target
        types. All instances of this projected entity share the same backing node or relationship, so data changes are
        reflected immediately.
    </p><p>
        This could for instance also be used to handle nodes of a traversal with a unified (simpler) type (e.g. for
        reporting or auditing) and only project them to a concrete, more functional target type when the business
        logic requires it.
    </p><div class="example"><a name="d0e2315"></a><p class="title"><b>Example&nbsp;18.19.&nbsp;Projection of entities</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Trainee {
    String name;
    @RelatedTo
    Set&lt;Training&gt; trainings;
}

<span class="hl-keyword">for</span> (Person person : graphRepository.findAllByProperyValue(<span class="hl-string">"occupation"</span>,<span class="hl-string">"developer"</span>)) {
    Developer developer = person.projectTo(Developer.<span class="hl-keyword">class</span>);
    <span class="hl-keyword">if</span> (developer.isJavaDeveloper()) {
        trainInSpringData(developer.projectTo(Trainee.<span class="hl-keyword">class</span>));
    }
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reference:programming-model:validation"></a>18.11.&nbsp;Bean validation (JSR-303)</h2></div></div></div><p>
        Spring Data Graph supports property-based validation support. When a property is changed, it is
        checked against the annotated constraints, e.g. <code class="code">@Min</code>, <code class="code">@Max</code>,
        <code class="code">@Size</code>, etc. Validation errors throw a <code class="code">ValidationException</code>. The validation
        support that comes with Spring is used for evaluating the constraints. To use this feature, a validator
        has to be registered with the <code class="code">GraphDatabaseContext</code>.
    </p><div class="example"><a name="d0e2340"></a><p class="title"><b>Example&nbsp;18.20.&nbsp;Bean validation</b></p><div class="example-contents"><pre class="programlisting">@NodeEntity
<span class="hl-keyword">class</span> Person {
    @Size(min = 3, max = 20)
    String name;

    @Min(0) @Max(100)
    <span class="hl-keyword">int</span> age;
}
</pre></div></div><br class="example-break"></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="setup"></a>Chapter&nbsp;19.&nbsp;Environment setup</h2></div></div></div><p>
        Spring Data Graph dramatically simplifies development, but some setup is naturally required.
        For building the application, Maven needs to be configured to include the Spring Data Graph dependencies,
        and configure the AspectJ weaving. After the build setup is complete, the Spring application needs to be
        configured to make use of Spring Data Graph.
		
        
    </p><p>
        Spring Data Graph projects can be built using maven, we also added means to build them with gradle and ant/ivy.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2356"></a>19.1.&nbsp;Gradle configuration</h2></div></div></div><p>
            The necessary build plugin to build Spring Data Graph projects with gradle is available as part of the
            SDG distribution or on github which makes the usage as easy as:
        </p><div class="example"><a name="d0e2361"></a><p class="title"><b>Example&nbsp;19.1.&nbsp;Gradle Build Configuration</b></p><div class="example-contents"><pre class="programlisting">sourceCompatibility = 1.6
targetCompatibility = 1.6

springVersion = <span class="hl-string">"3.0.5.RELEASE"</span>
springDataGraphVersion = <span class="hl-string">"1.1.0"</span>
aspectjVersion = <span class="hl-string">"1.6.12.M1

apply from:'https://github.com/SpringSource/spring-data-graph/raw/master/build/
gradle/springdatagraph.gradle'

configurations {
    runtime
    testCompile
}
repositories {
    mavenCentral()
	mavenLocal()
	mavenRepo urls: "</span>http:<span class="hl-comment">//maven.springframework.org/release"</span>
}</pre></div></div><br class="example-break"><p>
            The actual springdatagraph.gradle is very simple just decorating the javac tasks with the iajc ant task.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2368"></a>19.2.&nbsp;Ant/Ivy configuration</h2></div></div></div><p>
            The supplied sample ant <a class="ulink" href="https://github.com/SpringSource/spring-data-graph/raw/master/build/ivy" target="_top">build configuration</a> is mainly about resolving
            the dependencies for Spring Data Graph and AspectJ using Ivy and integrating the iajc ant task in the build.
        </p><div class="example"><a name="d0e2376"></a><p class="title"><b>Example&nbsp;19.2.&nbsp;Ant/Ivy Build Configuration</b></p><div class="example-contents"><pre class="programlisting">	&lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">resource</span>=<span class="hl-value">"org/aspectj/tools/ant/taskdefs/aspectjTaskdefs.properties"</span> <span class="hl-attribute">classpath</span>=<span class="hl-value">"${lib.dir}/aspectjtools.jar"</span>/&gt;

&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"compile"</span> <span class="hl-attribute">description</span>=<span class="hl-value">"Compile production classes"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"lib.retrieve"</span>&gt;
	&lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"${main.target}"</span> /&gt;

	&lt;<span class="hl-tag">iajc</span> <span class="hl-attribute">sourceroots</span>=<span class="hl-value">"${main.src}"</span> <span class="hl-attribute">destDir</span>=<span class="hl-value">"${main.target}"</span> <span class="hl-attribute">classpathref</span>=<span class="hl-value">"path.libs"</span> <span class="hl-attribute">source</span>=<span class="hl-value">"1.6"</span>&gt;
		&lt;<span class="hl-tag">aspectpath</span>&gt;
			&lt;<span class="hl-tag">pathelement</span> <span class="hl-attribute">location</span>=<span class="hl-value">"${lib.dir}/spring-aspects.jar"</span>/&gt;
		&lt;<span class="hl-tag">/aspectpath</span>&gt;
		&lt;<span class="hl-tag">aspectpath</span>&gt;
			&lt;<span class="hl-tag">pathelement</span> <span class="hl-attribute">location</span>=<span class="hl-value">"${lib.dir}/spring-data-neo4j.jar"</span>/&gt;
		&lt;<span class="hl-tag">/aspectpath</span>&gt;
	&lt;<span class="hl-tag">/iajc</span>&gt;
&lt;<span class="hl-tag">/target</span>&gt;</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2381"></a>19.3.&nbsp;Maven configuration</h2></div></div></div><p>
			Spring Data Graph projects are easiest to build with Apache Maven. The main dependencies are: Spring
            Data Graph itself, Spring Data Commons, parts of the Spring Framework, and the Neo4j graph database.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2386"></a>19.3.1.&nbsp;Repositories</h3></div></div></div><p>
                The milestone releases of Spring Data Graph are available from the dedicated milestone
                repository. Neo4j releases and milestones are available from Maven Central.
            </p><div class="example"><a name="d0e2391"></a><p class="title"><b>Example&nbsp;19.3.&nbsp;Spring milestone repository</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">repository</span>&gt;
    &lt;<span class="hl-tag">id</span>&gt;spring-maven-milestone&lt;<span class="hl-tag">/id</span>&gt;
    &lt;<span class="hl-tag">name</span>&gt;Springframework Maven Repository&lt;<span class="hl-tag">/name</span>&gt;
    &lt;<span class="hl-tag">url</span>&gt;http://maven.springframework.org/milestone&lt;<span class="hl-tag">/url</span>&gt;
&lt;<span class="hl-tag">/repository</span>&gt;
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2396"></a>19.3.2.&nbsp;Dependencies</h3></div></div></div><p>
                The dependency on <code class="code">spring-data-neo4j</code> will transitively pull in the necessary parts of
                Spring Framework (core, context, aop, aspects, tx), Aspectj, Neo4j, and Spring Data Commons. If you
                already use these (or different versions of these) in your project, then include those dependencies
                on your own.
            </p><div class="example"><a name="d0e2404"></a><p class="title"><b>Example&nbsp;19.4.&nbsp;Maven dependencies</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.springframework.data&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;spring-data-neo4j&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;1.1.0&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;

&lt;<span class="hl-tag">dependency</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.aspectj&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;aspectjrt&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;1.6.12.M1&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2409"></a>19.3.3.&nbsp;AspectJ build configuration</h3></div></div></div><p>
                Since Spring Data Graph uses AspectJ for build-time aspect weaving of entities, it is necessary to
                hook in the AspectJ Maven plugin to the build process. The plugin also has its own dependencies. You
                also need to explicitly specify the aspect libraries (spring-aspects and spring-data-neo4j).
            </p><div class="example"><a name="d0e2414"></a><p class="title"><b>Example&nbsp;19.5.&nbsp;AspectJ configuration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">plugin</span>&gt;
    &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
    &lt;<span class="hl-tag">artifactId</span>&gt;aspectj-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
    &lt;<span class="hl-tag">version</span>&gt;1.0&lt;<span class="hl-tag">/version</span>&gt;
    &lt;<span class="hl-tag">dependencies</span>&gt;
        &lt;<span class="hl-comment">!-- NB: You must use Maven 2.0.9 or above or these are ignored (see MNG-2972) --</span>&gt;
        &lt;<span class="hl-tag">dependency</span>&gt;
            &lt;<span class="hl-tag">groupId</span>&gt;org.aspectj&lt;<span class="hl-tag">/groupId</span>&gt;
            &lt;<span class="hl-tag">artifactId</span>&gt;aspectjrt&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">version</span>&gt;1.6.12.M1&lt;<span class="hl-tag">/version</span>&gt;
        &lt;<span class="hl-tag">/dependency</span>&gt;
        &lt;<span class="hl-tag">dependency</span>&gt;
            &lt;<span class="hl-tag">groupId</span>&gt;org.aspectj&lt;<span class="hl-tag">/groupId</span>&gt;
            &lt;<span class="hl-tag">artifactId</span>&gt;aspectjtools&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">version</span>&gt;1.6.12.M1&lt;<span class="hl-tag">/version</span>&gt;
        &lt;<span class="hl-tag">/dependency</span>&gt;
    &lt;<span class="hl-tag">/dependencies</span>&gt;
    &lt;<span class="hl-tag">executions</span>&gt;
        &lt;<span class="hl-tag">execution</span>&gt;
            &lt;<span class="hl-tag">goals</span>&gt;
                &lt;<span class="hl-tag">goal</span>&gt;compile&lt;<span class="hl-tag">/goal</span>&gt;
                &lt;<span class="hl-tag">goal</span>&gt;test-compile&lt;<span class="hl-tag">/goal</span>&gt;
            &lt;<span class="hl-tag">/goals</span>&gt;
        &lt;<span class="hl-tag">/execution</span>&gt;
    &lt;<span class="hl-tag">/executions</span>&gt;
    &lt;<span class="hl-tag">configuration</span>&gt;
        &lt;<span class="hl-tag">outxml</span>&gt;true&lt;<span class="hl-tag">/outxml</span>&gt;
        &lt;<span class="hl-tag">aspectLibraries</span>&gt;
            &lt;<span class="hl-tag">aspectLibrary</span>&gt;
                &lt;<span class="hl-tag">groupId</span>&gt;org.springframework&lt;<span class="hl-tag">/groupId</span>&gt;
                &lt;<span class="hl-tag">artifactId</span>&gt;spring-aspects&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">/aspectLibrary</span>&gt;
            &lt;<span class="hl-tag">aspectLibrary</span>&gt;
                &lt;<span class="hl-tag">groupId</span>&gt;org.springframework.data&lt;<span class="hl-tag">/groupId</span>&gt;
                &lt;<span class="hl-tag">artifactId</span>&gt;spring-datastore-neo4j&lt;<span class="hl-tag">/artifactId</span>&gt;
            &lt;<span class="hl-tag">/aspectLibrary</span>&gt;
        &lt;<span class="hl-tag">/aspectLibraries</span>&gt;
        &lt;<span class="hl-tag">source</span>&gt;1.6&lt;<span class="hl-tag">/source</span>&gt;
        &lt;<span class="hl-tag">target</span>&gt;1.6&lt;<span class="hl-tag">/target</span>&gt;
    &lt;<span class="hl-tag">/configuration</span>&gt;
&lt;<span class="hl-tag">/plugin</span>&gt;
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2419"></a>19.4.&nbsp;Spring configuration</h2></div></div></div><p>
            Users of Spring Data Graph have two ways of very concisely configuring it. Either they can use a
            Spring Data Graph XML configuration namespace, or they can use a Java-based bean configuration.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2424"></a>19.4.1.&nbsp;XML namespace</h3></div></div></div><p>
                The XML namespace can be used to configure Spring Data Graph. The <code class="code">config</code> element
                provides an XML-based configuration of Spring Data Graph in one line. It has three attributes.
                <code class="code">graphDatabaseService</code> points out the Neo4j instance to use. For convenience,
                <code class="code">storeDirectory</code> can be set instead of <code class="code">graphDatabaseService</code> to
                point to a directory where a new <code class="code">EmbeddedGraphDatabase</code> will be created. For
                cross-store configuration, the <code class="code">entityManagerFactory</code> attribute needs to be
                configured.
            </p><div class="example"><a name="d0e2447"></a><p class="title"><b>Example&nbsp;19.6.&nbsp;XML configuration with store directory</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8" standalone="yes"?</span>&gt;
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
        <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
        <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
        <span class="hl-attribute">xmlns:datagraph</span>=<span class="hl-value">"http://www.springframework.org/schema/data/graph"</span>
        <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context-3.0.xsd
            http://www.springframework.org/schema/data/graph
            http://www.springframework.org/schema/data/graph/datagraph-1.0.xsd"</span>&gt;

    &lt;<span class="hl-tag">context:annotation-config</span>/&gt;
    &lt;<span class="hl-tag">datagraph:config</span> <span class="hl-attribute">storeDirectory</span>=<span class="hl-value">"target/config-test"</span>/&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
</pre></div></div><br class="example-break"><div class="example"><a name="d0e2452"></a><p class="title"><b>Example&nbsp;19.7.&nbsp;XML configuration with bean</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">context:annotation-config</span>/&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"graphDatabaseService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.kernel.EmbeddedGraphDatabase"</span>
        <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"shutdown"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"target/config-test"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">datagraph:config</span> <span class="hl-attribute">graphDatabaseService</span>=<span class="hl-value">"graphDatabaseService"</span>/&gt;
</pre></div></div><br class="example-break"><div class="example"><a name="d0e2457"></a><p class="title"><b>Example&nbsp;19.8.&nbsp;XML configuration with cross-store</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">context:annotation-config</span>/&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span>
        <span class="hl-attribute">id</span>=<span class="hl-value">"entityManagerFactory"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceXmlLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:META-INF/persistence.xml"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">datagraph:config</span> <span class="hl-attribute">storeDirectory</span>=<span class="hl-value">"target/config-test"</span>
        <span class="hl-attribute">entityManagerFactory</span>=<span class="hl-value">"entityManagerFactory"</span>/&gt;
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2462"></a>19.4.2.&nbsp;Java-based bean configuration</h3></div></div></div><p>
                You can also configure Spring Data Graph using Java-based bean metadata.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    For those not familiar with Java-based bean metadata in Spring, we recommend that you
                    read up on it first. The Spring documentation has a
                    <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/new-in-3.html#new-java-configuration" target="_top">high-level introduction</a>
                    as well as
                    <a class="ulink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-java-instantiating-container" target="_top">detailed documentation</a>
                    on it.
                </p></div><p>
                In order to configure Spring Data Graph with Java-based bean metadata, the class
                <code class="code">Neo4jConfiguration</code> is registered with the context. This is either done
                explicitly in the context configuration, or via classpath scanning for classes that
                have the @Configuration annotation. The only thing that must be provided is the
                <code class="code">GraphDatabaseService</code>.  The example below shows how to register the
                <code class="code">@Configuration Neo4jConfiguration</code> class, as well as Spring's
                <code class="code">ConfigurationClassPostProcessor</code> that transforms the
                <code class="code">@Configuration</code> class to bean definitions.
                </p><div class="example"><a name="d0e2493"></a><p class="title"><b>Example&nbsp;19.9.&nbsp;Java-based bean configuration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">![CDATA[&lt;beans</span> <span class="hl-attribute">...&gt;</span>
    <span class="hl-attribute">...</span>
    <span class="hl-attribute">&lt;tx:annotation-driven</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"aspectj"</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span>/&gt;
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.neo4j.config.Neo4jConfiguration"</span>/&gt;

    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.context.annotation.ConfigurationClassPostProcessor"</span>/&gt;

    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"graphDatabaseService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.neo4j.kernel.EmbeddedGraphDatabase"</span>
          <span class="hl-attribute">destroy-method</span>=<span class="hl-value">"shutdown"</span> <span class="hl-attribute">scope</span>=<span class="hl-value">"singleton"</span>&gt;
        &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"target/config-test"</span>/&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
    ...
&lt;<span class="hl-tag">/beans</span>&gt;
</pre></div></div><p><br class="example-break">

            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:cross-store"></a>Chapter&nbsp;20.&nbsp;Cross-store persistence</h2></div></div></div><p>
        The Spring Data Graph project support cross-store persistence, which allows for parts of the data to be
        stored in a traditional JPA data store (RDBMS), and other parts in a graph store. This means that an entity
        can be partially stored in e.g. MySQL, and partially stored in Neo4j.
    </p><p>
        This allows existing JPA-based applications to embrace NOSQL data stores for evolving certain parts
        of their data model. Possible use cases include adding social networking or geospatial information to
        existing applications.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2506"></a>20.1.&nbsp;Partial entities</h2></div></div></div><p>
            Partial graph persistence is achieved by restricting the Spring Data Graph aspects to manage only
            explicitly annotated parts of the entity. Those fields will be made <code class="code">@Transient</code> by the
            aspect so that JPA ignores them.
        </p><p>
            A backing node in the graph store is only created when the entity has been assigned a JPA ID. Only
            then will the association between the two stores be established. Until the entity has been persisted,
            its state is just kept inside the POJO (in detached state), and then flushed to the backing graph
            database on <code class="code">persist()</code>.
        </p><p>
            The association between the two entities is maintained via a FOREIGN_ID field in the node, that
            contains the JPA ID. Currently only single-value IDs are supported. The entity class can be resolved
            via the <code class="code">TypeRepresentationStrategy</code> that manages the Java type hierarchy within the graph
            database. Given the ID and class, you can then retrieve the appropriate JPA entity for a given node.
        </p><p>
            The other direction is handled by indexing the Node with the FOREIGN_ID index which contains a
            concatenation of the fully qualified class name of the JPA entity and the ID. The matching node
            can then be found using the indexing facilities, and the two entities can be reassociated.
        </p><p>
            Using these mechanisms and the Spring Data Graph aspects, a single POJO can contain some fields
            handled by JPA and others handles by Spring Data Graph. This also includes relationship fields persisted
            in the graph database.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2528"></a>20.2.&nbsp;Cross-store annotations</h2></div></div></div><p>
            Cross-store persistence only requires the use of one additional annotation: <code class="code">@GraphProperty</code>.
            See below for details and an example.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2536"></a>20.2.1.&nbsp;@NodeEntity(partial = "true")</h3></div></div></div><p>
                When annotating an entity with <code class="code">partial = true</code>, this marks it as a cross-store entity.
                Spring Data Graph will thus only manage fields explicitly annotated with <code class="code">@GraphProperty</code>.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2547"></a>20.2.2.&nbsp;@GraphProperty</h3></div></div></div><p>
                Fields of primitive or convertible types do not normally have to be annotated in order to be
                persisted by Spring Data Graph. In cross-store mode, Spring Data Graph <span class="emphasis"><em>only</em></span>
                persists fields explicitly annotated with <code class="code">@GraphProperty</code>. JPA will ignore these fields.
            </p></div><p>
            The following example is taken from the
            <a class="ulink" href="http://github.com/SpringSource/spring-data-graph-examples" target="_top">Spring Data Graph examples</a>
            myrestaurants-social project:
        </p><div class="example"><a name="d0e2563"></a><p class="title"><b>Example&nbsp;20.1.&nbsp;Cross-store node entity</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Table(name = <span class="hl-string">"user_account"</span>)
@NodeEntity(partial = true)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> UserAccount {
    <span class="hl-keyword">private</span> String userName;
    <span class="hl-keyword">private</span> String firstName;
    <span class="hl-keyword">private</span> String lastName;

    @GraphProperty
    String nickname;

    @RelatedTo
    Set&lt;UserAccount&gt; friends;

    @RelatedToVia(type = <span class="hl-string">"recommends"</span>)
    Iterable&lt;Recommendation&gt; recommendations;

    @Temporal(TemporalType.TIMESTAMP)
    @DateTimeFormat(style = <span class="hl-string">"S-"</span>)
    <span class="hl-keyword">private</span> Date birthDate;

    @ManyToMany(cascade = CascadeType.ALL)
    <span class="hl-keyword">private</span> Set&lt;Restaurant&gt; favorites;

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = <span class="hl-string">"id"</span>)
    <span class="hl-keyword">private</span> Long id;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> knows(UserAccount friend) {
        relateTo(friend, <span class="hl-string">"friends"</span>);
    }

    <span class="hl-keyword">public</span> Recommendation rate(Restaurant restaurant, <span class="hl-keyword">int</span> stars, String comment) {
        Recommendation recommendation = relateTo(restaurant, Recommendation.<span class="hl-keyword">class</span>, <span class="hl-string">"recommends"</span>);
        recommendation.rate(stars, comment);
        <span class="hl-keyword">return</span> recommendation;
    }

    <span class="hl-keyword">public</span> Iterable&lt;Recommendation&gt; getRecommendations() {
        <span class="hl-keyword">return</span> recommendations;
    }
}
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2568"></a>20.3.&nbsp;Configuring cross-store persistence</h2></div></div></div><p>
            Configuring cross-store persistence is done similarly to the default Spring Data Graph configuration.
            All you need to do is to specify an <code class="code">entityManagerFactory</code> in the XML namespace
            <code class="code">config</code> element, and Spring Data Graph will configure itself for cross-store use.
        </p><div class="example"><a name="d0e2579"></a><p class="title"><b>Example&nbsp;20.2.&nbsp;Cross-store Spring configuration</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">"http://www.springframework.org/schema/context"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:datagraph</span>=<span class="hl-value">"http://www.springframework.org/schema/data/graph"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/data/graph
        http://www.springframework.org/schema/data/graph/datagraph-1.0.xsd
        "</span>&gt;

    &lt;<span class="hl-tag">context:annotation-config</span>/&gt;

    &lt;<span class="hl-tag">datagraph:config</span> <span class="hl-attribute">storeDirectory</span>=<span class="hl-value">"target/config-test"</span>
        <span class="hl-attribute">entityManagerFactory</span>=<span class="hl-value">"entityManagerFactory"</span>/&gt;

    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span>
            <span class="hl-attribute">id</span>=<span class="hl-value">"entityManagerFactory"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span>/&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"persistenceXmlLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:META-INF/persistence.xml"</span>/&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
&lt;<span class="hl-tag">/beans</span>&gt;
</pre></div></div><br class="example-break"></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:samples"></a>Chapter&nbsp;21.&nbsp;Sample code</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples:introduction"></a>21.1.&nbsp;Introduction</h2></div></div></div><p>
            Spring Data Graph comes with a number of sample applications. The source code of the samples can be found on
            <a class="ulink" href="http://github.com/SpringSource/spring-data-graph-examples" target="_top">Github</a>. The different sample
            projects are introduced below.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples:hello-worlds"></a>21.2.&nbsp;Hello Worlds sample application</h2></div></div></div><p>
            The Hello Worlds sample application is a simple console application. It creates some worlds
            (node entities) and rocket routes (relationships) between worlds, all in a galaxy (the graph),
            and then prints them.
        </p><p>
            The unit tests demonstrate some other features of Spring Data Graph as well. The sample comes
            with a minimal configuration for Maven and Spring to get up and running quickly.
        </p><p>
            Executing the application creates the following graph in the graph database:
        </p><div class="mediaobject"><img src="helloworlds.png" width="531.496062992126"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples:imdb"></a>21.3.&nbsp;IMDB sample application</h2></div></div></div><p>
            The IMDB sample is a web application that imports datasets from the Internet Movie Database (IMDB)
            into the graph database. It allows the listing of movies with their actors, and of actors and their
            roles in different movies. It also uses graph traversal operations to calculate the
            <a class="ulink" href="http://en.wikipedia.org/wiki/Bacon_number" target="_top">Bacon number</a> of any given actor.
            This sample application shows the usage of Spring Data Graph in a more complex setting, using several
            annotated entities and relationships as well as indexes and graph traversals.
        </p><p>
            See the readme file for instructions on how to compile and run the application.
        </p><p>
            An excerpt of the data stored in the graph database after executing the application:
        </p><p>
            </p><div class="screenshot"><div class="mediaobject"><img src="imdb.png" width="531.496062992126"></div></div><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples:myrestaurants-original"></a>21.4.&nbsp;MyRestaurants sample application</h2></div></div></div><p>
            Simple, JPA-based web application for managing users and restaurants, with the ability to add
            restaurants as favorites to a user. It is basically the foundation for the MyRestaurants-Social
            application (see<a class="xref" href="#samples:myrestaurants-social" title="21.5.&nbsp;MyRestaurant-Social sample application">Section&nbsp;21.5, &#8220;MyRestaurant-Social sample application&#8221;</a>), and does therefore not use
            Spring Data Graph.
        </p><div class="mediaobject"><img src="restaurant.png" width="531.496062992126"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples:myrestaurants-social"></a>21.5.&nbsp;MyRestaurant-Social sample application</h2></div></div></div><p>
            This application extends the MyRestaurants sample application, adding social networking
            functionality to it with cross-store persistence. The web application allows for users to add
            friends and rate restaurants. A graph traversal provides recommendations based on your friends'
            (and their friends') rating of restaurants.
        </p><p>
            Here's an excerpt of the data stored in the graph database after executing the application:
        </p><div class="mediaobject"><img src="restaurant-social.png" width="531.496062992126"></div><div class="mediaobject"><img src="restaurant-social-graph.png" width="531.496062992126"></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:performance"></a>Chapter&nbsp;22.&nbsp;Performance considerations</h2></div></div></div><p>
        Although adding layers of abstraction is a common pattern in software development, each of these layers
        generally adds overhead and performance penalties. This chapter discusses the performance implications
        of using Spring Data Graph instead of the Neo4j API directly.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2654"></a>22.1.&nbsp;When is Spring Data Graph right</h2></div></div></div><p>
            The focus of Spring Data Graph is to add a convenience layer on top of the Neo4j API. This enables
            developers to get up and running with a graph database very quickly, having their domain objects
            mapped to the graph with very little work. Building on this foundation, one can later explore other,
            more efficient ways to explore and process the graph - if the performance requirements demand it.
        </p><p>
            Like any other object mapping framework, the domain entities that are created, read, or persisted
            represent only a small fraction of the data stored in the database. This is the set needed for a
            certain use-case to be displayed, edited or processed in a low throughput fashion. The main advantages
            of using an object mapper in this case are the ease of use of real domain objects in your business
            logic and also with existing
            frameworks and libraries that expect Java POJOs as input or create them as results.
        </p><p>
            Spring Data Graph, however, was not designed with a major focus on performance. It does add some overhead
            to pure graph operations. Something to keep in mind is that any access of properties and relationships
            will in general read through down to the database. To avoid multiple reads, it is sensible to store the
            result in a local variable in suitable scope (e.g. method, class or jsp).
        </p><p>
            Most of the overhead comes from the use of the Java Reflection API, which is used to provide
            information about annotations, fields and constructors. Some of the information is already cached
            by the JVM and the library, so that only the first access gets a performance penalty.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:template"></a>Chapter&nbsp;23.&nbsp;Neo4jTemplate</h2></div></div></div><p>
        The <code class="code">Neo4jTemplate</code> offers the convenient API of Spring templates for the Neo4j graph
        database.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2673"></a>23.1.&nbsp;Basic operations</h2></div></div></div><p>
            For direct retrieval of nodes and relationships, the <code class="code">getReferenceNode()</code>,
            <code class="code">getNode()</code> and <code class="code">getRelationship()</code> methods can be used.
        </p><p>
            There are methods (<code class="code">createNode()</code> and <code class="code">createRelationship()</code>) for creating nodes and
            relationships that automatically set provided properties.
        </p><div class="example"><a name="d0e2695"></a><p class="title"><b>Example&nbsp;23.1.&nbsp;Neo4j template</b></p><div class="example-contents"><pre class="programlisting">&lt;![CDATA[<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.neo4j.helpers.collection.MapUtil.map;

Neo4jOperations neo = <span class="hl-keyword">new</span> Neo4jTemplate(graphDatabaseService);

Node michael = neo.createNode(map(<span class="hl-string">"name"</span>,<span class="hl-string">"Michael"</span>));
Node mark = neo.createNode(map(<span class="hl-string">"name"</span>,<span class="hl-string">"Mark"</span>));
Node thomas = neo.createNode(map(<span class="hl-string">"name"</span>,<span class="hl-string">"Thomas"</span>));

neo.createRelationship(mark,thomas, WORKS_WITH, map(<span class="hl-string">"project"</span>,<span class="hl-string">"spring-data"</span>));

neo.index(<span class="hl-string">"devs"</span>,thomas, <span class="hl-string">"name"</span>,<span class="hl-string">"Thomas"</span>);

<span class="hl-comment">// Cypher</span>
assert <span class="hl-string">"Mark"</span>.equals(neo.query(<span class="hl-string">"start p=(%person) match p&lt;-[:WORKS_WITH]-other return other.name"</span>,
    map(<span class="hl-string">"person"</span>,thomas)).to(String.<span class="hl-keyword">class</span>).single());

<span class="hl-comment">// Gremlin</span>
assert thomas.equals(neo.execute(<span class="hl-string">"g.v(person).out('WORKS_WITH')"</span>,
    map(<span class="hl-string">"person"</span>,mark)).to(Node.<span class="hl-keyword">class</span>).single());

<span class="hl-comment">// Index lookup</span>
assert mark.equals(neo.lookup(<span class="hl-string">"devs"</span>,<span class="hl-string">"name"</span>,<span class="hl-string">"Mark"</span>).single());

<span class="hl-comment">// Index lookup with Result Converter</span>
assert <span class="hl-string">"Mark"</span>.equals(neo.lookup(<span class="hl-string">"devs"</span>,<span class="hl-string">"name"</span>,<span class="hl-string">"Mark"</span>).to(String.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> ResultConverter&lt;PropertyContainer, String&gt; {
        <span class="hl-keyword">public</span> String convert(PropertyContainer element, Class&lt;String&gt; type) {
            <span class="hl-keyword">return</span> (String) element.getProperty(<span class="hl-string">"name"</span>);
        }}));</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2700"></a>23.2.&nbsp;QueryResult</h2></div></div></div><p>
            All querying methods of the template return a uniform result type: <code class="code">QueryResult&lt;T&gt;</code>
            which is also an <code class="code">Iterable&lt;T&gt;</code>. The query result offers methods of converting each
            element to a target type <code class="code">queryResult.to(Type.class)</code> optionally supplying a
            <code class="code">ResultConverter&lt;FROM,TO&gt;</code> which takes care of custom conversions. By default most
            query methods can already handle conversions from and to: Paths, Nodes, Relationship and GraphEntities
            as well as conversions backed by registered ConversionServices. A converted <code class="code">QueryResult&lt;FROM&gt;</code> is an
            <code class="code">Iterable&lt;TO&gt;</code>. QueryResults can be limited to a single value using the <code class="code">queryResult.single()</code>
            method. It also offers support for a pure callback function using a <code class="code">Handler&lt;T&gt;</code>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2729"></a>23.3.&nbsp;Indexing</h2></div></div></div><p>
            Adding nodes and relationships to an index is done with the <code class="code">index()</code> method.
        </p><p>
            The <code class="code">lookup()</code> methods either take a field/value combination to look for exact matches in the
            index, or a Lucene query object or string to handle more complex queries. All <code class="code">lookup()</code>
            methods return a <code class="code">QueryResult&lt;PropertyContainer&gt;</code> to be used or transformed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2748"></a>23.4.&nbsp;Graph traversal</h2></div></div></div><p>
            The traversal methods are at the core of graph operations.
            The <code class="code">traverse()</code> method covers the full traversal operation that takes a
            <code class="code">TraversalDescription</code> (typically built with the <code class="code">Traversal.description()</code>
            DSL) and runs it from the given start node. <code class="code">traverse</code> returns a <code class="code">QueryResult&lt;Path&gt;</code>
            to be used or transformed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2768"></a>23.5.&nbsp;Cypher Queries</h2></div></div></div><p>
            The <code class="code">Neo4jTemplate</code> also allows execution of arbitrary Cypher queries. Via the <code class="code">query</code>
            methods the statement and parameter-Map are provided. Cypher Queries return tabular results, so the
            <code class="code">QueryResult&lt;Map&lt;String,Object&gt;&gt;</code> contains the rows which can be either used as they are
            or converted as needed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2782"></a>23.6.&nbsp;Gremlin Scripts</h2></div></div></div><p>
            Gremlin Scripts can run with the <code class="code">execute</code> method, which also takes the parameters that will be
            available as variables inside the script. The result of the executions is a generic
            <code class="code">QueryResult&lt;Object&gt;</code> fit for conversion or usage.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2793"></a>23.7.&nbsp;Transactions</h2></div></div></div><p>
            The <code class="code">Neo4jTemplate</code> provides configurable implicit transactions for all its methods. By
            default it creates a transaction for each call (which is a no-op if there is already a transaction
            running). If you call the constructor with the <code class="code">useExplicitTransactions</code> parameter set to
            true, it won't create any transactions so you have to provide them using <code class="code">@Transactional</code>
            or the <code class="code">TransactionTemplate</code>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2810"></a>23.8.&nbsp;Neo4j REST Server</h2></div></div></div><p>If the template is configured to use a <code class="code">RestGraphDatabase</code> the expensive operations
        like traversals and querying are executed efficiently on the server side by using the REST API to forward
        those calls. All the other template methods require single network operations.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:aspectj-details"></a>Chapter&nbsp;24.&nbsp;AspectJ details</h2></div></div></div><p>
        The object graph mapper of Spring Data Graph relies heavily on AspectJ. AspectJ is a Java implementation
        of the <a class="ulink" href="https://secure.wikimedia.org/wikipedia/en/wiki/Aspect-oriented_programming" target="_top">aspect-oriented
        programming</a> paradigm that allows easy extraction and controlled application of so-called
        cross-cutting concerns. Cross-cutting concerns are typically repetitive tasks in a system (e.g. logging,
        security, auditing, caching, transaction scoping) that are difficult to extract using the normal OO
        paradigms. Many OO concepts, such as subclassing, polymorphism, overriding and delegation are still
        cumbersome to use with many of those concerns applied in the code base. Also, the flexibility becomes
        limited, potentially adding quite a number of configuration options or parameters.
    </p><p>
        The AspectJ pointcut language can be intimidating, but a developer using Spring Data Graph will not have
        to deal with that. Users don't have care about to hooking into a framework mechanism, or having to extend
        a framework superclass.
    </p><p>
        AspectJ uses a declarative approach, defining concrete advice, which is just pieces of code that contain
        the implementation of the concern. AspectJ advice can for instance be applied before, after, or instead
        of a method or constructor call. It can also be applied on variable and field access. This is declared
        using AspectJ's expressive pointcut language, able to express any place within a code structure or flow.
        AspectJ is also able to introduce new methods, fields, annotations, interfaces, and superclasses to
        existing classes.
    </p><p>
        Spring Data Graph uses a mix of these mechanisms internally. First, when encountering the
        <code class="code">@NodeEntity</code> or <code class="code">@RelationshipEntity</code> annotations it introduces a new interface
        <code class="code">NodeBacked</code> or <code class="code">RelationshipBacked</code> to the annotated class. Secondly, it introduces
        fields and methods to the annotated class. See <a class="xref" href="#reference:programming-model:introduced-methods" title="18.4.&nbsp;Introduced methods">Section&nbsp;18.4, &#8220;Introduced methods&#8221;</a>
        for more information on the methods introduced.
    </p><p>
        Spring Data Graph also leverages AspectJ to intercept access to fields, delegating the calls to the graph
        database instead. Under the hood, properties and relationships will be created.
    </p><p>
        So how is an aspect applied to a concrete class? At compile time, the AspectJ Java compiler (ajc) takes
        source files and aspect definitions, and compiles the source files while adding all the necessary
        interception code for the aspects to hook in where they're declared to. This is known as compile-time
        <span class="emphasis"><em>weaving</em></span>. At runtime only a small AspectJ runtime is needed, as the byte code of the
        classes has already been rewritten to delegate the appropriate calls via the declared advice in the aspects.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            A caveat of using compile-time weaving is that all source files that should be part of the weaving
            process must be compiled with the AspectJ compiler. Fortunately, this is all taken care of seamlessly
            by the AspectJ Maven plugin.
        </p></div><p>
        AspectJ also supports other types of weaving, e.g. load-time weaving and runtime weaving. These are
        currently not supported by Spring Data Graph.
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="reference:neo4j-server"></a>Chapter&nbsp;25.&nbsp;Neo4j Server</h2></div></div></div><p>
        Neo4j is not only available in embedded mode. It can also be installed and run as a stand-alone server
        accessible via a REST API. Developers can integrate Spring Data Graph into the Neo4j server infrastructure
        in two ways: in an unmanaged server extension, or via the REST API.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2863"></a>25.1.&nbsp;Server Extension</h2></div></div></div><p>
            When should you write a server extension? The default REST API is essentially a REST'ified representation
            of the Neo4j core API. It is nice for getting started, and for simpler scenarios. For more involved
            solutions that require high-volume access or more complex operations, writing a server extension that
            is able to process external parameters, do all the computations locally in the plugin, and then return
            just the relevant information to the calling client is preferable.
        </p><p>
            The Neo4j Server has two built-in extension mechanisms. It is possible to extend existing URI endpoints
            like the graph database, nodes, or relationships, adding new URIs or methods to those. This is achieved
            by writing a <a class="ulink" href="http://docs.neo4j.org/chunked/milestone/server-plugins.html" target="_top">server plugin</a>.
            This plugin type has some restrictions though.
        </p><p>
            For complete freedom in the implementation, an
            <a class="ulink" href="http://docs.neo4j.org/chunked/milestone/server-unmanaged-extensions.html" target="_top">unmanaged extension</a>
            can be used. Unmanaged extensions are essentially <a class="ulink" href="http://jersey.java.net/" target="_top">Jersey</a>
            resource implementations. The resource constructors or methods can get the
            <code class="code">GraphDatabaseService</code> injected to execute the necessary operations and return appropriate
            <code class="code">Representations</code>.
        </p><p>
            Both kinds of extensions have to be packaged as JAR files and added to the Neo4j Server's plugin
            directory. Server Plugins are picked up by the server at startup if they provide the necessary
            <code class="code">META-INF.services/org.neo4j.server.plugins.ServerPlugin</code> file for Java's ServiceLoader
            facility. Unmanaged extensions have to be registered with the Neo4j Server configuration.
        </p><div class="example"><a name="d0e2892"></a><p class="title"><b>Example&nbsp;25.1.&nbsp;Configuring an unmanaged extension</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">org.neo4j.server.thirdparty_jaxrs_classes=com.example.mypackage=</span>/my-context</pre></div></div><br class="example-break"><p>
            Running Spring Data Graph on the Neo4j Server is easy. You need to tell the server where to find the
            Spring context configuration file, and which beans from it to expose:
            </p><div class="example"><a name="d0e2899"></a><p class="title"><b>Example&nbsp;25.2.&nbsp;Server plugin initialization</b></p><div class="example-contents"><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HelloWorldInitializer <span class="hl-keyword">extends</span> SpringPluginInitializer {
    <span class="hl-keyword">public</span> HelloWorldInitializer() {
        <span class="hl-keyword">super</span>(<span class="hl-keyword">new</span> String[]{<span class="hl-string">"spring/helloWorldServer-Context.xml"</span>},
              Pair.of(<span class="hl-string">"worldRepository"</span>, WorldRepository.<span class="hl-keyword">class</span>),
              Pair.of(<span class="hl-string">"graphRepositoryFactory"</span>, GraphRepositoryFactory.<span class="hl-keyword">class</span>));
    }
}
</pre></div></div><p><br class="example-break">

            Now, your resources can require the spring-beans they need, annotated with <code class="code">@Context</code> like this:
            </p><div class="example"><a name="d0e2908"></a><p class="title"><b>Example&nbsp;25.3.&nbsp;Jersey resource</b></p><div class="example-contents"><pre class="programlisting">@Path( <span class="hl-string">"/path"</span> )
@POST
@Produces( MediaType.APPLICATION_JSON )
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> foo( @Context WorldRepository repo ) {
    ...
}
</pre></div></div><p><br class="example-break">
            The <code class="code">SpringPluginInitializer</code> merges the GraphDatabaseService with the Spring configuration
            and registers the named beans as Jersey <code class="code">Injectables</code>. It is still necessary to list the
            initializer's fully qualified class name in a file named
            <code class="code">META-INF/services/org.neo4j.server.plugins.PluginLifecycle</code>. The Neo4j Server can then pick
            up and run the initialization classes before the extensions are loaded.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2923"></a>25.2.&nbsp;Using Spring Data Graph as a REST client</h2></div></div></div><p>
            Spring Data Graph can use a set of Java REST bindings which come as a drop in replacement for the
            GraphDatabaseService API. By simply configuring the <code class="code">graphDatabaseService</code> to be a
            <code class="code">RestGraphDatabase</code> pointing to a Neo4j Server instance.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                The Neo4j Server REST API does not allow for transactions to span across requests, which means
                that Spring Data Graph is not transactional when running with a <code class="code">RestGraphDatabase</code>.
            </p></div><p>
            Please also keep in mind that performing graph operations via the REST-API is about one order of
            magnitude slower than location operations. Try to use the Neo4j Cypher query language,
            server-side traversals (<code class="code">RestTraversal</code>) or Gremlin expressions whenever possible for retrieving large sets of data.
            Future versions of Spring Data Graph will use the more performant batching as well as a binary protocol.
        </p><p>
        To set up your project to use the REST bindings, add this dependency to your pom.xml:
</p><div class="example"><a name="d0e2947"></a><p class="title"><b>Example&nbsp;25.4.&nbsp;REST-Client configuration - pom.xml</b></p><div class="example-contents"><pre class="programlisting">
&lt;<span class="hl-tag">dependency</span>&gt;
  &lt;<span class="hl-tag">groupId</span>&gt;org.springframework.data&lt;<span class="hl-tag">/groupId</span>&gt;
  &lt;<span class="hl-tag">artifactId</span>&gt;spring-data-neo4j-rest&lt;<span class="hl-tag">/artifactId</span>&gt;
  &lt;<span class="hl-tag">version</span>&gt;1.1.0&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
</pre></div></div><p><br class="example-break">
            Now, you set up the normal Spring Data Graph configuration, but point the database to an URL instead
            of a local directory, like so:
            </p><div class="example"><a name="d0e2953"></a><p class="title"><b>Example&nbsp;25.5.&nbsp;REST client configuration - application context</b></p><div class="example-contents"><pre class="programlisting">&lt;<span class="hl-tag">datagraph:config</span> <span class="hl-attribute">graphDatabaseService</span>=<span class="hl-value">"graphDatabaseService"</span>/&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"graphDatabaseService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.data.neo4j.rest.RestGraphDatabase"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"http://localhost:7474/db/data/"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
</pre></div></div><p><br class="example-break">
            Your project is now set up to work against a remote Neo4j Server.
        </p><p>
            The remote REST implementation works for both the Neo4jTemplate as well as the GraphEntities. For traversals
            and cypher-graph-queries it is sensible to forward those to the remote and execute them there instead of
            walking the graph over the wire. RestGraphDatabase already supports that by providing methods that forward
            to the remote instance. (e.g. <code class="code">queryEngineFor(), index() and createTraversalDescription()</code>).
            Please use those methods when interacting with a remote server for optimal performance.
        </p><p>

        </p></div></div></div></div></body></html>